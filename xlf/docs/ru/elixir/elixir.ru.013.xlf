<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="elixir">
    <body>
      <group id="elixir">
        <trans-unit id="3c2765b9061b4136a3838afbdd48ae286d5f9dd1" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;@impl&lt;/code&gt;, the example above can be rewritten as:</source>
          <target state="translated">Используя &lt;code&gt;@impl&lt;/code&gt; , приведенный выше пример можно переписать как:</target>
        </trans-unit>
        <trans-unit id="505fcdfd3ea4cc7dcdc28d67a1ee3972f771caf7" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;try/catch&lt;/code&gt; is already uncommon and using it to catch exits is even rarer.</source>
          <target state="translated">Использование &lt;code&gt;try/catch&lt;/code&gt; уже редко, а использование его для перехвата выходов еще реже.</target>
        </trans-unit>
        <trans-unit id="1030762105f9522e1c1851b1267235d4d19bc022" translate="yes" xml:space="preserve">
          <source>Using Erlang's term ordering means that comparisons are structural and not semantic. For example, when comparing dates:</source>
          <target state="translated">Использование термина &quot;упорядочение&quot; Эрланга означает,что сравнения структурированы,а не семантичны.Например,при сравнении дат:</target>
        </trans-unit>
        <trans-unit id="fe7cefcf1eabae7a686eac5a7a7290642e6eed61" translate="yes" xml:space="preserve">
          <source>Using Git repositories for internal dependencies is somewhat discouraged in Elixir. Remember that the runtime and the Elixir ecosystem already provide the concept of applications. As such, we expect you to frequently break your code into applications that can be organized logically, even within a single project.</source>
          <target state="translated">Использование Git-репозиториев для внутренних зависимостей в Elixir несколько обескураживает.Помните,что время выполнения и экосистема Elixir уже обеспечивают концепцию приложений.Поэтому мы ожидаем,что вы часто будете разбивать свой код на приложения,которые можно организовать логически,даже в рамках одного проекта.</target>
        </trans-unit>
        <trans-unit id="a2b78ec8cd8152714b3f5e9e262cc3fe32d34dd9" translate="yes" xml:space="preserve">
          <source>Using Processes and message passing</source>
          <target state="translated">Использование процессов и передача сообщений</target>
        </trans-unit>
        <trans-unit id="f3be89c545324883fd2361bb0486819210d9bb4f" translate="yes" xml:space="preserve">
          <source>Using a custom &lt;code&gt;sorter&lt;/code&gt; to override the order:</source>
          <target state="translated">Использование настраиваемого &lt;code&gt;sorter&lt;/code&gt; для переопределения порядка:</target>
        </trans-unit>
        <trans-unit id="bb2948a181ade01696e41af07bcf194a3237ab62" translate="yes" xml:space="preserve">
          <source>Using as a PubSub</source>
          <target state="translated">Использование в качестве PubSub</target>
        </trans-unit>
        <trans-unit id="12a48c5cdb39b5b708956e82103eb5aa1b37d5cf" translate="yes" xml:space="preserve">
          <source>Using as a dispatcher</source>
          <target state="translated">Использование в качестве диспетчера</target>
        </trans-unit>
        <trans-unit id="f68543ebad20919d4a9ab1b9e02fe49a33c14a13" translate="yes" xml:space="preserve">
          <source>Using epochs</source>
          <target state="translated">Используя эпохи</target>
        </trans-unit>
        <trans-unit id="22e72db3d5ad4dc09f439de5ffe89609c4f63667" translate="yes" xml:space="preserve">
          <source>Using functions from the &lt;code&gt;Path&lt;/code&gt; module as opposed to directly manipulating strings is preferred since the &lt;code&gt;Path&lt;/code&gt; module takes care of different operating systems transparently. Finally, keep in mind that Elixir will automatically convert slashes (&lt;code&gt;/&lt;/code&gt;) into backslashes (&lt;code&gt;\&lt;/code&gt;) on Windows when performing file operations.</source>
          <target state="translated">Использование функций из модуля &lt;code&gt;Path&lt;/code&gt; вместо прямого управления строками является предпочтительным, поскольку модуль &lt;code&gt;Path&lt;/code&gt; прозрачно заботится о различных операционных системах. Наконец, имейте в виду, что Elixir автоматически преобразует косую черту ( &lt;code&gt;/&lt;/code&gt; ) в обратную косую черту ( &lt;code&gt;\&lt;/code&gt; ) в Windows при выполнении файловых операций.</target>
        </trans-unit>
        <trans-unit id="6c5b3431f7bcd8e9adc5193d5b75b53a5ae56b11" translate="yes" xml:space="preserve">
          <source>Using in &lt;code&gt;:via&lt;/code&gt;</source>
          <target state="translated">Использование в &lt;code&gt;:via&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="22a7cc210dd530426a5dcf89d908dcdbccf3b54a" translate="yes" xml:space="preserve">
          <source>Using processes to maintain state and name registration are very common patterns in Elixir applications. However, most of the time, we won&amp;rsquo;t implement those patterns manually as above, but by using one of the many abstractions that ship with Elixir. For example, Elixir provides &lt;a href=&quot;https://hexdocs.pm/elixir/Agent.html&quot;&gt;agents&lt;/a&gt;, which are simple abstractions around state:</source>
          <target state="translated">Использование процессов для сохранения состояния и регистрации имени - очень распространенные шаблоны в приложениях Elixir. Однако в большинстве случаев мы не будем реализовывать эти шаблоны вручную, как указано выше, а будем использовать одну из многих абстракций, поставляемых с Elixir. Например, Elixir предоставляет &lt;a href=&quot;https://hexdocs.pm/elixir/Agent.html&quot;&gt;агентов&lt;/a&gt; , которые представляют собой простые абстракции состояния:</target>
        </trans-unit>
        <trans-unit id="fac68a7bbcec534d20e0f270b590c693f791a8ba" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;@deprecated&lt;/code&gt; attribute will also be reflected in the documentation of the given function and macro. You can choose between the &lt;code&gt;@deprecated&lt;/code&gt; attribute and the documentation metadata to provide hard-deprecations (with warnings) and soft-deprecations (without warnings):</source>
          <target state="translated">Использование атрибута &lt;code&gt;@deprecated&lt;/code&gt; также будет отражено в документации данной функции и макроса. Вы можете выбрать между атрибутом &lt;code&gt;@deprecated&lt;/code&gt; и метаданными документации, чтобы обеспечить отказ от рекомендаций (с предупреждениями) или отказ от рекомендаций (без предупреждений):</target>
        </trans-unit>
        <trans-unit id="c1fce9d06d100207ae94000178568e1e1523c465" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;unescape_map/1&lt;/code&gt; function defined above is easy:</source>
          <target state="translated">Использовать определенную выше функцию &lt;code&gt;unescape_map/1&lt;/code&gt; очень просто:</target>
        </trans-unit>
        <trans-unit id="70eb4c35b0fbbc17142c45a308c03f22806f9e80" translate="yes" xml:space="preserve">
          <source>Using the default &lt;code&gt;sorter&lt;/code&gt; of &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#%3C=/2&quot;&gt;&lt;code&gt;&amp;lt;=/2&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Используя &lt;code&gt;sorter&lt;/code&gt; по умолчанию &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#%3C=/2&quot;&gt; &lt;code&gt;&amp;lt;=/2&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="40f616c11b4612a788125178e432987022e94f9d" translate="yes" xml:space="preserve">
          <source>Using the default &lt;code&gt;sorter&lt;/code&gt; of &lt;a href=&quot;kernel#%253C=/2&quot;&gt;&lt;code&gt;&amp;lt;=/2&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Используя &lt;code&gt;sorter&lt;/code&gt; по умолчанию &lt;a href=&quot;kernel#%253C=/2&quot;&gt; &lt;code&gt;&amp;lt;=/2&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="9b47c1568d847c096ed268fe421b3ffdf9291333" translate="yes" xml:space="preserve">
          <source>Utilities for managing code compilation, code evaluation, and code loading.</source>
          <target state="translated">Утилиты для управления компиляцией,оценкой и загрузкой кода.</target>
        </trans-unit>
        <trans-unit id="a950d92c88a80326e3959073d9319dfdfe26f796" translate="yes" xml:space="preserve">
          <source>Utilities for working with URIs.</source>
          <target state="translated">Утилиты для работы с URI.</target>
        </trans-unit>
        <trans-unit id="c9ee5681d3c59f7541c27a38b67edf46259e187b" translate="yes" xml:space="preserve">
          <source>V</source>
          <target state="translated">V</target>
        </trans-unit>
        <trans-unit id="494e5398b739ace80c2800a4e5b3cd1fb68001cf" translate="yes" xml:space="preserve">
          <source>VM</source>
          <target state="translated">VM</target>
        </trans-unit>
        <trans-unit id="8cf63ad1e33ecf97ed7ba0e44ba1e1045768875c" translate="yes" xml:space="preserve">
          <source>Valid modifiers include only lower and upper case letters. Other characters will cause a syntax error.</source>
          <target state="translated">Действительные модификаторы включают только строчные и прописные буквы.Другие символы приведут к синтаксической ошибке.</target>
        </trans-unit>
        <trans-unit id="f81794f0623c259f7f2ad2720c7f65c25241d820" translate="yes" xml:space="preserve">
          <source>Valid values for each color are in the range 0 to 5.</source>
          <target state="translated">Допустимые значения для каждого цвета находятся в диапазоне от 0 до 5.</target>
        </trans-unit>
        <trans-unit id="9698cacbd5e3f89a0ab00436a91a3e87284fda79" translate="yes" xml:space="preserve">
          <source>Validates a &lt;a href=&quot;#t:config_path/0&quot;&gt;&lt;code&gt;config_path/0&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Проверяет &lt;a href=&quot;#t:config_path/0&quot;&gt; &lt;code&gt;config_path/0&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c51cf0a76585d587a0e8f7ab8de82724cd0922db" translate="yes" xml:space="preserve">
          <source>Validates the given expressions are valid quoted expressions.</source>
          <target state="translated">Проверяет,что данные выражения являются действительными выражениями,заключенными в кавычки.</target>
        </trans-unit>
        <trans-unit id="8dce170de238b1feda2ecd9674ea3ca0d068fbcb" translate="yes" xml:space="preserve">
          <source>Value</source>
          <target state="translated">Value</target>
        </trans-unit>
        <trans-unit id="56dcc0a7cf262d906a67fb0acd7bd55c0b2e0af5" translate="yes" xml:space="preserve">
          <source>Values from duplicated keys will be kept in the final list of values.</source>
          <target state="translated">Значения из дублированных ключей будут сохранены в итоговом списке.</target>
        </trans-unit>
        <trans-unit id="bba231ebda20b5f8062f3252ca8b56868e380a9d" translate="yes" xml:space="preserve">
          <source>Variable assignments inside the comprehension, be it in generators, filters or inside the block, are not reflected outside of the comprehension.</source>
          <target state="translated">Переменные задания внутри понимания,будь то в генераторах,фильтрах или внутри блока,не отражаются вне понимания.</target>
        </trans-unit>
        <trans-unit id="e5736ef93b4766ccd4b090695de9a9e5b75725fd" translate="yes" xml:space="preserve">
          <source>Variable handling</source>
          <target state="translated">Переменная обработка</target>
        </trans-unit>
        <trans-unit id="450790da2dc2629bcbedb648bf0b42931c1a1217" translate="yes" xml:space="preserve">
          <source>Variable hygiene only works because Elixir annotates variables with their context. For example, a variable &lt;code&gt;x&lt;/code&gt; defined on line 3 of a module would be represented as:</source>
          <target state="translated">Гигиена переменных работает только потому, что Elixir аннотирует переменные их контекстом. Например, переменная &lt;code&gt;x&lt;/code&gt; , определенная в строке 3 модуля, будет представлена ​​как:</target>
        </trans-unit>
        <trans-unit id="30198f1a7238ad824590316fe0e8bd0df65d9b66" translate="yes" xml:space="preserve">
          <source>Variable used as function call</source>
          <target state="translated">Переменная используется как вызов функции</target>
        </trans-unit>
        <trans-unit id="ac018db1f7b00972061adff843d37497d8ee153c" translate="yes" xml:space="preserve">
          <source>Variables</source>
          <target state="translated">Variables</target>
        </trans-unit>
        <trans-unit id="5e4d050cb107c1747d66ebd4856ad64e856a1514" translate="yes" xml:space="preserve">
          <source>Variables are also represented using a tuple with three elements and a combination of lists and atoms, for example:</source>
          <target state="translated">Переменные также представлены с помощью кортежа с тремя элементами и комбинации списков и атомов,например:</target>
        </trans-unit>
        <trans-unit id="dbf2df89d142b0d3f0bb4ede8494e41c32054358" translate="yes" xml:space="preserve">
          <source>Variables are also represented using such triplets, except the last element is an atom, instead of a list:</source>
          <target state="translated">Переменные также представляются с помощью таких триплетов,за исключением того,что последний элемент является атомом,а не списком:</target>
        </trans-unit>
        <trans-unit id="821703b844c6893a9bb58339226baa5472d41772" translate="yes" xml:space="preserve">
          <source>Variables can be used as map keys both when writing map literals as well as when matching:</source>
          <target state="translated">Переменные могут использоваться в качестве клавиш карты как при написании букв карты,так и при совпадении:</target>
        </trans-unit>
        <trans-unit id="c802a7c60e2c76d0ce217547c00e75a3c7aacf06" translate="yes" xml:space="preserve">
          <source>Variables can be used when accessing, matching and adding map keys:</source>
          <target state="translated">Переменные могут использоваться при доступе к клавишам карты,их сопоставлении и добавлении:</target>
        </trans-unit>
        <trans-unit id="13c207e2d8552cc70a71488f6d006d724e518bd1" translate="yes" xml:space="preserve">
          <source>Variables in Elixir can be rebound:</source>
          <target state="translated">Переменные в Эликсире могут отскакивать:</target>
        </trans-unit>
        <trans-unit id="03f0dd9e948cecac2dbcd988468c7f84c456ce0c" translate="yes" xml:space="preserve">
          <source>Variables in Elixir follow the identifier rule above with the following modifications:</source>
          <target state="translated">Переменные в Elixir следуют вышеуказанному правилу идентификации со следующими изменениями:</target>
        </trans-unit>
        <trans-unit id="675ba153ea525eb5962f8f25ca7142dc7421326e" translate="yes" xml:space="preserve">
          <source>Variables in Elixir must start with an underscore or a Unicode letter that is not in uppercase or titlecase. The variable may continue using a sequence of Unicode letters, numbers, and underscores. Variables may end in &lt;code&gt;?&lt;/code&gt; or &lt;code&gt;!&lt;/code&gt;. See &lt;a href=&quot;unicode-syntax&quot;&gt;Unicode Syntax&lt;/a&gt; for a formal specification.</source>
          <target state="translated">Переменные в Elixir должны начинаться с подчеркивания или буквы Unicode, которая не должна быть прописной или заглавной. Переменная может продолжать использовать последовательность букв Юникода, цифр и знаков подчеркивания. Переменные могут оканчиваться на &lt;code&gt;?&lt;/code&gt; или &lt;code&gt;!&lt;/code&gt; , См. Формальную спецификацию в &lt;a href=&quot;unicode-syntax&quot;&gt;синтаксисе Unicode&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="38e03778a4d67dc0517808845f9cf5459e3b84c9" translate="yes" xml:space="preserve">
          <source>Variables in patterns are always assigned to:</source>
          <target state="translated">Переменным в шаблонах всегда назначаются переменные:</target>
        </trans-unit>
        <trans-unit id="9dd88ce79cfea5a7985679e0418a24642e1946f2" translate="yes" xml:space="preserve">
          <source>Variables or any other type need to be explicitly tagged:</source>
          <target state="translated">Переменные или любые другие типы должны быть явно помечены:</target>
        </trans-unit>
        <trans-unit id="5c2492b6a76ece25c58f79dc3eb9560f7ab3f3bd" translate="yes" xml:space="preserve">
          <source>Variables scope</source>
          <target state="translated">Переменная область</target>
        </trans-unit>
        <trans-unit id="2da600bf9404843107a9531694f654e5662959e0" translate="yes" xml:space="preserve">
          <source>Version</source>
          <target state="translated">Version</target>
        </trans-unit>
        <trans-unit id="510f1df1a49656fd05d3a78cf65888ae976833ed" translate="yes" xml:space="preserve">
          <source>Version.InvalidRequirementError</source>
          <target state="translated">Version.InvalidRequirementError</target>
        </trans-unit>
        <trans-unit id="c1cb221f57e0ae6178e63ebeacc218b568ec650a" translate="yes" xml:space="preserve">
          <source>Version.InvalidRequirementError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">Version.InvalidRequirementError &lt;small&gt;исключение&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="29ca4a1db06262caa534068d5c946fa89fb538d9" translate="yes" xml:space="preserve">
          <source>Version.InvalidVersionError</source>
          <target state="translated">Version.InvalidVersionError</target>
        </trans-unit>
        <trans-unit id="eb7df9419f38796278f39dfdaee577c9920aef3b" translate="yes" xml:space="preserve">
          <source>Version.InvalidVersionError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">Version.InvalidVersionError &lt;small&gt;исключение&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="3351c5e4b78f9eb0bf0baa4b6d8dbc60869bd683" translate="yes" xml:space="preserve">
          <source>Version.Requirement</source>
          <target state="translated">Version.Requirement</target>
        </trans-unit>
        <trans-unit id="a239107ef28f6efe13d8ea83e502da9aa8c43fbb" translate="yes" xml:space="preserve">
          <source>Versions</source>
          <target state="translated">Versions</target>
        </trans-unit>
        <trans-unit id="e2415cb7f63df0c9de23362326ad3c37a9adfc96" translate="yes" xml:space="preserve">
          <source>W</source>
          <target state="translated">W</target>
        </trans-unit>
        <trans-unit id="f48ecdf1f6a9aea6cf19d13223fd11b1599d68d1" translate="yes" xml:space="preserve">
          <source>WARNING: Loss of precision may occur, as Erlang time tuples only contain hours/minutes/seconds.</source>
          <target state="translated">ПРЕДУПРЕЖДЕНИЕ:возможна потеря точности,так как кортежи времени Эрланга содержат только часы/минуты/секунды.</target>
        </trans-unit>
        <trans-unit id="47b4c1e035784f01be0c69fafea30a9b2026429f" translate="yes" xml:space="preserve">
          <source>WARNING: Loss of precision may occur, as Erlang time tuples only store hour/minute/second.</source>
          <target state="translated">ПРЕДУПРЕЖДЕНИЕ:возможна потеря точности,так как кортежи времени Эрланга хранят только час/минуту/секунду.</target>
        </trans-unit>
        <trans-unit id="f43e86f33963a81577b22c6ca0187a4cf4455fac" translate="yes" xml:space="preserve">
          <source>WARNING: This function can cause insidious bugs. It depends on the time zone configuration at run time. This can changed and be set to a time zone that has daylight saving jumps (spring forward or fall back).</source>
          <target state="translated">ВНИМАНИЕ:Эта функция может вызвать коварные ошибки.Она зависит от настройки часового пояса во время работы.Ее можно изменить и установить в часовой пояс с переходом на летнее время (пружина вперед или назад).</target>
        </trans-unit>
        <trans-unit id="060adc0fad39ca7580c07efaaf61a03475bd729c" translate="yes" xml:space="preserve">
          <source>WARNING: the ISO 8601 datetime format does not contain the time zone nor its abbreviation, which means information is lost when converting to such format.</source>
          <target state="translated">ПРЕДУПРЕЖДЕНИЕ:формат даты ISO 8601 не содержит ни часового пояса,ни его аббревиатуры,что означает потерю информации при преобразовании в такой формат.</target>
        </trans-unit>
        <trans-unit id="24b52f7221e506611f983c6a66637b0bdf0a5453" translate="yes" xml:space="preserve">
          <source>Waits for a client connection on that port and accepts it</source>
          <target state="translated">Ждет соединения с клиентом на этом порту и принимает его.</target>
        </trans-unit>
        <trans-unit id="833264ed2628e3e150d1f6d81b595fc4081a194c" translate="yes" xml:space="preserve">
          <source>Warning! Don&amp;rsquo;t use ETS as a cache prematurely! Log and analyze your application performance and identify which parts are bottlenecks, so you know &lt;em&gt;whether&lt;/em&gt; you should cache, and &lt;em&gt;what&lt;/em&gt; you should cache. This chapter is merely an example of how ETS can be used, once you&amp;rsquo;ve determined the need.</source>
          <target state="translated">Предупреждение! Не используйте ETS в качестве кеша преждевременно! Регистрируйте и анализируйте производительность вашего приложения и определяйте, какие части являются узкими местами, чтобы вы знали &lt;em&gt;,&lt;/em&gt; следует &lt;em&gt;ли&lt;/em&gt; вам кэшировать, а &lt;em&gt;что -&lt;/em&gt; кешировать. Эта глава является просто примером того, как можно использовать ETS, если вы определились с необходимостью.</target>
        </trans-unit>
        <trans-unit id="07f53218e24f6029b7697c005c09fa2c9c7e2c57" translate="yes" xml:space="preserve">
          <source>Warning: this function creates atoms dynamically and atoms are not garbage-collected. Therefore, &lt;code&gt;string&lt;/code&gt; should not be an untrusted value, such as input received from a socket or during a web request. Consider using &lt;a href=&quot;#to_existing_atom/1&quot;&gt;&lt;code&gt;to_existing_atom/1&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">Предупреждение: эта функция создает атомы динамически, и атомы не собираются сборщиком мусора. Следовательно, &lt;code&gt;string&lt;/code&gt; не должна быть ненадежным значением, таким как ввод, полученный из сокета или во время веб-запроса. &lt;a href=&quot;#to_existing_atom/1&quot;&gt; &lt;code&gt;to_existing_atom/1&lt;/code&gt; &lt;/a&gt; этого рассмотрите возможность использования to_existing_atom / 1 .</target>
        </trans-unit>
        <trans-unit id="1430f976c596795274458abcfbc4f280cbfcebac" translate="yes" xml:space="preserve">
          <source>Warnings</source>
          <target state="translated">Warnings</target>
        </trans-unit>
        <trans-unit id="8e1b8a938069f35be56d21075b02fc665bff349c" translate="yes" xml:space="preserve">
          <source>We access the information from the table with &lt;code&gt;KV.Registry.lookup(registry, &quot;shopping&quot;)&lt;/code&gt;</source>
          <target state="translated">Доступ к информации из таблицы с &lt;code&gt;KV.Registry.lookup(registry, &quot;shopping&quot;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4f270e7fa98f78d4a91d2d34f3dca8d0d25b2584" translate="yes" xml:space="preserve">
          <source>We also provide a tool called &lt;a href=&quot;https://github.com/elixir-lang/ex_doc&quot;&gt;ExDoc&lt;/a&gt; which is used to generate HTML pages from the documentation.</source>
          <target state="translated">Мы также предоставляем инструмент &lt;a href=&quot;https://github.com/elixir-lang/ex_doc&quot;&gt;ExDoc,&lt;/a&gt; который используется для создания HTML-страниц из документации.</target>
        </trans-unit>
        <trans-unit id="7420f50f5ea800c667c6d591562b02ecb3138867" translate="yes" xml:space="preserve">
          <source>We are getting a little bit ahead of ourselves. Let&amp;rsquo;s talk about bitstrings to learn about what exactly the &lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&lt;/code&gt; constructor means.</source>
          <target state="translated">Мы немного забегаем вперед. Давайте поговорим о битовых строках, чтобы узнать, что именно означает конструктор &lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="84b7b3a77090dc51964f720a1d3f403f3053b57d" translate="yes" xml:space="preserve">
          <source>We are getting closer and closer to a fully working system. The supervisor automatically starts the registry. But how can we automatically start the supervisor whenever our system starts? To answer this question, let&amp;rsquo;s talk about applications.</source>
          <target state="translated">Мы все ближе и ближе к полностью работающей системе. Супервизор автоматически запускает реестр. Но как мы можем автоматически запускать супервизор при каждом запуске нашей системы? Чтобы ответить на этот вопрос, поговорим о приложениях.</target>
        </trans-unit>
        <trans-unit id="89c4c33a1573de4b7284293b79f2c35805f70a32" translate="yes" xml:space="preserve">
          <source>We are going to explore them in detail now. Keep in mind the first three are called directives because they have &lt;strong&gt;lexical scope&lt;/strong&gt;, while &lt;code&gt;use&lt;/code&gt; is a common extension point that allows the used module to inject code.</source>
          <target state="translated">Сейчас мы собираемся изучить их подробно. Имейте в виду, что первые три называются директивами, потому что они имеют &lt;strong&gt;лексическую область видимости&lt;/strong&gt; , в то время как &lt;code&gt;use&lt;/code&gt; - это общая точка расширения, которая позволяет используемому модулю внедрять код.</target>
        </trans-unit>
        <trans-unit id="17fbf4999e7fd76ebfa56780dc2c430a141756ed" translate="yes" xml:space="preserve">
          <source>We are going to solve this issue by defining a new supervisor that will spawn and supervise all buckets. Opposite to the previous Supervisor we defined, the children are not known upfront, but they are rather started dynamically. For those situations, we use a &lt;code&gt;DynamicSupervisor&lt;/code&gt;. The &lt;code&gt;DynamicSupervisor&lt;/code&gt; does not expect a list of children during initialization; instead each child is started manually via &lt;code&gt;DynamicSupervisor.start_child/2&lt;/code&gt;.</source>
          <target state="translated">Мы собираемся решить эту проблему, определив нового супервизора, который будет создавать и контролировать все сегменты. В отличие от предыдущего супервизора, который мы определили, дочерние элементы не известны заранее, но скорее запускаются динамически. В таких ситуациях мы используем &lt;code&gt;DynamicSupervisor&lt;/code&gt; . &lt;code&gt;DynamicSupervisor&lt;/code&gt; не ожидает , что список детей во время инициализации; вместо этого каждый дочерний &lt;code&gt;DynamicSupervisor.start_child/2&lt;/code&gt; запускается вручную через DynamicSupervisor.start_child / 2 .</target>
        </trans-unit>
        <trans-unit id="66a257f39ae99fcce5fd4e7c7939a0f0b9b6d28e" translate="yes" xml:space="preserve">
          <source>We are going to start our server by calling &lt;code&gt;KVServer.accept(4040)&lt;/code&gt;, where 4040 is the port. The first step in &lt;code&gt;accept/1&lt;/code&gt; is to listen to the port until the socket becomes available and then call &lt;code&gt;loop_acceptor/1&lt;/code&gt;. &lt;code&gt;loop_acceptor/1&lt;/code&gt; is a loop accepting client connections. For each accepted connection, we call &lt;code&gt;serve/1&lt;/code&gt;.</source>
          <target state="translated">Мы собираемся запустить наш сервер, вызвав &lt;code&gt;KVServer.accept(4040)&lt;/code&gt; , где 4040 - это порт. Первым шагом в &lt;code&gt;accept/1&lt;/code&gt; является прослушивание порта до тех пор, пока сокет не станет доступным, а затем вызов &lt;code&gt;loop_acceptor/1&lt;/code&gt; . &lt;code&gt;loop_acceptor/1&lt;/code&gt; - это цикл, принимающий клиентские соединения. Для каждого принятого соединения мы вызываем &lt;code&gt;serve/1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f0a3473b399e71a57b7cad0d489cc6c99996e2a2" translate="yes" xml:space="preserve">
          <source>We are going to work on this &lt;code&gt;kv&lt;/code&gt; project, making modifications and trying out the latest changes from an &lt;code&gt;iex&lt;/code&gt; session. While you may start a new session whenever there are changes to the project source code, you can also recompile the project from within &lt;code&gt;iex&lt;/code&gt; with the &lt;code&gt;recompile&lt;/code&gt; helper, like this:</source>
          <target state="translated">Мы собираемся работать над этим проектом &lt;code&gt;kv&lt;/code&gt; , внося изменения и &lt;code&gt;iex&lt;/code&gt; последние изменения из сеанса IEX . Хотя вы можете начинать новый сеанс всякий раз, когда в исходный код проекта вносятся изменения, вы также можете перекомпилировать проект из &lt;code&gt;iex&lt;/code&gt; с помощью помощника &lt;code&gt;recompile&lt;/code&gt; , например:</target>
        </trans-unit>
        <trans-unit id="f3a2c31c893ab68348fa6a83fab20fa8c4610d92" translate="yes" xml:space="preserve">
          <source>We are keeping a map inside the agent to store our keys and values. Getting and putting values on the map is done with the Agent API and the capture operator &lt;code&gt;&amp;amp;&lt;/code&gt;, introduced in &lt;a href=&quot;../modules-and-functions#function-capturing&quot;&gt;the Getting Started guide&lt;/a&gt;.</source>
          <target state="translated">Мы храним карту внутри агента для хранения наших ключей и значений. Получение и размещение значений на карте выполняется с помощью API агента и оператора захвата &lt;code&gt;&amp;amp;&lt;/code&gt; , описанного в &lt;a href=&quot;../modules-and-functions#function-capturing&quot;&gt;руководстве по началу работы&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d13091f2d24e7ff35d138307c283479ea0879f12" translate="yes" xml:space="preserve">
          <source>We are keeping a map inside the agent to store our keys and values. Getting and putting values on the map is done with the Agent API and the capture operator &lt;code&gt;&amp;amp;&lt;/code&gt;, introduced in &lt;a href=&quot;../modules-and-functions#function-capturing&quot;&gt;the Getting Started guide&lt;/a&gt;. The agent passes its state to the anonymous function via the &lt;code&gt;&amp;amp;1&lt;/code&gt; argument when &lt;code&gt;Agent.get/2&lt;/code&gt; and &lt;code&gt;Agent.update/2&lt;/code&gt; are called.</source>
          <target state="translated">Мы храним карту внутри агента для хранения наших ключей и значений. Получение и размещение значений на карте выполняется с помощью API агента и оператора захвата &lt;code&gt;&amp;amp;&lt;/code&gt; , описанного в &lt;a href=&quot;../modules-and-functions#function-capturing&quot;&gt;руководстве по началу работы&lt;/a&gt; . Агент передает свое состояние анонимной функции через аргумент &lt;code&gt;&amp;amp;1&lt;/code&gt; при &lt;code&gt;Agent.get/2&lt;/code&gt; и &lt;code&gt;Agent.update/2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3de39a939a256c76bb5f3d5c434c42494e313045" translate="yes" xml:space="preserve">
          <source>We are prematurely optimizing (by adding this cache layer)</source>
          <target state="translated">Мы преждевременно оптимизируем (добавляя этот слой кэша).</target>
        </trans-unit>
        <trans-unit id="98e709b53693eead12625653dd1b14be1a41bdec" translate="yes" xml:space="preserve">
          <source>We are starting a linked Task directly from the acceptor process. But we&amp;rsquo;ve already made this mistake once. Do you remember?</source>
          <target state="translated">Мы запускаем связанную задачу прямо из процесса-приемника. Но однажды мы уже совершали эту ошибку. Ты помнишь?</target>
        </trans-unit>
        <trans-unit id="d4e4b8b6daeeae158dc805b81f3028139c8061f9" translate="yes" xml:space="preserve">
          <source>We are using &lt;code&gt;cast/2&lt;/code&gt; (while we should be using &lt;code&gt;call/2&lt;/code&gt;)</source>
          <target state="translated">Мы используем &lt;code&gt;cast/2&lt;/code&gt; (в то время как мы должны использовать &lt;code&gt;call/2&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="11591e8c4eb0268773c80edde093ba6561e1358d" translate="yes" xml:space="preserve">
          <source>We are using &lt;code&gt;cast/2&lt;/code&gt; (while we should be using &lt;code&gt;call/3&lt;/code&gt;)</source>
          <target state="translated">Мы используем &lt;code&gt;cast/2&lt;/code&gt; (в то время как мы должны использовать &lt;code&gt;call/3&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="b8cfde5c1ad8b2b1ce9d64a075749f12ac0d7836" translate="yes" xml:space="preserve">
          <source>We call them &quot;naive&quot; because this datetime representation does not have a time zone. This means the datetime may not actually exist in certain areas in the world even though it is valid.</source>
          <target state="translated">Мы называем их &quot;наивными&quot;,потому что в этом представлении даты нет часового пояса.Это означает,что дата может не существовать в некоторых регионах мира,даже если она действительна.</target>
        </trans-unit>
        <trans-unit id="92039985a3c4332a3392a8d1927f335ae96a31e5" translate="yes" xml:space="preserve">
          <source>We can access it during compile time as:</source>
          <target state="translated">Мы можем получить доступ к нему во время компиляции:</target>
        </trans-unit>
        <trans-unit id="a77b42bf0e1456fa472a99d5e18bf8b1349fa19d" translate="yes" xml:space="preserve">
          <source>We can access the documentation for the &lt;code&gt;~r&lt;/code&gt; sigil via &lt;code&gt;sigil_r&lt;/code&gt;:</source>
          <target state="translated">Мы можем получить доступ к документации для &lt;code&gt;sigil_r&lt;/code&gt; &lt;code&gt;~r&lt;/code&gt; через sigil_r :</target>
        </trans-unit>
        <trans-unit id="fe8009d0ba377613a52d009d93bebf653b3a471c" translate="yes" xml:space="preserve">
          <source>We can actually verify that this is the case by using &lt;code&gt;Macro.expand_once/2&lt;/code&gt;:</source>
          <target state="translated">Мы действительно можем проверить, что это так, используя &lt;code&gt;Macro.expand_once/2&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="c030c328d3a9c056d8ccb727197b640a951b23a6" translate="yes" xml:space="preserve">
          <source>We can already try out our first umbrella child. We could run tests inside the &lt;code&gt;apps/kv_server&lt;/code&gt; directory, but that wouldn&amp;rsquo;t be much fun. Instead, go to the root of the umbrella project and run &lt;code&gt;mix test&lt;/code&gt;:</source>
          <target state="translated">Мы уже можем опробовать нашего первого ребенка-зонтика. Мы могли бы запускать тесты внутри каталога &lt;code&gt;apps/kv_server&lt;/code&gt; , но это было бы не очень весело. Вместо этого перейдите в корень зонтичного проекта и запустите &lt;code&gt;mix test&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="76d915b11584eef7d90761bc6964ee3dcfd9b998" translate="yes" xml:space="preserve">
          <source>We can also alias multiple modules in one line:</source>
          <target state="translated">Мы также можем называть несколько модулей в одной строке:</target>
        </trans-unit>
        <trans-unit id="6f04c4524f84c94effef9fb5bcec2b882f65312b" translate="yes" xml:space="preserve">
          <source>We can also get the number of bytes in a string:</source>
          <target state="translated">Мы также можем получить количество байт в строке:</target>
        </trans-unit>
        <trans-unit id="d32d36279a4b620d4bed74fa6c37d65e7a66a517" translate="yes" xml:space="preserve">
          <source>We can also pattern match on binaries / bitstrings:</source>
          <target state="translated">Мы также можем сопоставить шаблоны на двоичных файлах/битовых строках:</target>
        </trans-unit>
        <trans-unit id="fed95b4dfe3e8f19721e9decd83125589f497411" translate="yes" xml:space="preserve">
          <source>We can also provide our own sigils by implementing functions that follow the &lt;code&gt;sigil_{identifier}&lt;/code&gt; pattern. For example, let&amp;rsquo;s implement the &lt;code&gt;~i&lt;/code&gt; sigil that returns an integer (with the optional &lt;code&gt;n&lt;/code&gt; modifier to make it negative):</source>
          <target state="translated">Мы также можем предоставить наши собственные сигилы, реализовав функции, которые следуют &lt;code&gt;sigil_{identifier}&lt;/code&gt; . Например, давайте реализуем сигил &lt;code&gt;~i&lt;/code&gt; который возвращает целое число (с необязательным модификатором &lt;code&gt;n&lt;/code&gt; , чтобы сделать его отрицательным):</target>
        </trans-unit>
        <trans-unit id="aed02b605b4c892e4f538fc64a641140a8f4dd48" translate="yes" xml:space="preserve">
          <source>We can also use the dot for creating aliases:</source>
          <target state="translated">Мы также можем использовать точку для создания псевдонимов:</target>
        </trans-unit>
        <trans-unit id="a26b7df9d8ed21cbfae4c86a3137802a26607e08" translate="yes" xml:space="preserve">
          <source>We can also use this syntax to access documentation. The Elixir shell defines the &lt;code&gt;h&lt;/code&gt; function, which you can use to access documentation for any function. For example, typing &lt;code&gt;h round/1&lt;/code&gt; is going to print the documentation for the &lt;code&gt;round/1&lt;/code&gt; function:</source>
          <target state="translated">Мы также можем использовать этот синтаксис для доступа к документации. Оболочка Elixir определяет функцию &lt;code&gt;h&lt;/code&gt; , которую вы можете использовать для доступа к документации по любой функции. Например, если ввести &lt;code&gt;h round/1&lt;/code&gt; , будет распечатана документация для функции &lt;code&gt;round/1&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="206f0c2db045ed8078217482f771ce08024e2d1b" translate="yes" xml:space="preserve">
          <source>We can also use unquote to generate a remote call in a quoted expression:</source>
          <target state="translated">Мы также можем использовать кавычки для генерации удаленного вызова в цитируемом выражении:</target>
        </trans-unit>
        <trans-unit id="f2dbdd4832136ee40e6106da4ff237e5086b3f62" translate="yes" xml:space="preserve">
          <source>We can check the truthiness of a value by using the &lt;a href=&quot;#!/1&quot;&gt;&lt;code&gt;!/1&lt;/code&gt;&lt;/a&gt; function twice.</source>
          <target state="translated">Мы можем проверить истинность значения, дважды используя функцию &lt;a href=&quot;#!/1&quot;&gt; &lt;code&gt;!/1&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="34ceb39491adfef2435637a7c059b77e2fcd5969" translate="yes" xml:space="preserve">
          <source>We can create a &lt;code&gt;Parser&lt;/code&gt; behaviour:</source>
          <target state="translated">Мы можем создать поведение &lt;code&gt;Parser&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="0dd1c8c6a5914f109c4f354f46226b3d028c2e02" translate="yes" xml:space="preserve">
          <source>We can define any function and macro we want, including ones that override the built-in definitions provided by Elixir. The only exceptions are Elixir special forms which are not implemented in Elixir and therefore cannot be overridden, &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#summary&quot;&gt;the full list of special forms is available in &lt;code&gt;Kernel.SpecialForms&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Мы можем определить любую функцию и макрос, которые захотим, в том числе те, которые отменяют встроенные определения, предоставляемые Elixir. Единственным исключением являются специальные формы Elixir, которые не реализованы в Elixir и поэтому не могут быть переопределены, &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#summary&quot;&gt;полный список специальных форм доступен в &lt;code&gt;Kernel.SpecialForms&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="093b9c9eb6d6b0fc66fe2a2daaa50a1cbe7322b6" translate="yes" xml:space="preserve">
          <source>We can do this by passing the &lt;code&gt;restart: :temporary&lt;/code&gt; option to &lt;code&gt;use Agent&lt;/code&gt; in &lt;code&gt;KV.Bucket&lt;/code&gt;:</source>
          <target state="translated">Мы можем сделать это, передав параметр &lt;code&gt;restart: :temporary&lt;/code&gt; &lt;code&gt;KV.Bucket&lt;/code&gt; для &lt;code&gt;use Agent&lt;/code&gt; в KV.Bucket :</target>
        </trans-unit>
        <trans-unit id="5948b90ba1129ec3a47a102cda2b8444a180dc8b" translate="yes" xml:space="preserve">
          <source>We can find the generated &lt;code&gt;.app&lt;/code&gt; file at &lt;code&gt;_build/dev/lib/kv/ebin/kv.app&lt;/code&gt;. Let&amp;rsquo;s have a look at its contents:</source>
          <target state="translated">Мы можем найти сгенерированный файл &lt;code&gt;.app&lt;/code&gt; в &lt;code&gt;_build/dev/lib/kv/ebin/kv.app&lt;/code&gt; . Взглянем на его содержимое:</target>
        </trans-unit>
        <trans-unit id="5bd02c81ba6eb5d62769c970196b9d789da3e8cf" translate="yes" xml:space="preserve">
          <source>We can invoke it as:</source>
          <target state="translated">Мы можем использовать это как:</target>
        </trans-unit>
        <trans-unit id="9fa7890904dbff07dec603c4fd23ae8212249d12" translate="yes" xml:space="preserve">
          <source>We can invoke this macro as:</source>
          <target state="translated">Мы можем использовать этот макрос как:</target>
        </trans-unit>
        <trans-unit id="ec221b458cd8f8df534326a6eca8a80f9017bf12" translate="yes" xml:space="preserve">
          <source>We can now create &lt;code&gt;User&lt;/code&gt; structs by using a syntax similar to the one used to create maps (if you have defined the struct in a separate file, you can compile the file inside IEx before proceeding by running &lt;code&gt;c &quot;file.exs&quot;&lt;/code&gt;; be aware you may get an error saying &lt;code&gt;the struct was not yet defined&lt;/code&gt; if you try the below example in a file directly due to when definitions are resolved):</source>
          <target state="translated">Теперь мы можем создавать &lt;code&gt;User&lt;/code&gt; структуры, используя синтаксис, аналогичный синтаксису, используемому для создания карт (если вы определили структуру в отдельном файле, вы можете скомпилировать файл внутри IEx, прежде чем продолжить, запустив &lt;code&gt;c &quot;file.exs&quot;&lt;/code&gt; ; имейте в виду вы можете получить сообщение об ошибке о том, &lt;code&gt;the struct was not yet defined&lt;/code&gt; если вы попробуете приведенный ниже пример в файле непосредственно из-за того, что определения разрешены):</target>
        </trans-unit>
        <trans-unit id="cb349bfbe30f9cb04e70d0822597f66eda9e1501" translate="yes" xml:space="preserve">
          <source>We can now start a supervisor that will start and supervise our stack process. The first step is to define a list of &lt;strong&gt;child specifications&lt;/strong&gt; that control how each child behaves. Each child specification is a map, as shown below:</source>
          <target state="translated">Теперь мы можем запустить супервизор, который будет запускать и контролировать наш стековый процесс. Первый шаг - определить список &lt;strong&gt;дочерних спецификаций,&lt;/strong&gt; которые контролируют поведение каждого дочернего элемента. Каждая дочерняя спецификация представляет собой карту, как показано ниже:</target>
        </trans-unit>
        <trans-unit id="2fff4b558e6b43bd26688c108539ad96241d60df" translate="yes" xml:space="preserve">
          <source>We can partially apply a remote function with placeholder:</source>
          <target state="translated">Мы можем частично применить удаленную функцию с плейсхолдером:</target>
        </trans-unit>
        <trans-unit id="e1dae55a2ef436168dca26e3a357bb8de790b475" translate="yes" xml:space="preserve">
          <source>We can pass an option to Mix to ask it to not start our application. Let&amp;rsquo;s give it a try by running &lt;code&gt;iex -S mix run --no-start&lt;/code&gt;:</source>
          <target state="translated">Мы можем передать Mix опцию, чтобы он не запускал наше приложение. Давайте попробуем, запустив &lt;code&gt;iex -S mix run --no-start&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="c5f7f298852cf2b9d4d114bc0cd5306010398052" translate="yes" xml:space="preserve">
          <source>We can pattern match on binaries / bitstrings:</source>
          <target state="translated">Мы можем сопоставить шаблоны на двоичных файлах/битовых строках:</target>
        </trans-unit>
        <trans-unit id="77f7b587fa11d773ef7ba586a16daa37340be0d6" translate="yes" xml:space="preserve">
          <source>We can pattern match on lists:</source>
          <target state="translated">Мы можем найти совпадение по шаблону в списках:</target>
        </trans-unit>
        <trans-unit id="f0a478e4d3f780a89dec1acd670b16ecab0fe6d8" translate="yes" xml:space="preserve">
          <source>We can retrieve the AST for any Elixir expression by calling &lt;code&gt;quote&lt;/code&gt;:</source>
          <target state="translated">Мы можем получить AST для любого выражения Elixir, вызвав &lt;code&gt;quote&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="ea6ae36afce917a366f60cadc38a2b7778dc8273" translate="yes" xml:space="preserve">
          <source>We can retrieve the PID of the current process by calling &lt;code&gt;self/0&lt;/code&gt;:</source>
          <target state="translated">Мы можем получить PID текущего процесса, вызвав &lt;code&gt;self/0&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="dda1d7d70c978bad3827eb4aef2e0f741f24b16d" translate="yes" xml:space="preserve">
          <source>We can see that &lt;code&gt;x&lt;/code&gt; did not leak to the user context. This happens because Elixir macros are hygienic, a topic we will discuss at length in the next sections as well.</source>
          <target state="translated">Мы видим, что &lt;code&gt;x&lt;/code&gt; не попал в контекст пользователя. Это происходит потому, что макросы Elixir гигиеничны, и эту тему мы также подробно обсудим в следующих разделах.</target>
        </trans-unit>
        <trans-unit id="9d7f07c4321edb95b40558ce4ce3f34ee1157e2e" translate="yes" xml:space="preserve">
          <source>We can send and receive messages from the pid returned by &lt;code&gt;Node.spawn_link/2&lt;/code&gt; as usual. Let&amp;rsquo;s try a quick ping-pong example:</source>
          <target state="translated">Мы можем отправлять и получать сообщения от pid, возвращаемого &lt;code&gt;Node.spawn_link/2&lt;/code&gt; , как обычно. Давайте попробуем быстрый пример пинг-понга:</target>
        </trans-unit>
        <trans-unit id="be65a398bab9afdd4c9279424e0b66beb2383362" translate="yes" xml:space="preserve">
          <source>We can send messages to a process with &lt;code&gt;send/2&lt;/code&gt; and receive them with &lt;code&gt;receive/1&lt;/code&gt;:</source>
          <target state="translated">Мы можем отправлять сообщения процессу с помощью &lt;code&gt;send/2&lt;/code&gt; и получать их с помощью &lt;code&gt;receive/1&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="89a292fe34f0517fb76add473e5f90e9445c0866" translate="yes" xml:space="preserve">
          <source>We can solve this by explicitly tagging it as &lt;code&gt;binary&lt;/code&gt;:</source>
          <target state="translated">Мы можем решить эту проблему, явно пометив его как &lt;code&gt;binary&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="a43133c591cffe7eae441ae9df0f625b8acc625f" translate="yes" xml:space="preserve">
          <source>We can stop our &lt;code&gt;:kv&lt;/code&gt; application as well as the &lt;code&gt;:logger&lt;/code&gt; application, which is started by default with Elixir:</source>
          <target state="translated">Мы можем остановить наше приложение &lt;code&gt;:kv&lt;/code&gt; , а также приложение &lt;code&gt;:logger&lt;/code&gt; , которое по умолчанию запускается с помощью Elixir:</target>
        </trans-unit>
        <trans-unit id="94ea1a9c3bcbf4640e6d211c9cd39b949fc95272" translate="yes" xml:space="preserve">
          <source>We can use the &lt;code&gt;:label&lt;/code&gt; option to decorate the output:</source>
          <target state="translated">Мы можем использовать опцию &lt;code&gt;:label&lt;/code&gt; для украшения вывода:</target>
        </trans-unit>
        <trans-unit id="0f0ea704dc501de98c5952d7c26653b440669d42" translate="yes" xml:space="preserve">
          <source>We can use the pin operator inside other pattern matches, such as tuples or lists:</source>
          <target state="translated">Мы можем использовать оператор pin внутри других совпадений шаблонов,таких как кортежи или списки:</target>
        </trans-unit>
        <trans-unit id="5eb1cad49fe0b7cf31002d0cb30f5452a668d30e" translate="yes" xml:space="preserve">
          <source>We changed the callback from &lt;code&gt;handle_cast/2&lt;/code&gt; to &lt;code&gt;handle_call/3&lt;/code&gt; and changed it to reply with the pid of the created bucket. Generally speaking, Elixir developers prefer to use &lt;code&gt;call/2&lt;/code&gt; instead of &lt;code&gt;cast/2&lt;/code&gt; as it also provides back-pressure - you block until you get a reply. Using &lt;code&gt;cast/2&lt;/code&gt; when not necessary can also be considered a premature optimization.</source>
          <target state="translated">Мы изменили обратный вызов с &lt;code&gt;handle_cast/2&lt;/code&gt; на &lt;code&gt;handle_call/3&lt;/code&gt; и изменили его на ответ с помощью pid созданного ведра. Вообще говоря, разработчики Elixir предпочитают использовать &lt;code&gt;call/2&lt;/code&gt; вместо &lt;code&gt;cast/2&lt;/code&gt; , поскольку он также обеспечивает обратное давление - вы блокируете, пока не получите ответ. Использование &lt;code&gt;cast/2&lt;/code&gt; , когда в нем нет необходимости, также можно рассматривать как преждевременную оптимизацию.</target>
        </trans-unit>
        <trans-unit id="e425300cff93bee7fcafcf5a279ba603882b1684" translate="yes" xml:space="preserve">
          <source>We could fix this by defining our own module that calls &lt;code&gt;use Task, restart: :permanent&lt;/code&gt; and invokes a &lt;code&gt;start_link&lt;/code&gt; function responsible for restarting the task, quite similar to &lt;code&gt;Agent&lt;/code&gt; and &lt;code&gt;GenServer&lt;/code&gt;. However, let&amp;rsquo;s take a different approach here. When integrating with someone else&amp;rsquo;s library, we won&amp;rsquo;t be able to change how their agents, tasks, and servers are defined. Instead, we need to be able to customize their child specification dynamically. This can be done by using &lt;code&gt;Supervisor.child_spec/2&lt;/code&gt;, a function that we happen to know from previous chapters. Let&amp;rsquo;s rewrite &lt;code&gt;start/2&lt;/code&gt; in &lt;code&gt;KVServer.Application&lt;/code&gt; once more:</source>
          <target state="translated">Мы могли бы исправить это, определив наш собственный модуль, который вызывает &lt;code&gt;use Task, restart: :permanent&lt;/code&gt; и вызывает функцию &lt;code&gt;start_link&lt;/code&gt; , отвечающую за перезапуск задачи, очень похожую на &lt;code&gt;Agent&lt;/code&gt; и &lt;code&gt;GenServer&lt;/code&gt; . Однако давайте воспользуемся другим подходом. При интеграции с чужой библиотекой мы не сможем изменить способ определения их агентов, задач и серверов. Вместо этого нам нужно иметь возможность динамически настраивать их дочернюю спецификацию. Это можно сделать с помощью функции &lt;code&gt;Supervisor.child_spec/2&lt;/code&gt; , которую мы знаем из предыдущих глав. &lt;code&gt;KVServer.Application&lt;/code&gt; раз перепишем &lt;code&gt;start/2&lt;/code&gt; в KVServer.Application :</target>
        </trans-unit>
        <trans-unit id="a3910a0d1de4ef411ffef6142801a0b82108c33c" translate="yes" xml:space="preserve">
          <source>We could have a server running on the other node and send requests to that node via the &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt;GenServer&lt;/a&gt; API. For example, you can call a server on a remote node by using &lt;code&gt;GenServer.call({name, node}, arg)&lt;/code&gt; or passing the remote process PID as the first argument</source>
          <target state="translated">Мы могли бы иметь сервер, работающий на другом узле, и отправлять запросы на этот узел через &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt;GenServer&lt;/a&gt; API. Например, вы можете вызвать сервер на удаленном узле, используя &lt;code&gt;GenServer.call({name, node}, arg)&lt;/code&gt; или передав PID удаленного процесса в качестве первого аргумента.</target>
        </trans-unit>
        <trans-unit id="534697b7ae5a1dc93cf9129d4470c64b61320dc1" translate="yes" xml:space="preserve">
          <source>We could use &lt;a href=&quot;https://hexdocs.pm/elixir/Task.html&quot;&gt;tasks&lt;/a&gt;, which we have learned about in &lt;a href=&quot;task-and-gen-tcp&quot;&gt;a previous chapter&lt;/a&gt;, as they can be spawned on both local and remote nodes</source>
          <target state="translated">Мы могли бы использовать &lt;a href=&quot;https://hexdocs.pm/elixir/Task.html&quot;&gt;задачи&lt;/a&gt; , о которых мы узнали в &lt;a href=&quot;task-and-gen-tcp&quot;&gt;предыдущей главе&lt;/a&gt; , поскольку они могут быть созданы как на локальных, так и на удаленных узлах.</target>
        </trans-unit>
        <trans-unit id="e4f1434d1a6494bb12e865205684d1adb1d41c51" translate="yes" xml:space="preserve">
          <source>We could use Erlang&amp;rsquo;s &lt;a href=&quot;http://www.erlang.org/doc/man/rpc.html&quot;&gt;:rpc&lt;/a&gt; module to execute functions on a remote node. Inside the &lt;code&gt;bar@computer-name&lt;/code&gt; shell above, you can call &lt;code&gt;:rpc.call(:&quot;foo@computer-name&quot;, Hello, :world, [])&lt;/code&gt; and it will print &amp;ldquo;hello world&amp;rdquo;</source>
          <target state="translated">Мы могли бы использовать модуль Erlang &lt;a href=&quot;http://www.erlang.org/doc/man/rpc.html&quot;&gt;: rpc&lt;/a&gt; для выполнения функций на удаленном узле. Внутри оболочки &lt;code&gt;bar@computer-name&lt;/code&gt; выше вы можете вызвать &lt;code&gt;:rpc.call(:&quot;foo@computer-name&quot;, Hello, :world, [])&lt;/code&gt; и он напечатает &amp;laquo;hello world&amp;raquo;</target>
        </trans-unit>
        <trans-unit id="4c0e6a10a3b1333bef19dabada44221a30ffa0b9" translate="yes" xml:space="preserve">
          <source>We covered processes in the Getting Started guide.</source>
          <target state="translated">Мы освещали процессы в руководстве &quot;Начало работы&quot;.</target>
        </trans-unit>
        <trans-unit id="4da3e8b3e27e6715edee0a64724a91895affe530" translate="yes" xml:space="preserve">
          <source>We define the protocol using &lt;code&gt;defprotocol&lt;/code&gt; - its functions and specs may look similar to interfaces or abstract base classes in other languages. We can add as many implementations as we like using &lt;code&gt;defimpl&lt;/code&gt;. The output is exactly the same as if we had a single module with multiple functions:</source>
          <target state="translated">Мы определяем протокол с помощью &lt;code&gt;defprotocol&lt;/code&gt; - его функции и спецификации могут быть похожи на интерфейсы или абстрактные базовые классы на других языках. Мы можем добавить столько реализаций, сколько захотим, используя &lt;code&gt;defimpl&lt;/code&gt; . Результат точно такой же, как если бы у нас был один модуль с несколькими функциями:</target>
        </trans-unit>
        <trans-unit id="c9f9a5502e96501c802a665d9324eab87d03f3ad" translate="yes" xml:space="preserve">
          <source>We define them in this module. Some of these forms are lexical (like &lt;a href=&quot;#alias/2&quot;&gt;&lt;code&gt;alias/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#case/2&quot;&gt;&lt;code&gt;case/2&lt;/code&gt;&lt;/a&gt;, etc.). The macros &lt;a href=&quot;#%257B%257D/1&quot;&gt;&lt;code&gt;{}/1&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#%253C%253C%253E%253E/1&quot;&gt;&lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;/1&lt;/code&gt;&lt;/a&gt; are also special forms used to define tuple and binary data structures respectively.</source>
          <target state="translated">Мы определяем их в этом модуле. Некоторые из этих форм являются лексическими (например, &lt;a href=&quot;#alias/2&quot;&gt; &lt;code&gt;alias/2&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#case/2&quot;&gt; &lt;code&gt;case/2&lt;/code&gt; &lt;/a&gt; и т. Д.). Макросы &lt;a href=&quot;#%257B%257D/1&quot;&gt; &lt;code&gt;{}/1&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;#%253C%253C%253E%253E/1&quot;&gt; &lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;/1&lt;/code&gt; &lt;/a&gt; также представляют собой специальные формы, используемые для определения кортежей и двоичных структур данных соответственно.</target>
        </trans-unit>
        <trans-unit id="53a13c26ec46afac43b4d43287c04fe12385a3eb" translate="yes" xml:space="preserve">
          <source>We defined &lt;code&gt;print_multiple_times/2&lt;/code&gt; so that, no matter what number is passed as the second argument, it either triggers our first definition (known as a &lt;em&gt;base case&lt;/em&gt;) or it triggers our second definition, which will ensure that we get exactly one step closer to our base case.</source>
          <target state="translated">Мы определили &lt;code&gt;print_multiple_times/2&lt;/code&gt; так, что независимо от того, какое число передается в качестве второго аргумента, оно либо запускает наше первое определение (известное как &lt;em&gt;базовый случай&lt;/em&gt; ), либо запускает наше второе определение, что гарантирует, что мы приблизимся ровно на один шаг к наш базовый случай.</target>
        </trans-unit>
        <trans-unit id="cd0565f2965aa875bf029148dfb2639986d33cde" translate="yes" xml:space="preserve">
          <source>We didn&amp;rsquo;t implement the &lt;code&gt;Size&lt;/code&gt; protocol for lists as there is no &amp;ldquo;size&amp;rdquo; information pre-computed for lists, and the length of a list has to be computed (with &lt;code&gt;length/1&lt;/code&gt;).</source>
          <target state="translated">Мы не реализовали протокол &lt;code&gt;Size&lt;/code&gt; для списков, так как для списков предварительно не вычисляется информация о &amp;laquo;размере&amp;raquo;, а длина списка должна быть вычислена (с &lt;code&gt;length/1&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="96557d39ec2ff50c51270cf7b396c7169836eae9" translate="yes" xml:space="preserve">
          <source>We explore the Observer in the context of an actual project &lt;a href=&quot;mix-otp/dynamic-supervisor&quot;&gt;in the Dynamic Supervisor chapter of the Mix &amp;amp; OTP guide&lt;/a&gt;.</source>
          <target state="translated">Мы исследуем Observer в контексте реального проекта &lt;a href=&quot;mix-otp/dynamic-supervisor&quot;&gt;в главе Dynamic Supervisor руководства Mix &amp;amp; OTP&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="73d563f8598d3baf5372c3b186303673dc0b48c2" translate="yes" xml:space="preserve">
          <source>We explore the Observer in the context of an actual project &lt;a href=&quot;mix-otp/dynamic-supervisor&quot;&gt;in the Dynamic Supervisor chapter of the Mix &amp;amp; OTP guide&lt;/a&gt;. This is one of the debugging techniques &lt;a href=&quot;https://phoenixframework.org/blog/the-road-to-2-million-websocket-connections&quot;&gt;the Phoenix framework used to achieve 2 million connections on a single machine&lt;/a&gt;.</source>
          <target state="translated">Мы исследуем Observer в контексте реального проекта &lt;a href=&quot;mix-otp/dynamic-supervisor&quot;&gt;в главе Dynamic Supervisor руководства Mix &amp;amp; OTP&lt;/a&gt; . Это один из методов отладки, который &lt;a href=&quot;https://phoenixframework.org/blog/the-road-to-2-million-websocket-connections&quot;&gt;фреймворк Phoenix использовал для достижения 2 миллионов соединений на одной машине&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="48a05447e0ce5a3dabef9e3188cfc11688196b7e" translate="yes" xml:space="preserve">
          <source>We fixed the issue for the registry by using a simple one for one supervisor. We are going to use the same tactic here, except that this pattern is so common with tasks that &lt;code&gt;Task&lt;/code&gt; already comes with a solution: a simple one for one supervisor that starts temporary tasks as part of our supervision tree.</source>
          <target state="translated">Мы исправили проблему с реестром, используя простой для одного супервизора. Мы собираемся использовать здесь ту же тактику, за исключением того, что этот шаблон настолько распространен для задач, что &lt;code&gt;Task&lt;/code&gt; уже имеет решение: простое решение для одного супервизора, который запускает временные задачи как часть нашего дерева наблюдения.</target>
        </trans-unit>
        <trans-unit id="39ce08db5db51d4902ad9a04510ad3592e662ebe" translate="yes" xml:space="preserve">
          <source>We get a list that follows the pipeline directly: first the &lt;code&gt;100&lt;/code&gt;, then the &lt;code&gt;div(5)&lt;/code&gt; (more precisely, its AST), then &lt;code&gt;div(2)&lt;/code&gt;. The &lt;code&gt;0&lt;/code&gt; as the second element of the tuples is the position of the previous element in the pipeline inside the current function application: &lt;code&gt;{{:div, [], [5]}, 0}&lt;/code&gt; means that the previous element (&lt;code&gt;100&lt;/code&gt;) will be inserted as the 0th (first) argument to the &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#div/2&quot;&gt;&lt;code&gt;div/2&lt;/code&gt;&lt;/a&gt; function, so that the AST for that function will become &lt;code&gt;{:div, [], [100, 5]}&lt;/code&gt; (&lt;code&gt;div(100, 5)&lt;/code&gt;).</source>
          <target state="translated">Мы получаем список, который следует непосредственно по конвейеру: сначала &lt;code&gt;100&lt;/code&gt; , затем &lt;code&gt;div(5)&lt;/code&gt; (точнее, его AST), затем &lt;code&gt;div(2)&lt;/code&gt; . &lt;code&gt;0&lt;/code&gt; в качестве второго элемента кортежей является позиция предыдущего элемента в трубопроводе внутри текущего приложения функции: &lt;code&gt;{{:div, [], [5]}, 0}&lt;/code&gt; означает , что предыдущий элемент ( &lt;code&gt;100&lt;/code&gt; ) , будет вставлен в качестве 0-го (первого) аргумента функции &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#div/2&quot;&gt; &lt;code&gt;div/2&lt;/code&gt; &lt;/a&gt; , так что AST для этой функции станет &lt;code&gt;{:div, [], [100, 5]}&lt;/code&gt; ( &lt;code&gt;div(100, 5)&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="9caab9660f6fe9cab22fc23d72b11c01e22a7a4f" translate="yes" xml:space="preserve">
          <source>We get a list that follows the pipeline directly: first the &lt;code&gt;100&lt;/code&gt;, then the &lt;code&gt;div(5)&lt;/code&gt; (more precisely, its AST), then &lt;code&gt;div(2)&lt;/code&gt;. The &lt;code&gt;0&lt;/code&gt; as the second element of the tuples is the position of the previous element in the pipeline inside the current function application: &lt;code&gt;{{:div, [], [5]}, 0}&lt;/code&gt; means that the previous element (&lt;code&gt;100&lt;/code&gt;) will be inserted as the 0th (first) argument to the &lt;a href=&quot;kernel#div/2&quot;&gt;&lt;code&gt;div/2&lt;/code&gt;&lt;/a&gt; function, so that the AST for that function will become &lt;code&gt;{:div, [], [100, 5]}&lt;/code&gt; (&lt;code&gt;div(100, 5)&lt;/code&gt;).</source>
          <target state="translated">Мы получаем список, который следует непосредственно по конвейеру: сначала &lt;code&gt;100&lt;/code&gt; , затем &lt;code&gt;div(5)&lt;/code&gt; (точнее, его AST), затем &lt;code&gt;div(2)&lt;/code&gt; . &lt;code&gt;0&lt;/code&gt; в качестве второго элемента кортежей является позиция предыдущего элемента в трубопроводе внутри текущего приложения функции: &lt;code&gt;{{:div, [], [5]}, 0}&lt;/code&gt; означает , что предыдущий элемент ( &lt;code&gt;100&lt;/code&gt; ) , будет вставлен в качестве 0-го (первого) аргумента функции &lt;a href=&quot;kernel#div/2&quot;&gt; &lt;code&gt;div/2&lt;/code&gt; &lt;/a&gt; , так что AST для этой функции станет &lt;code&gt;{:div, [], [100, 5]}&lt;/code&gt; ( &lt;code&gt;div(100, 5)&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="d0e9b09948eb0624f11716a9cef62d3abdf92490" translate="yes" xml:space="preserve">
          <source>We go into more details about aliases in the &lt;a href=&quot;#__aliases__/1&quot;&gt;&lt;code&gt;__aliases__/1&lt;/code&gt;&lt;/a&gt; special form documentation.</source>
          <target state="translated">Мы подробно рассмотрим псевдонимы в документации специальной формы &lt;a href=&quot;#__aliases__/1&quot;&gt; &lt;code&gt;__aliases__/1&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="26ed9d733aecb476410b063737c91f243a2791ec" translate="yes" xml:space="preserve">
          <source>We had originally sketched this chapter to come much earlier in the getting started guide. However, we noticed the IO system provides a great opportunity to shed some light on some philosophies and curiosities of Elixir and the</source>
          <target state="translated">Изначально мы зарисовали эту главу гораздо раньше в руководстве по началу работы.Тем не менее,мы заметили,что система ввода-вывода дает прекрасную возможность пролить свет на некоторые философии и любопытства Эликсира и</target>
        </trans-unit>
        <trans-unit id="abb6a95977675490c38034de2d568b04ea2c84a8" translate="yes" xml:space="preserve">
          <source>We have a &lt;a href=&quot;https://elixir-lang.org/learning.html&quot;&gt;Learning&lt;/a&gt; section that suggests books, screencasts, and other resources for learning Elixir and exploring the ecosystem. There are also plenty of Elixir resources out there, like conference talks, open source projects, and other learning material produced by the community.</source>
          <target state="translated">У нас есть раздел &lt;a href=&quot;https://elixir-lang.org/learning.html&quot;&gt;обучения, в&lt;/a&gt; котором предлагаются книги, скринкасты и другие ресурсы для изучения Elixir и изучения экосистемы. Также существует множество ресурсов Elixir, таких как выступления на конференциях, проекты с открытым исходным кодом и другие учебные материалы, созданные сообществом.</target>
        </trans-unit>
        <trans-unit id="b4c0db93e8af0bc00e24de6f1cf4f54858eab97d" translate="yes" xml:space="preserve">
          <source>We have a keyword list of users where each value is a map containing the name, age and a list of programming languages each user likes. If we wanted to access the age for john, we could write:</source>
          <target state="translated">У нас есть список пользователей,где каждое значение представляет собой карту,содержащую имя,возраст и список языков программирования,которые нравятся каждому пользователю.Если бы мы хотели получить доступ к возрасту Джона,мы могли бы написать:</target>
        </trans-unit>
        <trans-unit id="ceb63ee60b61c142c76846224ff6bca160c2c492" translate="yes" xml:space="preserve">
          <source>We have added a new &lt;code&gt;:env&lt;/code&gt; key to the application. It returns the application default environment, which has an entry of key &lt;code&gt;:routing_table&lt;/code&gt; and value of an empty list. It makes sense for the application environment to ship with an empty table, as the specific routing table depends on the testing/deployment structure.</source>
          <target state="translated">Мы добавили в приложение новый ключ &lt;code&gt;:env&lt;/code&gt; . Он возвращает среду приложения по умолчанию, в которой есть запись key &lt;code&gt;:routing_table&lt;/code&gt; и значение пустого списка. Для среды приложения имеет смысл поставляться с пустой таблицей, поскольку конкретная таблица маршрутизации зависит от структуры тестирования / развертывания.</target>
        </trans-unit>
        <trans-unit id="6faaf48e5eb0045eb584e188528f01304e4bbcaf" translate="yes" xml:space="preserve">
          <source>We have already explored &lt;code&gt;config/config.exs&lt;/code&gt;. Now let&amp;rsquo;s talk about &lt;code&gt;rel/env.sh.eex&lt;/code&gt; and then &lt;code&gt;config/releases.exs&lt;/code&gt; before we end this chapter.</source>
          <target state="translated">Мы уже изучили &lt;code&gt;config/config.exs&lt;/code&gt; . Теперь давайте поговорим о &lt;code&gt;rel/env.sh.eex&lt;/code&gt; , а затем о &lt;code&gt;config/releases.exs&lt;/code&gt; , прежде чем мы закончим эту главу.</target>
        </trans-unit>
        <trans-unit id="7d7a2eb3f07da32d273a9a9415d60c537251a582" translate="yes" xml:space="preserve">
          <source>We have already learned that Elixir provides double-quoted strings and single-quoted char lists. However, this only covers the surface of structures that have textual representation in the language. Atoms, for example, are mostly created via the &lt;code&gt;:atom&lt;/code&gt; representation.</source>
          <target state="translated">Мы уже узнали, что Elixir предоставляет строки в двойных кавычках и списки символов в одинарных кавычках. Однако это касается только поверхности структур, которые имеют текстовое представление на языке. Например, атомы в основном создаются с помощью представления &lt;code&gt;:atom&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="55fb07eb508a149a0659b431a989bcd41e036fb6" translate="yes" xml:space="preserve">
          <source>We have also discussed a handful of syntax conveniences provided by Elixir. Those conveniences are what allow us to write</source>
          <target state="translated">Мы также обсудили несколько синтаксических удобств,предоставляемых Elixir.Эти удобства позволяют нам писать.</target>
        </trans-unit>
        <trans-unit id="47ccfa66abec2276c0b7aea39fff20a82601b8d0" translate="yes" xml:space="preserve">
          <source>We have been working inside an application this entire time. Every time we changed a file and ran &lt;code&gt;mix compile&lt;/code&gt;, we could see a &lt;code&gt;Generated kv app&lt;/code&gt; message in the compilation output.</source>
          <target state="translated">Все это время мы работали внутри приложения. Каждый раз, когда мы меняли файл и запускали &lt;code&gt;mix compile&lt;/code&gt; , мы могли видеть сообщение &lt;code&gt;Generated kv app&lt;/code&gt; в выводе компиляции.</target>
        </trans-unit>
        <trans-unit id="396ab1bb827baf3dc86bc047bdb1971b5cf3514a" translate="yes" xml:space="preserve">
          <source>We have first defined a setup callback with the help of the &lt;code&gt;setup/1&lt;/code&gt; macro. The &lt;code&gt;setup/1&lt;/code&gt; macro defines a callback that is run before every test, in the same process as the test itself.</source>
          <target state="translated">Сначала мы определили обратный вызов установки с помощью макроса &lt;code&gt;setup/1&lt;/code&gt; . &lt;code&gt;setup/1&lt;/code&gt; макро определяет функцию обратного вызова, которая выполняется перед каждым испытанием, в том же самом процессе, что и сам тест.</target>
        </trans-unit>
        <trans-unit id="2e606875ff28c66f71d4da69c2e95037af1ac13f" translate="yes" xml:space="preserve">
          <source>We have just scratched the surface of what the Erlang VM has to offer, for example:</source>
          <target state="translated">Мы только что поцарапали поверхность того,что Erlang VM может предложить,например:</target>
        </trans-unit>
        <trans-unit id="15f26f69ec0440b784420ca2d8178fe6d168ad64" translate="yes" xml:space="preserve">
          <source>We have learned about agents, generic servers, and supervisors. They are all meant to work with multiple messages or manage state. But what do we use when we only need to execute some task and that is it?</source>
          <target state="translated">Мы узнали об агентах,общих серверах и супервайзерах.Все они предназначены для работы с несколькими сообщениями или для управления состоянием.Но что мы используем,когда нам нужно только выполнить какую-то задачу и все?</target>
        </trans-unit>
        <trans-unit id="4509fc7814603728df2ad623d4a1467453b70745" translate="yes" xml:space="preserve">
          <source>We have now successfully defined our supervisor which is automatically started (and stopped) as part of our application lifecycle.</source>
          <target state="translated">Теперь мы успешно определили нашего супервайзера,который автоматически запускается (и останавливается)как часть жизненного цикла нашего приложения.</target>
        </trans-unit>
        <trans-unit id="14bb9ad8c190c5b506299dbc844613b7db04c78f" translate="yes" xml:space="preserve">
          <source>We have previously learned about links in the &lt;a href=&quot;../processes&quot;&gt;Process chapter&lt;/a&gt;. Now, with the registry complete, you may be wondering: when should we use monitors and when should we use links?</source>
          <target state="translated">Ранее мы узнали о ссылках в &lt;a href=&quot;../processes&quot;&gt;главе &amp;laquo;Процесс&amp;raquo;&lt;/a&gt; . Теперь, когда реестр завершен, вы можете задаться вопросом: когда мы должны использовать мониторы, а когда - ссылки?</target>
        </trans-unit>
        <trans-unit id="24edfa5902db50de9858abd9fd5d24f337e28c2e" translate="yes" xml:space="preserve">
          <source>We have used the &lt;code&gt;=&lt;/code&gt; operator a couple times to assign variables in Elixir:</source>
          <target state="translated">Мы пару раз использовали оператор &lt;code&gt;=&lt;/code&gt; для присвоения переменных в Elixir:</target>
        </trans-unit>
        <trans-unit id="6f4f1a86e1887aa923d4b1e6c0eb9cb96b8624f4" translate="yes" xml:space="preserve">
          <source>We have written a guide that covers how to build an Elixir application, with its own supervision tree, configuration, tests, and more. The application works as a distributed key-value store where we organize key-value pairs into buckets and distribute those buckets across multiple nodes:</source>
          <target state="translated">Мы написали руководство,которое описывает,как построить приложение Elixir,с его собственным деревом управления,конфигурацией,тестами и многим другим.Приложение работает в качестве распределенного хранилища значений ключей,где мы организуем пары значений ключей в ведра и распределяем эти ведра по нескольким узлам:</target>
        </trans-unit>
        <trans-unit id="2161ef9aca87ca65355a4bfdacd38ac5d5a332ef" translate="yes" xml:space="preserve">
          <source>We have written extensive documentation on releases, so &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Release.html&quot;&gt;please check the official docs for more information&lt;/a&gt;. For now, we will continue exploring some of the features outlined above.</source>
          <target state="translated">Мы написали обширную документацию по выпускам, поэтому, &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Release.html&quot;&gt;пожалуйста, проверьте официальную документацию для получения дополнительной информации&lt;/a&gt; . На данный момент мы продолжим изучение некоторых функций, описанных выше.</target>
        </trans-unit>
        <trans-unit id="ac7652b3d4ad00e46453485a36d0a78622bc002f" translate="yes" xml:space="preserve">
          <source>We haven&amp;rsquo;t talked about state so far in this guide. If you are building an application that requires state, for example, to keep your application configuration, or you need to parse a file and keep it in memory, where would you store it?</source>
          <target state="translated">Мы еще не говорили о состоянии в этом руководстве. Если вы создаете приложение, которому требуется состояние, например, для сохранения конфигурации приложения, или вам нужно проанализировать файл и сохранить его в памяти, где бы вы его сохранили?</target>
        </trans-unit>
        <trans-unit id="3cfb66e1e45957f5152798168f2eef8b31f8d6a5" translate="yes" xml:space="preserve">
          <source>We hope this section shines some light on how Elixir supports meta-programming and how module attributes play an important role when doing so.</source>
          <target state="translated">Мы надеемся,что этот раздел прольет некоторый свет на то,как Elixir поддерживает мета-программирование и как атрибуты модуля играют важную роль при этом.</target>
        </trans-unit>
        <trans-unit id="5db8d9d324805b7a0536eb75c0e583101345dd6f" translate="yes" xml:space="preserve">
          <source>We imported only the function &lt;code&gt;duplicate&lt;/code&gt; (with arity 2) from &lt;code&gt;List&lt;/code&gt;. Although &lt;code&gt;:only&lt;/code&gt; is optional, its usage is recommended in order to avoid importing all the functions of a given module inside the current scope. &lt;code&gt;:except&lt;/code&gt; could also be given as an option in order to import everything in a module &lt;em&gt;except&lt;/em&gt; a list of functions.</source>
          <target state="translated">Мы импортировали только &lt;code&gt;duplicate&lt;/code&gt; функции (с арностью 2) из &lt;code&gt;List&lt;/code&gt; . Хотя &lt;code&gt;:only&lt;/code&gt; является необязательным, его использование рекомендуется, чтобы избежать импорта всех функций данного модуля внутри текущей области. &lt;code&gt;:except&lt;/code&gt; также можно указать в качестве опции для импорта всего в модуле, &lt;em&gt;кроме&lt;/em&gt; списка функций.</target>
        </trans-unit>
        <trans-unit id="ca020b3dd04bced732b9a88d32d9d8b560a99be0" translate="yes" xml:space="preserve">
          <source>We invoke &lt;code&gt;KV.Registry.create(registry, &quot;shopping&quot;)&lt;/code&gt;</source>
          <target state="translated">Вызываем &lt;code&gt;KV.Registry.create(registry, &quot;shopping&quot;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8c6e2f5ac3f7b1e14e21331e0191301fcc7de6cb" translate="yes" xml:space="preserve">
          <source>We invoke &lt;code&gt;sum_list&lt;/code&gt; with the list &lt;code&gt;[1, 2, 3]&lt;/code&gt; and the initial value &lt;code&gt;0&lt;/code&gt; as arguments. We will try each clause until we find one that matches according to the pattern matching rules. In this case, the list &lt;code&gt;[1, 2, 3]&lt;/code&gt; matches against &lt;code&gt;[head | tail]&lt;/code&gt; which binds &lt;code&gt;head&lt;/code&gt; to &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;tail&lt;/code&gt; to &lt;code&gt;[2, 3]&lt;/code&gt;; &lt;code&gt;accumulator&lt;/code&gt; is set to &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">Мы вызываем &lt;code&gt;sum_list&lt;/code&gt; со списком &lt;code&gt;[1, 2, 3]&lt;/code&gt; и начальным значением &lt;code&gt;0&lt;/code&gt; в качестве аргументов. Мы будем пробовать каждое предложение, пока не найдем то, которое соответствует правилам сопоставления с образцом. В этом случае список &lt;code&gt;[1, 2, 3]&lt;/code&gt; совпадает с &lt;code&gt;[head | tail]&lt;/code&gt; , который связывает &lt;code&gt;head&lt;/code&gt; с &lt;code&gt;1&lt;/code&gt; и &lt;code&gt;tail&lt;/code&gt; с &lt;code&gt;[2, 3]&lt;/code&gt; ; &lt;code&gt;accumulator&lt;/code&gt; установлен на &lt;code&gt;0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="caa4d8b87080c8f65cf48ef405dc69b67880c9f6" translate="yes" xml:space="preserve">
          <source>We need a way to configure the application environment. That&amp;rsquo;s when we use configuration files.</source>
          <target state="translated">Нам нужен способ настройки среды приложения. Вот когда мы используем файлы конфигурации.</target>
        </trans-unit>
        <trans-unit id="21270ac8203266757e479f248d45aea726769f54" translate="yes" xml:space="preserve">
          <source>We now need to modify &lt;code&gt;apps/kv/mix.exs&lt;/code&gt; to contain the umbrella entries we have seen in &lt;code&gt;apps/kv_server/mix.exs&lt;/code&gt;. Open up &lt;code&gt;apps/kv/mix.exs&lt;/code&gt; and add to the &lt;code&gt;project/0&lt;/code&gt; function:</source>
          <target state="translated">Теперь нам нужно изменить &lt;code&gt;apps/kv/mix.exs&lt;/code&gt; , чтобы они содержали зонтичные записи, которые мы видели в &lt;code&gt;apps/kv_server/mix.exs&lt;/code&gt; . Откройте &lt;code&gt;apps/kv/mix.exs&lt;/code&gt; и добавьте в &lt;code&gt;project/0&lt;/code&gt; функцию:</target>
        </trans-unit>
        <trans-unit id="4ff92ba25991ab6c2fa4457781ea94da9200ddeb" translate="yes" xml:space="preserve">
          <source>We recommend developers to format code directly in their editors, either automatically when saving a file or via an explicit command or key binding. If such option is not yet available in your editor of choice, adding the required integration is usually a matter of invoking:</source>
          <target state="translated">Мы рекомендуем разработчикам форматировать код непосредственно в своих редакторах,либо автоматически при сохранении файла,либо с помощью явной команды или привязки ключей.Если такая опция еще недоступна в выбранном вами редакторе,то добавление требуемой интеграции обычно является вызовом:</target>
        </trans-unit>
        <trans-unit id="0dfaef79b3bc9bce4f06cff718fb2cc10713dc31" translate="yes" xml:space="preserve">
          <source>We recommend that developers include examples in their documentation, often under their own &lt;code&gt;## Examples&lt;/code&gt; heading. To ensure examples do not get out of date, Elixir's test framework (ExUnit) provides a feature called doctests that allows developers to test the examples in their documentation. Doctests work by parsing out code samples starting with &lt;code&gt;iex&amp;gt;&lt;/code&gt; from the documentation. You can read more about it at &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.DocTest.html&quot;&gt;&lt;code&gt;ExUnit.DocTest&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Мы рекомендуем разработчикам включать примеры в свою документацию, часто под собственным заголовком &lt;code&gt;## Examples&lt;/code&gt; . Чтобы примеры не устарели, среда тестирования Elixir (ExUnit) предоставляет функцию, называемую doctests, которая позволяет разработчикам тестировать примеры в своей документации. Доктесты работают путем разбора примеров кода, начинающихся с &lt;code&gt;iex&amp;gt;&lt;/code&gt; из документации. Вы можете прочитать об этом на &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.DocTest.html&quot;&gt; &lt;code&gt;ExUnit.DocTest&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="087bb5b14c43d71b4effe4bdb7e80e24f491682e" translate="yes" xml:space="preserve">
          <source>We recommend using this feature with care, especially library authors. Deprecating code always pushes the burden towards library users. We also recommend for deprecated functionality to be maintained for long periods of time, even after deprecation, giving developers plenty of time to update (except for cases where keeping the deprecated API is undesired, such as in the presence of security issues).</source>
          <target state="translated">Мы рекомендуем использовать эту функцию с осторожностью,особенно авторам библиотек.Уменьшение количества кода всегда ложится тяжелым бременем на пользователей библиотеки.Мы также рекомендуем поддерживать устаревший функционал в течение длительного времени,даже после устаревания,давая разработчикам достаточно времени на обновление (за исключением случаев,когда хранение устаревшего API нежелательно,например,при наличии проблем с безопасностью).</target>
        </trans-unit>
        <trans-unit id="6f1255542381e555547beb22c662294ad2acd1e4" translate="yes" xml:space="preserve">
          <source>We say that functions that point to definitions residing in modules, such as &lt;code&gt;&amp;amp;String.length/1&lt;/code&gt;, are &lt;strong&gt;external&lt;/strong&gt; functions. All other functions are &lt;strong&gt;local&lt;/strong&gt; and they are always bound to the file or module that defined them.</source>
          <target state="translated">Мы говорим, что функции, которые указывают на определения, находящиеся в модулях, например &lt;code&gt;&amp;amp;String.length/1&lt;/code&gt; , являются &lt;strong&gt;внешними&lt;/strong&gt; функциями. Все остальные функции являются &lt;strong&gt;локальными&lt;/strong&gt; и всегда привязаны к файлу или модулю, который их определил.</target>
        </trans-unit>
        <trans-unit id="0bbc774ddec41a7d4c86b05aa27b1e75ab2f1cd6" translate="yes" xml:space="preserve">
          <source>We say the functions in the &lt;code&gt;Enum&lt;/code&gt; module are polymorphic because they can work with diverse data types. In particular, the functions in the &lt;code&gt;Enum&lt;/code&gt; module can work with any data type that implements &lt;a href=&quot;https://hexdocs.pm/elixir/Enumerable.html&quot;&gt;the &lt;code&gt;Enumerable&lt;/code&gt; protocol&lt;/a&gt;. We are going to discuss Protocols in a later chapter; for now we are going to move on to a specific kind of enumerable called a stream.</source>
          <target state="translated">Мы говорим, что функции в модуле &lt;code&gt;Enum&lt;/code&gt; полиморфны, потому что они могут работать с различными типами данных. В частности, функции в &lt;code&gt;Enum&lt;/code&gt; модуль может работать с любым типом данных , который реализует &lt;a href=&quot;https://hexdocs.pm/elixir/Enumerable.html&quot;&gt; &lt;code&gt;Enumerable&lt;/code&gt; &lt;/a&gt; протокола . Мы собираемся обсудить протоколы в следующей главе; сейчас мы собираемся перейти к определенному виду перечислимого типа, называемому потоком.</target>
        </trans-unit>
        <trans-unit id="3cb3b686e4a2ae3801a38f4de17970115ff08932" translate="yes" xml:space="preserve">
          <source>We start our &lt;code&gt;Stack&lt;/code&gt; by calling &lt;a href=&quot;#start_link/2&quot;&gt;&lt;code&gt;start_link/2&lt;/code&gt;&lt;/a&gt;, passing the module with the server implementation and its initial argument (a list representing the stack containing the element &lt;code&gt;:hello&lt;/code&gt;). We can primarily interact with the server by sending two types of messages. &lt;strong&gt;call&lt;/strong&gt; messages expect a reply from the server (and are therefore synchronous) while &lt;strong&gt;cast&lt;/strong&gt; messages do not.</source>
          <target state="translated">Мы начинаем наш &lt;code&gt;Stack&lt;/code&gt; с вызова &lt;a href=&quot;#start_link/2&quot;&gt; &lt;code&gt;start_link/2&lt;/code&gt; &lt;/a&gt; , передавая модуль с реализацией сервера и его начальным аргументом (список, представляющий стек, содержащий элемент &lt;code&gt;:hello&lt;/code&gt; ). В первую очередь мы можем взаимодействовать с сервером, отправляя два типа сообщений. &lt;strong&gt;вызов&lt;/strong&gt; сообщения ожидать ответ от сервера (и, следовательно , синхронный) , а &lt;strong&gt;литые&lt;/strong&gt; сообщений нет.</target>
        </trans-unit>
        <trans-unit id="ddbe0723f5169f8ebd3cc159b9dc24e024e26706" translate="yes" xml:space="preserve">
          <source>We started an agent with an initial state of an empty list. We updated the agent&amp;rsquo;s state, adding our new item to the head of the list. The second argument of &lt;a href=&quot;https://hexdocs.pm/elixir/Agent.html#update/3&quot;&gt;&lt;code&gt;Agent.update/3&lt;/code&gt;&lt;/a&gt; is a function that takes the agent&amp;rsquo;s current state as input and returns its desired new state. Finally, we retrieved the whole list. The second argument of &lt;a href=&quot;https://hexdocs.pm/elixir/Agent.html#get/3&quot;&gt;&lt;code&gt;Agent.get/3&lt;/code&gt;&lt;/a&gt; is a function that takes the state as input and returns the value that &lt;a href=&quot;https://hexdocs.pm/elixir/Agent.html#get/3&quot;&gt;&lt;code&gt;Agent.get/3&lt;/code&gt;&lt;/a&gt; itself will return. Once we are done with the agent, we can call &lt;a href=&quot;https://hexdocs.pm/elixir/Agent.html#stop/3&quot;&gt;&lt;code&gt;Agent.stop/3&lt;/code&gt;&lt;/a&gt; to terminate the agent process.</source>
          <target state="translated">Мы запустили агент с начальным состоянием пустого списка. Мы обновили состояние агента, добавив наш новый элемент в начало списка. Второй аргумент &lt;a href=&quot;https://hexdocs.pm/elixir/Agent.html#update/3&quot;&gt; &lt;code&gt;Agent.update/3&lt;/code&gt; &lt;/a&gt; - это функция, которая принимает текущее состояние агента в качестве входных данных и возвращает желаемое новое состояние. Наконец, мы получили весь список. Второй аргумент &lt;a href=&quot;https://hexdocs.pm/elixir/Agent.html#get/3&quot;&gt; &lt;code&gt;Agent.get/3&lt;/code&gt; &lt;/a&gt; - это функция, которая принимает состояние в качестве входных данных и возвращает значение, которое &lt;a href=&quot;https://hexdocs.pm/elixir/Agent.html#get/3&quot;&gt; &lt;code&gt;Agent.get/3&lt;/code&gt; &lt;/a&gt; сам Agent.get / 3 . Когда мы закончим с агентом, мы можем вызвать &lt;a href=&quot;https://hexdocs.pm/elixir/Agent.html#stop/3&quot;&gt; &lt;code&gt;Agent.stop/3&lt;/code&gt; ,&lt;/a&gt; чтобы завершить процесс агента.</target>
        </trans-unit>
        <trans-unit id="f6533bed650e28deb96da306d0ae21f387c7b715" translate="yes" xml:space="preserve">
          <source>We use &lt;code&gt;Application.fetch_env!/2&lt;/code&gt; to read the entry for &lt;code&gt;:routing_table&lt;/code&gt; in &lt;code&gt;:kv&lt;/code&gt;&amp;rsquo;s environment. You can find more information and other functions to manipulate the app environment in the &lt;a href=&quot;https://hexdocs.pm/elixir/Application.html&quot;&gt;Application module&lt;/a&gt;.</source>
          <target state="translated">Мы используем &lt;code&gt;Application.fetch_env!/2&lt;/code&gt; для чтения записи для &lt;code&gt;:routing_table&lt;/code&gt; в среде &lt;code&gt;:kv&lt;/code&gt; . Вы можете найти дополнительную информацию и другие функции для управления средой &lt;a href=&quot;https://hexdocs.pm/elixir/Application.html&quot;&gt;приложения в модуле Application&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4b34e4fa7e16cf3c414475f0eea7eea9ff1ca2d5" translate="yes" xml:space="preserve">
          <source>We use &lt;code&gt;import&lt;/code&gt; whenever we want to access functions or macros from other modules without using the fully-qualified name. Note we can only import public functions, as private functions are never accessible externally.</source>
          <target state="translated">Мы используем &lt;code&gt;import&lt;/code&gt; всякий раз, когда хотим получить доступ к функциям или макросам из других модулей без использования полного имени. Обратите внимание, что мы можем импортировать только общедоступные функции, поскольку частные функции никогда не доступны извне.</target>
        </trans-unit>
        <trans-unit id="29bdab7cfe0856e731211b24f42d38f56fc4cbfb" translate="yes" xml:space="preserve">
          <source>We use &lt;code&gt;import&lt;/code&gt; whenever we want to easily access functions or macros from other modules without using the fully-qualified name. For instance, if we want to use the &lt;code&gt;duplicate/2&lt;/code&gt; function from the &lt;code&gt;List&lt;/code&gt; module several times, we can import it:</source>
          <target state="translated">Мы используем &lt;code&gt;import&lt;/code&gt; всякий раз, когда хотим легко получить доступ к функциям или макросам из других модулей без использования полного имени. Например, если мы хотим использовать функцию &lt;code&gt;duplicate/2&lt;/code&gt; из модуля &lt;code&gt;List&lt;/code&gt; несколько раз, мы можем импортировать ее:</target>
        </trans-unit>
        <trans-unit id="1c85e6a1770769aa75641d4a9816aeb703d170de" translate="yes" xml:space="preserve">
          <source>We will explore most of these abstractions in this guide. Keep in mind that they are all implemented on top of processes using the basic features provided by the</source>
          <target state="translated">Мы рассмотрим большинство из этих абстракций в этом руководстве.Имейте в виду,что все они реализованы поверх процессов,используя основные возможности,предоставляемые в</target>
        </trans-unit>
        <trans-unit id="655e75f17c147831957b0f1ca8d40311ebda7698" translate="yes" xml:space="preserve">
          <source>We will explore the valid switches and operation modes of option parser below.</source>
          <target state="translated">Ниже мы рассмотрим действительные переключатели и режимы работы парсера опций.</target>
        </trans-unit>
        <trans-unit id="77cd8cf79452e8ce8626f2aa6a0bdf3ee709792b" translate="yes" xml:space="preserve">
          <source>We will explore those functionalities in the &lt;strong&gt;&lt;em&gt;Mix and OTP guide&lt;/em&gt;&lt;/strong&gt;, for now it is enough to remember to use &lt;code&gt;Task&lt;/code&gt; to get better error reports.</source>
          <target state="translated">Мы рассмотрим эти функции в руководстве &lt;strong&gt;&lt;em&gt;Mix and OTP&lt;/em&gt;&lt;/strong&gt; , а пока достаточно не забыть использовать &lt;code&gt;Task&lt;/code&gt; , чтобы получать более точные отчеты об ошибках.</target>
        </trans-unit>
        <trans-unit id="2744540fd7a20a87da7f1caa4830e0d61e9163cc" translate="yes" xml:space="preserve">
          <source>We will learn those details as we move forward on this guide. If you would rather peek ahead, check the &lt;a href=&quot;https://hexdocs.pm/elixir/Supervisor.html&quot;&gt;Supervisor&lt;/a&gt; docs.</source>
          <target state="translated">Мы узнаем эти детали по мере продвижения этого руководства. Если вы предпочитаете заглянуть вперед, посмотрите документацию &lt;a href=&quot;https://hexdocs.pm/elixir/Supervisor.html&quot;&gt;Supervisor&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7e6401949917ccd9b1dc37503a9619e2473c15e8" translate="yes" xml:space="preserve">
          <source>We will leave it up to you to further explore what Observer provides. Note you can double click any process in the supervision tree to retrieve more information about it, as well as right-click a process to send &amp;ldquo;a kill signal&amp;rdquo;, a perfect way to emulate failures and see if your supervisor reacts as expected.</source>
          <target state="translated">Мы предоставим вам возможность продолжить изучение того, что предлагает Observer. Обратите внимание, что вы можете дважды щелкнуть любой процесс в дереве надзора, чтобы получить дополнительную информацию о нем, а также щелкнуть процесс правой кнопкой мыши, чтобы отправить &amp;laquo;сигнал аннулирования&amp;raquo; - идеальный способ имитировать сбои и посмотреть, отреагирует ли ваш супервизор должным образом.</target>
        </trans-unit>
        <trans-unit id="0d6c2ae825cac9f0996d30218558edf03d9af98b" translate="yes" xml:space="preserve">
          <source>We will start our TCP server by first implementing an echo server. It will send a response with the text it received in the request. We will slowly improve our server until it is supervised and ready to handle multiple connections.</source>
          <target state="translated">Мы запустим наш TCP сервер,сначала внедрив эхо-сервер.Он отправит ответ с текстом,который он получил в запросе.Мы будем медленно улучшать наш сервер до тех пор,пока он не будет находиться под наблюдением и не будет готов к обработке нескольких соединений.</target>
        </trans-unit>
        <trans-unit id="fac2f5448b956d8da6564df88e205c307d9c5cdf" translate="yes" xml:space="preserve">
          <source>We will use a &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt;GenServer&lt;/a&gt; to create a registry process that can monitor the bucket processes. GenServer provides industrial strength functionality for building servers in both Elixir and</source>
          <target state="translated">Мы будем использовать &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt;GenServer&lt;/a&gt; для создания процесса реестра, который может отслеживать процессы корзины . GenServer предоставляет функциональные возможности промышленного уровня для создания серверов как в Elixir, так и в</target>
        </trans-unit>
        <trans-unit id="e79c1e292f9f25087d286b398c91b461d6dcecd5" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll now start a &lt;a href=&quot;https://hexdocs.pm/elixir/Task.Supervisor.html&quot;&gt;&lt;code&gt;Task.Supervisor&lt;/code&gt;&lt;/a&gt; process with name &lt;code&gt;KVServer.TaskSupervisor&lt;/code&gt;. Remember, since the acceptor task depends on this supervisor, the supervisor must be started first.</source>
          <target state="translated">Теперь мы &lt;a href=&quot;https://hexdocs.pm/elixir/Task.Supervisor.html&quot;&gt; &lt;code&gt;Task.Supervisor&lt;/code&gt; &lt;/a&gt; процесс Task.Supervisor с именем &lt;code&gt;KVServer.TaskSupervisor&lt;/code&gt; . Помните, поскольку задача приемника зависит от этого супервизора, супервизор должен быть запущен первым.</target>
        </trans-unit>
        <trans-unit id="ed0bddf403cdfbbcbd68216aea7a440098df2a8b" translate="yes" xml:space="preserve">
          <source>Welcome to Interactive Elixir. You are currently seeing the documentation for the module &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;IEx.Helpers&lt;/code&gt;&lt;/a&gt; which provides many helpers to make Elixir's shell more joyful to work with.</source>
          <target state="translated">Добро пожаловать в Interactive Elixir. В настоящее время вы просматриваете документацию по модулю &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;IEx.Helpers&lt;/code&gt; ,&lt;/a&gt; который предоставляет множество помощников, которые делают работу с оболочкой Elixir более приятной .</target>
        </trans-unit>
        <trans-unit id="e52e5e6cd50ef4de30d8a4fafbbfab41180cc200" translate="yes" xml:space="preserve">
          <source>Welcome!</source>
          <target state="translated">Welcome!</target>
        </trans-unit>
        <trans-unit id="1799caf9108a397466713ff5adb66927a4ad613e" translate="yes" xml:space="preserve">
          <source>What Every Programmer Should Know About Floating-Point Arithmetic</source>
          <target state="translated">Что каждый программист должен знать об арифметике с плавающими точками</target>
        </trans-unit>
        <trans-unit id="10f3a323d59ed1bc1fd18a9f06ddd91ca9d23324" translate="yes" xml:space="preserve">
          <source>What happens if we intentionally crash the registry started by the supervisor? Let&amp;rsquo;s do so by sending it a bad input on &lt;code&gt;call&lt;/code&gt;:</source>
          <target state="translated">Что произойдет, если мы намеренно разрушим реестр, запущенный супервизором? Давайте сделаем это, отправив ему неверный ввод по &lt;code&gt;call&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="b4b3256dbcacb22b4f6f01d2dfc0f210fb7bb580" translate="yes" xml:space="preserve">
          <source>What if we instead want to double all of the values in our list?</source>
          <target state="translated">Что,если вместо этого мы захотим удвоить все значения в нашем списке?</target>
        </trans-unit>
        <trans-unit id="109be0146bc5ad53b41b5fd51afbc9a73fd08edc" translate="yes" xml:space="preserve">
          <source>What is happening in our tests is that there is a delay in between an operation and the time we can observe this change in the ETS table. Here is what we were expecting to happen:</source>
          <target state="translated">В наших тестах происходит задержка между операцией и временем,которое мы можем наблюдать за этим изменением в таблице ETS.Вот чего мы ожидали:</target>
        </trans-unit>
        <trans-unit id="3e0d544d961c62170b13c4585da0fcb18fc3b9d1" translate="yes" xml:space="preserve">
          <source>What is the difference between lists and tuples?</source>
          <target state="translated">В чем разница между списками и кортежами?</target>
        </trans-unit>
        <trans-unit id="7aa70b85a229c070639a64a641a35f6f1bc6adf0" translate="yes" xml:space="preserve">
          <source>What makes &lt;code&gt;IO.inspect(item, opts \\ [])&lt;/code&gt; really useful in debugging is that it returns the &lt;code&gt;item&lt;/code&gt; argument passed to it without affecting the behavior of the original code. Let&amp;rsquo;s see an example.</source>
          <target state="translated">Что делает &lt;code&gt;IO.inspect(item, opts \\ [])&lt;/code&gt; действительно полезным при отладке, так это то, что он возвращает переданный ему аргумент &lt;code&gt;item&lt;/code&gt; не влияя на поведение исходного кода. Посмотрим на пример.</target>
        </trans-unit>
        <trans-unit id="f36299b12fc4f2e628757870a035b1b926aeb78d" translate="yes" xml:space="preserve">
          <source>What makes this project different from the previous one is the &lt;code&gt;apps_path: &quot;apps&quot;&lt;/code&gt; entry in the project definition. This means this project will act as an umbrella. Such projects do not have source files nor tests, although they can have their own dependencies. Each child application must be defined inside the &lt;code&gt;apps&lt;/code&gt; directory.</source>
          <target state="translated">Что отличает этот проект от предыдущего, так это &lt;code&gt;apps_path: &quot;apps&quot;&lt;/code&gt; в определении проекта. Это означает, что этот проект будет действовать как зонтик. У таких проектов нет исходных файлов и тестов, хотя у них могут быть свои зависимости. Каждое дочернее приложение должно быть определено в каталоге &lt;code&gt;apps&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b82b16926c1c401c50c5de43260d7d6bfd15f1dd" translate="yes" xml:space="preserve">
          <source>When (not) to use a GenServer</source>
          <target state="translated">Когда (не)использовать GenServer.</target>
        </trans-unit>
        <trans-unit id="31fa4a4dcc6a8a3b88863b4f81efd1e668262ac2" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;--callers&lt;/code&gt; option is specified, you'll see expanded function entries:</source>
          <target state="translated">Когда &lt;code&gt;--callers&lt;/code&gt; опция --callers , вы увидите расширенные записи функций:</target>
        </trans-unit>
        <trans-unit id="a913347a3c3c1ca9dc541c0a9cdbc7194c7830d0" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;--matching&lt;/code&gt; option is specified, call count tracing will be started only for the functions matching the given pattern:</source>
          <target state="translated">Когда &lt;code&gt;--matching&lt;/code&gt; опция --matching , трассировка счетчика вызовов будет запущена только для функций, соответствующих данному шаблону:</target>
        </trans-unit>
        <trans-unit id="8cf2de6f867864816f104de4c60eca50d53d89da" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;.&lt;/code&gt; is used, the quoted expression may take two distinct forms. When the right side starts with a lowercase letter (or underscore):</source>
          <target state="translated">Когда &lt;code&gt;.&lt;/code&gt; цитируемое выражение может принимать две различные формы. Когда правая сторона начинается со строчной буквы (или подчеркивания):</target>
        </trans-unit>
        <trans-unit id="b4028a2b288952e3e42b96883be10dac26bd36b0" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;:as_binaries&lt;/code&gt; all binaries will be printed in bit syntax.</source>
          <target state="translated">Когда &lt;code&gt;:as_binaries&lt;/code&gt; все двоичные файлы будут напечатаны в битовом синтаксисе.</target>
        </trans-unit>
        <trans-unit id="1cc116635ec80ef3ca62f754c296f6eef7bdca49" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;:as_lists&lt;/code&gt; all lists will be printed as lists.</source>
          <target state="translated">Когда &lt;code&gt;:as_lists&lt;/code&gt; все списки будут напечатаны как списки.</target>
        </trans-unit>
        <trans-unit id="1cc9bb46f3caa84520a3157eaff6cdeba1575931" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;:as_lists&lt;/code&gt; all lists will be printed as lists. When the default &lt;code&gt;:infer&lt;/code&gt;, the list will be printed as a charlist if it is printable, otherwise as list. See &lt;a href=&quot;https://hexdocs.pm/elixir/List.html#ascii_printable?/1&quot;&gt;&lt;code&gt;List.ascii_printable?/1&lt;/code&gt;&lt;/a&gt; to learn when a charlist is printable.</source>
          <target state="translated">Когда &lt;code&gt;:as_lists&lt;/code&gt; все списки будут напечатаны как списки. Если по умолчанию &lt;code&gt;:infer&lt;/code&gt; , список будет напечатан как список символов, если он доступен для печати, иначе как список. См. &lt;a href=&quot;https://hexdocs.pm/elixir/List.html#ascii_printable?/1&quot;&gt; &lt;code&gt;List.ascii_printable?/1&lt;/code&gt; ,&lt;/a&gt; чтобы узнать, когда список символов доступен для печати.</target>
        </trans-unit>
        <trans-unit id="b9fad7032d779243cba5fca339e22e9c32fa0f02" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;:as_strings&lt;/code&gt; all binaries will be printed as strings, non-printable bytes will be escaped. When the default &lt;code&gt;:infer&lt;/code&gt;, the binary will be printed as a string if it is printable, otherwise in bit syntax. See &lt;a href=&quot;https://hexdocs.pm/elixir/String.html#printable?/1&quot;&gt;&lt;code&gt;String.printable?/1&lt;/code&gt;&lt;/a&gt; to learn when a string is printable.</source>
          <target state="translated">Когда &lt;code&gt;:as_strings&lt;/code&gt; все двоичные файлы будут напечатаны как строки, непечатаемые байты будут экранированы. Если по умолчанию &lt;code&gt;:infer&lt;/code&gt; , двоичный файл будет напечатан в виде строки, если он доступен для печати, иначе в битовом синтаксисе. См. &lt;a href=&quot;https://hexdocs.pm/elixir/String.html#printable?/1&quot;&gt; &lt;code&gt;String.printable?/1&lt;/code&gt; ,&lt;/a&gt; чтобы узнать, когда строка пригодна для печати.</target>
        </trans-unit>
        <trans-unit id="15ecc670260c21fbdb9e392dbf128e78e186fc91" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;count&lt;/code&gt; is less than or equal to the length of &lt;code&gt;string&lt;/code&gt;, given &lt;code&gt;string&lt;/code&gt; is returned.</source>
          <target state="translated">Если &lt;code&gt;count&lt;/code&gt; меньше или равно длине &lt;code&gt;string&lt;/code&gt; , возвращается заданная &lt;code&gt;string&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="de4bdfc3290cc111eb68b82c9dd61f9600de60e9" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;fun&lt;/code&gt; is an anonymous function (that is, the type is &lt;code&gt;:local&lt;/code&gt;), the following additional keys are returned:</source>
          <target state="translated">Когда &lt;code&gt;fun&lt;/code&gt; является анонимной функцией (то есть тип &lt;code&gt;:local&lt;/code&gt; ), возвращаются следующие дополнительные ключи:</target>
        </trans-unit>
        <trans-unit id="223d25fb9e9e50ec86e6ed90ff88e7fffae68789" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;key&lt;/code&gt; exists in the given structure &lt;code&gt;data&lt;/code&gt;, the implementation should return a &lt;code&gt;{value, new_data}&lt;/code&gt; tuple where &lt;code&gt;value&lt;/code&gt; is the value that was under &lt;code&gt;key&lt;/code&gt; and &lt;code&gt;new_data&lt;/code&gt; is &lt;code&gt;term&lt;/code&gt; without &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">Когда &lt;code&gt;key&lt;/code&gt; существует в данной структуре &lt;code&gt;data&lt;/code&gt; , реализация должна возвращать &lt;code&gt;{value, new_data}&lt;/code&gt; кортеж , где &lt;code&gt;value&lt;/code&gt; является значением , которое находилось под &lt;code&gt;key&lt;/code&gt; и &lt;code&gt;new_data&lt;/code&gt; является &lt;code&gt;term&lt;/code&gt; без &lt;code&gt;key&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2a92494a01e974bc8479461c1fc150f473313415" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;key&lt;/code&gt; is not present in the given structure, a tuple &lt;code&gt;{value, data}&lt;/code&gt; should be returned, where &lt;code&gt;value&lt;/code&gt; is implementation-defined.</source>
          <target state="translated">Когда &lt;code&gt;key&lt;/code&gt; отсутствует в данной структуре, должен быть возвращен кортеж &lt;code&gt;{value, data}&lt;/code&gt; , где &lt;code&gt;value&lt;/code&gt; определяется реализацией.</target>
        </trans-unit>
        <trans-unit id="751c73460ace84cb9cb3af5ec88b007db2f0f157" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;mix xref graph&lt;/code&gt; runs, it will print a tree of the following format:</source>
          <target state="translated">При &lt;code&gt;mix xref graph&lt;/code&gt; будет напечатано дерево следующего формата:</target>
        </trans-unit>
        <trans-unit id="cae3aec565b8ce2ce0cbf8d86303e42f595da844" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;print_multiple_times/2&lt;/code&gt; is initially called in the example above, the argument &lt;code&gt;n&lt;/code&gt; is equal to &lt;code&gt;3&lt;/code&gt;.</source>
          <target state="translated">Когда &lt;code&gt;print_multiple_times/2&lt;/code&gt; первоначально вызывается в приведенном выше примере, аргумент &lt;code&gt;n&lt;/code&gt; равен &lt;code&gt;3&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a9eb4663dc0fbb999edc597d05f93217c9f5e912" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;some_fun/3&lt;/code&gt; is invoked with &lt;code&gt;:foo&lt;/code&gt;, &lt;code&gt;&quot;bar&quot;&lt;/code&gt;, &lt;code&gt;:baz&lt;/code&gt; it prints:</source>
          <target state="translated">Когда &lt;code&gt;some_fun/3&lt;/code&gt; вызывается с &lt;code&gt;:foo&lt;/code&gt; , &lt;code&gt;&quot;bar&quot;&lt;/code&gt; , &lt;code&gt;:baz&lt;/code&gt; печатает:</target>
        </trans-unit>
        <trans-unit id="881e0ddf18fdf0b8e18f1c5c2fb76ebfa4a0d4e8" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;static_atom_encoder: &amp;amp;my_encoder/2&lt;/code&gt; is passed as an argument, &lt;code&gt;my_encoder/2&lt;/code&gt; is called every time the tokenizer needs to create a &quot;static&quot; atom. Static atoms are atoms in the AST that function as aliases, remote calls, local calls, variable names, regular atoms and keyword lists.</source>
          <target state="translated">Когда &lt;code&gt;static_atom_encoder: &amp;amp;my_encoder/2&lt;/code&gt; передается в качестве аргумента, &lt;code&gt;my_encoder/2&lt;/code&gt; вызывается каждый раз, когда токенизатору необходимо создать &amp;laquo;статический&amp;raquo; атом. Статические атомы - это атомы в AST, которые функционируют как псевдонимы, удаленные вызовы, локальные вызовы, имена переменных, обычные атомы и списки ключевых слов.</target>
        </trans-unit>
        <trans-unit id="9ca2e0a2813c01d165bda258320b651762161647" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;static_atoms_encoder: &amp;amp;my_encoder/2&lt;/code&gt; is passed as an argument, &lt;code&gt;my_encoder/2&lt;/code&gt; is called every time the tokenizer needs to create a &quot;static&quot; atom. Static atoms are atoms in the AST that function as aliases, remote calls, local calls, variable names, regular atoms and keyword lists.</source>
          <target state="translated">Когда &lt;code&gt;static_atoms_encoder: &amp;amp;my_encoder/2&lt;/code&gt; передается в качестве аргумента, &lt;code&gt;my_encoder/2&lt;/code&gt; вызывается каждый раз, когда токенизатору требуется создать &amp;laquo;статический&amp;raquo; атом. Статические атомы - это атомы в AST, которые функционируют как псевдонимы, удаленные вызовы, локальные вызовы, имена переменных, обычные атомы и списки ключевых слов.</target>
        </trans-unit>
        <trans-unit id="ad5e2fdb3a60f0efd80fd38f40be2eb7879f4b9b" translate="yes" xml:space="preserve">
          <source>When Elixir sees a list of printable ASCII numbers, Elixir will print that as a charlist (literally a list of characters). Charlists are quite common when interfacing with existing Erlang code. Whenever you see a value in IEx and you are not quite sure what it is, you can use the &lt;code&gt;i/1&lt;/code&gt; to retrieve information about it:</source>
          <target state="translated">Когда Elixir видит список печатаемых номеров ASCII, Elixir напечатает его как список символов (буквально список символов). Чарлисты довольно часто встречаются при взаимодействии с существующим кодом Erlang. Когда вы видите значение в IEx и не совсем уверены, что это такое, вы можете использовать &lt;code&gt;i/1&lt;/code&gt; для получения информации о нем:</target>
        </trans-unit>
        <trans-unit id="30cb77a4b9530fedaaedcacb4981a49279ae00af" translate="yes" xml:space="preserve">
          <source>When a URI is given without a port, the value returned by &lt;a href=&quot;#default_port/1&quot;&gt;&lt;code&gt;URI.default_port/1&lt;/code&gt;&lt;/a&gt; for the URI's scheme is used for the &lt;code&gt;:port&lt;/code&gt; field.</source>
          <target state="translated">Когда URI дается без порта, значение, возвращаемое &lt;a href=&quot;#default_port/1&quot;&gt; &lt;code&gt;URI.default_port/1&lt;/code&gt; &lt;/a&gt; для схемы URI, используется для поля &lt;code&gt;:port&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="35c4063a6051dde1c696255275b6a41a4aaaebdd" translate="yes" xml:space="preserve">
          <source>When a URI is given without a port, the value returned by &lt;a href=&quot;uri#default_port/1&quot;&gt;&lt;code&gt;URI.default_port/1&lt;/code&gt;&lt;/a&gt; for the URI's scheme is used for the &lt;code&gt;:port&lt;/code&gt; field.</source>
          <target state="translated">Когда URI дается без порта, значение, возвращаемое &lt;a href=&quot;uri#default_port/1&quot;&gt; &lt;code&gt;URI.default_port/1&lt;/code&gt; &lt;/a&gt; для схемы URI, используется для поля &lt;code&gt;:port&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d330d05e3f10537e699f1f346119f235cd333a5f" translate="yes" xml:space="preserve">
          <source>When a breakpoint is reached, IEx will ask if you want to &lt;code&gt;pry&lt;/code&gt; the given function and arity. In other words, this works similar to &lt;a href=&quot;#pry/0&quot;&gt;&lt;code&gt;IEx.pry/0&lt;/code&gt;&lt;/a&gt; as the running process becomes the evaluator of IEx commands and is temporarily changed to have a custom group leader. However, differently from &lt;a href=&quot;#pry/0&quot;&gt;&lt;code&gt;IEx.pry/0&lt;/code&gt;&lt;/a&gt;, aliases and imports from the source code won't be available in the shell.</source>
          <target state="translated">Когда достигается точка останова, Iex спросит , если вы хотите , чтобы &lt;code&gt;pry&lt;/code&gt; данную функцию и валентности. Другими словами, это работает аналогично &lt;a href=&quot;#pry/0&quot;&gt; &lt;code&gt;IEx.pry/0&lt;/code&gt; ,&lt;/a&gt; поскольку выполняющийся процесс становится оценщиком команд IEx и временно заменяется на лидера настраиваемой группы. Однако, в отличие от &lt;a href=&quot;#pry/0&quot;&gt; &lt;code&gt;IEx.pry/0&lt;/code&gt; &lt;/a&gt; , псевдонимы и импорт из исходного кода не будут доступны в оболочке.</target>
        </trans-unit>
        <trans-unit id="25987424f80060bb3d956efb681cc86c02e031c9" translate="yes" xml:space="preserve">
          <source>When a breakpoint is reached, IEx will ask if you want to &lt;code&gt;pry&lt;/code&gt; the given function and arity. In other words, this works similar to &lt;a href=&quot;iex#pry/0&quot;&gt;&lt;code&gt;IEx.pry/0&lt;/code&gt;&lt;/a&gt; as the running process becomes the evaluator of IEx commands and is temporarily changed to have a custom group leader. However, differently from &lt;a href=&quot;iex#pry/0&quot;&gt;&lt;code&gt;IEx.pry/0&lt;/code&gt;&lt;/a&gt;, aliases and imports from the source code won't be available in the shell.</source>
          <target state="translated">Когда достигается точка останова, Iex спросит , если вы хотите , чтобы &lt;code&gt;pry&lt;/code&gt; данную функцию и валентности. Другими словами, это работает аналогично &lt;a href=&quot;iex#pry/0&quot;&gt; &lt;code&gt;IEx.pry/0&lt;/code&gt; ,&lt;/a&gt; поскольку запущенный процесс становится оценщиком команд IEx и временно заменяется на лидера настраиваемой группы. Однако, в отличие от &lt;a href=&quot;iex#pry/0&quot;&gt; &lt;code&gt;IEx.pry/0&lt;/code&gt; &lt;/a&gt; , псевдонимы и импорт из исходного кода не будут доступны в оболочке.</target>
        </trans-unit>
        <trans-unit id="43942abcf12ce6cc49052edac75db40769b71c11" translate="yes" xml:space="preserve">
          <source>When a key that does not exist in the map is updated a &lt;a href=&quot;https://hexdocs.pm/elixir/KeyError.html&quot;&gt;&lt;code&gt;KeyError&lt;/code&gt;&lt;/a&gt; exception will be raised:</source>
          <target state="translated">Когда ключ, которого нет на карте, обновляется, &lt;a href=&quot;https://hexdocs.pm/elixir/KeyError.html&quot;&gt; &lt;code&gt;KeyError&lt;/code&gt; &lt;/a&gt; исключение KeyError :</target>
        </trans-unit>
        <trans-unit id="b38ca287d116ffb71518505762e2c7d09b9bd2e7" translate="yes" xml:space="preserve">
          <source>When a long action is performed on the server, all other requests to that particular server will wait until the action is done, which may cause some clients to timeout.</source>
          <target state="translated">Когда на сервере выполняется длительное действие,все остальные запросы к этому конкретному серверу будут ждать,пока действие не будет выполнено,что может привести к таймауту некоторых клиентов.</target>
        </trans-unit>
        <trans-unit id="bcbf680c558a41d6d6a75e4381c38c76088bbeeb" translate="yes" xml:space="preserve">
          <source>When a message is sent to a process, the message is stored in the process mailbox. The &lt;code&gt;receive/1&lt;/code&gt; block goes through the current process mailbox searching for a message that matches any of the given patterns. &lt;code&gt;receive/1&lt;/code&gt; supports guards and many clauses, such as &lt;code&gt;case/2&lt;/code&gt;.</source>
          <target state="translated">Когда сообщение отправляется процессу, оно сохраняется в почтовом ящике процесса. Блок &lt;code&gt;receive/1&lt;/code&gt; просматривает почтовый ящик текущего процесса в поисках сообщения, которое соответствует любому из заданных шаблонов. &lt;code&gt;receive/1&lt;/code&gt; поддерживает охранники и многие пункты, например &lt;code&gt;case/2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="efa7709fb20a64125217b49eacd2e41e461864cc" translate="yes" xml:space="preserve">
          <source>When a process is pried, all code runs inside IEx and has access to all imports and aliases from the original code. However, the code is evaluated and therefore cannot access private functions of the module being pried. Module functions still need to be accessed via &lt;code&gt;Mod.fun(args)&lt;/code&gt;.</source>
          <target state="translated">Когда процесс загружается, весь код выполняется внутри IEx и имеет доступ ко всем операциям импорта и псевдонимам исходного кода. Однако код оценивается и поэтому не может получить доступ к частным функциям загружаемого модуля. Доступ к функциям модуля по-прежнему необходимо осуществлять через &lt;code&gt;Mod.fun(args)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a1dd320c95795f465d521db42ced2d81854df04f" translate="yes" xml:space="preserve">
          <source>When a process reaches its end, by default it exits with reason &lt;code&gt;:normal&lt;/code&gt;. You can also call &lt;a href=&quot;#exit/1&quot;&gt;&lt;code&gt;exit/1&lt;/code&gt;&lt;/a&gt; explicitly if you want to terminate a process but not signal any failure:</source>
          <target state="translated">Когда процесс достигает своего конца, по умолчанию он завершается по причине &lt;code&gt;:normal&lt;/code&gt; . Вы также можете явно вызвать &lt;a href=&quot;#exit/1&quot;&gt; &lt;code&gt;exit/1&lt;/code&gt; ,&lt;/a&gt; если хотите завершить процесс, но не сигнализировать об ошибке:</target>
        </trans-unit>
        <trans-unit id="6b82ee1a7b204267871ba58bdb550d5e578f2684" translate="yes" xml:space="preserve">
          <source>When a supervisor shuts down, it terminates all children in the opposite order they are listed. The termination happens by sending a shutdown exit signal, via &lt;code&gt;Process.exit(child_pid, :shutdown)&lt;/code&gt;, to the child process and then awaiting for a time interval for the child process to terminate. This interval defaults to 5000 milliseconds. If the child process does not terminate in this interval, the supervisor abruptly terminates the child with reason &lt;code&gt;:kill&lt;/code&gt;. The shutdown time can be configured in the child specification which is fully detailed in the next section.</source>
          <target state="translated">Когда супервизор завершает работу, он завершает работу всех дочерних элементов в порядке, обратном их перечислению. Завершение происходит путем отправки дочернему процессу сигнала завершения работы через &lt;code&gt;Process.exit(child_pid, :shutdown)&lt;/code&gt; , а затем ожидания в течение определенного интервала времени для завершения дочернего процесса. По умолчанию этот интервал составляет 5000 миллисекунд. Если дочерний процесс не завершается в течение этого интервала, супервизор внезапно завершает дочерний процесс по причине &lt;code&gt;:kill&lt;/code&gt; . Время выключения можно настроить в дочерней спецификации, которая подробно описана в следующем разделе.</target>
        </trans-unit>
        <trans-unit id="8faaac6c2f8c18a01b5af430b45f4916b3dd825c" translate="yes" xml:space="preserve">
          <source>When adding 3 seconds just before &quot;spring forward&quot; we go from 1:59:59 to 3:00:02</source>
          <target state="translated">При добавлении 3 секунд непосредственно перед &quot;прыжком вперед&quot; мы переходим с 1:59:59 на 3:00:02.</target>
        </trans-unit>
        <trans-unit id="c9f12bb1a577b215300a6befb2319f871a5526b1" translate="yes" xml:space="preserve">
          <source>When all the keys in a map are atoms, you can use the keyword syntax for convenience:</source>
          <target state="translated">Когда все клавиши на карте являются атомами,для удобства можно использовать синтаксис ключевых слов:</target>
        </trans-unit>
        <trans-unit id="b71088ccdefe00157ef914366e7da0f66c676805" translate="yes" xml:space="preserve">
          <source>When an application is loaded, the environment specified in its resource file is merged with any overrides from config files passed to &lt;code&gt;erl&lt;/code&gt; via the &lt;code&gt;-config&lt;/code&gt; option. It is worth highlighting that releases pass &lt;code&gt;sys.config&lt;/code&gt; this way. The resulting environment can still be overridden again via specific &lt;code&gt;-Application&lt;/code&gt; options passed to &lt;code&gt;erl&lt;/code&gt;.</source>
          <target state="translated">Когда приложение загружается, среда, указанная в его файле ресурсов, объединяется с любыми переопределениями из файлов конфигурации, переданными в &lt;code&gt;erl&lt;/code&gt; через параметр &lt;code&gt;-config&lt;/code&gt; . Стоит отметить, что релизы передают &lt;code&gt;sys.config&lt;/code&gt; таким образом. Полученную среду можно снова переопределить с помощью определенных параметров &lt;code&gt;-Application&lt;/code&gt; , переданных в &lt;code&gt;erl&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="68814ee5163a09c26c90be3d28cd4825a632b538" translate="yes" xml:space="preserve">
          <source>When an application is loaded, the environment specified in its resource file is merged with any overrides from config files.</source>
          <target state="translated">При загрузке приложения окружение,указанное в файле ресурса,сливается с любыми переопределениями из конфигурационных файлов.</target>
        </trans-unit>
        <trans-unit id="c1202c2e0c188151503ef65ce91c2cf42d3152ad" translate="yes" xml:space="preserve">
          <source>When an application is shutting down, its &lt;a href=&quot;#c:stop/1&quot;&gt;&lt;code&gt;stop/1&lt;/code&gt;&lt;/a&gt; callback is called after the supervision tree has been stopped by the runtime. This callback allows the application to do any final cleanup. The argument is the state returned by &lt;a href=&quot;#c:start/2&quot;&gt;&lt;code&gt;start/2&lt;/code&gt;&lt;/a&gt;, if it did, or &lt;code&gt;[]&lt;/code&gt; otherwise. The return value of &lt;a href=&quot;#c:stop/1&quot;&gt;&lt;code&gt;stop/1&lt;/code&gt;&lt;/a&gt; is ignored.</source>
          <target state="translated">Когда приложение завершает работу, его обратный вызов &lt;a href=&quot;#c:stop/1&quot;&gt; &lt;code&gt;stop/1&lt;/code&gt; &lt;/a&gt; вызывается после того, как дерево наблюдения было остановлено средой выполнения. Этот обратный вызов позволяет приложению выполнить окончательную очистку. Аргументом является состояние, возвращаемое функцией &lt;a href=&quot;#c:start/2&quot;&gt; &lt;code&gt;start/2&lt;/code&gt; &lt;/a&gt; , если это так, или &lt;code&gt;[]&lt;/code&gt; в противном случае. Возвращаемое значение &lt;a href=&quot;#c:stop/1&quot;&gt; &lt;code&gt;stop/1&lt;/code&gt; &lt;/a&gt; игнорируется.</target>
        </trans-unit>
        <trans-unit id="70e63a2548c47ae02dbf01d80b925af398fac364" translate="yes" xml:space="preserve">
          <source>When an application is started, the &lt;a href=&quot;#load/1&quot;&gt;&lt;code&gt;Application.load/1&lt;/code&gt;&lt;/a&gt; is automatically invoked if it hasn't been done yet. Then, it checks if the dependencies listed in the &lt;code&gt;applications&lt;/code&gt; key of the resource file are already started. Having at least one dependency not started is an error condition. Functions like &lt;a href=&quot;#ensure_all_started/1&quot;&gt;&lt;code&gt;ensure_all_started/1&lt;/code&gt;&lt;/a&gt; takes care of starting an application and all of its dependencies for you.</source>
          <target state="translated">При запуске &lt;a href=&quot;#load/1&quot;&gt; &lt;code&gt;Application.load/1&lt;/code&gt; &lt;/a&gt; автоматически вызывается Application.load / 1 , если это еще не было сделано. Затем он проверяет, запущены ли уже зависимости, перечисленные в ключе &lt;code&gt;applications&lt;/code&gt; файла ресурсов. Если хотя бы одна зависимость не запущена, это состояние ошибки. Такие функции, как &lt;a href=&quot;#ensure_all_started/1&quot;&gt; &lt;code&gt;ensure_all_started/1&lt;/code&gt; &lt;/a&gt; заботятся о запуске приложения и всех его зависимостей за вас.</target>
        </trans-unit>
        <trans-unit id="f6ef5e0c1b03cd4c7d5dd1940a8d6051debba964" translate="yes" xml:space="preserve">
          <source>When an application is started, the runtime loads it if it hasn't been loaded yet (in the technical sense described above). Then, it checks if the dependencies listed in the &lt;code&gt;applications&lt;/code&gt; key of the resource file are already started. Having at least one dependency not started is an error condition, but when you start an application with &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Run.html&quot;&gt;&lt;code&gt;mix run&lt;/code&gt;&lt;/a&gt;, Mix takes care of starting all the dependencies for you, so in practice you don't need to worry about it unless you are starting applications manually with the API provided by this module.</source>
          <target state="translated">Когда приложение запускается, среда выполнения загружает его, если оно еще не было загружено (в техническом смысле, описанном выше). Затем он проверяет, запущены ли уже зависимости, перечисленные в ключе &lt;code&gt;applications&lt;/code&gt; файла ресурсов. Наличие хотя бы одной не запущенной зависимости является условием ошибки, но когда вы запускаете приложение с &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Run.html&quot;&gt; &lt;code&gt;mix run&lt;/code&gt; &lt;/a&gt; , Mix позаботится о запуске всех зависимостей за вас, поэтому на практике вам не нужно беспокоиться об этом, если вы не запускаете приложения. вручную с помощью API, предоставляемого этим модулем.</target>
        </trans-unit>
        <trans-unit id="49a4a88ecb25b3a70cf3fc688e8ce9acfeb534dc" translate="yes" xml:space="preserve">
          <source>When an application starts, developers may configure a callback module that executes custom code. Developers use this callback to start the application supervision tree.</source>
          <target state="translated">Когда приложение запускается,разработчики могут настроить модуль обратного вызова,который выполняет пользовательский код.Разработчики используют этот обратный вызов для запуска дерева контроля приложений.</target>
        </trans-unit>
        <trans-unit id="fed10b03a998f194c91e2991e17c7adc90beb397" translate="yes" xml:space="preserve">
          <source>When an empty string is provided as a &lt;code&gt;pattern&lt;/code&gt;, the function will treat it as an implicit empty string between each grapheme and the string will be interspersed. If an empty string is provided as &lt;code&gt;replacement&lt;/code&gt; the &lt;code&gt;subject&lt;/code&gt; will be returned:</source>
          <target state="translated">Когда в качестве &lt;code&gt;pattern&lt;/code&gt; предоставляется пустая строка , функция будет рассматривать ее как неявную пустую строку между каждой графемой, и строка будет перемежаться. Если пустая строка предоставляется в качестве &lt;code&gt;replacement&lt;/code&gt; &lt;code&gt;subject&lt;/code&gt; будет возвращен:</target>
        </trans-unit>
        <trans-unit id="0e3a4594b4c87d19792becad51fa21e48de73592" translate="yes" xml:space="preserve">
          <source>When asking questions, remember these two tips:</source>
          <target state="translated">Когда будете задавать вопросы,помните эти два совета:</target>
        </trans-unit>
        <trans-unit id="b6379905dda95a52bdec96f75491cf26bf0667f5" translate="yes" xml:space="preserve">
          <source>When binding variables with the same names as variables in the outer context, the variables in the outer context are not affected.</source>
          <target state="translated">При привязке переменных с теми же именами,что и переменные во внешнем контексте,переменные во внешнем контексте не затрагиваются.</target>
        </trans-unit>
        <trans-unit id="e6520e68609a37a9a4335763dc27bb15395388e4" translate="yes" xml:space="preserve">
          <source>When building a struct, Elixir will automatically guarantee all keys belongs to the struct:</source>
          <target state="translated">При построении структуры Elixir автоматически гарантирует,что все ключи принадлежат структуре:</target>
        </trans-unit>
        <trans-unit id="43f8256ec2ba3b57ef9f039c36ae97440305cfe0" translate="yes" xml:space="preserve">
          <source>When called with no arguments, tells whether the current project is an umbrella project.</source>
          <target state="translated">Когда вызывается без аргументов,сообщает,является ли текущий проект зонтичным.</target>
        </trans-unit>
        <trans-unit id="5fe5b19f3e345b7e40bafcd757d6f4638d7ad19e" translate="yes" xml:space="preserve">
          <source>When calling &lt;code&gt;Macro.expand_once/2&lt;/code&gt; earlier in this chapter, we used the special form &lt;code&gt;__ENV__&lt;/code&gt;.</source>
          <target state="translated">При вызове &lt;code&gt;Macro.expand_once/2&lt;/code&gt; ранее в этой главе мы использовали специальную форму &lt;code&gt;__ENV__&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="81fce718e207dc57d7fe018b46a9c9813e132dc2" translate="yes" xml:space="preserve">
          <source>When calling a command, it's possible to pass command line options to modify what the command does. In this documentation, those are called &quot;switches&quot;, in other situations they may be called &quot;flags&quot; or simply &quot;options&quot;. A switch can be given a value, also called an &quot;argument&quot;.</source>
          <target state="translated">При вызове команды можно передать опции командной строки для изменения того,что команда делает.В этой документации они называются &quot;переключателями&quot;,в других ситуациях они могут называться &quot;флагами&quot; или просто &quot;опциями&quot;.Коммутатору может быть присвоено значение,также называемое &quot;аргументом&quot;.</target>
        </trans-unit>
        <trans-unit id="15bf0eb73b6deae14192c9599225bae5f5bf74a1" translate="yes" xml:space="preserve">
          <source>When calling:</source>
          <target state="translated">При звонке:</target>
        </trans-unit>
        <trans-unit id="fd91133b88b5c82009814d79120dfed5a2560676" translate="yes" xml:space="preserve">
          <source>When comparing two numbers of different types (a number being either an integer or a float), a conversion to the type with greater precision will always occur, unless the comparison operator used is either &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#===/2&quot;&gt;&lt;code&gt;===&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#!==/2&quot;&gt;&lt;code&gt;!==&lt;/code&gt;&lt;/a&gt;. A float will be considered more precise than an integer, unless the float is greater/less than +/-9007199254740992.0 respectively, at which point all the significant figures of the float are to the left of the decimal point. This behavior exists so that the comparison of large numbers remains transitive.</source>
          <target state="translated">При сравнении двух чисел разных типов (число является либо целым числом, либо числом с плавающей запятой) всегда будет происходить преобразование в тип с большей точностью, если только используемый оператор сравнения не равен &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#===/2&quot;&gt; &lt;code&gt;===&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#!==/2&quot;&gt; &lt;code&gt;!==&lt;/code&gt; &lt;/a&gt; . Число с плавающей запятой будет считаться более точным, чем целое число, за исключением случаев, когда число с плавающей запятой больше / меньше +/- 9007199254740992.0 соответственно, при этом все значащие цифры с плавающей запятой находятся слева от десятичной точки. Такое поведение существует для того, чтобы сравнение больших чисел оставалось транзитивным.</target>
        </trans-unit>
        <trans-unit id="ea3e44e3db057976b426aba831c82df6ff3b11a8" translate="yes" xml:space="preserve">
          <source>When comparing two numbers of different types (a number being either an integer or a float), a conversion to the type with greater precision will always occur, unless the comparison operator used is either &lt;a href=&quot;kernel#===/2&quot;&gt;&lt;code&gt;===&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;kernel#!==/2&quot;&gt;&lt;code&gt;!==&lt;/code&gt;&lt;/a&gt;. A float will be considered more precise than an integer, unless the float is greater/less than +/-9007199254740992.0 respectively, at which point all the significant figures of the float are to the left of the decimal point. This behavior exists so that the comparison of large numbers remains transitive.</source>
          <target state="translated">При сравнении двух чисел разных типов (число является либо целым числом, либо числом с плавающей точкой) всегда будет происходить преобразование в тип с большей точностью, если только используемый оператор сравнения не равен &lt;a href=&quot;kernel#===/2&quot;&gt; &lt;code&gt;===&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;kernel#!==/2&quot;&gt; &lt;code&gt;!==&lt;/code&gt; &lt;/a&gt; . Число с плавающей запятой будет считаться более точным, чем целое число, за исключением случаев, когда число с плавающей запятой больше / меньше +/- 9007199254740992.0 соответственно, при этом все значащие цифры числа с плавающей точкой находятся слева от десятичной точки. Такое поведение существует для того, чтобы сравнение больших чисел оставалось транзитивным.</target>
        </trans-unit>
        <trans-unit id="e0d63214236623420b6d65808e561ecf96add0a5" translate="yes" xml:space="preserve">
          <source>When compiling Elixir code via &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.ParallelCompiler.html&quot;&gt;&lt;code&gt;Kernel.ParallelCompiler&lt;/code&gt;&lt;/a&gt;, which is used by Mix and &lt;code&gt;elixirc&lt;/code&gt;, calling a module that has not yet been compiled will block the caller until the module becomes available. Executing Elixir scripts, such as passing a filename to &lt;code&gt;elixir&lt;/code&gt;, does not await.</source>
          <target state="translated">При компиляции кода Elixir через &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.ParallelCompiler.html&quot;&gt; &lt;code&gt;Kernel.ParallelCompiler&lt;/code&gt; &lt;/a&gt; , который используется Mix и &lt;code&gt;elixirc&lt;/code&gt; , вызов модуля, который еще не был скомпилирован, заблокирует вызывающую программу до тех пор, пока модуль не станет доступным. Выполнение сценариев Elixir, таких как передача имени файла в &lt;code&gt;elixir&lt;/code&gt; , не ожидает.</target>
        </trans-unit>
        <trans-unit id="abb8f461ed01787b27277cdcd5e984ed7200e3d4" translate="yes" xml:space="preserve">
          <source>When compiling one file, there is no need to wrap it in a list:</source>
          <target state="translated">При компиляции одного файла нет необходимости заворачивать его в список:</target>
        </trans-unit>
        <trans-unit id="dc320684f550c604f452ea80038eb7dce8a3df81" translate="yes" xml:space="preserve">
          <source>When counting the elements in a data structure, Elixir also abides by a simple rule: the function is named &lt;code&gt;size&lt;/code&gt; if the operation is in constant time (i.e. the value is pre-calculated) or &lt;code&gt;length&lt;/code&gt; if the operation is linear (i.e. calculating the length gets slower as the input grows). As a mnemonic, both &amp;ldquo;length&amp;rdquo; and &amp;ldquo;linear&amp;rdquo; start with &amp;ldquo;l&amp;rdquo;.</source>
          <target state="translated">При подсчете элементов в структуре данных Elixir также следует простому правилу: функция называется &lt;code&gt;size&lt;/code&gt; если операция выполняется в постоянное время (т. Е. Значение предварительно вычислено), или &lt;code&gt;length&lt;/code&gt; если операция линейная (т. Е. Вычисление длины становится медленнее по мере увеличения ввода). В качестве мнемоники и &amp;laquo;длина&amp;raquo;, и &amp;laquo;линейный&amp;raquo; начинаются с &amp;laquo;l&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="2e47658aa511c91b866e858f7ef1f7ec9ea38aae" translate="yes" xml:space="preserve">
          <source>When creating an ETS table, two arguments are required: the table name and a set of options. From the available options, we passed the table type and its access rules. We have chosen the &lt;code&gt;:set&lt;/code&gt; type, which means that keys cannot be duplicated. We&amp;rsquo;ve also set the table&amp;rsquo;s access to &lt;code&gt;:protected&lt;/code&gt;, meaning only the process that created the table can write to it, but all processes can read from it. The possible access controls:</source>
          <target state="translated">При создании таблицы ETS требуются два аргумента: имя таблицы и набор параметров. Из доступных опций мы передали тип таблицы и правила доступа к ней. Мы выбрали тип &lt;code&gt;:set&lt;/code&gt; , что означает невозможность дублирования ключей. Мы также установили доступ к таблице &lt;code&gt;:protected&lt;/code&gt; , то есть только процесс, создавший таблицу, может писать в нее, но все процессы могут читать из нее. Возможные элементы управления доступом:</target>
        </trans-unit>
        <trans-unit id="f6b6a0a6dde37d782de3ccaeae069e37c2979ec4" translate="yes" xml:space="preserve">
          <source>When creating an ETS table, two arguments are required: the table name and a set of options. From the available options, we passed the table type and its access rules. We have chosen the &lt;code&gt;:set&lt;/code&gt; type, which means that keys cannot be duplicated. We&amp;rsquo;ve also set the table&amp;rsquo;s access to &lt;code&gt;:protected&lt;/code&gt;, meaning only the process that created the table can write to it, but all processes can read from it. Those are actually the default values, so we will skip them from now on.</source>
          <target state="translated">При создании таблицы ETS требуются два аргумента: имя таблицы и набор параметров. Из доступных опций мы передали тип таблицы и правила доступа к ней. Мы выбрали тип &lt;code&gt;:set&lt;/code&gt; , что означает невозможность дублирования ключей. Мы также установили доступ к таблице &lt;code&gt;:protected&lt;/code&gt; , то есть только процесс, создавший таблицу, может писать в нее, но все процессы могут читать из нее. На самом деле это значения по умолчанию, поэтому мы будем их пропускать.</target>
        </trans-unit>
        <trans-unit id="33336d2f652ba1a581611b2ab795107a9818b6fc" translate="yes" xml:space="preserve">
          <source>When defining a function with default arguments as well as multiple explicitly declared clauses, you must write a function head that declares the defaults. For example:</source>
          <target state="translated">При определении функции с аргументами по умолчанию,а также с несколькими явно объявленными пунктами,вы должны написать голову функции,которая объявляет значения по умолчанию.Например:</target>
        </trans-unit>
        <trans-unit id="940944a0657e8af86b9ecfb3e0f5ccfcf23d2d7b" translate="yes" xml:space="preserve">
          <source>When defining an attribute, do not leave a line break between the attribute name and its value.</source>
          <target state="translated">При определении атрибута не оставляйте разрыв строки между именем атрибута и его значением.</target>
        </trans-unit>
        <trans-unit id="9c14e3bb37cd09a5f29b97fbe1d2849da51a757a" translate="yes" xml:space="preserve">
          <source>When defining functions via macros, developers have the option of choosing if runtime errors will be reported from the caller or from inside the quote. Let's see an example:</source>
          <target state="translated">При определении функций с помощью макросов разработчики имеют возможность выбрать,будут ли сообщения об ошибках выполнения от вызывающего абонента или изнутри котировки.Рассмотрим пример:</target>
        </trans-unit>
        <trans-unit id="59c4a9527901fd3285b6261e17bbd7072524dcb8" translate="yes" xml:space="preserve">
          <source>When deriving, Elixir will implement the &lt;code&gt;Size&lt;/code&gt; protocol for &lt;code&gt;OtherUser&lt;/code&gt; based on the implementation provided for &lt;code&gt;Any&lt;/code&gt;.</source>
          <target state="translated">При создании Elixir реализует протокол &lt;code&gt;Size&lt;/code&gt; для &lt;code&gt;OtherUser&lt;/code&gt; на основе реализации, предоставленной для &lt;code&gt;Any&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="faacdf06edb7c58723e21b75966b5a1b4848e52f" translate="yes" xml:space="preserve">
          <source>When disabled, it behaves as usual and it will ignore any further &lt;a href=&quot;#next_break_fits/2&quot;&gt;&lt;code&gt;next_break_fits/2&lt;/code&gt;&lt;/a&gt; instruction.</source>
          <target state="translated">Когда он отключен, он ведет себя как обычно и игнорирует любую дальнейшую &lt;a href=&quot;#next_break_fits/2&quot;&gt; &lt;code&gt;next_break_fits/2&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="df8c82e750351f095aeb40cc4f1edb723ac71be5" translate="yes" xml:space="preserve">
          <source>When discussing module attributes in earlier chapters, we mentioned how they can be used as temporary storage. That&amp;rsquo;s exactly the property we will apply in this section.</source>
          <target state="translated">Обсуждая атрибуты модуля в предыдущих главах, мы упоминали, как их можно использовать в качестве временного хранилища. Именно это свойство мы применим в этом разделе.</target>
        </trans-unit>
        <trans-unit id="c15d7561c822ee6973742c8650d791962bc9201f" translate="yes" xml:space="preserve">
          <source>When documenting a function, argument names are inferred by the compiler. For example:</source>
          <target state="translated">При документировании функции имена аргументов выводятся компилятором.Например:</target>
        </trans-unit>
        <trans-unit id="578a9a5990bc02bf442dcb9647e96d1e0deec47f" translate="yes" xml:space="preserve">
          <source>When given a module name, it finds its BEAM code and reads the docs from it.</source>
          <target state="translated">Когда ему дается имя модуля,он находит свой код BEAM и считывает из него документы.</target>
        </trans-unit>
        <trans-unit id="fef5c83aff7999db3d06dac86bd9f0184effdcaa" translate="yes" xml:space="preserve">
          <source>When given a path to a &lt;code&gt;.beam&lt;/code&gt; file, it will load the docs directly from that file.</source>
          <target state="translated">Если &lt;code&gt;.beam&lt;/code&gt; путь к файлу .beam , он загрузит документы прямо из этого файла.</target>
        </trans-unit>
        <trans-unit id="39fc62509ca6e8c4e6300100effd1de2d15c28d7" translate="yes" xml:space="preserve">
          <source>When going through this getting started guide, it is common to have questions; after all, that is part of the learning process! There are many places maintained by the community where you can ask questions, here are some of them:</source>
          <target state="translated">При прохождении этого руководства по началу работы,часто возникают вопросы;в конце концов,это часть процесса обучения! Есть много мест,поддерживаемых сообществом,где вы можете задать вопросы,вот некоторые из них:</target>
        </trans-unit>
        <trans-unit id="6a112f25a99f832f4b33d355b5926422a477370e" translate="yes" xml:space="preserve">
          <source>When going through this getting started guide, it is common to have questions; after all, that is part of the learning process! There are many places where you can ask questions, here are some of them:</source>
          <target state="translated">При прохождении этого руководства по началу работы,часто возникают вопросы;в конце концов,это часть процесса обучения! Есть много мест,где можно задать вопросы,вот некоторые из них:</target>
        </trans-unit>
        <trans-unit id="d74bd70d54c9a0f941a337c706cfb743de945220" translate="yes" xml:space="preserve">
          <source>When implementing a protocol for a struct, the &lt;code&gt;:for&lt;/code&gt; option can be omitted if the &lt;code&gt;defimpl&lt;/code&gt; call is inside the module that defines the struct:</source>
          <target state="translated">При реализации протокола для структуры параметр &lt;code&gt;:for&lt;/code&gt; может быть опущен, если вызов &lt;code&gt;defimpl&lt;/code&gt; находится внутри модуля, определяющего структуру:</target>
        </trans-unit>
        <trans-unit id="f9b91bfc2c95c3c008e57c050ff6b2e440fc4814" translate="yes" xml:space="preserve">
          <source>When invoked like this:</source>
          <target state="translated">При таком вызове</target>
        </trans-unit>
        <trans-unit id="9ea6ac5c2582bc339cde7241b58f3b81346c4c24" translate="yes" xml:space="preserve">
          <source>When invoked with no options, &lt;code&gt;use Bitwise&lt;/code&gt; is equivalent to &lt;code&gt;import Bitwise&lt;/code&gt;.</source>
          <target state="translated">При вызове без параметров &lt;code&gt;use Bitwise&lt;/code&gt; эквивалентно &lt;code&gt;import Bitwise&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6479c4e04d60a2979f5fdc435c3db7673d78eb7c" translate="yes" xml:space="preserve">
          <source>When invoked, &lt;a href=&quot;#ensure_compiled/1&quot;&gt;&lt;code&gt;ensure_compiled/1&lt;/code&gt;&lt;/a&gt; halts the compilation of the caller until the module given to &lt;a href=&quot;#ensure_compiled/1&quot;&gt;&lt;code&gt;ensure_compiled/1&lt;/code&gt;&lt;/a&gt; becomes available or all files for the current project have been compiled. If compilation finishes and the module is not available, an error tuple is returned.</source>
          <target state="translated">При вызове &lt;a href=&quot;#ensure_compiled/1&quot;&gt; &lt;code&gt;ensure_compiled/1&lt;/code&gt; &lt;/a&gt; останавливает компиляцию вызывающей стороны до тех пор, пока модуль, заданный для &lt;a href=&quot;#ensure_compiled/1&quot;&gt; &lt;code&gt;ensure_compiled/1&lt;/code&gt; &lt;/a&gt; станет доступным или все файлы для текущего проекта не будут скомпилированы. Если компиляция завершается и модуль недоступен, возвращается кортеж с ошибкой.</target>
        </trans-unit>
        <trans-unit id="060c4e9baf5bbf6d685865db22ba844114868707" translate="yes" xml:space="preserve">
          <source>When invoking &lt;code&gt;Adder.add(1, 2)&lt;/code&gt;, you will receive a message in your shell to pry the given environment. By allowing it, the shell will be reset and you gain access to all variables and the lexical scope from above:</source>
          <target state="translated">При вызове &lt;code&gt;Adder.add(1, 2)&lt;/code&gt; вы получите сообщение в своей оболочке, чтобы попытаться взломать данную среду. Если это разрешить, оболочка будет сброшена, и вы получите доступ ко всем переменным и лексической области сверху:</target>
        </trans-unit>
        <trans-unit id="7c9d5f385e194f5b34e40a73b8a3fada81a0e11a" translate="yes" xml:space="preserve">
          <source>When just a module is provided, the function is assumed to be &lt;code&gt;__on_definition__/6&lt;/code&gt;.</source>
          <target state="translated">Когда предоставляется только модуль, предполагается, что функция имеет вид &lt;code&gt;__on_definition__/6&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="09bb8abc825d51b9e7d13312b08810361ca96b5f" translate="yes" xml:space="preserve">
          <source>When just a module is provided, the function/macro is assumed to be &lt;code&gt;__before_compile__/1&lt;/code&gt;.</source>
          <target state="translated">Когда предоставляется только модуль, предполагается, что функция / макрос имеет вид &lt;code&gt;__before_compile__/1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4055572009310e77d3f8f9c147cbf0e89c6265f8" translate="yes" xml:space="preserve">
          <source>When keyword lists are passed as the last argument to a function, the square brackets around the keyword list can be omitted. For example, the keyword list syntax:</source>
          <target state="translated">Когда списки ключевых слов передаются в качестве последнего аргумента функции,квадратные скобки вокруг списка ключевых слов могут быть опущены.Например,синтаксис списка ключевых слов:</target>
        </trans-unit>
        <trans-unit id="ad041e4ced692624cb8e72a2915dff6522835e48" translate="yes" xml:space="preserve">
          <source>When no match is found, an empty list is returned and the update function is never called</source>
          <target state="translated">Когда совпадение не найдено,возвращается пустой список,а функция обновления никогда не вызывается.</target>
        </trans-unit>
        <trans-unit id="668ead62f46a113515691eea47cd9cf416c22eb2" translate="yes" xml:space="preserve">
          <source>When no type is specified, the default is &lt;code&gt;integer&lt;/code&gt;:</source>
          <target state="translated">Если тип не указан, по умолчанию используется &lt;code&gt;integer&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="abef43c7f43cdb1c991b8cd6df524a916c1912ab" translate="yes" xml:space="preserve">
          <source>When not called whithin guards, the &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#in/2&quot;&gt;&lt;code&gt;in&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#in/2&quot;&gt;&lt;code&gt;not in&lt;/code&gt;&lt;/a&gt; operators work by using this function.</source>
          <target state="translated">Когда они не вызываются внутри охранников, операторы &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#in/2&quot;&gt; &lt;code&gt;in&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#in/2&quot;&gt; &lt;code&gt;not in&lt;/code&gt; &lt;/a&gt; работают с использованием этой функции.</target>
        </trans-unit>
        <trans-unit id="f7f7f6bede95dcc54b517033bf243a392f220781" translate="yes" xml:space="preserve">
          <source>When not to use doctest</source>
          <target state="translated">Когда не использовать документацию</target>
        </trans-unit>
        <trans-unit id="3588217aa9bf0907adc5bc95772d644058750365" translate="yes" xml:space="preserve">
          <source>When one of the keys is a function, the function is invoked. In the example below, we use a function to get and increment all ages inside a list:</source>
          <target state="translated">Когда одна из клавиш является функцией,вызывается функция.В примере ниже мы используем функцию для получения и инкремента всех возрастов внутри списка:</target>
        </trans-unit>
        <trans-unit id="5dac029eee48d3ec58bc7974618e8728bcdcde33" translate="yes" xml:space="preserve">
          <source>When only the module name is given, it is equivalent to &lt;code&gt;{Stack, []}&lt;/code&gt;. By replacing the map specification by &lt;code&gt;{Stack, [:hello]}&lt;/code&gt; or &lt;code&gt;Stack&lt;/code&gt;, we keep the child specification encapsulated in the &lt;code&gt;Stack&lt;/code&gt; module, using the default implementation defined by &lt;code&gt;use GenServer&lt;/code&gt;. We can now share our &lt;code&gt;Stack&lt;/code&gt; worker with other developers and they can add it directly to their supervision tree without worrying about the low-level details of the worker.</source>
          <target state="translated">Когда указано только имя модуля, оно эквивалентно &lt;code&gt;{Stack, []}&lt;/code&gt; . Заменяя спецификацию карты на &lt;code&gt;{Stack, [:hello]}&lt;/code&gt; или &lt;code&gt;Stack&lt;/code&gt; , мы сохраняем &lt;code&gt;use GenServer&lt;/code&gt; спецификацию инкапсулированной в модуле &lt;code&gt;Stack&lt;/code&gt; , используя реализацию по умолчанию, определенную с помощью GenServer . Теперь мы можем поделиться нашим &lt;code&gt;Stack&lt;/code&gt; worker с другими разработчиками, и они могут добавить его непосредственно в свое дерево наблюдения, не беспокоясь о низкоуровневых деталях рабочего.</target>
        </trans-unit>
        <trans-unit id="766a963e79023140bf5452d976b11e3c509c178b" translate="yes" xml:space="preserve">
          <source>When parsing, it is common to list switches and their expected types:</source>
          <target state="translated">При синтаксическом анализе принято перечислять переключатели и их ожидаемые типы:</target>
        </trans-unit>
        <trans-unit id="36ba4e5102dee4d1f96eef0a95a3e5d29407d173" translate="yes" xml:space="preserve">
          <source>When possible, &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;mix help&lt;/code&gt;&lt;/a&gt; is going to use coloring for formatting guides. The formatting can be customized by configuring the Mix application either inside your project (in &lt;code&gt;config/config.exs&lt;/code&gt;) or by using the local config (in &lt;code&gt;~/.mix/config.exs&lt;/code&gt;).</source>
          <target state="translated">По возможности, &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;mix help&lt;/code&gt; &lt;/a&gt; будет использовать раскраску для направляющих по форматированию. Форматирование можно настроить, настроив приложение Mix внутри вашего проекта (в &lt;code&gt;config/config.exs&lt;/code&gt; ) или используя локальную конфигурацию (в &lt;code&gt;~/.mix/config.exs&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="39b3c58586f7e038e77e8a708b922775161fc839" translate="yes" xml:space="preserve">
          <source>When printing documentation, IEx will convert the Markdown documentation to ANSI as well. Colors for this can be configured via:</source>
          <target state="translated">При печати документации IEx также конвертирует документацию Markdown в ANSI.Цвета для этого можно настроить через:</target>
        </trans-unit>
        <trans-unit id="7c863b8baf992c9eeaa45fd095854ed9c7455c95" translate="yes" xml:space="preserve">
          <source>When quoting more complex expressions, we can see that the code is represented in such tuples, which are often nested inside each other in a structure resembling a tree. Many languages would call such representations an Abstract Syntax Tree (AST). Elixir calls them quoted expressions:</source>
          <target state="translated">При цитировании более сложных выражений видно,что код представлен в таких кортежах,которые часто вложены друг в друга в структуру,напоминающую дерево.Многие языки назвали бы такие представления абстрактным синтаксическим деревом (AST).Эликсир называет их выражениями в кавычках:</target>
        </trans-unit>
        <trans-unit id="c4d26099302c23e48a1daa30a35aa4a09ff99a4d" translate="yes" xml:space="preserve">
          <source>When registering an attribute, two options can be given:</source>
          <target state="translated">При регистрации атрибута можно указать два варианта:</target>
        </trans-unit>
        <trans-unit id="152f951b5158b67a3861b2b73b9a954063842f97" translate="yes" xml:space="preserve">
          <source>When replying from another process the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; should exit if the other process exits without replying as the caller will be blocking awaiting a reply.</source>
          <target state="translated">При ответе от другого процесса &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt; должен выйти, если другой процесс завершится без ответа, так как вызывающий будет заблокирован, ожидая ответа.</target>
        </trans-unit>
        <trans-unit id="cc7fe0445fd913951bee3f58c7983b860e7114ee" translate="yes" xml:space="preserve">
          <source>When representing code points in bytes, we need to encode them somehow. Elixir chose the UTF-8 encoding as its main and default encoding. When we say a string is a UTF-8 encoded binary, we mean a string is a bunch of bytes organized in a way to represent certain code points, as specified by the UTF-8 encoding.</source>
          <target state="translated">При представлении точек кода в байтах их нужно как-то кодировать.Эликсир выбрал кодировку UTF-8 в качестве основной и кодировки по умолчанию.Когда мы говорим,что строка-это бинарник в кодировке UTF-8,мы имеем в виду,что строка-это куча байтов,организованных таким образом,чтобы представлять определенные точки кода,как указано в кодировке UTF-8.</target>
        </trans-unit>
        <trans-unit id="47a96e8207dbba43ad0bea04b72a2d53b9a1f72f" translate="yes" xml:space="preserve">
          <source>When running &lt;code&gt;test.coverage&lt;/code&gt; from the umbrella root, it will use the &lt;code&gt;:test_coverage&lt;/code&gt; configuration from the umbrella root.</source>
          <target state="translated">При запуске &lt;code&gt;test.coverage&lt;/code&gt; из корня зонтика он будет использовать конфигурацию &lt;code&gt;:test_coverage&lt;/code&gt; из корня зонтика.</target>
        </trans-unit>
        <trans-unit id="8ba73e420e82fea09e21f152498ecd62bd2084ae" translate="yes" xml:space="preserve">
          <source>When setting up Pry inside a code defined by macros, such as:</source>
          <target state="translated">При настройке Pry внутри кода,определяемого макросами,например:</target>
        </trans-unit>
        <trans-unit id="5399bba4547032d1977ec734b465b9404b2e7555" translate="yes" xml:space="preserve">
          <source>When starting a supervisor, we pass a list of child specifications. Those specifications are maps that tell how the supervisor should start, stop and restart each of its children:</source>
          <target state="translated">При запуске супервайзера мы передаем список спецификаций ребенка.Это карты,которые показывают,как начальник должен запускать,останавливать и перезапускать каждого из своих детей:</target>
        </trans-unit>
        <trans-unit id="1afde91db5c18401a3ba6a5f7263520825af971b" translate="yes" xml:space="preserve">
          <source>When starting processes during your tests, we should always prefer to use &lt;code&gt;start_supervised!&lt;/code&gt;. We recommend you to change the &lt;code&gt;setup&lt;/code&gt; block in &lt;code&gt;bucket_test.exs&lt;/code&gt; to use &lt;code&gt;start_supervised!&lt;/code&gt; too.</source>
          <target state="translated">При запуске процессов во время тестов мы всегда должны предпочесть использовать &lt;code&gt;start_supervised!&lt;/code&gt; , Мы рекомендуем вам изменить блок &lt;code&gt;setup&lt;/code&gt; в &lt;code&gt;bucket_test.exs&lt;/code&gt; на использование &lt;code&gt;start_supervised!&lt;/code&gt; слишком.</target>
        </trans-unit>
        <trans-unit id="91ce06991729ec7e9eb2c5aee4daacee5fe91ea1" translate="yes" xml:space="preserve">
          <source>When starting, IEx looks for a local &lt;code&gt;.iex.exs&lt;/code&gt; file (located in the current working directory), then a global one (located at &lt;code&gt;~/.iex.exs&lt;/code&gt;) and loads the first one it finds (if any). Note the location of the &lt;code&gt;.iex.exs&lt;/code&gt; files, both in the current directory and the global one, are taken relative to the user that started the application, not to the user that is connecting to the node in case of remote IEx connections.</source>
          <target state="translated">При запуске IEx ищет локальный файл &lt;code&gt;.iex.exs&lt;/code&gt; (расположенный в текущем рабочем каталоге), затем глобальный (расположенный в &lt;code&gt;~/.iex.exs&lt;/code&gt; ) и загружает первый найденный файл (если он есть). Обратите внимание, что расположение файлов &lt;code&gt;.iex.exs&lt;/code&gt; , как в текущем каталоге, так и в глобальном, берется относительно пользователя, запустившего приложение, а не пользователя, который подключается к узлу в случае удаленных подключений IEx.</target>
        </trans-unit>
        <trans-unit id="da73f42a24fcc99f2f1dc5fa7376c2637e2c1445" translate="yes" xml:space="preserve">
          <source>When starting, IEx looks for a local &lt;code&gt;.iex.exs&lt;/code&gt; file (located in the current working directory), then a global one (located at &lt;code&gt;~/.iex.exs&lt;/code&gt;) and loads the first one it finds (if any). The code in the loaded &lt;code&gt;.iex.exs&lt;/code&gt; file is evaluated in the shell's context. So, for instance, any modules that are loaded or variables that are bound in the &lt;code&gt;.iex.exs&lt;/code&gt; file will be available in the shell after it has booted.</source>
          <target state="translated">При запуске IEx ищет локальный файл &lt;code&gt;.iex.exs&lt;/code&gt; (расположенный в текущем рабочем каталоге), затем глобальный (расположенный в &lt;code&gt;~/.iex.exs&lt;/code&gt; ) и загружает первый найденный файл (если он есть). Код в загруженном файле &lt;code&gt;.iex.exs&lt;/code&gt; оценивается в контексте оболочки. Так, например, любые загруженные модули или переменные, связанные с файлом &lt;code&gt;.iex.exs&lt;/code&gt; , будут доступны в оболочке после ее загрузки.</target>
        </trans-unit>
        <trans-unit id="63dac761d2448700171ff70d4839175c0009a766" translate="yes" xml:space="preserve">
          <source>When stopped, the application is still loaded.</source>
          <target state="translated">Когда приложение останавливается,оно все еще загружается.</target>
        </trans-unit>
        <trans-unit id="44fc4934aad1c4836563f8ccabbe822e5d3c33b8" translate="yes" xml:space="preserve">
          <source>When streamed, each task will emit &lt;code&gt;{:ok, value}&lt;/code&gt; upon successful completion or &lt;code&gt;{:exit, reason}&lt;/code&gt; if the caller is trapping exits. The order of results depends on the value of the &lt;code&gt;:ordered&lt;/code&gt; option.</source>
          <target state="translated">При потоковой передаче каждая задача будет выдавать &lt;code&gt;{:ok, value}&lt;/code&gt; при успешном завершении или &lt;code&gt;{:exit, reason}&lt;/code&gt; если вызывающий перехватывает выходы. Порядок результатов зависит от значения параметра &lt;code&gt;:ordered&lt;/code&gt; orders.</target>
        </trans-unit>
        <trans-unit id="eef8a0b0425ca67ec8755e1b57a825ae684f06e5" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;:allow_pre&lt;/code&gt; option is set &lt;code&gt;false&lt;/code&gt; in &lt;a href=&quot;#match?/3&quot;&gt;&lt;code&gt;Version.match?/3&lt;/code&gt;&lt;/a&gt;, the requirement will not match a pre-release version unless the operand is a pre-release version. The default is to always allow pre-releases but note that in Hex &lt;code&gt;:allow_pre&lt;/code&gt; is set to &lt;code&gt;false&lt;/code&gt;. See the table below for examples.</source>
          <target state="translated">Если для параметра &lt;code&gt;:allow_pre&lt;/code&gt; установлено значение &lt;code&gt;false&lt;/code&gt; в &lt;a href=&quot;#match?/3&quot;&gt; &lt;code&gt;Version.match?/3&lt;/code&gt; &lt;/a&gt; , требование не будет соответствовать предварительной версии, если только операнд не является предварительной версией. По умолчанию предварительные выпуски всегда разрешены, но обратите внимание, что в Hex &lt;code&gt;:allow_pre&lt;/code&gt; установлено значение &lt;code&gt;false&lt;/code&gt; . См. Примеры в таблице ниже.</target>
        </trans-unit>
        <trans-unit id="e967fe555e7491d14ab10c0651fa2c10f01bf7c1" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;:allow_pre&lt;/code&gt; option is set &lt;code&gt;false&lt;/code&gt; in &lt;a href=&quot;version#match?/3&quot;&gt;&lt;code&gt;Version.match?/3&lt;/code&gt;&lt;/a&gt;, the requirement will not match a pre-release version unless the operand is a pre-release version. The default is to always allow pre-releases but note that in Hex &lt;code&gt;:allow_pre&lt;/code&gt; is set to &lt;code&gt;false&lt;/code&gt;. See the table below for examples.</source>
          <target state="translated">Когда для параметра &lt;code&gt;:allow_pre&lt;/code&gt; установлено значение &lt;code&gt;false&lt;/code&gt; в &lt;a href=&quot;version#match?/3&quot;&gt; &lt;code&gt;Version.match?/3&lt;/code&gt; &lt;/a&gt; , требование не будет соответствовать предварительной версии, если только операнд не является предварительной версией. По умолчанию предварительные выпуски всегда разрешены, но обратите внимание, что в Hex &lt;code&gt;:allow_pre&lt;/code&gt; установлено значение &lt;code&gt;false&lt;/code&gt; . Примеры см. В таблице ниже.</target>
        </trans-unit>
        <trans-unit id="e79f5cbe356a7cdfd1f05e8dc80bced38e7f448e" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;:reduce&lt;/code&gt; key is given, its value is used as the initial accumulator and the &lt;code&gt;do&lt;/code&gt; block must be changed to use &lt;code&gt;-&amp;gt;&lt;/code&gt; clauses, where the left side of &lt;code&gt;-&amp;gt;&lt;/code&gt; receives the accumulated value of the previous iteration and the expression on the right side must return the new accumulator value. Once there are no more elements, the final accumulated value is returned. If there are no elements at all, then the initial accumulator value is returned.</source>
          <target state="translated">Когда задан ключ &lt;code&gt;:reduce&lt;/code&gt; , его значение используется в качестве начального аккумулятора, а блок &lt;code&gt;do&lt;/code&gt; должен быть изменен для использования предложений &lt;code&gt;-&amp;gt;&lt;/code&gt; , где левая часть &lt;code&gt;-&amp;gt;&lt;/code&gt; получает накопленное значение предыдущей итерации и выражение справа сторона должна вернуть новое значение аккумулятора. Когда элементов больше нет, возвращается окончательное накопленное значение. Если элементов нет вообще, возвращается начальное значение аккумулятора.</target>
        </trans-unit>
        <trans-unit id="f46f7e3c553c02ae7fead96311a793a3ad633924" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;:switches&lt;/code&gt; option is given, &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;OptionParser&lt;/code&gt;&lt;/a&gt; will attempt to parse unknown switches:</source>
          <target state="translated">Когда &lt;code&gt;:switches&lt;/code&gt; задана опция, &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;OptionParser&lt;/code&gt; &lt;/a&gt; попытается разобрать неизвестные переключатели:</target>
        </trans-unit>
        <trans-unit id="55710b0d4d5aaa7e5939c1b4abb2051161b46e72" translate="yes" xml:space="preserve">
          <source>When the code is executed, it will ask you for permission to be introspected.</source>
          <target state="translated">Когда код будет выполнен,он запросит у вас разрешение на интроспекцию.</target>
        </trans-unit>
        <trans-unit id="5f06da6eb5cf8fdd49d7a631b29f30d2bcf581d9" translate="yes" xml:space="preserve">
          <source>When the datetime is ambiguous - for instance during changing from summer to winter time - an error will be raised.</source>
          <target state="translated">При неоднозначной дате-например,при переходе с летнего на зимнее время-ошибка будет повышена.</target>
        </trans-unit>
        <trans-unit id="82d07e6f76ba2457b4bdb703973a237fe29a00b6" translate="yes" xml:space="preserve">
          <source>When the datetime is ambiguous - for instance during changing from summer to winter time - the two possible valid datetimes are returned. First the one that happens first, then the one that happens after.</source>
          <target state="translated">При неоднозначной дате-например,при переходе с летнего на зимнее время-возвращаются два возможных действительных времени даты.Сначала то,что происходит сначала,затем то,что происходит после.</target>
        </trans-unit>
        <trans-unit id="f9d4126199b613c96db5fb36b204b9cc8e74af41" translate="yes" xml:space="preserve">
          <source>When the default &lt;code&gt;:infer&lt;/code&gt;, the binary will be printed as a string if it is printable, otherwise in bit syntax. See &lt;a href=&quot;string#printable?/1&quot;&gt;&lt;code&gt;String.printable?/1&lt;/code&gt;&lt;/a&gt; to learn when a string is printable.</source>
          <target state="translated">Если по умолчанию &lt;code&gt;:infer&lt;/code&gt; , двоичный файл будет напечатан в виде строки, если он доступен для печати, в противном случае - в битовом синтаксисе. См. &lt;a href=&quot;string#printable?/1&quot;&gt; &lt;code&gt;String.printable?/1&lt;/code&gt; ,&lt;/a&gt; чтобы узнать, когда строка пригодна для печати.</target>
        </trans-unit>
        <trans-unit id="c612d63a8c1c933d7e8881534968752ca12fe8ad" translate="yes" xml:space="preserve">
          <source>When the default &lt;code&gt;:infer&lt;/code&gt;, the list will be printed as a charlist if it is printable, otherwise as list. See &lt;a href=&quot;list#ascii_printable?/1&quot;&gt;&lt;code&gt;List.ascii_printable?/1&lt;/code&gt;&lt;/a&gt; to learn when a charlist is printable.</source>
          <target state="translated">Если по умолчанию &lt;code&gt;:infer&lt;/code&gt; , список будет напечатан как список символов, если он доступен для печати, иначе как список. См. &lt;a href=&quot;list#ascii_printable?/1&quot;&gt; &lt;code&gt;List.ascii_printable?/1&lt;/code&gt; ,&lt;/a&gt; чтобы узнать, когда список символов доступен для печати.</target>
        </trans-unit>
        <trans-unit id="63da4232661d88a7f868999ff25b659010b2900b" translate="yes" xml:space="preserve">
          <source>When the dot is used to invoke an anonymous function there is only one operand, but it is still written using a postfix notation:</source>
          <target state="translated">Когда точка используется для вызова анонимной функции,есть только один операнд,но он все равно записывается с использованием постфиксной нотации:</target>
        </trans-unit>
        <trans-unit id="813d1cf0e1831ccf812556df6497fde20b090d3e" translate="yes" xml:space="preserve">
          <source>When the head element of aliases is the atom &lt;code&gt;:Elixir&lt;/code&gt;, no expansion happens.</source>
          <target state="translated">Когда верхним элементом псевдонимов является атом &lt;code&gt;:Elixir&lt;/code&gt; , расширения не происходит.</target>
        </trans-unit>
        <trans-unit id="f0ef8773abae5ce961ca6ed9da9a8a5ea8e088bb" translate="yes" xml:space="preserve">
          <source>When the index is out of bounds, &lt;code&gt;nil&lt;/code&gt; is returned and the update function is never called:</source>
          <target state="translated">Когда индекс выходит за границы, возвращается &lt;code&gt;nil&lt;/code&gt; и функция обновления никогда не вызывается:</target>
        </trans-unit>
        <trans-unit id="5f5f70104ffa9c3038871840751c7a53ef2fbfc2" translate="yes" xml:space="preserve">
          <source>When the key in a key-value pair is an atom, the &lt;code&gt;key: value&lt;/code&gt; shorthand syntax can be used (as in many other special forms), provided key-value pairs are put at the end:</source>
          <target state="translated">Когда ключ в паре ключ-значение является атомом, можно использовать сокращенный синтаксис &lt;code&gt;key: value&lt;/code&gt; (как и во многих других специальных формах), при условии, что пары ключ-значение помещаются в конец:</target>
        </trans-unit>
        <trans-unit id="92c67571369cee66bfcb870b4d12b5e27452cada" translate="yes" xml:space="preserve">
          <source>When the list is empty, it will match the final clause which returns the final result of &lt;code&gt;6&lt;/code&gt;.</source>
          <target state="translated">Когда список пуст, он будет соответствовать последнему предложению, которое возвращает окончательный результат &lt;code&gt;6&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b5b4de75025c76c7c3c9aeb02b7ac4bb35649ea3" translate="yes" xml:space="preserve">
          <source>When the pattern is a regular expression, one can give &lt;code&gt;\N&lt;/code&gt; or &lt;code&gt;\g{N}&lt;/code&gt; in the &lt;code&gt;replacement&lt;/code&gt; string to access a specific capture in the regular expression:</source>
          <target state="translated">Когда шаблон является регулярным выражением, можно указать &lt;code&gt;\N&lt;/code&gt; или &lt;code&gt;\g{N}&lt;/code&gt; в строке &lt;code&gt;replacement&lt;/code&gt; чтобы получить доступ к определенному захвату в регулярном выражении:</target>
        </trans-unit>
        <trans-unit id="e0d71eb3bfb3d292fa5f932c054528be96603bb4" translate="yes" xml:space="preserve">
          <source>When the pattern used is a regular expression, the string is split using &lt;a href=&quot;https://hexdocs.pm/elixir/Regex.html#split/3&quot;&gt;&lt;code&gt;Regex.split/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Когда используемый шаблон является регулярным выражением, строка разделяется с помощью &lt;a href=&quot;https://hexdocs.pm/elixir/Regex.html#split/3&quot;&gt; &lt;code&gt;Regex.split/3&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b7076cba8ae612bc5e423136274345c6b60737f6" translate="yes" xml:space="preserve">
          <source>When the pattern used is a regular expression, the string is split using &lt;a href=&quot;regex#split/3&quot;&gt;&lt;code&gt;Regex.split/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Когда используемый шаблон является регулярным выражением, строка разделяется с помощью &lt;a href=&quot;regex#split/3&quot;&gt; &lt;code&gt;Regex.split/3&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2bcb0dcaed7090610e887c1da375fc63e59c4ed5" translate="yes" xml:space="preserve">
          <source>When the provided &lt;code&gt;datetime&lt;/code&gt; is ambiguous a tuple with &lt;code&gt;:ambiguous&lt;/code&gt; and two possible periods. The periods in the list are sorted with the first element being the one that begins first.</source>
          <target state="translated">Если указанное значение &lt;code&gt;datetime&lt;/code&gt; неоднозначно, кортеж содержит &lt;code&gt;:ambiguous&lt;/code&gt; и два возможных периода. Точки в списке сортируются, причем первый элемент начинается первым.</target>
        </trans-unit>
        <trans-unit id="1fe6365d1946f947546f751bcb7719dfb32d0adb" translate="yes" xml:space="preserve">
          <source>When the provided &lt;code&gt;datetime&lt;/code&gt; is in a gap - for instance during the &quot;spring forward&quot; when going from winter time to summer time, a tuple with &lt;code&gt;:gap&lt;/code&gt; and two periods with limits are returned in a nested tuple. The first nested two-tuple is the period before the gap and a naive datetime with a limit for when the period ends (wall time). The second nested two-tuple is the period just after the gap and a datetime (wall time) for when the period begins just after the gap.</source>
          <target state="translated">Когда предоставленное &lt;code&gt;datetime&lt;/code&gt; находится в промежутке - например, во время &amp;laquo;весеннего перехода&amp;raquo; при переходе с зимнего времени на летнее время, кортеж с &lt;code&gt;:gap&lt;/code&gt; и два периода с ограничениями возвращаются во вложенном кортеже. Первый вложенный кортеж из двух элементов - это период до разрыва и наивное datetime с ограничением, когда период заканчивается (время стены). Второй вложенный кортеж - это период сразу после разрыва и datetime (время стены), когда период начинается сразу после разрыва.</target>
        </trans-unit>
        <trans-unit id="16bf87a94f168db6511f12fcea262e81e29d5db5" translate="yes" xml:space="preserve">
          <source>When the replacement is a function, the function may have arity N where each argument maps to a capture, with the first argument being the whole match. If the function expects more arguments than captures found, the remaining arguments will receive &lt;code&gt;&quot;&quot;&lt;/code&gt;.</source>
          <target state="translated">Когда замена является функцией, функция может иметь арность N, где каждый аргумент отображается на захват, причем первым аргументом является полное совпадение. Если функция ожидает больше аргументов, чем найдено, остальные аргументы получат &lt;code&gt;&quot;&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1d53459d48259932870dbd718ef131fa6f3ed113" translate="yes" xml:space="preserve">
          <source>When the result is &lt;code&gt;false&lt;/code&gt;, a timer corresponding to &lt;code&gt;timer_ref&lt;/code&gt; could not be found. This can be either because the timer expired, because it has already been canceled, or because &lt;code&gt;timer_ref&lt;/code&gt; never corresponded to a timer.</source>
          <target state="translated">Если результат &lt;code&gt;false&lt;/code&gt; , таймер, соответствующий &lt;code&gt;timer_ref&lt;/code&gt; , не может быть найден. Это может происходить либо потому, что таймер истек, потому что он уже был отменен, либо потому, что &lt;code&gt;timer_ref&lt;/code&gt; никогда не соответствовал таймеру.</target>
        </trans-unit>
        <trans-unit id="deb5988708af4ca0fcbf0783c8851fe13e767117" translate="yes" xml:space="preserve">
          <source>When the result is &lt;code&gt;false&lt;/code&gt;, a timer corresponding to &lt;code&gt;timer_ref&lt;/code&gt; could not be found. This can happen either because the timer expired, because it has already been canceled, or because &lt;code&gt;timer_ref&lt;/code&gt; never corresponded to a timer.</source>
          <target state="translated">Если результат &lt;code&gt;false&lt;/code&gt; , таймер, соответствующий &lt;code&gt;timer_ref&lt;/code&gt; , не может быть найден. Это может произойти либо потому, что таймер истек, потому что он уже был отменен, либо потому, что &lt;code&gt;timer_ref&lt;/code&gt; никогда не соответствовал таймеру.</target>
        </trans-unit>
        <trans-unit id="eb5c37eb9c975eba0eed810f4d26cf67ddbb9330" translate="yes" xml:space="preserve">
          <source>When the result is an integer, it represents the time in milliseconds left until the timer will expire.</source>
          <target state="translated">Когда результат является целым числом,он представляет собой время в миллисекундах,оставшихся до истечения таймера.</target>
        </trans-unit>
        <trans-unit id="ef76de8d282a8dcdcfd2491f1293a65f2b819189" translate="yes" xml:space="preserve">
          <source>When the result is an integer, it represents the time in milliseconds left until the timer would have expired.</source>
          <target state="translated">Когда результат является целым числом,он представляет собой время в миллисекундах,оставшихся до истечения срока действия таймера.</target>
        </trans-unit>
        <trans-unit id="1566d52e1acb479a0372d677819f4198f3d5870e" translate="yes" xml:space="preserve">
          <source>When the right side is an alias (i.e. starts with uppercase), we get instead:</source>
          <target state="translated">Когда правая сторона-это псевдоним (т.е.начинается с заглавного),мы получаем вместо него:</target>
        </trans-unit>
        <trans-unit id="ee4bde23a133e54a751c0692953befb4cdb97b52" translate="yes" xml:space="preserve">
          <source>When the supervisor starts, it traverses all child specifications and then starts each child in the order they are defined. This is done by calling the function defined under the &lt;code&gt;:start&lt;/code&gt; key in the child specification and typically defaults to &lt;code&gt;start_link/1&lt;/code&gt;.</source>
          <target state="translated">Когда супервизор запускается, он просматривает все дочерние спецификации, а затем запускает каждого дочернего элемента в том порядке, в котором они определены. Это делается путем вызова функции, определенной под ключом &lt;code&gt;:start&lt;/code&gt; в дочерней спецификации, и обычно по умолчанию используется &lt;code&gt;start_link/1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d59d60863222f91b9540bc7e612e16d9120fed96" translate="yes" xml:space="preserve">
          <source>When there is a gap in wall time - for instance in spring when the clocks are turned forward - an error will be raised.</source>
          <target state="translated">При наличии зазора в настенном времени-например,весной,когда часы поворачиваются вперед-ошибка будет увеличена.</target>
        </trans-unit>
        <trans-unit id="817e44489d4b19557f85e9b1054b8dfb286e7d81" translate="yes" xml:space="preserve">
          <source>When there is a gap in wall time - for instance in spring when the clocks are turned forward - the latest valid datetime just before the gap and the first valid datetime just after the gap.</source>
          <target state="translated">Когда есть пробел в настенном времени-например,весной,когда часы поворачиваются вперед,-самое позднее действительное время даты непосредственно перед этим зазором и самое первое действительное время даты непосредственно после этого зазора.</target>
        </trans-unit>
        <trans-unit id="89a704e085523c022c1474f3a583587729c0f099" translate="yes" xml:space="preserve">
          <source>When there is a need to &amp;ldquo;print&amp;rdquo; a more complex data structure, one can use the &lt;code&gt;inspect&lt;/code&gt; function, based on the &lt;code&gt;Inspect&lt;/code&gt; protocol:</source>
          <target state="translated">Когда есть необходимость &amp;laquo;распечатать&amp;raquo; более сложную структуру данных, можно использовать функцию &lt;code&gt;inspect&lt;/code&gt; , основанную на протоколе &lt;code&gt;Inspect&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="f6bf9502e79fba8ed757c65a9e4d357939c0a70a" translate="yes" xml:space="preserve">
          <source>When this task runs, it will check if the source code has been modified. If it has changed, &lt;a href=&quot;mix.tasks.xref&quot;&gt;&lt;code&gt;mix xref&lt;/code&gt;&lt;/a&gt; will be run to check remote dispatches. You can force checking regardless of modification time by passing the &lt;code&gt;--force&lt;/code&gt; option.</source>
          <target state="translated">Когда эта задача запускается, она проверяет, был ли изменен исходный код. Если он был изменен, для проверки удаленных отправлений будет запущена &lt;a href=&quot;mix.tasks.xref&quot;&gt; &lt;code&gt;mix xref&lt;/code&gt; &lt;/a&gt; . Вы можете выполнить принудительную проверку независимо от времени модификации, передав параметр &lt;code&gt;--force&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="62fb7e7f6c7c81758b59e89afd8071bd6483f45b" translate="yes" xml:space="preserve">
          <source>When this task runs, it will check the modification time of every file, and if it has changed, the file will be compiled. Files will be compiled in the same source directory with a .erl extension. You can force compilation regardless of modification times by passing the &lt;code&gt;--force&lt;/code&gt; option.</source>
          <target state="translated">Когда эта задача запускается, она проверяет время модификации каждого файла, и если оно изменилось, файл будет скомпилирован. Файлы будут скомпилированы в том же исходном каталоге с расширением .erl. Вы можете принудительно выполнить компиляцию независимо от времени модификации, передав параметр &lt;code&gt;--force&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a07869d83b2ef9bc609cce62a844eb6447e810ed" translate="yes" xml:space="preserve">
          <source>When this task runs, it will first check the modification times of all files to be compiled and if they haven't been changed since the last compilation, it will not compile them. If any of them have changed, it compiles everything.</source>
          <target state="translated">Когда эта задача выполняется,она сначала проверяет время модификации всех скомпилируемых файлов,и если они не были изменены с момента последней компиляции,она их не компилирует.Если что-то из них изменилось,она скомпилирует все.</target>
        </trans-unit>
        <trans-unit id="81fc9d0076e5bbe63feae8494371f9d076e5a6db" translate="yes" xml:space="preserve">
          <source>When to format code</source>
          <target state="translated">Когда форматировать код</target>
        </trans-unit>
        <trans-unit id="a9276e8b40c6df87535bcdb85fb17cf65c3e220e" translate="yes" xml:space="preserve">
          <source>When true, the &lt;code&gt;:start_permanent&lt;/code&gt; option starts your application in permanent mode, which means the Erlang VM will crash if your application&amp;rsquo;s supervision tree shuts down. Notice we don&amp;rsquo;t want this behaviour in dev and test because it is useful to keep the VM instance running in those environments for troubleshooting purposes.</source>
          <target state="translated">Если установлено значение true, параметр &lt;code&gt;:start_permanent&lt;/code&gt; запускает ваше приложение в постоянном режиме, что означает, что виртуальная машина Erlang выйдет из строя, если дерево наблюдения вашего приложения завершится. Обратите внимание, что мы не хотим, чтобы такое поведение выполнялось в среде разработки и тестирования, поскольку для устранения неполадок полезно поддерживать работу экземпляра виртуальной машины в этих средах.</target>
        </trans-unit>
        <trans-unit id="4f9a1ee40840757a2da20f98dce9c92498f29f26" translate="yes" xml:space="preserve">
          <source>When two processes are linked, each one receives exit signals from the other (see also &lt;a href=&quot;#exit/2&quot;&gt;&lt;code&gt;exit/2&lt;/code&gt;&lt;/a&gt;). Let's assume &lt;code&gt;pid1&lt;/code&gt; and &lt;code&gt;pid2&lt;/code&gt; are linked. If &lt;code&gt;pid2&lt;/code&gt; exits with a reason other than &lt;code&gt;:normal&lt;/code&gt; (which is also the exit reason used when a process finishes its job) and &lt;code&gt;pid1&lt;/code&gt; is not trapping exits (see &lt;a href=&quot;#flag/2&quot;&gt;&lt;code&gt;flag/2&lt;/code&gt;&lt;/a&gt;), then &lt;code&gt;pid1&lt;/code&gt; will exit with the same reason as &lt;code&gt;pid2&lt;/code&gt; and in turn emit an exit signal to all its other linked processes. The behaviour when &lt;code&gt;pid1&lt;/code&gt; is trapping exits is described in &lt;a href=&quot;#exit/2&quot;&gt;&lt;code&gt;exit/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Когда два процесса связаны, каждый из них получает сигналы выхода от другого (см. Также &lt;a href=&quot;#exit/2&quot;&gt; &lt;code&gt;exit/2&lt;/code&gt; &lt;/a&gt; ). Предположим, что &lt;code&gt;pid1&lt;/code&gt; и &lt;code&gt;pid2&lt;/code&gt; связаны. Если &lt;code&gt;pid2&lt;/code&gt; завершается по причине, отличной от &lt;code&gt;:normal&lt;/code&gt; (которая также является причиной выхода, используемой, когда процесс завершает свою работу) и &lt;code&gt;pid1&lt;/code&gt; не перехватывает выходы (см. &lt;a href=&quot;#flag/2&quot;&gt; &lt;code&gt;flag/2&lt;/code&gt; &lt;/a&gt; ), тогда &lt;code&gt;pid1&lt;/code&gt; выйдет с той же причиной, что и &lt;code&gt;pid2&lt;/code&gt; , и в Turn посылает сигнал выхода всем другим связанным процессам. Поведение, когда &lt;code&gt;pid1&lt;/code&gt; захватывает выходы, описано в &lt;a href=&quot;#exit/2&quot;&gt; &lt;code&gt;exit/2&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6dba6643714479395ecdc7d925db56d3c380711c" translate="yes" xml:space="preserve">
          <source>When used inside quoting, marks that the given alias should not be hygienized. This means the alias will be expanded when the macro is expanded.</source>
          <target state="translated">При использовании внутри кавычек,отметки,что данный псевдоним не должен быть гигиеничным.Это означает,что псевдоним будет расширен при расширении макроса.</target>
        </trans-unit>
        <trans-unit id="4d695de6a4e80464b19dd42d8515878b64fc9241" translate="yes" xml:space="preserve">
          <source>When used inside quoting, marks that the given variable should not be hygienized.</source>
          <target state="translated">При использовании внутри кавычек отмечает,что данная переменная не должна быть гигиенизирована.</target>
        </trans-unit>
        <trans-unit id="3c4b1b7c86346563bb3b33da3cb8c7c9d963d7d2" translate="yes" xml:space="preserve">
          <source>When used, it accepts the following options:</source>
          <target state="translated">При использовании он принимает следующие варианты:</target>
        </trans-unit>
        <trans-unit id="118cb9495dac7ccab88ff4eee2283ded576a5302" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;--cover&lt;/code&gt; with the default coverage tool, the coverage tool supports an &lt;code&gt;:export&lt;/code&gt; option to export the coverage results into a directory. This is useful when there are multiple test suites (such as in an umbrella app) or when a single test suite is partitioned across multiple runs when using the &lt;code&gt;mix test --partitions N&lt;/code&gt; option.</source>
          <target state="translated">При использовании &lt;code&gt;--cover&lt;/code&gt; с инструментом покрытия по умолчанию, инструмент покрытия поддерживает параметр &lt;code&gt;:export&lt;/code&gt; для экспорта результатов покрытия в каталог. Это полезно , когда есть несколько тестовых наборы (например, в зонтичном приложении) , или когда один тестовый пакет разделен на несколько трасс при использовании &lt;code&gt;mix test --partitions N&lt;/code&gt; варианта.</target>
        </trans-unit>
        <trans-unit id="11eb21eebbb18164e016f1c4fa392ee88b44b563" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;:spawn_executable&lt;/code&gt;, the list of arguments can be passed via the &lt;code&gt;:args&lt;/code&gt; option as done above. For the full list of options, see the documentation for the Erlang function &lt;a href=&quot;http://www.erlang.org/doc/man/erlang.html#open_port-2&quot;&gt;&lt;code&gt;:erlang.open_port/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">При использовании &lt;code&gt;:spawn_executable&lt;/code&gt; список аргументов можно передать с помощью параметра &lt;code&gt;:args&lt;/code&gt; , как это было сделано выше. Полный список параметров см. В документации к функции Erlang &lt;a href=&quot;http://www.erlang.org/doc/man/erlang.html#open_port-2&quot;&gt; &lt;code&gt;:erlang.open_port/2&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="09dea428dda95adef253e55ed94d7014ea9f1ea4" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;iex&lt;/code&gt;, the &lt;a href=&quot;https://hexdocs.pm/iex/IEx.Helpers.html#b/1&quot;&gt;&lt;code&gt;IEx.Helpers.b/1&lt;/code&gt;&lt;/a&gt; helper is also available.</source>
          <target state="translated">При использовании &lt;code&gt;iex&lt;/code&gt; , то &lt;a href=&quot;https://hexdocs.pm/iex/IEx.Helpers.html#b/1&quot;&gt; &lt;code&gt;IEx.Helpers.b/1&lt;/code&gt; &lt;/a&gt; помощник также доступен.</target>
        </trans-unit>
        <trans-unit id="0532ce4ac8a5c6ad2c52a2b5f9b566e548e2dcfa" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;location: :keep&lt;/code&gt; and invalid arguments are given to &lt;code&gt;Sample.add/2&lt;/code&gt;, the stacktrace information will point to the file and line inside the quote. Without &lt;code&gt;location: :keep&lt;/code&gt;, the error is reported to where &lt;code&gt;defadd&lt;/code&gt; was invoked. &lt;code&gt;location: :keep&lt;/code&gt; affects only definitions inside the quote.</source>
          <target state="translated">При использовании &lt;code&gt;location: :keep&lt;/code&gt; и недопустимых аргументов для &lt;code&gt;Sample.add/2&lt;/code&gt; информация трассировки стека будет указывать на файл и строку внутри цитаты. Без &lt;code&gt;location: :keep&lt;/code&gt; об ошибке &lt;code&gt;defadd&lt;/code&gt; туда, где был вызван defadd . &lt;code&gt;location: :keep&lt;/code&gt; влияет только на определения внутри цитаты.</target>
        </trans-unit>
        <trans-unit id="e32b79e90bc5213e96ed814396349030773cd138" translate="yes" xml:space="preserve">
          <source>When using Mix, you can run all tests in a describe block by name:</source>
          <target state="translated">При использовании Mix все тесты можно запускать в блоке описания по имени:</target>
        </trans-unit>
        <trans-unit id="16d7eda521d9dd1f3f49ae777c0c270bd44b3016" translate="yes" xml:space="preserve">
          <source>When using default values, one must be careful to avoid overlapping function definitions. Consider the following example:</source>
          <target state="translated">При использовании значений по умолчанию следует быть осторожным,чтобы избежать перекрытия определений функций.Рассмотрим следующий пример:</target>
        </trans-unit>
        <trans-unit id="d6654b695e9969cbc5da309dbf219f84c2b28aa9" translate="yes" xml:space="preserve">
          <source>When using ranges:</source>
          <target state="translated">При использовании диапазонов:</target>
        </trans-unit>
        <trans-unit id="f4e0ef31ee1ee252959b73eca8437281378616ce" translate="yes" xml:space="preserve">
          <source>When using the update syntax (&lt;code&gt;|&lt;/code&gt;), the</source>
          <target state="translated">При использовании синтаксиса обновления ( &lt;code&gt;|&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="bb7e8b90b84bd9cda137c3810fbc290000ca2f96" translate="yes" xml:space="preserve">
          <source>When using umbrella applications, it is important to have a clear boundary between them. Our upcoming &lt;code&gt;kv_server&lt;/code&gt; must only access public APIs defined in &lt;code&gt;kv&lt;/code&gt;. Think of your umbrella apps as any other dependency or even Elixir itself: you can only access what is public and documented. Reaching into private functionality in your dependencies is a poor practice that will eventually cause your code to break when a new version is up.</source>
          <target state="translated">При использовании зонтичных приложений важно иметь четкую границу между ними. Наш будущий &lt;code&gt;kv_server&lt;/code&gt; должен иметь доступ только к общедоступным API, определенным в &lt;code&gt;kv&lt;/code&gt; . Думайте о своих зонтичных приложениях как о любой другой зависимости или даже о самом Эликсире: вы можете получить доступ только к тому, что является общедоступным и документированным. Обращение к частным функциям в ваших зависимостях - плохая практика, которая в конечном итоге приведет к поломке вашего кода при выходе новой версии.</target>
        </trans-unit>
        <trans-unit id="2c98c890488f972198844594710fa00dc3ba20fe" translate="yes" xml:space="preserve">
          <source>When we &lt;code&gt;use Application&lt;/code&gt;, we may define a couple functions, similar to when we used &lt;code&gt;Supervisor&lt;/code&gt; or &lt;code&gt;GenServer&lt;/code&gt;. This time we only had to define a &lt;code&gt;start/2&lt;/code&gt; function. The &lt;code&gt;Application&lt;/code&gt; behaviour also has a &lt;code&gt;stop/1&lt;/code&gt; callback, but it is rarely used in practice, you can check the documentation for more information.</source>
          <target state="translated">Когда мы &lt;code&gt;use Application&lt;/code&gt; , мы можем определить пару функций, как при использовании &lt;code&gt;Supervisor&lt;/code&gt; или &lt;code&gt;GenServer&lt;/code&gt; . На этот раз нам нужно было определить только функцию &lt;code&gt;start/2&lt;/code&gt; . &lt;code&gt;Application&lt;/code&gt; поведение также имеет &lt;code&gt;stop/1&lt;/code&gt; обратный вызов, но он редко используется на практике, вы можете проверить документацию для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="bccf445c6c3ffc1e761deaaf0235e5ae767ca76e" translate="yes" xml:space="preserve">
          <source>When we &lt;code&gt;use Application&lt;/code&gt;, we may define a couple of functions, similar to when we used &lt;code&gt;Supervisor&lt;/code&gt; or &lt;code&gt;GenServer&lt;/code&gt;. This time we only had to define a &lt;code&gt;start/2&lt;/code&gt; function. The &lt;code&gt;Application&lt;/code&gt; behaviour also has a &lt;code&gt;stop/1&lt;/code&gt; callback, but it is rarely used in practice. You can check the documentation for more information.</source>
          <target state="translated">Когда мы &lt;code&gt;use Application&lt;/code&gt; , мы можем определить несколько функций, как при использовании &lt;code&gt;Supervisor&lt;/code&gt; или &lt;code&gt;GenServer&lt;/code&gt; . На этот раз нам нужно было определить только функцию &lt;code&gt;start/2&lt;/code&gt; . &lt;code&gt;Application&lt;/code&gt; поведение также имеет &lt;code&gt;stop/1&lt;/code&gt; обратный вызов, но он редко используется на практике. Вы можете проверить документацию для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="5b7058116f53f35239e2356beda55ec8034d3117" translate="yes" xml:space="preserve">
          <source>When we added &lt;code&gt;KV.BucketSupervisor&lt;/code&gt; as a child of &lt;code&gt;KV.Supervisor&lt;/code&gt;, we began to have supervisors that supervise other supervisors, forming so-called &amp;ldquo;supervision trees&amp;rdquo;.</source>
          <target state="translated">Когда мы добавили &lt;code&gt;KV.BucketSupervisor&lt;/code&gt; как потомок &lt;code&gt;KV.Supervisor&lt;/code&gt; , у нас появились супервизоры, которые контролируют других супервизоров, формируя так называемые &amp;laquo;деревья супервизоров&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="db2b543292422d67aa65cb035608589347e4a67a" translate="yes" xml:space="preserve">
          <source>When we call:</source>
          <target state="translated">Когда мы позвоним:</target>
        </trans-unit>
        <trans-unit id="c84904df1425d5dd9decb2d480d2165f3ad3805e" translate="yes" xml:space="preserve">
          <source>When we discussed maps, we showed how we can access and update the fields of a map. The same techniques (and the same syntax) apply to structs as well:</source>
          <target state="translated">Когда мы обсуждали карты,мы показывали,как мы можем получить доступ к полям карты и обновить их.Те же самые методы (и тот же синтаксис)применяются и к структурам:</target>
        </trans-unit>
        <trans-unit id="3ffe287a4ee207e44ff584189d143d006b07e2c8" translate="yes" xml:space="preserve">
          <source>When we reload the module in IEx, we recompile the module source code, updating its contents in memory. The original &lt;code&gt;.beam&lt;/code&gt; file in disk, probably the one where the first definition of the module came from, does not change at all.</source>
          <target state="translated">Когда мы перезагружаем модуль в IEx, мы перекомпилируем исходный код модуля, обновляя его содержимое в памяти. Оригинальный &lt;code&gt;.beam&lt;/code&gt; файл на диске, вероятно , тот , где первое определение модуля взялось, не меняется.</target>
        </trans-unit>
        <trans-unit id="b1b7e04a25c2e9cd8adc060ab8f333c0cb576192" translate="yes" xml:space="preserve">
          <source>When we say &amp;ldquo;project&amp;rdquo; you should think about Mix. Mix is the tool that manages your project. It knows how to compile your project, test your project and more. It also knows how to compile and start the application relevant to your project.</source>
          <target state="translated">Когда мы говорим &amp;laquo;проект&amp;raquo;, вы должны думать о Mix. Mix - это инструмент, который управляет вашим проектом. Он знает, как скомпилировать ваш проект, протестировать ваш проект и многое другое. Он также знает, как скомпилировать и запустить приложение, соответствующее вашему проекту.</target>
        </trans-unit>
        <trans-unit id="3988e99c0afba10ffddaaa653e055af9c86b1e3c" translate="yes" xml:space="preserve">
          <source>When we talk about applications, we talk about</source>
          <target state="translated">Когда мы говорим о приложениях,мы говорим о</target>
        </trans-unit>
        <trans-unit id="a55806641c97dbdd5be2b9424fe4617aa3a3d6ed" translate="yes" xml:space="preserve">
          <source>When working on actual projects, the build tool called &lt;code&gt;mix&lt;/code&gt; will be responsible for compiling and setting up the proper paths for you. For learning purposes, Elixir also supports a scripted mode which is more flexible and does not generate any compiled artifacts.</source>
          <target state="translated">При работе над реальными проектами инструмент сборки под названием &lt;code&gt;mix&lt;/code&gt; будет отвечать за компиляцию и настройку правильных путей для вас. В целях обучения Elixir также поддерживает более гибкий сценарий со сценарием, который не создает никаких скомпилированных артефактов.</target>
        </trans-unit>
        <trans-unit id="4555a713f8f0c47c0fda29090ee90e21d1fb8b9c" translate="yes" xml:space="preserve">
          <source>When working with Elixir projects, using the Mix build tool, you may see the output as follows:</source>
          <target state="translated">При работе с проектами Elixir,используя инструмент Mix build tool,вы можете увидеть результат следующим образом:</target>
        </trans-unit>
        <trans-unit id="4a7946a9fc0373dce56fd29a1a8c3afde30edd76" translate="yes" xml:space="preserve">
          <source>When writing documentation:</source>
          <target state="translated">При написании документации:</target>
        </trans-unit>
        <trans-unit id="7edece0006beadc23495370d9f59344caf5ee8ed" translate="yes" xml:space="preserve">
          <source>When written in multiline form and pasted into IEx this valid expression produces a syntax error:</source>
          <target state="translated">При записи в многострочном виде и вставке в IEx это корректное выражение приводит к синтаксической ошибке:</target>
        </trans-unit>
        <trans-unit id="4f88c1b7710727be1867ef5ea07ba0b0d812f06b" translate="yes" xml:space="preserve">
          <source>When you absolutely have to use a macro, make sure that a macro is not the only way the user can interface with your library and keep the amount of code generated by a macro to a minimum. For example, the &lt;a href=&quot;https://hexdocs.pm/logger/Logger.html&quot;&gt;&lt;code&gt;Logger&lt;/code&gt;&lt;/a&gt; module provides &lt;a href=&quot;https://hexdocs.pm/logger/Logger.html#debug/2&quot;&gt;&lt;code&gt;Logger.debug/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://hexdocs.pm/logger/Logger.html#info/2&quot;&gt;&lt;code&gt;Logger.info/2&lt;/code&gt;&lt;/a&gt; and friends as macros that are capable of extracting environment information, but a low-level mechanism for logging is still available with &lt;a href=&quot;https://hexdocs.pm/logger/Logger.html#bare_log/3&quot;&gt;&lt;code&gt;Logger.bare_log/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Когда вам абсолютно необходимо использовать макрос, убедитесь, что макрос - это не единственный способ взаимодействия пользователя с вашей библиотекой, и свести к минимуму объем кода, генерируемого макросом. Например, модуль &lt;a href=&quot;https://hexdocs.pm/logger/Logger.html&quot;&gt; &lt;code&gt;Logger&lt;/code&gt; &lt;/a&gt; предоставляет &lt;a href=&quot;https://hexdocs.pm/logger/Logger.html#debug/2&quot;&gt; &lt;code&gt;Logger.debug/2&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://hexdocs.pm/logger/Logger.html#info/2&quot;&gt; &lt;code&gt;Logger.info/2&lt;/code&gt; &lt;/a&gt; и другие макросы в качестве макросов, способных извлекать информацию о среде, но низкоуровневый механизм регистрации по-прежнему доступен с &lt;a href=&quot;https://hexdocs.pm/logger/Logger.html#bare_log/3&quot;&gt; &lt;code&gt;Logger.bare_log/3&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f1638480636a28cbc011e903bfbe6652cd3090fd" translate="yes" xml:space="preserve">
          <source>When you install Elixir, besides getting the &lt;code&gt;elixir&lt;/code&gt;, &lt;code&gt;elixirc&lt;/code&gt; and &lt;code&gt;iex&lt;/code&gt; executables, you also get an executable Elixir script named &lt;code&gt;mix&lt;/code&gt;.</source>
          <target state="translated">При установке эликсира, кроме получения &lt;code&gt;elixir&lt;/code&gt; , &lt;code&gt;elixirc&lt;/code&gt; и &lt;code&gt;iex&lt;/code&gt; исполняемых файлов, вы также можете получить исполняемый скрипт Elixir под названием &lt;code&gt;mix&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="51445e6109f96044711e17778f35ac063ea05da9" translate="yes" xml:space="preserve">
          <source>When you install Elixir, you will have three new executables: &lt;code&gt;iex&lt;/code&gt;, &lt;code&gt;elixir&lt;/code&gt; and &lt;code&gt;elixirc&lt;/code&gt;. If you compiled Elixir from source or are using a packaged version, you can find these inside the &lt;code&gt;bin&lt;/code&gt; directory.</source>
          <target state="translated">При установке эликсира, вы будете иметь три новые исполняемые файлы: &lt;code&gt;iex&lt;/code&gt; , &lt;code&gt;elixir&lt;/code&gt; и &lt;code&gt;elixirc&lt;/code&gt; . Если вы скомпилировали Elixir из исходного кода или используете упакованную версию, вы можете найти их в каталоге &lt;code&gt;bin&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="64869216e949cc8b1e4b90b19a8879d36be5ed8e" translate="yes" xml:space="preserve">
          <source>When you invoke a function in the &lt;a href=&quot;enum&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; module, the first argument is usually a collection that must implement this protocol. For example, the expression:</source>
          <target state="translated">Когда вы вызываете функцию в модуле &lt;a href=&quot;enum&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt; , первым аргументом обычно является коллекция, которая должна реализовывать этот протокол. Например, выражение:</target>
        </trans-unit>
        <trans-unit id="d755962a4503432fec6f9fbb5e73cd392ddd6fa9" translate="yes" xml:space="preserve">
          <source>When you invoke a function in the &lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; module, the first argument is usually a collection that must implement this protocol. For example, the expression:</source>
          <target state="translated">Когда вы вызываете функцию в модуле &lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt; , первым аргументом обычно является коллекция, которая должна реализовывать этот протокол. Например, выражение:</target>
        </trans-unit>
        <trans-unit id="fdc24bbab3bae3af51622412701d86913a237da3" translate="yes" xml:space="preserve">
          <source>When you run &lt;code&gt;iex -S mix&lt;/code&gt;, it is equivalent to running &lt;code&gt;iex -S mix run&lt;/code&gt;. So whenever you need to pass more options to Mix when starting IEx, it&amp;rsquo;s a matter of typing &lt;code&gt;iex -S mix run&lt;/code&gt; and then passing any options the &lt;code&gt;run&lt;/code&gt; command accepts. You can find more information by running &lt;code&gt;mix help run&lt;/code&gt; in your shell.</source>
          <target state="translated">Запуск &lt;code&gt;iex -S mix&lt;/code&gt; эквивалентен запуску &lt;code&gt;iex -S mix run&lt;/code&gt; . Поэтому всякий раз, когда вам нужно передать дополнительные параметры Mix при запуске IEx, достаточно &lt;code&gt;iex -S mix run&lt;/code&gt; команду iex -S mix run, а затем передать любые параметры, &lt;code&gt;run&lt;/code&gt; принимает команда run . Вы можете найти дополнительную информацию, запустив &lt;code&gt;mix help run&lt;/code&gt; в своей оболочке.</target>
        </trans-unit>
        <trans-unit id="d6917ee6422f5bcc16f5dc4c157fbd880bb1f29c" translate="yes" xml:space="preserve">
          <source>When you see &lt;code&gt;length&lt;/code&gt;, the operation runs in linear time (&quot;O(n) time&quot;) because the entire data structure has to be traversed.</source>
          <target state="translated">Когда вы видите &lt;code&gt;length&lt;/code&gt; , операция выполняется за линейное время (&amp;laquo;O (n) time&amp;raquo;), потому что необходимо пройти всю структуру данных.</target>
        </trans-unit>
        <trans-unit id="f1098aafc109071152ed8dbff4d163fca52f7b5c" translate="yes" xml:space="preserve">
          <source>When you see &lt;code&gt;size&lt;/code&gt; in a function name, it means the operation runs in constant time (also written as &quot;O(1) time&quot;) because the size is stored alongside the data structure.</source>
          <target state="translated">Когда вы видите &lt;code&gt;size&lt;/code&gt; в имени функции, это означает, что операция выполняется в постоянное время (также обозначаемое как &amp;laquo;время O (1)&amp;raquo;), потому что размер сохраняется вместе со структурой данных.</target>
        </trans-unit>
        <trans-unit id="32066dced8bf4260f74494c122dd24f5d3dcc107" translate="yes" xml:space="preserve">
          <source>When you start the debugger, a Graphical User Interface will open in your machine. We call &lt;code&gt;:int.ni(Example)&lt;/code&gt; to prepare our module for debugging and then add a breakpoint to line 3 with &lt;code&gt;:int.break(Example, 3)&lt;/code&gt;. After we call our function, we can see our process with break status in the debugger:</source>
          <target state="translated">Когда вы запустите отладчик, на вашем компьютере откроется графический интерфейс пользователя. Мы вызываем &lt;code&gt;:int.ni(Example)&lt;/code&gt; чтобы подготовить наш модуль к отладке, а затем добавляем &lt;code&gt;:int.break(Example, 3)&lt;/code&gt; останова в строку 3 с помощью : int.break (Пример, 3) . После того, как мы вызовем нашу функцию, мы можем увидеть наш процесс со статусом прерывания в отладчике:</target>
        </trans-unit>
        <trans-unit id="85ee2542605069975551a95d3a9fdf49f42f9fb7" translate="yes" xml:space="preserve">
          <source>Whenever a doctest starts with &quot;#Name&amp;lt;&quot;, &lt;code&gt;doctest&lt;/code&gt; will perform a string comparison. For example, the above test will perform the following match:</source>
          <target state="translated">Всякий раз, когда doctest начинается с &amp;laquo;#Name &amp;lt;&amp;raquo;, &lt;code&gt;doctest&lt;/code&gt; выполняет сравнение строк. Например, в приведенном выше тесте будет выполнено следующее совпадение:</target>
        </trans-unit>
        <trans-unit id="104ae960f9f0bec57555668b66cbc292e7eada47" translate="yes" xml:space="preserve">
          <source>Whenever a message is logged, additional information can be given via metadata. Each log operation, such as &lt;a href=&quot;#info/2&quot;&gt;&lt;code&gt;Logger.info/2&lt;/code&gt;&lt;/a&gt;, allows metadata to be given as argument.</source>
          <target state="translated">Всякий раз, когда сообщение регистрируется, дополнительная информация может быть предоставлена ​​через метаданные. Каждая операция журнала, такая как &lt;a href=&quot;#info/2&quot;&gt; &lt;code&gt;Logger.info/2&lt;/code&gt; &lt;/a&gt; , позволяет указывать метаданные в качестве аргумента.</target>
        </trans-unit>
        <trans-unit id="d0343678ea7a046b13fb51d1726454724348b519" translate="yes" xml:space="preserve">
          <source>Whenever an expression iterator sees a &lt;code&gt;:.&lt;/code&gt; as the tuple key, it can be sure that it represents a call and the second argument in the list is an atom.</source>
          <target state="translated">Всякий раз, когда итератор выражения видит &lt;code&gt;:.&lt;/code&gt; в качестве ключа кортежа можно быть уверенным, что он представляет вызов, а второй аргумент в списке - атом.</target>
        </trans-unit>
        <trans-unit id="a39390368c995ec3d4e4d59a6dd560fa4603c1d1" translate="yes" xml:space="preserve">
          <source>Whenever we invoke &lt;code&gt;iex -S mix&lt;/code&gt;, Mix automatically starts our application by calling &lt;code&gt;Application.start(:kv)&lt;/code&gt;. But can we customize what happens when our application starts? As a matter of fact, we can! To do so, we define an application callback.</source>
          <target state="translated">Каждый раз, когда мы вызываем &lt;code&gt;iex -S mix&lt;/code&gt; , Mix автоматически запускает наше приложение, вызывая &lt;code&gt;Application.start(:kv)&lt;/code&gt; . Но можем ли мы настроить, что происходит при запуске нашего приложения? Фактически, мы можем! Для этого мы определяем обратный вызов приложения.</target>
        </trans-unit>
        <trans-unit id="6ac32d51cd0b61fc0f811a675f20bfe5b116ba28" translate="yes" xml:space="preserve">
          <source>Whenever you invoke a &lt;code&gt;mix&lt;/code&gt; command, Mix loads the configuration in &lt;code&gt;config/config.exs&lt;/code&gt;, if said file exists. It is common for the &lt;code&gt;config/config.exs&lt;/code&gt; file itself to import other configuration based on the current &lt;code&gt;MIX_ENV&lt;/code&gt;, such as &lt;code&gt;config/dev.exs&lt;/code&gt;, &lt;code&gt;config/test.exs&lt;/code&gt;, and &lt;code&gt;config/prod.exs&lt;/code&gt;. We say that this configuration is a build-time configuration as it is evaluated whenever you compile your code or whenever you assemble the release.</source>
          <target state="translated">Каждый раз, когда вы вызываете команду &lt;code&gt;mix&lt;/code&gt; , Mix загружает конфигурацию в &lt;code&gt;config/config.exs&lt;/code&gt; , если указанный файл существует. Обычно для &lt;code&gt;config/config.exs&lt;/code&gt; самого файла , чтобы импортировать другую конфигурацию на основе текущего &lt;code&gt;MIX_ENV&lt;/code&gt; , такие как &lt;code&gt;config/dev.exs&lt;/code&gt; , &lt;code&gt;config/test.exs&lt;/code&gt; и &lt;code&gt;config/prod.exs&lt;/code&gt; . Мы говорим, что эта конфигурация является конфигурацией времени сборки, поскольку она оценивается всякий раз, когда вы компилируете свой код или всякий раз, когда вы собираете выпуск.</target>
        </trans-unit>
        <trans-unit id="46426dcf93a27179d19a66c1a5ce7b3db0ca84b2" translate="yes" xml:space="preserve">
          <source>Whenever you need a key-value store, maps are the &amp;ldquo;go to&amp;rdquo; data structure in Elixir. A map is created using the &lt;code&gt;%{}&lt;/code&gt; syntax:</source>
          <target state="translated">Всякий раз, когда вам нужно хранилище ключей и значений, карты являются структурой данных &amp;laquo;перехода&amp;raquo; в Elixir. Карта создается с использованием синтаксиса &lt;code&gt;%{}&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="4a4aa4923bd36be72dbe6f53c5381b13f315dd6a" translate="yes" xml:space="preserve">
          <source>Whenever you start a new process, Elixir annotates the parent of that process through the &lt;code&gt;$ancestors&lt;/code&gt; key in the process dictionary. This is often used to track the hierarchy inside a supervision tree.</source>
          <target state="translated">Каждый раз, когда вы запускаете новый процесс, Elixir аннотирует родителя этого процесса с помощью ключа &lt;code&gt;$ancestors&lt;/code&gt; в словаре процесса. Это часто используется для отслеживания иерархии внутри дерева надзора.</target>
        </trans-unit>
        <trans-unit id="367c170da441f4a9f1911cc978e43bc196c54b25" translate="yes" xml:space="preserve">
          <source>Where &quot;remsh&quot; means &quot;remote shell&quot;. In general, Elixir supports:</source>
          <target state="translated">Где &quot;remsh&quot; означает &quot;удаленная оболочка&quot;.В общем,Эликсир поддерживает:</target>
        </trans-unit>
        <trans-unit id="a611ce6f5741ed9a3522b8e9c3227865053830c5" translate="yes" xml:space="preserve">
          <source>Where &lt;code&gt;&amp;amp;clean_extra/1&lt;/code&gt; would be a function in your &lt;code&gt;mix.exs&lt;/code&gt; with extra cleanup logic.</source>
          <target state="translated">Где &lt;code&gt;&amp;amp;clean_extra/1&lt;/code&gt; будет функцией в вашем &lt;code&gt;mix.exs&lt;/code&gt; с дополнительной логикой очистки.</target>
        </trans-unit>
        <trans-unit id="cbce7e222b32979ca5deb65f6d63d9c44de3c563" translate="yes" xml:space="preserve">
          <source>Where guards can be used</source>
          <target state="translated">Где могут быть использованы охранники</target>
        </trans-unit>
        <trans-unit id="0a69749d1ba1c1724f7fe8e79c8264221798436c" translate="yes" xml:space="preserve">
          <source>Where in a file the diagnostic applies. Can be either a line number, a range specified as &lt;code&gt;{start_line, start_col, end_line, end_col}&lt;/code&gt;, or &lt;code&gt;nil&lt;/code&gt; if unknown.</source>
          <target state="translated">Где в файле применяется диагностика. Может быть либо номером строки, либо диапазоном, указанным как &lt;code&gt;{start_line, start_col, end_line, end_col}&lt;/code&gt; , или &lt;code&gt;nil&lt;/code&gt; если он неизвестен.</target>
        </trans-unit>
        <trans-unit id="043eff13884131b4ada78cf55a75cecd84218aa2" translate="yes" xml:space="preserve">
          <source>Where patterns and guards can be used</source>
          <target state="translated">Где можно использовать шаблоны и ограждения</target>
        </trans-unit>
        <trans-unit id="0320ac9cef49bf6819f7f5ea05026898ca882a24" translate="yes" xml:space="preserve">
          <source>Where to go next</source>
          <target state="translated">Куда идти дальше</target>
        </trans-unit>
        <trans-unit id="7e741bc3dcef0123eeda11543758853be2aac149" translate="yes" xml:space="preserve">
          <source>Where:</source>
          <target state="translated">Where:</target>
        </trans-unit>
        <trans-unit id="b54670d9e959f148593cc88086db78455f88db6b" translate="yes" xml:space="preserve">
          <source>Whereas strings (i.e. binaries) are created using double-quotes, charlists are created with single-quoted literals:</source>
          <target state="translated">В то время как строки (т.е.двоичные файлы)создаются с использованием двойных кавычек,чарлисты создаются с однокавычными литералами:</target>
        </trans-unit>
        <trans-unit id="e24583f0fef7d30e388aaa6bc96a6e3a7f4ff25e" translate="yes" xml:space="preserve">
          <source>Which invokes the function twice, explaining why we get the printed value twice! In the majority of the cases, this is actually unexpected behaviour, and that's why one of the first things you need to keep in mind when it comes to macros is to &lt;strong&gt;not unquote the same value more than once&lt;/strong&gt;.</source>
          <target state="translated">Это вызывает функцию дважды, объясняя, почему мы получаем напечатанное значение дважды! В большинстве случаев это на самом деле неожиданное поведение, и поэтому одна из первых вещей, которые вам нужно иметь в виду, когда дело доходит до макросов, - &lt;strong&gt;не отменять одно и то же значение более одного раза&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="c0bd033db9d91d7c8b4d117215134fdf3977195b" translate="yes" xml:space="preserve">
          <source>Which is equivalent to matching on &lt;code&gt;[?h, ?e, ?l, ?l, ?o, ?\s | world]&lt;/code&gt;. Suffix matches (&lt;code&gt;hello ++ ' world'&lt;/code&gt;) are not valid patterns.</source>
          <target state="translated">Что эквивалентно сопоставлению по &lt;code&gt;[?h, ?e, ?l, ?l, ?o, ?\s | world]&lt;/code&gt; . Совпадения суффиксов ( &lt;code&gt;hello ++ ' world'&lt;/code&gt; ) не являются допустимыми шаблонами.</target>
        </trans-unit>
        <trans-unit id="610c7400d727b3d0294243a02c10a7e75f931042" translate="yes" xml:space="preserve">
          <source>Which is equivalent to:</source>
          <target state="translated">Что эквивалентно:</target>
        </trans-unit>
        <trans-unit id="ee6f87c8bf9b769a438c8d350f11dd19efcc7631" translate="yes" xml:space="preserve">
          <source>Which is not the expected result. For this, we use &lt;code&gt;unquote&lt;/code&gt;:</source>
          <target state="translated">А это не ожидаемый результат. Для этого мы используем &lt;code&gt;unquote&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="9a1cee54eca00c3fd762b45316feb118ef6e1149" translate="yes" xml:space="preserve">
          <source>Which is similar to:</source>
          <target state="translated">Что похоже на то:</target>
        </trans-unit>
        <trans-unit id="e7611a003e06cd6cbd9a976440d116ba106999f7" translate="yes" xml:space="preserve">
          <source>Which means we store the following relationships:</source>
          <target state="translated">Что означает,что мы храним следующие отношения:</target>
        </trans-unit>
        <trans-unit id="865f281221c86013dcb74eebdc4c8949d79babac" translate="yes" xml:space="preserve">
          <source>Which technique is best between deriving and falling back to any depends on the use case but, given Elixir developers prefer explicit over implicit, you may see many libraries pushing towards the &lt;code&gt;@derive&lt;/code&gt; approach.</source>
          <target state="translated">Какой метод лучше всего выбрать между производным и обратным &lt;code&gt;@derive&lt;/code&gt; от варианта использования, но, учитывая, что разработчики Elixir предпочитают явное, а не неявное, вы можете увидеть, что многие библиотеки продвигаются к подходу @derive .</target>
        </trans-unit>
        <trans-unit id="cbd5368b4b8756e1f8174c9b573f020295a6bdf8" translate="yes" xml:space="preserve">
          <source>Which would then return:</source>
          <target state="translated">Который потом вернется:</target>
        </trans-unit>
        <trans-unit id="f2107dde537e90ae147db95c27b028e84ef989ac" translate="yes" xml:space="preserve">
          <source>Which, as we have seen above, is the same as:</source>
          <target state="translated">Что,как мы видели выше,является тем же самым:</target>
        </trans-unit>
        <trans-unit id="f101833a43dae895e5bf1409c2a111fb485239ce" translate="yes" xml:space="preserve">
          <source>While &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Inspect.Algebra&lt;/code&gt;&lt;/a&gt; accepts binaries as documents, those are counted by binary size. On the other hand, &lt;code&gt;string&lt;/code&gt; documents are measured in terms of graphemes towards the document size.</source>
          <target state="translated">Хотя &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Inspect.Algebra&lt;/code&gt; &lt;/a&gt; принимает двоичные файлы как документы, они считаются по размеру двоичного файла. С другой стороны, &lt;code&gt;string&lt;/code&gt; документы измеряются в графемах по отношению к размеру документа.</target>
        </trans-unit>
        <trans-unit id="006d02aa295a1431a596e309715a50dd81911529" translate="yes" xml:space="preserve">
          <source>While &lt;a href=&quot;#require_file/2&quot;&gt;&lt;code&gt;require_file/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#compile_file/2&quot;&gt;&lt;code&gt;compile_file/2&lt;/code&gt;&lt;/a&gt; return the loaded modules and their bytecode, &lt;a href=&quot;#eval_file/2&quot;&gt;&lt;code&gt;eval_file/2&lt;/code&gt;&lt;/a&gt; simply evaluates the file contents and returns the evaluation result and its binding (exactly the same return value as &lt;a href=&quot;#eval_string/3&quot;&gt;&lt;code&gt;eval_string/3&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">В то время как &lt;a href=&quot;#require_file/2&quot;&gt; &lt;code&gt;require_file/2&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;#compile_file/2&quot;&gt; &lt;code&gt;compile_file/2&lt;/code&gt; &lt;/a&gt; возвращают загруженные модули и их байт-код, &lt;a href=&quot;#eval_file/2&quot;&gt; &lt;code&gt;eval_file/2&lt;/code&gt; &lt;/a&gt; просто оценивает содержимое файла и возвращает результат оценки и его привязку (точно такое же возвращаемое значение, что и &lt;a href=&quot;#eval_string/3&quot;&gt; &lt;code&gt;eval_string/3&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="b70763808f360802ddcc8101a8762434700f5098" translate="yes" xml:space="preserve">
          <source>While &lt;a href=&quot;#require_file/2&quot;&gt;&lt;code&gt;require_file/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#compile_file/2&quot;&gt;&lt;code&gt;compile_file/2&lt;/code&gt;&lt;/a&gt; return the loaded modules and their bytecode, &lt;a href=&quot;#eval_file/2&quot;&gt;&lt;code&gt;eval_file/2&lt;/code&gt;&lt;/a&gt; simply evaluates the file contents and returns the evaluation result and its bindings (exactly the same return value as &lt;a href=&quot;#eval_string/3&quot;&gt;&lt;code&gt;eval_string/3&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">В то время как &lt;a href=&quot;#require_file/2&quot;&gt; &lt;code&gt;require_file/2&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;#compile_file/2&quot;&gt; &lt;code&gt;compile_file/2&lt;/code&gt; &lt;/a&gt; возвращают загруженные модули и их байт-код, &lt;a href=&quot;#eval_file/2&quot;&gt; &lt;code&gt;eval_file/2&lt;/code&gt; &lt;/a&gt; просто оценивает содержимое файла и возвращает результат оценки и его привязки (точно такое же возвращаемое значение, что и &lt;a href=&quot;#eval_string/3&quot;&gt; &lt;code&gt;eval_string/3&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="69f666585bc38ea0ba4d6c87139b5a142a30dbda" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;IO.inspect/2&lt;/code&gt; is static, Elixir&amp;rsquo;s interactive shell provides more dynamic ways to interact with debugged code.</source>
          <target state="translated">Хотя &lt;code&gt;IO.inspect/2&lt;/code&gt; статичен, интерактивная оболочка Elixir предоставляет более динамичные способы взаимодействия с отлаженным кодом.</target>
        </trans-unit>
        <trans-unit id="0327c3a74ed59f6c64011755ac0197a970c429ac" translate="yes" xml:space="preserve">
          <source>While Elixir Logger provides backends, Erlang/OTP logger provides handlers. They represent the same concept: the ability to integrate into the logging system to handle each logged message/event.</source>
          <target state="translated">В то время как Elixir Logger предоставляет бэкэнды,Erlang/OTP Logger предоставляет обработчики.Они представляют собой одну и ту же концепцию:возможность интеграции в систему регистрации для обработки каждого записанного сообщения/события.</target>
        </trans-unit>
        <trans-unit id="7e891083b7d17b20f59e0508fe476751a1ce5918" translate="yes" xml:space="preserve">
          <source>While Elixir often adds compatibility to new Erlang/OTP versions on released branches, such as support for Erlang/OTP 20 in v1.4.5, those releases usually contain the minimum changes for Elixir to run without errors. Only the next minor release, in this case v1.5.0, does effectively leverage the new features provided by the latest Erlang/OTP release.</source>
          <target state="translated">Хотя Elixir часто добавляет совместимость к новым версиям Erlang/OTP на выпущенных ветках,например,поддержка Erlang/OTP 20 в версии 1.4.5,эти выпуски обычно содержат минимальные изменения,чтобы Elixir работал без ошибок.Только следующий незначительный релиз,в данном случае v1.5.0,эффективно использует новые возможности,предоставляемые последним релизом Erlang/OTP.</target>
        </trans-unit>
        <trans-unit id="eff1c985b3cb7364d839bf596145ef8ecd3f8919" translate="yes" xml:space="preserve">
          <source>While Elixir provides a lot of useful built-in types, it&amp;rsquo;s convenient to define custom types when appropriate. This can be done when defining modules through the &lt;code&gt;@type&lt;/code&gt; directive.</source>
          <target state="translated">Хотя Elixir предоставляет множество полезных встроенных типов, при необходимости удобно определять собственные типы. Это можно сделать при определении модулей с &lt;code&gt;@type&lt;/code&gt; директивы @type .</target>
        </trans-unit>
        <trans-unit id="fc287f5e804d4c4a59c32fce6826f2c76d22f614" translate="yes" xml:space="preserve">
          <source>While ExUnit supports the ability to run tests concurrently within the same Elixir instance, it is not always possible to run all tests concurrently. For example, some tests may rely on global resources.</source>
          <target state="translated">Хотя ExUnit поддерживает возможность запускать тесты одновременно в одном и том же экземпляре Elixir,не всегда возможно запустить все тесты одновременно.Например,некоторые тесты могут полагаться на глобальные ресурсы.</target>
        </trans-unit>
        <trans-unit id="42e492f261dab6a613108b1864844d2a455e263d" translate="yes" xml:space="preserve">
          <source>While daemons are not available on Windows, it is possible to install a released system as a service on Windows with the help of &lt;a href=&quot;http://erlang.org/doc/man/erlsrv.html&quot;&gt;erlsrv&lt;/a&gt;. This can be done by running:</source>
          <target state="translated">Хотя демоны недоступны в Windows, можно установить выпущенную систему как службу в Windows с помощью &lt;a href=&quot;http://erlang.org/doc/man/erlsrv.html&quot;&gt;erlsrv&lt;/a&gt; . Это можно сделать, запустив:</target>
        </trans-unit>
        <trans-unit id="f39197ea7ae756757201361ad80eae1acf823b98" translate="yes" xml:space="preserve">
          <source>While in the shell, you may find the helper &lt;code&gt;flush/0&lt;/code&gt; quite useful. It flushes and prints all the messages in the mailbox.</source>
          <target state="translated">В оболочке вы можете найти помощник &lt;code&gt;flush/0&lt;/code&gt; весьма полезным. Он сбрасывает и распечатывает все сообщения в почтовом ящике.</target>
        </trans-unit>
        <trans-unit id="5e4643e134efe28695650e632c911749f82a168d" translate="yes" xml:space="preserve">
          <source>While it's possible to create custom guards with macros, it's recommended to define them using &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#defguard/1&quot;&gt;&lt;code&gt;defguard/1&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#defguardp/1&quot;&gt;&lt;code&gt;defguardp/1&lt;/code&gt;&lt;/a&gt; which perform additional compile-time checks.</source>
          <target state="translated">Хотя можно создавать собственные средства защиты с помощью макросов, рекомендуется определять их с помощью &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#defguard/1&quot;&gt; &lt;code&gt;defguard/1&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#defguardp/1&quot;&gt; &lt;code&gt;defguardp/1&lt;/code&gt; ,&lt;/a&gt; которые выполняют дополнительные проверки во время компиляции.</target>
        </trans-unit>
        <trans-unit id="948ac309c3d49e3090e9e6268ff5be5c675c1703" translate="yes" xml:space="preserve">
          <source>While it's possible to create custom guards with macros, it's recommended to define them using &lt;code&gt;defguard&lt;/code&gt; and &lt;code&gt;defguardp&lt;/code&gt; which perform additional compile-time checks.</source>
          <target state="translated">Несмотря на то, что с помощью макросов можно создавать собственные средства защиты, рекомендуется определять их с помощью &lt;code&gt;defguard&lt;/code&gt; и &lt;code&gt;defguardp&lt;/code&gt; , которые выполняют дополнительные проверки во время компиляции.</target>
        </trans-unit>
        <trans-unit id="e7e0433a97bbf2cdfd8497fc775fd566e71fc6d7" translate="yes" xml:space="preserve">
          <source>While it's possible to define unused operators (such as &lt;code&gt;&amp;lt;~&amp;gt;&lt;/code&gt;) and to &quot;override&quot; predefined operators (such as &lt;code&gt;+&lt;/code&gt;), the Elixir community generally discourages this. Custom-defined operators can be really hard to read and even more to understand, as they don't have a descriptive name like functions do. That said, some specific cases or custom domain specific languages (DSLs) may justify these practices.</source>
          <target state="translated">Хотя можно определить неиспользуемые операторы (такие как &lt;code&gt;&amp;lt;~&amp;gt;&lt;/code&gt; ) и &amp;laquo;переопределить&amp;raquo; предопределенные операторы (например, &lt;code&gt;+&lt;/code&gt; ), сообщество Elixir обычно не одобряет этого. Пользовательские операторы могут быть очень сложными для чтения и даже более трудными для понимания, поскольку у них нет описательного имени, как у функций. Тем не менее, некоторые конкретные случаи или языки, специфичные для пользовательских доменов (DSL), могут оправдать эту практику.</target>
        </trans-unit>
        <trans-unit id="c1664df92c33ce10f9a7ba24fd21afbe69d81240" translate="yes" xml:space="preserve">
          <source>While most UNIX command line tools will exit once its communication channels are closed, not all command line applications will do so. While we encourage graceful termination by detecting if stdin/stdout has been closed, we do not always have control over how third-party software terminates. In those cases, you can wrap the application in a script that checks for stdin. Here is such script in Bash:</source>
          <target state="translated">Хотя большинство инструментов командной строки UNIX выйдет из системы после закрытия каналов связи,не все приложения командной строки будут это делать.Несмотря на то,что мы поощряем изящное завершение работы,обнаруживая,был ли закрыт stdin/stdout,мы не всегда можем контролировать,как завершается работа стороннего программного обеспечения.В этих случаях вы можете обернуть приложение в скрипт,который проверяет наличие stdin.Вот такой скрипт на Bash:</target>
        </trans-unit>
        <trans-unit id="b87210387b28ebec2442f6f262222b9a8db51dff" translate="yes" xml:space="preserve">
          <source>While most Unix command line tools will exit once its communication channels are closed, not all command line applications will do so. You can easily check this by starting the port and then shutting down the VM and inspecting your operating system to see if the port process is still running.</source>
          <target state="translated">В то время как большинство инструментов командной строки Unix выйдет из системы после закрытия каналов связи,не все приложения командной строки сделают это.Вы можете легко проверить это,запустив порт,а затем выключив ВМ и осмотрев операционную систему,чтобы убедиться,что процесс порта все еще запущен.</target>
        </trans-unit>
        <trans-unit id="c24b8592b76f97129134ab89ec36ef2cec5eef0d" translate="yes" xml:space="preserve">
          <source>While one could also simply pass the &lt;code&gt;Counter&lt;/code&gt; as a child to the supervisor, such as:</source>
          <target state="translated">Хотя можно также просто передать &lt;code&gt;Counter&lt;/code&gt; как дочерний элемент супервизору, например:</target>
        </trans-unit>
        <trans-unit id="36362758dcc4b69a05743ba01ffd490227415dec" translate="yes" xml:space="preserve">
          <source>While other languages would require us to catch/handle exceptions, in Elixir we are actually fine with letting processes fail because we expect supervisors to properly restart our systems. &amp;ldquo;Failing fast&amp;rdquo; is a common philosophy when writing Elixir software!</source>
          <target state="translated">В то время как другие языки требуют от нас перехвата / обработки исключений, в Elixir мы на самом деле нормально допускаем сбой процессов, потому что ожидаем, что супервизоры правильно перезапустят наши системы. &amp;laquo;Быстро потерпеть неудачу&amp;raquo; - это общая философия при написании программного обеспечения на Эликсире!</target>
        </trans-unit>
        <trans-unit id="c9106e7acb9d2328494ccc8d8a5df4f1acd5cc0a" translate="yes" xml:space="preserve">
          <source>While our application will have many buckets, it will only have a single registry. Therefore, whenever we start the registry, we want to give it a unique name so we can reach out to it from anywhere. We do so by passing a &lt;code&gt;:name&lt;/code&gt; option to &lt;code&gt;KV.Registry.start_link/1&lt;/code&gt;.</source>
          <target state="translated">Хотя в нашем приложении будет много сегментов, у него будет только один реестр. Поэтому всякий раз, когда мы запускаем реестр, мы хотим дать ему уникальное имя, чтобы мы могли обращаться к нему из любого места. Мы делаем это, передавая параметр &lt;code&gt;:name&lt;/code&gt; в &lt;code&gt;KV.Registry.start_link/1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d03d6f908abf2f49bad588eb8e92749e481618fa" translate="yes" xml:space="preserve">
          <source>While the &lt;code&gt;:into&lt;/code&gt; option allows us to customize the comprehension behaviour to a given data type, such as putting all of the values inside a map or inside a binary, it is not always enough.</source>
          <target state="translated">Хотя параметр &lt;code&gt;:into&lt;/code&gt; позволяет нам настроить поведение понимания для данного типа данных, например, поместить все значения внутри карты или в двоичный файл, этого не всегда достаточно.</target>
        </trans-unit>
        <trans-unit id="6345023f6486581ef0b981a5089ae13410fe1184" translate="yes" xml:space="preserve">
          <source>While the above is straight-forward, it has the downside of traversing the data at least twice. If you are expecting long strings as inputs, this can be quite expensive.</source>
          <target state="translated">Несмотря на то,что вышеизложенное прямолинейно,у него есть обратная сторона при прохождении данных как минимум дважды.Если вы ожидаете в качестве входных данных длинные строки,то это может стоить довольно дорого.</target>
        </trans-unit>
        <trans-unit id="840e583e1f6163396e5057152a0935787393ec16" translate="yes" xml:space="preserve">
          <source>While the code above is completely valid, you may prefer to match on the struct variables inside the function body in order to keep the definition on a single line:</source>
          <target state="translated">Несмотря на то,что приведенный выше код полностью валиден,вы можете предпочесть сопоставить структурные переменные внутри тела функции,чтобы сохранить определение в одной строке:</target>
        </trans-unit>
        <trans-unit id="594620887d3476dbc120a3dcf5aefda1302d7ecc" translate="yes" xml:space="preserve">
          <source>While the process executes, the user will no longer have control of the shell. If you would rather start a new shell, use &lt;a href=&quot;#respawn/0&quot;&gt;&lt;code&gt;respawn/0&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">Пока процесс выполняется, пользователь больше не может управлять оболочкой. Если вы предпочитаете запускать новую оболочку, используйте вместо &lt;a href=&quot;#respawn/0&quot;&gt; &lt;code&gt;respawn/0&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6df62c1d796ef891e72a49f10459138b633ef075" translate="yes" xml:space="preserve">
          <source>While there are situations where &lt;code&gt;use SomeModule&lt;/code&gt; is necessary, &lt;code&gt;use&lt;/code&gt; should be skipped when all it does is to &lt;code&gt;import&lt;/code&gt; or &lt;code&gt;alias&lt;/code&gt; other modules. In a nutshell, &lt;code&gt;alias&lt;/code&gt; should be preferred, as it is simpler and clearer than &lt;code&gt;import&lt;/code&gt;, while &lt;code&gt;import&lt;/code&gt; is simpler and clearer than &lt;code&gt;use&lt;/code&gt;.</source>
          <target state="translated">Хотя бывают ситуации , когда &lt;code&gt;use SomeModule&lt;/code&gt; необходим, &lt;code&gt;use&lt;/code&gt; должно быть пропущено , когда все это делает для &lt;code&gt;import&lt;/code&gt; или &lt;code&gt;alias&lt;/code&gt; других модулей. Короче говоря, предпочтение следует отдавать &lt;code&gt;alias&lt;/code&gt; , поскольку он проще и понятнее, чем &lt;code&gt;import&lt;/code&gt; , а &lt;code&gt;import&lt;/code&gt; проще и понятнее, чем &lt;code&gt;use&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d955e2a979cdb9a5e708975ae43937efbb7ecbf2" translate="yes" xml:space="preserve">
          <source>While this is much better (we don't traverse &lt;code&gt;full&lt;/code&gt; twice), it could still be improved. In this case, since we want to extract a substring from a string, we can use &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#byte_size/1&quot;&gt;&lt;code&gt;Kernel.byte_size/1&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#binary_part/3&quot;&gt;&lt;code&gt;Kernel.binary_part/3&lt;/code&gt;&lt;/a&gt; as there is no chance we will slice in the middle of a code point made of more than one byte:</source>
          <target state="translated">Хотя это намного лучше (мы не проходим &lt;code&gt;full&lt;/code&gt; дважды), это все еще можно улучшить. В этом случае, поскольку мы хотим извлечь подстроку из строки, мы можем использовать &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#byte_size/1&quot;&gt; &lt;code&gt;Kernel.byte_size/1&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#binary_part/3&quot;&gt; &lt;code&gt;Kernel.binary_part/3&lt;/code&gt; ,&lt;/a&gt; поскольку нет шансов, что мы разрежем середину кодовой точки, состоящей из более чем одного байта. :</target>
        </trans-unit>
        <trans-unit id="d97357490e634679e794ba42b3a549cc212d1dc8" translate="yes" xml:space="preserve">
          <source>While this is much better (we don't traverse &lt;code&gt;full&lt;/code&gt; twice), it could still be improved. In this case, since we want to extract a substring from a string, we can use &lt;a href=&quot;kernel#byte_size/1&quot;&gt;&lt;code&gt;Kernel.byte_size/1&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;kernel#binary_part/3&quot;&gt;&lt;code&gt;Kernel.binary_part/3&lt;/code&gt;&lt;/a&gt; as there is no chance we will slice in the middle of a code point made of more than one byte:</source>
          <target state="translated">Хотя это намного лучше (мы не проходим &lt;code&gt;full&lt;/code&gt; дважды), это все еще можно улучшить. В этом случае, поскольку мы хотим извлечь подстроку из строки, мы можем использовать &lt;a href=&quot;kernel#byte_size/1&quot;&gt; &lt;code&gt;Kernel.byte_size/1&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;kernel#binary_part/3&quot;&gt; &lt;code&gt;Kernel.binary_part/3&lt;/code&gt; ,&lt;/a&gt; поскольку нет шансов, что мы разрежем середину кодовой точки, состоящей из более чем одного байта :</target>
        </trans-unit>
        <trans-unit id="75f74a8391ce99585979dcb3ea3da1ba4ddd33bc" translate="yes" xml:space="preserve">
          <source>While this module provides low-level conveniences to work with processes, developers typically use abstractions such as &lt;a href=&quot;agent&quot;&gt;&lt;code&gt;Agent&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;genserver&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;registry&quot;&gt;&lt;code&gt;Registry&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;supervisor&quot;&gt;&lt;code&gt;Supervisor&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt; for building their systems and resort to this module for gathering information, trapping exits, links and monitoring.</source>
          <target state="translated">Хотя этот модуль обеспечивает низкоуровневые удобства для работы с процессами, разработчики обычно используют абстракции, такие как &lt;a href=&quot;agent&quot;&gt; &lt;code&gt;Agent&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;genserver&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;registry&quot;&gt; &lt;code&gt;Registry&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;supervisor&quot;&gt; &lt;code&gt;Supervisor&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;task&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt; для построения своих систем, и прибегают к этому модулю для сбора информации, перехвата выходов, ссылок и мониторинга.</target>
        </trans-unit>
        <trans-unit id="3c748dce58cc0a4b655ad700197b7512f8bee596" translate="yes" xml:space="preserve">
          <source>While this module provides low-level conveniences to work with processes, developers typically use abstractions such as &lt;a href=&quot;https://hexdocs.pm/elixir/Agent.html&quot;&gt;&lt;code&gt;Agent&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://hexdocs.pm/elixir/Registry.html&quot;&gt;&lt;code&gt;Registry&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://hexdocs.pm/elixir/Supervisor.html&quot;&gt;&lt;code&gt;Supervisor&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://hexdocs.pm/elixir/Task.html&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt; for building their systems and resort to this module for gathering information, trapping exits, links and monitoring.</source>
          <target state="translated">Хотя этот модуль обеспечивает низкоуровневые удобства для работы с процессами, разработчики обычно используют абстракции, такие как &lt;a href=&quot;https://hexdocs.pm/elixir/Agent.html&quot;&gt; &lt;code&gt;Agent&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://hexdocs.pm/elixir/Registry.html&quot;&gt; &lt;code&gt;Registry&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://hexdocs.pm/elixir/Supervisor.html&quot;&gt; &lt;code&gt;Supervisor&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;https://hexdocs.pm/elixir/Task.html&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt; для построения своих систем, и прибегают к этому модулю для сбора информации, перехвата выходов, ссылок и мониторинга.</target>
        </trans-unit>
        <trans-unit id="cb6a8821086696174208667d7357f64ecd653513" translate="yes" xml:space="preserve">
          <source>While this will suffice for now, you may find the configuration a bit backwards. Usually, the computer name is usually not known upfront during development but only when deploying to production. For this purpose, we will later introduce &lt;a href=&quot;#runtime-configuration&quot;&gt;&lt;code&gt;config/releases.exs&lt;/code&gt;&lt;/a&gt;, which is a configuration file that is executed in the production machine before the system starts, giving you an opportunity to set the proper node name at the right time.</source>
          <target state="translated">Хотя на данный момент этого достаточно, вы можете найти конфигурацию немного наоборот. Обычно имя компьютера обычно не известно заранее во время разработки, а только при развертывании в производственной среде. Для этой цели позже мы представим &lt;a href=&quot;#runtime-configuration&quot;&gt; &lt;code&gt;config/releases.exs&lt;/code&gt; &lt;/a&gt; , который представляет собой файл конфигурации, который выполняется на производственном компьютере перед запуском системы, что дает вам возможность установить правильное имя узла в нужное время.</target>
        </trans-unit>
        <trans-unit id="8b522264297468a8fdf2244b0ac50dcc16406f84" translate="yes" xml:space="preserve">
          <source>While we encourage graceful termination by detecting if stdin/stdout has been closed, we do not always have control over how third-party software terminates. In those cases, you can wrap the application in a script that checks for stdin. Here is such script that has been verified to work on bash shells:</source>
          <target state="translated">Несмотря на то,что мы поощряем изящное завершение работы,обнаруживая,что stdin/stdout был закрыт,мы не всегда контролируем,как завершается работа стороннего программного обеспечения.В этих случаях вы можете обернуть приложение в скрипт,который проверяет наличие stdin.Вот такой скрипт,который был проверен на работу в bash shells:</target>
        </trans-unit>
        <trans-unit id="a071dda30d6568da003d94170f89a1641edfdf91" translate="yes" xml:space="preserve">
          <source>Why Collectable?</source>
          <target state="translated">Почему &quot;Коллекционный&quot;?</target>
        </trans-unit>
        <trans-unit id="f270b96c3543da962579aa2699fc04cd9390a45e" translate="yes" xml:space="preserve">
          <source>Why guards</source>
          <target state="translated">Почему охранники</target>
        </trans-unit>
        <trans-unit id="3953c15ac110f4692b3917f5608d0584abedc495" translate="yes" xml:space="preserve">
          <source>Why is it called naive? Because it does not contain timezone information. Therefore, the given datetime may not exist at all or it may exist twice in certain timezones - for example, when we move the clock back and forward for daylight saving time.</source>
          <target state="translated">Почему это называется наивностью? Потому что он не содержит информации о часовом поясе.Поэтому данное время может вообще не существовать или может существовать дважды в определенных часовых поясах-например,когда мы перемещаем часы назад и вперед для летнего времени.</target>
        </trans-unit>
        <trans-unit id="ac2b2f0f6634fb63d223d0af7e5a4015de1afa2d" translate="yes" xml:space="preserve">
          <source>Why releases?</source>
          <target state="translated">Зачем освобождать?</target>
        </trans-unit>
        <trans-unit id="a58ddf50c5ea5c03802da919dd5953bbf82ebd74" translate="yes" xml:space="preserve">
          <source>Width</source>
          <target state="translated">Width</target>
        </trans-unit>
        <trans-unit id="d713ca8d870cdfeb112abd654479d42242f3e918" translate="yes" xml:space="preserve">
          <source>Will output:</source>
          <target state="translated">Выходит:</target>
        </trans-unit>
        <trans-unit id="4a6579723b59ea9ec64425d88abb4286c7dc38a8" translate="yes" xml:space="preserve">
          <source>Will print error messages as:</source>
          <target state="translated">Будет печатать сообщения об ошибках как:</target>
        </trans-unit>
        <trans-unit id="2c2d1ea901f0c8101ac1fb5fa6dc20b9daa197c0" translate="yes" xml:space="preserve">
          <source>Will print:</source>
          <target state="translated">Уилл напечатает:</target>
        </trans-unit>
        <trans-unit id="26d9c28d789c254f71ea99a3463b99a7ccc2f4fa" translate="yes" xml:space="preserve">
          <source>Windows</source>
          <target state="translated">Windows</target>
        </trans-unit>
        <trans-unit id="1a372a68c5c6b9fd1a5e4e4c5bcb2c19d9a03783" translate="yes" xml:space="preserve">
          <source>Wiring it all up</source>
          <target state="translated">Подключая все это</target>
        </trans-unit>
        <trans-unit id="eaa42b7f9ff6889d59bad6d54129d3f6d5da9e0a" translate="yes" xml:space="preserve">
          <source>With a map:</source>
          <target state="translated">С картой:</target>
        </trans-unit>
        <trans-unit id="a142feb38b538cb226883f4345967e240846e8bf" translate="yes" xml:space="preserve">
          <source>With binaries, strings, and charlists out of the way, it is time to talk about key-value data structures.</source>
          <target state="translated">При отсутствии двоичных файлов,строк и чарлистов настало время поговорить о структурах данных с ключевыми значениями.</target>
        </trans-unit>
        <trans-unit id="59fd9c1ee5c1fccc62b073ebeed75c6eddbbabca" translate="yes" xml:space="preserve">
          <source>With doctests at hand, it is your turn to make tests pass! Once you&amp;rsquo;re ready, you can compare your work with our solution below:</source>
          <target state="translated">Имея под рукой документы, настала ваша очередь сдавать тесты! Когда вы будете готовы, вы можете сравнить свою работу с нашим решением ниже:</target>
        </trans-unit>
        <trans-unit id="b38a50a17602e3ae1b8ccc46a98a4df1a0b23f69" translate="yes" xml:space="preserve">
          <source>With duplicated keys:</source>
          <target state="translated">С дублированными ключами:</target>
        </trans-unit>
        <trans-unit id="6bf60a08d100412a557c9ec4468e26a3fc8d3190" translate="yes" xml:space="preserve">
          <source>With options:</source>
          <target state="translated">С опциями:</target>
        </trans-unit>
        <trans-unit id="1c9488c5cddccfc0e6d1f32c489b748da64fc121" translate="yes" xml:space="preserve">
          <source>With our umbrella project up and running, it is time to start writing our server.</source>
          <target state="translated">С запуском нашего зонтичного проекта пришло время начать писать наш сервер.</target>
        </trans-unit>
        <trans-unit id="27d88e0df1a5d3693256746484dff57191508042" translate="yes" xml:space="preserve">
          <source>With protocols, however, we are no longer stuck having to continuously modify the same module to support more and more data types. For example, we could get the &lt;code&gt;defimpl&lt;/code&gt; calls above and spread them over multiple files and Elixir will dispatch the execution to the appropriate implementation based on the data type. Functions defined in a protocol may have more than one input, but the &lt;strong&gt;dispatching will always be based on the data type of the first input&lt;/strong&gt;.</source>
          <target state="translated">Однако с протоколами мы больше не застреваем в необходимости постоянно изменять один и тот же модуль для поддержки все большего количества типов данных. Например, мы могли бы получить вызовы &lt;code&gt;defimpl&lt;/code&gt; , указанные выше, и распределить их по нескольким файлам, и Elixir отправит выполнение в соответствующую реализацию в зависимости от типа данных. Функции, определенные в протоколе, могут иметь более одного входа, но &lt;strong&gt;диспетчеризация всегда будет основана на типе данных первого входа&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="bba0c8a7b1ce199c741a002ee4243a9062d9953c" translate="yes" xml:space="preserve">
          <source>With releases, we were able to &amp;ldquo;cut different slices&amp;rdquo; of our project and prepared them to run in production, all packaged into a single directory.</source>
          <target state="translated">Выпуская релизы, мы смогли &amp;laquo;разрезать разные части&amp;raquo; нашего проекта и подготовить их к запуску в производственной среде, все упакованные в один каталог.</target>
        </trans-unit>
        <trans-unit id="13559370fc853a52f787a24b8c1b275e217543ea" translate="yes" xml:space="preserve">
          <source>With such a simple table available, we can now remove &lt;code&gt;@tag :distributed&lt;/code&gt; from the test in &lt;code&gt;test/kv_server_test.exs&lt;/code&gt;. If you run the complete suite, the test should now pass.</source>
          <target state="translated">Имея такую ​​простую таблицу, мы теперь можем удалить &lt;code&gt;@tag :distributed&lt;/code&gt; из теста в &lt;code&gt;test/kv_server_test.exs&lt;/code&gt; . Если вы запустите полный комплект, тест должен пройти.</target>
        </trans-unit>
        <trans-unit id="7a8ac78124dabe8eb4d0ade42727a617447db381" translate="yes" xml:space="preserve">
          <source>With the configuration in place, let&amp;rsquo;s give assembling the release another try:</source>
          <target state="translated">Имея конфигурацию, давайте еще раз попробуем собрать релиз:</target>
        </trans-unit>
        <trans-unit id="bf24bbb528b37b8d16045a9f34a9f10b8ac013e4" translate="yes" xml:space="preserve">
          <source>With the functions in this module, we can concatenate different elements together and render them:</source>
          <target state="translated">С помощью функций в этом модуле мы можем объединять различные элементы вместе и выводить их на экран:</target>
        </trans-unit>
        <trans-unit id="6df754d5302c1520a37db5161561c19578b70a47" translate="yes" xml:space="preserve">
          <source>With the routing table integrated, we have made a lot of progress in building our distributed key-value store but, up to this point, the routing table is still hard-coded. In the next chapter, we will learn how to make the routing table configurable and how to package our application for production.</source>
          <target state="translated">С интегрированной таблицей маршрутизации мы добились большого прогресса в построении нашего распределенного хранилища значений ключей,но до сих пор таблица маршрутизации остается жестко закодированной.В следующей главе мы узнаем,как сделать таблицу маршрутизации настраиваемой и как упаковать наше приложение для производства.</target>
        </trans-unit>
        <trans-unit id="88aff34e4e29570c42b886cfc99dae57378c1a87" translate="yes" xml:space="preserve">
          <source>With the test properly tagged, we can now check if the node is alive on the network and, if not, we can exclude all distributed tests. Open up &lt;code&gt;test/test_helper.exs&lt;/code&gt; inside the &lt;code&gt;:kv&lt;/code&gt; application and add the following:</source>
          <target state="translated">Теперь, когда тест помечен правильно, мы можем проверить, активен ли узел в сети, и, если нет, мы можем исключить все распределенные тесты. Откройте &lt;code&gt;test/test_helper.exs&lt;/code&gt; внутри приложения &lt;code&gt;:kv&lt;/code&gt; и добавьте следующее:</target>
        </trans-unit>
        <trans-unit id="03febbe4cffd47fca872e3ab15ba7ecbf3f2a521" translate="yes" xml:space="preserve">
          <source>With this change, we are saying that we want to run &lt;code&gt;KVServer.accept(4040)&lt;/code&gt; as a task. We are hardcoding the port for now but this could be changed in a few ways, for example, by reading the port out of the system environment when starting the application:</source>
          <target state="translated">Этим изменением мы говорим, что хотим запустить &lt;code&gt;KVServer.accept(4040)&lt;/code&gt; как задачу. На данный момент мы жестко кодируем порт, но это можно изменить несколькими способами, например, считывая порт из системной среды при запуске приложения:</target>
        </trans-unit>
        <trans-unit id="b2d8587ac4dfb38f02ee844e25af23cb384021e5" translate="yes" xml:space="preserve">
          <source>With this in place, the supervisor will now start &lt;code&gt;KV.Registry&lt;/code&gt; by calling &lt;code&gt;KV.Registry.start_link(name: KV.Registry)&lt;/code&gt;.</source>
          <target state="translated">После этого супервизор запустит &lt;code&gt;KV.Registry&lt;/code&gt; , вызвав &lt;code&gt;KV.Registry.start_link(name: KV.Registry)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3cfddebea7643fbc375079abeb732751424fdccb" translate="yes" xml:space="preserve">
          <source>With this knowledge in hand, let&amp;rsquo;s finally write the routing code.</source>
          <target state="translated">Обладая этими знаниями, давайте, наконец, напишем код маршрутизации.</target>
        </trans-unit>
        <trans-unit id="1b7ca4f17d0a5bd5d888ca1f58a59b4c8395b464" translate="yes" xml:space="preserve">
          <source>With this simple integration test, we start to see why integration tests may be slow. Not only can this test not run asynchronously, but it also requires the expensive setup of stopping and starting the &lt;code&gt;:kv&lt;/code&gt; application. In fact, your test suite may even fail and run into timeouts. If that&amp;rsquo;s the case, you can tweak the &lt;code&gt;:gen_tcp.recv(socket, 0)&lt;/code&gt; call to pass a third argument, which is the timeout in milliseconds. In the next chapter we will learn about application configuration, which we could use to make the timeout configurable, if desired.</source>
          <target state="translated">С помощью этого простого интеграционного теста мы начинаем понимать, почему интеграционные тесты могут быть медленными. Этот тест не только не может выполняться асинхронно, но также требует дорогостоящей настройки остановки и запуска приложения &lt;code&gt;:kv&lt;/code&gt; . Фактически, ваш набор тестов может даже дать сбой и дать время ожиданиям. В этом случае вы можете настроить &lt;code&gt;:gen_tcp.recv(socket, 0)&lt;/code&gt; чтобы передать третий аргумент, который представляет собой тайм-аут в миллисекундах. В следующей главе мы узнаем о конфигурации приложения, которую мы могли бы использовать для настройки времени ожидания, если это необходимо.</target>
        </trans-unit>
        <trans-unit id="e176657aed44574ca37e82fff8791f0963853823" translate="yes" xml:space="preserve">
          <source>With this simple integration test, we start to see why integration tests may be slow. Not only this test cannot run asynchronously, it also requires the expensive setup of stopping and starting the &lt;code&gt;:kv&lt;/code&gt; application. In fact, your test suite may even fail and run into timeouts. If that&amp;rsquo;s the case, you can tweak the &lt;code&gt;:gen_tcp.recv(socket, 0)&lt;/code&gt; call to pass a third argument, which is the timeout in milliseconds. In the next chapter we will learn about application configuration, which we could use to make the timeout configurable, if desired.</source>
          <target state="translated">С помощью этого простого интеграционного теста мы начинаем понимать, почему интеграционные тесты могут быть медленными. Этот тест не только не может выполняться асинхронно, он также требует дорогостоящей настройки остановки и запуска приложения &lt;code&gt;:kv&lt;/code&gt; . Фактически, ваш набор тестов может даже дать сбой и дать время ожиданиям. В этом случае вы можете настроить &lt;code&gt;:gen_tcp.recv(socket, 0)&lt;/code&gt; чтобы передать третий аргумент, который представляет собой тайм-аут в миллисекундах. В следующей главе мы узнаем о конфигурации приложения, которую мы могли бы использовать, чтобы при желании настроить тайм-аут.</target>
        </trans-unit>
        <trans-unit id="69a061adaee410870f0db0130a4863eb959d29cc" translate="yes" xml:space="preserve">
          <source>With this, we have covered the main modules that Elixir provides for dealing with IO and interacting with the file system. In the next sections, we will discuss some advanced topics regarding IO. Those sections are not necessary in order to write Elixir code, so feel free to skip them, but they do provide a nice overview of how the IO system is implemented in the</source>
          <target state="translated">Этим мы рассмотрели основные модули,которые Elixir предоставляет для работы с IO и взаимодействия с файловой системой.В следующих разделах мы обсудим некоторые продвинутые темы,касающиеся ввода-вывода.Эти разделы не нужны для написания кода Elixir,так что не стесняйтесь их пропустить,но они дают хороший обзор того,как система ввода-вывода реализуется в</target>
        </trans-unit>
        <trans-unit id="590e5438c7cb8d996880074ea694c0f4ce03cc86" translate="yes" xml:space="preserve">
          <source>With this, we have finished our tour of Elixir modules. The last topic to cover is module attributes.</source>
          <target state="translated">На этом мы закончили экскурсию по модулям Elixir.Последняя тема для обсуждения-атрибуты модулей.</target>
        </trans-unit>
        <trans-unit id="3977e5e25611957119fe9bd8093c06ae07247ece" translate="yes" xml:space="preserve">
          <source>With those lessons, we finish our introduction to macros. The next chapter is a brief discussion on DSLs that shows how we can mix macros and module attributes to annotate and extend modules and functions.</source>
          <target state="translated">Этими уроками мы заканчиваем введение в макросы.Следующая глава представляет собой краткое обсуждение DSL,показывающее,как мы можем смешивать макросы и атрибуты модулей для аннотирования и расширения модулей и функций.</target>
        </trans-unit>
        <trans-unit id="576386a4049c3f84e1e70ca63dc3a0583fd7ca02" translate="yes" xml:space="preserve">
          <source>WithClauseError</source>
          <target state="translated">WithClauseError</target>
        </trans-unit>
        <trans-unit id="531e8754d718662134036e0ed426d7e0605ed031" translate="yes" xml:space="preserve">
          <source>WithClauseError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">WithClauseError &lt;small&gt;исключение&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="ab0793176b49657e8d03d5f783b19379b3db349f" translate="yes" xml:space="preserve">
          <source>Without new lines, as seen below, ExUnit compiles it into a single doctest:</source>
          <target state="translated">Без новых строк,как видно ниже,ExUnit компилирует его в единый доктест:</target>
        </trans-unit>
        <trans-unit id="703c6eb398214673f74fdca9cf5f8628a7a7dd05" translate="yes" xml:space="preserve">
          <source>Without options:</source>
          <target state="translated">Без вариантов:</target>
        </trans-unit>
        <trans-unit id="11e35fb66328b6ede55b6b84c9357bd2414375bb" translate="yes" xml:space="preserve">
          <source>Word lists</source>
          <target state="translated">Списки слов</target>
        </trans-unit>
        <trans-unit id="acaa1f9e891f841e4f55280185da1c9a0bc87b80" translate="yes" xml:space="preserve">
          <source>Working with files</source>
          <target state="translated">Работа с файлами</target>
        </trans-unit>
        <trans-unit id="43c75eba4a76554736c3f35f9a22bf7076b21a6a" translate="yes" xml:space="preserve">
          <source>Works like &lt;a href=&quot;#raise/1&quot;&gt;&lt;code&gt;raise/1&lt;/code&gt;&lt;/a&gt; but does not generate a new stacktrace.</source>
          <target state="translated">Работает как &lt;a href=&quot;#raise/1&quot;&gt; &lt;code&gt;raise/1&lt;/code&gt; ,&lt;/a&gt; но не генерирует новую трассировку стека.</target>
        </trans-unit>
        <trans-unit id="134b6740811c97cd32f9b686cca4b898a98707e8" translate="yes" xml:space="preserve">
          <source>Works the same as &lt;a href=&quot;#async_stream/5&quot;&gt;&lt;code&gt;async_stream/5&lt;/code&gt;&lt;/a&gt; but with an anonymous function instead of a module-function-arguments tuple. &lt;code&gt;fun&lt;/code&gt; must be a one-arity anonymous function.</source>
          <target state="translated">Работает так же, как &lt;a href=&quot;#async_stream/5&quot;&gt; &lt;code&gt;async_stream/5&lt;/code&gt; ,&lt;/a&gt; но с анонимной функцией вместо кортежа модуль-функция-аргументы. &lt;code&gt;fun&lt;/code&gt; должно быть анонимной функцией с одной артерией.</target>
        </trans-unit>
        <trans-unit id="e01cc30af27c867806feacb956d20799166447ec" translate="yes" xml:space="preserve">
          <source>Would be parsed as:</source>
          <target state="translated">будет разобрано как:</target>
        </trans-unit>
        <trans-unit id="bef337a44d60f3ee2e621fe41abc36ff3b77f3c8" translate="yes" xml:space="preserve">
          <source>Wrapping a keyword in quotes does not make it a string. Keyword lists keys are always atoms. If you use quotes around the key when quoting is not necessary, Elixir will warn.</source>
          <target state="translated">Обертывание ключевого слова в кавычки не делает его строкой.Списки ключевых слов всегда являются атомами.Если вы используете кавычки вокруг ключа,когда кавычки не нужны,Elixir предупредит об этом.</target>
        </trans-unit>
        <trans-unit id="ed68f33e0edd83622fdda96f013734e64b3797b8" translate="yes" xml:space="preserve">
          <source>Wrapping a keyword in quotes does not make it a string. Keywords are always atoms. If you use quotes when all characters are a valid part of a keyword without quotes, Elixir will warn.</source>
          <target state="translated">Обертывание ключевого слова в кавычки не делает его строкой.Ключевые слова всегда являются атомами.Если вы используете кавычки,когда все символы являются действительной частью ключевого слова без кавычек,Elixir предупредит об этом.</target>
        </trans-unit>
        <trans-unit id="fc3aaaad1d5351a716bcfec3590a0c7aadfe5609" translate="yes" xml:space="preserve">
          <source>Wrapping the function name in single- or double-quotes is always a remote call. Therefore &lt;code&gt;Kernel.&quot;Foo&quot;&lt;/code&gt; will attempt to call the function &quot;Foo&quot; and not return the alias &lt;code&gt;Kernel.Foo&lt;/code&gt;. This is done by design as module names are more strict than function names.</source>
          <target state="translated">Заключение имени функции в одинарные или двойные кавычки всегда является удаленным вызовом. Поэтому &lt;code&gt;Kernel.&quot;Foo&quot;&lt;/code&gt; попытается вызвать функцию &amp;laquo;Foo&amp;raquo; и не вернет псевдоним &lt;code&gt;Kernel.Foo&lt;/code&gt; . Это сделано намеренно, поскольку имена модулей более строгие, чем имена функций.</target>
        </trans-unit>
        <trans-unit id="8dc389376346ac2c6054e49b93415804e45c3f9d" translate="yes" xml:space="preserve">
          <source>Wraps &lt;code&gt;collection&lt;/code&gt; in &lt;code&gt;left&lt;/code&gt; and &lt;code&gt;right&lt;/code&gt; according to limit and contents.</source>
          <target state="translated">Обертывания &lt;code&gt;collection&lt;/code&gt; в &lt;code&gt;left&lt;/code&gt; и &lt;code&gt;right&lt;/code&gt; в соответствии с лимитом и содержание.</target>
        </trans-unit>
        <trans-unit id="1fd191283e143c09014d6b10f8babd586c4dd3ff" translate="yes" xml:space="preserve">
          <source>Wraps &lt;code&gt;term&lt;/code&gt; in a list if this is not list.</source>
          <target state="translated">Оборачивает &lt;code&gt;term&lt;/code&gt; в список, если это не список.</target>
        </trans-unit>
        <trans-unit id="871135f343b118a2e6897770ba0d353314ad4e26" translate="yes" xml:space="preserve">
          <source>Writable temporary directory, exception on error.</source>
          <target state="translated">Записываемый временный каталог,исключение по ошибке.</target>
        </trans-unit>
        <trans-unit id="6d280821129e62362ceba6c4bff9e07a7b456feb" translate="yes" xml:space="preserve">
          <source>Writable temporary directory.</source>
          <target state="translated">Записываемый временный каталог.</target>
        </trans-unit>
        <trans-unit id="6ffa32df712de6eb75f6b3eb5860d11f7743bc16" translate="yes" xml:space="preserve">
          <source>Write documentation. The Elixir community is proud of treating documentation as a first-class citizen and making documentation easily accessible. Libraries contribute to the status quo by providing complete API documentation with examples for their modules, types and functions. See the &lt;a href=&quot;writing-documentation&quot;&gt;Writing Documentation&lt;/a&gt; guide for more information. Projects like &lt;a href=&quot;https://github.com/elixir-lang/ex_doc&quot;&gt;ExDoc&lt;/a&gt; can be used to generate HTML and EPUB documents from the documentation. ExDoc also supports &quot;extra pages&quot;, like this one that you are reading. Such pages augment the documentation with tutorials, guides and references.</source>
          <target state="translated">Напишите документацию. Сообщество Elixir гордится тем, что относится к документации как к первоклассному гражданину и делает ее легко доступной. Библиотеки поддерживают статус-кво, предоставляя полную документацию по API с примерами их модулей, типов и функций. Дополнительную информацию см. В руководстве &lt;a href=&quot;writing-documentation&quot;&gt;Writing Documentation&lt;/a&gt; . Такие проекты, как &lt;a href=&quot;https://github.com/elixir-lang/ex_doc&quot;&gt;ExDoc,&lt;/a&gt; можно использовать для создания документов HTML и EPUB из документации. ExDoc также поддерживает &amp;laquo;дополнительные страницы&amp;raquo;, подобные той, которую вы читаете. Такие страницы дополняют документацию учебными пособиями, руководствами и ссылками.</target>
        </trans-unit>
        <trans-unit id="c20c5c2676125559a686b163df005602f1f79cf9" translate="yes" xml:space="preserve">
          <source>Write macros responsibly</source>
          <target state="translated">Пишите макросы ответственно</target>
        </trans-unit>
        <trans-unit id="c8a2eb88e34c563062857a754892c9fa2cee5ed9" translate="yes" xml:space="preserve">
          <source>Write tests. Elixir ships with a test-framework named &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.html&quot;&gt;ExUnit&lt;/a&gt;. The project generated by &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.New.html&quot;&gt;&lt;code&gt;mix new&lt;/code&gt;&lt;/a&gt; includes sample tests and doctests.</source>
          <target state="translated">Напишите тесты. Elixir поставляется с тестовой платформой &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.html&quot;&gt;ExUnit&lt;/a&gt; . Проект, созданный с помощью &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.New.html&quot;&gt; &lt;code&gt;mix new&lt;/code&gt; ,&lt;/a&gt; включает в себя образцы тестов и тесты документации.</target>
        </trans-unit>
        <trans-unit id="1feeacf656b90f330a6a489cf3b74d6b58d07ce7" translate="yes" xml:space="preserve">
          <source>Writes &lt;code&gt;chardata&lt;/code&gt; to the given &lt;code&gt;device&lt;/code&gt;.</source>
          <target state="translated">Записывает &lt;code&gt;chardata&lt;/code&gt; на данное &lt;code&gt;device&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4b82357a7578553502291944537b9069cacc23ce" translate="yes" xml:space="preserve">
          <source>Writes &lt;code&gt;content&lt;/code&gt; to the file &lt;code&gt;path&lt;/code&gt;.</source>
          <target state="translated">Записывает &lt;code&gt;content&lt;/code&gt; в &lt;code&gt;path&lt;/code&gt; к файлу .</target>
        </trans-unit>
        <trans-unit id="9b687301a3673e72e85385f60b8d3a4d244ea746" translate="yes" xml:space="preserve">
          <source>Writes &lt;code&gt;iodata&lt;/code&gt; to the given &lt;code&gt;device&lt;/code&gt;.</source>
          <target state="translated">Записывает &lt;code&gt;iodata&lt;/code&gt; на данное &lt;code&gt;device&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="81c5649f21bfd5ad6a72c260c31465c5717dd093" translate="yes" xml:space="preserve">
          <source>Writes &lt;code&gt;item&lt;/code&gt; to the given &lt;code&gt;device&lt;/code&gt;, similar to &lt;a href=&quot;#write/2&quot;&gt;&lt;code&gt;write/2&lt;/code&gt;&lt;/a&gt;, but adds a newline at the end.</source>
          <target state="translated">Записывает &lt;code&gt;item&lt;/code&gt; в указанное &lt;code&gt;device&lt;/code&gt; , аналогично &lt;a href=&quot;#write/2&quot;&gt; &lt;code&gt;write/2&lt;/code&gt; &lt;/a&gt; , но добавляет в конец новую строку.</target>
        </trans-unit>
        <trans-unit id="91a0ede6abab1883ab37182f1281431e30f439b6" translate="yes" xml:space="preserve">
          <source>Writes a &lt;code&gt;message&lt;/code&gt; to stderr, along with the current stacktrace.</source>
          <target state="translated">Записывает &lt;code&gt;message&lt;/code&gt; в stderr вместе с текущей трассировкой стека.</target>
        </trans-unit>
        <trans-unit id="60b2773edfcfce0e6d9dca670d285a3e07d07034" translate="yes" xml:space="preserve">
          <source>Writes a &lt;code&gt;message&lt;/code&gt; to stderr, along with the given &lt;code&gt;stacktrace&lt;/code&gt;.</source>
          <target state="translated">Записывает &lt;code&gt;message&lt;/code&gt; в stderr вместе с заданной &lt;code&gt;stacktrace&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cb16223cc3eb746e3d1b6e8dc906aef60d73d8e4" translate="yes" xml:space="preserve">
          <source>Writes an .app file.</source>
          <target state="translated">Записывает файл .app.</target>
        </trans-unit>
        <trans-unit id="50ad9498b3d796e6083dcc801c9d470dfff4c6ff" translate="yes" xml:space="preserve">
          <source>Writes the given &lt;a href=&quot;file.stat&quot;&gt;&lt;code&gt;File.Stat&lt;/code&gt;&lt;/a&gt; back to the file system at the given path. Returns &lt;code&gt;:ok&lt;/code&gt; or &lt;code&gt;{:error, reason}&lt;/code&gt;.</source>
          <target state="translated">Записывает данный &lt;a href=&quot;file.stat&quot;&gt; &lt;code&gt;File.Stat&lt;/code&gt; &lt;/a&gt; обратно в файловую систему по заданному пути. Возвращает &lt;code&gt;:ok&lt;/code&gt; или &lt;code&gt;{:error, reason}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e78a8596bea8d28ebfb36faf2acfc624faefc2d0" translate="yes" xml:space="preserve">
          <source>Writes the given &lt;a href=&quot;https://hexdocs.pm/elixir/File.Stat.html&quot;&gt;&lt;code&gt;File.Stat&lt;/code&gt;&lt;/a&gt; back to the file system at the given path. Returns &lt;code&gt;:ok&lt;/code&gt; or &lt;code&gt;{:error, reason}&lt;/code&gt;.</source>
          <target state="translated">Записывает данный &lt;a href=&quot;https://hexdocs.pm/elixir/File.Stat.html&quot;&gt; &lt;code&gt;File.Stat&lt;/code&gt; &lt;/a&gt; обратно в файловую систему по заданному пути. Возвращает &lt;code&gt;:ok&lt;/code&gt; или &lt;code&gt;{:error, reason}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2dabb8334b6cbbc19635a160f00032f11eeb9962" translate="yes" xml:space="preserve">
          <source>Writing</source>
          <target state="translated">Writing</target>
        </trans-unit>
        <trans-unit id="131fd1dd1ce5d6ec0f6aa2acdfdd8f920515c873" translate="yes" xml:space="preserve">
          <source>Writing &lt;code&gt;@tag :distributed&lt;/code&gt; is equivalent to writing &lt;code&gt;@tag distributed: true&lt;/code&gt;.</source>
          <target state="translated">Написание &lt;code&gt;@tag :distributed&lt;/code&gt; эквивалентно написанию &lt;code&gt;@tag distributed: true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="469b1f8873498de485e6c8f565f8f7d313eb6b92" translate="yes" xml:space="preserve">
          <source>Writing Documentation</source>
          <target state="translated">Письменная документация</target>
        </trans-unit>
        <trans-unit id="24d7c2c2e5b00b0086937c4765f3d3f34430d546" translate="yes" xml:space="preserve">
          <source>Writing code is only the first of many steps to publish a package. We strongly recommend developers to:</source>
          <target state="translated">Написание кода-это только первый из многих шагов для публикации пакета.Мы настоятельно рекомендуем это делать разработчикам:</target>
        </trans-unit>
        <trans-unit id="b6db65d2bd46df16d24116fb30b8acb8ac0c704f" translate="yes" xml:space="preserve">
          <source>Writing the &lt;code&gt;empty_map?/1&lt;/code&gt; function by only using pattern matching would not be possible (as pattern matching on &lt;code&gt;%{}&lt;/code&gt; would match &lt;em&gt;any&lt;/em&gt; map, not only the empty ones).</source>
          <target state="translated">Написание функции &lt;code&gt;empty_map?/1&lt;/code&gt; с использованием только сопоставления с образцом было бы невозможно (поскольку сопоставление с образцом на &lt;code&gt;%{}&lt;/code&gt; будет соответствовать &lt;em&gt;любой&lt;/em&gt; карте, а не только пустым).</target>
        </trans-unit>
        <trans-unit id="f2f71f28a31e334663ab5d64232830d65131bffb" translate="yes" xml:space="preserve">
          <source>Writing the &lt;code&gt;empty_map?/1&lt;/code&gt; function by only using pattern matching would not be possible (as pattern matching on &lt;code&gt;%{}&lt;/code&gt; would match &lt;em&gt;every&lt;/em&gt; map, not empty maps).</source>
          <target state="translated">Написание функции &lt;code&gt;empty_map?/1&lt;/code&gt; с использованием только сопоставления с образцом было бы невозможно (поскольку сопоставление с образцом в &lt;code&gt;%{}&lt;/code&gt; будет соответствовать &lt;em&gt;каждой&lt;/em&gt; карте, а не пустым картам).</target>
        </trans-unit>
        <trans-unit id="c032adc1ff629c9b66f22749ad667e6beadf144b" translate="yes" xml:space="preserve">
          <source>X</source>
          <target state="translated">X</target>
        </trans-unit>
        <trans-unit id="0364f97e903a76eb2748323472186e449617cb88" translate="yes" xml:space="preserve">
          <source>Xref modes</source>
          <target state="translated">Xref-режимы</target>
        </trans-unit>
        <trans-unit id="23eb4d3f4155395a74e9d534f97ff4c1908f5aac" translate="yes" xml:space="preserve">
          <source>Y</source>
          <target state="translated">Y</target>
        </trans-unit>
        <trans-unit id="879e32326c5217968ac8e3a14e4a8a5214957264" translate="yes" xml:space="preserve">
          <source>Year</source>
          <target state="translated">Year</target>
        </trans-unit>
        <trans-unit id="6b2a18bf9a95ce6877fd5e0e0cf4ca902806f21b" translate="yes" xml:space="preserve">
          <source>Year as 2-digits</source>
          <target state="translated">Год как 2 цифры</target>
        </trans-unit>
        <trans-unit id="ce0bf305bc11db00a7123b9e6e1e0d7aa8dcb7d2" translate="yes" xml:space="preserve">
          <source>Yes, it works! However, does it &lt;em&gt;scale&lt;/em&gt;?</source>
          <target state="translated">Да, это работает! Однако &lt;em&gt;масштабируется&lt;/em&gt; ли оно ?</target>
        </trans-unit>
        <trans-unit id="5a20bc5d9e7b5ec9dd50e5b0a20cf3e3f7fd4d3a" translate="yes" xml:space="preserve">
          <source>Yields to multiple tasks in the given time interval.</source>
          <target state="translated">Уступает нескольким задачам в заданном интервале времени.</target>
        </trans-unit>
        <trans-unit id="68e38479c9c3989b1f5f4ba434055afe680c314f" translate="yes" xml:space="preserve">
          <source>You add this process as part of your supervision tree and ship version 0.1.0 of your system. Now let's imagine that on version 0.2.0 you added two changes: instead of &lt;code&gt;bump/0&lt;/code&gt;, that always increments the counter by one, you introduce &lt;code&gt;bump/1&lt;/code&gt; that passes the exact value to bump the counter. You also change the state, because you want to store the maximum bump value:</source>
          <target state="translated">Вы добавляете этот процесс как часть своего дерева надзора и поставляете версию 0.1.0 вашей системы. Теперь представим, что в версии 0.2.0 вы добавили два изменения: вместо &lt;code&gt;bump/0&lt;/code&gt; , который всегда увеличивает счетчик на единицу, вы вводите &lt;code&gt;bump/1&lt;/code&gt; , который передает точное значение для увеличения счетчика. Вы также меняете состояние, потому что хотите сохранить максимальное значение удара:</target>
        </trans-unit>
        <trans-unit id="7494d61e6543878f2b2566cc12d19e025bd840c8" translate="yes" xml:space="preserve">
          <source>You can also &lt;a href=&quot;http://blog.plataformatec.com.br/2016/05/tracing-and-observing-your-remote-node/&quot;&gt;use Observer to introspect a remote node&lt;/a&gt;. This is one of the debugging techniques &lt;a href=&quot;https://phoenixframework.org/blog/the-road-to-2-million-websocket-connections&quot;&gt;the Phoenix framework used to achieve 2 million connections on a single machine&lt;/a&gt;.</source>
          <target state="translated">Вы также можете &lt;a href=&quot;http://blog.plataformatec.com.br/2016/05/tracing-and-observing-your-remote-node/&quot;&gt;использовать Observer для интроспекции удаленного узла&lt;/a&gt; . Это один из методов отладки, который &lt;a href=&quot;https://phoenixframework.org/blog/the-road-to-2-million-websocket-connections&quot;&gt;фреймворк Phoenix использовал для достижения 2 миллионов подключений на одной машине&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="06983d8881008548f22731727c340afa53a46d0f" translate="yes" xml:space="preserve">
          <source>You can also assign the struct name to &lt;code&gt;_&lt;/code&gt; when you want to check if something is a struct but you are not interested in its name:</source>
          <target state="translated">Вы также можете присвоить имя структуры &lt;code&gt;_&lt;/code&gt; , если хотите проверить, является ли что-то структурой, но вас не интересует ее имя:</target>
        </trans-unit>
        <trans-unit id="d4ee5ba971949ab0229f8da390501bcbcda1e1e8" translate="yes" xml:space="preserve">
          <source>You can also change the application environment dynamically by using functions such as &lt;a href=&quot;#put_env/3&quot;&gt;&lt;code&gt;put_env/3&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#delete_env/2&quot;&gt;&lt;code&gt;delete_env/2&lt;/code&gt;&lt;/a&gt;. However, as a rule of thumb, each application is responsible for its own environment. Please do not use the functions in this module for directly accessing or modifying the environment of other applications.</source>
          <target state="translated">Вы также можете динамически изменять среду приложения, используя такие функции, как &lt;a href=&quot;#put_env/3&quot;&gt; &lt;code&gt;put_env/3&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;#delete_env/2&quot;&gt; &lt;code&gt;delete_env/2&lt;/code&gt; &lt;/a&gt; . Однако, как правило, каждое приложение отвечает за свою среду. Пожалуйста, не используйте функции этого модуля для прямого доступа или изменения среды других приложений.</target>
        </trans-unit>
        <trans-unit id="5ffdb4ed015fd808bfdd98a224b2a3a3cb234c70" translate="yes" xml:space="preserve">
          <source>You can also configure the syntax colors, however, as desired:</source>
          <target state="translated">Вы также можете настроить цвета синтаксиса,однако,по желанию:</target>
        </trans-unit>
        <trans-unit id="8098b82db0ff3e423ec9c8c9b67f0b8a0bd2b3cb" translate="yes" xml:space="preserve">
          <source>You can also define your own errors by creating a module and using the &lt;code&gt;defexception&lt;/code&gt; construct inside it; this way, you&amp;rsquo;ll create an error with the same name as the module it&amp;rsquo;s defined in. The most common case is to define a custom exception with a message field:</source>
          <target state="translated">Вы также можете определить свои собственные ошибки, создав модуль и используя внутри него конструкцию &lt;code&gt;defexception&lt;/code&gt; ; таким образом вы создадите ошибку с тем же именем, что и модуль, в котором она определена. Наиболее распространенный случай - определить настраиваемое исключение с полем сообщения:</target>
        </trans-unit>
        <trans-unit id="b68e78499f2ea8db0e4afcb826dd2b0504211510" translate="yes" xml:space="preserve">
          <source>You can also enforce that certain keys have to be specified when creating the struct:</source>
          <target state="translated">Вы также можете навязать,что определенные ключи должны быть указаны при создании структуры:</target>
        </trans-unit>
        <trans-unit id="45b6597eaf9dbe4f074f235f2d8907b14f3b97ad" translate="yes" xml:space="preserve">
          <source>You can also execute one-off commands, run the release as a daemon on Unix-like system, or install it as a service on Windows. We will take a look at those next. You can also list all available commands by invoking &lt;code&gt;bin/RELEASE_NAME&lt;/code&gt;.</source>
          <target state="translated">Вы также можете выполнять одноразовые команды, запускать выпуск как демон в Unix-подобной системе или устанавливать его как службу в Windows. Мы рассмотрим их дальше. Вы также можете просмотреть все доступные команды, вызвав &lt;code&gt;bin/RELEASE_NAME&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ce48ddf574efae9070be2275a470d1348ca3f552" translate="yes" xml:space="preserve">
          <source>You can also force function calls and keywords to be rendered on multiple lines by having each entry on its own line:</source>
          <target state="translated">Вы также можете принудительно вызывать функции и отображать ключевые слова на нескольких линиях,имея каждую запись на своей линии:</target>
        </trans-unit>
        <trans-unit id="f16e22554498a2f7d0cb0cce82e36cf97adf0692" translate="yes" xml:space="preserve">
          <source>You can also match against specific patterns:</source>
          <target state="translated">Вы также можете сопоставить их с определенными шаблонами:</target>
        </trans-unit>
        <trans-unit id="a9329b9f92977c7892d7c88a42d5d26ed7aa5b4a" translate="yes" xml:space="preserve">
          <source>You can also name your arguments in a typespec using &lt;code&gt;arg_name :: arg_type&lt;/code&gt; syntax. This is particularly useful in documentation as a way to differentiate multiple arguments of the same type (or multiple elements of the same type in a type definition):</source>
          <target state="translated">Вы также можете назвать свои аргументы в спецификации типов, используя синтаксис &lt;code&gt;arg_name :: arg_type&lt;/code&gt; . Это особенно полезно в документации как способ различать несколько аргументов одного типа (или несколько элементов одного типа в определении типа):</target>
        </trans-unit>
        <trans-unit id="de6063053e666763805418981069cf91fee85db4" translate="yes" xml:space="preserve">
          <source>You can also pass a keyword list of options to the reader, where the &lt;code&gt;:path&lt;/code&gt; is a required key:</source>
          <target state="translated">Вы также можете передать читателю список опций ключевых слов, где &lt;code&gt;:path&lt;/code&gt; является обязательным ключом:</target>
        </trans-unit>
        <trans-unit id="8f19d17744c6ca47102d5d5a6f0a7e379ef2e1be" translate="yes" xml:space="preserve">
          <source>You can also run tasks directly with &lt;a href=&quot;#run/2&quot;&gt;&lt;code&gt;run/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Вы также можете запускать задачи напрямую с помощью &lt;a href=&quot;#run/2&quot;&gt; &lt;code&gt;run/2&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6d06321caa5d42d499f94a7c08cb9516a5fc7e22" translate="yes" xml:space="preserve">
          <source>You can also select or skip functions when calling &lt;code&gt;doctest&lt;/code&gt;. See the documentation on the &lt;code&gt;:except&lt;/code&gt; and &lt;code&gt;:only&lt;/code&gt; options below for more information.</source>
          <target state="translated">Вы также можете выбрать или пропустить функции при вызове &lt;code&gt;doctest&lt;/code&gt; . См. Документацию по параметрам &lt;code&gt;:except&lt;/code&gt; и &lt;code&gt;:only&lt;/code&gt; ниже для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="4d5c4891fc2b5dc5597244eabc7c731fcd25c654" translate="yes" xml:space="preserve">
          <source>You can also showcase expressions raising an exception, for example:</source>
          <target state="translated">Можно также показывать выражения,вызывающие исключение,например:</target>
        </trans-unit>
        <trans-unit id="e510e5383d56a207bdf88bf2eafaec7eb9db321b" translate="yes" xml:space="preserve">
          <source>You can also specify that certain dependencies are available only for certain environments:</source>
          <target state="translated">Также можно указать,что определенные зависимости доступны только для определенных сред:</target>
        </trans-unit>
        <trans-unit id="e79de485968329efd72c9b8d75bcf174d86956a3" translate="yes" xml:space="preserve">
          <source>You can also start it by calling &lt;a href=&quot;#start_link/1&quot;&gt;&lt;code&gt;start_link/1&lt;/code&gt;&lt;/a&gt; directly:</source>
          <target state="translated">Вы также можете запустить его, &lt;a href=&quot;#start_link/1&quot;&gt; &lt;code&gt;start_link/1&lt;/code&gt; &lt;/a&gt; вызвав start_link / 1 :</target>
        </trans-unit>
        <trans-unit id="7b83780f98299cbc7765deca3b62980471aa7250" translate="yes" xml:space="preserve">
          <source>You can also use &lt;code&gt;is_integer/1&lt;/code&gt;, &lt;code&gt;is_float/1&lt;/code&gt; or &lt;code&gt;is_number/1&lt;/code&gt; to check, respectively, if an argument is an integer, a float, or either.</source>
          <target state="translated">Вы также можете использовать &lt;code&gt;is_integer/1&lt;/code&gt; , &lt;code&gt;is_float/1&lt;/code&gt; или &lt;code&gt;is_number/1&lt;/code&gt; для проверки, соответственно, является ли аргумент целым числом, числом с плавающей запятой или любым другим .</target>
        </trans-unit>
        <trans-unit id="0109469a00b4fd678c9dc3cf7143a92673581f33" translate="yes" xml:space="preserve">
          <source>You can also use the &lt;a href=&quot;#i/1&quot;&gt;&lt;code&gt;i/1&lt;/code&gt;&lt;/a&gt; function to introspect any value you have in the shell:</source>
          <target state="translated">Вы также можете использовать функцию &lt;a href=&quot;#i/1&quot;&gt; &lt;code&gt;i/1&lt;/code&gt; &lt;/a&gt; для анализа любого значения, которое есть в оболочке:</target>
        </trans-unit>
        <trans-unit id="6997e7247a3fc6a894b0d9b9dc9be42e6fc758f9" translate="yes" xml:space="preserve">
          <source>You can also use the functions in &lt;a href=&quot;https://hexdocs.pm/elixir/String.html&quot;&gt;the &lt;code&gt;String&lt;/code&gt; module&lt;/a&gt; to split a string in its individual characters, each one as a string of length 1:</source>
          <target state="translated">Вы можете также использовать функции &lt;a href=&quot;https://hexdocs.pm/elixir/String.html&quot;&gt;в &lt;code&gt;String&lt;/code&gt; модуль&lt;/a&gt; для разбиения строки в ее отдельных символов, каждый из которых в виде строки длины 1:</target>
        </trans-unit>
        <trans-unit id="032d983d619287af7e19e57383f3a70a6c51b618" translate="yes" xml:space="preserve">
          <source>You can automate this process in a couple different ways. One option is to make it part of your Continuous Integration (CI) / Continuous Deployment (CD) pipeline. When you have a CI/CD pipeline, it is common that the machines in your CI/CD pipeline run on the exact same target triple as your production servers (if they don't, they should). In this case, you can assemble the release at the end of your CI/CD pipeline by calling &lt;code&gt;MIX_ENV=prod mix release&lt;/code&gt; and push the artifact to S3 or any other network storage. To perform the deployment, your production machines can fetch the deployment from the network storage and run &lt;code&gt;bin/my_app start&lt;/code&gt;.</source>
          <target state="translated">Вы можете автоматизировать этот процесс несколькими способами. Один из вариантов - сделать его частью конвейера непрерывной интеграции (CI) / непрерывного развертывания (CD). Когда у вас есть конвейер CI / CD, обычно машины в вашем конвейере CI / CD работают на той же целевой тройке, что и ваши производственные серверы (если их нет, они должны). В этом случае вы можете собрать релиз в конце вашего конвейера CI / CD, вызвав &lt;code&gt;MIX_ENV=prod mix release&lt;/code&gt; и отправив артефакт на S3 или в любое другое сетевое хранилище. Чтобы выполнить развертывание, ваши производственные машины могут получить развертывание из сетевого хранилища и запустить &lt;code&gt;bin/my_app start&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0a41d7f6517eae46576fc865a7cd516cbedbf63d" translate="yes" xml:space="preserve">
          <source>You can change the path to the runtime configuration file by setting &lt;code&gt;:runtime_config_path&lt;/code&gt; inside each release configuration. This path is resolved at build time as the given configuration file is always copied to inside the release:</source>
          <target state="translated">Вы можете изменить путь к файлу конфигурации среды выполнения, задав &lt;code&gt;:runtime_config_path&lt;/code&gt; внутри каждой конфигурации выпуска. Этот путь разрешается во время сборки, так как данный файл конфигурации всегда копируется внутри выпуска:</target>
        </trans-unit>
        <trans-unit id="d849ace8fe93a046c9b6e408b21968764c52df57" translate="yes" xml:space="preserve">
          <source>You can change this behaviour by giving the &lt;code&gt;--no-start&lt;/code&gt; flag to Mix. It is rarely used in practice but it allows us to understand the underlying mechanisms better. Let&amp;rsquo;s give it a try.</source>
          <target state="translated">Вы можете изменить это поведение, установив флаг &lt;code&gt;--no-start&lt;/code&gt; для Mix. На практике он используется редко, но позволяет лучше понять основные механизмы. Давайте попробуем.</target>
        </trans-unit>
        <trans-unit id="8a64c6f6bfb10d20ae453663361f01db8ee582f3" translate="yes" xml:space="preserve">
          <source>You can concatenate two strings with the &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#%3C%3E/2&quot;&gt;&lt;code&gt;&amp;lt;&amp;gt;/2&lt;/code&gt;&lt;/a&gt; operator:</source>
          <target state="translated">Вы можете объединить две строки с помощью оператора &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#%3C%3E/2&quot;&gt; &lt;code&gt;&amp;lt;&amp;gt;/2&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="34a6cd6af6206fffe64d64fdd1b87f091eba6453" translate="yes" xml:space="preserve">
          <source>You can configure your list of tracers via &lt;a href=&quot;#put_compiler_option/2&quot;&gt;&lt;code&gt;put_compiler_option/2&lt;/code&gt;&lt;/a&gt;. The following events are available to tracers:</source>
          <target state="translated">Вы можете настроить свой список трассировщиков с помощью &lt;a href=&quot;#put_compiler_option/2&quot;&gt; &lt;code&gt;put_compiler_option/2&lt;/code&gt; &lt;/a&gt; . Трассерам доступны следующие события:</target>
        </trans-unit>
        <trans-unit id="27f4ad4dd738ad4d78055abf3e6e00767bbab05b" translate="yes" xml:space="preserve">
          <source>You can convert a charlist to a string and back by using the &lt;code&gt;to_string/1&lt;/code&gt; and &lt;code&gt;to_charlist/1&lt;/code&gt; functions:</source>
          <target state="translated">Вы можете преобразовать список символов в строку и обратно с помощью &lt;code&gt;to_string/1&lt;/code&gt; и &lt;code&gt;to_charlist/1&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="d3c998732a481638fd2db1b4a1bcc03793a148fa" translate="yes" xml:space="preserve">
          <source>You can create a new Elixir library by running the &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.New.html&quot;&gt;&lt;code&gt;mix new&lt;/code&gt;&lt;/a&gt; command:</source>
          <target state="translated">Вы можете создать новую библиотеку Elixir, выполнив команду &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.New.html&quot;&gt; &lt;code&gt;mix new&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="296e6e5ab861199c61485f84c654338b04c5c59e" translate="yes" xml:space="preserve">
          <source>You can customize the tmp directory used both for logging and for piping in daemon mode by setting the &lt;code&gt;RELEASE_TMP&lt;/code&gt; environment variable. See the &quot;Customization&quot; section.</source>
          <target state="translated">Вы можете настроить каталог tmp, используемый как для ведения журнала, так и для конвейерной передачи в режиме демона, установив переменную среды &lt;code&gt;RELEASE_TMP&lt;/code&gt; . См. Раздел &amp;laquo;Настройка&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="8d6434c5b2ade057524f84d6758bcde70ebb6f7a" translate="yes" xml:space="preserve">
          <source>You can define a structure combining both fields with explicit default values, and implicit &lt;code&gt;nil&lt;/code&gt; values. In this case you must first specify the fields which implicitly default to nil:</source>
          <target state="translated">Вы можете определить структуру, объединяющую оба поля с явными значениями по умолчанию и неявными значениями &lt;code&gt;nil&lt;/code&gt; . В этом случае вы должны сначала указать поля, которые неявно по умолчанию равны nil:</target>
        </trans-unit>
        <trans-unit id="d347c6fc0550ca70dfcc1c45aed881edcb92d810" translate="yes" xml:space="preserve">
          <source>You can find the built-in list of guards &lt;a href=&quot;kernel#guards&quot;&gt;in the &lt;code&gt;Kernel&lt;/code&gt; module&lt;/a&gt;. Here is an overview:</source>
          <target state="translated">Вы можете найти встроенный список охранников &lt;a href=&quot;kernel#guards&quot;&gt;в модуле &lt;code&gt;Kernel&lt;/code&gt; &lt;/a&gt; . Вот обзор:</target>
        </trans-unit>
        <trans-unit id="4fe77b5370ddcf03d4ba471d1546f4c568f7d01e" translate="yes" xml:space="preserve">
          <source>You can force lists, tuples, bitstrings, maps, structs and function calls to have one entry per line by adding a newline after the opening bracket and a new line before the closing bracket lines. For example:</source>
          <target state="translated">Вы можете заставить списки,кортежи,битовые строки,карты,структуры и вызовы функций иметь по одной записи на строку,добавляя новую строку после открывающей скобки и новую строку перед закрывающими строками скобки.Например:</target>
        </trans-unit>
        <trans-unit id="30fb8fde1f35561abc0c830c8f5133db917a5581" translate="yes" xml:space="preserve">
          <source>You can get a list of all compilers by running:</source>
          <target state="translated">Вы можете получить список всех компиляторов,запустив их:</target>
        </trans-unit>
        <trans-unit id="a832effd334a13f97e09ed1afd1f5e319784c368" translate="yes" xml:space="preserve">
          <source>You can get further information about a particular task by invoking &lt;code&gt;mix help TASK&lt;/code&gt;.</source>
          <target state="translated">Вы можете получить дополнительную информацию о конкретной задаче, вызвав &lt;code&gt;mix help TASK&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e8f264e42957665b5c8e06ba39323b8ce45a1614" translate="yes" xml:space="preserve">
          <source>You can get the representation of any expression by using the &lt;code&gt;quote&lt;/code&gt; macro:</source>
          <target state="translated">Вы можете получить представление любого выражения, используя макрос &lt;code&gt;quote&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="d21c63a1447fa0e26ff6a7b9be32848ffe669a41" translate="yes" xml:space="preserve">
          <source>You can however access the underlying error by invoking the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Inspect&lt;/code&gt;&lt;/a&gt; implementation directly. For example, to test &lt;a href=&quot;https://hexdocs.pm/elixir/Inspect.MapSet.html&quot;&gt;&lt;code&gt;Inspect.MapSet&lt;/code&gt;&lt;/a&gt; above, you can invoke it as:</source>
          <target state="translated">Однако вы можете получить доступ к основной ошибке путем вызова &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Inspect&lt;/code&gt; &lt;/a&gt; выполнение непосредственно. Например, чтобы протестировать &lt;a href=&quot;https://hexdocs.pm/elixir/Inspect.MapSet.html&quot;&gt; &lt;code&gt;Inspect.MapSet&lt;/code&gt; &lt;/a&gt; выше, вы можете вызвать его как:</target>
        </trans-unit>
        <trans-unit id="15574cf9e55c0c4cec340f97f66c84fcc6fda9fc" translate="yes" xml:space="preserve">
          <source>You can invoke &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Kernel&lt;/code&gt;&lt;/a&gt; functions and macros anywhere in Elixir code without the use of the &lt;code&gt;Kernel.&lt;/code&gt; prefix since they have all been automatically imported. For example, in IEx, you can call:</source>
          <target state="translated">Вы можете вызывать функции и макросы &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Kernel&lt;/code&gt; &lt;/a&gt; любом месте кода Elixir без использования &lt;code&gt;Kernel.&lt;/code&gt; префикс, поскольку все они были автоматически импортированы. Например, в IEx вы можете позвонить:</target>
        </trans-unit>
        <trans-unit id="7cc7d6571340f5c6c12c483154daae59b9c53bd0" translate="yes" xml:space="preserve">
          <source>You can invoke the &lt;code&gt;round&lt;/code&gt; function to get the closest integer to a given float, or the &lt;code&gt;trunc&lt;/code&gt; function to get the integer part of a float.</source>
          <target state="translated">Вы можете вызвать функцию &lt;code&gt;round&lt;/code&gt; , чтобы получить ближайшее целое число к заданному числу с плавающей запятой, или функцию &lt;code&gt;trunc&lt;/code&gt; , чтобы получить целую часть числа с плавающей запятой.</target>
        </trans-unit>
        <trans-unit id="5905f9e7cf68562c6033804324e364bd7fafdae3" translate="yes" xml:space="preserve">
          <source>You can invoke this function directly when you are not able to invoke &lt;a href=&quot;https://hexdocs.pm/iex/IEx.html#pry/0&quot;&gt;&lt;code&gt;IEx.pry/0&lt;/code&gt;&lt;/a&gt; as a macro. This function expects the binding (from &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#binding/0&quot;&gt;&lt;code&gt;Kernel.binding/0&lt;/code&gt;&lt;/a&gt;) and the environment (from &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#__ENV__/0&quot;&gt;&lt;code&gt;__ENV__/0&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">Вы можете вызвать эту функцию напрямую, если не можете вызвать &lt;a href=&quot;https://hexdocs.pm/iex/IEx.html#pry/0&quot;&gt; &lt;code&gt;IEx.pry/0&lt;/code&gt; &lt;/a&gt; в качестве макроса. Эта функция ожидает привязки (из &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#binding/0&quot;&gt; &lt;code&gt;Kernel.binding/0&lt;/code&gt; &lt;/a&gt; ) и среды (из &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#__ENV__/0&quot;&gt; &lt;code&gt;__ENV__/0&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="d8f4877ea531cc6ecd46b4a4e1b0aec877f1d54f" translate="yes" xml:space="preserve">
          <source>You can learn more about protocols and implementations in the &lt;a href=&quot;https://hexdocs.pm/elixir/Protocol.html&quot;&gt;&lt;code&gt;Protocol&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">Вы можете узнать больше о протоколах и их реализациях в модуле &lt;a href=&quot;https://hexdocs.pm/elixir/Protocol.html&quot;&gt; &lt;code&gt;Protocol&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3de3b4d6f1962ebd8513cf681799409cbcd4ca12" translate="yes" xml:space="preserve">
          <source>You can learn more about the code formatter by checking &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Format.html&quot;&gt;the format task documentation&lt;/a&gt; or by reading &lt;a href=&quot;https://elixir-lang.org/blog/2018/01/17/elixir-v1-6-0-released/&quot;&gt;the release announcement for Elixir v1.6&lt;/a&gt;, the first version to include the formatter.</source>
          <target state="translated">Вы можете узнать больше о &lt;a href=&quot;https://elixir-lang.org/blog/2018/01/17/elixir-v1-6-0-released/&quot;&gt;средстве&lt;/a&gt; форматирования кода, проверив &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Format.html&quot;&gt;документацию&lt;/a&gt; по задаче форматирования или прочитав объявление о выпуске Elixir v1.6 , первой версии, включающей средство форматирования.</target>
        </trans-unit>
        <trans-unit id="e68e6bb95841d8a40192a9512d9dd906cf05c679" translate="yes" xml:space="preserve">
          <source>You can learn more about the generation of application resource files in the documentation of &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Compile.App.html&quot;&gt;&lt;code&gt;Mix.Tasks.Compile.App&lt;/code&gt;&lt;/a&gt;, available as well by running &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Compile.App.html&quot;&gt;&lt;code&gt;mix help compile.app&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Вы можете узнать больше о создании файлов ресурсов приложения в документации &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Compile.App.html&quot;&gt; &lt;code&gt;Mix.Tasks.Compile.App&lt;/code&gt; &lt;/a&gt; , которую также можно получить, запустив &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Compile.App.html&quot;&gt; &lt;code&gt;mix help compile.app&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="404b8c4644c9d0f9d3755aaac33d1f0c7341b190" translate="yes" xml:space="preserve">
          <source>You can leverage &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Config&lt;/code&gt;&lt;/a&gt; instead of &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Config.html&quot;&gt;&lt;code&gt;Mix.Config&lt;/code&gt;&lt;/a&gt; in three steps. The first step is to replace &lt;code&gt;use Mix.Config&lt;/code&gt; at the top of your config files by &lt;code&gt;import Config&lt;/code&gt;.</source>
          <target state="translated">Вы можете использовать &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Config&lt;/code&gt; &lt;/a&gt; вместо &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Config.html&quot;&gt; &lt;code&gt;Mix.Config&lt;/code&gt; &lt;/a&gt; за три шага. Первый шаг - заменить &lt;code&gt;use Mix.Config&lt;/code&gt; в верхней части ваших файлов конфигурации на &lt;code&gt;import Config&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="858e0cb58aec939699966ea77b8a16af5dbe3b1c" translate="yes" xml:space="preserve">
          <source>You can leverage &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Config&lt;/code&gt;&lt;/a&gt; instead of &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Config.html&quot;&gt;&lt;code&gt;Mix.Config&lt;/code&gt;&lt;/a&gt; in two steps. The first step is to replace &lt;code&gt;use Mix.Config&lt;/code&gt; at the top of your config files by &lt;code&gt;import Config&lt;/code&gt;.</source>
          <target state="translated">Вы можете использовать &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Config&lt;/code&gt; &lt;/a&gt; вместо &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Config.html&quot;&gt; &lt;code&gt;Mix.Config&lt;/code&gt; &lt;/a&gt; в два этапа. Первый шаг - заменить &lt;code&gt;use Mix.Config&lt;/code&gt; в верхней части ваших файлов конфигурации на &lt;code&gt;import Config&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="481fc9f7ce3fe55a20ec7b55bee6cc479cc4c920" translate="yes" xml:space="preserve">
          <source>You can limit which apps the cmd runs in by passing the app names before the cmd using --app:</source>
          <target state="translated">Можно ограничить то,какие приложения выполняются в команде,передав имена приложений перед командой с помощью --app:</target>
        </trans-unit>
        <trans-unit id="061aef6ce80569a69cf92b6fcba5ab2892dd7d26" translate="yes" xml:space="preserve">
          <source>You can opt into this behaviour for individual tests by tagging them with &lt;code&gt;:capture_log&lt;/code&gt; or enable log capture for all tests in the ExUnit configuration:</source>
          <target state="translated">Вы можете выбрать в это поведение для отдельных тестов, помечая их &lt;code&gt;:capture_log&lt;/code&gt; или включить захват журнала для всех тестов в конфигурации ExUnit:</target>
        </trans-unit>
        <trans-unit id="9caab4aa325a00ee9cd1d2ba0be959240ba0340c" translate="yes" xml:space="preserve">
          <source>You can print a string using the &lt;code&gt;IO.puts/1&lt;/code&gt; function from the &lt;code&gt;IO&lt;/code&gt; module:</source>
          <target state="translated">Вы можете распечатать строку с помощью функции &lt;code&gt;IO.puts/1&lt;/code&gt; из модуля &lt;code&gt;IO&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="238dc90b91f8829ebbb626aecab76e8b80b505c8" translate="yes" xml:space="preserve">
          <source>You can read more about &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#with/1&quot;&gt;&lt;code&gt;with&lt;/code&gt; in our documentation&lt;/a&gt;.</source>
          <target state="translated">Вы можете узнать больше о &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#with/1&quot;&gt; &lt;code&gt;with&lt;/code&gt; в нашей документации&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b5cc3e518c581def9b6af3b0a0aee431cfb36ec7" translate="yes" xml:space="preserve">
          <source>You can read more about &lt;code&gt;quote&lt;/code&gt; and &lt;code&gt;unquote&lt;/code&gt; in the &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html&quot;&gt;&lt;code&gt;Kernel.SpecialForms&lt;/code&gt; module&lt;/a&gt;. Documentation for &lt;code&gt;Macro.escape/1&lt;/code&gt; and other functions related to quoted expressions can be found in the &lt;a href=&quot;https://hexdocs.pm/elixir/Macro.html&quot;&gt;&lt;code&gt;Macro&lt;/code&gt; module&lt;/a&gt;.</source>
          <target state="translated">Вы можете узнать больше о &lt;code&gt;quote&lt;/code&gt; и &lt;code&gt;unquote&lt;/code&gt; в &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html&quot;&gt;модуле &lt;/a&gt; &lt;code&gt;Kernel.SpecialForms&lt;/code&gt; . Документацию по &lt;code&gt;Macro.escape/1&lt;/code&gt; и другим функциям, связанным с выражениями в кавычках, можно найти в &lt;a href=&quot;https://hexdocs.pm/elixir/Macro.html&quot;&gt;модуле &lt;/a&gt; &lt;code&gt;Macro&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4c44d26110447a0ef14d1b0f03e310d296868469" translate="yes" xml:space="preserve">
          <source>You can read more about ExUnit cases in the &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.Case.html&quot;&gt;&lt;code&gt;ExUnit.Case&lt;/code&gt; module documentation&lt;/a&gt; and more about callbacks in &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.Callbacks.html&quot;&gt;&lt;code&gt;ExUnit.Callbacks&lt;/code&gt; docs&lt;/a&gt;.</source>
          <target state="translated">Вы можете прочитать больше о случаях &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.Case.html&quot;&gt; &lt;code&gt;ExUnit.Case&lt;/code&gt; документации модуля ExUnit.Case&lt;/a&gt; и больше о обратных &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.Callbacks.html&quot;&gt; &lt;code&gt;ExUnit.Callbacks&lt;/code&gt; документации ExUnit.Callbacks&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7a98f56e08fd31d3296a30c5e18504c38b9716ba" translate="yes" xml:space="preserve">
          <source>You can read more about filters, tags and the default tags in &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.Case.html&quot;&gt;&lt;code&gt;ExUnit.Case&lt;/code&gt; module documentation&lt;/a&gt;.</source>
          <target state="translated">Вы можете узнать больше о фильтрах, тегах и тегах по умолчанию в &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.Case.html&quot;&gt;документации модуля &lt;/a&gt; &lt;code&gt;ExUnit.Case&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="16ead9398b916dd9cb65ff27aa836c6e8dfd0e7e" translate="yes" xml:space="preserve">
          <source>You can read more about formatting in &lt;a href=&quot;https://hexdocs.pm/logger/Logger.Formatter.html&quot;&gt;&lt;code&gt;Logger.Formatter&lt;/code&gt;&lt;/a&gt;, especially if you want to support custom formatting in a custom backend.</source>
          <target state="translated">Вы можете узнать больше о форматировании в &lt;a href=&quot;https://hexdocs.pm/logger/Logger.Formatter.html&quot;&gt; &lt;code&gt;Logger.Formatter&lt;/code&gt; &lt;/a&gt; , особенно если вы хотите поддерживать настраиваемое форматирование в настраиваемом бэкэнде.</target>
        </trans-unit>
        <trans-unit id="74775aa5a943cf5bb41ef494fec5bf544f913cbb" translate="yes" xml:space="preserve">
          <source>You can read more about formatting in &lt;a href=&quot;logger.formatter&quot;&gt;&lt;code&gt;Logger.Formatter&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Вы можете узнать больше о форматировании в &lt;a href=&quot;logger.formatter&quot;&gt; &lt;code&gt;Logger.Formatter&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e5be2afeae811784dc65ff240ca6f8289e524240" translate="yes" xml:space="preserve">
          <source>You can run &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Deps.html&quot;&gt;&lt;code&gt;mix help deps&lt;/code&gt;&lt;/a&gt; to learn more about dependencies in Mix.</source>
          <target state="translated">Вы можете запустить &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Deps.html&quot;&gt; &lt;code&gt;mix help deps&lt;/code&gt; ,&lt;/a&gt; чтобы узнать больше о зависимостях в Mix.</target>
        </trans-unit>
        <trans-unit id="de940e7c82802a489662bba3bb1b738febb539ca" translate="yes" xml:space="preserve">
          <source>You can run &lt;a href=&quot;mix.tasks.deps&quot;&gt;&lt;code&gt;mix help deps&lt;/code&gt;&lt;/a&gt; to learn more about dependencies in Mix.</source>
          <target state="translated">Вы можете запустить &lt;a href=&quot;mix.tasks.deps&quot;&gt; &lt;code&gt;mix help deps&lt;/code&gt; ,&lt;/a&gt; чтобы узнать больше о зависимостях в Mix.</target>
        </trans-unit>
        <trans-unit id="e70cf0e8b02aa2541f0f863c818291aeb152867f" translate="yes" xml:space="preserve">
          <source>You can run the release in daemon mode with the command:</source>
          <target state="translated">Вы можете запустить релиз в демоническом режиме с помощью команды:</target>
        </trans-unit>
        <trans-unit id="54f450206bafe3c72254cb929d8344e838346665" translate="yes" xml:space="preserve">
          <source>You can see a handful more options used by the Erlang compiler in the documentation for the &lt;a href=&quot;http://www.erlang.org/doc/man/compile.html&quot;&gt;&lt;code&gt;:compile&lt;/code&gt; module&lt;/a&gt;.</source>
          <target state="translated">Вы можете увидеть несколько дополнительных опций, используемых компилятором Erlang, в документации для &lt;a href=&quot;http://www.erlang.org/doc/man/compile.html&quot;&gt;модуля &lt;/a&gt; &lt;code&gt;:compile&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c8976612d104d376ef4fa0cf9b359e7f22b095b4" translate="yes" xml:space="preserve">
          <source>You can see all the built-in types provided by Elixir &lt;a href=&quot;https://hexdocs.pm/elixir/typespecs.html&quot;&gt;in the typespecs docs&lt;/a&gt;.</source>
          <target state="translated">Вы можете увидеть все встроенные типы, предоставляемые Elixir, &lt;a href=&quot;https://hexdocs.pm/elixir/typespecs.html&quot;&gt;в документации по типам&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f508b38185d8637e812e75bab67d06d9f5d4394e" translate="yes" xml:space="preserve">
          <source>You can see now the prompt is slightly different and shows the node name followed by the computer name:</source>
          <target state="translated">Теперь вы видите,что приглашение немного отличается и показывает имя узла,за которым следует имя компьютера:</target>
        </trans-unit>
        <trans-unit id="0598ae8d09ffdda67a9b201d8b0039b9494be85e" translate="yes" xml:space="preserve">
          <source>You can see that instead of containing bytes, a charlist contains integer code points. By default, IEx will only output code points if any of the integers falls outside the ASCII range of 0 to 127:</source>
          <target state="translated">Видно,что вместо того,чтобы содержать байты,charlist содержит целочисленные точки кода.По умолчанию IEx будет выводить кодовые точки только в том случае,если любое из целых чисел окажется за пределами ASCII диапазона от 0 до 127:</target>
        </trans-unit>
        <trans-unit id="516c3c5987d4ecaa8ab4cebbdb6cd4f7180d78fb" translate="yes" xml:space="preserve">
          <source>You can see that variables are also represented with a tuple, except the third element is an atom expressing the variable context.</source>
          <target state="translated">Вы можете видеть,что переменные также представлены кортежом,за исключением того,что третий элемент является атомом,выражающим контекст переменной.</target>
        </trans-unit>
        <trans-unit id="5b9ccc7485aeb7ac27c89593fed8959b0d8ad55d" translate="yes" xml:space="preserve">
          <source>You can see that, instead of containing bytes, a charlist contains the code points of the characters between single-quotes (note that by default IEx will only output code points if any of the integers is outside the ASCII range). So while double-quotes represent a string (i.e. a binary), single-quotes represent a charlist (i.e. a list).</source>
          <target state="translated">Видно,что вместо байтов charlist содержит кодовые точки символов между одиночными кавычками (обратите внимание,что по умолчанию IEx будет выводить кодовые точки только в том случае,если любое из целых чисел находится за пределами ASCII диапазона).Таким образом,если двойные кавычки представляют собой строку (т.е.двоичный файл),то одинарные кавычки представляют собой список символов charlist (т.е.список).</target>
        </trans-unit>
        <trans-unit id="13da5bbf18b54b654e2e2ccc5a518a213ea62e25" translate="yes" xml:space="preserve">
          <source>You can see them being used in constructs such as &lt;code&gt;receive&lt;/code&gt;, &lt;code&gt;try&lt;/code&gt;, and others.</source>
          <target state="translated">Вы можете увидеть, как они используются в таких конструкциях, как &lt;code&gt;receive&lt;/code&gt; , &lt;code&gt;try&lt;/code&gt; и другие.</target>
        </trans-unit>
        <trans-unit id="8b973841f0016a154a2ccef0c5f3834aa77205c7" translate="yes" xml:space="preserve">
          <source>You can specify multiple releases where the key is the release name and the value is a keyword list with the release configuration. Releasing a certain name is done with:</source>
          <target state="translated">Вы можете указать несколько релизов,где ключом является имя релиза,а значением-список ключевых слов с конфигурацией релиза.Выпуск определенного имени осуществляется с помощью:</target>
        </trans-unit>
        <trans-unit id="7d347b71109e4b2e94b567fe8ba010ca5f9cdbf5" translate="yes" xml:space="preserve">
          <source>You can start an application by calling &lt;a href=&quot;https://hexdocs.pm/elixir/Application.html#ensure_all_started/1&quot;&gt;&lt;code&gt;Application.ensure_all_started/1&lt;/code&gt;&lt;/a&gt;. However, if for some reason you cannot start an application, maybe because it will run other services you do not want, you must at least load the application by calling &lt;a href=&quot;https://hexdocs.pm/elixir/Application.html#load/1&quot;&gt;&lt;code&gt;Application.load/1&lt;/code&gt;&lt;/a&gt;. If you don't load the application, any attempt at reading its environment or configuration may fail. Note that if you start an application, it is automatically loaded before started.</source>
          <target state="translated">Вы можете запустить приложение, вызвав &lt;a href=&quot;https://hexdocs.pm/elixir/Application.html#ensure_all_started/1&quot;&gt; &lt;code&gt;Application.ensure_all_started/1&lt;/code&gt; &lt;/a&gt; . Однако, если по какой-то причине вы не можете запустить приложение, возможно потому, что оно будет запускать другие службы, которые вам не нужны, вы должны хотя бы загрузить приложение, вызвав &lt;a href=&quot;https://hexdocs.pm/elixir/Application.html#load/1&quot;&gt; &lt;code&gt;Application.load/1&lt;/code&gt; &lt;/a&gt; . Если вы не загрузите приложение, любая попытка чтения его среды или конфигурации может потерпеть неудачу. Обратите внимание, что если вы запускаете приложение, оно автоматически загружается перед запуском.</target>
        </trans-unit>
        <trans-unit id="b61367dd10530be9cc81fb749aaf5a8d7be61c43" translate="yes" xml:space="preserve">
          <source>You can start those processes under test in isolation by running:</source>
          <target state="translated">Вы можете запускать тестируемые процессы изолированно,запуская их:</target>
        </trans-unit>
        <trans-unit id="fe09547257318c7e6f5e7852a60743468f3db318" translate="yes" xml:space="preserve">
          <source>You can take a look at the docs for &lt;a href=&quot;https://hexdocs.pm/elixir/Module.html&quot;&gt;Module&lt;/a&gt; for a complete list of supported attributes. Elixir also uses attributes to define &lt;a href=&quot;typespecs-and-behaviours&quot;&gt;typespecs&lt;/a&gt;.</source>
          <target state="translated">Полный список поддерживаемых атрибутов можно найти в документации по &lt;a href=&quot;https://hexdocs.pm/elixir/Module.html&quot;&gt;модулю&lt;/a&gt; . Elixir также использует атрибуты для определения &lt;a href=&quot;typespecs-and-behaviours&quot;&gt;спецификаций типов&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5003329b8d5825870febaa77dc5a05d8ad92d9da" translate="yes" xml:space="preserve">
          <source>You can use &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Kernel&lt;/code&gt;&lt;/a&gt; functions/macros without the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Kernel&lt;/code&gt;&lt;/a&gt; prefix anywhere in Elixir code as all its functions and macros are automatically imported. For example, in IEx:</source>
          <target state="translated">Вы можете использовать &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Kernel&lt;/code&gt; &lt;/a&gt; функцию / макросы без &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Kernel&lt;/code&gt; &lt;/a&gt; префикса любой точки Elixir кода , так как вся его функция и макросы автоматически импортированы. Например, в IEx:</target>
        </trans-unit>
        <trans-unit id="8f063c7f3b2e5fb194596446ea234e14e22e6a76" translate="yes" xml:space="preserve">
          <source>You can use &lt;a href=&quot;#shell/0&quot;&gt;&lt;code&gt;shell/0&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#shell/1&quot;&gt;&lt;code&gt;shell/1&lt;/code&gt;&lt;/a&gt; to temporarily switch shells, for example, if you want to run a Mix Task that normally produces a lot of output:</source>
          <target state="translated">Вы можете использовать &lt;a href=&quot;#shell/0&quot;&gt; &lt;code&gt;shell/0&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;#shell/1&quot;&gt; &lt;code&gt;shell/1&lt;/code&gt; &lt;/a&gt; для временного переключения оболочек, например, если вы хотите запустить задачу Mix, которая обычно производит много вывода:</target>
        </trans-unit>
        <trans-unit id="1ff3e87a6c2c47d0723f98be606445ee66b4e9e3" translate="yes" xml:space="preserve">
          <source>You can use &lt;a href=&quot;http://www.erlang.org/doc/man/file.html#format_error-1&quot;&gt;&lt;code&gt;:file.format_error/1&lt;/code&gt;&lt;/a&gt; to get a descriptive string of the error.</source>
          <target state="translated">Вы можете использовать &lt;a href=&quot;http://www.erlang.org/doc/man/file.html#format_error-1&quot;&gt; &lt;code&gt;:file.format_error/1&lt;/code&gt; ,&lt;/a&gt; чтобы получить строку описания ошибки.</target>
        </trans-unit>
        <trans-unit id="32805d53bcb25de0e45ff1ee652110cf06844e50" translate="yes" xml:space="preserve">
          <source>You can use the &lt;a href=&quot;#h/1&quot;&gt;&lt;code&gt;h/1&lt;/code&gt;&lt;/a&gt; function to invoke the documentation for any Elixir module or function:</source>
          <target state="translated">Вы можете использовать функцию &lt;a href=&quot;#h/1&quot;&gt; &lt;code&gt;h/1&lt;/code&gt; &lt;/a&gt; для вызова документации для любого модуля или функции Elixir:</target>
        </trans-unit>
        <trans-unit id="e7e9ff7ab3e09093f0158e4aab2c5cc2651ea616" translate="yes" xml:space="preserve">
          <source>You can use the &lt;a href=&quot;https://hexdocs.pm/iex/IEx.Helpers.html#i/1&quot;&gt;&lt;code&gt;IEx.Helpers.i/1&lt;/code&gt;&lt;/a&gt; helper to get a condensed rundown on charlists in IEx when you encounter them, which shows you the type, description and also the raw representation in one single summary.</source>
          <target state="translated">Вы можете использовать помощник &lt;a href=&quot;https://hexdocs.pm/iex/IEx.Helpers.html#i/1&quot;&gt; &lt;code&gt;IEx.Helpers.i/1&lt;/code&gt; ,&lt;/a&gt; чтобы получить сжатое изложение списков charlists в IEx, когда вы столкнетесь с ними, которое показывает вам тип, описание, а также необработанное представление в одном сводном виде.</target>
        </trans-unit>
        <trans-unit id="de73c3d055261ed09e1a43b8ec63874f87a9fe07" translate="yes" xml:space="preserve">
          <source>You can use the module+function to lookup for anything, including operators (try &lt;code&gt;h Kernel.+/2&lt;/code&gt;). Invoking &lt;code&gt;h&lt;/code&gt; without arguments displays the documentation for &lt;code&gt;IEx.Helpers&lt;/code&gt;, which is where &lt;code&gt;h&lt;/code&gt; and other functionality is defined.</source>
          <target state="translated">Вы можете использовать функцию module + для поиска чего угодно, включая операторы (попробуйте &lt;code&gt;h Kernel.+/2&lt;/code&gt; ). Вызов &lt;code&gt;h&lt;/code&gt; без аргументов отображает документацию для &lt;code&gt;IEx.Helpers&lt;/code&gt; , где определены &lt;code&gt;h&lt;/code&gt; и другие функции.</target>
        </trans-unit>
        <trans-unit id="4aa9d3c3d932c1ee0848c72824a9787504385105" translate="yes" xml:space="preserve">
          <source>You can verify a protocol is consolidated by checking its attributes:</source>
          <target state="translated">Вы можете проверить,что протокол консолидирован,проверив его атрибуты:</target>
        </trans-unit>
        <trans-unit id="685a0519371e51dd4e80c5cc3a472b10156fef57" translate="yes" xml:space="preserve">
          <source>You cannot even access variables defined in the same module unless you explicitly give it a context:</source>
          <target state="translated">Вы даже не можете получить доступ к переменным,определенным в том же модуле,если явно не зададите им контекст:</target>
        </trans-unit>
        <trans-unit id="2da60de011e5217c03ae75beeb07c81666f07da1" translate="yes" xml:space="preserve">
          <source>You could also replace the whole &lt;code&gt;apply&lt;/code&gt; system by explicitly sending messages. That's the example we will see next.</source>
          <target state="translated">Вы также можете заменить всю систему &lt;code&gt;apply&lt;/code&gt; , явно отправив сообщения. Это пример, который мы увидим дальше.</target>
        </trans-unit>
        <trans-unit id="52a81fdf1e26dc6a237fff7de279d410074015e7" translate="yes" xml:space="preserve">
          <source>You don&amp;rsquo;t actually need to memorize this ordering; it&amp;rsquo;s enough to know that this ordering exists.</source>
          <target state="translated">На самом деле вам не нужно запоминать этот порядок; достаточно знать, что такой порядок существует.</target>
        </trans-unit>
        <trans-unit id="eb49dae3e3f9d8636fe6649b7031d1a74f3182eb" translate="yes" xml:space="preserve">
          <source>You may also have noticed that we have added &lt;code&gt;@impl true&lt;/code&gt; before each callback. The &lt;code&gt;@impl true&lt;/code&gt; informs the compiler that our intention for the subsequent function definition is to define a callback. If by any chance we make a mistake in the function name or in the number of arguments, like we define a &lt;code&gt;handle_call/2&lt;/code&gt;, the compiler would warn us there isn&amp;rsquo;t any &lt;code&gt;handle_call/2&lt;/code&gt; to define, and would give us the complete list of known callbacks for the &lt;code&gt;GenServer&lt;/code&gt; module.</source>
          <target state="translated">Вы также могли заметить, что мы добавили &lt;code&gt;@impl true&lt;/code&gt; перед каждым обратным вызовом. В &lt;code&gt;@impl true&lt;/code&gt; сообщает компилятор , что наше намерение для последующего определения функции является определение обратного вызова. Если случайно мы сделаем ошибку в имени функции или в количестве аргументов, как мы определяем &lt;code&gt;handle_call/2&lt;/code&gt; , компилятор предупредит нас, что нет никакого &lt;code&gt;handle_call/2&lt;/code&gt; ,который нужно определить, и предоставит нам полный список известных обратных вызовов для модуля &lt;code&gt;GenServer&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="357f90408b77a2d7ab15eaf57433e794bef4a122" translate="yes" xml:space="preserve">
          <source>You may also set this option to &lt;code&gt;false&lt;/code&gt; if you desire to use the ERTS version installed on the target. Note, however, that the ERTS version on the target must have &lt;strong&gt;the exact version&lt;/strong&gt; as the ERTS version used when the release is assembled. Setting it to &lt;code&gt;false&lt;/code&gt; also disables hot code upgrades. Therefore, &lt;code&gt;:include_erts&lt;/code&gt; should be set to &lt;code&gt;false&lt;/code&gt; with caution and only if you are assembling the release on the same server that runs it.</source>
          <target state="translated">Вы также можете установить для этого параметра значение &lt;code&gt;false&lt;/code&gt; , если хотите использовать версию ERTS, установленную на целевом компьютере. Обратите внимание, однако, что версия ERTS на целевой машине должна иметь &lt;strong&gt;точную версию,&lt;/strong&gt; как версия ERTS, используемая при сборке выпуска. Установка значения &lt;code&gt;false&lt;/code&gt; также отключает обновление горячего кода. Поэтому &lt;code&gt;:include_erts&lt;/code&gt; следует устанавливать в значение &lt;code&gt;false&lt;/code&gt; с осторожностью и только в том случае, если вы собираете выпуск на том же сервере, на котором он запущен.</target>
        </trans-unit>
        <trans-unit id="d3ffa25c90671d5deafa8296be9a347ec0b5cc5a" translate="yes" xml:space="preserve">
          <source>You may capture the IO from any registered IO device. The device name given must be an atom representing the name of a registered process. In addition, Elixir provides two shortcuts:</source>
          <target state="translated">Вы можете захватить IO с любого зарегистрированного устройства ввода-вывода.Имя устройства должно быть атомом,представляющим название зарегистрированного процесса.Кроме того,Elixir предоставляет два ярлыка:</target>
        </trans-unit>
        <trans-unit id="ef79c7590435d6eb6d86dc0c5ca08534fa890283" translate="yes" xml:space="preserve">
          <source>You may define compound custom types, e.g. maps:</source>
          <target state="translated">Вы можете определить составные пользовательские типы,например,карты:</target>
        </trans-unit>
        <trans-unit id="d63d3165b51c6e5c0937ccdd6ef968772a3b4610" translate="yes" xml:space="preserve">
          <source>You may have noticed that &lt;code&gt;File.open/2&lt;/code&gt; returns a tuple like &lt;code&gt;{:ok, pid}&lt;/code&gt;:</source>
          <target state="translated">Вы могли заметить, что &lt;code&gt;File.open/2&lt;/code&gt; возвращает кортеж вроде &lt;code&gt;{:ok, pid}&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="24a9922677998390b346e99672a32ed06b220ac3" translate="yes" xml:space="preserve">
          <source>You may invoke:</source>
          <target state="translated">Вы можете вызвать:</target>
        </trans-unit>
        <trans-unit id="8f218d2faa7fa7209c123d6beeb4745cb90126c6" translate="yes" xml:space="preserve">
          <source>You may pass either &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;true&lt;/code&gt;, or a specific behaviour to &lt;code&gt;@impl&lt;/code&gt;.</source>
          <target state="translated">Вы можете передать &lt;code&gt;@impl&lt;/code&gt; либо &lt;code&gt;false&lt;/code&gt; , либо &lt;code&gt;true&lt;/code&gt; , либо конкретное поведение .</target>
        </trans-unit>
        <trans-unit id="35dfa5204eed8291195bbefec2b4dd5c6994b4a3" translate="yes" xml:space="preserve">
          <source>You may set &lt;code&gt;:format&lt;/code&gt; to either a string or a &lt;code&gt;{module, function}&lt;/code&gt; tuple if you wish to provide your own format function. Here is an example of how to configure the &lt;code&gt;:console&lt;/code&gt; backend in a &lt;code&gt;config/config.exs&lt;/code&gt; file:</source>
          <target state="translated">Вы можете установить &lt;code&gt;:format&lt;/code&gt; как строку или кортеж &lt;code&gt;{module, function}&lt;/code&gt; если вы хотите предоставить свою собственную функцию форматирования. Вот пример того , как настроить &lt;code&gt;:console&lt;/code&gt; бэкенд в &lt;code&gt;config/config.exs&lt;/code&gt; файла:</target>
        </trans-unit>
        <trans-unit id="3fbd8242e1f12076d2e6de9e662957c3435d74b0" translate="yes" xml:space="preserve">
          <source>You may then call &lt;code&gt;make_custom_env()&lt;/code&gt; to get a struct with the desired imports and aliases included.</source>
          <target state="translated">Затем вы можете вызвать &lt;code&gt;make_custom_env()&lt;/code&gt; чтобы получить структуру с желаемым импортом и включенными псевдонимами.</target>
        </trans-unit>
        <trans-unit id="69322d3d7e21dcf45f38c1a4256ea28e664abc0f" translate="yes" xml:space="preserve">
          <source>You might have noticed we have a function head, &lt;code&gt;def run(command)&lt;/code&gt;, without a body. In the &lt;a href=&quot;../modules-and-functions#default-arguments&quot;&gt;Modules and Functions&lt;/a&gt; chapter, we learned that a bodiless function can be used to declare default arguments for a multi-clause function. Here is another use case where we use a function without a body to document what the arguments are.</source>
          <target state="translated">Вы могли заметить, что у нас есть заголовок функции &lt;code&gt;def run(command)&lt;/code&gt; без тела. В главе &amp;laquo; &lt;a href=&quot;../modules-and-functions#default-arguments&quot;&gt;Модули и функции&amp;raquo;&lt;/a&gt; мы узнали, что бестелесная функция может использоваться для объявления аргументов по умолчанию для функции с несколькими предложениями. Вот еще один вариант использования, когда мы используем функцию без тела для документирования аргументов.</target>
        </trans-unit>
        <trans-unit id="60eed846530023fb8679ef23800ef12ddb7e3daa" translate="yes" xml:space="preserve">
          <source>You might notice that we added a line, &lt;code&gt;:ok = :gen_tcp.controlling_process(client, pid)&lt;/code&gt;. This makes the child process the &amp;ldquo;controlling process&amp;rdquo; of the &lt;code&gt;client&lt;/code&gt; socket. If we didn&amp;rsquo;t do this, the acceptor would bring down all the clients if it crashed because sockets would be tied to the process that accepted them (which is the default behaviour).</source>
          <target state="translated">Вы могли заметить, что мы добавили строку &lt;code&gt;:ok = :gen_tcp.controlling_process(client, pid)&lt;/code&gt; . Это делает дочерний процесс &amp;laquo;контролирующим процессом&amp;raquo; &lt;code&gt;client&lt;/code&gt; сокета. Если бы мы этого не сделали, акцептор отключил бы всех клиентов в случае сбоя, потому что сокеты были бы привязаны к процессу, который их принял (что является поведением по умолчанию).</target>
        </trans-unit>
        <trans-unit id="5f976962c87540d5ec1bd399d5ea623fcbba3044" translate="yes" xml:space="preserve">
          <source>You must create a &lt;code&gt;test_helper.exs&lt;/code&gt; file inside the &lt;code&gt;test&lt;/code&gt; directory and put the code common to all tests there.</source>
          <target state="translated">Вы должны создать файл &lt;code&gt;test_helper.exs&lt;/code&gt; внутри &lt;code&gt;test&lt;/code&gt; каталога и поместить туда общий для всех тестов код.</target>
        </trans-unit>
        <trans-unit id="669380c70bf6f138e0bf5ec04ed501d1a6411fc5" translate="yes" xml:space="preserve">
          <source>You should avoid spawning processes outside of a supervision tree, especially long-running ones. Instead, processes must be started inside supervision trees. This guarantees developers have full control over the initialization, restarts, and shutdown of the system.</source>
          <target state="translated">Следует избегать процессов нереста вне надзорного дерева,особенно длительных.Вместо этого процессы должны начинаться внутри дерева.Это гарантирует разработчикам полный контроль над инициализацией,перезагрузкой и выключением системы.</target>
        </trans-unit>
        <trans-unit id="dcb046535f15726d2bf09809f210124fab9764fd" translate="yes" xml:space="preserve">
          <source>You should avoid using exceptions for control-flow. For example, instead of:</source>
          <target state="translated">Следует избегать использования исключений для потока управления.Например,вместо:</target>
        </trans-unit>
        <trans-unit id="99f4ca1715b9c9721c3aedc65af08dc10eb9ec5f" translate="yes" xml:space="preserve">
          <source>You should avoid using the application environment (see &lt;a href=&quot;application#get_env/2&quot;&gt;&lt;code&gt;Application.get_env/2&lt;/code&gt;&lt;/a&gt;) as the configuration mechanism for libraries. The application environment is &lt;strong&gt;global&lt;/strong&gt; which means it becomes impossible for two dependencies to use your library in two different ways.</source>
          <target state="translated">Вам следует избегать использования среды приложения (см. &lt;a href=&quot;application#get_env/2&quot;&gt; &lt;code&gt;Application.get_env/2&lt;/code&gt; &lt;/a&gt; ) в качестве механизма конфигурации для библиотек. Среда приложения является &lt;strong&gt;глобальной,&lt;/strong&gt; что означает, что две зависимости не могут использовать вашу библиотеку двумя разными способами.</target>
        </trans-unit>
        <trans-unit id="95b404be508ac08733f6ca1d88b780ee1e89f1a5" translate="yes" xml:space="preserve">
          <source>You should avoid using the application environment (see &lt;a href=&quot;https://hexdocs.pm/elixir/Application.html#get_env/2&quot;&gt;&lt;code&gt;Application.get_env/2&lt;/code&gt;&lt;/a&gt;) as the configuration mechanism for libraries. The application environment is &lt;strong&gt;global&lt;/strong&gt; which means it becomes impossible for two dependencies to use your library in two different ways.</source>
          <target state="translated">Вам следует избегать использования среды приложения (см. &lt;a href=&quot;https://hexdocs.pm/elixir/Application.html#get_env/2&quot;&gt; &lt;code&gt;Application.get_env/2&lt;/code&gt; &lt;/a&gt; ) в качестве механизма конфигурации для библиотек. Среда приложения является &lt;strong&gt;глобальной,&lt;/strong&gt; что означает, что две зависимости не могут использовать вашу библиотеку двумя разными способами.</target>
        </trans-unit>
        <trans-unit id="2228d29e897b52b97888981e8823d3b22606271d" translate="yes" xml:space="preserve">
          <source>You should be aware that the code being profiled is running in an anonymous function which is invoked by &lt;a href=&quot;http://wwww.erlang.org/doc/man/eprof.html&quot;&gt;&lt;code&gt;:eprof&lt;/code&gt; module&lt;/a&gt;. Thus, you'll see some additional entries in your profile output. It is also important to note that the profiler is stopped as soon as the code has finished running, and this may need special attention, when: running asynchronous code as function calls which were called before the profiler stopped will not be counted; running synchronous code as long running computations and a profiler without a proper MFA trace pattern or filter may lead to a result set which is difficult to comprehend.</source>
          <target state="translated">Вы должны знать, что профилируемый код выполняется в анонимной функции, которая вызывается &lt;a href=&quot;http://wwww.erlang.org/doc/man/eprof.html&quot;&gt;модулем &lt;/a&gt; &lt;code&gt;:eprof&lt;/code&gt; . Таким образом, вы увидите некоторые дополнительные записи в выводе вашего профиля. Также важно отметить, что профилировщик останавливается, как только код завершает выполнение, и это может потребовать особого внимания, когда: выполнение асинхронного кода как вызовы функций, которые были вызваны до остановки профилировщика, не будут учитываться; выполнение синхронного кода в виде длительных вычислений и профилировщика без надлежащего шаблона трассировки или фильтра MFA может привести к набору результатов, который трудно понять.</target>
        </trans-unit>
        <trans-unit id="e4d1794f1b4805dfe6a3920546c5ae7ca73f34f1" translate="yes" xml:space="preserve">
          <source>You should be aware that the code being profiled is running in an anonymous function which is invoked by &lt;a href=&quot;http://wwww.erlang.org/doc/man/eprof.html&quot;&gt;&lt;code&gt;:eprof&lt;/code&gt; module&lt;/a&gt;. Thus, you'll see some additional entries in your profile output. It is also important to notice that the profiler is stopped as soon as the code has finished running, and this may need special attention, when: running asynchronous code as function calls which were called before the profiler stopped will not be counted; running synchronous code as long running computations and a profiler without a proper MFA trace pattern or filter may lead to a result set which is difficult to comprehend.</source>
          <target state="translated">Вы должны знать, что профилируемый код выполняется в анонимной функции, которая вызывается &lt;a href=&quot;http://wwww.erlang.org/doc/man/eprof.html&quot;&gt;модулем &lt;/a&gt; &lt;code&gt;:eprof&lt;/code&gt; . Таким образом, вы увидите некоторые дополнительные записи в выводе вашего профиля. Также важно отметить, что профилировщик останавливается, как только код завершает работу, и это может потребовать особого внимания, когда: выполнение асинхронного кода в виде вызовов функций, которые были вызваны до остановки профилировщика, не будет учитываться; выполнение синхронного кода в виде длительных вычислений и профилировщика без правильного шаблона трассировки MFA или фильтра может привести к набору результатов, который трудно понять.</target>
        </trans-unit>
        <trans-unit id="f609ba9cab33c27584866ee1bafabe1ab8cda2b0" translate="yes" xml:space="preserve">
          <source>You should be aware that the code being profiled is running in an anonymous function which is invoked by &lt;a href=&quot;http://wwww.erlang.org/doc/man/fprof.html&quot;&gt;&lt;code&gt;:fprof&lt;/code&gt; module&lt;/a&gt;. Thus, you'll see some additional entries in your profile output, such as &lt;code&gt;:fprof&lt;/code&gt; calls, an anonymous function with high ACC time, or an &lt;code&gt;:undefined&lt;/code&gt; function which represents the outer caller (non-profiled code which started the profiler).</source>
          <target state="translated">Вы должны знать, что профилируемый код выполняется в анонимной функции, которая вызывается &lt;a href=&quot;http://wwww.erlang.org/doc/man/fprof.html&quot;&gt;модулем &lt;/a&gt; &lt;code&gt;:fprof&lt;/code&gt; . Таким образом, вы увидите некоторые дополнительные записи в выводе вашего профиля, такие как &lt;code&gt;:fprof&lt;/code&gt; вызовы fprof , анонимная функция с высоким временем ACC или функция &lt;code&gt;:undefined&lt;/code&gt; , которая представляет внешнего вызывающего (непрофилированный код, запустивший профилировщик).</target>
        </trans-unit>
        <trans-unit id="ad57c7d6217a5b8532de6553070103bc648ebde2" translate="yes" xml:space="preserve">
          <source>You should be aware the profiler is stopped as soon as the code has finished running. This may need special attention, when: running asynchronous code as function calls which were called before the profiler stopped will not be counted; running synchronous code as long running computations and a profiler without a proper MFA trace pattern or filter may lead to a result set which is difficult to comprehend.</source>
          <target state="translated">Вы должны знать,что профилировщик будет остановлен,как только код завершит работу.Это может потребовать особого внимания,когда:запуск асинхронного кода в виде вызовов функций,которые были вызваны до остановки профайлера,не будет засчитан;запуск синхронного кода в виде длинных вычислений и профайлер без соответствующего шаблона трассировки или фильтра MFA может привести к набору результатов,который трудно понять.</target>
        </trans-unit>
        <trans-unit id="6dbe23be2c1cb07fabe1eb83cdfedae61b83d65b" translate="yes" xml:space="preserve">
          <source>You should expect a slowdown in your code execution using this tool since &lt;code&gt;:eprof&lt;/code&gt; has some performance impact on the execution, but the impact is considerably lower than &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Profile.Fprof.html&quot;&gt;&lt;code&gt;Mix.Tasks.Profile.Fprof&lt;/code&gt;&lt;/a&gt;. If you have a large system try to profile a limited scenario or focus on the main modules or processes. Another alternative is to use &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Profile.Cprof.html&quot;&gt;&lt;code&gt;Mix.Tasks.Profile.Cprof&lt;/code&gt;&lt;/a&gt; that uses &lt;code&gt;:cprof&lt;/code&gt; and has a low performance degradation effect.</source>
          <target state="translated">При использовании этого инструмента следует ожидать замедления выполнения кода, поскольку &lt;code&gt;:eprof&lt;/code&gt; оказывает некоторое влияние на производительность при выполнении, но это влияние значительно ниже, чем у &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Profile.Fprof.html&quot;&gt; &lt;code&gt;Mix.Tasks.Profile.Fprof&lt;/code&gt; &lt;/a&gt; . Если у вас большая система, попробуйте профилировать ограниченный сценарий или сосредоточиться на основных модулях или процессах. Другой альтернативой является использование &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Profile.Cprof.html&quot;&gt; &lt;code&gt;Mix.Tasks.Profile.Cprof&lt;/code&gt; ,&lt;/a&gt; который использует &lt;code&gt;:cprof&lt;/code&gt; и имеет небольшой эффект снижения производительности.</target>
        </trans-unit>
        <trans-unit id="5a84f5d4c0ef0af3172b0ed86583719c4894487a" translate="yes" xml:space="preserve">
          <source>You should expect a slowdown in your code execution using this tool since &lt;code&gt;:eprof&lt;/code&gt; has some performance impact on the execution, but the impact is considerably lower than &lt;a href=&quot;mix.tasks.profile.fprof&quot;&gt;&lt;code&gt;Mix.Tasks.Profile.Fprof&lt;/code&gt;&lt;/a&gt;. If you have a large system try to profile a limited scenario or focus on the main modules or processes. Another alternative is to use &lt;a href=&quot;mix.tasks.profile.cprof&quot;&gt;&lt;code&gt;Mix.Tasks.Profile.Cprof&lt;/code&gt;&lt;/a&gt; that uses &lt;code&gt;:cprof&lt;/code&gt; and has a low performance degradation effect.</source>
          <target state="translated">При использовании этого инструмента следует ожидать замедления выполнения кода, поскольку &lt;code&gt;:eprof&lt;/code&gt; оказывает некоторое влияние на производительность, но это влияние значительно ниже, чем у &lt;a href=&quot;mix.tasks.profile.fprof&quot;&gt; &lt;code&gt;Mix.Tasks.Profile.Fprof&lt;/code&gt; &lt;/a&gt; . Если у вас большая система, попробуйте профилировать ограниченный сценарий или сосредоточиться на основных модулях или процессах. Другой альтернативой является использование &lt;a href=&quot;mix.tasks.profile.cprof&quot;&gt; &lt;code&gt;Mix.Tasks.Profile.Cprof&lt;/code&gt; ,&lt;/a&gt; который использует &lt;code&gt;:cprof&lt;/code&gt; и имеет небольшой эффект снижения производительности.</target>
        </trans-unit>
        <trans-unit id="34f48ddf9f458a8c4cff93dc3dbe5cb1b93bf9ff" translate="yes" xml:space="preserve">
          <source>You will also notice that functions in the &lt;code&gt;File&lt;/code&gt; module have two variants: one &amp;ldquo;regular&amp;rdquo; variant and another variant with a trailing bang (&lt;code&gt;!&lt;/code&gt;). For example, when we read the &lt;code&gt;&quot;hello&quot;&lt;/code&gt; file in the example above, we use &lt;code&gt;File.read/1&lt;/code&gt;. Alternatively, we can use &lt;code&gt;File.read!/1&lt;/code&gt;:</source>
          <target state="translated">Вы также заметите, что функции в модуле &lt;code&gt;File&lt;/code&gt; имеют два варианта: один &amp;laquo;обычный&amp;raquo; вариант и другой вариант с завершающим взрывом ( &lt;code&gt;!&lt;/code&gt; ). Например, когда мы читаем файл &lt;code&gt;&quot;hello&quot;&lt;/code&gt; в приведенном выше примере, мы используем &lt;code&gt;File.read/1&lt;/code&gt; . В качестве альтернативы мы можем использовать &lt;code&gt;File.read!/1&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="7edda58a5288041fd2626f2fde4de673f8651019" translate="yes" xml:space="preserve">
          <source>You will notice that when you add a dependency to your project, Mix generates a &lt;code&gt;mix.lock&lt;/code&gt; file that guarantees &lt;em&gt;repeatable builds&lt;/em&gt;. The lock file must be checked in to your version control system, to guarantee that everyone who uses the project will use the same dependency versions as you.</source>
          <target state="translated">Вы заметите, что когда вы добавляете зависимость в свой проект, Mix генерирует файл &lt;code&gt;mix.lock&lt;/code&gt; , который гарантирует &lt;em&gt;повторяемые сборки&lt;/em&gt; . Файл блокировки должен быть зарегистрирован в вашей системе контроля версий, чтобы гарантировать, что каждый, кто использует проект, будет использовать те же версии зависимостей, что и вы.</target>
        </trans-unit>
        <trans-unit id="b214ce47f7eaecf345ea9e4479eb2daf88835923" translate="yes" xml:space="preserve">
          <source>You will see that Elixir has excellent support for working with strings. It also supports many of the Unicode operations. In fact, Elixir passes all the tests showcased in the article &lt;a href=&quot;http://mortoray.com/2013/11/27/the-string-type-is-broken/&quot;&gt;&amp;ldquo;The string type is broken&amp;rdquo;&lt;/a&gt;.</source>
          <target state="translated">Вы увидите, что Elixir отлично поддерживает работу со строками. Он также поддерживает многие операции Unicode. Фактически, Elixir проходит все тесты, описанные в статье &lt;a href=&quot;http://mortoray.com/2013/11/27/the-string-type-is-broken/&quot;&gt;&amp;laquo;Тип строки нарушен&amp;raquo;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c4525454674902061c1b514520438225ac3d52ac" translate="yes" xml:space="preserve">
          <source>You'll find the resource file of an application in its &lt;code&gt;ebin&lt;/code&gt; directory, it is generated automatically by Mix. Some of its keys are taken from the keyword lists returned by the &lt;code&gt;project/0&lt;/code&gt; and &lt;code&gt;application/0&lt;/code&gt; functions defined in &lt;code&gt;mix.exs&lt;/code&gt;, and others are generated by Mix itself.</source>
          <target state="translated">Вы найдете файл ресурсов приложения в его &lt;code&gt;ebin&lt;/code&gt; , он автоматически создается Mix. Некоторые из его ключей берутся из списков ключевых слов, возвращаемых функциями &lt;code&gt;project/0&lt;/code&gt; и &lt;code&gt;application/0&lt;/code&gt; , определенными в &lt;code&gt;mix.exs&lt;/code&gt; , а другие генерируются самим Mix.</target>
        </trans-unit>
        <trans-unit id="28845a5079a92d4070a3a95ead1696cd57e1ead9" translate="yes" xml:space="preserve">
          <source>Your &lt;code&gt;config/runtime.exs&lt;/code&gt; file needs to follow three important rules:</source>
          <target state="translated">Ваш файл &lt;code&gt;config/runtime.exs&lt;/code&gt; должен соответствовать трем важным правилам:</target>
        </trans-unit>
        <trans-unit id="31e77ee8f5b79e15eebf652ab6a7f99a0915241f" translate="yes" xml:space="preserve">
          <source>Your logs might then receive lines like this:</source>
          <target state="translated">Тогда в твоих журналах могут появиться такие строки:</target>
        </trans-unit>
        <trans-unit id="909f99a779adb66a76fc53ab56c7dd1caf35d0fd" translate="yes" xml:space="preserve">
          <source>Z</source>
          <target state="translated">Z</target>
        </trans-unit>
        <trans-unit id="559feb6095bf182138a3b4c5b0a6869996e9a835" translate="yes" xml:space="preserve">
          <source>Zero will be returned if there is no match.</source>
          <target state="translated">Ноль будет возвращен,если нет совпадений.</target>
        </trans-unit>
        <trans-unit id="c360b69284a084ed6128fa35ae5d3cddcf4691ea" translate="yes" xml:space="preserve">
          <source>Zero-based index.</source>
          <target state="translated">Нулевой индекс.</target>
        </trans-unit>
        <trans-unit id="6d19682a026c8ec1f09fb5b205c665ace8d5d0c7" translate="yes" xml:space="preserve">
          <source>Zero-based index. It can also be a negative integer.</source>
          <target state="translated">Нулевой индекс.Он также может быть отрицательным целым числом.</target>
        </trans-unit>
        <trans-unit id="df158a1ec3201042f65f02afbe3a3b4bd006197a" translate="yes" xml:space="preserve">
          <source>Zips corresponding elements from a finite collection of enumerables into one list of tuples.</source>
          <target state="translated">Замкнуть соответствующие элементы из конечной коллекции перечислений в один список кортежей.</target>
        </trans-unit>
        <trans-unit id="203223b26b6c7accee671d6510311309ff17979c" translate="yes" xml:space="preserve">
          <source>Zips corresponding elements from a finite collection of enumerables into one stream of tuples.</source>
          <target state="translated">Замолчите соответствующие элементы из конечной коллекции бесчисленных в один поток кортежей.</target>
        </trans-unit>
        <trans-unit id="1bfed92a39ee32d59521a708ff76ea497610a38e" translate="yes" xml:space="preserve">
          <source>Zips corresponding elements from each list in &lt;code&gt;list_of_lists&lt;/code&gt;.</source>
          <target state="translated">Зажимает соответствующие элементы из каждого списка в &lt;code&gt;list_of_lists&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="58c3b6f7176ddf31ce9148ac85055319257ca058" translate="yes" xml:space="preserve">
          <source>Zips corresponding elements from two enumerables into one list of tuples.</source>
          <target state="translated">Замкнуть соответствующие элементы из двух перечислений в один список кортежей.</target>
        </trans-unit>
        <trans-unit id="00cfd06487588a4d7f31aa3a150980d65bfaf2a5" translate="yes" xml:space="preserve">
          <source>Zips two collections together, lazily.</source>
          <target state="translated">Застёгивает две коллекции вместе,лениво.</target>
        </trans-unit>
        <trans-unit id="cafe76887cacaaf65275657b20e4009913b348cf" translate="yes" xml:space="preserve">
          <source>Zombie operating system processes</source>
          <target state="translated">Процессы операционной системы зомби</target>
        </trans-unit>
        <trans-unit id="08d3a96fcb659e45499ff8800c5d9b02c9f5d5e7" translate="yes" xml:space="preserve">
          <source>^var</source>
          <target state="translated">^var</target>
        </trans-unit>
        <trans-unit id="bc01569116f2ab15fb902409110b8bc5b1e1e9a2" translate="yes" xml:space="preserve">
          <source>^var (1)</source>
          <target state="translated">^ var (1)</target>
        </trans-unit>
        <trans-unit id="2b0e4da7ba7de811226d1e589a3dafed1082da59" translate="yes" xml:space="preserve">
          <source>__CALLER__</source>
          <target state="translated">__CALLER__</target>
        </trans-unit>
        <trans-unit id="116009782b4ac4aee2d8dab11c4809c0d1ebc198" translate="yes" xml:space="preserve">
          <source>__CALLER__ (0)</source>
          <target state="translated">__CALLER__ (0)</target>
        </trans-unit>
        <trans-unit id="afab0a49c7ceabfb338074dd17afd32d320d2e0d" translate="yes" xml:space="preserve">
          <source>__DIR__</source>
          <target state="translated">__DIR__</target>
        </trans-unit>
        <trans-unit id="36bb03bc0427bf8b9a1d4912ffe0e708394c8a39" translate="yes" xml:space="preserve">
          <source>__DIR__ (0)</source>
          <target state="translated">__DIR__ (0)</target>
        </trans-unit>
        <trans-unit id="601f6fc23ca3b0743af374a4f01070f856dd4d9a" translate="yes" xml:space="preserve">
          <source>__ENV__</source>
          <target state="translated">__ENV__</target>
        </trans-unit>
        <trans-unit id="274ff6b31ca455977fc2c254e3c7d72a43d77f11" translate="yes" xml:space="preserve">
          <source>__ENV__ (0)</source>
          <target state="translated">__ENV__ (0)</target>
        </trans-unit>
        <trans-unit id="44ad279c068c2aa891024b5e4789d6fce3bd4e30" translate="yes" xml:space="preserve">
          <source>__MODULE__</source>
          <target state="translated">__MODULE__</target>
        </trans-unit>
        <trans-unit id="45b51d1650bc2981392ec672584bee3b0eef19e7" translate="yes" xml:space="preserve">
          <source>__MODULE__ (0)</source>
          <target state="translated">__MODULE__ (0)</target>
        </trans-unit>
        <trans-unit id="383f765afc4b9be6d9d65d8985319fbba95d2941" translate="yes" xml:space="preserve">
          <source>__STACKTRACE__</source>
          <target state="translated">__STACKTRACE__</target>
        </trans-unit>
        <trans-unit id="40c4d357e42e18738498abc91cfbbec623bc3eac" translate="yes" xml:space="preserve">
          <source>__STACKTRACE__ (0)</source>
          <target state="translated">__STACKTRACE__ (0)</target>
        </trans-unit>
        <trans-unit id="95e7ff9d820f043fac6714bf8356efca3f731112" translate="yes" xml:space="preserve">
          <source>__aliases__ (1)</source>
          <target state="translated">__aliases__ (1)</target>
        </trans-unit>
        <trans-unit id="5e428e427d7dec6ffb090cc57d4f99596428bae0" translate="yes" xml:space="preserve">
          <source>__aliases__(args)</source>
          <target state="translated">__aliases__(args)</target>
        </trans-unit>
        <trans-unit id="76c3fbd0730868e8619f79de60aaa56c4fbca3d2" translate="yes" xml:space="preserve">
          <source>__block__ (1)</source>
          <target state="translated">__block__ (1)</target>
        </trans-unit>
        <trans-unit id="4ffd2236068356332d96bfb12ed86d69f24f74bb" translate="yes" xml:space="preserve">
          <source>__block__(args)</source>
          <target state="translated">__block__(args)</target>
        </trans-unit>
        <trans-unit id="9f16c3bbe5a985017500773431cb279065841a3d" translate="yes" xml:space="preserve">
          <source>__info__(atom)</source>
          <target state="translated">__info__(atom)</target>
        </trans-unit>
        <trans-unit id="86f7e437faa5a7fce15d1ddcb9eaeaea377667b8" translate="yes" xml:space="preserve">
          <source>a</source>
          <target state="translated">a</target>
        </trans-unit>
        <trans-unit id="f543ed2733380bf930fee7f07761a7a0df5ce3cb" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;{:system, system_var, path}&lt;/code&gt; tuple where the config is the concatenation of the environment variable &lt;code&gt;system_var&lt;/code&gt; with the given &lt;code&gt;path&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;{:system, system_var, path}&lt;/code&gt; кортеж , где конфигурация является конкатенацией переменной окружении &lt;code&gt;system_var&lt;/code&gt; с заданной &lt;code&gt;path&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cb133a7b058382216c0e2f8756ec4a8097f54303" translate="yes" xml:space="preserve">
          <source>a PID</source>
          <target state="translated">PID</target>
        </trans-unit>
        <trans-unit id="ec7d2b2573d9de6e326c02b1e8c59634c9a23261" translate="yes" xml:space="preserve">
          <source>a binary representing an absolute path</source>
          <target state="translated">двоичная система,представляющая собой абсолютный путь</target>
        </trans-unit>
        <trans-unit id="734fb2da92d407682a9cc47d5b108d6cbe1433cf" translate="yes" xml:space="preserve">
          <source>a function to be invoked next</source>
          <target state="translated">функция,которая будет вызвана следующей</target>
        </trans-unit>
        <trans-unit id="502fbd56e3b0c3cf11d02b7416e5d6f9c2626390" translate="yes" xml:space="preserve">
          <source>a list containing one of these three elements</source>
          <target state="translated">список,содержащий один из этих трех элементов</target>
        </trans-unit>
        <trans-unit id="a64ce55469e56477808a6b690f545aaa12838299" translate="yes" xml:space="preserve">
          <source>a map representing the child specification itself - as outlined in the &quot;Child specification&quot; section</source>
          <target state="translated">карта,представляющая саму спецификацию ребенка-как указано в разделе &quot;Спецификация ребенка&quot;.</target>
        </trans-unit>
        <trans-unit id="c80d6f05f1a8caa07ef67ce20b0b0ca7b91eed6f" translate="yes" xml:space="preserve">
          <source>a module - such as &lt;code&gt;Stack&lt;/code&gt;. In this case, &lt;code&gt;Stack.child_spec([])&lt;/code&gt; is called to retrieve the child specification</source>
          <target state="translated">модуль - например, &lt;code&gt;Stack&lt;/code&gt; . В этом случае &lt;code&gt;Stack.child_spec([])&lt;/code&gt; для получения дочерней спецификации.</target>
        </trans-unit>
        <trans-unit id="134dad47c3dd67035406cb3ed8da25b57e066edc" translate="yes" xml:space="preserve">
          <source>a non-negative integer - the amount of time in milliseconds that the supervisor tells the child process to terminate by calling &lt;code&gt;Process.exit(child, :shutdown)&lt;/code&gt; and then waits for an exit signal back. If no exit signal is received within the specified time, the child process is unconditionally terminated using &lt;code&gt;Process.exit(child, :kill)&lt;/code&gt;</source>
          <target state="translated">неотрицательное целое число - количество времени в миллисекундах, в течение которого супервизор сообщает дочернему процессу о завершении, вызывая &lt;code&gt;Process.exit(child, :shutdown)&lt;/code&gt; а затем ожидает сигнала выхода обратно. Если в течение указанного времени не поступает сигнал выхода, дочерний процесс безоговорочно завершается с использованием &lt;code&gt;Process.exit(child, :kill)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9b8d6899963c6b1849b03232cb4f4e71a7207c1f" translate="yes" xml:space="preserve">
          <source>a timeout value, where the supervisor will send the exit signal &lt;code&gt;:shutdown&lt;/code&gt; and the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; will have the duration of the timeout to terminate. If after duration of this timeout the process is still alive, it will be killed immediately.</source>
          <target state="translated">значение тайм-аута, при котором супервизор отправит сигнал выхода &lt;code&gt;:shutdown&lt;/code&gt; а у &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt; будет время ожидания для завершения. Если по истечении этого тайм-аута процесс все еще жив, он будет немедленно остановлен.</target>
        </trans-unit>
        <trans-unit id="a0ea0ba4868724242e4956219cba8cb1ef8b4172" translate="yes" xml:space="preserve">
          <source>a tuple with a module as first element and the start argument as second - such as &lt;code&gt;{Stack, [:hello]}&lt;/code&gt;. In this case, &lt;code&gt;Stack.child_spec([:hello])&lt;/code&gt; is called to retrieve the child specification</source>
          <target state="translated">кортеж с модулем в качестве первого элемента и начальным аргументом в качестве второго, например &lt;code&gt;{Stack, [:hello]}&lt;/code&gt; . В этом случае &lt;code&gt;Stack.child_spec([:hello])&lt;/code&gt; для получения дочерней спецификации</target>
        </trans-unit>
        <trans-unit id="362f1ac8a4ed3101c7e767a7343bf779218f1d02" translate="yes" xml:space="preserve">
          <source>a tuple {:system, system_var, path} where the config is the concatenation of the &lt;code&gt;system_var&lt;/code&gt; with the given &lt;code&gt;path&lt;/code&gt;</source>
          <target state="translated">кортеж {: system, system_var, path}, где config - это конкатенация &lt;code&gt;system_var&lt;/code&gt; с заданным &lt;code&gt;path&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cab7deed2a3742f86c582b0dc8a38ef1106ff9b9" translate="yes" xml:space="preserve">
          <source>a two-element tuple &lt;code&gt;{get_value, new_value}&lt;/code&gt;. In this case, &lt;code&gt;get_value&lt;/code&gt; is the retrieved value which can possibly be operated on before being returned. &lt;code&gt;new_value&lt;/code&gt; is the new value to be stored under &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">двухэлементный кортеж &lt;code&gt;{get_value, new_value}&lt;/code&gt; . В этом случае &lt;code&gt;get_value&lt;/code&gt; - это полученное значение, с которым, возможно, можно будет работать перед возвратом . &lt;code&gt;new_value&lt;/code&gt; - это новое значение, которое будет сохранено под &lt;code&gt;key&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="58540f6d62cd4713c9c1081d83394b907bf916df" translate="yes" xml:space="preserve">
          <source>a value is falsy when it is either &lt;code&gt;false&lt;/code&gt; or &lt;code&gt;nil&lt;/code&gt;</source>
          <target state="translated">значение является ложным, когда оно либо &lt;code&gt;false&lt;/code&gt; либо &lt;code&gt;nil&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9cd309a5b122a644c7bfb6656f3eb61d1daa78c0" translate="yes" xml:space="preserve">
          <source>a value is truthy when it is neither &lt;code&gt;false&lt;/code&gt; nor &lt;code&gt;nil&lt;/code&gt;</source>
          <target state="translated">значение истинно, когда оно не является ни &lt;code&gt;false&lt;/code&gt; ни &lt;code&gt;nil&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="03132489ebc918b7753fd8abac08ea39dc94a398" translate="yes" xml:space="preserve">
          <source>abcast(nodes \\ [node() | Node.list()], name, request)</source>
          <target state="translated">abcast(nodes \\ [node()| Node.list()],имя,запрос)</target>
        </trans-unit>
        <trans-unit id="63de8499bacfd70eba507c04a94405770d9c8712" translate="yes" xml:space="preserve">
          <source>abs (1)</source>
          <target state="translated">брюшные мышцы (1)</target>
        </trans-unit>
        <trans-unit id="b4bb0fca1626c2cba561f5b8c066cfc4958f2109" translate="yes" xml:space="preserve">
          <source>abs(number)</source>
          <target state="translated">abs(number)</target>
        </trans-unit>
        <trans-unit id="275fce92cc74afd24db101d22aaf3bebb46dff2c" translate="yes" xml:space="preserve">
          <source>absname(path)</source>
          <target state="translated">absname(path)</target>
        </trans-unit>
        <trans-unit id="1158fd681568fcd2eb9afc7aacf1c8457c01fe01" translate="yes" xml:space="preserve">
          <source>absname(path, relative_to)</source>
          <target state="translated">absname(path,relative_to)</target>
        </trans-unit>
        <trans-unit id="a9834cc26df9e591aaf3b9059861c87920267760" translate="yes" xml:space="preserve">
          <source>acc()</source>
          <target state="translated">acc()</target>
        </trans-unit>
        <trans-unit id="b59f5c588aba8cc0d53adab4fa31305b2650e0a8" translate="yes" xml:space="preserve">
          <source>accepts_options(app, opts)</source>
          <target state="translated">accept_options(app,opts)</target>
        </trans-unit>
        <trans-unit id="5cd4dffbe947a0a27ee38504e04afa01f57c5840" translate="yes" xml:space="preserve">
          <source>access_fun(data, get_value)</source>
          <target state="translated">access_fun(data,get_value)</target>
        </trans-unit>
        <trans-unit id="37e4298f00e4b04a039f9767597f041ed4bb77b9" translate="yes" xml:space="preserve">
          <source>add(date, days)</source>
          <target state="translated">добавить (дата,дни)</target>
        </trans-unit>
        <trans-unit id="cad1078dcdee7f8d74060d5de76a291438a58175" translate="yes" xml:space="preserve">
          <source>add(datetime, amount_to_add, unit \\ :second, time_zone_database \\ Calendar.get_time_zone_database())</source>
          <target state="translated">add(datetime,amount_to_add,unit \\ :second,time_zone_database \\ Calendar.get_time_zone_database())</target>
        </trans-unit>
        <trans-unit id="f8ecfb9e15c4c321a10bcf89505371175f5cbc61" translate="yes" xml:space="preserve">
          <source>add(naive_datetime, amount_to_add, unit \\ :second)</source>
          <target state="translated">add(naive_datetime,amount_to_add,unit \\ :second)</target>
        </trans-unit>
        <trans-unit id="ddd8b500ea07a334e0aedae3451af17825441423" translate="yes" xml:space="preserve">
          <source>add(time, number, unit \\ :second)</source>
          <target state="translated">add(time,number,unit \\ :second)</target>
        </trans-unit>
        <trans-unit id="8fbfd79ef8a165fdca563144367a381ee91b3ed9" translate="yes" xml:space="preserve">
          <source>add_backend(backend, opts \\ [])</source>
          <target state="translated">add_backend(backend,opts \\ []))</target>
        </trans-unit>
        <trans-unit id="3241fd5e2fc24f5764a7e7f80ccd3b03b9017f7d" translate="yes" xml:space="preserve">
          <source>add_translator(translator)</source>
          <target state="translated">add_translator(translator)</target>
        </trans-unit>
        <trans-unit id="122273d13da637fced52d2bd5eccddbb5a6a02b4" translate="yes" xml:space="preserve">
          <source>after_compiler(name, fun)</source>
          <target state="translated">after_compiler(name,fun)</target>
        </trans-unit>
        <trans-unit id="ebbe7ff0122ba78922baf34fee6cd329ce239feb" translate="yes" xml:space="preserve">
          <source>after_spawn()</source>
          <target state="translated">after_spawn()</target>
        </trans-unit>
        <trans-unit id="37aa41bf7a8f9c353386d2e070f77fe39891ca05" translate="yes" xml:space="preserve">
          <source>after_spawn(fun)</source>
          <target state="translated">after_spawn(fun)</target>
        </trans-unit>
        <trans-unit id="fc71d9fb4fd6ade47fc3030c4b6c3bcf588c5c94" translate="yes" xml:space="preserve">
          <source>after_suite(function)</source>
          <target state="translated">after_suite(function)</target>
        </trans-unit>
        <trans-unit id="ff38ff39073554eaf31d825e65d45b40089354f7" translate="yes" xml:space="preserve">
          <source>agent()</source>
          <target state="translated">agent()</target>
        </trans-unit>
        <trans-unit id="378080ab2e3d3ae0baa42c76462d6c1b34266db0" translate="yes" xml:space="preserve">
          <source>alert(message_or_fun, metadata \\ [])</source>
          <target state="translated">alert(message_or_fun,метаданные \\ []).</target>
        </trans-unit>
        <trans-unit id="cdb6fdbe91faa53a7c573c80b7c18108c73c0480" translate="yes" xml:space="preserve">
          <source>alias</source>
          <target state="translated">alias</target>
        </trans-unit>
        <trans-unit id="5cc4610153b63e761e50055d6f3406a292d36d24" translate="yes" xml:space="preserve">
          <source>alias (2)</source>
          <target state="translated">псевдоним (2)</target>
        </trans-unit>
        <trans-unit id="6c0f0e22f862a3f8150ad4251e1111003f9e0e0c" translate="yes" xml:space="preserve">
          <source>alias! (1)</source>
          <target state="translated">псевдоним! (1)</target>
        </trans-unit>
        <trans-unit id="eb8fae47b62a763edb0b639bc40712c6a38f111f" translate="yes" xml:space="preserve">
          <source>alias!(alias)</source>
          <target state="translated">alias!(alias)</target>
        </trans-unit>
        <trans-unit id="a8b5798a733a4fa8b3ccbccbcfcd78d9a10d36f6" translate="yes" xml:space="preserve">
          <source>alias(module, opts)</source>
          <target state="translated">псевдоним (модуль,опция)</target>
        </trans-unit>
        <trans-unit id="0faa5faaa456de937e347a6133ce03ef41eae84c" translate="yes" xml:space="preserve">
          <source>alias, require, and import</source>
          <target state="translated">псевдоним,требование и импорт</target>
        </trans-unit>
        <trans-unit id="1f945f3e60b949b53afbdc3b404472e659917a92" translate="yes" xml:space="preserve">
          <source>alias?(task)</source>
          <target state="translated">alias?(task)</target>
        </trans-unit>
        <trans-unit id="fab9d011a9c66d8d4da688adc4b2c7d7ec3885b4" translate="yes" xml:space="preserve">
          <source>aliases()</source>
          <target state="translated">aliases()</target>
        </trans-unit>
        <trans-unit id="dbbf7995a790b99eae045a30b54348abfd4809e9" translate="yes" xml:space="preserve">
          <source>alive?()</source>
          <target state="translated">alive?()</target>
        </trans-unit>
        <trans-unit id="b5ff5e5840a9cf81b029ed8d3e96cc03abc9f13e" translate="yes" xml:space="preserve">
          <source>alive?(pid)</source>
          <target state="translated">alive?(pid)</target>
        </trans-unit>
        <trans-unit id="37a2eb0945387d30fb64cb5fe24823e361f0921b" translate="yes" xml:space="preserve">
          <source>all()</source>
          <target state="translated">all()</target>
        </trans-unit>
        <trans-unit id="39179de0b113f2ca95b427e4a53ccb0b209a7ff3" translate="yes" xml:space="preserve">
          <source>all?(enumerable, fun \\ fn x -&amp;gt; x end)</source>
          <target state="translated">все? (перечислимое, забавное \\ fn x -&amp;gt; x end)</target>
        </trans-unit>
        <trans-unit id="93a055419ae32c75e105336b93742551d4fda292" translate="yes" xml:space="preserve">
          <source>all_modules()</source>
          <target state="translated">all_modules()</target>
        </trans-unit>
        <trans-unit id="ac77d52be4d42a98c15771a338e4226ec89f6e05" translate="yes" xml:space="preserve">
          <source>allows I/O messages to be routed between different nodes running Distributed Erlang or even exchange files to perform read/write operations across nodes.</source>
          <target state="translated">позволяет маршрутизировать сообщения ввода/вывода между различными узлами,на которых работает Distributed Erlang,или даже обмениваться файлами для выполнения операций чтения/записи между узлами.</target>
        </trans-unit>
        <trans-unit id="9af63204b35727b98209702287f461a07397dfd9" translate="yes" xml:space="preserve">
          <source>alnum - Letters and digits</source>
          <target state="translated">выпускник-Буквы и цифры</target>
        </trans-unit>
        <trans-unit id="7e5694e774d6739e2b00961f10b8ece1cca403e5" translate="yes" xml:space="preserve">
          <source>alpha - Letters</source>
          <target state="translated">альфа-буквы</target>
        </trans-unit>
        <trans-unit id="b3be9421ef0b80986643706647b1ee7d54a08281" translate="yes" xml:space="preserve">
          <source>am, pm</source>
          <target state="translated">вечером</target>
        </trans-unit>
        <trans-unit id="cc1bfe3539b2e308b57302928d7fee5d8c55aa3d" translate="yes" xml:space="preserve">
          <source>an atom - the GenServer is registered locally with the given name using &lt;a href=&quot;https://hexdocs.pm/elixir/Process.html#register/2&quot;&gt;&lt;code&gt;Process.register/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">атом - GenServer зарегистрирован локально с заданным именем с помощью &lt;a href=&quot;https://hexdocs.pm/elixir/Process.html#register/2&quot;&gt; &lt;code&gt;Process.register/2&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0946daf5267d99207384f84b7d292e1e9e17cad0" translate="yes" xml:space="preserve">
          <source>an atom - the GenServer is registered locally with the given name using &lt;a href=&quot;process#register/2&quot;&gt;&lt;code&gt;Process.register/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">атом - GenServer зарегистрирован локально с заданным именем с помощью &lt;a href=&quot;process#register/2&quot;&gt; &lt;code&gt;Process.register/2&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="496287211e92533c4e83f2030cb5ab193e3c0cfc" translate="yes" xml:space="preserve">
          <source>an atom if the server is locally registered</source>
          <target state="translated">атом,если сервер зарегистрирован локально</target>
        </trans-unit>
        <trans-unit id="131777738477ba63d177d41cf489fc34bb166d23" translate="yes" xml:space="preserve">
          <source>and (2)</source>
          <target state="translated">и (2)</target>
        </trans-unit>
        <trans-unit id="1d0661ad9f7cc4fe3c1410d2fbf9527ce0a6d2c3" translate="yes" xml:space="preserve">
          <source>and &lt;code&gt;&amp;lt;Continue&amp;gt;&lt;/code&gt; uses the same categories as the spec but restricts them to the NFC form (see R6):</source>
          <target state="translated">и &lt;code&gt;&amp;lt;Continue&amp;gt;&lt;/code&gt; использует те же категории, что и спецификация, но ограничивает их формой NFC (см. R6):</target>
        </trans-unit>
        <trans-unit id="5ebbc3bb0112607475023e59440002eed1b931b0" translate="yes" xml:space="preserve">
          <source>and Elixir will properly interpolate values.</source>
          <target state="translated">и Эликсир правильно интерполирует значения.</target>
        </trans-unit>
        <trans-unit id="adf717a037ab7af9bc9bacbd3b34170933270e02" translate="yes" xml:space="preserve">
          <source>and be out of the range &lt;code&gt;0xD800..0xDFFF&lt;/code&gt; (&lt;code&gt;55_296..57_343&lt;/code&gt;), which is reserved in Unicode for UTF-16 surrogate pairs.</source>
          <target state="translated">и быть вне диапазона &lt;code&gt;0xD800..0xDFFF&lt;/code&gt; ( &lt;code&gt;55_296..57_343&lt;/code&gt; ), который зарезервирован в Unicode для суррогатных пар UTF-16.</target>
        </trans-unit>
        <trans-unit id="416ef67e71d26bc8e2cc631b1ae5b57b302d0d56" translate="yes" xml:space="preserve">
          <source>and in this one</source>
          <target state="translated">и в этом</target>
        </trans-unit>
        <trans-unit id="71b18172343bdb8b2660d75e53835253043852f1" translate="yes" xml:space="preserve">
          <source>and it depends on previous chapters in this guide. For more information, &lt;a href=&quot;introduction-to-mix&quot;&gt;read the introduction guide&lt;/a&gt; or check out the chapter index in the sidebar.</source>
          <target state="translated">и это зависит от предыдущих глав этого руководства. Для получения дополнительной информации &lt;a href=&quot;introduction-to-mix&quot;&gt;прочтите вводное руководство&lt;/a&gt; или ознакомьтесь с указателем глав на боковой панели.</target>
        </trans-unit>
        <trans-unit id="7554dcd8106373b0fd9319e03515dd9d1ce9f49e" translate="yes" xml:space="preserve">
          <source>and only from Elixir v1.2 are they capable of holding millions of keys efficiently. Therefore, if you are working with previous Elixir versions (v1.0 or v1.1) and you need to support at least hundreds of keys, you may consider using &lt;a href=&quot;https://hexdocs.pm/elixir/HashDict.html&quot;&gt;the &lt;code&gt;HashDict&lt;/code&gt; module&lt;/a&gt;.</source>
          <target state="translated">и только с версии Elixir v1.2 они способны эффективно хранить миллионы ключей. Поэтому, если вы работаете с предыдущими версиями Elixir (V1.0 или v1.1) , и вы должны поддерживать по крайней мере сотни ключей, вы можете рассмотреть возможность использования &lt;a href=&quot;https://hexdocs.pm/elixir/HashDict.html&quot;&gt;в &lt;code&gt;HashDict&lt;/code&gt; модуля&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="23e76f170a2eec0baa07dd75bc86236006356315" translate="yes" xml:space="preserve">
          <source>and other curiosities.</source>
          <target state="translated">и другие курьезы.</target>
        </trans-unit>
        <trans-unit id="88d6b2f25f6107df46423a22c504ff1f6d070ffb" translate="yes" xml:space="preserve">
          <source>and the generated application resource file is going to have it included.</source>
          <target state="translated">и сгенерированный файл ресурса приложения будет включен в него.</target>
        </trans-unit>
        <trans-unit id="98f1d1d3c723d0bdc3fe73d908452997c2f3f2b2" translate="yes" xml:space="preserve">
          <source>and then defining a &lt;code&gt;my_app/application.ex&lt;/code&gt; file with the following template:</source>
          <target state="translated">а затем определение &lt;code&gt;my_app/application.ex&lt;/code&gt; с помощью следующего шаблона:</target>
        </trans-unit>
        <trans-unit id="142f05ea46227e8a90a3d5dca1f7a01d291d3eeb" translate="yes" xml:space="preserve">
          <source>and then you can use &lt;code&gt;Counter&lt;/code&gt;, &lt;code&gt;{Counter, name: :my_counter}&lt;/code&gt; or even &lt;code&gt;{Counter, initial_value: 0, name: :my_counter}&lt;/code&gt; as a child specification.</source>
          <target state="translated">а затем вы можете использовать &lt;code&gt;Counter&lt;/code&gt; , &lt;code&gt;{Counter, name: :my_counter}&lt;/code&gt; или даже &lt;code&gt;{Counter, initial_value: 0, name: :my_counter}&lt;/code&gt; в качестве дочерней спецификации.</target>
        </trans-unit>
        <trans-unit id="478c17c32f1bc3336788616eaad90d7da7f5fbd4" translate="yes" xml:space="preserve">
          <source>and then:</source>
          <target state="translated">а потом:</target>
        </trans-unit>
        <trans-unit id="e4dd2b34d903018abdb9e66f97f376877a9b3468" translate="yes" xml:space="preserve">
          <source>anonymous functions (&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#fn/1&quot;&gt;&lt;code&gt;fn/1&lt;/code&gt;&lt;/a&gt;):</source>
          <target state="translated">анонимные функции ( &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#fn/1&quot;&gt; &lt;code&gt;fn/1&lt;/code&gt; &lt;/a&gt; ):</target>
        </trans-unit>
        <trans-unit id="685629935c929e5f82705c8f9ff9de20984e688d" translate="yes" xml:space="preserve">
          <source>anonymous functions (&lt;a href=&quot;kernel.specialforms#fn/1&quot;&gt;&lt;code&gt;fn&lt;/code&gt;&lt;/a&gt;s):</source>
          <target state="translated">анонимные функции ( &lt;a href=&quot;kernel.specialforms#fn/1&quot;&gt; &lt;code&gt;fn&lt;/code&gt; &lt;/a&gt; s):</target>
        </trans-unit>
        <trans-unit id="70119b4f69236b27bdb7be512c74762ccd02429c" translate="yes" xml:space="preserve">
          <source>ansicode()</source>
          <target state="translated">ansicode()</target>
        </trans-unit>
        <trans-unit id="321063ba0f7d36a07cbde2dcfb75bcf14e7fdeee" translate="yes" xml:space="preserve">
          <source>ansidata()</source>
          <target state="translated">ansidata()</target>
        </trans-unit>
        <trans-unit id="20133b0aad87c7e344e5c1b69ed2d95aa539d46f" translate="yes" xml:space="preserve">
          <source>ansilist()</source>
          <target state="translated">ansilist()</target>
        </trans-unit>
        <trans-unit id="ffb7124e173aac9be0b5dc9e9143b3d7c16b5adb" translate="yes" xml:space="preserve">
          <source>any integer &amp;gt;= 0 - the amount of time in milliseconds that the supervisor will wait for its children to terminate after emitting a &lt;code&gt;Process.exit(child, :shutdown)&lt;/code&gt; signal. If the child process is not trapping exits, the initial &lt;code&gt;:shutdown&lt;/code&gt; signal will terminate the child process immediately. If the child process is trapping exits, it has the given amount of time to terminate. If it doesn't terminate within the specified time, the child process is unconditionally terminated by the supervisor via &lt;code&gt;Process.exit(child, :kill)&lt;/code&gt;.</source>
          <target state="translated">любое целое число&amp;gt; = 0 - время в миллисекундах, в течение которого супервизор будет ждать завершения своих дочерних &lt;code&gt;Process.exit(child, :shutdown)&lt;/code&gt; после выдачи сигнала Process.exit (child,: shutdown) . Если дочерний процесс не перехватывает &lt;code&gt;:shutdown&lt;/code&gt; сигнал initial : shutdown немедленно завершает дочерний процесс. Если дочерний процесс перехватывает выходы, у него есть заданное время для завершения. Если он не завершается в течение указанного времени, дочерний процесс безоговорочно завершается супервизором через &lt;code&gt;Process.exit(child, :kill)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d3add7802830a2ed653c15ee887ce11205bfaf20" translate="yes" xml:space="preserve">
          <source>any other term - in such cases, the exit will be logged, there are restarts in transient mode, and linked processes exit with the same reason unless they're trapping exits</source>
          <target state="translated">любой другой термин-в таких случаях выход записывается в журнал,происходят перезагрузки в переходном режиме,и связанные процессы выходят по той же причине,если только они не захватывают выходы.</target>
        </trans-unit>
        <trans-unit id="95de94b41d93e056d6d220532526c89ac6a67f71" translate="yes" xml:space="preserve">
          <source>any?(enumerable, fun \\ fn x -&amp;gt; x end)</source>
          <target state="translated">любой? (перечислимый, забавный \\ fn x -&amp;gt; x end)</target>
        </trans-unit>
        <trans-unit id="c8f9c188d78117e2a9e04c394de85091eb503226" translate="yes" xml:space="preserve">
          <source>any_container()</source>
          <target state="translated">any_container()</target>
        </trans-unit>
        <trans-unit id="eec1a38f7cc6cb9de70c40db411860fd9abae024" translate="yes" xml:space="preserve">
          <source>app is an atom</source>
          <target state="translated">приложение является атомом</target>
        </trans-unit>
        <trans-unit id="c83f1f5829ef91e20b92b78798a2c99b3393b74b" translate="yes" xml:space="preserve">
          <source>app()</source>
          <target state="translated">app()</target>
        </trans-unit>
        <trans-unit id="0172ce912b50113a477b0e455740f304b7eea4ee" translate="yes" xml:space="preserve">
          <source>app_dir(app)</source>
          <target state="translated">app_dir(app)</target>
        </trans-unit>
        <trans-unit id="19c796508dd45f1c1e4e466da19f5b77298e0763" translate="yes" xml:space="preserve">
          <source>app_dir(app, path)</source>
          <target state="translated">app_dir(app,path)</target>
        </trans-unit>
        <trans-unit id="9b2802cea7bd42f1fcb26ef84f823d14668e7861" translate="yes" xml:space="preserve">
          <source>app_path(config \\ config())</source>
          <target state="translated">app_path(config \\ config()))</target>
        </trans-unit>
        <trans-unit id="a3a949eda06d4f2e421c5f0364cbae11a5b93c3d" translate="yes" xml:space="preserve">
          <source>append(mod)</source>
          <target state="translated">append(mod)</target>
        </trans-unit>
        <trans-unit id="351ef5db651a2723ebf39a98522567b002c71d00" translate="yes" xml:space="preserve">
          <source>append(tuple, value)</source>
          <target state="translated">приложение (кортеж,стоимость)</target>
        </trans-unit>
        <trans-unit id="3b576e39d37e223620720715f18830f4bf25cfa7" translate="yes" xml:space="preserve">
          <source>append_path(path)</source>
          <target state="translated">append_path(path)</target>
        </trans-unit>
        <trans-unit id="9eb59a0166ed02f5217e2b3e883bfb8198d3aa40" translate="yes" xml:space="preserve">
          <source>application()</source>
          <target state="translated">application()</target>
        </trans-unit>
        <trans-unit id="de44800be3da4c5ae013680a4d6af1051f14b05d" translate="yes" xml:space="preserve">
          <source>application_key()</source>
          <target state="translated">application_key()</target>
        </trans-unit>
        <trans-unit id="2c4cc2df189b226e99afec198faaea9c8bacefdf" translate="yes" xml:space="preserve">
          <source>apply (2)</source>
          <target state="translated">применяться (2)</target>
        </trans-unit>
        <trans-unit id="5615a998e3b8b79aa485fda118694eade5689ca0" translate="yes" xml:space="preserve">
          <source>apply (3)</source>
          <target state="translated">применяться (3)</target>
        </trans-unit>
        <trans-unit id="1c292ff23209404c48e206dced70e337f9649050" translate="yes" xml:space="preserve">
          <source>apply(fun, args)</source>
          <target state="translated">применяться(весело,спорить)</target>
        </trans-unit>
        <trans-unit id="74580a850266eb2226c2e0b6d896e2f6d5f6826b" translate="yes" xml:space="preserve">
          <source>apply(module, function_name, args)</source>
          <target state="translated">apply(модуль,имя_функции,аргументы)</target>
        </trans-unit>
        <trans-unit id="5174ecf486063648d222f223b1195abf8c33a5b7" translate="yes" xml:space="preserve">
          <source>apps_paths(config \\ config())</source>
          <target state="translated">apps_paths(config \\ config())</target>
        </trans-unit>
        <trans-unit id="528238dd031e3950071d8f842568c18643095636" translate="yes" xml:space="preserve">
          <source>are considered equivalent (the nesting is discarded alongside most of user formatting). In such cases, the code formatter will always format to the latter.</source>
          <target state="translated">считаются эквивалентными (вложение отбрасывается вместе с большинством пользовательских форматов).В таких случаях форматировщик кода всегда будет форматировать под последний.</target>
        </trans-unit>
        <trans-unit id="986c3f6a6bea3f83bc4b2411f4940435940d3b52" translate="yes" xml:space="preserve">
          <source>arguments do not need to be escaped or quoted for shell safety</source>
          <target state="translated">аргументы не нужно избегать или приводить в качестве аргумента в пользу безопасности оболочки</target>
        </trans-unit>
        <trans-unit id="89e29e7cee01719de72906bdd3d4fbdb5be8b870" translate="yes" xml:space="preserve">
          <source>argv()</source>
          <target state="translated">argv()</target>
        </trans-unit>
        <trans-unit id="2a43e669413bad9c7a43cf276187f748ca58f246" translate="yes" xml:space="preserve">
          <source>argv(args)</source>
          <target state="translated">argv(args)</target>
        </trans-unit>
        <trans-unit id="3a9df410789f8c2ae879b3ae733e50a7fe43d216" translate="yes" xml:space="preserve">
          <source>arithmetic binary operators &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#+/2&quot;&gt;&lt;code&gt;+&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#-/2&quot;&gt;&lt;code&gt;-&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#*/2&quot;&gt;&lt;code&gt;*&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#//2&quot;&gt;&lt;code&gt;/&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="translated">арифметические бинарные операторы &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#+/2&quot;&gt; &lt;code&gt;+&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#-/2&quot;&gt; &lt;code&gt;-&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#*/2&quot;&gt; &lt;code&gt;*&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#//2&quot;&gt; &lt;code&gt;/&lt;/code&gt; &lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="79024a8401b2b8c396f988fb810ff0532f91eb9c" translate="yes" xml:space="preserve">
          <source>arithmetic unary and binary operators (&lt;a href=&quot;kernel#+/1&quot;&gt;&lt;code&gt;+&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;kernel#-/1&quot;&gt;&lt;code&gt;-&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;kernel#+/2&quot;&gt;&lt;code&gt;+&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;kernel#-/2&quot;&gt;&lt;code&gt;-&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;kernel#*/2&quot;&gt;&lt;code&gt;*&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;kernel#//2&quot;&gt;&lt;code&gt;/&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="translated">арифметические унарные и бинарные операторы ( &lt;a href=&quot;kernel#+/1&quot;&gt; &lt;code&gt;+&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;kernel#-/1&quot;&gt; &lt;code&gt;-&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;kernel#+/2&quot;&gt; &lt;code&gt;+&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;kernel#-/2&quot;&gt; &lt;code&gt;-&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;kernel#*/2&quot;&gt; &lt;code&gt;*&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;kernel#//2&quot;&gt; &lt;code&gt;/&lt;/code&gt; &lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="fa6811726cfe2a8d90f3a9537cc8c9e08e8aacd0" translate="yes" xml:space="preserve">
          <source>arithmetic unary operators (&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#+/1&quot;&gt;&lt;code&gt;+&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#-/1&quot;&gt;&lt;code&gt;-&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="translated">арифметические унарные операторы ( &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#+/1&quot;&gt; &lt;code&gt;+&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#-/1&quot;&gt; &lt;code&gt;-&lt;/code&gt; &lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="3afce94d78d7d19dcaf24e8433bb2fc4958c78e4" translate="yes" xml:space="preserve">
          <source>arity_or_args()</source>
          <target state="translated">arity_or_args()</target>
        </trans-unit>
        <trans-unit id="95257280b57ef4faff560cbaa0800e101d3c11b4" translate="yes" xml:space="preserve">
          <source>as a last resort, the current working directory</source>
          <target state="translated">в крайнем случае,текущий рабочий каталог</target>
        </trans-unit>
        <trans-unit id="ac68ccf28ae7e12cede55b97d51ef7d14aa7d630" translate="yes" xml:space="preserve">
          <source>as, in case of an error, &lt;code&gt;File.read/1&lt;/code&gt; will return &lt;code&gt;{:error, reason}&lt;/code&gt; and the pattern matching will fail. You will still get the desired result (a raised error), but the message will be about the pattern which doesn&amp;rsquo;t match (thus being cryptic in respect to what the error actually is about).</source>
          <target state="translated">поскольку в случае ошибки &lt;code&gt;File.read/1&lt;/code&gt; вернет &lt;code&gt;{:error, reason}&lt;/code&gt; error, cause } и сопоставление с образцом не удастся. Вы по-прежнему получите желаемый результат (поднятая ошибка), но сообщение будет о шаблоне, который не соответствует (что является загадочным в отношении того, в чем на самом деле ошибка).</target>
        </trans-unit>
        <trans-unit id="18a1ee2b34ca9c4a1fa8225b0b75c12be5fbb9a3" translate="yes" xml:space="preserve">
          <source>ascii - Character codes 0-127</source>
          <target state="translated">acii-коды символов 0-127</target>
        </trans-unit>
        <trans-unit id="74f18c1e2a01a57019fe79463f0a25da9ac0e5bd" translate="yes" xml:space="preserve">
          <source>ascii_printable?(list, limit \\ :infinity)</source>
          <target state="translated">ascii_printable?(список,лимит \\ :бесконечность)</target>
        </trans-unit>
        <trans-unit id="10c643ecc7e0f982a932fb0bea65d12d5287287b" translate="yes" xml:space="preserve">
          <source>assert(assertion)</source>
          <target state="translated">assert(assertion)</target>
        </trans-unit>
        <trans-unit id="89e19f9af27aa7c7669a80939500245f8dcf0e16" translate="yes" xml:space="preserve">
          <source>assert(value, message)</source>
          <target state="translated">утверждать (значение,сообщение)</target>
        </trans-unit>
        <trans-unit id="860e867b9917efbcb8354cf902e62854e02a0b28" translate="yes" xml:space="preserve">
          <source>assert_impl!(protocol, base)</source>
          <target state="translated">assert_impl!(протокол,база)</target>
        </trans-unit>
        <trans-unit id="d63fbdddec239c5bb5588153e2a2b48598a7c639" translate="yes" xml:space="preserve">
          <source>assert_in_delta(value1, value2, delta, message \\ nil)</source>
          <target state="translated">assert_in_delta(value1,value2,delta,сообщение \\ nil)</target>
        </trans-unit>
        <trans-unit id="f7fe0bb36981410620b40b362a87649e0515f878" translate="yes" xml:space="preserve">
          <source>assert_protocol!(module)</source>
          <target state="translated">assert_protocol!(module)</target>
        </trans-unit>
        <trans-unit id="9e15373b6a8595ae650733bfb0e4f98933ffa371" translate="yes" xml:space="preserve">
          <source>assert_raise(exception, function)</source>
          <target state="translated">assert_raise(исключение,функция)</target>
        </trans-unit>
        <trans-unit id="70f686bff8d88db9e0393e0c657dda87aeec8b59" translate="yes" xml:space="preserve">
          <source>assert_raise(exception, message, function)</source>
          <target state="translated">assert_raise(исключение,сообщение,функция)</target>
        </trans-unit>
        <trans-unit id="efad9e6cb866dbe2d328bdc1b1b0875a045f6632" translate="yes" xml:space="preserve">
          <source>assert_receive(pattern, timeout \\ Application.fetch_env!(:ex_unit, :assert_receive_timeout), failure_message \\ nil)</source>
          <target state="translated">assert_receive(pattern,timeout \\ Application.fetch_env!(:ex_unit,:assert_receive_timeout),failure_message \\ nil)</target>
        </trans-unit>
        <trans-unit id="51287d07e18083625624f1a33ed54ad45ced9b41" translate="yes" xml:space="preserve">
          <source>assert_receive(pattern, timeout \\ nil, failure_message \\ nil)</source>
          <target state="translated">assert_receive(pattern,timeout \\ nil,failure_message \\ nil)</target>
        </trans-unit>
        <trans-unit id="6d612077d393bab96c575feb95121035be357414" translate="yes" xml:space="preserve">
          <source>assert_received(pattern, failure_message \\ nil)</source>
          <target state="translated">assert_received(pattern,failure_message \\ nil)</target>
        </trans-unit>
        <trans-unit id="67bbf25898432cbcf651834e6b82fcb163d31316" translate="yes" xml:space="preserve">
          <source>async (1)</source>
          <target state="translated">асинхронизация (1)</target>
        </trans-unit>
        <trans-unit id="39bef3890cabe2f7913073bb5a5d985159fc9508" translate="yes" xml:space="preserve">
          <source>async and await</source>
          <target state="translated">асинхронизировать и ждать</target>
        </trans-unit>
        <trans-unit id="ba0642bd07de1e47a5422933f5c84b2c61e67a64" translate="yes" xml:space="preserve">
          <source>async tasks link the caller and the spawned process. This means that, if the caller crashes, the task will crash too and vice-versa. This is on purpose: if the process meant to receive the result no longer exists, there is no purpose in completing the computation.</source>
          <target state="translated">асинхронные задачи связывают вызывающего абонента и порожденный им процесс.Это означает,что в случае сбоя вызывающего абонента задача тоже рухнет,и наоборот.Это делается специально:если процесс,предназначенный для получения результата,больше не существует,то завершение вычислений не имеет смысла.</target>
        </trans-unit>
        <trans-unit id="3a1f114d26725f770a8d4a464e1b0b509f09efdd" translate="yes" xml:space="preserve">
          <source>async(fun)</source>
          <target state="translated">async(fun)</target>
        </trans-unit>
        <trans-unit id="b14f5a3ba085e9b047044838e3238e71f042980e" translate="yes" xml:space="preserve">
          <source>async(module, function_name, args)</source>
          <target state="translated">async(module,function_name,args)</target>
        </trans-unit>
        <trans-unit id="644a7c96c9dda0b61175fcadd25ad5a2d8e57a99" translate="yes" xml:space="preserve">
          <source>async(supervisor, fun, options \\ [])</source>
          <target state="translated">async(супервизор,веселье,опции \\ []))</target>
        </trans-unit>
        <trans-unit id="16eb8d415870b59d9a0cbf04b3ae5e3064a9d91a" translate="yes" xml:space="preserve">
          <source>async(supervisor, module, fun, args, options \\ [])</source>
          <target state="translated">async(супервизор,модуль,веселье,споры,опции \\ []).</target>
        </trans-unit>
        <trans-unit id="6c49f1d590dc630e8a7e644e6326dcfbba229928" translate="yes" xml:space="preserve">
          <source>async/await</source>
          <target state="translated">async/await</target>
        </trans-unit>
        <trans-unit id="6ded9b71c03e31e3335a220d12ea3decd27795ad" translate="yes" xml:space="preserve">
          <source>async_nolink(supervisor, fun, options \\ [])</source>
          <target state="translated">async_nolink(супервизор,веселье,опции \\ []))</target>
        </trans-unit>
        <trans-unit id="5afd38dae84f83eb3b40407823f41867e8ae805f" translate="yes" xml:space="preserve">
          <source>async_nolink(supervisor, module, fun, args, options \\ [])</source>
          <target state="translated">async_nolink(супервизор,модуль,веселье,аргументы,опции \\ []).</target>
        </trans-unit>
        <trans-unit id="2f5130f8e94b55df9c539856cfedaf60b50c1c6a" translate="yes" xml:space="preserve">
          <source>async_stream(enumerable, fun, options \\ [])</source>
          <target state="translated">async_stream(enumerable,fun,options \\ [])</target>
        </trans-unit>
        <trans-unit id="6dff84790a691c5d99359ee6110cfa62264d22a4" translate="yes" xml:space="preserve">
          <source>async_stream(enumerable, module, function_name, args, options \\ [])</source>
          <target state="translated">async_stream(enumerable,модуль,function_name,args,options \\ []).</target>
        </trans-unit>
        <trans-unit id="d6abe4ed4639f30d24556dd4a0636c6853a73c61" translate="yes" xml:space="preserve">
          <source>async_stream(supervisor, enumerable, fun, options \\ [])</source>
          <target state="translated">async_stream(supervisor,enumerable,fun,options \\ []).</target>
        </trans-unit>
        <trans-unit id="1e4df82d00aafae592ea5db9b625f8d3a3370713" translate="yes" xml:space="preserve">
          <source>async_stream(supervisor, enumerable, module, function, args, options \\ [])</source>
          <target state="translated">async_stream(супервизор,enumerable,модуль,функция,args,опции \\ []).</target>
        </trans-unit>
        <trans-unit id="e6770803ae75b3d74fe4816bda7f7a7878642ed7" translate="yes" xml:space="preserve">
          <source>async_stream_nolink(supervisor, enumerable, fun, options \\ [])</source>
          <target state="translated">async_stream_nolink(супервизор,перечисление,веселье,опции \\ []).</target>
        </trans-unit>
        <trans-unit id="099585fc354d29712529a12df14a7f56439d0975" translate="yes" xml:space="preserve">
          <source>async_stream_nolink(supervisor, enumerable, module, function, args, options \\ [])</source>
          <target state="translated">async_stream_nolink(супервизор,enumerable,модуль,функция,args,опции \\ []).</target>
        </trans-unit>
        <trans-unit id="cef3d91e3173d3251f66afa4267433ed22298137" translate="yes" xml:space="preserve">
          <source>at!(index)</source>
          <target state="translated">at!(index)</target>
        </trans-unit>
        <trans-unit id="bf99c9094d6c44fe17f2b0edfc99564c384277a8" translate="yes" xml:space="preserve">
          <source>at(enumerable, index, default \\ nil)</source>
          <target state="translated">at(enumerable,index,default \\ nil)</target>
        </trans-unit>
        <trans-unit id="35774d217491acb444648d4d8aa5dc599e6cf8ac" translate="yes" xml:space="preserve">
          <source>at(index)</source>
          <target state="translated">at(index)</target>
        </trans-unit>
        <trans-unit id="211c902c31671d0d69de0333dc6af625b8c09a4a" translate="yes" xml:space="preserve">
          <source>at(string, position)</source>
          <target state="translated">at(string,position)</target>
        </trans-unit>
        <trans-unit id="5b6c1250ee522b774f28773b006af9d68577716a" translate="yes" xml:space="preserve">
          <source>at_exit(fun)</source>
          <target state="translated">at_exit(fun)</target>
        </trans-unit>
        <trans-unit id="af97844af6122f4c0ef7841a6b4ab699109913de" translate="yes" xml:space="preserve">
          <source>atoms - such as &lt;code&gt;:foo&lt;/code&gt;</source>
          <target state="translated">атомы - такие как &lt;code&gt;:foo&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fbfb09c8eb2bfe559864c2afdb7974e99f9daec5" translate="yes" xml:space="preserve">
          <source>atoms containing interpolation (&lt;code&gt;:&quot;#{1 + 1} is two&quot;&lt;/code&gt;), as these atoms are constructed at runtime.</source>
          <target state="translated">атомы, содержащие интерполяцию ( &lt;code&gt;:&quot;#{1 + 1} is two&quot;&lt;/code&gt; ), так как эти атомы создаются во время выполнения.</target>
        </trans-unit>
        <trans-unit id="8a386a4b759a8e7c363b761f7b91bcf546069135" translate="yes" xml:space="preserve">
          <source>available()</source>
          <target state="translated">available()</target>
        </trans-unit>
        <trans-unit id="c668bbd97902c35149e9703edfac74cda21fa48f" translate="yes" xml:space="preserve">
          <source>available_compiler_options()</source>
          <target state="translated">available_compiler_options()</target>
        </trans-unit>
        <trans-unit id="e0981f3198429f4044bfc1486fe7ae63a66f1090" translate="yes" xml:space="preserve">
          <source>await(task, timeout \\ 5000)</source>
          <target state="translated">wait(task,timeout \\ 5000)</target>
        </trans-unit>
        <trans-unit id="7a73bfb697d929bdcd7f3b8ea9bf22c855379b3a" translate="yes" xml:space="preserve">
          <source>await_many(tasks, timeout \\ 5000)</source>
          <target state="translated">wait_many(задачи,тайм-аут \\ 5000)</target>
        </trans-unit>
        <trans-unit id="e9d71f5ee7c92d6dc9e92ffdad17b8bd49418f98" translate="yes" xml:space="preserve">
          <source>b</source>
          <target state="translated">b</target>
        </trans-unit>
        <trans-unit id="0cd00c30b019ba6ecfdabddaa2f4a56b546dde96" translate="yes" xml:space="preserve">
          <source>b(term)</source>
          <target state="translated">b(term)</target>
        </trans-unit>
        <trans-unit id="95e538affb9563d8a246471c2d822f6605fa9f9a" translate="yes" xml:space="preserve">
          <source>backend()</source>
          <target state="translated">backend()</target>
        </trans-unit>
        <trans-unit id="f395b7176e4e6c22a72c7354b91fe4f3c90e5bf3" translate="yes" xml:space="preserve">
          <source>bag_distance(string1, string2)</source>
          <target state="translated">bag_distance(string1,string2)</target>
        </trans-unit>
        <trans-unit id="65a3bb5b7fcec69eefa8a1df1aabbde9925d3db2" translate="yes" xml:space="preserve">
          <source>band(left, right)</source>
          <target state="translated">группа (слева,справа)</target>
        </trans-unit>
        <trans-unit id="b626e95c9a950f9c3e9d14c4b36ee2333a1f9d6f" translate="yes" xml:space="preserve">
          <source>bare_log(level, chardata_or_fun, metadata \\ [])</source>
          <target state="translated">bare_log(level,chardata_or_fun,metadata \\ [])</target>
        </trans-unit>
        <trans-unit id="dc136952ca3f09942db625a0183f048beb9e5566" translate="yes" xml:space="preserve">
          <source>bare_log(level, message_or_fun, metadata \\ [])</source>
          <target state="translated">bare_log(level,message_or_fun,metadata \\ []).</target>
        </trans-unit>
        <trans-unit id="fb644a6b04b7b3bf241d7acf3a194cbe9ac88c6d" translate="yes" xml:space="preserve">
          <source>basename(path)</source>
          <target state="translated">basename(path)</target>
        </trans-unit>
        <trans-unit id="d1b1d07bdf062e516810f3b9a5acb8ae84899cba" translate="yes" xml:space="preserve">
          <source>basename(path, extension)</source>
          <target state="translated">имя базисника (путь,расширение)</target>
        </trans-unit>
        <trans-unit id="bbf358df8cd93a3ba02d598ff2285629925a9ec5" translate="yes" xml:space="preserve">
          <source>basic language primitives, such as arithmetic operators, spawning of processes, data type handling, and others</source>
          <target state="translated">примитивы базового языка,такие как арифметические операторы,порождение процессов,обработка типов данных и др.</target>
        </trans-unit>
        <trans-unit id="e365b24437ffe1b6ca5c1e482c3b340b99ca0f89" translate="yes" xml:space="preserve">
          <source>basic language primitives, such as arithmetic operators, spawning of processes, data type handling, etc.</source>
          <target state="translated">примитивы базового языка,такие как арифметические операторы,порождение процессов,обработка типов данных и т.д.</target>
        </trans-unit>
        <trans-unit id="838c3bb5cb014e2b56b082c6374af11577e5758f" translate="yes" xml:space="preserve">
          <source>bce()</source>
          <target state="translated">bce()</target>
        </trans-unit>
        <trans-unit id="257074bfad4f890ba2be69198a08555a8b68a240" translate="yes" xml:space="preserve">
          <source>be within the range &lt;code&gt;0..0x10FFFF&lt;/code&gt; (&lt;code&gt;0..1_114_111&lt;/code&gt;);</source>
          <target state="translated">находиться в диапазоне &lt;code&gt;0..0x10FFFF&lt;/code&gt; ( &lt;code&gt;0..1_114_111&lt;/code&gt; );</target>
        </trans-unit>
        <trans-unit id="bfededbc91af0ea68bea5f2b001c1da1b705ce5d" translate="yes" xml:space="preserve">
          <source>beginning_of_month(map)</source>
          <target state="translated">beginning_of_month(map)</target>
        </trans-unit>
        <trans-unit id="d8a6a21abadaaa27a769a72cc478add3efee6ad3" translate="yes" xml:space="preserve">
          <source>beginning_of_week(date, starting_on \\ :default)</source>
          <target state="translated">start_of_week(дата,начало_в \\ :по умолчанию)</target>
        </trans-unit>
        <trans-unit id="bcce33fb6a26c83c3388b9bdab039e5bd0e3ccba" translate="yes" xml:space="preserve">
          <source>being able to refer to specific numbered scenarios</source>
          <target state="translated">возможность ссылаться на конкретные пронумерованные сценарии</target>
        </trans-unit>
        <trans-unit id="61945a024d3ad31bc97b4c4146a493ba6965aaff" translate="yes" xml:space="preserve">
          <source>binary_part (3)</source>
          <target state="translated">двоичная часть (3)</target>
        </trans-unit>
        <trans-unit id="3f0fe199d299de392ea64a31ca3f12d433002fb5" translate="yes" xml:space="preserve">
          <source>binary_part(binary, start, length)</source>
          <target state="translated">binary_part(двоичный,начало,длина)</target>
        </trans-unit>
        <trans-unit id="be55a3267db4409f034493415797db14292fd1c3" translate="yes" xml:space="preserve">
          <source>binding (1)</source>
          <target state="translated">обязывающий (1)</target>
        </trans-unit>
        <trans-unit id="6228382471e6936df78c76fdfe6348711cdf3b43" translate="yes" xml:space="preserve">
          <source>binding()</source>
          <target state="translated">binding()</target>
        </trans-unit>
        <trans-unit id="ddb8ed4423f573770a2ab96f9aa5237c643b668e" translate="yes" xml:space="preserve">
          <source>binding(context \\ nil)</source>
          <target state="translated">binding(context \\ nil)</target>
        </trans-unit>
        <trans-unit id="a2c53f1bbe25d58eae391d9f98327f3756ec5f19" translate="yes" xml:space="preserve">
          <source>binread(device \\ :stdio, line_or_chars)</source>
          <target state="translated">binread(устройство \\ :stdio,line_or_chars)</target>
        </trans-unit>
        <trans-unit id="3770d2369f69a250c90abd2d17e302aa32774f58" translate="yes" xml:space="preserve">
          <source>binstream(device, line_or_bytes)</source>
          <target state="translated">binstream(device,line_or_bytes)</target>
        </trans-unit>
        <trans-unit id="cf21ab6ef6f6a1dc37c2bd554365dd95b9009565" translate="yes" xml:space="preserve">
          <source>binwrite(device \\ :stdio, iodata)</source>
          <target state="translated">binwrite(устройство \\ :stdio,iodata)</target>
        </trans-unit>
        <trans-unit id="506697def21c57073a87a2ce3681f1c117381614" translate="yes" xml:space="preserve">
          <source>bit_size (1)</source>
          <target state="translated">бит_размер (1)</target>
        </trans-unit>
        <trans-unit id="399dc342625b72f3c79a77636b1f6a9e8df981c5" translate="yes" xml:space="preserve">
          <source>bit_size(bitstring)</source>
          <target state="translated">bit_size(bitstring)</target>
        </trans-unit>
        <trans-unit id="bc4218e8336dca1e4bc683da88053d8cc252fcd1" translate="yes" xml:space="preserve">
          <source>black()</source>
          <target state="translated">black()</target>
        </trans-unit>
        <trans-unit id="22f91081b2fc08e1b706c14fd06f5fe49b205d51" translate="yes" xml:space="preserve">
          <source>black_background()</source>
          <target state="translated">black_background()</target>
        </trans-unit>
        <trans-unit id="1a49af7a4bbad040aaf5dce728ad2542d89f9b1e" translate="yes" xml:space="preserve">
          <source>blame(kind, error, stacktrace)</source>
          <target state="translated">blame(kind,error,stacktrace)</target>
        </trans-unit>
        <trans-unit id="edf4584177e9a79f5d425d4594a659bec1cc30dd" translate="yes" xml:space="preserve">
          <source>blame(t, stacktrace)</source>
          <target state="translated">вина(t,stacktrace)</target>
        </trans-unit>
        <trans-unit id="5094e5cc5ec1839a56d830ac198bf301f64b3e0c" translate="yes" xml:space="preserve">
          <source>blame_mfa(module, function, args)</source>
          <target state="translated">blame_mfa(модуль,функция,аргументы)</target>
        </trans-unit>
        <trans-unit id="cfebdf29b405f0ee7f4bf2f1c41fc7a8113058e6" translate="yes" xml:space="preserve">
          <source>blank - Space or tab only</source>
          <target state="translated">пустой-Только пробел или вкладка</target>
        </trans-unit>
        <trans-unit id="408c177bae9d4727cd6f1daf2d926adbff67a5d5" translate="yes" xml:space="preserve">
          <source>blink_off()</source>
          <target state="translated">blink_off()</target>
        </trans-unit>
        <trans-unit id="db1ee76d307eab2e31f726ec884808f99a379b6b" translate="yes" xml:space="preserve">
          <source>blink_rapid()</source>
          <target state="translated">blink_rapid()</target>
        </trans-unit>
        <trans-unit id="20ae1db39f56eaf21a4311706905d4d48b969338" translate="yes" xml:space="preserve">
          <source>blink_slow()</source>
          <target state="translated">blink_slow()</target>
        </trans-unit>
        <trans-unit id="5cbbabeea6cd89e740f4fc04c12080d75eb788a6" translate="yes" xml:space="preserve">
          <source>blue()</source>
          <target state="translated">blue()</target>
        </trans-unit>
        <trans-unit id="d0d904edb1e8432e4d4569b8a4a440d3d42de84c" translate="yes" xml:space="preserve">
          <source>blue_background()</source>
          <target state="translated">blue_background()</target>
        </trans-unit>
        <trans-unit id="bce6c1eaf6b9cc0363d6fbe35526dd7395dd9ebf" translate="yes" xml:space="preserve">
          <source>bnot(expr)</source>
          <target state="translated">bnot(expr)</target>
        </trans-unit>
        <trans-unit id="75453e75a84ed7fb955577a4f8826dc89812816d" translate="yes" xml:space="preserve">
          <source>body()</source>
          <target state="translated">body()</target>
        </trans-unit>
        <trans-unit id="6b558f5e575d32f5db340e51a80be898e0c6903b" translate="yes" xml:space="preserve">
          <source>bor(left, right)</source>
          <target state="translated">бор(левый,правый)</target>
        </trans-unit>
        <trans-unit id="c9ec3865e390b027fae9d08e39e51a720bcdea73" translate="yes" xml:space="preserve">
          <source>break!(ast, stops \\ 1)</source>
          <target state="translated">break!(ast,stops \\ 1)</target>
        </trans-unit>
        <trans-unit id="5c346b0baa312a95ed61f36d30f6a591d9a932ec" translate="yes" xml:space="preserve">
          <source>break!(module, function, args, guard, env, breaks \\ 1)</source>
          <target state="translated">break!(модуль,функция,аргументы,защита,зависть,паузы \\ 1)</target>
        </trans-unit>
        <trans-unit id="fbd6b4d49434054a4769d718cf497514201b14f9" translate="yes" xml:space="preserve">
          <source>break!(module, function, arity, breaks \\ 1)</source>
          <target state="translated">break!(модуль,функция,arity,breaks \\ 1)</target>
        </trans-unit>
        <trans-unit id="3105037b87100ee55a10455e35df32ef2f6ec6e2" translate="yes" xml:space="preserve">
          <source>break!(module, function, arity, stops \\ 1)</source>
          <target state="translated">break!(модуль,функция,аритмия,стопы \\ 1)</target>
        </trans-unit>
        <trans-unit id="0ca944ad9e57dbb30f37b9c4be42d0106780af3e" translate="yes" xml:space="preserve">
          <source>break()</source>
          <target state="translated">break()</target>
        </trans-unit>
        <trans-unit id="7e5fda4ef1c0fb328fcf673adee8804f66e12436" translate="yes" xml:space="preserve">
          <source>break(module, function, args, guard, env, breaks \\ 1)</source>
          <target state="translated">break(модуль,функция,аргументы,защита,зависть,паузы \\ 1)</target>
        </trans-unit>
        <trans-unit id="2b0b786a92c89f0f0af518279d5e4e5ea36b15e9" translate="yes" xml:space="preserve">
          <source>break(module, function, arity, breaks \\ 1)</source>
          <target state="translated">break(модуль,функция,аритет,паузы \\ 1)</target>
        </trans-unit>
        <trans-unit id="b161e4f7384e3c463d8ee3978b04065bf8310004" translate="yes" xml:space="preserve">
          <source>break(string \\ &quot; &quot;)</source>
          <target state="translated">break(string \\ &quot; &quot;)</target>
        </trans-unit>
        <trans-unit id="678f4fdbb471d58e3e7363cf3caab144fa193f9e" translate="yes" xml:space="preserve">
          <source>break_error()</source>
          <target state="translated">break_error()</target>
        </trans-unit>
        <trans-unit id="969279661e12e7b53ad9773dae663e52ad3b02ff" translate="yes" xml:space="preserve">
          <source>breaks()</source>
          <target state="translated">breaks()</target>
        </trans-unit>
        <trans-unit id="af82e225252a073224a7c3f01edc22ba4186008f" translate="yes" xml:space="preserve">
          <source>bright()</source>
          <target state="translated">bright()</target>
        </trans-unit>
        <trans-unit id="8e5305b81a2bbb73a86dfa45df50bed29256eec1" translate="yes" xml:space="preserve">
          <source>bsl(left, right)</source>
          <target state="translated">bsl(левый,правый)</target>
        </trans-unit>
        <trans-unit id="e7c1b9ba1598634ac4edacaa6ca137c0d320f08c" translate="yes" xml:space="preserve">
          <source>bsr(left, right)</source>
          <target state="translated">bsr(левая,правая)</target>
        </trans-unit>
        <trans-unit id="8d0cf0327a36ac9e1f165d048984f61313aee81d" translate="yes" xml:space="preserve">
          <source>build()</source>
          <target state="translated">build()</target>
        </trans-unit>
        <trans-unit id="c7f20f10b9ebee5ce04a9c27a00c97be570b0d03" translate="yes" xml:space="preserve">
          <source>build_info()</source>
          <target state="translated">build_info()</target>
        </trans-unit>
        <trans-unit id="9550344570851db07d3e0819a8a3a0b3753b135d" translate="yes" xml:space="preserve">
          <source>build_path(config \\ config())</source>
          <target state="translated">build_path(config \\ config()))</target>
        </trans-unit>
        <trans-unit id="1b0451766a01a45d61cb81b0b5af3db4ff3621de" translate="yes" xml:space="preserve">
          <source>build_structure(config \\ config(), opts \\ [])</source>
          <target state="translated">build_structure(config \\ config(),opts \\ [])).</target>
        </trans-unit>
        <trans-unit id="ff3864c4f844476deb052e18baf4d5957364877b" translate="yes" xml:space="preserve">
          <source>but it won't match</source>
          <target state="translated">но он не подойдёт</target>
        </trans-unit>
        <trans-unit id="b5651891e94bcacea868412954d9cff44695f679" translate="yes" xml:space="preserve">
          <source>bxor(left, right)</source>
          <target state="translated">bxor(левый,правый)</target>
        </trans-unit>
        <trans-unit id="adbf128371d04f04e5778c12471cfccf93681b9b" translate="yes" xml:space="preserve">
          <source>by hitting &lt;code&gt;Ctrl+C&lt;/code&gt;, &lt;code&gt;Ctrl+C&lt;/code&gt;</source>
          <target state="translated">нажав &lt;code&gt;Ctrl+C&lt;/code&gt; , &lt;code&gt;Ctrl+C&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e753f9c66c97edb4c4f26740cf8b1cb9e4365f1a" translate="yes" xml:space="preserve">
          <source>by hitting &lt;code&gt;Ctrl+\&lt;/code&gt;</source>
          <target state="translated">нажав &lt;code&gt;Ctrl+\&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ea6b8e8b0ef7ba0453b4449f57eb25dfb303cc1d" translate="yes" xml:space="preserve">
          <source>by the following:</source>
          <target state="translated">следующим:</target>
        </trans-unit>
        <trans-unit id="7dd154f82b1fda04325f982dbdf38279aabe16c3" translate="yes" xml:space="preserve">
          <source>byte_size (1)</source>
          <target state="translated">размер байта (1)</target>
        </trans-unit>
        <trans-unit id="4ff214729194657479037e5bca3207e9de11aa49" translate="yes" xml:space="preserve">
          <source>byte_size(bitstring)</source>
          <target state="translated">byte_size(bitstring)</target>
        </trans-unit>
        <trans-unit id="84a516841ba77a5b4648de2cd0dfcb30ea46dbb4" translate="yes" xml:space="preserve">
          <source>c</source>
          <target state="translated">c</target>
        </trans-unit>
        <trans-unit id="d16ceab0e45bec5a295e9952cc9a7d3cb7c03a9c" translate="yes" xml:space="preserve">
          <source>c(files, path \\ :in_memory)</source>
          <target state="translated">c(файлы,путь \\ :in_memory)</target>
        </trans-unit>
        <trans-unit id="74234dcbd77bc7384b43232d09af56bb094382fe" translate="yes" xml:space="preserve">
          <source>calendar()</source>
          <target state="translated">calendar()</target>
        </trans-unit>
        <trans-unit id="888ee07121f2bfae0d4740685ae66af7e46e23ff" translate="yes" xml:space="preserve">
          <source>call(server, request, timeout \\ 5000)</source>
          <target state="translated">вызов(сервер,запрос,тайм-аут \\ 5000)</target>
        </trans-unit>
        <trans-unit id="63fdb8eeae5c54fc9ca6cdb74b6d83c85ae4493b" translate="yes" xml:space="preserve">
          <source>callers CALLEE</source>
          <target state="translated">звонящие звонят по телефону</target>
        </trans-unit>
        <trans-unit id="4fdf8a60b4534f8984668b9a808c83896befde56" translate="yes" xml:space="preserve">
          <source>calls &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#exit/1&quot;&gt;&lt;code&gt;Kernel.exit/1&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">вызывает &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#exit/1&quot;&gt; &lt;code&gt;Kernel.exit/1&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c9d0d80d9a596c430e090c08563db16444dfbd52" translate="yes" xml:space="preserve">
          <source>calls &lt;a href=&quot;kernel#exit/1&quot;&gt;&lt;code&gt;Kernel.exit/1&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">вызывает &lt;a href=&quot;kernel#exit/1&quot;&gt; &lt;code&gt;Kernel.exit/1&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c668678f2ada7a0c68fc26b247e3f58c7ce70525" translate="yes" xml:space="preserve">
          <source>calls that have do/end blocks</source>
          <target state="translated">звонки с блоками do/end</target>
        </trans-unit>
        <trans-unit id="c755b037d46e6f1cb1f9ea7b8822144a3b8c931a" translate="yes" xml:space="preserve">
          <source>calls(opts \\ [])</source>
          <target state="translated">звонки(опции \\ []))</target>
        </trans-unit>
        <trans-unit id="ae98dadd984dd004bfabe5d8be6399524dc058b5" translate="yes" xml:space="preserve">
          <source>camelize(string)</source>
          <target state="translated">camelize(string)</target>
        </trans-unit>
        <trans-unit id="6a4a4f9af0c6d015686e71d41036a174ea8b4a89" translate="yes" xml:space="preserve">
          <source>can be alternatively written as:</source>
          <target state="translated">может быть альтернативно написано как:</target>
        </trans-unit>
        <trans-unit id="1a3feea303fec3e09089b574e17dbd6e9d9c5fc6" translate="yes" xml:space="preserve">
          <source>can be written without the enclosing brackets whenever it is the last argument of a function call:</source>
          <target state="translated">может быть записано без вложенных скобок всякий раз,когда он является последним аргументом вызова функции:</target>
        </trans-unit>
        <trans-unit id="da9fa42e6ea65138d82ee6999b541da40cf4a638" translate="yes" xml:space="preserve">
          <source>can_await_module_compilation?()</source>
          <target state="translated">can_await_module_compilation?()</target>
        </trans-unit>
        <trans-unit id="d8d74056d7dacfa0c5dbcc37f601364fbfc28a48" translate="yes" xml:space="preserve">
          <source>cancel_timer(timer_ref, options \\ [])</source>
          <target state="translated">cancel_timer(таймер_ref,опции \\ [])</target>
        </trans-unit>
        <trans-unit id="c59a32c3ae74a29ed8f4825a8a23158c800ce201" translate="yes" xml:space="preserve">
          <source>capitalize(string, mode \\ :default)</source>
          <target state="translated">заглавная (string,mode \\ :по умолчанию)</target>
        </trans-unit>
        <trans-unit id="7801c477ed10d080a485a531ee939485640872e0" translate="yes" xml:space="preserve">
          <source>capture(module, function_name, arity)</source>
          <target state="translated">capture(модуль,имя_функции,arity)</target>
        </trans-unit>
        <trans-unit id="95d4736b680fcac5b0a0e56554ba3ac7f57f5ec2" translate="yes" xml:space="preserve">
          <source>capture_io(device, fun)</source>
          <target state="translated">capture_io(устройство,веселье)</target>
        </trans-unit>
        <trans-unit id="5d6f5fe651518f44c405bb809fa3c374e4ea48fc" translate="yes" xml:space="preserve">
          <source>capture_io(device, input, fun)</source>
          <target state="translated">capture_io(устройство,вход,веселье)</target>
        </trans-unit>
        <trans-unit id="c5d938056f7081bf6df2134004e11991485f659c" translate="yes" xml:space="preserve">
          <source>capture_io(fun)</source>
          <target state="translated">capture_io(fun)</target>
        </trans-unit>
        <trans-unit id="38107b049af4baeb6e4ccbde7732cdbd372a6a7f" translate="yes" xml:space="preserve">
          <source>capture_log(opts \\ [], fun)</source>
          <target state="translated">capture_log(opts \\ [],fun)</target>
        </trans-unit>
        <trans-unit id="eee2548620966030ed3a38d2618fc83fcee49512" translate="yes" xml:space="preserve">
          <source>captured_remote_function()</source>
          <target state="translated">captured_remote_function()</target>
        </trans-unit>
        <trans-unit id="1c9491c87f2e11558e6519f43fbdfb13d5f75757" translate="yes" xml:space="preserve">
          <source>case (2)</source>
          <target state="translated">случай (2)</target>
        </trans-unit>
        <trans-unit id="81a6fde4212c2c4e7a6bd1dd35f4d99c1756341f" translate="yes" xml:space="preserve">
          <source>case(condition, clauses)</source>
          <target state="translated">случай (условие,пункты)</target>
        </trans-unit>
        <trans-unit id="276f41646d5e418a498785c796cbe58630038ac8" translate="yes" xml:space="preserve">
          <source>case, cond, and if</source>
          <target state="translated">случай,конд,и если</target>
        </trans-unit>
        <trans-unit id="548c74de3d80b7e38f71e4cd34ee4e6ccd1b0975" translate="yes" xml:space="preserve">
          <source>cast(agent, fun)</source>
          <target state="translated">литьё (агент,веселье)</target>
        </trans-unit>
        <trans-unit id="24e0d639ff0592f02425109ef44097ef5ac141c5" translate="yes" xml:space="preserve">
          <source>cast(agent, module, fun, args)</source>
          <target state="translated">кастинг (агент,модуль,веселье,споры)</target>
        </trans-unit>
        <trans-unit id="bb33c244d99388a4c4d4a6278437e929a37371e3" translate="yes" xml:space="preserve">
          <source>cast(server, request)</source>
          <target state="translated">кастинг (сервер,запрос)</target>
        </trans-unit>
        <trans-unit id="f03277fe202fe2b7ce8cfac6175d162d96f1c404" translate="yes" xml:space="preserve">
          <source>catch_error(expression)</source>
          <target state="translated">catch_error(expression)</target>
        </trans-unit>
        <trans-unit id="22357d5fea4ccbbe014225cf943cdbb904fa71e8" translate="yes" xml:space="preserve">
          <source>catch_exit(expression)</source>
          <target state="translated">catch_exit(expression)</target>
        </trans-unit>
        <trans-unit id="36c5ff014418577832a7f43d20d83f9df1b48315" translate="yes" xml:space="preserve">
          <source>catch_throw(expression)</source>
          <target state="translated">catch_throw(expression)</target>
        </trans-unit>
        <trans-unit id="eef8012abcece720e4d07c62d863a2d2175734b4" translate="yes" xml:space="preserve">
          <source>cd!(path)</source>
          <target state="translated">cd!(path)</target>
        </trans-unit>
        <trans-unit id="81c9dce342a6d8a1492ec615839db369a51b0f94" translate="yes" xml:space="preserve">
          <source>cd!(path, function)</source>
          <target state="translated">cd! (путь,функция)</target>
        </trans-unit>
        <trans-unit id="1dd216ecc62e3003f0dbc326881c8241acad3876" translate="yes" xml:space="preserve">
          <source>cd(directory)</source>
          <target state="translated">cd(directory)</target>
        </trans-unit>
        <trans-unit id="9d057759cbf39721ee3cc79b1c6bd1b4d46e4d3a" translate="yes" xml:space="preserve">
          <source>cd(path)</source>
          <target state="translated">cd(path)</target>
        </trans-unit>
        <trans-unit id="72c36139e8899cfd269890421a37b145aaf7e7f1" translate="yes" xml:space="preserve">
          <source>ce()</source>
          <target state="translated">ce()</target>
        </trans-unit>
        <trans-unit id="3dd9424e14dc92cab3a7059628ae05c63ea935c6" translate="yes" xml:space="preserve">
          <source>ceil (1)</source>
          <target state="translated">потолок (1)</target>
        </trans-unit>
        <trans-unit id="c0266349867fff0e975607d4351fa76a2942152b" translate="yes" xml:space="preserve">
          <source>ceil(number)</source>
          <target state="translated">ceil(number)</target>
        </trans-unit>
        <trans-unit id="898c69d5af7d06ea5554d05f8aa17ffe33956d77" translate="yes" xml:space="preserve">
          <source>ceil(number, precision \\ 0)</source>
          <target state="translated">ceil(номер,точность \\ 0)</target>
        </trans-unit>
        <trans-unit id="41250883c82e9cc4d38b14c0497792d0bcd5fb86" translate="yes" xml:space="preserve">
          <source>char_reserved?(character)</source>
          <target state="translated">char_reserved?(character)</target>
        </trans-unit>
        <trans-unit id="9a45ce6e3ba50ddf22610392b0c8e5f2ae6ecb16" translate="yes" xml:space="preserve">
          <source>char_unescaped?(character)</source>
          <target state="translated">char_unescaped?(character)</target>
        </trans-unit>
        <trans-unit id="f4e470362d53d791e6a6ac43d42e4b890af1b9bc" translate="yes" xml:space="preserve">
          <source>char_unreserved?(character)</source>
          <target state="translated">char_unreserved?(character)</target>
        </trans-unit>
        <trans-unit id="89f42ab843e9ae20f26ffaaf05bb7634df10168f" translate="yes" xml:space="preserve">
          <source>characters derived from the Unicode General Category of uppercase letters, lowercase letters, titlecase letters, modifier letters, other letters, letter numbers, plus &lt;code&gt;Other_ID_Start&lt;/code&gt;, minus &lt;code&gt;Pattern_Syntax&lt;/code&gt; and &lt;code&gt;Pattern_White_Space&lt;/code&gt; code points</source>
          <target state="translated">символы, полученные из общей категории Unicode, состоящей из прописных букв, строчных букв, заглавных букв, букв модификаторов, других букв, буквенных цифр, а &lt;code&gt;Pattern_White_Space&lt;/code&gt; кодовых точек &lt;code&gt;Other_ID_Start&lt;/code&gt; , минус &lt;code&gt;Pattern_Syntax&lt;/code&gt; и Pattern_White_Space</target>
        </trans-unit>
        <trans-unit id="8fc8134273725d4bc7abcdcfcd708ce5008d636d" translate="yes" xml:space="preserve">
          <source>chardata()</source>
          <target state="translated">chardata()</target>
        </trans-unit>
        <trans-unit id="997cc3a24dc9b7c66b31c3ba3f6d3b7f6a5bd2b6" translate="yes" xml:space="preserve">
          <source>chardata_to_string(string)</source>
          <target state="translated">chardata_to_string(string)</target>
        </trans-unit>
        <trans-unit id="f643aca02e836435e756d05cf97a0d4c1570427c" translate="yes" xml:space="preserve">
          <source>checked_out?(opts)</source>
          <target state="translated">checked_out?(opts)</target>
        </trans-unit>
        <trans-unit id="f57c1f6ef6819e31cd7421925281b334ffc11f2e" translate="yes" xml:space="preserve">
          <source>checkout(opts)</source>
          <target state="translated">checkout(opts)</target>
        </trans-unit>
        <trans-unit id="841fc018c2d17064c5fbae4f894b2027171e7a64" translate="yes" xml:space="preserve">
          <source>chgrp!(path, gid)</source>
          <target state="translated">chgrp! (path,gid)</target>
        </trans-unit>
        <trans-unit id="83d8709394f90073805facd15aa07469e3948e6f" translate="yes" xml:space="preserve">
          <source>chgrp(path, gid)</source>
          <target state="translated">chgrp(path,gid)</target>
        </trans-unit>
        <trans-unit id="0e3a7c11a06fe711f18dbf309b00286b0d793c29" translate="yes" xml:space="preserve">
          <source>child()</source>
          <target state="translated">child()</target>
        </trans-unit>
        <trans-unit id="86091951beedcbf72fdc554efb159ae47024df63" translate="yes" xml:space="preserve">
          <source>child_id()</source>
          <target state="translated">child_id()</target>
        </trans-unit>
        <trans-unit id="85e835fef7ac9a461b0fe36250ff0a8682412f33" translate="yes" xml:space="preserve">
          <source>child_spec()</source>
          <target state="translated">child_spec()</target>
        </trans-unit>
        <trans-unit id="a8f980b6663ce5365507de71b4710fc32a3a5ef5" translate="yes" xml:space="preserve">
          <source>child_spec(arg)</source>
          <target state="translated">child_spec(arg)</target>
        </trans-unit>
        <trans-unit id="09111146ba8624fdb98d7c1dcb703e9ad5ea6a28" translate="yes" xml:space="preserve">
          <source>child_spec(init_arg)</source>
          <target state="translated">child_spec(init_arg)</target>
        </trans-unit>
        <trans-unit id="539727c4dd89232de4636588e068794deb56c936" translate="yes" xml:space="preserve">
          <source>child_spec(module_or_map, overrides)</source>
          <target state="translated">child_spec(модуль_or_map,переопределения)</target>
        </trans-unit>
        <trans-unit id="de99d4f79a09957a8cc797b89f534bff2b95dd9e" translate="yes" xml:space="preserve">
          <source>child_spec(options)</source>
          <target state="translated">child_spec(options)</target>
        </trans-unit>
        <trans-unit id="c3700ef202062b71ca39c68af9581bb6d089f74e" translate="yes" xml:space="preserve">
          <source>child_spec(opts)</source>
          <target state="translated">child_spec(opts)</target>
        </trans-unit>
        <trans-unit id="fd3ab6f1ad23a2991f023b22a6718b03206bd695" translate="yes" xml:space="preserve">
          <source>child_spec/1</source>
          <target state="translated">child_spec/1</target>
        </trans-unit>
        <trans-unit id="a71358b312012362c5471e8ee75d872182d2fbb1" translate="yes" xml:space="preserve">
          <source>children(supervisor)</source>
          <target state="translated">children(supervisor)</target>
        </trans-unit>
        <trans-unit id="618d777fee871efd6c85172d3bd853a4eb9246b8" translate="yes" xml:space="preserve">
          <source>chmod!(path, mode)</source>
          <target state="translated">кхмод! (путь,режим)</target>
        </trans-unit>
        <trans-unit id="0b87e43bb3ae70a6f0ac67e1f1b03ccf8d22d654" translate="yes" xml:space="preserve">
          <source>chmod(path, mode)</source>
          <target state="translated">хмод(путь,режим)</target>
        </trans-unit>
        <trans-unit id="93b82202fdad2579bf8b763746c4afb5d2f7c817" translate="yes" xml:space="preserve">
          <source>chown!(path, uid)</source>
          <target state="translated">Чаун!</target>
        </trans-unit>
        <trans-unit id="aecfcafbd79f97782f0bc6ed3cfedc1cb44be5bd" translate="yes" xml:space="preserve">
          <source>chown(path, uid)</source>
          <target state="translated">чаун(путь,уид)</target>
        </trans-unit>
        <trans-unit id="8dcaa4a671e79e51b844c75ccf15abbe4e29e94d" translate="yes" xml:space="preserve">
          <source>chunk(string, trait)</source>
          <target state="translated">фрагмент(строка,черта)</target>
        </trans-unit>
        <trans-unit id="c75281f825d0f2ad87fd2bd8a0550d5a79496ede" translate="yes" xml:space="preserve">
          <source>chunk_by(enum, fun)</source>
          <target state="translated">chunk_by(enum,fun)</target>
        </trans-unit>
        <trans-unit id="a10af27302650d5de9679a66a8cf28513348ad24" translate="yes" xml:space="preserve">
          <source>chunk_by(enumerable, fun)</source>
          <target state="translated">chunk_by(enumerable,fun)</target>
        </trans-unit>
        <trans-unit id="e8403167d4ad1dc5cbf0ba7e43ac17de9ee06cbb" translate="yes" xml:space="preserve">
          <source>chunk_every(enum, count)</source>
          <target state="translated">chunk_every(enum,count)</target>
        </trans-unit>
        <trans-unit id="414ead39f3c429a189cc01a03f7ace025eac0d10" translate="yes" xml:space="preserve">
          <source>chunk_every(enum, count, step, leftover \\ [])</source>
          <target state="translated">chunk_every(enum,count,step,leftover \\ [])</target>
        </trans-unit>
        <trans-unit id="fd799c31ade1d68beed115abe3f5f1667e296457" translate="yes" xml:space="preserve">
          <source>chunk_every(enumerable, count)</source>
          <target state="translated">chunk_every(enumerable,count)</target>
        </trans-unit>
        <trans-unit id="b1b840253492289bc2a6eb56657c69ba214dfe4f" translate="yes" xml:space="preserve">
          <source>chunk_every(enumerable, count, step, leftover \\ [])</source>
          <target state="translated">chunk_every(enumerable,count,step,leftover \\ [])</target>
        </trans-unit>
        <trans-unit id="86426607285a7499f7096cf3e4d35883633530a1" translate="yes" xml:space="preserve">
          <source>chunk_while(enum, acc, chunk_fun, after_fun)</source>
          <target state="translated">chunk_while(enum,acc,chunk_fun,after_fun)</target>
        </trans-unit>
        <trans-unit id="d20464a8c329af5b0041927667adbede6c25ea0c" translate="yes" xml:space="preserve">
          <source>chunk_while(enumerable, acc, chunk_fun, after_fun)</source>
          <target state="translated">chunk_while(enumerable,acc,chunk_fun,after_fun)</target>
        </trans-unit>
        <trans-unit id="eef661db9ae5437774284507d2609f746db37ea0" translate="yes" xml:space="preserve">
          <source>clean()</source>
          <target state="translated">clean()</target>
        </trans-unit>
        <trans-unit id="af6ab064a94fb3e9fd590a99e474c2ed6fe59e97" translate="yes" xml:space="preserve">
          <source>clear()</source>
          <target state="translated">clear()</target>
        </trans-unit>
        <trans-unit id="cc4fa8909241cf935c15b6d6decd530c334c13d9" translate="yes" xml:space="preserve">
          <source>clear_deps_cache()</source>
          <target state="translated">clear_deps_cache()</target>
        </trans-unit>
        <trans-unit id="8e148bf4bd8c70a275395283a1fee3149c01a6db" translate="yes" xml:space="preserve">
          <source>clear_line()</source>
          <target state="translated">clear_line()</target>
        </trans-unit>
        <trans-unit id="a8542ae60b86c5b7fab2c0f0ec801edbdd358ec2" translate="yes" xml:space="preserve">
          <source>close(io_device)</source>
          <target state="translated">close(io_device)</target>
        </trans-unit>
        <trans-unit id="ad48d4f1daa0af6218d10f1d9bdaa68220659962" translate="yes" xml:space="preserve">
          <source>close(pid)</source>
          <target state="translated">close(pid)</target>
        </trans-unit>
        <trans-unit id="126f6a2d5d855131423de17cf0f340552968d16a" translate="yes" xml:space="preserve">
          <source>close(port)</source>
          <target state="translated">close(port)</target>
        </trans-unit>
        <trans-unit id="06e8361ae167643cdd01639d7059abb16c682a63" translate="yes" xml:space="preserve">
          <source>cmd(command)</source>
          <target state="translated">cmd(command)</target>
        </trans-unit>
        <trans-unit id="3474d1f0104de4abf39d17d28090501f2d14af64" translate="yes" xml:space="preserve">
          <source>cmd(command, args, opts \\ [])</source>
          <target state="translated">cmd(command,args,opts \\ []).</target>
        </trans-unit>
        <trans-unit id="c4b6d3656532e0d3d5b764b72812de9e4395d4af" translate="yes" xml:space="preserve">
          <source>cmd(command, options \\ [], callback)</source>
          <target state="translated">cmd(команда,параметры \\ [],обратный вызов)</target>
        </trans-unit>
        <trans-unit id="86febf55be9ea088e569deb94b2febfca3f738c8" translate="yes" xml:space="preserve">
          <source>cmd(command, options)</source>
          <target state="translated">команда (команды,опции)</target>
        </trans-unit>
        <trans-unit id="92e9397dcbef1fbc7087be42a03c5f070dc0ca08" translate="yes" xml:space="preserve">
          <source>cmd(command, opts \\ [])</source>
          <target state="translated">cmd(command,opts \\ []))</target>
        </trans-unit>
        <trans-unit id="bce83c2643f3ffd948278c2f84d97c4499adbb97" translate="yes" xml:space="preserve">
          <source>cntrl - Control characters</source>
          <target state="translated">cntrl-контрольные символы</target>
        </trans-unit>
        <trans-unit id="008fcce5b9d0c4e7e823a52a6d540791a57eff66" translate="yes" xml:space="preserve">
          <source>code_change(old_vsn, state, extra)</source>
          <target state="translated">code_change(old_vsn,state,extra)</target>
        </trans-unit>
        <trans-unit id="efaff14494d5a7a6c75b8dc39649bcdb57a77e86" translate="yes" xml:space="preserve">
          <source>codepoint()</source>
          <target state="translated">codepoint()</target>
        </trans-unit>
        <trans-unit id="481504ade11e7bd75fac7f8c47cbaaed73a5aad1" translate="yes" xml:space="preserve">
          <source>codepoints(string)</source>
          <target state="translated">codepoints(string)</target>
        </trans-unit>
        <trans-unit id="e9fa4b7b4e3b16a346738a2f334d4f9662ec649d" translate="yes" xml:space="preserve">
          <source>collapse_lines(max)</source>
          <target state="translated">collapse_lines(max)</target>
        </trans-unit>
        <trans-unit id="ae1436cbaf361c172c76774c42997c1fe2df52b2" translate="yes" xml:space="preserve">
          <source>color(code)</source>
          <target state="translated">color(code)</target>
        </trans-unit>
        <trans-unit id="366078943e5fdc294278993179908cbdd1c7fb95" translate="yes" xml:space="preserve">
          <source>color(color, string)</source>
          <target state="translated">цвет (цвет,строка)</target>
        </trans-unit>
        <trans-unit id="5b6b60bb9a814685bbbe82e6dd18d80c05b20273" translate="yes" xml:space="preserve">
          <source>color(doc, color_key, opts)</source>
          <target state="translated">color(doc,color_key,opts)</target>
        </trans-unit>
        <trans-unit id="a212a67103c32a864ce08c31456661e9c27539ab" translate="yes" xml:space="preserve">
          <source>color(r, g, b)</source>
          <target state="translated">цвет(р,ж,б)</target>
        </trans-unit>
        <trans-unit id="ae8ce96620cbd80df8b6ba0cc7aebbb6fa9a40c0" translate="yes" xml:space="preserve">
          <source>color_background(code)</source>
          <target state="translated">color_background(code)</target>
        </trans-unit>
        <trans-unit id="d8cd01c394dc4a55dbdab64b2c004c6d9aeb59aa" translate="yes" xml:space="preserve">
          <source>color_background(r, g, b)</source>
          <target state="translated">color_background(r,g,b)</target>
        </trans-unit>
        <trans-unit id="06a0785bb2a6e3c0fb8be863151d12083ffd68e8" translate="yes" xml:space="preserve">
          <source>color_key()</source>
          <target state="translated">color_key()</target>
        </trans-unit>
        <trans-unit id="1106196ccdcd143f74bf0f42300cb9217d35cb4f" translate="yes" xml:space="preserve">
          <source>command()</source>
          <target state="translated">command()</target>
        </trans-unit>
        <trans-unit id="d2dba9b3d360e74e85badfe473bb5cbc6b47f7a8" translate="yes" xml:space="preserve">
          <source>command(port, data, options \\ [])</source>
          <target state="translated">команда(порт,данные,опции \\ []).</target>
        </trans-unit>
        <trans-unit id="b7578fa140e5a48efc018542164ff7a387af429d" translate="yes" xml:space="preserve">
          <source>compare(date1, date2)</source>
          <target state="translated">сравнение (дата1,дата2)</target>
        </trans-unit>
        <trans-unit id="08c1682119656a1942fc3e1fabda12d21124e673" translate="yes" xml:space="preserve">
          <source>compare(datetime1, datetime2)</source>
          <target state="translated">сравнение (datetime1,datetime2)</target>
        </trans-unit>
        <trans-unit id="2fb22b161c676bf6dc077aecadc4f0fcf693f7a8" translate="yes" xml:space="preserve">
          <source>compare(naive_datetime1, naive_datetime2)</source>
          <target state="translated">compare(naive_datetime1,naive_datetime2)</target>
        </trans-unit>
        <trans-unit id="8574cd59bc77840088b087620a0182089fd0206f" translate="yes" xml:space="preserve">
          <source>compare(time1, time2)</source>
          <target state="translated">сравнение (time1,time2)</target>
        </trans-unit>
        <trans-unit id="27497fe39089deb37ba63d0d9e02f22b644072bd" translate="yes" xml:space="preserve">
          <source>compare(version1, version2)</source>
          <target state="translated">появляется(версия 1,версия 2)</target>
        </trans-unit>
        <trans-unit id="c2d46c76bd019622c7c6534b32df3b41792b1b96" translate="yes" xml:space="preserve">
          <source>compare_levels(left, right)</source>
          <target state="translated">comparison_levels(left,right)</target>
        </trans-unit>
        <trans-unit id="3de00d12e4872fbb28b1b73be33038941dc1e654" translate="yes" xml:space="preserve">
          <source>comparison operators (&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#==/2&quot;&gt;&lt;code&gt;==&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#!=/2&quot;&gt;&lt;code&gt;!=&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#===/2&quot;&gt;&lt;code&gt;===&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#!==/2&quot;&gt;&lt;code&gt;!==&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#%3C/2&quot;&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#%3C=/2&quot;&gt;&lt;code&gt;&amp;lt;=&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#%3E/2&quot;&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#%3E=/2&quot;&gt;&lt;code&gt;&amp;gt;=&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="translated">операторы сравнения ( &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#==/2&quot;&gt; &lt;code&gt;==&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#!=/2&quot;&gt; &lt;code&gt;!=&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#===/2&quot;&gt; &lt;code&gt;===&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#!==/2&quot;&gt; &lt;code&gt;!==&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#%3C/2&quot;&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#%3C=/2&quot;&gt; &lt;code&gt;&amp;lt;=&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#%3E/2&quot;&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#%3E=/2&quot;&gt; &lt;code&gt;&amp;gt;=&lt;/code&gt; &lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="20426d6d1e27cd203aac7c5bc70cd30067784241" translate="yes" xml:space="preserve">
          <source>comparison operators (&lt;a href=&quot;kernel#==/2&quot;&gt;&lt;code&gt;==&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;kernel#!=/2&quot;&gt;&lt;code&gt;!=&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;kernel#===/2&quot;&gt;&lt;code&gt;===&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;kernel#!==/2&quot;&gt;&lt;code&gt;!==&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;kernel#%253E/2&quot;&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;kernel#%253E=/2&quot;&gt;&lt;code&gt;&amp;gt;=&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;kernel#%253C/2&quot;&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;kernel#%253C=/2&quot;&gt;&lt;code&gt;&amp;lt;=&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="translated">операторы сравнения ( &lt;a href=&quot;kernel#==/2&quot;&gt; &lt;code&gt;==&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;kernel#!=/2&quot;&gt; &lt;code&gt;!=&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;kernel#===/2&quot;&gt; &lt;code&gt;===&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;kernel#!==/2&quot;&gt; &lt;code&gt;!==&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;kernel#%253E/2&quot;&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;kernel#%253E=/2&quot;&gt; &lt;code&gt;&amp;gt;=&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;kernel#%253C/2&quot;&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;kernel#%253C=/2&quot;&gt; &lt;code&gt;&amp;lt;=&lt;/code&gt; &lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="993f2b9d93576f6156c5314f57a27c460d6872c2" translate="yes" xml:space="preserve">
          <source>compatible_calendars?(calendar, calendar)</source>
          <target state="translated">совместимые_календары?(календарь,календарь)</target>
        </trans-unit>
        <trans-unit id="a21285aad6815be212fb835e436777093446d5f8" translate="yes" xml:space="preserve">
          <source>compile (2)</source>
          <target state="translated">собирать (2)</target>
        </trans-unit>
        <trans-unit id="bef628e04dd15e46ff8e79eaf27a98ee0eee5188" translate="yes" xml:space="preserve">
          <source>compile!(source, options \\ &quot;&quot;)</source>
          <target state="translated">компилируйте!(источник,опции \\ &quot;&quot;)</target>
        </trans-unit>
        <trans-unit id="4ec3c3cea79df7d0e03e54c5af660591362c2413" translate="yes" xml:space="preserve">
          <source>compile(args, config \\ [])</source>
          <target state="translated">compile(args,config \\ []))</target>
        </trans-unit>
        <trans-unit id="61a71d51297295ea461ffe0b290cf6e12116c8c4" translate="yes" xml:space="preserve">
          <source>compile(files, options \\ [])</source>
          <target state="translated">compile(files,options \\ []))</target>
        </trans-unit>
        <trans-unit id="364e2c894a558395743d27e00bd39cef2a1788b7" translate="yes" xml:space="preserve">
          <source>compile(pattern)</source>
          <target state="translated">compile(pattern)</target>
        </trans-unit>
        <trans-unit id="41a5b56e900391eaacfc800fc7bdda5db10d2f02" translate="yes" xml:space="preserve">
          <source>compile(source, options \\ &quot;&quot;)</source>
          <target state="translated">compile(source,options \\ &quot;&quot;)</target>
        </trans-unit>
        <trans-unit id="f6c48be9261dbb56924df9c068e1ebfa4f710025" translate="yes" xml:space="preserve">
          <source>compile_env!(app, key_or_path)</source>
          <target state="translated">compile_env!(app,key_or_path)</target>
        </trans-unit>
        <trans-unit id="303dce613bbc4fc422c273b2fed553b6ca713abd" translate="yes" xml:space="preserve">
          <source>compile_env(app, key_or_path, default \\ nil)</source>
          <target state="translated">compile_env(app,key_or_path,по умолчанию \\ nil)</target>
        </trans-unit>
        <trans-unit id="8752d3c6d962fc52de0488799eb1d1f367e82bbb" translate="yes" xml:space="preserve">
          <source>compile_file(file, relative_to \\ nil)</source>
          <target state="translated">compile_file(file,relative_to \\ nil)</target>
        </trans-unit>
        <trans-unit id="286b7f4b3b4d21e89ffd463d46f624d0f7fa3ffe" translate="yes" xml:space="preserve">
          <source>compile_file(filename, options \\ [])</source>
          <target state="translated">compile_file(имя файла,опции \\ []))</target>
        </trans-unit>
        <trans-unit id="f1ca4f378c23609b823bba9fbaeb5ae372112643" translate="yes" xml:space="preserve">
          <source>compile_path(config \\ config())</source>
          <target state="translated">compile_path(config \\ config()))</target>
        </trans-unit>
        <trans-unit id="6877fe6f402dd1870145026c15af85ae0959a568" translate="yes" xml:space="preserve">
          <source>compile_quoted(quoted, file \\ &quot;nofile&quot;)</source>
          <target state="translated">compile_quoted(цитата,файл \\ &quot;nofile&quot;))</target>
        </trans-unit>
        <trans-unit id="497d66512419f120dbd2b3672f9460d96b122232" translate="yes" xml:space="preserve">
          <source>compile_requirement(requirement)</source>
          <target state="translated">compile_requirement(requirement)</target>
        </trans-unit>
        <trans-unit id="c84ffc2b13f2af6829569aa80b18dee5d7a7510c" translate="yes" xml:space="preserve">
          <source>compile_string(source, options \\ [])</source>
          <target state="translated">compile_string(source,options \\ []))</target>
        </trans-unit>
        <trans-unit id="45d187142888814fa068577ec3360d51bf6aeaac" translate="yes" xml:space="preserve">
          <source>compile_string(string, file \\ &quot;nofile&quot;)</source>
          <target state="translated">compile_string(string,file \\ &quot;nofile&quot;))</target>
        </trans-unit>
        <trans-unit id="fb2ff017711a4ae6f2fdf2db967bd96a679030a2" translate="yes" xml:space="preserve">
          <source>compile_to_path (3)</source>
          <target state="translated">путь компиляции (3)</target>
        </trans-unit>
        <trans-unit id="27b2eea245bc63f4b74c2d8b4be895b4289df549" translate="yes" xml:space="preserve">
          <source>compile_to_path(files, path, options \\ [])</source>
          <target state="translated">compile_to_path(files,path,options \\ []))</target>
        </trans-unit>
        <trans-unit id="63277de6d69c5f9aad541b9ec3f789e8034e4bc4" translate="yes" xml:space="preserve">
          <source>compiled_endianness()</source>
          <target state="translated">compiled_endianness()</target>
        </trans-unit>
        <trans-unit id="2767c3af26cea7820de250a7de5ade3c3d1e2c81" translate="yes" xml:space="preserve">
          <source>compiler_options()</source>
          <target state="translated">compiler_options()</target>
        </trans-unit>
        <trans-unit id="252398d7a593b4d08a655ba826bccd955d572a55" translate="yes" xml:space="preserve">
          <source>compiler_options(opts)</source>
          <target state="translated">compiler_options(opts)</target>
        </trans-unit>
        <trans-unit id="1960356e2b2513d59967ebc737c60956d941201a" translate="yes" xml:space="preserve">
          <source>compilers()</source>
          <target state="translated">compilers()</target>
        </trans-unit>
        <trans-unit id="eb504cd4f9717f84fe64792ae65aea78748358fe" translate="yes" xml:space="preserve">
          <source>compilers(config \\ Mix.Project.config())</source>
          <target state="translated">компиляторы(config \\ Mix.Project.config()).</target>
        </trans-unit>
        <trans-unit id="710d47d23ac1620245831f9c23544ee718443325" translate="yes" xml:space="preserve">
          <source>concat(doc1, doc2)</source>
          <target state="translated">concat(doc1,doc2)</target>
        </trans-unit>
        <trans-unit id="cb8dfe2df97c88031bad219115e5e55ba69e843f" translate="yes" xml:space="preserve">
          <source>concat(docs)</source>
          <target state="translated">concat(docs)</target>
        </trans-unit>
        <trans-unit id="31ef39524c4f24c9607790c33c07230530b841e5" translate="yes" xml:space="preserve">
          <source>concat(enumerables)</source>
          <target state="translated">concat(enumerables)</target>
        </trans-unit>
        <trans-unit id="3276c0c91b62f624a1a2a9614165cae56ca5cca9" translate="yes" xml:space="preserve">
          <source>concat(first, second)</source>
          <target state="translated">конкат (первый,второй)</target>
        </trans-unit>
        <trans-unit id="dc6b4510c18288b6bd81ff643ebe9cbae8b7e431" translate="yes" xml:space="preserve">
          <source>concat(left, right)</source>
          <target state="translated">конкат (левый,правый)</target>
        </trans-unit>
        <trans-unit id="8738f1a46de327c249c39d2354c3739f4766c63c" translate="yes" xml:space="preserve">
          <source>concat(list)</source>
          <target state="translated">concat(list)</target>
        </trans-unit>
        <trans-unit id="e28b38305a6df66c6e877af629349f1bffb459c1" translate="yes" xml:space="preserve">
          <source>conceal()</source>
          <target state="translated">conceal()</target>
        </trans-unit>
        <trans-unit id="21193427161cce7037d66c2f58602ad0dffd4246" translate="yes" xml:space="preserve">
          <source>cond (1)</source>
          <target state="translated">конденсироваться (1)</target>
        </trans-unit>
        <trans-unit id="fda3d0abc0a657dad53979cf02e5d4c4602451da" translate="yes" xml:space="preserve">
          <source>cond(clauses)</source>
          <target state="translated">cond(clauses)</target>
        </trans-unit>
        <trans-unit id="c705b5c07e94e5b4ef420654932ee77cfc0d3039" translate="yes" xml:space="preserve">
          <source>config()</source>
          <target state="translated">config()</target>
        </trans-unit>
        <trans-unit id="268ada50ba28f4a1eb21673e04b67f33e9b7cc71" translate="yes" xml:space="preserve">
          <source>config(root_key, key, opts)</source>
          <target state="translated">config(root_key,ключ,опции)</target>
        </trans-unit>
        <trans-unit id="71e62d46143958bb12d0e8aca6d3fdef1c23c638" translate="yes" xml:space="preserve">
          <source>config(root_key, opts)</source>
          <target state="translated">config(root_key,опции)</target>
        </trans-unit>
        <trans-unit id="51db1b3ddad0a74ab91ca531fdeb54363cd27fe7" translate="yes" xml:space="preserve">
          <source>config/releases.exs</source>
          <target state="translated">config/releases.exs</target>
        </trans-unit>
        <trans-unit id="e015298b8d0b2f841459266534b58031dedad47c" translate="yes" xml:space="preserve">
          <source>config/runtime.exs</source>
          <target state="translated">config/runtime.exs</target>
        </trans-unit>
        <trans-unit id="d26d5d64eb4ec8b0b59fe22b26c6debaa459f470" translate="yes" xml:space="preserve">
          <source>config_change(changed, new, removed)</source>
          <target state="translated">config_change(изменён,новый,удалён)</target>
        </trans-unit>
        <trans-unit id="e759d58e97e2d521d7b86e35282c4e6a90129485" translate="yes" xml:space="preserve">
          <source>config_env()</source>
          <target state="translated">config_env()</target>
        </trans-unit>
        <trans-unit id="a2b49faf8bb6345054b26d8e0f6eda8ee34494ef" translate="yes" xml:space="preserve">
          <source>config_files()</source>
          <target state="translated">config_files()</target>
        </trans-unit>
        <trans-unit id="334194de3b6d2b09dd93cabd0a1ae6cf2b71dda9" translate="yes" xml:space="preserve">
          <source>config_mtime()</source>
          <target state="translated">config_mtime()</target>
        </trans-unit>
        <trans-unit id="df9a431584b9da726432a34c6513238a108a380c" translate="yes" xml:space="preserve">
          <source>config_path()</source>
          <target state="translated">config_path()</target>
        </trans-unit>
        <trans-unit id="1a0f66208141ef3785c141cef3b3b1667174cc96" translate="yes" xml:space="preserve">
          <source>config_target()</source>
          <target state="translated">config_target()</target>
        </trans-unit>
        <trans-unit id="f5d9470a017fdd49731d6a7be7af7facf824b125" translate="yes" xml:space="preserve">
          <source>configuration()</source>
          <target state="translated">configuration()</target>
        </trans-unit>
        <trans-unit id="efb487abbb5b37257c0df42bbc10e1e1a46011a2" translate="yes" xml:space="preserve">
          <source>configure(options)</source>
          <target state="translated">configure(options)</target>
        </trans-unit>
        <trans-unit id="93ff4e6cd0f004a518c2bf47b1b532396848878d" translate="yes" xml:space="preserve">
          <source>configure_backend(backend, options)</source>
          <target state="translated">configure_backend(backend,опции)</target>
        </trans-unit>
        <trans-unit id="213d01061c45d9975b4c0fc9b01bc8c57c303834" translate="yes" xml:space="preserve">
          <source>connect(node)</source>
          <target state="translated">connect(node)</target>
        </trans-unit>
        <trans-unit id="c37276e9cce99c780366ccdf92242c4c6b96a9b5" translate="yes" xml:space="preserve">
          <source>connect(port, pid)</source>
          <target state="translated">соединяться (порт,квитанция)</target>
        </trans-unit>
        <trans-unit id="bcc685f8d95aa026046ad75079206d7d7146d391" translate="yes" xml:space="preserve">
          <source>consolidate(protocol, types)</source>
          <target state="translated">консолидация (протокол,типы)</target>
        </trans-unit>
        <trans-unit id="7f54621345d31a80ef1c341951e3f6e125a5712e" translate="yes" xml:space="preserve">
          <source>consolidated?()</source>
          <target state="translated">consolidated?()</target>
        </trans-unit>
        <trans-unit id="ff9a3367bc5548931d607504f4135eea8b08e40e" translate="yes" xml:space="preserve">
          <source>consolidated?(protocol)</source>
          <target state="translated">consolidated?(protocol)</target>
        </trans-unit>
        <trans-unit id="3bcd211572f544f4bdf9b9136a1431b29996b7cc" translate="yes" xml:space="preserve">
          <source>consolidation_path(config \\ config())</source>
          <target state="translated">путь консолидации (config \\ config())</target>
        </trans-unit>
        <trans-unit id="71bb4d3af21fa15513fe9e968ea68f9d771b40f7" translate="yes" xml:space="preserve">
          <source>container()</source>
          <target state="translated">container()</target>
        </trans-unit>
        <trans-unit id="596b992138ecebae696f6a437a81ed9d874af3ab" translate="yes" xml:space="preserve">
          <source>container_doc(left, collection, right, inspect_opts, fun, opts \\ [])</source>
          <target state="translated">container_doc(слева,коллекция,справа,inspect_opts,fun,opts \\ []).</target>
        </trans-unit>
        <trans-unit id="00cc0ff8bc111a27033ad6d1937617686b746752" translate="yes" xml:space="preserve">
          <source>contains?(string, contents)</source>
          <target state="translated">содержит?(строка,содержимое)</target>
        </trans-unit>
        <trans-unit id="5648e41eade8e40602f4d057a18735bec5d5922d" translate="yes" xml:space="preserve">
          <source>contents(pid)</source>
          <target state="translated">contents(pid)</target>
        </trans-unit>
        <trans-unit id="433ddc2803d9550f1ebf4fc761e87912ccc4d23e" translate="yes" xml:space="preserve">
          <source>context()</source>
          <target state="translated">context()</target>
        </trans-unit>
        <trans-unit id="09fd5b57523755ba7fc5bb7ca2df3bd46996b34b" translate="yes" xml:space="preserve">
          <source>context_modules()</source>
          <target state="translated">context_modules()</target>
        </trans-unit>
        <trans-unit id="07bd0a836eee357f1aab122bbc4383a5366426fa" translate="yes" xml:space="preserve">
          <source>continuation()</source>
          <target state="translated">continuation()</target>
        </trans-unit>
        <trans-unit id="126a595f6a2cd3243001f2d487ff13caf328f459" translate="yes" xml:space="preserve">
          <source>continue()</source>
          <target state="translated">continue()</target>
        </trans-unit>
        <trans-unit id="dd69470ae4dfb70e8ea1c6c85819fb36678a004a" translate="yes" xml:space="preserve">
          <source>convert!(date, calendar)</source>
          <target state="translated">новообращённый!</target>
        </trans-unit>
        <trans-unit id="1c33b2df18e9ce88483eef3574c53b7b2793a893" translate="yes" xml:space="preserve">
          <source>convert!(datetime, calendar)</source>
          <target state="translated">конвертировать! (дата,календарь)</target>
        </trans-unit>
        <trans-unit id="1cf36367d8cfa4da26517918fca5c13a54055ea3" translate="yes" xml:space="preserve">
          <source>convert!(naive_datetime, calendar)</source>
          <target state="translated">convert!(naive_datetime,calendar)</target>
        </trans-unit>
        <trans-unit id="f361ec115139de246f84ce003f0b3350df7bf9bf" translate="yes" xml:space="preserve">
          <source>convert!(time, calendar)</source>
          <target state="translated">новообращённый!</target>
        </trans-unit>
        <trans-unit id="00249548daa360a253d43213898f3595b1380627" translate="yes" xml:space="preserve">
          <source>convert(date, calendar)</source>
          <target state="translated">конвертировать (дата,календарь)</target>
        </trans-unit>
        <trans-unit id="24a4224be3a1b2702d7906a4bdec40fde8da2338" translate="yes" xml:space="preserve">
          <source>convert(datetime, calendar)</source>
          <target state="translated">конвертировать (дата,календарь)</target>
        </trans-unit>
        <trans-unit id="c90f751301ad073cdedbd95e930098bb8a37e34d" translate="yes" xml:space="preserve">
          <source>convert(naive_datetime, calendar)</source>
          <target state="translated">convert(naive_datetime,calendar)</target>
        </trans-unit>
        <trans-unit id="b12620c26a1e588ccce13237c04766eaf29d6a92" translate="yes" xml:space="preserve">
          <source>convert(time, calendar)</source>
          <target state="translated">конвертировать (время,календарь)</target>
        </trans-unit>
        <trans-unit id="1a139b7fce5447f07932df782f28ef0dadff66e0" translate="yes" xml:space="preserve">
          <source>convert_time_unit(time, from_unit, to_unit)</source>
          <target state="translated">convert_time_unit(время,из_unit,в_unit)</target>
        </trans-unit>
        <trans-unit id="3fdc485611de36b2b58552046a35421cedd2f635" translate="yes" xml:space="preserve">
          <source>copy!(source, destination, bytes_count \\ :infinity)</source>
          <target state="translated">копировать!(исходник,назначение,байт_счет \\ :бесконечность)</target>
        </trans-unit>
        <trans-unit id="9d2b2ae9f27b1c6627226c7d6efd0249aeb20860" translate="yes" xml:space="preserve">
          <source>copy(source, destination, bytes_count \\ :infinity)</source>
          <target state="translated">copy(source,destination,bytes_count \\ :бесконечность)</target>
        </trans-unit>
        <trans-unit id="1a68165b62781ec34bacbe1ef426173c3717ecd2" translate="yes" xml:space="preserve">
          <source>copy-pasting examples from an actual IEx session</source>
          <target state="translated">примеры копирования-вставки с фактической сессии IEx</target>
        </trans-unit>
        <trans-unit id="724d254870fced440ecc49d74b8f5abec124d77f" translate="yes" xml:space="preserve">
          <source>copy_app(release, app)</source>
          <target state="translated">copy_app(release,app)</target>
        </trans-unit>
        <trans-unit id="f3f2eee0eb40ef8dd58abed3d9af883625491d03" translate="yes" xml:space="preserve">
          <source>copy_ebin(release, source, target)</source>
          <target state="translated">copy_ebin(release,source,target)</target>
        </trans-unit>
        <trans-unit id="f74077be47a32a41d05e4fbcce0c4d3fcedcc822" translate="yes" xml:space="preserve">
          <source>copy_erts(release)</source>
          <target state="translated">copy_erts(release)</target>
        </trans-unit>
        <trans-unit id="a318108f83fea601444b36f1ad279a77a11d1a6d" translate="yes" xml:space="preserve">
          <source>copy_file(source, target, options \\ [])</source>
          <target state="translated">copy_file(source,target,options \\ []).</target>
        </trans-unit>
        <trans-unit id="f067038472780451c43b896122952fbf3ec88c4e" translate="yes" xml:space="preserve">
          <source>copy_template(source, target, assigns, options \\ [])</source>
          <target state="translated">copy_template(source,target,assignns,options \\ []).</target>
        </trans-unit>
        <trans-unit id="510f4da65709e40b6e2377ff99043570e2cb21ac" translate="yes" xml:space="preserve">
          <source>count(enumerable)</source>
          <target state="translated">count(enumerable)</target>
        </trans-unit>
        <trans-unit id="41403e7108da2b83f6233e2925d1ecbc9d1d24bd" translate="yes" xml:space="preserve">
          <source>count(enumerable, fun)</source>
          <target state="translated">счёт (бесчисленное количество,веселье)</target>
        </trans-unit>
        <trans-unit id="77675952b2d35edf5199701da8c50f1de5849bfc" translate="yes" xml:space="preserve">
          <source>count(registry)</source>
          <target state="translated">count(registry)</target>
        </trans-unit>
        <trans-unit id="3f70f3f02e3ec05efaa371be1d1ee5fb89d411d2" translate="yes" xml:space="preserve">
          <source>count_children(supervisor)</source>
          <target state="translated">count_children(supervisor)</target>
        </trans-unit>
        <trans-unit id="106fd67d7e3392da728be9f3f591e924444a38b0" translate="yes" xml:space="preserve">
          <source>count_match(registry, key, pattern, guards \\ [])</source>
          <target state="translated">count_match(реестр,ключ,шаблон,охрана \\ [])</target>
        </trans-unit>
        <trans-unit id="d14ed526880066adf9b34846d90fce34b50463ac" translate="yes" xml:space="preserve">
          <source>cp!(source_file, destination_file, callback \\ fn _, _ -&amp;gt; true end)</source>
          <target state="translated">cp! (исходный_файл, целевой_файл, обратный вызов \\ fn _, _ -&amp;gt; истинный конец)</target>
        </trans-unit>
        <trans-unit id="8f1c0f03a48a96edab09cab7eb911681304a1b3a" translate="yes" xml:space="preserve">
          <source>cp(source_file, destination_file, callback \\ fn _, _ -&amp;gt; true end)</source>
          <target state="translated">cp (исходный_файл, целевой_файл, обратный вызов \\ fn _, _ -&amp;gt; истинный конец)</target>
        </trans-unit>
        <trans-unit id="55b89c9f961030862db10ad8f6370e0b1e0827a4" translate="yes" xml:space="preserve">
          <source>cp_r!(source, destination, callback \\ fn _, _ -&amp;gt; true end)</source>
          <target state="translated">cp_r! (источник, назначение, обратный вызов \\ fn _, _ -&amp;gt; истинный конец)</target>
        </trans-unit>
        <trans-unit id="089921e8c3e0d9e1d5f4d924e0fc755653c5c45f" translate="yes" xml:space="preserve">
          <source>cp_r(source, destination, callback \\ fn _, _ -&amp;gt; true end)</source>
          <target state="translated">cp_r (источник, назначение, обратный вызов \\ fn _, _ -&amp;gt; истинный конец)</target>
        </trans-unit>
        <trans-unit id="23c9856582871a341c880734d6bc4316b9bb11ee" translate="yes" xml:space="preserve">
          <source>create(module, quoted, opts)</source>
          <target state="translated">create(модуль,цитата,опция)</target>
        </trans-unit>
        <trans-unit id="6f96ec48552897af742463e79a3d9775a3879156" translate="yes" xml:space="preserve">
          <source>create_directory(path, options \\ [])</source>
          <target state="translated">create_directory(path,options \\ []))</target>
        </trans-unit>
        <trans-unit id="abb87426594a8964e76711cbff5303edf6b8d790" translate="yes" xml:space="preserve">
          <source>create_file(path, contents, opts \\ [])</source>
          <target state="translated">create_file(путь,содержимое,параметры \\ []).</target>
        </trans-unit>
        <trans-unit id="985a15b7ec5ba4bbfb7028de21fbcff164ff0a89" translate="yes" xml:space="preserve">
          <source>critical(message_or_fun, metadata \\ [])</source>
          <target state="translated">critical(message_or_fun,metadata \\ [])</target>
        </trans-unit>
        <trans-unit id="4933c87b83e35f8b169757195c9e0da68eeccecd" translate="yes" xml:space="preserve">
          <source>crossed_out()</source>
          <target state="translated">crossed_out()</target>
        </trans-unit>
        <trans-unit id="b120e7151cbb5c37886a4601d5af6ca3571b2105" translate="yes" xml:space="preserve">
          <source>cursor(line, column)</source>
          <target state="translated">курсор (строка,столбец)</target>
        </trans-unit>
        <trans-unit id="973f6b9a7b781c09f1b240bb5ec68f6e9fe8097b" translate="yes" xml:space="preserve">
          <source>cursor_down(lines \\ 1)</source>
          <target state="translated">курсор_вниз(строки \\ 1)</target>
        </trans-unit>
        <trans-unit id="5496e3bf5bb4f4a7fb6071821ac9f62e9de14717" translate="yes" xml:space="preserve">
          <source>cursor_left(columns \\ 1)</source>
          <target state="translated">курсор_лево (столбцы \\ 1)</target>
        </trans-unit>
        <trans-unit id="81d9c99d50d61b77cee0688531d5ef10e2f9c0cb" translate="yes" xml:space="preserve">
          <source>cursor_right(columns \\ 1)</source>
          <target state="translated">курсор_right(колонки \\ 1)</target>
        </trans-unit>
        <trans-unit id="1c636366056e3f831eac233d5c56acac20ee3ea7" translate="yes" xml:space="preserve">
          <source>cursor_up(lines \\ 1)</source>
          <target state="translated">курсор_up(строки \\ 1)</target>
        </trans-unit>
        <trans-unit id="09ff08dd77395796bb431e765c2f3c54a365a235" translate="yes" xml:space="preserve">
          <source>custom guards can also be defined with &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#defguard/1&quot;&gt;&lt;code&gt;defguard/1&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#defguardp/1&quot;&gt;&lt;code&gt;defguardp/1&lt;/code&gt;&lt;/a&gt;. A custom guard can only be defined based on existing guards.</source>
          <target state="translated">пользовательские охранники также могут быть определены с помощью &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#defguard/1&quot;&gt; &lt;code&gt;defguard/1&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#defguardp/1&quot;&gt; &lt;code&gt;defguardp/1&lt;/code&gt; &lt;/a&gt; . Пользовательская защита может быть определена только на основе существующих охранников.</target>
        </trans-unit>
        <trans-unit id="dbed36184f87c8a60d6aa495d972b885ec4ecdfb" translate="yes" xml:space="preserve">
          <source>custom guards can also be defined with &lt;a href=&quot;kernel#defguard/1&quot;&gt;&lt;code&gt;defguard/1&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;kernel#defguardp/1&quot;&gt;&lt;code&gt;defguardp/1&lt;/code&gt;&lt;/a&gt;. A custom guard is always defined based on existing guards.</source>
          <target state="translated">пользовательские охранники также могут быть определены с помощью &lt;a href=&quot;kernel#defguard/1&quot;&gt; &lt;code&gt;defguard/1&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;kernel#defguardp/1&quot;&gt; &lt;code&gt;defguardp/1&lt;/code&gt; &lt;/a&gt; . Специальная защита всегда определяется на основе существующих охранников.</target>
        </trans-unit>
        <trans-unit id="59bd063262df86f1347fd1defe3b3a54024b3731" translate="yes" xml:space="preserve">
          <source>cwd!()</source>
          <target state="translated">cwd!()</target>
        </trans-unit>
        <trans-unit id="713621dce13a750b5cd39abe3f02112fa07b49f2" translate="yes" xml:space="preserve">
          <source>cwd()</source>
          <target state="translated">cwd()</target>
        </trans-unit>
        <trans-unit id="24208fa51359a68fed648c19fdab612baab71c2d" translate="yes" xml:space="preserve">
          <source>cyan()</source>
          <target state="translated">cyan()</target>
        </trans-unit>
        <trans-unit id="ec0527bf7bda19ab4423f6573f06d6ac2d7ffaf0" translate="yes" xml:space="preserve">
          <source>cyan_background()</source>
          <target state="translated">cyan_background()</target>
        </trans-unit>
        <trans-unit id="f1e6cf5bb8f26538d2c0c032bae10490bb0491dc" translate="yes" xml:space="preserve">
          <source>cycle(enumerable)</source>
          <target state="translated">cycle(enumerable)</target>
        </trans-unit>
        <trans-unit id="3c363836cf4e16666669a25da280a1865c2d2874" translate="yes" xml:space="preserve">
          <source>d</source>
          <target state="translated">d</target>
        </trans-unit>
        <trans-unit id="6d4d58d23a4acf486318e8b2edcd07953f7e3a1f" translate="yes" xml:space="preserve">
          <source>date()</source>
          <target state="translated">date()</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
