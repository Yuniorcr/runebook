<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="sqlite">
    <body>
      <group id="sqlite">
        <trans-unit id="e5c2df06ba96ff92a5b489615f6b10abd3bf147f" translate="yes" xml:space="preserve">
          <source>N&lt;sub&gt;&lt;small&gt;left&lt;/small&gt;&lt;/sub&gt;&amp;times;N&lt;sub&gt;&lt;small&gt;right&lt;/small&gt;&lt;/sub&gt;</source>
          <target state="translated">N&lt;sub&gt;&lt;small&gt;left&lt;/small&gt;&lt;/sub&gt;&amp;times;N&lt;sub&gt;&lt;small&gt;right&lt;/small&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="2c0a1bee57f9f58fc50d516a0bf15f88caa7689c" translate="yes" xml:space="preserve">
          <source>N&lt;sub&gt;&lt;small&gt;right&lt;/small&gt;&lt;/sub&gt;</source>
          <target state="translated">N&lt;sub&gt;&lt;small&gt;right&lt;/small&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="a9d371451b6909ac85117130b9153a96499a362c" translate="yes" xml:space="preserve">
          <source>NAME</source>
          <target state="translated">NAME</target>
        </trans-unit>
        <trans-unit id="5b0ac1bba3d09af88af51314ab9e3274563ae94b" translate="yes" xml:space="preserve">
          <source>NATIVE CHARACTER(70)</source>
          <target state="translated">РОДНОЙ СИМВОЛ(70)</target>
        </trans-unit>
        <trans-unit id="7b0c42d6ea58612c19c7961351b229254674e033" translate="yes" xml:space="preserve">
          <source>NATURAL</source>
          <target state="translated">NATURAL</target>
        </trans-unit>
        <trans-unit id="ea1a1d896196c614eb971163bd79e6b0f3ccbe73" translate="yes" xml:space="preserve">
          <source>NB: This extension is deprecated. [WAL mode] is recommended as a replacement.</source>
          <target state="translated">NB:Это расширение устарело.В качестве замены рекомендуется [режим WAL].</target>
        </trans-unit>
        <trans-unit id="9829174ea4702c19a86b2f2d0ae072ffd5bcdee0" translate="yes" xml:space="preserve">
          <source>NCHAR(55)</source>
          <target state="translated">NCHAR(55)</target>
        </trans-unit>
        <trans-unit id="b7fe5d20802ca2aca87db42d4b7dae9f148c0ed7" translate="yes" xml:space="preserve">
          <source>NEAR queries</source>
          <target state="translated">запросы NEAR</target>
        </trans-unit>
        <trans-unit id="ad140e1560939f826df416c1e0d8f81eaa5dd26a" translate="yes" xml:space="preserve">
          <source>NEAR queries are not available.</source>
          <target state="translated">Запросы NEAR недоступны.</target>
        </trans-unit>
        <trans-unit id="9bbceb6fd3a09583f532267c802c583270b6ed37" translate="yes" xml:space="preserve">
          <source>NEVER(X)</source>
          <target state="translated">NEVER(X)</target>
        </trans-unit>
        <trans-unit id="97b77dd54bade796fe382680ffda0d54d204b7ea" translate="yes" xml:space="preserve">
          <source>NEW and OLD references are valid</source>
          <target state="translated">Действительны НОВЫЕ и СТАРШИЕ ссылки</target>
        </trans-unit>
        <trans-unit id="a82d81a38474e7a2f1b05be86c3d0ec157924da9" translate="yes" xml:space="preserve">
          <source>NEW references are valid</source>
          <target state="translated">Действительны НОВЫЕ ссылки</target>
        </trans-unit>
        <trans-unit id="aa7b193ecb5f5e8127c45d86d672c669b4ad311a" translate="yes" xml:space="preserve">
          <source>NNN</source>
          <target state="translated">NNN</target>
        </trans-unit>
        <trans-unit id="cf99bc0053e83f8041fe548005de7972be838e08" translate="yes" xml:space="preserve">
          <source>NNN days</source>
          <target state="translated">NNN дни</target>
        </trans-unit>
        <trans-unit id="33c4ffa6e43390375c0bf9b4e04eedef73776044" translate="yes" xml:space="preserve">
          <source>NNN hours</source>
          <target state="translated">NNN часы</target>
        </trans-unit>
        <trans-unit id="4dc2b6e588bcda89bc862d480bc0a6894df9769a" translate="yes" xml:space="preserve">
          <source>NNN minutes</source>
          <target state="translated">NNN минут</target>
        </trans-unit>
        <trans-unit id="bf0082b4c02bd0d30ff30874661f393df82750f4" translate="yes" xml:space="preserve">
          <source>NNN months</source>
          <target state="translated">NNN месяцы</target>
        </trans-unit>
        <trans-unit id="afb2dbb2fb0e9adb5cd092d7e7b6d3ffb78523de" translate="yes" xml:space="preserve">
          <source>NNN years</source>
          <target state="translated">NNN годы</target>
        </trans-unit>
        <trans-unit id="b58c197b751c5ed1962a3c0390de8c10bb4951b3" translate="yes" xml:space="preserve">
          <source>NNN.NNNN seconds</source>
          <target state="translated">NNNN.NNNN секунд</target>
        </trans-unit>
        <trans-unit id="a0509b7780628bd9d9abc7eb8a2163477341053a" translate="yes" xml:space="preserve">
          <source>NO</source>
          <target state="translated">NO</target>
        </trans-unit>
        <trans-unit id="05fdd36e7692e52033451b07ec66dff9eb7e55c8" translate="yes" xml:space="preserve">
          <source>NOCASE</source>
          <target state="translated">NOCASE</target>
        </trans-unit>
        <trans-unit id="0654a028e5aea48c8fbb09871b8f397a186c883b" translate="yes" xml:space="preserve">
          <source>NONE</source>
          <target state="translated">NONE</target>
        </trans-unit>
        <trans-unit id="969e7d8dee132181523a501a068fec75bded3005" translate="yes" xml:space="preserve">
          <source>NOT</source>
          <target state="translated">NOT</target>
        </trans-unit>
        <trans-unit id="13e8b0dd0b366e8464e50db4ffa83a38db17f5c0" translate="yes" xml:space="preserve">
          <source>NOT EXISTS operator</source>
          <target state="translated">НЕ ВЫПАДАЕТ оператор</target>
        </trans-unit>
        <trans-unit id="c251201ede2fa823c20c38c57254fd75c17ce421" translate="yes" xml:space="preserve">
          <source>NOT IN operator</source>
          <target state="translated">НЕ В СЛУЧАЕ НЕОБХОДИМОСТИ</target>
        </trans-unit>
        <trans-unit id="f4a4efddb03a7d76572898f7eabe1ea34a780b2f" translate="yes" xml:space="preserve">
          <source>NOT NULL constraint</source>
          <target state="translated">НЕ НУЛЬШЕЕ ограничение</target>
        </trans-unit>
        <trans-unit id="6ff7e3eeee65666114a7a3854176937e0d8c1522" translate="yes" xml:space="preserve">
          <source>NOT NULL constraints are honored.</source>
          <target state="translated">НЕ НУЛЬШИЕ ограничения соблюдаются.</target>
        </trans-unit>
        <trans-unit id="c462e8fc3e502ae6d5489c34ffa0054b7073578f" translate="yes" xml:space="preserve">
          <source>NOTHING</source>
          <target state="translated">NOTHING</target>
        </trans-unit>
        <trans-unit id="d6a7f5abac5bd9faa0bac9e8bb7907ab9f614941" translate="yes" xml:space="preserve">
          <source>NOTNULL</source>
          <target state="translated">NOTNULL</target>
        </trans-unit>
        <trans-unit id="545dacd66301f165f41f75a11471135695f4dede" translate="yes" xml:space="preserve">
          <source>NUL Characters In Strings</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4771b572fc1de8c483abeb1a95a1bc516fa56a87" translate="yes" xml:space="preserve">
          <source>NUL characters (ASCII code 0x00 and Unicode \u0000) may appear in the middle of strings in SQLite. This can lead to unexpected behavior. See the &quot;&lt;a href=&quot;nulinstr&quot;&gt;NUL characters in strings&lt;/a&gt;&quot; document for further information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eef19c54306daa69eda49c0272623bdb5e2b341f" translate="yes" xml:space="preserve">
          <source>NULL</source>
          <target state="translated">NULL</target>
        </trans-unit>
        <trans-unit id="0d475d854a2a7eeffd82e1a01f92ca65e566328f" translate="yes" xml:space="preserve">
          <source>NULL Handling in SQLite</source>
          <target state="translated">NULL-обработка в SQLite</target>
        </trans-unit>
        <trans-unit id="7fac7bb3c1a767adbbac557d34135fb142c688ca" translate="yes" xml:space="preserve">
          <source>NULL Handling in SQLite Versus Other Database Engines</source>
          <target state="translated">NULL-обработка в SQLite против других двигателей баз данных</target>
        </trans-unit>
        <trans-unit id="248ab3abcb099e69f2fef53b64e651576012c852" translate="yes" xml:space="preserve">
          <source>NULL values (serial type 0) sort first.</source>
          <target state="translated">NULL-значения (последовательный тип 0)сортируются первыми.</target>
        </trans-unit>
        <trans-unit id="a1efa1e3b6119cae6664d71bdefea57f479d6ebf" translate="yes" xml:space="preserve">
          <source>NULL values are now reported to the callback as a NULL pointer rather than an empty string.</source>
          <target state="translated">NULL-значения теперь сообщаются в обратном вызове как NULL указатель,а не как пустая строка.</target>
        </trans-unit>
        <trans-unit id="743ef19013396d7d94a24cacbb830235275be9c8" translate="yes" xml:space="preserve">
          <source>NULLS</source>
          <target state="translated">NULLS</target>
        </trans-unit>
        <trans-unit id="fc81819cf87d3384597c4ae67d1976d82323a9b0" translate="yes" xml:space="preserve">
          <source>NULLS LAST</source>
          <target state="translated">ПОСЛЕДНИЙ</target>
        </trans-unit>
        <trans-unit id="8280c934b3178b2afed2c01f955aab5fe7295999" translate="yes" xml:space="preserve">
          <source>NULLs sort first</source>
          <target state="translated">NULLs сортируются первыми</target>
        </trans-unit>
        <trans-unit id="58ad270de77802cc63222e273fa800c4b248cdd7" translate="yes" xml:space="preserve">
          <source>NUMERIC</source>
          <target state="translated">NUMERIC</target>
        </trans-unit>
        <trans-unit id="024959fd2d5e8c9c205a2098591019699ae29143" translate="yes" xml:space="preserve">
          <source>NVARCHAR(100)</source>
          <target state="translated">NVARCHAR(100)</target>
        </trans-unit>
        <trans-unit id="709a23220f2c3d64d1e1d6d18c4d5280f8d82fca" translate="yes" xml:space="preserve">
          <source>Name</source>
          <target state="translated">Name</target>
        </trans-unit>
        <trans-unit id="daa5b774be0bfcbd2e2835e6bd0980fb6e06778a" translate="yes" xml:space="preserve">
          <source>Name Of A Host Parameter</source>
          <target state="translated">Имя параметра хозяина</target>
        </trans-unit>
        <trans-unit id="cb9e33f6b09bb7fe5d38a783b74c6905b2f43077" translate="yes" xml:space="preserve">
          <source>Name Of The Folder Holding Database Files</source>
          <target state="translated">Имя файла базы данных,хранящегося в папке</target>
        </trans-unit>
        <trans-unit id="7749c218b18b42cbe27f3f870da40b8d3d708ba1" translate="yes" xml:space="preserve">
          <source>Name Of The Folder Holding Temporary Files</source>
          <target state="translated">Имя папки,хранящей временные файлы</target>
        </trans-unit>
        <trans-unit id="fbb9c33e0412f25c0e798fd22a36fd452bd92012" translate="yes" xml:space="preserve">
          <source>Name of default collation sequence</source>
          <target state="translated">Имя последовательности сверки по умолчанию</target>
        </trans-unit>
        <trans-unit id="4e3a9de996d9196b59f293d51cf53aa5b2a8a36e" translate="yes" xml:space="preserve">
          <source>Named window-defn clauses may also be added to a SELECT statement using a WINDOW clause and then referred to by name within window function invocations. For example, the following SELECT statement contains two named window-defs clauses, &quot;win1&quot; and &quot;win2&quot;:</source>
          <target state="translated">Именованные клаузулы window-defn также могут быть добавлены в оператор SELECT с помощью клаузулы WINDOW,а затем на них можно ссылаться по имени в вызовах оконных функций.Например,следующий оператор SELECT содержит два именованных пункта windows-defs-&quot;win1&quot; и &quot;win2&quot;:</target>
        </trans-unit>
        <trans-unit id="02aead4c6c683a05b1c0ebf7ea825cf0f6d1b06c" translate="yes" xml:space="preserve">
          <source>Naming Changes</source>
          <target state="translated">Изменения в наименовании</target>
        </trans-unit>
        <trans-unit id="f736bf35e196e5f8a2152cf612783a7b401c2cad" translate="yes" xml:space="preserve">
          <source>Ne</source>
          <target state="translated">Ne</target>
        </trans-unit>
        <trans-unit id="28477357de69f5526193889fda40ed45cd101a03" translate="yes" xml:space="preserve">
          <source>Nearly all systems have the ability to call libraries written in C. This is not true of other implementation languages.</source>
          <target state="translated">Почти все системы имеют возможность вызывать библиотеки,написанные на C.Это не относится к другим языкам реализации.</target>
        </trans-unit>
        <trans-unit id="a37e5d1459b64bbf0f387b130668f0c8c4924e69" translate="yes" xml:space="preserve">
          <source>Negative numbers in the &quot;.width&quot; command cause right-alignment</source>
          <target state="translated">Отрицательные числа в команде &quot;.width&quot; вызывают выравнивание вправо.</target>
        </trans-unit>
        <trans-unit id="fec37acea6ebcef8454c4fc958c0b8f34d2b8c80" translate="yes" xml:space="preserve">
          <source>Nested transactions using &lt;a href=&quot;lang_savepoint&quot;&gt;SAVEPOINT&lt;/a&gt;, &lt;a href=&quot;lang_savepoint&quot;&gt;RELEASE&lt;/a&gt;, and &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK TO&lt;/a&gt;</source>
          <target state="translated">Вложенные транзакции с использованием &lt;a href=&quot;lang_savepoint&quot;&gt;SAVEPOINT&lt;/a&gt; , &lt;a href=&quot;lang_savepoint&quot;&gt;RELEASE&lt;/a&gt; и &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK TO&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9c791dcaae3666d9984fccf3b99d9aec11d78e88" translate="yes" xml:space="preserve">
          <source>Never despair of God's mercy.</source>
          <target state="translated">Никогда не отчаивайся от милости Божьей.</target>
        </trans-unit>
        <trans-unit id="56cdefb3df5828b1fdbe0c79de688ed68de09460" translate="yes" xml:space="preserve">
          <source>Never tag an application-defined SQL function with &lt;a href=&quot;c3ref/c_deterministic#sqliteinnocuous&quot;&gt;SQLITE_INNOCUOUS&lt;/a&gt; unless you really need to and you have checked the implementation closely and are certain that it can do no harm even if it falls under the control of an attacker.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb1f0a8ca1cbcde19e25e6a553a1aa4154cf9c78" translate="yes" xml:space="preserve">
          <source>Nevertheless, application developers are admonished to monitor the state of the memory allocation subsystems and raise alarms when memory usage approaches or exceeds Robson limits. In this way, the application will provide operators with abundant warning well in advance of failure. The &lt;a href=&quot;malloc#memstatus&quot;&gt;memory statistics&lt;/a&gt; interfaces of SQLite provide the application with all the mechanism necessary to complete the monitoring portion of this task.</source>
          <target state="translated">Тем не менее, разработчикам приложений рекомендуется отслеживать состояние подсистем распределения памяти и подавать сигналы тревоги, когда использование памяти приближается к пределам Робсона или превышает их. Таким образом, приложение будет предоставлять операторам подробные предупреждения задолго до сбоя. Интерфейсы &lt;a href=&quot;malloc#memstatus&quot;&gt;статистики памяти&lt;/a&gt; SQLite предоставляют приложению все механизмы, необходимые для выполнения части мониторинга этой задачи.</target>
        </trans-unit>
        <trans-unit id="b14d2dd89e46e860f7449a61cc79bde67323500f" translate="yes" xml:space="preserve">
          <source>Nevertheless, bugs happen. If you are writing an application that sends untrusted SQL inputs or database files to SQLite, there are additional steps you can take to help reduce the attack surface and prevent zero-day exploits caused by undetected bugs.</source>
          <target state="translated">Тем не менее,жуки случаются.Если вы пишете приложение,которое посылает недоверенные SQL входы или файлы базы данных на SQLite,есть дополнительные шаги,которые помогут уменьшить поверхность атаки и предотвратить эксплойты нулевого дня,вызванные необнаруженными ошибками.</target>
        </trans-unit>
        <trans-unit id="fe8f48a38c1ee2d5e1ec0b569c50eb0f4be22e0d" translate="yes" xml:space="preserve">
          <source>Nevertheless, integer overflow in the computation of memory allocation sizes is a concern that SQLite would like to deal with. To prevent problems, all SQLite internal memory allocations occur using thin wrapper functions that take a signed 64-bit integer size parameter. The SQLite source code is audited to ensure that all size computations are carried out using 64-bit signed integers as well. SQLite will refuse to allocate more than about 2GB of memory at one go. (In common use, SQLite seldom ever allocates more than about 8KB of memory at a time so a 2GB allocation limit is not a burden.) So the 64-bit size parameter provides lots of headroom for detecting overflows. The same audit that verifies that all size computations are done as 64-bit signed integers also verifies that it is impossible to overflow a 64-bit integer during the computation.</source>
          <target state="translated">Тем не менее,целочисленное переполнение при вычислении размеров выделения памяти является проблемой,с которой SQLite хотел бы иметь дело.Для предотвращения проблем все выделения внутренней памяти SQLite происходят с использованием тонких оберточных функций,которые принимают знаковый 64-битный целочисленный параметр размера.Исходный код SQLite проверяется на предмет того,что все вычисления размера выполняются и с использованием 64-битных подписанных целых чисел.SQLite откажется выделять более 2 Гб памяти за один раз.(Обычно SQLite редко выделяет более 8 КБ памяти за один раз,поэтому лимит выделения 2 ГБ не является обузой).Таким образом,параметр 64-битного размера предоставляет много места для обнаружения переполнений.Тот же самый аудит,который проверяет,что все вычисления размера выполняются в виде 64-битных подписанных целых чисел,также проверяет невозможность переполнения 64-битного целого при вычислении.</target>
        </trans-unit>
        <trans-unit id="e49fc674e296beca34786edd4c2b299863546a78" translate="yes" xml:space="preserve">
          <source>Nevertheless, no software is 100% perfect. There have been a few historical bugs in SQLite (now fixed) that could cause database corruption. And there may be yet a few more that remain undiscovered. Because of the extensive testing and widespread use of SQLite, bugs that result in database corruption tend to be very obscure. The likelihood of an application encountering an SQLite bug is small. To illustrate this, an account is given below of all database-corruption bugs found in SQLite during the four-year period from 2009-04-01 to 2013-04-15. This account should give the reader an intuitive sense of the kinds of bugs in SQLite that manage to slip through testing procedures and make it into a release.</source>
          <target state="translated">Тем не менее,ни одно программное обеспечение не идеально на 100%.В SQLite было несколько исторических ошибок (теперь исправлено),которые могли привести к повреждению базы данных.И,возможно,есть еще несколько,которые остаются нераскрытыми.Из-за обширного тестирования и широкого использования SQLite,ошибки,которые приводят к повреждению базы данных,как правило,очень малоизвестны.Вероятность того,что приложение столкнется с ошибкой SQLite,невелика.Чтобы проиллюстрировать это,ниже приведен аккаунт всех ошибок,связанных с коррупцией баз данных,обнаруженных в SQLite за четырехлетний период с 2009-04-01 по 2013-04-15 гг.Этот аккаунт должен дать читателю интуитивное представление о том,какие ошибки в SQLite удается проскользнуть через процедуры тестирования и превратить его в релиз.</target>
        </trans-unit>
        <trans-unit id="0116882452ef2d4b8e1293a906b669874cb29ba7" translate="yes" xml:space="preserve">
          <source>New &lt;a href=&quot;compile#omitfeatures&quot;&gt;SQLITE_OMIT_...&lt;/a&gt; compile-time options added</source>
          <target state="translated">&lt;a href=&quot;compile#omitfeatures&quot;&gt;Добавлены&lt;/a&gt; новые параметры времени компиляции SQLITE_OMIT _...</target>
        </trans-unit>
        <trans-unit id="75836f6f6b6f280ffed2e7c97c8de38d49f8b36b" translate="yes" xml:space="preserve">
          <source>New Change</source>
          <target state="translated">Новое изменение</target>
        </trans-unit>
        <trans-unit id="519eb3711af9fb8ce8d81cf7983b569f9b988fc0" translate="yes" xml:space="preserve">
          <source>New File Format</source>
          <target state="translated">Новый формат файла</target>
        </trans-unit>
        <trans-unit id="05a025f4bcdcce620e0b66e603b7b96a2aa62567" translate="yes" xml:space="preserve">
          <source>New HH:MM:SS modifier to the built-in date/time functions.</source>
          <target state="translated">Новый модификатор HH:MM:SS для встроенных функций даты/времени.</target>
        </trans-unit>
        <trans-unit id="35afb195f0b01edb4e7140e0f143cfa5913617eb" translate="yes" xml:space="preserve">
          <source>New VFSes are registered with sqlite3_vfs_register(). Each new VFS becomes the default VFS if the makeDflt flag is set. The same VFS can be registered multiple times without injury. To make an existing VFS into the default VFS, register it again with the makeDflt flag set. If two different VFSes with the same name are registered, the behavior is undefined. If a VFS is registered with a name that is NULL or an empty string, then the behavior is undefined.</source>
          <target state="translated">Новые VFSes регистрируются функцией sqlite3_vfs_register().Каждая новая VFS становится VFS по умолчанию,если установлен флаг makeDflt.Одна и та же VFS может быть зарегистрирована несколько раз без повреждений.Чтобы превратить существующую VFS в VFS по умолчанию,зарегистрируйте ее снова с установленным флагом makeDflt.Если зарегистрированы две разные VFS с одним и тем же именем,поведение будет неопределенным.Если VFS регистрируется с именем NULL или пустой строкой,поведение будет неопределенным.</target>
        </trans-unit>
        <trans-unit id="9e6d8977d2335274bf96388fe98628d1d0b7e083" translate="yes" xml:space="preserve">
          <source>New applications should always invoke &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; instead of &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt;. The older &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; is retained for backwards compatibility. But &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; provides a much better interface.</source>
          <target state="translated">Новые приложения всегда должны вызывать &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; вместо &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare ()&lt;/a&gt; . Более старый &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare ()&lt;/a&gt; сохранен для обратной совместимости. Но &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; предоставляет гораздо лучший интерфейс.</target>
        </trans-unit>
        <trans-unit id="741f30a581517ffe6e7dcd8b6f50643914279724" translate="yes" xml:space="preserve">
          <source>New configuration options may be added in future releases of SQLite. Existing configuration options might be discontinued. Applications should check the return code from &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config()&lt;/a&gt; to make sure that the call worked. The &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config()&lt;/a&gt; interface will return a non-zero &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; if a discontinued or unsupported configuration option is invoked.</source>
          <target state="translated">В будущих выпусках SQLite могут быть добавлены новые параметры конфигурации. Существующие параметры конфигурации могут быть прекращены. Приложения должны проверить код возврата из &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config (),&lt;/a&gt; чтобы убедиться, что вызов сработал. Интерфейс &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config ()&lt;/a&gt; вернет ненулевой &lt;a href=&quot;rescode&quot;&gt;код ошибки,&lt;/a&gt; если вызывается неподдерживаемый или неподдерживаемый параметр конфигурации.</target>
        </trans-unit>
        <trans-unit id="dfd7ca29d835fc9c4dbb0540c0bcc6f89fdaa393" translate="yes" xml:space="preserve">
          <source>New configuration options may be added in future releases of SQLite. Existing configuration options might be discontinued. Applications should check the return code from &lt;a href=&quot;#sqlite3_db_config&quot;&gt;sqlite3_db_config()&lt;/a&gt; to make sure that the call worked. The &lt;a href=&quot;#sqlite3_db_config&quot;&gt;sqlite3_db_config()&lt;/a&gt; interface will return a non-zero &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; if a discontinued or unsupported configuration option is invoked.</source>
          <target state="translated">В будущих выпусках SQLite могут быть добавлены новые параметры конфигурации. Существующие параметры конфигурации могут быть прекращены. Приложения должны проверить код возврата из &lt;a href=&quot;#sqlite3_db_config&quot;&gt;sqlite3_db_config (),&lt;/a&gt; чтобы убедиться, что вызов сработал. Интерфейс &lt;a href=&quot;#sqlite3_db_config&quot;&gt;sqlite3_db_config ()&lt;/a&gt; вернет ненулевой &lt;a href=&quot;rescode&quot;&gt;код ошибки,&lt;/a&gt; если вызывается неподдерживаемый или неподдерживаемый параметр конфигурации.</target>
        </trans-unit>
        <trans-unit id="290c5a063c07711b910fa8250f0c45e5e6c8d5a9" translate="yes" xml:space="preserve">
          <source>New configuration options may be added in future releases of SQLite. Existing configuration options might be discontinued. Applications should check the return code from &lt;a href=&quot;config&quot;&gt;sqlite3_config()&lt;/a&gt; to make sure that the call worked. The &lt;a href=&quot;config&quot;&gt;sqlite3_config()&lt;/a&gt; interface will return a non-zero &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; if a discontinued or unsupported configuration option is invoked.</source>
          <target state="translated">В будущих выпусках SQLite могут быть добавлены новые параметры конфигурации. Существующие параметры конфигурации могут быть прекращены. Приложения должны проверить код возврата из &lt;a href=&quot;config&quot;&gt;sqlite3_config (),&lt;/a&gt; чтобы убедиться, что вызов сработал. Интерфейс &lt;a href=&quot;config&quot;&gt;sqlite3_config ()&lt;/a&gt; вернет ненулевой &lt;a href=&quot;../rescode&quot;&gt;код ошибки,&lt;/a&gt; если вызывается неподдерживаемый или неподдерживаемый параметр конфигурации.</target>
        </trans-unit>
        <trans-unit id="bef0fe1db7b5b12623a7cb6dd11860448e032b3e" translate="yes" xml:space="preserve">
          <source>New configuration options may be added in future releases of SQLite. Existing configuration options might be discontinued. Applications should check the return code from &lt;a href=&quot;db_config&quot;&gt;sqlite3_db_config()&lt;/a&gt; to make sure that the call worked. The &lt;a href=&quot;db_config&quot;&gt;sqlite3_db_config()&lt;/a&gt; interface will return a non-zero &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; if a discontinued or unsupported configuration option is invoked.</source>
          <target state="translated">В будущих выпусках SQLite могут быть добавлены новые параметры конфигурации. Существующие параметры конфигурации могут быть прекращены. Приложения должны проверить код возврата из &lt;a href=&quot;db_config&quot;&gt;sqlite3_db_config (),&lt;/a&gt; чтобы убедиться, что вызов сработал. Интерфейс &lt;a href=&quot;db_config&quot;&gt;sqlite3_db_config ()&lt;/a&gt; вернет ненулевой &lt;a href=&quot;../rescode&quot;&gt;код ошибки,&lt;/a&gt; если вызывается неподдерживаемый или неподдерживаемый параметр конфигурации.</target>
        </trans-unit>
        <trans-unit id="b448decebb78010dbfebbde65087fb4a352a7ae8" translate="yes" xml:space="preserve">
          <source>New database files created by SQLite use format 4 by default. The &lt;a href=&quot;pragma#pragma_legacy_file_format&quot;&gt;legacy_file_format pragma&lt;/a&gt; can be used to cause SQLite to create new database files using format 1. The format version number can be made to default to 1 instead of 4 by setting &lt;a href=&quot;compile#default_file_format&quot;&gt;SQLITE_DEFAULT_FILE_FORMAT&lt;/a&gt;=1 at compile-time.</source>
          <target state="translated">Новые файлы базы данных, созданные SQLite, по умолчанию используют формат 4. &lt;a href=&quot;pragma#pragma_legacy_file_format&quot;&gt;Legacy_file_format прагма&lt;/a&gt; может быть использован , чтобы вызвать SQLite для создания новых файлов базы данных с использованием формата 1. Формат номера версии можно по умолчанию 1 вместо 4, установив &lt;a href=&quot;compile#default_file_format&quot;&gt;SQLITE_DEFAULT_FILE_FORMAT&lt;/a&gt; = 1 во время компиляции.</target>
        </trans-unit>
        <trans-unit id="7fae2a2a8fa480fb532533df6e47c596e4029933" translate="yes" xml:space="preserve">
          <source>New error codes may be added in future versions of SQLite.</source>
          <target state="translated">Новые коды ошибок могут быть добавлены в будущие версии SQLite.</target>
        </trans-unit>
        <trans-unit id="02a2eef012a8248fed2ec4a5f4418e441dee6267" translate="yes" xml:space="preserve">
          <source>New extensions:</source>
          <target state="translated">Новые расширения:</target>
        </trans-unit>
        <trans-unit id="c375e60e4ec3e7a7421f6f6fc9277a408ea2286e" translate="yes" xml:space="preserve">
          <source>New file format that is 25% to 35% smaller for typical use.</source>
          <target state="translated">Новый формат файла,который на 25%-35% меньше для типичного использования.</target>
        </trans-unit>
        <trans-unit id="fd04fa0f053215d42b7f8b539b38e361266bd4c9" translate="yes" xml:space="preserve">
          <source>New flags may be added in future releases of SQLite.</source>
          <target state="translated">Новые флаги могут быть добавлены в будущих релизах SQLite.</target>
        </trans-unit>
        <trans-unit id="609f25b82bb11b34abf866257917b5188d15ee70" translate="yes" xml:space="preserve">
          <source>New interface &lt;a href=&quot;c3ref/context_db_handle&quot;&gt;sqlite3_context_db_handle()&lt;/a&gt; that returns the &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; handle that has invoked an application-defined SQL function.</source>
          <target state="translated">Новый интерфейс &lt;a href=&quot;c3ref/context_db_handle&quot;&gt;sqlite3_context_db_handle (),&lt;/a&gt; который возвращает дескриптор &lt;a href=&quot;c3ref/sqlite3&quot;&gt;соединения&lt;/a&gt; с базой данных , который вызвал определяемую приложением функцию SQL.</target>
        </trans-unit>
        <trans-unit id="97e454a0ee0ddbdb1207081ac8f340c9145f813d" translate="yes" xml:space="preserve">
          <source>New interface &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit()&lt;/a&gt; allows size and length limits to be set on a per-connection basis and at run-time.</source>
          <target state="translated">Новый интерфейс &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit ()&lt;/a&gt; позволяет устанавливать ограничения размера и длины для каждого соединения и во время выполнения.</target>
        </trans-unit>
        <trans-unit id="351a6ce815b5dd18ffcf850d512cce2a33e3cd28" translate="yes" xml:space="preserve">
          <source>New interface: sqlite3_bind_parameter_index()</source>
          <target state="translated">Новый интерфейс:sqlite3_bind_parameter_index()</target>
        </trans-unit>
        <trans-unit id="ff421fae0557a39a0bd809f33195e163ee4bb7ae" translate="yes" xml:space="preserve">
          <source>New interfaces added to the test_quota.c add-on module.</source>
          <target state="translated">В дополнение к test_quota.c добавлены новые интерфейсы.</target>
        </trans-unit>
        <trans-unit id="ae3613412d28080958e2d37e217b087b523b9aae" translate="yes" xml:space="preserve">
          <source>New internal schema objects names, always beginning with &quot;sqlite_&quot;, may be added to the SQLite file format in future releases.</source>
          <target state="translated">Новые имена внутренних объектов схемы,всегда начинающиеся с &quot;sqlite_&quot;,могут быть добавлены в формат файла SQLite в будущих релизах.</target>
        </trans-unit>
        <trans-unit id="26bcef71ccfa90b2e0cbb123ce577eb05e69bad7" translate="yes" xml:space="preserve">
          <source>New memory allocators do not have to be part of the SQLite source tree nor included in the sqlite3.c &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt;. Individual applications can supply their own memory allocators to SQLite at start-time.</source>
          <target state="translated">Новые распределители памяти не обязательно должны быть частью дерева исходных текстов SQLite или включаться в &lt;a href=&quot;amalgamation&quot;&gt;объединение&lt;/a&gt; sqlite3.c . Отдельные приложения могут предоставлять свои собственные распределители памяти для SQLite во время запуска.</target>
        </trans-unit>
        <trans-unit id="5e4800161f51168ad45c54c49952a916eb4c7f5a" translate="yes" xml:space="preserve">
          <source>New options to the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; for configuring auxiliary memory usage: --pagecache, --lookaside, and --scratch.</source>
          <target state="translated">Новые параметры &lt;a href=&quot;cli&quot;&gt;оболочки командной строки&lt;/a&gt; для настройки использования вспомогательной памяти: --pagecache, --lookaside и --scratch.</target>
        </trans-unit>
        <trans-unit id="33b435c4ed8f9927e4700fe7e7aeadeae900e749" translate="yes" xml:space="preserve">
          <source>New query optimizations:</source>
          <target state="translated">Новые оптимизации запросов:</target>
        </trans-unit>
        <trans-unit id="27a96e272ba4064e97b901622de6fb30f7bc2a07" translate="yes" xml:space="preserve">
          <source>New run-time limit categories may be added in future releases.</source>
          <target state="translated">В будущих релизах могут быть добавлены новые категории ограничений по времени исполнения.</target>
        </trans-unit>
        <trans-unit id="aa7ba8a90d79e3949a9a92f1f6dd6361b3924b13" translate="yes" xml:space="preserve">
          <source>New status parameters may be added from time to time.</source>
          <target state="translated">Время от времени могут добавляться новые параметры состояния.</target>
        </trans-unit>
        <trans-unit id="8001d5465bcc215e617045ec61b342b4c0fbe511" translate="yes" xml:space="preserve">
          <source>New tests added to the test suite.</source>
          <target state="translated">В набор тестов добавлены новые тесты.</target>
        </trans-unit>
        <trans-unit id="19df796618ecb880621a1ff2386886f64457fe9e" translate="yes" xml:space="preserve">
          <source>New text tokens may be added to the end of the stat column in future enhancements to SQLite. For compatibility, unrecognized tokens at the end of the stat column are silently ignored.</source>
          <target state="translated">Новые текстовые маркеры могут быть добавлены в конец колонки &quot;Статистика&quot; в будущих улучшениях SQLite.Для совместимости непризнанные маркеры в конце колонки stat игнорируются.</target>
        </trans-unit>
        <trans-unit id="d23050a62d4b2ebb32c827e3e8678911cb996090" translate="yes" xml:space="preserve">
          <source>New tracing constants may be added in future releases.</source>
          <target state="translated">В будущих выпусках могут быть добавлены новые константы трассировки.</target>
        </trans-unit>
        <trans-unit id="8ec81cf9bf3ff78a39346bf7439447032b8bc32c" translate="yes" xml:space="preserve">
          <source>New verbs may be added in future releases of SQLite. Existing verbs might be discontinued. Applications should check the return code from &lt;a href=&quot;#sqlite3_db_status&quot;&gt;sqlite3_db_status()&lt;/a&gt; to make sure that the call worked. The &lt;a href=&quot;#sqlite3_db_status&quot;&gt;sqlite3_db_status()&lt;/a&gt; interface will return a non-zero error code if a discontinued or unsupported verb is invoked.</source>
          <target state="translated">В будущих выпусках SQLite могут быть добавлены новые команды. Существующие глаголы могут быть прекращены. Приложения должны проверить код возврата от &lt;a href=&quot;#sqlite3_db_status&quot;&gt;sqlite3_db_status (),&lt;/a&gt; чтобы убедиться, что вызов сработал. Интерфейс &lt;a href=&quot;#sqlite3_db_status&quot;&gt;sqlite3_db_status ()&lt;/a&gt; вернет ненулевой код ошибки, если вызывается прекращенная или неподдерживаемая команда.</target>
        </trans-unit>
        <trans-unit id="6997236519e17b29acb8e0c21015208012814bff" translate="yes" xml:space="preserve">
          <source>New verbs may be added in future releases of SQLite. Existing verbs might be discontinued. Applications should check the return code from &lt;a href=&quot;db_status&quot;&gt;sqlite3_db_status()&lt;/a&gt; to make sure that the call worked. The &lt;a href=&quot;db_status&quot;&gt;sqlite3_db_status()&lt;/a&gt; interface will return a non-zero error code if a discontinued or unsupported verb is invoked.</source>
          <target state="translated">В будущих выпусках SQLite могут быть добавлены новые команды. Существующие глаголы могут быть прекращены. Приложения должны проверить код возврата от &lt;a href=&quot;db_status&quot;&gt;sqlite3_db_status (),&lt;/a&gt; чтобы убедиться, что вызов сработал. Интерфейс &lt;a href=&quot;db_status&quot;&gt;sqlite3_db_status ()&lt;/a&gt; вернет ненулевой код ошибки, если вызывается прекращенная или неподдерживаемая команда.</target>
        </trans-unit>
        <trans-unit id="b162b6ee72989cc021180a9aa2d3a7a0e2b57826" translate="yes" xml:space="preserve">
          <source>New zip archives may be constructed entirely within memory using the zipfile() aggregate function. Each row visited by the aggregate function adds an entry to the zip archive. The value returned is a blob containing the entire archive image.</source>
          <target state="translated">Новые zip-архивы могут быть построены полностью в памяти с помощью функции-агрегатора zipfile().Каждая строка,которую посещает агрегатная функция,добавляет запись в zip-архив.Возвращаемое значение представляет собой блок,содержащий весь образ архива.</target>
        </trans-unit>
        <trans-unit id="e327377c14f6ddd81b93544df605d7203e2995e8" translate="yes" xml:space="preserve">
          <source>NewRowid</source>
          <target state="translated">NewRowid</target>
        </trans-unit>
        <trans-unit id="6975bed1eebd03a852e5aa6a11d0f144cd34ff6e" translate="yes" xml:space="preserve">
          <source>Newer disk drives have begun using 4096 byte sectors however. Beginning with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_10.html&quot;&gt;version 3.7.10&lt;/a&gt; (2012-01-16), the SQLite development team experimented with changes xSectorSize to report 4096 bytes as the blast radius. This had the effect of increasing write overhead on many databases. For a database with a &lt;a href=&quot;pragma#pragma_page_size&quot;&gt;PRAGMA page_size&lt;/a&gt; of 1024 (a very common choice) making a change to a single page in the database now requires SQLite to backup three other adjacent pages to the rollback journal, whereas formerly it only had to backup the one page that was changing. In &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt;, each transaction had to be padded out to the next 4096-byte boundary in the WAL file, rather than the next 512-byte boundary, resulting in thousands of extra bytes being written per transaction.</source>
          <target state="translated">Однако более новые диски начали использовать сектора размером 4096 байт. Начиная с &lt;a href=&quot;https://sqlite.org/releaselog/3_7_10.html&quot;&gt;версии&lt;/a&gt; SQLite 3.7.10 (16 января 2012 г. ), команда разработчиков SQLite экспериментировала с изменениями xSectorSize, чтобы указать 4096 байт как радиус взрыва. Это привело к увеличению накладных расходов на запись во многих базах данных. Для базы данных с &lt;a href=&quot;pragma#pragma_page_size&quot;&gt;PRAGMA page_size равным&lt;/a&gt; 1024 (очень распространенный выбор) для внесения изменений на одну страницу в базе данных теперь требуется, чтобы SQLite сделал резервную копию трех других соседних страниц в журнале отката, тогда как раньше требовалось резервное копирование только одной страницы, которая менялось. В &lt;a href=&quot;wal&quot;&gt;режиме WAL&lt;/a&gt; каждая транзакция должна была быть дополнена до следующей границы в 4096 байт в файле WAL, а не до следующей границы в 512 байт, в результате на каждую транзакцию записывались тысячи дополнительных байтов.</target>
        </trans-unit>
        <trans-unit id="bc981983e7f547dc62e19a1e383acfe00782a6d5" translate="yes" xml:space="preserve">
          <source>Next</source>
          <target state="translated">Next</target>
        </trans-unit>
        <trans-unit id="bc1189b8a3e7e2b908b403ea79a8eb14b14bcd47" translate="yes" xml:space="preserve">
          <source>Next, make copies of all the blobs into individual files in a directory using a command like this:</source>
          <target state="translated">Далее,сделайте копии всех блоков в отдельные файлы в каталоге с помощью такой команды:</target>
        </trans-unit>
        <trans-unit id="73f7cfb7746314674a12b8d200b36135947e050b" translate="yes" xml:space="preserve">
          <source>Next, move the resulting kvtest-android executable to the Android device:</source>
          <target state="translated">Далее переместите полученный исполняемый файл kvtest-android на Android-устройство:</target>
        </trans-unit>
        <trans-unit id="21d2b394790e7b47b83f7c9d1daa6c55ee3c0c16" translate="yes" xml:space="preserve">
          <source>Next, suppose that you want to look up the price of not just any orange, but specifically California-grown oranges. The appropriate query would be as follows:</source>
          <target state="translated">Далее,предположим,что вы хотите посмотреть цену не просто на любой апельсин,а именно на выращенные в Калифорнии апельсины.Соответствующий запрос будет выглядеть следующим образом:</target>
        </trans-unit>
        <trans-unit id="816c52fd2bdd94a63cd0944823a6c0aa9384c103" translate="yes" xml:space="preserve">
          <source>No</source>
          <target state="translated">No</target>
        </trans-unit>
        <trans-unit id="dad2991d263e4aa51578f91e92e9777428d9762b" translate="yes" xml:space="preserve">
          <source>No (Note 1)</source>
          <target state="translated">Нет (Примечание 1)</target>
        </trans-unit>
        <trans-unit id="b4f66722cbcf69861e819a02ca8d6803b779fcd3" translate="yes" xml:space="preserve">
          <source>No Isolation Between Operations On The Same Database Connection</source>
          <target state="translated">Нет изоляции между операциями при одном и том же подключении к базе данных.</target>
        </trans-unit>
        <trans-unit id="8dae863821cb04b5484c9a0e7717d726d350b9bd" translate="yes" xml:space="preserve">
          <source>No application file I/O code to write and debug.</source>
          <target state="translated">Нет кода входа/выхода из файла приложения для написания и отладки.</target>
        </trans-unit>
        <trans-unit id="95ec05297c8cafc96feb998f4af109f4728d5530" translate="yes" xml:space="preserve">
          <source>No change</source>
          <target state="translated">Без изменений</target>
        </trans-unit>
        <trans-unit id="7f2ff41fbbf4963dea6c3e81c6aa743e95c596b5" translate="yes" xml:space="preserve">
          <source>No current or conflicting row information is provided. The only function it is possible to call on the supplied sqlite3_changeset_iter handle is sqlite3changeset_fk_conflicts().</source>
          <target state="translated">Никакой текущей или противоречивой информации о строках не предоставляется.Единственная функция,которую можно вызвать на поставляемом дескрипторе sqlite3_changeset_iter-sqlite3changeset_fk_conflicts().</target>
        </trans-unit>
        <trans-unit id="7c5c383086cc31c41ab2122a84d0a48706ccfc11" translate="yes" xml:space="preserve">
          <source>No error is raised if a width or precision exceeds SQLITE_PRINTF_PRECISION_LIMIT. Instead, the large width or precision is silently truncated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="662adfcee595804e0d0a40f3427892366f101024" translate="yes" xml:space="preserve">
          <source>No error messages are generated if an unknown pragma is issued. Unknown pragmas are simply ignored. This means if there is a typo in a pragma statement the library does not inform the user of the fact.</source>
          <target state="translated">Сообщения об ошибках не выдаются,если выдается неизвестная прагма.Неизвестные прагмы просто игнорируются.Это означает,что если в прагматическом высказывании есть опечатка,библиотека не информирует пользователя об этом факте.</target>
        </trans-unit>
        <trans-unit id="36386488a9bfa58ff6f23801ec174053b73ed777" translate="yes" xml:space="preserve">
          <source>No locking style. If none of the above can be supported, this locking style is used. No database locking mechanism is used. When this system is used it is not safe for a single database to be accessed by multiple clients.</source>
          <target state="translated">Никакого стиля блокировки.Если ни один из вышеперечисленных способов не поддерживается,используется этот стиль блокировки.Механизм блокировки БД не используется.При использовании этой системы обращение к одной БД для нескольких клиентов небезопасно.</target>
        </trans-unit>
        <trans-unit id="7b15426333f8adb77f306aae95c84b204b379d14" translate="yes" xml:space="preserve">
          <source>No locks are held on the database. The database may be neither read nor written. Any internally cached data is considered suspect and subject to verification against the database file before being used. Other processes can read or write the database as their own locking states permit. This is the default state.</source>
          <target state="translated">В базе данных нет замков.База данных не может быть ни прочитана,ни записана.Любые внутренние кэшированные данные считаются подозрительными и подлежат проверке по файлу базы данных перед использованием.Другие процессы могут читать или записывать БД,если позволяют их собственные состояния блокировки.Это состояние по умолчанию.</target>
        </trans-unit>
        <trans-unit id="589cdf57b87436c5bbc074aa5e48b70f3f3363e1" translate="yes" xml:space="preserve">
          <source>No longer in use.</source>
          <target state="translated">Больше не используется.</target>
        </trans-unit>
        <trans-unit id="7375825a734eee4acde64dd3de9ae4b6f89db26c" translate="yes" xml:space="preserve">
          <source>No longer used.</source>
          <target state="translated">Больше не используется.</target>
        </trans-unit>
        <trans-unit id="1cff8c4990053d03c141cc08cc6f740585898fb6" translate="yes" xml:space="preserve">
          <source>No one is required to follow The Rule, to know The Rule, or even to think that The Rule is a good idea. The Founder of SQLite believes that anyone who follows The Rule will live a happier and more productive life, but individuals are free to dispute or ignore that advice if they wish.</source>
          <target state="translated">Никто не обязан следовать Правилам,знать Правила или даже думать,что Правила-это хорошая идея.Основатель SQLite считает,что каждый,кто следует Правилам,будет жить более счастливой и продуктивной жизнью,но люди могут свободно спорить или игнорировать эти советы,если захотят.</target>
        </trans-unit>
        <trans-unit id="a4226fa0e8cf6311cf2613fee3e52c99bd81b607" translate="yes" xml:space="preserve">
          <source>No other processes can change the database so there is never a need to check the change counter and clear the user-space cache at the beginning of a transaction.</source>
          <target state="translated">Никакие другие процессы не могут изменить базу данных,поэтому нет необходимости проверять счетчик изменений и очищать кэш пользовательского пространства в начале транзакции.</target>
        </trans-unit>
        <trans-unit id="6b5b494aee4d1b7c43eaf07044f46f3778af61cd" translate="yes" xml:space="preserve">
          <source>No other writes may occur on the target database while the RBU update is being applied. A read-lock is held on the target database to prevent this.</source>
          <target state="translated">Во время обновления RBU в целевой базе данных не может происходить никаких других записей.Для предотвращения этого в целевой базе данных удерживается блокировка чтения.</target>
        </trans-unit>
        <trans-unit id="3943b575617ba52cb8729616c676b13dc34b8e79" translate="yes" xml:space="preserve">
          <source>No reads or writes occur except within a transaction. Any command that accesses the database (basically, any SQL command, except a few &lt;a href=&quot;pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt; statements) will automatically start a transaction if one is not already in effect. Automatically started transactions are committed when the last SQL statement finishes.</source>
          <target state="translated">Никаких операций чтения или записи не происходит, кроме как внутри транзакции. Любая команда, которая обращается к базе данных (в основном, любая команда SQL, кроме нескольких операторов &lt;a href=&quot;pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt; ), автоматически запускает транзакцию, если она еще не действует. Автоматически запущенные транзакции фиксируются после завершения последнего оператора SQL.</target>
        </trans-unit>
        <trans-unit id="2a9bc5ebe3cc4eba5a484c518ae347f8a47ccd50" translate="yes" xml:space="preserve">
          <source>No table in a union-vtab may contain entries that are outside of the rowid bounds established by the</source>
          <target state="translated">Ни одна из таблиц в профсоюзной записной книжке не может содержать записи,выходящие за пределы рядовых границ,установленных в</target>
        </trans-unit>
        <trans-unit id="7d5b25b567984a7a4091e940273bfff96cd2fed3" translate="yes" xml:space="preserve">
          <source>No. When you delete information from an SQLite database, the unused disk space is added to an internal &quot;free-list&quot; and is reused the next time you insert data. The disk space is not lost. But neither is it returned to the operating system.</source>
          <target state="translated">Нет.Когда вы удаляете информацию из базы данных SQLite,неиспользованное дисковое пространство добавляется во внутренний &quot;свободный список&quot; и при следующем вводе данных используется повторно.Дисковое пространство не теряется.Но и оно не возвращается в операционную систему.</target>
        </trans-unit>
        <trans-unit id="d4e9f5ef9057ec35a6f3d638ab0a7b961dadfa79" translate="yes" xml:space="preserve">
          <source>NoConflict</source>
          <target state="translated">NoConflict</target>
        </trans-unit>
        <trans-unit id="66290ce3e3466df1560e431a1eebe9e205ef9f1e" translate="yes" xml:space="preserve">
          <source>Non-ASCII range characters (i.e. unicode codepoints greater than 127), or</source>
          <target state="translated">Символы,не относящиеся к диапазону ASCII (т.е.кодовые точки юникода больше 127),или</target>
        </trans-unit>
        <trans-unit id="1bc1387523b6d25784112f80a2990511e6a57420" translate="yes" xml:space="preserve">
          <source>Non-Vista Windows platforms only support one set of DST rules. Vista only supports two. Therefore, on these platforms, historical DST calculations will be incorrect. For example, in the US, in 2007 the DST rules changed. Non-Vista Windows platforms apply the new 2007 DST rules to all previous years as well. Vista does somewhat better getting results correct back to 1986, when the rules were also changed.</source>
          <target state="translated">Платформы не для Windows Vista поддерживают только один набор правил DST.Vista поддерживает только два.Поэтому на этих платформах исторические вычисления DST будут некорректны.Например,в США в 2007 году изменились правила DST.Платформы Non-Vista Windows также применяют новые 2007 DST правила ко всем предыдущим годам.Vista делает несколько лучше,получая корректные результаты еще в 1986 году,когда правила тоже были изменены.</target>
        </trans-unit>
        <trans-unit id="b1b833538f0549b7c8aca0acf47c1aa5ac7f2fac" translate="yes" xml:space="preserve">
          <source>Non-deterministic functions might give different answers on each invocation, even if the arguments are always the same. The following are examples of non-deterministic functions:</source>
          <target state="translated">Недетерминистические функции могут давать разные ответы на каждый вызов,даже если аргументы всегда одни и те же.Ниже приведены примеры недетерминистических функций:</target>
        </trans-unit>
        <trans-unit id="cf3ad9f318d5d17809c32f85aa54a78cb4cda991" translate="yes" xml:space="preserve">
          <source>Non-streaming equivalent</source>
          <target state="translated">Непотоковый эквивалент</target>
        </trans-unit>
        <trans-unit id="1d0d5248c3c8dbbb61313817bba98f17697e01b6" translate="yes" xml:space="preserve">
          <source>Non-streaming functions that accept changesets (or patchsets) as input require that the entire changeset be stored in a single buffer in memory. Similarly, those that return a changeset or patchset do so by returning a pointer to a single large buffer allocated using sqlite3_malloc(). Normally this is convenient. However, if an application running in a low-memory environment is required to handle very large changesets, the large contiguous memory allocations required can become onerous.</source>
          <target state="translated">Непотоковые функции,которые принимают наборы изменений (или патч-сеты)в качестве входных,требуют,чтобы весь набор изменений хранился в одном буфере в памяти.Аналогичным образом,те,кто возвращает changeset или patchset,делают это,возвращая указатель на один большой буфер,выделенный с помощью sqlite3_malloc().Обычно это удобно.Однако,если приложению,работающему в среде с низкой памятью,необходимо обрабатывать очень большие changeset'ы,то требуемое большое последовательное выделение памяти может стать обременительным.</target>
        </trans-unit>
        <trans-unit id="09f7070838a5d668002d389cd9b3fec752e6c30d" translate="yes" xml:space="preserve">
          <source>None of the safe programming languages existed for the first 10 years of SQLite's existence. SQLite could be recoded in Go or Rust, but doing so would probably introduce far more bugs than would be fixed, and it seems also likely to result in slower code.</source>
          <target state="translated">За первые 10 лет существования SQLite не существовало ни одного безопасного языка программирования.SQLite можно было бы перекодировать в Go или Rust,но это,скорее всего,привело бы к появлению гораздо большего количества ошибок,чем было бы исправлено,а также,похоже,привело бы к замедлению работы кода.</target>
        </trans-unit>
        <trans-unit id="9b9f34e057f76ac2b419477d464548015d8ef844" translate="yes" xml:space="preserve">
          <source>None of the xSavepoint(), xRelease(), or xRollbackTo() methods will ever be called except in between calls to xBegin() and either xCommit() or xRollback().</source>
          <target state="translated">Ни один из методов xSavepoint(),xRelease()или xRollbackTo()никогда не будет вызван,кроме как между вызовами xBegin()и либо xCommit(),либо xRollback().</target>
        </trans-unit>
        <trans-unit id="a1fe0caa1d6e9f3e9dd7087ae4f2a9ea810cd170" translate="yes" xml:space="preserve">
          <source>Noop</source>
          <target state="translated">Noop</target>
        </trans-unit>
        <trans-unit id="2bbfb9d52741dbc3a4ff03abc70ca82cb8e2f1bc" translate="yes" xml:space="preserve">
          <source>Normal functions specify only xFunc and leave xStep and xFinal set to NULL. Aggregate functions specify xStep and xFinal and leave xFunc set to NULL. There is no separate sqlite3_create_aggregate() API.</source>
          <target state="translated">Нормальные функции указывают только xFunc и оставляют xStep и xFinal set в NULL.Функции агрегирования указывают xStep и xFinal и оставляют xFunc установлено в NULL.Отдельного API sqlite3_create_aggregate()нет.</target>
        </trans-unit>
        <trans-unit id="8feff5d8988d2d3b3f82fe7920cdb81d5ba04e3a" translate="yes" xml:space="preserve">
          <source>Normal meaning</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e304219719d389c0ea46b9c98590f2134fb67330" translate="yes" xml:space="preserve">
          <source>Normally, FTS5 maintains a special backing table within the database that stores the size of each column value in tokens inserted into the main FTS5 table in a separate table. This backing table is used by the &lt;a href=&quot;#xColumnSize&quot;&gt;xColumnSize&lt;/a&gt;&lt;a&gt; API function, which is in turn used by the built-in &lt;/a&gt;&lt;a href=&quot;fts5#the_bm25_function&quot;&gt;bm25 ranking function&lt;/a&gt; (and is likely to be useful to other ranking functions as well).</source>
          <target state="translated">Обычно FTS5 поддерживает специальную вспомогательную таблицу в базе данных, в которой размер каждого значения столбца в токенах, вставленных в основную таблицу FTS5, хранится в отдельной таблице. Эта &lt;a href=&quot;#xColumnSize&quot;&gt;вспомогательная&lt;/a&gt; таблица используется функцией &lt;a&gt;API &lt;/a&gt;xColumnSize , которая, в свою очередь, используется встроенной &lt;a href=&quot;fts5#the_bm25_function&quot;&gt;функцией ранжирования bm25&lt;/a&gt; (и, вероятно, также будет полезна для других функций ранжирования).</target>
        </trans-unit>
        <trans-unit id="866b49d7e3deb743a545b4433375afa6debe3327" translate="yes" xml:space="preserve">
          <source>Normally, NULL SQL results are stored in the array using the &lt;a href=&quot;#nullvalue&quot;&gt;nullvalue&lt;/a&gt; setting. However, if the &lt;b&gt;-withoutnulls&lt;/b&gt; option is used, then NULL SQL values cause the corresponding array element to be unset instead.</source>
          <target state="translated">Обычно результаты NULL SQL сохраняются в массиве с использованием значения &lt;a href=&quot;#nullvalue&quot;&gt;NULL&lt;/a&gt; . Однако, если используется опция &lt;b&gt;-withoutnulls&lt;/b&gt; , тогда значения NULL SQL заставляют вместо этого сбрасывать соответствующий элемент массива.</target>
        </trans-unit>
        <trans-unit id="d1f5712d735a4022fc9c1482cc2c46055815935d" translate="yes" xml:space="preserve">
          <source>Normally, SQLite assumes that if a power failure occurs while updating any portion of a sector then the contents of the entire device sector is suspect following recovery. After writing to any part of a sector within a file, it is assumed that the modified sector contents are held in a volatile buffer somewhere within the system (main memory, disk cache etc.). SQLite does not assume that the updated data has reached the persistent storage media, until after it has successfully</source>
          <target state="translated">Обычно SQLite предполагает,что если при обновлении любой части сектора происходит сбой электропитания,то после восстановления возникает подозрение на содержимое всего сектора устройства.После записи в любую часть сектора в файле предполагается,что содержимое измененного сектора хранится в переменном буфере где-то в системе (основная память,дисковый кэш и т.д.).SQLite не предполагает,что обновленные данные попали на постоянный носитель,до тех пор,пока не будет успешно восстановлено</target>
        </trans-unit>
        <trans-unit id="e5b528fefcff05064efc30021e7a7579eaaad4d2" translate="yes" xml:space="preserve">
          <source>Normally, a token or token prefix query is matched against the FTS table column specified as the left-hand side of the MATCH operator. Or, if the special column with the same name as the FTS table itself is specified, against all columns. This may be overridden by specifying a column-name followed by a &quot;:&quot; character before a basic term query. There may be space between the &quot;:&quot; and the term to query for, but not between the column-name and the &quot;:&quot; character. For example:</source>
          <target state="translated">Обычно запрос на токен или префикс токена сопоставляется со столбцом таблицы FTS,указанным в качестве левой стороны MATCH-оператора.Или,если указан специальный столбец с тем же именем,что и сама таблица FTS,против всех столбцов.Это может быть отменено путем указания имени столбца с последующим символом &quot;:&quot; перед запросом на основной термин.Между &quot;:&quot; и термином,в отношении которого осуществляется запрос,может быть пробел,но не пробел между именем столбца и символом &quot;:&quot;.Например:</target>
        </trans-unit>
        <trans-unit id="bf4491e66772ed8b491e6908438d7924fa774545" translate="yes" xml:space="preserve">
          <source>Normally, an SQL index references columns of a table. But an index can also be formed on expressions involving table columns.</source>
          <target state="translated">Обычно SQL-индекс ссылается на столбцы таблицы.Но индекс также может быть сформирован на выражениях,включающих столбцы таблицы.</target>
        </trans-unit>
        <trans-unit id="39e8cea13d3d48550994e6ce4ac623d3130ee592" translate="yes" xml:space="preserve">
          <source>Normally, fossil will modify all the files in your checkout when switching between the private and the public branches. But at this point, the files are identical in both branches so not modifications need to be made.</source>
          <target state="translated">Обычно при переключении между частным и государственным секторами ископаемые изменяют все файлы,находящиеся в вашей кассе.Но на данный момент файлы идентичны в обеих ветках,поэтому модификаций делать не нужно.</target>
        </trans-unit>
        <trans-unit id="d3d92a3c721eaacd534b06f545203c90c257b9b9" translate="yes" xml:space="preserve">
          <source>Normally, full-text queries are case-insensitive. However, this is dependent on the specific &lt;a href=&quot;fts3#tokenizer&quot;&gt;tokenizer&lt;/a&gt; used by the FTS table being queried. Refer to the section on &lt;a href=&quot;fts3#tokenizer&quot;&gt;tokenizers&lt;/a&gt; for details.</source>
          <target state="translated">Обычно в полнотекстовых запросах регистр не учитывается. Однако это зависит от конкретного &lt;a href=&quot;fts3#tokenizer&quot;&gt;токенизатора,&lt;/a&gt; используемого запрашиваемой таблицей FTS. Подробности см. В разделе &lt;a href=&quot;fts3#tokenizer&quot;&gt;токенизаторов&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="63e53b72fdcc0af9b1c300c26469b45178a485e4" translate="yes" xml:space="preserve">
          <source>Normally, the FTS module maintains an inverted index of all terms in all columns of the table. This option is used to specify the name of a column for which entries should not be added to the index. Multiple &quot;notindexed&quot; options may be used to specify that multiple columns should be omitted from the index. For example:</source>
          <target state="translated">Обычно модуль FTS поддерживает инвертированный индекс всех терминов во всех столбцах таблицы.Эта опция используется для указания названия столбца,для которого не следует добавлять записи в индекс.Можно использовать несколько опций &quot;неиндексировать&quot;,чтобы указать,что из индекса следует исключить несколько столбцов.Например:</target>
        </trans-unit>
        <trans-unit id="ebe2262110ee72155bb934332e4fc5587e66a440" translate="yes" xml:space="preserve">
          <source>Normally, the database &lt;a href=&quot;pragma#pragma_page_size&quot;&gt;page_size&lt;/a&gt; and whether or not the database supports &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum&lt;/a&gt; must be configured before the database file is actually created. However, when not in &lt;a href=&quot;wal&quot;&gt;write-ahead log&lt;/a&gt; mode, the &lt;a href=&quot;pragma#pragma_page_size&quot;&gt;page_size&lt;/a&gt; and/or &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum&lt;/a&gt; properties of an existing database may be changed by using the &lt;a href=&quot;pragma#pragma_page_size&quot;&gt;page_size&lt;/a&gt; and/or &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;pragma auto_vacuum&lt;/a&gt; pragmas and then immediately VACUUMing the database. When in &lt;a href=&quot;wal&quot;&gt;write-ahead log&lt;/a&gt; mode, only the &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum&lt;/a&gt; support property can be changed using VACUUM.</source>
          <target state="translated">Обычно &lt;a href=&quot;pragma#pragma_page_size&quot;&gt;размер page_size&lt;/a&gt; базы данных и то, поддерживает ли база данных &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum,&lt;/a&gt; должны быть настроены до фактического создания файла базы данных. Однако, когда он не находится в режиме &lt;a href=&quot;wal&quot;&gt;журнала&lt;/a&gt; с &lt;a href=&quot;pragma#pragma_page_size&quot;&gt;упреждающей &lt;/a&gt;&lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;записью,&lt;/a&gt; свойства page_size и / или auto_vacuum существующей базы данных могут быть изменены с помощью &lt;a href=&quot;pragma#pragma_page_size&quot;&gt;прагм page_size&lt;/a&gt; и / или &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;pragma auto_vacuum,&lt;/a&gt; а затем немедленно VACUUMing базы данных. В режиме &lt;a href=&quot;wal&quot;&gt;журнала упреждающей&lt;/a&gt; записи с помощью VACUUM можно изменить только &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;свойство&lt;/a&gt; поддержки auto_vacuum .</target>
        </trans-unit>
        <trans-unit id="5df62864e283fb4361bad80921bbac8b7ec57013" translate="yes" xml:space="preserve">
          <source>Normally, when SQLite writes to a database file, it waits until the write operation is finished before returning control to the calling application. Since writing to the file-system is usually very slow compared with CPU bound operations, this can be a performance bottleneck. The asynchronous I/O backend is an extension that causes SQLite to perform all write requests using a separate thread running in the background. Although this does not reduce the overall system resources (CPU, disk bandwidth etc.), it does allow SQLite to return control to the caller quickly even when writing to the database.</source>
          <target state="translated">Обычно,когда SQLite записывает в файл базы данных,он ждет завершения операции записи,прежде чем вернуть управление вызывающему приложению.Поскольку запись в файловую систему обычно происходит очень медленно по сравнению с операциями,связанными с процессором,это может быть узким местом в производительности.Бэкэнд асинхронного ввода/вывода является расширением,которое заставляет SQLite выполнять все запросы на запись с помощью отдельного потока,работающего в фоновом режиме.Хотя это и не уменьшает общие системные ресурсы (процессор,пропускную способность диска и т.д.),но позволяет SQLite быстро возвращать управление вызывающему абоненту даже при записи в базу данных.</target>
        </trans-unit>
        <trans-unit id="b810f7b8c9c4b12cca67db5205f27d6d0477e848" translate="yes" xml:space="preserve">
          <source>Normally, when a row is inserted into an FTS5 table, as well as the various full-text index entries and other data a copy of the row is stored in a private table managed by the FTS5 module. When column values are requested from the FTS5 table by the user or by an auxiliary function implementation, they are read from this private table. The &quot;content&quot; option may be used to create an FTS5 table that stores only FTS full-text index entries. Because the column values themselves are usually much larger than the associated full-text index entries, this can save significant database space.</source>
          <target state="translated">Обычно,когда строка вставляется в таблицу FTS5,а также различные полнотекстовые элементы индекса и другие данные,копия строки хранится в приватной таблице,управляемой модулем FTS5.Когда значения столбцов запрашиваются из таблицы FTS5 пользователем или реализацией вспомогательной функции,они считываются из этой закрытой таблицы.Опция &quot;содержимое&quot; может быть использована для создания таблицы FTS5,в которой хранятся только записи полнотекстового индекса FTS.Поскольку сами значения столбцов обычно намного больше,чем соответствующие элементы полнотекстового индекса,это может сэкономить значительное пространство в БД.</target>
        </trans-unit>
        <trans-unit id="ca1dd39379254ab3f3c73dbffb0d03d628b27d20" translate="yes" xml:space="preserve">
          <source>Not</source>
          <target state="translated">Not</target>
        </trans-unit>
        <trans-unit id="5927a7e485b2adcf5a36cf65c4801a2eed120fcc" translate="yes" xml:space="preserve">
          <source>Not all applications meet these conditions. Fortunately, the NGQP will still usually find good query plans, even without these conditions. However, cases do arise (rarely) where performance regressions can occur.</source>
          <target state="translated">Не все приложения соответствуют этим условиям.К счастью,NGQP все равно обычно находит хорошие планы запросов,даже без этих условий.Тем не менее,возникают (редко)случаи,когда могут произойти регрессии производительности.</target>
        </trans-unit>
        <trans-unit id="6938024f626f02a7276620a318f6367169f62576" translate="yes" xml:space="preserve">
          <source>Not all test cases can be handled this way. Some test cases check to verify that the optimizations really are reducing the amount of computation by counting the number of disk accesses, sort operations, full-scan steps, or other processing steps that occur during queries. Those test cases will appear to fail when optimizations are disabled. But the majority of test cases simply check that the correct answer was obtained, and all of those cases can be run successfully with and without the optimizations, in order to show that the optimizations do not cause malfunctions.</source>
          <target state="translated">Не все тестовые случаи могут быть решены таким образом.Некоторые тестовые случаи проверяют,что оптимизация действительно уменьшает объем вычислений путем подсчета количества обращений к диску,операций сортировки,шагов полного сканирования или других шагов обработки,которые происходят во время запросов.Эти тестовые случаи будут казаться неудачными,когда оптимизации отключены.Но большинство тестовых случаев просто проверяют,что получен правильный ответ,и все эти случаи могут быть успешно запущены с оптимизациями и без них,чтобы показать,что оптимизации не приводят к сбоям.</target>
        </trans-unit>
        <trans-unit id="d047995ecc6203bb86f7cef3de1f0a2b4fa5dba8" translate="yes" xml:space="preserve">
          <source>Not ever decimal number with fewer than 16 significant digits can be represented exactly as a binary64 number. In fact, most decimal numbers with digits to the right of the decimal point lack an exact binary64 equivalent. For example, if you have a database column that is intended to hold an item price in dollars and cents, the only cents value that can be exactly represented are 0.00, 0.25, 0.50, and 0.75. Any other numbers to the right of the decimal point result in an approximation. If you provide a &quot;price&quot; value of 47.49, that number will be represented in binary64 as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef42529ee731ef3b3603a24c66a4c6f388b99dce" translate="yes" xml:space="preserve">
          <source>Not every decimal number with fewer than 16 significant digits can be represented exactly as a binary64 number. In fact, most decimal numbers with digits to the right of the decimal point lack an exact binary64 equivalent. For example, if you have a database column that is intended to hold an item price in dollars and cents, the only cents value that can be exactly represented are 0.00, 0.25, 0.50, and 0.75. Any other numbers to the right of the decimal point result in an approximation. If you provide a &quot;price&quot; value of 47.49, that number will be represented in binary64 as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="593dbd15d49368a738585302a9107baf925136df" translate="yes" xml:space="preserve">
          <source>Not shown in the example above is that there are also &lt;a href=&quot;fts5#fts5_table_creation_and_initialization&quot;&gt;various options&lt;/a&gt; that may be provided to FTS5 as part of the CREATE VIRTUAL TABLE statement to configure various aspects of the new table. These may be used to modify the way in which the FTS5 table extracts terms from documents and queries, to create extra indexes on disk to speed up prefix queries, or to create an FTS5 table that acts as an index on content stored elsewhere.</source>
          <target state="translated">В приведенном выше примере не показано, что существуют также &lt;a href=&quot;fts5#fts5_table_creation_and_initialization&quot;&gt;различные параметры,&lt;/a&gt; которые могут быть предоставлены FTS5 как часть оператора CREATE VIRTUAL TABLE для настройки различных аспектов новой таблицы. Они могут использоваться для изменения способа, которым таблица FTS5 извлекает термины из документов и запросов, для создания дополнительных индексов на диске для ускорения префиксных запросов или для создания таблицы FTS5, которая действует как индекс для контента, хранящегося в другом месте.</target>
        </trans-unit>
        <trans-unit id="edbfab21e07e4e0dbe02fb875980c40bdd52ad0f" translate="yes" xml:space="preserve">
          <source>NotExists</source>
          <target state="translated">NotExists</target>
        </trans-unit>
        <trans-unit id="6f05e7cc9203f83829c08dcc46fafe9db426763f" translate="yes" xml:space="preserve">
          <source>NotFound</source>
          <target state="translated">NotFound</target>
        </trans-unit>
        <trans-unit id="85c73c74f4b29a9fb7ba8d0a5bc532eb27f0866a" translate="yes" xml:space="preserve">
          <source>NotNull</source>
          <target state="translated">NotNull</target>
        </trans-unit>
        <trans-unit id="7884a1030f088443b3e65dc8c7d9c833c3f14209" translate="yes" xml:space="preserve">
          <source>Nota bene:</source>
          <target state="translated">Не за что:</target>
        </trans-unit>
        <trans-unit id="59ab81d7ff99620547d7c60a07878ec16f88cba0" translate="yes" xml:space="preserve">
          <source>Note also that when adding a &lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK constraint&lt;/a&gt;, the CHECK constraint is not tested against preexisting rows of the table. This can result in a table that contains data that is in violation of the CHECK constraint. Future versions of SQLite might change to validate CHECK constraints as they are added.</source>
          <target state="translated">Также обратите внимание, что при добавлении &lt;a href=&quot;lang_createtable#ckconst&quot;&gt;ограничения CHECK ограничение&lt;/a&gt; CHECK не проверяется на ранее существовавших строках таблицы. В результате может получиться таблица, содержащая данные, нарушающие ограничение CHECK. Будущие версии SQLite могут измениться для проверки ограничений CHECK по мере их добавления.</target>
        </trans-unit>
        <trans-unit id="63cff68b4cc8b6d1593b377ca2761e4a780c9aef" translate="yes" xml:space="preserve">
          <source>Note that &quot;monotonically increasing&quot; does not imply that the ROWID always increases by exactly one. One is the usual increment. However, if an insert fails due to (for example) a uniqueness constraint, the ROWID of the failed insertion attempt might not be reused on subsequent inserts, resulting in gaps in the ROWID sequence. AUTOINCREMENT guarantees that automatically chosen ROWIDs will be increasing but not that they will be sequential.</source>
          <target state="translated">Обратите внимание,что &quot;монотонное увеличение&quot; не означает,что ROWID всегда увеличивается ровно на единицу.Одно из них-обычное увеличение.Однако,если вставка не удается из-за (например)ограничения уникальности,ROWID неудачной попытки вставки может не использоваться повторно на последующих вставках,что приведет к пробелам в последовательности ROWID.АВТОИНКРЕМЕНТ гарантирует,что автоматически выбранные ROWID будут увеличиваться,но не будут последовательными.</target>
        </trans-unit>
        <trans-unit id="4308667a324be6565f7e88fc7a4b19a7777f66dd" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;#sqlite3_create_function&quot;&gt;application-defined SQL functions&lt;/a&gt; or &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt; might change the database indirectly as a side effect. For example, if an application defines a function &quot;eval()&quot; that calls &lt;a href=&quot;#sqlite3_exec&quot;&gt;sqlite3_exec()&lt;/a&gt;, then the following SQL statement would change the database file through side-effects:</source>
          <target state="translated">Обратите внимание, что &lt;a href=&quot;#sqlite3_create_function&quot;&gt;определяемые приложением функции SQL&lt;/a&gt; или &lt;a href=&quot;vtab&quot;&gt;виртуальные таблицы&lt;/a&gt; могут косвенно изменять базу данных в качестве побочного эффекта. Например, если приложение определяет функцию eval (), которая вызывает &lt;a href=&quot;#sqlite3_exec&quot;&gt;sqlite3_exec ()&lt;/a&gt; , то следующий оператор SQL изменит файл базы данных из-за побочных эффектов:</target>
        </trans-unit>
        <trans-unit id="2de1256b9fbe19c405bb475cc7365f640da5726d" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;../appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt; or &lt;a href=&quot;../vtab&quot;&gt;virtual tables&lt;/a&gt; might change the database indirectly as a side effect. For example, if an application defines a function &quot;eval()&quot; that calls &lt;a href=&quot;exec&quot;&gt;sqlite3_exec()&lt;/a&gt;, then the following SQL statement would change the database file through side-effects:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a8f4592d0e17a85103883247d0a4447a3744957" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt; are by default considered non-deterministic and may not be used in a CREATE INDEX statement unless the &lt;a href=&quot;c3ref/c_deterministic#sqlitedeterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt; flag is used when the function is registered.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1de4b11ed42096116749429497dc130939876ea1" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt; or &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt; might change the database indirectly as a side effect. For example, if an application defines a function &quot;eval()&quot; that calls &lt;a href=&quot;#sqlite3_exec&quot;&gt;sqlite3_exec()&lt;/a&gt;, then the following SQL statement would change the database file through side-effects:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa33906842475ccf0659a59159f766bfacc10e93" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;c3ref/create_function&quot;&gt;application-defined SQL functions&lt;/a&gt; are by default considered non-deterministic and may not be used in a CREATE INDEX statement unless the &lt;a href=&quot;c3ref/c_deterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt; flag is used when the function is registered.</source>
          <target state="translated">Обратите внимание, что &lt;a href=&quot;c3ref/create_function&quot;&gt;определяемые приложением функции SQL&lt;/a&gt; по умолчанию считаются недетерминированными и не могут использоваться в операторе CREATE INDEX, если при &lt;a href=&quot;c3ref/c_deterministic&quot;&gt;регистрации функции&lt;/a&gt; не используется флаг SQLITE_DETERMINISTIC .</target>
        </trans-unit>
        <trans-unit id="5f9e6d6d8a3bf2c6d2a7e519940c1c6c58742f80" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;create_function&quot;&gt;application-defined SQL functions&lt;/a&gt; or &lt;a href=&quot;../vtab&quot;&gt;virtual tables&lt;/a&gt; might change the database indirectly as a side effect. For example, if an application defines a function &quot;eval()&quot; that calls &lt;a href=&quot;exec&quot;&gt;sqlite3_exec()&lt;/a&gt;, then the following SQL statement would change the database file through side-effects:</source>
          <target state="translated">Обратите внимание, что &lt;a href=&quot;create_function&quot;&gt;определяемые приложением функции SQL&lt;/a&gt; или &lt;a href=&quot;../vtab&quot;&gt;виртуальные таблицы&lt;/a&gt; могут косвенно изменять базу данных в качестве побочного эффекта. Например, если приложение определяет функцию eval (), которая вызывает &lt;a href=&quot;exec&quot;&gt;sqlite3_exec ()&lt;/a&gt; , то следующий оператор SQL изменит файл базы данных из-за побочных эффектов:</target>
        </trans-unit>
        <trans-unit id="f679875d06130633120a14b47faa759dd16975f1" translate="yes" xml:space="preserve">
          <source>Note that Idx3 contains all the same information as the original &lt;a href=&quot;#fig3&quot;&gt;Idx1&lt;/a&gt;. And so if we have Idx3, we do not really need Idx1 any more. The &quot;price of peaches&quot; query can be satisfied using Idx3 by simply ignoring the &quot;state&quot; column of Idx3:</source>
          <target state="translated">Обратите внимание, что Idx3 содержит всю ту же информацию, что и исходный &lt;a href=&quot;#fig3&quot;&gt;Idx1&lt;/a&gt; . Итак, если у нас есть Idx3, нам больше не нужен Idx1. Запрос &amp;laquo;цена персиков&amp;raquo; можно удовлетворить с помощью Idx3, просто игнорируя столбец &amp;laquo;состояние&amp;raquo; Idx3:</target>
        </trans-unit>
        <trans-unit id="8e97b2bc14d77a13e225d171f50b67e2004fff89" translate="yes" xml:space="preserve">
          <source>Note that MinGW generates 32-bit DLLs only. There is a separate MinGW64 project that can be used to generate 64-bit DLLs. Presumably the command-line syntax is similar. Also note that recent versions of MSVC generate DLLs that will not work on WinXP and earlier versions of Windows. So for maximum compatibility of your generated DLL, MinGW is recommended. A good rule-of-thumb is to generate 32-bit DLLs using MinGW and 64-bit DLLs using MSVC.</source>
          <target state="translated">Обратите внимание,что MinGW генерирует только 32-битные DLL.Существует отдельный проект MinGW64,который может быть использован для генерации 64-битных DLL.Предположительно,синтаксис командной строки аналогичен.Также обратите внимание,что последние версии MSVC генерируют DLL,которые не будут работать на WinXP и более ранних версиях Windows.Поэтому для максимальной совместимости с генерируемыми вами DLL рекомендуется MinGW.Хорошим правилом является генерация 32-битных DLL с использованием MinGW и 64-битных DLL с использованием MSVC.</target>
        </trans-unit>
        <trans-unit id="103d786acd07e894276011f9fe0ff0e5d6f3f4da" translate="yes" xml:space="preserve">
          <source>Note that SQLITE_IGNORE is also used as a &lt;a href=&quot;#SQLITE_FAIL&quot;&gt;conflict resolution mode&lt;/a&gt; returned from the &lt;a href=&quot;#sqlite3_vtab_on_conflict&quot;&gt;sqlite3_vtab_on_conflict()&lt;/a&gt; interface.</source>
          <target state="translated">Обратите внимание, что SQLITE_IGNORE также используется в качестве &lt;a href=&quot;#SQLITE_FAIL&quot;&gt;режима разрешения конфликтов,&lt;/a&gt; возвращаемого интерфейсом &lt;a href=&quot;#sqlite3_vtab_on_conflict&quot;&gt;sqlite3_vtab_on_conflict ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="82cf9ab6c420a3c604d44b14992c4f512d1f4c35" translate="yes" xml:space="preserve">
          <source>Note that SQLITE_IGNORE is also used as a &lt;a href=&quot;c_fail&quot;&gt;conflict resolution mode&lt;/a&gt; returned from the &lt;a href=&quot;vtab_on_conflict&quot;&gt;sqlite3_vtab_on_conflict()&lt;/a&gt; interface.</source>
          <target state="translated">Обратите внимание, что SQLITE_IGNORE также используется в качестве &lt;a href=&quot;c_fail&quot;&gt;режима разрешения конфликтов,&lt;/a&gt; возвращаемого интерфейсом &lt;a href=&quot;vtab_on_conflict&quot;&gt;sqlite3_vtab_on_conflict ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="63e763dca84d9237a89baecc3d0c141975e41415" translate="yes" xml:space="preserve">
          <source>Note that SQLite allows the number of reserve-bytes to be increased but not decreased. So if a database file already has a reserve-bytes value greater than 8, there is no way to activate checksumming on that database, other than to dump and restore the database file. Note also that other extensions might also make use of the reserve-bytes. Checksumming will be incompatible with those other extensions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd4aaf9aa187deca337c2af0406d2d0e3c9d07f4" translate="yes" xml:space="preserve">
          <source>Note that SQLite allows the parenthesized list of scalar values on the right-hand side of an IN or NOT IN operator to be an empty list but most other SQL database database engines and the SQL92 standard require the list to contain at least one element.</source>
          <target state="translated">Обратите внимание,что SQLite допускает пустой список со скалярными значениями в скобках справа от оператора IN или NOT IN,но большинство других движков баз данных SQL и стандарт SQL92 требуют,чтобы список содержал по крайней мере один элемент.</target>
        </trans-unit>
        <trans-unit id="069a48733ca46d6fc20e074068d69739ed664b2b" translate="yes" xml:space="preserve">
          <source>Note that SQLite automatically adds the appropriate extension suffix (&quot;.dll&quot; on windows, &quot;.dylib&quot; on Mac, &quot;.so&quot; on most other unixes) to the extension filename. It is generally a good idea to specify the full pathname of the extension.</source>
          <target state="translated">Обратите внимание,что SQLite автоматически добавляет соответствующий суффикс расширения (&quot;.dll&quot; в окнах,&quot;.dylib&quot; в Mac,&quot;.so&quot; в большинстве других unix)к имени файла расширения.Обычно рекомендуется указывать полное имя расширения.</target>
        </trans-unit>
        <trans-unit id="878abfb73c8f4fd7637bff37205a9854afa6975b" translate="yes" xml:space="preserve">
          <source>Note that SQLite comes with several &lt;a href=&quot;../malloc#altalloc&quot;&gt;built-in memory allocators&lt;/a&gt; that are perfectly adequate for the overwhelming majority of applications and that this object is only useful to a tiny minority of applications with specialized memory allocation requirements. This object is also used during testing of SQLite in order to specify an alternative memory allocator that simulates memory out-of-memory conditions in order to verify that SQLite recovers gracefully from such conditions.</source>
          <target state="translated">Обратите внимание, что SQLite поставляется с несколькими &lt;a href=&quot;../malloc#altalloc&quot;&gt;встроенными распределителями памяти&lt;/a&gt; , которые идеально подходят для подавляющего большинства приложений, и что этот объект полезен только для крошечного меньшинства приложений со специализированными требованиями к выделению памяти. Этот объект также используется во время тестирования SQLite, чтобы указать альтернативный распределитель памяти, который имитирует условия нехватки памяти, чтобы убедиться, что SQLite корректно восстанавливается из таких условий.</target>
        </trans-unit>
        <trans-unit id="8a9932e44739c8fef89cbf2d998599f354bb604b" translate="yes" xml:space="preserve">
          <source>Note that SQLite comes with several &lt;a href=&quot;malloc#altalloc&quot;&gt;built-in memory allocators&lt;/a&gt; that are perfectly adequate for the overwhelming majority of applications and that this object is only useful to a tiny minority of applications with specialized memory allocation requirements. This object is also used during testing of SQLite in order to specify an alternative memory allocator that simulates memory out-of-memory conditions in order to verify that SQLite recovers gracefully from such conditions.</source>
          <target state="translated">Обратите внимание, что SQLite поставляется с несколькими &lt;a href=&quot;malloc#altalloc&quot;&gt;встроенными распределителями памяти&lt;/a&gt; , которые идеально подходят для подавляющего большинства приложений, и что этот объект полезен только для крошечного меньшинства приложений со специализированными требованиями к выделению памяти. Этот объект также используется во время тестирования SQLite, чтобы указать альтернативный распределитель памяти, который имитирует условия нехватки памяти, чтобы убедиться, что SQLite корректно восстанавливается из таких условий.</target>
        </trans-unit>
        <trans-unit id="f1f541cbfa03c47b900f800f3f8afdec05b49044" translate="yes" xml:space="preserve">
          <source>Note that SQLite does not enforce the PRIMARY KEY for a WITHOUT ROWID virtual table. Enforcement is the responsibility of the underlying virtual table implementation. But SQLite does assume that the PRIMARY KEY constraint is valid - that the identified columns really are UNIQUE and NOT NULL - and it uses that assumption to optimize queries against the virtual table.</source>
          <target state="translated">Обратите внимание,что SQLite не применяет PRIMARY KEY для виртуальной таблицы БЕЗ РОУИДА.Ответственность за обеспечение соблюдения лежит на реализации виртуальной таблицы.Но SQLite предполагает,что ограничение PRIMARY KEY является действительным-что идентифицированные столбцы действительно являются UNIQUE и НЕ NULL-и использует это предположение для оптимизации запросов к виртуальной таблице.</target>
        </trans-unit>
        <trans-unit id="d3bdb4d9a8050dadd7145a64b6065f6da75ef0eb" translate="yes" xml:space="preserve">
          <source>Note that SQLite must believe whatever the operating system and hardware tell it about the status of sync requests. There is no way for SQLite to detect that either is lying and that writes might be occurring out-of-order. However, SQLite in &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt; is far more forgiving of out-of-order writes than in the default rollback journal modes. In WAL mode, the only time that a failed sync operation can cause database corruption is during a &lt;a href=&quot;wal#ckpt&quot;&gt;checkpoint&lt;/a&gt; operation. A sync failure during a COMMIT might result in loss of durability but not in a corrupt database file. Hence, one line of defense against database corruption due to failed sync operations is to use SQLite in WAL mode and to checkpoint as infrequently as possible.</source>
          <target state="translated">Обратите внимание, что SQLite должен верить тому, что операционная система и оборудование говорят ему о состоянии запросов на синхронизацию. SQLite не может обнаружить, что какой-либо из них лжет и что записи могут происходить не по порядку. Однако SQLite в &lt;a href=&quot;wal&quot;&gt;режиме WAL&lt;/a&gt; гораздо более снисходительно относится к неупорядоченной записи, чем в режимах журнала отката по умолчанию. В режиме WAL единственный раз, когда неудачная операция синхронизации может вызвать повреждение базы данных, - это операция &lt;a href=&quot;wal#ckpt&quot;&gt;контрольной точки&lt;/a&gt; . Сбой синхронизации во время COMMIT может привести к потере устойчивости, но не к повреждению файла базы данных. Следовательно, одной из линий защиты от повреждения базы данных из-за неудачных операций синхронизации является использование SQLite в режиме WAL и выполнение контрольных точек как можно реже.</target>
        </trans-unit>
        <trans-unit id="a2fee544cde41af143fe81786b7190276086b344" translate="yes" xml:space="preserve">
          <source>Note that SQLite uses b-trees, which are a sorted data structure, so indices can be used when the WHERE clause of the SELECT statement contains tests for equality or inequality. Queries like the following can use an index if it is available:</source>
          <target state="translated">Обратите внимание,что SQLite использует b-деревья,которые представляют собой отсортированную структуру данных,поэтому индексы могут использоваться,когда в пункте WHERE оператора SELECT содержатся тесты на равенство или неравенство.В таких запросах,как ниже,можно использовать индекс,если он доступен:</target>
        </trans-unit>
        <trans-unit id="5081483bfc5c0173b67743dd4507d0595797d951" translate="yes" xml:space="preserve">
          <source>Note that a declared type of &quot;FLOATING POINT&quot; would give INTEGER affinity, not REAL affinity, due to the &quot;INT&quot; at the end of &quot;POINT&quot;. And the declared type of &quot;STRING&quot; has an affinity of NUMERIC, not TEXT.</source>
          <target state="translated">Обратите внимание,что объявленный тип &quot;FLOATING POINT&quot; даст сродство INTEGER,а не REAL,из-за &quot;INT&quot; в конце &quot;POINT&quot;.А объявленный тип &quot;STRING&quot; имеет сродство ЧИСЛОВЫЙ,а не ТЕКСТ.</target>
        </trans-unit>
        <trans-unit id="6008db09d7c79dcc3b84a140fc5e215929e6ce79" translate="yes" xml:space="preserve">
          <source>Note that a transformation that flips the polygon might cause the order of vertexes to be reversed. In other words, the transformation might cause the vertexes to circulate in clockwise order instead of counter-clockwise. This can be corrected by sending the result through the &lt;a href=&quot;geopoly#ccw&quot;&gt;geopoly_ccw()&lt;/a&gt; function after transformation.</source>
          <target state="translated">Обратите внимание, что преобразование, которое переворачивает многоугольник, может привести к обратному порядку вершин. Другими словами, преобразование может привести к тому, что вершины будут перемещаться по часовой стрелке, а не против часовой стрелки. Это можно исправить, отправив результат через &lt;a href=&quot;geopoly#ccw&quot;&gt;функцию geopoly_ccw ()&lt;/a&gt; после преобразования.</target>
        </trans-unit>
        <trans-unit id="3eb1501d271603c6953bfb8ef829d45c83d17e8d" translate="yes" xml:space="preserve">
          <source>Note that an inner transaction might commit (using the RELEASE command) but then later have its work undone by a ROLLBACK in an outer transaction. A power failure or program crash or OS crash will cause the outer-most transaction to rollback, undoing all changes that have occurred within that outer transaction, even changes that have supposedly been &quot;committed&quot; by the RELEASE command. Content is not actually committed on the disk until the outermost transaction commits.</source>
          <target state="translated">Обратите внимание,что внутренняя транзакция может совершить фиксацию (с помощью команды RELEASE),но затем отменить ее работу с помощью команды ROLLBACK во внешней транзакции.Сбой питания,сбой программы или отказ операционной системы приведет к откату самой внешней транзакции,отменив все изменения,которые произошли внутри этой внешней транзакции,даже изменения,которые предположительно были &quot;зафиксированы&quot; командой RELEASE.Содержимое на самом деле не фиксируется на диске до тех пор,пока не зафиксирована самая внешняя транзакция.</target>
        </trans-unit>
        <trans-unit id="7c93fd99fb4687ad2997daf3b6769cc616b7c58e" translate="yes" xml:space="preserve">
          <source>Note that conflict resolutions from multiple remote changesets are combined on a per-field basis, not per-row. This means that in the case of multiple remote UPDATE operations, some fields of a single local change may be rebased for REPLACE while others are rebased for OMIT.</source>
          <target state="translated">Обратите внимание,что разрешения конфликтов от нескольких удаленных изменений объединяются на основе для каждого поля,а не для каждого ряда.Это означает,что в случае нескольких удаленных операций UPDATE,некоторые поля одного локального изменения могут быть возвращены в REPLACE,в то время как другие-в OMIT.</target>
        </trans-unit>
        <trans-unit id="e3af7101a58299023cb05d90e0fc88f9fa63608b" translate="yes" xml:space="preserve">
          <source>Note that conversions between UTF-16be and UTF-16le are always done in place and do not invalidate a prior pointer, though of course the content of the buffer that the prior pointer points to will have been modified. Other kinds of conversion are done in place when it is possible, but sometime it is not possible and in those cases prior pointers are invalidated.</source>
          <target state="translated">Обратите внимание,что преобразования между UTF-16be и UTF-16le всегда выполняются на месте и не делают недействительным предыдущий указатель,хотя,конечно,содержимое буфера,на который указывает предыдущий указатель,будет изменено.Другие виды преобразований выполняются на месте,когда это возможно,но иногда это невозможно,и в этих случаях предыдущие указатели становятся недействительными.</target>
        </trans-unit>
        <trans-unit id="f0c5f85c046ed0d0d783a57a522950f881e39de3" translate="yes" xml:space="preserve">
          <source>Note that deleting records from a zip archive does not reclaim the space used within the archive - it merely removes an entry from the archives &quot;Central Directory Structure&quot;, making the entry inaccessible. One way to work around this inefficiency is to create a new zip archive based on the contents of the edited archive. For example, after editing the archive accessed via virtual table temp.zzz:</source>
          <target state="translated">Обратите внимание,что удаление записей из zip-архива не восстанавливает использованное пространство внутри архива-оно просто удаляет запись из архива &quot;Central Directory Structure&quot;,делая ее недоступной.Одним из способов обойти эту неэффективность является создание нового zip-архива на основе содержимого отредактированного архива.Например,после редактирования архива доступ к нему осуществляется через виртуальную таблицу temp.zzz:</target>
        </trans-unit>
        <trans-unit id="710cdb120286dd832bd6798397cffbb5dfeed9ef" translate="yes" xml:space="preserve">
          <source>Note that different operating systems use different filename suffixes for their shared libraries. Windows use &quot;.dll&quot;, Mac uses &quot;.dylib&quot;, and most unixes other than mac use &quot;.so&quot;. If you want to make your code portable, you can omit the suffix from the shared library filename and the appropriate suffix will be added automatically by the &lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension()&lt;/a&gt; interface.</source>
          <target state="translated">Обратите внимание, что разные операционные системы используют разные суффиксы файлов для своих общих библиотек. Windows использует &amp;laquo;.dll&amp;raquo;, Mac использует &amp;laquo;.dylib&amp;raquo;, а большинство unix-файлов, кроме Mac, используют &amp;laquo;.so&amp;raquo;. Если вы хотите сделать свой код переносимым, вы можете опустить суффикс в имени файла общей библиотеки, и соответствующий суффикс будет автоматически добавлен интерфейсом &lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c12e1242a0c93cb2f83528b0161fb89fb73eac90" translate="yes" xml:space="preserve">
          <source>Note that each 32768-byte unit of the shm file has its own aHash and aPgno arrays. The aHash array for a single unit is only helpful in finding aPgno entries in that same unit. The overall FindFrame(P,M) function needs to do hash lookups beginning with the latest unit and working backwards to the oldest unit until it finds an answer.</source>
          <target state="translated">Обратите внимание,что каждая 32768-байтовая единица файла shm имеет свой собственный массив aHash и aPgno.Массив aHash для одного устройства полезен только для поиска записей aPgno в этом же устройстве.Функция FindFrame(P,M)в целом должна выполнять поиск хэша,начиная с последнего модуля и работая в обратном направлении до самого старого модуля,пока не найдет ответ.</target>
        </trans-unit>
        <trans-unit id="30f49c0b1079064845cadc4000f3f0cbc4ba7f9a" translate="yes" xml:space="preserve">
          <source>Note that enabling FTS3 also makes FTS4 available. There is not a separate SQLITE_ENABLE_FTS4 compile-time option. A build of SQLite either supports both FTS3 and FTS4 or it supports neither.</source>
          <target state="translated">Обратите внимание,что включение FTS3 также делает FTS4 доступным.Отдельной опции времени компиляции SQLITE_ENABLE_FTS4 не существует.Сборка SQLite либо поддерживает FTS3 и FTS4,либо не поддерживает ни то,ни другое.</target>
        </trans-unit>
        <trans-unit id="665e7a6fdd40011f21f13b4109b67442ccc2792c" translate="yes" xml:space="preserve">
          <source>Note that except for a few corner-case differences detailed above, WITHOUT ROWID tables and rowid tables work the same. They both generate the same answers given the same SQL statements. So it is a simple matter to run experiments on an application, late in the development cycle, to test whether or not the use of WITHOUT ROWID tables will be helpful. A good strategy is to simply not worry about WITHOUT ROWID until near the end of product development, then go back and run tests to see if adding WITHOUT ROWID to tables with non-integer PRIMARY KEYs helps or hurts performance, and retaining the WITHOUT ROWID only in those cases where it helps.</source>
          <target state="translated">Обратите внимание,что за исключением нескольких угловых разниц,описанных выше,таблицы БЕЗ РОУИДов и таблицы rowid работают одинаково.Они оба генерируют одни и те же ответы,давая одни и те же SQL-операторы.Таким образом,просто запустить эксперименты над приложением на поздних стадиях цикла разработки,чтобы проверить,будет ли полезно использование таблиц БЕЗ РОУИДов.Хорошая стратегия заключается в том,чтобы просто не беспокоиться о БЕЗ РОУИДА до окончания разработки продукта,а затем вернуться назад и запустить тесты,чтобы посмотреть,помогает ли добавление БЕЗ РОУИДА в таблицы с неинтегрированными PRIMARY KEYs или снижает производительность,и сохранение БЕЗ РОУИДА только в тех случаях,когда это помогает.</target>
        </trans-unit>
        <trans-unit id="bde5b3e09fe9bd78baf5c5b8cf655c1d83bf9828" translate="yes" xml:space="preserve">
          <source>Note that geopoly uses a traditional right-handed cartesian coordinate system with the origin at the lower left, whereas SVG uses a left-handed coordinate system with the origin at the upper left. The geopoly_svg() routine makes no attempt to transform the coordinate system, so the displayed images are shown in mirror image and rotated. If that is undesirable, the geopoly_xform() routine can be used to transform the output from cartesian to SVG coordinates prior to passing the polygons into geopoly_svg().</source>
          <target state="translated">Обратите внимание,что в геополитике используется традиционная правая картезианская система координат с началом отсчета в левом нижнем углу,в то время как в SVG используется левосторонняя система координат с началом отсчета в левом верхнем углу.В программе geopoly_svg()не делается никаких попыток преобразования системы координат,поэтому отображаемые изображения отображаются в зеркальном отображении и поворачиваются.Если это нежелательно,рутина geopoly_xform()может быть использована для преобразования вывода из картезианских в SVG координат до передачи полигонов в функцию geopoly_svg().</target>
        </trans-unit>
        <trans-unit id="98a440c913714baad6d711ca1c482bbb8e3fece7" translate="yes" xml:space="preserve">
          <source>Note that if a non-deterministic function is tagged with &lt;a href=&quot;c3ref/c_deterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt; and if that function ends up being used in the WHERE clause of a &lt;a href=&quot;partialindex&quot;&gt;partial index&lt;/a&gt; or in an &lt;a href=&quot;expridx&quot;&gt;expression index&lt;/a&gt;, then when the function begins to return different answers, the associated index may become corrupt. If an SQL function is nearly deterministic (which is to say, if it only rarely changes, like &lt;a href=&quot;lang_corefunc#sqlite_version&quot;&gt;sqlite_version()&lt;/a&gt;) and it is used in an index that becomes corrupt, the corruption can be fixed by running &lt;a href=&quot;lang_reindex&quot;&gt;REINDEX&lt;/a&gt;.</source>
          <target state="translated">Обратите внимание, что если недетерминированная функция помечена тегом &lt;a href=&quot;c3ref/c_deterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt; и если эта функция в конечном итоге используется в предложении WHERE &lt;a href=&quot;partialindex&quot;&gt;частичного индекса&lt;/a&gt; или в &lt;a href=&quot;expridx&quot;&gt;индексе выражения&lt;/a&gt; , то, когда функция начинает возвращать разные ответы, связанный индекс может стать поврежденным. . Если функция SQL почти детерминирована (то есть, если она меняется редко, например &lt;a href=&quot;lang_corefunc#sqlite_version&quot;&gt;sqlite_version ()&lt;/a&gt; ) и используется в индексе, который становится поврежденным, повреждение можно исправить, запустив &lt;a href=&quot;lang_reindex&quot;&gt;REINDEX&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c13f9095e78ebed2a9c8d270bb63e3a9b47c70fe" translate="yes" xml:space="preserve">
          <source>Note that if a non-deterministic function is tagged with &lt;a href=&quot;c3ref/c_deterministic#sqlitedeterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt; and if that function ends up being used in the WHERE clause of a &lt;a href=&quot;partialindex&quot;&gt;partial index&lt;/a&gt; or in an &lt;a href=&quot;expridx&quot;&gt;expression index&lt;/a&gt;, then when the function begins to return different answers, the associated index may become corrupt. If an SQL function is nearly deterministic (which is to say, if it only rarely changes, like &lt;a href=&quot;lang_corefunc#sqlite_version&quot;&gt;sqlite_version()&lt;/a&gt;) and it is used in an index that becomes corrupt, the corruption can be fixed by running &lt;a href=&quot;lang_reindex&quot;&gt;REINDEX&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e7ef1f945a3c3a6083df7d03b59a24fcefb7fd0" translate="yes" xml:space="preserve">
          <source>Note that if one of the dynamic mutex parameters (SQLITE_MUTEX_FAST or SQLITE_MUTEX_RECURSIVE) is used then sqlite3_mutex_alloc() returns a different mutex on every call. For the static mutex types, the same mutex is returned on every call that has the same type number.</source>
          <target state="translated">Обратите внимание,что если используется один из динамических параметров мьютекса (SQLITE_MUTEX_FAST или SQLITE_MUTEX_RECURSIVE),то sqlite3_mutex_alloc()возвращает при каждом вызове другой мьютекс.Для статических типов мьютексов при каждом вызове,имеющем один и тот же номер типа,возвращается один и тот же мьютекс.</target>
        </trans-unit>
        <trans-unit id="1c50891c113debf231642ee8d937768c49d352cf" translate="yes" xml:space="preserve">
          <source>Note that if you do not include the &quot;langid=N&quot; term in the WHERE clause, the search will be against language 0 (English in the example above.) All spellfix1 searches are against a single language id. There is no way to search all languages at once.</source>
          <target state="translated">Обратите внимание,что если вы не включите термин &quot;langid=N&quot; в выражение WHERE,то поиск будет осуществляться по языку 0 (английский в примере выше).Все поиски spellfix1 идут по одному языковому идентификатору.Невозможно выполнить поиск сразу по всем языкам.</target>
        </trans-unit>
        <trans-unit id="67f33837baeec763fa57cef78587afa10292c83d" translate="yes" xml:space="preserve">
          <source>Note that in most cases, SQLite will only use a single index for each table in the FROM clause of a query. The second OR-clause optimization described here is the exception to that rule. With an OR-clause, a different index might be used for each subterm in the OR-clause.</source>
          <target state="translated">Обратите внимание,что в большинстве случаев SQLite будет использовать только один индекс для каждой таблицы в выражении FROM запроса.Описанная здесь вторая оптимизация &quot;ИЛИ&quot; является исключением из этого правила.При использовании OR-постановки для каждого подтермина в OR-постановке может использоваться отдельный индекс.</target>
        </trans-unit>
        <trans-unit id="63fa9dab5a3c38f244560b4ee3d5231308f8ad59" translate="yes" xml:space="preserve">
          <source>Note that in order for the special &quot;:memory:&quot; name to apply and to create a pure in-memory database, there must be no additional text in the filename. Thus, a disk-based database can be created in a file by prepending a pathname, like this: &quot;./:memory:&quot;.</source>
          <target state="translated">Обратите внимание,что для того,чтобы применить специальное имя &quot;:memory:&quot; и создать чистую базу данных in-memory,в имени файла не должно быть дополнительного текста.Таким образом,дисковая база данных может быть создана в файле с помощью предваряющего файла с таким именем:&quot;./:память:&quot;.</target>
        </trans-unit>
        <trans-unit id="1b52e107709738a3260fec8ebd98ff46511f5c58" translate="yes" xml:space="preserve">
          <source>Note that in the diagram above, we showed the private edits as a single commit. This was for clarity of presentation only. There is nothing to stop you from doing dozens or hundreds of separate tiny changes and committing each separately. In fact, making many small changes is the preferred way to work. The only reason for doing all the changes in a single commit is that it makes the diagram easier to draw.</source>
          <target state="translated">Обратите внимание,что на диаграмме выше мы показывали приватные правки как один коммит.Это было сделано только для наглядности презентации.Ничто не помешает вам сделать десятки или сотни отдельных крошечных изменений и зафиксировать каждое в отдельности.На самом деле,внесение множества мелких изменений является предпочтительным способом работы.Единственная причина делать все изменения в одном коммите-это то,что он облегчает рисование диаграммы.</target>
        </trans-unit>
        <trans-unit id="705b7526443ed2af20dbc38ecc0ad5be9f1ce9d9" translate="yes" xml:space="preserve">
          <source>Note that in this design, the tokenizer calls the parser. People who are familiar with YACC and BISON may be accustomed to doing things the other way around &amp;mdash; having the parser call the tokenizer. Having the tokenizer call the parser is better, though, because it can be made threadsafe and it runs faster.</source>
          <target state="translated">Обратите внимание, что в этом дизайне токенизатор вызывает парсер. Люди, знакомые с YACC и BISON, могут быть привыкли делать все наоборот - использовать парсер для вызова токенизатора. Тем не менее, имея вызов токенизатора, анализатор лучше, потому что его можно сделать потокобезопасным и он работает быстрее.</target>
        </trans-unit>
        <trans-unit id="819e65339172e5dc379cf7c2c3439c1fadf7ced3" translate="yes" xml:space="preserve">
          <source>Note that infix functions (&lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt;, &lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt;, &lt;a href=&quot;lang_expr#regexp&quot;&gt;REGEXP&lt;/a&gt;, and &lt;a href=&quot;lang_expr#match&quot;&gt;MATCH&lt;/a&gt;) reverse the order of their arguments. So &quot;like(A,B)&quot; is equivalent to &quot;B like A&quot;. For the form &quot;B like A&quot; the B term is considered the first argument to the function. But for &quot;like(A,B)&quot; the A term is considered the first argument.</source>
          <target state="translated">Обратите внимание, что инфиксные функции ( &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; , &lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; , &lt;a href=&quot;lang_expr#regexp&quot;&gt;REGEXP&lt;/a&gt; и &lt;a href=&quot;lang_expr#match&quot;&gt;MATCH&lt;/a&gt; ) меняют порядок своих аргументов. Итак, &amp;laquo;like (A, B)&amp;raquo; эквивалентно &amp;laquo;B like A&amp;raquo;. Для формы &amp;laquo;B как A&amp;raquo; термин B считается первым аргументом функции. Но для &amp;laquo;как (A, B)&amp;raquo; термин A считается первым аргументом.</target>
        </trans-unit>
        <trans-unit id="020c1f099f137d5df05ab667d59b055f8f6ad42a" translate="yes" xml:space="preserve">
          <source>Note that infix functions (&lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt;, &lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt;, &lt;a href=&quot;lang_expr#regexp&quot;&gt;REGEXP&lt;/a&gt;, and &lt;a href=&quot;lang_expr#match&quot;&gt;MATCH&lt;/a&gt;) reverse the order of their arguments. So &quot;like(A,B)&quot; would normally work the same as &quot;B like A&quot;. However, xFindFunction() always looks a the left-most argument, not the first logical argument. Hence, for the form &quot;B like A&quot;, SQLite looks at the left operand &quot;B&quot; and if that operand is a virtual table column it invokes the xFindFunction() method on that virtual table. But if the form &quot;like(A,B)&quot; is used instead, then SQLite checks the A term to see if it is column of a virtual table and if so it invokes the xFindFunction() method for the virtual table of column A.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35589dde916482f10a4613056291243d802b1cc4" translate="yes" xml:space="preserve">
          <source>Note that it is important to set the &quot;mode&quot; to &quot;csv&quot; before running the &quot;.import&quot; command. This is necessary to prevent the command-line shell from trying to interpret the input file text as some other format.</source>
          <target state="translated">Обратите внимание,что перед выполнением команды &quot;.импорт&quot; необходимо установить &quot;режим&quot; на &quot;csv&quot;.Это необходимо для того,чтобы оболочка командной строки не пыталась интерпретировать текст входного файла как какой-то другой формат.</target>
        </trans-unit>
        <trans-unit id="aab0f603b95c5838db66d31fe53b5c5afd66afd1" translate="yes" xml:space="preserve">
          <source>Note that it is not necessary for all coordinates in an R*Tree index to be constrained in order for the index search to be efficient. One might, for example, want to query all objects that overlap with the 35th parallel:</source>
          <target state="translated">Обратите внимание,что не обязательно,чтобы все координаты в индексе R*Tree были ограничены,чтобы поиск по индексу был эффективным.Например,можно запросить все объекты,которые пересекаются с 35 параллелью:</target>
        </trans-unit>
        <trans-unit id="750004cbbcdb4b09f134058116396d2802e69e0a" translate="yes" xml:space="preserve">
          <source>Note that it is not necessary to quote the $bigstring value. That happens automatically. If $bigstring is a large string or binary object, this technique is not only easier to write, it is also much more efficient since it avoids making a copy of the content of $bigstring.</source>
          <target state="translated">Обратите внимание,что нет необходимости цитировать значение $bigstring.Это происходит автоматически.Если $bigstring-большой строковый или двоичный объект,то эта техника не только проще в написании,но и намного эффективнее,так как позволяет избежать копирования содержимого $bigstring.</target>
        </trans-unit>
        <trans-unit id="aedf129a94b2c6ea4cf41bd3da4352659cc6bb37" translate="yes" xml:space="preserve">
          <source>Note that it is perfectly safe for two or more threads to access the same SQLite database file using the SQLite library. The unix drivers for SQLite know about the POSIX advisory locking quirks and work around them. This problem only arises when a thread tries to bypass the SQLite library and read the database file directly.</source>
          <target state="translated">Обратите внимание,что доступ к одному и тому же файлу базы данных SQLite с помощью библиотеки SQLite абсолютно безопасен для двух и более потоков.Драйверы unix для SQLite знают о тонкостях блокировки POSIX-советов и работают вокруг них.Данная проблема возникает только тогда,когда поток пытается обойти библиотеку SQLite и напрямую прочитать файл базы данных.</target>
        </trans-unit>
        <trans-unit id="af76f7d3a1b3eb149d8a26a0e9299bf38c7c0401" translate="yes" xml:space="preserve">
          <source>Note that it is very important that the database filename have some kind of extension. If there is no extension, then SQLite creates auxiliary filenames by appending to the base name of the file. Thus, a database named &quot;&lt;code&gt;db01&lt;/code&gt;&quot; would have a &lt;a href=&quot;lockingv3#rollback&quot;&gt;rollback journal&lt;/a&gt; file named &quot;&lt;code&gt;db01-journal&lt;/code&gt;&quot;. And as this filename has no extension to shorten to 3 characters, it will be used as-is, and will violate 8+3 naming rules.</source>
          <target state="translated">Обратите внимание, что очень важно, чтобы имя файла базы данных имело какое-то расширение. Если расширения нет, SQLite создает вспомогательные имена файлов, добавляя их к базовому имени файла. Таким образом, база данных с именем &amp;laquo; &lt;code&gt;db01&lt;/code&gt; &amp;raquo; будет иметь файл &lt;a href=&quot;lockingv3#rollback&quot;&gt;журнала отката с&lt;/a&gt; именем &amp;laquo; &lt;code&gt;db01-journal&lt;/code&gt; &amp;raquo;. И поскольку это имя файла не имеет расширения, которое можно было бы сократить до 3 символов, оно будет использоваться как есть и будет нарушать правила именования 8 + 3.</target>
        </trans-unit>
        <trans-unit id="19eeeefb37e5b82a70fbf6a86a847157f005c210" translate="yes" xml:space="preserve">
          <source>Note that prior to &lt;a href=&quot;https://sqlite.org/releaselog/3_9_0.html&quot;&gt;version 3.9.0&lt;/a&gt; (2015-10-14), SQLite did not check the xCreate method for NULL before invoking it. So if an eponymous-only virtual table is registered with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_11_1.html&quot;&gt;version 3.8.11.1&lt;/a&gt; (2015-07-29) or earlier and a &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; command is attempted against that virtual table module, a jump to a NULL pointer will occur, resulting in a crash.</source>
          <target state="translated">Обратите внимание, что до &lt;a href=&quot;https://sqlite.org/releaselog/3_9_0.html&quot;&gt;версии 3.9.0&lt;/a&gt; (2015-10-14) SQLite не проверял метод xCreate на NULL перед его вызовом. Таким образом, если виртуальная таблица только с одноименным &lt;a href=&quot;https://sqlite.org/releaselog/3_8_11_1.html&quot;&gt;именем&lt;/a&gt; зарегистрирована в SQLite версии 3.8.11.1 ( 2015-07-29 ) или более ранней, и команда &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; предпринимается для этого модуля виртуальной таблицы, произойдет переход к указателю NULL, что приведет к авария.</target>
        </trans-unit>
        <trans-unit id="7cb63274cd75ba4167c68c8885d57c07e7241aab" translate="yes" xml:space="preserve">
          <source>Note that running SQLite with gcov is not a test of SQLite &amp;mdash; it is a test of the test suite. The gcov run does not test SQLite because the -fprofile-args and -ftest-coverage options cause the compiler to generate different code. The gcov run merely verifies that the test suite provides 100% branch test coverage. The gcov run is a test of the test - a meta-test.</source>
          <target state="translated">Обратите внимание, что запуск SQLite с gcov - это не тест SQLite - это тест набора тестов. Запуск gcov не тестирует SQLite, потому что параметры -fprofile-args и -ftest-охват заставляют компилятор генерировать другой код. Запуск gcov просто проверяет, что набор тестов обеспечивает 100% тестовое покрытие ветвей. Запуск gcov - это тест теста - мета-тест.</target>
        </trans-unit>
        <trans-unit id="5a5f0aee350ad05534eee4c24d91d936725afa91" translate="yes" xml:space="preserve">
          <source>Note that the &lt;a href=&quot;#SQLITE_DENY&quot;&gt;SQLITE_IGNORE&lt;/a&gt; constant is also used as a potential return value from the &lt;a href=&quot;#sqlite3_set_authorizer&quot;&gt;sqlite3_set_authorizer()&lt;/a&gt; callback and that &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ABORT&lt;/a&gt; is also a &lt;a href=&quot;rescode&quot;&gt;result code&lt;/a&gt;.</source>
          <target state="translated">Обратите внимание, что константа &lt;a href=&quot;#SQLITE_DENY&quot;&gt;SQLITE_IGNORE&lt;/a&gt; также используется в качестве потенциального возвращаемого значения из обратного вызова &lt;a href=&quot;#sqlite3_set_authorizer&quot;&gt;sqlite3_set_authorizer ()&lt;/a&gt; и что &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ABORT&lt;/a&gt; также является &lt;a href=&quot;rescode&quot;&gt;кодом результата&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f4daa0a4c8ffbaa8c905b7b2b472738ae1e277cf" translate="yes" xml:space="preserve">
          <source>Note that the &lt;a href=&quot;c3ref/changes&quot;&gt;sqlite3_changes()&lt;/a&gt; and &lt;a href=&quot;c3ref/total_changes&quot;&gt;sqlite3_total_changes()&lt;/a&gt; interfaces do not count INSTEAD OF trigger firings, but the &lt;a href=&quot;pragma#pragma_count_changes&quot;&gt;count_changes pragma&lt;/a&gt; does count INSTEAD OF trigger firing.</source>
          <target state="translated">Обратите внимание, что интерфейсы &lt;a href=&quot;c3ref/changes&quot;&gt;sqlite3_changes ()&lt;/a&gt; и &lt;a href=&quot;c3ref/total_changes&quot;&gt;sqlite3_total_changes ()&lt;/a&gt; не учитывают срабатывания триггера INSTEAD OF, но &lt;a href=&quot;pragma#pragma_count_changes&quot;&gt;прагма count_changes&lt;/a&gt; учитывает срабатывание триггера INSTEAD OF.</target>
        </trans-unit>
        <trans-unit id="f4f048e66a09e44bfda0411919740620eea7756a" translate="yes" xml:space="preserve">
          <source>Note that the &lt;a href=&quot;c_deny&quot;&gt;SQLITE_IGNORE&lt;/a&gt; constant is also used as a potential return value from the &lt;a href=&quot;set_authorizer&quot;&gt;sqlite3_set_authorizer()&lt;/a&gt; callback and that &lt;a href=&quot;../rescode#abort&quot;&gt;SQLITE_ABORT&lt;/a&gt; is also a &lt;a href=&quot;../rescode&quot;&gt;result code&lt;/a&gt;.</source>
          <target state="translated">Обратите внимание, что константа &lt;a href=&quot;c_deny&quot;&gt;SQLITE_IGNORE&lt;/a&gt; также используется в качестве потенциального возвращаемого значения из обратного вызова &lt;a href=&quot;set_authorizer&quot;&gt;sqlite3_set_authorizer ()&lt;/a&gt; и что &lt;a href=&quot;../rescode#abort&quot;&gt;SQLITE_ABORT&lt;/a&gt; также является &lt;a href=&quot;../rescode&quot;&gt;кодом результата&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="732e678676cbad83be2195f0c9cbdf90bfcdfbeb" translate="yes" xml:space="preserve">
          <source>Note that the DO UPDATE clause acts only on the single row that experienced the constraint error during INSERT. It is not necessary to include a WHERE clause that restrictions the action to that one row. The only use for the WHERE clause at the end of the DO UPDATE is to optionally change the DO UPDATE into a no-op depending on the original and/or new values. For example:</source>
          <target state="translated">Обратите внимание,что выражение DO UPDATE действует только на единственной строке,в которой во время INSERT произошла ошибка ограничения.Нет необходимости включать условие WHERE,которое ограничивает действие одной строкой.Единственное использование выражения WHERE в конце DO UPDATE-это опциональное изменение DO UPDATE на no-op в зависимости от исходных и/или новых значений.Например:</target>
        </trans-unit>
        <trans-unit id="9e431af898d8e365308f86b50efb344365dfb157" translate="yes" xml:space="preserve">
          <source>Note that the SQLITE_TEXT constant was also used in SQLite version 2 for a completely different meaning. Software that links against both SQLite version 2 and SQLite version 3 should use SQLITE3_TEXT, not SQLITE_TEXT.</source>
          <target state="translated">Обратите внимание,что константа SQLITE_TEXT также использовалась в SQLite версии 2 в совершенно ином значении.Программное обеспечение,связанное как с SQLite версии 2,так и с SQLite версии 3,должно использовать SQLITE3_TEXT,а не SQLITE_TEXT.</target>
        </trans-unit>
        <trans-unit id="db7397560741b34c84d7c7b13b86a2bbf792ba5b" translate="yes" xml:space="preserve">
          <source>Note that the SQLite parser will not always generate code to use an index, even if it is possible to do so. The following queries will not currently use the index:</source>
          <target state="translated">Обратите внимание,что парсер SQLite не всегда будет генерировать код для использования индекса,даже если это возможно.Следующие запросы в настоящее время не будут использовать индекс:</target>
        </trans-unit>
        <trans-unit id="021cca6e0a1bc313b828c0c99864715910f5cf3d" translate="yes" xml:space="preserve">
          <source>Note that the UNION ALL operator for compound queries does not use transient indices by itself (though of course the right and left subqueries of the UNION ALL might use transient indices depending on how they are composed.)</source>
          <target state="translated">Обратите внимание,что оператор UNION ALL для составных запросов сам по себе не использует переходные индексы (хотя,конечно,правый и левый подзапросы UNION ALL могут использовать переходные индексы в зависимости от того,как они составлены).</target>
        </trans-unit>
        <trans-unit id="0676f5b60fd19b027ecab9b9999e5b7f746d671c" translate="yes" xml:space="preserve">
          <source>Note that the authorizer callback is invoked only during &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; or its variants. Authorization is not performed during statement evaluation in &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt;, unless as stated in the previous paragraph, sqlite3_step() invokes sqlite3_prepare_v2() to reprepare a statement after a schema change.</source>
          <target state="translated">Обратите внимание, что обратный вызов авторизатора вызывается только во время &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare ()&lt;/a&gt; или его вариантов. Авторизация не выполняется во время оценки оператора в &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step ()&lt;/a&gt; , если, как указано в предыдущем абзаце, sqlite3_step () не вызывает sqlite3_prepare_v2 () для представления оператора после изменения схемы.</target>
        </trans-unit>
        <trans-unit id="f1e28776761e0bfe4431c21ae77ea6373668b8fc" translate="yes" xml:space="preserve">
          <source>Note that the authorizer callback is invoked only during &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; or its variants. Authorization is not performed during statement evaluation in &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt;, unless as stated in the previous paragraph, sqlite3_step() invokes sqlite3_prepare_v2() to reprepare a statement after a schema change.</source>
          <target state="translated">Обратите внимание, что обратный вызов авторизатора вызывается только во время &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare ()&lt;/a&gt; или его вариантов. Авторизация не выполняется во время оценки оператора в &lt;a href=&quot;step&quot;&gt;sqlite3_step ()&lt;/a&gt; , если, как указано в предыдущем абзаце, sqlite3_step () не вызывает sqlite3_prepare_v2 () для представления оператора после изменения схемы.</target>
        </trans-unit>
        <trans-unit id="ac6d36a8492877c1ea3743d0c173020c27937cf2" translate="yes" xml:space="preserve">
          <source>Note that the character encoding mechanism used by SQLite cannot be changed at run-time. This is a compile-time option only. The &lt;b&gt;sqlite_encoding&lt;/b&gt; character string just tells you how the library was compiled.</source>
          <target state="translated">Обратите внимание, что механизм кодировки символов, используемый SQLite, нельзя изменить во время выполнения. Это опция только во время компиляции. &lt;b&gt;Sqlite_encoding&lt;/b&gt; символьная строка просто говорит вам , как была собрана библиотека.</target>
        </trans-unit>
        <trans-unit id="7febee2154ade1b2d3219ad0df6d8ce2b6d91690" translate="yes" xml:space="preserve">
          <source>Note that the checksums in the rollback journal are not necessary if the synchronous setting is FULL. We only depend on the checksums when synchronous is lowered to NORMAL. Nevertheless, the checksums never hurt and so they are included in the rollback journal regardless of the synchronous setting.</source>
          <target state="translated">Обратите внимание,что контрольные суммы в журнале отката не нужны,если настройка синхронизации FULL.Мы зависим только от контрольных сумм при снижении синхронной настройки до NORMAL.Тем не менее,контрольные суммы никогда не повреждаются и поэтому включаются в журнал отката независимо от синхронной установки.</target>
        </trans-unit>
        <trans-unit id="808239b91162b2ff74019b785a2c4443032a884a" translate="yes" xml:space="preserve">
          <source>Note that the command-line shell program has already enabled extension loading for you (by calling the &lt;a href=&quot;c3ref/enable_load_extension&quot;&gt;sqlite3_enable_load_extension()&lt;/a&gt; interface as part of its setup) so the command above works without any special switches, setup, or other complications.</source>
          <target state="translated">Обратите внимание, что программа оболочки командной строки уже включила для вас загрузку расширения (путем вызова интерфейса &lt;a href=&quot;c3ref/enable_load_extension&quot;&gt;sqlite3_enable_load_extension ()&lt;/a&gt; как части своей настройки), поэтому приведенная выше команда работает без каких-либо специальных переключателей, настройки или других сложностей.</target>
        </trans-unit>
        <trans-unit id="6e9cc72c28987333ade7d6e3571128f51c3b46dd" translate="yes" xml:space="preserve">
          <source>Note that the destructor function D is for the pointer value P, not for the type string T. The type string T should be a static string with an infinite lifetime.</source>
          <target state="translated">Обратите внимание,что функция деструктора D предназначена для значения указателя P,а не для строки типа T.Строка типа T должна быть статической строкой с бесконечным временем жизни.</target>
        </trans-unit>
        <trans-unit id="4cfa4e46e35f2a19630aea45991cffe3dd621ecd" translate="yes" xml:space="preserve">
          <source>Note that the integer key is one greater than the largest key that was in the table just prior to the insert. The new key will be unique over all keys currently in the table, but it might overlap with keys that have been previously deleted from the table. To create keys that are unique over the lifetime of the table, add the &lt;a href=&quot;autoinc&quot;&gt;AUTOINCREMENT&lt;/a&gt; keyword to the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; declaration. Then the key chosen will be one more than the largest key that has ever existed in that table. If the largest possible key has previously existed in that table, then the &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; will fail with an &lt;a href=&quot;rescode#full&quot;&gt;SQLITE_FULL&lt;/a&gt; error code.</source>
          <target state="translated">Обратите внимание, что целочисленный ключ на единицу больше, чем самый большой ключ, который был в таблице непосредственно перед вставкой. Новый ключ будет уникальным среди всех ключей, находящихся в настоящее время в таблице, но он может перекрываться с ключами, которые были ранее удалены из таблицы. Чтобы создать ключи, которые будут уникальными в течение всего времени существования таблицы, добавьте ключевое слово &lt;a href=&quot;autoinc&quot;&gt;AUTOINCREMENT&lt;/a&gt; в объявление &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; . Тогда выбранный ключ будет на один больше, чем самый большой ключ, который когда-либо существовал в этой таблице. Если в этой таблице ранее уже существовал самый большой из возможных ключей, то &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; завершится ошибкой с &lt;a href=&quot;rescode#full&quot;&gt;кодом SQLITE_FULL&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="228b63ead1b7d1b62a8c83539d4e8ab64da2dc4c" translate="yes" xml:space="preserve">
          <source>Note that the journal_mode for an &lt;a href=&quot;inmemorydb&quot;&gt;in-memory database&lt;/a&gt; is either MEMORY or OFF and can not be changed to a different value. An attempt to change the journal_mode of an &lt;a href=&quot;inmemorydb&quot;&gt;in-memory database&lt;/a&gt; to any setting other than MEMORY or OFF is ignored. Note also that the journal_mode cannot be changed while a transaction is active.</source>
          <target state="translated">Обратите внимание, что journal_mode для &lt;a href=&quot;inmemorydb&quot;&gt;базы данных в памяти&lt;/a&gt; имеет значение MEMORY или OFF и не может быть изменено на другое значение. Попытка изменить journal_mode &lt;a href=&quot;inmemorydb&quot;&gt;базы данных&lt;/a&gt; в памяти на любой параметр, кроме MEMORY или OFF, игнорируется. Также обратите внимание, что journal_mode нельзя изменить, пока транзакция активна.</target>
        </trans-unit>
        <trans-unit id="1150442b82dfad6909e59c690e94911009ab738b" translate="yes" xml:space="preserve">
          <source>Note that the list of routines above is conceptual rather than actual. Many of these routines come in multiple versions. For example, the list above shows a single routine named &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt; when in fact there are three separate routines that accomplish the same thing in slightly different ways: &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open16()&lt;/a&gt; and &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;. The list mentions &lt;a href=&quot;c3ref/column_blob&quot;&gt;sqlite3_column()&lt;/a&gt; when in fact no such routine exists. The &quot;sqlite3_column()&quot; shown in the list is a placeholder for an entire family of routines that extra column data in various datatypes.</source>
          <target state="translated">Обратите внимание, что приведенный выше список процедур является скорее концептуальным, чем фактическим. Многие из этих программ имеют несколько версий. Например, в приведенном выше списке показана одна подпрограмма с именем &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open (),&lt;/a&gt; хотя на самом деле есть три отдельных подпрограммы, которые выполняют одно и то же несколько разными способами: &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open ()&lt;/a&gt; , &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open16 ()&lt;/a&gt; и &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2 ()&lt;/a&gt; . В списке упоминается &lt;a href=&quot;c3ref/column_blob&quot;&gt;sqlite3_column (),&lt;/a&gt; хотя на самом деле такой процедуры не существует. Показанный в списке &amp;laquo;sqlite3_column ()&amp;raquo; является заполнителем для целого семейства подпрограмм, которые добавляют данные столбца в различные типы данных.</target>
        </trans-unit>
        <trans-unit id="4fdc00a153b8f8752a20bfd3564af15ee4f88900" translate="yes" xml:space="preserve">
          <source>Note that the memory leak detection logic continues to work even when the OOM overlay is being used. This verifies that SQLite does not leak memory even when it encounters memory allocation errors. Note also that the OOM overlay can work with any underlying memory allocator, including the instrumented memory allocator that checks for memory allocation misuse. In this way it is verified that OOM errors do not induce other kinds of memory usage errors.</source>
          <target state="translated">Обратите внимание,что логика обнаружения утечки памяти продолжает работать даже при использовании оверлея OOM.Это проверяет,что SQLite не утечка памяти,даже когда он сталкивается с ошибками выделения памяти.Заметьте также,что оверлей OOM может работать с любым аллокатором памяти,включая инструментированный аллокатор памяти,который проверяет неправильное выделение памяти.Таким образом,проверяется,что ошибки OOM не приводят к другим видам ошибок использования памяти.</target>
        </trans-unit>
        <trans-unit id="a2673a9d4ca364b864416763c5f28c9b8fac9ff0" translate="yes" xml:space="preserve">
          <source>Note that the number of keywords understood by SQLite can depend on compile-time options. For example, &quot;VACUUM&quot; is not a keyword if SQLite is compiled with the &lt;a href=&quot;../compile#omit_vacuum&quot;&gt;-DSQLITE_OMIT_VACUUM&lt;/a&gt; option. Also, new keywords may be added to future releases of SQLite.</source>
          <target state="translated">Обратите внимание, что количество ключевых слов, понимаемых SQLite, может зависеть от параметров времени компиляции. Например, &amp;laquo;VACUUM&amp;raquo; не является ключевым словом, если SQLite скомпилирован с параметром &lt;a href=&quot;../compile#omit_vacuum&quot;&gt;-DSQLITE_OMIT_VACUUM&lt;/a&gt; . Также новые ключевые слова могут быть добавлены в будущие выпуски SQLite.</target>
        </trans-unit>
        <trans-unit id="2d91b980ac2f1529b090c5eabcb20ce64f838c85" translate="yes" xml:space="preserve">
          <source>Note that the number of keywords understood by SQLite can depend on compile-time options. For example, &quot;VACUUM&quot; is not a keyword if SQLite is compiled with the &lt;a href=&quot;compile#omit_vacuum&quot;&gt;-DSQLITE_OMIT_VACUUM&lt;/a&gt; option. Also, new keywords may be added to future releases of SQLite.</source>
          <target state="translated">Обратите внимание, что количество ключевых слов, понимаемых SQLite, может зависеть от параметров времени компиляции. Например, &amp;laquo;VACUUM&amp;raquo; не является ключевым словом, если SQLite скомпилирован с параметром &lt;a href=&quot;compile#omit_vacuum&quot;&gt;-DSQLITE_OMIT_VACUUM&lt;/a&gt; . Также новые ключевые слова могут быть добавлены в будущие выпуски SQLite.</target>
        </trans-unit>
        <trans-unit id="4aca65a78510b061ab1efe777d7b5b2943653a08" translate="yes" xml:space="preserve">
          <source>Note that the order of the rules for determining column affinity is important. A column whose declared type is &quot;CHARINT&quot; will match both rules 1 and 2 but the first rule takes precedence and so the column affinity will be INTEGER.</source>
          <target state="translated">Обратите внимание,что порядок правил определения сродства столбцов важен.Столбец с объявленным типом &quot;CHARINT&quot; будет соответствовать и правилам 1 и 2,но первое правило имеет приоритет,поэтому сродство столбца будет INTEGER.</target>
        </trans-unit>
        <trans-unit id="1d73e69c69eafce89c99fd09f5dcbc2e6299190a" translate="yes" xml:space="preserve">
          <source>Note that the primary result code is always a part of the extended result code. Given a full 32-bit extended result code, the application can always find the corresponding primary result code merely by extracting the least significant 8 bits of the extended result code.</source>
          <target state="translated">Обратите внимание,что первичный код результата всегда является частью расширенного кода результата.При полном 32-битном расширенном результирующем коде приложение всегда может найти соответствующий код первичного результата,просто извлекая из расширенного результирующего кода наименее значащие 8 бит.</target>
        </trans-unit>
        <trans-unit id="299082c757bfbc2b1a98c9af13620cc48c49d3d4" translate="yes" xml:space="preserve">
          <source>Note that the program for this SELECT query didn't contain the Transaction and Commit instructions used in the INSERT example. Because the SELECT is a read operation that doesn't alter the database, it doesn't require a transaction.</source>
          <target state="translated">Обратите внимание,что программа для данного SELECT-запроса не содержала инструкций Transaction and Commit,используемых в примере INSERT.Поскольку SELECT-это операция чтения,которая не изменяет базу данных,она не требует транзакции.</target>
        </trans-unit>
        <trans-unit id="f586476195ef53b793699f052ad1af05d3a6c8e4" translate="yes" xml:space="preserve">
          <source>Note that the readfile(X) and writefile(X,Y) functions are extension functions and are not built into the core SQLite library. These routines are available as a &lt;a href=&quot;loadext&quot;&gt;loadable extension&lt;/a&gt; in the &lt;a href=&quot;http://www.sqlite.org/src/artifact?ci=trunk&amp;amp;filename=ext/misc/fileio.c&quot;&gt;ext/misc/fileio.c&lt;/a&gt; source file in the &lt;a href=&quot;https://sqlite.org/download.html#srctree&quot;&gt;SQLite source code repositories&lt;/a&gt;.</source>
          <target state="translated">Обратите внимание, что функции readfile (X) и writefile (X, Y) являются функциями расширения и не встроены в базовую библиотеку SQLite. Эти процедуры доступны в виде &lt;a href=&quot;loadext&quot;&gt;загружаемых расширений&lt;/a&gt; в исходном файле &lt;a href=&quot;http://www.sqlite.org/src/artifact?ci=trunk&amp;amp;filename=ext/misc/fileio.c&quot;&gt;ext / misc / fileio.c&lt;/a&gt; в &lt;a href=&quot;https://sqlite.org/download.html#srctree&quot;&gt;репозиториях исходного кода SQLite&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="672e23ac6cc2cc98d9511ab1e12385a015260590" translate="yes" xml:space="preserve">
          <source>Note that the readfile(X) and writefile(X,Y) functions are extension functions and are not built into the core SQLite library. These routines are available as a &lt;a href=&quot;loadext&quot;&gt;loadable extension&lt;/a&gt; in the &lt;a href=&quot;https://www.sqlite.org/src/artifact?ci=trunk&amp;amp;filename=ext/misc/fileio.c&quot;&gt;ext/misc/fileio.c&lt;/a&gt; source file in the &lt;a href=&quot;https://sqlite.org/download.html#srctree&quot;&gt;SQLite source code repositories&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64553501493418021ca0b221dddc1b5aa622fbc2" translate="yes" xml:space="preserve">
          <source>Note that the result from casting any non-BLOB value into a BLOB and the result from casting any BLOB value into a non-BLOB value may be different depending on whether the database &lt;a href=&quot;pragma#pragma_encoding&quot;&gt;encoding&lt;/a&gt; is UTF-8, UTF-16be, or UTF-16le.</source>
          <target state="translated">Обратите внимание, что результат преобразования любого значения, отличного от BLOB, в BLOB и результат преобразования любого значения BLOB в значение, отличное от BLOB, могут отличаться в зависимости от того, является ли &lt;a href=&quot;pragma#pragma_encoding&quot;&gt;кодировка&lt;/a&gt; базы данных UTF-8, UTF-16be или UTF-16le. .</target>
        </trans-unit>
        <trans-unit id="e984670ffac060fe0c3430de1a1c23ffe29028d1" translate="yes" xml:space="preserve">
          <source>Note that the sqlite3changeset_apply_v2() API is still &lt;b&gt;experimental&lt;/b&gt; and therefore subject to change.</source>
          <target state="translated">Обратите внимание, что API sqlite3changeset_apply_v2 () все еще является &lt;b&gt;экспериментальным&lt;/b&gt; и поэтому может быть изменен.</target>
        </trans-unit>
        <trans-unit id="a04165c5ad09a6b0ad2414206038c2e65d87aa51" translate="yes" xml:space="preserve">
          <source>Note that the sqlite3changeset_start_v2() API is still &lt;b&gt;experimental&lt;/b&gt; and therefore subject to change.</source>
          <target state="translated">Обратите внимание, что API sqlite3changeset_start_v2 () все еще является &lt;b&gt;экспериментальным&lt;/b&gt; и поэтому может быть изменен.</target>
        </trans-unit>
        <trans-unit id="6c55c88c2dea7079ec802efa3e99479f764ecf7e" translate="yes" xml:space="preserve">
          <source>Note that the unary *+* operator also removes &lt;a href=&quot;datatype3#affinity&quot;&gt;type affinity&lt;/a&gt; from an expression, and in some cases this can cause subtle changes in the meaning of an expression. In the example above, if column *x* has &lt;a href=&quot;datatype3#affinity&quot;&gt;TEXT affinity&lt;/a&gt; then the comparison &quot;x=5&quot; will be done as text. But the *+* operator removes the affinity. So the comparison &quot;+x=5&quot; will compare the text in column *x* with the numeric value 5 and will always be false.</source>
          <target state="translated">Обратите внимание, что унарный оператор * + * также удаляет &lt;a href=&quot;datatype3#affinity&quot;&gt;сходство типов&lt;/a&gt; из выражения, и в некоторых случаях это может вызвать незначительные изменения в значении выражения. В приведенном выше примере, если столбец * x * имеет соответствие &lt;a href=&quot;datatype3#affinity&quot;&gt;ТЕКСТА,&lt;/a&gt; тогда сравнение &amp;laquo;x = 5&amp;raquo; будет выполнено как текст. Но оператор * + * убирает сродство. Таким образом, сравнение &amp;laquo;+ x = 5&amp;raquo; будет сравнивать текст в столбце * x * с числовым значением 5 и всегда будет ложным.</target>
        </trans-unit>
        <trans-unit id="d81068a6cb6b3b6084654f5758e6e2d51e7af994" translate="yes" xml:space="preserve">
          <source>Note that the unary &lt;b&gt;+&lt;/b&gt; operator also removes &lt;a href=&quot;datatype3#affinity&quot;&gt;type affinity&lt;/a&gt; from an expression, and in some cases this can cause subtle changes in the meaning of an expression. In the example above, if column &lt;b&gt;x&lt;/b&gt; has &lt;a href=&quot;datatype3#affinity&quot;&gt;TEXT affinity&lt;/a&gt; then the comparison &quot;x=5&quot; will be done as text. The &lt;b&gt;+&lt;/b&gt; operator removes the affinity. So the comparison &quot;&lt;b&gt;+x=5&lt;/b&gt;&quot; will compare the text in column &lt;b&gt;x&lt;/b&gt; with the numeric value 5 and will always be false.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c990d58c5d0bc49b39ec476dafbb19955404bbcd" translate="yes" xml:space="preserve">
          <source>Note that there are paths through the syntax diagrams that are not allowed in practice. Some examples:</source>
          <target state="translated">Обратите внимание,что есть пути через синтаксические диаграммы,которые не разрешены на практике.Некоторые примеры:</target>
        </trans-unit>
        <trans-unit id="96acc3ff45ab0c01a0b94c0892486dbb72afce32" translate="yes" xml:space="preserve">
          <source>Note that there are two variations of the equals and not equals operators. Equals can be either</source>
          <target state="translated">Обратите внимание,что существует два варианта равенства и не равенства операторов.Равные могут быть также</target>
        </trans-unit>
        <trans-unit id="a67d64fb18ca2294fb42994c6d74eeb61ff03be8" translate="yes" xml:space="preserve">
          <source>Note that this is only a thought experiment. We are not suggesting that OpenDocument be changed. Nor is this article a criticism of the current OpenDocument design. The point of this essay is to suggest ways to improve future file format designs.</source>
          <target state="translated">Обратите внимание,что это всего лишь мыслительный эксперимент.Мы не предлагаем изменять OpenDocument.Эта статья также не является критикой текущего дизайна OpenDocument.Смысл этого эссе в том,чтобы предложить способы улучшения дизайна будущих форматов файлов.</target>
        </trans-unit>
        <trans-unit id="99c1505807d577ab62bcd4edbb24d5f3cd06e9f6" translate="yes" xml:space="preserve">
          <source>Note that this problem only occurs if the attempt to acquire the lock resulted in an I/O error. If the lock is simply not granted (because some other thread or process is already holding a conflicting lock) then no corruption will ever occur. We are not aware of any operating systems that will fail with an I/O error while attempting to get a file lock on shared memory. So this is a theoretical problem rather than a real problem. Needless to say, this problem has never been observed in the wild. The problem was discovered while doing stress testing of SQLite in a test harness that simulates I/O errors.</source>
          <target state="translated">Обратите внимание,что эта проблема возникает только в том случае,если попытка получения блокировки привела к ошибке ввода/вывода.Если блокировка просто не разрешена (потому что какой-то другой поток или процесс уже имеет конфликтующую блокировку),то повреждений никогда не произойдет.Мы не знаем ни одной операционной системы,которая бы не справилась с ошибкой ввода/вывода при попытке получить файловую блокировку в общей памяти.Таким образом,это скорее теоретическая проблема,чем реальная проблема.Нет нужды говорить,что эта проблема никогда не наблюдалась в дикой природе.Проблема была обнаружена во время стресс-тестирования SQLite в тестовом жгуте,который моделирует ошибки ввода/вывода.</target>
        </trans-unit>
        <trans-unit id="ebff595e74a177f5fa63d87902cc62cb3ce02f96" translate="yes" xml:space="preserve">
          <source>Note that this routine returns zero on a match and non-zero if the strings do not match, the same as &lt;a href=&quot;#sqlite3_stricmp&quot;&gt;sqlite3_stricmp()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_stricmp&quot;&gt;sqlite3_strnicmp()&lt;/a&gt;.</source>
          <target state="translated">Обратите внимание, что эта процедура возвращает ноль при совпадении и ненулевое значение, если строки не совпадают, так же, как &lt;a href=&quot;#sqlite3_stricmp&quot;&gt;sqlite3_stricmp ()&lt;/a&gt; и &lt;a href=&quot;#sqlite3_stricmp&quot;&gt;sqlite3_strnicmp ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0d629b76283bd20b6edf31050b7b9b764c009820" translate="yes" xml:space="preserve">
          <source>Note that this routine returns zero on a match and non-zero if the strings do not match, the same as &lt;a href=&quot;stricmp&quot;&gt;sqlite3_stricmp()&lt;/a&gt; and &lt;a href=&quot;stricmp&quot;&gt;sqlite3_strnicmp()&lt;/a&gt;.</source>
          <target state="translated">Обратите внимание, что эта процедура возвращает ноль при совпадении и ненулевое значение, если строки не совпадают, так же, как &lt;a href=&quot;stricmp&quot;&gt;sqlite3_stricmp ()&lt;/a&gt; и &lt;a href=&quot;stricmp&quot;&gt;sqlite3_strnicmp ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c810fa4c8943f66ac3d34092b7e767d31528340e" translate="yes" xml:space="preserve">
          <source>Note that triggers are automatically dropped when the associated table is dropped.</source>
          <target state="translated">Обратите внимание,что триггеры автоматически сбрасываются при сбросе соответствующей таблицы.</target>
        </trans-unit>
        <trans-unit id="d606f23ac3535efbf11c3a7516392c25071ecf15" translate="yes" xml:space="preserve">
          <source>Note that when SQLite is compiled with SQLITE_THREADSAFE=0, the code to make SQLite threadsafe is omitted from the build. When this occurs, it is impossible to change the &lt;a href=&quot;threadsafe&quot;&gt;threading mode&lt;/a&gt; at start-time or run-time.</source>
          <target state="translated">Обратите внимание, что когда SQLite скомпилирован с SQLITE_THREADSAFE = 0, код для обеспечения безопасности потоков SQLite не включается в сборку. Когда это происходит, невозможно изменить &lt;a href=&quot;threadsafe&quot;&gt;режим работы&lt;/a&gt; с потоками во время запуска или выполнения.</target>
        </trans-unit>
        <trans-unit id="32708b7e6e76296f6dad18be6a6d369658183e8b" translate="yes" xml:space="preserve">
          <source>Note that when the SQLITE_DBCONFIG_LEGACY_FILE_FORMAT setting is on, the &lt;a href=&quot;../lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; command will fail with an obscure error when attempting to process a table with generated columns and a descending index. This is not considered a bug since SQLite versions 3.3.0 and earlier do not support either generated columns or decending indexes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3822538f7b251248e21c02ba82556fd2e3a92957" translate="yes" xml:space="preserve">
          <source>Note that when the SQLITE_DBCONFIG_LEGACY_FILE_FORMAT setting is on, the &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; command will fail with an obscure error when attempting to process a table with generated columns and a descending index. This is not considered a bug since SQLite versions 3.3.0 and earlier do not support either generated columns or decending indexes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="789391b5c680547fd2d7df978b13d5bea4b6c611" translate="yes" xml:space="preserve">
          <source>Note that when the right-hand side of a LIKE or GLOB operator is a &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameter&lt;/a&gt; and the statement is prepared using &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; or &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare16_v2()&lt;/a&gt; then the statement is automatically reparsed and recompiled on the first &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; call of each run if the binding to the right-hand side parameter has changed since the previous run. This reparse and recompile is essentially the same action that occurs following a schema change. The recompile is necessary so that the query planner can examine the new value bound to the right-hand side of the LIKE or GLOB operator and determine whether or not to employ the optimization described above.</source>
          <target state="translated">Обратите внимание, что если правая часть оператора LIKE или GLOB является &lt;a href=&quot;lang_expr#varparam&quot;&gt;параметром&lt;/a&gt; и оператор подготовлен с использованием &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; или &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare16_v2 (),&lt;/a&gt; тогда оператор автоматически повторно анализируется и перекомпилируется при первом вызове &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step ()&lt;/a&gt; каждого запуска, если привязка к правому параметру изменилась по сравнению с предыдущим запуском. Этот повторный анализ и перекомпиляция - это, по сути, то же действие, которое происходит после изменения схемы. Перекомпиляция необходима для того, чтобы планировщик запросов мог проверить новое значение, привязанное к правой стороне оператора LIKE или GLOB, и определить, следует ли использовать оптимизацию, описанную выше.</target>
        </trans-unit>
        <trans-unit id="7aca89c620a18b6fdc63e568bea908a626dcadff" translate="yes" xml:space="preserve">
          <source>Note that when type conversions occur, pointers returned by prior calls to sqlite3_column_blob(), sqlite3_column_text(), and/or sqlite3_column_text16() may be invalidated. Type conversions and pointer invalidations might occur in the following cases:</source>
          <target state="translated">Обратите внимание,что при приведении типов указатели,возвращенные предыдущими вызовами sqlite3_column_blob(),sqlite3_column_text()и/или sqlite3_column_text16(),могут быть признаны недействительными.Приведение типов и аннулирование указателей может произойти в следующих случаях:</target>
        </trans-unit>
        <trans-unit id="1368e4859dec1f8b656ae1f17b0c284cfecc238a" translate="yes" xml:space="preserve">
          <source>Note that with &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous&lt;/a&gt; set to NORMAL, the checkpoint is the only operation to issue an I/O barrier or sync operation (fsync() on unix or FlushFileBuffers() on windows). If an application therefore runs checkpoint in a separate thread or process, the main thread or process that is doing database queries and updates will never block on a sync operation. This helps to prevent &quot;latch-up&quot; in applications running on a busy disk drive. The downside to this configuration is that transactions are no longer durable and might rollback following a power failure or hard reset.</source>
          <target state="translated">Обратите внимание, что с &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;синхронным PRAGMA,&lt;/a&gt; установленным на NORMAL, контрольная точка является единственной операцией, которая создает барьер ввода-вывода или операцию синхронизации (fsync () в unix или FlushFileBuffers () в Windows). Таким образом, если приложение запускает контрольную точку в отдельном потоке или процессе, основной поток или процесс, выполняющий запросы к базе данных и обновления, никогда не будет блокироваться при операции синхронизации. Это помогает предотвратить &amp;laquo;зависание&amp;raquo; приложений, работающих на загруженном диске. Обратной стороной этой конфигурации является то, что транзакции больше не являются надежными и могут откатиться после сбоя питания или жесткого сброса.</target>
        </trans-unit>
        <trans-unit id="8da0c032621fbb18df4dc03aaa124440bc316a57" translate="yes" xml:space="preserve">
          <source>Note that with ANALYZE the cost estimates are better aligned with reality and algorithm-1 is selected by both NN and N3.</source>
          <target state="translated">Обратите внимание,что при использовании ANALYZE смета расходов лучше согласуется с реальностью,а алгоритм-1 выбирается как NN,так и N3.</target>
        </trans-unit>
        <trans-unit id="695e607ef01e6db075031ffa227e23ca60904541" translate="yes" xml:space="preserve">
          <source>Note that xBestIndex will always be called before &lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter&lt;/a&gt;, since the idxNum and idxStr outputs from xBestIndex are required inputs to xFilter. However, there is no guarantee that xFilter will be called following a successful xBestIndex.</source>
          <target state="translated">Обратите внимание, что xBestIndex всегда будет вызываться перед &lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter&lt;/a&gt; , поскольку выходные данные idxNum и idxStr из xBestIndex являются обязательными входными данными для xFilter. Однако нет гарантии, что xFilter будет вызван после успешного xBestIndex.</target>
        </trans-unit>
        <trans-unit id="d227a38478007bafe1c5681fa0c0259f1628a846" translate="yes" xml:space="preserve">
          <source>Note the &quot;temp.&quot; qualifier before the virtual table name (&quot;stat&quot;). This qualifier causes the virtual table to be temporary - to only exist for the duration of the current database connection. This is the recommended approach.</source>
          <target state="translated">Обратите внимание на классификатор &quot;temp.&quot; перед именем виртуальной таблицы (&quot;stat&quot;).Этот классификатор приводит к тому,что виртуальная таблица будет временной-существовать только на время текущего подключения к БД.Это рекомендуемый подход.</target>
        </trans-unit>
        <trans-unit id="984a9d35869a9cec59e40e09a2d60d76afb99304" translate="yes" xml:space="preserve">
          <source>Note the last bullet in particular. The destructor X in sqlite3_set_auxdata(C,N,P,X) might be called immediately, before the sqlite3_set_auxdata() interface even returns. Hence sqlite3_set_auxdata() should be called near the end of the function implementation and the function implementation should not make any use of P after sqlite3_set_auxdata() has been called.</source>
          <target state="translated">Обратите внимание на последнюю пулю.Деструктор X в sqlite3_set_auxdata(C,N,P,X)может быть вызван сразу же,еще до того,как интерфейс sqlite3_set_auxdata()вернется.Следовательно,sqlite3_set_auxdata()должна вызываться ближе к концу реализации функции,а реализация функции не должна использовать P после вызова sqlite3_set_auxdata().</target>
        </trans-unit>
        <trans-unit id="be13ad345e0dba5ca596ce6f7266fdf09fc32236" translate="yes" xml:space="preserve">
          <source>Note the use of the &lt;a href=&quot;lang_corefunc#quote&quot;&gt;quote() SQL function&lt;/a&gt; in these triggers. The quote() function converts its argument into a form that is appropriate for inclusion in an SQL statement. Numeric values come through unchanged. Single quotes are added before and after strings and any internal single quotes are escaped. BLOB values are rendered using SQL-standard hexadecimal BLOB notation. The use of the quote() function ensures that the SQL statements used to undo and redo are always safe from SQL injection.</source>
          <target state="translated">Обратите внимание на использование в этих триггерах &lt;a href=&quot;lang_corefunc#quote&quot;&gt;SQL-функции quote ()&lt;/a&gt; . Функция quote () преобразует свой аргумент в форму, подходящую для включения в оператор SQL. Числовые значения остаются без изменений. Одиночные кавычки добавляются до и после строк, а любые внутренние одинарные кавычки экранируются. Значения BLOB отображаются с использованием стандартной шестнадцатеричной записи BLOB в стандарте SQL. Использование функции quote () гарантирует, что операторы SQL, используемые для отмены и повтора, всегда защищены от внедрения SQL.</target>
        </trans-unit>
        <trans-unit id="044b3a09040052b2232feb80c6848441318257d4" translate="yes" xml:space="preserve">
          <source>Note the warnings on the &quot;estimatedRows&quot;, &quot;idxFlags&quot;, and colUsed fields. These fields were added with SQLite versions 3.8.2, 3.9.0, and 3.10.0, respectively. Any extension that reads or writes these fields must first check that the version of the SQLite library in use is greater than or equal to appropriate version - perhaps comparing the value returned from &lt;a href=&quot;c3ref/libversion&quot;&gt;sqlite3_libversion_number()&lt;/a&gt; against constants 3008002, 3009000, and/or 3010000. The result of attempting to access these fields in an sqlite3_index_info structure created by an older version of SQLite are undefined.</source>
          <target state="translated">Обратите внимание на предупреждения в полях &amp;laquo;EstimatedRows&amp;raquo;, &amp;laquo;idxFlags&amp;raquo; и colUsed. Эти поля были добавлены в SQLite версий 3.8.2, 3.9.0 и 3.10.0 соответственно. Любое расширение, которое считывает или записывает эти поля, должно сначала проверить, что версия используемой библиотеки SQLite больше или равна соответствующей версии - возможно, сравнивая значение, возвращаемое функцией &lt;a href=&quot;c3ref/libversion&quot;&gt;sqlite3_libversion_number (),&lt;/a&gt; с константами 3008002, 3009000 и / или 3010000. Результат попытки доступа к этим полям в структуре sqlite3_index_info, созданной более старой версией SQLite, не определен.</target>
        </trans-unit>
        <trans-unit id="49bc1f28a1c9c886ae8bd63cbcbb27c797246229" translate="yes" xml:space="preserve">
          <source>Note: Functions marked with &quot;&lt;small&gt;&lt;i&gt;(exp)&lt;/i&gt;&lt;/small&gt;&quot; are &lt;a href=&quot;capi3ref&quot;&gt;experimental&lt;/a&gt; and functions whose names are &lt;s&gt;struck through&lt;/s&gt; are &lt;a href=&quot;capi3ref&quot;&gt;deprecated&lt;/a&gt;.</source>
          <target state="translated">Примечание. Функции, отмеченные знаком &amp;laquo; &lt;small&gt;&lt;i&gt;(exp)&lt;/i&gt;&lt;/small&gt; &amp;raquo;, являются &lt;a href=&quot;capi3ref&quot;&gt;экспериментальными,&lt;/a&gt; а функции, имена которых &lt;s&gt;зачеркнуты,&lt;/s&gt; считаются &lt;a href=&quot;capi3ref&quot;&gt;устаревшими&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="66ee76f5066068620f09c7e62f4bb8c158c87cf7" translate="yes" xml:space="preserve">
          <source>Note: Functions marked with &quot;&lt;small&gt;&lt;i&gt;(exp)&lt;/i&gt;&lt;/small&gt;&quot; are &lt;a href=&quot;experimental&quot;&gt;experimental&lt;/a&gt; and functions whose names are &lt;s&gt;struck through&lt;/s&gt; are &lt;a href=&quot;experimental&quot;&gt;deprecated&lt;/a&gt;.</source>
          <target state="translated">Примечание. Функции, отмеченные знаком &amp;laquo; &lt;small&gt;&lt;i&gt;(exp)&lt;/i&gt;&lt;/small&gt; &amp;raquo;, являются &lt;a href=&quot;experimental&quot;&gt;экспериментальными,&lt;/a&gt; а функции, имена которых &lt;s&gt;зачеркнуты,&lt;/s&gt; считаются &lt;a href=&quot;experimental&quot;&gt;устаревшими&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="03b148e28fde4df0887542e9d88b598d5e8f42db" translate="yes" xml:space="preserve">
          <source>Note: Sections 2.0 and 3.0 of this article were added in response to comments on &lt;a href=&quot;https://news.ycombinator.com/item?id=16585120&quot;&gt;Hacker News&lt;/a&gt; and &lt;a href=&quot;https://www.reddit.com/r/programming/comments/84fzoc/why_is_sqlite_coded_in_c/&quot;&gt;Reddit&lt;/a&gt;.</source>
          <target state="translated">Примечание. Разделы 2.0 и 3.0 этой статьи были добавлены в ответ на комментарии к &lt;a href=&quot;https://news.ycombinator.com/item?id=16585120&quot;&gt;Hacker News&lt;/a&gt; и &lt;a href=&quot;https://www.reddit.com/r/programming/comments/84fzoc/why_is_sqlite_coded_in_c/&quot;&gt;Reddit&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="85e051b1f236f895d99d48916ab5fd667388aec3" translate="yes" xml:space="preserve">
          <source>Note: This method is disabled on MacOS X 10.7 and iOS version 5.0 and will always return SQLITE_MISUSE. On those systems, shared cache mode should be enabled per-database connection via &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; with &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_SHAREDCACHE&lt;/a&gt;.</source>
          <target state="translated">Примечание. Этот метод отключен в MacOS X 10.7 и iOS версии 5.0 и всегда будет возвращать SQLITE_MISUSE. В этих системах режим общего кеша должен быть включен для подключения к базе данных через &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2 ()&lt;/a&gt; с &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_SHAREDCACHE&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ddf57deb38e4651cb3981116d2b9ec03a6feb885" translate="yes" xml:space="preserve">
          <source>Note: This method is disabled on MacOS X 10.7 and iOS version 5.0 and will always return SQLITE_MISUSE. On those systems, shared cache mode should be enabled per-database connection via &lt;a href=&quot;open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; with &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_SHAREDCACHE&lt;/a&gt;.</source>
          <target state="translated">Примечание. Этот метод отключен в MacOS X 10.7 и iOS версии 5.0 и всегда будет возвращать SQLITE_MISUSE. В этих системах режим общего кеша должен быть включен для подключения к базе данных через &lt;a href=&quot;open&quot;&gt;sqlite3_open_v2 ()&lt;/a&gt; с &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_SHAREDCACHE&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="70440046a3dc2e079f23ee1c57dfa76669b732aa" translate="yes" xml:space="preserve">
          <source>Notes</source>
          <target state="translated">Notes</target>
        </trans-unit>
        <trans-unit id="b7c62ae6be1885d1c5a81f6a7886c67b36419ed4" translate="yes" xml:space="preserve">
          <source>Notes on the &lt;a href=&quot;optoverview&quot;&gt;query optimizer&lt;/a&gt;.</source>
          <target state="translated">Примечания к &lt;a href=&quot;optoverview&quot;&gt;оптимизатору запросов&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9c3befe7e22c8667bc957541f49b0ee79970b588" translate="yes" xml:space="preserve">
          <source>Notes:</source>
          <target state="translated">Notes:</target>
        </trans-unit>
        <trans-unit id="bb5c89c5cb4409cab6ee44d716c6d95feaaddc62" translate="yes" xml:space="preserve">
          <source>Notice how the LIKE operator is implemented. It is a user-defined function in SQLite, so the address of its function definition is specified in P3. The operand P1 is the number of function arguments for it to take from the stack. In this case the LIKE() function takes 2 arguments. The arguments are taken off the stack in reverse order (right-to-left), so the pattern to match is the top stack element, and the next element is the data to compare. The return value is pushed onto the stack.</source>
          <target state="translated">Обратите внимание,как реализуется оператор LIKE.В SQLite это пользовательская функция,поэтому адрес ее определения указан в P3.Операнд P1-это количество аргументов функции,которое она может взять из стека.В этом случае функция LIKE()принимает 2 аргумента.Аргументы снимаются со стека в обратном порядке (справа налево),поэтому подходящий образец-верхний элемент стека,а следующий элемент-данные для сравнения.Возвращаемое значение перемещается в стек.</target>
        </trans-unit>
        <trans-unit id="5255c6a9b36d606aac6af8d3dbbceadb0d1f9b02" translate="yes" xml:space="preserve">
          <source>Notice how the query above works: The R*Tree index runs in the outer loop to find entries that are contained within the bounding box of longitude -81..-79.6 and latitude 35.0..36.2. For each object identifier found, SQLite looks up the corresponding entry in the demo_data table. It then uses the boundary field from the demo_data table as a parameter to the contained_in() function and if that function returns true, the objname field from the demo_data table is returned as the next row of query result.</source>
          <target state="translated">Обратите внимание,как работает вышеприведенный запрос:Индекс R*Tree запускается во внешнем цикле для поиска записей,которые содержатся в граничном поле долготы -81...-79.6 и широты 35.0...36.2.Для каждого найденного идентификатора объекта SQLite ищет соответствующую запись в таблице demo_data.Затем он использует граничное поле из таблицы demo_data в качестве параметра в функцию contain_in(),и если эта функция возвращает true,то поле объектного имени из таблицы demo_data возвращается в качестве следующей строки результата запроса.</target>
        </trans-unit>
        <trans-unit id="3b7384e004cca4a56bb485375c44be1a10c5774f" translate="yes" xml:space="preserve">
          <source>Notice that all other date and time functions can be expressed in terms of strftime():</source>
          <target state="translated">Обратите внимание,что все остальные функции даты и времени могут быть выражены с помощью функции strftime():</target>
        </trans-unit>
        <trans-unit id="a0897fe8cedb04900939c7986a4c19ddb9b29972" translate="yes" xml:space="preserve">
          <source>Notice that dividing up the content into smaller pieces using an SQLite table gives flexibility to the implementation. The application can choose to read all content into memory at startup. Or it can read just a few pages into memory and keep the rest on disk. Or it can read just single page into memory at a time. And different versions of the application can make different choices without having to make any changes to the file format. Such options are not available when all content is in a single big XML file in a ZIP archive.</source>
          <target state="translated">Обратите внимание,что разделение содержимого на более мелкие кусочки с помощью таблицы SQLite дает гибкость в реализации.При запуске приложение может выбрать чтение всего содержимого в память.Или же оно может прочитать всего несколько страниц в память,а остальное оставить на диске.Или же оно может читать только одну страницу в память одновременно.И разные версии приложения могут делать разный выбор без необходимости вносить изменения в формат файла.Такие опции недоступны,когда все содержимое находится в одном большом XML-файле в ZIP-архиве.</target>
        </trans-unit>
        <trans-unit id="8b6637336242d861c3d1aedafa06202a9a576add" translate="yes" xml:space="preserve">
          <source>Notice that the &quot;host&quot; value for the &quot;dummy&quot; record is NULL so the result[] array contains a NULL pointer at that slot.</source>
          <target state="translated">Обратите внимание,что значение &quot;host&quot; для записи &quot;dummy&quot; равно NULL,поэтому массив result[]содержит в этом слоте указатель NULL.</target>
        </trans-unit>
        <trans-unit id="81da02d10ebbcf526492f91d32dd8afa2884d608" translate="yes" xml:space="preserve">
          <source>Notice that the parameters to functions are now pointers to sqlite3_value structures instead of pointers to strings as in SQLite version 2.X. The following routines are used to extract useful information from these &quot;values&quot;:</source>
          <target state="translated">Обратите внимание,что параметры функций теперь являются указателями на структуры sqlite3_value вместо указателей на строки,как в SQLite версии 2.X.Следующие процедуры используются для извлечения полезной информации из этих &quot;значений&quot;:</target>
        </trans-unit>
        <trans-unit id="45ef496d245754f1f4daa860e31545d9feaf1aea" translate="yes" xml:space="preserve">
          <source>Notice that the shared lock is on the operating system disk cache, not on the disk itself. File locks really are just flags within the operating system kernel, usually. (The details depend on the specific OS layer interface.) Hence, the lock will instantly vanish if the operating system crashes or if there is a power loss. It is usually also the case that the lock will vanish if the process that created the lock exits.</source>
          <target state="translated">Обратите внимание,что разделяемая блокировка находится в кэше диска операционной системы,а не на самом диске.Файловые блокировки на самом деле-это просто флаги в ядре операционной системы,обычно.(Детали зависят от конкретного интерфейса уровня операционной системы.)Следовательно,блокировка мгновенно исчезнет,если операционная система выйдет из строя или произойдет отключение питания.Обычно блокировка также исчезает,если процесс,создавший блокировку,завершает свою работу.</target>
        </trans-unit>
        <trans-unit id="f8f4b80268c40011630e5371241e6ab982124215" translate="yes" xml:space="preserve">
          <source>Notice that the tokens in the result set from the fts3tokenize virtual table have been transformed according to the rules of the tokenizer. Since this example used the &quot;porter&quot; tokenizer, the &quot;This&quot; token was converted into &quot;thi&quot;. If the original text of the token is desired, it can be retrieved using the &quot;start&quot; and &quot;end&quot; columns with the &lt;a href=&quot;lang_corefunc#substr&quot;&gt;substr()&lt;/a&gt; function. For example:</source>
          <target state="translated">Обратите внимание, что токены в результирующем наборе из виртуальной таблицы fts3tokenize были преобразованы в соответствии с правилами токенизатора. Поскольку в этом примере использовался токенизатор &amp;laquo;porter&amp;raquo;, токен &amp;laquo;This&amp;raquo; был преобразован в &amp;laquo;thi&amp;raquo;. Если требуется исходный текст токена, его можно получить, используя столбцы &amp;laquo;начало&amp;raquo; и &amp;laquo;конец&amp;raquo; с помощью функции &lt;a href=&quot;lang_corefunc#substr&quot;&gt;substr ()&lt;/a&gt; . Например:</target>
        </trans-unit>
        <trans-unit id="af54971d34d4b499061179fcac4a7f0e1fee4c0f" translate="yes" xml:space="preserve">
          <source>Notice the similarity between the ListRead and Next instructions. Both operations work according to this rule:</source>
          <target state="translated">Обратите внимание на сходство между инструкциями ListRead и Next.Обе операции работают по этому правилу:</target>
        </trans-unit>
        <trans-unit id="7cec2e96076ffe89a48a9bb0d641ff84dbe2e0a2" translate="yes" xml:space="preserve">
          <source>Notice too that there is a tradeoff between average read performance and average write performance. To maximize the read performance, one wants to keep the WAL as small as possible and hence run checkpoints frequently, perhaps as often as every COMMIT. To maximize write performance, one wants to amortize the cost of each checkpoint over as many writes as possible, meaning that one wants to run checkpoints infrequently and let the WAL grow as large as possible before each checkpoint. The decision of how often to run checkpoints may therefore vary from one application to another depending on the relative read and write performance requirements of the application. The default strategy is to run a checkpoint once the WAL reaches 1000 pages and this strategy seems to work well in test applications on workstations, but other strategies might work better on different platforms or for different workloads.</source>
          <target state="translated">Заметьте также,что существует компромисс между средней производительностью чтения и средней производительностью записи.Чтобы максимизировать производительность при чтении,необходимо сохранять стены как можно меньше и,следовательно,запускать контрольно-пропускные пункты часто,возможно,так же часто,как и каждый КОММИТ.Чтобы максимизировать производительность записи,хочется амортизировать стоимость каждой контрольно-пропускной пункт над как можно большим количеством записей,а это значит,что хочется запускать контрольно-пропускные пункты нечасто,и пусть WAL растет как можно больше перед каждой контрольно-пропускной точкой.Решение о том,как часто запускать контрольно-пропускные пункты,следовательно,может варьироваться от одного приложения к другому в зависимости от относительного чтения и записи требования к производительности приложения.По умолчанию стратегия заключается в том,чтобы запустить контрольно-пропускной пункт,как только WAL достигнет 1000 страниц,и эта стратегия,кажется,хорошо работает в тестовых приложениях на рабочих станциях,но другие стратегии могут работать лучше на разных платформах или для разных рабочих нагрузок.</target>
        </trans-unit>
        <trans-unit id="d969bb722b85b5d0915700d40ff32bef3f77944d" translate="yes" xml:space="preserve">
          <source>Now compiles on MSVC++6 again</source>
          <target state="translated">Теперь снова компилирует на MSVC++6.</target>
        </trans-unit>
        <trans-unit id="6c31ef81ebda278449acfecbdc59bc58b62b9f81" translate="yes" xml:space="preserve">
          <source>Now compiles on Solaris and OpenBSD and other Unix variants that lack the fdatasync() function</source>
          <target state="translated">Теперь компилируется на Solaris и OpenBSD и других Unix-вариантах,в которых отсутствует функция fdatasync()</target>
        </trans-unit>
        <trans-unit id="d8eeae1a57da5c7c1fc46f998bfb914d868defe3" translate="yes" xml:space="preserve">
          <source>Now consider a query to find the names of everyone in the organization that is 180cm tall or taller:</source>
          <target state="translated">Теперь рассмотрим запрос,чтобы найти имена всех в организации ростом 180 см или выше:</target>
        </trans-unit>
        <trans-unit id="cace99b617f1285adb8e73b73b38a21bf398149e" translate="yes" xml:space="preserve">
          <source>Now consider the case where M and N are both 3500. Alice nodes are abundant. But suppose each of these nodes is connected by only one or two edges. In this case, option 2 is preferred. With option 2, the outer loop still has to run 3500 times, but the middle loop only runs once or twice for each outer loop and the inner loop will only run once for each middle loop, if at all. So the total number of iterations of the inner loop is around 7000. Option 1, on the other hand, has to run both its outer loop and its middle loop 3500 times each, resulting in 12 million iterations of the middle loop. Thus in the second scenario, option 2 is nearly 2000 times faster than option 1.</source>
          <target state="translated">Теперь рассмотрим случай,когда M и N оба 3500.Узлы Алисы обильны.Но предположим,что каждый из этих узлов связан только одним или двумя ребрами.В этом случае предпочтителен вариант 2.При варианте 2 внешний цикл все равно должен протекать 3500 раз,но средний-только один или два раза для каждого внешнего,а внутренний-только один раз для каждого среднего,если он вообще протекает.Таким образом,общее количество итераций внутреннего цикла составляет около 7000.Вариант 1,с другой стороны,должен прогонять как внешний,так и средний цикл 3500 раз,в результате чего средний цикл получит 12 миллионов итераций.Таким образом,во втором сценарии вариант 2 почти в 2000 раз быстрее варианта 1.</target>
        </trans-unit>
        <trans-unit id="51646e1329ed662a99db388949416fd2e9a42dfe" translate="yes" xml:space="preserve">
          <source>Now consider the case where M and N are both 3500. Alice nodes are abundant. This time suppose each of these nodes is connected by only one or two edges. Now option 2 is preferred. With option 2, the outer loop still has to run 3500 times, but the middle loop only runs once or twice for each outer loop and the inner loop will only run once for each middle loop, if at all. So the total number of iterations of the inner loop is around 7000. Option 1, on the other hand, has to run both its outer loop and its middle loop 3500 times each, resulting in 12 million iterations of the middle loop. Thus in the second scenario, option 2 is nearly 2000 times faster than option 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddfe6464a41b67622d5429681d09c2e30ec73502" translate="yes" xml:space="preserve">
          <source>Now it is time to make the private, custom modifications to SQLite which are the whole point of this exercise. Switch to the private branch (if you are not already there) using the &quot;&lt;code&gt;fossil update private&lt;/code&gt;&quot; command, then bring up the source files in your text editor and make whatever changes you want to make. Once you have finished making changes, commit those changes using this command:</source>
          <target state="translated">Пришло время внести в SQLite частные пользовательские изменения, которые и составляют основу этого упражнения. Переключитесь на частную ветку (если вас еще нет) с помощью команды &amp;laquo; &lt;code&gt;fossil update private&lt;/code&gt; &amp;raquo;, затем откройте исходные файлы в текстовом редакторе и внесите любые изменения, которые хотите внести. После того, как вы закончите вносить изменения, зафиксируйте их с помощью этой команды:</target>
        </trans-unit>
        <trans-unit id="421feb72f2bd97fb759d08871988b6f039784dca" translate="yes" xml:space="preserve">
          <source>Now let's look at how this index will be used. Consider the following query:</source>
          <target state="translated">Теперь давайте посмотрим,как будет использоваться этот индекс.Рассмотрим следующий вопрос:</target>
        </trans-unit>
        <trans-unit id="470c0db4772f894a123be1434e95e5d5a6304ade" translate="yes" xml:space="preserve">
          <source>Now suppose the user.phone field contains plain text if the user has only a single phone number and a JSON array if the user has multiple phone numbers. The same question is posed: &quot;Which users have a phone number in the 704 area code?&quot; But now the json_each() function can only be called for those users that have two or more phone numbers since json_each() requires well-formed JSON as its first argument:</source>
          <target state="translated">Теперь предположим,что поле user.phone содержит простой текст,если у пользователя только один телефонный номер,и массив JSON,если у пользователя несколько телефонных номеров.Тот же самый вопрос задается:&quot;У кого из пользователей есть телефонный номер в коде 704?&quot;.Но теперь функция json_each()может быть вызвана только для тех пользователей,которые имеют два или более телефонных номера,так как json_each()требует в качестве первого аргумента хорошо сформированного JSON:</target>
        </trans-unit>
        <trans-unit id="f22ea5fd82bf1b044f7951c4c771bd645f73f8d1" translate="yes" xml:space="preserve">
          <source>Now that the public and private branches are different, you can run the &quot;&lt;code&gt;fossil update trunk&lt;/code&gt;&quot; and &quot;&lt;code&gt;fossil update private&lt;/code&gt;&quot; commands and see that fossil really does change the files in the checkout as you switch back and forth between branches.</source>
          <target state="translated">Теперь, когда публичная и частная ветки различны, вы можете запустить команды &amp;laquo; &lt;code&gt;fossil update trunk&lt;/code&gt; &amp;raquo; и &amp;laquo; &lt;code&gt;fossil update private&lt;/code&gt; &amp;raquo; и увидеть, что fossil действительно изменяет файлы в кассе при переключении между ветвями.</target>
        </trans-unit>
        <trans-unit id="109085beaaa80ac89858b283a64f7c75d7e5bb12" translate="yes" xml:space="preserve">
          <source>Null</source>
          <target state="translated">Null</target>
        </trans-unit>
        <trans-unit id="5b7d454836a77f93829b713b5a5d0e3045934959" translate="yes" xml:space="preserve">
          <source>Null-indicator is an optional string that indicates a column value is null. The default is an empty string. Note that column-separator and null-indicator are optional positional arguments; if null-indicator is specified, a column-separator argument must be specified and precede the null-indicator argument.</source>
          <target state="translated">Null-индикатор-это необязательная строка,которая указывает на то,что значение столбца является нулевым.По умолчанию пустая строка.Обратите внимание,что аргументы &quot;столбец-сепаратор&quot; и &quot;нуль-индикатор&quot; являются необязательными позиционными аргументами;если указан нуль-индикатор,то должен быть указан аргумент &quot;столбец-сепаратор&quot;,который предшествует аргументу &quot;нуль-индикатор&quot;.</target>
        </trans-unit>
        <trans-unit id="a37aacd80c708abde1a03c3d5afe5b13fd00cfc3" translate="yes" xml:space="preserve">
          <source>NullRow</source>
          <target state="translated">NullRow</target>
        </trans-unit>
        <trans-unit id="eb0f5a21c19313cdefd12cf556538964ec1b60c1" translate="yes" xml:space="preserve">
          <source>Number Of Columns In A Result Set</source>
          <target state="translated">Количество столбцов в наборе результатов</target>
        </trans-unit>
        <trans-unit id="29a85c89c3b665d61a62026778cb1a84d89e00ac" translate="yes" xml:space="preserve">
          <source>Number Of SQL Parameters</source>
          <target state="translated">Количество параметров SQL</target>
        </trans-unit>
        <trans-unit id="a780fc260fcaca2d5e967db2577edefc7720d5d2" translate="yes" xml:space="preserve">
          <source>Number of WAL frames that have already been backfilled into the database by prior checkpoints</source>
          <target state="translated">Количество фреймов WAL,которые уже были занесены в базу данных по предыдущим контрольно-пропускным пунктам</target>
        </trans-unit>
        <trans-unit id="2a37475de2d92c9f14f2ea5c38819cea5766eaa7" translate="yes" xml:space="preserve">
          <source>Number of WAL frames that have attempted to be backfilled but which might not have been backfilled successfully.</source>
          <target state="translated">Количество кадров WAL,которые пытались залить обратно,но которые не были успешно засыплены.</target>
        </trans-unit>
        <trans-unit id="3b125f191573ae8fecea26a8fd5c1f85866a1737" translate="yes" xml:space="preserve">
          <source>Number of bytes of payload</source>
          <target state="translated">Количество байтов полезной нагрузки</target>
        </trans-unit>
        <trans-unit id="3bacc7e3374d56ead644519a8de907aa11ddb984" translate="yes" xml:space="preserve">
          <source>Number of cells on the current page or btree</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93e4ee2802912bc9542ff03c865140e0975aff48" translate="yes" xml:space="preserve">
          <source>Number of columns in a result set</source>
          <target state="translated">Количество столбцов в результирующем наборе</target>
        </trans-unit>
        <trans-unit id="2b00ff36e6009d3918fa275ec909bb841ed966c0" translate="yes" xml:space="preserve">
          <source>Number of valid and committed frames in the WAL file.</source>
          <target state="translated">Количество корректных и зафиксированных кадров в файле WAL.</target>
        </trans-unit>
        <trans-unit id="ff84d5af979f34eb1211b7993c06c6a08d3a99e3" translate="yes" xml:space="preserve">
          <source>Number-of-pages</source>
          <target state="translated">Number-of-pages</target>
        </trans-unit>
        <trans-unit id="2f32b7f17e88cd173c751d8cdc7e8c19cbcaed9f" translate="yes" xml:space="preserve">
          <source>Numeric and text types make a difference for the DISTINCT keyword too:</source>
          <target state="translated">Цифровой и текстовый типы также имеют значение для ключевого слова DISTINCT:</target>
        </trans-unit>
        <trans-unit id="c37c2e33a0fa0b90c0fc1ac3254fa39cce3fa242" translate="yes" xml:space="preserve">
          <source>Numeric values (serial types 1 through 9) sort after NULLs and in numeric order.</source>
          <target state="translated">Числовые значения (последовательные типы с 1 по 9)сортируются после NULL и в числовом порядке.</target>
        </trans-unit>
        <trans-unit id="16bebfa71033ff1ade58c6f0e6b14f281dfaba25" translate="yes" xml:space="preserve">
          <source>Numeric values sort next in numerical order</source>
          <target state="translated">Числовые значения сортируются следующим образом в числовом порядке</target>
        </trans-unit>
        <trans-unit id="0f5fd79254e55ff1fbee2cde5598536b3ec7dea6" translate="yes" xml:space="preserve">
          <source>Numerous bug fixes and documentation updates.</source>
          <target state="translated">Многочисленные исправления ошибок и обновления документации.</target>
        </trans-unit>
        <trans-unit id="dc11c061204c46d3ddd7e450955d3893423efff5" translate="yes" xml:space="preserve">
          <source>Numerous code optimizations, specially optimizations designed to make the code footprint smaller.</source>
          <target state="translated">Многочисленные оптимизации кода,специально оптимизированные для того,чтобы уменьшить объем кода.</target>
        </trans-unit>
        <trans-unit id="1608a6f49ab43b4c01022e79721183478aa81607" translate="yes" xml:space="preserve">
          <source>Numerous minor bug fixes</source>
          <target state="translated">Многочисленные незначительные исправления</target>
        </trans-unit>
        <trans-unit id="59f5ab25bf1e5a211679172dc18a637343443a9e" translate="yes" xml:space="preserve">
          <source>Numerous other performance enhancements</source>
          <target state="translated">Многочисленные другие улучшения производительности</target>
        </trans-unit>
        <trans-unit id="957b6bbcded8f49f8684b4d5e7a64d7f3a67b7a1" translate="yes" xml:space="preserve">
          <source>OCELOT</source>
          <target state="translated">OCELOT</target>
        </trans-unit>
        <trans-unit id="7481b4b2758d96d6c2ef2af6709c88460dc01560" translate="yes" xml:space="preserve">
          <source>ODP - The Open Document presentation format used by OpenOffice and others</source>
          <target state="translated">ODP-формат представления открытых документов,используемый OpenOffice и др.</target>
        </trans-unit>
        <trans-unit id="2a2888f26efa625ef4871988ca874037d8ea156c" translate="yes" xml:space="preserve">
          <source>ODT - The Open Document format used by OpenOffice and others</source>
          <target state="translated">ODT-Формат открытого документа,используемый OpenOffice и др.</target>
        </trans-unit>
        <trans-unit id="0cf81c47abad8b8dc52569f7edcc1b5b2d3511f9" translate="yes" xml:space="preserve">
          <source>OF</source>
          <target state="translated">OF</target>
        </trans-unit>
        <trans-unit id="acd2081fe0965992b6934d49ae30eed38ac749e0" translate="yes" xml:space="preserve">
          <source>OFFSET</source>
          <target state="translated">OFFSET</target>
        </trans-unit>
        <trans-unit id="4f963961751f0891a23f93bba4882f74f0ade805" translate="yes" xml:space="preserve">
          <source>OFFSET clause ignored on queries without a FROM clause. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/07d6a0453d&quot;&gt;07d6a0453d&lt;/a&gt;</source>
          <target state="translated">Предложение OFFSET игнорируется в запросах без предложения FROM. Билет &lt;a href=&quot;http://www.sqlite.org/src/info/07d6a0453d&quot;&gt;07d6a0453d&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="da4ccf2c7bbe14dbe10f95677bd45e189a9ba8cb" translate="yes" xml:space="preserve">
          <source>OFFSET clause ignored on queries without a FROM clause. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/07d6a0453d&quot;&gt;07d6a0453d&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80f83fb7443c61c317b946841f59c0be3182f095" translate="yes" xml:space="preserve">
          <source>OFFSET gives the correct answer. However, OFFSET requires time proportional to the offset value. What really happens with &quot;LIMIT x OFFSET y&quot; is that SQLite computes the query as &quot;LIMIT x+y&quot; and discards the first y values without returning them to the application. So as the window scrolls down toward the bottom of a long list, and the y value becomes larger and larger, successive offset computations take more and more time.</source>
          <target state="translated">OFFSET дает правильный ответ.Однако,OFFSET требует времени,пропорционального значению смещения.Что на самом деле происходит с &quot;LIMIT x OFFSET y&quot;,так это то,что SQLite вычисляет запрос как &quot;LIMIT x+y&quot; и отбрасывает первые значения y,не возвращая их приложению.Так как окно прокручивается вниз к концу длинного списка,и значение y становится все больше и больше,последовательные вычисления смещения занимают все больше и больше времени.</target>
        </trans-unit>
        <trans-unit id="9c108e42d4ae43fd2c4c857619aacef018184aee" translate="yes" xml:space="preserve">
          <source>OLD references are valid</source>
          <target state="translated">Действительны ссылки на старые образцы</target>
        </trans-unit>
        <trans-unit id="387d7a59dbaaef002e0f9ac69ecd4443b9c5cef2" translate="yes" xml:space="preserve">
          <source>ON</source>
          <target state="translated">ON</target>
        </trans-unit>
        <trans-unit id="32bb503cc80e713ad933b48ce9053610aae7664e" translate="yes" xml:space="preserve">
          <source>ON CONFLICT clause</source>
          <target state="translated">ПО КОНФЛИКАТНОЙ оговорке</target>
        </trans-unit>
        <trans-unit id="c13d037157d8eb7ac7ee7af0a3380941dabf2fa2" translate="yes" xml:space="preserve">
          <source>OOM testing is accomplished by simulating OOM errors. SQLite allows an application to substitute an alternative malloc() implementation using the &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmalloc&quot;&gt;SQLITE_CONFIG_MALLOC&lt;/a&gt;,...) interface. The TCL and TH3 test harnesses are both capable of inserting a modified version of malloc() that can be rigged to fail after a certain number of allocations. These instrumented mallocs can be set to fail only once and then start working again, or to continue failing after the first failure. OOM tests are done in a loop. On the first iteration of the loop, the instrumented malloc is rigged to fail on the first allocation. Then some SQLite operation is carried out and checks are done to make sure SQLite handled the OOM error correctly. Then the time-to-failure counter on the instrumented malloc is increased by one and the test is repeated. The loop continues until the entire operation runs to completion without ever encountering a simulated OOM failure. Tests like this are run twice, once with the instrumented malloc set to fail only once, and again with the instrumented malloc set to fail continuously after the first failure.</source>
          <target state="translated">OOM-тестирование выполняется путем моделирования ошибок OOM. SQLite позволяет приложению заменять альтернативную реализацию malloc () с помощью &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt; ( &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmalloc&quot;&gt;SQLITE_CONFIG_MALLOC&lt;/a&gt;, ...) интерфейс. Тестовые жгуты TCL и TH3 способны вставлять модифицированную версию malloc (), которая может быть настроена на отказ после определенного количества распределений. Эти инструментированные маллоки могут быть настроены на сбой только один раз, а затем снова начать работать или продолжать сбой после первого сбоя. OOM-тесты выполняются в цикле. На первой итерации цикла инструментированный malloc настраивается на сбой при первом выделении. Затем выполняется некоторая операция SQLite и выполняется проверка, чтобы убедиться, что SQLite правильно обработал ошибку OOM. Затем счетчик времени до отказа на инструментированном malloc увеличивается на единицу, и тест повторяется. Цикл продолжается до тех пор, пока вся операция не завершится, даже не столкнувшись с имитацией сбоя OOM. Подобные тесты выполняются дважды,один раз с инструментированным malloc, установленным на сбой только один раз, и снова с инструментальным malloc, настроенным на постоянный сбой после первого сбоя.</target>
        </trans-unit>
        <trans-unit id="f579c523960af1aec824c6fdc57af6d4abd76a1f" translate="yes" xml:space="preserve">
          <source>OR</source>
          <target state="translated">OR</target>
        </trans-unit>
        <trans-unit id="683e61c81d390d130002106c2c28e827414b7056" translate="yes" xml:space="preserve">
          <source>ORDER</source>
          <target state="translated">ORDER</target>
        </trans-unit>
        <trans-unit id="2164bde64d5e67a9aad0e7c0543250365dc40e72" translate="yes" xml:space="preserve">
          <source>ORDER BY</source>
          <target state="translated">ЗАКАЗ</target>
        </trans-unit>
        <trans-unit id="e4ec6dd8b3c32fb2c490ae23010139de3ea19166" translate="yes" xml:space="preserve">
          <source>ORDER BY and GROUP BY now use bounded memory</source>
          <target state="translated">ЗАКАЗАТЕЛЬСТВО ЗАКАЗАТЕЛЬСТВА И ГРУППА теперь использует ограниченную память</target>
        </trans-unit>
        <trans-unit id="f9252c387c5a364e0aa75e161fd6ca4b31550d60" translate="yes" xml:space="preserve">
          <source>ORDER BY ignored if the query has an identical GROUP BY. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/b75a9ca6b0499&quot;&gt;b75a9ca6b0&lt;/a&gt;</source>
          <target state="translated">ORDER BY игнорируется, если запрос имеет идентичную GROUP BY. Билет &lt;a href=&quot;http://www.sqlite.org/src/info/b75a9ca6b0499&quot;&gt;b75a9ca6b0&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4c80a022ba8a937ff7b06aa241ba59238ca58957" translate="yes" xml:space="preserve">
          <source>ORDER BY ignored if the query has an identical GROUP BY. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/b75a9ca6b0499&quot;&gt;b75a9ca6b0&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d00407a3fb0d8ad7b8bcf4535e5d986d53520d0" translate="yes" xml:space="preserve">
          <source>ORDER BY works on subselects</source>
          <target state="translated">ЗАКАЗЫВАЙТЕ Работы по подгруппам</target>
        </trans-unit>
        <trans-unit id="fb1eb08d2d3f0a79b8449be8ce9ee77050e088a5" translate="yes" xml:space="preserve">
          <source>OS Interface</source>
          <target state="translated">интерфейс операционной системы</target>
        </trans-unit>
        <trans-unit id="7ea1a5ba1dffba576fe0a188bb466f1a65ef5c2d" translate="yes" xml:space="preserve">
          <source>OS Interface File Virtual Methods Object</source>
          <target state="translated">Файл интерфейса ОС Файл виртуальных методов Объект</target>
        </trans-unit>
        <trans-unit id="2fdd9f0dd04e20b2da0185c9864ac62e0fd49b33" translate="yes" xml:space="preserve">
          <source>OS Interface Object</source>
          <target state="translated">Объект интерфейса ОС</target>
        </trans-unit>
        <trans-unit id="e502b880ac4721322e02bb29b5215f15ab6c97e9" translate="yes" xml:space="preserve">
          <source>OS Interface Open File Handle</source>
          <target state="translated">Интерфейс ОС Открыть файловую ручку</target>
        </trans-unit>
        <trans-unit id="1bea0dbc1c9e6f1262f42405074e1a4e5f89e1c4" translate="yes" xml:space="preserve">
          <source>OSS Fuzz no longer finds historical bugs in SQLite. But it is still running and does occasionally find issues in new development check-ins. Examples: &lt;a href=&quot;https://www.sqlite.org/src/timeline?y=ci&amp;amp;c=c422afb507dc8757&quot;&gt;[1]&lt;/a&gt;&lt;a href=&quot;https://www.sqlite.org/src/timeline?y=ci&amp;amp;c=0a2eb949f8a759e5&quot;&gt;[2]&lt;/a&gt;&lt;a href=&quot;https://www.sqlite.org/src/timeline?y=ci&amp;amp;c=62f2235adf796c72&quot;&gt;[3]&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dee9889ad644e6e58468f0ff85f3a57aa76cfbd9" translate="yes" xml:space="preserve">
          <source>OTHERS</source>
          <target state="translated">OTHERS</target>
        </trans-unit>
        <trans-unit id="a032f6607e24aa99492871d19a553d714048e163" translate="yes" xml:space="preserve">
          <source>OUTER</source>
          <target state="translated">OUTER</target>
        </trans-unit>
        <trans-unit id="cc11826689203b888f22525a7551a5472c324526" translate="yes" xml:space="preserve">
          <source>OVER</source>
          <target state="translated">OVER</target>
        </trans-unit>
        <trans-unit id="829a2c0005fc7d37eb660c0d5cde206b5192f790" translate="yes" xml:space="preserve">
          <source>Obey in all things the commands of those whom God has placed in authority over you even though they (which God forbid) should act otherwise, mindful of the Lord's precept, &quot;Do what they say, but not what they do.&quot;</source>
          <target state="translated">Повинуйтесь во всем повелениям тех,кого Бог поставил над вами,даже если они (что Бог запрещает)должны поступать иначе,помня заповедь Господа:&quot;Делайте,что они говорят,а не то,что делают&quot;.</target>
        </trans-unit>
        <trans-unit id="a21a5206c75e38db5a2f38df79e6283758ee658a" translate="yes" xml:space="preserve">
          <source>Object-Oriented Design</source>
          <target state="translated">Объектно-ориентированный дизайн</target>
        </trans-unit>
        <trans-unit id="898a9f4f224c827df0fb00ecec65822c23a3936e" translate="yes" xml:space="preserve">
          <source>Object-Oriented is a design pattern, not a programming language. You can do object-oriented programming in any language you want, including assembly language. Some languages (ex: C++ or Java) make object-oriented easier. But you can still do object-oriented programming in languages like C.</source>
          <target state="translated">Объектно-ориентированный-это шаблон проектирования,а не язык программирования.Объектно-ориентированное программирование можно выполнять на любом языке,включая язык ассемблера.Некоторые языки (например,C++или Java)облегчают объектно-ориентированное программирование.Но вы все равно можете заниматься объектно-ориентированным программированием на таких языках,как Си.</target>
        </trans-unit>
        <trans-unit id="1e6159d8c90870c6430155592639731dac8033a3" translate="yes" xml:space="preserve">
          <source>Object-oriented is not the only valid design pattern. Many programmers have been taught to think purely in terms of objects. And, to be fair, objects are often a good way to decompose a problem. But objects are not the only way, and are not always the best way to decompose a problem. Sometimes good old procedural code is easier to write, easier to maintain and understand, and faster than object-oriented code.</source>
          <target state="translated">Объектно-ориентированный не единственный действительный образец конструкции.Многих программистов научили мыслить чисто в терминах объектов.И,справедливости ради,объекты часто являются хорошим способом разложения проблемы.Но объекты-это не единственный способ,и не всегда лучший способ разложить проблему.Иногда старый добрый процедурный код легче писать,легче поддерживать и понимать,и быстрее,чем объектно-ориентированный.</target>
        </trans-unit>
        <trans-unit id="ea838bb1557d80ce2bdbf51816fc7a1525503976" translate="yes" xml:space="preserve">
          <source>Objects:</source>
          <target state="translated">Objects:</target>
        </trans-unit>
        <trans-unit id="3a36347e6c9b66b32ae45cd886e8708db38d062b" translate="yes" xml:space="preserve">
          <source>Obscure bug fix on triggers (&lt;a href=&quot;http://www.sqlite.org/src/info/efc02f9779&quot;&gt;[efc02f9779]&lt;/a&gt;).</source>
          <target state="translated">Непонятное исправление ошибки триггеров ( &lt;a href=&quot;http://www.sqlite.org/src/info/efc02f9779&quot;&gt;[efc02f9779]&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="d0994929eda2b0503d9117c72035600d8833ef50" translate="yes" xml:space="preserve">
          <source>Obscure bug fix on triggers (&lt;a href=&quot;https://www.sqlite.org/src/info/efc02f9779&quot;&gt;[efc02f9779]&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06705e47733fa2d26527ca5b13fe92c1b7ca1944" translate="yes" xml:space="preserve">
          <source>Obsolete Documents</source>
          <target state="translated">Устаревшие документы</target>
        </trans-unit>
        <trans-unit id="adcd55329b6153adb94eaf8a12d01ba2bc7cea95" translate="yes" xml:space="preserve">
          <source>Obtain A Composite Changeset From A Changegroup</source>
          <target state="translated">Получить композитный набор изменений из группы смены</target>
        </trans-unit>
        <trans-unit id="f036e380a093cadb7b7384e4b591b8c75c1ba145" translate="yes" xml:space="preserve">
          <source>Obtain Aggregate Function Context</source>
          <target state="translated">Получить контекст функции агрегата</target>
        </trans-unit>
        <trans-unit id="e79fb280b93973e6bfe3f8e79ba72b5b038ba1fa" translate="yes" xml:space="preserve">
          <source>Obtain Conflicting Row Values From A Changeset Iterator</source>
          <target state="translated">Получить противоречивые значения рядов от итератора изменений.</target>
        </trans-unit>
        <trans-unit id="d4c8c29e25fb3ccc649578fec3be2c67a658b123" translate="yes" xml:space="preserve">
          <source>Obtain The Current Operation From A Changeset Iterator</source>
          <target state="translated">Получить текущую операцию от итератора переменных параметров.</target>
        </trans-unit>
        <trans-unit id="7ada95f817f8fc624dbadc0c0f495b244a8d38b3" translate="yes" xml:space="preserve">
          <source>Obtain The Primary Key Definition Of A Table</source>
          <target state="translated">Получить определение первичного ключа таблицы А</target>
        </trans-unit>
        <trans-unit id="2f0f8596ef7c82c2d68f88fe0c2c42b22b20b24e" translate="yes" xml:space="preserve">
          <source>Obtain Values For URI Parameters</source>
          <target state="translated">Получить значения для параметров URI</target>
        </trans-unit>
        <trans-unit id="e719cf57b48331ec73c3d09816f240ac71d990d4" translate="yes" xml:space="preserve">
          <source>Obtain a PENDING lock and then an EXCLUSIVE lock on the database file. If other processes still have SHARED locks, the writer might have to wait until those SHARED locks clear before it is able to obtain an EXCLUSIVE lock.</source>
          <target state="translated">Получите блокировку PENDING,а затем EXCLUSIVE на файле базы данных.Если другие процессы все еще имеют блокировку SHARED,записывающему устройству,возможно,придется подождать,пока эти блокировки не будут сняты,прежде чем оно сможет получить ЭКСКЛЮЗИВНУЮ блокировку.</target>
        </trans-unit>
        <trans-unit id="c4c184719398e2fd529d288f83e902aa72fdd7b4" translate="yes" xml:space="preserve">
          <source>Obtain a buffer containing a changeset (or patchset) representing the current contents of the changegroup. If the inputs to the changegroup were themselves changesets, the output is a changeset. Or, if the inputs were patchsets, the output is also a patchset.</source>
          <target state="translated">Получить буфер,содержащий набор изменений (или патчсет),представляющий текущее содержимое группы изменений.Если входы в группу изменений были сами по себе changeset'ами,то на выходе будет changeset'ом.Или,если входы были патчсетами,выход также является патчсет.</target>
        </trans-unit>
        <trans-unit id="0ad736b5bee2570f5cbf619854f8b97d9b6134d1" translate="yes" xml:space="preserve">
          <source>Obtain a changeset containing changes to the tables attached to the session object passed as the first argument. If successful, set *ppChangeset to point to a buffer containing the changeset and *pnChangeset to the size of the changeset in bytes before returning SQLITE_OK. If an error occurs, set both *ppChangeset and *pnChangeset to zero and return an SQLite error code.</source>
          <target state="translated">Получить changeset,содержащий изменения в таблицах,прикрепленных к объекту сеанса,переданному в качестве первого аргумента.В случае успеха перед возвращением SQLITE_OK установите *ppChangeset в указатель на буфер,содержащий changeset,и *pnChangeset в размер changeset в байтах.В случае ошибки установите оба аргумента *ppChangeset и *pnChangeset в нулевое значение и верните код ошибки SQLite.</target>
        </trans-unit>
        <trans-unit id="4304c4d08f4f900e2ab1ec29540131e8bf87ae39" translate="yes" xml:space="preserve">
          <source>Obtain a lock on a particular table. This instruction is only used when the shared-cache feature is enabled.</source>
          <target state="translated">Получить замок на определенном столе.Эта инструкция используется только при включенной функции общего кэширования.</target>
        </trans-unit>
        <trans-unit id="35cc8c81bb0ab78babd3f65cb1b473a29bd69034" translate="yes" xml:space="preserve">
          <source>Obtain an EXCLUSIVE lock on the database file and make sure all memory changes have been written to the database file using the algorithm of steps 1-3 above.</source>
          <target state="translated">Получите ЭКСКЛЮЗИВНУЮ блокировку на файле БД и убедитесь,что все изменения в памяти записаны в файл БД по алгоритму,описанному выше в п.п.1-3.</target>
        </trans-unit>
        <trans-unit id="edc981514ab58076de28ce864d46ccc2641ec1d0" translate="yes" xml:space="preserve">
          <source>Obtain new.* Values From A Changeset Iterator</source>
          <target state="translated">Получите новые.Значения от итератора изменений.</target>
        </trans-unit>
        <trans-unit id="c31b9f4e355939157fe39f17fcb0e54282736c63" translate="yes" xml:space="preserve">
          <source>Obtain old.* Values From A Changeset Iterator</source>
          <target state="translated">Получите старое.*Ценности от итератора изменений.</target>
        </trans-unit>
        <trans-unit id="d399842fa2ae120f608cae0543637da5b44e2b8c" translate="yes" xml:space="preserve">
          <source>Obtain the latest SQLite code from fossil.</source>
          <target state="translated">Получите новейший код SQLite из ископаемых источников.</target>
        </trans-unit>
        <trans-unit id="9ed23644c9e9a46df1cd037be0519be726230e11" translate="yes" xml:space="preserve">
          <source>Obtaining SQL Values</source>
          <target state="translated">Получение значений SQL</target>
        </trans-unit>
        <trans-unit id="ffe740a4611067b4b4dd0b5b7a28183003203956" translate="yes" xml:space="preserve">
          <source>Obtaining the</source>
          <target state="translated">Получение</target>
        </trans-unit>
        <trans-unit id="a8fbf19c89308087d70d289986f946de344868c9" translate="yes" xml:space="preserve">
          <source>Obtains the mutex.</source>
          <target state="translated">Получает мьютекс.</target>
        </trans-unit>
        <trans-unit id="974debb0f023f79fb3eec2db47da68008b639181" translate="yes" xml:space="preserve">
          <source>Occasionally, a serious problem is found and a small &quot;patch&quot; release must be made against a regular maintenance release. Patch are distinct from maintenance releases in that the number of lines of code changed from the previous release is very small. Every effort is made to avoid patch releases by making sure that maintenance releases are bug free.</source>
          <target state="translated">Время от времени обнаруживается серьезная проблема,и необходимо сделать небольшую &quot;заплатку&quot; на регулярном техобслуживании.Патч отличается от релиза для обслуживания тем,что количество строк кода,измененных по сравнению с предыдущим релизом,очень мало.Прилагаются все усилия,чтобы избежать использования патчей,убедившись,что в релизах сопровождения нет ошибок.</target>
        </trans-unit>
        <trans-unit id="10b7fae72f94602297b15a7cf850a8e1ee7b4b31" translate="yes" xml:space="preserve">
          <source>Of course, ANALYZE only works effectively if you have a significant amount of content in your database in the first place. When creating a new database that you expect to accumulate a lot of data, you can run the command &quot;ANALYZE sqlite_master&quot; to create the SQLITE_STAT1 table, then prepopulate the SQLITE_STAT1 table (using ordinary INSERT statements) with content that describes a typical database for your application - perhaps content that you extracted after running ANALYZE on a well-populated template database in the lab.</source>
          <target state="translated">Конечно,ANALYZE работает эффективно только в том случае,если в Вашей базе данных имеется значительный объем контента.При создании новой БД,в которой вы ожидаете накопления большого количества данных,вы можете запустить команду &quot;ANALYZE sqlite_master&quot; для создания таблицы SQLITE_STAT1,а затем подготовить таблицу SQLITE_STAT1 (используя обычные операторы INSERT)с содержимым,описывающим типичную БД для вашего приложения-возможно,с содержимым,которое вы извлекли после запуска ANALYZE на хорошо заполненной шаблонной базе данных в лаборатории.</target>
        </trans-unit>
        <trans-unit id="3d4796f0a34c568634b9634297a83ac77168e0e1" translate="yes" xml:space="preserve">
          <source>Of course, ANALYZE only works effectively if you have a significant amount of content in your database in the first place. When creating a new database that you expect to accumulate a lot of data, you can run the command &quot;ANALYZE sqlite_schema&quot; to create the SQLITE_STAT1 table, then prepopulate the SQLITE_STAT1 table (using ordinary INSERT statements) with content that describes a typical database for your application - perhaps content that you extracted after running ANALYZE on a well-populated template database in the lab.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79c23fc170f4a6f6a03298037f6a0ed97740fe0f" translate="yes" xml:space="preserve">
          <source>Of course, an error may occur while attempting any of the 4 steps enumerated above. If this happens, then the</source>
          <target state="translated">Конечно,ошибка может произойти при попытке выполнить любой из 4 перечисленных выше шагов.Если это произойдет,то</target>
        </trans-unit>
        <trans-unit id="4144a21a0e5e7b5ef89db325c2463b409501b64d" translate="yes" xml:space="preserve">
          <source>Of course, an ordinary SQLite table will also do a query against its integer primary key efficiently, so the previous is no big deal. The real reason for using an R*Tree is so that you can efficiently do inequality queries against the coordinate ranges. To find all elements of the index that are contained within the vicinity of Charlotte, North Carolina, one might do:</source>
          <target state="translated">Конечно,обычная таблица SQLite также будет эффективно выполнять запрос к своему целочисленному первичному ключу,так что предыдущий-ничего страшного.Настоящая причина использования R*Tree заключается в том,что вы можете эффективно выполнять запросы неравенства по отношению к диапазонам координат.Найти все элементы индекса,которые содержатся в окрестностях Шарлотты,штат Северная Каролина,можно:</target>
        </trans-unit>
        <trans-unit id="ad9000f84241cbe168fcf9edea5a309a2f41cf64" translate="yes" xml:space="preserve">
          <source>Of course, it is also possible that it does exist following system recovery.</source>
          <target state="translated">Конечно,также возможно,что он существует и после восстановления системы.</target>
        </trans-unit>
        <trans-unit id="7a79fe7e88cf76ed8c1ab2e6617de9596ed474d8" translate="yes" xml:space="preserve">
          <source>Of course, it is usually not possible to atomically apply all the changes required by a</source>
          <target state="translated">Конечно,как правило,невозможно атоматически применить все изменения,необходимые для</target>
        </trans-unit>
        <trans-unit id="03e6ead3b1dad229ee29b568087a8cd4aada1c2d" translate="yes" xml:space="preserve">
          <source>Of course, not every language fits neatly into one of the above catagories. This applies to both SQL database engines and more familiar imperative programming languages. Javascript is famous for using a hybrid execution model, where the code is initially compiled into a tree of objects, but might be further translating (using just-in-time compilation) down into more efficient bytecode or machine code, as a means of boosting performance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8a4fe5b2fe5db1f855a348ab89c3de5aa545089" translate="yes" xml:space="preserve">
          <source>Of course, one wants to eventually transfer all the transactions that are appended in the WAL file back into the original database. Moving the WAL file transactions back into the database is called a &quot;</source>
          <target state="translated">Конечно же,хочется в конечном итоге перенести все транзакции,которые прилагаются к файлу WAL,обратно в исходную базу данных.Перемещение транзакций из файла WAL обратно в базу данных называется &quot;.</target>
        </trans-unit>
        <trans-unit id="a8d7cb464eb0b5300b1a2a71635654f684270965" translate="yes" xml:space="preserve">
          <source>Of course, ordering the output of a query by rowid is seldom useful. Usually one wants to order the output by some other column.</source>
          <target state="translated">Конечно,упорядочивание вывода запроса по rowid редко бывает полезным.Обычно хочется заказать вывод по какому-нибудь другому столбцу.</target>
        </trans-unit>
        <trans-unit id="178df5e8851c3ac34f7dcea098e85da7dbfe235b" translate="yes" xml:space="preserve">
          <source>Of course, substitute the desired index and imposter table names in place of the &quot;t1bc&quot; and &quot;t2&quot; shown in the example. The &quot;.imposter&quot; command reads the schema of the &quot;t1bc&quot; index, uses that information to construct a compatible CREATE TABLE statement for the imposter table, then makes all the necessary calls to create the transient imposter table automatically.</source>
          <target state="translated">Конечно же,вместо &quot;t1bc&quot; и &quot;t2&quot;,показанных в примере,подставьте нужные имена индексов и самозваных таблиц.Команда &quot;.imposter&quot; читает схему индекса &quot;t1bc&quot;,использует эту информацию для построения совместимого оператора CREATE TABLE для imposter-таблицы,затем автоматически делает все необходимые вызовы для создания переходной imposter-таблицы.</target>
        </trans-unit>
        <trans-unit id="116444cf2f220a0caf732f16ffb5a2f69fd9321c" translate="yes" xml:space="preserve">
          <source>Of course, the two queries above are not entirely equivalent. For example the LIKE query matches rows that contain terms such as &quot;linuxophobe&quot; or &quot;EnterpriseLinux&quot; (as it happens, the Enron E-Mail Dataset does not actually contain any such terms), whereas the MATCH query on the FTS3 table selects only those rows that contain &quot;linux&quot; as a discrete token. Both searches are case-insensitive. The FTS3 table consumes around 2006 MB on disk compared to just 1453 MB for the ordinary table. Using the same hardware configuration used to perform the SELECT queries above, the FTS3 table took just under 31 minutes to populate, versus 25 for the ordinary table.</source>
          <target state="translated">Конечно,два вышеприведенных вопроса не совсем эквивалентны.Например,запрос LIKE совпадает со строками,которые содержат такие термины,как &quot;linuxophobe&quot; или &quot;EnterpriseLinux&quot; (как это бывает,набор данных электронной почты Enron на самом деле не содержит таких терминов),в то время как MATCH-запрос на таблицу FTS3 выбирает только те строки,которые содержат &quot;linux&quot; в качестве дискретного токена.Оба поиска не чувствительны к регистру.Таблица FTS3 потребляет на диске около 2006 МБ по сравнению с 1453 МБ для обычной таблицы.Используя ту же самую аппаратную конфигурацию,которая использовалась для выполнения SELECT-запросов,описанных выше,таблица FTS3 заняла чуть менее 31 минуты,по сравнению с 25 для обычной таблицы.</target>
        </trans-unit>
        <trans-unit id="68b0ebb94fca52bc2076d132ead5c0f0cef17ce0" translate="yes" xml:space="preserve">
          <source>Of course, users would prefer code that is both robust in normal use and resistant to malicious attack. The SQLite developers are dedicated to providing that. The purpose of this section is merely to point out that doing both at the same time is hard.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6778acfecc08483f487870a27c4e0b19bb8701d" translate="yes" xml:space="preserve">
          <source>Of course, your mileage may vary depending on hardware, filesystem, and operating system. Double-check these figures on target hardware before committing to a particular design.</source>
          <target state="translated">Конечно,ваш пробег может варьироваться в зависимости от оборудования,файловой системы и операционной системы.Перепроверьте эти цифры на целевом аппаратном обеспечении перед тем,как совершить фиксацию на определенном дизайне.</target>
        </trans-unit>
        <trans-unit id="315230e941921effe51cc9ebfa05403b855f0476" translate="yes" xml:space="preserve">
          <source>Of these changes, only 1a and 2a through 2c are incompatibilities in any formal sense. But users who have previously made custom modifications to the SQLite source (for example to add a custom OS layer for embedded hardware) might find that these changes have a larger impact. On the other hand, an important goal of these changes is to make it much easier to customize SQLite for use on different operating systems.</source>
          <target state="translated">Из этих изменений только 1a и 2a-2c являются несовместимыми в любом формальном смысле.Но пользователи,которые ранее вносили пользовательские изменения в исходный текст SQLite (например,для добавления пользовательского уровня операционной системы для встроенного оборудования),могут обнаружить,что эти изменения оказывают большее влияние.С другой стороны,важной целью этих изменений является облегчение настройки SQLite для использования на различных операционных системах.</target>
        </trans-unit>
        <trans-unit id="e3de5ab0ca4c69dbf00e86d2558843e8d806bb49" translate="yes" xml:space="preserve">
          <source>Off</source>
          <target state="translated">Off</target>
        </trans-unit>
        <trans-unit id="ce667716547fa82bc8795ad7ef205e9410193ed0" translate="yes" xml:space="preserve">
          <source>Offset</source>
          <target state="translated">Offset</target>
        </trans-unit>
        <trans-unit id="58190317f4f075103c701ab1719a5146c7d71c8f" translate="yes" xml:space="preserve">
          <source>OffsetLimit</source>
          <target state="translated">OffsetLimit</target>
        </trans-unit>
        <trans-unit id="1ab3ac50fee719ce4797840a2df9f8c5ee707c03" translate="yes" xml:space="preserve">
          <source>Older versions of SQLite could not read a WAL-mode database that was read-only. In other words, write access was required in order to read a WAL-mode database. This constraint was relaxed beginning with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_22_0.html&quot;&gt;version 3.22.0&lt;/a&gt; (2018-01-22).</source>
          <target state="translated">Более старые версии SQLite не могли читать базу данных в режиме WAL, которая была доступна только для чтения. Другими словами, для чтения базы данных в режиме WAL требовался доступ на запись. Это ограничение было ослаблено, начиная с &lt;a href=&quot;https://sqlite.org/releaselog/3_22_0.html&quot;&gt;версии&lt;/a&gt; SQLite 3.22.0 (2018-01-22).</target>
        </trans-unit>
        <trans-unit id="28b3eeca1402aeadaf4db2bf8f6d2403ee957bf0" translate="yes" xml:space="preserve">
          <source>Older versions of firebird omits all NULLs from SELECT DISTINCT and from UNION.</source>
          <target state="translated">Старые версии firebird исключают все NULL из SELECT DISTINCT и UNION.</target>
        </trans-unit>
        <trans-unit id="8bfe5e60a5daf11fac21979e5a4fa9643a76bc3b" translate="yes" xml:space="preserve">
          <source>Omit all use of &quot;awk&quot; in the makefiles, to make building easier for MSVC users.</source>
          <target state="translated">Опустите все использование &quot;awk&quot; в makefiles,чтобы облегчить сборку для пользователей MSVC.</target>
        </trans-unit>
        <trans-unit id="bf4d0857bd27f59258be5d9b1e12776a9ff94992" translate="yes" xml:space="preserve">
          <source>Omitted parameters take on default values. STEP defaults to 1. END defaults to 9223372036854775807. START defaults to 0.</source>
          <target state="translated">Пропущенные параметры принимают значения по умолчанию.Шаг по умолчанию-1.Значения по умолчанию END-9223372036854775807.Значения по умолчанию для пуска-0.</target>
        </trans-unit>
        <trans-unit id="e0049a66519cae71159800bb77a35007bc2d76d3" translate="yes" xml:space="preserve">
          <source>On</source>
          <target state="translated">On</target>
        </trans-unit>
        <trans-unit id="0e46092ad025ac57fb1677f1d311680029cda2c1" translate="yes" xml:space="preserve">
          <source>On Android, we are told, there are many services that will blindly run arbitrary SQL that is passed to them by untrustworthy apps that have been downloaded from dodgy corners of the internet. Android services are suppose to be more guarded about running SQL from unvetted sources. This author does not have any specific examples to the contrary, but he has heard rumors that they exist. Even if all Android services are more careful and properly vet all the SQL they run, it would be difficult to audit them all in order to verify that they are safe. Hence, security-minded people are keen to ensure that no exploits are possible by passing arbitrary SQL text.</source>
          <target state="translated">На Android,как нам говорят,есть много сервисов,которые будут вслепую запускать произвольный SQL,который передается им ненадежными приложениями,которые были загружены из изворотливых уголков интернета.Предполагается,что сервисы Android будут более осторожны в запуске SQL из непроверенных источников.У этого автора нет конкретных примеров наоборот,но он слышал слухи о том,что они существуют.Даже если все службы Android будут более внимательны и правильно проверять все SQL,которые они запускают,будет сложно провести их аудит,чтобы убедиться,что они безопасны.Следовательно,люди,ориентированные на безопасность,стремятся к тому,чтобы гарантировать отсутствие эксплойтов путем передачи произвольного SQL-текста.</target>
        </trans-unit>
        <trans-unit id="26c3af907230190631617dbb8e5acb92e9854301" translate="yes" xml:space="preserve">
          <source>On Linux and other unix systems you will need to enter something like:</source>
          <target state="translated">На Linux и других unix-системах Вам нужно будет ввести что-то вроде:</target>
        </trans-unit>
        <trans-unit id="1273deeaf4de08300113723f337bae0ec716c243" translate="yes" xml:space="preserve">
          <source>On Win32, do not return an error when attempting to delete a file that does not exist.</source>
          <target state="translated">На Win32 не возвращайте ошибку при попытке удалить несуществующий файл.</target>
        </trans-unit>
        <trans-unit id="b2b2f36a4fafa25d031c2e6870c72d35c487959e" translate="yes" xml:space="preserve">
          <source>On Windows systems, folders are searched in the following order:</source>
          <target state="translated">В системах Windows поиск папок выполняется в следующем порядке:</target>
        </trans-unit>
        <trans-unit id="9d83a99bbbc3869a446954149b390c5195af03a3" translate="yes" xml:space="preserve">
          <source>On Windows with MSVC, use nmake with the Makefile.msc:</source>
          <target state="translated">На Windows с MSVC используйте nmake с Makefile.msc:</target>
        </trans-unit>
        <trans-unit id="e51bd18dd2b65a7e346c37ac44c1031b3f3942d7" translate="yes" xml:space="preserve">
          <source>On Windows, enter:</source>
          <target state="translated">На Windows,введите:</target>
        </trans-unit>
        <trans-unit id="aacb79e6ea038d7e3cda09880e0781239b1e3933" translate="yes" xml:space="preserve">
          <source>On a &lt;a href=&quot;wal#ckpt&quot;&gt;checkpoint&lt;/a&gt;, the WAL is first flushed to persistent storage using the xSync method of the &lt;a href=&quot;c3ref/io_methods&quot;&gt;VFS&lt;/a&gt;. Then valid content of the WAL is transferred into the database file. Finally, the database is flushed to persistent storage using another xSync method call. The xSync operations serve as write barriers - all writes launched before the xSync must complete before any write that launches after the xSync begins.</source>
          <target state="translated">На &lt;a href=&quot;wal#ckpt&quot;&gt;контрольной точке&lt;/a&gt; WAL сначала сбрасывается в постоянное хранилище с помощью метода xSync &lt;a href=&quot;c3ref/io_methods&quot;&gt;VFS&lt;/a&gt; . Затем действительное содержимое WAL переносится в файл базы данных. Наконец, база данных сбрасывается в постоянное хранилище с помощью другого вызова метода xSync. Операции xSync служат барьерами для записи - все записи, запущенные до xSync, должны завершиться до любой записи, которая запускается после начала xSync.</target>
        </trans-unit>
        <trans-unit id="ea7fd316bd0a1ed7abbfd63a2c9be9dcb14966c5" translate="yes" xml:space="preserve">
          <source>On a DISTINCT query that uses an index, try to skip ahead to the next distinct entry using the index rather than stepping through rows, when an appropriate index is available.</source>
          <target state="translated">В запросе DISTINCT,использующем индекс,попробуйте перейти к следующей отдельной записи,используя индекс,а не переходить по строкам,когда доступен соответствующий индекс.</target>
        </trans-unit>
        <trans-unit id="439b4340c2826997b9311dbcdfa182caed0bc968" translate="yes" xml:space="preserve">
          <source>On a traditional spinning disk, a sector is the minimum unit of transfer in both directions, both reading and writing. On flash memory, however, the minimum size of a read is typically much smaller than a minimum write. SQLite is only concerned with the minimum write amount and so for the purposes of this article, when we say &quot;sector&quot; we mean the minimum amount of data that can be written to mass storage in a single go.</source>
          <target state="translated">На традиционном прядильном диске сектор является минимальной единицей передачи в обоих направлениях,как при чтении,так и при записи.На флэш-памяти,однако,минимальный размер считываемого сектора обычно намного меньше минимального объема записи.SQLite заботится только о минимальном объеме записи,поэтому для целей данной статьи,когда мы говорим &quot;сектор&quot;,мы имеем в виду минимальный объем данных,который можно за один раз записать на массовое хранение.</target>
        </trans-unit>
        <trans-unit id="4d25766d7605da89f0dc45ce4758796da7aaedb1" translate="yes" xml:space="preserve">
          <source>On an &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;, if the ROWID or INTEGER PRIMARY KEY column is not explicitly given a value, then it will be filled automatically with an unused integer, usually one more than the largest ROWID currently in use. This is true regardless of whether or not the AUTOINCREMENT keyword is used.</source>
          <target state="translated">В &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; , если столбцу ROWID или INTEGER PRIMARY KEY явно не присвоено значение, он будет автоматически заполнен неиспользуемым целым числом, обычно на единицу больше, чем самый большой ROWID, используемый в настоящее время. Это верно независимо от того, используется ли ключевое слово AUTOINCREMENT.</target>
        </trans-unit>
        <trans-unit id="ebef8439735d14eb6033471fd2e7d318b20febc6" translate="yes" xml:space="preserve">
          <source>On an UPSERT when the order of constraint checks is rearranged, ensure that the affinity transformations on the inserted content occur before any of the constraint checks. Fix for ticket &lt;a href=&quot;https://www.sqlite.org/src/info/79cad5e4b2e219dd197242e9e&quot;&gt;79cad5e4b2e219dd197242e9e&lt;/a&gt;.</source>
          <target state="translated">В UPSERT, когда порядок проверок ограничений изменен, убедитесь, что преобразования сродства во вставленном содержимом происходят до любых проверок ограничений. Исправление для билета &lt;a href=&quot;https://www.sqlite.org/src/info/79cad5e4b2e219dd197242e9e&quot;&gt;79cad5e4b2e219dd197242e9e&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0a7e67fba14e6027ea80edde2148e2473e22f15f" translate="yes" xml:space="preserve">
          <source>On each call to undo::undo or undo::redo, the undo/redo module automatically invokes methods status_refresh and reload_all in all toplevel namespaces. These methods should be defined to reconstruct the display or otherwise update the state of the program based on the undone/redone changes to the database.</source>
          <target state="translated">При каждом вызове команды undo::undo или undo::redo модуль undo/redo автоматически вызывает методы status_refresh и reload_all во всех пространствах имен верхнего уровня.Эти методы должны быть определены,чтобы реконструировать отображение или иным образом обновить состояние программы на основании отмененных/восстановленных изменений в базе данных.</target>
        </trans-unit>
        <trans-unit id="51efe73d5459fecda0ebf237f9f8f384ca5daf31" translate="yes" xml:space="preserve">
          <source>On embedded systems with synchronous filesystems, TRUNCATE results in slower behavior than PERSIST. The commit operation is the same speed. But subsequent transactions are slower following a TRUNCATE because it is faster to overwrite existing content than to append to the end of a file. New journal file entries will always be appended following a TRUNCATE but will usually overwrite with PERSIST.</source>
          <target state="translated">На встраиваемых системах с синхронными файловыми системами TRUNCATE ведет себя медленнее,чем PERSIST.Операция фиксации происходит с той же скоростью.Но последующие транзакции после TRUNCATE выполняются медленнее,так как быстрее перезаписывать существующее содержимое,чем добавлять его в конец файла.Новые записи в файле журнала всегда будут добавляться после ТРУНКАТА,но обычно перезаписываются с помощью PERSIST.</target>
        </trans-unit>
        <trans-unit id="cff1aa0bee9c89492d085449129eae77e72bb5fa" translate="yes" xml:space="preserve">
          <source>On most systems, the malloc() system call returns a buffer that is aligned to an 8-byte boundary. But on some systems (ex: windows) malloc() returns 4-byte aligned pointer. This compile-time option must be used on systems that return 4-byte aligned pointers from malloc().</source>
          <target state="translated">На большинстве систем системный вызов malloc()возвращает буфер,который выровнен по границе 8 байт.Но на некоторых системах (ex:windows)malloc()возвращает указатель,выровненный по 4-байтной границе.Эта опция времени компиляции должна использоваться на системах,возвращающих указатели,выровненные по 4 байтам из malloc().</target>
        </trans-unit>
        <trans-unit id="87f5be0e7a33503458f9f1fc5e662122708d06fc" translate="yes" xml:space="preserve">
          <source>On newer versions of SQLite, a WAL-mode database on read-only media, or a WAL-mode database that lacks write permission, can still be read as long as one or more of the following conditions are met:</source>
          <target state="translated">На более новых версиях SQLite базу данных WAL-режима на носителе,доступном только для чтения,или базу данных WAL-режима,не имеющую разрешения на запись,можно читать до тех пор,пока выполняется одно или несколько из нижеперечисленных условий:</target>
        </trans-unit>
        <trans-unit id="0a3b32dd2c0c0446522505f738b73e43600ba9ad" translate="yes" xml:space="preserve">
          <source>On startup, the &lt;b&gt;sqlite3&lt;/b&gt; program will show a brief banner message then prompt you to enter SQL. Type in SQL statements (terminated by a semicolon), press &quot;Enter&quot; and the SQL will be executed.</source>
          <target state="translated">При запуске программа &lt;b&gt;sqlite3&lt;/b&gt; покажет краткое баннерное сообщение, а затем предложит вам ввести SQL. Введите операторы SQL (заканчивающиеся точкой с запятой), нажмите &amp;laquo;Enter&amp;raquo;, и SQL будет выполнен.</target>
        </trans-unit>
        <trans-unit id="a6133c9cbc7fd01002e1fd8f131c7ef4a48f7b82" translate="yes" xml:space="preserve">
          <source>On startup, the application first decides which version it wants to display. Since the versionId will naturally increase in time and one would normally want to see the latest version, an appropriate query might be:</source>
          <target state="translated">При запуске приложение сначала решает,какую версию оно хочет отобразить.Так как versionId будет естественным образом увеличиваться со временем,и человек обычно хочет видеть последнюю версию,то может быть сделан соответствующий запрос:</target>
        </trans-unit>
        <trans-unit id="d2a06dc722811f829dbda8827b08f5f0b5f36ae8" translate="yes" xml:space="preserve">
          <source>On success, &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; is returned and the new &lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB handle&lt;/a&gt; is stored in *ppBlob. Otherwise an &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; is returned and, unless the error code is SQLITE_MISUSE, *ppBlob is set to NULL. This means that, provided the API is not misused, it is always safe to call &lt;a href=&quot;#sqlite3_blob_close&quot;&gt;sqlite3_blob_close()&lt;/a&gt; on *ppBlob after this function it returns.</source>
          <target state="translated">В случае успеха &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;возвращается SQLITE_OK,&lt;/a&gt; а новый &lt;a href=&quot;#sqlite3_blob&quot;&gt;дескриптор&lt;/a&gt; большого двоичного объекта сохраняется в * ppBlob. В противном случае возвращается &lt;a href=&quot;rescode&quot;&gt;код ошибки&lt;/a&gt; и, если код ошибки не SQLITE_MISUSE, * ppBlob устанавливается в NULL. Это означает, что при условии, что API не используется неправильно, всегда безопасно вызывать &lt;a href=&quot;#sqlite3_blob_close&quot;&gt;sqlite3_blob_close ()&lt;/a&gt; для * ppBlob после того, как эта функция возвращает.</target>
        </trans-unit>
        <trans-unit id="749e0ca8bebcf0ea981a3b5d51013a9a74a29d29" translate="yes" xml:space="preserve">
          <source>On success, &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; is returned and the new &lt;a href=&quot;blob&quot;&gt;BLOB handle&lt;/a&gt; is stored in *ppBlob. Otherwise an &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; is returned and, unless the error code is SQLITE_MISUSE, *ppBlob is set to NULL. This means that, provided the API is not misused, it is always safe to call &lt;a href=&quot;blob_close&quot;&gt;sqlite3_blob_close()&lt;/a&gt; on *ppBlob after this function it returns.</source>
          <target state="translated">В случае успеха &lt;a href=&quot;../rescode#ok&quot;&gt;возвращается SQLITE_OK,&lt;/a&gt; а новый &lt;a href=&quot;blob&quot;&gt;дескриптор&lt;/a&gt; большого двоичного объекта сохраняется в * ppBlob. В противном случае возвращается &lt;a href=&quot;../rescode&quot;&gt;код ошибки&lt;/a&gt; и, если код ошибки не SQLITE_MISUSE, * ppBlob устанавливается в NULL. Это означает, что при условии, что API не используется неправильно, всегда безопасно вызывать &lt;a href=&quot;blob_close&quot;&gt;sqlite3_blob_close ()&lt;/a&gt; для * ppBlob после того, как эта функция возвращает.</target>
        </trans-unit>
        <trans-unit id="65eaebdd334ea618570d91e4458e0eb1b208375f" translate="yes" xml:space="preserve">
          <source>On success, &lt;b&gt;sqlite_compile&lt;/b&gt; returns SQLITE_OK. Otherwise and error code is returned.</source>
          <target state="translated">В случае успеха &lt;b&gt;sqlite_compile&lt;/b&gt; возвращает SQLITE_OK. В противном случае возвращается код ошибки.</target>
        </trans-unit>
        <trans-unit id="3e9b1d8e369d082b964c508c283e64eea1e0560c" translate="yes" xml:space="preserve">
          <source>On success, sqlite3_blob_read() returns SQLITE_OK. Otherwise, an &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; or an &lt;a href=&quot;../rescode#extrc&quot;&gt;extended error code&lt;/a&gt; is returned.</source>
          <target state="translated">В случае успеха sqlite3_blob_read () возвращает SQLITE_OK. В противном случае возвращается &lt;a href=&quot;../rescode&quot;&gt;код ошибки&lt;/a&gt; или &lt;a href=&quot;../rescode#extrc&quot;&gt;расширенный код ошибки&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e81bdc76837634caa6cec9a7812e38a822384af4" translate="yes" xml:space="preserve">
          <source>On success, sqlite3_blob_read() returns SQLITE_OK. Otherwise, an &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; or an &lt;a href=&quot;rescode#extrc&quot;&gt;extended error code&lt;/a&gt; is returned.</source>
          <target state="translated">В случае успеха sqlite3_blob_read () возвращает SQLITE_OK. В противном случае возвращается &lt;a href=&quot;rescode&quot;&gt;код ошибки&lt;/a&gt; или &lt;a href=&quot;rescode#extrc&quot;&gt;расширенный код ошибки&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="00223380eeb8684c87e10d42630c25143e83fb7d" translate="yes" xml:space="preserve">
          <source>On success, sqlite3_blob_write() returns SQLITE_OK. Otherwise, an &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; or an &lt;a href=&quot;../rescode#extrc&quot;&gt;extended error code&lt;/a&gt; is returned. Unless SQLITE_MISUSE is returned, this function sets the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; error code and message accessible via &lt;a href=&quot;errcode&quot;&gt;sqlite3_errcode()&lt;/a&gt; and &lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg()&lt;/a&gt; and related functions.</source>
          <target state="translated">В случае успеха sqlite3_blob_write () возвращает SQLITE_OK. В противном случае возвращается &lt;a href=&quot;../rescode&quot;&gt;код ошибки&lt;/a&gt; или &lt;a href=&quot;../rescode#extrc&quot;&gt;расширенный код ошибки&lt;/a&gt; . Если не возвращается SQLITE_MISUSE, эта функция устанавливает код ошибки &lt;a href=&quot;sqlite3&quot;&gt;подключения&lt;/a&gt; к базе данных и сообщение, доступное через &lt;a href=&quot;errcode&quot;&gt;sqlite3_errcode ()&lt;/a&gt; и &lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg ()&lt;/a&gt; и связанные с ними функции.</target>
        </trans-unit>
        <trans-unit id="e1d8319a0f054e12945ffdcd496271dbacaf81a2" translate="yes" xml:space="preserve">
          <source>On success, sqlite3_blob_write() returns SQLITE_OK. Otherwise, an &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; or an &lt;a href=&quot;rescode#extrc&quot;&gt;extended error code&lt;/a&gt; is returned. Unless SQLITE_MISUSE is returned, this function sets the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; error code and message accessible via &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errcode()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errmsg()&lt;/a&gt; and related functions.</source>
          <target state="translated">В случае успеха sqlite3_blob_write () возвращает SQLITE_OK. В противном случае возвращается &lt;a href=&quot;rescode&quot;&gt;код ошибки&lt;/a&gt; или &lt;a href=&quot;rescode#extrc&quot;&gt;расширенный код ошибки&lt;/a&gt; . Если не возвращается SQLITE_MISUSE, эта функция устанавливает код ошибки &lt;a href=&quot;#sqlite3&quot;&gt;подключения&lt;/a&gt; к базе данных и сообщение, доступное через &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errcode ()&lt;/a&gt; и &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errmsg ()&lt;/a&gt; и связанные с ними функции.</target>
        </trans-unit>
        <trans-unit id="8609e89a9e3f181cc9bf01d1a6238ab2d0959ed4" translate="yes" xml:space="preserve">
          <source>On success, the sqlite3_prepare() family of routines return &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt;; otherwise an &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; is returned.</source>
          <target state="translated">В случае успеха семейство подпрограмм sqlite3_prepare () вернет &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; ; в противном случае возвращается &lt;a href=&quot;rescode&quot;&gt;код ошибки&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3e16251e40927c67fe655d2518e028082c6fa9b3" translate="yes" xml:space="preserve">
          <source>On success, the sqlite3_prepare() family of routines return &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;; otherwise an &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; is returned.</source>
          <target state="translated">В случае успеха семейство подпрограмм sqlite3_prepare () вернет &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; ; в противном случае возвращается &lt;a href=&quot;../rescode&quot;&gt;код ошибки&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="79e4255a03a365ba20cd0884b8ee349e3d935179" translate="yes" xml:space="preserve">
          <source>On the Mac, you can set this pragma:</source>
          <target state="translated">На Маке ты можешь установить эту прагму:</target>
        </trans-unit>
        <trans-unit id="69a450284be9205b76c2e066c35f545c5c025beb" translate="yes" xml:space="preserve">
          <source>On the other hand, a database engine that uses a server can provide better protection from bugs in the client application - stray pointers in a client cannot corrupt memory on the server. And because a server is a single persistent process, it is able control database access with more precision, allowing for finer grain locking and better concurrency.</source>
          <target state="translated">С другой стороны,движок базы данных,использующий сервер,может обеспечить лучшую защиту от ошибок в клиентском приложении-блуждающие указатели в клиенте не могут повредить память на сервере.А поскольку сервер представляет собой единый постоянный процесс,он способен с большей точностью контролировать доступ к базе данных,позволяя более тонкую блокировку зерна и лучшее совпадение.</target>
        </trans-unit>
        <trans-unit id="84736c128a35123ea022380e6a3900484bf1a802" translate="yes" xml:space="preserve">
          <source>On the other hand, a database engine that uses a server can provide better protection from bugs in the client application - stray pointers in a client cannot corrupt memory on the server. And because a server is a single persistent process, it is able to control database access with more precision, allowing for finer-grained locking and better concurrency.</source>
          <target state="translated">С другой стороны,движок базы данных,использующий сервер,может обеспечить лучшую защиту от ошибок в клиентском приложении-блуждающие указатели в клиенте не могут повредить память на сервере.А поскольку сервер представляет собой единый постоянный процесс,он способен с большей точностью контролировать доступ к базе данных,позволяя более точную блокировку и лучшее совпадение.</target>
        </trans-unit>
        <trans-unit id="71cbc82c664fd1caf1a677d0c65b18293805a90f" translate="yes" xml:space="preserve">
          <source>On the other hand, an RBU Vacuum uses more CPU than a regular SQLite VACUUM - in one test as much as five times as much. For this reason, an RBU Vacuum is often significantly slower than an SQLite VACUUM under the same conditions.</source>
          <target state="translated">С другой стороны,RBU Vacuum использует больше CPU,чем обычный SQLite VACUUM-в одном тесте в пять раз больше.По этой причине,вакуум RBU часто значительно медленнее,чем SQLite VACUUM при тех же условиях.</target>
        </trans-unit>
        <trans-unit id="2ec9b50cf6f067a94359ec578926c021dba81fa8" translate="yes" xml:space="preserve">
          <source>On the other hand, dropping tables is not a very common operation so if SQLite takes a little longer, that is not seen as a big problem.</source>
          <target state="translated">С другой стороны,выпадающие таблицы-не очень распространенная операция,поэтому если SQLite занимает немного больше времени,то это не рассматривается как большая проблема.</target>
        </trans-unit>
        <trans-unit id="b75edbc4ccb51b3a0effc26ec943821968d21e88" translate="yes" xml:space="preserve">
          <source>On the other hand, if the result of the subquery must be scanned multiple times (because, for example, it is just one table in a join) then it is better to use a transient table to remember the entire result of the subquery, in order to avoid computing the subquery more than once.</source>
          <target state="translated">С другой стороны,если результат подзапроса должен быть отсканирован несколько раз (потому что,например,это всего лишь одна таблица в соединении),то лучше использовать переходную таблицу,чтобы запомнить весь результат подзапроса,чтобы избежать вычисления подзапроса более одного раза.</target>
        </trans-unit>
        <trans-unit id="4cb26bb6bd2845585001f514df8ac5e23d3a9784" translate="yes" xml:space="preserve">
          <source>On the other hand, read performance deteriorates as the WAL file grows in size since each reader must check the WAL file for the content and the time needed to check the WAL file is proportional to the size of the WAL file. The wal-index helps find content in the WAL file much faster, but performance still falls off with increasing WAL file size. Hence, to maintain good read performance it is important to keep the WAL file size down by running checkpoints at regular intervals.</source>
          <target state="translated">С другой стороны,производительность чтения ухудшается по мере роста размера файла WAL,поскольку каждый читатель должен проверять файл WAL на содержание,а время,необходимое для проверки файла WAL,пропорционально размеру файла WAL.Индекс wal-index помогает находить содержимое в файле WAL гораздо быстрее,но производительность все равно снижается с увеличением размера файла WAL.Следовательно,для поддержания хорошей производительности чтения важно уменьшить размер файла WAL за счет регулярного выполнения контрольных точек через определенные промежутки времени.</target>
        </trans-unit>
        <trans-unit id="9a0c49cb1cedb27f90f5b843b5321b6c2675c041" translate="yes" xml:space="preserve">
          <source>On the stack display, most entries are shown with a prefix that tells the datatype of that stack entry. Integers begin with &quot;&lt;code&gt;i:&lt;/code&gt;&quot;. Floating point values begin with &quot;&lt;code&gt;r:&lt;/code&gt;&quot;. (The &quot;r&quot; stands for &quot;real-number&quot;.) Strings begin with either &quot;&lt;code&gt;s:&lt;/code&gt;&quot;, &quot;&lt;code&gt;t:&lt;/code&gt;&quot;, &quot;&lt;code&gt;e:&lt;/code&gt;&quot; or &quot;&lt;code&gt;z:&lt;/code&gt;&quot;. The difference among the string prefixes is caused by how their memory is allocated. The z: strings are stored in memory obtained from &lt;b&gt;malloc()&lt;/b&gt;. The t: strings are statically allocated. The e: strings are ephemeral. All other strings have the s: prefix. This doesn't make any difference to you, the observer, but it is vitally important to the VDBE since the z: strings need to be passed to &lt;b&gt;free()&lt;/b&gt; when they are popped to avoid a memory leak. Note that only the first 10 characters of string values are displayed and that binary values (such as the result of the MakeRecord instruction) are treated as strings. The only other datatype that can be stored on the VDBE stack is a NULL, which is display without prefix as simply &quot;&lt;code&gt;NULL&lt;/code&gt;&quot;. If an integer has been placed on the stack as both an integer and a string, its prefix is &quot;&lt;code&gt;si:&lt;/code&gt;&quot;.</source>
          <target state="translated">На дисплее стека большинство записей отображается с префиксом, который указывает тип данных этой записи стека. Целые числа начинаются с &amp;laquo; &lt;code&gt;i:&lt;/code&gt; &amp;raquo;. Значения с плавающей запятой начинаются с &amp;laquo; &lt;code&gt;r:&lt;/code&gt; &amp;raquo;. (&amp;laquo;R&amp;raquo; означает &amp;laquo;действительное число&amp;raquo;.) Строки начинаются с &amp;laquo; &lt;code&gt;s:&lt;/code&gt; &amp;raquo;, &amp;laquo; &lt;code&gt;t:&lt;/code&gt; &amp;raquo;, &amp;laquo; &lt;code&gt;e:&lt;/code&gt; &amp;raquo; или &amp;laquo; &lt;code&gt;z:&lt;/code&gt; &amp;raquo;. Разница между строковыми префиксами обусловлена ​​тем, как распределяется их память. Строки z: хранятся в памяти, полученной из &lt;b&gt;malloc ()&lt;/b&gt; . Строки t: размещаются статически. Струны e: эфемерны. Все остальные строки имеют префикс s :. Это не имеет значения для вас, наблюдатель,но это жизненно важно для VDBE, поскольку строки z: должны передаваться в&lt;b&gt;free (),&lt;/b&gt; когда они появляются, чтобы избежать утечки памяти. Обратите внимание, что отображаются только первые 10 символов строковых значений и что двоичные значения (например, результат инструкции MakeRecord) обрабатываются как строки. Единственный другой тип данных, который может храниться в стеке VDBE, - это NULL, который отображается без префикса просто как &amp;laquo; &lt;code&gt;NULL&lt;/code&gt; &amp;raquo;. Если целое число было помещено в стек и как целое число, и как строка, его префикс - &amp;laquo; &lt;code&gt;si:&lt;/code&gt; &amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="e3336bd71adcf37ccf53527f3a1cc4855eac8894" translate="yes" xml:space="preserve">
          <source>On unix systems (or on Windows using cygwin or mingw+msys) the command typically looks something like this:</source>
          <target state="translated">На unix-системах (или в Windows с помощью cygwin или mingw+msys)команда обычно выглядит примерно так:</target>
        </trans-unit>
        <trans-unit id="287d1cbba1056569ceaf042e45ed9558181651a7" translate="yes" xml:space="preserve">
          <source>On unix, if a symlink to a database file is opened, then the corresponding journal files are based on the actual filename, not the symlink name.</source>
          <target state="translated">В unix,если открыта системная ссылка на файл базы данных,то соответствующие файлы журнала основываются на фактическом имени файла,а не на имени системной ссылки.</target>
        </trans-unit>
        <trans-unit id="6c70d0e29a89e83eef274cc81c5528ba689d997c" translate="yes" xml:space="preserve">
          <source>On unix-like systems, directories are searched in the following order:</source>
          <target state="translated">На unix-подобных системах поиск по каталогам осуществляется в следующем порядке:</target>
        </trans-unit>
        <trans-unit id="db7db60b91e81d2d39614db0d3144dc3caa85aa5" translate="yes" xml:space="preserve">
          <source>On windows only, convert all &quot;&lt;code&gt;\&lt;/code&gt;&quot; characters into &quot;&lt;code&gt;/&lt;/code&gt;&quot;.</source>
          <target state="translated">Только в Windows: конвертируйте все символы &amp;laquo; &lt;code&gt;\&lt;/code&gt; &amp;raquo; в &amp;laquo; &lt;code&gt;/&lt;/code&gt; &amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="aa996bed689bb081c327fe76624367885c13654f" translate="yes" xml:space="preserve">
          <source>On windows only, if the filename begins with a drive letter, prepend a single &quot;&lt;code&gt;/&lt;/code&gt;&quot; character.</source>
          <target state="translated">Только в Windows: если имя файла начинается с буквы диска, добавьте перед ним один символ &amp;laquo; &lt;code&gt;/&lt;/code&gt; &amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="d9c768782ea8653d485fb3b7f5aba21cb2ca7bf3" translate="yes" xml:space="preserve">
          <source>Once</source>
          <target state="translated">Once</target>
        </trans-unit>
        <trans-unit id="87f26aaf5f6994f877b899775d955216fa5722f5" translate="yes" xml:space="preserve">
          <source>Once a</source>
          <target state="translated">Один раз</target>
        </trans-unit>
        <trans-unit id="8464198c181050b3c7b7af3b57436c91d71a13de" translate="yes" xml:space="preserve">
          <source>Once a VFS has been registered, it should never be modified. If a change in behavior is required, a new VFS should be registered. The application could, perhaps, use &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_find()&lt;/a&gt; to locate the old VFS, make a copy of the old VFS into a new &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object, make the desired modifications to the new VFS, unregister the old VFS, then register the new VFS in its place. Existing database connections would continue to use the old VFS even after it is unregistered, but new database connections would use the new VFS.</source>
          <target state="translated">После регистрации VFS не следует изменять ее. Если требуется изменение поведения, необходимо зарегистрировать новую VFS. Приложение, возможно, могло бы использовать &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_find (),&lt;/a&gt; чтобы найти старую VFS, сделать копию старой VFS в новый объект &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; , внести желаемые изменения в новую VFS, отменить регистрацию старой VFS, а затем зарегистрировать новую VFS в ее место. Существующие соединения с базой данных будут продолжать использовать старую VFS даже после отмены регистрации, но новые соединения с базой данных будут использовать новую VFS.</target>
        </trans-unit>
        <trans-unit id="55b2eace4f6d572184649196769be324d9ec08aa" translate="yes" xml:space="preserve">
          <source>Once a connection obtains a table lock, it is not released until the current transaction (read or write) is concluded.</source>
          <target state="translated">Как только соединение получает блокировку таблицы,оно не освобождается до тех пор,пока не будет заключена текущая транзакция (чтение или запись).</target>
        </trans-unit>
        <trans-unit id="5e4e9f1432dcf3c9b2a4412dec01ffd3ea3a631b" translate="yes" xml:space="preserve">
          <source>Once a process obtains an exclusive lock, it is permitted to write to the database file. It then proceeds to read the original content of pages out of the rollback journal and write that content back to where it came from in the database file. Recall that the header of the rollback journal records the original size of the database file prior to the start of the aborted transaction. SQLite uses this information to truncate the database file back to its original size in cases where the incomplete transaction caused the database to grow. At the end of this step, the database should be the same size and contain the same information as it did before the start of the aborted transaction.</source>
          <target state="translated">Как только процесс получает эксклюзивный замок,разрешается запись в файл базы данных.Затем он переходит к чтению исходного содержимого страниц из журнала отката и записывает это содержимое обратно в файл базы данных,откуда оно пришло.Вспомните,что заголовок журнала отката записывает исходный размер файла базы данных до начала прерванной транзакции.SQLite использует эту информацию для усечения файла базы данных до исходного размера в тех случаях,когда неполная транзакция привела к росту базы данных.В конце этого шага БД должна быть того же размера и содержать ту же информацию,что и до начала прерванной транзакции.</target>
        </trans-unit>
        <trans-unit id="b42ea281b3fc7c07c016d5e3f2cf18291c599ca4" translate="yes" xml:space="preserve">
          <source>Once a table has been attached to a session object, the session object records the primary key values of all new rows inserted into the table. It also records the original primary key and other column values of any deleted or updated rows. For each unique primary key value, data is only recorded once - the first time a row with said primary key is inserted, updated or deleted in the lifetime of the session.</source>
          <target state="translated">После прикрепления таблицы к объекту сеанса,объект сеанса записывает первичные ключевые значения всех новых строк,вставленных в таблицу.Он также записывает исходный первичный ключ и другие значения столбцов любых удаленных или обновленных строк.Для каждого уникального значения первичного ключа данные записываются только один раз-это первый раз,когда строка с указанным первичным ключом вставляется,обновляется или удаляется в течение всего сеанса.</target>
        </trans-unit>
        <trans-unit id="9c0b7ad6ff995bbd9fed309a9d73615d47bfa0e5" translate="yes" xml:space="preserve">
          <source>Once a transaction has been opened, reading data from a database connection is a simple operation. Using the xRead() method of the file-handle open on the database file, the required database file pages are read one at a time. SQLite never reads partial pages and always uses a single call to xRead() for each required page.</source>
          <target state="translated">После открытия транзакции чтение данных из соединения с базой данных является простой операцией.С помощью метода xRead()файл-ручка,открытая на файле базы данных,считываются по очереди страницы требуемого файла базы данных.SQLite никогда не читает частичные страницы и всегда использует один вызов xRead()для каждой требуемой страницы.</target>
        </trans-unit>
        <trans-unit id="511dc23c3f8ad619f86fc49e5ac60cacc5f4cbfc" translate="yes" xml:space="preserve">
          <source>Once a virtual table has been created, it can be used like any other table with the exceptions noted above and imposed by specific virtual table implementations. A virtual table is destroyed using the ordinary &lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt; syntax.</source>
          <target state="translated">После создания виртуальной таблицы ее можно использовать как любую другую таблицу с исключениями, указанными выше и налагаемыми конкретными реализациями виртуальной таблицы. Виртуальная таблица уничтожается с использованием обычного синтаксиса &lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c3f695a7b377f8d655c6f7bd1deb78c481aa015e" translate="yes" xml:space="preserve">
          <source>Once again, practical implementations will likely subclass this structure to add additional private fields.</source>
          <target state="translated">Опять же,практические реализации,скорее всего,подразделят эту структуру на подклассы для добавления дополнительных приватных полей.</target>
        </trans-unit>
        <trans-unit id="44317a76e0c4f1b6b3d16db84fa92562885dc8a9" translate="yes" xml:space="preserve">
          <source>Once again, the SQL statements generate identical bytecode and thus do exactly the same job in exactly the same way. But the second form is made easier for humans to read by grouping the query parameters together into a single row value rather than scattering them across the WHERE clause.</source>
          <target state="translated">И снова SQL операторы генерируют идентичный байткод и таким образом делают точно такую же работу.Но вторую форму человеку проще прочитать,сгруппировав параметры запроса в одну строку,а не рассеивая их по пункту WHERE.</target>
        </trans-unit>
        <trans-unit id="d645ca4d6b0e5bfa41d1d0e06bb9cd91ff636156" translate="yes" xml:space="preserve">
          <source>Once all rollback journal files have been flushed to disk, it is safe to begin updating database files. We have to obtain an exclusive lock on all database files before writing the changes. After all the changes are written, it is important to flush the changes to disk so that they will be preserved in the event of a power failure or operating system crash.</source>
          <target state="translated">После того,как все файлы журналов отката будут записаны на диск,можно приступать к обновлению файлов базы данных.Перед записью изменений мы должны получить эксклюзивную блокировку всех файлов базы данных.После того,как все изменения записаны,важно промыть их на диск,чтобы они были сохранены в случае отключения питания или сбоя операционной системы.</target>
        </trans-unit>
        <trans-unit id="73fcb528effe6301ec78591adf7629a8ed98b913" translate="yes" xml:space="preserve">
          <source>Once an SQLite database is open, it can be controlled using methods of the</source>
          <target state="translated">После того,как база данных SQLite открыта,ею можно управлять с помощью метода</target>
        </trans-unit>
        <trans-unit id="1676ac6920d27f0701cc052fe7ff5982a44cea9d" translate="yes" xml:space="preserve">
          <source>Once an encoding has been set for a database, it cannot be changed.</source>
          <target state="translated">После установки кодировки для базы данных она не может быть изменена.</target>
        </trans-unit>
        <trans-unit id="1f61d0c0dc743205cfd592b973902a4df3bd2139" translate="yes" xml:space="preserve">
          <source>Once an exclusive lock is held, we know that no other processes are reading from the database file and it is safe to write changes into the database file. Usually those changes only go as far as the operating systems disk cache and do not make it all the way to mass storage.</source>
          <target state="translated">После того,как эксклюзивный замок снят,мы знаем,что никакие другие процессы не читают из файла базы данных,и можно безопасно записать изменения в файл базы данных.Обычно эти изменения заходят только в кэш диска операционной системы и не попадают в массовое хранилище.</target>
        </trans-unit>
        <trans-unit id="8d6da848ac7743477288c842a221e398489c8a06" translate="yes" xml:space="preserve">
          <source>Once any conversions have taken place, and neither value is NULL, the values are compared. If both values are blobs then memcmp() is used to determine the results of the comparison. If both values are text, then the appropriate collating function specified in P4 is used to do the comparison. If P4 is not specified then memcmp() is used to compare text string. If both values are numeric, then a numeric comparison is used. If the two values are of different types, then numbers are considered less than strings and strings are considered less than blobs.</source>
          <target state="translated">После любых преобразований,ни одно из которых не является NULL,значения сравниваются.Если оба значения являются блоками,то для определения результатов сравнения используется функция memcmp().Если оба значения являются текстовыми,то для проведения сравнения используется соответствующая функция сравнения,указанная в P4.Если P4 не указана,то для сравнения текстовой строки используется функция memcmp().Если оба значения являются числовыми,то для сравнения используется числовая функция.Если оба значения разного типа,то числа считаются меньше,чем строки,а строки считаются меньше,чем капли.</target>
        </trans-unit>
        <trans-unit id="4b170c45b3f098d917697616ac86ca3f213bd255" translate="yes" xml:space="preserve">
          <source>Once everything is ready, run the &quot;&lt;code&gt;fossil commit&lt;/code&gt;&quot; command to check in the changes. This creates circle (4) in the diagram above.</source>
          <target state="translated">Когда все будет готово, запустите команду &quot; &lt;code&gt;fossil commit&lt;/code&gt; &quot;, чтобы проверить изменения. Это создает круг (4) на схеме выше.</target>
        </trans-unit>
        <trans-unit id="89efbd20c0a9cf3f9851965660941121b8a57cbc" translate="yes" xml:space="preserve">
          <source>Once one is comfortable with the concept of storing each slide separately, it is a small step to support versioning of the presentation. Consider the following schema:</source>
          <target state="translated">После того,как вы уживаетесь с концепцией хранения каждого слайда в отдельности,это небольшой шаг для поддержки версионирования презентации.Рассмотрим следующую схему:</target>
        </trans-unit>
        <trans-unit id="05be8dd08c1c90f1df285706af044dc836d0d98a" translate="yes" xml:space="preserve">
          <source>Once populated, there are three ways to execute a full-text query against the contents of an FTS5 table:</source>
          <target state="translated">После заполнения существует три способа выполнения полнотекстового запроса к содержимому таблицы FTS5:</target>
        </trans-unit>
        <trans-unit id="e7dc51406db9bf51bbe6620c6512b34c3f0e8f5e" translate="yes" xml:space="preserve">
          <source>Once the dirty page being purged is writable, it is simply written into the database file.</source>
          <target state="translated">После того,как очищаемая грязная страница может быть записана,она просто записывается в файл базы данных.</target>
        </trans-unit>
        <trans-unit id="821430ef05c1ab204de759a3df24102ae4261d90" translate="yes" xml:space="preserve">
          <source>Once the input data from the FROM clause has been filtered by the WHERE clause expression (if any), the set of result rows for the simple SELECT are calculated. Exactly how this is done depends on whether the simple SELECT is an aggregate or non-aggregate query, and whether or not a GROUP BY clause was specified.</source>
          <target state="translated">После того,как входные данные из выражения FROM отфильтрованы выражением WHERE (если таковое имеется),вычисляется набор строк результата для простого SELECT.Точность этого зависит от того,является ли простой SELECT агрегированным или неагрегированным запросом и была ли указана оговорка GROUP BY или нет.</target>
        </trans-unit>
        <trans-unit id="79336569e93b2e9d0a83cc5e0a929d5ce48d2824" translate="yes" xml:space="preserve">
          <source>Once the project repository is created, create an open checkout of the project by moving to the directory where you want to keep all of the project source code and typing:</source>
          <target state="translated">После того,как репозиторий проекта создан,создайте открытую проверку проекта,перейдя в каталог,в котором вы хотите сохранить весь исходный код проекта и набрав его:</target>
        </trans-unit>
        <trans-unit id="c4e9c9ce3f592c90096798d4d198a8b0474086e9" translate="yes" xml:space="preserve">
          <source>Once the spellfix1 extension is loaded, an instance of the spellfix1 virtual table is created like this:</source>
          <target state="translated">После загрузки расширения spellfix1 создаётся экземпляр виртуальной таблицы spellfix1 таким образом:</target>
        </trans-unit>
        <trans-unit id="8513b43854c13df7657753be614db748baf13f7a" translate="yes" xml:space="preserve">
          <source>Once the test program is generated, it is run with no arguments to perform the tests. Progress information as well as error diagnostics appear on standard output. (Alternative output arrangements can be made using a compile-time option for embedded devices that lack a standard output channel.) The program returns zero if there are no errors and non-zero if any problems were detected.</source>
          <target state="translated">После того,как тестовая программа сгенерирована,она запускается без аргументов для выполнения тестов.Информация о ходе выполнения,а также диагностика ошибок появляется на стандартном выходе.(Для встраиваемых устройств,не имеющих стандартного выходного канала,можно использовать опцию &quot;время компиляции&quot;).Программа возвращает ноль при отсутствии ошибок и ненулевой при обнаружении проблем.</target>
        </trans-unit>
        <trans-unit id="bd0d76b14cf548de7ba347b074f1a4d3fbd73686" translate="yes" xml:space="preserve">
          <source>Once the virtual table is created, it can be queried as follows:</source>
          <target state="translated">После создания виртуальной таблицы ее можно запросить следующим образом:</target>
        </trans-unit>
        <trans-unit id="1f76d0dc14ccffaabe0506021b655e9b2d8e3d76" translate="yes" xml:space="preserve">
          <source>Once you locate a specific version, click on the hyperlink for that version to see the &quot;Check-in Information Page&quot;. Then click on either the &quot;Tarball&quot; link or the &quot;ZIP archive&quot; link to download the complete source tree.</source>
          <target state="translated">Как только вы найдете конкретную версию,нажмите на гиперссылку для этой версии,чтобы увидеть &quot;Страницу информации о регистрации&quot;.Затем нажмите либо на ссылку &quot;Tarball&quot;,либо на ссылку &quot;ZIP-архив&quot;,чтобы загрузить полное дерево исходных текстов.</target>
        </trans-unit>
        <trans-unit id="5d89aa77c530c282e22378ce0f5d708e01a8b4fb" translate="yes" xml:space="preserve">
          <source>One approach to this query is to use the fruit='Orange' term of the WHERE clause to find all rows dealing with oranges, then filter those rows by rejecting any that are from states other than California. This process is shown by &lt;a href=&quot;#fig7&quot;&gt;figure 7&lt;/a&gt; above. This is a perfectly reasonable approach in most cases. Yes, the database engine did have to do an extra binary search for the Florida orange row that was later rejected, so it was not as efficient as we might hope, though for many applications it is efficient enough.</source>
          <target state="translated">Один из подходов к этому запросу - использовать термин fruit = 'Orange' в предложении WHERE, чтобы найти все строки, относящиеся к апельсинам, а затем отфильтровать эти строки, отклоняя любые из штатов, отличных от Калифорнии. Этот процесс показан на &lt;a href=&quot;#fig7&quot;&gt;рисунке 7&lt;/a&gt; выше. В большинстве случаев это совершенно разумный подход. Да, движку базы данных действительно пришлось выполнить дополнительный двоичный поиск оранжевой строки Флориды, который позже был отклонен, поэтому он оказался не таким эффективным, как мы могли бы надеяться, хотя для многих приложений он достаточно эффективен.</target>
        </trans-unit>
        <trans-unit id="83e48e323326e14265bd89807dc478da45112a98" translate="yes" xml:space="preserve">
          <source>One can also provide comma-separated arguments to the module following the module name:</source>
          <target state="translated">Можно также предоставлять аргументы,разделенные запятыми,модулю,следующему за именем модуля:</target>
        </trans-unit>
        <trans-unit id="c99a07ebdfa971a90b20da9b4561b5f49cd6023c" translate="yes" xml:space="preserve">
          <source>One can also set the &lt;a href=&quot;cli&quot;&gt;CLI&lt;/a&gt; into automatic EXPLAIN QUERY PLAN mode using the &quot;.eqp on&quot; command:</source>
          <target state="translated">Также можно установить &lt;a href=&quot;cli&quot;&gt;CLI&lt;/a&gt; в автоматический режим EXPLAIN QUERY PLAN с помощью команды &quot;.eqp on&quot;:</target>
        </trans-unit>
        <trans-unit id="efbb187108974c009f143234a98d6989ff9c9ac6" translate="yes" xml:space="preserve">
          <source>One can also think of savepoints as &quot;marks&quot; in the transaction timeline. In this view, the SAVEPOINT command creates a new mark, the ROLLBACK TO command rewinds the timeline back to a point just after the named mark, and the RELEASE command erases marks from the timeline without actually making any changes to the database.</source>
          <target state="translated">Можно также думать о точках сохранения как о &quot;метках&quot; в графике транзакций.В этом представлении команда SAVEPOINT создает новую метку,команда ROLLBACK TO перематывает временную шкалу обратно в точку,расположенную сразу после именованной метки,а команда RELEASE стирает метки с временной шкалы,не внося никаких изменений в базу данных.</target>
        </trans-unit>
        <trans-unit id="3d55d95e5af6d3d744fa5a934dc2cc27683084a3" translate="yes" xml:space="preserve">
          <source>One can explicitly change out of WAL mode using a pragma such as this:</source>
          <target state="translated">Можно явно выйти из режима WAL,используя такую прагму:</target>
        </trans-unit>
        <trans-unit id="5812082b2084545c8ed5d26ce266777d4a58efe5" translate="yes" xml:space="preserve">
          <source>One can see how the OR-by-UNION technique could also be leveraged to use multiple indices on queries where the WHERE clause has terms connected by AND, by using an intersect operator in place of union. Many SQL database engines will do just that. But the performance gain over using just a single index is slight and so SQLite does not implement that technique at this time. However, a future version SQLite might be enhanced to support AND-by-INTERSECT.</source>
          <target state="translated">Можно увидеть,как можно использовать технику &quot;по ОРИ&quot; для использования нескольких индексов на запросах,где в пункте &quot;Где&quot; есть термины,связанные с И&quot;,с помощью оператора пересечения вместо объединения.Многие движки баз данных SQL сделают именно это.Но прирост производительности по сравнению с использованием только одного индекса невелик,и поэтому SQLite в настоящее время не реализует эту технику.Тем не менее,будущая версия SQLite может быть усовершенствована для поддержки AND-by-INTERSECT.</target>
        </trans-unit>
        <trans-unit id="18266c8f1da4ccb3784663f1422488207a89b45d" translate="yes" xml:space="preserve">
          <source>One cannot create a trigger on a virtual table.</source>
          <target state="translated">Нельзя создать триггер на виртуальном столе.</target>
        </trans-unit>
        <trans-unit id="08c14fea12c1a91b86b4eb3020bc8d201daa13d9" translate="yes" xml:space="preserve">
          <source>One cannot create additional indices on a virtual table. (Virtual tables can have indices but that must be built into the virtual table implementation. Indices cannot be added separately using &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt; statements.)</source>
          <target state="translated">На виртуальной таблице нельзя создать дополнительные индексы. (Виртуальные таблицы могут иметь индексы, но они должны быть встроены в реализацию виртуальной таблицы. Индексы нельзя добавлять отдельно с помощью операторов &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt; .)</target>
        </trans-unit>
        <trans-unit id="d3b50c178c087fb42ad06f0aba999c85b1ef895b" translate="yes" xml:space="preserve">
          <source>One cannot easily view, change, or extract the content of an OpenDocument presentation using generic tools. The only reasonable way to view or edit an OpenDocument document is to open it up using an application that is specifically designed to read or write OpenDocument (read: LibreOffice or one of its cousins). The situation could be worse. One can extract and view individual images (say) from a presentation using just the &quot;zip&quot; archiver tool. But it is not reasonable try to extract the text from a slide. Remember that all content is stored in a single &quot;context.xml&quot; file. That file is XML, so it is a text file. But it is not a text file that can be managed with an ordinary text editor. For the example presentation above, the content.xml file consist of exactly two lines. The first line of the file is just:</source>
          <target state="translated">Невозможно легко просмотреть,изменить или извлечь содержимое презентации OpenDocument с помощью общих инструментов.Единственный разумный способ просмотра или редактирования документа OpenDocument-это открыть его с помощью приложения,специально разработанного для чтения или написания OpenDocument (читать:LibreOffice или один из его двоюродных братьев).Ситуация может быть хуже.Можно извлекать и просматривать отдельные изображения (скажем)из презентации с помощью простого инструмента архиватора &quot;zip&quot;.Но пытаться извлечь текст из слайда нецелесообразно.Помните,что все содержимое хранится в одном файле &quot;context.xml&quot;.Этот файл является XML,то есть текстовым.Но это не текстовый файл,которым можно управлять с помощью обычного текстового редактора.Для вышеприведенного примера представления,файл content.xml состоит ровно из двух строк.Первая строка файла просто:</target>
        </trans-unit>
        <trans-unit id="8b60832325e280604faf68cf7c5149fd06825525" translate="yes" xml:space="preserve">
          <source>One cannot run &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE ... ADD COLUMN&lt;/a&gt; commands against a virtual table.</source>
          <target state="translated">Невозможно выполнить команды &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE ... ADD COLUMN&lt;/a&gt; для виртуальной таблицы.</target>
        </trans-unit>
        <trans-unit id="8229271a498b58a8b73749061ba175879d5bffff" translate="yes" xml:space="preserve">
          <source>One difference between Next and ListRead is their idea of a &quot;thing&quot;. The &quot;things&quot; for the Next instruction are records in a database file. &quot;Things&quot; for ListRead are integer keys in a list. Another difference is whether to jump or fall through if there is no next &quot;thing&quot;. In this case, Next falls through, and ListRead jumps. Later on, we will see other looping instructions (NextIdx and SortNext) that operate using the same principle.</source>
          <target state="translated">Одно из различий между Next и ListRead заключается в их представлении о &quot;вещи&quot;.Вещи&quot; для команды Next-это записи в файле базы данных.&quot;Вещи&quot; для ListRead-это целочисленные ключи в списке.Другое отличие-прыгать или проваливаться,если следующего &quot;вещи&quot; нет.В этом случае Next выпадает,а ListRead прыгает.Позже мы увидим другие инструкции по прыжкам (NextIdx и SortNext),которые работают по тому же принципу.</target>
        </trans-unit>
        <trans-unit id="0e2add845dd3757fedbc712aca0fdd2b6ebca768" translate="yes" xml:space="preserve">
          <source>One example of this occurred circa 2013-08-30 on the canonical repository for the &lt;a href=&quot;http://www.fossil-scm.org/&quot;&gt;Fossil DVCS&lt;/a&gt;. In that event, file descriptor 2 (standard error) was being erroneously closed (by &lt;a href=&quot;http://www.stunnel.org/&quot;&gt;stunnel&lt;/a&gt;, we suspect) prior to &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; so that the file descriptor used for the repository database file was 2. Later, an application bug caused an assert() statement to emit an error message by invoking write(2,...). But since file descriptor 2 was now connected to a database file, the error message overwrote part of the database. To guard against this kind of problem, SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_1.html&quot;&gt;version 3.8.1&lt;/a&gt; (2013-10-17) and later refuse to use low-numbered file descriptors for database files. (See &lt;a href=&quot;compile#minimum_file_descriptor&quot;&gt;SQLITE_MINIMUM_FILE_DESCRIPTOR&lt;/a&gt; for additional information.)</source>
          <target state="translated">Один из примеров этого произошел примерно 30 августа 2013 г. в каноническом репозитории &lt;a href=&quot;http://www.fossil-scm.org/&quot;&gt;Fossil DVCS&lt;/a&gt; . В этом случае файловый дескриптор 2 (стандартная ошибка) был ошибочно закрыт ( мы подозреваем, &lt;a href=&quot;http://www.stunnel.org/&quot;&gt;stunnel&lt;/a&gt; ) до &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2 (),&lt;/a&gt; так что файловый дескриптор, используемый для файла базы данных репозитория, был 2. Позже ошибка приложения вызвала assert ( ), чтобы выдать сообщение об ошибке, вызвав write (2, ...). Но поскольку файловый дескриптор 2 теперь был подключен к файлу базы данных, сообщение об ошибке перезаписало часть базы данных. Чтобы защититься от такого рода проблем, SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_1.html&quot;&gt;версии 3.8.1&lt;/a&gt; (2013-10-17) и более поздних версий отказываются использовать файловые дескрипторы с малыми номерами для файлов базы данных. (См. &lt;a href=&quot;compile#minimum_file_descriptor&quot;&gt;SQLITE_MINIMUM_FILE_DESCRIPTOR&lt;/a&gt; для дополнительной информации.)</target>
        </trans-unit>
        <trans-unit id="2800173ae3677a256fd77a10d7d4ad92a56413c2" translate="yes" xml:space="preserve">
          <source>One example of this occurred circa 2013-08-30 on the canonical repository for the &lt;a href=&quot;https://www.fossil-scm.org/&quot;&gt;Fossil DVCS&lt;/a&gt;. In that event, file descriptor 2 (standard error) was being erroneously closed (by &lt;a href=&quot;https://www.stunnel.org/&quot;&gt;stunnel&lt;/a&gt;, we suspect) prior to &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; so that the file descriptor used for the repository database file was 2. Later, an application bug caused an assert() statement to emit an error message by invoking write(2,...). But since file descriptor 2 was now connected to a database file, the error message overwrote part of the database. To guard against this kind of problem, SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_1.html&quot;&gt;version 3.8.1&lt;/a&gt; (2013-10-17) and later refuse to use low-numbered file descriptors for database files. (See &lt;a href=&quot;compile#minimum_file_descriptor&quot;&gt;SQLITE_MINIMUM_FILE_DESCRIPTOR&lt;/a&gt; for additional information.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f155185b09ba1b186403646b80d41d02e18f29b2" translate="yes" xml:space="preserve">
          <source>One exception to the typelessness of SQLite is a column whose type is INTEGER PRIMARY KEY. (And you must use &quot;INTEGER&quot; not &quot;INT&quot;. A column of type INT PRIMARY KEY is typeless just like any other.) INTEGER PRIMARY KEY columns must contain a 32-bit signed integer. Any attempt to insert non-integer data will result in an error.</source>
          <target state="translated">Одним из исключений безпечатности SQLite является столбец,тип которого-INTEGER PRIMARY KEY.(И вы должны использовать &quot;INTEGER&quot;,а не &quot;INT&quot;.Столбец типа INT PRIMARY KEY является безпечатным,как и любой другой).Столбец типа INTEGER PRIMARY KEY должен содержать 32-битное знаковое целое число.Любая попытка вставить нецифровые данные приведет к ошибке.</target>
        </trans-unit>
        <trans-unit id="c476dc0c19b1ad151c922c972d11950866ac1040" translate="yes" xml:space="preserve">
          <source>One fuzzing researcher of particular note is &lt;a href=&quot;https://www.manuelrigger.at/&quot;&gt;Manuel Rigger&lt;/a&gt;, currently (as this paragraph is written on 2019-12-21) at &lt;a href=&quot;https://ethz.ch/en.html&quot;&gt;ETH Zurich&lt;/a&gt;. Most fuzzers only look for assertion faults, crashes, undefined behavior (UB), or other easily detected anomalies. Dr. Rigger's fuzzers, on the other hand, are able to find cases where SQLite computes an incorrect answer. Rigger has found &lt;a href=&quot;https://www.sqlite.org/src/timeline?y=t&amp;amp;u=mrigger&amp;amp;n=all&quot;&gt;many such cases&lt;/a&gt;. Most of these finds are fairly obscure corner cases involving type conversions and affinity transformations, and a good number of the finds are against unreleased features. Nevertheless, his finds are still important as they are real bugs, and the SQLite developers are grateful to be able to identify and fix the underlying problems. Rigger's work is currently unpublished. When it is released, it could be as influential as Zalewski's invention of AFL and profile-guided fuzzing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6bf8910e6414d0165fef0d30b0886bc0f8d4329" translate="yes" xml:space="preserve">
          <source>One implication of the above is that if a change is made and then unmade within a single session (for example if a row is inserted and then deleted again), the sessions module does not report any change at all. Or if a row is updated multiple times within the same session, all updates are coalesced into a single update within any changeset or patchset blob.</source>
          <target state="translated">Одно из последствий вышесказанного заключается в том,что если в течение одного сеанса (например,если вставляется строка,а затем снова удаляется)происходит изменение,то модуль сеансов вообще не сообщает об этом изменении.Или если строка обновляется несколько раз в течение одного сеанса,все обновления объединяются в одно обновление в любом changeset или patchset блоке.</target>
        </trans-unit>
        <trans-unit id="fc9f38831587103a404686b12cd389ecfbf1fe12" translate="yes" xml:space="preserve">
          <source>One might argue that it is ok, in this era of multi-gigabyte desktops, to read the entire document into memory. But it is not ok. For one, the amount of memory used far exceeds the (compressed) file size on disk. So a 50MB presentation might take 200MB or more RAM. That still is not a problem if one only edits a single document at a time. But when working on a talk, this author will typically have 10 or 15 different presentations up all at the same time (to facilitate copy/paste of slides from past presentation) and so gigabytes of memory are required. Add in an open web browser or two and a few other desktop apps, and suddenly the disk is whirling and the machine is swapping. And even having just a single document is a problem when working on an inexpensive Chromebook retrofitted with Ubuntu. Using less memory is always better.</source>
          <target state="translated">Можно поспорить,что в эту эпоху многогигабайтных рабочих столов нормально читать весь документ в память.Но это не нормально.Во-первых,объем используемой памяти намного превышает (сжатый)размер файла на диске.Так что для презентации на 50 МБ может потребоваться 200 МБ и более оперативной памяти.Это все равно не проблема,если редактировать только один документ за раз.Но при работе над докладом этот автор,как правило,имеет 10 или 15 различных презентаций одновременно (для облегчения копирования/вставки слайдов из прошлой презентации),поэтому требуется гигабайт памяти.Добавьте в открытый веб-браузер или два и несколько других настольных приложений,и вдруг диск закрутится,и машина поменяется местами.И даже иметь только один документ является проблемой при работе на недорогой Chromebook,модернизированный с Ubuntu.Использование меньшего количества памяти всегда лучше.</target>
        </trans-unit>
        <trans-unit id="f44cc341ba0d29ec39fe1d9113cc5db69afebdc7" translate="yes" xml:space="preserve">
          <source>One might want to provide other &lt;a href=&quot;compile&quot;&gt;compile-time options&lt;/a&gt; such as &lt;a href=&quot;compile#enable_fts4&quot;&gt;-DSQLITE_ENABLE_FTS4&lt;/a&gt; or &lt;a href=&quot;compile#enable_fts5&quot;&gt;-DSQLITE_ENABLE_FTS5&lt;/a&gt; for full-text search, &lt;a href=&quot;compile#enable_rtree&quot;&gt;-DSQLITE_ENABLE_RTREE&lt;/a&gt; for the R*Tree search engine extension, &lt;a href=&quot;compile#enable_json1&quot;&gt;-DSQLITE_ENABLE_JSON1&lt;/a&gt; to include &lt;a href=&quot;json1&quot;&gt;JSON SQL functions&lt;/a&gt;, or &lt;a href=&quot;compile#enable_dbstat_vtab&quot;&gt;-DSQLITE_ENABLE_DBSTAT_VTAB&lt;/a&gt; for the &lt;a href=&quot;dbstat&quot;&gt;dbstat virtual table&lt;/a&gt;. In order to see extra commentary in &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt; listings, add the &lt;a href=&quot;compile#enable_explain_comments&quot;&gt;-DSQLITE_ENABLE_EXPLAIN_COMMENTS&lt;/a&gt; option. On unix systems, add -DHAVE_USLEEP=1 if the host machine supports the usleep() system call. Add -DHAVE_READLINE and the -lreadline and -lncurses libraries to get command-line editing support. One might also want to specify some compiler optimization switches. (The precompiled CLI available for download from the SQLite website uses &quot;-Os&quot;.) There are countless possible variations here. A command to compile a full-featured shell might look something like this:</source>
          <target state="translated">Можно было бы хотеть , чтобы обеспечить другие &lt;a href=&quot;compile&quot;&gt;параметры компиляции&lt;/a&gt; , такие как &lt;a href=&quot;compile#enable_fts4&quot;&gt;-DSQLITE_ENABLE_FTS4&lt;/a&gt; или &lt;a href=&quot;compile#enable_fts5&quot;&gt;-DSQLITE_ENABLE_FTS5&lt;/a&gt; для полнотекстового поиска, &lt;a href=&quot;compile#enable_rtree&quot;&gt;-DSQLITE_ENABLE_RTREE&lt;/a&gt; для расширения поисковой системы R * Tree, &lt;a href=&quot;compile#enable_json1&quot;&gt;-DSQLITE_ENABLE_JSON1&lt;/a&gt; включать &lt;a href=&quot;json1&quot;&gt;функции JSON SQL&lt;/a&gt; или &lt;a href=&quot;compile#enable_dbstat_vtab&quot;&gt;-DSQLITE_ENABLE_DBSTAT_VTAB&lt;/a&gt; для &lt;a href=&quot;dbstat&quot;&gt;dbstat виртуальной таблицы&lt;/a&gt; . Чтобы увидеть дополнительные комментарии в списках &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt; , добавьте &lt;a href=&quot;compile#enable_explain_comments&quot;&gt;-DSQLITE_ENABLE_EXPLAIN_COMMENTS&lt;/a&gt;вариант. В системах unix добавьте -DHAVE_USLEEP = 1, если хост-машина поддерживает системный вызов usleep (). Добавьте -DHAVE_READLINE и библиотеки -lreadline и -lncurses, чтобы получить поддержку редактирования командной строки. Можно также указать некоторые переключатели оптимизации компилятора. (В предварительно скомпилированном интерфейсе командной строки, доступном для загрузки с веб-сайта SQLite, используется &amp;laquo;-O&amp;raquo;.) Здесь существует бесчисленное множество возможных вариантов. Команда для компиляции полнофункциональной оболочки может выглядеть примерно так:</target>
        </trans-unit>
        <trans-unit id="6a02d032d7380123e8a5e72e863e1054c5bd48cb" translate="yes" xml:space="preserve">
          <source>One minor downside of splitting content into smaller pieces is that compression does not work as well on shorter texts and so the size of the document might increase. But as the bulk of the document space is used to store images, a small reduction in the compression efficiency of the text content will hardly be noticeable, and is a small price to pay for an improved user experience.</source>
          <target state="translated">Один незначительный недостаток разделения содержания на более мелкие части заключается в том,что сжатие не работает так же хорошо на более короткие тексты,и поэтому размер документа может увеличиться.Но так как большая часть документального пространства используется для хранения изображений,небольшое снижение эффективности сжатия текстового содержимого вряд ли будет заметно,и это небольшая цена,которую нужно заплатить за улучшенный пользовательский опыт.</target>
        </trans-unit>
        <trans-unit id="b297ff44d76535e06e20e05a05458aba9a18af0a" translate="yes" xml:space="preserve">
          <source>One of the 10 decimal digit ASCII characters, or</source>
          <target state="translated">Один из 10 десятичных ASCII-символов или</target>
        </trans-unit>
        <trans-unit id="67403b0cb5390fcf0c705699aeb495a2edb6d96b" translate="yes" xml:space="preserve">
          <source>One of the 52 upper and lower case ASCII characters, or</source>
          <target state="translated">Один из 52 символов ASCII в верхнем и нижнем регистре,или</target>
        </trans-unit>
        <trans-unit id="cff101187bdbe5720613db95b3564ea1057f17a1" translate="yes" xml:space="preserve">
          <source>One of the &lt;a href=&quot;different&quot;&gt;distinctive features&lt;/a&gt; of SQLite is that a database consists of a single disk file. This simplifies the use of SQLite since moving or backing up a database is a simple as copying a single file. It also makes SQLite appropriate for use as an &lt;a href=&quot;whentouse#appfileformat&quot;&gt;application file format&lt;/a&gt;. But while a complete database is held in a single disk file, SQLite does make use of many temporary files during the course of processing a database.</source>
          <target state="translated">Одна из &lt;a href=&quot;different&quot;&gt;отличительных особенностей&lt;/a&gt; SQLite заключается в том, что база данных состоит из одного файла на диске. Это упрощает использование SQLite, поскольку перемещение или резервное копирование базы данных выполняется так же, как копирование одного файла. Это также делает SQLite подходящим для использования в качестве &lt;a href=&quot;whentouse#appfileformat&quot;&gt;формата файла приложения&lt;/a&gt; . Но хотя полная база данных хранится в одном файле на диске, SQLite действительно использует множество временных файлов в процессе обработки базы данных.</target>
        </trans-unit>
        <trans-unit id="e5c91de459561e96de8f3e9e77eaa61509cd18a7" translate="yes" xml:space="preserve">
          <source>One of the ALL or DISTINCT keywords may follow the SELECT keyword in a simple SELECT statement. If the simple SELECT is a SELECT ALL, then the entire set of result rows are returned by the SELECT. If neither ALL or DISTINCT are present, then the behavior is as if ALL were specified. If the simple SELECT is a SELECT DISTINCT, then duplicate rows are removed from the set of result rows before it is returned. For the purposes of detecting duplicate rows, two NULL values are considered to be equal. The &lt;a href=&quot;datatype3#colrules&quot;&gt;usual rules&lt;/a&gt; apply for selecting a collation sequence to compare text values.</source>
          <target state="translated">Одно из ключевых слов ALL или DISTINCT может следовать за ключевым словом SELECT в простой инструкции SELECT. Если простой SELECT - это SELECT ALL, тогда весь набор строк результатов возвращается SELECT. Если ни ALL, ни DISTINCT не присутствуют, поведение будет таким, как если бы было указано ALL. Если простой SELECT - это SELECT DISTINCT, то повторяющиеся строки удаляются из набора строк результата перед его возвратом. В целях обнаружения повторяющихся строк два значения NULL считаются равными. Для выбора последовательности сопоставления для сравнения текстовых значений применяются &lt;a href=&quot;datatype3#colrules&quot;&gt;обычные правила&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="148ba6e1c7e039de60e4599c768cf9921948e4c8" translate="yes" xml:space="preserve">
          <source>One of the advantages of hosting code generator tools as part of the project is that the tools can be optimized to serve specific needs of the overall project. Lemon has benefited from this effect. Over the years, the Lemon parser generator has been extended and enhanced to provide new capabilities and improved performance to SQLite. A few of the specific enhancements to Lemon that are specifically designed for use by SQLite include:</source>
          <target state="translated">Одним из преимуществ хостинга инструментов генератора кода как части проекта является то,что эти инструменты могут быть оптимизированы для удовлетворения специфических потребностей всего проекта в целом.Лемон извлекла выгоду из этого эффекта.С годами генератор парсера Lemon был расширен и усовершенствован для обеспечения новых возможностей и повышения производительности SQLite.Некоторые из специфических усовершенствований Lemon,которые специально разработаны для использования в SQLite,включают в себя:</target>
        </trans-unit>
        <trans-unit id="66a50c77336f3c9a6df53cb2e7363aee5a52fbbd" translate="yes" xml:space="preserve">
          <source>One of the interesting features of the VFS interface is that SQLite can support multiple VFSes at the same time. Each &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; has to choose a single VFS for its use when the connection is first opened using &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;. But if a process contains multiple &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt; each can choose a different VFS. VFSes can be added at run-time using the &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register()&lt;/a&gt; interface.</source>
          <target state="translated">Одна из интересных особенностей интерфейса VFS заключается в том, что SQLite может одновременно поддерживать несколько VFS. Каждое &lt;a href=&quot;c3ref/sqlite3&quot;&gt;соединение с базой данных&lt;/a&gt; должно выбрать одну VFS для использования при первом открытии соединения с помощью &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2 ()&lt;/a&gt; . Но если процесс содержит несколько &lt;a href=&quot;c3ref/sqlite3&quot;&gt;соединений с базой данных,&lt;/a&gt; каждый может выбрать другую VFS. VFS можно добавить во время выполнения с помощью интерфейса &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f1c2a440e7d12be65f7ff95454bfa77307c4b02e" translate="yes" xml:space="preserve">
          <source>One of the many reports that Fossil makes available is a timeline of changes to a single branch showing all merges in and out of that branch. See &lt;a href=&quot;http://www.sqlite.org/src/timeline?nd&amp;amp;n=200&amp;amp;r=trunk&quot;&gt;http://www.sqlite.org/src/timeline?nd&amp;amp;n=200&amp;amp;r=trunk&lt;/a&gt; for a typical example of such a report. Generating such a report normally takes just a few milliseconds. But after upgrading to the NGQP we noticed that this one report was taking closer to 10 seconds for the trunk of the repository.</source>
          <target state="translated">Один из многих отчетов, которые предоставляет Fossil, - это временная шкала изменений в одной ветке, показывающая все слияния внутри и вне этой ветви. См. &lt;a href=&quot;http://www.sqlite.org/src/timeline?nd&amp;amp;n=200&amp;amp;r=trunk&quot;&gt;Http://www.sqlite.org/src/timeline?nd&amp;amp;n=200&amp;amp;r=trunk&lt;/a&gt; для получения типичного примера такого отчета. Создание такого отчета обычно занимает всего несколько миллисекунд. Но после обновления до NGQP мы заметили, что этот отчет занимал около 10 секунд для магистрали репозитория.</target>
        </trans-unit>
        <trans-unit id="2bf1094093ae892a1e0164d69250728d7ebf09d8" translate="yes" xml:space="preserve">
          <source>One of the many reports that Fossil makes available is a timeline of changes to a single branch showing all merges in and out of that branch. See &lt;a href=&quot;https://www.sqlite.org/src/timeline?nd&amp;amp;n=200&amp;amp;r=trunk&quot;&gt;http://www.sqlite.org/src/timeline?nd&amp;amp;n=200&amp;amp;r=trunk&lt;/a&gt; for a typical example of such a report. Generating such a report normally takes just a few milliseconds. But after upgrading to the NGQP we noticed that this one report was taking closer to 10 seconds for the trunk of the repository.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16f929fd09cef7d1acb11b165614f8e6f651a35f" translate="yes" xml:space="preserve">
          <source>One of the things that SQLite does to ensure that transactions are atomic across system crashes and power failures is to write all changes into the rollback journal file prior to changing the database. The TCL test harness contains an alternative &lt;a href=&quot;vfs&quot;&gt;OS backend&lt;/a&gt; implementation that helps to verify this is occurring correctly. The &quot;journal-test VFS&quot; monitors all disk I/O traffic between the database file and rollback journal, checking to make sure that nothing is written into the database file which has not first been written and synced to the rollback journal. If any discrepancies are found, an assertion fault is raised.</source>
          <target state="translated">Одна из вещей, которые SQLite делает для обеспечения атомарности транзакций при сбоях системы и сбоях питания, - это записывать все изменения в файл журнала отката до изменения базы данных. Пакет тестирования TCL содержит альтернативную &lt;a href=&quot;vfs&quot;&gt;внутреннюю&lt;/a&gt; реализацию ОС, которая помогает проверить, что это происходит правильно. VFS &quot;journal-test&quot; отслеживает весь дисковый трафик ввода-вывода между файлом базы данных и журналом отката, проверяя, что в файл базы данных не записано ничего, что не было предварительно записано и синхронизировано с журналом отката. Если обнаруживаются какие-либо несоответствия, возникает ошибка утверждения.</target>
        </trans-unit>
        <trans-unit id="8702bf42f5b52e2937e5261eb8fe5e53cb025817" translate="yes" xml:space="preserve">
          <source>One or more indexes of the table are currently unanalyzed &lt;em&gt;or&lt;/em&gt; the number of rows in the table has increased by 25 times or more since the last time ANALYZE was run.</source>
          <target state="translated">Один или несколько индексов таблицы в настоящее время не проанализированы, &lt;em&gt;или&lt;/em&gt; количество строк в таблице увеличилось в 25 или более раз с момента последнего запуска ANALYZE.</target>
        </trans-unit>
        <trans-unit id="feb2e1f55ecdbf77cec780482429b500004b78e4" translate="yes" xml:space="preserve">
          <source>One or more of the SELECT statements in the compound must be non-recursive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea6d64ad5a0fa81894775a5275ad8d5ac847fedc" translate="yes" xml:space="preserve">
          <source>One or more of the individual SELECT statements that make up the compound must be &quot;recursive&quot;. A SELECT statement is a recursive if its FROM clause contains exactly one reference to the the CTE table (the table named on the left-hand side of the AS clause).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c07477cd0e5dcf04189629377d839b6d5b58ba89" translate="yes" xml:space="preserve">
          <source>One or more transactions must have been written to the current wal file since it was created on disk (by any connection). This means that a snapshot cannot be taken on a wal mode database with no wal file immediately after it is first opened. At least one transaction must be written to it first.</source>
          <target state="translated">Одна или более транзакций должны были быть записаны в текущий wal-файл с момента его создания на диске (по любому соединению).Это означает,что снимки не могут быть сделаны в базе данных в режиме wal,где нет ни одного wal-файла сразу после его первого открытия.Сначала в нее должна быть записана хотя бы одна транзакция.</target>
        </trans-unit>
        <trans-unit id="b839504f0d97f30339eb42940d7178a50aed3e9b" translate="yes" xml:space="preserve">
          <source>One solution is to add an SQL foreign key constraint to the database schema to enforce the relationship between the</source>
          <target state="translated">Одним из решений является добавление ограничения по внешнему ключу SQL в схему базы данных,чтобы усилить связь между</target>
        </trans-unit>
        <trans-unit id="9e9e9e6d05419e1f1b802f612d5f17adfe32fb1a" translate="yes" xml:space="preserve">
          <source>One solution to this problem is to change SQLite to do an exhaustive search for the best path. But an exhaustive search requires time proportional to K! (where K is the number of tables in the join) and so when you get beyond a 10-way join, the time to run &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; becomes very large.</source>
          <target state="translated">Одним из решений этой проблемы является изменение SQLite для выполнения исчерпывающего поиска наилучшего пути. Но для полного перебора требуется время, пропорциональное K! (где K - количество таблиц в объединении), поэтому, когда вы выйдете за пределы 10-стороннего соединения, время выполнения &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare ()&lt;/a&gt; станет очень большим.</target>
        </trans-unit>
        <trans-unit id="3ea27e906845c470414940dc542a3a724c62dba9" translate="yes" xml:space="preserve">
          <source>One technique for avoiding a full table scan is to do lookups by rowid (or by the equivalent &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;). To lookup the price of peaches, one would query for the entry with a rowid of 4:</source>
          <target state="translated">Один из способов избежать полного сканирования таблицы - выполнить поиск по идентификатору строки (или эквивалентному &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; ). Чтобы узнать цену персиков, нужно запросить запись с идентификатором строки 4:</target>
        </trans-unit>
        <trans-unit id="9d59b48161b2263d40d4491d1bb939a7b7f92e6e" translate="yes" xml:space="preserve">
          <source>One user of both Git and Fossil &lt;a href=&quot;https://news.ycombinator.com/item?id=16806955&quot;&gt;writes in HN&lt;/a&gt;:</source>
          <target state="translated">Один пользователь как Git, так и Fossil &lt;a href=&quot;https://news.ycombinator.com/item?id=16806955&quot;&gt;пишет на HN&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="75f64ba853c8246c4f074dd74725d9448e0221f8" translate="yes" xml:space="preserve">
          <source>One verification technique used on SQLite is to run an entire test suite twice, once with optimizations left on and a second time with optimizations turned off, and verify that the same output is obtained both times. This shows that the optimizations do not introduce errors.</source>
          <target state="translated">Один метод верификации,используемый на SQLite,состоит в том,чтобы дважды запустить весь тестовый набор,один раз с включенными оптимизациями и второй раз с выключенными оптимизациями,и проверить,что один и тот же результат получен в оба раза.Это показывает,что оптимизации не вносят ошибок.</target>
        </trans-unit>
        <trans-unit id="1193850e31c2f1f6fdd8ba5f6d6a21ba1025f991" translate="yes" xml:space="preserve">
          <source>One very simple scheme might be to count the number of instances of the users search terms in each result document. Those documents that contain many instances of the terms are considered more relevant than those with a small number of instances of each term. In an FTS application, the number of term instances in each result could be determined by counting the number of integers in the return value of the &lt;a href=&quot;fts3#offsets&quot;&gt;offsets&lt;/a&gt; function. The following example shows a query that could be used to obtain the ten most relevant results for a query entered by the user:</source>
          <target state="translated">Одна очень простая схема может заключаться в подсчете количества экземпляров пользовательских условий поиска в каждом документе результатов. Те документы, которые содержат много экземпляров терминов, считаются более релевантными, чем документы с небольшим количеством экземпляров каждого термина. В приложении FTS количество экземпляров термина в каждом результате может быть определено путем подсчета количества целых чисел в возвращаемом значении функции &lt;a href=&quot;fts3#offsets&quot;&gt;смещения&lt;/a&gt; . В следующем примере показан запрос, который можно использовать для получения десяти наиболее релевантных результатов по запросу, введенному пользователем:</target>
        </trans-unit>
        <trans-unit id="ef8241368a545dcfd4804f314c3279bd316a6040" translate="yes" xml:space="preserve">
          <source>One way around this problem is to check the extended error code returned by an sqlite3_step() call. If there is a blocking connection, then the extended error code is set to SQLITE_LOCKED_SHAREDCACHE. Otherwise, in the special &quot;DROP TABLE/INDEX&quot; case, the extended error code is just SQLITE_LOCKED.</source>
          <target state="translated">Одним из способов решения этой проблемы является проверка расширенного кода ошибки,возвращаемого вызовом sqlite3_step().Если соединение блокируется,то расширенный код ошибки устанавливается в SQLITE_LOCKED_SHAREDCACHE.В противном случае,в специальном случае &quot;DROP TABLE/INDEX&quot;,расширенный код ошибки будет просто SQLITE_LOCKED.</target>
        </trans-unit>
        <trans-unit id="acee115381c0c09c4f7ee9640610c7e8117858b5" translate="yes" xml:space="preserve">
          <source>One way to compute FindFrame(P,M) would be to scan the aPgno array starting with the M-th entry and working backwards towards the beginning and return J where aPgno[J]==P. Such an algorithm would work, and it would be faster than searching the whole WAL file for the latest frame with page number P. But the search can be made much faster still by using the aHash structure.</source>
          <target state="translated">Одним из способов вычисления FindFrame(P,M)было бы сканирование массива aPgno,начинающегося с M-го элемента и работающего в обратном направлении к началу,и возврат J,где aPgno[J]==P.Такой алгоритм сработал бы,и это было бы быстрее,чем искать во всем файле WAL последний кадр с номером страницы P.Но поиск все равно можно сделать намного быстрее,используя структуру aHash.</target>
        </trans-unit>
        <trans-unit id="43ce70174605b98e2611ee3fa62c55d5c3b3d847" translate="yes" xml:space="preserve">
          <source>One way to create an imposter table is to directly edit the sqlite_master table to insert a new row that describes the table. For example, suppose the schema is like this:</source>
          <target state="translated">Один из способов создать таблицу imposter-напрямую отредактировать таблицу sqlite_master,чтобы вставить новую строку,описывающую таблицу.Например,предположим,что схема такая:</target>
        </trans-unit>
        <trans-unit id="84cd9c4bdeae83b60aa9ede1d4ab69d156255724" translate="yes" xml:space="preserve">
          <source>One way to create an imposter table is to directly edit the sqlite_schema table to insert a new row that describes the table. For example, suppose the schema is like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5371a62fb713016b88bf9cbe1ee3e53f088627a9" translate="yes" xml:space="preserve">
          <source>One way to use sqlite3 in a shell script is to use &quot;echo&quot; or &quot;cat&quot; to generate a sequence of commands in a file, then invoke sqlite3 while redirecting input from the generated command file. This works fine and is appropriate in many circumstances. But as an added convenience, sqlite3 allows a single SQL command to be entered on the command line as a second argument after the database name. When the sqlite3 program is launched with two arguments, the second argument is passed to the SQLite library for processing, the query results are printed on standard output in list mode, and the program exits. This mechanism is designed to make sqlite3 easy to use in conjunction with programs like &quot;awk&quot;. For example:</source>
          <target state="translated">Один из способов использования sqlite3 в скрипте оболочки-использовать &quot;echo&quot; или &quot;cat&quot; для генерации последовательности команд в файле,а затем вызывать sqlite3 при перенаправлении входных данных из сгенерированного командного файла.Это прекрасно работает и подходит во многих случаях.Но в качестве дополнительного удобства sqlite3 позволяет ввести в командную строку одну SQL-команду в качестве второго аргумента после имени БД.При запуске программы sqlite3 с двумя аргументами второй аргумент передается на обработку в библиотеку SQLite,результаты запроса выводятся на стандартный вывод в режиме списка,и программа завершает работу.Данный механизм предназначен для того,чтобы сделать sqlite3 простым в использовании совместно с программами типа &quot;awk&quot;.Например:</target>
        </trans-unit>
        <trans-unit id="c9f164cc934fc44dc3087a408a43d581d45a004f" translate="yes" xml:space="preserve">
          <source>One would get the same answer without the use of the R*Tree index using the following simpler query:</source>
          <target state="translated">Ответ можно было бы получить и без использования индекса R*Tree с помощью следующего более простого запроса:</target>
        </trans-unit>
        <trans-unit id="17f5a4fe2f5c62ecd81776d246b8c0c725190c25" translate="yes" xml:space="preserve">
          <source>One-Step Query Execution Interface</source>
          <target state="translated">Интерфейс выполнения одношаговых запросов</target>
        </trans-unit>
        <trans-unit id="aa3d3adac784c0d74a31276058a965e9e8ca9895" translate="yes" xml:space="preserve">
          <source>Online Backup API</source>
          <target state="translated">API онлайн-безопасность</target>
        </trans-unit>
        <trans-unit id="84ecd14ddbadabe468f63832d803f2392f405f33" translate="yes" xml:space="preserve">
          <source>Online Backup API.</source>
          <target state="translated">API Онлайн Резервного Копирования.</target>
        </trans-unit>
        <trans-unit id="df4435ab96f572a5ddc0d0575dab3a2326c426c1" translate="yes" xml:space="preserve">
          <source>Online Backup Object</source>
          <target state="translated">объект онлайн-безопасного копирования</target>
        </trans-unit>
        <trans-unit id="cf333df0d0137378797eeac3fd91be937936f09b" translate="yes" xml:space="preserve">
          <source>Only CPU cycle counts are being measured here. CPU cycle counts are a good proxy for energy consumption, but do not necessary correlate well with real-world timings. Time spent doing I/O is not reflected in the CPU cycle counts, and I/O time predominates in many SQLite usage scenarios.</source>
          <target state="translated">Здесь измеряется только количество циклов процессора.Подсчеты циклов ЦП являются хорошим показателем энергопотребления,но не обязательно хорошо коррелируют с реальными таймингами.Время,затрачиваемое на ввод/вывод,не отражается на счетах цикла ЦП,а время ввода/вывода превалирует во многих сценариях использования SQLite.</target>
        </trans-unit>
        <trans-unit id="d5604491374c9f17a80675ca75c6861a336b77e6" translate="yes" xml:space="preserve">
          <source>Only a single authorizer can be in place on a database connection at a time. Each call to sqlite3_set_authorizer overrides the previous call. Disable the authorizer by installing a NULL callback. The authorizer is disabled by default.</source>
          <target state="translated">Одновременно при подключении к базе данных может быть установлен только один авторизатор.Каждый вызов sqlite3_set_authorizer перекрывает предыдущий вызов.Отключите авторизатор,установив NULL обратный вызов.Авторизатор отключен по умолчанию.</target>
        </trans-unit>
        <trans-unit id="478d5d49691bd8c6240a1fe276d18045c9e67957" translate="yes" xml:space="preserve">
          <source>Only a single progress handler may be defined at one time per &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt;; setting a new progress handler cancels the old one. Setting parameter X to NULL disables the progress handler. The progress handler is also disabled by setting N to a value less than 1.</source>
          <target state="translated">Только один обработчик хода выполнения может быть определен одновременно для каждого &lt;a href=&quot;#sqlite3&quot;&gt;соединения с базой данных&lt;/a&gt; ; установка нового обработчика прогресса отменяет старый. Установка для параметра X значения NULL отключает обработчик хода выполнения. Обработчик хода выполнения также отключается путем установки для N значения меньше 1.</target>
        </trans-unit>
        <trans-unit id="94e56a9c57047e711c69e819b360a3dd7e101263" translate="yes" xml:space="preserve">
          <source>Only a single progress handler may be defined at one time per &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt;; setting a new progress handler cancels the old one. Setting parameter X to NULL disables the progress handler. The progress handler is also disabled by setting N to a value less than 1.</source>
          <target state="translated">Только один обработчик хода выполнения может быть определен одновременно для каждого &lt;a href=&quot;sqlite3&quot;&gt;соединения с базой данных&lt;/a&gt; ; установка нового обработчика прогресса отменяет старый. Установка для параметра X значения NULL отключает обработчик хода выполнения. Обработчик хода выполнения также отключается путем установки для N значения меньше 1.</target>
        </trans-unit>
        <trans-unit id="7036e4ebe3282d4cd750dee2b265f33019cf27cb" translate="yes" xml:space="preserve">
          <source>Only changes made directly by the INSERT, UPDATE or DELETE statement are considered - auxiliary changes caused by &lt;a href=&quot;../lang_createtrigger&quot;&gt;triggers&lt;/a&gt;, &lt;a href=&quot;../foreignkeys#fk_actions&quot;&gt;foreign key actions&lt;/a&gt; or &lt;a href=&quot;../lang_replace&quot;&gt;REPLACE&lt;/a&gt; constraint resolution are not counted.</source>
          <target state="translated">Учитываются только изменения, сделанные непосредственно оператором INSERT, UPDATE или DELETE - вспомогательные изменения, вызванные &lt;a href=&quot;../lang_createtrigger&quot;&gt;триггерами&lt;/a&gt; , &lt;a href=&quot;../foreignkeys#fk_actions&quot;&gt;действиями внешнего ключа&lt;/a&gt; или разрешением ограничения &lt;a href=&quot;../lang_replace&quot;&gt;REPLACE&lt;/a&gt; , не учитываются.</target>
        </trans-unit>
        <trans-unit id="c27ab9dbf00600e9d93b4dae249b72bd85740109" translate="yes" xml:space="preserve">
          <source>Only changes made directly by the INSERT, UPDATE or DELETE statement are considered - auxiliary changes caused by &lt;a href=&quot;lang_createtrigger&quot;&gt;triggers&lt;/a&gt;, &lt;a href=&quot;foreignkeys#fk_actions&quot;&gt;foreign key actions&lt;/a&gt; or &lt;a href=&quot;lang_replace&quot;&gt;REPLACE&lt;/a&gt; constraint resolution are not counted.</source>
          <target state="translated">Учитываются только изменения, сделанные непосредственно оператором INSERT, UPDATE или DELETE - вспомогательные изменения, вызванные &lt;a href=&quot;lang_createtrigger&quot;&gt;триггерами&lt;/a&gt; , &lt;a href=&quot;foreignkeys#fk_actions&quot;&gt;действиями внешнего ключа&lt;/a&gt; или разрешением ограничения &lt;a href=&quot;lang_replace&quot;&gt;REPLACE&lt;/a&gt; , не учитываются.</target>
        </trans-unit>
        <trans-unit id="9ca2d95ecc0496343a0233bd681510ca318c6946" translate="yes" xml:space="preserve">
          <source>Only columns a and b of the index would be usable. The d column would not be usable because column c is not constrained and there can be no gaps in the set of columns that usable by the index.</source>
          <target state="translated">Полезными будут только столбцы a и b индекса.Столбец d не будет использоваться,поскольку столбец c не ограничен,и в наборе столбцов,используемых индексом,не может быть пробелов.</target>
        </trans-unit>
        <trans-unit id="05736f4fee6c4c67dfd5428743f05e710b55053c" translate="yes" xml:space="preserve">
          <source>Only columns a, b, and c of the index would be usable. The d column would not be usable because it occurs to the right of c and c is constrained only by inequalities.</source>
          <target state="translated">Полезными будут только столбцы a,b и c индекса.Столбец d не может быть использован,поскольку он находится справа от столбцов c и c и ограничивается только неравенством.</target>
        </trans-unit>
        <trans-unit id="6822d83fba844c52182b6e2b1305124432ab29b8" translate="yes" xml:space="preserve">
          <source>Only create &lt;a href=&quot;tempfiles#masterjrnl&quot;&gt;master journal&lt;/a&gt; files if two or more attached databases are all modified, do not have &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous&lt;/a&gt; set to OFF, and do not have the &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;journal_mode&lt;/a&gt; set to OFF, MEMORY, or WAL.</source>
          <target state="translated">Только создать &lt;a href=&quot;tempfiles#masterjrnl&quot;&gt;мастер - журнальные&lt;/a&gt; файлы , если два или более подключенные баз данных все изменяется, не &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;Pragma синхронных&lt;/a&gt; отключаются, и не имеют &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;journal_mode&lt;/a&gt; отключаются, ПАМЯТЬ, или WAL.</target>
        </trans-unit>
        <trans-unit id="9d1635246b5aeaad6de58e92e5095276c845c10a" translate="yes" xml:space="preserve">
          <source>Only create &lt;a href=&quot;tempfiles#stmtjrnl&quot;&gt;statement journal&lt;/a&gt; files when their size exceeds a threshold. Otherwise the journal is held in memory and no I/O occurs. The threshold can be configured at compile-time using &lt;a href=&quot;compile#stmtjrnl_spill&quot;&gt;SQLITE_STMTJRNL_SPILL&lt;/a&gt; or at start-time using &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigstmtjrnlspill&quot;&gt;SQLITE_CONFIG_STMTJRNL_SPILL&lt;/a&gt;).</source>
          <target state="translated">&lt;a href=&quot;tempfiles#stmtjrnl&quot;&gt;Создавайте&lt;/a&gt; файлы журнала выписок только тогда, когда их размер превышает пороговое значение. В противном случае журнал сохраняется в памяти, и операций ввода-вывода не происходит. Порог можно настроить во время компиляции с помощью &lt;a href=&quot;compile#stmtjrnl_spill&quot;&gt;SQLITE_STMTJRNL_SPILL&lt;/a&gt; или во время запуска с помощью &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt; ( &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigstmtjrnlspill&quot;&gt;SQLITE_CONFIG_STMTJRNL_SPILL&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="55a00a3777e2ad8aeddbe2020e521d24210ef62b" translate="yes" xml:space="preserve">
          <source>Only create &lt;a href=&quot;tempfiles#superjrnl&quot;&gt;master journal&lt;/a&gt; files if two or more attached databases are all modified, do not have &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous&lt;/a&gt; set to OFF, and do not have the &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;journal_mode&lt;/a&gt; set to OFF, MEMORY, or WAL.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04951ae9e91c50e633618b0424f4870112bf6e2c" translate="yes" xml:space="preserve">
          <source>Only create master journal files if two or more attached databases are all modified, do not have &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous&lt;/a&gt; set to OFF, and do not have the &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;journal_mode&lt;/a&gt; set to OFF, MEMORY, or WAL.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="610003d6616c61d3e569880b1cf6337a8bfaac43" translate="yes" xml:space="preserve">
          <source>Only rows of the table for which the WHERE clause evaluates to true are included in the index. If the WHERE clause expression evaluates to NULL or to false for some rows of the table, then those rows are omitted from the index.</source>
          <target state="translated">В индекс включаются только строки таблицы,для которой пункт WHERE оценивает как истинный.Если выражение из выражения WHERE для некоторых строк таблицы оценивается как NULL или false,то эти строки опускаются из индекса.</target>
        </trans-unit>
        <trans-unit id="255e530c466468dcdf3e2dbc7217cf60c632c517" translate="yes" xml:space="preserve">
          <source>Only terms of the vocabulary with a matching langid are searched. Hence, the same table can contain entries from multiple languages and only the requested language will be used. The default langid is 0.</source>
          <target state="translated">Поиск ведется только по словарю с совпадающим по значению словарным запасом.Таким образом,одна и та же таблица может содержать записи из нескольких языков,и будет использоваться только запрашиваемый язык.Лангид по умолчанию равен 0.</target>
        </trans-unit>
        <trans-unit id="2ece13f71abf0bca8da38ece8f95957b023f2f28" translate="yes" xml:space="preserve">
          <source>Only the &quot;ll&quot; length modifier ever makes a difference for SQLite. And it only makes a difference when using the C-language interfaces.</source>
          <target state="translated">Только модификатор длины &quot;ll&quot; когда-либо имеет значение для SQLite.И это имеет значение только при использовании интерфейсов на языке C.</target>
        </trans-unit>
        <trans-unit id="85148a6237828ed28c44695045ab73ff06e6fcad" translate="yes" xml:space="preserve">
          <source>Only the RENAME TABLE, ADD COLUMN, and RENAME COLUMN variants of the ALTER TABLE command are supported. Other kinds of ALTER TABLE operations such as DROP COLUMN, ALTER COLUMN, ADD CONSTRAINT, and so forth are omitted.</source>
          <target state="translated">Поддерживаются только варианты ALTER TABLE,ADD COLUMN и RENAME COLUMN.Другие виды операций ALTER TABLE,такие как DROP COLUMN,ALTER COLUMN,ADD CONSTRAINT и т.д.,опускаются.</target>
        </trans-unit>
        <trans-unit id="718ea1282b5847e8c3e9e8f8d5345c6ee50c38cc" translate="yes" xml:space="preserve">
          <source>Only the implicit version of the AND operator is supported. Specifying the string &quot;AND&quot; as part of a standard query syntax query is interpreted as a term query for the set of documents containing the term &quot;and&quot;.</source>
          <target state="translated">Поддерживается только неявная версия оператора AND.Указание строки &quot;AND&quot; как части стандартного синтаксического запроса интерпретируется как запрос на набор документов,содержащих термин &quot;и&quot;.</target>
        </trans-unit>
        <trans-unit id="1eda18e73564838ddd329dd3f15abb7d2f114fbe" translate="yes" xml:space="preserve">
          <source>Only the three core routines described in section 1.0 are required to use SQLite. But there are many other functions that provide useful interfaces. These extended routines are as follows:</source>
          <target state="translated">Для использования SQLite требуются только три основные подпрограммы,описанные в разделе 1.0.Однако существует множество других функций,которые предоставляют полезные интерфейсы.Эти расширенные процедуры следующие:</target>
        </trans-unit>
        <trans-unit id="97073c710caef6e8b97ed50f7242027a83850af5" translate="yes" xml:space="preserve">
          <source>Only unsigned integers are recognized. Plus and minus signs are ignored. Decimal points and exponential notation are ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ddd9d23f19b01af8d3915a7bfd11c89aef2d1d4" translate="yes" xml:space="preserve">
          <source>Only use indexes-on-expressions to optimize ORDER BY or GROUP BY if the COLLATE is correct. Ticket &lt;a href=&quot;https://sqlite.org/src/info/e20dd54ab0e4383&quot;&gt;e20dd54ab0e4383&lt;/a&gt;</source>
          <target state="translated">Используйте индексы-по-выражениям только для оптимизации ORDER BY или GROUP BY, если COLLATE правильный. Билет &lt;a href=&quot;https://sqlite.org/src/info/e20dd54ab0e4383&quot;&gt;e20dd54ab0e4383&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c74dd7ced7cd4ea8002b3c96a9b1ecdff66b1e59" translate="yes" xml:space="preserve">
          <source>Opcode Name</source>
          <target state="translated">Имя опкода</target>
        </trans-unit>
        <trans-unit id="1682c59856887894432baf4bb39e98c21d42d731" translate="yes" xml:space="preserve">
          <source>Opcode definitions</source>
          <target state="translated">Определения опкодов</target>
        </trans-unit>
        <trans-unit id="313411b9bd1b97b8fcd666d91d350cb8e6bed0d1" translate="yes" xml:space="preserve">
          <source>Open A BLOB For Incremental I/O</source>
          <target state="translated">Открыть BLOB для инкрементального ввода/вывода</target>
        </trans-unit>
        <trans-unit id="beb2e15e058a69d62502daa1bdfb1095abeb86de" translate="yes" xml:space="preserve">
          <source>Open a cursor into the table to be queried.</source>
          <target state="translated">Откройте курсор в таблицу,которую нужно опросить.</target>
        </trans-unit>
        <trans-unit id="7e8e851c144078264ee423ec854e116a3d7fdff4" translate="yes" xml:space="preserve">
          <source>Open a new cursor P1 that points to the same ephemeral table as cursor P2. The P2 cursor must have been opened by a prior &lt;a href=&quot;opcode#OpenEphemeral&quot;&gt;OpenEphemeral&lt;/a&gt; opcode. Only ephemeral cursors may be duplicated.</source>
          <target state="translated">Откройте новый курсор P1, который указывает на ту же временную таблицу, что и курсор P2. Курсор P2 должен быть открыт предыдущим &lt;a href=&quot;opcode#OpenEphemeral&quot;&gt;кодом&lt;/a&gt; операции OpenEphemeral . Можно дублировать только эфемерные курсоры.</target>
        </trans-unit>
        <trans-unit id="57454cf77dc40f8ad1e1086dd9c199e6c88ed771" translate="yes" xml:space="preserve">
          <source>Open a new cursor P1 to a transient table. The cursor is always opened read/write even if the main database is read-only. The ephemeral table is deleted automatically when the cursor is closed.</source>
          <target state="translated">Откройте новый курсор P1 на переходную таблицу.Курсор всегда открыт на чтение/запись,даже если основная БД доступна только для чтения.Эфемерная таблица удаляется автоматически при закрытии курсора.</target>
        </trans-unit>
        <trans-unit id="545bc19bf66be6511144aed187f1840c5a4278d1" translate="yes" xml:space="preserve">
          <source>Open a new cursor that points to a fake table that contains a single row of data. The content of that one row is the content of memory register P2. In other words, cursor P1 becomes an alias for the MEM_Blob content contained in register P2.</source>
          <target state="translated">Открыть новый курсор,указывающий на поддельную таблицу,содержащую одну строку данных.Содержимое этой строки-содержимое регистра памяти P2.Другими словами,курсор P1 становится псевдонимом для содержимого MEM_Blob,содержащегося в регистре P2.</target>
        </trans-unit>
        <trans-unit id="135ddb8c48350a0a78c4aa223b6b8ae16522c7fd" translate="yes" xml:space="preserve">
          <source>Open a read-only cursor for the database table whose root page is P2 in a database file. The database file is determined by P3. P3==0 means the main database, P3==1 means the database used for temporary tables, and P3&amp;gt;1 means used the corresponding attached database. Give the new cursor an identifier of P1. The P1 values need not be contiguous but all P1 values should be small integers. It is an error for P1 to be negative.</source>
          <target state="translated">Откройте доступный только для чтения курсор для таблицы базы данных, корневой страницей которой является P2 в файле базы данных. Файл базы данных определяется P3. P3 == 0 означает основную базу данных, P3 == 1 означает базу данных, используемую для временных таблиц, а P3&amp;gt; 1 означает, что использовалась соответствующая присоединенная база данных. Дайте новому курсору идентификатор P1. Значения P1 не обязательно должны быть смежными, но все значения P1 должны быть небольшими целыми числами. Отрицательное значение P1 является ошибкой.</target>
        </trans-unit>
        <trans-unit id="84089bd01646e44fd57253086466eec04ccae47a" translate="yes" xml:space="preserve">
          <source>Open a read/write cursor named P1 on the table or index whose root page is P2 (or whose root page is held in register P2 if the OPFLAG_P2ISREG bit is set in P5 - see below).</source>
          <target state="translated">Откройте курсор чтения/записи с именем P1 на таблице или индексе,корневая страница которого равна P2 (или корневая страница которого находится в регистре P2,если бит OPFLAG_P2ISREG установлен в P5-см.ниже).</target>
        </trans-unit>
        <trans-unit id="4063448157b3ab2686e1495793b9571ba748ea89" translate="yes" xml:space="preserve">
          <source>Open an RBU handle using the sqlite3rbu_open(T,A,S) function.</source>
          <target state="translated">Открыть хэндл RBU,используя функцию sqlite3rbu_open(T,A,S).</target>
        </trans-unit>
        <trans-unit id="596a83fa51ee88b7bacaba491d0bd9269153f384" translate="yes" xml:space="preserve">
          <source>Open database connections using the &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt; or &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; interfaces, as normal. Ordinary database files (without a checksum) will operate normally. Databases with checksums will return an SQLITE_IOERR_DATA error if a page is encountered that contains an invalid checksum.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6423cf77a906b294f7ccb82649c19b9b21d337a4" translate="yes" xml:space="preserve">
          <source>Open file &quot;/home/fred/data.db&quot;. Use the special VFS &quot;unix-dotfile&quot; that uses dot-files in place of posix advisory locking.</source>
          <target state="translated">Открыть файл &quot;/home/fred/data.db&quot;.Используйте специальный VFS &quot;unix-файл точки&quot;,который использует dot-файлы вместо блокировки posix-советов.</target>
        </trans-unit>
        <trans-unit id="d23dfc68fcbe2b64c96946a59f2391f88d879ada" translate="yes" xml:space="preserve">
          <source>Open file &quot;data.db&quot; in the current directory for read-only access. Regardless of whether or not shared-cache mode is enabled by default, use a private cache.</source>
          <target state="translated">Открыть файл &quot;data.db&quot; в текущем каталоге для доступа только на чтение.Независимо от того,включен ли режим общего кэша по умолчанию,используйте частный кэш.</target>
        </trans-unit>
        <trans-unit id="32023375b26a0776fe1660f78af585c47d78b01e" translate="yes" xml:space="preserve">
          <source>Open the database file &quot;/home/fred/data.db&quot;.</source>
          <target state="translated">Открыть файл базы данных &quot;/home/fred/data.db&quot;.</target>
        </trans-unit>
        <trans-unit id="b140126e4bb0c579baba79fa4b78910264cad628" translate="yes" xml:space="preserve">
          <source>Open the database file and obtain a SHARED lock. If the SHARED lock cannot be obtained, fail immediately and return SQLITE_BUSY.</source>
          <target state="translated">Откройте файл базы данных и получите блокировку SHARED.Если блокировка SHARED не может быть получена,немедленно выйдите из строя и верните SQLITE_BUSY.</target>
        </trans-unit>
        <trans-unit id="1fdbee3b0460b37f393d93c476774730b651cdaf" translate="yes" xml:space="preserve">
          <source>Open the file &quot;data.db&quot; in the current directory.</source>
          <target state="translated">Откройте файл &quot;data.db&quot; в текущем каталоге.</target>
        </trans-unit>
        <trans-unit id="e305cdc0a6e58d2992d00df36114935a966f06eb" translate="yes" xml:space="preserve">
          <source>Open two cursors, one to each of the two tables being queried.</source>
          <target state="translated">Откройте два курсора,по одному на каждый из двух опрашиваемых таблиц.</target>
        </trans-unit>
        <trans-unit id="db8828ea77768020acda7b34e1bdcfb01f4a650b" translate="yes" xml:space="preserve">
          <source>Open, release or rollback the savepoint named by parameter P4, depending on the value of P1. To open a new savepoint set P1==0 (SAVEPOINT_BEGIN). To release (commit) an existing savepoint set P1==1 (SAVEPOINT_RELEASE). To rollback an existing savepoint set P1==2 (SAVEPOINT_ROLLBACK).</source>
          <target state="translated">Откройте,отпустите или откатите точку сохранения,названную параметром P4,в зависимости от значения P1.Для открытия нового набора точек сохранения P1==0 (SAVEPOINT_BEGIN).Чтобы освободить (зафиксировать)существующую точку сохранения P1==1 (SAVEPOINT_RELEASE).Чтобы откатить существующую точку сохранения P1==2 (SAVEPOINT_ROLLBACK).</target>
        </trans-unit>
        <trans-unit id="e54c6e14fb4a075fa699ffdaaaf395ff313982e8" translate="yes" xml:space="preserve">
          <source>OpenAutoindex</source>
          <target state="translated">OpenAutoindex</target>
        </trans-unit>
        <trans-unit id="4102c59c0ab3f6e830e46718de359a59f628ee07" translate="yes" xml:space="preserve">
          <source>OpenDup</source>
          <target state="translated">OpenDup</target>
        </trans-unit>
        <trans-unit id="ad5bdfbe38582d74f4e2d987d0014c4a061fc0bc" translate="yes" xml:space="preserve">
          <source>OpenEphemeral</source>
          <target state="translated">OpenEphemeral</target>
        </trans-unit>
        <trans-unit id="4a5d4d0e6cf7c26b571b8ed8b7d9e91f5a55707c" translate="yes" xml:space="preserve">
          <source>OpenPseudo</source>
          <target state="translated">OpenPseudo</target>
        </trans-unit>
        <trans-unit id="321f145cb1e3470cc293ca452256220e4b476cbf" translate="yes" xml:space="preserve">
          <source>OpenRead</source>
          <target state="translated">OpenRead</target>
        </trans-unit>
        <trans-unit id="3894e594709a936290c9439b10b580db3b56e3b5" translate="yes" xml:space="preserve">
          <source>OpenWrite</source>
          <target state="translated">OpenWrite</target>
        </trans-unit>
        <trans-unit id="10f17177db5db183ce11fbbf98483043f8f93d13" translate="yes" xml:space="preserve">
          <source>Openclose callback</source>
          <target state="translated">Обратный звонок в режиме &quot;открытость</target>
        </trans-unit>
        <trans-unit id="f1ba5b2c8dba45952ee1dd4e3e5587becf1e4832" translate="yes" xml:space="preserve">
          <source>Opening A New Database Connection</source>
          <target state="translated">Открытие нового соединения с базой данных</target>
        </trans-unit>
        <trans-unit id="8bea067fa84f98eb8cb08b76d377cd2759d84a48" translate="yes" xml:space="preserve">
          <source>Opening a New Connection</source>
          <target state="translated">Открытие нового соединения</target>
        </trans-unit>
        <trans-unit id="0fcdc2f790b5b05c0b11e1b00c614a1147af7a65" translate="yes" xml:space="preserve">
          <source>Opening a Read-Only Transaction</source>
          <target state="translated">Открытие сделки только для чтения</target>
        </trans-unit>
        <trans-unit id="8c328ea219e123938753dd011cc218695e36770e" translate="yes" xml:space="preserve">
          <source>Opening a connection.</source>
          <target state="translated">Открытие соединения.</target>
        </trans-unit>
        <trans-unit id="0a848c1fa6f5b691a8b43871dbf9920b32a63f8f" translate="yes" xml:space="preserve">
          <source>Opening a new database connection is a two-step process:</source>
          <target state="translated">Открытие нового соединения с БД-это двухступенчатый процесс:</target>
        </trans-unit>
        <trans-unit id="60a2e026abe5554a6164ccf369d3bdb712d462a6" translate="yes" xml:space="preserve">
          <source>Opening a read-only transaction.</source>
          <target state="translated">Открытие сделки только для чтения.</target>
        </trans-unit>
        <trans-unit id="d0a97ec8f1b3b761b48ba3f0b5793b7b063cf28e" translate="yes" xml:space="preserve">
          <source>Opening a read-write transaction.</source>
          <target state="translated">Открытие операции чтения и записи.</target>
        </trans-unit>
        <trans-unit id="5bef4a855a587c7ae88d0d6e7fbc4f0cf1d92d9c" translate="yes" xml:space="preserve">
          <source>Opening a statement transaction.</source>
          <target state="translated">Открытие операции по выписке.</target>
        </trans-unit>
        <trans-unit id="5f6fc2590106eab5d853e4838b574315ff3651ac" translate="yes" xml:space="preserve">
          <source>Operand P1 must be 0x7fffffff and P2 must positive.</source>
          <target state="translated">Операнд P1 должен быть 0x7fffff и P2 должен быть положительным.</target>
        </trans-unit>
        <trans-unit id="d0e687b079fb70f2208d1f8d2c75d64d74925496" translate="yes" xml:space="preserve">
          <source>Operator</source>
          <target state="translated">Operator</target>
        </trans-unit>
        <trans-unit id="e90414358dbfff0a68e4eb5d68a16978cf197d5a" translate="yes" xml:space="preserve">
          <source>Operators</source>
          <target state="translated">Operators</target>
        </trans-unit>
        <trans-unit id="653e79b2411d60c991c837c40648dc99da326979" translate="yes" xml:space="preserve">
          <source>Optimization: When doing an &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; on a table with &lt;a href=&quot;expridx&quot;&gt;indexes on expressions&lt;/a&gt;, do not update the expression indexes if they do not refer to any of the columns of the table being updated.</source>
          <target state="translated">Оптимизация: при выполнении &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; в таблице с &lt;a href=&quot;expridx&quot;&gt;индексами в выражениях&lt;/a&gt; не обновляйте индексы выражений, если они не относятся ни к одному из столбцов обновляемой таблицы.</target>
        </trans-unit>
        <trans-unit id="a794f9704b3031ad0771d79793775c086e03f157" translate="yes" xml:space="preserve">
          <source>Optimizations to the sqlite_mprintf() routine.</source>
          <target state="translated">Оптимизация рутины sqlite_mprintf().</target>
        </trans-unit>
        <trans-unit id="088089a3961fc329e20285999528f0da0604b13a" translate="yes" xml:space="preserve">
          <source>Optimize the &lt;a href=&quot;lang_corefunc#typeof&quot;&gt;typeof()&lt;/a&gt; and &lt;a href=&quot;lang_corefunc#length&quot;&gt;length()&lt;/a&gt; SQL functions so that they avoid unnecessary reading of database content from disk.</source>
          <target state="translated">Оптимизируйте функции SQL &lt;a href=&quot;lang_corefunc#typeof&quot;&gt;typeof ()&lt;/a&gt; и &lt;a href=&quot;lang_corefunc#length&quot;&gt;length (),&lt;/a&gt; чтобы они избегали ненужного чтения содержимого базы данных с диска.</target>
        </trans-unit>
        <trans-unit id="89ea4f0e94546aba0e6576de32f5af050f08375b" translate="yes" xml:space="preserve">
          <source>Optimizer does a better job of using indices to satisfy ORDER BY clauses that sort on the integer primary key</source>
          <target state="translated">Оптимизатор лучше использует индексы для удовлетворения пунктов ORDER BY,которые сортируют по целочисленному первичному ключу</target>
        </trans-unit>
        <trans-unit id="d859dd72c637fafc6319ca0f4f6cb8c1fd01736f" translate="yes" xml:space="preserve">
          <source>Optimizer enhancement: &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statements&lt;/a&gt; are automatically re-compiled when a binding on the RHS of a LIKE operator changes or when any range constraint changes under &lt;a href=&quot;compile#enable_stat2&quot;&gt;SQLITE_ENABLE_STAT2&lt;/a&gt;.</source>
          <target state="translated">Улучшение оптимизатора: &lt;a href=&quot;c3ref/stmt&quot;&gt;подготовленные операторы&lt;/a&gt; автоматически перекомпилируются при изменении привязки RHS оператора LIKE или при изменении любого ограничения диапазона в &lt;a href=&quot;compile#enable_stat2&quot;&gt;SQLITE_ENABLE_STAT2&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e31d972229de381b461860014dd710856361917a" translate="yes" xml:space="preserve">
          <source>Option</source>
          <target state="translated">Option</target>
        </trans-unit>
        <trans-unit id="6120d3ea8f989e319fa4157b88a6894abd99ea8b" translate="yes" xml:space="preserve">
          <source>Option 1:</source>
          <target state="translated">Вариант 1:</target>
        </trans-unit>
        <trans-unit id="787636b9cef675727f97423a49f2d6e8aeb5b354" translate="yes" xml:space="preserve">
          <source>Option 2:</source>
          <target state="translated">Вариант 2:</target>
        </trans-unit>
        <trans-unit id="620a38bc45cce1e89bad8abed95cee233ec74ca8" translate="yes" xml:space="preserve">
          <source>Optional LIMIT and ORDER BY Clauses</source>
          <target state="translated">Необязательно ОГРАНИЧИТЬ и ЗАКАЗАТЬ по пунктам</target>
        </trans-unit>
        <trans-unit id="4a8101f15dc88fa6899984a679049286645dada8" translate="yes" xml:space="preserve">
          <source>Optional LIMIT and ORDER BY clauses</source>
          <target state="translated">Необязательное ОГРАНИЧЕНИЕ и ЗАКАЗЫВАНИЕ ОРГАНИЗАЦИЕЙ</target>
        </trans-unit>
        <trans-unit id="147fccad2acf5d54cf4c9bd90959d2b685bb12a8" translate="yes" xml:space="preserve">
          <source>Optional READ UNCOMMITTED isolation (instead of the default isolation level of SERIALIZABLE) and table level locking when database connections share a common cache.</source>
          <target state="translated">Опционально READ UNCOMMITTED изоляция (вместо уровня изоляции по умолчанию SERIALIZABLE)и блокировка на уровне таблиц,когда соединения БД имеют общий кэш.</target>
        </trans-unit>
        <trans-unit id="99e39e3c25d749e303cfb0392ac6108be81a9ed0" translate="yes" xml:space="preserve">
          <source>Optionally, a &lt;a href=&quot;gencol&quot;&gt;generated column&lt;/a&gt; constraint.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3c4d258c19e0b0e32f1a0047f810a58bf67a8d7" translate="yes" xml:space="preserve">
          <source>Optionally, a PRIMARY KEY for the table. Both single column and composite (multiple column) primary keys are supported.</source>
          <target state="translated">Опционально,ПРАЙМАРИ КЕЙ для стола.Поддерживаются как одностолбцовые,так и составные (многостолбцовые)первичные ключи.</target>
        </trans-unit>
        <trans-unit id="afb65b09ecb1abf655b3870806d0d663e9055759" translate="yes" xml:space="preserve">
          <source>Options understood by the &lt;b&gt;sqlite3&lt;/b&gt; command include:</source>
          <target state="translated">Параметры, понимаемые командой &lt;b&gt;sqlite3,&lt;/b&gt; включают:</target>
        </trans-unit>
        <trans-unit id="e72184f55cc026514b7160d78c3c5aef63c2a050" translate="yes" xml:space="preserve">
          <source>Or</source>
          <target state="translated">Or</target>
        </trans-unit>
        <trans-unit id="1a5a89789f35d1adc160640f07b04eccb062e675" translate="yes" xml:space="preserve">
          <source>Or consider these identical queries:</source>
          <target state="translated">Или рассмотрим эти идентичные запросы:</target>
        </trans-unit>
        <trans-unit id="16127303ea06cc226e15f6d081becfc0853f54f2" translate="yes" xml:space="preserve">
          <source>Or go the other way:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa8e4bd6460fbb4edd20d4ab7cc84cb756c25fa7" translate="yes" xml:space="preserve">
          <source>Or on Windows with MSVC:</source>
          <target state="translated">Или на Windows с MSVC:</target>
        </trans-unit>
        <trans-unit id="65cc0e4d32009c846d3d67b851864fc0e2100eac" translate="yes" xml:space="preserve">
          <source>Or optimization</source>
          <target state="translated">Или оптимизация</target>
        </trans-unit>
        <trans-unit id="fbfd8b5435e1bb1225c27564f4e61467d6052b3a" translate="yes" xml:space="preserve">
          <source>Or perhaps the application would rather use the most recent checkinTime:</source>
          <target state="translated">Или,возможно,приложение предпочло бы использовать самую последнюю проверку CheckinTime:</target>
        </trans-unit>
        <trans-unit id="2a55f1def49ba2cf28edd04aebe0ae914d6adc01" translate="yes" xml:space="preserve">
          <source>Or this:</source>
          <target state="translated">Или это:</target>
        </trans-unit>
        <trans-unit id="4adffe1f4f67467b27dd86bae1fcc140644a1e80" translate="yes" xml:space="preserve">
          <source>Or to be extra safe with a database and to force SQLite to assume the database lacks powersafe overwrite, open it using</source>
          <target state="translated">Или,чтобы быть особо безопасным с базой данных и заставить SQLite предположить,что база данных не имеет powersafe перезаписи,откройте ее,используя</target>
        </trans-unit>
        <trans-unit id="cb4a4efee56406c1c1e484f479dafaa1ce0d3fdd" translate="yes" xml:space="preserve">
          <source>Or using &lt;a href=&quot;cli#fileio&quot;&gt;file I/O functions&lt;/a&gt;, you can extract elements of the ZIP archive:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="beb6e4abd1b3ea2eadafe45050288632422b5468" translate="yes" xml:space="preserve">
          <source>Or,</source>
          <target state="translated">Or,</target>
        </trans-unit>
        <trans-unit id="66d567cd524d8ab999d4e199670d77fab66ce1bc" translate="yes" xml:space="preserve">
          <source>Or, from the SQLite shell tool (the &lt;a href=&quot;cli#fileio&quot;&gt;readfile()&lt;/a&gt; function reads the contents of a file from the file-system and returns it as a blob):</source>
          <target state="translated">Или из инструмента оболочки SQLite ( &lt;a href=&quot;cli#fileio&quot;&gt;функция readfile ()&lt;/a&gt; считывает содержимое файла из файловой системы и возвращает его как большой двоичный объект):</target>
        </trans-unit>
        <trans-unit id="5555ca89e43c2c41b68ce29dd846f696f04f9021" translate="yes" xml:space="preserve">
          <source>Or, if argument zTab is NULL, then changes are recorded for all tables in the database. If additional tables are added to the database (by executing &quot;CREATE TABLE&quot; statements) after this call is made, changes for the new tables are also recorded.</source>
          <target state="translated">Или,если аргумент zTab равен NULL,то изменения записываются для всех таблиц в БД.Если после этого вызова в БД добавляются дополнительные таблицы (путем выполнения оператора &quot;CREATE TABLE&quot;),то изменения для новых таблиц также записываются.</target>
        </trans-unit>
        <trans-unit id="0aca97133f8a0b1812de40afe8dc2efdb01e49c8" translate="yes" xml:space="preserve">
          <source>Or, if double-quoted string literals are disabled by default, but need to be selectively enabled for some historical database connections, that can be done using the same C-code as shown above except with the third parameter changed from 0 to 1.</source>
          <target state="translated">Или,если по умолчанию отключены строковые литералы в двойных кавычках,но их необходимо выборочно включить для некоторых исторических подключений к БД,это можно сделать с помощью того же самого C-кода,как показано выше,за исключением того,что третий параметр изменен с 0 на 1.</target>
        </trans-unit>
        <trans-unit id="322edc10740abf86eb6c1728491b5451dec39f1d" translate="yes" xml:space="preserve">
          <source>Or, if sqlite3.c is compiled using some other build system, by arranging for the SQLITE_ENABLE_FTS5 pre-processor symbol to be defined.</source>
          <target state="translated">Или,если sqlite3.c скомпилирована с помощью другой системы сборки,организуя определение символа препроцессора SQLITE_ENABLE_FTS5.</target>
        </trans-unit>
        <trans-unit id="658f77f8eef94489e4209dc1e50f66504ceb72eb" translate="yes" xml:space="preserve">
          <source>Or, if the argument attached to the REINDEX identifies a specific database table, then all indices attached to the database table are rebuilt. If it identifies a specific database index, then just that index is recreated.</source>
          <target state="translated">Или,если аргумент,приложенный к REINDEX,идентифицирует конкретную таблицу БД,то все индексы,приложенные к таблице БД,перестраиваются.Если же он идентифицирует конкретный индекс БД,то воссоздается именно этот индекс.</target>
        </trans-unit>
        <trans-unit id="60a5aae7483ffe81235af01c0cffa5d4ff23cd22" translate="yes" xml:space="preserve">
          <source>Or, if the table is also a &lt;a href=&quot;fts5#contentless_tables&quot;&gt;contentless table&lt;/a&gt;, then the following apply:</source>
          <target state="translated">Или, если таблица также является &lt;a href=&quot;fts5#contentless_tables&quot;&gt;таблицей без содержимого&lt;/a&gt; , применяется следующее:</target>
        </trans-unit>
        <trans-unit id="aa1077574bb502a8689f667cb965b8e30b1c1e85" translate="yes" xml:space="preserve">
          <source>Or, if using the autoconf build system, pass the --enable-session option to the configure script.</source>
          <target state="translated">Или,если используется система сборки autoconf,передайте опцию --enable-session скрипту конфигурации.</target>
        </trans-unit>
        <trans-unit id="0ff802a22b003329b02ab696a2c315faad2a0e85" translate="yes" xml:space="preserve">
          <source>Or, multiple presentations could be stored within the same document.</source>
          <target state="translated">Или несколько презентаций могут храниться в одном документе.</target>
        </trans-unit>
        <trans-unit id="d354f2e196d0e9cdbbdd8e5133631fe7bd7c69f7" translate="yes" xml:space="preserve">
          <source>Or, the same content can be read using:</source>
          <target state="translated">Или то же самое содержимое можно прочитать,используя:</target>
        </trans-unit>
        <trans-unit id="e7aee41fb363d46e588ad49a1b5591b283e863a6" translate="yes" xml:space="preserve">
          <source>Or, to list all changes to one particular account ($xyz) in order of decreasing magnitude, one can write:</source>
          <target state="translated">Или,чтобы перечислить все изменения на одном конкретном счете ($xyz)в порядке убывания,можно написать:</target>
        </trans-unit>
        <trans-unit id="8a1681e612a2025087b703fdf1f8f617e506b053" translate="yes" xml:space="preserve">
          <source>Oracle</source>
          <target state="translated">Oracle</target>
        </trans-unit>
        <trans-unit id="6e8727d6e68eed5d20f3fa889a8e8b2bd24438db" translate="yes" xml:space="preserve">
          <source>Orders of magnitude performance improvement for &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt; on very large tables.</source>
          <target state="translated">Увеличение производительности &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt; на порядки на очень больших таблицах.</target>
        </trans-unit>
        <trans-unit id="6ce3fb54d989f83f97843b164388df9c55d52716" translate="yes" xml:space="preserve">
          <source>Ordinary Common Table Expressions</source>
          <target state="translated">Обычные общие табличные выражения</target>
        </trans-unit>
        <trans-unit id="628b6d597a836775d3c57cc85ac20362e62df83f" translate="yes" xml:space="preserve">
          <source>Ordinary SQL statements are free-form, and can be spread across multiple lines, and can have whitespace and comments anywhere. Dot-commands are more restrictive:</source>
          <target state="translated">Обычные SQL-операторы имеют свободную форму и могут быть распределены по нескольким строкам,а также могут иметь пробельные символы и комментарии в любом месте.Точка-команды более ограничены:</target>
        </trans-unit>
        <trans-unit id="410efca163172750b4e7d07d3df715195f75df04" translate="yes" xml:space="preserve">
          <source>Ordinary common table expressions</source>
          <target state="translated">Обычные общие табличные выражения</target>
        </trans-unit>
        <trans-unit id="d3bfeb484e7ad7fe55b8281bb0d45da13e3151eb" translate="yes" xml:space="preserve">
          <source>Original content of the page prior to the start of the transaction</source>
          <target state="translated">Оригинальное содержание страницы до начала транзакции</target>
        </trans-unit>
        <trans-unit id="53583b5aa5fa79b35a37fe615fa3d9b1eece6568" translate="yes" xml:space="preserve">
          <source>Other C-libraries that process complex structured inputs will routinely be asked to deal with unvetted inputs from untrusted sources. Libraries like libjpeg, or libzip, or OpenSSL are handed input streams that come directly from potentially hostile agents.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="220b92a9851d65e3f5763bc585c592d7a14215e7" translate="yes" xml:space="preserve">
          <source>Other Issues</source>
          <target state="translated">Другие вопросы</target>
        </trans-unit>
        <trans-unit id="286c105cf7e1fc8242c5f069e4037b0e5e35102f" translate="yes" xml:space="preserve">
          <source>Other SQL database engines tend to store data as a large collection of files. Often these files are in a standard location that only the database engine itself can access. This makes the data more secure, but also makes it harder to access. Some SQL database engines provide the option of writing directly to disk and bypassing the filesystem all together. This provides added performance, but at the cost of considerable setup and maintenance complexity.</source>
          <target state="translated">Другие движки баз данных SQL,как правило,хранят данные в виде большой коллекции файлов.Часто эти файлы находятся в стандартном месте,доступном только самому движку базы данных.Это делает данные более безопасными,но и затрудняет доступ к ним.Некоторые движки баз данных SQL предоставляют возможность записи непосредственно на диск и в обход файловой системы все вместе.Это обеспечивает дополнительную производительность,но за счет значительной сложности настройки и обслуживания.</target>
        </trans-unit>
        <trans-unit id="5210f14e159e526b00e7b67ae5e00a7489e472f8" translate="yes" xml:space="preserve">
          <source>Other and more complex extensions can be found in subfolders under &lt;a href=&quot;https://www.sqlite.org/src/file/ext&quot;&gt;ext/&lt;/a&gt; other than ext/misc/.</source>
          <target state="translated">Другие, более сложные расширения можно найти в подпапках &lt;a href=&quot;https://www.sqlite.org/src/file/ext&quot;&gt;ext /,&lt;/a&gt; отличных от ext / misc /.</target>
        </trans-unit>
        <trans-unit id="a5885d7d219a9dd314e80ea53c10a7870f48702f" translate="yes" xml:space="preserve">
          <source>Other compile-time options such as using -O3 instead of -Os or using &lt;a href=&quot;compile#threadsafe&quot;&gt;-DSQLITE_THREADSAFE=0&lt;/a&gt; and/or some of the other &lt;a href=&quot;compile#rcmd&quot;&gt;recommended compile-time options&lt;/a&gt; might help SQLite to run even faster relative to direct filesystem reads.</source>
          <target state="translated">Другие параметры времени компиляции, такие как использование -O3 вместо -Os или использование &lt;a href=&quot;compile#threadsafe&quot;&gt;-DSQLITE_THREADSAFE = 0&lt;/a&gt; и / или некоторые другие &lt;a href=&quot;compile#rcmd&quot;&gt;рекомендуемые параметры времени компиляции,&lt;/a&gt; могут помочь SQLite работать еще быстрее по сравнению с прямым чтением файловой системы.</target>
        </trans-unit>
        <trans-unit id="68a8c532629b4cb41be7b1e40786ac6ad241781e" translate="yes" xml:space="preserve">
          <source>Other database engines may run great once you get them going. But doing the initial installation and configuration can often be intimidating.</source>
          <target state="translated">Другие движки баз данных могут отлично работать,как только вы их запустите.Но начальная установка и настройка часто может быть пугающей.</target>
        </trans-unit>
        <trans-unit id="0d3a3415efe071d534d2ab15cd7fe976055daeb3" translate="yes" xml:space="preserve">
          <source>Other entries in the cost table specific transforms for particular characters. The cost of specific transforms should be less than the default costs, or else the default costs will take precedence and the specific transforms will never be used.</source>
          <target state="translated">Другие записи в таблице расходов специфические преобразования для конкретных символов.Затраты на конкретные трансформации должны быть меньше затрат по умолчанию,иначе затраты по умолчанию будут иметь приоритет и конкретные трансформации никогда не будут использоваться.</target>
        </trans-unit>
        <trans-unit id="0ac3c9882a4b70189ad1bfa57e91f5a096b4d423" translate="yes" xml:space="preserve">
          <source>Other examples:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cae24656c6711756dea7bb8cd35f3afb8c810eb8" translate="yes" xml:space="preserve">
          <source>Other experimental memory allocators might be added in future releases of SQLite. One may anticipate that these will be called memsys7, memsys8, and so forth.</source>
          <target state="translated">В будущих релизах SQLite могут быть добавлены другие экспериментальные аллокаторы памяти.Можно ожидать,что они будут называться memsys7,memsys8 и так далее.</target>
        </trans-unit>
        <trans-unit id="10c1a85e8f6e1ba9ad67291c0e509d27f0146a7c" translate="yes" xml:space="preserve">
          <source>Other important bug fixes</source>
          <target state="translated">Другие важные исправления ошибок</target>
        </trans-unit>
        <trans-unit id="eafff73d48037ade49167d838ce6e1b6a891fb16" translate="yes" xml:space="preserve">
          <source>Other information fields of the sqlite3_rtree_query_info structure are available for use by the xQueryFunc callback, if desired. The iRowid field is the rowid (the first of the 3 to 11 columns in the R*Tree) for the element being considered. iRowid is only valid for leaves. The eParentWithin and rParentScore values are copies of the eWithin and rScore values from the containing subtree of the current row. The anQueue field is an array of mxLevel+1 unsigned integers that tell the current number of elements in the priority queue at each level.</source>
          <target state="translated">Другие информационные поля структуры sqlite3_rtree_query_info доступны для использования обратным вызовом xQueryFunc,при желании.Поле iRowid-это rowid (первый из 3-11 столбцов в R*Tree)для рассматриваемого элемента.iRowid действителен только для листьев.Значения eParentWithin и rParentScore являются копиями значений eWithin и rScore из содержащего поддерева текущей строки.Поле anQueue представляет собой массив из mxLevel+1 неподписанных целых чисел,которые сообщают текущее количество элементов в очереди приоритетов на каждом уровне.</target>
        </trans-unit>
        <trans-unit id="ac116740090073aa7d395dd931c8587b7e5ed819" translate="yes" xml:space="preserve">
          <source>Other kinds of constraints may be used and will work, but other constraints will be checked individually for each row and will not be optimized (at least not initially). All constraint checking is completely automatic regardless of whether or not optimization occurs. The optimization referred to in this bullet point is a performance consideration only. The same result is obtained regardless of whether or not the query is optimized.</source>
          <target state="translated">Другие виды ограничений могут быть использованы и будут работать,но другие ограничения будут проверяться индивидуально для каждой строки и не будут оптимизированы (по крайней мере,не изначально).Вся проверка ограничений происходит полностью автоматически,независимо от того,происходит оптимизация или нет.Оптимизация,о которой идет речь в данном пункте,является рассмотрением только производительности.Один и тот же результат получается независимо от того,оптимизирован запрос или нет.</target>
        </trans-unit>
        <trans-unit id="aea1c45528f91c41cd64bff7bc4b9fe5c5d9e390" translate="yes" xml:space="preserve">
          <source>Other languages like Java, Perl, Python, and TCL typically translate the program source text into bytecode. This bytecode is then run through an interpreter that reads the bytecode and carries out the desired operations. SQLite uses this bytecode approach. If you preceed any SQL statement with the &quot;&lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt;&quot; keyword in SQLite, it will show you the bytecode that is generated rather than run the bytecode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="808f70785d1ef92ea5c6148eaa9481e6d0e14aa1" translate="yes" xml:space="preserve">
          <source>Other lists: &lt;a href=&quot;constlist&quot;&gt;Constants&lt;/a&gt; and &lt;a href=&quot;funclist&quot;&gt;Functions&lt;/a&gt; and &lt;a href=&quot;../rescode&quot;&gt;Result Codes&lt;/a&gt;.</source>
          <target state="translated">Другие списки: &lt;a href=&quot;constlist&quot;&gt;константы&lt;/a&gt; и &lt;a href=&quot;funclist&quot;&gt;функции&lt;/a&gt; и &lt;a href=&quot;../rescode&quot;&gt;коды результатов&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="254b17e4c2182837b7ef0fdd5b3824e226f2c5a8" translate="yes" xml:space="preserve">
          <source>Other lists: &lt;a href=&quot;constlist&quot;&gt;Constants&lt;/a&gt; and &lt;a href=&quot;funclist&quot;&gt;Functions&lt;/a&gt;.</source>
          <target state="translated">Другие списки: &lt;a href=&quot;constlist&quot;&gt;константы&lt;/a&gt; и &lt;a href=&quot;funclist&quot;&gt;функции&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4f2e591c11c09005f92f16a4e53401bee7662b02" translate="yes" xml:space="preserve">
          <source>Other lists: &lt;a href=&quot;constlist&quot;&gt;Constants&lt;/a&gt; and &lt;a href=&quot;objlist&quot;&gt;Objects&lt;/a&gt; and &lt;a href=&quot;../rescode&quot;&gt;Result Codes&lt;/a&gt;</source>
          <target state="translated">Другие списки: &lt;a href=&quot;constlist&quot;&gt;Константы&lt;/a&gt; и &lt;a href=&quot;objlist&quot;&gt;объекты&lt;/a&gt; и &lt;a href=&quot;../rescode&quot;&gt;Результирующие коды&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="710d410006003e6c96fa23b1a96739384d30f239" translate="yes" xml:space="preserve">
          <source>Other lists: &lt;a href=&quot;constlist&quot;&gt;Constants&lt;/a&gt; and &lt;a href=&quot;objlist&quot;&gt;Objects&lt;/a&gt;.</source>
          <target state="translated">Другие списки: &lt;a href=&quot;constlist&quot;&gt;константы&lt;/a&gt; и &lt;a href=&quot;objlist&quot;&gt;объекты&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="dc0c16f3fd55dac69e3748a6c043c6447d6ab575" translate="yes" xml:space="preserve">
          <source>Other lists: &lt;a href=&quot;objlist&quot;&gt;Objects&lt;/a&gt; and &lt;a href=&quot;funclist&quot;&gt;Functions&lt;/a&gt; and &lt;a href=&quot;../rescode&quot;&gt;Result Codes&lt;/a&gt;.</source>
          <target state="translated">Другие списки: &lt;a href=&quot;objlist&quot;&gt;объекты&lt;/a&gt; и &lt;a href=&quot;funclist&quot;&gt;функции&lt;/a&gt; и &lt;a href=&quot;../rescode&quot;&gt;коды результатов&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ce8676972cf44ad111328d5252187ad79820f8b7" translate="yes" xml:space="preserve">
          <source>Other lists: &lt;a href=&quot;objlist&quot;&gt;Objects&lt;/a&gt; and &lt;a href=&quot;funclist&quot;&gt;Functions&lt;/a&gt;.</source>
          <target state="translated">Другие списки: &lt;a href=&quot;objlist&quot;&gt;объекты&lt;/a&gt; и &lt;a href=&quot;funclist&quot;&gt;функции&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6e05129b6c75ff832aa70dbb2deb9f7c3bddb6dc" translate="yes" xml:space="preserve">
          <source>Other minor bug fixes</source>
          <target state="translated">Другие незначительные исправления</target>
        </trans-unit>
        <trans-unit id="d4fc03a4fb1eb22ede8954ef99eea86a034ae6d2" translate="yes" xml:space="preserve">
          <source>Other minor bug fixes and documentation enhancements</source>
          <target state="translated">Другие незначительные исправления ошибок и улучшения документации</target>
        </trans-unit>
        <trans-unit id="890b3d475caba8d5bd7557f9c475d8af3c752a15" translate="yes" xml:space="preserve">
          <source>Other minor bug fixes and documentation enhancements.</source>
          <target state="translated">Другие незначительные исправления ошибок и улучшения документации.</target>
        </trans-unit>
        <trans-unit id="aa1b8c87b3d167a75e9df291742b29d3051fb50c" translate="yes" xml:space="preserve">
          <source>Other minor bug fixes and performance enhancements.</source>
          <target state="translated">Другие незначительные исправления ошибок и улучшения производительности.</target>
        </trans-unit>
        <trans-unit id="0fa68e95547b847335553befa0f2cb7b67624587" translate="yes" xml:space="preserve">
          <source>Other minor bug fixes and performance optimizations.</source>
          <target state="translated">Другие незначительные исправления и оптимизация производительности.</target>
        </trans-unit>
        <trans-unit id="1057a4540e5ed3386909678e9ca548cf6300a507" translate="yes" xml:space="preserve">
          <source>Other minor bug fixes in preparation for the first stable release of version 3.3</source>
          <target state="translated">Другие незначительные исправления в подготовке первого стабильного релиза версии 3.3</target>
        </trans-unit>
        <trans-unit id="f58ff693cc659b1eb66fa3445ac112f3a975e0d7" translate="yes" xml:space="preserve">
          <source>Other minor bug fixes.</source>
          <target state="translated">Другие незначительные исправления.</target>
        </trans-unit>
        <trans-unit id="3d1e22329a4cb1219246e265a7a252a723c9d5fa" translate="yes" xml:space="preserve">
          <source>Other minor changes and enhancements.</source>
          <target state="translated">Другие незначительные изменения и улучшения.</target>
        </trans-unit>
        <trans-unit id="251ead6fb529a54fa107bbdc4f76c0af651e9179" translate="yes" xml:space="preserve">
          <source>Other minor compiler-warning fixes and whatnot.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="deee6da4efcaf54f2a7bee650d4c13bb508dfa45" translate="yes" xml:space="preserve">
          <source>Other minor documentation and makefile changes and bug fixes.</source>
          <target state="translated">Другие незначительные изменения в документации и makefile,а также исправления ошибок.</target>
        </trans-unit>
        <trans-unit id="031aa8e8c99846cb30787089a75b424566d207ca" translate="yes" xml:space="preserve">
          <source>Other minor tweaks to improve the quality of &lt;a href=&quot;opcode&quot;&gt;VDBE&lt;/a&gt; code.</source>
          <target state="translated">Другие незначительные изменения для улучшения качества кода &lt;a href=&quot;opcode&quot;&gt;VDBE&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8b05e7277715773ceabf87f5e50fad5de6b24dd9" translate="yes" xml:space="preserve">
          <source>Other miscellaneous bug fixes</source>
          <target state="translated">Другие различные исправления ошибок</target>
        </trans-unit>
        <trans-unit id="5d73e7d5d87f0b601b3cbf8f19cc97602a0f29c4" translate="yes" xml:space="preserve">
          <source>Other miscellaneous bug fixes.</source>
          <target state="translated">Другие различные исправления ошибок.</target>
        </trans-unit>
        <trans-unit id="4b8124041770cac5d89ae555b4ac03153c37ffc1" translate="yes" xml:space="preserve">
          <source>Other miscellaneous enhancements such as loop unrolling.</source>
          <target state="translated">Другие различные усовершенствования,такие как разворачивание петли.</target>
        </trans-unit>
        <trans-unit id="6f62eac50d6703d3917c9f2154f9f77dce98abcd" translate="yes" xml:space="preserve">
          <source>Other miscellaneous micro-optimizations for improved performance and reduced memory usage.</source>
          <target state="translated">Другие различные микро-оптимизации для повышения производительности и сокращения использования памяти.</target>
        </trans-unit>
        <trans-unit id="26485a453cc99f6d07c9ad5f2979b799b10596af" translate="yes" xml:space="preserve">
          <source>Other miscellaneous minor bug fixes.</source>
          <target state="translated">Другие мелкие ошибки.</target>
        </trans-unit>
        <trans-unit id="583fac43540a1c8647f7a52c63c6d87ee3c57112" translate="yes" xml:space="preserve">
          <source>Other miscellaneous performance enhancements.</source>
          <target state="translated">Другие различные улучшения производительности.</target>
        </trans-unit>
        <trans-unit id="d5335cc4f60749bd941dc9764ef3c6855a7a176b" translate="yes" xml:space="preserve">
          <source>Other more familiar database engines run great once you get them going. But doing the initial installation and configuration can be intimidatingly complex.</source>
          <target state="translated">Другие,более знакомые движки баз данных,работают отлично,как только вы их запускаете.Но первоначальная установка и настройка может быть пугающе сложной.</target>
        </trans-unit>
        <trans-unit id="d62a6e61f5dec5bfc458e9cb92c78c02e716a2af" translate="yes" xml:space="preserve">
          <source>Other output modes include &quot;html&quot;, &quot;json&quot;, and &quot;tcl&quot;. Try these yourself to see what they do.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="453575f6d5ccd906017a354a3747a73c275dcbf4" translate="yes" xml:space="preserve">
          <source>Other pages that talk about Fossil and Git include:</source>
          <target state="translated">Другие страницы,которые говорят об ископаемых и Git,включают в себя:</target>
        </trans-unit>
        <trans-unit id="1691c79ed589685ad615d8d10ce5d4a24f7887ad" translate="yes" xml:space="preserve">
          <source>Other performance improvements. Uses about &lt;a href=&quot;cpu&quot;&gt;6.5% fewer CPU cycles&lt;/a&gt;.</source>
          <target state="translated">Прочие улучшения производительности. Использует примерно на &lt;a href=&quot;cpu&quot;&gt;6,5% меньше циклов ЦП&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="53a9f15c17fc6f690db9ec48e6c595c7787f86a9" translate="yes" xml:space="preserve">
          <source>Other performance optimizations:</source>
          <target state="translated">Другие оптимизации производительности:</target>
        </trans-unit>
        <trans-unit id="a62bf7250068b9b0c4a25d2045a53dbb9795b912" translate="yes" xml:space="preserve">
          <source>Other programming languages sometimes claim to be &quot;as fast as C&quot;. But no other language claims to be faster than C for general-purpose programming, because none are.</source>
          <target state="translated">Другие языки программирования иногда утверждают,что они &quot;такие же быстрые,как C&quot;.Но ни один другой язык не претендует на то,что он быстрее С для программирования общего назначения,потому что ни один из них не быстрее С.</target>
        </trans-unit>
        <trans-unit id="400864fb9a5435081d0153c603d26034407232fd" translate="yes" xml:space="preserve">
          <source>Other relation database engines also implement UPDATE-FROM, but because the construct is not part of the SQL standards, each product implements UPDATE-FROM differently. The SQLite implementation strives to be compatible with PostgreSQL. The SQL Server and MySQL implementations of the same idea work a little differently.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b724fba24bcbd81609e47345dfce9dfa38bb53b6" translate="yes" xml:space="preserve">
          <source>Other similar tree-display routines include:</source>
          <target state="translated">Другие аналогичные процедуры отображения деревьев включают в себя:</target>
        </trans-unit>
        <trans-unit id="eb0b09bd0abc9cbcebf776931eb89745e9f2f6c6" translate="yes" xml:space="preserve">
          <source>Other small bug fixes and optimizations.</source>
          <target state="translated">Другие небольшие исправления и оптимизации.</target>
        </trans-unit>
        <trans-unit id="ce257a3574985ec3c0e88eff4d14f53603f86d62" translate="yes" xml:space="preserve">
          <source>Other systems sometimes use assert(X) in a way that is similar to the use of ALWAYS(X) or NEVER(X) in SQLite. Developers will add an assert(X) as a &lt;a href=&quot;https://blog.regehr.org/archives/1576&quot;&gt;tacit acknowledgement that they do not fully believe that X is always true&lt;/a&gt;. We believe that this use of assert(X) is wrong and violates the intent and purpose of having assert(X) available in C in the first place. An assert(X) should not be seen as a safety-net or top-rope used to guard against mistakes. Nor is assert(X) appropriate for defense-in-depth. An ALWAYS(X) or NEVER(X) macro, or something similar, should be used in those cases because ALWAYS(X) or NEVER(X) will be followed by code to actually deal with the problem when the programmers reasoning turns out to be wrong. Since the code that follows ALWAYS(X) or NEVER(X) is untested, it should be something very simple, like a &quot;return&quot; statement, that is easily verified by inspection.</source>
          <target state="translated">Другие системы иногда используют assert (X) способом, аналогичным использованию ALWAYS (X) или NEVER (X) в SQLite. Разработчики добавят assert (X) в качестве &lt;a href=&quot;https://blog.regehr.org/archives/1576&quot;&gt;молчаливого подтверждения того, что они не полностью верят, что X всегда истинно.&lt;/a&gt;. Мы считаем, что такое использование assert (X) является неправильным и нарушает намерение и цель наличия assert (X), доступного в C в первую очередь. Утверждение (X) не следует рассматривать как страховочную сетку или верёвку, используемую для защиты от ошибок. Также assert (X) не подходит для глубокой защиты. В этих случаях следует использовать макрос ВСЕГДА (X) или НИКОГДА (X) или что-то подобное, потому что ВСЕГДА (X) или НИКОГДА (X) будет следовать код для реального решения проблемы, когда рассуждения программистов оказываются неверными. быть неправым. Поскольку код, следующий за ВСЕГДА (X) или НИКОГДА (X), не протестирован, он должен быть чем-то очень простым, например, оператором возврата, который легко проверить путем проверки.</target>
        </trans-unit>
        <trans-unit id="34d2c9c7d77d063050411b9cf0d5ad05916eb325" translate="yes" xml:space="preserve">
          <source>Otherwise, an expression has no affinity.</source>
          <target state="translated">В противном случае,выражение не имеет никакого сходства.</target>
        </trans-unit>
        <trans-unit id="6917a7f5da3062b0cb87b819a1b98dde64d2060e" translate="yes" xml:space="preserve">
          <source>Otherwise, if no error occurs, &lt;a href=&quot;#sqlite3_db_cacheflush&quot;&gt;sqlite3_db_cacheflush()&lt;/a&gt; returns SQLITE_OK.</source>
          <target state="translated">В противном случае, если ошибки не возникает, &lt;a href=&quot;#sqlite3_db_cacheflush&quot;&gt;sqlite3_db_cacheflush ()&lt;/a&gt; возвращает SQLITE_OK.</target>
        </trans-unit>
        <trans-unit id="63ffff1a975b81be129a4faecffea464b53159fd" translate="yes" xml:space="preserve">
          <source>Otherwise, if no error occurs, &lt;a href=&quot;db_cacheflush&quot;&gt;sqlite3_db_cacheflush()&lt;/a&gt; returns SQLITE_OK.</source>
          <target state="translated">В противном случае, если ошибки не возникает, &lt;a href=&quot;db_cacheflush&quot;&gt;sqlite3_db_cacheflush ()&lt;/a&gt; возвращает SQLITE_OK.</target>
        </trans-unit>
        <trans-unit id="f4554128dd35917d0080717168dbd2c249f00b56" translate="yes" xml:space="preserve">
          <source>Otherwise, if the ORDER BY expression is a column or an alias of an expression that is a column, then the default collation sequence for the column is used.</source>
          <target state="translated">В противном случае,если выражение ORDER BY является столбцом или псевдонимом выражения,являющегося столбцом,то для столбца используется последовательность сверки по умолчанию.</target>
        </trans-unit>
        <trans-unit id="7e53078a08397e14f15e969e1f704be9f2cd8b70" translate="yes" xml:space="preserve">
          <source>Otherwise, if the ORDER BY expression is an alias to an expression that has been assigned a collation sequence using the postfix &lt;a href=&quot;lang_expr#collateop&quot;&gt;COLLATE operator&lt;/a&gt;, then the collation sequence assigned to the aliased expression is used.</source>
          <target state="translated">В противном случае, если выражение ORDER BY является псевдонимом выражения, которому была назначена последовательность сопоставления с помощью постфиксного &lt;a href=&quot;lang_expr#collateop&quot;&gt;оператора COLLATE&lt;/a&gt; , то используется последовательность сопоставления, назначенная выражению с псевдонимом.</target>
        </trans-unit>
        <trans-unit id="16e19790e123dd698bb68d8acfc3c250ddf0f26c" translate="yes" xml:space="preserve">
          <source>Otherwise, if the ORDER BY expression is any other expression, it is evaluated and the returned value used to order the output rows. If the SELECT statement is a simple SELECT, then an ORDER BY may contain any arbitrary expressions. However, if the SELECT is a compound SELECT, then ORDER BY expressions that are not aliases to output columns must be exactly the same as an expression used as an output column.</source>
          <target state="translated">В противном случае,если выражение ORDER BY является любым другим выражением,оно вычисляется и возвращаемое значение используется для упорядочивания выходных строк.Если оператор SELECT (ВЫБОР)является простым SELECT (ВЫБОР),то оператор ORDER BY может содержать любые произвольные выражения.Однако,если оператор SELECT является составным SELECT,то выражения ORDER BY,не являющиеся псевдонимами для выходных столбцов,должны быть точно такими же,как и выражение,используемое в качестве выходного столбца.</target>
        </trans-unit>
        <trans-unit id="74d7943e809a432b89e323d15537e7de75d402f8" translate="yes" xml:space="preserve">
          <source>Otherwise, no affinity is applied and both operands are compared as is.</source>
          <target state="translated">В противном случае сродство не применяется,и оба операнда сравниваются как есть.</target>
        </trans-unit>
        <trans-unit id="ace2ae60f4f3efb9070beb6a2fed407ad7cd8e65" translate="yes" xml:space="preserve">
          <source>Otherwise, r[P2] is set to the sum of r[P1] and r[P3].</source>
          <target state="translated">В противном случае r[P2]устанавливается равным сумме r[P1]и r[P3].</target>
        </trans-unit>
        <trans-unit id="c9d8794c47ac5fbe000cffe629c489a9791ed713" translate="yes" xml:space="preserve">
          <source>Otherwise, the &lt;a href=&quot;datatype3#collation&quot;&gt;BINARY&lt;/a&gt; collation sequence is used.</source>
          <target state="translated">В противном случае используется &lt;a href=&quot;datatype3#collation&quot;&gt;БИНАРНАЯ&lt;/a&gt; последовательность сортировки.</target>
        </trans-unit>
        <trans-unit id="35b896906bdef712969f9e7297c680f9a2e53cd3" translate="yes" xml:space="preserve">
          <source>Otherwise, the BINARY collating function is used for comparison.</source>
          <target state="translated">В противном случае для сравнения используется функция сопоставления BINARY.</target>
        </trans-unit>
        <trans-unit id="638ab872140702484af1c059aebc57de13dbd98b" translate="yes" xml:space="preserve">
          <source>Otherwise, the affinity is NUMERIC.</source>
          <target state="translated">В противном случае,сродство ЧИСЛОВОЕ.</target>
        </trans-unit>
        <trans-unit id="cfc6f8803bf4c712ac864728c4305aa6942d9a6a" translate="yes" xml:space="preserve">
          <source>Otherwise, the value inserted into this field is the file contents for a regular file, or the target of a symbolic link.</source>
          <target state="translated">В противном случае,значение,вставленное в это поле,является содержимым файла для обычного файла,или целью символической ссылки.</target>
        </trans-unit>
        <trans-unit id="cb91e52cc1b3ca8f3f684e2966f8d4c11f3cb0b5" translate="yes" xml:space="preserve">
          <source>Otherwise, this API returns a negative value if P1 refers to an older snapshot than P2, zero if the two handles refer to the same database snapshot, and a positive value if P1 is a newer snapshot than P2.</source>
          <target state="translated">В противном случае,этот API возвращает отрицательное значение,если P1 ссылается на более старый снимок,чем P2,ноль,если два дескриптора ссылаются на один и тот же снимок базы данных,и положительное значение,если P1 является более новым снимок,чем P2.</target>
        </trans-unit>
        <trans-unit id="afebc4d098577eaf408f5312d05f2e55f910ee39" translate="yes" xml:space="preserve">
          <source>Our goal is to make the content you store in SQLite today as easily accessible to your grandchildren as it is to you.</source>
          <target state="translated">Наша цель-сделать контент,который вы храните в SQLite сегодня,таким же легкодоступным для ваших внуков,как и для вас.</target>
        </trans-unit>
        <trans-unit id="3edd7f9a4b0d8d87dc9885a06cb59a66ad8766a5" translate="yes" xml:space="preserve">
          <source>Out of memory (OOM) error conditions generate error logging events with the SQLITE_NOMEM error code and a message that says how many bytes of memory were requested by the failed allocation.</source>
          <target state="translated">Ошибочные условия Out of memory (OOM)генерируют события регистрации ошибок с кодом ошибки SQLITE_NOMEM и сообщением о том,сколько байт памяти было запрошено при неудачном выделении.</target>
        </trans-unit>
        <trans-unit id="3eb43b3eb70e7d12a47e5820876f3c296dc05bc2" translate="yes" xml:space="preserve">
          <source>Out-of-memory tests</source>
          <target state="translated">тесты вне памяти</target>
        </trans-unit>
        <trans-unit id="c1bf191f6ccc359ad8a3c05c295f7fe8cef84ae3" translate="yes" xml:space="preserve">
          <source>Outlandish Recursive Query Examples</source>
          <target state="translated">Примеры рекурсивных запросов из других стран</target>
        </trans-unit>
        <trans-unit id="4bed336194a9a5c86b6a734f03b3570d2aae1a68" translate="yes" xml:space="preserve">
          <source>Output</source>
          <target state="translated">Output</target>
        </trans-unit>
        <trans-unit id="1bd1112bbbb687e4d808e79cb404cc3ec423a23a" translate="yes" xml:space="preserve">
          <source>Output Change</source>
          <target state="translated">Выход Изменение выхода</target>
        </trans-unit>
        <trans-unit id="0c51e370c031f37870509dc46422ce61ca6e1f16" translate="yes" xml:space="preserve">
          <source>Output columns from the index_info pragma are as follows:</source>
          <target state="translated">Выходные столбцы из прагмы index_info следующие:</target>
        </trans-unit>
        <trans-unit id="8383ea0f1fb51fe84444b17104e0dd18b8f3f3b4" translate="yes" xml:space="preserve">
          <source>Output columns from the index_list pragma are as follows:</source>
          <target state="translated">Выходные столбцы из прагмы index_list выглядят следующим образом:</target>
        </trans-unit>
        <trans-unit id="bc6e58f2bacd5891df7b631d05c18328e75e62f4" translate="yes" xml:space="preserve">
          <source>Output columns from the index_xinfo pragma are as follows:</source>
          <target state="translated">Выходные столбцы из прагмы index_xinfo следующие:</target>
        </trans-unit>
        <trans-unit id="d1088854d972e4ceb1796db8756ad3486790779d" translate="yes" xml:space="preserve">
          <source>Output infinity as 1e999 in the &quot;.dump&quot; command of the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt;.</source>
          <target state="translated">Выведите бесконечность как 1e999 в команде &quot;.dump&quot; &lt;a href=&quot;cli&quot;&gt;оболочки командной строки&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="17e008cf652984308f7573376fc6932528a013cf" translate="yes" xml:space="preserve">
          <source>Output rows can be returned to the application as each small sort completes, and well before the table scan is complete.</source>
          <target state="translated">Выходные строки могут быть возвращены в приложение по мере завершения каждой небольшой сортировки,а также задолго до завершения сканирования таблицы.</target>
        </trans-unit>
        <trans-unit id="b785807667b898e4c7f09b3ee44afccba51a9945" translate="yes" xml:space="preserve">
          <source>Outputs an SQL script to create an RBU database which, if used to update database t1.db, patches it so that its contents are identical to that of database t2.db.</source>
          <target state="translated">Выводит SQL-скрипт для создания базы данных RBU,которая,если используется для обновления базы данных t1.db,исправляет ее так,чтобы ее содержимое было идентично содержимому базы данных t2.db.</target>
        </trans-unit>
        <trans-unit id="25a352aa2e3e3671bf4d083fdd886df3d305e826" translate="yes" xml:space="preserve">
          <source>Over 100 separate source files are concatenated into a single large files of C-code named &quot;sqlite3.c&quot; and called &quot;the amalgamation&quot;. The amalgamation contains everything an application needs to embed SQLite. The amalgamation file is more than 220,000 lines long and over 7.5 megabytes in size (as of 2018-11-24).</source>
          <target state="translated">Более 100 отдельных исходных файлов объединены в один большой файл C-кода,названный &quot;sqlite3.c&quot; и названный &quot;слияние&quot;.Слияние содержит все,что необходимо приложению для встраивания SQLite.Файл слияния имеет длину более 220 000 строк и размер более 7,5 мегабайт (по состоянию на 2018-11-24 гг.).</target>
        </trans-unit>
        <trans-unit id="6f2a6be035cf5a02d68b5e9127156e17d6b333b6" translate="yes" xml:space="preserve">
          <source>Overflow page</source>
          <target state="translated">Страница переполнения</target>
        </trans-unit>
        <trans-unit id="26c78f2170e31758038f3bb0a52b3d4d222f938f" translate="yes" xml:space="preserve">
          <source>Overload A Function For A Virtual Table</source>
          <target state="translated">Перегрузка функции для виртуальной таблицы</target>
        </trans-unit>
        <trans-unit id="007c99e63ddccff493d60c3cf9732ab7365f22fb" translate="yes" xml:space="preserve">
          <source>Override other operating system interfaces such as calls to obtain Zulu or local time.</source>
          <target state="translated">Переопределить другие интерфейсы операционной системы,такие как звонки для получения Zulu или местного времени.</target>
        </trans-unit>
        <trans-unit id="0efc2e6be4c23b9a513d7ce0dcff8ed80e8912e7" translate="yes" xml:space="preserve">
          <source>Overview</source>
          <target state="translated">Overview</target>
        </trans-unit>
        <trans-unit id="46880b89366d47b3659d0ee6bf4c167da19b6968" translate="yes" xml:space="preserve">
          <source>Overview Documents</source>
          <target state="translated">Обзор документов</target>
        </trans-unit>
        <trans-unit id="04e78b5fd19361d42f0880283437d8302448583e" translate="yes" xml:space="preserve">
          <source>Overwrite if already exists?</source>
          <target state="translated">Перезапись,если она уже существует?</target>
        </trans-unit>
        <trans-unit id="9ada09a735411e9de190da46810d6bab2f578abd" translate="yes" xml:space="preserve">
          <source>Overwriting a database file with another without also deleting any hot journal associated with the original database.</source>
          <target state="translated">Перезапись файла базы данных другим файлом без удаления горячего журнала,связанного с исходной базой данных.</target>
        </trans-unit>
        <trans-unit id="bcfd518ec9aac14be70cb40d43cadb15da01978e" translate="yes" xml:space="preserve">
          <source>Overwritting a journal file with a different journal file.</source>
          <target state="translated">Перезапись файла журнала другим файлом.</target>
        </trans-unit>
        <trans-unit id="f6202fa6f9727ecd28cda41b586c4f17db3f9662" translate="yes" xml:space="preserve">
          <source>P (cost: 7.71)</source>
          <target state="translated">P (стоимость:7,71)</target>
        </trans-unit>
        <trans-unit id="80d8eec7d81f7a0324484c1ac454ead7da895c4f" translate="yes" xml:space="preserve">
          <source>P1 can be either an ordinary table or a virtual table. There used to be a separate OP_VRowid opcode for use with virtual tables, but this one opcode now works for both table types.</source>
          <target state="translated">P1 может быть как обычным столом,так и виртуальным.Раньше был отдельный опкод OP_VRowid для использования с виртуальными таблицами,но теперь этот опкод работает для обоих типов таблиц.</target>
        </trans-unit>
        <trans-unit id="84bf22352f6da5dd236d64694b38dd6696254f42" translate="yes" xml:space="preserve">
          <source>P1 contains the address of the memory cell that contains the first memory cell in an array of values used as arguments to the sub-program. P2 contains the address to jump to if the sub-program throws an IGNORE exception using the RAISE() function. Register P3 contains the address of a memory cell in this (the parent) VM that is used to allocate the memory required by the sub-vdbe at runtime.</source>
          <target state="translated">P1 содержит адрес ячейки памяти,которая содержит первую ячейку памяти в массиве значений,используемых в качестве аргументов для подпрограммы.P2 содержит адрес,на который нужно перейти,если подпрограмма выбрасывает исключение IGNORE с помощью функции RAISE().Регистр P3 содержит адрес ячейки памяти в этой (родительской)ВМ,которая используется для выделения памяти,требуемой подпрограмме во время выполнения.</target>
        </trans-unit>
        <trans-unit id="bbb7c16489d0b290a1227473f0d5f4da2b7691cc" translate="yes" xml:space="preserve">
          <source>P1 is a 32-bit bitmask indicating whether or not each argument to the function was determined to be constant at compile time. If the first argument was constant then bit 0 of P1 is set. This is used to determine whether meta data associated with a user function argument using the sqlite3_set_auxdata() API may be safely retained until the next invocation of this opcode.</source>
          <target state="translated">P1-это 32-битная битовая маска,указывающая,был ли каждый аргумент функции определен как постоянный во время компиляции.Если первый аргумент был константным,то устанавливается бит 0 из P1.Это используется для определения того,могут ли мета-данные,связанные с аргументом пользовательской функции с помощью API sqlite3_set_auxdata(),быть безопасно сохранены до следующего вызова этого опкода.</target>
        </trans-unit>
        <trans-unit id="ce2db3e033bf07aaa2aac0e6df082aac39175194" translate="yes" xml:space="preserve">
          <source>P1 is a boolean flag. If it is set to true and the xUpdate call is successful, then the value returned by sqlite3_last_insert_rowid() is set to the value of the rowid for the row just inserted.</source>
          <target state="translated">P1-это булевский флаг.Если он установлен в true и вызов xUpdate выполнен успешно,то значение,возвращаемое функцией sqlite3_last_insert_rowid(),устанавливается в значение rowid только что вставленного ряда.</target>
        </trans-unit>
        <trans-unit id="ab3846ffb469791c7c875a7d6e64699955c09eb4" translate="yes" xml:space="preserve">
          <source>P1 is a cursor opened using &lt;a href=&quot;opcode#VOpen&quot;&gt;VOpen&lt;/a&gt;. P2 is an address to jump to if the filtered result set is empty.</source>
          <target state="translated">P1 - это курсор, открытый с помощью &lt;a href=&quot;opcode#VOpen&quot;&gt;VOpen&lt;/a&gt; . P2 - это адрес для перехода, если отфильтрованный набор результатов пуст.</target>
        </trans-unit>
        <trans-unit id="99e16bb5285cdf74213efcd911112d0254cc888f" translate="yes" xml:space="preserve">
          <source>P1 is a register in the root frame of this VM (the root frame is different from the current frame if this instruction is being executed within a sub-program). Set the value of register P1 to the maximum of its current value and the value in register P2.</source>
          <target state="translated">P1-это регистр в корневом фрейме этой ВМ (корневой фрейм отличается от текущего фрейма,если эта инструкция выполняется в подпрограмме).Установите значение регистра P1 в максимальное из его текущего значения и значение в регистре P2.</target>
        </trans-unit>
        <trans-unit id="17a3ab4e084c4ae225f4e64b76426d06344fe074" translate="yes" xml:space="preserve">
          <source>P1 is a sorter cursor. If the sequence counter is currently zero, jump to P2. Regardless of whether or not the jump is taken, increment the the sequence value.</source>
          <target state="translated">P1-это курсор сортировки.Если счетчик последовательности на данный момент равен нулю,перейдите к P2.Независимо от того,выполнен скачок или нет,увеличивайте значение последовательности.</target>
        </trans-unit>
        <trans-unit id="f9ac2a8e79b4d0f70e9cfe08c3c644453f11b20b" translate="yes" xml:space="preserve">
          <source>P1 is a sorter cursor. This instruction compares a prefix of the record blob in register P3 against a prefix of the entry that the sorter cursor currently points to. Only the first P4 fields of r[P3] and the sorter record are compared.</source>
          <target state="translated">P1-это курсор сортировки.Эта инструкция сравнивает префикс блока записи в регистре P3 с префиксом записи,на которую в данный момент указывает курсор сортировщика.Сравниваются только первые поля P4 регистра r[P3]и запись сортировщика.</target>
        </trans-unit>
        <trans-unit id="d14bcdd4246c685563dd290988090774223c445f" translate="yes" xml:space="preserve">
          <source>P1 is an open index cursor and P3 is a cursor on the corresponding table. This opcode does a deferred seek of the P3 table cursor to the row that corresponds to the current row of P1.</source>
          <target state="translated">P1-открытый указательный курсор,а P3-курсор на соответствующую таблицу.Данный опкод выполняет отложенный поиск курсора P3 таблицы к строке,соответствующей текущей строке P1.</target>
        </trans-unit>
        <trans-unit id="86c484d0a40d444e4dc0b4d443a06296772d4391" translate="yes" xml:space="preserve">
          <source>P1 is the index of a cursor open on an SQL table btree (with integer keys). If register P3 does not contain an integer or if P1 does not contain a record with rowid P3 then jump immediately to P2. Or, if P2 is 0, raise an SQLITE_CORRUPT error. If P1 does contain a record with rowid P3 then leave the cursor pointing at that record and fall through to the next instruction.</source>
          <target state="translated">P1-это индекс курсора,открытого в дереве таблицы SQL (с целочисленными ключами).Если регистр P3 не содержит целого числа или если P1 не содержит записи с rowid P3,то сразу же переходите к P2.Или,если P2 равен 0,поднять ошибку SQLITE_CORRUPT.Если P1 содержит запись с rowid P3,то оставьте курсор,наведенный на эту запись,и перейдите к следующей команде.</target>
        </trans-unit>
        <trans-unit id="be17250db9325023bb6814cabfbf543abfa5ba67" translate="yes" xml:space="preserve">
          <source>P1 is the index of a cursor open on an SQL table btree (with integer keys). P3 is an integer rowid. If P1 does not contain a record with rowid P3 then jump immediately to P2. Or, if P2 is 0, raise an SQLITE_CORRUPT error. If P1 does contain a record with rowid P3 then leave the cursor pointing at that record and fall through to the next instruction.</source>
          <target state="translated">P1-это индекс курсора,открытого в дереве таблицы SQL (с целочисленными ключами).P3-это целочисленный ряд.Если P1 не содержит записи с rowid P3,то сразу переходите к P2.Или,если P2 равен 0,поднять ошибку SQLITE_CORRUPT.Если P1 содержит запись с rowid P3,то оставьте курсор,указывающий на эту запись,и перейдите к следующей инструкции.</target>
        </trans-unit>
        <trans-unit id="35a6c564ff4d581152e9a1f876d9eb72d2af48f4" translate="yes" xml:space="preserve">
          <source>P1 is the index of the database file on which the transaction is started. Index 0 is the main database file and index 1 is the file used for temporary tables. Indices of 2 or more are used for attached databases.</source>
          <target state="translated">P1-это индекс файла базы данных,по которому начинается транзакция.Индекс 0-основной файл БД,а индекс 1-файл,используемый для временных таблиц.Индексы 2 и более используются для прикрепленных баз данных.</target>
        </trans-unit>
        <trans-unit id="b9198f15e439eca54714083fc1fc6d108cc42915" translate="yes" xml:space="preserve">
          <source>P1 is the index of the database in sqlite3.aDb[] of the database on which the lock is acquired. A readlock is obtained if P3==0 or a write lock if P3==1.</source>
          <target state="translated">P1-это индекс БД в sqlite3.aDb[]БД,на которую получен замок.Блокировка чтения получается,если P3==0,или блокировка записи,если P3==1.</target>
        </trans-unit>
        <trans-unit id="1fcd6d3417638283143894ac28a56d5766856870" translate="yes" xml:space="preserve">
          <source>P1 is the memory location that is the accumulator for an aggregate or window function. Execute the finalizer function for an aggregate and store the result in P1.</source>
          <target state="translated">P1-это ячейка памяти,которая является аккумулятором для агрегатной или оконной функции.Выполните функцию финализатора для агрегата и сохраните результат в P1.</target>
        </trans-unit>
        <trans-unit id="9564a9171b616f080f45aeeeeb50a759cf2543a9" translate="yes" xml:space="preserve">
          <source>P1 is the result code returned by sqlite3_exec(), sqlite3_reset(), or sqlite3_finalize(). For a normal halt, this should be SQLITE_OK (0). For errors, it can be some other value. If P1!=0 then P2 will determine whether or not to rollback the current transaction. Do not rollback if P2==OE_Fail. Do the rollback if P2==OE_Rollback. If P2==OE_Abort, then back out all changes that have occurred during this execution of the VDBE, but do not rollback the transaction.</source>
          <target state="translated">P1-это код результата,возвращаемый функциями sqlite3_exec(),sqlite3_reset()или sqlite3_finalize().Для нормальной остановки это должен быть SQLITE_OK (0).Для ошибок это может быть какое-то другое значение.Если P1!=0,то P2 будет определять,откатывать ли текущую транзакцию.Не откатывать,если P2==OE_Fail.Делать откат,если P2==OE_Rollback.Если P2==OE_Abort,то откатываем все изменения,произошедшие во время выполнения VDBE,но не откатываем транзакцию.</target>
        </trans-unit>
        <trans-unit id="dcea1649c96ae08171a24407e2519d717994383c" translate="yes" xml:space="preserve">
          <source>P1 must be a valid b-tree cursor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05f5c83f3b169019c8e82a0eaf11fb45a16518b4" translate="yes" xml:space="preserve">
          <source>P1 must be a valid b-tree cursor. P2 must be a boolean value, either 0 or 1.</source>
          <target state="translated">P1 должен быть действительным курсором b-дерева.P2 должен быть булевым значением,либо 0,либо 1.</target>
        </trans-unit>
        <trans-unit id="05f600aab9b18602c22139c66a31c7458bbfad3f" translate="yes" xml:space="preserve">
          <source>P1 must not be pseudo-table. It has to be a real table with multiple rows.</source>
          <target state="translated">P1 не должен быть псевдо-таблицей.Это должна быть настоящая таблица с несколькими строками.</target>
        </trans-unit>
        <trans-unit id="f93c0802a39924cff1b00e9015e9aa33f54938f7" translate="yes" xml:space="preserve">
          <source>P2 contains the root-page of the table to lock.</source>
          <target state="translated">P2 содержит корневую страницу таблицы для блокировки.</target>
        </trans-unit>
        <trans-unit id="9ce77455e05f3264d5bb123f4f714e82dd11c666" translate="yes" xml:space="preserve">
          <source>P2 is a register that holds the name of a virtual table in database P1. Call the xCreate method for that table.</source>
          <target state="translated">P2-это регистр,содержащий имя виртуальной таблицы в базе данных P1.Вызовите метод xCreate для этой таблицы.</target>
        </trans-unit>
        <trans-unit id="be0d49dbe18b5a0cf012a9f8a24be16667dd4219" translate="yes" xml:space="preserve">
          <source>P2 is the column number for the argument to the sqlite_offset() function. This opcode does not use P2 itself, but the P2 value is used by the code generator. The P1, P2, and P3 operands to this opcode are the same as for &lt;a href=&quot;opcode#Column&quot;&gt;Column&lt;/a&gt;.</source>
          <target state="translated">P2 - это номер столбца для аргумента функции sqlite_offset (). Этот код операции не использует сам P2, но значение P2 используется генератором кода. Операнды P1, P2 и P3 для этого кода операции такие же, как для &lt;a href=&quot;opcode#Column&quot;&gt;столбца&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b9b9294fefdd80f907d449f8b026a50941891877" translate="yes" xml:space="preserve">
          <source>P2 is the number of arguments that the step function takes and P4 is a pointer to the FuncDef for this function. The P2 argument is not used by this opcode. It is only there to disambiguate functions that can take varying numbers of arguments. The P4 argument is only needed for the case where the step function was not previously called.</source>
          <target state="translated">P2-это количество аргументов,которое принимает шаговая функция,а P4-указатель на FuncDef для этой функции.P2 аргумент не используется данным опкодом.Он используется только для разделения функций,которые могут принимать различное количество аргументов.Аргумент P4 нужен только в том случае,если функция шага ранее не вызывалась.</target>
        </trans-unit>
        <trans-unit id="3bd7cc65ffe04a6cbb96320f3dfb05bef13a6003" translate="yes" xml:space="preserve">
          <source>P2 is the number of columns in the ephemeral table. The cursor points to a BTree table if P4==0 and to a BTree index if P4 is not 0. If P4 is not NULL, it points to a KeyInfo structure that defines the format of keys in the index.</source>
          <target state="translated">P2-это количество колонок в эфемерной таблице.Курсор указывает на таблицу BTree,если P4==0,и на индекс BTree,если P4 не 0.Если P4 не NULL,он указывает на структуру KeyInfo,которая определяет формат ключей в индексе.</target>
        </trans-unit>
        <trans-unit id="d43bd5b8560de02b50e24570db7ff928128725ba" translate="yes" xml:space="preserve">
          <source>P2=='A' &amp;rarr; BLOB</source>
          <target state="translated">P2 == 'A' &amp;rarr; BLOB</target>
        </trans-unit>
        <trans-unit id="549df038ddec37fc17c85e7dccfd3d0f7eac490b" translate="yes" xml:space="preserve">
          <source>P2=='B' &amp;rarr; TEXT</source>
          <target state="translated">P2 == 'B' &amp;rarr; ТЕКСТ</target>
        </trans-unit>
        <trans-unit id="3eb880697f1f955293bf5968bad5752ba9e6c36d" translate="yes" xml:space="preserve">
          <source>P2=='C' &amp;rarr; NUMERIC</source>
          <target state="translated">P2 == 'C' &amp;rarr; ЧИСЛО</target>
        </trans-unit>
        <trans-unit id="11082965a2f3470ce5a9187e0cfe05f51096d4b9" translate="yes" xml:space="preserve">
          <source>P2=='D' &amp;rarr; INTEGER</source>
          <target state="translated">P2 == 'D' &amp;rarr; ЦЕЛОЕ</target>
        </trans-unit>
        <trans-unit id="8d3f310a6285b7cb02844a9cd70fd245db85edd2" translate="yes" xml:space="preserve">
          <source>P2=='E' &amp;rarr; REAL</source>
          <target state="translated">P2 == 'E' &amp;rarr; REAL</target>
        </trans-unit>
        <trans-unit id="12d088ae7e89df349fe37f3d37cf8b1ca4c09b3a" translate="yes" xml:space="preserve">
          <source>P3 = P2 || P1</source>
          <target state="translated">P3=P2 || P1</target>
        </trans-unit>
        <trans-unit id="3a22c873357ee7f56f10d2e038f148e48353f460" translate="yes" xml:space="preserve">
          <source>P3 is the number of fields in the records that will be stored by the pseudo-table.</source>
          <target state="translated">P3-это количество полей в записях,которые будут храниться в псевдотаблице.</target>
        </trans-unit>
        <trans-unit id="fa5df0db7433454e4380316b1e3b9bfe2adbea6f" translate="yes" xml:space="preserve">
          <source>P4 contains a pointer to the name of the table being locked. This is only used to generate an error message if the lock cannot be obtained.</source>
          <target state="translated">P4 содержит указатель на имя блокируемой таблицы.Он используется только для генерации сообщения об ошибке,если блокировка не может быть получена.</target>
        </trans-unit>
        <trans-unit id="3f5b2dbcd76db7494d70506eccc181bd880869ce" translate="yes" xml:space="preserve">
          <source>P4 is a KeyInfo structure that defines collating sequences and sort orders for the comparison. The permutation applies to registers only. The KeyInfo elements are used sequentially.</source>
          <target state="translated">P4-это структура KeyInfo,которая определяет коллекцию последовательностей и сортирует приказы для сравнения.Перестановка относится только к регистрам.Элементы KeyInfo используются последовательно.</target>
        </trans-unit>
        <trans-unit id="6e63a14f434c9d816b03aebb21b25ccfa99f1b42" translate="yes" xml:space="preserve">
          <source>P4 is a pointer to a 64-bit floating point value. Write that value into register P2.</source>
          <target state="translated">P4 является указателем на 64-битное значение с плавающей точкой.Запишите это значение в регистр P2.</target>
        </trans-unit>
        <trans-unit id="006b4d737b2fe81d322403675fc01054f9eaddfd" translate="yes" xml:space="preserve">
          <source>P4 is a pointer to a 64-bit integer value. Write that value into register P2.</source>
          <target state="translated">P4 является указателем на 64-битное целое значение.Запишите это значение в регистр P2.</target>
        </trans-unit>
        <trans-unit id="93432616419a7361a72b061b65e02339a1738910" translate="yes" xml:space="preserve">
          <source>P4 is a pointer to a CollSeq object. If the next call to a user function or aggregate calls sqlite3GetFuncCollSeq(), this collation sequence will be returned. This is used by the built-in min(), max() and nullif() functions.</source>
          <target state="translated">P4-это указатель на объект CollSeq.При следующем вызове пользовательской функции или совокупном вызове sqlite3GetFuncCollSeq()будет возвращена эта последовательность сверки.Это используется встроенными функциями min(),max()и nullif().</target>
        </trans-unit>
        <trans-unit id="d80240e61957d32e7437d69346afb9ca3c15eca9" translate="yes" xml:space="preserve">
          <source>P4 is a pointer to a virtual table object, an sqlite3_vtab structure. P1 is a cursor number. This opcode opens a cursor to the virtual table and stores that cursor in P1.</source>
          <target state="translated">P4-это указатель на объект виртуальной таблицы,структуру sqlite3_vtab.P1-номер курсора.Этот опкод открывает курсор к виртуальной таблице и сохраняет этот курсор в P1.</target>
        </trans-unit>
        <trans-unit id="0dbffabc54d98d6801900e6ab537de5e2bcdd805" translate="yes" xml:space="preserve">
          <source>P4 is a pointer to a virtual table object, an sqlite3_vtab structure. This opcode invokes the corresponding xRename method. The value in register P1 is passed as the zName argument to the xRename method.</source>
          <target state="translated">P4-это указатель на объект виртуальной таблицы,структуру sqlite3_vtab.Этот опкод вызывает соответствующий метод xRename.Значение в регистре P1 передаётся в качестве аргумента zName методу xRename.</target>
        </trans-unit>
        <trans-unit id="8c184e85a48a476ce012fdb53452bec6f0cb31bc" translate="yes" xml:space="preserve">
          <source>P4 is a pointer to a virtual table object, an sqlite3_vtab structure. This opcode invokes the corresponding xUpdate method. P2 values are contiguous memory cells starting at P3 to pass to the xUpdate invocation. The value in register (P3+P2-1) corresponds to the p2th element of the argv array passed to xUpdate.</source>
          <target state="translated">P4-это указатель на объект виртуальной таблицы,структуру sqlite3_vtab.Данный опкод вызывает соответствующий метод xUpdate.Значения P2 являются смежными ячейками памяти,начинающимися от P3 для перехода к вызову xUpdate.Значение в регистре (P3+P2-1)соответствует p2-му элементу массива argv,переданному в xUpdate.</target>
        </trans-unit>
        <trans-unit id="ad1bbf355e84d3c7a49f4b2d106cdd6317b07ee3" translate="yes" xml:space="preserve">
          <source>P4 is a pointer to the VM containing the trigger program.</source>
          <target state="translated">P4-это указатель на ВМ,содержащую триггерную программу.</target>
        </trans-unit>
        <trans-unit id="f47594ef27452803fbd06eb33f15569fa2ff24ae" translate="yes" xml:space="preserve">
          <source>P4 is a string that is P2 characters long. The N-th character of the string indicates the column affinity that should be used for the N-th memory cell in the range.</source>
          <target state="translated">P4-это строка длиной в 2 символа.N-ый символ строки указывает на сродство столбца,которое должно использоваться для N-ой ячейки памяти в диапазоне.</target>
        </trans-unit>
        <trans-unit id="990f075b203cf5ad046ffef4a8c3f52f5d8e8021" translate="yes" xml:space="preserve">
          <source>P4 is always of type P4_ADVANCE. The function pointer points to sqlite3BtreeNext().</source>
          <target state="translated">P4 всегда имеет тип P4_ADVANCE.Указатель функции указывает на sqlite3BtreeNext().</target>
        </trans-unit>
        <trans-unit id="33ef9db58085779c3fa7810a9ac7b841027b65e6" translate="yes" xml:space="preserve">
          <source>P4 is always of type P4_ADVANCE. The function pointer points to sqlite3BtreePrevious().</source>
          <target state="translated">P4 всегда имеет тип P4_ADVANCE.Указатель функции указывает на sqlite3BtreePrevious().</target>
        </trans-unit>
        <trans-unit id="d1b9c8ecf53ced9f246c4b6e555cd6111c1ca23e" translate="yes" xml:space="preserve">
          <source>P4 is either NULL or a string that was generated by the xBestIndex method of the module. The interpretation of the P4 string is left to the module implementation.</source>
          <target state="translated">P4-это либо NULL,либо строка,сгенерированная методом xBestIndex модуля.Интерпретация строки P4 остаётся в реализации модуля.</target>
        </trans-unit>
        <trans-unit id="c28c1dcafe0312975199fcb1fcfbb17e24dd7d0c" translate="yes" xml:space="preserve">
          <source>P4 is the name of a virtual table in database P1. Call the xDestroy method of that table.</source>
          <target state="translated">P4-это имя виртуальной таблицы в базе данных P1.Вызовите метод xDestroy этой таблицы.</target>
        </trans-unit>
        <trans-unit id="b1c200e3bc2517ade0a0775a576b9a6ce0d06b98" translate="yes" xml:space="preserve">
          <source>P4 may be a pointer to an sqlite3_vtab structure. If so, call the xBegin method for that table.</source>
          <target state="translated">P4 может быть указателем на структуру sqlite3_vtab.Если да,то вызовите метод xBegin для этой таблицы.</target>
        </trans-unit>
        <trans-unit id="946a7239230e3ec0a9c66885447aaf26ad8bc930" translate="yes" xml:space="preserve">
          <source>P4 may be a string that is P2 characters long. The N-th character of the string indicates the column affinity that should be used for the N-th field of the index key.</source>
          <target state="translated">P4 может быть строкой длиной в 2 символа.N-ый символ строки указывает на сродство столбца,которое должно быть использовано для N-ого поля индексного ключа.</target>
        </trans-unit>
        <trans-unit id="69adfac261137322671a1ca5cef4f8a650bcfbae" translate="yes" xml:space="preserve">
          <source>P4 may be an array of integers (type P4_INTARRAY) containing one entry for each column in the P3 table. If array entry a(i) is non-zero, then reading column a(i)-1 from cursor P3 is equivalent to performing the deferred seek and then reading column i from P1. This information is stored in P3 and used to redirect reads against P3 over to P1, thus possibly avoiding the need to seek and read cursor P3.</source>
          <target state="translated">P4 может быть массивом целых чисел (тип P4_INTARRAY),содержащим по одной записи для каждого столбца таблицы P3.Если запись в массиве a(i)ненулевая,то чтение столбца a(i)-1 из курсора P3 эквивалентно выполнению отложенного поиска,а затем чтению столбца i из P1.Эта информация хранится в P3 и используется для перенаправления чтения против P3 на P1,что,возможно,позволяет избежать необходимости искать и читать курсор P3.</target>
        </trans-unit>
        <trans-unit id="2b3aae431e84b9e296011557b13fc95c59d8a3fe" translate="yes" xml:space="preserve">
          <source>P4 points to a blob of data P1 bytes long. Store this blob in register P2.</source>
          <target state="translated">P4 указывает на блок данных P1 байт длиной.Хранить этот блок в регистре P2.</target>
        </trans-unit>
        <trans-unit id="5f1f77c01d77787acda0ee06f04f3dd3dab581c9" translate="yes" xml:space="preserve">
          <source>P4 points to a nul terminated UTF-8 string. This opcode is transformed into a &lt;a href=&quot;opcode#String&quot;&gt;String&lt;/a&gt; opcode before it is executed for the first time. During this transformation, the length of string P4 is computed and stored as the P1 parameter.</source>
          <target state="translated">P4 указывает на строку UTF-8 с нулевым завершением. Этот код операции преобразуется в код операции &lt;a href=&quot;opcode#String&quot;&gt;String&lt;/a&gt; перед первым выполнением. Во время этого преобразования длина строки P4 вычисляется и сохраняется как параметр P1.</target>
        </trans-unit>
        <trans-unit id="8c8ae2d7e0dfc4268ff56cfc9e2e47a67fc1ddaf" translate="yes" xml:space="preserve">
          <source>P5 is a value between 0 and 4, inclusive, that modifies the P4 string.</source>
          <target state="translated">P5-это значение между 0 и 4,включительно,которое изменяет строку P4.</target>
        </trans-unit>
        <trans-unit id="e03c8fcb835da321a7966f8a1cfc9fb80046f7b0" translate="yes" xml:space="preserve">
          <source>P5 is the error actions (OE_Replace, OE_Fail, OE_Ignore, etc) to apply in the case of a constraint failure on an insert or update.</source>
          <target state="translated">P5-это действия по ошибке (OE_Replace,OE_Fail,OE_Ignore и т.д.)для применения в случае отказа ограничения на вставку или обновление.</target>
        </trans-unit>
        <trans-unit id="b092db6b7249be33e50e9f2a75c65696bf56d25e" translate="yes" xml:space="preserve">
          <source>P5 ought to be set on every call to this opcode. However, there are places in the code generator will release registers before their are used, under the (valid) assumption that the registers will not be reallocated for some other purpose before they are used and hence are safe to release.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d23183b7ef6b3cfee6722e9cab664f9eba24c080" translate="yes" xml:space="preserve">
          <source>PARTITION</source>
          <target state="translated">PARTITION</target>
        </trans-unit>
        <trans-unit id="7c423f3264effc4f744de4e6255ff034137bcc1e" translate="yes" xml:space="preserve">
          <source>PASSIVE</source>
          <target state="translated">PASSIVE</target>
        </trans-unit>
        <trans-unit id="418f304013689ba52fc7c27eebb7dcb9d2ced563" translate="yes" xml:space="preserve">
          <source>PDF - Portable Document Format from Adobe</source>
          <target state="translated">PDF-Portable Document Format от Adobe</target>
        </trans-unit>
        <trans-unit id="0a7b38b716933a39c0bca66f229cd6d52f0c1271" translate="yes" xml:space="preserve">
          <source>PENDING</source>
          <target state="translated">PENDING</target>
        </trans-unit>
        <trans-unit id="5a61e634ec49d3919b83a13434809a009040ffa1" translate="yes" xml:space="preserve">
          <source>PLAN</source>
          <target state="translated">PLAN</target>
        </trans-unit>
        <trans-unit id="4b01f0d6c5bf45bcaa85e117787de16b76894b18" translate="yes" xml:space="preserve">
          <source>POSIX locking style. This is the default locking style and the style used by other (non Mac OS X) Unixes. Locks are obtained and released using the fcntl() system call.</source>
          <target state="translated">Стиль блокировки POSIX.Это стиль блокировки по умолчанию и стиль,используемый другими (не Mac OS X)Unixes.Блокировки получаются и освобождаются с помощью системного вызова fcntl().</target>
        </trans-unit>
        <trans-unit id="304e41f1b7440f605b6d901a3f56679fe5127675" translate="yes" xml:space="preserve">
          <source>PPT - Microsoft PowerPoint presentations</source>
          <target state="translated">PPT-презентации Microsoft PowerPoint</target>
        </trans-unit>
        <trans-unit id="eb3b3e1144fc0ba039acb3375dbf811550aeb6d8" translate="yes" xml:space="preserve">
          <source>PRAGMA</source>
          <target state="translated">PRAGMA</target>
        </trans-unit>
        <trans-unit id="2031386335ef51b174ad3b83ba1c813522943aeb" translate="yes" xml:space="preserve">
          <source>PRAGMA Statements</source>
          <target state="translated">заявления PRAGMA</target>
        </trans-unit>
        <trans-unit id="dd8e7015522cfd4dcf823317fdfa144e1ffa8793" translate="yes" xml:space="preserve">
          <source>PRAGMA application_id</source>
          <target state="translated">PRAGMA application_id</target>
        </trans-unit>
        <trans-unit id="4272fe5aa2578d44c85ef586cbdb481255d6ef40" translate="yes" xml:space="preserve">
          <source>PRAGMA auto_vacuum</source>
          <target state="translated">PRAGMA auto_vacuum</target>
        </trans-unit>
        <trans-unit id="ecdb75c7d78bb2d218243fd805db4a0952130227" translate="yes" xml:space="preserve">
          <source>PRAGMA automatic_index</source>
          <target state="translated">PRAGMA automatic_index</target>
        </trans-unit>
        <trans-unit id="06f21794e50e9014cbc68dddc08b0afe728a2339" translate="yes" xml:space="preserve">
          <source>PRAGMA busy_timeout</source>
          <target state="translated">PRAGMA busy_timeout</target>
        </trans-unit>
        <trans-unit id="0079a2a1c563d3a80935f663efd9c2f3f214bd31" translate="yes" xml:space="preserve">
          <source>PRAGMA cache_size</source>
          <target state="translated">размер кэша PRAGMA</target>
        </trans-unit>
        <trans-unit id="53830be86cc01d9861a99c96b4baf9389520d439" translate="yes" xml:space="preserve">
          <source>PRAGMA cache_spill</source>
          <target state="translated">PRAGMA cache_spill</target>
        </trans-unit>
        <trans-unit id="c62c55dc2230d9ef14955c77928155e6ec4c7ae3" translate="yes" xml:space="preserve">
          <source>PRAGMA case_sensitive_like</source>
          <target state="translated">PRAGMA case_sensitive_like</target>
        </trans-unit>
        <trans-unit id="629aac38c33c9e2128ff55cc2623e94247525dd5" translate="yes" xml:space="preserve">
          <source>PRAGMA cell_size_check</source>
          <target state="translated">PRAGMA cell_size_check</target>
        </trans-unit>
        <trans-unit id="f7a6fea31875d2709fc8636382fa71e3e405a8bd" translate="yes" xml:space="preserve">
          <source>PRAGMA checkpoint_fullfsync</source>
          <target state="translated">PRAGMA контрольно-пропускной пункт_fullfsync</target>
        </trans-unit>
        <trans-unit id="c3bb771e91f755dbbaf486313dfb86863abb68c6" translate="yes" xml:space="preserve">
          <source>PRAGMA collation_list</source>
          <target state="translated">PRAGMA collation_list</target>
        </trans-unit>
        <trans-unit id="03029df867e6189d3cb8be071de311b5adc094ca" translate="yes" xml:space="preserve">
          <source>PRAGMA command syntax</source>
          <target state="translated">синтаксис команд PRAGMA</target>
        </trans-unit>
        <trans-unit id="41b472d1fbef46bb9f050319914604b6fc2ba68d" translate="yes" xml:space="preserve">
          <source>PRAGMA compile_options</source>
          <target state="translated">параметры PRAGMA</target>
        </trans-unit>
        <trans-unit id="c654b246f7037e0f8929e3e045a813d87f20921d" translate="yes" xml:space="preserve">
          <source>PRAGMA count_changes</source>
          <target state="translated">PRAGMA count_changes</target>
        </trans-unit>
        <trans-unit id="e558ad585b01cc3a4aa52bb53490182d9eacc4e8" translate="yes" xml:space="preserve">
          <source>PRAGMA data_store_directory</source>
          <target state="translated">Каталог_магазина_данных PRAGMA</target>
        </trans-unit>
        <trans-unit id="9a7e5a694b84807a56ec0b72b64b9c9c84d92f92" translate="yes" xml:space="preserve">
          <source>PRAGMA data_version</source>
          <target state="translated">PRAGMA data_version</target>
        </trans-unit>
        <trans-unit id="71f193736d432d273c489df59218224a1bd26bb0" translate="yes" xml:space="preserve">
          <source>PRAGMA database_list</source>
          <target state="translated">список_базы данных PRAGMA</target>
        </trans-unit>
        <trans-unit id="d2b0abac3ff561286d0f244f1229dbe0d7c413ba" translate="yes" xml:space="preserve">
          <source>PRAGMA default_cache_size</source>
          <target state="translated">PRAGMA по умолчанию_cache_size</target>
        </trans-unit>
        <trans-unit id="baa9b0985d524aa3c28f49ac66dec16e57647a96" translate="yes" xml:space="preserve">
          <source>PRAGMA defer_foreign_keys</source>
          <target state="translated">PRAGMA ключи_отсрочки_foreign_keys</target>
        </trans-unit>
        <trans-unit id="5a13b54115c31e192bafba5863e3b69f614ae8e0" translate="yes" xml:space="preserve">
          <source>PRAGMA empty_result_callbacks</source>
          <target state="translated">PRAGMA empty_result_callbacks</target>
        </trans-unit>
        <trans-unit id="464f0c2fc86d3a8263fffd42239b50d53989d1da" translate="yes" xml:space="preserve">
          <source>PRAGMA encoding</source>
          <target state="translated">кодирование PRAGMA</target>
        </trans-unit>
        <trans-unit id="5a35e091ec7521a831d067bdc90ecb017a359b26" translate="yes" xml:space="preserve">
          <source>PRAGMA foreign_key_check</source>
          <target state="translated">PRAGMA foreign_key_check</target>
        </trans-unit>
        <trans-unit id="4f9cabaf50d87f897238e4cfca01cbf9a956476a" translate="yes" xml:space="preserve">
          <source>PRAGMA foreign_key_list</source>
          <target state="translated">PRAGMA зарубежный_ключевой_список</target>
        </trans-unit>
        <trans-unit id="c26430dedacc940c37179bc2ab043a40726e60aa" translate="yes" xml:space="preserve">
          <source>PRAGMA foreign_keys</source>
          <target state="translated">PRAGMA иностранные ключи</target>
        </trans-unit>
        <trans-unit id="f6f4d8a618687004328fc80c2fe129e8548fb446" translate="yes" xml:space="preserve">
          <source>PRAGMA freelist_count</source>
          <target state="translated">PRAGMA фрилист_счёт</target>
        </trans-unit>
        <trans-unit id="a1a0446b52b0c9481ab686d03b259ad5f54f8cce" translate="yes" xml:space="preserve">
          <source>PRAGMA full_column_names</source>
          <target state="translated">PRAGMA полные_колонки_имени</target>
        </trans-unit>
        <trans-unit id="19952a9490a74b7cefcba8ae3ffcd4c6cd36c908" translate="yes" xml:space="preserve">
          <source>PRAGMA fullfsync</source>
          <target state="translated">PRAGMA fullfsync</target>
        </trans-unit>
        <trans-unit id="9b4ca9a487733d7c417ae8784f57aa1ed11b34f0" translate="yes" xml:space="preserve">
          <source>PRAGMA fullfsync=ON;</source>
          <target state="translated">PRAGMA fullfsync=ON;</target>
        </trans-unit>
        <trans-unit id="327858b59b9cfef735d94d93f6b85bcef5690111" translate="yes" xml:space="preserve">
          <source>PRAGMA function</source>
          <target state="translated">функция PRAGMA</target>
        </trans-unit>
        <trans-unit id="2a0bacb7b9cc513abddcbbe743f428bab68dfa8c" translate="yes" xml:space="preserve">
          <source>PRAGMA function_list</source>
          <target state="translated">список функций PRAGMA</target>
        </trans-unit>
        <trans-unit id="e837cb07b592292e4ed84f750d66cb314f82a9c5" translate="yes" xml:space="preserve">
          <source>PRAGMA functions</source>
          <target state="translated">функции PRAGMA</target>
        </trans-unit>
        <trans-unit id="f7e42e33fd73efd0a92d36f4ff6b3819913f9bc4" translate="yes" xml:space="preserve">
          <source>PRAGMA ignore_check_constraints</source>
          <target state="translated">PRAGMA игнорировать_check_constraints</target>
        </trans-unit>
        <trans-unit id="cd58bb64e6b2a173c5b581b0cb503c85da1dbd24" translate="yes" xml:space="preserve">
          <source>PRAGMA incremental_vacuum</source>
          <target state="translated">PRAGMA инкрементальный_вакуум</target>
        </trans-unit>
        <trans-unit id="652aaaf1f9e0a84122b69d9954ec064ee9d02a48" translate="yes" xml:space="preserve">
          <source>PRAGMA index_info</source>
          <target state="translated">PRAGMA индекс_info</target>
        </trans-unit>
        <trans-unit id="125af8cf007c5ae9f4a12bfd4e392de5088aeebd" translate="yes" xml:space="preserve">
          <source>PRAGMA index_list</source>
          <target state="translated">индекс_список PRAGMA</target>
        </trans-unit>
        <trans-unit id="2da953925bb8a4bec48afa57978cfa755a68b864" translate="yes" xml:space="preserve">
          <source>PRAGMA index_xinfo</source>
          <target state="translated">PRAGMA index_xinfo</target>
        </trans-unit>
        <trans-unit id="a0a681b89ba9014d636bfe01c90f033d409952e9" translate="yes" xml:space="preserve">
          <source>PRAGMA integrity_check</source>
          <target state="translated">проверка целостности PRAGMA</target>
        </trans-unit>
        <trans-unit id="47cd2260e4aae51e91f7618b4491c7a57dbd31aa" translate="yes" xml:space="preserve">
          <source>PRAGMA integrity_check does not find &lt;a href=&quot;foreignkeys&quot;&gt;FOREIGN KEY&lt;/a&gt; errors. Use the &lt;a href=&quot;pragma#pragma_foreign_key_check&quot;&gt;PRAGMA foreign_key_check&lt;/a&gt; command for to find errors in FOREIGN KEY constraints.</source>
          <target state="translated">PRAGMA Integrity_check не находит ошибок &lt;a href=&quot;foreignkeys&quot;&gt;FOREIGN KEY&lt;/a&gt; . Используйте команду &lt;a href=&quot;pragma#pragma_foreign_key_check&quot;&gt;PRAGMA foreign_key_check,&lt;/a&gt; чтобы найти ошибки в ограничениях FOREIGN KEY.</target>
        </trans-unit>
        <trans-unit id="fed086b5dc8e5ae4d059caf4aa86921613ca6bce" translate="yes" xml:space="preserve">
          <source>PRAGMA integrity_check does not find &lt;a href=&quot;foreignkeys&quot;&gt;FOREIGN KEY&lt;/a&gt; errors. Use the &lt;a href=&quot;pragma#pragma_foreign_key_check&quot;&gt;PRAGMA foreign_key_check&lt;/a&gt; command to find errors in FOREIGN KEY constraints.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e40c9bb92f26ef5f07d9f3367463e8597505eee" translate="yes" xml:space="preserve">
          <source>PRAGMA journal_mode</source>
          <target state="translated">режим PRAGMA log_mode</target>
        </trans-unit>
        <trans-unit id="0dc7949f2c37427da3286461ab0d99c192b23454" translate="yes" xml:space="preserve">
          <source>PRAGMA journal_size_limit</source>
          <target state="translated">Журнал_размер_ограничения PRAGMA</target>
        </trans-unit>
        <trans-unit id="1d1d61ff55f21546bb199472fc5fb09c63e7801f" translate="yes" xml:space="preserve">
          <source>PRAGMA legacy_alter_table</source>
          <target state="translated">PRAGMA legacy_alter_table</target>
        </trans-unit>
        <trans-unit id="1d7e28dc08cc03a9bb08dd39291f00ea3a00d6ce" translate="yes" xml:space="preserve">
          <source>PRAGMA legacy_file_format</source>
          <target state="translated">Наследственный_файл_формат PRAGMA</target>
        </trans-unit>
        <trans-unit id="e05eb926ae67395e18a7ff48872e6bf6de93826e" translate="yes" xml:space="preserve">
          <source>PRAGMA locking_mode</source>
          <target state="translated">режим блокировки PRAGMA</target>
        </trans-unit>
        <trans-unit id="a71f8b9f21a1c76ece9dc64397bce57f203e4519" translate="yes" xml:space="preserve">
          <source>PRAGMA max_page_count</source>
          <target state="translated">PRAGMA max_page_count</target>
        </trans-unit>
        <trans-unit id="3aba9ed125640a69838f81731ba34ebdf094d76a" translate="yes" xml:space="preserve">
          <source>PRAGMA mmap_size</source>
          <target state="translated">PRAGMA mmap_size</target>
        </trans-unit>
        <trans-unit id="c29ccc2a4945dfe06f8af7b8b574f07e8a513dc7" translate="yes" xml:space="preserve">
          <source>PRAGMA module_list</source>
          <target state="translated">список модулей PRAGMA</target>
        </trans-unit>
        <trans-unit id="ed5cd9ca526909b51a8497a39931b7a730a4b534" translate="yes" xml:space="preserve">
          <source>PRAGMA optimize</source>
          <target state="translated">PRAGMA оптимизация</target>
        </trans-unit>
        <trans-unit id="9618d59586d55b1fe7cf6403a08d5878deeff0b2" translate="yes" xml:space="preserve">
          <source>PRAGMA page_count</source>
          <target state="translated">PRAGMA страница_счёт</target>
        </trans-unit>
        <trans-unit id="73b1778335144273f1b55bbda71292b3236c2f7c" translate="yes" xml:space="preserve">
          <source>PRAGMA page_size</source>
          <target state="translated">Размер страницы PRAGMA</target>
        </trans-unit>
        <trans-unit id="0c33d6f9f55335baef42453f3966f2ae2790fe21" translate="yes" xml:space="preserve">
          <source>PRAGMA parser_trace</source>
          <target state="translated">PRAGMA парсер_trace</target>
        </trans-unit>
        <trans-unit id="987c5140e9a3de6520e0e9a5de928a2bd5f2af7c" translate="yes" xml:space="preserve">
          <source>PRAGMA synchronous=FULL;</source>
          <target state="translated">PRAGMA synchronous=FULL;</target>
        </trans-unit>
        <trans-unit id="c40b0db1ea40d45cf9c01804a3ada577b8b752ae" translate="yes" xml:space="preserve">
          <source>PRAGMA temp_store_directory = ''</source>
          <target state="translated">Каталог_магазина_температуры PRAGMA=''.</target>
        </trans-unit>
        <trans-unit id="0662bf3087347b5b0ecf25fecad0c21f9bfb340d" translate="yes" xml:space="preserve">
          <source>PRAGMA vdbe_addoptrace</source>
          <target state="translated">PRAGMA vdbe_addoptrace</target>
        </trans-unit>
        <trans-unit id="ed607acfa6bacfc2bc133e1d2e829c3c31c8a51c" translate="yes" xml:space="preserve">
          <source>PRAGMA vdbe_debug</source>
          <target state="translated">PRAGMA vdbe_debug</target>
        </trans-unit>
        <trans-unit id="f5251eb4d3acd0707857877ee684d1bef0e741e2" translate="yes" xml:space="preserve">
          <source>PRAGMA vdbe_listing</source>
          <target state="translated">PRAGMA vdbe_listing</target>
        </trans-unit>
        <trans-unit id="319d369f27e5d322702e5eca965b605f26e48c8b" translate="yes" xml:space="preserve">
          <source>PRAGMA vdbe_trace</source>
          <target state="translated">PRAGMA vdbe_trace</target>
        </trans-unit>
        <trans-unit id="f0a71878598fa251896a1bb5f07402743f02c1c6" translate="yes" xml:space="preserve">
          <source>PRAGMAs that return results and that have no side-effects can be accessed from ordinary &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statements as &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued functions&lt;/a&gt;. For each participating PRAGMA, the corresponding table-valued function has the same name as the PRAGMA with a 7-character &quot;pragma_&quot; prefix. The PRAGMA argument and schema, if any, are passed as arguments to the table-valued function.</source>
          <target state="translated">К PRAGMA, возвращающим результаты и не имеющим побочных эффектов, можно получить доступ из обычных &lt;a href=&quot;lang_select&quot;&gt;операторов SELECT&lt;/a&gt; как &lt;a href=&quot;vtab#tabfunc2&quot;&gt;функций&lt;/a&gt; , возвращающих табличное значение . Для каждой участвующей PRAGMA соответствующая возвращающая табличное значение функция имеет то же имя, что и PRAGMA, с 7-символьным префиксом pragma_. Аргумент и схема PRAGMA, если таковые имеются, передаются в качестве аргументов функции, возвращающей табличное значение.</target>
        </trans-unit>
        <trans-unit id="f5e246fc197bcab96dcc71246fd51e046d154a6b" translate="yes" xml:space="preserve">
          <source>PRECEDING</source>
          <target state="translated">PRECEDING</target>
        </trans-unit>
        <trans-unit id="ed15de08f42371953d12d6c433f3d7a83e50d659" translate="yes" xml:space="preserve">
          <source>PRIMARY</source>
          <target state="translated">PRIMARY</target>
        </trans-unit>
        <trans-unit id="5d81ed20f739b911f425c9e71391691185dad6d3" translate="yes" xml:space="preserve">
          <source>PRIMARY KEY constraint</source>
          <target state="translated">Ограничение PRIMARY KEY</target>
        </trans-unit>
        <trans-unit id="fcdd367db6d48a1ca9ffb0132d54992dd930544d" translate="yes" xml:space="preserve">
          <source>Page 1 and the Expected Page Size</source>
          <target state="translated">Страница 1 и ожидаемый размер страницы</target>
        </trans-unit>
        <trans-unit id="626d2e810cbdab389ce5499e79846105d079da1c" translate="yes" xml:space="preserve">
          <source>Page 1 of a database file is the root page of a table b-tree that holds a special table named &quot;&lt;a href=&quot;schematab&quot;&gt;sqlite_schema&lt;/a&gt;&quot;. This b-tree is known as the &quot;schema table&quot; since it stores the complete database schema. The structure of the sqlite_schema table is as if it had been created using the following SQL:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0da1c304b873d5c4bfe7eb2116e8b2b93162178" translate="yes" xml:space="preserve">
          <source>Page 1 of a database file is the root page of a table b-tree that holds a special table named &quot;sqlite_master&quot; (or &quot;sqlite_temp_master&quot; in the case of a TEMP database) which stores the complete database schema. The structure of the sqlite_master table is as if it had been created using the following SQL:</source>
          <target state="translated">Страница 1 файла БД является корневой страницей таблицы b-дерева,содержащей специальную таблицу &quot;sqlite_master&quot; (или &quot;sqlite_temp_master&quot; в случае БД TEMP),в которой хранится полная схема БД.Структура таблицы sqlite_master выглядит так,как если бы она была создана с использованием следующего SQL:</target>
        </trans-unit>
        <trans-unit id="bb98169c72c2e0218852294c4088a714e55ae813" translate="yes" xml:space="preserve">
          <source>Page Cache</source>
          <target state="translated">Кэш страниц</target>
        </trans-unit>
        <trans-unit id="111e3d8b941451e6256ee0ce1fa5b2560f773697" translate="yes" xml:space="preserve">
          <source>Page Cache Algorithms</source>
          <target state="translated">Алгоритмы кэширования страниц</target>
        </trans-unit>
        <trans-unit id="51e73b0787f74035c32eccb9bca14aa82436008b" translate="yes" xml:space="preserve">
          <source>Page Cache Configuration</source>
          <target state="translated">Конфигурация кэша страниц</target>
        </trans-unit>
        <trans-unit id="91dcdd907d00efb6c274aa541e77d89ded5b848c" translate="yes" xml:space="preserve">
          <source>Page cache memory allocations that overflow into the general-purpose memory allocator.</source>
          <target state="translated">Распределение кэш-памяти страницы,которое переполняет универсальный аллокатор памяти.</target>
        </trans-unit>
        <trans-unit id="8b08ca42225d56c2d889ece253767100d76e7c2a" translate="yes" xml:space="preserve">
          <source>Page number</source>
          <target state="translated">Номер страницы</target>
        </trans-unit>
        <trans-unit id="ad392683af791420db4e7324c20464059ce3492a" translate="yes" xml:space="preserve">
          <source>Page number of first overflow page</source>
          <target state="translated">Номер страницы первого переполнения</target>
        </trans-unit>
        <trans-unit id="6e528c19af566e5c19716241accd44732b15c3f1" translate="yes" xml:space="preserve">
          <source>Page number of left child</source>
          <target state="translated">Номер левого ребенка на странице</target>
        </trans-unit>
        <trans-unit id="1d20e1ca269b0f7a9ac2bdd34ee817b875d0828b" translate="yes" xml:space="preserve">
          <source>Page number of the first freelist trunk page.</source>
          <target state="translated">Номер страницы первого багажника фрилиста.</target>
        </trans-unit>
        <trans-unit id="2f6078feea4fe70e006a40f0bbe8960bf8454aee" translate="yes" xml:space="preserve">
          <source>Pagecache memory allocator</source>
          <target state="translated">аллокатор памяти Pagecache</target>
        </trans-unit>
        <trans-unit id="7a89afd5ef39a4cff0b861ab314756ac6e516da0" translate="yes" xml:space="preserve">
          <source>Pagecount</source>
          <target state="translated">Pagecount</target>
        </trans-unit>
        <trans-unit id="2a084ba7d77808cea5a5f8f9c1ab34ab55b7585a" translate="yes" xml:space="preserve">
          <source>Pager and btree subsystems removed. These will be used in a follow-on SQL server library named &quot;SQLus&quot;.</source>
          <target state="translated">Удалены подсистемы пейджера и btree.Они будут использоваться в последующей SQL-серверной библиотеке под названием &quot;SQLus&quot;.</target>
        </trans-unit>
        <trans-unit id="d03660f900d198f933a03da740944dbf17018900" translate="yes" xml:space="preserve">
          <source>Pager subsystem added but not yet used.</source>
          <target state="translated">Подсистема пейджера добавлена,но еще не используется.</target>
        </trans-unit>
        <trans-unit id="70384aa891f4780133eb9e575d0bd72469e20f4e" translate="yes" xml:space="preserve">
          <source>Pages are numbered beginning with 1. The maximum page number is 2147483646 (2&lt;sup&gt;&lt;small&gt;31&lt;/small&gt;&lt;/sup&gt; - 2). The minimum size SQLite database is a single 512-byte page. The maximum size database would be 2147483646 pages at 65536 bytes per page or 140,737,488,224,256 bytes (about 140 terabytes). Usually SQLite will hit the maximum file size limit of the underlying filesystem or disk hardware long before it hits its own internal size limit.</source>
          <target state="translated">Страницы нумеруются, начиная с 1. Максимальный номер страницы - 2147483646 (2 &lt;sup&gt;&lt;small&gt;31&lt;/small&gt;&lt;/sup&gt; - 2). Минимальный размер базы данных SQLite - это одна страница размером 512 байт. Максимальный размер базы данных составляет 2147483646 страниц при 65536 байтах на страницу или 140 737 488 224 256 байтов (около 140 терабайт). Обычно SQLite достигает предела максимального размера файла базовой файловой системы или дискового оборудования задолго до того, как достигнет своего собственного внутреннего предела размера.</target>
        </trans-unit>
        <trans-unit id="a6bf70b89378b1b3ed63fb1aa677ec02aea17bdf" translate="yes" xml:space="preserve">
          <source>Pages are numbered beginning with 1. The maximum page number is 4294967294 (2&lt;sup&gt;&lt;small&gt;32&lt;/small&gt;&lt;/sup&gt; - 2). The minimum size SQLite database is a single 512-byte page. The maximum size database would be 2147483646 pages at 65536 bytes per page or 281,474,976,579,584 bytes (about 281 terabytes). Usually SQLite will hit the maximum file size limit of the underlying filesystem or disk hardware long before it hits its own internal size limit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f332eeefd007bb0043ccb46738196508c6a602b" translate="yes" xml:space="preserve">
          <source>Param</source>
          <target state="translated">Param</target>
        </trans-unit>
        <trans-unit id="f699f295e5ae4ac633cfa18437fed38d028b3fdb" translate="yes" xml:space="preserve">
          <source>Parameter</source>
          <target state="translated">Parameter</target>
        </trans-unit>
        <trans-unit id="8b81f4321a39e53a61cf8fbe1b4d654902c2cd89" translate="yes" xml:space="preserve">
          <source>Parameter P4 may point to a Table structure, or may be NULL. If it is not NULL, then the update-hook (sqlite3.xUpdateCallback) is invoked following a successful insert.</source>
          <target state="translated">Параметр P4 может указывать на структуру таблицы или может быть NULL.Если она не NULL,то после успешной вставки вызывается updateate-hook (sqlite3.xUpdateCallback).</target>
        </trans-unit>
        <trans-unit id="a5652d036064588f8b6a1cd35001bca04abb6577" translate="yes" xml:space="preserve">
          <source>Parameter zDb is not the filename that contains the database, but rather the symbolic name of the database. For attached databases, this is the name that appears after the AS keyword in the &lt;a href=&quot;../lang_attach&quot;&gt;ATTACH&lt;/a&gt; statement. For the main database file, the database name is &quot;main&quot;. For TEMP tables, the database name is &quot;temp&quot;.</source>
          <target state="translated">Параметр zDb - это не имя файла, содержащего базу данных, а скорее символическое имя базы данных. Для подключенных баз данных это имя появляется после ключевого слова AS в операторе &lt;a href=&quot;../lang_attach&quot;&gt;ATTACH&lt;/a&gt; . Для основного файла базы данных имя базы данных - &amp;laquo;main&amp;raquo;. Для таблиц TEMP имя базы данных - &amp;laquo;temp&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="6b3dbfca494676dd202b93efd1413416a69fb138" translate="yes" xml:space="preserve">
          <source>Parameter zDb is not the filename that contains the database, but rather the symbolic name of the database. For attached databases, this is the name that appears after the AS keyword in the &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; statement. For the main database file, the database name is &quot;main&quot;. For TEMP tables, the database name is &quot;temp&quot;.</source>
          <target state="translated">Параметр zDb - это не имя файла, содержащего базу данных, а скорее символическое имя базы данных. Для подключенных баз данных это имя появляется после ключевого слова AS в операторе &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; . Для основного файла базы данных имя базы данных - &amp;laquo;main&amp;raquo;. Для таблиц TEMP имя базы данных - &amp;laquo;temp&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="a975eea30db9fa05003e3b5097688bd49ec7e01b" translate="yes" xml:space="preserve">
          <source>Parameters</source>
          <target state="translated">Parameters</target>
        </trans-unit>
        <trans-unit id="799e97b7e20fea27a8af5b85f72a1e45ff70f20e" translate="yes" xml:space="preserve">
          <source>Parameters can be either named or unnamed. An unnamed parameter is a single question mark (&quot;?&quot;). Named parameters are a &quot;?&quot; followed immediately by a number (ex: &quot;?15&quot; or &quot;?123&quot;) or one of the characters &quot;$&quot;, &quot;:&quot;, or &quot;@&quot; followed by an alphanumeric name (ex: &quot;$var1&quot;, &quot;:xyz&quot;, &quot;@bingo&quot;).</source>
          <target state="translated">Параметры могут быть как именованными,так и безымянными.Безымянный параметр является одним вопросительным знаком (&quot;?&quot;).Именованные параметры-это &quot;?&quot;,за которым сразу же следует цифра (например:&quot;?15&quot; или &quot;?123&quot;)или один из символов &quot;$&quot;,&quot;:&quot; или &quot;@&quot;,за которым следует буквенно-цифровое имя (например:&quot;$var1&quot;,&quot;:xyz&quot;,&quot;@bingo&quot;).</target>
        </trans-unit>
        <trans-unit id="8cba5f18115ee2b196f01cd67b537bb6b53bf7ec" translate="yes" xml:space="preserve">
          <source>Parameters that are not assigned values using &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind()&lt;/a&gt; are treated as NULL. The &lt;a href=&quot;c3ref/bind_parameter_index&quot;&gt;sqlite3_bind_parameter_index()&lt;/a&gt; interface can be used to translate a symbolic parameter name into its equivalent numeric index.</source>
          <target state="translated">Параметры, которым не присвоены значения с помощью &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind ()&lt;/a&gt; , обрабатываются как NULL. Интерфейс &lt;a href=&quot;c3ref/bind_parameter_index&quot;&gt;sqlite3_bind_parameter_index ()&lt;/a&gt; можно использовать для преобразования символьного имени параметра в его эквивалентный числовой индекс.</target>
        </trans-unit>
        <trans-unit id="4de5d1891af8779fc1d212b882aca704731f9909" translate="yes" xml:space="preserve">
          <source>Parent and child keys must have the same cardinality. In SQLite, if any of the child key columns (in this case songartist and songalbum) are NULL, then there is no requirement for a corresponding row in the parent table.</source>
          <target state="translated">Родительский и детский ключи должны иметь одинаковую кардинальность.В SQLite,если любой из столбцов дочернего ключа (в данном случае songartist и songalbum)имеет NULL,то нет необходимости в соответствующей строке в родительской таблице.</target>
        </trans-unit>
        <trans-unit id="f4093b4053e6e304b33edcd1e545c7ac44407405" translate="yes" xml:space="preserve">
          <source>Parent table</source>
          <target state="translated">Родительская таблица</target>
        </trans-unit>
        <trans-unit id="4e28259727cc9bea774f5aa837a0a46e7e8f6e3d" translate="yes" xml:space="preserve">
          <source>Parentheses around the column name are ignored. Hence if X and Y.Z are column names, then (X) and (Y.Z) are also considered column names and have the affinity of the corresponding columns.</source>
          <target state="translated">Круглые скобки вокруг названия колонки игнорируются.Следовательно,если X и Y.Z являются названиями столбцов,то (X)и (Y.Z)также считаются названиями столбцов и имеют сродство с соответствующими столбцами.</target>
        </trans-unit>
        <trans-unit id="e9b3806832484c8806fbc046fab28912aa2aa64c" translate="yes" xml:space="preserve">
          <source>Parenthesis are not supported.</source>
          <target state="translated">Родословная не поддерживается.</target>
        </trans-unit>
        <trans-unit id="75d39bc816f04be94a422f23dd0120a1ebf6cf81" translate="yes" xml:space="preserve">
          <source>Parenthesis may be used to group expressions in order to modify operator precedence in the usual ways. For example:</source>
          <target state="translated">С помощью скобки можно сгруппировать выражения,чтобы изменить приоритет операторов обычными способами.Например:</target>
        </trans-unit>
        <trans-unit id="a5d92895b79471a4a9fa3ce0a6ffdf64945a6880" translate="yes" xml:space="preserve">
          <source>Parse (but do not implement) foreign keys.</source>
          <target state="translated">Разобрать (но не внедрить)иностранные ключи.</target>
        </trans-unit>
        <trans-unit id="c98796aa2add46f2617d36d2c94c638a1c0df012" translate="yes" xml:space="preserve">
          <source>ParseSchema</source>
          <target state="translated">ParseSchema</target>
        </trans-unit>
        <trans-unit id="1b3cf5033ed01a4fcbff3f2957e66cfe44af45a9" translate="yes" xml:space="preserve">
          <source>Parser</source>
          <target state="translated">Parser</target>
        </trans-unit>
        <trans-unit id="e5dde1d1ec704f9acd81aeb949908d6d48dedf9c" translate="yes" xml:space="preserve">
          <source>Parser detects and reports automaton stack overflow.</source>
          <target state="translated">Парсер обнаруживает и сообщает о переполнении стека автоматов.</target>
        </trans-unit>
        <trans-unit id="de7186ac205c0a4d05d1b7e13d0477c901e264d5" translate="yes" xml:space="preserve">
          <source>Parsing Ambiguity</source>
          <target state="translated">Неопределенность при разборе</target>
        </trans-unit>
        <trans-unit id="6893b79566df0f4ab433d9b0d800d95d1637ec25" translate="yes" xml:space="preserve">
          <source>Partial Indexes</source>
          <target state="translated">Частичные индексы</target>
        </trans-unit>
        <trans-unit id="b83a6d7f720f864139ebf6cd22707c1309f4af67" translate="yes" xml:space="preserve">
          <source>Partial index causes assertion fault on UPDATE OR REPLACE. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/2ea3e9fe63&quot;&gt;2ea3e9fe63&lt;/a&gt;</source>
          <target state="translated">Частичный индекс вызывает ошибку утверждения при UPDATE OR REPLACE. Билет &lt;a href=&quot;http://www.sqlite.org/src/info/2ea3e9fe63&quot;&gt;2ea3e9fe63&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="74f02a08dcb98cd96d7cf448a85669448cde0119" translate="yes" xml:space="preserve">
          <source>Partial index causes assertion fault on UPDATE OR REPLACE. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/2ea3e9fe63&quot;&gt;2ea3e9fe63&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92e7c6c4dccd56837450920de775aa91130dc6eb" translate="yes" xml:space="preserve">
          <source>Partial indexes</source>
          <target state="translated">Частичные индексы</target>
        </trans-unit>
        <trans-unit id="a6b00209f988aae401d1637e4d3a48cf480b87b9" translate="yes" xml:space="preserve">
          <source>Partial indexes have been supported in SQLite since &lt;a href=&quot;https://sqlite.org/releaselog/3_8_0.html&quot;&gt;version 3.8.0&lt;/a&gt; (2013-08-26).</source>
          <target state="translated">Частичные индексы поддерживаются в SQLite с &lt;a href=&quot;https://sqlite.org/releaselog/3_8_0.html&quot;&gt;версии 3.8.0&lt;/a&gt; (2013-08-26).</target>
        </trans-unit>
        <trans-unit id="2c653f2abbb32f0888ba48000a6d19c0a678be3c" translate="yes" xml:space="preserve">
          <source>Partial sorting by index</source>
          <target state="translated">Частичная сортировка по индексу</target>
        </trans-unit>
        <trans-unit id="8e7b279371a7a0621eac24aac6019fdbd06fb946" translate="yes" xml:space="preserve">
          <source>Partially or fully disable the use of mutexes using &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigsinglethread&quot;&gt;SQLITE_CONFIG_SINGLETHREAD&lt;/a&gt;, &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmultithread&quot;&gt;SQLITE_CONFIG_MULTITHREAD&lt;/a&gt; and &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigserialized&quot;&gt;SQLITE_CONFIG_SERIALIZED&lt;/a&gt;.</source>
          <target state="translated">Частично или полностью отключите использование мьютексов с помощью &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigsinglethread&quot;&gt;SQLITE_CONFIG_SINGLETHREAD&lt;/a&gt; , &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmultithread&quot;&gt;SQLITE_CONFIG_MULTITHREAD&lt;/a&gt; и &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigserialized&quot;&gt;SQLITE_CONFIG_SERIALIZED&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="322d75c78f20c6c69dad6d4668258bee1cff55cf" translate="yes" xml:space="preserve">
          <source>Pass information about !=, IS, IS NOT, NOT NULL, and IS NULL constraints into the &lt;a href=&quot;vtab#xbestindex&quot;&gt;xBestIndex&lt;/a&gt; method of virtual tables.</source>
          <target state="translated">Передайте информацию об ограничениях! =, IS, IS NOT, NOT NULL и IS NULL в метод виртуальных таблиц &lt;a href=&quot;vtab#xbestindex&quot;&gt;xBestIndex&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="87139427c07163b54b934cac2e589a5477f5abd2" translate="yes" xml:space="preserve">
          <source>Passing around pointers as if they were integers or BLOBs is easy, effective, and works well in an environment where the application components are all friendly toward one another. However, passing pointers as integers and BLOBs allows hostile SQL text to forge invalid pointers that can carry out mischief.</source>
          <target state="translated">Передача указателей,как если бы они были целыми числами или BLOB,проста,эффективна и хорошо работает в среде,где все компоненты приложения дружелюбны друг к другу.Однако,передача указателей в виде целых чисел и BLOB-ов позволяет враждебно настроенному SQL-тексту подделать недействительные указатели,способные нанести вред.</target>
        </trans-unit>
        <trans-unit id="3138de58b357feeff45cc3442a6fef1e07764789" translate="yes" xml:space="preserve">
          <source>Passing zero to this function disables the session. Passing a value greater than zero enables it. Passing a value less than zero is a no-op, and may be used to query the current state of the session.</source>
          <target state="translated">Передача нуля в эту функцию отключает сеанс.Передача значения больше нуля позволяет это сделать.Передача значения меньше нуля-это &quot;нет-оп&quot;,и может быть использована для запроса текущего состояния сеанса.</target>
        </trans-unit>
        <trans-unit id="590be09d7533f1bdecea251bf8fa20c21692381c" translate="yes" xml:space="preserve">
          <source>Patch releases may or may not have a release checklist, depending on the issue. This is a judgement call by the project leader.</source>
          <target state="translated">В зависимости от проблемы,у патч-релизов может быть контрольный список выпусков,а может и нет.Это решение принимается руководителем проекта.</target>
        </trans-unit>
        <trans-unit id="6943c09e1bab506ed4d4e77bf277765f2ba43e9d" translate="yes" xml:space="preserve">
          <source>Patches from Christian Werner to improve ODBC compatibility and to fix a bug in the round() function.</source>
          <target state="translated">Патчи от Christian Werner для улучшения ODBC совместимости и исправления ошибки в функции round().</target>
        </trans-unit>
        <trans-unit id="2e7fec23d54bbd8979f0f75ea726578cd4ba06c0" translate="yes" xml:space="preserve">
          <source>Pay close attention to the last sentence in the previous paragraph:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c30415eacc6a59446974b716eff56cf28219815d" translate="yes" xml:space="preserve">
          <source>Payload</source>
          <target state="translated">Payload</target>
        </trans-unit>
        <trans-unit id="2cd642b895a9277d90f1edb51ac2e97d29897374" translate="yes" xml:space="preserve">
          <source>Payload, either table b-tree data or index b-tree keys, is always in the &quot;record format&quot;. The record format defines a sequence of values corresponding to columns in a table or index. The record format specifies the number of columns, the datatype of each column, and the content of each column.</source>
          <target state="translated">Полезная нагрузка,будь то данные из b-дерева таблицы или ключи индекса b-дерева,всегда находится в &quot;формате записи&quot;.Формат записи определяет последовательность значений,соответствующих столбцам таблицы или индекса.Формат записи задает количество столбцов,тип данных каждого столбца и содержание каждого столбца.</target>
        </trans-unit>
        <trans-unit id="e74a4343f3025ea9dd8df608f45f6bce992f0d7e" translate="yes" xml:space="preserve">
          <source>Pending statements no longer block &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt;. Instead, the pending statement will return SQLITE_ABORT upon next access after the ROLLBACK.</source>
          <target state="translated">Отложенные операторы больше не блокируют &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt; . Вместо этого ожидающий оператор вернет SQLITE_ABORT при следующем доступе после ROLLBACK.</target>
        </trans-unit>
        <trans-unit id="4737507de6ca940161ab97310c9c1d96280bacd6" translate="yes" xml:space="preserve">
          <source>People often wonder why SQLite does not use the &lt;a href=&quot;https://git-scm.org&quot;&gt;Git&lt;/a&gt; version control system like everybody else. This article attempts to answer that question. Also, in &lt;a href=&quot;#getthecode&quot;&gt;section 3&lt;/a&gt;, this article provides hints to Git users about how they can easily access the SQLite source code.</source>
          <target state="translated">Люди часто задаются вопросом, почему SQLite не использует систему контроля версий &lt;a href=&quot;https://git-scm.org&quot;&gt;Git&lt;/a&gt; , как все остальные. В этой статье делается попытка ответить на этот вопрос. Кроме того, в &lt;a href=&quot;#getthecode&quot;&gt;разделе 3&lt;/a&gt; этой статьи даются советы пользователям Git о том, как они могут легко получить доступ к исходному коду SQLite.</target>
        </trans-unit>
        <trans-unit id="a859905b933e3207fdf46d957c4ccc640fdf48ae" translate="yes" xml:space="preserve">
          <source>People who understand SQL can employ the &lt;a href=&quot;cli&quot;&gt;sqlite3 command-line shell&lt;/a&gt; (or various third-party SQLite access programs) to analyze large datasets. Raw data can be imported from CSV files, then that data can be sliced and diced to generate a myriad of summary reports. More complex analysis can be done using simple scripts written in Tcl or Python (both of which come with SQLite built-in) or in R or other languages using readily available adaptors. Possible uses include website log analysis, sports statistics analysis, compilation of programming metrics, and analysis of experimental results. Many bioinformatics researchers use SQLite in this way.</source>
          <target state="translated">Люди, разбирающиеся в SQL, могут использовать &lt;a href=&quot;cli&quot;&gt;оболочку командной строки sqlite3&lt;/a&gt; (или различные сторонние программы доступа к SQLite) для анализа больших наборов данных. Необработанные данные можно импортировать из файлов CSV, а затем эти данные можно разрезать и разрезать для создания множества сводных отчетов. Более сложный анализ может быть выполнен с использованием простых сценариев, написанных на Tcl или Python (оба из которых имеют встроенный SQLite) или на R или других языках с использованием легко доступных адаптеров. Возможные варианты использования включают анализ журналов веб-сайтов, анализ спортивной статистики, составление программных показателей и анализ результатов экспериментов. Многие исследователи биоинформатики используют SQLite таким образом.</target>
        </trans-unit>
        <trans-unit id="deda64204144c5cb8a53d34e5d28a353e9faf513" translate="yes" xml:space="preserve">
          <source>Perform a single step of the incremental vacuum procedure on the P1 database. If the vacuum has finished, jump to instruction P2. Otherwise, fall through to the next instruction.</source>
          <target state="translated">Выполните один шаг процедуры создания инкрементного вакуума в базе данных P1.Если вакуум закончился,перейдите к инструкции P2.В противном случае перейдите к следующей инструкции.</target>
        </trans-unit>
        <trans-unit id="54eef71ea08bf2a0291b4730516048fec290cbbf" translate="yes" xml:space="preserve">
          <source>Perform any required foreign key actions,</source>
          <target state="translated">Выполните все необходимые зарубежные ключевые действия,</target>
        </trans-unit>
        <trans-unit id="94e7748396990532238f46b792b6a833a4e68178" translate="yes" xml:space="preserve">
          <source>Perform some &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; operations in a single pass instead of in two passes.</source>
          <target state="translated">Выполняйте некоторые операции &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; за один проход вместо двух.</target>
        </trans-unit>
        <trans-unit id="63c904559993935c470f516c8b549ca7f3640dbb" translate="yes" xml:space="preserve">
          <source>Performance</source>
          <target state="translated">Performance</target>
        </trans-unit>
        <trans-unit id="0b4045b439e29414aaf2009ad15f476795f21a79" translate="yes" xml:space="preserve">
          <source>Performance Related Assumptions</source>
          <target state="translated">Предположения,связанные с производительностью</target>
        </trans-unit>
        <trans-unit id="5539b01935cddeb466afb8949c00cacfd4174474" translate="yes" xml:space="preserve">
          <source>Performance can be improved and the size reduced by enabling &lt;a href=&quot;compile#threadsafe&quot;&gt;-DSQLITE_THREADSAFE=0&lt;/a&gt;, &lt;a href=&quot;compile#default_memstatus&quot;&gt;-DSQLITE_DEFAULT_MEMSTATUS=0&lt;/a&gt;, &lt;a href=&quot;compile#default_wal_synchronous&quot;&gt;-DSQLITE_DEFAULT_WAL_SYNCHRONOUS=1&lt;/a&gt;, &lt;a href=&quot;compile#like_doesnt_match_blobs&quot;&gt;-DSQLITE_LIKE_DOESNT_MATCH_BLOBS&lt;/a&gt;, &lt;a href=&quot;limits#max_expr_depth&quot;&gt;-DSQLITE_MAX_EXPR_DEPTH=0&lt;/a&gt;, &lt;a href=&quot;compile#omit_decltype&quot;&gt;-DSQLITE_OMIT_DECLTYPE&lt;/a&gt;, &lt;a href=&quot;compile#omit_deprecated&quot;&gt;-DSQLITE_OMIT_DEPRECATED&lt;/a&gt;, &lt;a href=&quot;compile#omit_progress_callback&quot;&gt;-DSQLITE_OMIT_PROGRESS_CALLBACK&lt;/a&gt;, &lt;a href=&quot;compile#omit_shared_cache&quot;&gt;-DSQLITE_OMIT_SHARED_CACHE&lt;/a&gt;, and &lt;a href=&quot;compile#use_alloca&quot;&gt;-DSQLITE_USE_ALLOCA&lt;/a&gt;. All these options together result in about a 3.5% performance increase and a 3.0% size reduction.</source>
          <target state="translated">Производительность может быть улучшена , и размер уменьшен, позволяя &lt;a href=&quot;compile#threadsafe&quot;&gt;-DSQLITE_THREADSAFE = 0&lt;/a&gt; , &lt;a href=&quot;compile#default_memstatus&quot;&gt;-DSQLITE_DEFAULT_MEMSTATUS = 0&lt;/a&gt; , &lt;a href=&quot;compile#default_wal_synchronous&quot;&gt;-DSQLITE_DEFAULT_WAL_SYNCHRONOUS = 1&lt;/a&gt; , &lt;a href=&quot;compile#like_doesnt_match_blobs&quot;&gt;-DSQLITE_LIKE_DOESNT_MATCH_BLOBS&lt;/a&gt; , &lt;a href=&quot;limits#max_expr_depth&quot;&gt;-DSQLITE_MAX_EXPR_DEPTH = 0&lt;/a&gt; , &lt;a href=&quot;compile#omit_decltype&quot;&gt;-DSQLITE_OMIT_DECLTYPE&lt;/a&gt; , &lt;a href=&quot;compile#omit_deprecated&quot;&gt;-DSQLITE_OMIT_DEPRECATED&lt;/a&gt; , &lt;a href=&quot;compile#omit_progress_callback&quot;&gt;-DSQLITE_OMIT_PROGRESS_CALLBACK&lt;/a&gt; , &lt;a href=&quot;compile#omit_shared_cache&quot;&gt;-DSQLITE_OMIT_SHARED_CACHE&lt;/a&gt; и &lt;a href=&quot;compile#use_alloca&quot;&gt;-DSQLITE_USE_ALLOCA&lt;/a&gt; . Все эти параметры вместе приводят к увеличению производительности примерно на 3,5% и уменьшению размера на 3,0%.</target>
        </trans-unit>
        <trans-unit id="1860a0dfdb81986d4ea2f6eb535ec453b85d5fe2" translate="yes" xml:space="preserve">
          <source>Performance does not always increase with memory-mapped I/O. In fact, it is possible to construct test cases where performance is reduced by the use of memory-mapped I/O.</source>
          <target state="translated">Производительность не всегда повышается при вводе/выводе данных с отображением на карте памяти.Фактически,можно построить тестовые случаи,когда производительность снижается за счет использования ввода/вывода с отображением на карте памяти.</target>
        </trans-unit>
        <trans-unit id="61bd66ed39fd686f0ca14a86562254f51520b57c" translate="yes" xml:space="preserve">
          <source>Performance enhancement: Reengineer the internal routines used to interpret and render variable-length integers.</source>
          <target state="translated">Повышение производительности:Реинжиниринг внутренних процедур,используемых для интерпретации и вывода целых чисел переменной длины.</target>
        </trans-unit>
        <trans-unit id="cea233e3b9eddbf52457c8a5a182ae23ce06f170" translate="yes" xml:space="preserve">
          <source>Performance enhancements in the &lt;a href=&quot;lemon&quot;&gt;Lemon&lt;/a&gt;-generated parser</source>
          <target state="translated">Повышение производительности синтаксического анализатора, созданного &lt;a href=&quot;lemon&quot;&gt;Lemon&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c2ed78164f58cda3689de3af94b6683e701f4012" translate="yes" xml:space="preserve">
          <source>Performance enhancements in the VDBE, especially to the OP_Column opcode.</source>
          <target state="translated">Улучшения производительности в VDBE,особенно в коде колонки OP_Column.</target>
        </trans-unit>
        <trans-unit id="3e83f7e02f169f16c4ce4c1bf1daf1d4f6a2d0dd" translate="yes" xml:space="preserve">
          <source>Performance enhancements in the parser.</source>
          <target state="translated">Улучшение производительности парсера.</target>
        </trans-unit>
        <trans-unit id="1553d9684987d03c293eb61361d1bad6eb661140" translate="yes" xml:space="preserve">
          <source>Performance enhancements in the sorter used by ORDER BY and CREATE INDEX.</source>
          <target state="translated">Улучшение производительности сортировщика,используемого ORDER BY и CREATE INDEX.</target>
        </trans-unit>
        <trans-unit id="d07c917b16f3c5d3172eade92a68d5375afe8a41" translate="yes" xml:space="preserve">
          <source>Performance enhancements on some corner cases of COUNT(*).</source>
          <target state="translated">Повышение эффективности в некоторых угловых случаях COUNT(*).</target>
        </trans-unit>
        <trans-unit id="2136335adf2e68388f67bd194f29e528095a22d7" translate="yes" xml:space="preserve">
          <source>Performance enhancements through reductions in disk I/O:</source>
          <target state="translated">Повышение производительности за счет сокращения дисковых входов/выходов:</target>
        </trans-unit>
        <trans-unit id="f10f9c4b246cd76bbc82d16d809b97086003c9dc" translate="yes" xml:space="preserve">
          <source>Performance enhancements to tree balancing logic in the B-Tree layer.</source>
          <target state="translated">Повышение производительности логики балансировки деревьев в слое B-Tree.</target>
        </trans-unit>
        <trans-unit id="c1957e5fe4e4a95d607424db9c544dbfb2c9f147" translate="yes" xml:space="preserve">
          <source>Performance enhancements.</source>
          <target state="translated">Улучшения производительности.</target>
        </trans-unit>
        <trans-unit id="fd543174849447437d626cec826158c9d3d9aa89" translate="yes" xml:space="preserve">
          <source>Performance improvement: Constant subexpressions are factored out of loops.</source>
          <target state="translated">Улучшение производительности:Постоянные подвыражения исключены из циклов.</target>
        </trans-unit>
        <trans-unit id="6267206177784b60f0b03bc62ec213be82afcde6" translate="yes" xml:space="preserve">
          <source>Performance improvement: Results of OP_Column are reused rather than issuing multiple OP_Column opcodes.</source>
          <target state="translated">Улучшение производительности:Результаты работы столбца OP_Column используются повторно,вместо того,чтобы выдавать несколько опкодов столбца OP_Column.</target>
        </trans-unit>
        <trans-unit id="865a67eeabea312b0a75ae22ab67eb186cfe013a" translate="yes" xml:space="preserve">
          <source>Performance improvement: The OP_IdxDelete opcode uses unpacked records, obviating the need for one OP_MakeRecord opcode call for each index record deleted.</source>
          <target state="translated">Улучшение производительности:Опкод OP_IdxDelete использует распакованные записи,избавляя от необходимости одного вызова опкода OP_MakeRecord для каждой удаленной индексной записи.</target>
        </trans-unit>
        <trans-unit id="78e2db7e7f2b2267a1830af4b4a2ed0ba33c683b" translate="yes" xml:space="preserve">
          <source>Performance improvements for &quot;count(*)&quot; queries.</source>
          <target state="translated">Улучшение производительности для запросов &quot;count(*)&quot;.</target>
        </trans-unit>
        <trans-unit id="6efb6a4d8f17dc824c346d05f15cd7b2b88dcf5d" translate="yes" xml:space="preserve">
          <source>Performance improvements for &lt;a href=&quot;lang_select#orderby&quot;&gt;ORDER BY&lt;/a&gt;, &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt;, &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt;, &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt;, and &lt;a href=&quot;pragma#pragma_quick_check&quot;&gt;PRAGMA quick_check&lt;/a&gt;.</source>
          <target state="translated">Улучшения производительности для &lt;a href=&quot;lang_select#orderby&quot;&gt;ORDER BY&lt;/a&gt; , &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; , &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt; , &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA Integrity_check&lt;/a&gt; и &lt;a href=&quot;pragma#pragma_quick_check&quot;&gt;PRAGMA quick_check&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c7ba2d57a08f2fc705e0114aa7d1ce0a8358e340" translate="yes" xml:space="preserve">
          <source>Performance improvements for &lt;a href=&quot;pragma#pragma_incremental_vacuum&quot;&gt;PRAGMA incremental_vacuum&lt;/a&gt;, especially in cases where the number of free pages is greater than what will fit on a single trunk page of the freelist.</source>
          <target state="translated">Улучшения производительности &lt;a href=&quot;pragma#pragma_incremental_vacuum&quot;&gt;PRAGMA incremental_vacuum&lt;/a&gt; , особенно в случаях, когда количество свободных страниц больше, чем умещается на одной основной странице списка фрилансеров .</target>
        </trans-unit>
        <trans-unit id="ca9c11fd98f734889e089bb0e89c4f23dda7fe58" translate="yes" xml:space="preserve">
          <source>Performance improvements in the LEMON-generated parser.</source>
          <target state="translated">Улучшение производительности парсера LEMON.</target>
        </trans-unit>
        <trans-unit id="a14e5b6d4c4866ac4384c7883a92dffe274c0fdc" translate="yes" xml:space="preserve">
          <source>Performance improvements in the parser, pager, and WHERE clause code generator.</source>
          <target state="translated">Улучшение производительности парсера,пейджера и генератора кода пункта WHERE.</target>
        </trans-unit>
        <trans-unit id="4775771a833741ba344ee91f202aad2d4ccd4444" translate="yes" xml:space="preserve">
          <source>Performance improvements in the query optimizer.</source>
          <target state="translated">Улучшение производительности оптимизатора запросов.</target>
        </trans-unit>
        <trans-unit id="db2c756a058cad6c443215c62bd837d8ebcd7c86" translate="yes" xml:space="preserve">
          <source>Performance improvements. The library is now much faster.</source>
          <target state="translated">Улучшения производительности.Библиотека теперь работает намного быстрее.</target>
        </trans-unit>
        <trans-unit id="7776d02639084ffcec06b8eee5d8080752868819" translate="yes" xml:space="preserve">
          <source>Performance measurements are done with a single compiler (gcc 5.4.0), optimization setting (-Os), and on a single platform (Ubuntu 16.04 LTS on x64). The performance of other compilers and processors may vary.</source>
          <target state="translated">Измерение производительности производится с помощью одного компилятора (gcc 5.4.0),установки оптимизации (-O),и на одной платформе (Ubuntu 16.04 LTS на x64).Производительность других компиляторов и процессоров может отличаться.</target>
        </trans-unit>
        <trans-unit id="4313721e53c3870801c269d394561df5830ac670" translate="yes" xml:space="preserve">
          <source>Performance optimizations targeting a specific use case from a single high-profile user of SQLite. A 12% reduction in the number of CPU operations is achieved (as measured by Valgrind). Actual performance improvements in practice may vary depending on workload. Changes include:</source>
          <target state="translated">Оптимизация производительности для конкретного случая использования от одного высокопоставленного пользователя SQLite.Достигнуто снижение количества операций на процессоре на 12% (по данным Valgrind).Фактическое повышение производительности на практике может варьироваться в зависимости от рабочей нагрузки.Изменения включают в себя:</target>
        </trans-unit>
        <trans-unit id="aafc19be49f715a88d989d3b462949b02cf65924" translate="yes" xml:space="preserve">
          <source>Performance problems can often be resolved, even late in the development cycle, using &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt;, avoiding costly redesign, rewrite, and retest efforts.</source>
          <target state="translated">Проблемы производительности часто можно решить, даже на поздних этапах цикла разработки, с помощью &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt; , избегая дорогостоящих усилий по редизайну, переписыванию и повторному тестированию.</target>
        </trans-unit>
        <trans-unit id="80d748ed593bda4d15f97528a4a48c139940ad2c" translate="yes" xml:space="preserve">
          <source>Performance was measured by running speedtest1 using cachegrind and observing the &quot;I refs&quot; output.</source>
          <target state="translated">Производительность измерялась с помощью теста скорости работы1 с использованием кэш-функции измельчения и наблюдением за выводом &quot;I refs&quot;.</target>
        </trans-unit>
        <trans-unit id="fd932d13fa7bed8f3a51946f0c1cded4ce734cc8" translate="yes" xml:space="preserve">
          <source>Performance was measured using the &lt;a href=&quot;https://sqlite.org/src/file/test/speedtest1.c&quot;&gt;speedtest1.c&lt;/a&gt; utility program, which attempts to mimic a typical workload for SQLite. Options to the test runs are:</source>
          <target state="translated">Производительность измерялась с помощью служебной программы &lt;a href=&quot;https://sqlite.org/src/file/test/speedtest1.c&quot;&gt;speedtest1.c&lt;/a&gt; , которая пытается имитировать типичную рабочую нагрузку для SQLite. Варианты тестовых прогонов:</target>
        </trans-unit>
        <trans-unit id="306df6900907956d3250e5c6b9116143f3e59d56" translate="yes" xml:space="preserve">
          <source>Perhaps you are referring to the following statement from SQL92:</source>
          <target state="translated">Возможно,вы имеете в виду следующее утверждение из SQL92:</target>
        </trans-unit>
        <trans-unit id="dc174949d4e077b47c1979929b03d9b696ed5987" translate="yes" xml:space="preserve">
          <source>Permit SELECT statements without a FROM clause.</source>
          <target state="translated">Разрешение на выбор заявлений без пункта FROM.</target>
        </trans-unit>
        <trans-unit id="6cbfe59727ef5993727b847bb5705e98e92cb339" translate="yes" xml:space="preserve">
          <source>Permutation</source>
          <target state="translated">Permutation</target>
        </trans-unit>
        <trans-unit id="4fce736ea498cc616300b0a192c1d1da1b783f4c" translate="yes" xml:space="preserve">
          <source>Permuted Title Index</source>
          <target state="translated">Индекс презумпции титула</target>
        </trans-unit>
        <trans-unit id="d33cf936053187794d74699260279a0a85c60b95" translate="yes" xml:space="preserve">
          <source>Persistent loadable extensions</source>
          <target state="translated">Постоянно загружаемые удлинители</target>
        </trans-unit>
        <trans-unit id="cda60e78224642430ac8ecc50f20cf5762fbe57b" translate="yes" xml:space="preserve">
          <source>Phrase and NEAR queries may not span multiple columns within a row.</source>
          <target state="translated">Фразы и запросы NEAR не могут охватывать несколько столбцов в пределах строки.</target>
        </trans-unit>
        <trans-unit id="8867fcbca825b3aa1d7306421a378db86e201e5f" translate="yes" xml:space="preserve">
          <source>Phrase queries</source>
          <target state="translated">фразовые запросы</target>
        </trans-unit>
        <trans-unit id="a363180d8d104ea58876b6a7416ecc65d37a83bd" translate="yes" xml:space="preserve">
          <source>Phrase queries are not available.</source>
          <target state="translated">Фразовые запросы недоступны.</target>
        </trans-unit>
        <trans-unit id="c2d36c2214269a55cf08fe15db0efb7f6b50dc52" translate="yes" xml:space="preserve">
          <source>Phrases and NEAR groups may also be connected by &lt;b&gt;implicit AND operators&lt;/b&gt;. For simplicity, these are not shown in the BNF grammar above. Essentially, any sequence of phrases or NEAR groups (including those restricted to matching specified columns) separated only by whitespace are handled as if there were an implicit AND operator between each pair of phrases or NEAR groups. Implicit AND operators are never inserted after or before an expression enclosed in parenthesis. For example:</source>
          <target state="translated">Фразы и группы NEAR также могут быть связаны &lt;b&gt;неявными операторами AND&lt;/b&gt; . Для простоты они не показаны в грамматике BNF выше. По сути, любая последовательность фраз или групп NEAR (включая те, которые ограничены указанными столбцами), разделенные только пробелом, обрабатываются так, как если бы между каждой парой фраз или группами NEAR был неявный оператор AND. Неявные операторы И никогда не вставляются после или перед выражением, заключенным в круглые скобки. Например:</target>
        </trans-unit>
        <trans-unit id="c324bfc69bd8b1bd8095017021f5a91e3ea40b2c" translate="yes" xml:space="preserve">
          <source>Phrases and NEAR groups may be arranged into expressions using &lt;b&gt;boolean operators&lt;/b&gt;. In order of precedence, from highest (tightest grouping) to lowest (loosest grouping), the operators are:</source>
          <target state="translated">Фразы и группы NEAR могут быть объединены в выражения с использованием &lt;b&gt;логических операторов&lt;/b&gt; . В порядке приоритета, от самого высокого (самая плотная группировка) до самого низкого (самая слабая группировка), операторы:</target>
        </trans-unit>
        <trans-unit id="3ae7ce4ac376e04456d5e49b6ed2413b1a3d558b" translate="yes" xml:space="preserve">
          <source>Picking the nested order of the various loops</source>
          <target state="translated">Выбирая вложенный порядок различных петель</target>
        </trans-unit>
        <trans-unit id="e6557cb061d60a980305721118e117b8668196a9" translate="yes" xml:space="preserve">
          <source>Picking the nesting order is generally the more challenging problem. Once the nesting order of the join is established, the choice of indexes for each loop is normally obvious.</source>
          <target state="translated">Выбор порядка гнездования,как правило,является более сложной проблемой.Как только порядок вложенности соединения установлен,выбор индексов для каждого цикла,как правило,очевиден.</target>
        </trans-unit>
        <trans-unit id="48838d5eebf4e016bae8e0582e9b79166631f842" translate="yes" xml:space="preserve">
          <source>Pinning (reading) a database page.</source>
          <target state="translated">Пиннинг (чтение)страницы базы данных.</target>
        </trans-unit>
        <trans-unit id="e786fb34d40222929b9ef3bd84afa78c0fc799e8" translate="yes" xml:space="preserve">
          <source>Plays better with virus scanners on Windows</source>
          <target state="translated">Играет лучше с антивирусными сканерами на Windows</target>
        </trans-unit>
        <trans-unit id="0ba6acad031749dfc1ea19f37cf3cf3ba6821875" translate="yes" xml:space="preserve">
          <source>Please pay particular attention to the fact that the pointer returned from &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_blob()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_text()&lt;/a&gt;, or &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_text16()&lt;/a&gt; can be invalidated by a subsequent call to &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_bytes()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_bytes16()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_text()&lt;/a&gt;, or &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_text16()&lt;/a&gt;.</source>
          <target state="translated">Пожалуйста , обратите особое внимание на то , что указатель вернулся из &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_blob ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_text ()&lt;/a&gt; , или &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_text16 ()&lt;/a&gt; могут быть признаны недействительными последующим вызовом &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_bytes ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_bytes16 ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_text ()&lt;/a&gt; , или &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_text16 ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7ae91e82ac5caaf87714c26921fb437ec0209ebd" translate="yes" xml:space="preserve">
          <source>Please pay particular attention to the fact that the pointer returned from &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_blob()&lt;/a&gt;, &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_text()&lt;/a&gt;, or &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_text16()&lt;/a&gt; can be invalidated by a subsequent call to &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_bytes()&lt;/a&gt;, &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_bytes16()&lt;/a&gt;, &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_text()&lt;/a&gt;, or &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_text16()&lt;/a&gt;.</source>
          <target state="translated">Пожалуйста , обратите особое внимание на то , что указатель вернулся из &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_blob ()&lt;/a&gt; , &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_text ()&lt;/a&gt; , или &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_text16 ()&lt;/a&gt; могут быть признаны недействительными последующим вызовом &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_bytes ()&lt;/a&gt; , &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_bytes16 ()&lt;/a&gt; , &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_text ()&lt;/a&gt; , или &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_text16 ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="82e80b8ed5a5ef5a7f7f84502fd344efe74ab819" translate="yes" xml:space="preserve">
          <source>Plug some memory leaks that use to occur if malloc() failed. We have been and continue to be memory leak free as long as malloc() works.</source>
          <target state="translated">Подключите некоторые утечки памяти,которые происходят,если malloc()не удалось.Мы были и остаемся свободными от утечек памяти до тех пор,пока работает malloc().</target>
        </trans-unit>
        <trans-unit id="9885c5aa124b354814a6a44123b3e909495fe046" translate="yes" xml:space="preserve">
          <source>Pointer Passing Interfaces</source>
          <target state="translated">Интерфейсы передачи указателей</target>
        </trans-unit>
        <trans-unit id="59e3eae717dea15b934265a0c37302cf590a5714" translate="yes" xml:space="preserve">
          <source>Pointer leak</source>
          <target state="translated">Утечка указателя</target>
        </trans-unit>
        <trans-unit id="893d8abe3b1d2dc513b4dcba9c2db9ee48da24a6" translate="yes" xml:space="preserve">
          <source>Pointer map or ptrmap pages are extra pages inserted into the database to make the operation of &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum&lt;/a&gt; and &lt;a href=&quot;pragma#pragma_incremental_vacuum&quot;&gt;incremental_vacuum&lt;/a&gt; modes more efficient. Other page types in the database typically have pointers from parent to child. For example, an interior b-tree page contains pointers to its child b-tree pages and an overflow chain has a pointer from earlier to later links in the chain. A ptrmap page contains linkage information going in the opposite direction, from child to parent.</source>
          <target state="translated">Страницы Pointer map или ptrmap - это дополнительные страницы, вставленные в базу данных, чтобы сделать работу &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;режимов auto_vacuum&lt;/a&gt; и &lt;a href=&quot;pragma#pragma_incremental_vacuum&quot;&gt;incremental_vacuum&lt;/a&gt; более эффективной. Другие типы страниц в базе данных обычно имеют указатели от родительского к дочернему. Например, внутренняя страница b-дерева содержит указатели на свои дочерние страницы b-дерева, а цепочка переполнения имеет указатель с более ранних на более поздние ссылки в цепочке. Страница ptrmap содержит информацию о связях, идущую в противоположном направлении, от дочернего к родительскому.</target>
        </trans-unit>
        <trans-unit id="d9fb370b0a40e2e2f19446936bcadb07206247ac" translate="yes" xml:space="preserve">
          <source>Pointer types</source>
          <target state="translated">Типы указателей</target>
        </trans-unit>
        <trans-unit id="1091e0ac6927998f6cf6d184bfe2c9b9dcea6870" translate="yes" xml:space="preserve">
          <source>Pointer types are static strings, which ideally should be string literals embedded directly in the SQLite API call, not parameters passed in from other functions. Consideration was given to using integer values as the pointer type, but static strings provides a much larger name space which reduces the chance of accidental type-name collisions between unrelated extensions.</source>
          <target state="translated">Типы указателей-это статические строки,которые в идеале должны быть строковыми литералами,встроенными непосредственно в вызов SQLite API,а не параметрами,передаваемыми из других функций.Рассматривалось использование целочисленных значений в качестве типа указателя,но статические строки обеспечивают гораздо большее пространство имён,что снижает вероятность случайных коллизий между не связанными между собой расширениями.</target>
        </trans-unit>
        <trans-unit id="3b1d288532e92abf21814dda987180d6353e6315" translate="yes" xml:space="preserve">
          <source>Pointer values generated by &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer()&lt;/a&gt; and &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer()&lt;/a&gt; cannot be read by pure SQL. Hence, it is not possible for SQL to leak the value of pointers.</source>
          <target state="translated">Значения указателей, сгенерированные &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer ()&lt;/a&gt; и &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer (),&lt;/a&gt; не могут быть прочитаны чистым SQL. Следовательно, SQL не может утечь значение указателей.</target>
        </trans-unit>
        <trans-unit id="362edd7f45230e1071baa348e5b8aa0beef2dc87" translate="yes" xml:space="preserve">
          <source>Pointer values must flow directly from their producer into their consumer, with no intermediate operators or functions. Any transformation of a pointer value destroys the pointer and transforms the value into an ordinary SQL NULL.</source>
          <target state="translated">Значения указателей должны поступать непосредственно от производителя к потребителю,без промежуточных операторов и функций.Любое преобразование значения указателя уничтожает указатель и превращает его в обычный SQL NULL.</target>
        </trans-unit>
        <trans-unit id="d40a766f8bf600e29b3ebb06afc3c66d8eb2275c" translate="yes" xml:space="preserve">
          <source>Pointer values read by &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_pointer()&lt;/a&gt; cannot be generated by pure SQL. Hence, it is not possible for SQL to forge pointers.</source>
          <target state="translated">Значения указателя, считываемые &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_pointer (),&lt;/a&gt; не могут быть сгенерированы чистым SQL. Следовательно, SQL не может подделывать указатели.</target>
        </trans-unit>
        <trans-unit id="074017050c52f59774a49045cefb3a8e55469503" translate="yes" xml:space="preserve">
          <source>Pointers should &lt;u&gt;never&lt;/u&gt; be exchanged by encoding them as some other SQL datatype, such as integers or BLOBs. Instead, use the interfaces designed to facilitate secure pointer passing: &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer()&lt;/a&gt;, &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer()&lt;/a&gt;, and &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_pointer()&lt;/a&gt;.</source>
          <target state="translated">Указатели &lt;u&gt;никогда не&lt;/u&gt; следует обменивать, кодируя их как другой тип данных SQL, например целые числа или большие двоичные объекты. Вместо этого используйте интерфейсы, разработанные для облегчения безопасной передачи указателей: &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer ()&lt;/a&gt; , &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer ()&lt;/a&gt; и &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_pointer ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3758fcfa626c0aaafd8e85f7ec0b94d37eb1b41f" translate="yes" xml:space="preserve">
          <source>Porting SQLite To New Operating Systems</source>
          <target state="translated">Портирование SQLite на новые операционные системы</target>
        </trans-unit>
        <trans-unit id="492619cf72b9410d05b5a1fac306af0804a5c47b" translate="yes" xml:space="preserve">
          <source>Position cursor P1 at the end of the btree for the purpose of appending a new entry onto the btree.</source>
          <target state="translated">Установите курсор P1 в конце дерева для добавления новой записи в дерево.</target>
        </trans-unit>
        <trans-unit id="24fd6c2d1150de6a47543209150ff4c2a2d3104f" translate="yes" xml:space="preserve">
          <source>PostgreSQL</source>
          <target state="translated">PostgreSQL</target>
        </trans-unit>
        <trans-unit id="a6c78fee1df30606dfc4f598f623eca0d1354255" translate="yes" xml:space="preserve">
          <source>PostgreSQL:</source>
          <target state="translated">PostgreSQL:</target>
        </trans-unit>
        <trans-unit id="957feaeb06e5a65656c3283c9c7193ebcf008b45" translate="yes" xml:space="preserve">
          <source>Postpone I/O associated with TEMP files for as long as possible, with the hope that the I/O can ultimately be avoided completely.</source>
          <target state="translated">Отложите ввод/вывод,связанный с файлами TEMP,на как можно более долгий срок,надеясь,что в конечном итоге можно будет полностью избежать ввода/вывода.</target>
        </trans-unit>
        <trans-unit id="1bdd037a51c3dae4c27aa3b443867933947439ca" translate="yes" xml:space="preserve">
          <source>Powersafe Overwrite</source>
          <target state="translated">Powersafe Overwrite</target>
        </trans-unit>
        <trans-unit id="10329807f69720bd141eb1a12685730b2cfaf4cd" translate="yes" xml:space="preserve">
          <source>Pragma list</source>
          <target state="translated">список прагматиков</target>
        </trans-unit>
        <trans-unit id="c984aa3372c91f167c3b8d4c0c9f9715c82d4221" translate="yes" xml:space="preserve">
          <source>Pragma statements supported by SQLite</source>
          <target state="translated">Прагматические заявления,поддерживаемые SQLite</target>
        </trans-unit>
        <trans-unit id="4a80a5f45da767ce7271bd5ac307890ba0ff78a6" translate="yes" xml:space="preserve">
          <source>Pragmas whose names are &lt;s&gt;struck through&lt;/s&gt; are deprecated. Do not use them. They exist for historical compatibility.</source>
          <target state="translated">Прагмы , чьи имена &lt;s&gt;перечеркнуты&lt;/s&gt; устарели. Не используйте их. Они существуют для исторической совместимости.</target>
        </trans-unit>
        <trans-unit id="36fd60583248a73e8dcb8aeb3b04450519f9ddea" translate="yes" xml:space="preserve">
          <source>Pray for your enemies in the love of Christ.</source>
          <target state="translated">Молитесь о своих врагах в любви Христа.</target>
        </trans-unit>
        <trans-unit id="1d437b581e9dcd72eb07665e29677b9a7ea18988" translate="yes" xml:space="preserve">
          <source>Prefer nothing more than the love of Christ.</source>
          <target state="translated">Не желают ничего,кроме любви Христовой.</target>
        </trans-unit>
        <trans-unit id="6b85b242b16c8eaf303d30b62e8918e8c764ab9e" translate="yes" xml:space="preserve">
          <source>Prefix indexes may be used to optimize &lt;a href=&quot;fts3#termprefix&quot;&gt;prefix queries&lt;/a&gt; in two cases. If the query is for a prefix of N bytes, then a prefix index created with &quot;prefix=N&quot; provides the best optimization. Or, if no &quot;prefix=N&quot; index is available, a &quot;prefix=N+1&quot; index may be used instead. Using a &quot;prefix=N+1&quot; index is less efficient than a &quot;prefix=N&quot; index, but is better than no prefix index at all.</source>
          <target state="translated">Префиксные индексы могут использоваться для оптимизации &lt;a href=&quot;fts3#termprefix&quot;&gt;префиксных запросов&lt;/a&gt; в двух случаях. Если запрос предназначен для префикса из N байтов, то индекс префикса, созданный с помощью &amp;laquo;prefix = N&amp;raquo;, обеспечивает лучшую оптимизацию. Или, если индекс &amp;laquo;prefix = N&amp;raquo; недоступен, вместо него можно использовать индекс &amp;laquo;prefix = N + 1&amp;raquo;. Использование индекса &amp;laquo;prefix = N + 1&amp;raquo; менее эффективно, чем индекс &amp;laquo;prefix = N&amp;raquo;, но лучше, чем отсутствие индекса префикса вообще.</target>
        </trans-unit>
        <trans-unit id="f58acbef3b4f1545b36db43fdb7aa3248226ddc3" translate="yes" xml:space="preserve">
          <source>Prefix query</source>
          <target state="translated">Префиксный запрос</target>
        </trans-unit>
        <trans-unit id="d876a9e47626f4666efcfc69bdf4c50fcc426b9e" translate="yes" xml:space="preserve">
          <source>Prefix search in FTS3 is much more efficient.</source>
          <target state="translated">Префиксный поиск в FTS3 намного эффективнее.</target>
        </trans-unit>
        <trans-unit id="68a57fd3726c085ce337dc259dc3b2499a35efce" translate="yes" xml:space="preserve">
          <source>Preliminaries</source>
          <target state="translated">Preliminaries</target>
        </trans-unit>
        <trans-unit id="f3d20f83dbeeb1d79306958dea533c43146bb29c" translate="yes" xml:space="preserve">
          <source>Prepare Flags</source>
          <target state="translated">Приготовить флаги</target>
        </trans-unit>
        <trans-unit id="d5f65540d8f04f5669bf0a7783fb7256d5f3309f" translate="yes" xml:space="preserve">
          <source>Prepared Statement Object</source>
          <target state="translated">Объект готового заявления</target>
        </trans-unit>
        <trans-unit id="d84580c0a3c076e6a6095c0d8c0427ccdaa13d1e" translate="yes" xml:space="preserve">
          <source>Prepared Statement Scan Status</source>
          <target state="translated">Статус сканирования готовых заявлений</target>
        </trans-unit>
        <trans-unit id="1037ef270384cfd9be096004017447826d2cb2f5" translate="yes" xml:space="preserve">
          <source>Prepared Statement Scan Status Opcodes</source>
          <target state="translated">Готовые заявления Статус сканирования Опкоды</target>
        </trans-unit>
        <trans-unit id="2f5da103100b3440f26c60eb3e05807f62717d70" translate="yes" xml:space="preserve">
          <source>Prepared Statement Status</source>
          <target state="translated">Статус готового заявления</target>
        </trans-unit>
        <trans-unit id="213d6f218c41a8dc480fb564c77564038e40e839" translate="yes" xml:space="preserve">
          <source>Prepend as many &quot;0&quot; characters to numeric substitutions as necessary to expand the value out to the specified width. If the width field is omitted, then this flag is a no-op.</source>
          <target state="translated">Подготовьте к числовым подстановкам столько символов &quot;0&quot;,сколько необходимо для расширения значения до заданной ширины.Если поле &quot;Ширина&quot; опущено,то этот флаг является нулевым.</target>
        </trans-unit>
        <trans-unit id="07ea5425dab39a1ce6090bfaba72b208d8a2bb32" translate="yes" xml:space="preserve">
          <source>Prepend the &quot;&lt;code&gt;file:&lt;/code&gt;&quot; scheme.</source>
          <target state="translated">Добавьте схему &amp;laquo; &lt;code&gt;file:&lt;/code&gt; &amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="b5b2c6aa0c741177b3341a9cac682f0503cc7181" translate="yes" xml:space="preserve">
          <source>Pretend that the single row just extracted is the only row in the recursive table and run the recursive-select, adding all results to the queue.</source>
          <target state="translated">Представьте,что только что извлеченная единственная строка в рекурсивной таблице,и запустите рекурсивный выбор,добавив все результаты в очередь.</target>
        </trans-unit>
        <trans-unit id="e96fea52df5eb0d7ea088eb0523f5fd6be20645f" translate="yes" xml:space="preserve">
          <source>Prev</source>
          <target state="translated">Prev</target>
        </trans-unit>
        <trans-unit id="d011a785f80d4ac2978260fd4baeb9a488339607" translate="yes" xml:space="preserve">
          <source>Prevent journal file overflows on huge transactions.</source>
          <target state="translated">Предотвращение переполнения файлов журнала на огромных транзакциях.</target>
        </trans-unit>
        <trans-unit id="15aff2aaf0be53526cd90b44a8f7faa67462af63" translate="yes" xml:space="preserve">
          <source>Primary location: &lt;a href=&quot;https://www.sqlite.org/docsrc&quot;&gt;https://www.sqlite.org/docsrc&lt;/a&gt;</source>
          <target state="translated">Основное расположение: &lt;a href=&quot;https://www.sqlite.org/docsrc&quot;&gt;https://www.sqlite.org/docsrc&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bb559fe38e423e3bb19de0649fe3fd5b6b237723" translate="yes" xml:space="preserve">
          <source>Primary location: &lt;a href=&quot;https://www.sqlite.org/sqllogictest&quot;&gt;https://www.sqlite.org/sqllogictest&lt;/a&gt;</source>
          <target state="translated">Основное расположение: &lt;a href=&quot;https://www.sqlite.org/sqllogictest&quot;&gt;https://www.sqlite.org/sqllogictest&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="40da77fe99b4c2e0002b4b5a88b9bdf5b5ffd788" translate="yes" xml:space="preserve">
          <source>Primary location: &lt;a href=&quot;https://www.sqlite.org/src&quot;&gt;https://www.sqlite.org/src&lt;/a&gt;</source>
          <target state="translated">Основное расположение: &lt;a href=&quot;https://www.sqlite.org/src&quot;&gt;https://www.sqlite.org/src&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="72c44b5ab0d08449343e1c11f7db59a0baee6a06" translate="yes" xml:space="preserve">
          <source>Primary location: &lt;a href=&quot;https://www.sqlite.org/th3&quot;&gt;https://www.sqlite.org/th3&lt;/a&gt;</source>
          <target state="translated">Основное расположение: &lt;a href=&quot;https://www.sqlite.org/th3&quot;&gt;https://www.sqlite.org/th3&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="284d8db03255f327420e4917415f7de011fcda53" translate="yes" xml:space="preserve">
          <source>Primary location: &lt;a href=&quot;https://www.sqlite.org/th3private&quot;&gt;https://www.sqlite.org/th3private&lt;/a&gt;</source>
          <target state="translated">Основное расположение: &lt;a href=&quot;https://www.sqlite.org/th3private&quot;&gt;https://www.sqlite.org/th3private&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="12c6ce30d8dde9c30a0548e43a1a65f2399c3ac8" translate="yes" xml:space="preserve">
          <source>Primary result code symbolic names are of the form &quot;SQLITE_XXXXXX&quot; where XXXXXX is a sequence of uppercase alphabetic characters. Extended result code names are of the form &quot;SQLITE_XXXXXX_YYYYYYY&quot; where the XXXXXX part is the corresponding primary result code and the YYYYYYY is an extension that further classifies the result code.</source>
          <target state="translated">Код первичного результата-символические имена формы &quot;SQLITE_XXXXXX&quot;,где XXXXXX-это последовательность заглавных алфавитных символов.Расширенные кодовые имена результата относятся к форме &quot;SQLITE_XXXXXX_YYYYYYY&quot;,где XXXXXX часть является соответствующим первичным кодом результата,а YYYYYY является расширением,которое далее классифицирует код результата.</target>
        </trans-unit>
        <trans-unit id="4fda803b9a957798a3e6c9099105e126c5e73e36" translate="yes" xml:space="preserve">
          <source>Primary versus extended result codes</source>
          <target state="translated">Первичный и расширенный коды результатов</target>
        </trans-unit>
        <trans-unit id="3b2d52029dad08f51a816bff4a2b1ace042995a8" translate="yes" xml:space="preserve">
          <source>Print the offending SQL statement when an error occurs.</source>
          <target state="translated">При возникновении ошибки выведите на печать оскорбительный SQL-оператор.</target>
        </trans-unit>
        <trans-unit id="93863d358af110c5080e64cc1cfc5d8749e0490f" translate="yes" xml:space="preserve">
          <source>Prior to &lt;a href=&quot;https://sqlite.org/releaselog/3_8_0.html&quot;&gt;version 3.8.0&lt;/a&gt; (2013-08-26), SQLite always used the &quot;Nearest Neighbor&quot; or &quot;NN&quot; heuristic when searching for the best query plan. The NN heuristic makes a single traversal of the graph, always choosing the lowest-cost arc as the next step. The NN heuristic works surprisingly well in most cases. And NN is fast, so that SQLite is able to quickly find good plans for even large 64-way joins. In contrast, other SQL database engines that do more extensive searching tend to bog down when the number of tables in a join goes above 10 or 15.</source>
          <target state="translated">До &lt;a href=&quot;https://sqlite.org/releaselog/3_8_0.html&quot;&gt;версии 3.8.0&lt;/a&gt; (2013-08-26) SQLite всегда использовала эвристику &amp;laquo;Ближайший сосед&amp;raquo; или &amp;laquo;NN&amp;raquo; при поиске лучшего плана запроса. Эвристика NN выполняет однократный обход графа, всегда выбирая дугу с наименьшей стоимостью в качестве следующего шага. В большинстве случаев эвристика NN работает на удивление хорошо. NN работает быстро, так что SQLite может быстро найти хорошие планы даже для больших 64-сторонних соединений. Напротив, другие механизмы баз данных SQL, которые выполняют более обширный поиск, имеют тенденцию останавливаться, когда количество таблиц в объединении превышает 10 или 15.</target>
        </trans-unit>
        <trans-unit id="0cbead769cfd094dac2d1d702814135203e88038" translate="yes" xml:space="preserve">
          <source>Prior to SQLite 3.20.0 (2017-08-01) all date/time functions were always considered non-deterministic. The ability for date/time functions to be deterministic sometimes and non-deterministic at other times, depending on their arguments, was added for the 3.20.0 release.</source>
          <target state="translated">До SQLite 3.20.0 (2017-08-01)все функции даты/времени всегда считались недетерминированными.В версии 3.20.0 была добавлена способность функций даты/времени быть детерминированными иногда и недетерминированными в другое время,в зависимости от их аргументов.</target>
        </trans-unit>
        <trans-unit id="6c7f8cc84bc5292827563b13ba75248881d97140" translate="yes" xml:space="preserve">
          <source>Prior to SQLite 3.7.15 (2012-12-12), a subquery in the FROM clause would be either flattened into the outer query, or else the subquery would be run to completion before the outer query started, the result set from the subquery would be stored in a transient table, and then the transient table would be used in the outer query. Newer versions of SQLite have a third option, which is to implement the subquery using a co-routine.</source>
          <target state="translated">До SQLite 3.7.15 (2012-12-12)подзапрос в пункте FROM либо сплющивался во внешний запрос,либо подзапрос выполнялся до начала внешнего запроса,набор результатов из подзапроса хранился в переходной таблице,а затем переходная таблица использовалась во внешнем запросе.В более новых версиях SQLite есть третий вариант,который заключается в реализации подзапроса с использованием ко-маршрутизации.</target>
        </trans-unit>
        <trans-unit id="a720aafd2afa8c2c385472fc2e648bd2ccdf321e" translate="yes" xml:space="preserve">
          <source>Prior to SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_11_0.html&quot;&gt;version 3.11.0&lt;/a&gt; (2016-02-15), the arguments to fts3_tokenzer() could be literal strings or BLOBs. They did not have to be &lt;a href=&quot;lang_expr#varparam&quot;&gt;bound parameters&lt;/a&gt;. But that could lead to security problems in the event of an SQL injection. Hence, the legacy behavior is now disabled by default. But the old legacy behavior can be enabled, for backwards compatibility in applications that really need it, by calling &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigenablefts3tokenizer&quot;&gt;SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER&lt;/a&gt;,1,0).</source>
          <target state="translated">До версии SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_11_0.html&quot;&gt;3.11.0&lt;/a&gt; (15.02.2016) аргументы функции fts3_tokenzer () могли быть буквальными строками или большими двоичными объектами. Им не нужно было &lt;a href=&quot;lang_expr#varparam&quot;&gt;связывать параметры&lt;/a&gt; . Но это может привести к проблемам с безопасностью в случае SQL-инъекции. Следовательно, устаревшее поведение по умолчанию отключено. Но старое устаревшее поведение можно включить для обратной совместимости в приложениях, которые действительно в нем нуждаются, путем вызова &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config&lt;/a&gt; (db, &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigenablefts3tokenizer&quot;&gt;SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER&lt;/a&gt; , 1,0).</target>
        </trans-unit>
        <trans-unit id="51d8edb11a84377ed9b294770763b3964473b7ee" translate="yes" xml:space="preserve">
          <source>Prior to SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_6_17.html&quot;&gt;version 3.6.17&lt;/a&gt; (2009-08-10), the virtual table mechanism assumes that each &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; kept its own copy of the database schema. Hence, the virtual table mechanism could not be used in a database that has &lt;a href=&quot;sharedcache&quot;&gt;shared cache mode&lt;/a&gt; enabled. The &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module()&lt;/a&gt; interface would return an error if &lt;a href=&quot;sharedcache&quot;&gt;shared cache mode&lt;/a&gt; is enabled. That restriction was relaxed beginning with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_6_17.html&quot;&gt;version 3.6.17&lt;/a&gt;.</source>
          <target state="translated">До версии SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_6_17.html&quot;&gt;3.6.17&lt;/a&gt; ( 10.08.2009 ) механизм виртуальных таблиц предполагает, что каждое &lt;a href=&quot;c3ref/sqlite3&quot;&gt;соединение с базой данных&lt;/a&gt; хранит свою собственную копию схемы базы данных. Следовательно, механизм виртуальной таблицы не может использоваться в базе данных, в которой включен &lt;a href=&quot;sharedcache&quot;&gt;режим общего кэша&lt;/a&gt; . Интерфейс &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module ()&lt;/a&gt; вернет ошибку, если включен &lt;a href=&quot;sharedcache&quot;&gt;режим общего кеша&lt;/a&gt; . Это ограничение было ослаблено, начиная с &lt;a href=&quot;https://sqlite.org/releaselog/3_6_17.html&quot;&gt;версии&lt;/a&gt; SQLite 3.6.17 .</target>
        </trans-unit>
        <trans-unit id="33d0fd70a8f55e9f98c0c7adf04301e981d0c322" translate="yes" xml:space="preserve">
          <source>Prior to SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_6_18.html&quot;&gt;version 3.6.18&lt;/a&gt; (2009-09-11), recursive triggers were not supported. The behavior of SQLite was always as if this pragma was set to OFF. Support for recursive triggers was added in version 3.6.18 but was initially turned OFF by default, for compatibility. Recursive triggers may be turned on by default in future versions of SQLite.</source>
          <target state="translated">До версии SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_6_18.html&quot;&gt;3.6.18&lt;/a&gt; (11 сентября 2009 г. ) рекурсивные триггеры не поддерживались. Поведение SQLite всегда было таким, как если бы эта прагма была отключена. Поддержка рекурсивных триггеров была добавлена ​​в версии 3.6.18, но изначально была отключена по умолчанию для совместимости. Рекурсивные триггеры могут быть включены по умолчанию в будущих версиях SQLite.</target>
        </trans-unit>
        <trans-unit id="a28758e140ed243892fd7015e84c9739d352fdbe" translate="yes" xml:space="preserve">
          <source>Prior to SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_6_18.html&quot;&gt;version 3.6.18&lt;/a&gt; (2009-09-11), triggers were not recursive and so this limit was meaningless. Beginning with version 3.6.18, recursive triggers were supported but had to be explicitly enabled using the &lt;a href=&quot;pragma#pragma_recursive_triggers&quot;&gt;PRAGMA recursive_triggers&lt;/a&gt; statement. Beginning with &lt;a href=&quot;https://sqlite.org/releaselog/3_7_0.html&quot;&gt;version 3.7.0&lt;/a&gt; (2009-09-11), recursive triggers are enabled by default but can be manually disabled using &lt;a href=&quot;pragma#pragma_recursive_triggers&quot;&gt;PRAGMA recursive_triggers&lt;/a&gt;. The SQLITE_MAX_TRIGGER_DEPTH is only meaningful if recursive triggers are enabled.</source>
          <target state="translated">До версии SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_6_18.html&quot;&gt;3.6.18&lt;/a&gt; (11 сентября 2009 г. ) триггеры не были рекурсивными, поэтому этот предел не имел смысла. Начиная с версии 3.6.18, рекурсивные триггеры поддерживались, но их нужно было явно включить с помощью &lt;a href=&quot;pragma#pragma_recursive_triggers&quot;&gt;оператора PRAGMA recursive_triggers&lt;/a&gt; . Начиная с &lt;a href=&quot;https://sqlite.org/releaselog/3_7_0.html&quot;&gt;версии 3.7.0&lt;/a&gt; (2009-09-11) рекурсивные триггеры включены по умолчанию, но их можно отключить вручную с помощью &lt;a href=&quot;pragma#pragma_recursive_triggers&quot;&gt;PRAGMA recursive_triggers&lt;/a&gt; . SQLITE_MAX_TRIGGER_DEPTH имеет смысл, только если включены рекурсивные триггеры.</target>
        </trans-unit>
        <trans-unit id="534f30ad3bfba01b49cf3bf01218d9cf22140413" translate="yes" xml:space="preserve">
          <source>Prior to SQLite version 3.17.0, the session extension only worked with &lt;a href=&quot;rowidtable&quot;&gt;rowid tables&lt;/a&gt;, not &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables. As of 3.17.0, both rowid and WITHOUT ROWID tables are supported.</source>
          <target state="translated">До версии SQLite 3.17.0 расширение сеанса работало только с &lt;a href=&quot;rowidtable&quot;&gt;таблицами &lt;/a&gt;&lt;a href=&quot;withoutrowid&quot;&gt;rowid&lt;/a&gt; , а не БЕЗ таблиц ROWID . Начиная с версии 3.17.0, поддерживаются таблицы rowid и БЕЗ ROWID.</target>
        </trans-unit>
        <trans-unit id="8ca3ddf5fd526ae6f9a1aaa722828cf40f2bf92a" translate="yes" xml:space="preserve">
          <source>Prior to SQLite version 3.3.14, a sector size of 512 bytes was assumed in all cases. There was a compile-time option to change this but the code had never been tested with a larger value. The 512 byte sector assumption seemed reasonable since until very recently all disk drives used a 512 byte sector internally. However, there has recently been a push to increase the sector size of disks to 4096 bytes. Also the sector size for flash memory is usually larger than 512 bytes. For these reasons, versions of SQLite beginning with 3.3.14 have a method in the OS interface layer that interrogates the underlying filesystem to find the true sector size. As currently implemented (version 3.5.0) this method still returns a hard-coded value of 512 bytes, since there is no standard way of discovering the true sector size on either Unix or Windows. But the method is available for embedded device manufacturers to tweak according to their own needs. And we have left open the possibility of filling in a more meaningful implementation on Unix and Windows in the future.</source>
          <target state="translated">До версии SQLite 3.3.14 во всех случаях предполагался размер сектора 512 байт.Это можно было изменить во время компиляции,но код никогда не тестировался с большим значением.Предположение о 512-байтном секторе казалось разумным,так как до недавнего времени все диски использовали 512-байтный сектор внутри.Тем не менее,в последнее время было принято решение увеличить размер сектора дисков до 4096 байт.Также размер сектора для флэш-памяти обычно больше 512 байт.По этим причинам версии SQLite,начиная с версии 3.3.14,имеют метод на уровне интерфейса операционной системы,который опрашивает базовую файловую систему,чтобы найти истинный размер сектора.Как и в настоящее время (версия 3.5.0),этот метод все еще возвращает жестко закодированное значение в 512 байт,так как не существует стандартного способа определения истинного размера сектора ни в Unix,ни в Windows.Но этот метод доступен производителям встраиваемых устройств для настройки в соответствии с их собственными потребностями.И мы оставили открытой возможность в будущем заполнить более осмысленную реализацию на Unix и Windows.</target>
        </trans-unit>
        <trans-unit id="d9c2ee7b5aac6da179c8f578b8285aa5c54f4524" translate="yes" xml:space="preserve">
          <source>Prior to SQLite version 3.7.10, the Windows OS interface layer called the system malloc() and free() directly when converting filenames between the UTF-8 encoding used by SQLite and whatever filename encoding is used by the particular Windows installation. Memory allocation errors were detected, but they were reported back as &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_CANTOPEN&lt;/a&gt; or &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_IOERR&lt;/a&gt; rather than &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOMEM&lt;/a&gt;.</source>
          <target state="translated">До версии SQLite 3.7.10 уровень интерфейса ОС Windows называл систему malloc () и free () непосредственно при преобразовании имен файлов между кодировкой UTF-8, используемой SQLite, и любой кодировкой имени файла, используемой конкретной установкой Windows. Были обнаружены ошибки выделения памяти, но они были возвращены как &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_CANTOPEN&lt;/a&gt; или &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_IOERR,&lt;/a&gt; а не как &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOMEM&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="91089ffc77affdb7ae59f739dbaf9014a293f340" translate="yes" xml:space="preserve">
          <source>Prior to SQLite version 3.7.10, the Windows OS interface layer called the system malloc() and free() directly when converting filenames between the UTF-8 encoding used by SQLite and whatever filename encoding is used by the particular Windows installation. Memory allocation errors were detected, but they were reported back as &lt;a href=&quot;../rescode#cantopen&quot;&gt;SQLITE_CANTOPEN&lt;/a&gt; or &lt;a href=&quot;../rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt; rather than &lt;a href=&quot;../rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt;.</source>
          <target state="translated">До версии SQLite 3.7.10 уровень интерфейса ОС Windows называл систему malloc () и free () непосредственно при преобразовании имен файлов между кодировкой UTF-8, используемой SQLite, и любой кодировкой имени файла, используемой конкретной установкой Windows. Были обнаружены ошибки выделения памяти, но они были возвращены как &lt;a href=&quot;../rescode#cantopen&quot;&gt;SQLITE_CANTOPEN&lt;/a&gt; или &lt;a href=&quot;../rescode#ioerr&quot;&gt;SQLITE_IOERR,&lt;/a&gt; а не как &lt;a href=&quot;../rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4f00bebae92fba462c0a2ff1a68401159dfc1bce" translate="yes" xml:space="preserve">
          <source>Prior to SQLite version 3.8.2 (2013-12-06), casting a REAL value greater than +9223372036854775807.0 into an integer resulted in the most negative integer, -9223372036854775808. This behavior was meant to emulate the behavior of x86/x64 hardware when doing the equivalent cast.</source>
          <target state="translated">До версии SQLite 3.8.2 (2013-12-06),приведение значения REAL больше +9223372036854775807.0 к целому числу приводило к наибольшему отрицательному числу,-9223372036854775808.Такое поведение предназначалось для эмуляции поведения аппаратного обеспечения x86/x64 при эквивалентном приведении.</target>
        </trans-unit>
        <trans-unit id="a1634472b77cd282aba3425a6cf5a2a4d268772c" translate="yes" xml:space="preserve">
          <source>Prior to each check-in to the SQLite source tree, developers typically run a subset (called &quot;veryquick&quot;) of the Tcl tests consisting of about 248.5 thousand test cases. The veryquick tests include most tests other than the anomaly, fuzz, and soak tests. The idea behind the veryquick tests are that they are sufficient to catch most errors, but also run in only a few minutes instead of a few hours.</source>
          <target state="translated">Перед каждой регистрацией в дереве исходных текстов SQLite разработчики,как правило,запускают подмножество (называемое &quot;veryquick&quot;)тестов Tcl,состоящее примерно из 248.5 тысяч тестовых случаев.Очень быстрые тесты включают в себя большинство тестов,кроме аномалий,нечеткости и замачивания.Идея,лежащая в основе очень быстрых тестов,заключается в том,что они достаточны,чтобы перехватить большинство ошибок,но и запускаются всего за несколько минут,а не за несколько часов.</target>
        </trans-unit>
        <trans-unit id="ce5fd27df1123f4d155915fc1d5725287e09a7ea" translate="yes" xml:space="preserve">
          <source>Prior to making any changes to the database file, SQLite first creates a separate rollback journal file and writes into the rollback journal the original content of the database pages that are to be altered. The idea behind the rollback journal is that it contains all information needed to restore the database back to its original state.</source>
          <target state="translated">Перед тем,как внести изменения в файл базы данных,SQLite сначала создает отдельный файл журнала отката и записывает в него исходное содержимое страниц базы данных,которые должны быть изменены.Идея журнала отката заключается в том,что он содержит всю информацию,необходимую для восстановления исходного состояния БД.</target>
        </trans-unit>
        <trans-unit id="5e201518d0d186ad7cdf7483565006fe761fd040" translate="yes" xml:space="preserve">
          <source>Prior to making changes to the database file itself, we must obtain an exclusive lock on the database file. Obtaining an exclusive lock is really a two-step process. First SQLite obtains a &quot;pending&quot; lock. Then it escalates the pending lock to an exclusive lock.</source>
          <target state="translated">Перед внесением изменений в сам файл базы данных мы должны получить эксклюзивную блокировку на файле базы данных.Получение эксклюзивной блокировки-это действительно двухэтапный процесс.Первый SQLite получает &quot;отложенную&quot; блокировку.Затем он перевешивает отложенную блокировку в эксклюзивную.</target>
        </trans-unit>
        <trans-unit id="3f85c53dbe23e0808bcb91d75d8ad07e4c7bc69c" translate="yes" xml:space="preserve">
          <source>Prior to version 3.26.0 (2018-12-01), FOREIGN KEY references to a table that is renamed were only edited if the &lt;a href=&quot;pragma#pragma_foreign_keys&quot;&gt;PRAGMA foreign_keys=ON&lt;/a&gt;, or in other words if &lt;a href=&quot;foreignkeys&quot;&gt;foreign key constraints&lt;/a&gt; were begin enforced. With &lt;a href=&quot;pragma#pragma_foreign_keys&quot;&gt;PRAGMA foreign_keys=OFF&lt;/a&gt;, FOREIGN KEY constraints would not be changed when the table that the foreign key referred to (the &quot;&lt;a href=&quot;foreignkeys#parentchild&quot;&gt;parent table&lt;/a&gt;&quot;) was renamed. Beginning with version 3.26.0, FOREIGN KEY constraints are always converted when a table is renamed, unless the &lt;a href=&quot;pragma#pragma_legacy_alter_table&quot;&gt;PRAGMA legacy_alter_table=ON&lt;/a&gt; setting is engaged. The following table summaries the difference:</source>
          <target state="translated">До версии 3.26.0 (2018-12-01) ссылки FOREIGN KEY на переименованную таблицу редактировались только в том случае, если &lt;a href=&quot;pragma#pragma_foreign_keys&quot;&gt;PRAGMA foreign_keys = ON&lt;/a&gt; , или, другими словами, если начали применяться &lt;a href=&quot;foreignkeys&quot;&gt;ограничения внешнего ключа&lt;/a&gt; . Если &lt;a href=&quot;pragma#pragma_foreign_keys&quot;&gt;PRAGMA foreign_keys = OFF&lt;/a&gt; , ограничения FOREIGN KEY не будут изменены при переименовании таблицы, на которую ссылается внешний ключ (&amp;laquo; &lt;a href=&quot;foreignkeys#parentchild&quot;&gt;родительская таблица&lt;/a&gt; &amp;raquo;). Начиная с версии 3.26.0, ограничения FOREIGN KEY всегда преобразуются при переименовании таблицы, если не &lt;a href=&quot;pragma#pragma_legacy_alter_table&quot;&gt;задействован параметр PRAGMA legacy_alter_table = ON&lt;/a&gt; . В следующей таблице приведены различия:</target>
        </trans-unit>
        <trans-unit id="4367495333845697b7f484185297e72e4794158a" translate="yes" xml:space="preserve">
          <source>Prior to version 3.26.0 (2018-12-01), FOREIGN KEY references to a table that is renamed were only edited if the &lt;a href=&quot;pragma#pragma_foreign_keys&quot;&gt;PRAGMA foreign_keys=ON&lt;/a&gt;, or in other words if &lt;a href=&quot;foreignkeys&quot;&gt;foreign key constraints&lt;/a&gt; were being enforced. With &lt;a href=&quot;pragma#pragma_foreign_keys&quot;&gt;PRAGMA foreign_keys=OFF&lt;/a&gt;, FOREIGN KEY constraints would not be changed when the table that the foreign key referred to (the &quot;&lt;a href=&quot;foreignkeys#parentchild&quot;&gt;parent table&lt;/a&gt;&quot;) was renamed. Beginning with version 3.26.0, FOREIGN KEY constraints are always converted when a table is renamed, unless the &lt;a href=&quot;pragma#pragma_legacy_alter_table&quot;&gt;PRAGMA legacy_alter_table=ON&lt;/a&gt; setting is engaged. The following table summaries the difference:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f15493198f102fc11171baf7abf0e0dbb2b1e4b" translate="yes" xml:space="preserve">
          <source>Prior to version 3.5.0 the &lt;a href=&quot;c3ref/release_memory&quot;&gt;sqlite3_release_memory()&lt;/a&gt; function would try to reclaim memory from all database connections in the same thread as the sqlite3_release_memory() call. Beginning with version 3.5.0, the sqlite3_release_memory() function will attempt to reclaim memory from all database connections in all threads.</source>
          <target state="translated">До версии 3.5.0 функция &lt;a href=&quot;c3ref/release_memory&quot;&gt;sqlite3_release_memory ()&lt;/a&gt; пыталась освободить память из всех подключений к базе данных в том же потоке, что и вызов sqlite3_release_memory (). Начиная с версии 3.5.0, функция sqlite3_release_memory () будет пытаться освободить память из всех подключений к базе данных во всех потоках.</target>
        </trans-unit>
        <trans-unit id="4167592bfe9ab2523a8fde6561d95f830a107410" translate="yes" xml:space="preserve">
          <source>Prior to version 3.5.0 the &lt;a href=&quot;c3ref/soft_heap_limit&quot;&gt;sqlite3_soft_heap_limit()&lt;/a&gt; set an upper bound on heap memory usage for all database connections within a single thread. Each thread could have its own heap limit. Beginning in version 3.5.0, there is a single heap limit for the entire process. This seems more restrictive (one limit as opposed to many) but in practice it is what most users want.</source>
          <target state="translated">До версии 3.5.0 &lt;a href=&quot;c3ref/soft_heap_limit&quot;&gt;sqlite3_soft_heap_limit ()&lt;/a&gt; устанавливал верхнюю границу использования памяти кучи для всех подключений к базе данных в одном потоке. У каждого потока может быть свой предел кучи. Начиная с версии 3.5.0, существует единственное ограничение кучи для всего процесса. Это кажется более строгим (одно ограничение вместо многих), но на практике это то, чего хочет большинство пользователей.</target>
        </trans-unit>
        <trans-unit id="fc681e809e94e340265ecee10f223e6915cced6a" translate="yes" xml:space="preserve">
          <source>Prior to version 3.5.0, the &lt;a href=&quot;c3ref/enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache()&lt;/a&gt; API would enable and disable the shared cache feature for all connections within a single thread - the same thread from which the sqlite3_enable_shared_cache() routine was called. Database connections that used the shared cache were restricted to running in the same thread in which they were opened. Beginning with version 3.5.0, the sqlite3_enable_shared_cache() applies to all database connections in all threads within the process. Now database connections running in separate threads can share a cache. And database connections that use shared cache can migrate from one thread to another.</source>
          <target state="translated">До версии 3.5.0 API &lt;a href=&quot;c3ref/enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache ()&lt;/a&gt; мог включать и отключать функцию общего кеширования для всех соединений в одном потоке - том же потоке, из которого вызывалась процедура sqlite3_enable_shared_cache (). Подключения к базе данных, которые использовали общий кеш, были ограничены работой в том же потоке, в котором они были открыты. Начиная с версии 3.5.0, sqlite3_enable_shared_cache () применяется ко всем соединениям с базой данных во всех потоках внутри процесса. Теперь соединения с базой данных, выполняемые в отдельных потоках, могут совместно использовать кеш. А подключения к базе данных, которые используют общий кеш, могут переноситься из одного потока в другой.</target>
        </trans-unit>
        <trans-unit id="d828632471991da7903c0c2be934633680ad57e8" translate="yes" xml:space="preserve">
          <source>Process A now tries to write to the database. But process A's view of the database content is now obsolete because process B has modified the database file after process A read from it. Hence process A gets an SQLITE_BUSY_SNAPSHOT error.</source>
          <target state="translated">Процесс A теперь пытается записать в базу данных.Но представление процесса A о содержимом базы данных теперь устарело,потому что процесс B изменил файл базы данных после того,как процесс A прочитал из него.Поэтому процесс A получает ошибку SQLITE_BUSY_SNAPSHOT.</target>
        </trans-unit>
        <trans-unit id="6588c47b29127d1f98a87c238369e743b0e77d94" translate="yes" xml:space="preserve">
          <source>Process A starts a read transaction on the database and does one or more SELECT statement. Process A keeps the transaction open.</source>
          <target state="translated">Процесс A запускает прочитанную транзакцию по базе данных и выполняет один или несколько SELECT-запросов.Процесс A держит транзакцию открытой.</target>
        </trans-unit>
        <trans-unit id="7e082f5417cd4ab89e9c56b231bce953e66b35a9" translate="yes" xml:space="preserve">
          <source>Process B updates the database, changing values previous read by process A.</source>
          <target state="translated">Процесс B обновляет базу данных,изменяя значения,ранее прочитанные процессом A.</target>
        </trans-unit>
        <trans-unit id="ee0914d299e6e7430a22ed0faafffc12d302d567" translate="yes" xml:space="preserve">
          <source>Productize and officially support the group_concat() SQL function.</source>
          <target state="translated">Производить и официально поддерживать SQL функцию group_concat().</target>
        </trans-unit>
        <trans-unit id="9257f2cbe973bd89967c512a0ab4ef3a71be8dcc" translate="yes" xml:space="preserve">
          <source>Profile guided optimization (PGO) is not helpful with SQLite. PGO results in binaries that are about 1% larger and about 0.33% slower.</source>
          <target state="translated">Оптимизация,ориентированная на профили (PGO),не помогает в работе с SQLite.В результате PGO получаются двоичные файлы,которые примерно на 1% больше и примерно на 0.33% медленнее.</target>
        </trans-unit>
        <trans-unit id="b46994e8cc3c2683acbfd969c84c88b83b02d9c0" translate="yes" xml:space="preserve">
          <source>Profiling indicates that for most systems and in most circumstances SQLite spends most of its time doing disk I/O. It follows then that anything we can do to reduce the amount of disk I/O will likely have a large positive impact on the performance of SQLite. This section describes some of the techniques used by SQLite to try to reduce the amount of disk I/O to a minimum while still preserving atomic commit.</source>
          <target state="translated">Профилирование показывает,что для большинства систем и в большинстве случаев SQLite тратит большую часть своего времени на дисковый ввод/вывод.Из этого следует,что все,что мы можем сделать для уменьшения количества дисковых операций ввода-вывода,скорее всего,окажет большое положительное влияние на производительность SQLite.В этом разделе описаны некоторые методы,используемые SQLite для того,чтобы попытаться свести к минимуму количество дисковых операций ввода-вывода,сохраняя при этом атомные коммиты.</target>
        </trans-unit>
        <trans-unit id="9d68007b0763cb230f9034ec96f52b39d03ad630" translate="yes" xml:space="preserve">
          <source>Program</source>
          <target state="translated">Program</target>
        </trans-unit>
        <trans-unit id="6bc5295aed74aa8af8bf9a74f722f2706e580d3c" translate="yes" xml:space="preserve">
          <source>Programmers are cautioned not to use the two exceptions described in the previous bullets. We emphasize that they exist only so that old and ill-formed SQL statements will run correctly. Future versions of SQLite might raise errors instead of accepting the malformed statements covered by the exceptions above.</source>
          <target state="translated">Программистов предостерегают от использования двух исключений,описанных в предыдущих пулях.Подчеркнем,что они существуют только для того,чтобы старые и плохо оформленные SQL-операторы работали корректно.Будущие версии SQLite могут привести к ошибкам вместо того,чтобы принимать некорректные операторы,на которые распространяются вышеописанные исключения.</target>
        </trans-unit>
        <trans-unit id="442f2f1b223aedc9d27d672e9d91f49a3b27fb5b" translate="yes" xml:space="preserve">
          <source>Programmers can force SQLite to use a particular loop nesting order for a join by using the CROSS JOIN operator instead of just JOIN, INNER JOIN, NATURAL JOIN, or a &quot;,&quot; join. Though CROSS JOINs are commutative in theory, SQLite chooses to never reorder the tables in a CROSS JOIN. Hence, the left table of a CROSS JOIN will always be in an outer loop relative to the right table.</source>
          <target state="translated">Программисты могут заставить SQLite использовать для соединения определенный порядок вложенности в цикл,используя оператор CROSS JOIN вместо простого JOIN,INNER JOIN,NATURAL JOIN или &quot;,&quot; join.Несмотря на то,что CROSS JOIN в теории является коммутативным,SQLite предпочитает никогда не переупорядочивать таблицы в CROSS JOIN.Следовательно,левая таблица CROSS JOIN всегда будет находиться во внешней петле относительно правой таблицы.</target>
        </trans-unit>
        <trans-unit id="9ecd00ed19c9aa2f215c5b5e8453037ffd17fc89" translate="yes" xml:space="preserve">
          <source>Programming Interfaces</source>
          <target state="translated">Программирующие интерфейсы</target>
        </trans-unit>
        <trans-unit id="1c8b4bfbf1e2ec54cc62ffa3332992d5ae9a4350" translate="yes" xml:space="preserve">
          <source>Programming Loadable Extensions</source>
          <target state="translated">Программирование Загрузочные удлинители</target>
        </trans-unit>
        <trans-unit id="19ca1fa808a68639f1670f7213bf267471fdbd20" translate="yes" xml:space="preserve">
          <source>Programs contain a single instance of this opcode as the very first opcode.</source>
          <target state="translated">Программы содержат один экземпляр этого опкода в качестве самого первого опкода.</target>
        </trans-unit>
        <trans-unit id="7b85e7edf23f7121981c9a7f81acf2f88e25d897" translate="yes" xml:space="preserve">
          <source>Prohibit the use of SQL functions inside triggers, views, CHECK constraints, DEFAULT clauses, expression indexes, partial indexes, or generated columns unless those functions are tagged with &lt;a href=&quot;#sqliteinnocuous&quot;&gt;SQLITE_INNOCUOUS&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="836cdbe091f8e6d2e0a3bc0953580f5b61d80d1b" translate="yes" xml:space="preserve">
          <source>Prohibit the use of SQL functions inside triggers, views, CHECK constraints, DEFAULT clauses, expression indexes, partial indexes, or generated columns unless those functions are tagged with &lt;a href=&quot;c_deterministic#sqliteinnocuous&quot;&gt;SQLITE_INNOCUOUS&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4131fb0c74864c2b5168b32ce6c60e9b911d245" translate="yes" xml:space="preserve">
          <source>Prohibit the use of virtual tables inside of triggers or views unless those virtual tables are tagged with &lt;a href=&quot;#sqlitevtabinnocuous&quot;&gt;SQLITE_VTAB_INNOCUOUS&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0dd1398efbb71440f12c0472c04e04e100c1dd4b" translate="yes" xml:space="preserve">
          <source>Prohibit the use of virtual tables inside of triggers or views unless those virtual tables are tagged with &lt;a href=&quot;c_vtab_constraint_support#sqlitevtabinnocuous&quot;&gt;SQLITE_VTAB_INNOCUOUS&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b341d69d9619d4d85640d6150737c146812b7c0" translate="yes" xml:space="preserve">
          <source>Provide &lt;a href=&quot;pragma#pragfunc&quot;&gt;PRAGMA functions&lt;/a&gt; for &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt;, &lt;a href=&quot;pragma#pragma_quick_check&quot;&gt;PRAGMA quick_check&lt;/a&gt;, and &lt;a href=&quot;pragma#pragma_foreign_key_check&quot;&gt;PRAGMA foreign_key_check&lt;/a&gt;.</source>
          <target state="translated">Предоставьте &lt;a href=&quot;pragma#pragfunc&quot;&gt;функции PRAGMA&lt;/a&gt; для &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;проверки целостности PRAGMA&lt;/a&gt; , &lt;a href=&quot;pragma#pragma_quick_check&quot;&gt;quick_check PRAGMA&lt;/a&gt; и &lt;a href=&quot;pragma#pragma_foreign_key_check&quot;&gt;внешней проверки ключа PRAGMA&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7a4632572329984193ba91894b49406924b5a89d" translate="yes" xml:space="preserve">
          <source>Provide a hint to cursor P1 that it only needs to return rows that satisfy the Expr in P4. TK_REGISTER terms in the P4 expression refer to values currently held in registers. TK_COLUMN terms in the P4 expression refer to columns in the b-tree to which cursor P1 is pointing.</source>
          <target state="translated">Укажите курсору P1,что ему нужно вернуть только те строки,которые удовлетворяют параметру Expr в P4.Термины TK_REGISTER в выражении P4 относятся к значениям,которые в настоящее время хранятся в регистрах.Термины TK_COLUMN в выражении P4 относятся к столбцам в b-дереве,на которые указывает курсор P1.</target>
        </trans-unit>
        <trans-unit id="054ee0d871e7b20122b3ff23a8374fbfb871d9ca" translate="yes" xml:space="preserve">
          <source>Provide an appropriate error message when the sqlite_master table contains a CREATE TABLE AS statement. Formerly this caused either an assertion fault or null pointer dereference. Problem found by OSSFuzz on the GDAL project. Check-in &lt;a href=&quot;https://www.sqlite.org/src/info/d75e67654aa96&quot;&gt;d75e67654aa96&lt;/a&gt;</source>
          <target state="translated">Предоставьте соответствующее сообщение об ошибке, если таблица sqlite_master содержит оператор CREATE TABLE AS. Раньше это вызывало либо ошибку утверждения, либо разыменование нулевого указателя. Проблема, обнаруженная OSSFuzz в проекте GDAL. Заезд &lt;a href=&quot;https://www.sqlite.org/src/info/d75e67654aa96&quot;&gt;d75e67654aa96&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7c2fd3e74c8200bf8ab45d458d069a0c702c0cd7" translate="yes" xml:space="preserve">
          <source>Provide the &lt;a href=&quot;c3ref/c_prepare_normalize#sqlitepreparepersistent&quot;&gt;SQLITE_PREPARE_PERSISTENT&lt;/a&gt; flag for &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v3()&lt;/a&gt; and use it to limit &lt;a href=&quot;malloc#lookaside&quot;&gt;lookaside memory&lt;/a&gt; misuse by &lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt;, &lt;a href=&quot;fts5&quot;&gt;FTS5&lt;/a&gt;, and the &lt;a href=&quot;rtree&quot;&gt;R-Tree extension&lt;/a&gt;.</source>
          <target state="translated">Предоставьте флаг &lt;a href=&quot;c3ref/c_prepare_normalize#sqlitepreparepersistent&quot;&gt;SQLITE_PREPARE_PERSISTENT&lt;/a&gt; для &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v3 ()&lt;/a&gt; и используйте его для ограничения неправомерного использования дополнительной &lt;a href=&quot;malloc#lookaside&quot;&gt;памяти &lt;/a&gt;&lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt; , &lt;a href=&quot;fts5&quot;&gt;FTS5&lt;/a&gt; и &lt;a href=&quot;rtree&quot;&gt;расширением R-Tree&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0788f21345510b44c97d1a7ea9db2e84d27c5ed1" translate="yes" xml:space="preserve">
          <source>Provide the &lt;a href=&quot;lang_corefunc#sqlite_offset&quot;&gt;sqlite_offset(X)&lt;/a&gt; SQL function that returns the byte offset into the database file to the beginning of the record holding value X, when compiling with &lt;a href=&quot;compile#enable_offset_sql_func&quot;&gt;-DSQLITE_ENABLE_OFFSET_SQL_FUNC&lt;/a&gt;.</source>
          <target state="translated">Предоставьте SQL-функцию &lt;a href=&quot;lang_corefunc#sqlite_offset&quot;&gt;sqlite_offset (X),&lt;/a&gt; которая возвращает байтовое смещение в файле базы данных до начала значения хранения записи X при компиляции с &lt;a href=&quot;compile#enable_offset_sql_func&quot;&gt;-DSQLITE_ENABLE_OFFSET_SQL_FUNC&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6abc71c7c814cc2d05ebc22239e7790b1f15e917" translate="yes" xml:space="preserve">
          <source>Provide the ability to tag &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt; with new properties &lt;a href=&quot;c3ref/c_deterministic#sqliteinnocuous&quot;&gt;SQLITE_INNOCUOUS&lt;/a&gt; or &lt;a href=&quot;c3ref/c_deterministic#sqlitedirectonly&quot;&gt;SQLITE_DIRECTONLY&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcb01e4e57cfae253305eca2f9007587c22f7fb2" translate="yes" xml:space="preserve">
          <source>Provides SQL access to the &lt;a href=&quot;c3ref/status&quot;&gt;sqlite3_status64()&lt;/a&gt; and &lt;a href=&quot;c3ref/db_status&quot;&gt;sqlite3_db_status()&lt;/a&gt; interfaces.</source>
          <target state="translated">Предоставляет доступ SQL к интерфейсам &lt;a href=&quot;c3ref/status&quot;&gt;sqlite3_status64 ()&lt;/a&gt; и &lt;a href=&quot;c3ref/db_status&quot;&gt;sqlite3_db_status ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c78b408cda5c2c489b9c5ef105dac2382d881e16" translate="yes" xml:space="preserve">
          <source>Provides information about all files in a single check-in in the &lt;a href=&quot;https://fossil-scm.org/&quot;&gt;Fossil version control system&lt;/a&gt;. This virtual table is not part of the SQLite project but is included because it provides an example of how to use virtual tables and because it is used to help version control the SQLite sources.</source>
          <target state="translated">Предоставляет информацию обо всех файлах за одну регистрацию в системе &lt;a href=&quot;https://fossil-scm.org/&quot;&gt;контроля версий Fossil&lt;/a&gt; . Эта виртуальная таблица не является частью проекта SQLite, но включена, потому что она предоставляет пример того, как использовать виртуальные таблицы, и потому, что она используется для помощи в управлении версиями источников SQLite.</target>
        </trans-unit>
        <trans-unit id="3126f48ce2a68ae1473f8364444a7e563e9968c3" translate="yes" xml:space="preserve">
          <source>Provides information about the purpose and use of each page in a database file. Used in the implementation of the &lt;a href=&quot;sqlanalyze&quot;&gt;sqlite3_analyzer&lt;/a&gt; utility program.</source>
          <target state="translated">Предоставляет информацию о назначении и использовании каждой страницы в файле базы данных. Используется при реализации служебной программы &lt;a href=&quot;sqlanalyze&quot;&gt;sqlite3_analyzer&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bfec143c19b8a7da8ef2986bfdff976c6539b3dc" translate="yes" xml:space="preserve">
          <source>Pseudo-Random Number Generator</source>
          <target state="translated">Генератор псевдослучайных чисел</target>
        </trans-unit>
        <trans-unit id="52a406d334528b19ea259feaeb009e7160aeac5f" translate="yes" xml:space="preserve">
          <source>Ptrmap pages must exist in any database file which has a non-zero largest root b-tree page value at offset 52 in the database header. If the largest root b-tree page value is zero, then the database must not contain ptrmap pages.</source>
          <target state="translated">Ptrmap-страницы должны существовать в любом файле базы данных,который имеет ненулевое наибольшее значение корневой b-деревянной страницы со смещением 52 в заголовке базы данных.Если значение наибольшей корневой b-деревянной страницы равно нулю,то БД не должна содержать ptrmap-страниц.</target>
        </trans-unit>
        <trans-unit id="fe35e9945539e89cd05f704b37cf341406598782" translate="yes" xml:space="preserve">
          <source>Punctuation characters like &quot;,&quot; or &quot;==&quot; or &quot;;&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7a7b9c96916fe33cad00dfc0a31cbc73811f7fc" translate="yes" xml:space="preserve">
          <source>PureFunc</source>
          <target state="translated">PureFunc</target>
        </trans-unit>
        <trans-unit id="73f66c4bb296f02b5e558e94e1ebb8671640db19" translate="yes" xml:space="preserve">
          <source>Purging a Dirty Page</source>
          <target state="translated">Очистка грязной страницы</target>
        </trans-unit>
        <trans-unit id="a0fb821bdaf93ed9a1f1e920acfb2840eff5b153" translate="yes" xml:space="preserve">
          <source>Purpose</source>
          <target state="translated">Purpose</target>
        </trans-unit>
        <trans-unit id="865ca2a73367e4e56f98cc35dd0cc7fe25f8e129" translate="yes" xml:space="preserve">
          <source>Push the next &quot;thing&quot; onto the stack and fall through OR jump to P2, depending on whether or not there is a next &quot;thing&quot; to push.</source>
          <target state="translated">Протолкните следующую &quot;штуку&quot; на стек и проваливайте ИЛИ прыгайте в P2,в зависимости от того,есть ли следующая &quot;штука&quot;,которую нужно протолкнуть.</target>
        </trans-unit>
        <trans-unit id="0555ed5711adce7afcbd2d3235114460d585953d" translate="yes" xml:space="preserve">
          <source>Put all identifier names inside double-quotes. This is the official SQL way to escape identifier names.</source>
          <target state="translated">Поместите все имена идентификаторов в двойные кавычки.Это официальный способ SQL экранирования имен идентификаторов.</target>
        </trans-unit>
        <trans-unit id="73eb67d0cb954e65c543496b0577de68b482cb5a" translate="yes" xml:space="preserve">
          <source>Put identifier names inside [...]. This is not standard SQL, but it is what SQL Server does and so lots of programmers use this technique.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8b5818c3fdaa2a399fa24163289f33ef9912b79" translate="yes" xml:space="preserve">
          <source>Put the macro &quot;&lt;code&gt;SQLITE_EXTENSION_INIT1&lt;/code&gt;&quot; on a line by itself right after the &quot;&lt;code&gt;#include &amp;lt;sqlite3ext.h&amp;gt;&lt;/code&gt;&quot; line.</source>
          <target state="translated">Поместите макрос &amp;laquo; &lt;code&gt;SQLITE_EXTENSION_INIT1&lt;/code&gt; &amp;raquo; в отдельную строку сразу после строки &amp;laquo; &lt;code&gt;#include &amp;lt;sqlite3ext.h&amp;gt;&lt;/code&gt; &amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="36dc5ec2a56fbc19dcd1aa69b72dba8e93123b26" translate="yes" xml:space="preserve">
          <source>Put your hope in God.</source>
          <target state="translated">Положи свою надежду на Бога.</target>
        </trans-unit>
        <trans-unit id="c3156e00d3c2588c639e0d3cf6821258b05761c7" translate="yes" xml:space="preserve">
          <source>Q</source>
          <target state="translated">Q</target>
        </trans-unit>
        <trans-unit id="4ae694911c3fee4e1df954bf5e225e075d582d11" translate="yes" xml:space="preserve">
          <source>QUERY</source>
          <target state="translated">QUERY</target>
        </trans-unit>
        <trans-unit id="ebdfba68a60db859050a346ba6621b2d1c232869" translate="yes" xml:space="preserve">
          <source>Quality Management</source>
          <target state="translated">Управление качеством</target>
        </trans-unit>
        <trans-unit id="3dd6362242ec4d8e950fc308f0c9c5371ac3e523" translate="yes" xml:space="preserve">
          <source>Quality assurance in SQLite is done using &lt;a href=&quot;testing#coverage&quot;&gt;full-coverage testing&lt;/a&gt;, not by compiler warnings or other static code analysis tools. In other words, we verify that SQLite actually gets the correct answer, not that it merely satisfies stylistic constraints. Most of the SQLite code base is devoted purely to testing. The SQLite test suite runs tens of thousands of separate test cases and many of those test cases are parameterized so that hundreds of millions of tests involving billions of SQL statements are run and evaluated for correctness prior to every release. The developers use code coverage tools to verify that all paths through the code are tested. Whenever a bug is found in SQLite, new test cases are written to exhibit the bug so that the bug cannot recur undetected in the future.</source>
          <target state="translated">Обеспечение качества в SQLite осуществляется с помощью &lt;a href=&quot;testing#coverage&quot;&gt;тестирования&lt;/a&gt; с полным покрытием , а не с помощью предупреждений компилятора или других инструментов статического анализа кода. Другими словами, мы проверяем, что SQLite действительно получает правильный ответ, а не просто удовлетворяет стилистическим ограничениям. Большая часть кодовой базы SQLite посвящена исключительно тестированию. Набор тестов SQLite запускает десятки тысяч отдельных тестовых примеров, и многие из этих тестовых примеров параметризованы, так что сотни миллионов тестов, включающих миллиарды операторов SQL, запускаются и оцениваются на правильность перед каждым выпуском. Разработчики используют инструменты покрытия кода, чтобы убедиться, что все пути прохождения кода протестированы. Каждый раз, когда ошибка обнаруживается в SQLite, создаются новые тестовые примеры, чтобы выявить ошибку, чтобы ошибка не могла повторяться незамеченной в будущем.</target>
        </trans-unit>
        <trans-unit id="96ecb898d9fd59826f9555c415e65eadb6f74ead" translate="yes" xml:space="preserve">
          <source>Quality management documents tend to expand into binders full of incomprehensible jargon that nobody reads. This document strives to break that pattern by being concise and useful.</source>
          <target state="translated">Документы по управлению качеством имеют тенденцию расширяться до связок,полных непонятного жаргона,который никто не читает.Этот документ стремится разорвать эту закономерность,будучи кратким и полезным.</target>
        </trans-unit>
        <trans-unit id="61b1d96663c5eb21b3f12fad273403f6ef48c73d" translate="yes" xml:space="preserve">
          <source>Queries (and also DELETE and UPDATE statements) in which the WHERE clause contains a bare geopoly_overlap() or geopoly_within() function make use of the underlying R*Tree data structures for a fast lookup that only has to examine a subset of the rows in the table. The number of rows examines depends, of course, on the size of the $query_polygon. Large $query_polygons will normally need to look at more rows than small ones.</source>
          <target state="translated">Запросы (а также утверждения DELETE и UPDATE),в которых в пункте WHERE имеется функция geopoly_overlap()или geopoly_within(),используют базовые структуры данных R*Tree для быстрого поиска,который должен исследовать только подмножество строк в таблице.Количество исследуемых строк зависит,конечно же,от размера $query_polygon.Большие $query_polygons обычно должны смотреть больше строк,чем маленькие.</target>
        </trans-unit>
        <trans-unit id="5877d4b4dd805510713fc8b0f7324db5905fcfac" translate="yes" xml:space="preserve">
          <source>Queries Against A Graph</source>
          <target state="translated">Запросы против графика</target>
        </trans-unit>
        <trans-unit id="83b570c5458fbacf6723ef9304ccc7570ee10af8" translate="yes" xml:space="preserve">
          <source>Queries against the rowid of a geopoly table are also very quick, even for tables with a vast number of rows. However, none of the auxiliary data columns are indexes, and so queries against the auxiliary data columns will involve a full table scan.</source>
          <target state="translated">Запросы против ряда геополитической таблицы также очень быстрые,даже для таблиц с большим количеством строк.Однако ни один из вспомогательных столбцов данных не является индексами,поэтому запросы к вспомогательным столбцам данных потребуют полного сканирования таблицы.</target>
        </trans-unit>
        <trans-unit id="e655d8b919b6556f1f0ce40faccc63fe0ee22962" translate="yes" xml:space="preserve">
          <source>Queries of the form: &quot;SELECT max(x), y FROM table&quot; returns the value of y on the same row that contains the maximum x value.</source>
          <target state="translated">Запросы формы:&quot;SELECT max(x),y FROM table&quot; возвращает значение y в той же строке,которая содержит максимальное значение x.</target>
        </trans-unit>
        <trans-unit id="e4ff6a5e7ac06c745f7d49496f70f4a140defd99" translate="yes" xml:space="preserve">
          <source>Queries that contain a single MIN() or MAX() aggregate function whose argument is the left-most column of an index might be satisfied by doing a single index lookup rather than by scanning the entire table. Examples:</source>
          <target state="translated">Запросы,содержащие одну совокупную функцию MIN()или MAX(),аргументом которой является самый левый столбец индекса,могут быть удовлетворены путем выполнения одного поиска по индексу,а не путем сканирования всей таблицы.Примеры:</target>
        </trans-unit>
        <trans-unit id="29a6a39bdba4fd39660625514af2f1cb40b3edcf" translate="yes" xml:space="preserve">
          <source>Queries that contain subqueries must sometime evaluate the subqueries separately and store the results in a temporary table, then use the content of the temporary table to evaluate the outer query. We call this &quot;materializing&quot; the subquery. The query optimizer in SQLite attempts to avoid materializing, but sometimes it is not easily avoidable. The temporary tables created by materialization are each stored in their own separate temporary file, which is automatically deleted at the conclusion of the query. The size of these temporary tables depends on the amount of data in the materialization of the subquery, of course.</source>
          <target state="translated">Запросы,содержащие подзапросы,должны иногда оценивать подзапросы отдельно и хранить результаты во временной таблице,а затем использовать содержимое временной таблицы для оценки внешнего запроса.Мы называем это &quot;материализующимся&quot; подзапросом.Оптимизатор запросов в SQLite пытается избежать материализации,но иногда этого нелегко избежать.Созданные в результате материализации временные таблицы хранятся в отдельном временном файле,который автоматически удаляется при завершении запроса.Размер этих временных таблиц зависит,конечно же,от объема данных в материализации подзапроса.</target>
        </trans-unit>
        <trans-unit id="cfbd9457ec43caaedb5b89c759265cf2be427fe5" translate="yes" xml:space="preserve">
          <source>Queries that use ORDER BY and LIMIT now try to avoid computing rows that cannot possibly come in under the LIMIT. This can greatly improve performance of ORDER BY LIMIT queries, especially when the LIMIT is small relative to the number of unrestricted output rows.</source>
          <target state="translated">Запросы,использующие ORDER BY и LIMIT,теперь пытаются избежать вычислительных строк,которые не могут попасть под LIMIT.Это может значительно улучшить производительность запросов ORDER BY LIMIT,особенно когда LIMIT мал по отношению к количеству неограниченных выходных строк.</target>
        </trans-unit>
        <trans-unit id="e885c97cd0eb73037d91afe0e25f71733d813af5" translate="yes" xml:space="preserve">
          <source>Query Language Understood by SQLite</source>
          <target state="translated">Язык запросов Понятен SQLite</target>
        </trans-unit>
        <trans-unit id="3d4f16fd1d91b47c556b84948dabe05573437a3d" translate="yes" xml:space="preserve">
          <source>Query Planner</source>
          <target state="translated">Планировщик запросов</target>
        </trans-unit>
        <trans-unit id="efa9d81fc99ae6041fbe49339a919ef99bac7ade" translate="yes" xml:space="preserve">
          <source>Query Planning</source>
          <target state="translated">Планирование запросов</target>
        </trans-unit>
        <trans-unit id="625af40606e435d60c7571eb3eaed21802aa70ee" translate="yes" xml:space="preserve">
          <source>Query Progress Callbacks</source>
          <target state="translated">Обратный звонок по вопросам прогресса</target>
        </trans-unit>
        <trans-unit id="4af542248ab5d4cfc6f1e9df7245e3bb184ea082" translate="yes" xml:space="preserve">
          <source>Query The EXPLAIN Setting For A Prepared Statement</source>
          <target state="translated">Запрос Установка ЭКСПЛАЙНА для готового отчета</target>
        </trans-unit>
        <trans-unit id="27930b82a7c3d467781ad3b52e0b1d9894281ffa" translate="yes" xml:space="preserve">
          <source>Query flattener</source>
          <target state="translated">Запросительный уплотнитель</target>
        </trans-unit>
        <trans-unit id="e60fdc9ba7fb5d86546748b364cd1dfbde0107e1" translate="yes" xml:space="preserve">
          <source>Query flattening is an important optimization when views are used as each use of a view is translated into a subquery.</source>
          <target state="translated">Сглаживание запроса является важной оптимизацией,когда используются представления,так как каждое использование представления транслируется в подзапрос.</target>
        </trans-unit>
        <trans-unit id="bfee3391ed2fb89e3470d4d2a93c4c710274a3ef" translate="yes" xml:space="preserve">
          <source>Query for the details of phrase match iIdx within the current row. Phrase matches are numbered starting from zero, so the iIdx argument should be greater than or equal to zero and smaller than the value output by xInstCount().</source>
          <target state="translated">Запрос деталей фразы,совпадающей с iIdx в текущей строке.Фразы совпадают,начиная с нуля,поэтому аргумент iIdx должен быть больше или равен нулю и меньше значения,выводимого функцией xInstCount().</target>
        </trans-unit>
        <trans-unit id="3a7dd1ac6b04f70fb3ec3bd5dfe2b333de122f27" translate="yes" xml:space="preserve">
          <source>Query optimizer enhancements:</source>
          <target state="translated">Улучшения оптимизатора запросов:</target>
        </trans-unit>
        <trans-unit id="a2c73363a91970f8d7d0f3ba2033b2b1141c7659" translate="yes" xml:space="preserve">
          <source>Query optimizer improvements:</source>
          <target state="translated">Улучшения оптимизатора запросов:</target>
        </trans-unit>
        <trans-unit id="65d2f2329c994ccea3b5e213a1d1b909c0f33338" translate="yes" xml:space="preserve">
          <source>Query or change a limit on the &lt;a href=&quot;lang_analyze#approx&quot;&gt;approximate ANALYZE&lt;/a&gt; setting. This is approximate number of rows examined in each index by the &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; command. If the argument</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0fbdef4345ce05f423c29e77346a76ae1183a9c" translate="yes" xml:space="preserve">
          <source>Query or change the count-changes flag. Normally, when the count-changes flag is not set, &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;, &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; and &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; statements return no data. When count-changes is set, each of these commands returns a single row of data consisting of one integer value - the number of rows inserted, modified or deleted by the command. The returned change count does not include any insertions, modifications or deletions performed by triggers, any changes made automatically by &lt;a href=&quot;foreignkeys#fk_actions&quot;&gt;foreign key actions&lt;/a&gt;, or updates caused by an &lt;a href=&quot;lang_upsert&quot;&gt;upsert&lt;/a&gt;.</source>
          <target state="translated">Запросить или изменить флаг количества изменений. Обычно, когда флаг количества изменений не установлен, операторы &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; , &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; и &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; не возвращают данных. Когда установлено значение count-changes, каждая из этих команд возвращает одну строку данных, состоящую из одного целого числа - количества строк, вставленных, измененных или удаленных командой. Возвращенный счетчик изменений не включает в себя каких - либо вставок, модификации или удаления , выполняемые триггерами, любые изменения , сделанные автоматически &lt;a href=&quot;foreignkeys#fk_actions&quot;&gt;иностранных действий ключевых&lt;/a&gt; , или обновлений , вызванных &lt;a href=&quot;lang_upsert&quot;&gt;upsert&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9a7df9605f2eec87d8f2db2efd84251b953fcfd6" translate="yes" xml:space="preserve">
          <source>Query or change the empty-result-callbacks flag.</source>
          <target state="translated">Запросить или поменять флаг &quot;Пустота-результат-обратный ход&quot;.</target>
        </trans-unit>
        <trans-unit id="4386c302fe03b8bf430568c307ba9f2bfa451ec8" translate="yes" xml:space="preserve">
          <source>Query or change the full_column_names flag. This flag together with the &lt;a href=&quot;pragma#pragma_short_column_names&quot;&gt;short_column_names&lt;/a&gt; flag determine the way SQLite assigns names to result columns of &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statements. Result columns are named by applying the following rules in order:</source>
          <target state="translated">Запросить или изменить флаг full_column_names. Этот флаг вместе с флагом &lt;a href=&quot;pragma#pragma_short_column_names&quot;&gt;short_column_names&lt;/a&gt; определяет способ, которым SQLite назначает имена столбцам результатов &lt;a href=&quot;lang_select&quot;&gt;операторов SELECT&lt;/a&gt; . Столбцы результатов именуются с применением следующих правил по порядку:</target>
        </trans-unit>
        <trans-unit id="6ea33a7feb73dab172e527ce6afcb51892e3e546" translate="yes" xml:space="preserve">
          <source>Query or change the fullfsync flag for &lt;a href=&quot;wal#ckpt&quot;&gt;checkpoint&lt;/a&gt; operations. If this flag is set, then the F_FULLFSYNC syncing method is used during checkpoint operations on systems that support F_FULLFSYNC. The default value of the checkpoint_fullfsync flag is off. Only Mac OS-X supports F_FULLFSYNC.</source>
          <target state="translated">Запросить или изменить флаг fullfsync для операций с &lt;a href=&quot;wal#ckpt&quot;&gt;контрольной&lt;/a&gt; точкой . Если этот флаг установлен, то метод синхронизации F_FULLFSYNC используется во время операций контрольной точки в системах, поддерживающих F_FULLFSYNC. По умолчанию флаг checkpoint_fullfsync выключен. Только Mac OS-X поддерживает F_FULLFSYNC.</target>
        </trans-unit>
        <trans-unit id="563bc8c4477c1c2b886876e5894cd59e0001b35e" translate="yes" xml:space="preserve">
          <source>Query or change the fullfsync flag. This flag determines whether or not the F_FULLFSYNC syncing method is used on systems that support it. The default value of the fullfsync flag is off. Only Mac OS X supports F_FULLFSYNC.</source>
          <target state="translated">Запрос или изменение флага fullfsync.Этот флаг определяет,используется ли метод синхронизации F_FULLFSYNC на системах,которые его поддерживают.Значение по умолчанию для флага fullfsync выключено.Только Mac OS X поддерживает F_FULLFSYNC.</target>
        </trans-unit>
        <trans-unit id="77df4b91f1e34f39b185a6ee7e54e82d58dfa005" translate="yes" xml:space="preserve">
          <source>Query or change the maximum number of bytes that are set aside for memory-mapped I/O on a single database. The first form (without an argument) queries the current limit. The second form (with a numeric argument) sets the limit for the specified database, or for all databases if the optional database name is omitted. In the second form, if the database name is omitted, the limit that is set becomes the default limit for all databases that are added to the &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; by subsequent &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; statements.</source>
          <target state="translated">Запросить или изменить максимальное количество байтов, отведенных для ввода-вывода с отображением памяти в одной базе данных. Первая форма (без аргумента) запрашивает текущий лимит. Вторая форма (с числовым аргументом) устанавливает предел для указанной базы данных или для всех баз данных, если необязательное имя базы данных опущено. Во второй форме, если имя базы данных опущено, установленный предел становится пределом по умолчанию для всех баз данных, которые добавляются к &lt;a href=&quot;c3ref/sqlite3&quot;&gt;соединению&lt;/a&gt; с базой данных последующими операторами &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; .</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
