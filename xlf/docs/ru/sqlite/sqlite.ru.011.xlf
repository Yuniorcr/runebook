<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="sqlite">
    <body>
      <group id="sqlite">
        <trans-unit id="cc11826689203b888f22525a7551a5472c324526" translate="yes" xml:space="preserve">
          <source>OVER</source>
          <target state="translated">OVER</target>
        </trans-unit>
        <trans-unit id="829a2c0005fc7d37eb660c0d5cde206b5192f790" translate="yes" xml:space="preserve">
          <source>Obey in all things the commands of those whom God has placed in authority over you even though they (which God forbid) should act otherwise, mindful of the Lord's precept, &quot;Do what they say, but not what they do.&quot;</source>
          <target state="translated">Повинуйтесь во всем повелениям тех,кого Бог поставил над вами,даже если они (что Бог запрещает)должны поступать иначе,помня заповедь Господа:&quot;Делайте,что они говорят,а не то,что делают&quot;.</target>
        </trans-unit>
        <trans-unit id="a21a5206c75e38db5a2f38df79e6283758ee658a" translate="yes" xml:space="preserve">
          <source>Object-Oriented Design</source>
          <target state="translated">Объектно-ориентированный дизайн</target>
        </trans-unit>
        <trans-unit id="898a9f4f224c827df0fb00ecec65822c23a3936e" translate="yes" xml:space="preserve">
          <source>Object-Oriented is a design pattern, not a programming language. You can do object-oriented programming in any language you want, including assembly language. Some languages (ex: C++ or Java) make object-oriented easier. But you can still do object-oriented programming in languages like C.</source>
          <target state="translated">Объектно-ориентированный-это шаблон проектирования,а не язык программирования.Объектно-ориентированное программирование можно выполнять на любом языке,включая язык ассемблера.Некоторые языки (например,C++или Java)облегчают объектно-ориентированное программирование.Но вы все равно можете заниматься объектно-ориентированным программированием на таких языках,как Си.</target>
        </trans-unit>
        <trans-unit id="1e6159d8c90870c6430155592639731dac8033a3" translate="yes" xml:space="preserve">
          <source>Object-oriented is not the only valid design pattern. Many programmers have been taught to think purely in terms of objects. And, to be fair, objects are often a good way to decompose a problem. But objects are not the only way, and are not always the best way to decompose a problem. Sometimes good old procedural code is easier to write, easier to maintain and understand, and faster than object-oriented code.</source>
          <target state="translated">Объектно-ориентированный не единственный действительный образец конструкции.Многих программистов научили мыслить чисто в терминах объектов.И,справедливости ради,объекты часто являются хорошим способом разложения проблемы.Но объекты-это не единственный способ,и не всегда лучший способ разложить проблему.Иногда старый добрый процедурный код легче писать,легче поддерживать и понимать,и быстрее,чем объектно-ориентированный.</target>
        </trans-unit>
        <trans-unit id="ea838bb1557d80ce2bdbf51816fc7a1525503976" translate="yes" xml:space="preserve">
          <source>Objects:</source>
          <target state="translated">Objects:</target>
        </trans-unit>
        <trans-unit id="3a36347e6c9b66b32ae45cd886e8708db38d062b" translate="yes" xml:space="preserve">
          <source>Obscure bug fix on triggers (&lt;a href=&quot;http://www.sqlite.org/src/info/efc02f9779&quot;&gt;[efc02f9779]&lt;/a&gt;).</source>
          <target state="translated">Непонятное исправление ошибки триггеров ( &lt;a href=&quot;http://www.sqlite.org/src/info/efc02f9779&quot;&gt;[efc02f9779]&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="06705e47733fa2d26527ca5b13fe92c1b7ca1944" translate="yes" xml:space="preserve">
          <source>Obsolete Documents</source>
          <target state="translated">Устаревшие документы</target>
        </trans-unit>
        <trans-unit id="adcd55329b6153adb94eaf8a12d01ba2bc7cea95" translate="yes" xml:space="preserve">
          <source>Obtain A Composite Changeset From A Changegroup</source>
          <target state="translated">Получить композитный набор изменений из группы смены</target>
        </trans-unit>
        <trans-unit id="f036e380a093cadb7b7384e4b591b8c75c1ba145" translate="yes" xml:space="preserve">
          <source>Obtain Aggregate Function Context</source>
          <target state="translated">Получить контекст функции агрегата</target>
        </trans-unit>
        <trans-unit id="e79fb280b93973e6bfe3f8e79ba72b5b038ba1fa" translate="yes" xml:space="preserve">
          <source>Obtain Conflicting Row Values From A Changeset Iterator</source>
          <target state="translated">Получить противоречивые значения рядов от итератора изменений.</target>
        </trans-unit>
        <trans-unit id="d4c8c29e25fb3ccc649578fec3be2c67a658b123" translate="yes" xml:space="preserve">
          <source>Obtain The Current Operation From A Changeset Iterator</source>
          <target state="translated">Получить текущую операцию от итератора переменных параметров.</target>
        </trans-unit>
        <trans-unit id="7ada95f817f8fc624dbadc0c0f495b244a8d38b3" translate="yes" xml:space="preserve">
          <source>Obtain The Primary Key Definition Of A Table</source>
          <target state="translated">Получить определение первичного ключа таблицы А</target>
        </trans-unit>
        <trans-unit id="2f0f8596ef7c82c2d68f88fe0c2c42b22b20b24e" translate="yes" xml:space="preserve">
          <source>Obtain Values For URI Parameters</source>
          <target state="translated">Получить значения для параметров URI</target>
        </trans-unit>
        <trans-unit id="e719cf57b48331ec73c3d09816f240ac71d990d4" translate="yes" xml:space="preserve">
          <source>Obtain a PENDING lock and then an EXCLUSIVE lock on the database file. If other processes still have SHARED locks, the writer might have to wait until those SHARED locks clear before it is able to obtain an EXCLUSIVE lock.</source>
          <target state="translated">Получите блокировку PENDING,а затем EXCLUSIVE на файле базы данных.Если другие процессы все еще имеют блокировку SHARED,записывающему устройству,возможно,придется подождать,пока эти блокировки не будут сняты,прежде чем оно сможет получить ЭКСКЛЮЗИВНУЮ блокировку.</target>
        </trans-unit>
        <trans-unit id="c4c184719398e2fd529d288f83e902aa72fdd7b4" translate="yes" xml:space="preserve">
          <source>Obtain a buffer containing a changeset (or patchset) representing the current contents of the changegroup. If the inputs to the changegroup were themselves changesets, the output is a changeset. Or, if the inputs were patchsets, the output is also a patchset.</source>
          <target state="translated">Получить буфер,содержащий набор изменений (или патчсет),представляющий текущее содержимое группы изменений.Если входы в группу изменений были сами по себе changeset'ами,то на выходе будет changeset'ом.Или,если входы были патчсетами,выход также является патчсет.</target>
        </trans-unit>
        <trans-unit id="0ad736b5bee2570f5cbf619854f8b97d9b6134d1" translate="yes" xml:space="preserve">
          <source>Obtain a changeset containing changes to the tables attached to the session object passed as the first argument. If successful, set *ppChangeset to point to a buffer containing the changeset and *pnChangeset to the size of the changeset in bytes before returning SQLITE_OK. If an error occurs, set both *ppChangeset and *pnChangeset to zero and return an SQLite error code.</source>
          <target state="translated">Получить changeset,содержащий изменения в таблицах,прикрепленных к объекту сеанса,переданному в качестве первого аргумента.В случае успеха перед возвращением SQLITE_OK установите *ppChangeset в указатель на буфер,содержащий changeset,и *pnChangeset в размер changeset в байтах.В случае ошибки установите оба аргумента *ppChangeset и *pnChangeset в нулевое значение и верните код ошибки SQLite.</target>
        </trans-unit>
        <trans-unit id="4304c4d08f4f900e2ab1ec29540131e8bf87ae39" translate="yes" xml:space="preserve">
          <source>Obtain a lock on a particular table. This instruction is only used when the shared-cache feature is enabled.</source>
          <target state="translated">Получить замок на определенном столе.Эта инструкция используется только при включенной функции общего кэширования.</target>
        </trans-unit>
        <trans-unit id="35cc8c81bb0ab78babd3f65cb1b473a29bd69034" translate="yes" xml:space="preserve">
          <source>Obtain an EXCLUSIVE lock on the database file and make sure all memory changes have been written to the database file using the algorithm of steps 1-3 above.</source>
          <target state="translated">Получите ЭКСКЛЮЗИВНУЮ блокировку на файле БД и убедитесь,что все изменения в памяти записаны в файл БД по алгоритму,описанному выше в п.п.1-3.</target>
        </trans-unit>
        <trans-unit id="edc981514ab58076de28ce864d46ccc2641ec1d0" translate="yes" xml:space="preserve">
          <source>Obtain new.* Values From A Changeset Iterator</source>
          <target state="translated">Получите новые.Значения от итератора изменений.</target>
        </trans-unit>
        <trans-unit id="c31b9f4e355939157fe39f17fcb0e54282736c63" translate="yes" xml:space="preserve">
          <source>Obtain old.* Values From A Changeset Iterator</source>
          <target state="translated">Получите старое.*Ценности от итератора изменений.</target>
        </trans-unit>
        <trans-unit id="d399842fa2ae120f608cae0543637da5b44e2b8c" translate="yes" xml:space="preserve">
          <source>Obtain the latest SQLite code from fossil.</source>
          <target state="translated">Получите новейший код SQLite из ископаемых источников.</target>
        </trans-unit>
        <trans-unit id="9ed23644c9e9a46df1cd037be0519be726230e11" translate="yes" xml:space="preserve">
          <source>Obtaining SQL Values</source>
          <target state="translated">Получение значений SQL</target>
        </trans-unit>
        <trans-unit id="ffe740a4611067b4b4dd0b5b7a28183003203956" translate="yes" xml:space="preserve">
          <source>Obtaining the</source>
          <target state="translated">Получение</target>
        </trans-unit>
        <trans-unit id="a8fbf19c89308087d70d289986f946de344868c9" translate="yes" xml:space="preserve">
          <source>Obtains the mutex.</source>
          <target state="translated">Получает мьютекс.</target>
        </trans-unit>
        <trans-unit id="974debb0f023f79fb3eec2db47da68008b639181" translate="yes" xml:space="preserve">
          <source>Occasionally, a serious problem is found and a small &quot;patch&quot; release must be made against a regular maintenance release. Patch are distinct from maintenance releases in that the number of lines of code changed from the previous release is very small. Every effort is made to avoid patch releases by making sure that maintenance releases are bug free.</source>
          <target state="translated">Время от времени обнаруживается серьезная проблема,и необходимо сделать небольшую &quot;заплатку&quot; на регулярном техобслуживании.Патч отличается от релиза для обслуживания тем,что количество строк кода,измененных по сравнению с предыдущим релизом,очень мало.Прилагаются все усилия,чтобы избежать использования патчей,убедившись,что в релизах сопровождения нет ошибок.</target>
        </trans-unit>
        <trans-unit id="10b7fae72f94602297b15a7cf850a8e1ee7b4b31" translate="yes" xml:space="preserve">
          <source>Of course, ANALYZE only works effectively if you have a significant amount of content in your database in the first place. When creating a new database that you expect to accumulate a lot of data, you can run the command &quot;ANALYZE sqlite_master&quot; to create the SQLITE_STAT1 table, then prepopulate the SQLITE_STAT1 table (using ordinary INSERT statements) with content that describes a typical database for your application - perhaps content that you extracted after running ANALYZE on a well-populated template database in the lab.</source>
          <target state="translated">Конечно,ANALYZE работает эффективно только в том случае,если в Вашей базе данных имеется значительный объем контента.При создании новой БД,в которой вы ожидаете накопления большого количества данных,вы можете запустить команду &quot;ANALYZE sqlite_master&quot; для создания таблицы SQLITE_STAT1,а затем подготовить таблицу SQLITE_STAT1 (используя обычные операторы INSERT)с содержимым,описывающим типичную БД для вашего приложения-возможно,с содержимым,которое вы извлекли после запуска ANALYZE на хорошо заполненной шаблонной базе данных в лаборатории.</target>
        </trans-unit>
        <trans-unit id="3d4796f0a34c568634b9634297a83ac77168e0e1" translate="yes" xml:space="preserve">
          <source>Of course, ANALYZE only works effectively if you have a significant amount of content in your database in the first place. When creating a new database that you expect to accumulate a lot of data, you can run the command &quot;ANALYZE sqlite_schema&quot; to create the SQLITE_STAT1 table, then prepopulate the SQLITE_STAT1 table (using ordinary INSERT statements) with content that describes a typical database for your application - perhaps content that you extracted after running ANALYZE on a well-populated template database in the lab.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79c23fc170f4a6f6a03298037f6a0ed97740fe0f" translate="yes" xml:space="preserve">
          <source>Of course, an error may occur while attempting any of the 4 steps enumerated above. If this happens, then the</source>
          <target state="translated">Конечно,ошибка может произойти при попытке выполнить любой из 4 перечисленных выше шагов.Если это произойдет,то</target>
        </trans-unit>
        <trans-unit id="4144a21a0e5e7b5ef89db325c2463b409501b64d" translate="yes" xml:space="preserve">
          <source>Of course, an ordinary SQLite table will also do a query against its integer primary key efficiently, so the previous is no big deal. The real reason for using an R*Tree is so that you can efficiently do inequality queries against the coordinate ranges. To find all elements of the index that are contained within the vicinity of Charlotte, North Carolina, one might do:</source>
          <target state="translated">Конечно,обычная таблица SQLite также будет эффективно выполнять запрос к своему целочисленному первичному ключу,так что предыдущий-ничего страшного.Настоящая причина использования R*Tree заключается в том,что вы можете эффективно выполнять запросы неравенства по отношению к диапазонам координат.Найти все элементы индекса,которые содержатся в окрестностях Шарлотты,штат Северная Каролина,можно:</target>
        </trans-unit>
        <trans-unit id="ad9000f84241cbe168fcf9edea5a309a2f41cf64" translate="yes" xml:space="preserve">
          <source>Of course, it is also possible that it does exist following system recovery.</source>
          <target state="translated">Конечно,также возможно,что он существует и после восстановления системы.</target>
        </trans-unit>
        <trans-unit id="7a79fe7e88cf76ed8c1ab2e6617de9596ed474d8" translate="yes" xml:space="preserve">
          <source>Of course, it is usually not possible to atomically apply all the changes required by a</source>
          <target state="translated">Конечно,как правило,невозможно атоматически применить все изменения,необходимые для</target>
        </trans-unit>
        <trans-unit id="03e6ead3b1dad229ee29b568087a8cd4aada1c2d" translate="yes" xml:space="preserve">
          <source>Of course, not every language fits neatly into one of the above catagories. This applies to both SQL database engines and more familiar imperative programming languages. Javascript is famous for using a hybrid execution model, where the code is initially compiled into a tree of objects, but might be further translating (using just-in-time compilation) down into more efficient bytecode or machine code, as a means of boosting performance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8a4fe5b2fe5db1f855a348ab89c3de5aa545089" translate="yes" xml:space="preserve">
          <source>Of course, one wants to eventually transfer all the transactions that are appended in the WAL file back into the original database. Moving the WAL file transactions back into the database is called a &quot;</source>
          <target state="translated">Конечно же,хочется в конечном итоге перенести все транзакции,которые прилагаются к файлу WAL,обратно в исходную базу данных.Перемещение транзакций из файла WAL обратно в базу данных называется &quot;.</target>
        </trans-unit>
        <trans-unit id="a8d7cb464eb0b5300b1a2a71635654f684270965" translate="yes" xml:space="preserve">
          <source>Of course, ordering the output of a query by rowid is seldom useful. Usually one wants to order the output by some other column.</source>
          <target state="translated">Конечно,упорядочивание вывода запроса по rowid редко бывает полезным.Обычно хочется заказать вывод по какому-нибудь другому столбцу.</target>
        </trans-unit>
        <trans-unit id="178df5e8851c3ac34f7dcea098e85da7dbfe235b" translate="yes" xml:space="preserve">
          <source>Of course, substitute the desired index and imposter table names in place of the &quot;t1bc&quot; and &quot;t2&quot; shown in the example. The &quot;.imposter&quot; command reads the schema of the &quot;t1bc&quot; index, uses that information to construct a compatible CREATE TABLE statement for the imposter table, then makes all the necessary calls to create the transient imposter table automatically.</source>
          <target state="translated">Конечно же,вместо &quot;t1bc&quot; и &quot;t2&quot;,показанных в примере,подставьте нужные имена индексов и самозваных таблиц.Команда &quot;.imposter&quot; читает схему индекса &quot;t1bc&quot;,использует эту информацию для построения совместимого оператора CREATE TABLE для imposter-таблицы,затем автоматически делает все необходимые вызовы для создания переходной imposter-таблицы.</target>
        </trans-unit>
        <trans-unit id="116444cf2f220a0caf732f16ffb5a2f69fd9321c" translate="yes" xml:space="preserve">
          <source>Of course, the two queries above are not entirely equivalent. For example the LIKE query matches rows that contain terms such as &quot;linuxophobe&quot; or &quot;EnterpriseLinux&quot; (as it happens, the Enron E-Mail Dataset does not actually contain any such terms), whereas the MATCH query on the FTS3 table selects only those rows that contain &quot;linux&quot; as a discrete token. Both searches are case-insensitive. The FTS3 table consumes around 2006 MB on disk compared to just 1453 MB for the ordinary table. Using the same hardware configuration used to perform the SELECT queries above, the FTS3 table took just under 31 minutes to populate, versus 25 for the ordinary table.</source>
          <target state="translated">Конечно,два вышеприведенных вопроса не совсем эквивалентны.Например,запрос LIKE совпадает со строками,которые содержат такие термины,как &quot;linuxophobe&quot; или &quot;EnterpriseLinux&quot; (как это бывает,набор данных электронной почты Enron на самом деле не содержит таких терминов),в то время как MATCH-запрос на таблицу FTS3 выбирает только те строки,которые содержат &quot;linux&quot; в качестве дискретного токена.Оба поиска не чувствительны к регистру.Таблица FTS3 потребляет на диске около 2006 МБ по сравнению с 1453 МБ для обычной таблицы.Используя ту же самую аппаратную конфигурацию,которая использовалась для выполнения SELECT-запросов,описанных выше,таблица FTS3 заняла чуть менее 31 минуты,по сравнению с 25 для обычной таблицы.</target>
        </trans-unit>
        <trans-unit id="68b0ebb94fca52bc2076d132ead5c0f0cef17ce0" translate="yes" xml:space="preserve">
          <source>Of course, users would prefer code that is both robust in normal use and resistant to malicious attack. The SQLite developers are dedicated to providing that. The purpose of this section is merely to point out that doing both at the same time is hard.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6778acfecc08483f487870a27c4e0b19bb8701d" translate="yes" xml:space="preserve">
          <source>Of course, your mileage may vary depending on hardware, filesystem, and operating system. Double-check these figures on target hardware before committing to a particular design.</source>
          <target state="translated">Конечно,ваш пробег может варьироваться в зависимости от оборудования,файловой системы и операционной системы.Перепроверьте эти цифры на целевом аппаратном обеспечении перед тем,как совершить фиксацию на определенном дизайне.</target>
        </trans-unit>
        <trans-unit id="315230e941921effe51cc9ebfa05403b855f0476" translate="yes" xml:space="preserve">
          <source>Of these changes, only 1a and 2a through 2c are incompatibilities in any formal sense. But users who have previously made custom modifications to the SQLite source (for example to add a custom OS layer for embedded hardware) might find that these changes have a larger impact. On the other hand, an important goal of these changes is to make it much easier to customize SQLite for use on different operating systems.</source>
          <target state="translated">Из этих изменений только 1a и 2a-2c являются несовместимыми в любом формальном смысле.Но пользователи,которые ранее вносили пользовательские изменения в исходный текст SQLite (например,для добавления пользовательского уровня операционной системы для встроенного оборудования),могут обнаружить,что эти изменения оказывают большее влияние.С другой стороны,важной целью этих изменений является облегчение настройки SQLite для использования на различных операционных системах.</target>
        </trans-unit>
        <trans-unit id="e3de5ab0ca4c69dbf00e86d2558843e8d806bb49" translate="yes" xml:space="preserve">
          <source>Off</source>
          <target state="translated">Off</target>
        </trans-unit>
        <trans-unit id="ce667716547fa82bc8795ad7ef205e9410193ed0" translate="yes" xml:space="preserve">
          <source>Offset</source>
          <target state="translated">Offset</target>
        </trans-unit>
        <trans-unit id="58190317f4f075103c701ab1719a5146c7d71c8f" translate="yes" xml:space="preserve">
          <source>OffsetLimit</source>
          <target state="translated">OffsetLimit</target>
        </trans-unit>
        <trans-unit id="1ab3ac50fee719ce4797840a2df9f8c5ee707c03" translate="yes" xml:space="preserve">
          <source>Older versions of SQLite could not read a WAL-mode database that was read-only. In other words, write access was required in order to read a WAL-mode database. This constraint was relaxed beginning with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_22_0.html&quot;&gt;version 3.22.0&lt;/a&gt; (2018-01-22).</source>
          <target state="translated">Более старые версии SQLite не могли читать базу данных в режиме WAL, которая была доступна только для чтения. Другими словами, для чтения базы данных в режиме WAL требовался доступ на запись. Это ограничение было ослаблено, начиная с &lt;a href=&quot;https://sqlite.org/releaselog/3_22_0.html&quot;&gt;версии&lt;/a&gt; SQLite 3.22.0 (2018-01-22).</target>
        </trans-unit>
        <trans-unit id="28b3eeca1402aeadaf4db2bf8f6d2403ee957bf0" translate="yes" xml:space="preserve">
          <source>Older versions of firebird omits all NULLs from SELECT DISTINCT and from UNION.</source>
          <target state="translated">Старые версии firebird исключают все NULL из SELECT DISTINCT и UNION.</target>
        </trans-unit>
        <trans-unit id="8bfe5e60a5daf11fac21979e5a4fa9643a76bc3b" translate="yes" xml:space="preserve">
          <source>Omit all use of &quot;awk&quot; in the makefiles, to make building easier for MSVC users.</source>
          <target state="translated">Опустите все использование &quot;awk&quot; в makefiles,чтобы облегчить сборку для пользователей MSVC.</target>
        </trans-unit>
        <trans-unit id="bf4d0857bd27f59258be5d9b1e12776a9ff94992" translate="yes" xml:space="preserve">
          <source>Omitted parameters take on default values. STEP defaults to 1. END defaults to 9223372036854775807. START defaults to 0.</source>
          <target state="translated">Пропущенные параметры принимают значения по умолчанию.Шаг по умолчанию-1.Значения по умолчанию END-9223372036854775807.Значения по умолчанию для пуска-0.</target>
        </trans-unit>
        <trans-unit id="e0049a66519cae71159800bb77a35007bc2d76d3" translate="yes" xml:space="preserve">
          <source>On</source>
          <target state="translated">On</target>
        </trans-unit>
        <trans-unit id="0e46092ad025ac57fb1677f1d311680029cda2c1" translate="yes" xml:space="preserve">
          <source>On Android, we are told, there are many services that will blindly run arbitrary SQL that is passed to them by untrustworthy apps that have been downloaded from dodgy corners of the internet. Android services are suppose to be more guarded about running SQL from unvetted sources. This author does not have any specific examples to the contrary, but he has heard rumors that they exist. Even if all Android services are more careful and properly vet all the SQL they run, it would be difficult to audit them all in order to verify that they are safe. Hence, security-minded people are keen to ensure that no exploits are possible by passing arbitrary SQL text.</source>
          <target state="translated">На Android,как нам говорят,есть много сервисов,которые будут вслепую запускать произвольный SQL,который передается им ненадежными приложениями,которые были загружены из изворотливых уголков интернета.Предполагается,что сервисы Android будут более осторожны в запуске SQL из непроверенных источников.У этого автора нет конкретных примеров наоборот,но он слышал слухи о том,что они существуют.Даже если все службы Android будут более внимательны и правильно проверять все SQL,которые они запускают,будет сложно провести их аудит,чтобы убедиться,что они безопасны.Следовательно,люди,ориентированные на безопасность,стремятся к тому,чтобы гарантировать отсутствие эксплойтов путем передачи произвольного SQL-текста.</target>
        </trans-unit>
        <trans-unit id="26c3af907230190631617dbb8e5acb92e9854301" translate="yes" xml:space="preserve">
          <source>On Linux and other unix systems you will need to enter something like:</source>
          <target state="translated">На Linux и других unix-системах Вам нужно будет ввести что-то вроде:</target>
        </trans-unit>
        <trans-unit id="1273deeaf4de08300113723f337bae0ec716c243" translate="yes" xml:space="preserve">
          <source>On Win32, do not return an error when attempting to delete a file that does not exist.</source>
          <target state="translated">На Win32 не возвращайте ошибку при попытке удалить несуществующий файл.</target>
        </trans-unit>
        <trans-unit id="b2b2f36a4fafa25d031c2e6870c72d35c487959e" translate="yes" xml:space="preserve">
          <source>On Windows systems, folders are searched in the following order:</source>
          <target state="translated">В системах Windows поиск папок выполняется в следующем порядке:</target>
        </trans-unit>
        <trans-unit id="9d83a99bbbc3869a446954149b390c5195af03a3" translate="yes" xml:space="preserve">
          <source>On Windows with MSVC, use nmake with the Makefile.msc:</source>
          <target state="translated">На Windows с MSVC используйте nmake с Makefile.msc:</target>
        </trans-unit>
        <trans-unit id="e51bd18dd2b65a7e346c37ac44c1031b3f3942d7" translate="yes" xml:space="preserve">
          <source>On Windows, enter:</source>
          <target state="translated">На Windows,введите:</target>
        </trans-unit>
        <trans-unit id="aacb79e6ea038d7e3cda09880e0781239b1e3933" translate="yes" xml:space="preserve">
          <source>On a &lt;a href=&quot;wal#ckpt&quot;&gt;checkpoint&lt;/a&gt;, the WAL is first flushed to persistent storage using the xSync method of the &lt;a href=&quot;c3ref/io_methods&quot;&gt;VFS&lt;/a&gt;. Then valid content of the WAL is transferred into the database file. Finally, the database is flushed to persistent storage using another xSync method call. The xSync operations serve as write barriers - all writes launched before the xSync must complete before any write that launches after the xSync begins.</source>
          <target state="translated">На &lt;a href=&quot;wal#ckpt&quot;&gt;контрольной точке&lt;/a&gt; WAL сначала сбрасывается в постоянное хранилище с помощью метода xSync &lt;a href=&quot;c3ref/io_methods&quot;&gt;VFS&lt;/a&gt; . Затем действительное содержимое WAL переносится в файл базы данных. Наконец, база данных сбрасывается в постоянное хранилище с помощью другого вызова метода xSync. Операции xSync служат барьерами для записи - все записи, запущенные до xSync, должны завершиться до любой записи, которая запускается после начала xSync.</target>
        </trans-unit>
        <trans-unit id="ea7fd316bd0a1ed7abbfd63a2c9be9dcb14966c5" translate="yes" xml:space="preserve">
          <source>On a DISTINCT query that uses an index, try to skip ahead to the next distinct entry using the index rather than stepping through rows, when an appropriate index is available.</source>
          <target state="translated">В запросе DISTINCT,использующем индекс,попробуйте перейти к следующей отдельной записи,используя индекс,а не переходить по строкам,когда доступен соответствующий индекс.</target>
        </trans-unit>
        <trans-unit id="439b4340c2826997b9311dbcdfa182caed0bc968" translate="yes" xml:space="preserve">
          <source>On a traditional spinning disk, a sector is the minimum unit of transfer in both directions, both reading and writing. On flash memory, however, the minimum size of a read is typically much smaller than a minimum write. SQLite is only concerned with the minimum write amount and so for the purposes of this article, when we say &quot;sector&quot; we mean the minimum amount of data that can be written to mass storage in a single go.</source>
          <target state="translated">На традиционном прядильном диске сектор является минимальной единицей передачи в обоих направлениях,как при чтении,так и при записи.На флэш-памяти,однако,минимальный размер считываемого сектора обычно намного меньше минимального объема записи.SQLite заботится только о минимальном объеме записи,поэтому для целей данной статьи,когда мы говорим &quot;сектор&quot;,мы имеем в виду минимальный объем данных,который можно за один раз записать на массовое хранение.</target>
        </trans-unit>
        <trans-unit id="4d25766d7605da89f0dc45ce4758796da7aaedb1" translate="yes" xml:space="preserve">
          <source>On an &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;, if the ROWID or INTEGER PRIMARY KEY column is not explicitly given a value, then it will be filled automatically with an unused integer, usually one more than the largest ROWID currently in use. This is true regardless of whether or not the AUTOINCREMENT keyword is used.</source>
          <target state="translated">В &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; , если столбцу ROWID или INTEGER PRIMARY KEY явно не присвоено значение, он будет автоматически заполнен неиспользуемым целым числом, обычно на единицу больше, чем самый большой ROWID, используемый в настоящее время. Это верно независимо от того, используется ли ключевое слово AUTOINCREMENT.</target>
        </trans-unit>
        <trans-unit id="ebef8439735d14eb6033471fd2e7d318b20febc6" translate="yes" xml:space="preserve">
          <source>On an UPSERT when the order of constraint checks is rearranged, ensure that the affinity transformations on the inserted content occur before any of the constraint checks. Fix for ticket &lt;a href=&quot;https://www.sqlite.org/src/info/79cad5e4b2e219dd197242e9e&quot;&gt;79cad5e4b2e219dd197242e9e&lt;/a&gt;.</source>
          <target state="translated">В UPSERT, когда порядок проверок ограничений изменен, убедитесь, что преобразования сродства во вставленном содержимом происходят до любых проверок ограничений. Исправление для билета &lt;a href=&quot;https://www.sqlite.org/src/info/79cad5e4b2e219dd197242e9e&quot;&gt;79cad5e4b2e219dd197242e9e&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0a7e67fba14e6027ea80edde2148e2473e22f15f" translate="yes" xml:space="preserve">
          <source>On each call to undo::undo or undo::redo, the undo/redo module automatically invokes methods status_refresh and reload_all in all toplevel namespaces. These methods should be defined to reconstruct the display or otherwise update the state of the program based on the undone/redone changes to the database.</source>
          <target state="translated">При каждом вызове команды undo::undo или undo::redo модуль undo/redo автоматически вызывает методы status_refresh и reload_all во всех пространствах имен верхнего уровня.Эти методы должны быть определены,чтобы реконструировать отображение или иным образом обновить состояние программы на основании отмененных/восстановленных изменений в базе данных.</target>
        </trans-unit>
        <trans-unit id="51efe73d5459fecda0ebf237f9f8f384ca5daf31" translate="yes" xml:space="preserve">
          <source>On embedded systems with synchronous filesystems, TRUNCATE results in slower behavior than PERSIST. The commit operation is the same speed. But subsequent transactions are slower following a TRUNCATE because it is faster to overwrite existing content than to append to the end of a file. New journal file entries will always be appended following a TRUNCATE but will usually overwrite with PERSIST.</source>
          <target state="translated">На встраиваемых системах с синхронными файловыми системами TRUNCATE ведет себя медленнее,чем PERSIST.Операция фиксации происходит с той же скоростью.Но последующие транзакции после TRUNCATE выполняются медленнее,так как быстрее перезаписывать существующее содержимое,чем добавлять его в конец файла.Новые записи в файле журнала всегда будут добавляться после ТРУНКАТА,но обычно перезаписываются с помощью PERSIST.</target>
        </trans-unit>
        <trans-unit id="cff1aa0bee9c89492d085449129eae77e72bb5fa" translate="yes" xml:space="preserve">
          <source>On most systems, the malloc() system call returns a buffer that is aligned to an 8-byte boundary. But on some systems (ex: windows) malloc() returns 4-byte aligned pointer. This compile-time option must be used on systems that return 4-byte aligned pointers from malloc().</source>
          <target state="translated">На большинстве систем системный вызов malloc()возвращает буфер,который выровнен по границе 8 байт.Но на некоторых системах (ex:windows)malloc()возвращает указатель,выровненный по 4-байтной границе.Эта опция времени компиляции должна использоваться на системах,возвращающих указатели,выровненные по 4 байтам из malloc().</target>
        </trans-unit>
        <trans-unit id="87f5be0e7a33503458f9f1fc5e662122708d06fc" translate="yes" xml:space="preserve">
          <source>On newer versions of SQLite, a WAL-mode database on read-only media, or a WAL-mode database that lacks write permission, can still be read as long as one or more of the following conditions are met:</source>
          <target state="translated">На более новых версиях SQLite базу данных WAL-режима на носителе,доступном только для чтения,или базу данных WAL-режима,не имеющую разрешения на запись,можно читать до тех пор,пока выполняется одно или несколько из нижеперечисленных условий:</target>
        </trans-unit>
        <trans-unit id="0a3b32dd2c0c0446522505f738b73e43600ba9ad" translate="yes" xml:space="preserve">
          <source>On startup, the &lt;b&gt;sqlite3&lt;/b&gt; program will show a brief banner message then prompt you to enter SQL. Type in SQL statements (terminated by a semicolon), press &quot;Enter&quot; and the SQL will be executed.</source>
          <target state="translated">При запуске программа &lt;b&gt;sqlite3&lt;/b&gt; покажет краткое баннерное сообщение, а затем предложит вам ввести SQL. Введите операторы SQL (заканчивающиеся точкой с запятой), нажмите &amp;laquo;Enter&amp;raquo;, и SQL будет выполнен.</target>
        </trans-unit>
        <trans-unit id="a6133c9cbc7fd01002e1fd8f131c7ef4a48f7b82" translate="yes" xml:space="preserve">
          <source>On startup, the application first decides which version it wants to display. Since the versionId will naturally increase in time and one would normally want to see the latest version, an appropriate query might be:</source>
          <target state="translated">При запуске приложение сначала решает,какую версию оно хочет отобразить.Так как versionId будет естественным образом увеличиваться со временем,и человек обычно хочет видеть последнюю версию,то может быть сделан соответствующий запрос:</target>
        </trans-unit>
        <trans-unit id="d2a06dc722811f829dbda8827b08f5f0b5f36ae8" translate="yes" xml:space="preserve">
          <source>On success, &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; is returned and the new &lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB handle&lt;/a&gt; is stored in *ppBlob. Otherwise an &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; is returned and, unless the error code is SQLITE_MISUSE, *ppBlob is set to NULL. This means that, provided the API is not misused, it is always safe to call &lt;a href=&quot;#sqlite3_blob_close&quot;&gt;sqlite3_blob_close()&lt;/a&gt; on *ppBlob after this function it returns.</source>
          <target state="translated">В случае успеха &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;возвращается SQLITE_OK,&lt;/a&gt; а новый &lt;a href=&quot;#sqlite3_blob&quot;&gt;дескриптор&lt;/a&gt; большого двоичного объекта сохраняется в * ppBlob. В противном случае возвращается &lt;a href=&quot;rescode&quot;&gt;код ошибки&lt;/a&gt; и, если код ошибки не SQLITE_MISUSE, * ppBlob устанавливается в NULL. Это означает, что при условии, что API не используется неправильно, всегда безопасно вызывать &lt;a href=&quot;#sqlite3_blob_close&quot;&gt;sqlite3_blob_close ()&lt;/a&gt; для * ppBlob после того, как эта функция возвращает.</target>
        </trans-unit>
        <trans-unit id="749e0ca8bebcf0ea981a3b5d51013a9a74a29d29" translate="yes" xml:space="preserve">
          <source>On success, &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; is returned and the new &lt;a href=&quot;blob&quot;&gt;BLOB handle&lt;/a&gt; is stored in *ppBlob. Otherwise an &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; is returned and, unless the error code is SQLITE_MISUSE, *ppBlob is set to NULL. This means that, provided the API is not misused, it is always safe to call &lt;a href=&quot;blob_close&quot;&gt;sqlite3_blob_close()&lt;/a&gt; on *ppBlob after this function it returns.</source>
          <target state="translated">В случае успеха &lt;a href=&quot;../rescode#ok&quot;&gt;возвращается SQLITE_OK,&lt;/a&gt; а новый &lt;a href=&quot;blob&quot;&gt;дескриптор&lt;/a&gt; большого двоичного объекта сохраняется в * ppBlob. В противном случае возвращается &lt;a href=&quot;../rescode&quot;&gt;код ошибки&lt;/a&gt; и, если код ошибки не SQLITE_MISUSE, * ppBlob устанавливается в NULL. Это означает, что при условии, что API не используется неправильно, всегда безопасно вызывать &lt;a href=&quot;blob_close&quot;&gt;sqlite3_blob_close ()&lt;/a&gt; для * ppBlob после того, как эта функция возвращает.</target>
        </trans-unit>
        <trans-unit id="65eaebdd334ea618570d91e4458e0eb1b208375f" translate="yes" xml:space="preserve">
          <source>On success, &lt;b&gt;sqlite_compile&lt;/b&gt; returns SQLITE_OK. Otherwise and error code is returned.</source>
          <target state="translated">В случае успеха &lt;b&gt;sqlite_compile&lt;/b&gt; возвращает SQLITE_OK. В противном случае возвращается код ошибки.</target>
        </trans-unit>
        <trans-unit id="3e9b1d8e369d082b964c508c283e64eea1e0560c" translate="yes" xml:space="preserve">
          <source>On success, sqlite3_blob_read() returns SQLITE_OK. Otherwise, an &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; or an &lt;a href=&quot;../rescode#extrc&quot;&gt;extended error code&lt;/a&gt; is returned.</source>
          <target state="translated">В случае успеха sqlite3_blob_read () возвращает SQLITE_OK. В противном случае возвращается &lt;a href=&quot;../rescode&quot;&gt;код ошибки&lt;/a&gt; или &lt;a href=&quot;../rescode#extrc&quot;&gt;расширенный код ошибки&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e81bdc76837634caa6cec9a7812e38a822384af4" translate="yes" xml:space="preserve">
          <source>On success, sqlite3_blob_read() returns SQLITE_OK. Otherwise, an &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; or an &lt;a href=&quot;rescode#extrc&quot;&gt;extended error code&lt;/a&gt; is returned.</source>
          <target state="translated">В случае успеха sqlite3_blob_read () возвращает SQLITE_OK. В противном случае возвращается &lt;a href=&quot;rescode&quot;&gt;код ошибки&lt;/a&gt; или &lt;a href=&quot;rescode#extrc&quot;&gt;расширенный код ошибки&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="00223380eeb8684c87e10d42630c25143e83fb7d" translate="yes" xml:space="preserve">
          <source>On success, sqlite3_blob_write() returns SQLITE_OK. Otherwise, an &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; or an &lt;a href=&quot;../rescode#extrc&quot;&gt;extended error code&lt;/a&gt; is returned. Unless SQLITE_MISUSE is returned, this function sets the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; error code and message accessible via &lt;a href=&quot;errcode&quot;&gt;sqlite3_errcode()&lt;/a&gt; and &lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg()&lt;/a&gt; and related functions.</source>
          <target state="translated">В случае успеха sqlite3_blob_write () возвращает SQLITE_OK. В противном случае возвращается &lt;a href=&quot;../rescode&quot;&gt;код ошибки&lt;/a&gt; или &lt;a href=&quot;../rescode#extrc&quot;&gt;расширенный код ошибки&lt;/a&gt; . Если не возвращается SQLITE_MISUSE, эта функция устанавливает код ошибки &lt;a href=&quot;sqlite3&quot;&gt;подключения&lt;/a&gt; к базе данных и сообщение, доступное через &lt;a href=&quot;errcode&quot;&gt;sqlite3_errcode ()&lt;/a&gt; и &lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg ()&lt;/a&gt; и связанные с ними функции.</target>
        </trans-unit>
        <trans-unit id="e1d8319a0f054e12945ffdcd496271dbacaf81a2" translate="yes" xml:space="preserve">
          <source>On success, sqlite3_blob_write() returns SQLITE_OK. Otherwise, an &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; or an &lt;a href=&quot;rescode#extrc&quot;&gt;extended error code&lt;/a&gt; is returned. Unless SQLITE_MISUSE is returned, this function sets the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; error code and message accessible via &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errcode()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errmsg()&lt;/a&gt; and related functions.</source>
          <target state="translated">В случае успеха sqlite3_blob_write () возвращает SQLITE_OK. В противном случае возвращается &lt;a href=&quot;rescode&quot;&gt;код ошибки&lt;/a&gt; или &lt;a href=&quot;rescode#extrc&quot;&gt;расширенный код ошибки&lt;/a&gt; . Если не возвращается SQLITE_MISUSE, эта функция устанавливает код ошибки &lt;a href=&quot;#sqlite3&quot;&gt;подключения&lt;/a&gt; к базе данных и сообщение, доступное через &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errcode ()&lt;/a&gt; и &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errmsg ()&lt;/a&gt; и связанные с ними функции.</target>
        </trans-unit>
        <trans-unit id="8609e89a9e3f181cc9bf01d1a6238ab2d0959ed4" translate="yes" xml:space="preserve">
          <source>On success, the sqlite3_prepare() family of routines return &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt;; otherwise an &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; is returned.</source>
          <target state="translated">В случае успеха семейство подпрограмм sqlite3_prepare () вернет &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; ; в противном случае возвращается &lt;a href=&quot;rescode&quot;&gt;код ошибки&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3e16251e40927c67fe655d2518e028082c6fa9b3" translate="yes" xml:space="preserve">
          <source>On success, the sqlite3_prepare() family of routines return &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;; otherwise an &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; is returned.</source>
          <target state="translated">В случае успеха семейство подпрограмм sqlite3_prepare () вернет &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; ; в противном случае возвращается &lt;a href=&quot;../rescode&quot;&gt;код ошибки&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="79e4255a03a365ba20cd0884b8ee349e3d935179" translate="yes" xml:space="preserve">
          <source>On the Mac, you can set this pragma:</source>
          <target state="translated">На Маке ты можешь установить эту прагму:</target>
        </trans-unit>
        <trans-unit id="69a450284be9205b76c2e066c35f545c5c025beb" translate="yes" xml:space="preserve">
          <source>On the other hand, a database engine that uses a server can provide better protection from bugs in the client application - stray pointers in a client cannot corrupt memory on the server. And because a server is a single persistent process, it is able control database access with more precision, allowing for finer grain locking and better concurrency.</source>
          <target state="translated">С другой стороны,движок базы данных,использующий сервер,может обеспечить лучшую защиту от ошибок в клиентском приложении-блуждающие указатели в клиенте не могут повредить память на сервере.А поскольку сервер представляет собой единый постоянный процесс,он способен с большей точностью контролировать доступ к базе данных,позволяя более тонкую блокировку зерна и лучшее совпадение.</target>
        </trans-unit>
        <trans-unit id="84736c128a35123ea022380e6a3900484bf1a802" translate="yes" xml:space="preserve">
          <source>On the other hand, a database engine that uses a server can provide better protection from bugs in the client application - stray pointers in a client cannot corrupt memory on the server. And because a server is a single persistent process, it is able to control database access with more precision, allowing for finer-grained locking and better concurrency.</source>
          <target state="translated">С другой стороны,движок базы данных,использующий сервер,может обеспечить лучшую защиту от ошибок в клиентском приложении-блуждающие указатели в клиенте не могут повредить память на сервере.А поскольку сервер представляет собой единый постоянный процесс,он способен с большей точностью контролировать доступ к базе данных,позволяя более точную блокировку и лучшее совпадение.</target>
        </trans-unit>
        <trans-unit id="71cbc82c664fd1caf1a677d0c65b18293805a90f" translate="yes" xml:space="preserve">
          <source>On the other hand, an RBU Vacuum uses more CPU than a regular SQLite VACUUM - in one test as much as five times as much. For this reason, an RBU Vacuum is often significantly slower than an SQLite VACUUM under the same conditions.</source>
          <target state="translated">С другой стороны,RBU Vacuum использует больше CPU,чем обычный SQLite VACUUM-в одном тесте в пять раз больше.По этой причине,вакуум RBU часто значительно медленнее,чем SQLite VACUUM при тех же условиях.</target>
        </trans-unit>
        <trans-unit id="2ec9b50cf6f067a94359ec578926c021dba81fa8" translate="yes" xml:space="preserve">
          <source>On the other hand, dropping tables is not a very common operation so if SQLite takes a little longer, that is not seen as a big problem.</source>
          <target state="translated">С другой стороны,выпадающие таблицы-не очень распространенная операция,поэтому если SQLite занимает немного больше времени,то это не рассматривается как большая проблема.</target>
        </trans-unit>
        <trans-unit id="b75edbc4ccb51b3a0effc26ec943821968d21e88" translate="yes" xml:space="preserve">
          <source>On the other hand, if the result of the subquery must be scanned multiple times (because, for example, it is just one table in a join) then it is better to use a transient table to remember the entire result of the subquery, in order to avoid computing the subquery more than once.</source>
          <target state="translated">С другой стороны,если результат подзапроса должен быть отсканирован несколько раз (потому что,например,это всего лишь одна таблица в соединении),то лучше использовать переходную таблицу,чтобы запомнить весь результат подзапроса,чтобы избежать вычисления подзапроса более одного раза.</target>
        </trans-unit>
        <trans-unit id="4cb26bb6bd2845585001f514df8ac5e23d3a9784" translate="yes" xml:space="preserve">
          <source>On the other hand, read performance deteriorates as the WAL file grows in size since each reader must check the WAL file for the content and the time needed to check the WAL file is proportional to the size of the WAL file. The wal-index helps find content in the WAL file much faster, but performance still falls off with increasing WAL file size. Hence, to maintain good read performance it is important to keep the WAL file size down by running checkpoints at regular intervals.</source>
          <target state="translated">С другой стороны,производительность чтения ухудшается по мере роста размера файла WAL,поскольку каждый читатель должен проверять файл WAL на содержание,а время,необходимое для проверки файла WAL,пропорционально размеру файла WAL.Индекс wal-index помогает находить содержимое в файле WAL гораздо быстрее,но производительность все равно снижается с увеличением размера файла WAL.Следовательно,для поддержания хорошей производительности чтения важно уменьшить размер файла WAL за счет регулярного выполнения контрольных точек через определенные промежутки времени.</target>
        </trans-unit>
        <trans-unit id="9a0c49cb1cedb27f90f5b843b5321b6c2675c041" translate="yes" xml:space="preserve">
          <source>On the stack display, most entries are shown with a prefix that tells the datatype of that stack entry. Integers begin with &quot;&lt;code&gt;i:&lt;/code&gt;&quot;. Floating point values begin with &quot;&lt;code&gt;r:&lt;/code&gt;&quot;. (The &quot;r&quot; stands for &quot;real-number&quot;.) Strings begin with either &quot;&lt;code&gt;s:&lt;/code&gt;&quot;, &quot;&lt;code&gt;t:&lt;/code&gt;&quot;, &quot;&lt;code&gt;e:&lt;/code&gt;&quot; or &quot;&lt;code&gt;z:&lt;/code&gt;&quot;. The difference among the string prefixes is caused by how their memory is allocated. The z: strings are stored in memory obtained from &lt;b&gt;malloc()&lt;/b&gt;. The t: strings are statically allocated. The e: strings are ephemeral. All other strings have the s: prefix. This doesn't make any difference to you, the observer, but it is vitally important to the VDBE since the z: strings need to be passed to &lt;b&gt;free()&lt;/b&gt; when they are popped to avoid a memory leak. Note that only the first 10 characters of string values are displayed and that binary values (such as the result of the MakeRecord instruction) are treated as strings. The only other datatype that can be stored on the VDBE stack is a NULL, which is display without prefix as simply &quot;&lt;code&gt;NULL&lt;/code&gt;&quot;. If an integer has been placed on the stack as both an integer and a string, its prefix is &quot;&lt;code&gt;si:&lt;/code&gt;&quot;.</source>
          <target state="translated">На дисплее стека большинство записей отображается с префиксом, который указывает тип данных этой записи стека. Целые числа начинаются с &amp;laquo; &lt;code&gt;i:&lt;/code&gt; &amp;raquo;. Значения с плавающей запятой начинаются с &amp;laquo; &lt;code&gt;r:&lt;/code&gt; &amp;raquo;. (&amp;laquo;R&amp;raquo; означает &amp;laquo;действительное число&amp;raquo;.) Строки начинаются с &amp;laquo; &lt;code&gt;s:&lt;/code&gt; &amp;raquo;, &amp;laquo; &lt;code&gt;t:&lt;/code&gt; &amp;raquo;, &amp;laquo; &lt;code&gt;e:&lt;/code&gt; &amp;raquo; или &amp;laquo; &lt;code&gt;z:&lt;/code&gt; &amp;raquo;. Разница между строковыми префиксами обусловлена ​​тем, как распределяется их память. Строки z: хранятся в памяти, полученной из &lt;b&gt;malloc ()&lt;/b&gt; . Строки t: размещаются статически. Струны e: эфемерны. Все остальные строки имеют префикс s :. Это не имеет значения для вас, наблюдатель,но это жизненно важно для VDBE, поскольку строки z: должны передаваться в&lt;b&gt;free (),&lt;/b&gt; когда они появляются, чтобы избежать утечки памяти. Обратите внимание, что отображаются только первые 10 символов строковых значений и что двоичные значения (например, результат инструкции MakeRecord) обрабатываются как строки. Единственный другой тип данных, который может храниться в стеке VDBE, - это NULL, который отображается без префикса просто как &amp;laquo; &lt;code&gt;NULL&lt;/code&gt; &amp;raquo;. Если целое число было помещено в стек и как целое число, и как строка, его префикс - &amp;laquo; &lt;code&gt;si:&lt;/code&gt; &amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="e3336bd71adcf37ccf53527f3a1cc4855eac8894" translate="yes" xml:space="preserve">
          <source>On unix systems (or on Windows using cygwin or mingw+msys) the command typically looks something like this:</source>
          <target state="translated">На unix-системах (или в Windows с помощью cygwin или mingw+msys)команда обычно выглядит примерно так:</target>
        </trans-unit>
        <trans-unit id="287d1cbba1056569ceaf042e45ed9558181651a7" translate="yes" xml:space="preserve">
          <source>On unix, if a symlink to a database file is opened, then the corresponding journal files are based on the actual filename, not the symlink name.</source>
          <target state="translated">В unix,если открыта системная ссылка на файл базы данных,то соответствующие файлы журнала основываются на фактическом имени файла,а не на имени системной ссылки.</target>
        </trans-unit>
        <trans-unit id="6c70d0e29a89e83eef274cc81c5528ba689d997c" translate="yes" xml:space="preserve">
          <source>On unix-like systems, directories are searched in the following order:</source>
          <target state="translated">На unix-подобных системах поиск по каталогам осуществляется в следующем порядке:</target>
        </trans-unit>
        <trans-unit id="db7db60b91e81d2d39614db0d3144dc3caa85aa5" translate="yes" xml:space="preserve">
          <source>On windows only, convert all &quot;&lt;code&gt;\&lt;/code&gt;&quot; characters into &quot;&lt;code&gt;/&lt;/code&gt;&quot;.</source>
          <target state="translated">Только в Windows: конвертируйте все символы &amp;laquo; &lt;code&gt;\&lt;/code&gt; &amp;raquo; в &amp;laquo; &lt;code&gt;/&lt;/code&gt; &amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="aa996bed689bb081c327fe76624367885c13654f" translate="yes" xml:space="preserve">
          <source>On windows only, if the filename begins with a drive letter, prepend a single &quot;&lt;code&gt;/&lt;/code&gt;&quot; character.</source>
          <target state="translated">Только в Windows: если имя файла начинается с буквы диска, добавьте перед ним один символ &amp;laquo; &lt;code&gt;/&lt;/code&gt; &amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="d9c768782ea8653d485fb3b7f5aba21cb2ca7bf3" translate="yes" xml:space="preserve">
          <source>Once</source>
          <target state="translated">Once</target>
        </trans-unit>
        <trans-unit id="87f26aaf5f6994f877b899775d955216fa5722f5" translate="yes" xml:space="preserve">
          <source>Once a</source>
          <target state="translated">Один раз</target>
        </trans-unit>
        <trans-unit id="8464198c181050b3c7b7af3b57436c91d71a13de" translate="yes" xml:space="preserve">
          <source>Once a VFS has been registered, it should never be modified. If a change in behavior is required, a new VFS should be registered. The application could, perhaps, use &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_find()&lt;/a&gt; to locate the old VFS, make a copy of the old VFS into a new &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object, make the desired modifications to the new VFS, unregister the old VFS, then register the new VFS in its place. Existing database connections would continue to use the old VFS even after it is unregistered, but new database connections would use the new VFS.</source>
          <target state="translated">После регистрации VFS не следует изменять ее. Если требуется изменение поведения, необходимо зарегистрировать новую VFS. Приложение, возможно, могло бы использовать &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_find (),&lt;/a&gt; чтобы найти старую VFS, сделать копию старой VFS в новый объект &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; , внести желаемые изменения в новую VFS, отменить регистрацию старой VFS, а затем зарегистрировать новую VFS в ее место. Существующие соединения с базой данных будут продолжать использовать старую VFS даже после отмены регистрации, но новые соединения с базой данных будут использовать новую VFS.</target>
        </trans-unit>
        <trans-unit id="55b2eace4f6d572184649196769be324d9ec08aa" translate="yes" xml:space="preserve">
          <source>Once a connection obtains a table lock, it is not released until the current transaction (read or write) is concluded.</source>
          <target state="translated">Как только соединение получает блокировку таблицы,оно не освобождается до тех пор,пока не будет заключена текущая транзакция (чтение или запись).</target>
        </trans-unit>
        <trans-unit id="5e4e9f1432dcf3c9b2a4412dec01ffd3ea3a631b" translate="yes" xml:space="preserve">
          <source>Once a process obtains an exclusive lock, it is permitted to write to the database file. It then proceeds to read the original content of pages out of the rollback journal and write that content back to where it came from in the database file. Recall that the header of the rollback journal records the original size of the database file prior to the start of the aborted transaction. SQLite uses this information to truncate the database file back to its original size in cases where the incomplete transaction caused the database to grow. At the end of this step, the database should be the same size and contain the same information as it did before the start of the aborted transaction.</source>
          <target state="translated">Как только процесс получает эксклюзивный замок,разрешается запись в файл базы данных.Затем он переходит к чтению исходного содержимого страниц из журнала отката и записывает это содержимое обратно в файл базы данных,откуда оно пришло.Вспомните,что заголовок журнала отката записывает исходный размер файла базы данных до начала прерванной транзакции.SQLite использует эту информацию для усечения файла базы данных до исходного размера в тех случаях,когда неполная транзакция привела к росту базы данных.В конце этого шага БД должна быть того же размера и содержать ту же информацию,что и до начала прерванной транзакции.</target>
        </trans-unit>
        <trans-unit id="b42ea281b3fc7c07c016d5e3f2cf18291c599ca4" translate="yes" xml:space="preserve">
          <source>Once a table has been attached to a session object, the session object records the primary key values of all new rows inserted into the table. It also records the original primary key and other column values of any deleted or updated rows. For each unique primary key value, data is only recorded once - the first time a row with said primary key is inserted, updated or deleted in the lifetime of the session.</source>
          <target state="translated">После прикрепления таблицы к объекту сеанса,объект сеанса записывает первичные ключевые значения всех новых строк,вставленных в таблицу.Он также записывает исходный первичный ключ и другие значения столбцов любых удаленных или обновленных строк.Для каждого уникального значения первичного ключа данные записываются только один раз-это первый раз,когда строка с указанным первичным ключом вставляется,обновляется или удаляется в течение всего сеанса.</target>
        </trans-unit>
        <trans-unit id="9c0b7ad6ff995bbd9fed309a9d73615d47bfa0e5" translate="yes" xml:space="preserve">
          <source>Once a transaction has been opened, reading data from a database connection is a simple operation. Using the xRead() method of the file-handle open on the database file, the required database file pages are read one at a time. SQLite never reads partial pages and always uses a single call to xRead() for each required page.</source>
          <target state="translated">После открытия транзакции чтение данных из соединения с базой данных является простой операцией.С помощью метода xRead()файл-ручка,открытая на файле базы данных,считываются по очереди страницы требуемого файла базы данных.SQLite никогда не читает частичные страницы и всегда использует один вызов xRead()для каждой требуемой страницы.</target>
        </trans-unit>
        <trans-unit id="511dc23c3f8ad619f86fc49e5ac60cacc5f4cbfc" translate="yes" xml:space="preserve">
          <source>Once a virtual table has been created, it can be used like any other table with the exceptions noted above and imposed by specific virtual table implementations. A virtual table is destroyed using the ordinary &lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt; syntax.</source>
          <target state="translated">После создания виртуальной таблицы ее можно использовать как любую другую таблицу с исключениями, указанными выше и налагаемыми конкретными реализациями виртуальной таблицы. Виртуальная таблица уничтожается с использованием обычного синтаксиса &lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c3f695a7b377f8d655c6f7bd1deb78c481aa015e" translate="yes" xml:space="preserve">
          <source>Once again, practical implementations will likely subclass this structure to add additional private fields.</source>
          <target state="translated">Опять же,практические реализации,скорее всего,подразделят эту структуру на подклассы для добавления дополнительных приватных полей.</target>
        </trans-unit>
        <trans-unit id="44317a76e0c4f1b6b3d16db84fa92562885dc8a9" translate="yes" xml:space="preserve">
          <source>Once again, the SQL statements generate identical bytecode and thus do exactly the same job in exactly the same way. But the second form is made easier for humans to read by grouping the query parameters together into a single row value rather than scattering them across the WHERE clause.</source>
          <target state="translated">И снова SQL операторы генерируют идентичный байткод и таким образом делают точно такую же работу.Но вторую форму человеку проще прочитать,сгруппировав параметры запроса в одну строку,а не рассеивая их по пункту WHERE.</target>
        </trans-unit>
        <trans-unit id="d645ca4d6b0e5bfa41d1d0e06bb9cd91ff636156" translate="yes" xml:space="preserve">
          <source>Once all rollback journal files have been flushed to disk, it is safe to begin updating database files. We have to obtain an exclusive lock on all database files before writing the changes. After all the changes are written, it is important to flush the changes to disk so that they will be preserved in the event of a power failure or operating system crash.</source>
          <target state="translated">После того,как все файлы журналов отката будут записаны на диск,можно приступать к обновлению файлов базы данных.Перед записью изменений мы должны получить эксклюзивную блокировку всех файлов базы данных.После того,как все изменения записаны,важно промыть их на диск,чтобы они были сохранены в случае отключения питания или сбоя операционной системы.</target>
        </trans-unit>
        <trans-unit id="73fcb528effe6301ec78591adf7629a8ed98b913" translate="yes" xml:space="preserve">
          <source>Once an SQLite database is open, it can be controlled using methods of the</source>
          <target state="translated">После того,как база данных SQLite открыта,ею можно управлять с помощью метода</target>
        </trans-unit>
        <trans-unit id="1676ac6920d27f0701cc052fe7ff5982a44cea9d" translate="yes" xml:space="preserve">
          <source>Once an encoding has been set for a database, it cannot be changed.</source>
          <target state="translated">После установки кодировки для базы данных она не может быть изменена.</target>
        </trans-unit>
        <trans-unit id="1f61d0c0dc743205cfd592b973902a4df3bd2139" translate="yes" xml:space="preserve">
          <source>Once an exclusive lock is held, we know that no other processes are reading from the database file and it is safe to write changes into the database file. Usually those changes only go as far as the operating systems disk cache and do not make it all the way to mass storage.</source>
          <target state="translated">После того,как эксклюзивный замок снят,мы знаем,что никакие другие процессы не читают из файла базы данных,и можно безопасно записать изменения в файл базы данных.Обычно эти изменения заходят только в кэш диска операционной системы и не попадают в массовое хранилище.</target>
        </trans-unit>
        <trans-unit id="8d6da848ac7743477288c842a221e398489c8a06" translate="yes" xml:space="preserve">
          <source>Once any conversions have taken place, and neither value is NULL, the values are compared. If both values are blobs then memcmp() is used to determine the results of the comparison. If both values are text, then the appropriate collating function specified in P4 is used to do the comparison. If P4 is not specified then memcmp() is used to compare text string. If both values are numeric, then a numeric comparison is used. If the two values are of different types, then numbers are considered less than strings and strings are considered less than blobs.</source>
          <target state="translated">После любых преобразований,ни одно из которых не является NULL,значения сравниваются.Если оба значения являются блоками,то для определения результатов сравнения используется функция memcmp().Если оба значения являются текстовыми,то для проведения сравнения используется соответствующая функция сравнения,указанная в P4.Если P4 не указана,то для сравнения текстовой строки используется функция memcmp().Если оба значения являются числовыми,то для сравнения используется числовая функция.Если оба значения разного типа,то числа считаются меньше,чем строки,а строки считаются меньше,чем капли.</target>
        </trans-unit>
        <trans-unit id="4b170c45b3f098d917697616ac86ca3f213bd255" translate="yes" xml:space="preserve">
          <source>Once everything is ready, run the &quot;&lt;code&gt;fossil commit&lt;/code&gt;&quot; command to check in the changes. This creates circle (4) in the diagram above.</source>
          <target state="translated">Когда все будет готово, запустите команду &quot; &lt;code&gt;fossil commit&lt;/code&gt; &quot;, чтобы проверить изменения. Это создает круг (4) на схеме выше.</target>
        </trans-unit>
        <trans-unit id="89efbd20c0a9cf3f9851965660941121b8a57cbc" translate="yes" xml:space="preserve">
          <source>Once one is comfortable with the concept of storing each slide separately, it is a small step to support versioning of the presentation. Consider the following schema:</source>
          <target state="translated">После того,как вы уживаетесь с концепцией хранения каждого слайда в отдельности,это небольшой шаг для поддержки версионирования презентации.Рассмотрим следующую схему:</target>
        </trans-unit>
        <trans-unit id="05be8dd08c1c90f1df285706af044dc836d0d98a" translate="yes" xml:space="preserve">
          <source>Once populated, there are three ways to execute a full-text query against the contents of an FTS5 table:</source>
          <target state="translated">После заполнения существует три способа выполнения полнотекстового запроса к содержимому таблицы FTS5:</target>
        </trans-unit>
        <trans-unit id="e7dc51406db9bf51bbe6620c6512b34c3f0e8f5e" translate="yes" xml:space="preserve">
          <source>Once the dirty page being purged is writable, it is simply written into the database file.</source>
          <target state="translated">После того,как очищаемая грязная страница может быть записана,она просто записывается в файл базы данных.</target>
        </trans-unit>
        <trans-unit id="821430ef05c1ab204de759a3df24102ae4261d90" translate="yes" xml:space="preserve">
          <source>Once the input data from the FROM clause has been filtered by the WHERE clause expression (if any), the set of result rows for the simple SELECT are calculated. Exactly how this is done depends on whether the simple SELECT is an aggregate or non-aggregate query, and whether or not a GROUP BY clause was specified.</source>
          <target state="translated">После того,как входные данные из выражения FROM отфильтрованы выражением WHERE (если таковое имеется),вычисляется набор строк результата для простого SELECT.Точность этого зависит от того,является ли простой SELECT агрегированным или неагрегированным запросом и была ли указана оговорка GROUP BY или нет.</target>
        </trans-unit>
        <trans-unit id="79336569e93b2e9d0a83cc5e0a929d5ce48d2824" translate="yes" xml:space="preserve">
          <source>Once the project repository is created, create an open checkout of the project by moving to the directory where you want to keep all of the project source code and typing:</source>
          <target state="translated">После того,как репозиторий проекта создан,создайте открытую проверку проекта,перейдя в каталог,в котором вы хотите сохранить весь исходный код проекта и набрав его:</target>
        </trans-unit>
        <trans-unit id="c4e9c9ce3f592c90096798d4d198a8b0474086e9" translate="yes" xml:space="preserve">
          <source>Once the spellfix1 extension is loaded, an instance of the spellfix1 virtual table is created like this:</source>
          <target state="translated">После загрузки расширения spellfix1 создаётся экземпляр виртуальной таблицы spellfix1 таким образом:</target>
        </trans-unit>
        <trans-unit id="8513b43854c13df7657753be614db748baf13f7a" translate="yes" xml:space="preserve">
          <source>Once the test program is generated, it is run with no arguments to perform the tests. Progress information as well as error diagnostics appear on standard output. (Alternative output arrangements can be made using a compile-time option for embedded devices that lack a standard output channel.) The program returns zero if there are no errors and non-zero if any problems were detected.</source>
          <target state="translated">После того,как тестовая программа сгенерирована,она запускается без аргументов для выполнения тестов.Информация о ходе выполнения,а также диагностика ошибок появляется на стандартном выходе.(Для встраиваемых устройств,не имеющих стандартного выходного канала,можно использовать опцию &quot;время компиляции&quot;).Программа возвращает ноль при отсутствии ошибок и ненулевой при обнаружении проблем.</target>
        </trans-unit>
        <trans-unit id="bd0d76b14cf548de7ba347b074f1a4d3fbd73686" translate="yes" xml:space="preserve">
          <source>Once the virtual table is created, it can be queried as follows:</source>
          <target state="translated">После создания виртуальной таблицы ее можно запросить следующим образом:</target>
        </trans-unit>
        <trans-unit id="1f76d0dc14ccffaabe0506021b655e9b2d8e3d76" translate="yes" xml:space="preserve">
          <source>Once you locate a specific version, click on the hyperlink for that version to see the &quot;Check-in Information Page&quot;. Then click on either the &quot;Tarball&quot; link or the &quot;ZIP archive&quot; link to download the complete source tree.</source>
          <target state="translated">Как только вы найдете конкретную версию,нажмите на гиперссылку для этой версии,чтобы увидеть &quot;Страницу информации о регистрации&quot;.Затем нажмите либо на ссылку &quot;Tarball&quot;,либо на ссылку &quot;ZIP-архив&quot;,чтобы загрузить полное дерево исходных текстов.</target>
        </trans-unit>
        <trans-unit id="5d89aa77c530c282e22378ce0f5d708e01a8b4fb" translate="yes" xml:space="preserve">
          <source>One approach to this query is to use the fruit='Orange' term of the WHERE clause to find all rows dealing with oranges, then filter those rows by rejecting any that are from states other than California. This process is shown by &lt;a href=&quot;#fig7&quot;&gt;figure 7&lt;/a&gt; above. This is a perfectly reasonable approach in most cases. Yes, the database engine did have to do an extra binary search for the Florida orange row that was later rejected, so it was not as efficient as we might hope, though for many applications it is efficient enough.</source>
          <target state="translated">Один из подходов к этому запросу - использовать термин fruit = 'Orange' в предложении WHERE, чтобы найти все строки, относящиеся к апельсинам, а затем отфильтровать эти строки, отклоняя любые из штатов, отличных от Калифорнии. Этот процесс показан на &lt;a href=&quot;#fig7&quot;&gt;рисунке 7&lt;/a&gt; выше. В большинстве случаев это совершенно разумный подход. Да, движку базы данных действительно пришлось выполнить дополнительный двоичный поиск оранжевой строки Флориды, который позже был отклонен, поэтому он оказался не таким эффективным, как мы могли бы надеяться, хотя для многих приложений он достаточно эффективен.</target>
        </trans-unit>
        <trans-unit id="83e48e323326e14265bd89807dc478da45112a98" translate="yes" xml:space="preserve">
          <source>One can also provide comma-separated arguments to the module following the module name:</source>
          <target state="translated">Можно также предоставлять аргументы,разделенные запятыми,модулю,следующему за именем модуля:</target>
        </trans-unit>
        <trans-unit id="c99a07ebdfa971a90b20da9b4561b5f49cd6023c" translate="yes" xml:space="preserve">
          <source>One can also set the &lt;a href=&quot;cli&quot;&gt;CLI&lt;/a&gt; into automatic EXPLAIN QUERY PLAN mode using the &quot;.eqp on&quot; command:</source>
          <target state="translated">Также можно установить &lt;a href=&quot;cli&quot;&gt;CLI&lt;/a&gt; в автоматический режим EXPLAIN QUERY PLAN с помощью команды &quot;.eqp on&quot;:</target>
        </trans-unit>
        <trans-unit id="efbb187108974c009f143234a98d6989ff9c9ac6" translate="yes" xml:space="preserve">
          <source>One can also think of savepoints as &quot;marks&quot; in the transaction timeline. In this view, the SAVEPOINT command creates a new mark, the ROLLBACK TO command rewinds the timeline back to a point just after the named mark, and the RELEASE command erases marks from the timeline without actually making any changes to the database.</source>
          <target state="translated">Можно также думать о точках сохранения как о &quot;метках&quot; в графике транзакций.В этом представлении команда SAVEPOINT создает новую метку,команда ROLLBACK TO перематывает временную шкалу обратно в точку,расположенную сразу после именованной метки,а команда RELEASE стирает метки с временной шкалы,не внося никаких изменений в базу данных.</target>
        </trans-unit>
        <trans-unit id="3d55d95e5af6d3d744fa5a934dc2cc27683084a3" translate="yes" xml:space="preserve">
          <source>One can explicitly change out of WAL mode using a pragma such as this:</source>
          <target state="translated">Можно явно выйти из режима WAL,используя такую прагму:</target>
        </trans-unit>
        <trans-unit id="5812082b2084545c8ed5d26ce266777d4a58efe5" translate="yes" xml:space="preserve">
          <source>One can see how the OR-by-UNION technique could also be leveraged to use multiple indices on queries where the WHERE clause has terms connected by AND, by using an intersect operator in place of union. Many SQL database engines will do just that. But the performance gain over using just a single index is slight and so SQLite does not implement that technique at this time. However, a future version SQLite might be enhanced to support AND-by-INTERSECT.</source>
          <target state="translated">Можно увидеть,как можно использовать технику &quot;по ОРИ&quot; для использования нескольких индексов на запросах,где в пункте &quot;Где&quot; есть термины,связанные с И&quot;,с помощью оператора пересечения вместо объединения.Многие движки баз данных SQL сделают именно это.Но прирост производительности по сравнению с использованием только одного индекса невелик,и поэтому SQLite в настоящее время не реализует эту технику.Тем не менее,будущая версия SQLite может быть усовершенствована для поддержки AND-by-INTERSECT.</target>
        </trans-unit>
        <trans-unit id="18266c8f1da4ccb3784663f1422488207a89b45d" translate="yes" xml:space="preserve">
          <source>One cannot create a trigger on a virtual table.</source>
          <target state="translated">Нельзя создать триггер на виртуальном столе.</target>
        </trans-unit>
        <trans-unit id="08c14fea12c1a91b86b4eb3020bc8d201daa13d9" translate="yes" xml:space="preserve">
          <source>One cannot create additional indices on a virtual table. (Virtual tables can have indices but that must be built into the virtual table implementation. Indices cannot be added separately using &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt; statements.)</source>
          <target state="translated">На виртуальной таблице нельзя создать дополнительные индексы. (Виртуальные таблицы могут иметь индексы, но они должны быть встроены в реализацию виртуальной таблицы. Индексы нельзя добавлять отдельно с помощью операторов &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt; .)</target>
        </trans-unit>
        <trans-unit id="d3b50c178c087fb42ad06f0aba999c85b1ef895b" translate="yes" xml:space="preserve">
          <source>One cannot easily view, change, or extract the content of an OpenDocument presentation using generic tools. The only reasonable way to view or edit an OpenDocument document is to open it up using an application that is specifically designed to read or write OpenDocument (read: LibreOffice or one of its cousins). The situation could be worse. One can extract and view individual images (say) from a presentation using just the &quot;zip&quot; archiver tool. But it is not reasonable try to extract the text from a slide. Remember that all content is stored in a single &quot;context.xml&quot; file. That file is XML, so it is a text file. But it is not a text file that can be managed with an ordinary text editor. For the example presentation above, the content.xml file consist of exactly two lines. The first line of the file is just:</source>
          <target state="translated">Невозможно легко просмотреть,изменить или извлечь содержимое презентации OpenDocument с помощью общих инструментов.Единственный разумный способ просмотра или редактирования документа OpenDocument-это открыть его с помощью приложения,специально разработанного для чтения или написания OpenDocument (читать:LibreOffice или один из его двоюродных братьев).Ситуация может быть хуже.Можно извлекать и просматривать отдельные изображения (скажем)из презентации с помощью простого инструмента архиватора &quot;zip&quot;.Но пытаться извлечь текст из слайда нецелесообразно.Помните,что все содержимое хранится в одном файле &quot;context.xml&quot;.Этот файл является XML,то есть текстовым.Но это не текстовый файл,которым можно управлять с помощью обычного текстового редактора.Для вышеприведенного примера представления,файл content.xml состоит ровно из двух строк.Первая строка файла просто:</target>
        </trans-unit>
        <trans-unit id="8b60832325e280604faf68cf7c5149fd06825525" translate="yes" xml:space="preserve">
          <source>One cannot run &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE ... ADD COLUMN&lt;/a&gt; commands against a virtual table.</source>
          <target state="translated">Невозможно выполнить команды &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE ... ADD COLUMN&lt;/a&gt; для виртуальной таблицы.</target>
        </trans-unit>
        <trans-unit id="8229271a498b58a8b73749061ba175879d5bffff" translate="yes" xml:space="preserve">
          <source>One difference between Next and ListRead is their idea of a &quot;thing&quot;. The &quot;things&quot; for the Next instruction are records in a database file. &quot;Things&quot; for ListRead are integer keys in a list. Another difference is whether to jump or fall through if there is no next &quot;thing&quot;. In this case, Next falls through, and ListRead jumps. Later on, we will see other looping instructions (NextIdx and SortNext) that operate using the same principle.</source>
          <target state="translated">Одно из различий между Next и ListRead заключается в их представлении о &quot;вещи&quot;.Вещи&quot; для команды Next-это записи в файле базы данных.&quot;Вещи&quot; для ListRead-это целочисленные ключи в списке.Другое отличие-прыгать или проваливаться,если следующего &quot;вещи&quot; нет.В этом случае Next выпадает,а ListRead прыгает.Позже мы увидим другие инструкции по прыжкам (NextIdx и SortNext),которые работают по тому же принципу.</target>
        </trans-unit>
        <trans-unit id="0e2add845dd3757fedbc712aca0fdd2b6ebca768" translate="yes" xml:space="preserve">
          <source>One example of this occurred circa 2013-08-30 on the canonical repository for the &lt;a href=&quot;http://www.fossil-scm.org/&quot;&gt;Fossil DVCS&lt;/a&gt;. In that event, file descriptor 2 (standard error) was being erroneously closed (by &lt;a href=&quot;http://www.stunnel.org/&quot;&gt;stunnel&lt;/a&gt;, we suspect) prior to &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; so that the file descriptor used for the repository database file was 2. Later, an application bug caused an assert() statement to emit an error message by invoking write(2,...). But since file descriptor 2 was now connected to a database file, the error message overwrote part of the database. To guard against this kind of problem, SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_1.html&quot;&gt;version 3.8.1&lt;/a&gt; (2013-10-17) and later refuse to use low-numbered file descriptors for database files. (See &lt;a href=&quot;compile#minimum_file_descriptor&quot;&gt;SQLITE_MINIMUM_FILE_DESCRIPTOR&lt;/a&gt; for additional information.)</source>
          <target state="translated">Один из примеров этого произошел примерно 30 августа 2013 г. в каноническом репозитории &lt;a href=&quot;http://www.fossil-scm.org/&quot;&gt;Fossil DVCS&lt;/a&gt; . В этом случае файловый дескриптор 2 (стандартная ошибка) был ошибочно закрыт ( мы подозреваем, &lt;a href=&quot;http://www.stunnel.org/&quot;&gt;stunnel&lt;/a&gt; ) до &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2 (),&lt;/a&gt; так что файловый дескриптор, используемый для файла базы данных репозитория, был 2. Позже ошибка приложения вызвала assert ( ), чтобы выдать сообщение об ошибке, вызвав write (2, ...). Но поскольку файловый дескриптор 2 теперь был подключен к файлу базы данных, сообщение об ошибке перезаписало часть базы данных. Чтобы защититься от такого рода проблем, SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_1.html&quot;&gt;версии 3.8.1&lt;/a&gt; (2013-10-17) и более поздних версий отказываются использовать файловые дескрипторы с малыми номерами для файлов базы данных. (См. &lt;a href=&quot;compile#minimum_file_descriptor&quot;&gt;SQLITE_MINIMUM_FILE_DESCRIPTOR&lt;/a&gt; для дополнительной информации.)</target>
        </trans-unit>
        <trans-unit id="f155185b09ba1b186403646b80d41d02e18f29b2" translate="yes" xml:space="preserve">
          <source>One exception to the typelessness of SQLite is a column whose type is INTEGER PRIMARY KEY. (And you must use &quot;INTEGER&quot; not &quot;INT&quot;. A column of type INT PRIMARY KEY is typeless just like any other.) INTEGER PRIMARY KEY columns must contain a 32-bit signed integer. Any attempt to insert non-integer data will result in an error.</source>
          <target state="translated">Одним из исключений безпечатности SQLite является столбец,тип которого-INTEGER PRIMARY KEY.(И вы должны использовать &quot;INTEGER&quot;,а не &quot;INT&quot;.Столбец типа INT PRIMARY KEY является безпечатным,как и любой другой).Столбец типа INTEGER PRIMARY KEY должен содержать 32-битное знаковое целое число.Любая попытка вставить нецифровые данные приведет к ошибке.</target>
        </trans-unit>
        <trans-unit id="c476dc0c19b1ad151c922c972d11950866ac1040" translate="yes" xml:space="preserve">
          <source>One fuzzing researcher of particular note is &lt;a href=&quot;https://www.manuelrigger.at/&quot;&gt;Manuel Rigger&lt;/a&gt;, currently (as this paragraph is written on 2019-12-21) at &lt;a href=&quot;https://ethz.ch/en.html&quot;&gt;ETH Zurich&lt;/a&gt;. Most fuzzers only look for assertion faults, crashes, undefined behavior (UB), or other easily detected anomalies. Dr. Rigger's fuzzers, on the other hand, are able to find cases where SQLite computes an incorrect answer. Rigger has found &lt;a href=&quot;https://www.sqlite.org/src/timeline?y=t&amp;amp;u=mrigger&amp;amp;n=all&quot;&gt;many such cases&lt;/a&gt;. Most of these finds are fairly obscure corner cases involving type conversions and affinity transformations, and a good number of the finds are against unreleased features. Nevertheless, his finds are still important as they are real bugs, and the SQLite developers are grateful to be able to identify and fix the underlying problems. Rigger's work is currently unpublished. When it is released, it could be as influential as Zalewski's invention of AFL and profile-guided fuzzing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6bf8910e6414d0165fef0d30b0886bc0f8d4329" translate="yes" xml:space="preserve">
          <source>One implication of the above is that if a change is made and then unmade within a single session (for example if a row is inserted and then deleted again), the sessions module does not report any change at all. Or if a row is updated multiple times within the same session, all updates are coalesced into a single update within any changeset or patchset blob.</source>
          <target state="translated">Одно из последствий вышесказанного заключается в том,что если в течение одного сеанса (например,если вставляется строка,а затем снова удаляется)происходит изменение,то модуль сеансов вообще не сообщает об этом изменении.Или если строка обновляется несколько раз в течение одного сеанса,все обновления объединяются в одно обновление в любом changeset или patchset блоке.</target>
        </trans-unit>
        <trans-unit id="fc9f38831587103a404686b12cd389ecfbf1fe12" translate="yes" xml:space="preserve">
          <source>One might argue that it is ok, in this era of multi-gigabyte desktops, to read the entire document into memory. But it is not ok. For one, the amount of memory used far exceeds the (compressed) file size on disk. So a 50MB presentation might take 200MB or more RAM. That still is not a problem if one only edits a single document at a time. But when working on a talk, this author will typically have 10 or 15 different presentations up all at the same time (to facilitate copy/paste of slides from past presentation) and so gigabytes of memory are required. Add in an open web browser or two and a few other desktop apps, and suddenly the disk is whirling and the machine is swapping. And even having just a single document is a problem when working on an inexpensive Chromebook retrofitted with Ubuntu. Using less memory is always better.</source>
          <target state="translated">Можно поспорить,что в эту эпоху многогигабайтных рабочих столов нормально читать весь документ в память.Но это не нормально.Во-первых,объем используемой памяти намного превышает (сжатый)размер файла на диске.Так что для презентации на 50 МБ может потребоваться 200 МБ и более оперативной памяти.Это все равно не проблема,если редактировать только один документ за раз.Но при работе над докладом этот автор,как правило,имеет 10 или 15 различных презентаций одновременно (для облегчения копирования/вставки слайдов из прошлой презентации),поэтому требуется гигабайт памяти.Добавьте в открытый веб-браузер или два и несколько других настольных приложений,и вдруг диск закрутится,и машина поменяется местами.И даже иметь только один документ является проблемой при работе на недорогой Chromebook,модернизированный с Ubuntu.Использование меньшего количества памяти всегда лучше.</target>
        </trans-unit>
        <trans-unit id="f44cc341ba0d29ec39fe1d9113cc5db69afebdc7" translate="yes" xml:space="preserve">
          <source>One might want to provide other &lt;a href=&quot;compile&quot;&gt;compile-time options&lt;/a&gt; such as &lt;a href=&quot;compile#enable_fts4&quot;&gt;-DSQLITE_ENABLE_FTS4&lt;/a&gt; or &lt;a href=&quot;compile#enable_fts5&quot;&gt;-DSQLITE_ENABLE_FTS5&lt;/a&gt; for full-text search, &lt;a href=&quot;compile#enable_rtree&quot;&gt;-DSQLITE_ENABLE_RTREE&lt;/a&gt; for the R*Tree search engine extension, &lt;a href=&quot;compile#enable_json1&quot;&gt;-DSQLITE_ENABLE_JSON1&lt;/a&gt; to include &lt;a href=&quot;json1&quot;&gt;JSON SQL functions&lt;/a&gt;, or &lt;a href=&quot;compile#enable_dbstat_vtab&quot;&gt;-DSQLITE_ENABLE_DBSTAT_VTAB&lt;/a&gt; for the &lt;a href=&quot;dbstat&quot;&gt;dbstat virtual table&lt;/a&gt;. In order to see extra commentary in &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt; listings, add the &lt;a href=&quot;compile#enable_explain_comments&quot;&gt;-DSQLITE_ENABLE_EXPLAIN_COMMENTS&lt;/a&gt; option. On unix systems, add -DHAVE_USLEEP=1 if the host machine supports the usleep() system call. Add -DHAVE_READLINE and the -lreadline and -lncurses libraries to get command-line editing support. One might also want to specify some compiler optimization switches. (The precompiled CLI available for download from the SQLite website uses &quot;-Os&quot;.) There are countless possible variations here. A command to compile a full-featured shell might look something like this:</source>
          <target state="translated">Можно было бы хотеть , чтобы обеспечить другие &lt;a href=&quot;compile&quot;&gt;параметры компиляции&lt;/a&gt; , такие как &lt;a href=&quot;compile#enable_fts4&quot;&gt;-DSQLITE_ENABLE_FTS4&lt;/a&gt; или &lt;a href=&quot;compile#enable_fts5&quot;&gt;-DSQLITE_ENABLE_FTS5&lt;/a&gt; для полнотекстового поиска, &lt;a href=&quot;compile#enable_rtree&quot;&gt;-DSQLITE_ENABLE_RTREE&lt;/a&gt; для расширения поисковой системы R * Tree, &lt;a href=&quot;compile#enable_json1&quot;&gt;-DSQLITE_ENABLE_JSON1&lt;/a&gt; включать &lt;a href=&quot;json1&quot;&gt;функции JSON SQL&lt;/a&gt; или &lt;a href=&quot;compile#enable_dbstat_vtab&quot;&gt;-DSQLITE_ENABLE_DBSTAT_VTAB&lt;/a&gt; для &lt;a href=&quot;dbstat&quot;&gt;dbstat виртуальной таблицы&lt;/a&gt; . Чтобы увидеть дополнительные комментарии в списках &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt; , добавьте &lt;a href=&quot;compile#enable_explain_comments&quot;&gt;-DSQLITE_ENABLE_EXPLAIN_COMMENTS&lt;/a&gt;вариант. В системах unix добавьте -DHAVE_USLEEP = 1, если хост-машина поддерживает системный вызов usleep (). Добавьте -DHAVE_READLINE и библиотеки -lreadline и -lncurses, чтобы получить поддержку редактирования командной строки. Можно также указать некоторые переключатели оптимизации компилятора. (В предварительно скомпилированном интерфейсе командной строки, доступном для загрузки с веб-сайта SQLite, используется &amp;laquo;-O&amp;raquo;.) Здесь существует бесчисленное множество возможных вариантов. Команда для компиляции полнофункциональной оболочки может выглядеть примерно так:</target>
        </trans-unit>
        <trans-unit id="6a02d032d7380123e8a5e72e863e1054c5bd48cb" translate="yes" xml:space="preserve">
          <source>One minor downside of splitting content into smaller pieces is that compression does not work as well on shorter texts and so the size of the document might increase. But as the bulk of the document space is used to store images, a small reduction in the compression efficiency of the text content will hardly be noticeable, and is a small price to pay for an improved user experience.</source>
          <target state="translated">Один незначительный недостаток разделения содержания на более мелкие части заключается в том,что сжатие не работает так же хорошо на более короткие тексты,и поэтому размер документа может увеличиться.Но так как большая часть документального пространства используется для хранения изображений,небольшое снижение эффективности сжатия текстового содержимого вряд ли будет заметно,и это небольшая цена,которую нужно заплатить за улучшенный пользовательский опыт.</target>
        </trans-unit>
        <trans-unit id="b297ff44d76535e06e20e05a05458aba9a18af0a" translate="yes" xml:space="preserve">
          <source>One of the 10 decimal digit ASCII characters, or</source>
          <target state="translated">Один из 10 десятичных ASCII-символов или</target>
        </trans-unit>
        <trans-unit id="67403b0cb5390fcf0c705699aeb495a2edb6d96b" translate="yes" xml:space="preserve">
          <source>One of the 52 upper and lower case ASCII characters, or</source>
          <target state="translated">Один из 52 символов ASCII в верхнем и нижнем регистре,или</target>
        </trans-unit>
        <trans-unit id="cff101187bdbe5720613db95b3564ea1057f17a1" translate="yes" xml:space="preserve">
          <source>One of the &lt;a href=&quot;different&quot;&gt;distinctive features&lt;/a&gt; of SQLite is that a database consists of a single disk file. This simplifies the use of SQLite since moving or backing up a database is a simple as copying a single file. It also makes SQLite appropriate for use as an &lt;a href=&quot;whentouse#appfileformat&quot;&gt;application file format&lt;/a&gt;. But while a complete database is held in a single disk file, SQLite does make use of many temporary files during the course of processing a database.</source>
          <target state="translated">Одна из &lt;a href=&quot;different&quot;&gt;отличительных особенностей&lt;/a&gt; SQLite заключается в том, что база данных состоит из одного файла на диске. Это упрощает использование SQLite, поскольку перемещение или резервное копирование базы данных выполняется так же, как копирование одного файла. Это также делает SQLite подходящим для использования в качестве &lt;a href=&quot;whentouse#appfileformat&quot;&gt;формата файла приложения&lt;/a&gt; . Но хотя полная база данных хранится в одном файле на диске, SQLite действительно использует множество временных файлов в процессе обработки базы данных.</target>
        </trans-unit>
        <trans-unit id="e5c91de459561e96de8f3e9e77eaa61509cd18a7" translate="yes" xml:space="preserve">
          <source>One of the ALL or DISTINCT keywords may follow the SELECT keyword in a simple SELECT statement. If the simple SELECT is a SELECT ALL, then the entire set of result rows are returned by the SELECT. If neither ALL or DISTINCT are present, then the behavior is as if ALL were specified. If the simple SELECT is a SELECT DISTINCT, then duplicate rows are removed from the set of result rows before it is returned. For the purposes of detecting duplicate rows, two NULL values are considered to be equal. The &lt;a href=&quot;datatype3#colrules&quot;&gt;usual rules&lt;/a&gt; apply for selecting a collation sequence to compare text values.</source>
          <target state="translated">Одно из ключевых слов ALL или DISTINCT может следовать за ключевым словом SELECT в простой инструкции SELECT. Если простой SELECT - это SELECT ALL, тогда весь набор строк результатов возвращается SELECT. Если ни ALL, ни DISTINCT не присутствуют, поведение будет таким, как если бы было указано ALL. Если простой SELECT - это SELECT DISTINCT, то повторяющиеся строки удаляются из набора строк результата перед его возвратом. В целях обнаружения повторяющихся строк два значения NULL считаются равными. Для выбора последовательности сопоставления для сравнения текстовых значений применяются &lt;a href=&quot;datatype3#colrules&quot;&gt;обычные правила&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="148ba6e1c7e039de60e4599c768cf9921948e4c8" translate="yes" xml:space="preserve">
          <source>One of the advantages of hosting code generator tools as part of the project is that the tools can be optimized to serve specific needs of the overall project. Lemon has benefited from this effect. Over the years, the Lemon parser generator has been extended and enhanced to provide new capabilities and improved performance to SQLite. A few of the specific enhancements to Lemon that are specifically designed for use by SQLite include:</source>
          <target state="translated">Одним из преимуществ хостинга инструментов генератора кода как части проекта является то,что эти инструменты могут быть оптимизированы для удовлетворения специфических потребностей всего проекта в целом.Лемон извлекла выгоду из этого эффекта.С годами генератор парсера Lemon был расширен и усовершенствован для обеспечения новых возможностей и повышения производительности SQLite.Некоторые из специфических усовершенствований Lemon,которые специально разработаны для использования в SQLite,включают в себя:</target>
        </trans-unit>
        <trans-unit id="66a50c77336f3c9a6df53cb2e7363aee5a52fbbd" translate="yes" xml:space="preserve">
          <source>One of the interesting features of the VFS interface is that SQLite can support multiple VFSes at the same time. Each &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; has to choose a single VFS for its use when the connection is first opened using &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;. But if a process contains multiple &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt; each can choose a different VFS. VFSes can be added at run-time using the &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register()&lt;/a&gt; interface.</source>
          <target state="translated">Одна из интересных особенностей интерфейса VFS заключается в том, что SQLite может одновременно поддерживать несколько VFS. Каждое &lt;a href=&quot;c3ref/sqlite3&quot;&gt;соединение с базой данных&lt;/a&gt; должно выбрать одну VFS для использования при первом открытии соединения с помощью &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2 ()&lt;/a&gt; . Но если процесс содержит несколько &lt;a href=&quot;c3ref/sqlite3&quot;&gt;соединений с базой данных,&lt;/a&gt; каждый может выбрать другую VFS. VFS можно добавить во время выполнения с помощью интерфейса &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f1c2a440e7d12be65f7ff95454bfa77307c4b02e" translate="yes" xml:space="preserve">
          <source>One of the many reports that Fossil makes available is a timeline of changes to a single branch showing all merges in and out of that branch. See &lt;a href=&quot;http://www.sqlite.org/src/timeline?nd&amp;amp;n=200&amp;amp;r=trunk&quot;&gt;http://www.sqlite.org/src/timeline?nd&amp;amp;n=200&amp;amp;r=trunk&lt;/a&gt; for a typical example of such a report. Generating such a report normally takes just a few milliseconds. But after upgrading to the NGQP we noticed that this one report was taking closer to 10 seconds for the trunk of the repository.</source>
          <target state="translated">Один из многих отчетов, которые предоставляет Fossil, - это временная шкала изменений в одной ветке, показывающая все слияния внутри и вне этой ветви. См. &lt;a href=&quot;http://www.sqlite.org/src/timeline?nd&amp;amp;n=200&amp;amp;r=trunk&quot;&gt;Http://www.sqlite.org/src/timeline?nd&amp;amp;n=200&amp;amp;r=trunk&lt;/a&gt; для получения типичного примера такого отчета. Создание такого отчета обычно занимает всего несколько миллисекунд. Но после обновления до NGQP мы заметили, что этот отчет занимал около 10 секунд для магистрали репозитория.</target>
        </trans-unit>
        <trans-unit id="16f929fd09cef7d1acb11b165614f8e6f651a35f" translate="yes" xml:space="preserve">
          <source>One of the things that SQLite does to ensure that transactions are atomic across system crashes and power failures is to write all changes into the rollback journal file prior to changing the database. The TCL test harness contains an alternative &lt;a href=&quot;vfs&quot;&gt;OS backend&lt;/a&gt; implementation that helps to verify this is occurring correctly. The &quot;journal-test VFS&quot; monitors all disk I/O traffic between the database file and rollback journal, checking to make sure that nothing is written into the database file which has not first been written and synced to the rollback journal. If any discrepancies are found, an assertion fault is raised.</source>
          <target state="translated">Одна из вещей, которые SQLite делает для обеспечения атомарности транзакций при сбоях системы и сбоях питания, - это записывать все изменения в файл журнала отката до изменения базы данных. Пакет тестирования TCL содержит альтернативную &lt;a href=&quot;vfs&quot;&gt;внутреннюю&lt;/a&gt; реализацию ОС, которая помогает проверить, что это происходит правильно. VFS &quot;journal-test&quot; отслеживает весь дисковый трафик ввода-вывода между файлом базы данных и журналом отката, проверяя, что в файл базы данных не записано ничего, что не было предварительно записано и синхронизировано с журналом отката. Если обнаруживаются какие-либо несоответствия, возникает ошибка утверждения.</target>
        </trans-unit>
        <trans-unit id="8702bf42f5b52e2937e5261eb8fe5e53cb025817" translate="yes" xml:space="preserve">
          <source>One or more indexes of the table are currently unanalyzed &lt;em&gt;or&lt;/em&gt; the number of rows in the table has increased by 25 times or more since the last time ANALYZE was run.</source>
          <target state="translated">Один или несколько индексов таблицы в настоящее время не проанализированы, &lt;em&gt;или&lt;/em&gt; количество строк в таблице увеличилось в 25 или более раз с момента последнего запуска ANALYZE.</target>
        </trans-unit>
        <trans-unit id="c07477cd0e5dcf04189629377d839b6d5b58ba89" translate="yes" xml:space="preserve">
          <source>One or more transactions must have been written to the current wal file since it was created on disk (by any connection). This means that a snapshot cannot be taken on a wal mode database with no wal file immediately after it is first opened. At least one transaction must be written to it first.</source>
          <target state="translated">Одна или более транзакций должны были быть записаны в текущий wal-файл с момента его создания на диске (по любому соединению).Это означает,что снимки не могут быть сделаны в базе данных в режиме wal,где нет ни одного wal-файла сразу после его первого открытия.Сначала в нее должна быть записана хотя бы одна транзакция.</target>
        </trans-unit>
        <trans-unit id="b839504f0d97f30339eb42940d7178a50aed3e9b" translate="yes" xml:space="preserve">
          <source>One solution is to add an SQL foreign key constraint to the database schema to enforce the relationship between the</source>
          <target state="translated">Одним из решений является добавление ограничения по внешнему ключу SQL в схему базы данных,чтобы усилить связь между</target>
        </trans-unit>
        <trans-unit id="9e9e9e6d05419e1f1b802f612d5f17adfe32fb1a" translate="yes" xml:space="preserve">
          <source>One solution to this problem is to change SQLite to do an exhaustive search for the best path. But an exhaustive search requires time proportional to K! (where K is the number of tables in the join) and so when you get beyond a 10-way join, the time to run &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; becomes very large.</source>
          <target state="translated">Одним из решений этой проблемы является изменение SQLite для выполнения исчерпывающего поиска наилучшего пути. Но для полного перебора требуется время, пропорциональное K! (где K - количество таблиц в объединении), поэтому, когда вы выйдете за пределы 10-стороннего соединения, время выполнения &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare ()&lt;/a&gt; станет очень большим.</target>
        </trans-unit>
        <trans-unit id="3ea27e906845c470414940dc542a3a724c62dba9" translate="yes" xml:space="preserve">
          <source>One technique for avoiding a full table scan is to do lookups by rowid (or by the equivalent &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;). To lookup the price of peaches, one would query for the entry with a rowid of 4:</source>
          <target state="translated">Один из способов избежать полного сканирования таблицы - выполнить поиск по идентификатору строки (или эквивалентному &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; ). Чтобы узнать цену персиков, нужно запросить запись с идентификатором строки 4:</target>
        </trans-unit>
        <trans-unit id="9d59b48161b2263d40d4491d1bb939a7b7f92e6e" translate="yes" xml:space="preserve">
          <source>One user of both Git and Fossil &lt;a href=&quot;https://news.ycombinator.com/item?id=16806955&quot;&gt;writes in HN&lt;/a&gt;:</source>
          <target state="translated">Один пользователь как Git, так и Fossil &lt;a href=&quot;https://news.ycombinator.com/item?id=16806955&quot;&gt;пишет на HN&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="75f64ba853c8246c4f074dd74725d9448e0221f8" translate="yes" xml:space="preserve">
          <source>One verification technique used on SQLite is to run an entire test suite twice, once with optimizations left on and a second time with optimizations turned off, and verify that the same output is obtained both times. This shows that the optimizations do not introduce errors.</source>
          <target state="translated">Один метод верификации,используемый на SQLite,состоит в том,чтобы дважды запустить весь тестовый набор,один раз с включенными оптимизациями и второй раз с выключенными оптимизациями,и проверить,что один и тот же результат получен в оба раза.Это показывает,что оптимизации не вносят ошибок.</target>
        </trans-unit>
        <trans-unit id="1193850e31c2f1f6fdd8ba5f6d6a21ba1025f991" translate="yes" xml:space="preserve">
          <source>One very simple scheme might be to count the number of instances of the users search terms in each result document. Those documents that contain many instances of the terms are considered more relevant than those with a small number of instances of each term. In an FTS application, the number of term instances in each result could be determined by counting the number of integers in the return value of the &lt;a href=&quot;fts3#offsets&quot;&gt;offsets&lt;/a&gt; function. The following example shows a query that could be used to obtain the ten most relevant results for a query entered by the user:</source>
          <target state="translated">Одна очень простая схема может заключаться в подсчете количества экземпляров пользовательских условий поиска в каждом документе результатов. Те документы, которые содержат много экземпляров терминов, считаются более релевантными, чем документы с небольшим количеством экземпляров каждого термина. В приложении FTS количество экземпляров термина в каждом результате может быть определено путем подсчета количества целых чисел в возвращаемом значении функции &lt;a href=&quot;fts3#offsets&quot;&gt;смещения&lt;/a&gt; . В следующем примере показан запрос, который можно использовать для получения десяти наиболее релевантных результатов по запросу, введенному пользователем:</target>
        </trans-unit>
        <trans-unit id="ef8241368a545dcfd4804f314c3279bd316a6040" translate="yes" xml:space="preserve">
          <source>One way around this problem is to check the extended error code returned by an sqlite3_step() call. If there is a blocking connection, then the extended error code is set to SQLITE_LOCKED_SHAREDCACHE. Otherwise, in the special &quot;DROP TABLE/INDEX&quot; case, the extended error code is just SQLITE_LOCKED.</source>
          <target state="translated">Одним из способов решения этой проблемы является проверка расширенного кода ошибки,возвращаемого вызовом sqlite3_step().Если соединение блокируется,то расширенный код ошибки устанавливается в SQLITE_LOCKED_SHAREDCACHE.В противном случае,в специальном случае &quot;DROP TABLE/INDEX&quot;,расширенный код ошибки будет просто SQLITE_LOCKED.</target>
        </trans-unit>
        <trans-unit id="acee115381c0c09c4f7ee9640610c7e8117858b5" translate="yes" xml:space="preserve">
          <source>One way to compute FindFrame(P,M) would be to scan the aPgno array starting with the M-th entry and working backwards towards the beginning and return J where aPgno[J]==P. Such an algorithm would work, and it would be faster than searching the whole WAL file for the latest frame with page number P. But the search can be made much faster still by using the aHash structure.</source>
          <target state="translated">Одним из способов вычисления FindFrame(P,M)было бы сканирование массива aPgno,начинающегося с M-го элемента и работающего в обратном направлении к началу,и возврат J,где aPgno[J]==P.Такой алгоритм сработал бы,и это было бы быстрее,чем искать во всем файле WAL последний кадр с номером страницы P.Но поиск все равно можно сделать намного быстрее,используя структуру aHash.</target>
        </trans-unit>
        <trans-unit id="43ce70174605b98e2611ee3fa62c55d5c3b3d847" translate="yes" xml:space="preserve">
          <source>One way to create an imposter table is to directly edit the sqlite_master table to insert a new row that describes the table. For example, suppose the schema is like this:</source>
          <target state="translated">Один из способов создать таблицу imposter-напрямую отредактировать таблицу sqlite_master,чтобы вставить новую строку,описывающую таблицу.Например,предположим,что схема такая:</target>
        </trans-unit>
        <trans-unit id="84cd9c4bdeae83b60aa9ede1d4ab69d156255724" translate="yes" xml:space="preserve">
          <source>One way to create an imposter table is to directly edit the sqlite_schema table to insert a new row that describes the table. For example, suppose the schema is like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5371a62fb713016b88bf9cbe1ee3e53f088627a9" translate="yes" xml:space="preserve">
          <source>One way to use sqlite3 in a shell script is to use &quot;echo&quot; or &quot;cat&quot; to generate a sequence of commands in a file, then invoke sqlite3 while redirecting input from the generated command file. This works fine and is appropriate in many circumstances. But as an added convenience, sqlite3 allows a single SQL command to be entered on the command line as a second argument after the database name. When the sqlite3 program is launched with two arguments, the second argument is passed to the SQLite library for processing, the query results are printed on standard output in list mode, and the program exits. This mechanism is designed to make sqlite3 easy to use in conjunction with programs like &quot;awk&quot;. For example:</source>
          <target state="translated">Один из способов использования sqlite3 в скрипте оболочки-использовать &quot;echo&quot; или &quot;cat&quot; для генерации последовательности команд в файле,а затем вызывать sqlite3 при перенаправлении входных данных из сгенерированного командного файла.Это прекрасно работает и подходит во многих случаях.Но в качестве дополнительного удобства sqlite3 позволяет ввести в командную строку одну SQL-команду в качестве второго аргумента после имени БД.При запуске программы sqlite3 с двумя аргументами второй аргумент передается на обработку в библиотеку SQLite,результаты запроса выводятся на стандартный вывод в режиме списка,и программа завершает работу.Данный механизм предназначен для того,чтобы сделать sqlite3 простым в использовании совместно с программами типа &quot;awk&quot;.Например:</target>
        </trans-unit>
        <trans-unit id="c9f164cc934fc44dc3087a408a43d581d45a004f" translate="yes" xml:space="preserve">
          <source>One would get the same answer without the use of the R*Tree index using the following simpler query:</source>
          <target state="translated">Ответ можно было бы получить и без использования индекса R*Tree с помощью следующего более простого запроса:</target>
        </trans-unit>
        <trans-unit id="17f5a4fe2f5c62ecd81776d246b8c0c725190c25" translate="yes" xml:space="preserve">
          <source>One-Step Query Execution Interface</source>
          <target state="translated">Интерфейс выполнения одношаговых запросов</target>
        </trans-unit>
        <trans-unit id="aa3d3adac784c0d74a31276058a965e9e8ca9895" translate="yes" xml:space="preserve">
          <source>Online Backup API</source>
          <target state="translated">API онлайн-безопасность</target>
        </trans-unit>
        <trans-unit id="84ecd14ddbadabe468f63832d803f2392f405f33" translate="yes" xml:space="preserve">
          <source>Online Backup API.</source>
          <target state="translated">API Онлайн Резервного Копирования.</target>
        </trans-unit>
        <trans-unit id="df4435ab96f572a5ddc0d0575dab3a2326c426c1" translate="yes" xml:space="preserve">
          <source>Online Backup Object</source>
          <target state="translated">объект онлайн-безопасного копирования</target>
        </trans-unit>
        <trans-unit id="cf333df0d0137378797eeac3fd91be937936f09b" translate="yes" xml:space="preserve">
          <source>Only CPU cycle counts are being measured here. CPU cycle counts are a good proxy for energy consumption, but do not necessary correlate well with real-world timings. Time spent doing I/O is not reflected in the CPU cycle counts, and I/O time predominates in many SQLite usage scenarios.</source>
          <target state="translated">Здесь измеряется только количество циклов процессора.Подсчеты циклов ЦП являются хорошим показателем энергопотребления,но не обязательно хорошо коррелируют с реальными таймингами.Время,затрачиваемое на ввод/вывод,не отражается на счетах цикла ЦП,а время ввода/вывода превалирует во многих сценариях использования SQLite.</target>
        </trans-unit>
        <trans-unit id="d5604491374c9f17a80675ca75c6861a336b77e6" translate="yes" xml:space="preserve">
          <source>Only a single authorizer can be in place on a database connection at a time. Each call to sqlite3_set_authorizer overrides the previous call. Disable the authorizer by installing a NULL callback. The authorizer is disabled by default.</source>
          <target state="translated">Одновременно при подключении к базе данных может быть установлен только один авторизатор.Каждый вызов sqlite3_set_authorizer перекрывает предыдущий вызов.Отключите авторизатор,установив NULL обратный вызов.Авторизатор отключен по умолчанию.</target>
        </trans-unit>
        <trans-unit id="478d5d49691bd8c6240a1fe276d18045c9e67957" translate="yes" xml:space="preserve">
          <source>Only a single progress handler may be defined at one time per &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt;; setting a new progress handler cancels the old one. Setting parameter X to NULL disables the progress handler. The progress handler is also disabled by setting N to a value less than 1.</source>
          <target state="translated">Только один обработчик хода выполнения может быть определен одновременно для каждого &lt;a href=&quot;#sqlite3&quot;&gt;соединения с базой данных&lt;/a&gt; ; установка нового обработчика прогресса отменяет старый. Установка для параметра X значения NULL отключает обработчик хода выполнения. Обработчик хода выполнения также отключается путем установки для N значения меньше 1.</target>
        </trans-unit>
        <trans-unit id="94e56a9c57047e711c69e819b360a3dd7e101263" translate="yes" xml:space="preserve">
          <source>Only a single progress handler may be defined at one time per &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt;; setting a new progress handler cancels the old one. Setting parameter X to NULL disables the progress handler. The progress handler is also disabled by setting N to a value less than 1.</source>
          <target state="translated">Только один обработчик хода выполнения может быть определен одновременно для каждого &lt;a href=&quot;sqlite3&quot;&gt;соединения с базой данных&lt;/a&gt; ; установка нового обработчика прогресса отменяет старый. Установка для параметра X значения NULL отключает обработчик хода выполнения. Обработчик хода выполнения также отключается путем установки для N значения меньше 1.</target>
        </trans-unit>
        <trans-unit id="7036e4ebe3282d4cd750dee2b265f33019cf27cb" translate="yes" xml:space="preserve">
          <source>Only changes made directly by the INSERT, UPDATE or DELETE statement are considered - auxiliary changes caused by &lt;a href=&quot;../lang_createtrigger&quot;&gt;triggers&lt;/a&gt;, &lt;a href=&quot;../foreignkeys#fk_actions&quot;&gt;foreign key actions&lt;/a&gt; or &lt;a href=&quot;../lang_replace&quot;&gt;REPLACE&lt;/a&gt; constraint resolution are not counted.</source>
          <target state="translated">Учитываются только изменения, сделанные непосредственно оператором INSERT, UPDATE или DELETE - вспомогательные изменения, вызванные &lt;a href=&quot;../lang_createtrigger&quot;&gt;триггерами&lt;/a&gt; , &lt;a href=&quot;../foreignkeys#fk_actions&quot;&gt;действиями внешнего ключа&lt;/a&gt; или разрешением ограничения &lt;a href=&quot;../lang_replace&quot;&gt;REPLACE&lt;/a&gt; , не учитываются.</target>
        </trans-unit>
        <trans-unit id="c27ab9dbf00600e9d93b4dae249b72bd85740109" translate="yes" xml:space="preserve">
          <source>Only changes made directly by the INSERT, UPDATE or DELETE statement are considered - auxiliary changes caused by &lt;a href=&quot;lang_createtrigger&quot;&gt;triggers&lt;/a&gt;, &lt;a href=&quot;foreignkeys#fk_actions&quot;&gt;foreign key actions&lt;/a&gt; or &lt;a href=&quot;lang_replace&quot;&gt;REPLACE&lt;/a&gt; constraint resolution are not counted.</source>
          <target state="translated">Учитываются только изменения, сделанные непосредственно оператором INSERT, UPDATE или DELETE - вспомогательные изменения, вызванные &lt;a href=&quot;lang_createtrigger&quot;&gt;триггерами&lt;/a&gt; , &lt;a href=&quot;foreignkeys#fk_actions&quot;&gt;действиями внешнего ключа&lt;/a&gt; или разрешением ограничения &lt;a href=&quot;lang_replace&quot;&gt;REPLACE&lt;/a&gt; , не учитываются.</target>
        </trans-unit>
        <trans-unit id="9ca2d95ecc0496343a0233bd681510ca318c6946" translate="yes" xml:space="preserve">
          <source>Only columns a and b of the index would be usable. The d column would not be usable because column c is not constrained and there can be no gaps in the set of columns that usable by the index.</source>
          <target state="translated">Полезными будут только столбцы a и b индекса.Столбец d не будет использоваться,поскольку столбец c не ограничен,и в наборе столбцов,используемых индексом,не может быть пробелов.</target>
        </trans-unit>
        <trans-unit id="05736f4fee6c4c67dfd5428743f05e710b55053c" translate="yes" xml:space="preserve">
          <source>Only columns a, b, and c of the index would be usable. The d column would not be usable because it occurs to the right of c and c is constrained only by inequalities.</source>
          <target state="translated">Полезными будут только столбцы a,b и c индекса.Столбец d не может быть использован,поскольку он находится справа от столбцов c и c и ограничивается только неравенством.</target>
        </trans-unit>
        <trans-unit id="6822d83fba844c52182b6e2b1305124432ab29b8" translate="yes" xml:space="preserve">
          <source>Only create &lt;a href=&quot;tempfiles#masterjrnl&quot;&gt;master journal&lt;/a&gt; files if two or more attached databases are all modified, do not have &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous&lt;/a&gt; set to OFF, and do not have the &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;journal_mode&lt;/a&gt; set to OFF, MEMORY, or WAL.</source>
          <target state="translated">Только создать &lt;a href=&quot;tempfiles#masterjrnl&quot;&gt;мастер - журнальные&lt;/a&gt; файлы , если два или более подключенные баз данных все изменяется, не &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;Pragma синхронных&lt;/a&gt; отключаются, и не имеют &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;journal_mode&lt;/a&gt; отключаются, ПАМЯТЬ, или WAL.</target>
        </trans-unit>
        <trans-unit id="9d1635246b5aeaad6de58e92e5095276c845c10a" translate="yes" xml:space="preserve">
          <source>Only create &lt;a href=&quot;tempfiles#stmtjrnl&quot;&gt;statement journal&lt;/a&gt; files when their size exceeds a threshold. Otherwise the journal is held in memory and no I/O occurs. The threshold can be configured at compile-time using &lt;a href=&quot;compile#stmtjrnl_spill&quot;&gt;SQLITE_STMTJRNL_SPILL&lt;/a&gt; or at start-time using &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigstmtjrnlspill&quot;&gt;SQLITE_CONFIG_STMTJRNL_SPILL&lt;/a&gt;).</source>
          <target state="translated">&lt;a href=&quot;tempfiles#stmtjrnl&quot;&gt;Создавайте&lt;/a&gt; файлы журнала выписок только тогда, когда их размер превышает пороговое значение. В противном случае журнал сохраняется в памяти, и операций ввода-вывода не происходит. Порог можно настроить во время компиляции с помощью &lt;a href=&quot;compile#stmtjrnl_spill&quot;&gt;SQLITE_STMTJRNL_SPILL&lt;/a&gt; или во время запуска с помощью &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt; ( &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigstmtjrnlspill&quot;&gt;SQLITE_CONFIG_STMTJRNL_SPILL&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="04951ae9e91c50e633618b0424f4870112bf6e2c" translate="yes" xml:space="preserve">
          <source>Only create master journal files if two or more attached databases are all modified, do not have &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous&lt;/a&gt; set to OFF, and do not have the &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;journal_mode&lt;/a&gt; set to OFF, MEMORY, or WAL.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="610003d6616c61d3e569880b1cf6337a8bfaac43" translate="yes" xml:space="preserve">
          <source>Only rows of the table for which the WHERE clause evaluates to true are included in the index. If the WHERE clause expression evaluates to NULL or to false for some rows of the table, then those rows are omitted from the index.</source>
          <target state="translated">В индекс включаются только строки таблицы,для которой пункт WHERE оценивает как истинный.Если выражение из выражения WHERE для некоторых строк таблицы оценивается как NULL или false,то эти строки опускаются из индекса.</target>
        </trans-unit>
        <trans-unit id="255e530c466468dcdf3e2dbc7217cf60c632c517" translate="yes" xml:space="preserve">
          <source>Only terms of the vocabulary with a matching langid are searched. Hence, the same table can contain entries from multiple languages and only the requested language will be used. The default langid is 0.</source>
          <target state="translated">Поиск ведется только по словарю с совпадающим по значению словарным запасом.Таким образом,одна и та же таблица может содержать записи из нескольких языков,и будет использоваться только запрашиваемый язык.Лангид по умолчанию равен 0.</target>
        </trans-unit>
        <trans-unit id="2ece13f71abf0bca8da38ece8f95957b023f2f28" translate="yes" xml:space="preserve">
          <source>Only the &quot;ll&quot; length modifier ever makes a difference for SQLite. And it only makes a difference when using the C-language interfaces.</source>
          <target state="translated">Только модификатор длины &quot;ll&quot; когда-либо имеет значение для SQLite.И это имеет значение только при использовании интерфейсов на языке C.</target>
        </trans-unit>
        <trans-unit id="85148a6237828ed28c44695045ab73ff06e6fcad" translate="yes" xml:space="preserve">
          <source>Only the RENAME TABLE, ADD COLUMN, and RENAME COLUMN variants of the ALTER TABLE command are supported. Other kinds of ALTER TABLE operations such as DROP COLUMN, ALTER COLUMN, ADD CONSTRAINT, and so forth are omitted.</source>
          <target state="translated">Поддерживаются только варианты ALTER TABLE,ADD COLUMN и RENAME COLUMN.Другие виды операций ALTER TABLE,такие как DROP COLUMN,ALTER COLUMN,ADD CONSTRAINT и т.д.,опускаются.</target>
        </trans-unit>
        <trans-unit id="718ea1282b5847e8c3e9e8f8d5345c6ee50c38cc" translate="yes" xml:space="preserve">
          <source>Only the implicit version of the AND operator is supported. Specifying the string &quot;AND&quot; as part of a standard query syntax query is interpreted as a term query for the set of documents containing the term &quot;and&quot;.</source>
          <target state="translated">Поддерживается только неявная версия оператора AND.Указание строки &quot;AND&quot; как части стандартного синтаксического запроса интерпретируется как запрос на набор документов,содержащих термин &quot;и&quot;.</target>
        </trans-unit>
        <trans-unit id="1eda18e73564838ddd329dd3f15abb7d2f114fbe" translate="yes" xml:space="preserve">
          <source>Only the three core routines described in section 1.0 are required to use SQLite. But there are many other functions that provide useful interfaces. These extended routines are as follows:</source>
          <target state="translated">Для использования SQLite требуются только три основные подпрограммы,описанные в разделе 1.0.Однако существует множество других функций,которые предоставляют полезные интерфейсы.Эти расширенные процедуры следующие:</target>
        </trans-unit>
        <trans-unit id="97073c710caef6e8b97ed50f7242027a83850af5" translate="yes" xml:space="preserve">
          <source>Only unsigned integers are recognized. Plus and minus signs are ignored. Decimal points and exponential notation are ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ddd9d23f19b01af8d3915a7bfd11c89aef2d1d4" translate="yes" xml:space="preserve">
          <source>Only use indexes-on-expressions to optimize ORDER BY or GROUP BY if the COLLATE is correct. Ticket &lt;a href=&quot;https://sqlite.org/src/info/e20dd54ab0e4383&quot;&gt;e20dd54ab0e4383&lt;/a&gt;</source>
          <target state="translated">Используйте индексы-по-выражениям только для оптимизации ORDER BY или GROUP BY, если COLLATE правильный. Билет &lt;a href=&quot;https://sqlite.org/src/info/e20dd54ab0e4383&quot;&gt;e20dd54ab0e4383&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c74dd7ced7cd4ea8002b3c96a9b1ecdff66b1e59" translate="yes" xml:space="preserve">
          <source>Opcode Name</source>
          <target state="translated">Имя опкода</target>
        </trans-unit>
        <trans-unit id="1682c59856887894432baf4bb39e98c21d42d731" translate="yes" xml:space="preserve">
          <source>Opcode definitions</source>
          <target state="translated">Определения опкодов</target>
        </trans-unit>
        <trans-unit id="313411b9bd1b97b8fcd666d91d350cb8e6bed0d1" translate="yes" xml:space="preserve">
          <source>Open A BLOB For Incremental I/O</source>
          <target state="translated">Открыть BLOB для инкрементального ввода/вывода</target>
        </trans-unit>
        <trans-unit id="beb2e15e058a69d62502daa1bdfb1095abeb86de" translate="yes" xml:space="preserve">
          <source>Open a cursor into the table to be queried.</source>
          <target state="translated">Откройте курсор в таблицу,которую нужно опросить.</target>
        </trans-unit>
        <trans-unit id="7e8e851c144078264ee423ec854e116a3d7fdff4" translate="yes" xml:space="preserve">
          <source>Open a new cursor P1 that points to the same ephemeral table as cursor P2. The P2 cursor must have been opened by a prior &lt;a href=&quot;opcode#OpenEphemeral&quot;&gt;OpenEphemeral&lt;/a&gt; opcode. Only ephemeral cursors may be duplicated.</source>
          <target state="translated">Откройте новый курсор P1, который указывает на ту же временную таблицу, что и курсор P2. Курсор P2 должен быть открыт предыдущим &lt;a href=&quot;opcode#OpenEphemeral&quot;&gt;кодом&lt;/a&gt; операции OpenEphemeral . Можно дублировать только эфемерные курсоры.</target>
        </trans-unit>
        <trans-unit id="57454cf77dc40f8ad1e1086dd9c199e6c88ed771" translate="yes" xml:space="preserve">
          <source>Open a new cursor P1 to a transient table. The cursor is always opened read/write even if the main database is read-only. The ephemeral table is deleted automatically when the cursor is closed.</source>
          <target state="translated">Откройте новый курсор P1 на переходную таблицу.Курсор всегда открыт на чтение/запись,даже если основная БД доступна только для чтения.Эфемерная таблица удаляется автоматически при закрытии курсора.</target>
        </trans-unit>
        <trans-unit id="545bc19bf66be6511144aed187f1840c5a4278d1" translate="yes" xml:space="preserve">
          <source>Open a new cursor that points to a fake table that contains a single row of data. The content of that one row is the content of memory register P2. In other words, cursor P1 becomes an alias for the MEM_Blob content contained in register P2.</source>
          <target state="translated">Открыть новый курсор,указывающий на поддельную таблицу,содержащую одну строку данных.Содержимое этой строки-содержимое регистра памяти P2.Другими словами,курсор P1 становится псевдонимом для содержимого MEM_Blob,содержащегося в регистре P2.</target>
        </trans-unit>
        <trans-unit id="135ddb8c48350a0a78c4aa223b6b8ae16522c7fd" translate="yes" xml:space="preserve">
          <source>Open a read-only cursor for the database table whose root page is P2 in a database file. The database file is determined by P3. P3==0 means the main database, P3==1 means the database used for temporary tables, and P3&amp;gt;1 means used the corresponding attached database. Give the new cursor an identifier of P1. The P1 values need not be contiguous but all P1 values should be small integers. It is an error for P1 to be negative.</source>
          <target state="translated">Откройте доступный только для чтения курсор для таблицы базы данных, корневой страницей которой является P2 в файле базы данных. Файл базы данных определяется P3. P3 == 0 означает основную базу данных, P3 == 1 означает базу данных, используемую для временных таблиц, а P3&amp;gt; 1 означает, что использовалась соответствующая присоединенная база данных. Дайте новому курсору идентификатор P1. Значения P1 не обязательно должны быть смежными, но все значения P1 должны быть небольшими целыми числами. Отрицательное значение P1 является ошибкой.</target>
        </trans-unit>
        <trans-unit id="84089bd01646e44fd57253086466eec04ccae47a" translate="yes" xml:space="preserve">
          <source>Open a read/write cursor named P1 on the table or index whose root page is P2 (or whose root page is held in register P2 if the OPFLAG_P2ISREG bit is set in P5 - see below).</source>
          <target state="translated">Откройте курсор чтения/записи с именем P1 на таблице или индексе,корневая страница которого равна P2 (или корневая страница которого находится в регистре P2,если бит OPFLAG_P2ISREG установлен в P5-см.ниже).</target>
        </trans-unit>
        <trans-unit id="4063448157b3ab2686e1495793b9571ba748ea89" translate="yes" xml:space="preserve">
          <source>Open an RBU handle using the sqlite3rbu_open(T,A,S) function.</source>
          <target state="translated">Открыть хэндл RBU,используя функцию sqlite3rbu_open(T,A,S).</target>
        </trans-unit>
        <trans-unit id="596a83fa51ee88b7bacaba491d0bd9269153f384" translate="yes" xml:space="preserve">
          <source>Open database connections using the &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt; or &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; interfaces, as normal. Ordinary database files (without a checksum) will operate normally. Databases with checksums will return an SQLITE_IOERR_DATA error if a page is encountered that contains an invalid checksum.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6423cf77a906b294f7ccb82649c19b9b21d337a4" translate="yes" xml:space="preserve">
          <source>Open file &quot;/home/fred/data.db&quot;. Use the special VFS &quot;unix-dotfile&quot; that uses dot-files in place of posix advisory locking.</source>
          <target state="translated">Открыть файл &quot;/home/fred/data.db&quot;.Используйте специальный VFS &quot;unix-файл точки&quot;,который использует dot-файлы вместо блокировки posix-советов.</target>
        </trans-unit>
        <trans-unit id="d23dfc68fcbe2b64c96946a59f2391f88d879ada" translate="yes" xml:space="preserve">
          <source>Open file &quot;data.db&quot; in the current directory for read-only access. Regardless of whether or not shared-cache mode is enabled by default, use a private cache.</source>
          <target state="translated">Открыть файл &quot;data.db&quot; в текущем каталоге для доступа только на чтение.Независимо от того,включен ли режим общего кэша по умолчанию,используйте частный кэш.</target>
        </trans-unit>
        <trans-unit id="32023375b26a0776fe1660f78af585c47d78b01e" translate="yes" xml:space="preserve">
          <source>Open the database file &quot;/home/fred/data.db&quot;.</source>
          <target state="translated">Открыть файл базы данных &quot;/home/fred/data.db&quot;.</target>
        </trans-unit>
        <trans-unit id="b140126e4bb0c579baba79fa4b78910264cad628" translate="yes" xml:space="preserve">
          <source>Open the database file and obtain a SHARED lock. If the SHARED lock cannot be obtained, fail immediately and return SQLITE_BUSY.</source>
          <target state="translated">Откройте файл базы данных и получите блокировку SHARED.Если блокировка SHARED не может быть получена,немедленно выйдите из строя и верните SQLITE_BUSY.</target>
        </trans-unit>
        <trans-unit id="1fdbee3b0460b37f393d93c476774730b651cdaf" translate="yes" xml:space="preserve">
          <source>Open the file &quot;data.db&quot; in the current directory.</source>
          <target state="translated">Откройте файл &quot;data.db&quot; в текущем каталоге.</target>
        </trans-unit>
        <trans-unit id="e305cdc0a6e58d2992d00df36114935a966f06eb" translate="yes" xml:space="preserve">
          <source>Open two cursors, one to each of the two tables being queried.</source>
          <target state="translated">Откройте два курсора,по одному на каждый из двух опрашиваемых таблиц.</target>
        </trans-unit>
        <trans-unit id="db8828ea77768020acda7b34e1bdcfb01f4a650b" translate="yes" xml:space="preserve">
          <source>Open, release or rollback the savepoint named by parameter P4, depending on the value of P1. To open a new savepoint set P1==0 (SAVEPOINT_BEGIN). To release (commit) an existing savepoint set P1==1 (SAVEPOINT_RELEASE). To rollback an existing savepoint set P1==2 (SAVEPOINT_ROLLBACK).</source>
          <target state="translated">Откройте,отпустите или откатите точку сохранения,названную параметром P4,в зависимости от значения P1.Для открытия нового набора точек сохранения P1==0 (SAVEPOINT_BEGIN).Чтобы освободить (зафиксировать)существующую точку сохранения P1==1 (SAVEPOINT_RELEASE).Чтобы откатить существующую точку сохранения P1==2 (SAVEPOINT_ROLLBACK).</target>
        </trans-unit>
        <trans-unit id="e54c6e14fb4a075fa699ffdaaaf395ff313982e8" translate="yes" xml:space="preserve">
          <source>OpenAutoindex</source>
          <target state="translated">OpenAutoindex</target>
        </trans-unit>
        <trans-unit id="4102c59c0ab3f6e830e46718de359a59f628ee07" translate="yes" xml:space="preserve">
          <source>OpenDup</source>
          <target state="translated">OpenDup</target>
        </trans-unit>
        <trans-unit id="ad5bdfbe38582d74f4e2d987d0014c4a061fc0bc" translate="yes" xml:space="preserve">
          <source>OpenEphemeral</source>
          <target state="translated">OpenEphemeral</target>
        </trans-unit>
        <trans-unit id="4a5d4d0e6cf7c26b571b8ed8b7d9e91f5a55707c" translate="yes" xml:space="preserve">
          <source>OpenPseudo</source>
          <target state="translated">OpenPseudo</target>
        </trans-unit>
        <trans-unit id="321f145cb1e3470cc293ca452256220e4b476cbf" translate="yes" xml:space="preserve">
          <source>OpenRead</source>
          <target state="translated">OpenRead</target>
        </trans-unit>
        <trans-unit id="3894e594709a936290c9439b10b580db3b56e3b5" translate="yes" xml:space="preserve">
          <source>OpenWrite</source>
          <target state="translated">OpenWrite</target>
        </trans-unit>
        <trans-unit id="10f17177db5db183ce11fbbf98483043f8f93d13" translate="yes" xml:space="preserve">
          <source>Openclose callback</source>
          <target state="translated">Обратный звонок в режиме &quot;открытость</target>
        </trans-unit>
        <trans-unit id="f1ba5b2c8dba45952ee1dd4e3e5587becf1e4832" translate="yes" xml:space="preserve">
          <source>Opening A New Database Connection</source>
          <target state="translated">Открытие нового соединения с базой данных</target>
        </trans-unit>
        <trans-unit id="8bea067fa84f98eb8cb08b76d377cd2759d84a48" translate="yes" xml:space="preserve">
          <source>Opening a New Connection</source>
          <target state="translated">Открытие нового соединения</target>
        </trans-unit>
        <trans-unit id="0fcdc2f790b5b05c0b11e1b00c614a1147af7a65" translate="yes" xml:space="preserve">
          <source>Opening a Read-Only Transaction</source>
          <target state="translated">Открытие сделки только для чтения</target>
        </trans-unit>
        <trans-unit id="8c328ea219e123938753dd011cc218695e36770e" translate="yes" xml:space="preserve">
          <source>Opening a connection.</source>
          <target state="translated">Открытие соединения.</target>
        </trans-unit>
        <trans-unit id="0a848c1fa6f5b691a8b43871dbf9920b32a63f8f" translate="yes" xml:space="preserve">
          <source>Opening a new database connection is a two-step process:</source>
          <target state="translated">Открытие нового соединения с БД-это двухступенчатый процесс:</target>
        </trans-unit>
        <trans-unit id="60a2e026abe5554a6164ccf369d3bdb712d462a6" translate="yes" xml:space="preserve">
          <source>Opening a read-only transaction.</source>
          <target state="translated">Открытие сделки только для чтения.</target>
        </trans-unit>
        <trans-unit id="d0a97ec8f1b3b761b48ba3f0b5793b7b063cf28e" translate="yes" xml:space="preserve">
          <source>Opening a read-write transaction.</source>
          <target state="translated">Открытие операции чтения и записи.</target>
        </trans-unit>
        <trans-unit id="5bef4a855a587c7ae88d0d6e7fbc4f0cf1d92d9c" translate="yes" xml:space="preserve">
          <source>Opening a statement transaction.</source>
          <target state="translated">Открытие операции по выписке.</target>
        </trans-unit>
        <trans-unit id="5f6fc2590106eab5d853e4838b574315ff3651ac" translate="yes" xml:space="preserve">
          <source>Operand P1 must be 0x7fffffff and P2 must positive.</source>
          <target state="translated">Операнд P1 должен быть 0x7fffff и P2 должен быть положительным.</target>
        </trans-unit>
        <trans-unit id="d0e687b079fb70f2208d1f8d2c75d64d74925496" translate="yes" xml:space="preserve">
          <source>Operator</source>
          <target state="translated">Operator</target>
        </trans-unit>
        <trans-unit id="e90414358dbfff0a68e4eb5d68a16978cf197d5a" translate="yes" xml:space="preserve">
          <source>Operators</source>
          <target state="translated">Operators</target>
        </trans-unit>
        <trans-unit id="653e79b2411d60c991c837c40648dc99da326979" translate="yes" xml:space="preserve">
          <source>Optimization: When doing an &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; on a table with &lt;a href=&quot;expridx&quot;&gt;indexes on expressions&lt;/a&gt;, do not update the expression indexes if they do not refer to any of the columns of the table being updated.</source>
          <target state="translated">Оптимизация: при выполнении &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; в таблице с &lt;a href=&quot;expridx&quot;&gt;индексами в выражениях&lt;/a&gt; не обновляйте индексы выражений, если они не относятся ни к одному из столбцов обновляемой таблицы.</target>
        </trans-unit>
        <trans-unit id="a794f9704b3031ad0771d79793775c086e03f157" translate="yes" xml:space="preserve">
          <source>Optimizations to the sqlite_mprintf() routine.</source>
          <target state="translated">Оптимизация рутины sqlite_mprintf().</target>
        </trans-unit>
        <trans-unit id="088089a3961fc329e20285999528f0da0604b13a" translate="yes" xml:space="preserve">
          <source>Optimize the &lt;a href=&quot;lang_corefunc#typeof&quot;&gt;typeof()&lt;/a&gt; and &lt;a href=&quot;lang_corefunc#length&quot;&gt;length()&lt;/a&gt; SQL functions so that they avoid unnecessary reading of database content from disk.</source>
          <target state="translated">Оптимизируйте функции SQL &lt;a href=&quot;lang_corefunc#typeof&quot;&gt;typeof ()&lt;/a&gt; и &lt;a href=&quot;lang_corefunc#length&quot;&gt;length (),&lt;/a&gt; чтобы они избегали ненужного чтения содержимого базы данных с диска.</target>
        </trans-unit>
        <trans-unit id="89ea4f0e94546aba0e6576de32f5af050f08375b" translate="yes" xml:space="preserve">
          <source>Optimizer does a better job of using indices to satisfy ORDER BY clauses that sort on the integer primary key</source>
          <target state="translated">Оптимизатор лучше использует индексы для удовлетворения пунктов ORDER BY,которые сортируют по целочисленному первичному ключу</target>
        </trans-unit>
        <trans-unit id="d859dd72c637fafc6319ca0f4f6cb8c1fd01736f" translate="yes" xml:space="preserve">
          <source>Optimizer enhancement: &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statements&lt;/a&gt; are automatically re-compiled when a binding on the RHS of a LIKE operator changes or when any range constraint changes under &lt;a href=&quot;compile#enable_stat2&quot;&gt;SQLITE_ENABLE_STAT2&lt;/a&gt;.</source>
          <target state="translated">Улучшение оптимизатора: &lt;a href=&quot;c3ref/stmt&quot;&gt;подготовленные операторы&lt;/a&gt; автоматически перекомпилируются при изменении привязки RHS оператора LIKE или при изменении любого ограничения диапазона в &lt;a href=&quot;compile#enable_stat2&quot;&gt;SQLITE_ENABLE_STAT2&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e31d972229de381b461860014dd710856361917a" translate="yes" xml:space="preserve">
          <source>Option</source>
          <target state="translated">Option</target>
        </trans-unit>
        <trans-unit id="6120d3ea8f989e319fa4157b88a6894abd99ea8b" translate="yes" xml:space="preserve">
          <source>Option 1:</source>
          <target state="translated">Вариант 1:</target>
        </trans-unit>
        <trans-unit id="787636b9cef675727f97423a49f2d6e8aeb5b354" translate="yes" xml:space="preserve">
          <source>Option 2:</source>
          <target state="translated">Вариант 2:</target>
        </trans-unit>
        <trans-unit id="620a38bc45cce1e89bad8abed95cee233ec74ca8" translate="yes" xml:space="preserve">
          <source>Optional LIMIT and ORDER BY Clauses</source>
          <target state="translated">Необязательно ОГРАНИЧИТЬ и ЗАКАЗАТЬ по пунктам</target>
        </trans-unit>
        <trans-unit id="4a8101f15dc88fa6899984a679049286645dada8" translate="yes" xml:space="preserve">
          <source>Optional LIMIT and ORDER BY clauses</source>
          <target state="translated">Необязательное ОГРАНИЧЕНИЕ и ЗАКАЗЫВАНИЕ ОРГАНИЗАЦИЕЙ</target>
        </trans-unit>
        <trans-unit id="147fccad2acf5d54cf4c9bd90959d2b685bb12a8" translate="yes" xml:space="preserve">
          <source>Optional READ UNCOMMITTED isolation (instead of the default isolation level of SERIALIZABLE) and table level locking when database connections share a common cache.</source>
          <target state="translated">Опционально READ UNCOMMITTED изоляция (вместо уровня изоляции по умолчанию SERIALIZABLE)и блокировка на уровне таблиц,когда соединения БД имеют общий кэш.</target>
        </trans-unit>
        <trans-unit id="99e39e3c25d749e303cfb0392ac6108be81a9ed0" translate="yes" xml:space="preserve">
          <source>Optionally, a &lt;a href=&quot;gencol&quot;&gt;generated column&lt;/a&gt; constraint.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3c4d258c19e0b0e32f1a0047f810a58bf67a8d7" translate="yes" xml:space="preserve">
          <source>Optionally, a PRIMARY KEY for the table. Both single column and composite (multiple column) primary keys are supported.</source>
          <target state="translated">Опционально,ПРАЙМАРИ КЕЙ для стола.Поддерживаются как одностолбцовые,так и составные (многостолбцовые)первичные ключи.</target>
        </trans-unit>
        <trans-unit id="afb65b09ecb1abf655b3870806d0d663e9055759" translate="yes" xml:space="preserve">
          <source>Options understood by the &lt;b&gt;sqlite3&lt;/b&gt; command include:</source>
          <target state="translated">Параметры, понимаемые командой &lt;b&gt;sqlite3,&lt;/b&gt; включают:</target>
        </trans-unit>
        <trans-unit id="e72184f55cc026514b7160d78c3c5aef63c2a050" translate="yes" xml:space="preserve">
          <source>Or</source>
          <target state="translated">Or</target>
        </trans-unit>
        <trans-unit id="1a5a89789f35d1adc160640f07b04eccb062e675" translate="yes" xml:space="preserve">
          <source>Or consider these identical queries:</source>
          <target state="translated">Или рассмотрим эти идентичные запросы:</target>
        </trans-unit>
        <trans-unit id="16127303ea06cc226e15f6d081becfc0853f54f2" translate="yes" xml:space="preserve">
          <source>Or go the other way:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa8e4bd6460fbb4edd20d4ab7cc84cb756c25fa7" translate="yes" xml:space="preserve">
          <source>Or on Windows with MSVC:</source>
          <target state="translated">Или на Windows с MSVC:</target>
        </trans-unit>
        <trans-unit id="65cc0e4d32009c846d3d67b851864fc0e2100eac" translate="yes" xml:space="preserve">
          <source>Or optimization</source>
          <target state="translated">Или оптимизация</target>
        </trans-unit>
        <trans-unit id="fbfd8b5435e1bb1225c27564f4e61467d6052b3a" translate="yes" xml:space="preserve">
          <source>Or perhaps the application would rather use the most recent checkinTime:</source>
          <target state="translated">Или,возможно,приложение предпочло бы использовать самую последнюю проверку CheckinTime:</target>
        </trans-unit>
        <trans-unit id="2a55f1def49ba2cf28edd04aebe0ae914d6adc01" translate="yes" xml:space="preserve">
          <source>Or this:</source>
          <target state="translated">Или это:</target>
        </trans-unit>
        <trans-unit id="4adffe1f4f67467b27dd86bae1fcc140644a1e80" translate="yes" xml:space="preserve">
          <source>Or to be extra safe with a database and to force SQLite to assume the database lacks powersafe overwrite, open it using</source>
          <target state="translated">Или,чтобы быть особо безопасным с базой данных и заставить SQLite предположить,что база данных не имеет powersafe перезаписи,откройте ее,используя</target>
        </trans-unit>
        <trans-unit id="cb4a4efee56406c1c1e484f479dafaa1ce0d3fdd" translate="yes" xml:space="preserve">
          <source>Or using &lt;a href=&quot;cli#fileio&quot;&gt;file I/O functions&lt;/a&gt;, you can extract elements of the ZIP archive:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="beb6e4abd1b3ea2eadafe45050288632422b5468" translate="yes" xml:space="preserve">
          <source>Or,</source>
          <target state="translated">Or,</target>
        </trans-unit>
        <trans-unit id="66d567cd524d8ab999d4e199670d77fab66ce1bc" translate="yes" xml:space="preserve">
          <source>Or, from the SQLite shell tool (the &lt;a href=&quot;cli#fileio&quot;&gt;readfile()&lt;/a&gt; function reads the contents of a file from the file-system and returns it as a blob):</source>
          <target state="translated">Или из инструмента оболочки SQLite ( &lt;a href=&quot;cli#fileio&quot;&gt;функция readfile ()&lt;/a&gt; считывает содержимое файла из файловой системы и возвращает его как большой двоичный объект):</target>
        </trans-unit>
        <trans-unit id="5555ca89e43c2c41b68ce29dd846f696f04f9021" translate="yes" xml:space="preserve">
          <source>Or, if argument zTab is NULL, then changes are recorded for all tables in the database. If additional tables are added to the database (by executing &quot;CREATE TABLE&quot; statements) after this call is made, changes for the new tables are also recorded.</source>
          <target state="translated">Или,если аргумент zTab равен NULL,то изменения записываются для всех таблиц в БД.Если после этого вызова в БД добавляются дополнительные таблицы (путем выполнения оператора &quot;CREATE TABLE&quot;),то изменения для новых таблиц также записываются.</target>
        </trans-unit>
        <trans-unit id="0aca97133f8a0b1812de40afe8dc2efdb01e49c8" translate="yes" xml:space="preserve">
          <source>Or, if double-quoted string literals are disabled by default, but need to be selectively enabled for some historical database connections, that can be done using the same C-code as shown above except with the third parameter changed from 0 to 1.</source>
          <target state="translated">Или,если по умолчанию отключены строковые литералы в двойных кавычках,но их необходимо выборочно включить для некоторых исторических подключений к БД,это можно сделать с помощью того же самого C-кода,как показано выше,за исключением того,что третий параметр изменен с 0 на 1.</target>
        </trans-unit>
        <trans-unit id="322edc10740abf86eb6c1728491b5451dec39f1d" translate="yes" xml:space="preserve">
          <source>Or, if sqlite3.c is compiled using some other build system, by arranging for the SQLITE_ENABLE_FTS5 pre-processor symbol to be defined.</source>
          <target state="translated">Или,если sqlite3.c скомпилирована с помощью другой системы сборки,организуя определение символа препроцессора SQLITE_ENABLE_FTS5.</target>
        </trans-unit>
        <trans-unit id="658f77f8eef94489e4209dc1e50f66504ceb72eb" translate="yes" xml:space="preserve">
          <source>Or, if the argument attached to the REINDEX identifies a specific database table, then all indices attached to the database table are rebuilt. If it identifies a specific database index, then just that index is recreated.</source>
          <target state="translated">Или,если аргумент,приложенный к REINDEX,идентифицирует конкретную таблицу БД,то все индексы,приложенные к таблице БД,перестраиваются.Если же он идентифицирует конкретный индекс БД,то воссоздается именно этот индекс.</target>
        </trans-unit>
        <trans-unit id="60a5aae7483ffe81235af01c0cffa5d4ff23cd22" translate="yes" xml:space="preserve">
          <source>Or, if the table is also a &lt;a href=&quot;fts5#contentless_tables&quot;&gt;contentless table&lt;/a&gt;, then the following apply:</source>
          <target state="translated">Или, если таблица также является &lt;a href=&quot;fts5#contentless_tables&quot;&gt;таблицей без содержимого&lt;/a&gt; , применяется следующее:</target>
        </trans-unit>
        <trans-unit id="aa1077574bb502a8689f667cb965b8e30b1c1e85" translate="yes" xml:space="preserve">
          <source>Or, if using the autoconf build system, pass the --enable-session option to the configure script.</source>
          <target state="translated">Или,если используется система сборки autoconf,передайте опцию --enable-session скрипту конфигурации.</target>
        </trans-unit>
        <trans-unit id="0ff802a22b003329b02ab696a2c315faad2a0e85" translate="yes" xml:space="preserve">
          <source>Or, multiple presentations could be stored within the same document.</source>
          <target state="translated">Или несколько презентаций могут храниться в одном документе.</target>
        </trans-unit>
        <trans-unit id="d354f2e196d0e9cdbbdd8e5133631fe7bd7c69f7" translate="yes" xml:space="preserve">
          <source>Or, the same content can be read using:</source>
          <target state="translated">Или то же самое содержимое можно прочитать,используя:</target>
        </trans-unit>
        <trans-unit id="e7aee41fb363d46e588ad49a1b5591b283e863a6" translate="yes" xml:space="preserve">
          <source>Or, to list all changes to one particular account ($xyz) in order of decreasing magnitude, one can write:</source>
          <target state="translated">Или,чтобы перечислить все изменения на одном конкретном счете ($xyz)в порядке убывания,можно написать:</target>
        </trans-unit>
        <trans-unit id="8a1681e612a2025087b703fdf1f8f617e506b053" translate="yes" xml:space="preserve">
          <source>Oracle</source>
          <target state="translated">Oracle</target>
        </trans-unit>
        <trans-unit id="6e8727d6e68eed5d20f3fa889a8e8b2bd24438db" translate="yes" xml:space="preserve">
          <source>Orders of magnitude performance improvement for &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt; on very large tables.</source>
          <target state="translated">Увеличение производительности &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt; на порядки на очень больших таблицах.</target>
        </trans-unit>
        <trans-unit id="6ce3fb54d989f83f97843b164388df9c55d52716" translate="yes" xml:space="preserve">
          <source>Ordinary Common Table Expressions</source>
          <target state="translated">Обычные общие табличные выражения</target>
        </trans-unit>
        <trans-unit id="628b6d597a836775d3c57cc85ac20362e62df83f" translate="yes" xml:space="preserve">
          <source>Ordinary SQL statements are free-form, and can be spread across multiple lines, and can have whitespace and comments anywhere. Dot-commands are more restrictive:</source>
          <target state="translated">Обычные SQL-операторы имеют свободную форму и могут быть распределены по нескольким строкам,а также могут иметь пробельные символы и комментарии в любом месте.Точка-команды более ограничены:</target>
        </trans-unit>
        <trans-unit id="410efca163172750b4e7d07d3df715195f75df04" translate="yes" xml:space="preserve">
          <source>Ordinary common table expressions</source>
          <target state="translated">Обычные общие табличные выражения</target>
        </trans-unit>
        <trans-unit id="d3bfeb484e7ad7fe55b8281bb0d45da13e3151eb" translate="yes" xml:space="preserve">
          <source>Original content of the page prior to the start of the transaction</source>
          <target state="translated">Оригинальное содержание страницы до начала транзакции</target>
        </trans-unit>
        <trans-unit id="53583b5aa5fa79b35a37fe615fa3d9b1eece6568" translate="yes" xml:space="preserve">
          <source>Other C-libraries that process complex structured inputs will routinely be asked to deal with unvetted inputs from untrusted sources. Libraries like libjpeg, or libzip, or OpenSSL are handed input streams that come directly from potentially hostile agents.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="220b92a9851d65e3f5763bc585c592d7a14215e7" translate="yes" xml:space="preserve">
          <source>Other Issues</source>
          <target state="translated">Другие вопросы</target>
        </trans-unit>
        <trans-unit id="286c105cf7e1fc8242c5f069e4037b0e5e35102f" translate="yes" xml:space="preserve">
          <source>Other SQL database engines tend to store data as a large collection of files. Often these files are in a standard location that only the database engine itself can access. This makes the data more secure, but also makes it harder to access. Some SQL database engines provide the option of writing directly to disk and bypassing the filesystem all together. This provides added performance, but at the cost of considerable setup and maintenance complexity.</source>
          <target state="translated">Другие движки баз данных SQL,как правило,хранят данные в виде большой коллекции файлов.Часто эти файлы находятся в стандартном месте,доступном только самому движку базы данных.Это делает данные более безопасными,но и затрудняет доступ к ним.Некоторые движки баз данных SQL предоставляют возможность записи непосредственно на диск и в обход файловой системы все вместе.Это обеспечивает дополнительную производительность,но за счет значительной сложности настройки и обслуживания.</target>
        </trans-unit>
        <trans-unit id="5210f14e159e526b00e7b67ae5e00a7489e472f8" translate="yes" xml:space="preserve">
          <source>Other and more complex extensions can be found in subfolders under &lt;a href=&quot;https://www.sqlite.org/src/file/ext&quot;&gt;ext/&lt;/a&gt; other than ext/misc/.</source>
          <target state="translated">Другие, более сложные расширения можно найти в подпапках &lt;a href=&quot;https://www.sqlite.org/src/file/ext&quot;&gt;ext /,&lt;/a&gt; отличных от ext / misc /.</target>
        </trans-unit>
        <trans-unit id="a5885d7d219a9dd314e80ea53c10a7870f48702f" translate="yes" xml:space="preserve">
          <source>Other compile-time options such as using -O3 instead of -Os or using &lt;a href=&quot;compile#threadsafe&quot;&gt;-DSQLITE_THREADSAFE=0&lt;/a&gt; and/or some of the other &lt;a href=&quot;compile#rcmd&quot;&gt;recommended compile-time options&lt;/a&gt; might help SQLite to run even faster relative to direct filesystem reads.</source>
          <target state="translated">Другие параметры времени компиляции, такие как использование -O3 вместо -Os или использование &lt;a href=&quot;compile#threadsafe&quot;&gt;-DSQLITE_THREADSAFE = 0&lt;/a&gt; и / или некоторые другие &lt;a href=&quot;compile#rcmd&quot;&gt;рекомендуемые параметры времени компиляции,&lt;/a&gt; могут помочь SQLite работать еще быстрее по сравнению с прямым чтением файловой системы.</target>
        </trans-unit>
        <trans-unit id="68a8c532629b4cb41be7b1e40786ac6ad241781e" translate="yes" xml:space="preserve">
          <source>Other database engines may run great once you get them going. But doing the initial installation and configuration can often be intimidating.</source>
          <target state="translated">Другие движки баз данных могут отлично работать,как только вы их запустите.Но начальная установка и настройка часто может быть пугающей.</target>
        </trans-unit>
        <trans-unit id="0d3a3415efe071d534d2ab15cd7fe976055daeb3" translate="yes" xml:space="preserve">
          <source>Other entries in the cost table specific transforms for particular characters. The cost of specific transforms should be less than the default costs, or else the default costs will take precedence and the specific transforms will never be used.</source>
          <target state="translated">Другие записи в таблице расходов специфические преобразования для конкретных символов.Затраты на конкретные трансформации должны быть меньше затрат по умолчанию,иначе затраты по умолчанию будут иметь приоритет и конкретные трансформации никогда не будут использоваться.</target>
        </trans-unit>
        <trans-unit id="0ac3c9882a4b70189ad1bfa57e91f5a096b4d423" translate="yes" xml:space="preserve">
          <source>Other examples:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cae24656c6711756dea7bb8cd35f3afb8c810eb8" translate="yes" xml:space="preserve">
          <source>Other experimental memory allocators might be added in future releases of SQLite. One may anticipate that these will be called memsys7, memsys8, and so forth.</source>
          <target state="translated">В будущих релизах SQLite могут быть добавлены другие экспериментальные аллокаторы памяти.Можно ожидать,что они будут называться memsys7,memsys8 и так далее.</target>
        </trans-unit>
        <trans-unit id="10c1a85e8f6e1ba9ad67291c0e509d27f0146a7c" translate="yes" xml:space="preserve">
          <source>Other important bug fixes</source>
          <target state="translated">Другие важные исправления ошибок</target>
        </trans-unit>
        <trans-unit id="eafff73d48037ade49167d838ce6e1b6a891fb16" translate="yes" xml:space="preserve">
          <source>Other information fields of the sqlite3_rtree_query_info structure are available for use by the xQueryFunc callback, if desired. The iRowid field is the rowid (the first of the 3 to 11 columns in the R*Tree) for the element being considered. iRowid is only valid for leaves. The eParentWithin and rParentScore values are copies of the eWithin and rScore values from the containing subtree of the current row. The anQueue field is an array of mxLevel+1 unsigned integers that tell the current number of elements in the priority queue at each level.</source>
          <target state="translated">Другие информационные поля структуры sqlite3_rtree_query_info доступны для использования обратным вызовом xQueryFunc,при желании.Поле iRowid-это rowid (первый из 3-11 столбцов в R*Tree)для рассматриваемого элемента.iRowid действителен только для листьев.Значения eParentWithin и rParentScore являются копиями значений eWithin и rScore из содержащего поддерева текущей строки.Поле anQueue представляет собой массив из mxLevel+1 неподписанных целых чисел,которые сообщают текущее количество элементов в очереди приоритетов на каждом уровне.</target>
        </trans-unit>
        <trans-unit id="ac116740090073aa7d395dd931c8587b7e5ed819" translate="yes" xml:space="preserve">
          <source>Other kinds of constraints may be used and will work, but other constraints will be checked individually for each row and will not be optimized (at least not initially). All constraint checking is completely automatic regardless of whether or not optimization occurs. The optimization referred to in this bullet point is a performance consideration only. The same result is obtained regardless of whether or not the query is optimized.</source>
          <target state="translated">Другие виды ограничений могут быть использованы и будут работать,но другие ограничения будут проверяться индивидуально для каждой строки и не будут оптимизированы (по крайней мере,не изначально).Вся проверка ограничений происходит полностью автоматически,независимо от того,происходит оптимизация или нет.Оптимизация,о которой идет речь в данном пункте,является рассмотрением только производительности.Один и тот же результат получается независимо от того,оптимизирован запрос или нет.</target>
        </trans-unit>
        <trans-unit id="aea1c45528f91c41cd64bff7bc4b9fe5c5d9e390" translate="yes" xml:space="preserve">
          <source>Other languages like Java, Perl, Python, and TCL typically translate the program source text into bytecode. This bytecode is then run through an interpreter that reads the bytecode and carries out the desired operations. SQLite uses this bytecode approach. If you preceed any SQL statement with the &quot;&lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt;&quot; keyword in SQLite, it will show you the bytecode that is generated rather than run the bytecode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="808f70785d1ef92ea5c6148eaa9481e6d0e14aa1" translate="yes" xml:space="preserve">
          <source>Other lists: &lt;a href=&quot;constlist&quot;&gt;Constants&lt;/a&gt; and &lt;a href=&quot;funclist&quot;&gt;Functions&lt;/a&gt; and &lt;a href=&quot;../rescode&quot;&gt;Result Codes&lt;/a&gt;.</source>
          <target state="translated">Другие списки: &lt;a href=&quot;constlist&quot;&gt;константы&lt;/a&gt; и &lt;a href=&quot;funclist&quot;&gt;функции&lt;/a&gt; и &lt;a href=&quot;../rescode&quot;&gt;коды результатов&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="254b17e4c2182837b7ef0fdd5b3824e226f2c5a8" translate="yes" xml:space="preserve">
          <source>Other lists: &lt;a href=&quot;constlist&quot;&gt;Constants&lt;/a&gt; and &lt;a href=&quot;funclist&quot;&gt;Functions&lt;/a&gt;.</source>
          <target state="translated">Другие списки: &lt;a href=&quot;constlist&quot;&gt;константы&lt;/a&gt; и &lt;a href=&quot;funclist&quot;&gt;функции&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4f2e591c11c09005f92f16a4e53401bee7662b02" translate="yes" xml:space="preserve">
          <source>Other lists: &lt;a href=&quot;constlist&quot;&gt;Constants&lt;/a&gt; and &lt;a href=&quot;objlist&quot;&gt;Objects&lt;/a&gt; and &lt;a href=&quot;../rescode&quot;&gt;Result Codes&lt;/a&gt;</source>
          <target state="translated">Другие списки: &lt;a href=&quot;constlist&quot;&gt;Константы&lt;/a&gt; и &lt;a href=&quot;objlist&quot;&gt;объекты&lt;/a&gt; и &lt;a href=&quot;../rescode&quot;&gt;Результирующие коды&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="710d410006003e6c96fa23b1a96739384d30f239" translate="yes" xml:space="preserve">
          <source>Other lists: &lt;a href=&quot;constlist&quot;&gt;Constants&lt;/a&gt; and &lt;a href=&quot;objlist&quot;&gt;Objects&lt;/a&gt;.</source>
          <target state="translated">Другие списки: &lt;a href=&quot;constlist&quot;&gt;константы&lt;/a&gt; и &lt;a href=&quot;objlist&quot;&gt;объекты&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="dc0c16f3fd55dac69e3748a6c043c6447d6ab575" translate="yes" xml:space="preserve">
          <source>Other lists: &lt;a href=&quot;objlist&quot;&gt;Objects&lt;/a&gt; and &lt;a href=&quot;funclist&quot;&gt;Functions&lt;/a&gt; and &lt;a href=&quot;../rescode&quot;&gt;Result Codes&lt;/a&gt;.</source>
          <target state="translated">Другие списки: &lt;a href=&quot;objlist&quot;&gt;объекты&lt;/a&gt; и &lt;a href=&quot;funclist&quot;&gt;функции&lt;/a&gt; и &lt;a href=&quot;../rescode&quot;&gt;коды результатов&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ce8676972cf44ad111328d5252187ad79820f8b7" translate="yes" xml:space="preserve">
          <source>Other lists: &lt;a href=&quot;objlist&quot;&gt;Objects&lt;/a&gt; and &lt;a href=&quot;funclist&quot;&gt;Functions&lt;/a&gt;.</source>
          <target state="translated">Другие списки: &lt;a href=&quot;objlist&quot;&gt;объекты&lt;/a&gt; и &lt;a href=&quot;funclist&quot;&gt;функции&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6e05129b6c75ff832aa70dbb2deb9f7c3bddb6dc" translate="yes" xml:space="preserve">
          <source>Other minor bug fixes</source>
          <target state="translated">Другие незначительные исправления</target>
        </trans-unit>
        <trans-unit id="d4fc03a4fb1eb22ede8954ef99eea86a034ae6d2" translate="yes" xml:space="preserve">
          <source>Other minor bug fixes and documentation enhancements</source>
          <target state="translated">Другие незначительные исправления ошибок и улучшения документации</target>
        </trans-unit>
        <trans-unit id="890b3d475caba8d5bd7557f9c475d8af3c752a15" translate="yes" xml:space="preserve">
          <source>Other minor bug fixes and documentation enhancements.</source>
          <target state="translated">Другие незначительные исправления ошибок и улучшения документации.</target>
        </trans-unit>
        <trans-unit id="aa1b8c87b3d167a75e9df291742b29d3051fb50c" translate="yes" xml:space="preserve">
          <source>Other minor bug fixes and performance enhancements.</source>
          <target state="translated">Другие незначительные исправления ошибок и улучшения производительности.</target>
        </trans-unit>
        <trans-unit id="0fa68e95547b847335553befa0f2cb7b67624587" translate="yes" xml:space="preserve">
          <source>Other minor bug fixes and performance optimizations.</source>
          <target state="translated">Другие незначительные исправления и оптимизация производительности.</target>
        </trans-unit>
        <trans-unit id="1057a4540e5ed3386909678e9ca548cf6300a507" translate="yes" xml:space="preserve">
          <source>Other minor bug fixes in preparation for the first stable release of version 3.3</source>
          <target state="translated">Другие незначительные исправления в подготовке первого стабильного релиза версии 3.3</target>
        </trans-unit>
        <trans-unit id="f58ff693cc659b1eb66fa3445ac112f3a975e0d7" translate="yes" xml:space="preserve">
          <source>Other minor bug fixes.</source>
          <target state="translated">Другие незначительные исправления.</target>
        </trans-unit>
        <trans-unit id="3d1e22329a4cb1219246e265a7a252a723c9d5fa" translate="yes" xml:space="preserve">
          <source>Other minor changes and enhancements.</source>
          <target state="translated">Другие незначительные изменения и улучшения.</target>
        </trans-unit>
        <trans-unit id="251ead6fb529a54fa107bbdc4f76c0af651e9179" translate="yes" xml:space="preserve">
          <source>Other minor compiler-warning fixes and whatnot.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="deee6da4efcaf54f2a7bee650d4c13bb508dfa45" translate="yes" xml:space="preserve">
          <source>Other minor documentation and makefile changes and bug fixes.</source>
          <target state="translated">Другие незначительные изменения в документации и makefile,а также исправления ошибок.</target>
        </trans-unit>
        <trans-unit id="031aa8e8c99846cb30787089a75b424566d207ca" translate="yes" xml:space="preserve">
          <source>Other minor tweaks to improve the quality of &lt;a href=&quot;opcode&quot;&gt;VDBE&lt;/a&gt; code.</source>
          <target state="translated">Другие незначительные изменения для улучшения качества кода &lt;a href=&quot;opcode&quot;&gt;VDBE&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8b05e7277715773ceabf87f5e50fad5de6b24dd9" translate="yes" xml:space="preserve">
          <source>Other miscellaneous bug fixes</source>
          <target state="translated">Другие различные исправления ошибок</target>
        </trans-unit>
        <trans-unit id="5d73e7d5d87f0b601b3cbf8f19cc97602a0f29c4" translate="yes" xml:space="preserve">
          <source>Other miscellaneous bug fixes.</source>
          <target state="translated">Другие различные исправления ошибок.</target>
        </trans-unit>
        <trans-unit id="4b8124041770cac5d89ae555b4ac03153c37ffc1" translate="yes" xml:space="preserve">
          <source>Other miscellaneous enhancements such as loop unrolling.</source>
          <target state="translated">Другие различные усовершенствования,такие как разворачивание петли.</target>
        </trans-unit>
        <trans-unit id="6f62eac50d6703d3917c9f2154f9f77dce98abcd" translate="yes" xml:space="preserve">
          <source>Other miscellaneous micro-optimizations for improved performance and reduced memory usage.</source>
          <target state="translated">Другие различные микро-оптимизации для повышения производительности и сокращения использования памяти.</target>
        </trans-unit>
        <trans-unit id="26485a453cc99f6d07c9ad5f2979b799b10596af" translate="yes" xml:space="preserve">
          <source>Other miscellaneous minor bug fixes.</source>
          <target state="translated">Другие мелкие ошибки.</target>
        </trans-unit>
        <trans-unit id="583fac43540a1c8647f7a52c63c6d87ee3c57112" translate="yes" xml:space="preserve">
          <source>Other miscellaneous performance enhancements.</source>
          <target state="translated">Другие различные улучшения производительности.</target>
        </trans-unit>
        <trans-unit id="d5335cc4f60749bd941dc9764ef3c6855a7a176b" translate="yes" xml:space="preserve">
          <source>Other more familiar database engines run great once you get them going. But doing the initial installation and configuration can be intimidatingly complex.</source>
          <target state="translated">Другие,более знакомые движки баз данных,работают отлично,как только вы их запускаете.Но первоначальная установка и настройка может быть пугающе сложной.</target>
        </trans-unit>
        <trans-unit id="d62a6e61f5dec5bfc458e9cb92c78c02e716a2af" translate="yes" xml:space="preserve">
          <source>Other output modes include &quot;html&quot;, &quot;json&quot;, and &quot;tcl&quot;. Try these yourself to see what they do.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="453575f6d5ccd906017a354a3747a73c275dcbf4" translate="yes" xml:space="preserve">
          <source>Other pages that talk about Fossil and Git include:</source>
          <target state="translated">Другие страницы,которые говорят об ископаемых и Git,включают в себя:</target>
        </trans-unit>
        <trans-unit id="1691c79ed589685ad615d8d10ce5d4a24f7887ad" translate="yes" xml:space="preserve">
          <source>Other performance improvements. Uses about &lt;a href=&quot;cpu&quot;&gt;6.5% fewer CPU cycles&lt;/a&gt;.</source>
          <target state="translated">Прочие улучшения производительности. Использует примерно на &lt;a href=&quot;cpu&quot;&gt;6,5% меньше циклов ЦП&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="53a9f15c17fc6f690db9ec48e6c595c7787f86a9" translate="yes" xml:space="preserve">
          <source>Other performance optimizations:</source>
          <target state="translated">Другие оптимизации производительности:</target>
        </trans-unit>
        <trans-unit id="a62bf7250068b9b0c4a25d2045a53dbb9795b912" translate="yes" xml:space="preserve">
          <source>Other programming languages sometimes claim to be &quot;as fast as C&quot;. But no other language claims to be faster than C for general-purpose programming, because none are.</source>
          <target state="translated">Другие языки программирования иногда утверждают,что они &quot;такие же быстрые,как C&quot;.Но ни один другой язык не претендует на то,что он быстрее С для программирования общего назначения,потому что ни один из них не быстрее С.</target>
        </trans-unit>
        <trans-unit id="400864fb9a5435081d0153c603d26034407232fd" translate="yes" xml:space="preserve">
          <source>Other relation database engines also implement UPDATE-FROM, but because the construct is not part of the SQL standards, each product implements UPDATE-FROM differently. The SQLite implementation strives to be compatible with PostgreSQL. The SQL Server and MySQL implementations of the same idea work a little differently.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b724fba24bcbd81609e47345dfce9dfa38bb53b6" translate="yes" xml:space="preserve">
          <source>Other similar tree-display routines include:</source>
          <target state="translated">Другие аналогичные процедуры отображения деревьев включают в себя:</target>
        </trans-unit>
        <trans-unit id="eb0b09bd0abc9cbcebf776931eb89745e9f2f6c6" translate="yes" xml:space="preserve">
          <source>Other small bug fixes and optimizations.</source>
          <target state="translated">Другие небольшие исправления и оптимизации.</target>
        </trans-unit>
        <trans-unit id="ce257a3574985ec3c0e88eff4d14f53603f86d62" translate="yes" xml:space="preserve">
          <source>Other systems sometimes use assert(X) in a way that is similar to the use of ALWAYS(X) or NEVER(X) in SQLite. Developers will add an assert(X) as a &lt;a href=&quot;https://blog.regehr.org/archives/1576&quot;&gt;tacit acknowledgement that they do not fully believe that X is always true&lt;/a&gt;. We believe that this use of assert(X) is wrong and violates the intent and purpose of having assert(X) available in C in the first place. An assert(X) should not be seen as a safety-net or top-rope used to guard against mistakes. Nor is assert(X) appropriate for defense-in-depth. An ALWAYS(X) or NEVER(X) macro, or something similar, should be used in those cases because ALWAYS(X) or NEVER(X) will be followed by code to actually deal with the problem when the programmers reasoning turns out to be wrong. Since the code that follows ALWAYS(X) or NEVER(X) is untested, it should be something very simple, like a &quot;return&quot; statement, that is easily verified by inspection.</source>
          <target state="translated">Другие системы иногда используют assert (X) способом, аналогичным использованию ALWAYS (X) или NEVER (X) в SQLite. Разработчики добавят assert (X) в качестве &lt;a href=&quot;https://blog.regehr.org/archives/1576&quot;&gt;молчаливого подтверждения того, что они не полностью верят, что X всегда истинно.&lt;/a&gt;. Мы считаем, что такое использование assert (X) является неправильным и нарушает намерение и цель наличия assert (X), доступного в C в первую очередь. Утверждение (X) не следует рассматривать как страховочную сетку или верёвку, используемую для защиты от ошибок. Также assert (X) не подходит для глубокой защиты. В этих случаях следует использовать макрос ВСЕГДА (X) или НИКОГДА (X) или что-то подобное, потому что ВСЕГДА (X) или НИКОГДА (X) будет следовать код для реального решения проблемы, когда рассуждения программистов оказываются неверными. быть неправым. Поскольку код, следующий за ВСЕГДА (X) или НИКОГДА (X), не протестирован, он должен быть чем-то очень простым, например, оператором возврата, который легко проверить путем проверки.</target>
        </trans-unit>
        <trans-unit id="34d2c9c7d77d063050411b9cf0d5ad05916eb325" translate="yes" xml:space="preserve">
          <source>Otherwise, an expression has no affinity.</source>
          <target state="translated">В противном случае,выражение не имеет никакого сходства.</target>
        </trans-unit>
        <trans-unit id="6917a7f5da3062b0cb87b819a1b98dde64d2060e" translate="yes" xml:space="preserve">
          <source>Otherwise, if no error occurs, &lt;a href=&quot;#sqlite3_db_cacheflush&quot;&gt;sqlite3_db_cacheflush()&lt;/a&gt; returns SQLITE_OK.</source>
          <target state="translated">В противном случае, если ошибки не возникает, &lt;a href=&quot;#sqlite3_db_cacheflush&quot;&gt;sqlite3_db_cacheflush ()&lt;/a&gt; возвращает SQLITE_OK.</target>
        </trans-unit>
        <trans-unit id="63ffff1a975b81be129a4faecffea464b53159fd" translate="yes" xml:space="preserve">
          <source>Otherwise, if no error occurs, &lt;a href=&quot;db_cacheflush&quot;&gt;sqlite3_db_cacheflush()&lt;/a&gt; returns SQLITE_OK.</source>
          <target state="translated">В противном случае, если ошибки не возникает, &lt;a href=&quot;db_cacheflush&quot;&gt;sqlite3_db_cacheflush ()&lt;/a&gt; возвращает SQLITE_OK.</target>
        </trans-unit>
        <trans-unit id="f4554128dd35917d0080717168dbd2c249f00b56" translate="yes" xml:space="preserve">
          <source>Otherwise, if the ORDER BY expression is a column or an alias of an expression that is a column, then the default collation sequence for the column is used.</source>
          <target state="translated">В противном случае,если выражение ORDER BY является столбцом или псевдонимом выражения,являющегося столбцом,то для столбца используется последовательность сверки по умолчанию.</target>
        </trans-unit>
        <trans-unit id="7e53078a08397e14f15e969e1f704be9f2cd8b70" translate="yes" xml:space="preserve">
          <source>Otherwise, if the ORDER BY expression is an alias to an expression that has been assigned a collation sequence using the postfix &lt;a href=&quot;lang_expr#collateop&quot;&gt;COLLATE operator&lt;/a&gt;, then the collation sequence assigned to the aliased expression is used.</source>
          <target state="translated">В противном случае, если выражение ORDER BY является псевдонимом выражения, которому была назначена последовательность сопоставления с помощью постфиксного &lt;a href=&quot;lang_expr#collateop&quot;&gt;оператора COLLATE&lt;/a&gt; , то используется последовательность сопоставления, назначенная выражению с псевдонимом.</target>
        </trans-unit>
        <trans-unit id="16e19790e123dd698bb68d8acfc3c250ddf0f26c" translate="yes" xml:space="preserve">
          <source>Otherwise, if the ORDER BY expression is any other expression, it is evaluated and the returned value used to order the output rows. If the SELECT statement is a simple SELECT, then an ORDER BY may contain any arbitrary expressions. However, if the SELECT is a compound SELECT, then ORDER BY expressions that are not aliases to output columns must be exactly the same as an expression used as an output column.</source>
          <target state="translated">В противном случае,если выражение ORDER BY является любым другим выражением,оно вычисляется и возвращаемое значение используется для упорядочивания выходных строк.Если оператор SELECT (ВЫБОР)является простым SELECT (ВЫБОР),то оператор ORDER BY может содержать любые произвольные выражения.Однако,если оператор SELECT является составным SELECT,то выражения ORDER BY,не являющиеся псевдонимами для выходных столбцов,должны быть точно такими же,как и выражение,используемое в качестве выходного столбца.</target>
        </trans-unit>
        <trans-unit id="74d7943e809a432b89e323d15537e7de75d402f8" translate="yes" xml:space="preserve">
          <source>Otherwise, no affinity is applied and both operands are compared as is.</source>
          <target state="translated">В противном случае сродство не применяется,и оба операнда сравниваются как есть.</target>
        </trans-unit>
        <trans-unit id="ace2ae60f4f3efb9070beb6a2fed407ad7cd8e65" translate="yes" xml:space="preserve">
          <source>Otherwise, r[P2] is set to the sum of r[P1] and r[P3].</source>
          <target state="translated">В противном случае r[P2]устанавливается равным сумме r[P1]и r[P3].</target>
        </trans-unit>
        <trans-unit id="c9d8794c47ac5fbe000cffe629c489a9791ed713" translate="yes" xml:space="preserve">
          <source>Otherwise, the &lt;a href=&quot;datatype3#collation&quot;&gt;BINARY&lt;/a&gt; collation sequence is used.</source>
          <target state="translated">В противном случае используется &lt;a href=&quot;datatype3#collation&quot;&gt;БИНАРНАЯ&lt;/a&gt; последовательность сортировки.</target>
        </trans-unit>
        <trans-unit id="35b896906bdef712969f9e7297c680f9a2e53cd3" translate="yes" xml:space="preserve">
          <source>Otherwise, the BINARY collating function is used for comparison.</source>
          <target state="translated">В противном случае для сравнения используется функция сопоставления BINARY.</target>
        </trans-unit>
        <trans-unit id="638ab872140702484af1c059aebc57de13dbd98b" translate="yes" xml:space="preserve">
          <source>Otherwise, the affinity is NUMERIC.</source>
          <target state="translated">В противном случае,сродство ЧИСЛОВОЕ.</target>
        </trans-unit>
        <trans-unit id="cfc6f8803bf4c712ac864728c4305aa6942d9a6a" translate="yes" xml:space="preserve">
          <source>Otherwise, the value inserted into this field is the file contents for a regular file, or the target of a symbolic link.</source>
          <target state="translated">В противном случае,значение,вставленное в это поле,является содержимым файла для обычного файла,или целью символической ссылки.</target>
        </trans-unit>
        <trans-unit id="cb91e52cc1b3ca8f3f684e2966f8d4c11f3cb0b5" translate="yes" xml:space="preserve">
          <source>Otherwise, this API returns a negative value if P1 refers to an older snapshot than P2, zero if the two handles refer to the same database snapshot, and a positive value if P1 is a newer snapshot than P2.</source>
          <target state="translated">В противном случае,этот API возвращает отрицательное значение,если P1 ссылается на более старый снимок,чем P2,ноль,если два дескриптора ссылаются на один и тот же снимок базы данных,и положительное значение,если P1 является более новым снимок,чем P2.</target>
        </trans-unit>
        <trans-unit id="afebc4d098577eaf408f5312d05f2e55f910ee39" translate="yes" xml:space="preserve">
          <source>Our goal is to make the content you store in SQLite today as easily accessible to your grandchildren as it is to you.</source>
          <target state="translated">Наша цель-сделать контент,который вы храните в SQLite сегодня,таким же легкодоступным для ваших внуков,как и для вас.</target>
        </trans-unit>
        <trans-unit id="3edd7f9a4b0d8d87dc9885a06cb59a66ad8766a5" translate="yes" xml:space="preserve">
          <source>Out of memory (OOM) error conditions generate error logging events with the SQLITE_NOMEM error code and a message that says how many bytes of memory were requested by the failed allocation.</source>
          <target state="translated">Ошибочные условия Out of memory (OOM)генерируют события регистрации ошибок с кодом ошибки SQLITE_NOMEM и сообщением о том,сколько байт памяти было запрошено при неудачном выделении.</target>
        </trans-unit>
        <trans-unit id="3eb43b3eb70e7d12a47e5820876f3c296dc05bc2" translate="yes" xml:space="preserve">
          <source>Out-of-memory tests</source>
          <target state="translated">тесты вне памяти</target>
        </trans-unit>
        <trans-unit id="c1bf191f6ccc359ad8a3c05c295f7fe8cef84ae3" translate="yes" xml:space="preserve">
          <source>Outlandish Recursive Query Examples</source>
          <target state="translated">Примеры рекурсивных запросов из других стран</target>
        </trans-unit>
        <trans-unit id="4bed336194a9a5c86b6a734f03b3570d2aae1a68" translate="yes" xml:space="preserve">
          <source>Output</source>
          <target state="translated">Output</target>
        </trans-unit>
        <trans-unit id="1bd1112bbbb687e4d808e79cb404cc3ec423a23a" translate="yes" xml:space="preserve">
          <source>Output Change</source>
          <target state="translated">Выход Изменение выхода</target>
        </trans-unit>
        <trans-unit id="0c51e370c031f37870509dc46422ce61ca6e1f16" translate="yes" xml:space="preserve">
          <source>Output columns from the index_info pragma are as follows:</source>
          <target state="translated">Выходные столбцы из прагмы index_info следующие:</target>
        </trans-unit>
        <trans-unit id="8383ea0f1fb51fe84444b17104e0dd18b8f3f3b4" translate="yes" xml:space="preserve">
          <source>Output columns from the index_list pragma are as follows:</source>
          <target state="translated">Выходные столбцы из прагмы index_list выглядят следующим образом:</target>
        </trans-unit>
        <trans-unit id="bc6e58f2bacd5891df7b631d05c18328e75e62f4" translate="yes" xml:space="preserve">
          <source>Output columns from the index_xinfo pragma are as follows:</source>
          <target state="translated">Выходные столбцы из прагмы index_xinfo следующие:</target>
        </trans-unit>
        <trans-unit id="d1088854d972e4ceb1796db8756ad3486790779d" translate="yes" xml:space="preserve">
          <source>Output infinity as 1e999 in the &quot;.dump&quot; command of the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt;.</source>
          <target state="translated">Выведите бесконечность как 1e999 в команде &quot;.dump&quot; &lt;a href=&quot;cli&quot;&gt;оболочки командной строки&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="17e008cf652984308f7573376fc6932528a013cf" translate="yes" xml:space="preserve">
          <source>Output rows can be returned to the application as each small sort completes, and well before the table scan is complete.</source>
          <target state="translated">Выходные строки могут быть возвращены в приложение по мере завершения каждой небольшой сортировки,а также задолго до завершения сканирования таблицы.</target>
        </trans-unit>
        <trans-unit id="b785807667b898e4c7f09b3ee44afccba51a9945" translate="yes" xml:space="preserve">
          <source>Outputs an SQL script to create an RBU database which, if used to update database t1.db, patches it so that its contents are identical to that of database t2.db.</source>
          <target state="translated">Выводит SQL-скрипт для создания базы данных RBU,которая,если используется для обновления базы данных t1.db,исправляет ее так,чтобы ее содержимое было идентично содержимому базы данных t2.db.</target>
        </trans-unit>
        <trans-unit id="25a352aa2e3e3671bf4d083fdd886df3d305e826" translate="yes" xml:space="preserve">
          <source>Over 100 separate source files are concatenated into a single large files of C-code named &quot;sqlite3.c&quot; and called &quot;the amalgamation&quot;. The amalgamation contains everything an application needs to embed SQLite. The amalgamation file is more than 220,000 lines long and over 7.5 megabytes in size (as of 2018-11-24).</source>
          <target state="translated">Более 100 отдельных исходных файлов объединены в один большой файл C-кода,названный &quot;sqlite3.c&quot; и названный &quot;слияние&quot;.Слияние содержит все,что необходимо приложению для встраивания SQLite.Файл слияния имеет длину более 220 000 строк и размер более 7,5 мегабайт (по состоянию на 2018-11-24 гг.).</target>
        </trans-unit>
        <trans-unit id="6f2a6be035cf5a02d68b5e9127156e17d6b333b6" translate="yes" xml:space="preserve">
          <source>Overflow page</source>
          <target state="translated">Страница переполнения</target>
        </trans-unit>
        <trans-unit id="26c78f2170e31758038f3bb0a52b3d4d222f938f" translate="yes" xml:space="preserve">
          <source>Overload A Function For A Virtual Table</source>
          <target state="translated">Перегрузка функции для виртуальной таблицы</target>
        </trans-unit>
        <trans-unit id="007c99e63ddccff493d60c3cf9732ab7365f22fb" translate="yes" xml:space="preserve">
          <source>Override other operating system interfaces such as calls to obtain Zulu or local time.</source>
          <target state="translated">Переопределить другие интерфейсы операционной системы,такие как звонки для получения Zulu или местного времени.</target>
        </trans-unit>
        <trans-unit id="0efc2e6be4c23b9a513d7ce0dcff8ed80e8912e7" translate="yes" xml:space="preserve">
          <source>Overview</source>
          <target state="translated">Overview</target>
        </trans-unit>
        <trans-unit id="46880b89366d47b3659d0ee6bf4c167da19b6968" translate="yes" xml:space="preserve">
          <source>Overview Documents</source>
          <target state="translated">Обзор документов</target>
        </trans-unit>
        <trans-unit id="04e78b5fd19361d42f0880283437d8302448583e" translate="yes" xml:space="preserve">
          <source>Overwrite if already exists?</source>
          <target state="translated">Перезапись,если она уже существует?</target>
        </trans-unit>
        <trans-unit id="9ada09a735411e9de190da46810d6bab2f578abd" translate="yes" xml:space="preserve">
          <source>Overwriting a database file with another without also deleting any hot journal associated with the original database.</source>
          <target state="translated">Перезапись файла базы данных другим файлом без удаления горячего журнала,связанного с исходной базой данных.</target>
        </trans-unit>
        <trans-unit id="bcfd518ec9aac14be70cb40d43cadb15da01978e" translate="yes" xml:space="preserve">
          <source>Overwritting a journal file with a different journal file.</source>
          <target state="translated">Перезапись файла журнала другим файлом.</target>
        </trans-unit>
        <trans-unit id="f6202fa6f9727ecd28cda41b586c4f17db3f9662" translate="yes" xml:space="preserve">
          <source>P (cost: 7.71)</source>
          <target state="translated">P (стоимость:7,71)</target>
        </trans-unit>
        <trans-unit id="80d8eec7d81f7a0324484c1ac454ead7da895c4f" translate="yes" xml:space="preserve">
          <source>P1 can be either an ordinary table or a virtual table. There used to be a separate OP_VRowid opcode for use with virtual tables, but this one opcode now works for both table types.</source>
          <target state="translated">P1 может быть как обычным столом,так и виртуальным.Раньше был отдельный опкод OP_VRowid для использования с виртуальными таблицами,но теперь этот опкод работает для обоих типов таблиц.</target>
        </trans-unit>
        <trans-unit id="84bf22352f6da5dd236d64694b38dd6696254f42" translate="yes" xml:space="preserve">
          <source>P1 contains the address of the memory cell that contains the first memory cell in an array of values used as arguments to the sub-program. P2 contains the address to jump to if the sub-program throws an IGNORE exception using the RAISE() function. Register P3 contains the address of a memory cell in this (the parent) VM that is used to allocate the memory required by the sub-vdbe at runtime.</source>
          <target state="translated">P1 содержит адрес ячейки памяти,которая содержит первую ячейку памяти в массиве значений,используемых в качестве аргументов для подпрограммы.P2 содержит адрес,на который нужно перейти,если подпрограмма выбрасывает исключение IGNORE с помощью функции RAISE().Регистр P3 содержит адрес ячейки памяти в этой (родительской)ВМ,которая используется для выделения памяти,требуемой подпрограмме во время выполнения.</target>
        </trans-unit>
        <trans-unit id="bbb7c16489d0b290a1227473f0d5f4da2b7691cc" translate="yes" xml:space="preserve">
          <source>P1 is a 32-bit bitmask indicating whether or not each argument to the function was determined to be constant at compile time. If the first argument was constant then bit 0 of P1 is set. This is used to determine whether meta data associated with a user function argument using the sqlite3_set_auxdata() API may be safely retained until the next invocation of this opcode.</source>
          <target state="translated">P1-это 32-битная битовая маска,указывающая,был ли каждый аргумент функции определен как постоянный во время компиляции.Если первый аргумент был константным,то устанавливается бит 0 из P1.Это используется для определения того,могут ли мета-данные,связанные с аргументом пользовательской функции с помощью API sqlite3_set_auxdata(),быть безопасно сохранены до следующего вызова этого опкода.</target>
        </trans-unit>
        <trans-unit id="ce2db3e033bf07aaa2aac0e6df082aac39175194" translate="yes" xml:space="preserve">
          <source>P1 is a boolean flag. If it is set to true and the xUpdate call is successful, then the value returned by sqlite3_last_insert_rowid() is set to the value of the rowid for the row just inserted.</source>
          <target state="translated">P1-это булевский флаг.Если он установлен в true и вызов xUpdate выполнен успешно,то значение,возвращаемое функцией sqlite3_last_insert_rowid(),устанавливается в значение rowid только что вставленного ряда.</target>
        </trans-unit>
        <trans-unit id="ab3846ffb469791c7c875a7d6e64699955c09eb4" translate="yes" xml:space="preserve">
          <source>P1 is a cursor opened using &lt;a href=&quot;opcode#VOpen&quot;&gt;VOpen&lt;/a&gt;. P2 is an address to jump to if the filtered result set is empty.</source>
          <target state="translated">P1 - это курсор, открытый с помощью &lt;a href=&quot;opcode#VOpen&quot;&gt;VOpen&lt;/a&gt; . P2 - это адрес для перехода, если отфильтрованный набор результатов пуст.</target>
        </trans-unit>
        <trans-unit id="99e16bb5285cdf74213efcd911112d0254cc888f" translate="yes" xml:space="preserve">
          <source>P1 is a register in the root frame of this VM (the root frame is different from the current frame if this instruction is being executed within a sub-program). Set the value of register P1 to the maximum of its current value and the value in register P2.</source>
          <target state="translated">P1-это регистр в корневом фрейме этой ВМ (корневой фрейм отличается от текущего фрейма,если эта инструкция выполняется в подпрограмме).Установите значение регистра P1 в максимальное из его текущего значения и значение в регистре P2.</target>
        </trans-unit>
        <trans-unit id="17a3ab4e084c4ae225f4e64b76426d06344fe074" translate="yes" xml:space="preserve">
          <source>P1 is a sorter cursor. If the sequence counter is currently zero, jump to P2. Regardless of whether or not the jump is taken, increment the the sequence value.</source>
          <target state="translated">P1-это курсор сортировки.Если счетчик последовательности на данный момент равен нулю,перейдите к P2.Независимо от того,выполнен скачок или нет,увеличивайте значение последовательности.</target>
        </trans-unit>
        <trans-unit id="f9ac2a8e79b4d0f70e9cfe08c3c644453f11b20b" translate="yes" xml:space="preserve">
          <source>P1 is a sorter cursor. This instruction compares a prefix of the record blob in register P3 against a prefix of the entry that the sorter cursor currently points to. Only the first P4 fields of r[P3] and the sorter record are compared.</source>
          <target state="translated">P1-это курсор сортировки.Эта инструкция сравнивает префикс блока записи в регистре P3 с префиксом записи,на которую в данный момент указывает курсор сортировщика.Сравниваются только первые поля P4 регистра r[P3]и запись сортировщика.</target>
        </trans-unit>
        <trans-unit id="d14bcdd4246c685563dd290988090774223c445f" translate="yes" xml:space="preserve">
          <source>P1 is an open index cursor and P3 is a cursor on the corresponding table. This opcode does a deferred seek of the P3 table cursor to the row that corresponds to the current row of P1.</source>
          <target state="translated">P1-открытый указательный курсор,а P3-курсор на соответствующую таблицу.Данный опкод выполняет отложенный поиск курсора P3 таблицы к строке,соответствующей текущей строке P1.</target>
        </trans-unit>
        <trans-unit id="86c484d0a40d444e4dc0b4d443a06296772d4391" translate="yes" xml:space="preserve">
          <source>P1 is the index of a cursor open on an SQL table btree (with integer keys). If register P3 does not contain an integer or if P1 does not contain a record with rowid P3 then jump immediately to P2. Or, if P2 is 0, raise an SQLITE_CORRUPT error. If P1 does contain a record with rowid P3 then leave the cursor pointing at that record and fall through to the next instruction.</source>
          <target state="translated">P1-это индекс курсора,открытого в дереве таблицы SQL (с целочисленными ключами).Если регистр P3 не содержит целого числа или если P1 не содержит записи с rowid P3,то сразу же переходите к P2.Или,если P2 равен 0,поднять ошибку SQLITE_CORRUPT.Если P1 содержит запись с rowid P3,то оставьте курсор,наведенный на эту запись,и перейдите к следующей команде.</target>
        </trans-unit>
        <trans-unit id="be17250db9325023bb6814cabfbf543abfa5ba67" translate="yes" xml:space="preserve">
          <source>P1 is the index of a cursor open on an SQL table btree (with integer keys). P3 is an integer rowid. If P1 does not contain a record with rowid P3 then jump immediately to P2. Or, if P2 is 0, raise an SQLITE_CORRUPT error. If P1 does contain a record with rowid P3 then leave the cursor pointing at that record and fall through to the next instruction.</source>
          <target state="translated">P1-это индекс курсора,открытого в дереве таблицы SQL (с целочисленными ключами).P3-это целочисленный ряд.Если P1 не содержит записи с rowid P3,то сразу переходите к P2.Или,если P2 равен 0,поднять ошибку SQLITE_CORRUPT.Если P1 содержит запись с rowid P3,то оставьте курсор,указывающий на эту запись,и перейдите к следующей инструкции.</target>
        </trans-unit>
        <trans-unit id="35a6c564ff4d581152e9a1f876d9eb72d2af48f4" translate="yes" xml:space="preserve">
          <source>P1 is the index of the database file on which the transaction is started. Index 0 is the main database file and index 1 is the file used for temporary tables. Indices of 2 or more are used for attached databases.</source>
          <target state="translated">P1-это индекс файла базы данных,по которому начинается транзакция.Индекс 0-основной файл БД,а индекс 1-файл,используемый для временных таблиц.Индексы 2 и более используются для прикрепленных баз данных.</target>
        </trans-unit>
        <trans-unit id="b9198f15e439eca54714083fc1fc6d108cc42915" translate="yes" xml:space="preserve">
          <source>P1 is the index of the database in sqlite3.aDb[] of the database on which the lock is acquired. A readlock is obtained if P3==0 or a write lock if P3==1.</source>
          <target state="translated">P1-это индекс БД в sqlite3.aDb[]БД,на которую получен замок.Блокировка чтения получается,если P3==0,или блокировка записи,если P3==1.</target>
        </trans-unit>
        <trans-unit id="1fcd6d3417638283143894ac28a56d5766856870" translate="yes" xml:space="preserve">
          <source>P1 is the memory location that is the accumulator for an aggregate or window function. Execute the finalizer function for an aggregate and store the result in P1.</source>
          <target state="translated">P1-это ячейка памяти,которая является аккумулятором для агрегатной или оконной функции.Выполните функцию финализатора для агрегата и сохраните результат в P1.</target>
        </trans-unit>
        <trans-unit id="9564a9171b616f080f45aeeeeb50a759cf2543a9" translate="yes" xml:space="preserve">
          <source>P1 is the result code returned by sqlite3_exec(), sqlite3_reset(), or sqlite3_finalize(). For a normal halt, this should be SQLITE_OK (0). For errors, it can be some other value. If P1!=0 then P2 will determine whether or not to rollback the current transaction. Do not rollback if P2==OE_Fail. Do the rollback if P2==OE_Rollback. If P2==OE_Abort, then back out all changes that have occurred during this execution of the VDBE, but do not rollback the transaction.</source>
          <target state="translated">P1-это код результата,возвращаемый функциями sqlite3_exec(),sqlite3_reset()или sqlite3_finalize().Для нормальной остановки это должен быть SQLITE_OK (0).Для ошибок это может быть какое-то другое значение.Если P1!=0,то P2 будет определять,откатывать ли текущую транзакцию.Не откатывать,если P2==OE_Fail.Делать откат,если P2==OE_Rollback.Если P2==OE_Abort,то откатываем все изменения,произошедшие во время выполнения VDBE,но не откатываем транзакцию.</target>
        </trans-unit>
        <trans-unit id="05f5c83f3b169019c8e82a0eaf11fb45a16518b4" translate="yes" xml:space="preserve">
          <source>P1 must be a valid b-tree cursor. P2 must be a boolean value, either 0 or 1.</source>
          <target state="translated">P1 должен быть действительным курсором b-дерева.P2 должен быть булевым значением,либо 0,либо 1.</target>
        </trans-unit>
        <trans-unit id="05f600aab9b18602c22139c66a31c7458bbfad3f" translate="yes" xml:space="preserve">
          <source>P1 must not be pseudo-table. It has to be a real table with multiple rows.</source>
          <target state="translated">P1 не должен быть псевдо-таблицей.Это должна быть настоящая таблица с несколькими строками.</target>
        </trans-unit>
        <trans-unit id="f93c0802a39924cff1b00e9015e9aa33f54938f7" translate="yes" xml:space="preserve">
          <source>P2 contains the root-page of the table to lock.</source>
          <target state="translated">P2 содержит корневую страницу таблицы для блокировки.</target>
        </trans-unit>
        <trans-unit id="9ce77455e05f3264d5bb123f4f714e82dd11c666" translate="yes" xml:space="preserve">
          <source>P2 is a register that holds the name of a virtual table in database P1. Call the xCreate method for that table.</source>
          <target state="translated">P2-это регистр,содержащий имя виртуальной таблицы в базе данных P1.Вызовите метод xCreate для этой таблицы.</target>
        </trans-unit>
        <trans-unit id="be0d49dbe18b5a0cf012a9f8a24be16667dd4219" translate="yes" xml:space="preserve">
          <source>P2 is the column number for the argument to the sqlite_offset() function. This opcode does not use P2 itself, but the P2 value is used by the code generator. The P1, P2, and P3 operands to this opcode are the same as for &lt;a href=&quot;opcode#Column&quot;&gt;Column&lt;/a&gt;.</source>
          <target state="translated">P2 - это номер столбца для аргумента функции sqlite_offset (). Этот код операции не использует сам P2, но значение P2 используется генератором кода. Операнды P1, P2 и P3 для этого кода операции такие же, как для &lt;a href=&quot;opcode#Column&quot;&gt;столбца&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b9b9294fefdd80f907d449f8b026a50941891877" translate="yes" xml:space="preserve">
          <source>P2 is the number of arguments that the step function takes and P4 is a pointer to the FuncDef for this function. The P2 argument is not used by this opcode. It is only there to disambiguate functions that can take varying numbers of arguments. The P4 argument is only needed for the case where the step function was not previously called.</source>
          <target state="translated">P2-это количество аргументов,которое принимает шаговая функция,а P4-указатель на FuncDef для этой функции.P2 аргумент не используется данным опкодом.Он используется только для разделения функций,которые могут принимать различное количество аргументов.Аргумент P4 нужен только в том случае,если функция шага ранее не вызывалась.</target>
        </trans-unit>
        <trans-unit id="3bd7cc65ffe04a6cbb96320f3dfb05bef13a6003" translate="yes" xml:space="preserve">
          <source>P2 is the number of columns in the ephemeral table. The cursor points to a BTree table if P4==0 and to a BTree index if P4 is not 0. If P4 is not NULL, it points to a KeyInfo structure that defines the format of keys in the index.</source>
          <target state="translated">P2-это количество колонок в эфемерной таблице.Курсор указывает на таблицу BTree,если P4==0,и на индекс BTree,если P4 не 0.Если P4 не NULL,он указывает на структуру KeyInfo,которая определяет формат ключей в индексе.</target>
        </trans-unit>
        <trans-unit id="d43bd5b8560de02b50e24570db7ff928128725ba" translate="yes" xml:space="preserve">
          <source>P2=='A' &amp;rarr; BLOB</source>
          <target state="translated">P2 == 'A' &amp;rarr; BLOB</target>
        </trans-unit>
        <trans-unit id="549df038ddec37fc17c85e7dccfd3d0f7eac490b" translate="yes" xml:space="preserve">
          <source>P2=='B' &amp;rarr; TEXT</source>
          <target state="translated">P2 == 'B' &amp;rarr; ТЕКСТ</target>
        </trans-unit>
        <trans-unit id="3eb880697f1f955293bf5968bad5752ba9e6c36d" translate="yes" xml:space="preserve">
          <source>P2=='C' &amp;rarr; NUMERIC</source>
          <target state="translated">P2 == 'C' &amp;rarr; ЧИСЛО</target>
        </trans-unit>
        <trans-unit id="11082965a2f3470ce5a9187e0cfe05f51096d4b9" translate="yes" xml:space="preserve">
          <source>P2=='D' &amp;rarr; INTEGER</source>
          <target state="translated">P2 == 'D' &amp;rarr; ЦЕЛОЕ</target>
        </trans-unit>
        <trans-unit id="8d3f310a6285b7cb02844a9cd70fd245db85edd2" translate="yes" xml:space="preserve">
          <source>P2=='E' &amp;rarr; REAL</source>
          <target state="translated">P2 == 'E' &amp;rarr; REAL</target>
        </trans-unit>
        <trans-unit id="12d088ae7e89df349fe37f3d37cf8b1ca4c09b3a" translate="yes" xml:space="preserve">
          <source>P3 = P2 || P1</source>
          <target state="translated">P3=P2 || P1</target>
        </trans-unit>
        <trans-unit id="3a22c873357ee7f56f10d2e038f148e48353f460" translate="yes" xml:space="preserve">
          <source>P3 is the number of fields in the records that will be stored by the pseudo-table.</source>
          <target state="translated">P3-это количество полей в записях,которые будут храниться в псевдотаблице.</target>
        </trans-unit>
        <trans-unit id="fa5df0db7433454e4380316b1e3b9bfe2adbea6f" translate="yes" xml:space="preserve">
          <source>P4 contains a pointer to the name of the table being locked. This is only used to generate an error message if the lock cannot be obtained.</source>
          <target state="translated">P4 содержит указатель на имя блокируемой таблицы.Он используется только для генерации сообщения об ошибке,если блокировка не может быть получена.</target>
        </trans-unit>
        <trans-unit id="3f5b2dbcd76db7494d70506eccc181bd880869ce" translate="yes" xml:space="preserve">
          <source>P4 is a KeyInfo structure that defines collating sequences and sort orders for the comparison. The permutation applies to registers only. The KeyInfo elements are used sequentially.</source>
          <target state="translated">P4-это структура KeyInfo,которая определяет коллекцию последовательностей и сортирует приказы для сравнения.Перестановка относится только к регистрам.Элементы KeyInfo используются последовательно.</target>
        </trans-unit>
        <trans-unit id="6e63a14f434c9d816b03aebb21b25ccfa99f1b42" translate="yes" xml:space="preserve">
          <source>P4 is a pointer to a 64-bit floating point value. Write that value into register P2.</source>
          <target state="translated">P4 является указателем на 64-битное значение с плавающей точкой.Запишите это значение в регистр P2.</target>
        </trans-unit>
        <trans-unit id="006b4d737b2fe81d322403675fc01054f9eaddfd" translate="yes" xml:space="preserve">
          <source>P4 is a pointer to a 64-bit integer value. Write that value into register P2.</source>
          <target state="translated">P4 является указателем на 64-битное целое значение.Запишите это значение в регистр P2.</target>
        </trans-unit>
        <trans-unit id="93432616419a7361a72b061b65e02339a1738910" translate="yes" xml:space="preserve">
          <source>P4 is a pointer to a CollSeq object. If the next call to a user function or aggregate calls sqlite3GetFuncCollSeq(), this collation sequence will be returned. This is used by the built-in min(), max() and nullif() functions.</source>
          <target state="translated">P4-это указатель на объект CollSeq.При следующем вызове пользовательской функции или совокупном вызове sqlite3GetFuncCollSeq()будет возвращена эта последовательность сверки.Это используется встроенными функциями min(),max()и nullif().</target>
        </trans-unit>
        <trans-unit id="d80240e61957d32e7437d69346afb9ca3c15eca9" translate="yes" xml:space="preserve">
          <source>P4 is a pointer to a virtual table object, an sqlite3_vtab structure. P1 is a cursor number. This opcode opens a cursor to the virtual table and stores that cursor in P1.</source>
          <target state="translated">P4-это указатель на объект виртуальной таблицы,структуру sqlite3_vtab.P1-номер курсора.Этот опкод открывает курсор к виртуальной таблице и сохраняет этот курсор в P1.</target>
        </trans-unit>
        <trans-unit id="0dbffabc54d98d6801900e6ab537de5e2bcdd805" translate="yes" xml:space="preserve">
          <source>P4 is a pointer to a virtual table object, an sqlite3_vtab structure. This opcode invokes the corresponding xRename method. The value in register P1 is passed as the zName argument to the xRename method.</source>
          <target state="translated">P4-это указатель на объект виртуальной таблицы,структуру sqlite3_vtab.Этот опкод вызывает соответствующий метод xRename.Значение в регистре P1 передаётся в качестве аргумента zName методу xRename.</target>
        </trans-unit>
        <trans-unit id="8c184e85a48a476ce012fdb53452bec6f0cb31bc" translate="yes" xml:space="preserve">
          <source>P4 is a pointer to a virtual table object, an sqlite3_vtab structure. This opcode invokes the corresponding xUpdate method. P2 values are contiguous memory cells starting at P3 to pass to the xUpdate invocation. The value in register (P3+P2-1) corresponds to the p2th element of the argv array passed to xUpdate.</source>
          <target state="translated">P4-это указатель на объект виртуальной таблицы,структуру sqlite3_vtab.Данный опкод вызывает соответствующий метод xUpdate.Значения P2 являются смежными ячейками памяти,начинающимися от P3 для перехода к вызову xUpdate.Значение в регистре (P3+P2-1)соответствует p2-му элементу массива argv,переданному в xUpdate.</target>
        </trans-unit>
        <trans-unit id="ad1bbf355e84d3c7a49f4b2d106cdd6317b07ee3" translate="yes" xml:space="preserve">
          <source>P4 is a pointer to the VM containing the trigger program.</source>
          <target state="translated">P4-это указатель на ВМ,содержащую триггерную программу.</target>
        </trans-unit>
        <trans-unit id="f47594ef27452803fbd06eb33f15569fa2ff24ae" translate="yes" xml:space="preserve">
          <source>P4 is a string that is P2 characters long. The N-th character of the string indicates the column affinity that should be used for the N-th memory cell in the range.</source>
          <target state="translated">P4-это строка длиной в 2 символа.N-ый символ строки указывает на сродство столбца,которое должно использоваться для N-ой ячейки памяти в диапазоне.</target>
        </trans-unit>
        <trans-unit id="990f075b203cf5ad046ffef4a8c3f52f5d8e8021" translate="yes" xml:space="preserve">
          <source>P4 is always of type P4_ADVANCE. The function pointer points to sqlite3BtreeNext().</source>
          <target state="translated">P4 всегда имеет тип P4_ADVANCE.Указатель функции указывает на sqlite3BtreeNext().</target>
        </trans-unit>
        <trans-unit id="33ef9db58085779c3fa7810a9ac7b841027b65e6" translate="yes" xml:space="preserve">
          <source>P4 is always of type P4_ADVANCE. The function pointer points to sqlite3BtreePrevious().</source>
          <target state="translated">P4 всегда имеет тип P4_ADVANCE.Указатель функции указывает на sqlite3BtreePrevious().</target>
        </trans-unit>
        <trans-unit id="d1b9c8ecf53ced9f246c4b6e555cd6111c1ca23e" translate="yes" xml:space="preserve">
          <source>P4 is either NULL or a string that was generated by the xBestIndex method of the module. The interpretation of the P4 string is left to the module implementation.</source>
          <target state="translated">P4-это либо NULL,либо строка,сгенерированная методом xBestIndex модуля.Интерпретация строки P4 остаётся в реализации модуля.</target>
        </trans-unit>
        <trans-unit id="c28c1dcafe0312975199fcb1fcfbb17e24dd7d0c" translate="yes" xml:space="preserve">
          <source>P4 is the name of a virtual table in database P1. Call the xDestroy method of that table.</source>
          <target state="translated">P4-это имя виртуальной таблицы в базе данных P1.Вызовите метод xDestroy этой таблицы.</target>
        </trans-unit>
        <trans-unit id="b1c200e3bc2517ade0a0775a576b9a6ce0d06b98" translate="yes" xml:space="preserve">
          <source>P4 may be a pointer to an sqlite3_vtab structure. If so, call the xBegin method for that table.</source>
          <target state="translated">P4 может быть указателем на структуру sqlite3_vtab.Если да,то вызовите метод xBegin для этой таблицы.</target>
        </trans-unit>
        <trans-unit id="946a7239230e3ec0a9c66885447aaf26ad8bc930" translate="yes" xml:space="preserve">
          <source>P4 may be a string that is P2 characters long. The N-th character of the string indicates the column affinity that should be used for the N-th field of the index key.</source>
          <target state="translated">P4 может быть строкой длиной в 2 символа.N-ый символ строки указывает на сродство столбца,которое должно быть использовано для N-ого поля индексного ключа.</target>
        </trans-unit>
        <trans-unit id="69adfac261137322671a1ca5cef4f8a650bcfbae" translate="yes" xml:space="preserve">
          <source>P4 may be an array of integers (type P4_INTARRAY) containing one entry for each column in the P3 table. If array entry a(i) is non-zero, then reading column a(i)-1 from cursor P3 is equivalent to performing the deferred seek and then reading column i from P1. This information is stored in P3 and used to redirect reads against P3 over to P1, thus possibly avoiding the need to seek and read cursor P3.</source>
          <target state="translated">P4 может быть массивом целых чисел (тип P4_INTARRAY),содержащим по одной записи для каждого столбца таблицы P3.Если запись в массиве a(i)ненулевая,то чтение столбца a(i)-1 из курсора P3 эквивалентно выполнению отложенного поиска,а затем чтению столбца i из P1.Эта информация хранится в P3 и используется для перенаправления чтения против P3 на P1,что,возможно,позволяет избежать необходимости искать и читать курсор P3.</target>
        </trans-unit>
        <trans-unit id="2b3aae431e84b9e296011557b13fc95c59d8a3fe" translate="yes" xml:space="preserve">
          <source>P4 points to a blob of data P1 bytes long. Store this blob in register P2.</source>
          <target state="translated">P4 указывает на блок данных P1 байт длиной.Хранить этот блок в регистре P2.</target>
        </trans-unit>
        <trans-unit id="5f1f77c01d77787acda0ee06f04f3dd3dab581c9" translate="yes" xml:space="preserve">
          <source>P4 points to a nul terminated UTF-8 string. This opcode is transformed into a &lt;a href=&quot;opcode#String&quot;&gt;String&lt;/a&gt; opcode before it is executed for the first time. During this transformation, the length of string P4 is computed and stored as the P1 parameter.</source>
          <target state="translated">P4 указывает на строку UTF-8 с нулевым завершением. Этот код операции преобразуется в код операции &lt;a href=&quot;opcode#String&quot;&gt;String&lt;/a&gt; перед первым выполнением. Во время этого преобразования длина строки P4 вычисляется и сохраняется как параметр P1.</target>
        </trans-unit>
        <trans-unit id="8c8ae2d7e0dfc4268ff56cfc9e2e47a67fc1ddaf" translate="yes" xml:space="preserve">
          <source>P5 is a value between 0 and 4, inclusive, that modifies the P4 string.</source>
          <target state="translated">P5-это значение между 0 и 4,включительно,которое изменяет строку P4.</target>
        </trans-unit>
        <trans-unit id="e03c8fcb835da321a7966f8a1cfc9fb80046f7b0" translate="yes" xml:space="preserve">
          <source>P5 is the error actions (OE_Replace, OE_Fail, OE_Ignore, etc) to apply in the case of a constraint failure on an insert or update.</source>
          <target state="translated">P5-это действия по ошибке (OE_Replace,OE_Fail,OE_Ignore и т.д.)для применения в случае отказа ограничения на вставку или обновление.</target>
        </trans-unit>
        <trans-unit id="b092db6b7249be33e50e9f2a75c65696bf56d25e" translate="yes" xml:space="preserve">
          <source>P5 ought to be set on every call to this opcode. However, there are places in the code generator will release registers before their are used, under the (valid) assumption that the registers will not be reallocated for some other purpose before they are used and hence are safe to release.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d23183b7ef6b3cfee6722e9cab664f9eba24c080" translate="yes" xml:space="preserve">
          <source>PARTITION</source>
          <target state="translated">PARTITION</target>
        </trans-unit>
        <trans-unit id="7c423f3264effc4f744de4e6255ff034137bcc1e" translate="yes" xml:space="preserve">
          <source>PASSIVE</source>
          <target state="translated">PASSIVE</target>
        </trans-unit>
        <trans-unit id="418f304013689ba52fc7c27eebb7dcb9d2ced563" translate="yes" xml:space="preserve">
          <source>PDF - Portable Document Format from Adobe</source>
          <target state="translated">PDF-Portable Document Format от Adobe</target>
        </trans-unit>
        <trans-unit id="0a7b38b716933a39c0bca66f229cd6d52f0c1271" translate="yes" xml:space="preserve">
          <source>PENDING</source>
          <target state="translated">PENDING</target>
        </trans-unit>
        <trans-unit id="5a61e634ec49d3919b83a13434809a009040ffa1" translate="yes" xml:space="preserve">
          <source>PLAN</source>
          <target state="translated">PLAN</target>
        </trans-unit>
        <trans-unit id="4b01f0d6c5bf45bcaa85e117787de16b76894b18" translate="yes" xml:space="preserve">
          <source>POSIX locking style. This is the default locking style and the style used by other (non Mac OS X) Unixes. Locks are obtained and released using the fcntl() system call.</source>
          <target state="translated">Стиль блокировки POSIX.Это стиль блокировки по умолчанию и стиль,используемый другими (не Mac OS X)Unixes.Блокировки получаются и освобождаются с помощью системного вызова fcntl().</target>
        </trans-unit>
        <trans-unit id="304e41f1b7440f605b6d901a3f56679fe5127675" translate="yes" xml:space="preserve">
          <source>PPT - Microsoft PowerPoint presentations</source>
          <target state="translated">PPT-презентации Microsoft PowerPoint</target>
        </trans-unit>
        <trans-unit id="eb3b3e1144fc0ba039acb3375dbf811550aeb6d8" translate="yes" xml:space="preserve">
          <source>PRAGMA</source>
          <target state="translated">PRAGMA</target>
        </trans-unit>
        <trans-unit id="2031386335ef51b174ad3b83ba1c813522943aeb" translate="yes" xml:space="preserve">
          <source>PRAGMA Statements</source>
          <target state="translated">заявления PRAGMA</target>
        </trans-unit>
        <trans-unit id="dd8e7015522cfd4dcf823317fdfa144e1ffa8793" translate="yes" xml:space="preserve">
          <source>PRAGMA application_id</source>
          <target state="translated">PRAGMA application_id</target>
        </trans-unit>
        <trans-unit id="4272fe5aa2578d44c85ef586cbdb481255d6ef40" translate="yes" xml:space="preserve">
          <source>PRAGMA auto_vacuum</source>
          <target state="translated">PRAGMA auto_vacuum</target>
        </trans-unit>
        <trans-unit id="ecdb75c7d78bb2d218243fd805db4a0952130227" translate="yes" xml:space="preserve">
          <source>PRAGMA automatic_index</source>
          <target state="translated">PRAGMA automatic_index</target>
        </trans-unit>
        <trans-unit id="06f21794e50e9014cbc68dddc08b0afe728a2339" translate="yes" xml:space="preserve">
          <source>PRAGMA busy_timeout</source>
          <target state="translated">PRAGMA busy_timeout</target>
        </trans-unit>
        <trans-unit id="0079a2a1c563d3a80935f663efd9c2f3f214bd31" translate="yes" xml:space="preserve">
          <source>PRAGMA cache_size</source>
          <target state="translated">размер кэша PRAGMA</target>
        </trans-unit>
        <trans-unit id="53830be86cc01d9861a99c96b4baf9389520d439" translate="yes" xml:space="preserve">
          <source>PRAGMA cache_spill</source>
          <target state="translated">PRAGMA cache_spill</target>
        </trans-unit>
        <trans-unit id="c62c55dc2230d9ef14955c77928155e6ec4c7ae3" translate="yes" xml:space="preserve">
          <source>PRAGMA case_sensitive_like</source>
          <target state="translated">PRAGMA case_sensitive_like</target>
        </trans-unit>
        <trans-unit id="629aac38c33c9e2128ff55cc2623e94247525dd5" translate="yes" xml:space="preserve">
          <source>PRAGMA cell_size_check</source>
          <target state="translated">PRAGMA cell_size_check</target>
        </trans-unit>
        <trans-unit id="f7a6fea31875d2709fc8636382fa71e3e405a8bd" translate="yes" xml:space="preserve">
          <source>PRAGMA checkpoint_fullfsync</source>
          <target state="translated">PRAGMA контрольно-пропускной пункт_fullfsync</target>
        </trans-unit>
        <trans-unit id="c3bb771e91f755dbbaf486313dfb86863abb68c6" translate="yes" xml:space="preserve">
          <source>PRAGMA collation_list</source>
          <target state="translated">PRAGMA collation_list</target>
        </trans-unit>
        <trans-unit id="03029df867e6189d3cb8be071de311b5adc094ca" translate="yes" xml:space="preserve">
          <source>PRAGMA command syntax</source>
          <target state="translated">синтаксис команд PRAGMA</target>
        </trans-unit>
        <trans-unit id="41b472d1fbef46bb9f050319914604b6fc2ba68d" translate="yes" xml:space="preserve">
          <source>PRAGMA compile_options</source>
          <target state="translated">параметры PRAGMA</target>
        </trans-unit>
        <trans-unit id="c654b246f7037e0f8929e3e045a813d87f20921d" translate="yes" xml:space="preserve">
          <source>PRAGMA count_changes</source>
          <target state="translated">PRAGMA count_changes</target>
        </trans-unit>
        <trans-unit id="e558ad585b01cc3a4aa52bb53490182d9eacc4e8" translate="yes" xml:space="preserve">
          <source>PRAGMA data_store_directory</source>
          <target state="translated">Каталог_магазина_данных PRAGMA</target>
        </trans-unit>
        <trans-unit id="9a7e5a694b84807a56ec0b72b64b9c9c84d92f92" translate="yes" xml:space="preserve">
          <source>PRAGMA data_version</source>
          <target state="translated">PRAGMA data_version</target>
        </trans-unit>
        <trans-unit id="71f193736d432d273c489df59218224a1bd26bb0" translate="yes" xml:space="preserve">
          <source>PRAGMA database_list</source>
          <target state="translated">список_базы данных PRAGMA</target>
        </trans-unit>
        <trans-unit id="d2b0abac3ff561286d0f244f1229dbe0d7c413ba" translate="yes" xml:space="preserve">
          <source>PRAGMA default_cache_size</source>
          <target state="translated">PRAGMA по умолчанию_cache_size</target>
        </trans-unit>
        <trans-unit id="baa9b0985d524aa3c28f49ac66dec16e57647a96" translate="yes" xml:space="preserve">
          <source>PRAGMA defer_foreign_keys</source>
          <target state="translated">PRAGMA ключи_отсрочки_foreign_keys</target>
        </trans-unit>
        <trans-unit id="5a13b54115c31e192bafba5863e3b69f614ae8e0" translate="yes" xml:space="preserve">
          <source>PRAGMA empty_result_callbacks</source>
          <target state="translated">PRAGMA empty_result_callbacks</target>
        </trans-unit>
        <trans-unit id="464f0c2fc86d3a8263fffd42239b50d53989d1da" translate="yes" xml:space="preserve">
          <source>PRAGMA encoding</source>
          <target state="translated">кодирование PRAGMA</target>
        </trans-unit>
        <trans-unit id="5a35e091ec7521a831d067bdc90ecb017a359b26" translate="yes" xml:space="preserve">
          <source>PRAGMA foreign_key_check</source>
          <target state="translated">PRAGMA foreign_key_check</target>
        </trans-unit>
        <trans-unit id="4f9cabaf50d87f897238e4cfca01cbf9a956476a" translate="yes" xml:space="preserve">
          <source>PRAGMA foreign_key_list</source>
          <target state="translated">PRAGMA зарубежный_ключевой_список</target>
        </trans-unit>
        <trans-unit id="c26430dedacc940c37179bc2ab043a40726e60aa" translate="yes" xml:space="preserve">
          <source>PRAGMA foreign_keys</source>
          <target state="translated">PRAGMA иностранные ключи</target>
        </trans-unit>
        <trans-unit id="f6f4d8a618687004328fc80c2fe129e8548fb446" translate="yes" xml:space="preserve">
          <source>PRAGMA freelist_count</source>
          <target state="translated">PRAGMA фрилист_счёт</target>
        </trans-unit>
        <trans-unit id="a1a0446b52b0c9481ab686d03b259ad5f54f8cce" translate="yes" xml:space="preserve">
          <source>PRAGMA full_column_names</source>
          <target state="translated">PRAGMA полные_колонки_имени</target>
        </trans-unit>
        <trans-unit id="19952a9490a74b7cefcba8ae3ffcd4c6cd36c908" translate="yes" xml:space="preserve">
          <source>PRAGMA fullfsync</source>
          <target state="translated">PRAGMA fullfsync</target>
        </trans-unit>
        <trans-unit id="9b4ca9a487733d7c417ae8784f57aa1ed11b34f0" translate="yes" xml:space="preserve">
          <source>PRAGMA fullfsync=ON;</source>
          <target state="translated">PRAGMA fullfsync=ON;</target>
        </trans-unit>
        <trans-unit id="327858b59b9cfef735d94d93f6b85bcef5690111" translate="yes" xml:space="preserve">
          <source>PRAGMA function</source>
          <target state="translated">функция PRAGMA</target>
        </trans-unit>
        <trans-unit id="2a0bacb7b9cc513abddcbbe743f428bab68dfa8c" translate="yes" xml:space="preserve">
          <source>PRAGMA function_list</source>
          <target state="translated">список функций PRAGMA</target>
        </trans-unit>
        <trans-unit id="e837cb07b592292e4ed84f750d66cb314f82a9c5" translate="yes" xml:space="preserve">
          <source>PRAGMA functions</source>
          <target state="translated">функции PRAGMA</target>
        </trans-unit>
        <trans-unit id="f7e42e33fd73efd0a92d36f4ff6b3819913f9bc4" translate="yes" xml:space="preserve">
          <source>PRAGMA ignore_check_constraints</source>
          <target state="translated">PRAGMA игнорировать_check_constraints</target>
        </trans-unit>
        <trans-unit id="cd58bb64e6b2a173c5b581b0cb503c85da1dbd24" translate="yes" xml:space="preserve">
          <source>PRAGMA incremental_vacuum</source>
          <target state="translated">PRAGMA инкрементальный_вакуум</target>
        </trans-unit>
        <trans-unit id="652aaaf1f9e0a84122b69d9954ec064ee9d02a48" translate="yes" xml:space="preserve">
          <source>PRAGMA index_info</source>
          <target state="translated">PRAGMA индекс_info</target>
        </trans-unit>
        <trans-unit id="125af8cf007c5ae9f4a12bfd4e392de5088aeebd" translate="yes" xml:space="preserve">
          <source>PRAGMA index_list</source>
          <target state="translated">индекс_список PRAGMA</target>
        </trans-unit>
        <trans-unit id="2da953925bb8a4bec48afa57978cfa755a68b864" translate="yes" xml:space="preserve">
          <source>PRAGMA index_xinfo</source>
          <target state="translated">PRAGMA index_xinfo</target>
        </trans-unit>
        <trans-unit id="a0a681b89ba9014d636bfe01c90f033d409952e9" translate="yes" xml:space="preserve">
          <source>PRAGMA integrity_check</source>
          <target state="translated">проверка целостности PRAGMA</target>
        </trans-unit>
        <trans-unit id="47cd2260e4aae51e91f7618b4491c7a57dbd31aa" translate="yes" xml:space="preserve">
          <source>PRAGMA integrity_check does not find &lt;a href=&quot;foreignkeys&quot;&gt;FOREIGN KEY&lt;/a&gt; errors. Use the &lt;a href=&quot;pragma#pragma_foreign_key_check&quot;&gt;PRAGMA foreign_key_check&lt;/a&gt; command for to find errors in FOREIGN KEY constraints.</source>
          <target state="translated">PRAGMA Integrity_check не находит ошибок &lt;a href=&quot;foreignkeys&quot;&gt;FOREIGN KEY&lt;/a&gt; . Используйте команду &lt;a href=&quot;pragma#pragma_foreign_key_check&quot;&gt;PRAGMA foreign_key_check,&lt;/a&gt; чтобы найти ошибки в ограничениях FOREIGN KEY.</target>
        </trans-unit>
        <trans-unit id="fed086b5dc8e5ae4d059caf4aa86921613ca6bce" translate="yes" xml:space="preserve">
          <source>PRAGMA integrity_check does not find &lt;a href=&quot;foreignkeys&quot;&gt;FOREIGN KEY&lt;/a&gt; errors. Use the &lt;a href=&quot;pragma#pragma_foreign_key_check&quot;&gt;PRAGMA foreign_key_check&lt;/a&gt; command to find errors in FOREIGN KEY constraints.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e40c9bb92f26ef5f07d9f3367463e8597505eee" translate="yes" xml:space="preserve">
          <source>PRAGMA journal_mode</source>
          <target state="translated">режим PRAGMA log_mode</target>
        </trans-unit>
        <trans-unit id="0dc7949f2c37427da3286461ab0d99c192b23454" translate="yes" xml:space="preserve">
          <source>PRAGMA journal_size_limit</source>
          <target state="translated">Журнал_размер_ограничения PRAGMA</target>
        </trans-unit>
        <trans-unit id="1d1d61ff55f21546bb199472fc5fb09c63e7801f" translate="yes" xml:space="preserve">
          <source>PRAGMA legacy_alter_table</source>
          <target state="translated">PRAGMA legacy_alter_table</target>
        </trans-unit>
        <trans-unit id="1d7e28dc08cc03a9bb08dd39291f00ea3a00d6ce" translate="yes" xml:space="preserve">
          <source>PRAGMA legacy_file_format</source>
          <target state="translated">Наследственный_файл_формат PRAGMA</target>
        </trans-unit>
        <trans-unit id="e05eb926ae67395e18a7ff48872e6bf6de93826e" translate="yes" xml:space="preserve">
          <source>PRAGMA locking_mode</source>
          <target state="translated">режим блокировки PRAGMA</target>
        </trans-unit>
        <trans-unit id="a71f8b9f21a1c76ece9dc64397bce57f203e4519" translate="yes" xml:space="preserve">
          <source>PRAGMA max_page_count</source>
          <target state="translated">PRAGMA max_page_count</target>
        </trans-unit>
        <trans-unit id="3aba9ed125640a69838f81731ba34ebdf094d76a" translate="yes" xml:space="preserve">
          <source>PRAGMA mmap_size</source>
          <target state="translated">PRAGMA mmap_size</target>
        </trans-unit>
        <trans-unit id="c29ccc2a4945dfe06f8af7b8b574f07e8a513dc7" translate="yes" xml:space="preserve">
          <source>PRAGMA module_list</source>
          <target state="translated">список модулей PRAGMA</target>
        </trans-unit>
        <trans-unit id="ed5cd9ca526909b51a8497a39931b7a730a4b534" translate="yes" xml:space="preserve">
          <source>PRAGMA optimize</source>
          <target state="translated">PRAGMA оптимизация</target>
        </trans-unit>
        <trans-unit id="9618d59586d55b1fe7cf6403a08d5878deeff0b2" translate="yes" xml:space="preserve">
          <source>PRAGMA page_count</source>
          <target state="translated">PRAGMA страница_счёт</target>
        </trans-unit>
        <trans-unit id="73b1778335144273f1b55bbda71292b3236c2f7c" translate="yes" xml:space="preserve">
          <source>PRAGMA page_size</source>
          <target state="translated">Размер страницы PRAGMA</target>
        </trans-unit>
        <trans-unit id="0c33d6f9f55335baef42453f3966f2ae2790fe21" translate="yes" xml:space="preserve">
          <source>PRAGMA parser_trace</source>
          <target state="translated">PRAGMA парсер_trace</target>
        </trans-unit>
        <trans-unit id="987c5140e9a3de6520e0e9a5de928a2bd5f2af7c" translate="yes" xml:space="preserve">
          <source>PRAGMA synchronous=FULL;</source>
          <target state="translated">PRAGMA synchronous=FULL;</target>
        </trans-unit>
        <trans-unit id="c40b0db1ea40d45cf9c01804a3ada577b8b752ae" translate="yes" xml:space="preserve">
          <source>PRAGMA temp_store_directory = ''</source>
          <target state="translated">Каталог_магазина_температуры PRAGMA=''.</target>
        </trans-unit>
        <trans-unit id="0662bf3087347b5b0ecf25fecad0c21f9bfb340d" translate="yes" xml:space="preserve">
          <source>PRAGMA vdbe_addoptrace</source>
          <target state="translated">PRAGMA vdbe_addoptrace</target>
        </trans-unit>
        <trans-unit id="ed607acfa6bacfc2bc133e1d2e829c3c31c8a51c" translate="yes" xml:space="preserve">
          <source>PRAGMA vdbe_debug</source>
          <target state="translated">PRAGMA vdbe_debug</target>
        </trans-unit>
        <trans-unit id="f5251eb4d3acd0707857877ee684d1bef0e741e2" translate="yes" xml:space="preserve">
          <source>PRAGMA vdbe_listing</source>
          <target state="translated">PRAGMA vdbe_listing</target>
        </trans-unit>
        <trans-unit id="319d369f27e5d322702e5eca965b605f26e48c8b" translate="yes" xml:space="preserve">
          <source>PRAGMA vdbe_trace</source>
          <target state="translated">PRAGMA vdbe_trace</target>
        </trans-unit>
        <trans-unit id="f0a71878598fa251896a1bb5f07402743f02c1c6" translate="yes" xml:space="preserve">
          <source>PRAGMAs that return results and that have no side-effects can be accessed from ordinary &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statements as &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued functions&lt;/a&gt;. For each participating PRAGMA, the corresponding table-valued function has the same name as the PRAGMA with a 7-character &quot;pragma_&quot; prefix. The PRAGMA argument and schema, if any, are passed as arguments to the table-valued function.</source>
          <target state="translated">К PRAGMA, возвращающим результаты и не имеющим побочных эффектов, можно получить доступ из обычных &lt;a href=&quot;lang_select&quot;&gt;операторов SELECT&lt;/a&gt; как &lt;a href=&quot;vtab#tabfunc2&quot;&gt;функций&lt;/a&gt; , возвращающих табличное значение . Для каждой участвующей PRAGMA соответствующая возвращающая табличное значение функция имеет то же имя, что и PRAGMA, с 7-символьным префиксом pragma_. Аргумент и схема PRAGMA, если таковые имеются, передаются в качестве аргументов функции, возвращающей табличное значение.</target>
        </trans-unit>
        <trans-unit id="f5e246fc197bcab96dcc71246fd51e046d154a6b" translate="yes" xml:space="preserve">
          <source>PRECEDING</source>
          <target state="translated">PRECEDING</target>
        </trans-unit>
        <trans-unit id="ed15de08f42371953d12d6c433f3d7a83e50d659" translate="yes" xml:space="preserve">
          <source>PRIMARY</source>
          <target state="translated">PRIMARY</target>
        </trans-unit>
        <trans-unit id="5d81ed20f739b911f425c9e71391691185dad6d3" translate="yes" xml:space="preserve">
          <source>PRIMARY KEY constraint</source>
          <target state="translated">Ограничение PRIMARY KEY</target>
        </trans-unit>
        <trans-unit id="fcdd367db6d48a1ca9ffb0132d54992dd930544d" translate="yes" xml:space="preserve">
          <source>Page 1 and the Expected Page Size</source>
          <target state="translated">Страница 1 и ожидаемый размер страницы</target>
        </trans-unit>
        <trans-unit id="626d2e810cbdab389ce5499e79846105d079da1c" translate="yes" xml:space="preserve">
          <source>Page 1 of a database file is the root page of a table b-tree that holds a special table named &quot;&lt;a href=&quot;schematab&quot;&gt;sqlite_schema&lt;/a&gt;&quot;. This b-tree is known as the &quot;schema table&quot; since it stores the complete database schema. The structure of the sqlite_schema table is as if it had been created using the following SQL:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0da1c304b873d5c4bfe7eb2116e8b2b93162178" translate="yes" xml:space="preserve">
          <source>Page 1 of a database file is the root page of a table b-tree that holds a special table named &quot;sqlite_master&quot; (or &quot;sqlite_temp_master&quot; in the case of a TEMP database) which stores the complete database schema. The structure of the sqlite_master table is as if it had been created using the following SQL:</source>
          <target state="translated">Страница 1 файла БД является корневой страницей таблицы b-дерева,содержащей специальную таблицу &quot;sqlite_master&quot; (или &quot;sqlite_temp_master&quot; в случае БД TEMP),в которой хранится полная схема БД.Структура таблицы sqlite_master выглядит так,как если бы она была создана с использованием следующего SQL:</target>
        </trans-unit>
        <trans-unit id="bb98169c72c2e0218852294c4088a714e55ae813" translate="yes" xml:space="preserve">
          <source>Page Cache</source>
          <target state="translated">Кэш страниц</target>
        </trans-unit>
        <trans-unit id="111e3d8b941451e6256ee0ce1fa5b2560f773697" translate="yes" xml:space="preserve">
          <source>Page Cache Algorithms</source>
          <target state="translated">Алгоритмы кэширования страниц</target>
        </trans-unit>
        <trans-unit id="51e73b0787f74035c32eccb9bca14aa82436008b" translate="yes" xml:space="preserve">
          <source>Page Cache Configuration</source>
          <target state="translated">Конфигурация кэша страниц</target>
        </trans-unit>
        <trans-unit id="91dcdd907d00efb6c274aa541e77d89ded5b848c" translate="yes" xml:space="preserve">
          <source>Page cache memory allocations that overflow into the general-purpose memory allocator.</source>
          <target state="translated">Распределение кэш-памяти страницы,которое переполняет универсальный аллокатор памяти.</target>
        </trans-unit>
        <trans-unit id="8b08ca42225d56c2d889ece253767100d76e7c2a" translate="yes" xml:space="preserve">
          <source>Page number</source>
          <target state="translated">Номер страницы</target>
        </trans-unit>
        <trans-unit id="ad392683af791420db4e7324c20464059ce3492a" translate="yes" xml:space="preserve">
          <source>Page number of first overflow page</source>
          <target state="translated">Номер страницы первого переполнения</target>
        </trans-unit>
        <trans-unit id="6e528c19af566e5c19716241accd44732b15c3f1" translate="yes" xml:space="preserve">
          <source>Page number of left child</source>
          <target state="translated">Номер левого ребенка на странице</target>
        </trans-unit>
        <trans-unit id="1d20e1ca269b0f7a9ac2bdd34ee817b875d0828b" translate="yes" xml:space="preserve">
          <source>Page number of the first freelist trunk page.</source>
          <target state="translated">Номер страницы первого багажника фрилиста.</target>
        </trans-unit>
        <trans-unit id="2f6078feea4fe70e006a40f0bbe8960bf8454aee" translate="yes" xml:space="preserve">
          <source>Pagecache memory allocator</source>
          <target state="translated">аллокатор памяти Pagecache</target>
        </trans-unit>
        <trans-unit id="7a89afd5ef39a4cff0b861ab314756ac6e516da0" translate="yes" xml:space="preserve">
          <source>Pagecount</source>
          <target state="translated">Pagecount</target>
        </trans-unit>
        <trans-unit id="2a084ba7d77808cea5a5f8f9c1ab34ab55b7585a" translate="yes" xml:space="preserve">
          <source>Pager and btree subsystems removed. These will be used in a follow-on SQL server library named &quot;SQLus&quot;.</source>
          <target state="translated">Удалены подсистемы пейджера и btree.Они будут использоваться в последующей SQL-серверной библиотеке под названием &quot;SQLus&quot;.</target>
        </trans-unit>
        <trans-unit id="d03660f900d198f933a03da740944dbf17018900" translate="yes" xml:space="preserve">
          <source>Pager subsystem added but not yet used.</source>
          <target state="translated">Подсистема пейджера добавлена,но еще не используется.</target>
        </trans-unit>
        <trans-unit id="70384aa891f4780133eb9e575d0bd72469e20f4e" translate="yes" xml:space="preserve">
          <source>Pages are numbered beginning with 1. The maximum page number is 2147483646 (2&lt;sup&gt;&lt;small&gt;31&lt;/small&gt;&lt;/sup&gt; - 2). The minimum size SQLite database is a single 512-byte page. The maximum size database would be 2147483646 pages at 65536 bytes per page or 140,737,488,224,256 bytes (about 140 terabytes). Usually SQLite will hit the maximum file size limit of the underlying filesystem or disk hardware long before it hits its own internal size limit.</source>
          <target state="translated">Страницы нумеруются, начиная с 1. Максимальный номер страницы - 2147483646 (2 &lt;sup&gt;&lt;small&gt;31&lt;/small&gt;&lt;/sup&gt; - 2). Минимальный размер базы данных SQLite - это одна страница размером 512 байт. Максимальный размер базы данных составляет 2147483646 страниц при 65536 байтах на страницу или 140 737 488 224 256 байтов (около 140 терабайт). Обычно SQLite достигает предела максимального размера файла базовой файловой системы или дискового оборудования задолго до того, как достигнет своего собственного внутреннего предела размера.</target>
        </trans-unit>
        <trans-unit id="a6bf70b89378b1b3ed63fb1aa677ec02aea17bdf" translate="yes" xml:space="preserve">
          <source>Pages are numbered beginning with 1. The maximum page number is 4294967294 (2&lt;sup&gt;&lt;small&gt;32&lt;/small&gt;&lt;/sup&gt; - 2). The minimum size SQLite database is a single 512-byte page. The maximum size database would be 2147483646 pages at 65536 bytes per page or 281,474,976,579,584 bytes (about 281 terabytes). Usually SQLite will hit the maximum file size limit of the underlying filesystem or disk hardware long before it hits its own internal size limit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f332eeefd007bb0043ccb46738196508c6a602b" translate="yes" xml:space="preserve">
          <source>Param</source>
          <target state="translated">Param</target>
        </trans-unit>
        <trans-unit id="f699f295e5ae4ac633cfa18437fed38d028b3fdb" translate="yes" xml:space="preserve">
          <source>Parameter</source>
          <target state="translated">Parameter</target>
        </trans-unit>
        <trans-unit id="8b81f4321a39e53a61cf8fbe1b4d654902c2cd89" translate="yes" xml:space="preserve">
          <source>Parameter P4 may point to a Table structure, or may be NULL. If it is not NULL, then the update-hook (sqlite3.xUpdateCallback) is invoked following a successful insert.</source>
          <target state="translated">Параметр P4 может указывать на структуру таблицы или может быть NULL.Если она не NULL,то после успешной вставки вызывается updateate-hook (sqlite3.xUpdateCallback).</target>
        </trans-unit>
        <trans-unit id="a5652d036064588f8b6a1cd35001bca04abb6577" translate="yes" xml:space="preserve">
          <source>Parameter zDb is not the filename that contains the database, but rather the symbolic name of the database. For attached databases, this is the name that appears after the AS keyword in the &lt;a href=&quot;../lang_attach&quot;&gt;ATTACH&lt;/a&gt; statement. For the main database file, the database name is &quot;main&quot;. For TEMP tables, the database name is &quot;temp&quot;.</source>
          <target state="translated">Параметр zDb - это не имя файла, содержащего базу данных, а скорее символическое имя базы данных. Для подключенных баз данных это имя появляется после ключевого слова AS в операторе &lt;a href=&quot;../lang_attach&quot;&gt;ATTACH&lt;/a&gt; . Для основного файла базы данных имя базы данных - &amp;laquo;main&amp;raquo;. Для таблиц TEMP имя базы данных - &amp;laquo;temp&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="6b3dbfca494676dd202b93efd1413416a69fb138" translate="yes" xml:space="preserve">
          <source>Parameter zDb is not the filename that contains the database, but rather the symbolic name of the database. For attached databases, this is the name that appears after the AS keyword in the &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; statement. For the main database file, the database name is &quot;main&quot;. For TEMP tables, the database name is &quot;temp&quot;.</source>
          <target state="translated">Параметр zDb - это не имя файла, содержащего базу данных, а скорее символическое имя базы данных. Для подключенных баз данных это имя появляется после ключевого слова AS в операторе &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; . Для основного файла базы данных имя базы данных - &amp;laquo;main&amp;raquo;. Для таблиц TEMP имя базы данных - &amp;laquo;temp&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="a975eea30db9fa05003e3b5097688bd49ec7e01b" translate="yes" xml:space="preserve">
          <source>Parameters</source>
          <target state="translated">Parameters</target>
        </trans-unit>
        <trans-unit id="799e97b7e20fea27a8af5b85f72a1e45ff70f20e" translate="yes" xml:space="preserve">
          <source>Parameters can be either named or unnamed. An unnamed parameter is a single question mark (&quot;?&quot;). Named parameters are a &quot;?&quot; followed immediately by a number (ex: &quot;?15&quot; or &quot;?123&quot;) or one of the characters &quot;$&quot;, &quot;:&quot;, or &quot;@&quot; followed by an alphanumeric name (ex: &quot;$var1&quot;, &quot;:xyz&quot;, &quot;@bingo&quot;).</source>
          <target state="translated">Параметры могут быть как именованными,так и безымянными.Безымянный параметр является одним вопросительным знаком (&quot;?&quot;).Именованные параметры-это &quot;?&quot;,за которым сразу же следует цифра (например:&quot;?15&quot; или &quot;?123&quot;)или один из символов &quot;$&quot;,&quot;:&quot; или &quot;@&quot;,за которым следует буквенно-цифровое имя (например:&quot;$var1&quot;,&quot;:xyz&quot;,&quot;@bingo&quot;).</target>
        </trans-unit>
        <trans-unit id="8cba5f18115ee2b196f01cd67b537bb6b53bf7ec" translate="yes" xml:space="preserve">
          <source>Parameters that are not assigned values using &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind()&lt;/a&gt; are treated as NULL. The &lt;a href=&quot;c3ref/bind_parameter_index&quot;&gt;sqlite3_bind_parameter_index()&lt;/a&gt; interface can be used to translate a symbolic parameter name into its equivalent numeric index.</source>
          <target state="translated">Параметры, которым не присвоены значения с помощью &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind ()&lt;/a&gt; , обрабатываются как NULL. Интерфейс &lt;a href=&quot;c3ref/bind_parameter_index&quot;&gt;sqlite3_bind_parameter_index ()&lt;/a&gt; можно использовать для преобразования символьного имени параметра в его эквивалентный числовой индекс.</target>
        </trans-unit>
        <trans-unit id="4de5d1891af8779fc1d212b882aca704731f9909" translate="yes" xml:space="preserve">
          <source>Parent and child keys must have the same cardinality. In SQLite, if any of the child key columns (in this case songartist and songalbum) are NULL, then there is no requirement for a corresponding row in the parent table.</source>
          <target state="translated">Родительский и детский ключи должны иметь одинаковую кардинальность.В SQLite,если любой из столбцов дочернего ключа (в данном случае songartist и songalbum)имеет NULL,то нет необходимости в соответствующей строке в родительской таблице.</target>
        </trans-unit>
        <trans-unit id="f4093b4053e6e304b33edcd1e545c7ac44407405" translate="yes" xml:space="preserve">
          <source>Parent table</source>
          <target state="translated">Родительская таблица</target>
        </trans-unit>
        <trans-unit id="4e28259727cc9bea774f5aa837a0a46e7e8f6e3d" translate="yes" xml:space="preserve">
          <source>Parentheses around the column name are ignored. Hence if X and Y.Z are column names, then (X) and (Y.Z) are also considered column names and have the affinity of the corresponding columns.</source>
          <target state="translated">Круглые скобки вокруг названия колонки игнорируются.Следовательно,если X и Y.Z являются названиями столбцов,то (X)и (Y.Z)также считаются названиями столбцов и имеют сродство с соответствующими столбцами.</target>
        </trans-unit>
        <trans-unit id="e9b3806832484c8806fbc046fab28912aa2aa64c" translate="yes" xml:space="preserve">
          <source>Parenthesis are not supported.</source>
          <target state="translated">Родословная не поддерживается.</target>
        </trans-unit>
        <trans-unit id="75d39bc816f04be94a422f23dd0120a1ebf6cf81" translate="yes" xml:space="preserve">
          <source>Parenthesis may be used to group expressions in order to modify operator precedence in the usual ways. For example:</source>
          <target state="translated">С помощью скобки можно сгруппировать выражения,чтобы изменить приоритет операторов обычными способами.Например:</target>
        </trans-unit>
        <trans-unit id="a5d92895b79471a4a9fa3ce0a6ffdf64945a6880" translate="yes" xml:space="preserve">
          <source>Parse (but do not implement) foreign keys.</source>
          <target state="translated">Разобрать (но не внедрить)иностранные ключи.</target>
        </trans-unit>
        <trans-unit id="c98796aa2add46f2617d36d2c94c638a1c0df012" translate="yes" xml:space="preserve">
          <source>ParseSchema</source>
          <target state="translated">ParseSchema</target>
        </trans-unit>
        <trans-unit id="1b3cf5033ed01a4fcbff3f2957e66cfe44af45a9" translate="yes" xml:space="preserve">
          <source>Parser</source>
          <target state="translated">Parser</target>
        </trans-unit>
        <trans-unit id="e5dde1d1ec704f9acd81aeb949908d6d48dedf9c" translate="yes" xml:space="preserve">
          <source>Parser detects and reports automaton stack overflow.</source>
          <target state="translated">Парсер обнаруживает и сообщает о переполнении стека автоматов.</target>
        </trans-unit>
        <trans-unit id="de7186ac205c0a4d05d1b7e13d0477c901e264d5" translate="yes" xml:space="preserve">
          <source>Parsing Ambiguity</source>
          <target state="translated">Неопределенность при разборе</target>
        </trans-unit>
        <trans-unit id="6893b79566df0f4ab433d9b0d800d95d1637ec25" translate="yes" xml:space="preserve">
          <source>Partial Indexes</source>
          <target state="translated">Частичные индексы</target>
        </trans-unit>
        <trans-unit id="b83a6d7f720f864139ebf6cd22707c1309f4af67" translate="yes" xml:space="preserve">
          <source>Partial index causes assertion fault on UPDATE OR REPLACE. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/2ea3e9fe63&quot;&gt;2ea3e9fe63&lt;/a&gt;</source>
          <target state="translated">Частичный индекс вызывает ошибку утверждения при UPDATE OR REPLACE. Билет &lt;a href=&quot;http://www.sqlite.org/src/info/2ea3e9fe63&quot;&gt;2ea3e9fe63&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="92e7c6c4dccd56837450920de775aa91130dc6eb" translate="yes" xml:space="preserve">
          <source>Partial indexes</source>
          <target state="translated">Частичные индексы</target>
        </trans-unit>
        <trans-unit id="a6b00209f988aae401d1637e4d3a48cf480b87b9" translate="yes" xml:space="preserve">
          <source>Partial indexes have been supported in SQLite since &lt;a href=&quot;https://sqlite.org/releaselog/3_8_0.html&quot;&gt;version 3.8.0&lt;/a&gt; (2013-08-26).</source>
          <target state="translated">Частичные индексы поддерживаются в SQLite с &lt;a href=&quot;https://sqlite.org/releaselog/3_8_0.html&quot;&gt;версии 3.8.0&lt;/a&gt; (2013-08-26).</target>
        </trans-unit>
        <trans-unit id="2c653f2abbb32f0888ba48000a6d19c0a678be3c" translate="yes" xml:space="preserve">
          <source>Partial sorting by index</source>
          <target state="translated">Частичная сортировка по индексу</target>
        </trans-unit>
        <trans-unit id="8e7b279371a7a0621eac24aac6019fdbd06fb946" translate="yes" xml:space="preserve">
          <source>Partially or fully disable the use of mutexes using &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigsinglethread&quot;&gt;SQLITE_CONFIG_SINGLETHREAD&lt;/a&gt;, &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmultithread&quot;&gt;SQLITE_CONFIG_MULTITHREAD&lt;/a&gt; and &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigserialized&quot;&gt;SQLITE_CONFIG_SERIALIZED&lt;/a&gt;.</source>
          <target state="translated">Частично или полностью отключите использование мьютексов с помощью &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigsinglethread&quot;&gt;SQLITE_CONFIG_SINGLETHREAD&lt;/a&gt; , &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmultithread&quot;&gt;SQLITE_CONFIG_MULTITHREAD&lt;/a&gt; и &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigserialized&quot;&gt;SQLITE_CONFIG_SERIALIZED&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="322d75c78f20c6c69dad6d4668258bee1cff55cf" translate="yes" xml:space="preserve">
          <source>Pass information about !=, IS, IS NOT, NOT NULL, and IS NULL constraints into the &lt;a href=&quot;vtab#xbestindex&quot;&gt;xBestIndex&lt;/a&gt; method of virtual tables.</source>
          <target state="translated">Передайте информацию об ограничениях! =, IS, IS NOT, NOT NULL и IS NULL в метод виртуальных таблиц &lt;a href=&quot;vtab#xbestindex&quot;&gt;xBestIndex&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="87139427c07163b54b934cac2e589a5477f5abd2" translate="yes" xml:space="preserve">
          <source>Passing around pointers as if they were integers or BLOBs is easy, effective, and works well in an environment where the application components are all friendly toward one another. However, passing pointers as integers and BLOBs allows hostile SQL text to forge invalid pointers that can carry out mischief.</source>
          <target state="translated">Передача указателей,как если бы они были целыми числами или BLOB,проста,эффективна и хорошо работает в среде,где все компоненты приложения дружелюбны друг к другу.Однако,передача указателей в виде целых чисел и BLOB-ов позволяет враждебно настроенному SQL-тексту подделать недействительные указатели,способные нанести вред.</target>
        </trans-unit>
        <trans-unit id="3138de58b357feeff45cc3442a6fef1e07764789" translate="yes" xml:space="preserve">
          <source>Passing zero to this function disables the session. Passing a value greater than zero enables it. Passing a value less than zero is a no-op, and may be used to query the current state of the session.</source>
          <target state="translated">Передача нуля в эту функцию отключает сеанс.Передача значения больше нуля позволяет это сделать.Передача значения меньше нуля-это &quot;нет-оп&quot;,и может быть использована для запроса текущего состояния сеанса.</target>
        </trans-unit>
        <trans-unit id="590be09d7533f1bdecea251bf8fa20c21692381c" translate="yes" xml:space="preserve">
          <source>Patch releases may or may not have a release checklist, depending on the issue. This is a judgement call by the project leader.</source>
          <target state="translated">В зависимости от проблемы,у патч-релизов может быть контрольный список выпусков,а может и нет.Это решение принимается руководителем проекта.</target>
        </trans-unit>
        <trans-unit id="6943c09e1bab506ed4d4e77bf277765f2ba43e9d" translate="yes" xml:space="preserve">
          <source>Patches from Christian Werner to improve ODBC compatibility and to fix a bug in the round() function.</source>
          <target state="translated">Патчи от Christian Werner для улучшения ODBC совместимости и исправления ошибки в функции round().</target>
        </trans-unit>
        <trans-unit id="2e7fec23d54bbd8979f0f75ea726578cd4ba06c0" translate="yes" xml:space="preserve">
          <source>Pay close attention to the last sentence in the previous paragraph:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c30415eacc6a59446974b716eff56cf28219815d" translate="yes" xml:space="preserve">
          <source>Payload</source>
          <target state="translated">Payload</target>
        </trans-unit>
        <trans-unit id="2cd642b895a9277d90f1edb51ac2e97d29897374" translate="yes" xml:space="preserve">
          <source>Payload, either table b-tree data or index b-tree keys, is always in the &quot;record format&quot;. The record format defines a sequence of values corresponding to columns in a table or index. The record format specifies the number of columns, the datatype of each column, and the content of each column.</source>
          <target state="translated">Полезная нагрузка,будь то данные из b-дерева таблицы или ключи индекса b-дерева,всегда находится в &quot;формате записи&quot;.Формат записи определяет последовательность значений,соответствующих столбцам таблицы или индекса.Формат записи задает количество столбцов,тип данных каждого столбца и содержание каждого столбца.</target>
        </trans-unit>
        <trans-unit id="e74a4343f3025ea9dd8df608f45f6bce992f0d7e" translate="yes" xml:space="preserve">
          <source>Pending statements no longer block &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt;. Instead, the pending statement will return SQLITE_ABORT upon next access after the ROLLBACK.</source>
          <target state="translated">Отложенные операторы больше не блокируют &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt; . Вместо этого ожидающий оператор вернет SQLITE_ABORT при следующем доступе после ROLLBACK.</target>
        </trans-unit>
        <trans-unit id="4737507de6ca940161ab97310c9c1d96280bacd6" translate="yes" xml:space="preserve">
          <source>People often wonder why SQLite does not use the &lt;a href=&quot;https://git-scm.org&quot;&gt;Git&lt;/a&gt; version control system like everybody else. This article attempts to answer that question. Also, in &lt;a href=&quot;#getthecode&quot;&gt;section 3&lt;/a&gt;, this article provides hints to Git users about how they can easily access the SQLite source code.</source>
          <target state="translated">Люди часто задаются вопросом, почему SQLite не использует систему контроля версий &lt;a href=&quot;https://git-scm.org&quot;&gt;Git&lt;/a&gt; , как все остальные. В этой статье делается попытка ответить на этот вопрос. Кроме того, в &lt;a href=&quot;#getthecode&quot;&gt;разделе 3&lt;/a&gt; этой статьи даются советы пользователям Git о том, как они могут легко получить доступ к исходному коду SQLite.</target>
        </trans-unit>
        <trans-unit id="a859905b933e3207fdf46d957c4ccc640fdf48ae" translate="yes" xml:space="preserve">
          <source>People who understand SQL can employ the &lt;a href=&quot;cli&quot;&gt;sqlite3 command-line shell&lt;/a&gt; (or various third-party SQLite access programs) to analyze large datasets. Raw data can be imported from CSV files, then that data can be sliced and diced to generate a myriad of summary reports. More complex analysis can be done using simple scripts written in Tcl or Python (both of which come with SQLite built-in) or in R or other languages using readily available adaptors. Possible uses include website log analysis, sports statistics analysis, compilation of programming metrics, and analysis of experimental results. Many bioinformatics researchers use SQLite in this way.</source>
          <target state="translated">Люди, разбирающиеся в SQL, могут использовать &lt;a href=&quot;cli&quot;&gt;оболочку командной строки sqlite3&lt;/a&gt; (или различные сторонние программы доступа к SQLite) для анализа больших наборов данных. Необработанные данные можно импортировать из файлов CSV, а затем эти данные можно разрезать и разрезать для создания множества сводных отчетов. Более сложный анализ может быть выполнен с использованием простых сценариев, написанных на Tcl или Python (оба из которых имеют встроенный SQLite) или на R или других языках с использованием легко доступных адаптеров. Возможные варианты использования включают анализ журналов веб-сайтов, анализ спортивной статистики, составление программных показателей и анализ результатов экспериментов. Многие исследователи биоинформатики используют SQLite таким образом.</target>
        </trans-unit>
        <trans-unit id="deda64204144c5cb8a53d34e5d28a353e9faf513" translate="yes" xml:space="preserve">
          <source>Perform a single step of the incremental vacuum procedure on the P1 database. If the vacuum has finished, jump to instruction P2. Otherwise, fall through to the next instruction.</source>
          <target state="translated">Выполните один шаг процедуры создания инкрементного вакуума в базе данных P1.Если вакуум закончился,перейдите к инструкции P2.В противном случае перейдите к следующей инструкции.</target>
        </trans-unit>
        <trans-unit id="54eef71ea08bf2a0291b4730516048fec290cbbf" translate="yes" xml:space="preserve">
          <source>Perform any required foreign key actions,</source>
          <target state="translated">Выполните все необходимые зарубежные ключевые действия,</target>
        </trans-unit>
        <trans-unit id="94e7748396990532238f46b792b6a833a4e68178" translate="yes" xml:space="preserve">
          <source>Perform some &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; operations in a single pass instead of in two passes.</source>
          <target state="translated">Выполняйте некоторые операции &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; за один проход вместо двух.</target>
        </trans-unit>
        <trans-unit id="63c904559993935c470f516c8b549ca7f3640dbb" translate="yes" xml:space="preserve">
          <source>Performance</source>
          <target state="translated">Performance</target>
        </trans-unit>
        <trans-unit id="0b4045b439e29414aaf2009ad15f476795f21a79" translate="yes" xml:space="preserve">
          <source>Performance Related Assumptions</source>
          <target state="translated">Предположения,связанные с производительностью</target>
        </trans-unit>
        <trans-unit id="5539b01935cddeb466afb8949c00cacfd4174474" translate="yes" xml:space="preserve">
          <source>Performance can be improved and the size reduced by enabling &lt;a href=&quot;compile#threadsafe&quot;&gt;-DSQLITE_THREADSAFE=0&lt;/a&gt;, &lt;a href=&quot;compile#default_memstatus&quot;&gt;-DSQLITE_DEFAULT_MEMSTATUS=0&lt;/a&gt;, &lt;a href=&quot;compile#default_wal_synchronous&quot;&gt;-DSQLITE_DEFAULT_WAL_SYNCHRONOUS=1&lt;/a&gt;, &lt;a href=&quot;compile#like_doesnt_match_blobs&quot;&gt;-DSQLITE_LIKE_DOESNT_MATCH_BLOBS&lt;/a&gt;, &lt;a href=&quot;limits#max_expr_depth&quot;&gt;-DSQLITE_MAX_EXPR_DEPTH=0&lt;/a&gt;, &lt;a href=&quot;compile#omit_decltype&quot;&gt;-DSQLITE_OMIT_DECLTYPE&lt;/a&gt;, &lt;a href=&quot;compile#omit_deprecated&quot;&gt;-DSQLITE_OMIT_DEPRECATED&lt;/a&gt;, &lt;a href=&quot;compile#omit_progress_callback&quot;&gt;-DSQLITE_OMIT_PROGRESS_CALLBACK&lt;/a&gt;, &lt;a href=&quot;compile#omit_shared_cache&quot;&gt;-DSQLITE_OMIT_SHARED_CACHE&lt;/a&gt;, and &lt;a href=&quot;compile#use_alloca&quot;&gt;-DSQLITE_USE_ALLOCA&lt;/a&gt;. All these options together result in about a 3.5% performance increase and a 3.0% size reduction.</source>
          <target state="translated">Производительность может быть улучшена , и размер уменьшен, позволяя &lt;a href=&quot;compile#threadsafe&quot;&gt;-DSQLITE_THREADSAFE = 0&lt;/a&gt; , &lt;a href=&quot;compile#default_memstatus&quot;&gt;-DSQLITE_DEFAULT_MEMSTATUS = 0&lt;/a&gt; , &lt;a href=&quot;compile#default_wal_synchronous&quot;&gt;-DSQLITE_DEFAULT_WAL_SYNCHRONOUS = 1&lt;/a&gt; , &lt;a href=&quot;compile#like_doesnt_match_blobs&quot;&gt;-DSQLITE_LIKE_DOESNT_MATCH_BLOBS&lt;/a&gt; , &lt;a href=&quot;limits#max_expr_depth&quot;&gt;-DSQLITE_MAX_EXPR_DEPTH = 0&lt;/a&gt; , &lt;a href=&quot;compile#omit_decltype&quot;&gt;-DSQLITE_OMIT_DECLTYPE&lt;/a&gt; , &lt;a href=&quot;compile#omit_deprecated&quot;&gt;-DSQLITE_OMIT_DEPRECATED&lt;/a&gt; , &lt;a href=&quot;compile#omit_progress_callback&quot;&gt;-DSQLITE_OMIT_PROGRESS_CALLBACK&lt;/a&gt; , &lt;a href=&quot;compile#omit_shared_cache&quot;&gt;-DSQLITE_OMIT_SHARED_CACHE&lt;/a&gt; и &lt;a href=&quot;compile#use_alloca&quot;&gt;-DSQLITE_USE_ALLOCA&lt;/a&gt; . Все эти параметры вместе приводят к увеличению производительности примерно на 3,5% и уменьшению размера на 3,0%.</target>
        </trans-unit>
        <trans-unit id="1860a0dfdb81986d4ea2f6eb535ec453b85d5fe2" translate="yes" xml:space="preserve">
          <source>Performance does not always increase with memory-mapped I/O. In fact, it is possible to construct test cases where performance is reduced by the use of memory-mapped I/O.</source>
          <target state="translated">Производительность не всегда повышается при вводе/выводе данных с отображением на карте памяти.Фактически,можно построить тестовые случаи,когда производительность снижается за счет использования ввода/вывода с отображением на карте памяти.</target>
        </trans-unit>
        <trans-unit id="61bd66ed39fd686f0ca14a86562254f51520b57c" translate="yes" xml:space="preserve">
          <source>Performance enhancement: Reengineer the internal routines used to interpret and render variable-length integers.</source>
          <target state="translated">Повышение производительности:Реинжиниринг внутренних процедур,используемых для интерпретации и вывода целых чисел переменной длины.</target>
        </trans-unit>
        <trans-unit id="cea233e3b9eddbf52457c8a5a182ae23ce06f170" translate="yes" xml:space="preserve">
          <source>Performance enhancements in the &lt;a href=&quot;lemon&quot;&gt;Lemon&lt;/a&gt;-generated parser</source>
          <target state="translated">Повышение производительности синтаксического анализатора, созданного &lt;a href=&quot;lemon&quot;&gt;Lemon&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c2ed78164f58cda3689de3af94b6683e701f4012" translate="yes" xml:space="preserve">
          <source>Performance enhancements in the VDBE, especially to the OP_Column opcode.</source>
          <target state="translated">Улучшения производительности в VDBE,особенно в коде колонки OP_Column.</target>
        </trans-unit>
        <trans-unit id="3e83f7e02f169f16c4ce4c1bf1daf1d4f6a2d0dd" translate="yes" xml:space="preserve">
          <source>Performance enhancements in the parser.</source>
          <target state="translated">Улучшение производительности парсера.</target>
        </trans-unit>
        <trans-unit id="1553d9684987d03c293eb61361d1bad6eb661140" translate="yes" xml:space="preserve">
          <source>Performance enhancements in the sorter used by ORDER BY and CREATE INDEX.</source>
          <target state="translated">Улучшение производительности сортировщика,используемого ORDER BY и CREATE INDEX.</target>
        </trans-unit>
        <trans-unit id="d07c917b16f3c5d3172eade92a68d5375afe8a41" translate="yes" xml:space="preserve">
          <source>Performance enhancements on some corner cases of COUNT(*).</source>
          <target state="translated">Повышение эффективности в некоторых угловых случаях COUNT(*).</target>
        </trans-unit>
        <trans-unit id="2136335adf2e68388f67bd194f29e528095a22d7" translate="yes" xml:space="preserve">
          <source>Performance enhancements through reductions in disk I/O:</source>
          <target state="translated">Повышение производительности за счет сокращения дисковых входов/выходов:</target>
        </trans-unit>
        <trans-unit id="f10f9c4b246cd76bbc82d16d809b97086003c9dc" translate="yes" xml:space="preserve">
          <source>Performance enhancements to tree balancing logic in the B-Tree layer.</source>
          <target state="translated">Повышение производительности логики балансировки деревьев в слое B-Tree.</target>
        </trans-unit>
        <trans-unit id="c1957e5fe4e4a95d607424db9c544dbfb2c9f147" translate="yes" xml:space="preserve">
          <source>Performance enhancements.</source>
          <target state="translated">Улучшения производительности.</target>
        </trans-unit>
        <trans-unit id="fd543174849447437d626cec826158c9d3d9aa89" translate="yes" xml:space="preserve">
          <source>Performance improvement: Constant subexpressions are factored out of loops.</source>
          <target state="translated">Улучшение производительности:Постоянные подвыражения исключены из циклов.</target>
        </trans-unit>
        <trans-unit id="6267206177784b60f0b03bc62ec213be82afcde6" translate="yes" xml:space="preserve">
          <source>Performance improvement: Results of OP_Column are reused rather than issuing multiple OP_Column opcodes.</source>
          <target state="translated">Улучшение производительности:Результаты работы столбца OP_Column используются повторно,вместо того,чтобы выдавать несколько опкодов столбца OP_Column.</target>
        </trans-unit>
        <trans-unit id="865a67eeabea312b0a75ae22ab67eb186cfe013a" translate="yes" xml:space="preserve">
          <source>Performance improvement: The OP_IdxDelete opcode uses unpacked records, obviating the need for one OP_MakeRecord opcode call for each index record deleted.</source>
          <target state="translated">Улучшение производительности:Опкод OP_IdxDelete использует распакованные записи,избавляя от необходимости одного вызова опкода OP_MakeRecord для каждой удаленной индексной записи.</target>
        </trans-unit>
        <trans-unit id="78e2db7e7f2b2267a1830af4b4a2ed0ba33c683b" translate="yes" xml:space="preserve">
          <source>Performance improvements for &quot;count(*)&quot; queries.</source>
          <target state="translated">Улучшение производительности для запросов &quot;count(*)&quot;.</target>
        </trans-unit>
        <trans-unit id="6efb6a4d8f17dc824c346d05f15cd7b2b88dcf5d" translate="yes" xml:space="preserve">
          <source>Performance improvements for &lt;a href=&quot;lang_select#orderby&quot;&gt;ORDER BY&lt;/a&gt;, &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt;, &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt;, &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt;, and &lt;a href=&quot;pragma#pragma_quick_check&quot;&gt;PRAGMA quick_check&lt;/a&gt;.</source>
          <target state="translated">Улучшения производительности для &lt;a href=&quot;lang_select#orderby&quot;&gt;ORDER BY&lt;/a&gt; , &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; , &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt; , &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA Integrity_check&lt;/a&gt; и &lt;a href=&quot;pragma#pragma_quick_check&quot;&gt;PRAGMA quick_check&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c7ba2d57a08f2fc705e0114aa7d1ce0a8358e340" translate="yes" xml:space="preserve">
          <source>Performance improvements for &lt;a href=&quot;pragma#pragma_incremental_vacuum&quot;&gt;PRAGMA incremental_vacuum&lt;/a&gt;, especially in cases where the number of free pages is greater than what will fit on a single trunk page of the freelist.</source>
          <target state="translated">Улучшения производительности &lt;a href=&quot;pragma#pragma_incremental_vacuum&quot;&gt;PRAGMA incremental_vacuum&lt;/a&gt; , особенно в случаях, когда количество свободных страниц больше, чем умещается на одной основной странице списка фрилансеров .</target>
        </trans-unit>
        <trans-unit id="ca9c11fd98f734889e089bb0e89c4f23dda7fe58" translate="yes" xml:space="preserve">
          <source>Performance improvements in the LEMON-generated parser.</source>
          <target state="translated">Улучшение производительности парсера LEMON.</target>
        </trans-unit>
        <trans-unit id="a14e5b6d4c4866ac4384c7883a92dffe274c0fdc" translate="yes" xml:space="preserve">
          <source>Performance improvements in the parser, pager, and WHERE clause code generator.</source>
          <target state="translated">Улучшение производительности парсера,пейджера и генератора кода пункта WHERE.</target>
        </trans-unit>
        <trans-unit id="4775771a833741ba344ee91f202aad2d4ccd4444" translate="yes" xml:space="preserve">
          <source>Performance improvements in the query optimizer.</source>
          <target state="translated">Улучшение производительности оптимизатора запросов.</target>
        </trans-unit>
        <trans-unit id="db2c756a058cad6c443215c62bd837d8ebcd7c86" translate="yes" xml:space="preserve">
          <source>Performance improvements. The library is now much faster.</source>
          <target state="translated">Улучшения производительности.Библиотека теперь работает намного быстрее.</target>
        </trans-unit>
        <trans-unit id="7776d02639084ffcec06b8eee5d8080752868819" translate="yes" xml:space="preserve">
          <source>Performance measurements are done with a single compiler (gcc 5.4.0), optimization setting (-Os), and on a single platform (Ubuntu 16.04 LTS on x64). The performance of other compilers and processors may vary.</source>
          <target state="translated">Измерение производительности производится с помощью одного компилятора (gcc 5.4.0),установки оптимизации (-O),и на одной платформе (Ubuntu 16.04 LTS на x64).Производительность других компиляторов и процессоров может отличаться.</target>
        </trans-unit>
        <trans-unit id="4313721e53c3870801c269d394561df5830ac670" translate="yes" xml:space="preserve">
          <source>Performance optimizations targeting a specific use case from a single high-profile user of SQLite. A 12% reduction in the number of CPU operations is achieved (as measured by Valgrind). Actual performance improvements in practice may vary depending on workload. Changes include:</source>
          <target state="translated">Оптимизация производительности для конкретного случая использования от одного высокопоставленного пользователя SQLite.Достигнуто снижение количества операций на процессоре на 12% (по данным Valgrind).Фактическое повышение производительности на практике может варьироваться в зависимости от рабочей нагрузки.Изменения включают в себя:</target>
        </trans-unit>
        <trans-unit id="aafc19be49f715a88d989d3b462949b02cf65924" translate="yes" xml:space="preserve">
          <source>Performance problems can often be resolved, even late in the development cycle, using &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt;, avoiding costly redesign, rewrite, and retest efforts.</source>
          <target state="translated">Проблемы производительности часто можно решить, даже на поздних этапах цикла разработки, с помощью &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt; , избегая дорогостоящих усилий по редизайну, переписыванию и повторному тестированию.</target>
        </trans-unit>
        <trans-unit id="80d748ed593bda4d15f97528a4a48c139940ad2c" translate="yes" xml:space="preserve">
          <source>Performance was measured by running speedtest1 using cachegrind and observing the &quot;I refs&quot; output.</source>
          <target state="translated">Производительность измерялась с помощью теста скорости работы1 с использованием кэш-функции измельчения и наблюдением за выводом &quot;I refs&quot;.</target>
        </trans-unit>
        <trans-unit id="fd932d13fa7bed8f3a51946f0c1cded4ce734cc8" translate="yes" xml:space="preserve">
          <source>Performance was measured using the &lt;a href=&quot;https://sqlite.org/src/file/test/speedtest1.c&quot;&gt;speedtest1.c&lt;/a&gt; utility program, which attempts to mimic a typical workload for SQLite. Options to the test runs are:</source>
          <target state="translated">Производительность измерялась с помощью служебной программы &lt;a href=&quot;https://sqlite.org/src/file/test/speedtest1.c&quot;&gt;speedtest1.c&lt;/a&gt; , которая пытается имитировать типичную рабочую нагрузку для SQLite. Варианты тестовых прогонов:</target>
        </trans-unit>
        <trans-unit id="306df6900907956d3250e5c6b9116143f3e59d56" translate="yes" xml:space="preserve">
          <source>Perhaps you are referring to the following statement from SQL92:</source>
          <target state="translated">Возможно,вы имеете в виду следующее утверждение из SQL92:</target>
        </trans-unit>
        <trans-unit id="dc174949d4e077b47c1979929b03d9b696ed5987" translate="yes" xml:space="preserve">
          <source>Permit SELECT statements without a FROM clause.</source>
          <target state="translated">Разрешение на выбор заявлений без пункта FROM.</target>
        </trans-unit>
        <trans-unit id="6cbfe59727ef5993727b847bb5705e98e92cb339" translate="yes" xml:space="preserve">
          <source>Permutation</source>
          <target state="translated">Permutation</target>
        </trans-unit>
        <trans-unit id="4fce736ea498cc616300b0a192c1d1da1b783f4c" translate="yes" xml:space="preserve">
          <source>Permuted Title Index</source>
          <target state="translated">Индекс презумпции титула</target>
        </trans-unit>
        <trans-unit id="d33cf936053187794d74699260279a0a85c60b95" translate="yes" xml:space="preserve">
          <source>Persistent loadable extensions</source>
          <target state="translated">Постоянно загружаемые удлинители</target>
        </trans-unit>
        <trans-unit id="cda60e78224642430ac8ecc50f20cf5762fbe57b" translate="yes" xml:space="preserve">
          <source>Phrase and NEAR queries may not span multiple columns within a row.</source>
          <target state="translated">Фразы и запросы NEAR не могут охватывать несколько столбцов в пределах строки.</target>
        </trans-unit>
        <trans-unit id="8867fcbca825b3aa1d7306421a378db86e201e5f" translate="yes" xml:space="preserve">
          <source>Phrase queries</source>
          <target state="translated">фразовые запросы</target>
        </trans-unit>
        <trans-unit id="a363180d8d104ea58876b6a7416ecc65d37a83bd" translate="yes" xml:space="preserve">
          <source>Phrase queries are not available.</source>
          <target state="translated">Фразовые запросы недоступны.</target>
        </trans-unit>
        <trans-unit id="c2d36c2214269a55cf08fe15db0efb7f6b50dc52" translate="yes" xml:space="preserve">
          <source>Phrases and NEAR groups may also be connected by &lt;b&gt;implicit AND operators&lt;/b&gt;. For simplicity, these are not shown in the BNF grammar above. Essentially, any sequence of phrases or NEAR groups (including those restricted to matching specified columns) separated only by whitespace are handled as if there were an implicit AND operator between each pair of phrases or NEAR groups. Implicit AND operators are never inserted after or before an expression enclosed in parenthesis. For example:</source>
          <target state="translated">Фразы и группы NEAR также могут быть связаны &lt;b&gt;неявными операторами AND&lt;/b&gt; . Для простоты они не показаны в грамматике BNF выше. По сути, любая последовательность фраз или групп NEAR (включая те, которые ограничены указанными столбцами), разделенные только пробелом, обрабатываются так, как если бы между каждой парой фраз или группами NEAR был неявный оператор AND. Неявные операторы И никогда не вставляются после или перед выражением, заключенным в круглые скобки. Например:</target>
        </trans-unit>
        <trans-unit id="c324bfc69bd8b1bd8095017021f5a91e3ea40b2c" translate="yes" xml:space="preserve">
          <source>Phrases and NEAR groups may be arranged into expressions using &lt;b&gt;boolean operators&lt;/b&gt;. In order of precedence, from highest (tightest grouping) to lowest (loosest grouping), the operators are:</source>
          <target state="translated">Фразы и группы NEAR могут быть объединены в выражения с использованием &lt;b&gt;логических операторов&lt;/b&gt; . В порядке приоритета, от самого высокого (самая плотная группировка) до самого низкого (самая слабая группировка), операторы:</target>
        </trans-unit>
        <trans-unit id="3ae7ce4ac376e04456d5e49b6ed2413b1a3d558b" translate="yes" xml:space="preserve">
          <source>Picking the nested order of the various loops</source>
          <target state="translated">Выбирая вложенный порядок различных петель</target>
        </trans-unit>
        <trans-unit id="e6557cb061d60a980305721118e117b8668196a9" translate="yes" xml:space="preserve">
          <source>Picking the nesting order is generally the more challenging problem. Once the nesting order of the join is established, the choice of indexes for each loop is normally obvious.</source>
          <target state="translated">Выбор порядка гнездования,как правило,является более сложной проблемой.Как только порядок вложенности соединения установлен,выбор индексов для каждого цикла,как правило,очевиден.</target>
        </trans-unit>
        <trans-unit id="48838d5eebf4e016bae8e0582e9b79166631f842" translate="yes" xml:space="preserve">
          <source>Pinning (reading) a database page.</source>
          <target state="translated">Пиннинг (чтение)страницы базы данных.</target>
        </trans-unit>
        <trans-unit id="e786fb34d40222929b9ef3bd84afa78c0fc799e8" translate="yes" xml:space="preserve">
          <source>Plays better with virus scanners on Windows</source>
          <target state="translated">Играет лучше с антивирусными сканерами на Windows</target>
        </trans-unit>
        <trans-unit id="0ba6acad031749dfc1ea19f37cf3cf3ba6821875" translate="yes" xml:space="preserve">
          <source>Please pay particular attention to the fact that the pointer returned from &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_blob()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_text()&lt;/a&gt;, or &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_text16()&lt;/a&gt; can be invalidated by a subsequent call to &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_bytes()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_bytes16()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_text()&lt;/a&gt;, or &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_text16()&lt;/a&gt;.</source>
          <target state="translated">Пожалуйста , обратите особое внимание на то , что указатель вернулся из &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_blob ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_text ()&lt;/a&gt; , или &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_text16 ()&lt;/a&gt; могут быть признаны недействительными последующим вызовом &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_bytes ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_bytes16 ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_text ()&lt;/a&gt; , или &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_text16 ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7ae91e82ac5caaf87714c26921fb437ec0209ebd" translate="yes" xml:space="preserve">
          <source>Please pay particular attention to the fact that the pointer returned from &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_blob()&lt;/a&gt;, &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_text()&lt;/a&gt;, or &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_text16()&lt;/a&gt; can be invalidated by a subsequent call to &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_bytes()&lt;/a&gt;, &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_bytes16()&lt;/a&gt;, &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_text()&lt;/a&gt;, or &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_text16()&lt;/a&gt;.</source>
          <target state="translated">Пожалуйста , обратите особое внимание на то , что указатель вернулся из &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_blob ()&lt;/a&gt; , &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_text ()&lt;/a&gt; , или &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_text16 ()&lt;/a&gt; могут быть признаны недействительными последующим вызовом &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_bytes ()&lt;/a&gt; , &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_bytes16 ()&lt;/a&gt; , &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_text ()&lt;/a&gt; , или &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_text16 ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="82e80b8ed5a5ef5a7f7f84502fd344efe74ab819" translate="yes" xml:space="preserve">
          <source>Plug some memory leaks that use to occur if malloc() failed. We have been and continue to be memory leak free as long as malloc() works.</source>
          <target state="translated">Подключите некоторые утечки памяти,которые происходят,если malloc()не удалось.Мы были и остаемся свободными от утечек памяти до тех пор,пока работает malloc().</target>
        </trans-unit>
        <trans-unit id="9885c5aa124b354814a6a44123b3e909495fe046" translate="yes" xml:space="preserve">
          <source>Pointer Passing Interfaces</source>
          <target state="translated">Интерфейсы передачи указателей</target>
        </trans-unit>
        <trans-unit id="59e3eae717dea15b934265a0c37302cf590a5714" translate="yes" xml:space="preserve">
          <source>Pointer leak</source>
          <target state="translated">Утечка указателя</target>
        </trans-unit>
        <trans-unit id="893d8abe3b1d2dc513b4dcba9c2db9ee48da24a6" translate="yes" xml:space="preserve">
          <source>Pointer map or ptrmap pages are extra pages inserted into the database to make the operation of &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum&lt;/a&gt; and &lt;a href=&quot;pragma#pragma_incremental_vacuum&quot;&gt;incremental_vacuum&lt;/a&gt; modes more efficient. Other page types in the database typically have pointers from parent to child. For example, an interior b-tree page contains pointers to its child b-tree pages and an overflow chain has a pointer from earlier to later links in the chain. A ptrmap page contains linkage information going in the opposite direction, from child to parent.</source>
          <target state="translated">Страницы Pointer map или ptrmap - это дополнительные страницы, вставленные в базу данных, чтобы сделать работу &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;режимов auto_vacuum&lt;/a&gt; и &lt;a href=&quot;pragma#pragma_incremental_vacuum&quot;&gt;incremental_vacuum&lt;/a&gt; более эффективной. Другие типы страниц в базе данных обычно имеют указатели от родительского к дочернему. Например, внутренняя страница b-дерева содержит указатели на свои дочерние страницы b-дерева, а цепочка переполнения имеет указатель с более ранних на более поздние ссылки в цепочке. Страница ptrmap содержит информацию о связях, идущую в противоположном направлении, от дочернего к родительскому.</target>
        </trans-unit>
        <trans-unit id="d9fb370b0a40e2e2f19446936bcadb07206247ac" translate="yes" xml:space="preserve">
          <source>Pointer types</source>
          <target state="translated">Типы указателей</target>
        </trans-unit>
        <trans-unit id="1091e0ac6927998f6cf6d184bfe2c9b9dcea6870" translate="yes" xml:space="preserve">
          <source>Pointer types are static strings, which ideally should be string literals embedded directly in the SQLite API call, not parameters passed in from other functions. Consideration was given to using integer values as the pointer type, but static strings provides a much larger name space which reduces the chance of accidental type-name collisions between unrelated extensions.</source>
          <target state="translated">Типы указателей-это статические строки,которые в идеале должны быть строковыми литералами,встроенными непосредственно в вызов SQLite API,а не параметрами,передаваемыми из других функций.Рассматривалось использование целочисленных значений в качестве типа указателя,но статические строки обеспечивают гораздо большее пространство имён,что снижает вероятность случайных коллизий между не связанными между собой расширениями.</target>
        </trans-unit>
        <trans-unit id="3b1d288532e92abf21814dda987180d6353e6315" translate="yes" xml:space="preserve">
          <source>Pointer values generated by &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer()&lt;/a&gt; and &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer()&lt;/a&gt; cannot be read by pure SQL. Hence, it is not possible for SQL to leak the value of pointers.</source>
          <target state="translated">Значения указателей, сгенерированные &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer ()&lt;/a&gt; и &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer (),&lt;/a&gt; не могут быть прочитаны чистым SQL. Следовательно, SQL не может утечь значение указателей.</target>
        </trans-unit>
        <trans-unit id="362edd7f45230e1071baa348e5b8aa0beef2dc87" translate="yes" xml:space="preserve">
          <source>Pointer values must flow directly from their producer into their consumer, with no intermediate operators or functions. Any transformation of a pointer value destroys the pointer and transforms the value into an ordinary SQL NULL.</source>
          <target state="translated">Значения указателей должны поступать непосредственно от производителя к потребителю,без промежуточных операторов и функций.Любое преобразование значения указателя уничтожает указатель и превращает его в обычный SQL NULL.</target>
        </trans-unit>
        <trans-unit id="d40a766f8bf600e29b3ebb06afc3c66d8eb2275c" translate="yes" xml:space="preserve">
          <source>Pointer values read by &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_pointer()&lt;/a&gt; cannot be generated by pure SQL. Hence, it is not possible for SQL to forge pointers.</source>
          <target state="translated">Значения указателя, считываемые &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_pointer (),&lt;/a&gt; не могут быть сгенерированы чистым SQL. Следовательно, SQL не может подделывать указатели.</target>
        </trans-unit>
        <trans-unit id="074017050c52f59774a49045cefb3a8e55469503" translate="yes" xml:space="preserve">
          <source>Pointers should &lt;u&gt;never&lt;/u&gt; be exchanged by encoding them as some other SQL datatype, such as integers or BLOBs. Instead, use the interfaces designed to facilitate secure pointer passing: &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer()&lt;/a&gt;, &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer()&lt;/a&gt;, and &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_pointer()&lt;/a&gt;.</source>
          <target state="translated">Указатели &lt;u&gt;никогда не&lt;/u&gt; следует обменивать, кодируя их как другой тип данных SQL, например целые числа или большие двоичные объекты. Вместо этого используйте интерфейсы, разработанные для облегчения безопасной передачи указателей: &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer ()&lt;/a&gt; , &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer ()&lt;/a&gt; и &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_pointer ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3758fcfa626c0aaafd8e85f7ec0b94d37eb1b41f" translate="yes" xml:space="preserve">
          <source>Porting SQLite To New Operating Systems</source>
          <target state="translated">Портирование SQLite на новые операционные системы</target>
        </trans-unit>
        <trans-unit id="492619cf72b9410d05b5a1fac306af0804a5c47b" translate="yes" xml:space="preserve">
          <source>Position cursor P1 at the end of the btree for the purpose of appending a new entry onto the btree.</source>
          <target state="translated">Установите курсор P1 в конце дерева для добавления новой записи в дерево.</target>
        </trans-unit>
        <trans-unit id="24fd6c2d1150de6a47543209150ff4c2a2d3104f" translate="yes" xml:space="preserve">
          <source>PostgreSQL</source>
          <target state="translated">PostgreSQL</target>
        </trans-unit>
        <trans-unit id="a6c78fee1df30606dfc4f598f623eca0d1354255" translate="yes" xml:space="preserve">
          <source>PostgreSQL:</source>
          <target state="translated">PostgreSQL:</target>
        </trans-unit>
        <trans-unit id="957feaeb06e5a65656c3283c9c7193ebcf008b45" translate="yes" xml:space="preserve">
          <source>Postpone I/O associated with TEMP files for as long as possible, with the hope that the I/O can ultimately be avoided completely.</source>
          <target state="translated">Отложите ввод/вывод,связанный с файлами TEMP,на как можно более долгий срок,надеясь,что в конечном итоге можно будет полностью избежать ввода/вывода.</target>
        </trans-unit>
        <trans-unit id="1bdd037a51c3dae4c27aa3b443867933947439ca" translate="yes" xml:space="preserve">
          <source>Powersafe Overwrite</source>
          <target state="translated">Powersafe Overwrite</target>
        </trans-unit>
        <trans-unit id="10329807f69720bd141eb1a12685730b2cfaf4cd" translate="yes" xml:space="preserve">
          <source>Pragma list</source>
          <target state="translated">список прагматиков</target>
        </trans-unit>
        <trans-unit id="c984aa3372c91f167c3b8d4c0c9f9715c82d4221" translate="yes" xml:space="preserve">
          <source>Pragma statements supported by SQLite</source>
          <target state="translated">Прагматические заявления,поддерживаемые SQLite</target>
        </trans-unit>
        <trans-unit id="4a80a5f45da767ce7271bd5ac307890ba0ff78a6" translate="yes" xml:space="preserve">
          <source>Pragmas whose names are &lt;s&gt;struck through&lt;/s&gt; are deprecated. Do not use them. They exist for historical compatibility.</source>
          <target state="translated">Прагмы , чьи имена &lt;s&gt;перечеркнуты&lt;/s&gt; устарели. Не используйте их. Они существуют для исторической совместимости.</target>
        </trans-unit>
        <trans-unit id="36fd60583248a73e8dcb8aeb3b04450519f9ddea" translate="yes" xml:space="preserve">
          <source>Pray for your enemies in the love of Christ.</source>
          <target state="translated">Молитесь о своих врагах в любви Христа.</target>
        </trans-unit>
        <trans-unit id="1d437b581e9dcd72eb07665e29677b9a7ea18988" translate="yes" xml:space="preserve">
          <source>Prefer nothing more than the love of Christ.</source>
          <target state="translated">Не желают ничего,кроме любви Христовой.</target>
        </trans-unit>
        <trans-unit id="6b85b242b16c8eaf303d30b62e8918e8c764ab9e" translate="yes" xml:space="preserve">
          <source>Prefix indexes may be used to optimize &lt;a href=&quot;fts3#termprefix&quot;&gt;prefix queries&lt;/a&gt; in two cases. If the query is for a prefix of N bytes, then a prefix index created with &quot;prefix=N&quot; provides the best optimization. Or, if no &quot;prefix=N&quot; index is available, a &quot;prefix=N+1&quot; index may be used instead. Using a &quot;prefix=N+1&quot; index is less efficient than a &quot;prefix=N&quot; index, but is better than no prefix index at all.</source>
          <target state="translated">Префиксные индексы могут использоваться для оптимизации &lt;a href=&quot;fts3#termprefix&quot;&gt;префиксных запросов&lt;/a&gt; в двух случаях. Если запрос предназначен для префикса из N байтов, то индекс префикса, созданный с помощью &amp;laquo;prefix = N&amp;raquo;, обеспечивает лучшую оптимизацию. Или, если индекс &amp;laquo;prefix = N&amp;raquo; недоступен, вместо него можно использовать индекс &amp;laquo;prefix = N + 1&amp;raquo;. Использование индекса &amp;laquo;prefix = N + 1&amp;raquo; менее эффективно, чем индекс &amp;laquo;prefix = N&amp;raquo;, но лучше, чем отсутствие индекса префикса вообще.</target>
        </trans-unit>
        <trans-unit id="f58acbef3b4f1545b36db43fdb7aa3248226ddc3" translate="yes" xml:space="preserve">
          <source>Prefix query</source>
          <target state="translated">Префиксный запрос</target>
        </trans-unit>
        <trans-unit id="d876a9e47626f4666efcfc69bdf4c50fcc426b9e" translate="yes" xml:space="preserve">
          <source>Prefix search in FTS3 is much more efficient.</source>
          <target state="translated">Префиксный поиск в FTS3 намного эффективнее.</target>
        </trans-unit>
        <trans-unit id="68a57fd3726c085ce337dc259dc3b2499a35efce" translate="yes" xml:space="preserve">
          <source>Preliminaries</source>
          <target state="translated">Preliminaries</target>
        </trans-unit>
        <trans-unit id="f3d20f83dbeeb1d79306958dea533c43146bb29c" translate="yes" xml:space="preserve">
          <source>Prepare Flags</source>
          <target state="translated">Приготовить флаги</target>
        </trans-unit>
        <trans-unit id="d5f65540d8f04f5669bf0a7783fb7256d5f3309f" translate="yes" xml:space="preserve">
          <source>Prepared Statement Object</source>
          <target state="translated">Объект готового заявления</target>
        </trans-unit>
        <trans-unit id="d84580c0a3c076e6a6095c0d8c0427ccdaa13d1e" translate="yes" xml:space="preserve">
          <source>Prepared Statement Scan Status</source>
          <target state="translated">Статус сканирования готовых заявлений</target>
        </trans-unit>
        <trans-unit id="1037ef270384cfd9be096004017447826d2cb2f5" translate="yes" xml:space="preserve">
          <source>Prepared Statement Scan Status Opcodes</source>
          <target state="translated">Готовые заявления Статус сканирования Опкоды</target>
        </trans-unit>
        <trans-unit id="2f5da103100b3440f26c60eb3e05807f62717d70" translate="yes" xml:space="preserve">
          <source>Prepared Statement Status</source>
          <target state="translated">Статус готового заявления</target>
        </trans-unit>
        <trans-unit id="213d6f218c41a8dc480fb564c77564038e40e839" translate="yes" xml:space="preserve">
          <source>Prepend as many &quot;0&quot; characters to numeric substitutions as necessary to expand the value out to the specified width. If the width field is omitted, then this flag is a no-op.</source>
          <target state="translated">Подготовьте к числовым подстановкам столько символов &quot;0&quot;,сколько необходимо для расширения значения до заданной ширины.Если поле &quot;Ширина&quot; опущено,то этот флаг является нулевым.</target>
        </trans-unit>
        <trans-unit id="07ea5425dab39a1ce6090bfaba72b208d8a2bb32" translate="yes" xml:space="preserve">
          <source>Prepend the &quot;&lt;code&gt;file:&lt;/code&gt;&quot; scheme.</source>
          <target state="translated">Добавьте схему &amp;laquo; &lt;code&gt;file:&lt;/code&gt; &amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="b5b2c6aa0c741177b3341a9cac682f0503cc7181" translate="yes" xml:space="preserve">
          <source>Pretend that the single row just extracted is the only row in the recursive table and run the recursive-select, adding all results to the queue.</source>
          <target state="translated">Представьте,что только что извлеченная единственная строка в рекурсивной таблице,и запустите рекурсивный выбор,добавив все результаты в очередь.</target>
        </trans-unit>
        <trans-unit id="e96fea52df5eb0d7ea088eb0523f5fd6be20645f" translate="yes" xml:space="preserve">
          <source>Prev</source>
          <target state="translated">Prev</target>
        </trans-unit>
        <trans-unit id="d011a785f80d4ac2978260fd4baeb9a488339607" translate="yes" xml:space="preserve">
          <source>Prevent journal file overflows on huge transactions.</source>
          <target state="translated">Предотвращение переполнения файлов журнала на огромных транзакциях.</target>
        </trans-unit>
        <trans-unit id="15aff2aaf0be53526cd90b44a8f7faa67462af63" translate="yes" xml:space="preserve">
          <source>Primary location: &lt;a href=&quot;https://www.sqlite.org/docsrc&quot;&gt;https://www.sqlite.org/docsrc&lt;/a&gt;</source>
          <target state="translated">Основное расположение: &lt;a href=&quot;https://www.sqlite.org/docsrc&quot;&gt;https://www.sqlite.org/docsrc&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bb559fe38e423e3bb19de0649fe3fd5b6b237723" translate="yes" xml:space="preserve">
          <source>Primary location: &lt;a href=&quot;https://www.sqlite.org/sqllogictest&quot;&gt;https://www.sqlite.org/sqllogictest&lt;/a&gt;</source>
          <target state="translated">Основное расположение: &lt;a href=&quot;https://www.sqlite.org/sqllogictest&quot;&gt;https://www.sqlite.org/sqllogictest&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="40da77fe99b4c2e0002b4b5a88b9bdf5b5ffd788" translate="yes" xml:space="preserve">
          <source>Primary location: &lt;a href=&quot;https://www.sqlite.org/src&quot;&gt;https://www.sqlite.org/src&lt;/a&gt;</source>
          <target state="translated">Основное расположение: &lt;a href=&quot;https://www.sqlite.org/src&quot;&gt;https://www.sqlite.org/src&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="72c44b5ab0d08449343e1c11f7db59a0baee6a06" translate="yes" xml:space="preserve">
          <source>Primary location: &lt;a href=&quot;https://www.sqlite.org/th3&quot;&gt;https://www.sqlite.org/th3&lt;/a&gt;</source>
          <target state="translated">Основное расположение: &lt;a href=&quot;https://www.sqlite.org/th3&quot;&gt;https://www.sqlite.org/th3&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="284d8db03255f327420e4917415f7de011fcda53" translate="yes" xml:space="preserve">
          <source>Primary location: &lt;a href=&quot;https://www.sqlite.org/th3private&quot;&gt;https://www.sqlite.org/th3private&lt;/a&gt;</source>
          <target state="translated">Основное расположение: &lt;a href=&quot;https://www.sqlite.org/th3private&quot;&gt;https://www.sqlite.org/th3private&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="12c6ce30d8dde9c30a0548e43a1a65f2399c3ac8" translate="yes" xml:space="preserve">
          <source>Primary result code symbolic names are of the form &quot;SQLITE_XXXXXX&quot; where XXXXXX is a sequence of uppercase alphabetic characters. Extended result code names are of the form &quot;SQLITE_XXXXXX_YYYYYYY&quot; where the XXXXXX part is the corresponding primary result code and the YYYYYYY is an extension that further classifies the result code.</source>
          <target state="translated">Код первичного результата-символические имена формы &quot;SQLITE_XXXXXX&quot;,где XXXXXX-это последовательность заглавных алфавитных символов.Расширенные кодовые имена результата относятся к форме &quot;SQLITE_XXXXXX_YYYYYYY&quot;,где XXXXXX часть является соответствующим первичным кодом результата,а YYYYYY является расширением,которое далее классифицирует код результата.</target>
        </trans-unit>
        <trans-unit id="4fda803b9a957798a3e6c9099105e126c5e73e36" translate="yes" xml:space="preserve">
          <source>Primary versus extended result codes</source>
          <target state="translated">Первичный и расширенный коды результатов</target>
        </trans-unit>
        <trans-unit id="3b2d52029dad08f51a816bff4a2b1ace042995a8" translate="yes" xml:space="preserve">
          <source>Print the offending SQL statement when an error occurs.</source>
          <target state="translated">При возникновении ошибки выведите на печать оскорбительный SQL-оператор.</target>
        </trans-unit>
        <trans-unit id="93863d358af110c5080e64cc1cfc5d8749e0490f" translate="yes" xml:space="preserve">
          <source>Prior to &lt;a href=&quot;https://sqlite.org/releaselog/3_8_0.html&quot;&gt;version 3.8.0&lt;/a&gt; (2013-08-26), SQLite always used the &quot;Nearest Neighbor&quot; or &quot;NN&quot; heuristic when searching for the best query plan. The NN heuristic makes a single traversal of the graph, always choosing the lowest-cost arc as the next step. The NN heuristic works surprisingly well in most cases. And NN is fast, so that SQLite is able to quickly find good plans for even large 64-way joins. In contrast, other SQL database engines that do more extensive searching tend to bog down when the number of tables in a join goes above 10 or 15.</source>
          <target state="translated">До &lt;a href=&quot;https://sqlite.org/releaselog/3_8_0.html&quot;&gt;версии 3.8.0&lt;/a&gt; (2013-08-26) SQLite всегда использовала эвристику &amp;laquo;Ближайший сосед&amp;raquo; или &amp;laquo;NN&amp;raquo; при поиске лучшего плана запроса. Эвристика NN выполняет однократный обход графа, всегда выбирая дугу с наименьшей стоимостью в качестве следующего шага. В большинстве случаев эвристика NN работает на удивление хорошо. NN работает быстро, так что SQLite может быстро найти хорошие планы даже для больших 64-сторонних соединений. Напротив, другие механизмы баз данных SQL, которые выполняют более обширный поиск, имеют тенденцию останавливаться, когда количество таблиц в объединении превышает 10 или 15.</target>
        </trans-unit>
        <trans-unit id="0cbead769cfd094dac2d1d702814135203e88038" translate="yes" xml:space="preserve">
          <source>Prior to SQLite 3.20.0 (2017-08-01) all date/time functions were always considered non-deterministic. The ability for date/time functions to be deterministic sometimes and non-deterministic at other times, depending on their arguments, was added for the 3.20.0 release.</source>
          <target state="translated">До SQLite 3.20.0 (2017-08-01)все функции даты/времени всегда считались недетерминированными.В версии 3.20.0 была добавлена способность функций даты/времени быть детерминированными иногда и недетерминированными в другое время,в зависимости от их аргументов.</target>
        </trans-unit>
        <trans-unit id="6c7f8cc84bc5292827563b13ba75248881d97140" translate="yes" xml:space="preserve">
          <source>Prior to SQLite 3.7.15 (2012-12-12), a subquery in the FROM clause would be either flattened into the outer query, or else the subquery would be run to completion before the outer query started, the result set from the subquery would be stored in a transient table, and then the transient table would be used in the outer query. Newer versions of SQLite have a third option, which is to implement the subquery using a co-routine.</source>
          <target state="translated">До SQLite 3.7.15 (2012-12-12)подзапрос в пункте FROM либо сплющивался во внешний запрос,либо подзапрос выполнялся до начала внешнего запроса,набор результатов из подзапроса хранился в переходной таблице,а затем переходная таблица использовалась во внешнем запросе.В более новых версиях SQLite есть третий вариант,который заключается в реализации подзапроса с использованием ко-маршрутизации.</target>
        </trans-unit>
        <trans-unit id="a720aafd2afa8c2c385472fc2e648bd2ccdf321e" translate="yes" xml:space="preserve">
          <source>Prior to SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_11_0.html&quot;&gt;version 3.11.0&lt;/a&gt; (2016-02-15), the arguments to fts3_tokenzer() could be literal strings or BLOBs. They did not have to be &lt;a href=&quot;lang_expr#varparam&quot;&gt;bound parameters&lt;/a&gt;. But that could lead to security problems in the event of an SQL injection. Hence, the legacy behavior is now disabled by default. But the old legacy behavior can be enabled, for backwards compatibility in applications that really need it, by calling &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigenablefts3tokenizer&quot;&gt;SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER&lt;/a&gt;,1,0).</source>
          <target state="translated">До версии SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_11_0.html&quot;&gt;3.11.0&lt;/a&gt; (15.02.2016) аргументы функции fts3_tokenzer () могли быть буквальными строками или большими двоичными объектами. Им не нужно было &lt;a href=&quot;lang_expr#varparam&quot;&gt;связывать параметры&lt;/a&gt; . Но это может привести к проблемам с безопасностью в случае SQL-инъекции. Следовательно, устаревшее поведение по умолчанию отключено. Но старое устаревшее поведение можно включить для обратной совместимости в приложениях, которые действительно в нем нуждаются, путем вызова &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config&lt;/a&gt; (db, &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigenablefts3tokenizer&quot;&gt;SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER&lt;/a&gt; , 1,0).</target>
        </trans-unit>
        <trans-unit id="51d8edb11a84377ed9b294770763b3964473b7ee" translate="yes" xml:space="preserve">
          <source>Prior to SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_6_17.html&quot;&gt;version 3.6.17&lt;/a&gt; (2009-08-10), the virtual table mechanism assumes that each &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; kept its own copy of the database schema. Hence, the virtual table mechanism could not be used in a database that has &lt;a href=&quot;sharedcache&quot;&gt;shared cache mode&lt;/a&gt; enabled. The &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module()&lt;/a&gt; interface would return an error if &lt;a href=&quot;sharedcache&quot;&gt;shared cache mode&lt;/a&gt; is enabled. That restriction was relaxed beginning with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_6_17.html&quot;&gt;version 3.6.17&lt;/a&gt;.</source>
          <target state="translated">До версии SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_6_17.html&quot;&gt;3.6.17&lt;/a&gt; ( 10.08.2009 ) механизм виртуальных таблиц предполагает, что каждое &lt;a href=&quot;c3ref/sqlite3&quot;&gt;соединение с базой данных&lt;/a&gt; хранит свою собственную копию схемы базы данных. Следовательно, механизм виртуальной таблицы не может использоваться в базе данных, в которой включен &lt;a href=&quot;sharedcache&quot;&gt;режим общего кэша&lt;/a&gt; . Интерфейс &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module ()&lt;/a&gt; вернет ошибку, если включен &lt;a href=&quot;sharedcache&quot;&gt;режим общего кеша&lt;/a&gt; . Это ограничение было ослаблено, начиная с &lt;a href=&quot;https://sqlite.org/releaselog/3_6_17.html&quot;&gt;версии&lt;/a&gt; SQLite 3.6.17 .</target>
        </trans-unit>
        <trans-unit id="33d0fd70a8f55e9f98c0c7adf04301e981d0c322" translate="yes" xml:space="preserve">
          <source>Prior to SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_6_18.html&quot;&gt;version 3.6.18&lt;/a&gt; (2009-09-11), recursive triggers were not supported. The behavior of SQLite was always as if this pragma was set to OFF. Support for recursive triggers was added in version 3.6.18 but was initially turned OFF by default, for compatibility. Recursive triggers may be turned on by default in future versions of SQLite.</source>
          <target state="translated">До версии SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_6_18.html&quot;&gt;3.6.18&lt;/a&gt; (11 сентября 2009 г. ) рекурсивные триггеры не поддерживались. Поведение SQLite всегда было таким, как если бы эта прагма была отключена. Поддержка рекурсивных триггеров была добавлена ​​в версии 3.6.18, но изначально была отключена по умолчанию для совместимости. Рекурсивные триггеры могут быть включены по умолчанию в будущих версиях SQLite.</target>
        </trans-unit>
        <trans-unit id="a28758e140ed243892fd7015e84c9739d352fdbe" translate="yes" xml:space="preserve">
          <source>Prior to SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_6_18.html&quot;&gt;version 3.6.18&lt;/a&gt; (2009-09-11), triggers were not recursive and so this limit was meaningless. Beginning with version 3.6.18, recursive triggers were supported but had to be explicitly enabled using the &lt;a href=&quot;pragma#pragma_recursive_triggers&quot;&gt;PRAGMA recursive_triggers&lt;/a&gt; statement. Beginning with &lt;a href=&quot;https://sqlite.org/releaselog/3_7_0.html&quot;&gt;version 3.7.0&lt;/a&gt; (2009-09-11), recursive triggers are enabled by default but can be manually disabled using &lt;a href=&quot;pragma#pragma_recursive_triggers&quot;&gt;PRAGMA recursive_triggers&lt;/a&gt;. The SQLITE_MAX_TRIGGER_DEPTH is only meaningful if recursive triggers are enabled.</source>
          <target state="translated">До версии SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_6_18.html&quot;&gt;3.6.18&lt;/a&gt; (11 сентября 2009 г. ) триггеры не были рекурсивными, поэтому этот предел не имел смысла. Начиная с версии 3.6.18, рекурсивные триггеры поддерживались, но их нужно было явно включить с помощью &lt;a href=&quot;pragma#pragma_recursive_triggers&quot;&gt;оператора PRAGMA recursive_triggers&lt;/a&gt; . Начиная с &lt;a href=&quot;https://sqlite.org/releaselog/3_7_0.html&quot;&gt;версии 3.7.0&lt;/a&gt; (2009-09-11) рекурсивные триггеры включены по умолчанию, но их можно отключить вручную с помощью &lt;a href=&quot;pragma#pragma_recursive_triggers&quot;&gt;PRAGMA recursive_triggers&lt;/a&gt; . SQLITE_MAX_TRIGGER_DEPTH имеет смысл, только если включены рекурсивные триггеры.</target>
        </trans-unit>
        <trans-unit id="534f30ad3bfba01b49cf3bf01218d9cf22140413" translate="yes" xml:space="preserve">
          <source>Prior to SQLite version 3.17.0, the session extension only worked with &lt;a href=&quot;rowidtable&quot;&gt;rowid tables&lt;/a&gt;, not &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables. As of 3.17.0, both rowid and WITHOUT ROWID tables are supported.</source>
          <target state="translated">До версии SQLite 3.17.0 расширение сеанса работало только с &lt;a href=&quot;rowidtable&quot;&gt;таблицами &lt;/a&gt;&lt;a href=&quot;withoutrowid&quot;&gt;rowid&lt;/a&gt; , а не БЕЗ таблиц ROWID . Начиная с версии 3.17.0, поддерживаются таблицы rowid и БЕЗ ROWID.</target>
        </trans-unit>
        <trans-unit id="8ca3ddf5fd526ae6f9a1aaa722828cf40f2bf92a" translate="yes" xml:space="preserve">
          <source>Prior to SQLite version 3.3.14, a sector size of 512 bytes was assumed in all cases. There was a compile-time option to change this but the code had never been tested with a larger value. The 512 byte sector assumption seemed reasonable since until very recently all disk drives used a 512 byte sector internally. However, there has recently been a push to increase the sector size of disks to 4096 bytes. Also the sector size for flash memory is usually larger than 512 bytes. For these reasons, versions of SQLite beginning with 3.3.14 have a method in the OS interface layer that interrogates the underlying filesystem to find the true sector size. As currently implemented (version 3.5.0) this method still returns a hard-coded value of 512 bytes, since there is no standard way of discovering the true sector size on either Unix or Windows. But the method is available for embedded device manufacturers to tweak according to their own needs. And we have left open the possibility of filling in a more meaningful implementation on Unix and Windows in the future.</source>
          <target state="translated">До версии SQLite 3.3.14 во всех случаях предполагался размер сектора 512 байт.Это можно было изменить во время компиляции,но код никогда не тестировался с большим значением.Предположение о 512-байтном секторе казалось разумным,так как до недавнего времени все диски использовали 512-байтный сектор внутри.Тем не менее,в последнее время было принято решение увеличить размер сектора дисков до 4096 байт.Также размер сектора для флэш-памяти обычно больше 512 байт.По этим причинам версии SQLite,начиная с версии 3.3.14,имеют метод на уровне интерфейса операционной системы,который опрашивает базовую файловую систему,чтобы найти истинный размер сектора.Как и в настоящее время (версия 3.5.0),этот метод все еще возвращает жестко закодированное значение в 512 байт,так как не существует стандартного способа определения истинного размера сектора ни в Unix,ни в Windows.Но этот метод доступен производителям встраиваемых устройств для настройки в соответствии с их собственными потребностями.И мы оставили открытой возможность в будущем заполнить более осмысленную реализацию на Unix и Windows.</target>
        </trans-unit>
        <trans-unit id="d9c2ee7b5aac6da179c8f578b8285aa5c54f4524" translate="yes" xml:space="preserve">
          <source>Prior to SQLite version 3.7.10, the Windows OS interface layer called the system malloc() and free() directly when converting filenames between the UTF-8 encoding used by SQLite and whatever filename encoding is used by the particular Windows installation. Memory allocation errors were detected, but they were reported back as &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_CANTOPEN&lt;/a&gt; or &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_IOERR&lt;/a&gt; rather than &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOMEM&lt;/a&gt;.</source>
          <target state="translated">До версии SQLite 3.7.10 уровень интерфейса ОС Windows называл систему malloc () и free () непосредственно при преобразовании имен файлов между кодировкой UTF-8, используемой SQLite, и любой кодировкой имени файла, используемой конкретной установкой Windows. Были обнаружены ошибки выделения памяти, но они были возвращены как &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_CANTOPEN&lt;/a&gt; или &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_IOERR,&lt;/a&gt; а не как &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOMEM&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="91089ffc77affdb7ae59f739dbaf9014a293f340" translate="yes" xml:space="preserve">
          <source>Prior to SQLite version 3.7.10, the Windows OS interface layer called the system malloc() and free() directly when converting filenames between the UTF-8 encoding used by SQLite and whatever filename encoding is used by the particular Windows installation. Memory allocation errors were detected, but they were reported back as &lt;a href=&quot;../rescode#cantopen&quot;&gt;SQLITE_CANTOPEN&lt;/a&gt; or &lt;a href=&quot;../rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt; rather than &lt;a href=&quot;../rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt;.</source>
          <target state="translated">До версии SQLite 3.7.10 уровень интерфейса ОС Windows называл систему malloc () и free () непосредственно при преобразовании имен файлов между кодировкой UTF-8, используемой SQLite, и любой кодировкой имени файла, используемой конкретной установкой Windows. Были обнаружены ошибки выделения памяти, но они были возвращены как &lt;a href=&quot;../rescode#cantopen&quot;&gt;SQLITE_CANTOPEN&lt;/a&gt; или &lt;a href=&quot;../rescode#ioerr&quot;&gt;SQLITE_IOERR,&lt;/a&gt; а не как &lt;a href=&quot;../rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4f00bebae92fba462c0a2ff1a68401159dfc1bce" translate="yes" xml:space="preserve">
          <source>Prior to SQLite version 3.8.2 (2013-12-06), casting a REAL value greater than +9223372036854775807.0 into an integer resulted in the most negative integer, -9223372036854775808. This behavior was meant to emulate the behavior of x86/x64 hardware when doing the equivalent cast.</source>
          <target state="translated">До версии SQLite 3.8.2 (2013-12-06),приведение значения REAL больше +9223372036854775807.0 к целому числу приводило к наибольшему отрицательному числу,-9223372036854775808.Такое поведение предназначалось для эмуляции поведения аппаратного обеспечения x86/x64 при эквивалентном приведении.</target>
        </trans-unit>
        <trans-unit id="a1634472b77cd282aba3425a6cf5a2a4d268772c" translate="yes" xml:space="preserve">
          <source>Prior to each check-in to the SQLite source tree, developers typically run a subset (called &quot;veryquick&quot;) of the Tcl tests consisting of about 248.5 thousand test cases. The veryquick tests include most tests other than the anomaly, fuzz, and soak tests. The idea behind the veryquick tests are that they are sufficient to catch most errors, but also run in only a few minutes instead of a few hours.</source>
          <target state="translated">Перед каждой регистрацией в дереве исходных текстов SQLite разработчики,как правило,запускают подмножество (называемое &quot;veryquick&quot;)тестов Tcl,состоящее примерно из 248.5 тысяч тестовых случаев.Очень быстрые тесты включают в себя большинство тестов,кроме аномалий,нечеткости и замачивания.Идея,лежащая в основе очень быстрых тестов,заключается в том,что они достаточны,чтобы перехватить большинство ошибок,но и запускаются всего за несколько минут,а не за несколько часов.</target>
        </trans-unit>
        <trans-unit id="ce5fd27df1123f4d155915fc1d5725287e09a7ea" translate="yes" xml:space="preserve">
          <source>Prior to making any changes to the database file, SQLite first creates a separate rollback journal file and writes into the rollback journal the original content of the database pages that are to be altered. The idea behind the rollback journal is that it contains all information needed to restore the database back to its original state.</source>
          <target state="translated">Перед тем,как внести изменения в файл базы данных,SQLite сначала создает отдельный файл журнала отката и записывает в него исходное содержимое страниц базы данных,которые должны быть изменены.Идея журнала отката заключается в том,что он содержит всю информацию,необходимую для восстановления исходного состояния БД.</target>
        </trans-unit>
        <trans-unit id="5e201518d0d186ad7cdf7483565006fe761fd040" translate="yes" xml:space="preserve">
          <source>Prior to making changes to the database file itself, we must obtain an exclusive lock on the database file. Obtaining an exclusive lock is really a two-step process. First SQLite obtains a &quot;pending&quot; lock. Then it escalates the pending lock to an exclusive lock.</source>
          <target state="translated">Перед внесением изменений в сам файл базы данных мы должны получить эксклюзивную блокировку на файле базы данных.Получение эксклюзивной блокировки-это действительно двухэтапный процесс.Первый SQLite получает &quot;отложенную&quot; блокировку.Затем он перевешивает отложенную блокировку в эксклюзивную.</target>
        </trans-unit>
        <trans-unit id="3f85c53dbe23e0808bcb91d75d8ad07e4c7bc69c" translate="yes" xml:space="preserve">
          <source>Prior to version 3.26.0 (2018-12-01), FOREIGN KEY references to a table that is renamed were only edited if the &lt;a href=&quot;pragma#pragma_foreign_keys&quot;&gt;PRAGMA foreign_keys=ON&lt;/a&gt;, or in other words if &lt;a href=&quot;foreignkeys&quot;&gt;foreign key constraints&lt;/a&gt; were begin enforced. With &lt;a href=&quot;pragma#pragma_foreign_keys&quot;&gt;PRAGMA foreign_keys=OFF&lt;/a&gt;, FOREIGN KEY constraints would not be changed when the table that the foreign key referred to (the &quot;&lt;a href=&quot;foreignkeys#parentchild&quot;&gt;parent table&lt;/a&gt;&quot;) was renamed. Beginning with version 3.26.0, FOREIGN KEY constraints are always converted when a table is renamed, unless the &lt;a href=&quot;pragma#pragma_legacy_alter_table&quot;&gt;PRAGMA legacy_alter_table=ON&lt;/a&gt; setting is engaged. The following table summaries the difference:</source>
          <target state="translated">До версии 3.26.0 (2018-12-01) ссылки FOREIGN KEY на переименованную таблицу редактировались только в том случае, если &lt;a href=&quot;pragma#pragma_foreign_keys&quot;&gt;PRAGMA foreign_keys = ON&lt;/a&gt; , или, другими словами, если начали применяться &lt;a href=&quot;foreignkeys&quot;&gt;ограничения внешнего ключа&lt;/a&gt; . Если &lt;a href=&quot;pragma#pragma_foreign_keys&quot;&gt;PRAGMA foreign_keys = OFF&lt;/a&gt; , ограничения FOREIGN KEY не будут изменены при переименовании таблицы, на которую ссылается внешний ключ (&amp;laquo; &lt;a href=&quot;foreignkeys#parentchild&quot;&gt;родительская таблица&lt;/a&gt; &amp;raquo;). Начиная с версии 3.26.0, ограничения FOREIGN KEY всегда преобразуются при переименовании таблицы, если не &lt;a href=&quot;pragma#pragma_legacy_alter_table&quot;&gt;задействован параметр PRAGMA legacy_alter_table = ON&lt;/a&gt; . В следующей таблице приведены различия:</target>
        </trans-unit>
        <trans-unit id="5f15493198f102fc11171baf7abf0e0dbb2b1e4b" translate="yes" xml:space="preserve">
          <source>Prior to version 3.5.0 the &lt;a href=&quot;c3ref/release_memory&quot;&gt;sqlite3_release_memory()&lt;/a&gt; function would try to reclaim memory from all database connections in the same thread as the sqlite3_release_memory() call. Beginning with version 3.5.0, the sqlite3_release_memory() function will attempt to reclaim memory from all database connections in all threads.</source>
          <target state="translated">До версии 3.5.0 функция &lt;a href=&quot;c3ref/release_memory&quot;&gt;sqlite3_release_memory ()&lt;/a&gt; пыталась освободить память из всех подключений к базе данных в том же потоке, что и вызов sqlite3_release_memory (). Начиная с версии 3.5.0, функция sqlite3_release_memory () будет пытаться освободить память из всех подключений к базе данных во всех потоках.</target>
        </trans-unit>
        <trans-unit id="4167592bfe9ab2523a8fde6561d95f830a107410" translate="yes" xml:space="preserve">
          <source>Prior to version 3.5.0 the &lt;a href=&quot;c3ref/soft_heap_limit&quot;&gt;sqlite3_soft_heap_limit()&lt;/a&gt; set an upper bound on heap memory usage for all database connections within a single thread. Each thread could have its own heap limit. Beginning in version 3.5.0, there is a single heap limit for the entire process. This seems more restrictive (one limit as opposed to many) but in practice it is what most users want.</source>
          <target state="translated">До версии 3.5.0 &lt;a href=&quot;c3ref/soft_heap_limit&quot;&gt;sqlite3_soft_heap_limit ()&lt;/a&gt; устанавливал верхнюю границу использования памяти кучи для всех подключений к базе данных в одном потоке. У каждого потока может быть свой предел кучи. Начиная с версии 3.5.0, существует единственное ограничение кучи для всего процесса. Это кажется более строгим (одно ограничение вместо многих), но на практике это то, чего хочет большинство пользователей.</target>
        </trans-unit>
        <trans-unit id="fc681e809e94e340265ecee10f223e6915cced6a" translate="yes" xml:space="preserve">
          <source>Prior to version 3.5.0, the &lt;a href=&quot;c3ref/enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache()&lt;/a&gt; API would enable and disable the shared cache feature for all connections within a single thread - the same thread from which the sqlite3_enable_shared_cache() routine was called. Database connections that used the shared cache were restricted to running in the same thread in which they were opened. Beginning with version 3.5.0, the sqlite3_enable_shared_cache() applies to all database connections in all threads within the process. Now database connections running in separate threads can share a cache. And database connections that use shared cache can migrate from one thread to another.</source>
          <target state="translated">До версии 3.5.0 API &lt;a href=&quot;c3ref/enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache ()&lt;/a&gt; мог включать и отключать функцию общего кеширования для всех соединений в одном потоке - том же потоке, из которого вызывалась процедура sqlite3_enable_shared_cache (). Подключения к базе данных, которые использовали общий кеш, были ограничены работой в том же потоке, в котором они были открыты. Начиная с версии 3.5.0, sqlite3_enable_shared_cache () применяется ко всем соединениям с базой данных во всех потоках внутри процесса. Теперь соединения с базой данных, выполняемые в отдельных потоках, могут совместно использовать кеш. А подключения к базе данных, которые используют общий кеш, могут переноситься из одного потока в другой.</target>
        </trans-unit>
        <trans-unit id="d828632471991da7903c0c2be934633680ad57e8" translate="yes" xml:space="preserve">
          <source>Process A now tries to write to the database. But process A's view of the database content is now obsolete because process B has modified the database file after process A read from it. Hence process A gets an SQLITE_BUSY_SNAPSHOT error.</source>
          <target state="translated">Процесс A теперь пытается записать в базу данных.Но представление процесса A о содержимом базы данных теперь устарело,потому что процесс B изменил файл базы данных после того,как процесс A прочитал из него.Поэтому процесс A получает ошибку SQLITE_BUSY_SNAPSHOT.</target>
        </trans-unit>
        <trans-unit id="6588c47b29127d1f98a87c238369e743b0e77d94" translate="yes" xml:space="preserve">
          <source>Process A starts a read transaction on the database and does one or more SELECT statement. Process A keeps the transaction open.</source>
          <target state="translated">Процесс A запускает прочитанную транзакцию по базе данных и выполняет один или несколько SELECT-запросов.Процесс A держит транзакцию открытой.</target>
        </trans-unit>
        <trans-unit id="7e082f5417cd4ab89e9c56b231bce953e66b35a9" translate="yes" xml:space="preserve">
          <source>Process B updates the database, changing values previous read by process A.</source>
          <target state="translated">Процесс B обновляет базу данных,изменяя значения,ранее прочитанные процессом A.</target>
        </trans-unit>
        <trans-unit id="ee0914d299e6e7430a22ed0faafffc12d302d567" translate="yes" xml:space="preserve">
          <source>Productize and officially support the group_concat() SQL function.</source>
          <target state="translated">Производить и официально поддерживать SQL функцию group_concat().</target>
        </trans-unit>
        <trans-unit id="9257f2cbe973bd89967c512a0ab4ef3a71be8dcc" translate="yes" xml:space="preserve">
          <source>Profile guided optimization (PGO) is not helpful with SQLite. PGO results in binaries that are about 1% larger and about 0.33% slower.</source>
          <target state="translated">Оптимизация,ориентированная на профили (PGO),не помогает в работе с SQLite.В результате PGO получаются двоичные файлы,которые примерно на 1% больше и примерно на 0.33% медленнее.</target>
        </trans-unit>
        <trans-unit id="b46994e8cc3c2683acbfd969c84c88b83b02d9c0" translate="yes" xml:space="preserve">
          <source>Profiling indicates that for most systems and in most circumstances SQLite spends most of its time doing disk I/O. It follows then that anything we can do to reduce the amount of disk I/O will likely have a large positive impact on the performance of SQLite. This section describes some of the techniques used by SQLite to try to reduce the amount of disk I/O to a minimum while still preserving atomic commit.</source>
          <target state="translated">Профилирование показывает,что для большинства систем и в большинстве случаев SQLite тратит большую часть своего времени на дисковый ввод/вывод.Из этого следует,что все,что мы можем сделать для уменьшения количества дисковых операций ввода-вывода,скорее всего,окажет большое положительное влияние на производительность SQLite.В этом разделе описаны некоторые методы,используемые SQLite для того,чтобы попытаться свести к минимуму количество дисковых операций ввода-вывода,сохраняя при этом атомные коммиты.</target>
        </trans-unit>
        <trans-unit id="9d68007b0763cb230f9034ec96f52b39d03ad630" translate="yes" xml:space="preserve">
          <source>Program</source>
          <target state="translated">Program</target>
        </trans-unit>
        <trans-unit id="6bc5295aed74aa8af8bf9a74f722f2706e580d3c" translate="yes" xml:space="preserve">
          <source>Programmers are cautioned not to use the two exceptions described in the previous bullets. We emphasize that they exist only so that old and ill-formed SQL statements will run correctly. Future versions of SQLite might raise errors instead of accepting the malformed statements covered by the exceptions above.</source>
          <target state="translated">Программистов предостерегают от использования двух исключений,описанных в предыдущих пулях.Подчеркнем,что они существуют только для того,чтобы старые и плохо оформленные SQL-операторы работали корректно.Будущие версии SQLite могут привести к ошибкам вместо того,чтобы принимать некорректные операторы,на которые распространяются вышеописанные исключения.</target>
        </trans-unit>
        <trans-unit id="442f2f1b223aedc9d27d672e9d91f49a3b27fb5b" translate="yes" xml:space="preserve">
          <source>Programmers can force SQLite to use a particular loop nesting order for a join by using the CROSS JOIN operator instead of just JOIN, INNER JOIN, NATURAL JOIN, or a &quot;,&quot; join. Though CROSS JOINs are commutative in theory, SQLite chooses to never reorder the tables in a CROSS JOIN. Hence, the left table of a CROSS JOIN will always be in an outer loop relative to the right table.</source>
          <target state="translated">Программисты могут заставить SQLite использовать для соединения определенный порядок вложенности в цикл,используя оператор CROSS JOIN вместо простого JOIN,INNER JOIN,NATURAL JOIN или &quot;,&quot; join.Несмотря на то,что CROSS JOIN в теории является коммутативным,SQLite предпочитает никогда не переупорядочивать таблицы в CROSS JOIN.Следовательно,левая таблица CROSS JOIN всегда будет находиться во внешней петле относительно правой таблицы.</target>
        </trans-unit>
        <trans-unit id="9ecd00ed19c9aa2f215c5b5e8453037ffd17fc89" translate="yes" xml:space="preserve">
          <source>Programming Interfaces</source>
          <target state="translated">Программирующие интерфейсы</target>
        </trans-unit>
        <trans-unit id="1c8b4bfbf1e2ec54cc62ffa3332992d5ae9a4350" translate="yes" xml:space="preserve">
          <source>Programming Loadable Extensions</source>
          <target state="translated">Программирование Загрузочные удлинители</target>
        </trans-unit>
        <trans-unit id="19ca1fa808a68639f1670f7213bf267471fdbd20" translate="yes" xml:space="preserve">
          <source>Programs contain a single instance of this opcode as the very first opcode.</source>
          <target state="translated">Программы содержат один экземпляр этого опкода в качестве самого первого опкода.</target>
        </trans-unit>
        <trans-unit id="7b85e7edf23f7121981c9a7f81acf2f88e25d897" translate="yes" xml:space="preserve">
          <source>Prohibit the use of SQL functions inside triggers, views, CHECK constraints, DEFAULT clauses, expression indexes, partial indexes, or generated columns unless those functions are tagged with &lt;a href=&quot;#sqliteinnocuous&quot;&gt;SQLITE_INNOCUOUS&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="836cdbe091f8e6d2e0a3bc0953580f5b61d80d1b" translate="yes" xml:space="preserve">
          <source>Prohibit the use of SQL functions inside triggers, views, CHECK constraints, DEFAULT clauses, expression indexes, partial indexes, or generated columns unless those functions are tagged with &lt;a href=&quot;c_deterministic#sqliteinnocuous&quot;&gt;SQLITE_INNOCUOUS&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4131fb0c74864c2b5168b32ce6c60e9b911d245" translate="yes" xml:space="preserve">
          <source>Prohibit the use of virtual tables inside of triggers or views unless those virtual tables are tagged with &lt;a href=&quot;#sqlitevtabinnocuous&quot;&gt;SQLITE_VTAB_INNOCUOUS&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0dd1398efbb71440f12c0472c04e04e100c1dd4b" translate="yes" xml:space="preserve">
          <source>Prohibit the use of virtual tables inside of triggers or views unless those virtual tables are tagged with &lt;a href=&quot;c_vtab_constraint_support#sqlitevtabinnocuous&quot;&gt;SQLITE_VTAB_INNOCUOUS&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b341d69d9619d4d85640d6150737c146812b7c0" translate="yes" xml:space="preserve">
          <source>Provide &lt;a href=&quot;pragma#pragfunc&quot;&gt;PRAGMA functions&lt;/a&gt; for &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt;, &lt;a href=&quot;pragma#pragma_quick_check&quot;&gt;PRAGMA quick_check&lt;/a&gt;, and &lt;a href=&quot;pragma#pragma_foreign_key_check&quot;&gt;PRAGMA foreign_key_check&lt;/a&gt;.</source>
          <target state="translated">Предоставьте &lt;a href=&quot;pragma#pragfunc&quot;&gt;функции PRAGMA&lt;/a&gt; для &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;проверки целостности PRAGMA&lt;/a&gt; , &lt;a href=&quot;pragma#pragma_quick_check&quot;&gt;quick_check PRAGMA&lt;/a&gt; и &lt;a href=&quot;pragma#pragma_foreign_key_check&quot;&gt;внешней проверки ключа PRAGMA&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7a4632572329984193ba91894b49406924b5a89d" translate="yes" xml:space="preserve">
          <source>Provide a hint to cursor P1 that it only needs to return rows that satisfy the Expr in P4. TK_REGISTER terms in the P4 expression refer to values currently held in registers. TK_COLUMN terms in the P4 expression refer to columns in the b-tree to which cursor P1 is pointing.</source>
          <target state="translated">Укажите курсору P1,что ему нужно вернуть только те строки,которые удовлетворяют параметру Expr в P4.Термины TK_REGISTER в выражении P4 относятся к значениям,которые в настоящее время хранятся в регистрах.Термины TK_COLUMN в выражении P4 относятся к столбцам в b-дереве,на которые указывает курсор P1.</target>
        </trans-unit>
        <trans-unit id="054ee0d871e7b20122b3ff23a8374fbfb871d9ca" translate="yes" xml:space="preserve">
          <source>Provide an appropriate error message when the sqlite_master table contains a CREATE TABLE AS statement. Formerly this caused either an assertion fault or null pointer dereference. Problem found by OSSFuzz on the GDAL project. Check-in &lt;a href=&quot;https://www.sqlite.org/src/info/d75e67654aa96&quot;&gt;d75e67654aa96&lt;/a&gt;</source>
          <target state="translated">Предоставьте соответствующее сообщение об ошибке, если таблица sqlite_master содержит оператор CREATE TABLE AS. Раньше это вызывало либо ошибку утверждения, либо разыменование нулевого указателя. Проблема, обнаруженная OSSFuzz в проекте GDAL. Заезд &lt;a href=&quot;https://www.sqlite.org/src/info/d75e67654aa96&quot;&gt;d75e67654aa96&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7c2fd3e74c8200bf8ab45d458d069a0c702c0cd7" translate="yes" xml:space="preserve">
          <source>Provide the &lt;a href=&quot;c3ref/c_prepare_normalize#sqlitepreparepersistent&quot;&gt;SQLITE_PREPARE_PERSISTENT&lt;/a&gt; flag for &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v3()&lt;/a&gt; and use it to limit &lt;a href=&quot;malloc#lookaside&quot;&gt;lookaside memory&lt;/a&gt; misuse by &lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt;, &lt;a href=&quot;fts5&quot;&gt;FTS5&lt;/a&gt;, and the &lt;a href=&quot;rtree&quot;&gt;R-Tree extension&lt;/a&gt;.</source>
          <target state="translated">Предоставьте флаг &lt;a href=&quot;c3ref/c_prepare_normalize#sqlitepreparepersistent&quot;&gt;SQLITE_PREPARE_PERSISTENT&lt;/a&gt; для &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v3 ()&lt;/a&gt; и используйте его для ограничения неправомерного использования дополнительной &lt;a href=&quot;malloc#lookaside&quot;&gt;памяти &lt;/a&gt;&lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt; , &lt;a href=&quot;fts5&quot;&gt;FTS5&lt;/a&gt; и &lt;a href=&quot;rtree&quot;&gt;расширением R-Tree&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0788f21345510b44c97d1a7ea9db2e84d27c5ed1" translate="yes" xml:space="preserve">
          <source>Provide the &lt;a href=&quot;lang_corefunc#sqlite_offset&quot;&gt;sqlite_offset(X)&lt;/a&gt; SQL function that returns the byte offset into the database file to the beginning of the record holding value X, when compiling with &lt;a href=&quot;compile#enable_offset_sql_func&quot;&gt;-DSQLITE_ENABLE_OFFSET_SQL_FUNC&lt;/a&gt;.</source>
          <target state="translated">Предоставьте SQL-функцию &lt;a href=&quot;lang_corefunc#sqlite_offset&quot;&gt;sqlite_offset (X),&lt;/a&gt; которая возвращает байтовое смещение в файле базы данных до начала значения хранения записи X при компиляции с &lt;a href=&quot;compile#enable_offset_sql_func&quot;&gt;-DSQLITE_ENABLE_OFFSET_SQL_FUNC&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6abc71c7c814cc2d05ebc22239e7790b1f15e917" translate="yes" xml:space="preserve">
          <source>Provide the ability to tag &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt; with new properties &lt;a href=&quot;c3ref/c_deterministic#sqliteinnocuous&quot;&gt;SQLITE_INNOCUOUS&lt;/a&gt; or &lt;a href=&quot;c3ref/c_deterministic#sqlitedirectonly&quot;&gt;SQLITE_DIRECTONLY&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcb01e4e57cfae253305eca2f9007587c22f7fb2" translate="yes" xml:space="preserve">
          <source>Provides SQL access to the &lt;a href=&quot;c3ref/status&quot;&gt;sqlite3_status64()&lt;/a&gt; and &lt;a href=&quot;c3ref/db_status&quot;&gt;sqlite3_db_status()&lt;/a&gt; interfaces.</source>
          <target state="translated">Предоставляет доступ SQL к интерфейсам &lt;a href=&quot;c3ref/status&quot;&gt;sqlite3_status64 ()&lt;/a&gt; и &lt;a href=&quot;c3ref/db_status&quot;&gt;sqlite3_db_status ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c78b408cda5c2c489b9c5ef105dac2382d881e16" translate="yes" xml:space="preserve">
          <source>Provides information about all files in a single check-in in the &lt;a href=&quot;https://fossil-scm.org/&quot;&gt;Fossil version control system&lt;/a&gt;. This virtual table is not part of the SQLite project but is included because it provides an example of how to use virtual tables and because it is used to help version control the SQLite sources.</source>
          <target state="translated">Предоставляет информацию обо всех файлах за одну регистрацию в системе &lt;a href=&quot;https://fossil-scm.org/&quot;&gt;контроля версий Fossil&lt;/a&gt; . Эта виртуальная таблица не является частью проекта SQLite, но включена, потому что она предоставляет пример того, как использовать виртуальные таблицы, и потому, что она используется для помощи в управлении версиями источников SQLite.</target>
        </trans-unit>
        <trans-unit id="3126f48ce2a68ae1473f8364444a7e563e9968c3" translate="yes" xml:space="preserve">
          <source>Provides information about the purpose and use of each page in a database file. Used in the implementation of the &lt;a href=&quot;sqlanalyze&quot;&gt;sqlite3_analyzer&lt;/a&gt; utility program.</source>
          <target state="translated">Предоставляет информацию о назначении и использовании каждой страницы в файле базы данных. Используется при реализации служебной программы &lt;a href=&quot;sqlanalyze&quot;&gt;sqlite3_analyzer&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bfec143c19b8a7da8ef2986bfdff976c6539b3dc" translate="yes" xml:space="preserve">
          <source>Pseudo-Random Number Generator</source>
          <target state="translated">Генератор псевдослучайных чисел</target>
        </trans-unit>
        <trans-unit id="52a406d334528b19ea259feaeb009e7160aeac5f" translate="yes" xml:space="preserve">
          <source>Ptrmap pages must exist in any database file which has a non-zero largest root b-tree page value at offset 52 in the database header. If the largest root b-tree page value is zero, then the database must not contain ptrmap pages.</source>
          <target state="translated">Ptrmap-страницы должны существовать в любом файле базы данных,который имеет ненулевое наибольшее значение корневой b-деревянной страницы со смещением 52 в заголовке базы данных.Если значение наибольшей корневой b-деревянной страницы равно нулю,то БД не должна содержать ptrmap-страниц.</target>
        </trans-unit>
        <trans-unit id="fe35e9945539e89cd05f704b37cf341406598782" translate="yes" xml:space="preserve">
          <source>Punctuation characters like &quot;,&quot; or &quot;==&quot; or &quot;;&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7a7b9c96916fe33cad00dfc0a31cbc73811f7fc" translate="yes" xml:space="preserve">
          <source>PureFunc</source>
          <target state="translated">PureFunc</target>
        </trans-unit>
        <trans-unit id="73f66c4bb296f02b5e558e94e1ebb8671640db19" translate="yes" xml:space="preserve">
          <source>Purging a Dirty Page</source>
          <target state="translated">Очистка грязной страницы</target>
        </trans-unit>
        <trans-unit id="a0fb821bdaf93ed9a1f1e920acfb2840eff5b153" translate="yes" xml:space="preserve">
          <source>Purpose</source>
          <target state="translated">Purpose</target>
        </trans-unit>
        <trans-unit id="865ca2a73367e4e56f98cc35dd0cc7fe25f8e129" translate="yes" xml:space="preserve">
          <source>Push the next &quot;thing&quot; onto the stack and fall through OR jump to P2, depending on whether or not there is a next &quot;thing&quot; to push.</source>
          <target state="translated">Протолкните следующую &quot;штуку&quot; на стек и проваливайте ИЛИ прыгайте в P2,в зависимости от того,есть ли следующая &quot;штука&quot;,которую нужно протолкнуть.</target>
        </trans-unit>
        <trans-unit id="0555ed5711adce7afcbd2d3235114460d585953d" translate="yes" xml:space="preserve">
          <source>Put all identifier names inside double-quotes. This is the official SQL way to escape identifier names.</source>
          <target state="translated">Поместите все имена идентификаторов в двойные кавычки.Это официальный способ SQL экранирования имен идентификаторов.</target>
        </trans-unit>
        <trans-unit id="73eb67d0cb954e65c543496b0577de68b482cb5a" translate="yes" xml:space="preserve">
          <source>Put identifier names inside [...]. This is not standard SQL, but it is what SQL Server does and so lots of programmers use this technique.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8b5818c3fdaa2a399fa24163289f33ef9912b79" translate="yes" xml:space="preserve">
          <source>Put the macro &quot;&lt;code&gt;SQLITE_EXTENSION_INIT1&lt;/code&gt;&quot; on a line by itself right after the &quot;&lt;code&gt;#include &amp;lt;sqlite3ext.h&amp;gt;&lt;/code&gt;&quot; line.</source>
          <target state="translated">Поместите макрос &amp;laquo; &lt;code&gt;SQLITE_EXTENSION_INIT1&lt;/code&gt; &amp;raquo; в отдельную строку сразу после строки &amp;laquo; &lt;code&gt;#include &amp;lt;sqlite3ext.h&amp;gt;&lt;/code&gt; &amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="36dc5ec2a56fbc19dcd1aa69b72dba8e93123b26" translate="yes" xml:space="preserve">
          <source>Put your hope in God.</source>
          <target state="translated">Положи свою надежду на Бога.</target>
        </trans-unit>
        <trans-unit id="c3156e00d3c2588c639e0d3cf6821258b05761c7" translate="yes" xml:space="preserve">
          <source>Q</source>
          <target state="translated">Q</target>
        </trans-unit>
        <trans-unit id="4ae694911c3fee4e1df954bf5e225e075d582d11" translate="yes" xml:space="preserve">
          <source>QUERY</source>
          <target state="translated">QUERY</target>
        </trans-unit>
        <trans-unit id="ebdfba68a60db859050a346ba6621b2d1c232869" translate="yes" xml:space="preserve">
          <source>Quality Management</source>
          <target state="translated">Управление качеством</target>
        </trans-unit>
        <trans-unit id="3dd6362242ec4d8e950fc308f0c9c5371ac3e523" translate="yes" xml:space="preserve">
          <source>Quality assurance in SQLite is done using &lt;a href=&quot;testing#coverage&quot;&gt;full-coverage testing&lt;/a&gt;, not by compiler warnings or other static code analysis tools. In other words, we verify that SQLite actually gets the correct answer, not that it merely satisfies stylistic constraints. Most of the SQLite code base is devoted purely to testing. The SQLite test suite runs tens of thousands of separate test cases and many of those test cases are parameterized so that hundreds of millions of tests involving billions of SQL statements are run and evaluated for correctness prior to every release. The developers use code coverage tools to verify that all paths through the code are tested. Whenever a bug is found in SQLite, new test cases are written to exhibit the bug so that the bug cannot recur undetected in the future.</source>
          <target state="translated">Обеспечение качества в SQLite осуществляется с помощью &lt;a href=&quot;testing#coverage&quot;&gt;тестирования&lt;/a&gt; с полным покрытием , а не с помощью предупреждений компилятора или других инструментов статического анализа кода. Другими словами, мы проверяем, что SQLite действительно получает правильный ответ, а не просто удовлетворяет стилистическим ограничениям. Большая часть кодовой базы SQLite посвящена исключительно тестированию. Набор тестов SQLite запускает десятки тысяч отдельных тестовых примеров, и многие из этих тестовых примеров параметризованы, так что сотни миллионов тестов, включающих миллиарды операторов SQL, запускаются и оцениваются на правильность перед каждым выпуском. Разработчики используют инструменты покрытия кода, чтобы убедиться, что все пути прохождения кода протестированы. Каждый раз, когда ошибка обнаруживается в SQLite, создаются новые тестовые примеры, чтобы выявить ошибку, чтобы ошибка не могла повторяться незамеченной в будущем.</target>
        </trans-unit>
        <trans-unit id="96ecb898d9fd59826f9555c415e65eadb6f74ead" translate="yes" xml:space="preserve">
          <source>Quality management documents tend to expand into binders full of incomprehensible jargon that nobody reads. This document strives to break that pattern by being concise and useful.</source>
          <target state="translated">Документы по управлению качеством имеют тенденцию расширяться до связок,полных непонятного жаргона,который никто не читает.Этот документ стремится разорвать эту закономерность,будучи кратким и полезным.</target>
        </trans-unit>
        <trans-unit id="61b1d96663c5eb21b3f12fad273403f6ef48c73d" translate="yes" xml:space="preserve">
          <source>Queries (and also DELETE and UPDATE statements) in which the WHERE clause contains a bare geopoly_overlap() or geopoly_within() function make use of the underlying R*Tree data structures for a fast lookup that only has to examine a subset of the rows in the table. The number of rows examines depends, of course, on the size of the $query_polygon. Large $query_polygons will normally need to look at more rows than small ones.</source>
          <target state="translated">Запросы (а также утверждения DELETE и UPDATE),в которых в пункте WHERE имеется функция geopoly_overlap()или geopoly_within(),используют базовые структуры данных R*Tree для быстрого поиска,который должен исследовать только подмножество строк в таблице.Количество исследуемых строк зависит,конечно же,от размера $query_polygon.Большие $query_polygons обычно должны смотреть больше строк,чем маленькие.</target>
        </trans-unit>
        <trans-unit id="5877d4b4dd805510713fc8b0f7324db5905fcfac" translate="yes" xml:space="preserve">
          <source>Queries Against A Graph</source>
          <target state="translated">Запросы против графика</target>
        </trans-unit>
        <trans-unit id="83b570c5458fbacf6723ef9304ccc7570ee10af8" translate="yes" xml:space="preserve">
          <source>Queries against the rowid of a geopoly table are also very quick, even for tables with a vast number of rows. However, none of the auxiliary data columns are indexes, and so queries against the auxiliary data columns will involve a full table scan.</source>
          <target state="translated">Запросы против ряда геополитической таблицы также очень быстрые,даже для таблиц с большим количеством строк.Однако ни один из вспомогательных столбцов данных не является индексами,поэтому запросы к вспомогательным столбцам данных потребуют полного сканирования таблицы.</target>
        </trans-unit>
        <trans-unit id="e655d8b919b6556f1f0ce40faccc63fe0ee22962" translate="yes" xml:space="preserve">
          <source>Queries of the form: &quot;SELECT max(x), y FROM table&quot; returns the value of y on the same row that contains the maximum x value.</source>
          <target state="translated">Запросы формы:&quot;SELECT max(x),y FROM table&quot; возвращает значение y в той же строке,которая содержит максимальное значение x.</target>
        </trans-unit>
        <trans-unit id="e4ff6a5e7ac06c745f7d49496f70f4a140defd99" translate="yes" xml:space="preserve">
          <source>Queries that contain a single MIN() or MAX() aggregate function whose argument is the left-most column of an index might be satisfied by doing a single index lookup rather than by scanning the entire table. Examples:</source>
          <target state="translated">Запросы,содержащие одну совокупную функцию MIN()или MAX(),аргументом которой является самый левый столбец индекса,могут быть удовлетворены путем выполнения одного поиска по индексу,а не путем сканирования всей таблицы.Примеры:</target>
        </trans-unit>
        <trans-unit id="29a6a39bdba4fd39660625514af2f1cb40b3edcf" translate="yes" xml:space="preserve">
          <source>Queries that contain subqueries must sometime evaluate the subqueries separately and store the results in a temporary table, then use the content of the temporary table to evaluate the outer query. We call this &quot;materializing&quot; the subquery. The query optimizer in SQLite attempts to avoid materializing, but sometimes it is not easily avoidable. The temporary tables created by materialization are each stored in their own separate temporary file, which is automatically deleted at the conclusion of the query. The size of these temporary tables depends on the amount of data in the materialization of the subquery, of course.</source>
          <target state="translated">Запросы,содержащие подзапросы,должны иногда оценивать подзапросы отдельно и хранить результаты во временной таблице,а затем использовать содержимое временной таблицы для оценки внешнего запроса.Мы называем это &quot;материализующимся&quot; подзапросом.Оптимизатор запросов в SQLite пытается избежать материализации,но иногда этого нелегко избежать.Созданные в результате материализации временные таблицы хранятся в отдельном временном файле,который автоматически удаляется при завершении запроса.Размер этих временных таблиц зависит,конечно же,от объема данных в материализации подзапроса.</target>
        </trans-unit>
        <trans-unit id="cfbd9457ec43caaedb5b89c759265cf2be427fe5" translate="yes" xml:space="preserve">
          <source>Queries that use ORDER BY and LIMIT now try to avoid computing rows that cannot possibly come in under the LIMIT. This can greatly improve performance of ORDER BY LIMIT queries, especially when the LIMIT is small relative to the number of unrestricted output rows.</source>
          <target state="translated">Запросы,использующие ORDER BY и LIMIT,теперь пытаются избежать вычислительных строк,которые не могут попасть под LIMIT.Это может значительно улучшить производительность запросов ORDER BY LIMIT,особенно когда LIMIT мал по отношению к количеству неограниченных выходных строк.</target>
        </trans-unit>
        <trans-unit id="e885c97cd0eb73037d91afe0e25f71733d813af5" translate="yes" xml:space="preserve">
          <source>Query Language Understood by SQLite</source>
          <target state="translated">Язык запросов Понятен SQLite</target>
        </trans-unit>
        <trans-unit id="3d4f16fd1d91b47c556b84948dabe05573437a3d" translate="yes" xml:space="preserve">
          <source>Query Planner</source>
          <target state="translated">Планировщик запросов</target>
        </trans-unit>
        <trans-unit id="efa9d81fc99ae6041fbe49339a919ef99bac7ade" translate="yes" xml:space="preserve">
          <source>Query Planning</source>
          <target state="translated">Планирование запросов</target>
        </trans-unit>
        <trans-unit id="625af40606e435d60c7571eb3eaed21802aa70ee" translate="yes" xml:space="preserve">
          <source>Query Progress Callbacks</source>
          <target state="translated">Обратный звонок по вопросам прогресса</target>
        </trans-unit>
        <trans-unit id="4af542248ab5d4cfc6f1e9df7245e3bb184ea082" translate="yes" xml:space="preserve">
          <source>Query The EXPLAIN Setting For A Prepared Statement</source>
          <target state="translated">Запрос Установка ЭКСПЛАЙНА для готового отчета</target>
        </trans-unit>
        <trans-unit id="27930b82a7c3d467781ad3b52e0b1d9894281ffa" translate="yes" xml:space="preserve">
          <source>Query flattener</source>
          <target state="translated">Запросительный уплотнитель</target>
        </trans-unit>
        <trans-unit id="e60fdc9ba7fb5d86546748b364cd1dfbde0107e1" translate="yes" xml:space="preserve">
          <source>Query flattening is an important optimization when views are used as each use of a view is translated into a subquery.</source>
          <target state="translated">Сглаживание запроса является важной оптимизацией,когда используются представления,так как каждое использование представления транслируется в подзапрос.</target>
        </trans-unit>
        <trans-unit id="bfee3391ed2fb89e3470d4d2a93c4c710274a3ef" translate="yes" xml:space="preserve">
          <source>Query for the details of phrase match iIdx within the current row. Phrase matches are numbered starting from zero, so the iIdx argument should be greater than or equal to zero and smaller than the value output by xInstCount().</source>
          <target state="translated">Запрос деталей фразы,совпадающей с iIdx в текущей строке.Фразы совпадают,начиная с нуля,поэтому аргумент iIdx должен быть больше или равен нулю и меньше значения,выводимого функцией xInstCount().</target>
        </trans-unit>
        <trans-unit id="3a7dd1ac6b04f70fb3ec3bd5dfe2b333de122f27" translate="yes" xml:space="preserve">
          <source>Query optimizer enhancements:</source>
          <target state="translated">Улучшения оптимизатора запросов:</target>
        </trans-unit>
        <trans-unit id="a2c73363a91970f8d7d0f3ba2033b2b1141c7659" translate="yes" xml:space="preserve">
          <source>Query optimizer improvements:</source>
          <target state="translated">Улучшения оптимизатора запросов:</target>
        </trans-unit>
        <trans-unit id="65d2f2329c994ccea3b5e213a1d1b909c0f33338" translate="yes" xml:space="preserve">
          <source>Query or change a limit on the &lt;a href=&quot;lang_analyze#approx&quot;&gt;approximate ANALYZE&lt;/a&gt; setting. This is approximate number of rows examined in each index by the &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; command. If the argument</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0fbdef4345ce05f423c29e77346a76ae1183a9c" translate="yes" xml:space="preserve">
          <source>Query or change the count-changes flag. Normally, when the count-changes flag is not set, &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;, &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; and &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; statements return no data. When count-changes is set, each of these commands returns a single row of data consisting of one integer value - the number of rows inserted, modified or deleted by the command. The returned change count does not include any insertions, modifications or deletions performed by triggers, any changes made automatically by &lt;a href=&quot;foreignkeys#fk_actions&quot;&gt;foreign key actions&lt;/a&gt;, or updates caused by an &lt;a href=&quot;lang_upsert&quot;&gt;upsert&lt;/a&gt;.</source>
          <target state="translated">Запросить или изменить флаг количества изменений. Обычно, когда флаг количества изменений не установлен, операторы &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; , &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; и &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; не возвращают данных. Когда установлено значение count-changes, каждая из этих команд возвращает одну строку данных, состоящую из одного целого числа - количества строк, вставленных, измененных или удаленных командой. Возвращенный счетчик изменений не включает в себя каких - либо вставок, модификации или удаления , выполняемые триггерами, любые изменения , сделанные автоматически &lt;a href=&quot;foreignkeys#fk_actions&quot;&gt;иностранных действий ключевых&lt;/a&gt; , или обновлений , вызванных &lt;a href=&quot;lang_upsert&quot;&gt;upsert&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9a7df9605f2eec87d8f2db2efd84251b953fcfd6" translate="yes" xml:space="preserve">
          <source>Query or change the empty-result-callbacks flag.</source>
          <target state="translated">Запросить или поменять флаг &quot;Пустота-результат-обратный ход&quot;.</target>
        </trans-unit>
        <trans-unit id="4386c302fe03b8bf430568c307ba9f2bfa451ec8" translate="yes" xml:space="preserve">
          <source>Query or change the full_column_names flag. This flag together with the &lt;a href=&quot;pragma#pragma_short_column_names&quot;&gt;short_column_names&lt;/a&gt; flag determine the way SQLite assigns names to result columns of &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statements. Result columns are named by applying the following rules in order:</source>
          <target state="translated">Запросить или изменить флаг full_column_names. Этот флаг вместе с флагом &lt;a href=&quot;pragma#pragma_short_column_names&quot;&gt;short_column_names&lt;/a&gt; определяет способ, которым SQLite назначает имена столбцам результатов &lt;a href=&quot;lang_select&quot;&gt;операторов SELECT&lt;/a&gt; . Столбцы результатов именуются с применением следующих правил по порядку:</target>
        </trans-unit>
        <trans-unit id="6ea33a7feb73dab172e527ce6afcb51892e3e546" translate="yes" xml:space="preserve">
          <source>Query or change the fullfsync flag for &lt;a href=&quot;wal#ckpt&quot;&gt;checkpoint&lt;/a&gt; operations. If this flag is set, then the F_FULLFSYNC syncing method is used during checkpoint operations on systems that support F_FULLFSYNC. The default value of the checkpoint_fullfsync flag is off. Only Mac OS-X supports F_FULLFSYNC.</source>
          <target state="translated">Запросить или изменить флаг fullfsync для операций с &lt;a href=&quot;wal#ckpt&quot;&gt;контрольной&lt;/a&gt; точкой . Если этот флаг установлен, то метод синхронизации F_FULLFSYNC используется во время операций контрольной точки в системах, поддерживающих F_FULLFSYNC. По умолчанию флаг checkpoint_fullfsync выключен. Только Mac OS-X поддерживает F_FULLFSYNC.</target>
        </trans-unit>
        <trans-unit id="563bc8c4477c1c2b886876e5894cd59e0001b35e" translate="yes" xml:space="preserve">
          <source>Query or change the fullfsync flag. This flag determines whether or not the F_FULLFSYNC syncing method is used on systems that support it. The default value of the fullfsync flag is off. Only Mac OS X supports F_FULLFSYNC.</source>
          <target state="translated">Запрос или изменение флага fullfsync.Этот флаг определяет,используется ли метод синхронизации F_FULLFSYNC на системах,которые его поддерживают.Значение по умолчанию для флага fullfsync выключено.Только Mac OS X поддерживает F_FULLFSYNC.</target>
        </trans-unit>
        <trans-unit id="77df4b91f1e34f39b185a6ee7e54e82d58dfa005" translate="yes" xml:space="preserve">
          <source>Query or change the maximum number of bytes that are set aside for memory-mapped I/O on a single database. The first form (without an argument) queries the current limit. The second form (with a numeric argument) sets the limit for the specified database, or for all databases if the optional database name is omitted. In the second form, if the database name is omitted, the limit that is set becomes the default limit for all databases that are added to the &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; by subsequent &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; statements.</source>
          <target state="translated">Запросить или изменить максимальное количество байтов, отведенных для ввода-вывода с отображением памяти в одной базе данных. Первая форма (без аргумента) запрашивает текущий лимит. Вторая форма (с числовым аргументом) устанавливает предел для указанной базы данных или для всех баз данных, если необязательное имя базы данных опущено. Во второй форме, если имя базы данных опущено, установленный предел становится пределом по умолчанию для всех баз данных, которые добавляются к &lt;a href=&quot;c3ref/sqlite3&quot;&gt;соединению&lt;/a&gt; с базой данных последующими операторами &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5b3761ba731b4ca68bda2cd1e8fe9ffa86d5d2f0" translate="yes" xml:space="preserve">
          <source>Query or change the secure-delete setting. When secure_delete is on, SQLite overwrites deleted content with zeros. The default setting for secure_delete is determined by the &lt;a href=&quot;compile#secure_delete&quot;&gt;SQLITE_SECURE_DELETE&lt;/a&gt; compile-time option and is normally off. The off setting for secure_delete improves performance by reducing the number of CPU cycles and the amount of disk I/O. Applications that wish to avoid leaving forensic traces after content is deleted or updated should enable the secure_delete pragma prior to performing the delete or update, or else run &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; after the delete or update.</source>
          <target state="translated">Запросить или изменить настройку безопасного удаления. Когда secure_delete включен, SQLite перезаписывает удаленный контент нулями. Значение по умолчанию для secure_delete определяется параметром &lt;a href=&quot;compile#secure_delete&quot;&gt;времени&lt;/a&gt; компиляции SQLITE_SECURE_DELETE и обычно выключено. Параметр off для secure_delete повышает производительность за счет уменьшения количества циклов ЦП и объема дискового ввода-вывода. Приложения, которые хотят не оставлять следы судебной экспертизы после удаления или обновления содержимого, должны включить прагму secure_delete перед выполнением удаления или обновления или запустить &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; после удаления или обновления.</target>
        </trans-unit>
        <trans-unit id="de56ca3e30c1c074a1fd98f6d3fdce5680f699b3" translate="yes" xml:space="preserve">
          <source>Query or change the setting of the &quot;&lt;b&gt;temp_store&lt;/b&gt;&quot; parameter. When temp_store is DEFAULT (0), the compile-time C preprocessor macro &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; is used to determine where temporary tables and indices are stored. When temp_store is MEMORY (2) &lt;a href=&quot;inmemorydb#temp_db&quot;&gt;temporary tables&lt;/a&gt; and indices are kept in as if they were pure &lt;a href=&quot;inmemorydb&quot;&gt;in-memory databases&lt;/a&gt; memory. When temp_store is FILE (1) &lt;a href=&quot;inmemorydb#temp_db&quot;&gt;temporary tables&lt;/a&gt; and indices are stored in a file. The &lt;a href=&quot;pragma#pragma_temp_store_directory&quot;&gt;temp_store_directory&lt;/a&gt; pragma can be used to specify the directory containing temporary files when &lt;b&gt;FILE&lt;/b&gt; is specified. When the temp_store setting is changed, all existing temporary tables, indices, triggers, and views are immediately deleted.</source>
          <target state="translated">Запросить или изменить настройку параметра &amp;laquo; &lt;b&gt;temp_store&lt;/b&gt; &amp;raquo;. Когда temp_store имеет значение DEFAULT (0), макрос препроцессора C времени компиляции &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; используется для определения места хранения временных таблиц и индексов. Когда temp_store имеет значение MEMORY (2), &lt;a href=&quot;inmemorydb#temp_db&quot;&gt;временные таблицы&lt;/a&gt; и индексы сохраняются, как если бы они были чистой &lt;a href=&quot;inmemorydb&quot;&gt;памятью баз данных в&lt;/a&gt; памяти. Когда temp_store имеет значение FILE (1), &lt;a href=&quot;inmemorydb#temp_db&quot;&gt;временные таблицы&lt;/a&gt; и индексы хранятся в файле. &lt;a href=&quot;pragma#pragma_temp_store_directory&quot;&gt;Temp_store_directory&lt;/a&gt; Прагма можно использовать , чтобы указать каталог , содержащий временные файлы , когда &lt;b&gt;FILE&lt;/b&gt; указано. При изменении параметра temp_store все существующие временные таблицы, индексы, триггеры и представления немедленно удаляются.</target>
        </trans-unit>
        <trans-unit id="0eb005d9ab4e0804f12c87dee002073b411d274d" translate="yes" xml:space="preserve">
          <source>Query or change the setting of the &quot;synchronous&quot; flag. The first (query) form will return the synchronous setting as an integer. The second form changes the synchronous setting. The meanings of the various synchronous settings are as follows:</source>
          <target state="translated">Запрос или изменение установки флага &quot;синхронный&quot;.Первая форма (форма запроса)вернет синхронную установку в виде целого числа.Вторая форма изменяет установку &quot;синхронный&quot;.Значения различных установок синхронизации следующие:</target>
        </trans-unit>
        <trans-unit id="8dcfcd54b0505cd09f50244da9bbd756766eef81" translate="yes" xml:space="preserve">
          <source>Query or change the setting of the &lt;a href=&quot;c3ref/busy_timeout&quot;&gt;busy timeout&lt;/a&gt;. This pragma is an alternative to the &lt;a href=&quot;c3ref/busy_timeout&quot;&gt;sqlite3_busy_timeout()&lt;/a&gt; C-language interface which is made available as a pragma for use with language bindings that do not provide direct access to &lt;a href=&quot;c3ref/busy_timeout&quot;&gt;sqlite3_busy_timeout()&lt;/a&gt;.</source>
          <target state="translated">Запросить или изменить настройку &lt;a href=&quot;c3ref/busy_timeout&quot;&gt;тайм-аута занятости&lt;/a&gt; . Эта прагма является альтернативой интерфейсу языка C &lt;a href=&quot;c3ref/busy_timeout&quot;&gt;sqlite3_busy_timeout (),&lt;/a&gt; который доступен как прагма для использования с языковыми привязками, которые не предоставляют прямой доступ к &lt;a href=&quot;c3ref/busy_timeout&quot;&gt;sqlite3_busy_timeout ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9a6f0cf05490ce574881ff5675cbd192d91cf992" translate="yes" xml:space="preserve">
          <source>Query or change the short-column-names flag. This flag affects the way SQLite names columns of data returned by &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statements. See the &lt;a href=&quot;pragma#pragma_full_column_names&quot;&gt;full_column_names&lt;/a&gt; pragma for full details.</source>
          <target state="translated">Запросить или изменить флаг коротких имен столбцов. Этот флаг влияет на то, как SQLite называет столбцы данных, возвращаемых &lt;a href=&quot;lang_select&quot;&gt;операторами SELECT&lt;/a&gt; . См. &lt;a href=&quot;pragma#pragma_full_column_names&quot;&gt;Прагму full_column_names&lt;/a&gt; для получения полной информации.</target>
        </trans-unit>
        <trans-unit id="c472dc3fc7ff36d8acee51946b1687ac08bd59fe" translate="yes" xml:space="preserve">
          <source>Query or change the suggested maximum number of database disk pages that SQLite will hold in memory at once per open database file. Whether or not this suggestion is honored is at the discretion of the &lt;a href=&quot;c3ref/pcache_methods2&quot;&gt;Application Defined Page Cache&lt;/a&gt;. The default page cache that is built into SQLite honors the request, however alternative application-defined page cache implementations may choose to interpret the suggested cache size in different ways or to ignore it all together. The default suggested cache size is -2000, which means the cache size is limited to 2048000 bytes of memory. The default suggested cache size can be altered using the &lt;a href=&quot;compile#default_cache_size&quot;&gt;SQLITE_DEFAULT_CACHE_SIZE&lt;/a&gt; compile-time options. The TEMP database has a default suggested cache size of 0 pages.</source>
          <target state="translated">Запросить или изменить предлагаемое максимальное количество страниц диска базы данных, которые SQLite будет удерживать в памяти одновременно для каждого открытого файла базы данных. Будет ли выполнено это предложение, на усмотрение определяемого &lt;a href=&quot;c3ref/pcache_methods2&quot;&gt;приложением кэша страниц&lt;/a&gt; . Кэш страниц по умолчанию, встроенный в SQLite, учитывает запрос, однако альтернативные реализации кеша страниц, определяемые приложением, могут интерпретировать предлагаемый размер кеша по-разному или игнорировать его все вместе. Рекомендуемый размер кэша по умолчанию - -2000, что означает, что размер кэша ограничен 2048000 байтами памяти. Предлагаемый по умолчанию размер кеша можно изменить с помощью параметров &lt;a href=&quot;compile#default_cache_size&quot;&gt;времени&lt;/a&gt; компиляции SQLITE_DEFAULT_CACHE_SIZE . База данных TEMP имеет рекомендуемый размер кэша по умолчанию 0 страниц.</target>
        </trans-unit>
        <trans-unit id="38317b0c0d1df51bd83790ce312ba13da0c5ed05" translate="yes" xml:space="preserve">
          <source>Query or change the value of the &lt;a href=&quot;c3ref/data_directory&quot;&gt;sqlite3_data_directory&lt;/a&gt; global variable, which windows operating-system interface backends use to determine where to store database files specified using a relative pathname.</source>
          <target state="translated">Запросите или измените значение глобальной переменной &lt;a href=&quot;c3ref/data_directory&quot;&gt;sqlite3_data_directory&lt;/a&gt; , которую серверные части интерфейса операционной системы Windows используют для определения места для хранения файлов базы данных, указанных с использованием относительного пути.</target>
        </trans-unit>
        <trans-unit id="f61590ed5a58a97ecca18f3fbb40bf0ae63fb037" translate="yes" xml:space="preserve">
          <source>Query or change the value of the &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitworkerthreads&quot;&gt;SQLITE_LIMIT_WORKER_THREADS&lt;/a&gt;,...) limit for the current database connection. This limit sets an upper bound on the number of auxiliary threads that a &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; is allowed to launch to assist with a query. The default limit is 0 unless it is changed using the &lt;a href=&quot;compile#default_worker_threads&quot;&gt;SQLITE_DEFAULT_WORKER_THREADS&lt;/a&gt; compile-time option. When the limit is zero, that means no auxiliary threads will be launched.</source>
          <target state="translated">Запросить или изменить значение ограничения &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt; (db, &lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitworkerthreads&quot;&gt;SQLITE_LIMIT_WORKER_THREADS&lt;/a&gt; , ...) для текущего подключения к базе данных. Этот предел устанавливает верхнюю границу количества вспомогательных потоков, которые &lt;a href=&quot;c3ref/stmt&quot;&gt;подготовленному оператору&lt;/a&gt; разрешено запускать для помощи с запросом. Предел по умолчанию равен 0, если он не изменен с помощью параметра &lt;a href=&quot;compile#default_worker_threads&quot;&gt;времени&lt;/a&gt; компиляции SQLITE_DEFAULT_WORKER_THREADS . Когда лимит равен нулю, это означает, что вспомогательные потоки запускаться не будут.</target>
        </trans-unit>
        <trans-unit id="4ad35fae3f5b98f4ef0cd9485074046877d96539" translate="yes" xml:space="preserve">
          <source>Query or change the value of the &lt;a href=&quot;c3ref/temp_directory&quot;&gt;sqlite3_temp_directory&lt;/a&gt; global variable, which many operating-system interface backends use to determine where to store &lt;a href=&quot;inmemorydb#temp_db&quot;&gt;temporary tables&lt;/a&gt; and indices.</source>
          <target state="translated">Запросите или измените значение глобальной переменной &lt;a href=&quot;c3ref/temp_directory&quot;&gt;sqlite3_temp_directory&lt;/a&gt; , которую многие серверные части интерфейса операционной системы используют для определения места для хранения &lt;a href=&quot;inmemorydb#temp_db&quot;&gt;временных таблиц&lt;/a&gt; и индексов.</target>
        </trans-unit>
        <trans-unit id="5866fac6602f3e40c19df259ea318d2b63caf2bd" translate="yes" xml:space="preserve">
          <source>Query or set the auto-vacuum status in the database.</source>
          <target state="translated">Запрос или установка статуса авто-вакуума в базе данных.</target>
        </trans-unit>
        <trans-unit id="3cc5d0ecc46bacf93e04d7b7978224221ecdf262" translate="yes" xml:space="preserve">
          <source>Query or set the maximum number of pages in the database file. Both forms of the pragma return the maximum page count. The second form attempts to modify the maximum page count. The maximum page count cannot be reduced below the current database size.</source>
          <target state="translated">Запрос или установка максимального количества страниц в файле базы данных.Обе формы прагмы возвращают максимальное количество страниц.Вторая форма пытается изменить максимальное количество страниц.Максимальное количество страниц не может быть уменьшено ниже текущего размера базы данных.</target>
        </trans-unit>
        <trans-unit id="3b4e54fcf1e120591a5a6535bff6e2b69b86d7df" translate="yes" xml:space="preserve">
          <source>Query or set the page size of the database. The page size must be a power of two between 512 and 65536 inclusive.</source>
          <target state="translated">Запрос или установка размера страницы базы данных.Размер страницы должен быть двух мощностей от 512 до 65536 включительно.</target>
        </trans-unit>
        <trans-unit id="627a1950bccb0926f06969a3db2d136c3cabdca5" translate="yes" xml:space="preserve">
          <source>Query planner checklist</source>
          <target state="translated">Контрольный список планировщика запросов</target>
        </trans-unit>
        <trans-unit id="e93c39912e396551e04ed9b46c1ea823e2d8b3bb" translate="yes" xml:space="preserve">
          <source>Query planner enhancement - automatic transient indices are created when doing so reduces the estimated query time.</source>
          <target state="translated">Улучшение планировщика запросов-при этом создаются автоматические переходные индексы,уменьшающие расчетное время запроса.</target>
        </trans-unit>
        <trans-unit id="15e2bd2467aae946e711f6cc5ade007f83eb3c87" translate="yes" xml:space="preserve">
          <source>Query planner enhancement - the ORDER BY becomes a no-op if the query also contains a GROUP BY clause that forces the correct output order.</source>
          <target state="translated">Улучшение планировщика запросов-&quot;ЗАКАЗАТЬ ВЫБОР&quot; становится &quot;нет&quot;,если запрос также содержит пункт GROUP ВЫБОР,который заставляет правильный порядок вывода.</target>
        </trans-unit>
        <trans-unit id="26786d5880615e168b7819292d8f2bd689ef42b3" translate="yes" xml:space="preserve">
          <source>Query planner enhancement: Use the transitive property of constraints to move constraints into the outer loops of a join whenever possible, thereby reducing the amount of work that needs to occur in inner loops.</source>
          <target state="translated">Улучшение планирования запросов:Используйте переходное свойство ограничений для перемещения ограничений во внешние петли соединения,когда это возможно,тем самым уменьшая объем работы,которая должна выполняться во внутренних петлях.</target>
        </trans-unit>
        <trans-unit id="736e85cef8966360d93b45933c07771905d6a0b9" translate="yes" xml:space="preserve">
          <source>Query planner enhancements.</source>
          <target state="translated">Улучшения планировщика запросов.</target>
        </trans-unit>
        <trans-unit id="c7e16cd25b99db12dc36d4eb42e08d056acec1b1" translate="yes" xml:space="preserve">
          <source>Query planner enhancements:</source>
          <target state="translated">Улучшения планировщика запросов:</target>
        </trans-unit>
        <trans-unit id="666ab0644bcf7abdf389c79c890bad61c7c7fec2" translate="yes" xml:space="preserve">
          <source>Query planner improvements:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2b452d242e61d8f7480bffaae127bf001921fa3" translate="yes" xml:space="preserve">
          <source>Query planner stability guarantee</source>
          <target state="translated">Гарантия стабильности планировщика запросов</target>
        </trans-unit>
        <trans-unit id="ca5891ff28346fccc5150a605b02b68689910ebb" translate="yes" xml:space="preserve">
          <source>Query planners are what make SQL database engines so amazingly useful and powerful. (This is true of all SQL database engines, not just SQLite.) The query planner frees the programmer from the chore of selecting a particular query plan, and thereby allows the programmer to focus more mental energy on higher-level application issues and on providing more value to the end user. For simple queries where the choice of query plan is obvious, this is convenient but not hugely important. But as applications and schemas and queries grow more complex, a clever query planner can greatly speed and simplify the work of application development. There is amazing power in being about to tell the database engine what content is desired, and then let the database engine figure out the best way to retrieve that content.</source>
          <target state="translated">Планировщики запросов-это то,что делает движки баз данных SQL такими удивительно полезными и мощными.(Это справедливо для всех движков баз данных SQL,а не только для SQLite.)Планировщик запросов освобождает программиста от рутинной работы по выбору конкретного плана запроса,и тем самым позволяет сосредоточиться на вопросах более высокого уровня приложений и на предоставлении большей ценности конечному пользователю.Для простых запросов,где выбор плана запроса очевиден,это удобно,но не очень важно.Но по мере усложнения приложений,а также схем и запросов,умный планировщик запросов может значительно ускорить и упростить работу по разработке приложений.Существует удивительная сила в том,чтобы быть готовым сказать движку базы данных,какое содержимое желательно,а затем позволить движку базы данных выяснить лучший способ получить это содержимое.</target>
        </trans-unit>
        <trans-unit id="9ee854629ae78a2199bdb56da8e286e6006b5d8d" translate="yes" xml:space="preserve">
          <source>Query results are returned as a list of column values. If a query requests 2 columns and there are 3 rows matching the query, then the returned list will contain 6 elements. For example:</source>
          <target state="translated">Результаты запроса возвращаются в виде списка значений столбцов.Если запрос запрашивает 2 столбца и 3 строки соответствуют запросу,то возвращаемый список будет содержать 6 элементов.Например:</target>
        </trans-unit>
        <trans-unit id="50cb7820ab431080267a59361b01e9af99b0f2f7" translate="yes" xml:space="preserve">
          <source>Query, set, or clear READ UNCOMMITTED isolation. The default isolation level for SQLite is SERIALIZABLE. Any process or thread can select READ UNCOMMITTED isolation, but SERIALIZABLE will still be used except between connections that share a common page and schema cache. Cache sharing is enabled using the &lt;a href=&quot;c3ref/enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache()&lt;/a&gt; API. Cache sharing is disabled by default.</source>
          <target state="translated">Запросить, установить или снять изоляцию READ UNCOMMITTED. Уровень изоляции по умолчанию для SQLite - SERIALIZABLE. Любой процесс или поток может выбрать изоляцию READ UNCOMMITTED, но SERIALIZABLE по-прежнему будет использоваться, за исключением соединений, которые имеют общую страницу и кеш схемы. Совместное использование кеша включается с помощью API &lt;a href=&quot;c3ref/enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache ()&lt;/a&gt; . По умолчанию общий доступ к кешу отключен.</target>
        </trans-unit>
        <trans-unit id="0366bdd9a4ae5e944fbf6092ddc8900d9aeaaed5" translate="yes" xml:space="preserve">
          <source>Query, set, or clear the &lt;a href=&quot;optoverview#autoindex&quot;&gt;automatic indexing&lt;/a&gt; capability.</source>
          <target state="translated">Запросить, установить или отменить возможность &lt;a href=&quot;optoverview#autoindex&quot;&gt;автоматического индексирования&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="14ccb18dde2fc34367c93b804727ccf1143765e5" translate="yes" xml:space="preserve">
          <source>Query, set, or clear the enforcement of &lt;a href=&quot;foreignkeys&quot;&gt;foreign key constraints&lt;/a&gt;.</source>
          <target state="translated">Запросить, установить или отменить принудительное применение &lt;a href=&quot;foreignkeys&quot;&gt;ограничений внешнего ключа&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="160bfb7a8121ce10fe672d852b6ba0dcf536c5e1" translate="yes" xml:space="preserve">
          <source>Query, set, or clear the recursive trigger capability.</source>
          <target state="translated">Запрос,установка или очистка возможности рекурсивного запуска.</target>
        </trans-unit>
        <trans-unit id="bf0ed56a136cbe5ffad095931c71813d09f0273f" translate="yes" xml:space="preserve">
          <source>Questions and confusion quickly arose on the &lt;a href=&quot;https://sqlite.org/support.html#mailinglists&quot;&gt;mailing lists&lt;/a&gt; about the purpose behind these new interfaces, why they were introduced, and what problem they solve. This essay attempts to answer those questions and clear up the confusion.</source>
          <target state="translated">В &lt;a href=&quot;https://sqlite.org/support.html#mailinglists&quot;&gt;списках рассылки&lt;/a&gt; быстро возникли вопросы и путаница относительно целей этих новых интерфейсов, почему они были введены и какие проблемы они решают. В этом эссе делается попытка ответить на эти вопросы и устранить путаницу.</target>
        </trans-unit>
        <trans-unit id="6fb0e0d11a03f78b5ecb2f7f8b42ef10b6e101e0" translate="yes" xml:space="preserve">
          <source>Questions like these (and countless others) can be answered without having to uncompress or extract any content.</source>
          <target state="translated">На подобные вопросы (и на бесчисленное множество других)можно ответить без необходимости распаковывать или извлекать какое-либо содержимое.</target>
        </trans-unit>
        <trans-unit id="09a7d1d2da3256534f8a2a26b3d747dbae8b2a14" translate="yes" xml:space="preserve">
          <source>Quirks, Caveats, and Gotchas In SQLite</source>
          <target state="translated">Причуды,пещеры и ловушки в SQLite.</target>
        </trans-unit>
        <trans-unit id="9432058147a91a2c4afeff95adc17f4930b4c6b9" translate="yes" xml:space="preserve">
          <source>R (cost: 3.56)</source>
          <target state="translated">R (стоимость:3,56)</target>
        </trans-unit>
        <trans-unit id="37abd4d23bc413fb5db77feee86f46ad0b861e2d" translate="yes" xml:space="preserve">
          <source>R*Tree Module</source>
          <target state="translated">R*Tree Module</target>
        </trans-unit>
        <trans-unit id="43ea99300f03323c6239855a57c58f91be6c0d63" translate="yes" xml:space="preserve">
          <source>R-N1 (cost: 7.03)</source>
          <target state="translated">R-N1 (стоимость:7.03)</target>
        </trans-unit>
        <trans-unit id="00f923142bbc27eb285a9f64b857d908b86719d8" translate="yes" xml:space="preserve">
          <source>R-N1-C (cost: 13.43)</source>
          <target state="translated">Р-Н1-С (стоимость:13.43)</target>
        </trans-unit>
        <trans-unit id="f743ed80cd4af3e3dd6aaa0242ee69bf26b480c0" translate="yes" xml:space="preserve">
          <source>R-N1-N2 (cost: 12.55)</source>
          <target state="translated">R-N1-N2 (стоимость:12,55)</target>
        </trans-unit>
        <trans-unit id="12fc721fdde87226fb7f977e95887d024b7fef9e" translate="yes" xml:space="preserve">
          <source>R-N1-P (cost: 14.74)</source>
          <target state="translated">Р-Н1-П (стоимость:14,74)</target>
        </trans-unit>
        <trans-unit id="fab85d63ca52ab34a7d0d4d635cb4434f4c73c7c" translate="yes" xml:space="preserve">
          <source>R-N2 (cost: 9.08)</source>
          <target state="translated">R-N2 (стоимость:9.08)</target>
        </trans-unit>
        <trans-unit id="2a3b1ad1ab0d9afa5d157dd5a7723841765c8a20" translate="yes" xml:space="preserve">
          <source>R-N2-S (cost: 15.08)</source>
          <target state="translated">Р-Н2-С (стоимость:15.08)</target>
        </trans-unit>
        <trans-unit id="181200f18a6abb830d9a1e4da77cb05da7c0b226" translate="yes" xml:space="preserve">
          <source>R-P {cost: 11.27}</source>
          <target state="translated">R-P {кост:11.27}</target>
        </trans-unit>
        <trans-unit id="a39f8b032fb6773009f23cdf1fc4a43dca07ca75" translate="yes" xml:space="preserve">
          <source>R-tree indexes</source>
          <target state="translated">индексы R-дерева</target>
        </trans-unit>
        <trans-unit id="27625665a48434a97da2f59bce85a61c08c57d13" translate="yes" xml:space="preserve">
          <source>RAISE</source>
          <target state="translated">RAISE</target>
        </trans-unit>
        <trans-unit id="eab70b41d287161d06757b3c91f16b40700edd9b" translate="yes" xml:space="preserve">
          <source>RAISE function</source>
          <target state="translated">функция RAISE</target>
        </trans-unit>
        <trans-unit id="578e6dad8d99e7211a3086f6ebcd1836a6b2b2b0" translate="yes" xml:space="preserve">
          <source>RANGE</source>
          <target state="translated">RANGE</target>
        </trans-unit>
        <trans-unit id="ddd7e61302a8592bafc0bc44fda92b4c46585957" translate="yes" xml:space="preserve">
          <source>RANGE frames</source>
          <target state="translated">ранжированные рамки</target>
        </trans-unit>
        <trans-unit id="3314a11c461e2d3c3169c9709d07e23cec14a354" translate="yes" xml:space="preserve">
          <source>RANGE n PRECEDING</source>
          <target state="translated">РЕЙНГ n ПРЕДОСТАВЛЕНИЕ</target>
        </trans-unit>
        <trans-unit id="f4c206eeb5c6f3b744195c276954fdb473ea9623" translate="yes" xml:space="preserve">
          <source>RBU Database Contents</source>
          <target state="translated">Содержание базы данных RBU</target>
        </trans-unit>
        <trans-unit id="712d8aa663fc4fe498c4350eb3d107a2e61b11c3" translate="yes" xml:space="preserve">
          <source>RBU Database Tables</source>
          <target state="translated">Таблицы базы данных RBU</target>
        </trans-unit>
        <trans-unit id="07201c49e16cf7ee53c14561a1009692319b08f1" translate="yes" xml:space="preserve">
          <source>RBU Extension</source>
          <target state="translated">расширение RBU</target>
        </trans-unit>
        <trans-unit id="e78ae84baf56b93a5fa01e9dafad71c1200f7218" translate="yes" xml:space="preserve">
          <source>RBU FTS3/4 Tables</source>
          <target state="translated">RBU FTS3/4 Таблицы</target>
        </trans-unit>
        <trans-unit id="462b7e20bcfb4a1c16aa1cac30ebb2f5b6113539" translate="yes" xml:space="preserve">
          <source>RBU Update</source>
          <target state="translated">Обновление RBU</target>
        </trans-unit>
        <trans-unit id="fa41f4d5c464fe94904b941d3fdd9fd06f70c8d7" translate="yes" xml:space="preserve">
          <source>RBU Vacuum</source>
          <target state="translated">вакуум RBU</target>
        </trans-unit>
        <trans-unit id="29b65cd1a0583c71c8f08f136996230310e8af2c" translate="yes" xml:space="preserve">
          <source>RBU Vacuum applications all implement some variation of the following procedure:</source>
          <target state="translated">Все вакуумные приложения RBU реализуют некоторые вариации следующей процедуры:</target>
        </trans-unit>
        <trans-unit id="5f247eac406d30bce84777c8b0ea049a1e0cac26" translate="yes" xml:space="preserve">
          <source>RBU operations may be suspended and then later resumed, perhaps with intervening power outages and/or system resets. For an RBU update, the original database content remains visible to all database readers until the entire update has been applied - even if the update is suspended and then later resumed.</source>
          <target state="translated">Операции RBU могут быть приостановлены,а затем возобновлены,возможно,с перебоями в электроснабжении и/или перезагрузкой системы.При обновлении RBU содержимое исходной базы данных остается видимым для всех читателей базы данных до тех пор,пока не будет применено полное обновление-даже если обновление приостановлено,а затем возобновлено.</target>
        </trans-unit>
        <trans-unit id="51d4c96a1d92222b7d93c52475b51db8766c79b8" translate="yes" xml:space="preserve">
          <source>RBU updates cannot be applied to any tables that contain a column named &quot;rbu_control&quot;.</source>
          <target state="translated">Обновления RBU не могут быть применены ни к одной из таблиц,содержащей столбец с именем &quot;rbu_control&quot;.</target>
        </trans-unit>
        <trans-unit id="3b330731a188b19fdf61999609e5e9b932bb400b" translate="yes" xml:space="preserve">
          <source>REAL</source>
          <target state="translated">REAL</target>
        </trans-unit>
        <trans-unit id="d2c4a8bcf4efc09f908cb4e40d7d6f381c3c3ef0" translate="yes" xml:space="preserve">
          <source>RECURSIVE</source>
          <target state="translated">RECURSIVE</target>
        </trans-unit>
        <trans-unit id="d4730753022e62db3135b00e0df88859d25187e8" translate="yes" xml:space="preserve">
          <source>REFERENCES</source>
          <target state="translated">REFERENCES</target>
        </trans-unit>
        <trans-unit id="2347c845abd05fb0d1bae0ab927335b643793946" translate="yes" xml:space="preserve">
          <source>REGEXP</source>
          <target state="translated">REGEXP</target>
        </trans-unit>
        <trans-unit id="5345e769e7d2d5a04080b106526b4188c28b2947" translate="yes" xml:space="preserve">
          <source>REINDEX</source>
          <target state="translated">REINDEX</target>
        </trans-unit>
        <trans-unit id="f73b278fdabab028fe5f65c62197e4b5634529e5" translate="yes" xml:space="preserve">
          <source>RELEASE</source>
          <target state="translated">RELEASE</target>
        </trans-unit>
        <trans-unit id="bec39b2581dc86d96ef7eb4b59715b2db9fb5b98" translate="yes" xml:space="preserve">
          <source>RELEASE SAVEPOINT</source>
          <target state="translated">ТОЧКА СОХРАНЕНИЯ</target>
        </trans-unit>
        <trans-unit id="4756081595ff9366e8b59c094aebf3df53a8fc98" translate="yes" xml:space="preserve">
          <source>RENAME</source>
          <target state="translated">RENAME</target>
        </trans-unit>
        <trans-unit id="a464c34da3d7dbc3eb6ade113363a4f1b48466a0" translate="yes" xml:space="preserve">
          <source>RENAME COLUMN</source>
          <target state="translated">РЕНАМЕ КОЛУМН</target>
        </trans-unit>
        <trans-unit id="c336fcec997db68ba1a16ff95d4b5a6b5f133c3b" translate="yes" xml:space="preserve">
          <source>REPLACE</source>
          <target state="translated">REPLACE</target>
        </trans-unit>
        <trans-unit id="eb5450aba42e33754272b8b32dc01c695827c179" translate="yes" xml:space="preserve">
          <source>REPLACE INTO</source>
          <target state="translated">ЗАМЕНА ВХОДА</target>
        </trans-unit>
        <trans-unit id="044eabc2191e6bd2b8395304f84a790584ab5cd3" translate="yes" xml:space="preserve">
          <source>RESERVED</source>
          <target state="translated">RESERVED</target>
        </trans-unit>
        <trans-unit id="69ed002a9f57d1ba3022c561c2f3bb595bf68418" translate="yes" xml:space="preserve">
          <source>RESTART</source>
          <target state="translated">RESTART</target>
        </trans-unit>
        <trans-unit id="99e2cdb8b048ca3999469c35242023f92980f5e6" translate="yes" xml:space="preserve">
          <source>RESTRICT</source>
          <target state="translated">RESTRICT</target>
        </trans-unit>
        <trans-unit id="95253203f79304981143599cedfdaa606f083ca2" translate="yes" xml:space="preserve">
          <source>RIGHT</source>
          <target state="translated">RIGHT</target>
        </trans-unit>
        <trans-unit id="2ce42e824f2163751d62c49d3226c338efa1179d" translate="yes" xml:space="preserve">
          <source>ROLLBACK</source>
          <target state="translated">ROLLBACK</target>
        </trans-unit>
        <trans-unit id="1b38c7ab7be8eb4066bc5bd507af4275ed737be5" translate="yes" xml:space="preserve">
          <source>ROLLBACK TRANSACTION</source>
          <target state="translated">ОБРАТНАЯ СДЕЛКА</target>
        </trans-unit>
        <trans-unit id="fee8f3fde6222d1d587520ccdcc8bdc883934e5b" translate="yes" xml:space="preserve">
          <source>ROW</source>
          <target state="translated">ROW</target>
        </trans-unit>
        <trans-unit id="27bcbad0c7dc6e890992a45957c32cb63b180961" translate="yes" xml:space="preserve">
          <source>ROWID</source>
          <target state="translated">ROWID</target>
        </trans-unit>
        <trans-unit id="1066d5101585674b0bf2bb2a7f36e54bd28ffb0c" translate="yes" xml:space="preserve">
          <source>ROWIDs and the INTEGER PRIMARY KEY</source>
          <target state="translated">ROWIDs и INTEGER PRIMARY KEY</target>
        </trans-unit>
        <trans-unit id="35c47b79dc3cdab698d2bf71b053c1b257f8db73" translate="yes" xml:space="preserve">
          <source>ROWS</source>
          <target state="translated">ROWS</target>
        </trans-unit>
        <trans-unit id="43bc1be6b036dd85df3053c47dc4432d982cf8e0" translate="yes" xml:space="preserve">
          <source>RTRIM</source>
          <target state="translated">RTRIM</target>
        </trans-unit>
        <trans-unit id="912333c4ddec40db71424e4b21120e0065cfde78" translate="yes" xml:space="preserve">
          <source>RTRIM collating function</source>
          <target state="translated">функция сопоставления RTRIM</target>
        </trans-unit>
        <trans-unit id="d4ccca8588cab0a99233c6cf71400747dcf81d92" translate="yes" xml:space="preserve">
          <source>RTRIM is like BINARY except that extra spaces at the end of either string do not change the result. In other words, strings will compare equal to one another as long as they differ only in the number of spaces at the end.</source>
          <target state="translated">RTRIM похож на BINARY за исключением того,что лишние пробелы в конце любой из строк не меняют результат.Другими словами,строки будут сравниваться равными друг другу до тех пор,пока они различаются только по количеству пробелов в конце.</target>
        </trans-unit>
        <trans-unit id="73bc329996a4b61f272d21a8ef8e13d37b2f5bf8" translate="yes" xml:space="preserve">
          <source>Raising the number of open databases may improve performance in some scenarios.</source>
          <target state="translated">Увеличение количества открытых баз данных может повысить производительность в некоторых сценариях.</target>
        </trans-unit>
        <trans-unit id="d62e76ddc1a4a4c5a8b50ba8345b20a992c2b937" translate="yes" xml:space="preserve">
          <source>Range query optimization</source>
          <target state="translated">Оптимизация запросов диапазона</target>
        </trans-unit>
        <trans-unit id="415026844c74bb5d00489173b1d5e1a90b70bfca" translate="yes" xml:space="preserve">
          <source>Raw (possibly compressed) data associated with zip file entry (a blob).</source>
          <target state="translated">Сырые (возможно,сжатые)данные,связанные с записью в zip-файле (блоб).</target>
        </trans-unit>
        <trans-unit id="3685a628a8d194c36e92956d9b368621a3c4f89e" translate="yes" xml:space="preserve">
          <source>Reactivated the VACUUM command that reclaims unused disk space in a database file.</source>
          <target state="translated">Восстановлена команда VACUUM,которая восстанавливает неиспользованное дисковое пространство в файле базы данных.</target>
        </trans-unit>
        <trans-unit id="7bf4a534bd19935da933046f9a9ff7be5b6a7965" translate="yes" xml:space="preserve">
          <source>Read Data From A BLOB Incrementally</source>
          <target state="translated">Чтение данных из BLOB инкрементально</target>
        </trans-unit>
        <trans-unit id="4817ee387eb1c80d362458e295a1ce28b034e185" translate="yes" xml:space="preserve">
          <source>Read and parse all entries from the SQLITE_MASTER table of database P1 that match the WHERE clause P4. If P4 is a NULL pointer, then the entire schema for P1 is reparsed.</source>
          <target state="translated">Читайте и разбирайте все записи из таблицы SQLITE_MASTER базы данных P1,которые соответствуют пункту WHERE P4.Если P4 является NULL указателем,то перечитывается вся схема для P1.</target>
        </trans-unit>
        <trans-unit id="427a567a06032b13c88b02d33d153fca76063c5d" translate="yes" xml:space="preserve">
          <source>Read and parse all entries from the schema table of database P1 that match the WHERE clause P4. If P4 is a NULL pointer, then the entire schema for P1 is reparsed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06b6a6259408a05057f38693264034af5b800655" translate="yes" xml:space="preserve">
          <source>Read and/or write the content of a comma-separated value (CSV) file</source>
          <target state="translated">Чтение и/или запись содержимого файла с разделенными запятыми значениями (CSV)</target>
        </trans-unit>
        <trans-unit id="37ad8caf62966373ce6c4e8d0b90dbca553a6d76" translate="yes" xml:space="preserve">
          <source>Read cookie number P3 from database P1 and write it into register P2. P3==1 is the schema version. P3==2 is the database format. P3==3 is the recommended pager cache size, and so forth. P1==0 is the main database file and P1==1 is the database file used to store temporary tables.</source>
          <target state="translated">Прочитайте номер куки P3 из базы данных P1 и запишите его в регистр P2.P3==1-версия схемы.P3==2-формат базы данных.P3==3-рекомендуемый размер кэша пейджера и так далее.P1==0-основной файл БД,а P1==1-файл БД,используемый для хранения временных таблиц.</target>
        </trans-unit>
        <trans-unit id="e71f89bd0ef9b4251c544f6970cc91848cb5836e" translate="yes" xml:space="preserve">
          <source>Read the journal file and roll back the changes.</source>
          <target state="translated">Прочтите файл журнала и откатите изменения.</target>
        </trans-unit>
        <trans-unit id="6d88c31d2b81845a511df588f6a77f45dfc3be73" translate="yes" xml:space="preserve">
          <source>Read the sqlite_stat1 table for database P1 and load the content of that table into the internal index hash table. This will cause the analysis to be used when preparing all subsequent queries.</source>
          <target state="translated">Прочитайте таблицу sqlite_stat1 для БД P1 и загрузите содержимое этой таблицы во внутреннюю хэш-таблицу индекса.Это приведет к тому,что анализ будет использован при подготовке всех последующих запросов.</target>
        </trans-unit>
        <trans-unit id="0e44b30ba60fce1cc60703c777be280cb42ce89f" translate="yes" xml:space="preserve">
          <source>Read transactions versus write transactions</source>
          <target state="translated">Сделки чтения и записи</target>
        </trans-unit>
        <trans-unit id="c8e239ec9521392219205446c1db66f47cb14a6f" translate="yes" xml:space="preserve">
          <source>Read-mark name</source>
          <target state="translated">Название с меткой чтения</target>
        </trans-unit>
        <trans-unit id="e722ca5fefcf08950d7578b4ed97dfff47cf060e" translate="yes" xml:space="preserve">
          <source>Read-mark offset</source>
          <target state="translated">Смещение Чтение метки</target>
        </trans-unit>
        <trans-unit id="54ac153bd485005c1470e6c415d25c56cea6db82" translate="yes" xml:space="preserve">
          <source>Read-uncommitted mode has no effect on the locks required to write to database tables (i.e. read-uncommitted connections must still obtain write-locks and hence database writes may still block or be blocked). Also, read-uncommitted mode has no effect on the</source>
          <target state="translated">Режим чтения-незавершения не влияет на блокировки,необходимые для записи в таблицы БД (т.е.соединения с функцией чтения-незавершения все равно должны получать блокировки записи,а значит,запись в БД все еще может блокироваться или блокироваться).Кроме того,режим чтения-выключения никак не влияет на</target>
        </trans-unit>
        <trans-unit id="0f2ef9917dd28993c09e6d3368ecafd38ec21fd3" translate="yes" xml:space="preserve">
          <source>Read-uncommitted mode has no effect on the locks required to write to database tables (i.e. read-uncommitted connections must still obtain write-locks and hence database writes may still block or be blocked). Also, read-uncommitted mode has no effect on the &lt;a href=&quot;schematab&quot;&gt;sqlite_schema&lt;/a&gt; locks required by the rules enumerated below (see section &quot;Schema (sqlite_schema) Level Locking&quot;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3be7f0a767b2f2348fac25e36a455df9d59b0aa8" translate="yes" xml:space="preserve">
          <source>ReadCookie</source>
          <target state="translated">ReadCookie</target>
        </trans-unit>
        <trans-unit id="31f3f980bf6aafbf0b6a01d8c93e178b55b84057" translate="yes" xml:space="preserve">
          <source>Readers can also interpret this document as a primer on the world-view of the SQLite Founder, to help them better understand &quot;where he is coming from&quot;.</source>
          <target state="translated">Читатели также могут интерпретировать этот документ как учебник по мировосприятию Основателя SQLite,чтобы помочь им лучше понять,&quot;откуда он пришел&quot;.</target>
        </trans-unit>
        <trans-unit id="ae8a4ca543f39205e57cdf686189d6cb9f899366" translate="yes" xml:space="preserve">
          <source>Reading Data</source>
          <target state="translated">Чтение данных</target>
        </trans-unit>
        <trans-unit id="d6ac804a10ccff7c120f27eba34a8d2846e4c951" translate="yes" xml:space="preserve">
          <source>Reading Database Data</source>
          <target state="translated">Считывание данных базы данных</target>
        </trans-unit>
        <trans-unit id="5e3252839a95733cfd147953cc0469ba8c3ee82b" translate="yes" xml:space="preserve">
          <source>Reading and writing from an SQLite database is often faster than reading and writing individual files from disk. See &lt;a href=&quot;fasterthanfs&quot;&gt;35% Faster Than The Filesystem&lt;/a&gt; and &lt;a href=&quot;intern-v-extern-blob&quot;&gt;Internal Versus External BLOBs&lt;/a&gt;.</source>
          <target state="translated">Чтение и запись из базы данных SQLite часто быстрее, чем чтение и запись отдельных файлов с диска. Смотрите на &lt;a href=&quot;fasterthanfs&quot;&gt;35% быстрее, чем файловая система&lt;/a&gt; и &lt;a href=&quot;intern-v-extern-blob&quot;&gt;внутренние большие двоичные объекты по сравнению с внешними&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="629464bd60f83394a3a117af1490178a3f7649b8" translate="yes" xml:space="preserve">
          <source>Reading is about an order of magnitude faster than writing, for all systems and for both SQLite and direct-to-disk I/O.</source>
          <target state="translated">Чтение примерно на порядок быстрее,чем запись,для всех систем,как для SQLite,так и для ввода/вывода непосредственно на диск.</target>
        </trans-unit>
        <trans-unit id="8e16e5b2c446aea3b142d9320755f82932fc2cdf" translate="yes" xml:space="preserve">
          <source>Real</source>
          <target state="translated">Real</target>
        </trans-unit>
        <trans-unit id="51b9846d84b8915556858261f582bc9dc0399f32" translate="yes" xml:space="preserve">
          <source>RealAffinity</source>
          <target state="translated">RealAffinity</target>
        </trans-unit>
        <trans-unit id="316d0580c3ad15b3966bd98be1d84957c1e60292" translate="yes" xml:space="preserve">
          <source>Realign the memory allocation subsystem so that it never calls malloc() at all but instead satisfies all memory requests using a fixed-size memory buffer assigned to SQLite at startup.</source>
          <target state="translated">Выровнять подсистему выделения памяти так,чтобы она вообще никогда не вызывала malloc(),а вместо этого удовлетворяла все запросы к памяти,используя буфер памяти фиксированного размера,назначенный SQLite при старте.</target>
        </trans-unit>
        <trans-unit id="2d8e19244acdc1fed3e593bd66d86fe928aee4c4" translate="yes" xml:space="preserve">
          <source>Really means</source>
          <target state="translated">Действительно означает</target>
        </trans-unit>
        <trans-unit id="9da9cf4099ea26b56238081e57a06dfa3fa584c9" translate="yes" xml:space="preserve">
          <source>Rebase a changeset</source>
          <target state="translated">Перезагрузить изменённый набор</target>
        </trans-unit>
        <trans-unit id="f4699eec6b4e510d56bd2c8d9d97198adba02986" translate="yes" xml:space="preserve">
          <source>Rebasing changesets</source>
          <target state="translated">Изменение изменяемых параметров</target>
        </trans-unit>
        <trans-unit id="2ef8fffd38b336e3ddd055d82551d4885c779b2a" translate="yes" xml:space="preserve">
          <source>Recall that by default SQLite assumes that sector writes are linear but not atomic. A linear write starts at one end of the sector and changes information byte by byte until it gets to the other end of the sector. If a power loss occurs in the middle of a linear write then part of the sector might be modified while the other end is unchanged. In an atomic sector write, either the entire sector is overwritten or else nothing in the sector is changed.</source>
          <target state="translated">Напомним,что по умолчанию SQLite предполагает,что записи секторов являются линейными,но не атомными.Линейная запись начинается с одного конца сектора и изменяет байт за байтом информацию до тех пор,пока не достигнет другого конца сектора.Если в середине линейной записи происходит потеря питания,то часть сектора может быть изменена,а другой конец остается неизменным.В атомной записи сектора либо перезаписывается весь сектор,либо ничего не меняется в секторе.</target>
        </trans-unit>
        <trans-unit id="fe42ed2ae63e9fc51b86e94617527ae66cabf09d" translate="yes" xml:space="preserve">
          <source>Recall that there are two versions of the count() aggregate. With zero arguments, count() returns a count of the number of rows. With one argument, count() returns the number of times that the argument was non-NULL.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a00f50656a9b34825cf831a680edaba10510fe56" translate="yes" xml:space="preserve">
          <source>Recall the query template discussed above where there was a single loop that searched through every record of the table. In a join we have basically the same thing except that there are nested loops. For example, to join two tables, the query template might look something like this:</source>
          <target state="translated">Вспомните шаблон запроса,рассмотренный выше,где был один цикл,который перебирал каждую запись таблицы.В соединении мы имеем практически то же самое,за исключением того,что есть вложенные циклы.Например,для объединения двух таблиц шаблон запроса может выглядеть примерно так:</target>
        </trans-unit>
        <trans-unit id="86809186276b082875677dfb8773e34c548fc873" translate="yes" xml:space="preserve">
          <source>Recent versions of SQLite (&lt;a href=&quot;https://sqlite.org/releaselog/3_5_4.html&quot;&gt;version 3.5.4&lt;/a&gt; 2007-12-14) and later) will do this rewrite automatically if an index exists on the column ex2.b.</source>
          <target state="translated">Последние версии SQLite ( &lt;a href=&quot;https://sqlite.org/releaselog/3_5_4.html&quot;&gt;версия 3.5.4&lt;/a&gt; 2007-12-14) и более поздние версии будут выполнять эту перезапись автоматически, если в столбце ex2.b существует индекс.</target>
        </trans-unit>
        <trans-unit id="3bc92f0a6532d70c3844508e07c71adfd5cc6f39" translate="yes" xml:space="preserve">
          <source>Recently, folks have begun to use the word &quot;serverless&quot; to mean something subtly different from its intended meaning in this document. Here are two possible definitions of &quot;serverless&quot;:</source>
          <target state="translated">В последнее время люди стали использовать слово &quot;бессерверный&quot;,чтобы иметь в виду что-то тонко отличающееся от его предполагаемого значения в этом документе.Вот два возможных определения слова &quot;бессерверный&quot;:</target>
        </trans-unit>
        <trans-unit id="6aff9d1c0cd44324ba9f0bf36546b5e1f8429f77" translate="yes" xml:space="preserve">
          <source>Recognize TRUE and FALSE as constants. (For compatibility, if there exist columns named &quot;true&quot; or &quot;false&quot;, then the identifiers refer to the columns rather than Boolean constants.)</source>
          <target state="translated">Признать TRUE и FALSE постоянными.(Для совместимости,если существуют столбцы с именами &quot;true&quot; или &quot;false&quot;,то идентификаторы ссылаются на столбцы,а не на булевы константы).</target>
        </trans-unit>
        <trans-unit id="179015156dce938e7897002183aef5320bee7f01" translate="yes" xml:space="preserve">
          <source>Recognize always that evil is your own doing, and to impute it to yourself.</source>
          <target state="translated">Всегда признавай,что зло-это твое собственное дело,и вменяй его себе.</target>
        </trans-unit>
        <trans-unit id="29b5caee3338c6458807b234105f74058b4d7a0e" translate="yes" xml:space="preserve">
          <source>Recognize and use the &lt;a href=&quot;uri#coreqp&quot;&gt;mode=memory&lt;/a&gt; query parameter in &lt;a href=&quot;uri&quot;&gt;URI filenames&lt;/a&gt;.</source>
          <target state="translated">Распознавайте и используйте параметр запроса &lt;a href=&quot;uri#coreqp&quot;&gt;mode = memory&lt;/a&gt; в &lt;a href=&quot;uri&quot;&gt;именах файлов URI&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cb32b6d7f8df5da26a0dcd937f77f995164cb71d" translate="yes" xml:space="preserve">
          <source>Recommended practice is to omit any extra tokens in the rtree specification. Let each argument to &quot;rtree&quot; be a single ordinary label that is the name of the corresponding column, and omit all other tokens from the argument list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c16e180b0bdec1403e839436f75c49abbd9e4f92" translate="yes" xml:space="preserve">
          <source>Recommended storage formats are formats which, in the opinion of the preservationists at the Library of Congress, maximizes the chance of survival and continued accessibility of digital content. When selecting recommended storage formats, the following criteria are considered (quoting from the LOC website):</source>
          <target state="translated">Рекомендуемые форматы хранения-это форматы,которые,по мнению хранителей Библиотеки Конгресса,максимизируют шансы на выживание и постоянную доступность цифрового контента.При выборе рекомендуемых форматов хранения учитываются следующие критерии (цитирование с сайта Библиотеки Конгресса LOC):</target>
        </trans-unit>
        <trans-unit id="5592531a18661eb883b5bed3c568528bf424614f" translate="yes" xml:space="preserve">
          <source>Reconfigure the memory allocation subsystem to use a memory allocator other the malloc() implementation from the standard library.</source>
          <target state="translated">Переконфигурировать подсистему выделения памяти для использования аллокатора памяти другой реализации malloc()из стандартной библиотеки.</target>
        </trans-unit>
        <trans-unit id="8ba4782c1f2f1755a1c2a5a0d315ff7ac146d397" translate="yes" xml:space="preserve">
          <source>Record A Database Snapshot</source>
          <target state="translated">Запись Снимок базы данных</target>
        </trans-unit>
        <trans-unit id="8234a19b9512ea840c0ba24f55af66169cacecab" translate="yes" xml:space="preserve">
          <source>Record format</source>
          <target state="translated">Формат записи</target>
        </trans-unit>
        <trans-unit id="10c3664b2112d9f16bd331cd75392554bbbcdf62" translate="yes" xml:space="preserve">
          <source>Records may be removed from an existing zip archive by deleting the corresponding rows. For example, to remove file &quot;m.txt&quot; from zip archive &quot;test.zip&quot; using the virtual table created above:</source>
          <target state="translated">Записи могут быть удалены из существующего zip-архива путем удаления соответствующих строк.Например,удалить файл &quot;m.txt&quot; из zip-архива &quot;test.zip&quot;,используя виртуальную таблицу,созданную выше:</target>
        </trans-unit>
        <trans-unit id="9d25bfb94d2fc125544295d666182c0dd2c985e3" translate="yes" xml:space="preserve">
          <source>Recover snapshots from a wal file</source>
          <target state="translated">Восстановление снимков из бумажного файла</target>
        </trans-unit>
        <trans-unit id="a5ee4bb9875041e97087fa0bc2157c001344d43d" translate="yes" xml:space="preserve">
          <source>Recovery is run by the first thread to connect to a WAL-mode database. Recovery restores the WAL-index so that it accurately describes the WAL file. If there is no WAL file present when the first thread connects to the database, there is nothing to recover, but the recovery process still runs to initialize the WAL-index.</source>
          <target state="translated">Восстановление запускается первым потоком для подключения к базе данных WAL-режима.Recovery восстанавливает WAL-индекс так,чтобы он точно описывал файл WAL.Если при подключении первого потока к базе данных файл WAL отсутствует,то восстанавливать нечего,но процесс восстановления все равно запускается для инициализации WAL-индекса.</target>
        </trans-unit>
        <trans-unit id="bb50e77cc812505c4eff76e2425d38fe88e897da" translate="yes" xml:space="preserve">
          <source>Recovery is the process of rebuilding the WAL-index so that it is synchronized with the WAL.</source>
          <target state="translated">Восстановление-это процесс восстановления WAL-индекса так,чтобы он был синхронизирован с WAL.</target>
        </trans-unit>
        <trans-unit id="126c442522e8176d581a74aac3e674f456801a72" translate="yes" xml:space="preserve">
          <source>Recovery works by doing a single pass over the WAL, from beginning to end. The checksums are verified on each frame of the WAL as it is read. The scan stops at the end of the file or at the first invalid checksum. The &lt;a href=&quot;walformat#mxframe&quot;&gt;mxFrame&lt;/a&gt; field is set to the index of the last valid commit frame in WAL. Since WAL frame numbers are indexed starting with 1, mxFrame is also the number of valid frames in the WAL. A &quot;commit frame&quot; is a frame that has a non-zero value in bytes 4 through 7 of the frame header. Since the recovery procedure has no way of knowing how many frames of the WAL might have previously been copied back into the database, it initializes the &lt;a href=&quot;walformat#nbackfill&quot;&gt;nBackfill&lt;/a&gt; value to zero.</source>
          <target state="translated">Восстановление работает путем выполнения одного прохода по WAL от начала до конца. Контрольные суммы проверяются для каждого кадра WAL при чтении. Сканирование останавливается в конце файла или при первой неверной контрольной сумме. В поле &lt;a href=&quot;walformat#mxframe&quot;&gt;mxFrame&lt;/a&gt; устанавливается индекс последнего допустимого кадра фиксации в WAL. Поскольку номера кадров WAL индексируются, начиная с 1, mxFrame также является количеством допустимых кадров в WAL. &amp;laquo;Фрейм фиксации&amp;raquo; - это фрейм, который имеет ненулевое значение в байтах с 4 по 7 заголовка фрейма. Поскольку процедура восстановления не имеет возможности узнать, сколько кадров WAL могло быть ранее скопировано обратно в базу данных, она инициализирует значение &lt;a href=&quot;walformat#nbackfill&quot;&gt;nBackfill&lt;/a&gt; равным нулю.</target>
        </trans-unit>
        <trans-unit id="3d82c021f8a8434797b007430def5edf49be84c3" translate="yes" xml:space="preserve">
          <source>Recursive Common Table Expressions</source>
          <target state="translated">Рекурсивные общие табличные выражения</target>
        </trans-unit>
        <trans-unit id="7c623be56f37d78f01c1c7d914b54e7a24680aab" translate="yes" xml:space="preserve">
          <source>Recursive Query Examples</source>
          <target state="translated">Примеры рекурсивных запросов</target>
        </trans-unit>
        <trans-unit id="8f08fb34ad6f2633ad710e95a13cbec5c283657b" translate="yes" xml:space="preserve">
          <source>Recursive query</source>
          <target state="translated">Рекурсивный запрос</target>
        </trans-unit>
        <trans-unit id="c73052a6762ac25c0cb1d9b0bebcfc3a9bcec8a1" translate="yes" xml:space="preserve">
          <source>Recursive triggers can be enabled using the &lt;a href=&quot;pragma#pragma_recursive_triggers&quot;&gt;PRAGMA recursive_triggers&lt;/a&gt; statement.</source>
          <target state="translated">Рекурсивные триггеры можно включить с помощью &lt;a href=&quot;pragma#pragma_recursive_triggers&quot;&gt;оператора PRAGMA recursive_triggers&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="142c98a709e57d4d546600faca999a5bf35abdaa" translate="yes" xml:space="preserve">
          <source>Redesign the OS interface layer. See &lt;a href=&quot;34to35&quot;&gt;34to35.html&lt;/a&gt; for details. *** Potentially incompatible change ***</source>
          <target state="translated">Редизайн уровня интерфейса ОС. Подробнее см. &lt;a href=&quot;34to35&quot;&gt;34to35.html&lt;/a&gt; . *** Потенциально несовместимое изменение ***</target>
        </trans-unit>
        <trans-unit id="7d081723177fd4e3a870ace0d58c302ef456d798" translate="yes" xml:space="preserve">
          <source>Reduce the &lt;a href=&quot;limits&quot;&gt;limits&lt;/a&gt; that SQLite imposes on inputs. This can help prevent denial of service attacks and other kinds of mischief that can occur as a result of unusually large inputs. You can do this either at compile-time using -DSQLITE_MAX_... options, or at run-time using the &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit()&lt;/a&gt; interface. Most applications can reduce limits dramatically without impacting functionality. The table below provides some suggestions, though exact values will vary depending on the application:</source>
          <target state="translated">Уменьшите &lt;a href=&quot;limits&quot;&gt;ограничения,&lt;/a&gt; которые SQLite накладывает на входные данные. Это может помочь предотвратить атаки типа &amp;laquo;отказ в обслуживании&amp;raquo; и другие виды вреда, которые могут произойти в результате необычно больших входных данных. Вы можете сделать это либо во время компиляции, используя параметры -DSQLITE_MAX _..., либо во время выполнения, используя интерфейс &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit ()&lt;/a&gt; . Большинство приложений могут значительно уменьшить ограничения без ущерба для функциональности. В таблице ниже представлены некоторые предложения, хотя точные значения могут отличаться в зависимости от приложения:</target>
        </trans-unit>
        <trans-unit id="818c7c2bc91785e19d03eddcb38dd27df259ccaf" translate="yes" xml:space="preserve">
          <source>Reduce the amount of heap memory used, especially by TRIGGERs.</source>
          <target state="translated">Сократите объем используемой памяти кучи,особенно TRIGGERs.</target>
        </trans-unit>
        <trans-unit id="eef61fea62e3c60ebd3be2d6739fac06ddb5ab7f" translate="yes" xml:space="preserve">
          <source>Reduce the amount of memory needed to hold the schema.</source>
          <target state="translated">Уменьшить объем памяти,необходимый для хранения схемы.</target>
        </trans-unit>
        <trans-unit id="46eb8cc3e58b2e58eac841d7bad510287fbae8b0" translate="yes" xml:space="preserve">
          <source>Reduce the amount of stack space used</source>
          <target state="translated">Уменьшить количество используемого пространства стека</target>
        </trans-unit>
        <trans-unit id="2a4594bb7a13597e42630528fe396b294272a9f2" translate="yes" xml:space="preserve">
          <source>Reduce the number of memcpy() operations involved in balancing a b-tree, for 3.2% overall performance boost.</source>
          <target state="translated">Сократите количество операций memcpy(),участвующих в балансировке b-дерева,для увеличения общей производительности на 3,2%.</target>
        </trans-unit>
        <trans-unit id="15563f82edab75e0e9a9533c5985511dfd901167" translate="yes" xml:space="preserve">
          <source>Reduce the size and increase the speed of various modules, especially the virtual machine.</source>
          <target state="translated">Уменьшите размеры и увеличьте скорость работы различных модулей,особенно виртуальной машины.</target>
        </trans-unit>
        <trans-unit id="f355d2ddba29d09803b074513416794452b26fe2" translate="yes" xml:space="preserve">
          <source>Reenable the xCurrentTime and xGetLastError methods in the built-in unix &lt;a href=&quot;vfs&quot;&gt;VFSes&lt;/a&gt; as long as &lt;a href=&quot;compile#omit_deprecated&quot;&gt;SQLITE_OMIT_DEPRECATED&lt;/a&gt; is not defined.</source>
          <target state="translated">Повторно включите методы xCurrentTime и xGetLastError во встроенной в UNIX &lt;a href=&quot;vfs&quot;&gt;VFSes&lt;/a&gt; , пока &lt;a href=&quot;compile#omit_deprecated&quot;&gt;SQLITE_OMIT_DEPRECATED&lt;/a&gt; не определен.</target>
        </trans-unit>
        <trans-unit id="f79991a5be2e57d9f5c8d975047a7ce1e99e2e69" translate="yes" xml:space="preserve">
          <source>Refactor parts of the code in order to make the code footprint smaller. The code is now also a little bit faster.</source>
          <target state="translated">Рефлекторные части кода для того,чтобы уменьшить площадь,занимаемую кодом.Код теперь также немного быстрее.</target>
        </trans-unit>
        <trans-unit id="731a046a349bd8b2ec56f17167cd9586697efc8d" translate="yes" xml:space="preserve">
          <source>Refactor the implementation of PRAGMA statements to improve parsing performance.</source>
          <target state="translated">Отражать осуществление заявлений,содержащихся в системе PRAGMA,в целях улучшения результатов анализа.</target>
        </trans-unit>
        <trans-unit id="e01090e00d57212fc38896c2384f678dca5a4d12" translate="yes" xml:space="preserve">
          <source>Refactor the internal representation of SQL expressions so that they use less memory on embedded platforms.</source>
          <target state="translated">Рефакторинг внутреннего представления SQL выражений таким образом,чтобы они использовали меньше памяти на встроенных платформах.</target>
        </trans-unit>
        <trans-unit id="f207a8a558acb07f31589303df5e596105913ffb" translate="yes" xml:space="preserve">
          <source>Refactored the pager module.</source>
          <target state="translated">Переделан модуль пейджера.</target>
        </trans-unit>
        <trans-unit id="226346556688fb9ee0c75ecc678574e3685f1eba" translate="yes" xml:space="preserve">
          <source>Refer to comments in the &lt;a href=&quot;http://www.sqlite.org/src/finfo?name=ext/async/sqlite3async.h&quot;&gt; sqlite3async.h header file&lt;/a&gt; for details.</source>
          <target state="translated">Подробнее см. Комментарии в &lt;a href=&quot;http://www.sqlite.org/src/finfo?name=ext/async/sqlite3async.h&quot;&gt;заголовочном файле sqlite3async.h&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="aaa837aee763755888a50c44b690c5b28c724c42" translate="yes" xml:space="preserve">
          <source>Refer to section</source>
          <target state="translated">См.раздел</target>
        </trans-unit>
        <trans-unit id="4604acc1b8f76983f5d1c6cf4dd45f3755df9f62" translate="yes" xml:space="preserve">
          <source>Refer to the documentation for the &lt;a href=&quot;fts5#the_automerge_configuration_option&quot;&gt;FTS5 automerge option&lt;/a&gt; for more details regarding the relationship between the full-text index and its component b-trees.</source>
          <target state="translated">Обратитесь к документации по &lt;a href=&quot;fts5#the_automerge_configuration_option&quot;&gt;опции автоматического объединения FTS5&lt;/a&gt; для получения дополнительных сведений о взаимосвязи между полнотекстовым индексом и его компонентными b-деревьями.</target>
        </trans-unit>
        <trans-unit id="5c53a88bcf3d728c764909fd53351fd558c74013" translate="yes" xml:space="preserve">
          <source>Refer to the sqlite3_changegroup documentation below for details.</source>
          <target state="translated">Подробности смотрите в документации sqlite3_changegroup ниже.</target>
        </trans-unit>
        <trans-unit id="96203fca2f22f72728b0d96559374bef790492f7" translate="yes" xml:space="preserve">
          <source>Refer to wikipedia for &lt;a href=&quot;http://en.wikipedia.org/wiki/Okapi_BM25&quot;&gt;more information regarding BM25&lt;/a&gt; and its variants.</source>
          <target state="translated">Обратитесь к Википедии для получения &lt;a href=&quot;http://en.wikipedia.org/wiki/Okapi_BM25&quot;&gt;дополнительной информации о BM25&lt;/a&gt; и его вариантах.</target>
        </trans-unit>
        <trans-unit id="5d20d0fee3b91643dd8d272ac33d01ca95179d82" translate="yes" xml:space="preserve">
          <source>References</source>
          <target state="translated">References</target>
        </trans-unit>
        <trans-unit id="ed24ba4d4b3deaa5349f31379e8793cc898888c5" translate="yes" xml:space="preserve">
          <source>References to the table within CHECK constraints in the original CREATE TABLE statement.</source>
          <target state="translated">Ссылки на таблицу в пределах ограничений CHECK в первоначальном заявлении CREATE TABLE.</target>
        </trans-unit>
        <trans-unit id="f196200e5cee3f63f8cb5af84d2656fca6403f9b" translate="yes" xml:space="preserve">
          <source>References to the table within the WHERE clauses of &lt;a href=&quot;partialindex&quot;&gt;partial indexes&lt;/a&gt;.</source>
          <target state="translated">Ссылки на таблицу в разделах WHERE &lt;a href=&quot;partialindex&quot;&gt;частичных индексов&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9ee14d3156938bfc006a2f0c8ed355d9ca151ab6" translate="yes" xml:space="preserve">
          <source>References to the table within the bodies of triggers and views.</source>
          <target state="translated">Ссылки на таблицу в телах триггеров и представлений.</target>
        </trans-unit>
        <trans-unit id="906a77daf0ffffc997c9b5822b41dc5c11c3a7b9" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#alter-table-stmt&quot;&gt;alter-table-stmt&lt;/a&gt;&lt;a href=&quot;#analyze-stmt&quot;&gt;analyze-stmt&lt;/a&gt;&lt;a href=&quot;#attach-stmt&quot;&gt;attach-stmt&lt;/a&gt;&lt;a href=&quot;#begin-stmt&quot;&gt;begin-stmt&lt;/a&gt;&lt;a href=&quot;#commit-stmt&quot;&gt;commit-stmt&lt;/a&gt;&lt;a href=&quot;#create-index-stmt&quot;&gt;create-index-stmt&lt;/a&gt;&lt;a href=&quot;#create-table-stmt&quot;&gt;create-table-stmt&lt;/a&gt;&lt;a href=&quot;#create-trigger-stmt&quot;&gt;create-trigger-stmt&lt;/a&gt;&lt;a href=&quot;#create-view-stmt&quot;&gt;create-view-stmt&lt;/a&gt;&lt;a href=&quot;#create-virtual-table-stmt&quot;&gt;create-virtual-table-stmt&lt;/a&gt;&lt;a href=&quot;#delete-stmt&quot;&gt;delete-stmt&lt;/a&gt;&lt;a href=&quot;#delete-stmt-limited&quot;&gt;delete-stmt-limited&lt;/a&gt;&lt;a href=&quot;#detach-stmt&quot;&gt;detach-stmt&lt;/a&gt;&lt;a href=&quot;#drop-index-stmt&quot;&gt;drop-index-stmt&lt;/a&gt;&lt;a href=&quot;#drop-table-stmt&quot;&gt;drop-table-stmt&lt;/a&gt;&lt;a href=&quot;#drop-trigger-stmt&quot;&gt;drop-trigger-stmt&lt;/a&gt;&lt;a href=&quot;#drop-view-stmt&quot;&gt;drop-view-stmt&lt;/a&gt;&lt;a href=&quot;#insert-stmt&quot;&gt;insert-stmt&lt;/a&gt;&lt;a href=&quot;#pragma-stmt&quot;&gt;pragma-stmt&lt;/a&gt;&lt;a href=&quot;#reindex-stmt&quot;&gt;reindex-stmt&lt;/a&gt;&lt;a href=&quot;#release-stmt&quot;&gt;release-stmt&lt;/a&gt;&lt;a href=&quot;#rollback-stmt&quot;&gt;rollback-stmt&lt;/a&gt;&lt;a href=&quot;#savepoint-stmt&quot;&gt;savepoint-stmt&lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt&lt;/a&gt;&lt;a href=&quot;#update-stmt&quot;&gt;update-stmt&lt;/a&gt;&lt;a href=&quot;#update-stmt-limited&quot;&gt;update-stmt-limited&lt;/a&gt;&lt;a href=&quot;#vacuum-stmt&quot;&gt;vacuum-stmt&lt;/a&gt;</source>
          <target state="translated">Ссылки: &lt;a href=&quot;#alter-table-stmt&quot;&gt;alter-table-stmt analysis &lt;/a&gt;&lt;a href=&quot;#analyze-stmt&quot;&gt;-stmt &lt;/a&gt;&lt;a href=&quot;#attach-stmt&quot;&gt;attach-stmt &lt;/a&gt;&lt;a href=&quot;#begin-stmt&quot;&gt;begin-stmt &lt;/a&gt;&lt;a href=&quot;#commit-stmt&quot;&gt;commit-stmt &lt;/a&gt;&lt;a href=&quot;#create-index-stmt&quot;&gt;create-index-stmt &lt;/a&gt;&lt;a href=&quot;#create-table-stmt&quot;&gt;create-table-stmt &lt;/a&gt;&lt;a href=&quot;#create-trigger-stmt&quot;&gt;create-trigger-stmt &lt;/a&gt;&lt;a href=&quot;#create-view-stmt&quot;&gt;create-view-stmt &lt;/a&gt;&lt;a href=&quot;#create-virtual-table-stmt&quot;&gt;create-virtual-table-stmt &lt;/a&gt;&lt;a href=&quot;#delete-stmt&quot;&gt;delete-stmt &lt;/a&gt;&lt;a href=&quot;#delete-stmt-limited&quot;&gt;delete -stmt-limited &lt;/a&gt;&lt;a href=&quot;#detach-stmt&quot;&gt;detach-stmt &lt;/a&gt;&lt;a href=&quot;#drop-index-stmt&quot;&gt;drop-index-stmt &lt;/a&gt;&lt;a href=&quot;#drop-table-stmt&quot;&gt;drop-table-stmt &lt;/a&gt;&lt;a href=&quot;#drop-trigger-stmt&quot;&gt;drop-trigger-stmt &lt;/a&gt;&lt;a href=&quot;#drop-view-stmt&quot;&gt;drop-view-stmt &lt;/a&gt;&lt;a href=&quot;#insert-stmt&quot;&gt;insert-stmt &lt;/a&gt;&lt;a href=&quot;#pragma-stmt&quot;&gt;pragma-stmt &lt;/a&gt;&lt;a href=&quot;#reindex-stmt&quot;&gt;reindex-stmt &lt;/a&gt;&lt;a href=&quot;#release-stmt&quot;&gt;release-stmt &lt;/a&gt;&lt;a href=&quot;#rollback-stmt&quot;&gt;rollback-stmt &lt;/a&gt;&lt;a href=&quot;#savepoint-stmt&quot;&gt;savepoint-stmt &lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt &lt;/a&gt;&lt;a href=&quot;#update-stmt&quot;&gt;update- stmt &lt;/a&gt;&lt;a href=&quot;#update-stmt-limited&quot;&gt;update-stmt-limited &lt;/a&gt;&lt;a href=&quot;#vacuum-stmt&quot;&gt;вакуум-stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="91c7fe4cacb331d9cfb44eb087944db8da3afcbf" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#column-constraint&quot;&gt;column-constraint&lt;/a&gt;&lt;a href=&quot;#type-name&quot;&gt;type-name&lt;/a&gt;</source>
          <target state="translated">Ссылки: &lt;a href=&quot;#column-constraint&quot;&gt;ограничение &lt;/a&gt;&lt;a href=&quot;#type-name&quot;&gt;- &lt;/a&gt;столбец имя- типа</target>
        </trans-unit>
        <trans-unit id="6d8aed8c6ef717e51cf55fa5d410506ec56f1af1" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#column-def&quot;&gt;column-def&lt;/a&gt;</source>
          <target state="translated">Ссылки: &lt;a href=&quot;#column-def&quot;&gt;column-def&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bd54af792928e125a7c3d661324a97a3ce29b673" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#column-def&quot;&gt;column-def&lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt&lt;/a&gt;&lt;a href=&quot;#table-constraint&quot;&gt;table-constraint&lt;/a&gt;</source>
          <target state="translated">Ссылки: &lt;a href=&quot;#column-def&quot;&gt;column-def &lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt &lt;/a&gt;&lt;a href=&quot;#table-constraint&quot;&gt;table-constraint&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="071f7537398d675e45a2fdaeb7bd26af44546b4d" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#column-name-list&quot;&gt;column-name-list&lt;/a&gt;&lt;a href=&quot;#common-table-expression&quot;&gt;common-table-expression&lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;#join-clause&quot;&gt;join-clause&lt;/a&gt;&lt;a href=&quot;#ordering-term&quot;&gt;ordering-term&lt;/a&gt;&lt;a href=&quot;#qualified-table-name&quot;&gt;qualified-table-name&lt;/a&gt;&lt;a href=&quot;#table-or-subquery&quot;&gt;table-or-subquery&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="282f6190a1e00fb7ff7db1945ee84f7660a92c19" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#column-name-list&quot;&gt;column-name-list&lt;/a&gt;&lt;a href=&quot;#common-table-expression&quot;&gt;common-table-expression&lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;#join-clause&quot;&gt;join-clause&lt;/a&gt;&lt;a href=&quot;#qualified-table-name&quot;&gt;qualified-table-name&lt;/a&gt;&lt;a href=&quot;#table-or-subquery&quot;&gt;table-or-subquery&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e21742ff977fd9e5a8403d3239f8a93202fb0f39" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#column-name-list&quot;&gt;column-name-list&lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;#indexed-column&quot;&gt;indexed-column&lt;/a&gt;</source>
          <target state="translated">Ссылки: &lt;a href=&quot;#column-name-list&quot;&gt;список имен столбцов &lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;выражение &lt;/a&gt;&lt;a href=&quot;#indexed-column&quot;&gt;индексированный столбец&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3f805e85c41e9b3e30cafd3a842789358c3b6f12" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#column-name-list&quot;&gt;column-name-list&lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;#ordering-term&quot;&gt;ordering-term&lt;/a&gt;&lt;a href=&quot;#qualified-table-name&quot;&gt;qualified-table-name&lt;/a&gt;&lt;a href=&quot;#with-clause&quot;&gt;with-clause&lt;/a&gt;</source>
          <target state="translated">Ссылки: &lt;a href=&quot;#column-name-list&quot;&gt;список-имен-столбцов &lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;выражение &lt;/a&gt;&lt;a href=&quot;#ordering-term&quot;&gt;-термин &lt;/a&gt;&lt;a href=&quot;#qualified-table-name&quot;&gt;- &lt;/a&gt;заказ-термин уточненное-имя-таблицы &lt;a href=&quot;#with-clause&quot;&gt;с-предложением&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7c69d978973c2b2241d5e4e82a79030c6aad5250" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#column-name-list&quot;&gt;column-name-list&lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;#qualified-table-name&quot;&gt;qualified-table-name&lt;/a&gt;&lt;a href=&quot;#with-clause&quot;&gt;with-clause&lt;/a&gt;</source>
          <target state="translated">Ссылки: &lt;a href=&quot;#column-name-list&quot;&gt;список имен столбцов &lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;выражение &lt;/a&gt;&lt;a href=&quot;#qualified-table-name&quot;&gt;квалифицированное имя таблицы &lt;/a&gt;&lt;a href=&quot;#with-clause&quot;&gt;с предложением&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c2fd61f6a02e283a2e59272b7eb020a882319466" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#common-table-expression&quot;&gt;common-table-expression&lt;/a&gt;&lt;a href=&quot;#compound-operator&quot;&gt;compound-operator&lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;#join-clause&quot;&gt;join-clause&lt;/a&gt;&lt;a href=&quot;#ordering-term&quot;&gt;ordering-term&lt;/a&gt;&lt;a href=&quot;#result-column&quot;&gt;result-column&lt;/a&gt;&lt;a href=&quot;#table-or-subquery&quot;&gt;table-or-subquery&lt;/a&gt;&lt;a href=&quot;#window-defn&quot;&gt;window-defn&lt;/a&gt;</source>
          <target state="translated">Ссылки: &lt;a href=&quot;#compound-operator&quot;&gt;составной-оператор &lt;/a&gt;&lt;a href=&quot;#common-table-expression&quot;&gt;-выражение &lt;/a&gt;- общей-таблицы выражение - &lt;a href=&quot;#expr&quot;&gt;выражение &lt;/a&gt;&lt;a href=&quot;#join-clause&quot;&gt;-предложение &lt;/a&gt;&lt;a href=&quot;#ordering-term&quot;&gt;-термин упорядочение- &lt;/a&gt;&lt;a href=&quot;#result-column&quot;&gt;результат-столбец &lt;/a&gt;&lt;a href=&quot;#table-or-subquery&quot;&gt;таблица-или-подзапрос &lt;/a&gt;&lt;a href=&quot;#window-defn&quot;&gt;window-defn&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="667fd9a2ec0f33043daaaa5159b9ecc1f39e7b33" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#common-table-expression&quot;&gt;common-table-expression&lt;/a&gt;&lt;a href=&quot;#compound-operator&quot;&gt;compound-operator&lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;#ordering-term&quot;&gt;ordering-term&lt;/a&gt;&lt;a href=&quot;#select-core&quot;&gt;select-core&lt;/a&gt;</source>
          <target state="translated">Ссылки: &lt;a href=&quot;#common-table-expression&quot;&gt;common-table-expression &lt;/a&gt;&lt;a href=&quot;#compound-operator&quot;&gt;составной оператор &lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;#ordering-term&quot;&gt;ordering-term &lt;/a&gt;&lt;a href=&quot;#select-core&quot;&gt;select-core&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8472bb382411c88450e331d7c59babdb2e746659" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#common-table-expression&quot;&gt;common-table-expression&lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;#ordering-term&quot;&gt;ordering-term&lt;/a&gt;&lt;a href=&quot;#qualified-table-name&quot;&gt;qualified-table-name&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77d3b028f4d456c29b115c3c1f35daadd6ff1624" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#common-table-expression&quot;&gt;common-table-expression&lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;#ordering-term&quot;&gt;ordering-term&lt;/a&gt;&lt;a href=&quot;#select-core&quot;&gt;select-core&lt;/a&gt;</source>
          <target state="translated">Ссылки: &lt;a href=&quot;#common-table-expression&quot;&gt;common-table-expression &lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;#ordering-term&quot;&gt;ordering-term &lt;/a&gt;&lt;a href=&quot;#select-core&quot;&gt;select-core&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1f8ccd3795f8b71bf70343d3fadc3ac179cc9d91" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#common-table-expression&quot;&gt;common-table-expression&lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;#qualified-table-name&quot;&gt;qualified-table-name&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a74b1ac9b009442b86c0a0250e3450f6dd245c7" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#common-table-expression&quot;&gt;common-table-expression&lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt&lt;/a&gt;&lt;a href=&quot;#upsert-clause&quot;&gt;upsert-clause&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="093e3a3349236fc2dfd7410c161635443356bb67" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#conflict-clause&quot;&gt;conflict-clause&lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;#foreign-key-clause&quot;&gt;foreign-key-clause&lt;/a&gt;&lt;a href=&quot;#indexed-column&quot;&gt;indexed-column&lt;/a&gt;</source>
          <target state="translated">Ссылки: &lt;a href=&quot;#expr&quot;&gt;выражение &lt;/a&gt;&lt;a href=&quot;#foreign-key-clause&quot;&gt;- &lt;/a&gt;&lt;a href=&quot;#conflict-clause&quot;&gt;конфликт &lt;/a&gt;-предложение, &lt;a href=&quot;#indexed-column&quot;&gt;индексированный-столбец-предложение.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="75b80513956bb1581ff56ceefb5d202b11f453b7" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#conflict-clause&quot;&gt;conflict-clause&lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;#foreign-key-clause&quot;&gt;foreign-key-clause&lt;/a&gt;&lt;a href=&quot;#literal-value&quot;&gt;literal-value&lt;/a&gt;&lt;a href=&quot;#signed-number&quot;&gt;signed-number&lt;/a&gt;</source>
          <target state="translated">Ссылки: &lt;a href=&quot;#expr&quot;&gt;выражение &lt;/a&gt;&lt;a href=&quot;#conflict-clause&quot;&gt;-условие-конфликт &lt;/a&gt;выражение -предложение- &lt;a href=&quot;#foreign-key-clause&quot;&gt;внешнего- &lt;/a&gt;&lt;a href=&quot;#literal-value&quot;&gt;буквальное-значение &lt;/a&gt;&lt;a href=&quot;#signed-number&quot;&gt;-число со знаком&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d11da2b5af692e996d5a48b32dfe86b2041eb8fa" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#cte-table-name&quot;&gt;cte-table-name&lt;/a&gt;</source>
          <target state="translated">Ссылки: &lt;a href=&quot;#cte-table-name&quot;&gt;cte-table-name&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7d0820e324079711069f47384d996edb389c3588" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#cte-table-name&quot;&gt;cte-table-name&lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt&lt;/a&gt;</source>
          <target state="translated">Ссылки: &lt;a href=&quot;#cte-table-name&quot;&gt;cte-table-name &lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="20cbc57031b425ef7fc75a576696f91fe9b3d951" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#delete-stmt&quot;&gt;delete-stmt&lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;#insert-stmt&quot;&gt;insert-stmt&lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt&lt;/a&gt;&lt;a href=&quot;#update-stmt&quot;&gt;update-stmt&lt;/a&gt;</source>
          <target state="translated">Ссылки: &lt;a href=&quot;#delete-stmt&quot;&gt;delete-stmt &lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;#insert-stmt&quot;&gt;insert-stmt &lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt &lt;/a&gt;&lt;a href=&quot;#update-stmt&quot;&gt;update-stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="93149806f66b1921c7517b514d80a3b282666f6b" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;</source>
          <target state="translated">Ссылки: &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8bd75a2c3ba3eeca6c41d3a9318cbfdbb49e88c0" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;#filter-clause&quot;&gt;filter-clause&lt;/a&gt;</source>
          <target state="translated">Ссылки: &lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;#filter-clause&quot;&gt;filter-clause&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="af58968390f59e5f5b4c323addb3e01a57ee6c1e" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;#filter-clause&quot;&gt;filter-clause&lt;/a&gt;&lt;a href=&quot;#window-defn&quot;&gt;window-defn&lt;/a&gt;</source>
          <target state="translated">Ссылки: &lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;#filter-clause&quot;&gt;filter-clause &lt;/a&gt;&lt;a href=&quot;#window-defn&quot;&gt;window-defn&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="32f96f5ec0fb2907e9e4e032ea0ae81ddc82a1a3" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;#frame-spec&quot;&gt;frame-spec&lt;/a&gt;&lt;a href=&quot;#ordering-term&quot;&gt;ordering-term&lt;/a&gt;</source>
          <target state="translated">Ссылки: &lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;#frame-spec&quot;&gt;frame-spec &lt;/a&gt;&lt;a href=&quot;#ordering-term&quot;&gt;ordering-term&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a9dbf0458189780b769224889b3056c63b7e1f84" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;#indexed-column&quot;&gt;indexed-column&lt;/a&gt;</source>
          <target state="translated">Ссылки: &lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;#indexed-column&quot;&gt;indexed-column&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="59c40f8bbdab8cad4f5af93d93f71d7dbf30aa93" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;#join-clause&quot;&gt;join-clause&lt;/a&gt;&lt;a href=&quot;#result-column&quot;&gt;result-column&lt;/a&gt;&lt;a href=&quot;#table-or-subquery&quot;&gt;table-or-subquery&lt;/a&gt;&lt;a href=&quot;#window-defn&quot;&gt;window-defn&lt;/a&gt;</source>
          <target state="translated">Ссылки: &lt;a href=&quot;#expr&quot;&gt;выражение &lt;/a&gt;&lt;a href=&quot;#join-clause&quot;&gt;-предложение &lt;/a&gt;&lt;a href=&quot;#result-column&quot;&gt;-столбец &lt;/a&gt;- результат-столбец &lt;a href=&quot;#table-or-subquery&quot;&gt;таблица-или-подзапрос &lt;/a&gt;&lt;a href=&quot;#window-defn&quot;&gt;window-defn&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5b9919027e05781036111a8daacdadf3c525fde5" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;#join-clause&quot;&gt;join-clause&lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt&lt;/a&gt;</source>
          <target state="translated">Ссылки: &lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;#join-clause&quot;&gt;join-clause &lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0773bdc1abf8efee6c1c60cecf9ee9685433dab7" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;#ordering-term&quot;&gt;ordering-term&lt;/a&gt;&lt;a href=&quot;#qualified-table-name&quot;&gt;qualified-table-name&lt;/a&gt;&lt;a href=&quot;#with-clause&quot;&gt;with-clause&lt;/a&gt;</source>
          <target state="translated">Ссылки: &lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;#ordering-term&quot;&gt;ordering-term &lt;/a&gt;&lt;a href=&quot;#qualified-table-name&quot;&gt;квалифицированное-имя-таблицы &lt;/a&gt;&lt;a href=&quot;#with-clause&quot;&gt;с предложением&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="24422bef8d6810e38018f045129e207f3e959155" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;#qualified-table-name&quot;&gt;qualified-table-name&lt;/a&gt;&lt;a href=&quot;#with-clause&quot;&gt;with-clause&lt;/a&gt;</source>
          <target state="translated">Ссылки: &lt;a href=&quot;#expr&quot;&gt;выражение &lt;/a&gt;&lt;a href=&quot;#qualified-table-name&quot;&gt;квалифицированное имя-таблицы &lt;/a&gt;&lt;a href=&quot;#with-clause&quot;&gt;с предложением&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="85f3810be175c469cf369360e14b9b2e5e01ac51" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt&lt;/a&gt;&lt;a href=&quot;#upsert-clause&quot;&gt;upsert-clause&lt;/a&gt;&lt;a href=&quot;#with-clause&quot;&gt;with-clause&lt;/a&gt;</source>
          <target state="translated">Ссылки: &lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt &lt;/a&gt;&lt;a href=&quot;#upsert-clause&quot;&gt;upsert-clause &lt;/a&gt;&lt;a href=&quot;#with-clause&quot;&gt;with-clause&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="70abaefe9f99828256cfd758a3afb7aa4c216e61" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#filter-clause&quot;&gt;filter-clause&lt;/a&gt;&lt;a href=&quot;#literal-value&quot;&gt;literal-value&lt;/a&gt;&lt;a href=&quot;#over-clause&quot;&gt;over-clause&lt;/a&gt;&lt;a href=&quot;#raise-function&quot;&gt;raise-function&lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt&lt;/a&gt;&lt;a href=&quot;#type-name&quot;&gt;type-name&lt;/a&gt;</source>
          <target state="translated">Ссылки: &lt;a href=&quot;#filter-clause&quot;&gt;предложение &lt;/a&gt;&lt;a href=&quot;#literal-value&quot;&gt;- &lt;/a&gt;фильтр буквальное-значение &lt;a href=&quot;#over-clause&quot;&gt;-предложение &lt;/a&gt;&lt;a href=&quot;#raise-function&quot;&gt;-функция &lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;- &lt;/a&gt;поднятие- выбор-stmt &lt;a href=&quot;#type-name&quot;&gt;имя &lt;/a&gt;- типа</target>
        </trans-unit>
        <trans-unit id="c999a62fb82e126ba176715636e35111bb542d88" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#join-constraint&quot;&gt;join-constraint&lt;/a&gt;&lt;a href=&quot;#join-operator&quot;&gt;join-operator&lt;/a&gt;&lt;a href=&quot;#table-or-subquery&quot;&gt;table-or-subquery&lt;/a&gt;</source>
          <target state="translated">Ссылки: &lt;a href=&quot;#join-constraint&quot;&gt;ограничение &lt;/a&gt;&lt;a href=&quot;#join-operator&quot;&gt;соединения &lt;/a&gt;&lt;a href=&quot;#table-or-subquery&quot;&gt;таблица или подзапрос &lt;/a&gt;оператора соединения</target>
        </trans-unit>
        <trans-unit id="3ad3c1f9f2a404dc774db57c85b8cec60718ee04" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#pragma-value&quot;&gt;pragma-value&lt;/a&gt;</source>
          <target state="translated">Ссылки: &lt;a href=&quot;#pragma-value&quot;&gt;pragma-value&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="442eba43f59acab4d01a4fc91704194929768abd" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#select-stmt&quot;&gt;select-stmt&lt;/a&gt;</source>
          <target state="translated">Ссылки: &lt;a href=&quot;#select-stmt&quot;&gt;select-stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="be27274cd4dccea52cefd3991def25081da71262" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#signed-number&quot;&gt;signed-number&lt;/a&gt;</source>
          <target state="translated">Ссылки: &lt;a href=&quot;#signed-number&quot;&gt;номер со знаком&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a57a4e147f3de189d6e7e73c4c51f52022e0bd82" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#sql-stmt&quot;&gt;sql-stmt&lt;/a&gt;</source>
          <target state="translated">Ссылки: &lt;a href=&quot;#sql-stmt&quot;&gt;sql-stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="38492d751f295bea065fa71e3925fb3ad037a1e2" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;alter-table-stmt&quot;&gt;alter-table-stmt&lt;/a&gt;&lt;a href=&quot;analyze-stmt&quot;&gt;analyze-stmt&lt;/a&gt;&lt;a href=&quot;attach-stmt&quot;&gt;attach-stmt&lt;/a&gt;&lt;a href=&quot;begin-stmt&quot;&gt;begin-stmt&lt;/a&gt;&lt;a href=&quot;commit-stmt&quot;&gt;commit-stmt&lt;/a&gt;&lt;a href=&quot;create-index-stmt&quot;&gt;create-index-stmt&lt;/a&gt;&lt;a href=&quot;create-table-stmt&quot;&gt;create-table-stmt&lt;/a&gt;&lt;a href=&quot;create-trigger-stmt&quot;&gt;create-trigger-stmt&lt;/a&gt;&lt;a href=&quot;create-view-stmt&quot;&gt;create-view-stmt&lt;/a&gt;&lt;a href=&quot;create-virtual-table-stmt&quot;&gt;create-virtual-table-stmt&lt;/a&gt;&lt;a href=&quot;delete-stmt&quot;&gt;delete-stmt&lt;/a&gt;&lt;a href=&quot;delete-stmt-limited&quot;&gt;delete-stmt-limited&lt;/a&gt;&lt;a href=&quot;detach-stmt&quot;&gt;detach-stmt&lt;/a&gt;&lt;a href=&quot;drop-index-stmt&quot;&gt;drop-index-stmt&lt;/a&gt;&lt;a href=&quot;drop-table-stmt&quot;&gt;drop-table-stmt&lt;/a&gt;&lt;a href=&quot;drop-trigger-stmt&quot;&gt;drop-trigger-stmt&lt;/a&gt;&lt;a href=&quot;drop-view-stmt&quot;&gt;drop-view-stmt&lt;/a&gt;&lt;a href=&quot;insert-stmt&quot;&gt;insert-stmt&lt;/a&gt;&lt;a href=&quot;pragma-stmt&quot;&gt;pragma-stmt&lt;/a&gt;&lt;a href=&quot;reindex-stmt&quot;&gt;reindex-stmt&lt;/a&gt;&lt;a href=&quot;release-stmt&quot;&gt;release-stmt&lt;/a&gt;&lt;a href=&quot;rollback-stmt&quot;&gt;rollback-stmt&lt;/a&gt;&lt;a href=&quot;savepoint-stmt&quot;&gt;savepoint-stmt&lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt&lt;/a&gt;&lt;a href=&quot;update-stmt&quot;&gt;update-stmt&lt;/a&gt;&lt;a href=&quot;update-stmt-limited&quot;&gt;update-stmt-limited&lt;/a&gt;&lt;a href=&quot;vacuum-stmt&quot;&gt;vacuum-stmt&lt;/a&gt;</source>
          <target state="translated">Ссылки: &lt;a href=&quot;alter-table-stmt&quot;&gt;alter-table-stmt analysis &lt;/a&gt;&lt;a href=&quot;analyze-stmt&quot;&gt;-stmt &lt;/a&gt;&lt;a href=&quot;attach-stmt&quot;&gt;attach-stmt &lt;/a&gt;&lt;a href=&quot;begin-stmt&quot;&gt;begin-stmt &lt;/a&gt;&lt;a href=&quot;commit-stmt&quot;&gt;commit-stmt &lt;/a&gt;&lt;a href=&quot;create-index-stmt&quot;&gt;create-index-stmt &lt;/a&gt;&lt;a href=&quot;create-table-stmt&quot;&gt;create-table-stmt &lt;/a&gt;&lt;a href=&quot;create-trigger-stmt&quot;&gt;create-trigger-stmt &lt;/a&gt;&lt;a href=&quot;create-view-stmt&quot;&gt;create-view-stmt &lt;/a&gt;&lt;a href=&quot;create-virtual-table-stmt&quot;&gt;create-virtual-table-stmt &lt;/a&gt;&lt;a href=&quot;delete-stmt&quot;&gt;delete-stmt &lt;/a&gt;&lt;a href=&quot;delete-stmt-limited&quot;&gt;delete -stmt-limited &lt;/a&gt;&lt;a href=&quot;detach-stmt&quot;&gt;detach-stmt &lt;/a&gt;&lt;a href=&quot;drop-index-stmt&quot;&gt;drop-index-stmt &lt;/a&gt;&lt;a href=&quot;drop-table-stmt&quot;&gt;drop-table-stmt &lt;/a&gt;&lt;a href=&quot;drop-trigger-stmt&quot;&gt;drop-trigger-stmt &lt;/a&gt;&lt;a href=&quot;drop-view-stmt&quot;&gt;drop-view-stmt &lt;/a&gt;&lt;a href=&quot;insert-stmt&quot;&gt;insert-stmt &lt;/a&gt;&lt;a href=&quot;pragma-stmt&quot;&gt;pragma-stmt &lt;/a&gt;&lt;a href=&quot;reindex-stmt&quot;&gt;reindex-stmt &lt;/a&gt;&lt;a href=&quot;release-stmt&quot;&gt;release-stmt &lt;/a&gt;&lt;a href=&quot;rollback-stmt&quot;&gt;rollback-stmt &lt;/a&gt;&lt;a href=&quot;savepoint-stmt&quot;&gt;savepoint-stmt &lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt &lt;/a&gt;&lt;a href=&quot;update-stmt&quot;&gt;update- stmt &lt;/a&gt;&lt;a href=&quot;update-stmt-limited&quot;&gt;update-stmt-limited &lt;/a&gt;&lt;a href=&quot;vacuum-stmt&quot;&gt;вакуум-stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="650835c724bb2a86f89f84e9bbd3b780c13b6c9b" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;column-constraint&quot;&gt;column-constraint&lt;/a&gt;&lt;a href=&quot;type-name&quot;&gt;type-name&lt;/a&gt;</source>
          <target state="translated">Ссылки: &lt;a href=&quot;column-constraint&quot;&gt;ограничение &lt;/a&gt;&lt;a href=&quot;type-name&quot;&gt;- &lt;/a&gt;столбец имя- типа</target>
        </trans-unit>
        <trans-unit id="794b40cf8cd20637c83761e0684d3f4a5ca08040" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;column-def&quot;&gt;column-def&lt;/a&gt;</source>
          <target state="translated">Ссылки: &lt;a href=&quot;column-def&quot;&gt;column-def&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="aa218b2013469fb9882536f9cece6e55484d18b7" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;column-def&quot;&gt;column-def&lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt&lt;/a&gt;&lt;a href=&quot;table-constraint&quot;&gt;table-constraint&lt;/a&gt;</source>
          <target state="translated">Ссылки: &lt;a href=&quot;column-def&quot;&gt;column-def &lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt &lt;/a&gt;&lt;a href=&quot;table-constraint&quot;&gt;table-constraint&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5321f3c79df9e1ae13dc45785cee7ab2db6ce76c" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;column-name-list&quot;&gt;column-name-list&lt;/a&gt;&lt;a href=&quot;common-table-expression&quot;&gt;common-table-expression&lt;/a&gt;&lt;a href=&quot;expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;join-clause&quot;&gt;join-clause&lt;/a&gt;&lt;a href=&quot;ordering-term&quot;&gt;ordering-term&lt;/a&gt;&lt;a href=&quot;qualified-table-name&quot;&gt;qualified-table-name&lt;/a&gt;&lt;a href=&quot;table-or-subquery&quot;&gt;table-or-subquery&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d04da558e7b275ed093eaddcfd1b8fc7d2f8e276" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;column-name-list&quot;&gt;column-name-list&lt;/a&gt;&lt;a href=&quot;common-table-expression&quot;&gt;common-table-expression&lt;/a&gt;&lt;a href=&quot;expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;join-clause&quot;&gt;join-clause&lt;/a&gt;&lt;a href=&quot;qualified-table-name&quot;&gt;qualified-table-name&lt;/a&gt;&lt;a href=&quot;table-or-subquery&quot;&gt;table-or-subquery&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0efb77e2ca9ef9f00e4b6a166106c03c563ce0be" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;column-name-list&quot;&gt;column-name-list&lt;/a&gt;&lt;a href=&quot;expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;indexed-column&quot;&gt;indexed-column&lt;/a&gt;</source>
          <target state="translated">Ссылки: &lt;a href=&quot;column-name-list&quot;&gt;список имен столбцов &lt;/a&gt;&lt;a href=&quot;expr&quot;&gt;выражение &lt;/a&gt;&lt;a href=&quot;indexed-column&quot;&gt;индексированный столбец&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e4f6089017390e83489b6d24ed571adac8331d80" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;column-name-list&quot;&gt;column-name-list&lt;/a&gt;&lt;a href=&quot;expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;ordering-term&quot;&gt;ordering-term&lt;/a&gt;&lt;a href=&quot;qualified-table-name&quot;&gt;qualified-table-name&lt;/a&gt;&lt;a href=&quot;with-clause&quot;&gt;with-clause&lt;/a&gt;</source>
          <target state="translated">Ссылки: &lt;a href=&quot;column-name-list&quot;&gt;список-имен-столбцов &lt;/a&gt;&lt;a href=&quot;expr&quot;&gt;выражение &lt;/a&gt;&lt;a href=&quot;ordering-term&quot;&gt;-термин &lt;/a&gt;&lt;a href=&quot;qualified-table-name&quot;&gt;- &lt;/a&gt;заказ-термин уточненное-имя-таблицы &lt;a href=&quot;with-clause&quot;&gt;с-предложением&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1113daac28cbd063c08079443895f5566fdb33e5" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;column-name-list&quot;&gt;column-name-list&lt;/a&gt;&lt;a href=&quot;expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;qualified-table-name&quot;&gt;qualified-table-name&lt;/a&gt;&lt;a href=&quot;with-clause&quot;&gt;with-clause&lt;/a&gt;</source>
          <target state="translated">Ссылки: &lt;a href=&quot;column-name-list&quot;&gt;список имен столбцов &lt;/a&gt;&lt;a href=&quot;expr&quot;&gt;выражение &lt;/a&gt;&lt;a href=&quot;qualified-table-name&quot;&gt;квалифицированное имя таблицы &lt;/a&gt;&lt;a href=&quot;with-clause&quot;&gt;с предложением&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d3451b0f3b2b5af6b8d8b5aaefde1b19828f7a6c" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;common-table-expression&quot;&gt;common-table-expression&lt;/a&gt;&lt;a href=&quot;compound-operator&quot;&gt;compound-operator&lt;/a&gt;&lt;a href=&quot;expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;join-clause&quot;&gt;join-clause&lt;/a&gt;&lt;a href=&quot;ordering-term&quot;&gt;ordering-term&lt;/a&gt;&lt;a href=&quot;result-column&quot;&gt;result-column&lt;/a&gt;&lt;a href=&quot;table-or-subquery&quot;&gt;table-or-subquery&lt;/a&gt;&lt;a href=&quot;window-defn&quot;&gt;window-defn&lt;/a&gt;</source>
          <target state="translated">Ссылки: &lt;a href=&quot;compound-operator&quot;&gt;составной-оператор &lt;/a&gt;&lt;a href=&quot;common-table-expression&quot;&gt;-выражение &lt;/a&gt;- общей-таблицы выражение - &lt;a href=&quot;expr&quot;&gt;выражение &lt;/a&gt;&lt;a href=&quot;join-clause&quot;&gt;-предложение &lt;/a&gt;&lt;a href=&quot;ordering-term&quot;&gt;-термин упорядочение- &lt;/a&gt;&lt;a href=&quot;result-column&quot;&gt;результат-столбец &lt;/a&gt;&lt;a href=&quot;table-or-subquery&quot;&gt;таблица-или-подзапрос &lt;/a&gt;&lt;a href=&quot;window-defn&quot;&gt;window-defn&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bba4382f55d6ffe66c81fa9289d49182e1355fcb" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;common-table-expression&quot;&gt;common-table-expression&lt;/a&gt;&lt;a href=&quot;compound-operator&quot;&gt;compound-operator&lt;/a&gt;&lt;a href=&quot;expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;ordering-term&quot;&gt;ordering-term&lt;/a&gt;&lt;a href=&quot;select-core&quot;&gt;select-core&lt;/a&gt;</source>
          <target state="translated">Ссылки: &lt;a href=&quot;common-table-expression&quot;&gt;common-table-expression &lt;/a&gt;&lt;a href=&quot;compound-operator&quot;&gt;составной оператор &lt;/a&gt;&lt;a href=&quot;expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;ordering-term&quot;&gt;ordering-term &lt;/a&gt;&lt;a href=&quot;select-core&quot;&gt;select-core&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8b632fa679cae46b9a02f325553f2a2a7613b116" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;common-table-expression&quot;&gt;common-table-expression&lt;/a&gt;&lt;a href=&quot;expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;ordering-term&quot;&gt;ordering-term&lt;/a&gt;&lt;a href=&quot;qualified-table-name&quot;&gt;qualified-table-name&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79d31ae5a462b6f054075ad5596a58eef1283d37" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;common-table-expression&quot;&gt;common-table-expression&lt;/a&gt;&lt;a href=&quot;expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;ordering-term&quot;&gt;ordering-term&lt;/a&gt;&lt;a href=&quot;select-core&quot;&gt;select-core&lt;/a&gt;</source>
          <target state="translated">Ссылки: &lt;a href=&quot;common-table-expression&quot;&gt;common-table-expression &lt;/a&gt;&lt;a href=&quot;expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;ordering-term&quot;&gt;ordering-term &lt;/a&gt;&lt;a href=&quot;select-core&quot;&gt;select-core&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1445ac57fe2b5334ccb8353e30f33be3e0e94b22" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;common-table-expression&quot;&gt;common-table-expression&lt;/a&gt;&lt;a href=&quot;expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;qualified-table-name&quot;&gt;qualified-table-name&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91e02a407b8ce1872e126aedfe89133ac0d4f641" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;common-table-expression&quot;&gt;common-table-expression&lt;/a&gt;&lt;a href=&quot;expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt&lt;/a&gt;&lt;a href=&quot;upsert-clause&quot;&gt;upsert-clause&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8df9ea1d38fc83cf8d4c226cc463aaf1077b0c6f" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;conflict-clause&quot;&gt;conflict-clause&lt;/a&gt;&lt;a href=&quot;expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;foreign-key-clause&quot;&gt;foreign-key-clause&lt;/a&gt;&lt;a href=&quot;indexed-column&quot;&gt;indexed-column&lt;/a&gt;</source>
          <target state="translated">Ссылки: &lt;a href=&quot;expr&quot;&gt;выражение &lt;/a&gt;&lt;a href=&quot;foreign-key-clause&quot;&gt;- &lt;/a&gt;&lt;a href=&quot;conflict-clause&quot;&gt;конфликт &lt;/a&gt;-предложение, &lt;a href=&quot;indexed-column&quot;&gt;индексированный-столбец-предложение.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b098cacd25ca6e0fe7a4f6cbe7dc7b7acf41b7b8" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;conflict-clause&quot;&gt;conflict-clause&lt;/a&gt;&lt;a href=&quot;expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;foreign-key-clause&quot;&gt;foreign-key-clause&lt;/a&gt;&lt;a href=&quot;literal-value&quot;&gt;literal-value&lt;/a&gt;&lt;a href=&quot;signed-number&quot;&gt;signed-number&lt;/a&gt;</source>
          <target state="translated">Ссылки: &lt;a href=&quot;expr&quot;&gt;выражение &lt;/a&gt;&lt;a href=&quot;conflict-clause&quot;&gt;-условие-конфликт &lt;/a&gt;выражение -предложение- &lt;a href=&quot;foreign-key-clause&quot;&gt;внешнего- &lt;/a&gt;&lt;a href=&quot;literal-value&quot;&gt;буквальное-значение &lt;/a&gt;&lt;a href=&quot;signed-number&quot;&gt;-число со знаком&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="21f46943158a8d7768ec74ac4bca397f3d7466cc" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;cte-table-name&quot;&gt;cte-table-name&lt;/a&gt;</source>
          <target state="translated">Ссылки: &lt;a href=&quot;cte-table-name&quot;&gt;cte-table-name&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="52f4dcceccfec99df86cc955c80ee8cdbaf49960" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;cte-table-name&quot;&gt;cte-table-name&lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt&lt;/a&gt;</source>
          <target state="translated">Ссылки: &lt;a href=&quot;cte-table-name&quot;&gt;cte-table-name &lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="96f363ba239b93df7e224622a52457e08203ac21" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;delete-stmt&quot;&gt;delete-stmt&lt;/a&gt;&lt;a href=&quot;expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;insert-stmt&quot;&gt;insert-stmt&lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt&lt;/a&gt;&lt;a href=&quot;update-stmt&quot;&gt;update-stmt&lt;/a&gt;</source>
          <target state="translated">Ссылки: &lt;a href=&quot;delete-stmt&quot;&gt;delete-stmt &lt;/a&gt;&lt;a href=&quot;expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;insert-stmt&quot;&gt;insert-stmt &lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt &lt;/a&gt;&lt;a href=&quot;update-stmt&quot;&gt;update-stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b1460387ec8f592a739d62fe04e5527e471ea1d0" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;expr&quot;&gt;expr&lt;/a&gt;</source>
          <target state="translated">Ссылки: &lt;a href=&quot;expr&quot;&gt;expr&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="192d6846ace3aa19cd52dd4ee585f12a733bb1e7" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;filter-clause&quot;&gt;filter-clause&lt;/a&gt;</source>
          <target state="translated">Ссылки: &lt;a href=&quot;expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;filter-clause&quot;&gt;filter-clause&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c9283f303c0dddff0aeb96fe77630b3f0f7f1cd0" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;filter-clause&quot;&gt;filter-clause&lt;/a&gt;&lt;a href=&quot;window-defn&quot;&gt;window-defn&lt;/a&gt;</source>
          <target state="translated">Ссылки: &lt;a href=&quot;expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;filter-clause&quot;&gt;filter-clause &lt;/a&gt;&lt;a href=&quot;window-defn&quot;&gt;window-defn&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="885613b30bdc3bb4e3fc4bfce7226fd3a4194313" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;frame-spec&quot;&gt;frame-spec&lt;/a&gt;&lt;a href=&quot;ordering-term&quot;&gt;ordering-term&lt;/a&gt;</source>
          <target state="translated">Ссылки: &lt;a href=&quot;expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;frame-spec&quot;&gt;frame-spec &lt;/a&gt;&lt;a href=&quot;ordering-term&quot;&gt;ordering-term&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5bbd33495175a536a093475520310921d8e80cb9" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;indexed-column&quot;&gt;indexed-column&lt;/a&gt;</source>
          <target state="translated">Ссылки: &lt;a href=&quot;expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;indexed-column&quot;&gt;indexed-column&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5ac7994da54203d91b06af47c53b1f26548090ed" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;join-clause&quot;&gt;join-clause&lt;/a&gt;&lt;a href=&quot;result-column&quot;&gt;result-column&lt;/a&gt;&lt;a href=&quot;table-or-subquery&quot;&gt;table-or-subquery&lt;/a&gt;&lt;a href=&quot;window-defn&quot;&gt;window-defn&lt;/a&gt;</source>
          <target state="translated">Ссылки: &lt;a href=&quot;expr&quot;&gt;выражение &lt;/a&gt;&lt;a href=&quot;join-clause&quot;&gt;-предложение &lt;/a&gt;&lt;a href=&quot;result-column&quot;&gt;-столбец &lt;/a&gt;- результат-столбец &lt;a href=&quot;table-or-subquery&quot;&gt;таблица-или-подзапрос &lt;/a&gt;&lt;a href=&quot;window-defn&quot;&gt;window-defn&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5211947595082a78c56fd9fbfa97e9aa9db46e39" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;join-clause&quot;&gt;join-clause&lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt&lt;/a&gt;</source>
          <target state="translated">Ссылки: &lt;a href=&quot;expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;join-clause&quot;&gt;join-clause &lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8ef3d4989ffca292fb408e36d6c80a0be05d38e3" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;ordering-term&quot;&gt;ordering-term&lt;/a&gt;&lt;a href=&quot;qualified-table-name&quot;&gt;qualified-table-name&lt;/a&gt;&lt;a href=&quot;with-clause&quot;&gt;with-clause&lt;/a&gt;</source>
          <target state="translated">Ссылки: &lt;a href=&quot;expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;ordering-term&quot;&gt;ordering-term &lt;/a&gt;&lt;a href=&quot;qualified-table-name&quot;&gt;квалифицированное-имя-таблицы &lt;/a&gt;&lt;a href=&quot;with-clause&quot;&gt;с предложением&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2f754738e511b595c21699d1599455b2ad77e7ea" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;qualified-table-name&quot;&gt;qualified-table-name&lt;/a&gt;&lt;a href=&quot;with-clause&quot;&gt;with-clause&lt;/a&gt;</source>
          <target state="translated">Ссылки: &lt;a href=&quot;expr&quot;&gt;выражение &lt;/a&gt;&lt;a href=&quot;qualified-table-name&quot;&gt;квалифицированное имя-таблицы &lt;/a&gt;&lt;a href=&quot;with-clause&quot;&gt;с предложением&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="10dff942ab951e8379beded21b97716b5a9470ac" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt&lt;/a&gt;&lt;a href=&quot;upsert-clause&quot;&gt;upsert-clause&lt;/a&gt;&lt;a href=&quot;with-clause&quot;&gt;with-clause&lt;/a&gt;</source>
          <target state="translated">Ссылки: &lt;a href=&quot;expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt &lt;/a&gt;&lt;a href=&quot;upsert-clause&quot;&gt;upsert-clause &lt;/a&gt;&lt;a href=&quot;with-clause&quot;&gt;with-clause&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="aead43f0300958c1d62f97ac7d9dbb7744c5f973" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;filter-clause&quot;&gt;filter-clause&lt;/a&gt;&lt;a href=&quot;literal-value&quot;&gt;literal-value&lt;/a&gt;&lt;a href=&quot;over-clause&quot;&gt;over-clause&lt;/a&gt;&lt;a href=&quot;raise-function&quot;&gt;raise-function&lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt&lt;/a&gt;&lt;a href=&quot;type-name&quot;&gt;type-name&lt;/a&gt;</source>
          <target state="translated">Ссылки: &lt;a href=&quot;filter-clause&quot;&gt;предложение &lt;/a&gt;&lt;a href=&quot;literal-value&quot;&gt;- &lt;/a&gt;фильтр буквальное-значение &lt;a href=&quot;over-clause&quot;&gt;-предложение &lt;/a&gt;&lt;a href=&quot;raise-function&quot;&gt;-функция &lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;- &lt;/a&gt;поднятие- выбор-stmt &lt;a href=&quot;type-name&quot;&gt;имя &lt;/a&gt;- типа</target>
        </trans-unit>
        <trans-unit id="e4a21a32ca632c80e791992375d683d3cb2b152e" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;join-constraint&quot;&gt;join-constraint&lt;/a&gt;&lt;a href=&quot;join-operator&quot;&gt;join-operator&lt;/a&gt;&lt;a href=&quot;table-or-subquery&quot;&gt;table-or-subquery&lt;/a&gt;</source>
          <target state="translated">Ссылки: &lt;a href=&quot;join-constraint&quot;&gt;ограничение &lt;/a&gt;&lt;a href=&quot;join-operator&quot;&gt;соединения &lt;/a&gt;&lt;a href=&quot;table-or-subquery&quot;&gt;таблица или подзапрос &lt;/a&gt;оператора соединения</target>
        </trans-unit>
        <trans-unit id="eab2c400e1da9841def91aa5e9939c315ac03195" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;pragma-value&quot;&gt;pragma-value&lt;/a&gt;</source>
          <target state="translated">Ссылки: &lt;a href=&quot;pragma-value&quot;&gt;pragma-value&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9ba25d3b7bd9b22c410033510c17375ba8fbc355" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;select-stmt&quot;&gt;select-stmt&lt;/a&gt;</source>
          <target state="translated">Ссылки: &lt;a href=&quot;select-stmt&quot;&gt;select-stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1911821b127dd809d42d87c2ae5a010deb04e3f1" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;signed-number&quot;&gt;signed-number&lt;/a&gt;</source>
          <target state="translated">Ссылки: &lt;a href=&quot;signed-number&quot;&gt;номер со знаком&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4105cc2bca5aa3561ea07c37d7a688f2cefa3733" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;sql-stmt&quot;&gt;sql-stmt&lt;/a&gt;</source>
          <target state="translated">Ссылки: &lt;a href=&quot;sql-stmt&quot;&gt;sql-stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fee8a9d70903bab5247e1644ccd6676a4cf76b15" translate="yes" xml:space="preserve">
          <source>Regardless of whether or not the instrumented memory allocator is used, SQLite keeps track of how much memory is currently checked out. There are hundreds of test scripts used for testing SQLite. At the end of each script, all objects are destroyed and a test is made to ensure that all memory has been freed. This is how memory leaks are detected. Notice that memory leak detection is in force at all times, during test builds and during production builds. Whenever one of the developers runs any individual test script, memory leak detection is active. Hence memory leaks that do arise during development are quickly detected and fixed.</source>
          <target state="translated">Независимо от того,используется ли инструментированный аллокатор памяти или нет,SQLite отслеживает,какой объем памяти в настоящее время проверяется.Для тестирования SQLite используются сотни тестовых скриптов.В конце каждого скрипта уничтожаются все объекты,и проводится тест,чтобы убедиться,что вся память была освобождена.Именно так происходит обнаружение утечек памяти.Обратите внимание,что обнаружение утечек памяти действует в любое время,как во время тестовых сборок,так и во время производственных сборок.Всякий раз,когда один из разработчиков запускает какой-нибудь отдельный тестовый скрипт,обнаружение утечки памяти активно.Поэтому утечки памяти,которые все же возникают во время разработки,быстро обнаруживаются и устраняются.</target>
        </trans-unit>
        <trans-unit id="ae990d665eb1948d09faab80d8ea36e2fb369696" translate="yes" xml:space="preserve">
          <source>Regardless of whether or not the limit was changed, the &lt;a href=&quot;#sqlite3_limit&quot;&gt;sqlite3_limit()&lt;/a&gt; interface returns the prior value of the limit. Hence, to find the current value of a limit without changing it, simply invoke this interface with the third parameter set to -1.</source>
          <target state="translated">Независимо от того, был ли изменен лимит, интерфейс &lt;a href=&quot;#sqlite3_limit&quot;&gt;sqlite3_limit ()&lt;/a&gt; возвращает предыдущее значение лимита. Следовательно, чтобы найти текущее значение лимита без его изменения, просто вызовите этот интерфейс с третьим параметром, установленным на -1.</target>
        </trans-unit>
        <trans-unit id="475dd8379b7144ac8a6fe852e876196470fc7208" translate="yes" xml:space="preserve">
          <source>Regardless of whether or not the limit was changed, the &lt;a href=&quot;limit&quot;&gt;sqlite3_limit()&lt;/a&gt; interface returns the prior value of the limit. Hence, to find the current value of a limit without changing it, simply invoke this interface with the third parameter set to -1.</source>
          <target state="translated">Независимо от того, был ли изменен лимит, интерфейс &lt;a href=&quot;limit&quot;&gt;sqlite3_limit ()&lt;/a&gt; возвращает предыдущее значение лимита. Следовательно, чтобы найти текущее значение лимита без его изменения, просто вызовите этот интерфейс с третьим параметром, установленным на -1.</target>
        </trans-unit>
        <trans-unit id="e9e73aedbb554e1304705d3de0f39389c534343e" translate="yes" xml:space="preserve">
          <source>Regions for custom R*Tree queries are defined by R*Tree geometry callbacks implemented by the application and registered with SQLite via a call to one of the following two APIs:</source>
          <target state="translated">Регионы для пользовательских R*Tree запросов определяются обратными вызовами R*Tree геометрии,реализованными приложением и зарегистрированными в SQLite через вызов одного из следующих двух API:</target>
        </trans-unit>
        <trans-unit id="16168729e57b855923c7a71a802959676ea3a2be" translate="yes" xml:space="preserve">
          <source>Register A Callback To Handle SQLITE_BUSY Errors</source>
          <target state="translated">Регистрация Обратный вызов для обработки ошибок SQLITE_BUSY</target>
        </trans-unit>
        <trans-unit id="d7ada71741a5c5efe7fce5b9acb6e7cf75421e75" translate="yes" xml:space="preserve">
          <source>Register A Virtual Table Implementation</source>
          <target state="translated">Регистрация Виртуальная таблица Внедрение</target>
        </trans-unit>
        <trans-unit id="958187253e4e67d26cfc6c57d03a7d486067c5db" translate="yes" xml:space="preserve">
          <source>Register P1 must contain an integer. If the content of register P1 is initially greater than zero, then decrement the value in register P1. If it is non-zero (negative or positive) and then also jump to P2. If register P1 is initially zero, leave it unchanged and fall through.</source>
          <target state="translated">Регистр P1 должен содержать целое число.Если содержимое регистра P1 изначально больше нуля,то уменьшается значение в регистре P1.Если оно ненулевое (отрицательное или положительное),а затем также перескакивает на P2.Если регистр P1 изначально равен нулю,то оставьте его без изменений и пропустите.</target>
        </trans-unit>
        <trans-unit id="6fc7ce61728bc6135a810d1467e955ec5c18cca5" translate="yes" xml:space="preserve">
          <source>Register P1 must contain an integer. If the value of register P1 is 1 or greater, subtract P3 from the value in P1 and jump to P2.</source>
          <target state="translated">Регистр P1 должен содержать целое число.Если значение регистра P1 равно 1 или больше,вычтите P3 из значения в P1 и перейдите к P2.</target>
        </trans-unit>
        <trans-unit id="d06710a36a9775573764357fb20e740182e291de" translate="yes" xml:space="preserve">
          <source>Register P1 must hold an integer. Decrement the value in P1 and jump to P2 if the new value is exactly zero.</source>
          <target state="translated">Регистр P1 должен содержать целое число.Уменьшите значение в P1 и перейдите к P2,если новое значение точно равно нулю.</target>
        </trans-unit>
        <trans-unit id="e5b942ab2eff4aada4b58db13bc65435ed431f02" translate="yes" xml:space="preserve">
          <source>Register P2 holds an SQL index key made using the &lt;a href=&quot;opcode#MakeRecord&quot;&gt;MakeRecord&lt;/a&gt; instructions. This opcode writes that key into the index P1. Data for the entry is nil.</source>
          <target state="translated">Регистр P2 содержит ключ индекса SQL, созданный с &lt;a href=&quot;opcode#MakeRecord&quot;&gt;помощью&lt;/a&gt; инструкций MakeRecord . Этот код операции записывает этот ключ в индекс P1. Данные для записи равны нулю.</target>
        </trans-unit>
        <trans-unit id="01732db42505a803a66049796c8bf94fe2cae34d" translate="yes" xml:space="preserve">
          <source>Register P2 holds an SQL index key made using the &lt;a href=&quot;opcode#MakeRecord&quot;&gt;MakeRecord&lt;/a&gt; instructions. This opcode writes that key into the sorter P1. Data for the entry is nil.</source>
          <target state="translated">Регистр P2 содержит ключ индекса SQL, созданный с &lt;a href=&quot;opcode#MakeRecord&quot;&gt;помощью&lt;/a&gt; инструкций MakeRecord . Этот код операции записывает этот ключ в сортировщик P1. Данные для записи равны нулю.</target>
        </trans-unit>
        <trans-unit id="3d2ffa8c9852450209f632158a1e7073fb3dfaaa" translate="yes" xml:space="preserve">
          <source>Register P3 is assumed to hold a 64-bit integer value. If register P1 contains a RowSet object and that RowSet object contains the value held in P3, jump to register P2. Otherwise, insert the integer in P3 into the RowSet and continue on to the next opcode.</source>
          <target state="translated">Предполагается,что регистр P3 содержит 64-битное целое значение.Если регистр P1 содержит объект RowSet,а объект RowSet содержит значение,содержащееся в P3,переходите к регистру P2.В противном случае,вставьте целое число в P3 в RowSet и перейдите к следующему опкоду.</target>
        </trans-unit>
        <trans-unit id="bb45c70cacf149749ff353ab480989cee1443045" translate="yes" xml:space="preserve">
          <source>Register P3 is the first of P4 registers that form an unpacked record.</source>
          <target state="translated">Регистр P3 является первым из регистров P4,которые образуют распакованную запись.</target>
        </trans-unit>
        <trans-unit id="6b0d004c3926bf5b1daf83fe67dbd02805bbbe04" translate="yes" xml:space="preserve">
          <source>Register any required virtual table modules with the database handle returned by sqlite3rbu_db(X) (where argument X is the sqlite3rbu pointer returned from sqlite3rbu_open()). Also, if required, register the rbu_delta() SQL function using &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function_v2()&lt;/a&gt;.</source>
          <target state="translated">Зарегистрируйте все необходимые модули виртуальной таблицы с помощью дескриптора базы данных, возвращаемого sqlite3rbu_db (X) (где аргумент X - это указатель sqlite3rbu, возвращаемый sqlite3rbu_open ()). Кроме того, при необходимости зарегистрируйте функцию SQL rbu_delta () с помощью &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function_v2 ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6b1ab59684ecdfa6e23d462a92936dce3e5d8ac7" translate="yes" xml:space="preserve">
          <source>Register the asynchronous IO VFS with SQLite by calling the sqlite3async_initialize() function.</source>
          <target state="translated">Регистрируйте асинхронную IO VFS с SQLite вызовом функции sqlite3async_initialize().</target>
        </trans-unit>
        <trans-unit id="89422a050ade616c86455a9e2dd6f33cb03ad894" translate="yes" xml:space="preserve">
          <source>Register your &lt;a href=&quot;c3ref/module&quot;&gt;sqlite3_module&lt;/a&gt; structure using one of the &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module()&lt;/a&gt; or &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module_v2()&lt;/a&gt; interfaces.</source>
          <target state="translated">Зарегистрируйте структуру &lt;a href=&quot;c3ref/module&quot;&gt;sqlite3_module&lt;/a&gt; с помощью одного из интерфейсов &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module ()&lt;/a&gt; или &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module_v2 ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="27c9b460c397ef5be790575add8647f1cec36dca" translate="yes" xml:space="preserve">
          <source>Registered sqlite3_vfs objects are kept on a linked list formed by the pNext pointer. The &lt;a href=&quot;#sqlite3_vfs_find&quot;&gt;sqlite3_vfs_register()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_vfs_find&quot;&gt;sqlite3_vfs_unregister()&lt;/a&gt; interfaces manage this list in a thread-safe way. The &lt;a href=&quot;#sqlite3_vfs_find&quot;&gt;sqlite3_vfs_find()&lt;/a&gt; interface searches the list. Neither the application code nor the VFS implementation should use the pNext pointer.</source>
          <target state="translated">Зарегистрированные объекты sqlite3_vfs хранятся в связанном списке, образованном указателем pNext. Интерфейсы &lt;a href=&quot;#sqlite3_vfs_find&quot;&gt;sqlite3_vfs_register ()&lt;/a&gt; и &lt;a href=&quot;#sqlite3_vfs_find&quot;&gt;sqlite3_vfs_unregister ()&lt;/a&gt; управляют этим списком потокобезопасным способом. Интерфейс &lt;a href=&quot;#sqlite3_vfs_find&quot;&gt;sqlite3_vfs_find ()&lt;/a&gt; выполняет поиск в списке. Ни код приложения, ни реализация VFS не должны использовать указатель pNext.</target>
        </trans-unit>
        <trans-unit id="de4afbb05497a501a0da1ff3e255c9bea23038bf" translate="yes" xml:space="preserve">
          <source>Registered sqlite3_vfs objects are kept on a linked list formed by the pNext pointer. The &lt;a href=&quot;vfs_find&quot;&gt;sqlite3_vfs_register()&lt;/a&gt; and &lt;a href=&quot;vfs_find&quot;&gt;sqlite3_vfs_unregister()&lt;/a&gt; interfaces manage this list in a thread-safe way. The &lt;a href=&quot;vfs_find&quot;&gt;sqlite3_vfs_find()&lt;/a&gt; interface searches the list. Neither the application code nor the VFS implementation should use the pNext pointer.</source>
          <target state="translated">Зарегистрированные объекты sqlite3_vfs хранятся в связанном списке, образованном указателем pNext. Интерфейсы &lt;a href=&quot;vfs_find&quot;&gt;sqlite3_vfs_register ()&lt;/a&gt; и &lt;a href=&quot;vfs_find&quot;&gt;sqlite3_vfs_unregister ()&lt;/a&gt; управляют этим списком потокобезопасным способом. Интерфейс &lt;a href=&quot;vfs_find&quot;&gt;sqlite3_vfs_find ()&lt;/a&gt; выполняет поиск в списке. Ни код приложения, ни реализация VFS не должны использовать указатель pNext.</target>
        </trans-unit>
        <trans-unit id="9a5c1b8d7536fe55fb50a507d2ffb4e2ef3d6e66" translate="yes" xml:space="preserve">
          <source>Registering a NULL function disables the callback.</source>
          <target state="translated">Регистрация функции NULL отключает обратный вызов.</target>
        </trans-unit>
        <trans-unit id="7e5b14172bb50385ea604b908cd56b4ced0181ef" translate="yes" xml:space="preserve">
          <source>Registering a new FTS tokenizer is similar to registering a new virtual table module with SQLite. The user passes a pointer to a structure containing pointers to various callback functions that make up the implementation of the new tokenizer type. For tokenizers, the structure (defined in fts3_tokenizer.h) is called &quot;sqlite3_tokenizer_module&quot;.</source>
          <target state="translated">Регистрация нового токенайзера FTS аналогична регистрации нового модуля виртуальной таблицы с SQLite.Пользователь передает указатель на структуру,содержащую указатели на различные функции обратного вызова,составляющие реализацию нового типа токенайзера.Для токенайзеров структура (определенная в файле fts3_tokenizer.h)называется &quot;sqlite3_tokenizer_module&quot;.</target>
        </trans-unit>
        <trans-unit id="b0c19399b5563dfe1fd2d9520239e189e1da88bf" translate="yes" xml:space="preserve">
          <source>Registers are numbered beginning with 0. Most opcodes refer to at least one register.</source>
          <target state="translated">Регистры пронумерованы,начиная с 0.Большинство опкодов относятся как минимум к одному регистру.</target>
        </trans-unit>
        <trans-unit id="3416ca847c2f3fcac36ca80a6aa453bda2a4a879" translate="yes" xml:space="preserve">
          <source>Regression tests</source>
          <target state="translated">Регрессивные тесты</target>
        </trans-unit>
        <trans-unit id="d3a13cdc6fea5f8b0f17f86149a799a401cfa954" translate="yes" xml:space="preserve">
          <source>Reimplemented the memory allocation subsystem and made it replaceable at compile-time.</source>
          <target state="translated">Реализована подсистема выделения памяти и сделана заменяемой при компиляции.</target>
        </trans-unit>
        <trans-unit id="7c51b2c09a7ac00c32d5f5b60d5cc13c023b651f" translate="yes" xml:space="preserve">
          <source>Reinstate performance improvements that were added in &lt;a href=&quot;#version_3_3_14&quot;&gt;Version 3.3.14&lt;/a&gt; but regressed in &lt;a href=&quot;#version_3_3_15&quot;&gt;Version 3.3.15&lt;/a&gt;.</source>
          <target state="translated">Восстановите улучшения производительности, которые были добавлены в &lt;a href=&quot;#version_3_3_14&quot;&gt;версии 3.3.14,&lt;/a&gt; но остались прежними в &lt;a href=&quot;#version_3_3_15&quot;&gt;версии 3.3.15&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3011dfada1ebc527f6c1a610c58b9f9d0286fe3f" translate="yes" xml:space="preserve">
          <source>Related to C-API requirements:</source>
          <target state="translated">Связанные с требованиями C-API:</target>
        </trans-unit>
        <trans-unit id="4e090a454ee61aaf3f58e28631cff8999e93331b" translate="yes" xml:space="preserve">
          <source>Related to SQL requirements:</source>
          <target state="translated">Связанные с требованиями SQL:</target>
        </trans-unit>
        <trans-unit id="3eb999525849eac11552ac3098daf2b69f5321b3" translate="yes" xml:space="preserve">
          <source>Related to file-format requirements:</source>
          <target state="translated">Связано с требованиями к формату файлов:</target>
        </trans-unit>
        <trans-unit id="8f24d23adbf6898f82e865e9f816b7bd6e3ba106" translate="yes" xml:space="preserve">
          <source>Relational database engines act as bandwidth-reducing data filters. So it is best to keep the database engine and the data on the same physical device so that the high-bandwidth engine-to-disk link does not have to traverse the network, only the lower-bandwidth application-to-engine link.</source>
          <target state="translated">Двигатели реляционных баз данных выступают в качестве фильтров данных,уменьшающих пропускную способность.Поэтому лучше держать движок базы данных и данные на одном физическом устройстве,чтобы высокоскоростному движку не приходилось пересекать сеть,а только низкоскоростное соединение между приложениями.</target>
        </trans-unit>
        <trans-unit id="720fa9e6ba7dd17be077bf0b4c2393be699b32bc" translate="yes" xml:space="preserve">
          <source>Relationship to Other Documents</source>
          <target state="translated">Связь с другими документами</target>
        </trans-unit>
        <trans-unit id="910fe0ebb846d769acb1f768f3b350b52b7c87fa" translate="yes" xml:space="preserve">
          <source>Relax the SQL statement length restriction in the CLI so that the &quot;.dump&quot; output of databases with very large BLOBs and strings can be played back to recreate the database.</source>
          <target state="translated">Уменьшите ограничение длины оператора SQL в CLI,чтобы можно было воспроизводить вывод &quot;.dump&quot; баз данных с очень большими BLOB и строк для воссоздания базы данных.</target>
        </trans-unit>
        <trans-unit id="d41f56cea1ac933d25c57aebc6522e2b6c58eb87" translate="yes" xml:space="preserve">
          <source>Release</source>
          <target state="translated">Release</target>
        </trans-unit>
        <trans-unit id="3f453891a8b048016ad785ded9267d527fc4c217" translate="yes" xml:space="preserve">
          <source>Release History</source>
          <target state="translated">История релизов</target>
        </trans-unit>
        <trans-unit id="b5d6e335495f80d39d703350d3e97ffdb93dd6dd" translate="yes" xml:space="preserve">
          <source>Release History Of SQLite</source>
          <target state="translated">История выпуска SQLite</target>
        </trans-unit>
        <trans-unit id="059948eaf49ab1f91af7a1724f1325548609c407" translate="yes" xml:space="preserve">
          <source>Release registers from service. Any content that was in the the registers is unreliable after this opcode completes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f91d8788ccb8580c59f2957385adedb96f9eebdb" translate="yes" xml:space="preserve">
          <source>Release testing proceeds by &lt;a href=&quot;testing#cklist&quot;&gt;checklist&lt;/a&gt;. The current status and complete change history for each checklist is stored in a separate SQLite database file. These files are not version controlled, but separate copies are maintained on private backup servers.</source>
          <target state="translated">Тестирование релиза проводится по &lt;a href=&quot;testing#cklist&quot;&gt;контрольному списку&lt;/a&gt; . Текущий статус и полная история изменений для каждого контрольного списка хранятся в отдельном файле базы данных SQLite. Эти файлы не контролируются версиями, но отдельные копии хранятся на частных серверах резервного копирования.</target>
        </trans-unit>
        <trans-unit id="d39cd2c52497ee84030ad057906e4ab9e12677f2" translate="yes" xml:space="preserve">
          <source>ReleaseReg</source>
          <target state="translated">ReleaseReg</target>
        </trans-unit>
        <trans-unit id="68bd446f9608234bde9262049ecc13307a217604" translate="yes" xml:space="preserve">
          <source>Releases the mutex.</source>
          <target state="translated">Выпускает мьютекс.</target>
        </trans-unit>
        <trans-unit id="093e4161a9fbb2d3df1b7e1618ac6472d6ffad88" translate="yes" xml:space="preserve">
          <source>Releasing a register clears the Mem.pScopyFrom pointer. That means that if the content of the released register was set using &lt;a href=&quot;opcode#SCopy&quot;&gt;SCopy&lt;/a&gt;, a change to the value of the source register for the &lt;a href=&quot;opcode#SCopy&quot;&gt;SCopy&lt;/a&gt; will no longer generate an assertion fault in sqlite3VdbeMemAboutToChange().</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e7fb42133185287484ac33cdd16d16a32e9573a" translate="yes" xml:space="preserve">
          <source>Relieve the poor.</source>
          <target state="translated">Успокойте бедняков.</target>
        </trans-unit>
        <trans-unit id="c129618e6f09666fc71019f6f11ca49c584723bd" translate="yes" xml:space="preserve">
          <source>Relinquish the shared lock on the database file obtained in step 1.</source>
          <target state="translated">Снять общую блокировку с файла базы данных,полученного на шаге 1.</target>
        </trans-unit>
        <trans-unit id="c20a1017faea096d3f06199fd35a9c0037bfb227" translate="yes" xml:space="preserve">
          <source>Remainder</source>
          <target state="translated">Remainder</target>
        </trans-unit>
        <trans-unit id="d7020f448aaf8aacc8b4d63537e375e865fff9d8" translate="yes" xml:space="preserve">
          <source>Remarks</source>
          <target state="translated">Remarks</target>
        </trans-unit>
        <trans-unit id="f818b7fc01e1b4eb78ea0d60ac974d5efb37d086" translate="yes" xml:space="preserve">
          <source>Remember that every table (except sqlite_master) and every named index has an entry in the sqlite_master table. Since we are creating a new index, we have to add a new entry to sqlite_master. This is handled by instructions 3 through 15. Adding an entry to sqlite_master works just like any other INSERT statement so we will not say any more about it here. In this example, we want to focus on populating the new index with valid data, which happens on instructions 16 through 23.</source>
          <target state="translated">Помните,что каждая таблица (кроме sqlite_master)и каждый именованный индекс имеет запись в таблице sqlite_master.Поскольку мы создаем новый индекс,мы должны добавить новую запись в sqlite_master.Это обрабатывается инструкциями с 3 по 15.Добавление записи в sqlite_master работает так же,как и любое другое утверждение INSERT,поэтому здесь мы больше не будем об этом говорить.В данном примере мы хотим сосредоточиться на заполнении нового индекса достоверными данными,что происходит при выполнении инструкций с 16 по 23.</target>
        </trans-unit>
        <trans-unit id="69897e6a01044562fef92617e584bcaf82e348ea" translate="yes" xml:space="preserve">
          <source>Remember that the names and meanings of opcodes often change from one release of SQLite to the next. So if you are studying the &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt; output from SQLite, you should reference the version of this document (or the vdbe.c source code) that corresponds to the version of SQLite that ran the &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt;. Otherwise, the description of the opcodes may not be accurate. This document is derived from SQLite version 3.30.1 check-in &lt;a href=&quot;https://www.sqlite.org/src/timeline?c=18db032d058f1&quot;&gt;18db032d058f1&lt;/a&gt; dated 2019-10-10.</source>
          <target state="translated">Помните, что имена и значения кодов операций часто меняются от одного выпуска SQLite к другому. Поэтому, если вы &lt;a href=&quot;lang_explain&quot;&gt;изучаете&lt;/a&gt; вывод EXPLAIN из SQLite, вы должны ссылаться на версию этого документа (или исходный код vdbe.c), которая соответствует версии SQLite, которая запускала &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt; . В противном случае описание кодов операций может быть неточным. Этот документ является производным от проверки SQLite версии 3.30.1 &lt;a href=&quot;https://www.sqlite.org/src/timeline?c=18db032d058f1&quot;&gt;18db032d058f1&lt;/a&gt; от 10.10.2019.</target>
        </trans-unit>
        <trans-unit id="f553d13a1a4a6a005164fe968cc587aaf66e9b40" translate="yes" xml:space="preserve">
          <source>Remember that the names and meanings of opcodes often change from one release of SQLite to the next. So if you are studying the &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt; output from SQLite, you should reference the version of this document (or the vdbe.c source code) that corresponds to the version of SQLite that ran the &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt;. Otherwise, the description of the opcodes may not be accurate. This document is derived from SQLite version 3.33.0 check-in &lt;a href=&quot;https://www.sqlite.org/src/timeline?c=fca8dc8b578f2&quot;&gt;fca8dc8b578f2&lt;/a&gt; dated 2020-08-14.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6eb5f044eeebb740c044069cc0a1760dfcfed869" translate="yes" xml:space="preserve">
          <source>Remember the format of all indexes, triggers, and views associated with table X. This information will be needed in step 8 below. One way to do this is to run a query like the following: SELECT type, sql FROM sqlite_master WHERE tbl_name='X'.</source>
          <target state="translated">Запомните формат всех индексов,триггеров и представлений,связанных с таблицей X.Эта информация будет необходима на шаге 8 ниже.Один из способов сделать это-выполнить запрос,как показано ниже:Тип SELECT,sql FROM sqlite_master ГДЕ tbl_name='X'.</target>
        </trans-unit>
        <trans-unit id="96ba241fe10cc7a94246b3ba48e08be55ea73559" translate="yes" xml:space="preserve">
          <source>Remember the format of all indexes, triggers, and views associated with table X. This information will be needed in step 8 below. One way to do this is to run a query like the following: SELECT type, sql FROM sqlite_schema WHERE tbl_name='X'.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7697dd70c220c16d6cd40cffcf6ebbe938ec6d8c" translate="yes" xml:space="preserve">
          <source>Remember: The VDBE opcodes are &lt;u&gt;not&lt;/u&gt; part of the interface definition for SQLite. The number of opcodes and their names and meanings change from one release of SQLite to the next. The opcodes shown in the table below are valid for SQLite version 3.30.1 check-in &lt;a href=&quot;https://www.sqlite.org/src/timeline?c=18db032d058f1&quot;&gt;18db032d058f1&lt;/a&gt; dated 2019-10-10.</source>
          <target state="translated">Помните: коды операций VDBE &lt;u&gt;не&lt;/u&gt; являются частью определения интерфейса для SQLite. Количество кодов операций, их имена и значения меняются от одного выпуска SQLite к другому. Коды операций, приведенные в таблице ниже, действительны для проверки SQLite версии 3.30.1 &lt;a href=&quot;https://www.sqlite.org/src/timeline?c=18db032d058f1&quot;&gt;18db032d058f1&lt;/a&gt; от 10.10.2019.</target>
        </trans-unit>
        <trans-unit id="0cf1bdb8435fa5c7b1a229b2efb579581c575742" translate="yes" xml:space="preserve">
          <source>Remember: The VDBE opcodes are &lt;u&gt;not&lt;/u&gt; part of the interface definition for SQLite. The number of opcodes and their names and meanings change from one release of SQLite to the next. The opcodes shown in the table below are valid for SQLite version 3.33.0 check-in &lt;a href=&quot;https://www.sqlite.org/src/timeline?c=fca8dc8b578f2&quot;&gt;fca8dc8b578f2&lt;/a&gt; dated 2020-08-14.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad8914d260e2d26c0f65a1244263c5ebd74ffa40" translate="yes" xml:space="preserve">
          <source>Removals occurs sequentially from left to right. Changes caused by prior removals can affect the path search for subsequent arguments.</source>
          <target state="translated">Удаление происходит последовательно слева направо.Изменения,вызванные предыдущими удалениями,могут повлиять на поиск путей для последующих аргументов.</target>
        </trans-unit>
        <trans-unit id="911efbaa270338e46274d0437cfd895711d3b921" translate="yes" xml:space="preserve">
          <source>Remove Unnecessary Virtual Table Implementations</source>
          <target state="translated">Удаление ненужных виртуальных табличных имплементаций</target>
        </trans-unit>
        <trans-unit id="e2ba27377e47e450dcae92850eed494633ee561a" translate="yes" xml:space="preserve">
          <source>Remove a call to rand_s() in the Windows VFS since it was causing problems in Firefox on some older laptops.</source>
          <target state="translated">Удалить вызов rand_s()в Windows VFS,так как он вызывал проблемы в Firefox на некоторых старых ноутбуках.</target>
        </trans-unit>
        <trans-unit id="de2c1add2fd3544da9609574c31dec164859c5a6" translate="yes" xml:space="preserve">
          <source>Remove a surplus semicolon that was causing problems for older versions of MSVC.</source>
          <target state="translated">Удалить лишнюю точку с запятой,которая вызывала проблемы для старых версий MSVC.</target>
        </trans-unit>
        <trans-unit id="d1a5392ba748cb8c4dacc7b44e730fc30161dbb4" translate="yes" xml:space="preserve">
          <source>Remove all instances of sprintf() from the code</source>
          <target state="translated">Удалить все экземпляры sprintf()из кода</target>
        </trans-unit>
        <trans-unit id="a7347e37ad5bb38746524ddb0e6ffca369e7fc25" translate="yes" xml:space="preserve">
          <source>Remove all uses of umask() in the unix VFS.</source>
          <target state="translated">Удалить все использования функции umask()в unix VFS.</target>
        </trans-unit>
        <trans-unit id="e9a7875d6c4fd8a037f45ad1e5ae66d9676a5804" translate="yes" xml:space="preserve">
          <source>Remove cruft from the APIs.</source>
          <target state="translated">Удалить Круфт из API.</target>
        </trans-unit>
        <trans-unit id="1b6d6e3634ac9d3666b932168ce6ff89f16adfc2" translate="yes" xml:space="preserve">
          <source>Remove limits on the magnitude of precision and width value in the format specifiers of the &lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_mprintf()&lt;/a&gt; family of string rendering routines.</source>
          <target state="translated">Удалите ограничения на величину точности и значения ширины в спецификаторах формата семейства &lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_mprintf ()&lt;/a&gt; подпрограмм рендеринга строк.</target>
        </trans-unit>
        <trans-unit id="232f2fe0e5dd49ef4b04602d08b8943e14a7d142" translate="yes" xml:space="preserve">
          <source>Remove some C++ style comments from btree.c so that it will compile using compilers other than gcc.</source>
          <target state="translated">Удалите некоторые комментарии в стиле Си++из btree.c,чтобы он компилировался с использованием компиляторов,отличных от gcc.</target>
        </trans-unit>
        <trans-unit id="f2e07b9153ec780a2a1b29629bb1d3f64a20239f" translate="yes" xml:space="preserve">
          <source>Remove the &lt;b&gt;sqlite_encoding&lt;/b&gt; TCL variable that was introduced in the previous version.</source>
          <target state="translated">Удалите переменную &lt;b&gt;sqlite_encoding&lt;/b&gt; TCL, которая была представлена ​​в предыдущей версии.</target>
        </trans-unit>
        <trans-unit id="2b21568b3fad30533d945c9f60e6bb04786d29af" translate="yes" xml:space="preserve">
          <source>Remove the internal (in-memory) data structures that describe the index named P4 in database P1. This is called after an index is dropped from disk (using the &lt;a href=&quot;opcode#Destroy&quot;&gt;Destroy&lt;/a&gt; opcode) in order to keep the internal representation of the schema consistent with what is on disk.</source>
          <target state="translated">Удалите внутренние (в памяти) структуры данных, которые описывают индекс с именем P4 в базе данных P1. Это вызывается после удаления индекса с диска (с использованием кода операции &amp;laquo; &lt;a href=&quot;opcode#Destroy&quot;&gt;Уничтожить&amp;raquo;&lt;/a&gt; ), чтобы внутреннее представление схемы соответствовало тому, что находится на диске.</target>
        </trans-unit>
        <trans-unit id="36574b14e4fba42639d51b715dd56510bbbe9bbe" translate="yes" xml:space="preserve">
          <source>Remove the internal (in-memory) data structures that describe the table named P4 in database P1. This is called after a table is dropped from disk (using the &lt;a href=&quot;opcode#Destroy&quot;&gt;Destroy&lt;/a&gt; opcode) in order to keep the internal representation of the schema consistent with what is on disk.</source>
          <target state="translated">Удалите внутренние (в памяти) структуры данных, которые описывают таблицу с именем P4 в базе данных P1. Это вызывается после того, как таблица удаляется с диска (с использованием кода операции &amp;laquo; &lt;a href=&quot;opcode#Destroy&quot;&gt;Уничтожить&amp;raquo;&lt;/a&gt; ), чтобы внутреннее представление схемы соответствовало тому, что находится на диске.</target>
        </trans-unit>
        <trans-unit id="a2ee755d70dfde8b6acc7bc963a2c09e0d856e3d" translate="yes" xml:space="preserve">
          <source>Remove the internal (in-memory) data structures that describe the trigger named P4 in database P1. This is called after a trigger is dropped from disk (using the &lt;a href=&quot;opcode#Destroy&quot;&gt;Destroy&lt;/a&gt; opcode) in order to keep the internal representation of the schema consistent with what is on disk.</source>
          <target state="translated">Удалите внутренние (в памяти) структуры данных, которые описывают триггер с именем P4 в базе данных P1. Он вызывается после сброса триггера с диска (с использованием кода операции &amp;laquo; &lt;a href=&quot;opcode#Destroy&quot;&gt;Уничтожить&amp;raquo;&lt;/a&gt; ), чтобы внутреннее представление схемы соответствовало тому, что находится на диске.</target>
        </trans-unit>
        <trans-unit id="4bdb98bb814d00a40fac7a5bc5a53816ed8a4fe3" translate="yes" xml:space="preserve">
          <source>Remove the limit (formerly 100) on the number of terms in the WHERE clause</source>
          <target state="translated">Убрать лимит (ранее 100)на количество терминов в пункте ГДЕ</target>
        </trans-unit>
        <trans-unit id="6c2cfa3751933f72373c8446091ad7cbfc829e90" translate="yes" xml:space="preserve">
          <source>Remove the rarely-used &quot;scratch&quot; memory allocator. Replace it with the &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigsmallmalloc&quot;&gt;SQLITE_CONFIG_SMALL_MALLOC&lt;/a&gt; configuration setting that gives SQLite a hint that large memory allocations should be avoided when possible.</source>
          <target state="translated">Удалите редко используемый &quot;временной&quot; распределитель памяти. Замените его &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigsmallmalloc&quot;&gt;параметром&lt;/a&gt; конфигурации SQLITE_CONFIG_SMALL_MALLOC, который дает SQLite подсказку о том, что по возможности следует избегать выделения больших объемов памяти.</target>
        </trans-unit>
        <trans-unit id="f76d7af1679885a7bfe9d24b6ffde8997604493f" translate="yes" xml:space="preserve">
          <source>Remove the restriction on &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt; and &lt;a href=&quot;sharedcache&quot;&gt;shared cache mode&lt;/a&gt;. Virtual tables and shared cache can now be used at the same time.</source>
          <target state="translated">Снимите ограничение на &lt;a href=&quot;vtab&quot;&gt;виртуальные таблицы&lt;/a&gt; и &lt;a href=&quot;sharedcache&quot;&gt;режим общего кеша&lt;/a&gt; . Виртуальные таблицы и общий кеш теперь можно использовать одновременно.</target>
        </trans-unit>
        <trans-unit id="0f161850d96f27ed56876982a84f7c1b8a07321a" translate="yes" xml:space="preserve">
          <source>Remove the use of strcasecmp() from the shell</source>
          <target state="translated">Удалить использование strcasecmp()из оболочки</target>
        </trans-unit>
        <trans-unit id="b82adca5a3d606350246be926940c7079f564580" translate="yes" xml:space="preserve">
          <source>Removed a few variables that were not being used. Etc.</source>
          <target state="translated">Удалены некоторые переменные,которые не использовались.И т.д.</target>
        </trans-unit>
        <trans-unit id="ce23c20d6612496d01f2695dbdf3e159dffac5f1" translate="yes" xml:space="preserve">
          <source>Removed all instances of sprintf() and strcpy() from the core library.</source>
          <target state="translated">Удалены все экземпляры sprintf()и strcpy()из основной библиотеки.</target>
        </trans-unit>
        <trans-unit id="1cae4989947b35c7db5ba36e62fdeec64147115e" translate="yes" xml:space="preserve">
          <source>Removed encode.c file (containing unused routines) from the version 3.0 source tree.</source>
          <target state="translated">Удален файл encode.c (содержащий неиспользуемые процедуры)из дерева исходных текстов версии 3.0.</target>
        </trans-unit>
        <trans-unit id="57859e1d20dcbe4d104c0ddc713636157aa93b7b" translate="yes" xml:space="preserve">
          <source>Removed some unused &quot;#include</source>
          <target state="translated">Удалены некоторые неиспользованные &quot;#включая</target>
        </trans-unit>
        <trans-unit id="8d2a9960e30e515570aed5ad791fda0cf2ff5231" translate="yes" xml:space="preserve">
          <source>Removed support for &lt;a href=&quot;compile#enable_stat2&quot;&gt;SQLITE_ENABLE_STAT2&lt;/a&gt;, replacing it with the much more capable &lt;a href=&quot;compile#enable_stat3&quot;&gt;SQLITE_ENABLE_STAT3&lt;/a&gt; option.</source>
          <target state="translated">Удалена поддержка &lt;a href=&quot;compile#enable_stat2&quot;&gt;SQLITE_ENABLE_STAT2&lt;/a&gt; , заменена более &lt;a href=&quot;compile#enable_stat3&quot;&gt;функциональной&lt;/a&gt; опцией SQLITE_ENABLE_STAT3 .</target>
        </trans-unit>
        <trans-unit id="65be623270aae4b13c60984d581079005860c71c" translate="yes" xml:space="preserve">
          <source>Removed support for an ON CONFLICT clause on CREATE INDEX - it never worked correctly so this should not present any backward compatibility problems.</source>
          <target state="translated">Удалена поддержка пункта ON CONFLICT на CREATE INDEX-он никогда не работал корректно,поэтому не должно быть проблем с обратной совместимостью.</target>
        </trans-unit>
        <trans-unit id="ba2329a69fcada7cfc55496da4a2c7aa1027255b" translate="yes" xml:space="preserve">
          <source>Removed support for the Oracle8 outer join syntax.</source>
          <target state="translated">Удалена поддержка синтаксиса внешнего соединения Oracle8.</target>
        </trans-unit>
        <trans-unit id="29a877d4bc4a615404fe28f15ef25cea333f3dfb" translate="yes" xml:space="preserve">
          <source>Removed the experimental sqlite_open_aux_file(). Its function is subsumed in the new ATTACH command.</source>
          <target state="translated">Удалена экспериментальная функция sqlite_open_aux_file().Его функция вычисляется в новой команде ATTACH.</target>
        </trans-unit>
        <trans-unit id="d84a5c2bd6c237fcc154859882d3b6c252699015" translate="yes" xml:space="preserve">
          <source>Removed the vestigal SQLITE_PROTOCOL error.</source>
          <target state="translated">Удалена ошибка vestigal SQLITE_PROTOCOL.</target>
        </trans-unit>
        <trans-unit id="eace5c7b4ff6a4702d4283d3160c8d68a2dcede9" translate="yes" xml:space="preserve">
          <source>Rename column</source>
          <target state="translated">Переименованная колонка</target>
        </trans-unit>
        <trans-unit id="23dbd5b69dca406be177f26a10ac454eda104e75" translate="yes" xml:space="preserve">
          <source>Rename new into old</source>
          <target state="translated">Переименовать новое в старое</target>
        </trans-unit>
        <trans-unit id="5bd4049b4d784a22b055fc8e5f3c3684061c5d9c" translate="yes" xml:space="preserve">
          <source>Rename old table</source>
          <target state="translated">Переименовать старый стол</target>
        </trans-unit>
        <trans-unit id="c9a739b6bb3de7aee85aef1cd51db485f31caf22" translate="yes" xml:space="preserve">
          <source>Rename table</source>
          <target state="translated">Переименовать таблицу</target>
        </trans-unit>
        <trans-unit id="a6f163085aea45df98f42b1c1ebd60597433d37a" translate="yes" xml:space="preserve">
          <source>Rename the &lt;a href=&quot;compile#omit_builtin_test&quot;&gt;SQLITE_OMIT_BUILTIN_TEST&lt;/a&gt; compile-time option to &lt;a href=&quot;compile#untestable&quot;&gt;SQLITE_UNTESTABLE&lt;/a&gt; to better reflect the implications of using it.</source>
          <target state="translated">Переименуйте параметр &lt;a href=&quot;compile#omit_builtin_test&quot;&gt;времени&lt;/a&gt; компиляции SQLITE_OMIT_BUILTIN_TEST в &lt;a href=&quot;compile#untestable&quot;&gt;SQLITE_UNTESTABLE,&lt;/a&gt; чтобы лучше отразить последствия его использования.</target>
        </trans-unit>
        <trans-unit id="be5b8fd29874b31a75967598563d2c598ed8c802" translate="yes" xml:space="preserve">
          <source>Render expressions of the form &quot;x IN (?)&quot; (with a single value in the list on the right-hand side of the IN operator) as if they where &quot;x==?&quot;, Similarly optimize &quot;x NOT IN (?)&quot;</source>
          <target state="translated">Выражения формы &quot;x IN (?)&quot; (с одним значением в списке справа от оператора IN),как если бы они были где &quot;x==?&quot;,аналогично оптимизируйте &quot;x NOT IN (?)&quot;.</target>
        </trans-unit>
        <trans-unit id="88333a43b7fd427d0516f0a5d5107e5f54e545df" translate="yes" xml:space="preserve">
          <source>ReopenIdx</source>
          <target state="translated">ReopenIdx</target>
        </trans-unit>
        <trans-unit id="7c28d43c9fc88003b6477ed308834ef4aec930a4" translate="yes" xml:space="preserve">
          <source>Reorganize the Unix interface in os_unix.c</source>
          <target state="translated">Реорганизация Unix-интерфейса в os_unix.c</target>
        </trans-unit>
        <trans-unit id="4b096fbd5cf8040410b520d0087755f15a4e4623" translate="yes" xml:space="preserve">
          <source>Repeatedly switching an SQLite database in and out of &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt; and running the &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; command in between switches, in one process or thread, can cause another process or thread that has the database file open to miss the fact that the database has changed. That second process or thread might then try to modify the database using a stale cache and cause database corruption.</source>
          <target state="translated">Неоднократное переключение базы данных SQLite в &lt;a href=&quot;wal&quot;&gt;режим WAL&lt;/a&gt; и из него и выполнение команды &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; между переключателями в одном процессе или потоке может привести к тому, что другой процесс или поток, у которого открыт файл базы данных, пропустит тот факт, что база данных изменилась. Затем этот второй процесс или поток может попытаться изменить базу данных с помощью устаревшего кеша и вызвать повреждение базы данных.</target>
        </trans-unit>
        <trans-unit id="08d1902d969043d4f5ff76c612c66edc344a58a0" translate="yes" xml:space="preserve">
          <source>Replace the built-in mutex subsystem with an alternative implementation.</source>
          <target state="translated">Заменить встроенную подсистему мьютекса альтернативной реализацией.</target>
        </trans-unit>
        <trans-unit id="6fd04b040e5c22cd85b1871575a876977a443534" translate="yes" xml:space="preserve">
          <source>Replace the interface to the file system with an alternative design. In other words, override all of the system calls that SQLite makes in order to talk to the disk with a completely different set of system calls.</source>
          <target state="translated">Замените интерфейс на файловую систему альтернативным дизайном.Другими словами,переопределить все системные вызовы,которые делает SQLite,чтобы поговорить с диском с совершенно другим набором системных вызовов.</target>
        </trans-unit>
        <trans-unit id="8a67a8b071dbf97af58f9f8fc030dc4129a982a5" translate="yes" xml:space="preserve">
          <source>Report an error if an ORDER BY or GROUP BY expression is constant.</source>
          <target state="translated">Сообщить об ошибке,если выражение ORDER BY или GROUP BY является постоянным.</target>
        </trans-unit>
        <trans-unit id="5382d03ec82f0e424f0e2bcd884c37beaa553f16" translate="yes" xml:space="preserve">
          <source>Report rollback recovery in the &lt;a href=&quot;errlog&quot;&gt;error log&lt;/a&gt; as SQLITE_NOTICE_RECOVER_ROLLBACK. Change the error log code for WAL recover from SQLITE_OK to SQLITE_NOTICE_RECOVER_WAL.</source>
          <target state="translated">Сообщите о восстановлении отката в &lt;a href=&quot;errlog&quot;&gt;журнале ошибок&lt;/a&gt; как SQLITE_NOTICE_RECOVER_ROLLBACK. Измените код журнала ошибок для восстановления WAL с SQLITE_OK на SQLITE_NOTICE_RECOVER_WAL.</target>
        </trans-unit>
        <trans-unit id="2a209e68ce6d7ef5cbfce6e23fd387511ef2796d" translate="yes" xml:space="preserve">
          <source>Report the name of specific &lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK&lt;/a&gt; constraints that fail.</source>
          <target state="translated">Сообщите имя конкретных ограничений &lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK,&lt;/a&gt; которые не выполняются.</target>
        </trans-unit>
        <trans-unit id="1b12d49166f15edffd3aeb0179e7e1787f48ce27" translate="yes" xml:space="preserve">
          <source>Report the risky uses of &lt;a href=&quot;howtocorrupt#unlink&quot;&gt;unlinked database files&lt;/a&gt; and &lt;a href=&quot;howtocorrupt#alias&quot;&gt;database filename aliasing&lt;/a&gt; as SQLITE_WARNING messages in the &lt;a href=&quot;errlog&quot;&gt;error log&lt;/a&gt;.</source>
          <target state="translated">Сообщайте о рискованном использовании &lt;a href=&quot;howtocorrupt#unlink&quot;&gt;несвязанных файлов &lt;/a&gt;&lt;a href=&quot;howtocorrupt#alias&quot;&gt;базы &lt;/a&gt;данных и псевдонимов файлов базы данных в виде сообщений SQLITE_WARNING в &lt;a href=&quot;errlog&quot;&gt;журнале ошибок&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a328f2c4ddffb4f007ee170c822e792cbe7ac2bd" translate="yes" xml:space="preserve">
          <source>Reposition cursor P1 so that it points to the largest entry that is less than or equal to the key value. If there are no records less than or equal to the key and P2 is not zero, then jump to P2.</source>
          <target state="translated">Переместите курсор P1 так,чтобы он указывал на самую большую запись,которая меньше или равна ключевому значению.Если нет записей меньше или равно клавише,а P2 не равен нулю,то переходите к P2.</target>
        </trans-unit>
        <trans-unit id="3135b4b4b6f2ab789efbcd1b22f24612c3f91745" translate="yes" xml:space="preserve">
          <source>Reposition cursor P1 so that it points to the largest entry that is less than the key value. If there are no records less than the key and P2 is not zero, then jump to P2.</source>
          <target state="translated">Переместите курсор P1 так,чтобы он указывал на самую большую запись,которая меньше ключевого значения.Если нет записей меньше клавиши,а P2 не равен нулю,то переходите к P2.</target>
        </trans-unit>
        <trans-unit id="0ecdc43c68575ffe0f6b403b40297cdd23849385" translate="yes" xml:space="preserve">
          <source>Reposition cursor P1 so that it points to the smallest entry that is greater than or equal to the key value. If there are no records greater than or equal to the key and P2 is not zero, then jump to P2.</source>
          <target state="translated">Переместите курсор P1 так,чтобы он указывал на самую маленькую запись,которая больше или равна ключевому значению.Если нет записей больше или равно клавише,а P2 не равен нулю,то переходите к P2.</target>
        </trans-unit>
        <trans-unit id="12d5076757ddc1b93a63854acae2fbdea1746c5f" translate="yes" xml:space="preserve">
          <source>Reposition cursor P1 so that it points to the smallest entry that is greater than the key value. If there are no records greater than the key and P2 is not zero, then jump to P2.</source>
          <target state="translated">Переместите курсор P1 так,чтобы он указывал на самую маленькую запись,которая больше ключевого значения.Если нет записей больше клавиши,а P2 не равен нулю,то переходите к P2.</target>
        </trans-unit>
        <trans-unit id="c029db81bd8f30ac7ba33c5eb9c17a5ae29866f1" translate="yes" xml:space="preserve">
          <source>Represent a &lt;a href=&quot;https://en.wikipedia.org/wiki/Zip_(file_format)&quot;&gt;ZIP Archive&lt;/a&gt; as an SQL table. Works for both reading and writing. Used by the &lt;a href=&quot;cli&quot;&gt;CLI&lt;/a&gt; to implement the ability to read and write ZIP Archives.</source>
          <target state="translated">Представьте &lt;a href=&quot;https://en.wikipedia.org/wiki/Zip_(file_format)&quot;&gt;ZIP-архив&lt;/a&gt; в виде таблицы SQL. Работает как для чтения, так и для письма. Используется &lt;a href=&quot;cli&quot;&gt;CLI&lt;/a&gt; для реализации возможности чтения и записи ZIP-архивов.</target>
        </trans-unit>
        <trans-unit id="bf10d00bc3da2452de6c68f43ec52e620c1a7872" translate="yes" xml:space="preserve">
          <source>Representation is the essence of computer programming.</source>
          <target state="translated">Представительство является сущностью компьютерного программирования.</target>
        </trans-unit>
        <trans-unit id="1d9b3293e88caaa716c1a885e5b50e65b2bb3b2a" translate="yes" xml:space="preserve">
          <source>Represents the global variables of a &lt;a href=&quot;https://en.wikipedia.org/wiki/Tcl&quot;&gt;TCL Interpreter&lt;/a&gt; as an SQL table. Used as part of the SQLite test suite.</source>
          <target state="translated">Представляет глобальные переменные &lt;a href=&quot;https://en.wikipedia.org/wiki/Tcl&quot;&gt;интерпретатора TCL&lt;/a&gt; в виде таблицы SQL. Используется как часть набора тестов SQLite.</target>
        </trans-unit>
        <trans-unit id="c26bf60fed3744bb0049608ff95380b842c473a6" translate="yes" xml:space="preserve">
          <source>Requested</source>
          <target state="translated">Requested</target>
        </trans-unit>
        <trans-unit id="dbbf6c568082dd9fe7decc89c41aaaa504df8ded" translate="yes" xml:space="preserve">
          <source>Requirement H35050 (section</source>
          <target state="translated">Требование H35050 (раздел</target>
        </trans-unit>
        <trans-unit id="4e1bcb3ced4612d53be234208553c503d16c2746" translate="yes" xml:space="preserve">
          <source>Requirements describing how a</source>
          <target state="translated">Требования,описывающие как</target>
        </trans-unit>
        <trans-unit id="5472f074118e0fcc2fcc663b98dfc71e267df752" translate="yes" xml:space="preserve">
          <source>Requirements describing step 1 of the above procedure in detail:</source>
          <target state="translated">Требования,подробно описывающие этап 1 вышеописанной процедуры:</target>
        </trans-unit>
        <trans-unit id="fad7011bc39debdd3199704eacbe43fe1a48d858" translate="yes" xml:space="preserve">
          <source>Requirements describing step 2 of the above procedure in detail:</source>
          <target state="translated">Требования,подробно описывающие этап 2 вышеуказанной процедуры:</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
