<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="sqlite">
    <body>
      <group id="sqlite">
        <trans-unit id="fa9dd62d3bfcaf75e4033204e51b41d31455c6e9" translate="yes" xml:space="preserve">
          <source>It is important to verify that the gcov test run and the second real test run both give the same output. Any differences in output indicate either the use of undefined or indeterminate behavior in the SQLite code (and hence a bug), or a bug in the compiler. Note that SQLite has, over the previous decade, encountered bugs in each of GCC, Clang, and MSVC. Compiler bugs, while rare, do happen, which is why it is so important to test the code in an as-delivered configuration.</source>
          <target state="translated">Важно убедиться,что тест gcov и второй реальный тест дают один и тот же результат.Любые различия в выводимых данных указывают либо на использование неопределенного или неопределенного поведения в коде SQLite (и,следовательно,на ошибку),либо на ошибку в компиляторе.Обратите внимание,что за последнее десятилетие SQLite сталкивался с ошибками в каждом из GCC,Clang и MSVC.Ошибки компилятора,хотя и встречаются редко,но случаются,поэтому так важно тестировать код в конфигурации &quot;как есть&quot;.</target>
        </trans-unit>
        <trans-unit id="d1cea258b6006ec069fad2e48bb8e0ae1aa954d2" translate="yes" xml:space="preserve">
          <source>It is impossible to test every possible combination of compile-time options for SQLite. But the following set of compile-time options is one configuration that is always fully tested.</source>
          <target state="translated">Невозможно проверить все возможные комбинации опций времени компиляции для SQLite.Но следующий набор опций времени компиляции-это одна конфигурация,которая всегда полностью тестируется.</target>
        </trans-unit>
        <trans-unit id="15edf0a6c6c69dc4fe559f59d8b017e98f300472" translate="yes" xml:space="preserve">
          <source>It is impractical to do crash testing using real power failures, of course, and so crash testing is done in simulation. An alternative &lt;a href=&quot;c3ref/vfs&quot;&gt;Virtual File System&lt;/a&gt; is inserted that allows the test harness to simulate the state of the database file following a crash.</source>
          <target state="translated">Конечно, нецелесообразно проводить краш-тестирование с использованием реальных отказов питания, поэтому краш-тестирование проводится в симуляции. Добавлена ​​альтернативная &lt;a href=&quot;c3ref/vfs&quot;&gt;виртуальная файловая система,&lt;/a&gt; которая позволяет тестовой системе имитировать состояние файла базы данных после сбоя.</target>
        </trans-unit>
        <trans-unit id="e1d5ef237a2a6e6403153de4b153927de75448b8" translate="yes" xml:space="preserve">
          <source>It is not an error if the named table does not exist in the database. Nor is it an error if the named table does not have a PRIMARY KEY. However, no changes will be recorded in either of these scenarios.</source>
          <target state="translated">Это не является ошибкой,если именованная таблица не существует в БД.Это также не ошибка,если именованная таблица не имеет PRIMARY KEY.Однако ни в одном из этих сценариев изменения записываться не будут.</target>
        </trans-unit>
        <trans-unit id="d49fdf0ef1b4c639114a4ac63de04efc40c67c48" translate="yes" xml:space="preserve">
          <source>It is not an error to create a table that has the same name as an existing &lt;a href=&quot;lang_createtrigger&quot;&gt;trigger&lt;/a&gt;.</source>
          <target state="translated">Создание таблицы с тем же именем, что и существующий &lt;a href=&quot;lang_createtrigger&quot;&gt;триггер,&lt;/a&gt; не является ошибкой .</target>
        </trans-unit>
        <trans-unit id="8aaf6c77de556f14a491171c58f28d211cfbc9d4" translate="yes" xml:space="preserve">
          <source>It is not commonly useful to evaluate the &lt;em&gt;exact&lt;/em&gt; same SQL statement more than once. More often, one wants to evaluate similar statements. For example, you might want to evaluate an INSERT statement multiple times with different values. Or you might want to evaluate the same query multiple times using a different key in the WHERE clause. To accommodate this, SQLite allows SQL statements to contain &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameters&lt;/a&gt; which are &quot;bound&quot; to values prior to being evaluated. These values can later be changed and the same &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; can be evaluated a second time using the new values.</source>
          <target state="translated">Это обычно не полезно оценить &lt;em&gt;точно&lt;/em&gt; тот же оператор SQL более чем один раз. Чаще хочется оценить подобные утверждения. Например, вы можете захотеть несколько раз оценить оператор INSERT с разными значениями. Или вы можете захотеть оценить один и тот же запрос несколько раз, используя другой ключ в предложении WHERE. Чтобы приспособиться к этому, SQLite позволяет операторам SQL содержать &lt;a href=&quot;lang_expr#varparam&quot;&gt;параметры,&lt;/a&gt; которые &amp;laquo;привязаны&amp;raquo; к значениям до их оценки. Эти значения могут быть позже изменены, и тот же &lt;a href=&quot;c3ref/stmt&quot;&gt;подготовленный оператор&lt;/a&gt; может быть оценен во второй раз с использованием новых значений.</target>
        </trans-unit>
        <trans-unit id="8de5c77745aab508a14fca7f3c047cc5a41b83c4" translate="yes" xml:space="preserve">
          <source>It is not impossible to find the descendents of a check-in in Git. It is merely difficult. For example, there is a &lt;a href=&quot;https://stackoverflow.com/questions/27960605/find-all-the-direct-descendants-of-a-given-commit#27962018&quot;&gt;stackoverflow page&lt;/a&gt; showing the command sequence for finding the descendents of a check-in in unix:</source>
          <target state="translated">В Git возможно найти потомков регистрации. Это просто сложно. Например, есть &lt;a href=&quot;https://stackoverflow.com/questions/27960605/find-all-the-direct-descendants-of-a-given-commit#27962018&quot;&gt;страница stackoverflow,&lt;/a&gt; показывающая последовательность команд для поиска потомков регистрации в unix:</target>
        </trans-unit>
        <trans-unit id="968af02ea707c660eea2edbc719717453c1c09b4" translate="yes" xml:space="preserve">
          <source>It is not necessary for every column of an index to appear in a WHERE clause term in order for that index to be used. But there cannot be gaps in the columns of the index that are used. Thus for the example index above, if there is no WHERE clause term that constraints column c, then terms that constrain columns a and b can be used with the index but not terms that constraint columns d through z. Similarly, index columns will not normally be used (for indexing purposes) if they are to the right of a column that is constrained only by inequalities. (See the &lt;a href=&quot;optoverview#skipscan&quot;&gt;skip-scan optimization&lt;/a&gt; below for the exception.)</source>
          <target state="translated">Необязательно, чтобы каждый столбец индекса появлялся в термине предложения WHERE, чтобы этот индекс можно было использовать. Но в используемых столбцах индекса не может быть пробелов. Таким образом, для приведенного выше примера индекса, если нет термина предложения WHERE, ограничивающего столбец c, тогда термины, которые ограничивают столбцы a и b, могут использоваться с индексом, но не термины, которые ограничивают столбцы с d по z. Точно так же столбцы индекса обычно не используются (для целей индексации), если они находятся справа от столбца, который ограничен только неравенствами. (Для исключения см. &lt;a href=&quot;optoverview#skipscan&quot;&gt;Оптимизацию пропуска сканирования&lt;/a&gt; ниже.)</target>
        </trans-unit>
        <trans-unit id="91c4a366eb8b7036569a617f444657bfe2829b75" translate="yes" xml:space="preserve">
          <source>It is not necessary to delete a session object after extracting a changeset or patchset from it. It can be left attached to the database handle and will continue monitoring for changes on the configured tables as before. However, if &lt;a href=&quot;session/sqlite3session_changeset&quot;&gt;sqlite3session_changeset()&lt;/a&gt; or &lt;a href=&quot;session/sqlite3session_patchset&quot;&gt;sqlite3session_patchset()&lt;/a&gt; is called a second time on a session object, the changeset or patchset will contain &lt;em&gt;all&lt;/em&gt; changes that have taken place on the connection since the session was created. In other words, a session object is not reset or zeroed by a call to sqlite3session_changeset() or sqlite3session_patchset().</source>
          <target state="translated">Нет необходимости удалять объект сеанса после извлечения из него набора изменений или патчей. Его можно оставить прикрепленным к дескриптору базы данных, и он будет продолжать отслеживать изменения в настроенных таблицах, как и раньше. Однако, если &lt;a href=&quot;session/sqlite3session_changeset&quot;&gt;sqlite3session_changeset ()&lt;/a&gt; или &lt;a href=&quot;session/sqlite3session_patchset&quot;&gt;sqlite3session_patchset ()&lt;/a&gt; вызывается второй раз для объекта сеанса, набор изменений или набор исправлений будет содержать &lt;em&gt;все&lt;/em&gt; изменения, которые произошли в соединении с момента создания сеанса. Другими словами, объект сеанса не сбрасывается или не обнуляется вызовом sqlite3session_changeset () или sqlite3session_patchset ().</target>
        </trans-unit>
        <trans-unit id="670d42dfe457729d9823abd17b04a227c0f7995a" translate="yes" xml:space="preserve">
          <source>It is not necessary to increment the change counter in the database header for transactions after the first transaction. This will often save a write of page one to both the rollback journal and the main database file.</source>
          <target state="translated">Нет необходимости увеличивать счетчик изменений в заголовке БД для транзакций после первой транзакции.Часто это позволяет сохранить запись первой страницы как в журнал отката,так и в основной файл БД.</target>
        </trans-unit>
        <trans-unit id="2403c6f4220d7ab7621d951d5ca316ce8bb167ec" translate="yes" xml:space="preserve">
          <source>It is not necessary to retrieve data in the format specify by sqlite3_column_type(). If a different format is requested, the data is converted automatically.</source>
          <target state="translated">Нет необходимости извлекать данные в формате,указанном функцией sqlite3_column_type().Если запрашивается другой формат,данные преобразуются автоматически.</target>
        </trans-unit>
        <trans-unit id="900bad887efaa153c1a2b75294545475e3b1d504" translate="yes" xml:space="preserve">
          <source>It is not possible for a single FTS query to return rows with different languageid values. The results of adding WHERE clauses that use other operators (e.g. lid!=5, or lid&amp;lt;=5) are undefined.</source>
          <target state="translated">Один запрос FTS не может возвращать строки с разными значениями languageid. Результаты добавления предложений WHERE, использующих другие операторы (например, lid! = 5 или lid &amp;lt;= 5), не определены.</target>
        </trans-unit>
        <trans-unit id="7d7041428ac37cb2fe5a20d78347fe7eb6acfbe1" translate="yes" xml:space="preserve">
          <source>It is not possible to UPDATE or DELETE a row stored in a contentless FTS4 table. Attempting to do so is an error.</source>
          <target state="translated">Невозможно ОБНАРУЖИВАТЬ или УДАЛИТЬ строку,хранящуюся в бесконтактной таблице FTS4.Попытка сделать это является ошибкой.</target>
        </trans-unit>
        <trans-unit id="9e4665d3e6caf2e43eb0161671eab0b61b62c13a" translate="yes" xml:space="preserve">
          <source>It is not possible to change the &lt;a href=&quot;pragma#pragma_page_size&quot;&gt;page_size&lt;/a&gt; after entering WAL mode, either on an empty database or by using &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; or by restoring from a backup using the &lt;a href=&quot;backup&quot;&gt;backup API&lt;/a&gt;. You must be in a rollback journal mode to change the page size.</source>
          <target state="translated">Невозможно изменить &lt;a href=&quot;pragma#pragma_page_size&quot;&gt;page_size&lt;/a&gt; после входа в режим WAL ни в пустой базе данных, ни с помощью &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM,&lt;/a&gt; ни путем восстановления из резервной копии с помощью &lt;a href=&quot;backup&quot;&gt;API резервного копирования&lt;/a&gt; . Чтобы изменить размер страницы, вы должны находиться в режиме журнала отката.</target>
        </trans-unit>
        <trans-unit id="deaab8f44371f477a4e7e55d31601e0d0d6a03fb" translate="yes" xml:space="preserve">
          <source>It is not possible to enable or disable foreign key constraints in the middle of a &lt;a href=&quot;lang_transaction&quot;&gt;multi-statement transaction&lt;/a&gt; (when SQLite is not in &lt;a href=&quot;c3ref/get_autocommit&quot;&gt;autocommit mode&lt;/a&gt;). Attempting to do so does not return an error; it simply has no effect.</source>
          <target state="translated">Невозможно включить или отключить ограничения внешнего ключа в середине &lt;a href=&quot;lang_transaction&quot;&gt;транзакции&lt;/a&gt; с несколькими операторами (когда SQLite не находится в &lt;a href=&quot;c3ref/get_autocommit&quot;&gt;режиме автоматической фиксации&lt;/a&gt; ). Попытка сделать это не вернет ошибку; это просто не действует.</target>
        </trans-unit>
        <trans-unit id="59d7023d400b2c4a42c25e47c1d1dae5bdb83625" translate="yes" xml:space="preserve">
          <source>It is not possible to use the &quot;ALTER TABLE ... ADD COLUMN&quot; syntax to add a column that includes a REFERENCES clause, unless the default value of the new column is NULL. Attempting to do so returns an error.</source>
          <target state="translated">Невозможно использовать &quot;АЛЬТЕР-ТАБЛИЦУ&quot; ...ADD COLUMN&quot; для добавления столбца,включающего пункт REFERENCES,если только значение по умолчанию нового столбца не равно NULL.Попытка сделать это возвращает ошибку.</target>
        </trans-unit>
        <trans-unit id="912f58b54e2d4f955145072d5727d208f46d87cf" translate="yes" xml:space="preserve">
          <source>It is not safe to read or modify this variable in more than one thread at a time. It is not safe to read or modify this variable if a &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; is being used at the same time in a separate thread. It is intended that this variable be set once as part of process initialization and before any SQLite interface routines have been called and that this variable remain unchanged thereafter.</source>
          <target state="translated">Прочитать или изменить эту переменную более чем в одном потоке одновременно небезопасно. Прочитать или изменить эту переменную небезопасно, если &lt;a href=&quot;#sqlite3&quot;&gt;соединение&lt;/a&gt; с базой данных используется одновременно в отдельном потоке. Предполагается, что эта переменная будет установлена ​​один раз как часть инициализации процесса и до того, как будут вызваны какие-либо процедуры интерфейса SQLite, и что эта переменная после этого останется неизменной.</target>
        </trans-unit>
        <trans-unit id="903cea61d0db784ec27805bae69d5dea09532edb" translate="yes" xml:space="preserve">
          <source>It is not safe to read or modify this variable in more than one thread at a time. It is not safe to read or modify this variable if a &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; is being used at the same time in a separate thread. It is intended that this variable be set once as part of process initialization and before any SQLite interface routines have been called and that this variable remain unchanged thereafter.</source>
          <target state="translated">Прочитать или изменить эту переменную более чем в одном потоке одновременно небезопасно. Прочитать или изменить эту переменную небезопасно, если &lt;a href=&quot;sqlite3&quot;&gt;соединение&lt;/a&gt; с базой данных используется одновременно в отдельном потоке. Предполагается, что эта переменная будет установлена ​​один раз как часть инициализации процесса и до того, как будут вызваны какие-либо процедуры интерфейса SQLite, и что эта переменная после этого останется неизменной.</target>
        </trans-unit>
        <trans-unit id="159cf71be6e4a6830ae2567917f78113abca0955" translate="yes" xml:space="preserve">
          <source>It is ok to make multiple entries for the same word as long as each entry has a different soundslike value. Note that if no soundslike value is specified, the soundslike defaults to the word itself.</source>
          <target state="translated">Можно делать несколько записей для одного и того же слова,если каждая запись имеет разное звуковое значение.Обратите внимание,что если звуковое значение не указано,звуковое значение по умолчанию будет соответствовать самому слову.</target>
        </trans-unit>
        <trans-unit id="42b6da3d325a27b4a54e5028535caa1fb0d83d7a" translate="yes" xml:space="preserve">
          <source>It is particularly important to use an entry point name that is based on the extension filename, rather than the generic &quot;sqlite3_extension_init&quot; entry point name, if you will be statically linking two or more extensions. If you use the generic name, there will be multiple definitions of the same symbol and the link will fail.</source>
          <target state="translated">Особенно важно использовать имя точки входа,которое основано на имени файла расширения,а не на общем имени точки входа &quot;sqlite3_extension_init&quot;,если вы будете статически связывать два или более расширения.Если вы используете общее имя,то будет несколько определений одного и того же символа,и ссылка будет неудачной.</target>
        </trans-unit>
        <trans-unit id="1f5372992ab68655b726354d1de85f6b9510df2c" translate="yes" xml:space="preserve">
          <source>It is permitted to register multiple implementations of the same functions with the same name but with either differing numbers of arguments or differing preferred text encodings. SQLite will use the implementation that most closely matches the way in which the SQL function is used. A function implementation with a non-negative nArg parameter is a better match than a function implementation with a negative nArg. A function where the preferred text encoding matches the database encoding is a better match than a function where the encoding is different. A function where the encoding difference is between UTF16le and UTF16be is a closer match than a function where the encoding difference is between UTF8 and UTF16.</source>
          <target state="translated">Разрешается регистрировать несколько реализаций одних и тех же функций с одним и тем же именем,но либо с разным количеством аргументов,либо с разными предпочтительными текстовыми кодировками.SQLite будет использовать реализацию,наиболее точно соответствующую способу использования функции SQL.Реализация функции с неотрицательным параметром nArg лучше подходит,чем реализация функции с отрицательным параметром nArg.Функция,в которой предпочитаемая текстовая кодировка совпадает с кодировкой БД,лучше подходит,чем функция,в которой кодировка отличается.Функция,где разница кодировок между UTF16le и UTF16be ближе,чем функция,где разница кодировок между UTF8 и UTF16.</target>
        </trans-unit>
        <trans-unit id="d335c80330cdb9262d358bd293d73594c1829762" translate="yes" xml:space="preserve">
          <source>It is possible for the library compile-time C preprocessor symbol &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; to override this pragma setting. The following table summarizes the interaction of the &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; preprocessor macro and the temp_store pragma:</source>
          <target state="translated">Символ препроцессора C времени компиляции &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; может переопределить эту настройку прагмы . В следующей таблице суммировано взаимодействие &lt;a href=&quot;compile#temp_store&quot;&gt;макроса&lt;/a&gt; препроцессора SQLITE_TEMP_STORE и прагмы temp_store:</target>
        </trans-unit>
        <trans-unit id="882d45108ae3506a475e868a2ed67d0f5c2e5629" translate="yes" xml:space="preserve">
          <source>It is possible that future enhancements to the prover might enable it to recognize that NULL inputs to certain built-in functions always result in a NULL answer. But not all built-in functions have that property (for example &lt;a href=&quot;lang_corefunc#coalesce&quot;&gt;coalesce()&lt;/a&gt;) and, of course, the prover will never be able to reason about &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="105eb1a524704db6ebed7c523dd9971899853505" translate="yes" xml:space="preserve">
          <source>It is possible that future enhancements to the prover might enable it to recognize that NULL inputs to certain built-in functions always result in a NULL answer. But not all built-in functions have that property (for example &lt;a href=&quot;lang_corefunc#coalesce&quot;&gt;coalesce()&lt;/a&gt;) and, of course, the prover will never be able to reason about &lt;a href=&quot;c3ref/create_function&quot;&gt;application-defined SQL functions&lt;/a&gt;.</source>
          <target state="translated">Возможно, что будущие усовершенствования программы доказательства могут позволить ему распознавать, что входные данные NULL для определенных встроенных функций всегда приводят к ответу NULL. Но не все встроенные функции обладают этим свойством (например, &lt;a href=&quot;lang_corefunc#coalesce&quot;&gt;coalesce ()&lt;/a&gt; ), и, конечно же, доказывающий никогда не сможет рассуждать о &lt;a href=&quot;c3ref/create_function&quot;&gt;функциях SQL, определяемых приложением&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2be5eee10a74ce784db26ece955361d8533b48cb" translate="yes" xml:space="preserve">
          <source>It is possible to build a special &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt; that will work with a predetermined set of SQLITE_OMIT_... options. Instructions for doing so can be found with the &lt;a href=&quot;compile#omitfeatures&quot;&gt;SQLITE_OMIT_... documentation&lt;/a&gt;.</source>
          <target state="translated">Можно создать специальное &lt;a href=&quot;amalgamation&quot;&gt;объединение,&lt;/a&gt; которое будет работать с заранее определенным набором параметров SQLITE_OMIT _.... Инструкции по этим вопросам можно найти с &lt;a href=&quot;compile#omitfeatures&quot;&gt;SQLITE_OMIT _... документации&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="321373a36254200d34f2e6be79e9dd835a4c4ba3" translate="yes" xml:space="preserve">
          <source>It is possible to create multiple session objects attached to a single database handle.</source>
          <target state="translated">Можно создать несколько объектов сеанса,прикрепленных к одному дескриптору базы данных.</target>
        </trans-unit>
        <trans-unit id="bed5d040f0bed9644c8d2600cb5ecf6e91531170" translate="yes" xml:space="preserve">
          <source>It is possible to extend custom or pile-of-files formats too, of course, but doing is often much harder. If indices are added, then all application code that changes the corresponding tables must be located and modified to keep those indices up-to-date. If columns are added, then all application code that accesses the corresponding table must be located and modified to take into account the new columns.</source>
          <target state="translated">Конечно,можно расширить и пользовательский формат или формат &quot;кучи файлов&quot;,но зачастую это гораздо сложнее сделать.Если добавляются индексы,то весь код приложения,который изменяет соответствующие таблицы,должен быть расположен и модифицирован,чтобы поддерживать эти индексы в актуальном состоянии.Если добавляются столбцы,то весь код приложения,получающего доступ к соответствующей таблице,должен быть расположен и изменен с учетом новых столбцов.</target>
        </trans-unit>
        <trans-unit id="e6a04c27b0773734dfa33829ac44458f0f513a43" translate="yes" xml:space="preserve">
          <source>It is possible to have an aggregate function with the same name as a simple function, as long as the number of arguments for the two forms of the function are different. For example, the &lt;a href=&quot;lang_aggfunc#maxggunc&quot;&gt;max()&lt;/a&gt; function with a single argument is an aggregate and the &lt;a href=&quot;lang_corefunc#maxoreunc&quot;&gt;max()&lt;/a&gt; function with two or more arguments is a simple function. Aggregate functions can usually also be used as window functions.</source>
          <target state="translated">Возможно иметь агрегатную функцию с тем же именем, что и у простой функции, если количество аргументов для двух форм функции различно. Например, функция &lt;a href=&quot;lang_aggfunc#maxggunc&quot;&gt;max ()&lt;/a&gt; с одним аргументом является агрегатом, а функция &lt;a href=&quot;lang_corefunc#maxoreunc&quot;&gt;max ()&lt;/a&gt; с двумя или более аргументами является простой функцией. Агрегатные функции обычно также могут использоваться как оконные.</target>
        </trans-unit>
        <trans-unit id="79fc85e42448050747bff9c78bdebc62767b73c0" translate="yes" xml:space="preserve">
          <source>It is possible to make SQLite treat NULLs as distinct for the purposes of the SELECT DISTINCT and UNION. To do so, one should change the value of the NULL_ALWAYS_DISTINCT #define in the &lt;code&gt;sqliteInt.h&lt;/code&gt; source file and recompile.</source>
          <target state="translated">Можно заставить SQLite обрабатывать NULL как разные для целей SELECT DISTINCT и UNION. Для этого необходимо изменить значение NULL_ALWAYS_DISTINCT #define в исходном файле &lt;code&gt;sqliteInt.h&lt;/code&gt; и перекомпилировать.</target>
        </trans-unit>
        <trans-unit id="ef8babc1f36de58a996ade599caa2a6556653b1a" translate="yes" xml:space="preserve">
          <source>It is possible to tell whether or not the 'merge' command found any b-trees to merge together by checking the value returned by the &lt;a href=&quot;c3ref/total_changes&quot;&gt;sqlite3_total_changes()&lt;/a&gt; API before and after the command is executed. If the difference between the two values is 2 or greater, then work was performed. If the difference is less than 2, then the 'merge' command was a no-op. In this case there is no reason to execute the same 'merge' command again, at least until after the FTS table is next updated.</source>
          <target state="translated">Можно определить, нашла ли команда 'merge' какие-либо b-деревья для слияния, проверив значение, возвращаемое API &lt;a href=&quot;c3ref/total_changes&quot;&gt;sqlite3_total_changes ()&lt;/a&gt; до и после выполнения команды. Если разница между двумя значениями составляет 2 или больше, значит работа выполнена. Если разница меньше 2, то команда &amp;laquo;слияние&amp;raquo; не выполнялась. В этом случае нет причин для повторного выполнения той же команды &amp;laquo;слияния&amp;raquo;, по крайней мере, до следующего обновления таблицы FTS.</target>
        </trans-unit>
        <trans-unit id="e63e80c9bba9974f9e6774ae97788b65cf7107ad" translate="yes" xml:space="preserve">
          <source>It is possible to write into the &quot;t2&quot; table, thus changing the content of the index. But doing so will get the &quot;t1bc&quot; index out of synchronization with its parent table &quot;t1&quot;. An out-of-sync index can result in incorrect query results.</source>
          <target state="translated">Можно записать в таблицу &quot;t2&quot;,тем самым изменив содержание индекса.Но при этом индекс &quot;t1bc&quot; выйдет из синхронизации с его родительской таблицей &quot;t1&quot;.Несинхронизированный индекс может привести к некорректным результатам запроса.</target>
        </trans-unit>
        <trans-unit id="0822da1b538a191177f07ef1dc3b36f0cff1be87" translate="yes" xml:space="preserve">
          <source>It is recommended that applications respond to the errors listed above by explicitly issuing a ROLLBACK command. If the transaction has already been rolled back automatically by the error response, then the ROLLBACK command will fail with an error, but no harm is caused by this.</source>
          <target state="translated">Рекомендуется,чтобы приложения отвечали на перечисленные выше ошибки явным выпуском команды ROLLBACK.Если транзакция уже откатилась автоматически в ответ на ошибку,то команда ROLLBACK не будет выполнена с ошибкой,но это не причинит никакого вреда.</target>
        </trans-unit>
        <trans-unit id="7b7eb3618faa363b4bb6cb76587e213a07280f4c" translate="yes" xml:space="preserve">
          <source>It is safe to call this routine from a thread different from the thread that is currently running the database operation. But it is not safe to call this routine with a &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; that is closed or might close before sqlite3_interrupt() returns.</source>
          <target state="translated">Эту процедуру можно безопасно вызывать из потока, отличного от потока, в котором в данный момент выполняется операция с базой данных. Но небезопасно вызывать эту процедуру при закрытом или закрытом &lt;a href=&quot;#sqlite3&quot;&gt;соединении&lt;/a&gt; с базой данных до возврата sqlite3_interrupt ().</target>
        </trans-unit>
        <trans-unit id="0d70d917087b8b111a765ae7a55cfbd2640b316e" translate="yes" xml:space="preserve">
          <source>It is safe to call this routine from a thread different from the thread that is currently running the database operation. But it is not safe to call this routine with a &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; that is closed or might close before sqlite3_interrupt() returns.</source>
          <target state="translated">Эту процедуру можно безопасно вызывать из потока, отличного от потока, в котором в данный момент выполняется операция с базой данных. Но небезопасно вызывать эту процедуру при закрытом или закрытом &lt;a href=&quot;sqlite3&quot;&gt;соединении&lt;/a&gt; с базой данных до возврата sqlite3_interrupt ().</target>
        </trans-unit>
        <trans-unit id="d9e98c95444e8fd3d643f309806f8f5b2d312406" translate="yes" xml:space="preserve">
          <source>It is safe to execute SQL statements, including those that write to the table that the callback related to, from within the xConflict callback. This can be used to further customize the application's conflict resolution strategy.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7155cc55f906067b466a3957abc2b2fa5ca703ab" translate="yes" xml:space="preserve">
          <source>It is safe to execute SQL statements, including those that write to the table that the callback related to, from within the xConflict callback. This can be used to further customize the applications conflict resolution strategy.</source>
          <target state="translated">Безопасно выполнять SQL-операторы,в том числе и те,которые пишут в таблицу,с которой связан обратный вызов,из xConflict callback.Это может быть использовано для дальнейшей настройки стратегии разрешения конфликтов приложений.</target>
        </trans-unit>
        <trans-unit id="33153f14bd397b5e62d91fe18b2589aae1781966" translate="yes" xml:space="preserve">
          <source>It is sometimes convenient for SQLite extensions to communicate non-SQL values between subcomponents or between the extension and the application. Some examples:</source>
          <target state="translated">Для расширений SQLite иногда удобно обмениваться не-SQL-значениями между подкомпонентами или между расширением и приложением.Некоторые примеры:</target>
        </trans-unit>
        <trans-unit id="4e37312abd7d96cc7759f842b46f93a1a662f8a0" translate="yes" xml:space="preserve">
          <source>It is still the responsibility of the user to ensure that the contents of an external content FTS5 table are kept up to date with the content table. One way to do this is with triggers. For example:</source>
          <target state="translated">Пользователь по-прежнему несет ответственность за то,чтобы содержание таблицы внешнего контента FTS5 было актуальным.Один из способов сделать это-с помощью триггеров.Например:</target>
        </trans-unit>
        <trans-unit id="9c7272134156136dee6648bc42ced66fabf0b75c" translate="yes" xml:space="preserve">
          <source>It is the nature of the Guttman R-Tree algorithm that any write might radically restructure the tree, and in the process change the scan order of the nodes. For this reason, it is not generally possible to modify the R-Tree in the middle of a query of the R-Tree. Attempts to do so will fail with a &lt;a href=&quot;rescode#locked&quot;&gt;SQLITE_LOCKED&lt;/a&gt; &quot;database table is locked&quot; error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5653d5d90f75b604cccae96a448a1866fdfa38fe" translate="yes" xml:space="preserve">
          <source>It is the responsibility of the caller to eventually call sqlite3_free() on the *ppOut pointer to free the buffer allocation following a successful call to this function.</source>
          <target state="translated">В обязанности вызывающего абонента входит,в конечном счете,вызов sqlite3_free()по указателю *ppOut,чтобы освободить выделение буфера после успешного вызова этой функции.</target>
        </trans-unit>
        <trans-unit id="ea70438336584a95d4e17716f1df0d6b713aeb3b" translate="yes" xml:space="preserve">
          <source>It is the responsibility of the caller to eventually destroy the iterator by passing it to &lt;a href=&quot;#sqlite3changeset_finalize&quot;&gt;sqlite3changeset_finalize()&lt;/a&gt;. The buffer containing the changeset (pChangeset) must remain valid until after the iterator is destroyed.</source>
          <target state="translated">Вызывающий &lt;a href=&quot;#sqlite3changeset_finalize&quot;&gt;объект обязан&lt;/a&gt; в конечном итоге уничтожить итератор, передав его в sqlite3changeset_finalize () . Буфер, содержащий набор изменений (pChangeset), должен оставаться действительным до тех пор, пока итератор не будет уничтожен.</target>
        </trans-unit>
        <trans-unit id="f0493c91af19ce8153b8e56f3f8a534dd5019c91" translate="yes" xml:space="preserve">
          <source>It is the responsibility of the caller to eventually destroy the iterator by passing it to &lt;a href=&quot;sqlite3changeset_finalize&quot;&gt;sqlite3changeset_finalize()&lt;/a&gt;. The buffer containing the changeset (pChangeset) must remain valid until after the iterator is destroyed.</source>
          <target state="translated">Вызывающий &lt;a href=&quot;sqlite3changeset_finalize&quot;&gt;объект обязан&lt;/a&gt; в конечном итоге уничтожить итератор, передав его в sqlite3changeset_finalize () . Буфер, содержащий набор изменений (pChangeset), должен оставаться действительным до тех пор, пока итератор не будет уничтожен.</target>
        </trans-unit>
        <trans-unit id="6d23d845a723659b2b2994a8ad4c9862067cda40" translate="yes" xml:space="preserve">
          <source>It is true that applications sometimes import complete binary SQLite database files from untrusted sources, and such imports could present a possible attack vector. However, those code paths in SQLite are limited and are extremely well tested. And pre-validation routines are available to applications that want to read untrusted databases that can help detect possible attacks prior to use.</source>
          <target state="translated">Правда,иногда приложения импортируют полные бинарные файлы базы данных SQLite из недоверенных источников,и такой импорт может представлять собой возможный вектор атаки.Однако такие пути кода в SQLite ограничены и очень хорошо протестированы.А для приложений,которые хотят читать недоверенные базы данных,доступны процедуры предварительной проверки,которые могут помочь обнаружить возможные атаки до их использования.</target>
        </trans-unit>
        <trans-unit id="c6122ba39afe0e09e2d2af761ca27152501399d2" translate="yes" xml:space="preserve">
          <source>It is usually an error to attempt to create a new table in a database that already contains a table, index or view of the same name. However, if the &quot;IF NOT EXISTS&quot; clause is specified as part of the CREATE TABLE statement and a table or view of the same name already exists, the CREATE TABLE command simply has no effect (and no error message is returned). An error is still returned if the table cannot be created because of an existing index, even if the &quot;IF NOT EXISTS&quot; clause is specified.</source>
          <target state="translated">Как правило,это ошибка при попытке создать новую таблицу в базе данных,которая уже содержит таблицу,индекс или представление с тем же именем.Однако,если в операторе CREATE TABLE указано &quot;IF NOT EXISTS&quot; и таблица или представление с таким же именем уже существует,команда CREATE TABLE просто не имеет никакого эффекта (и сообщение об ошибке не возвращается).Ошибка все равно возвращается,если таблица не может быть создана из-за существующего индекса,даже если указано выражение &quot;IF NOT EXISTS&quot;.</target>
        </trans-unit>
        <trans-unit id="6955fa966a557f5231f3a39e108f89afbdbb1b83" translate="yes" xml:space="preserve">
          <source>It may not be used on a database that contains &lt;a href=&quot;expridx&quot;&gt;indexes on expressions&lt;/a&gt;.</source>
          <target state="translated">Его нельзя использовать в базе данных, содержащей &lt;a href=&quot;expridx&quot;&gt;индексы по выражениям&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="16a2200cb76f9664274f3ef9da8045211e14cc43" translate="yes" xml:space="preserve">
          <source>It might be that there are conflicts in the merge. Conflicts occur when the same line of code was changed in different ways between circles (1) and (4) versus circles (2) and (3). The merge command will announce any conflicts and will include both versions of the conflicting lines in the output. You will need to bring up the files that contain conflicts and manually resolve the conflicts.</source>
          <target state="translated">Возможно,в слиянии есть конфликты.Конфликты возникают,когда одна и та же строка кода по-разному меняется между кругами (1)и (4)по сравнению с кругами (2)и (3).Команда слияния объявит о любых конфликтах и включит в вывод обе версии конфликтующих строк.Вам нужно будет вывести на экран файлы,содержащие конфликты,и разрешить их вручную.</target>
        </trans-unit>
        <trans-unit id="129a00b2ad750693913d2844d8acb7e806afdd09" translate="yes" xml:space="preserve">
          <source>It must not be possible to make the LIKE or GLOB operator true by having a numeric value (instead of a string or blob) on the left-hand side. This means that either:</source>
          <target state="translated">Нельзя сделать оператор LIKE или GLOB истинным,имея слева числовое значение (вместо строки или капли).Это означает,что и это тоже:</target>
        </trans-unit>
        <trans-unit id="e56780a95b18eed6f05e0be25053224b3c52ac99" translate="yes" xml:space="preserve">
          <source>It was necessary to move to version 3.0 to implement these features because each requires incompatible changes to the database file format. Other incompatible changes, such as a cleanup of the API, were introduced at the same time under the theory that it is best to get your incompatible changes out of the way all at once.</source>
          <target state="translated">Для реализации этих возможностей необходимо было перейти на версию 3.0,так как каждая из них требует несовместимых изменений формата файла базы данных.Другие несовместимые изменения,такие как очистка API,были введены одновременно с теорией о том,что лучше всего убрать несовместимые изменения с пути сразу.</target>
        </trans-unit>
        <trans-unit id="8d41777ca525f229dab6b56dd5c34598aff8efa5" translate="yes" xml:space="preserve">
          <source>It works with unicode (UTF8) text.</source>
          <target state="translated">Работает с текстом в кодировке Unicode (UTF8).</target>
        </trans-unit>
        <trans-unit id="829d920a492c6126eef1531c8e8c0e1ab7033bd1" translate="yes" xml:space="preserve">
          <source>Its master journal exists or the master journal name is an empty string, and</source>
          <target state="translated">Его главный журнал существует или имя главного журнала-пустая строка,и</target>
        </trans-unit>
        <trans-unit id="a9d92a1b4a228c7e648d8125ef5d3c71b3cd4ff7" translate="yes" xml:space="preserve">
          <source>Its size is greater than 512 bytes, and</source>
          <target state="translated">Его размер больше 512 байт,и</target>
        </trans-unit>
        <trans-unit id="0239a4728421bae8f8eeba1f3844a6c5e5e3d81b" translate="yes" xml:space="preserve">
          <source>Its super-journal exists or the super-journal name is an empty string, and</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73bd910d330560ea1012376a486871434fb0c82d" translate="yes" xml:space="preserve">
          <source>J. M. Robson. &quot;Bounds for Some Functions Concerning Dynamic Storage Allocation&quot;.</source>
          <target state="translated">J.М.Робсон.&quot;Ограничения для некоторых функций относительно динамического распределения хранилищ&quot;.</target>
        </trans-unit>
        <trans-unit id="9a3f6528f2606d1ed81f1e9f85b624a26b98cbbe" translate="yes" xml:space="preserve">
          <source>JOIN</source>
          <target state="translated">JOIN</target>
        </trans-unit>
        <trans-unit id="031a4e76f0b39d0df073d934da5fc48da8d737e5" translate="yes" xml:space="preserve">
          <source>JSON</source>
          <target state="translated">JSON</target>
        </trans-unit>
        <trans-unit id="935b885e280c10afb46d2bf45f85bbea09bc94ce" translate="yes" xml:space="preserve">
          <source>JSON support</source>
          <target state="translated">JSON поддержка</target>
        </trans-unit>
        <trans-unit id="69a65023a22e8f6d2ee1c6c6ee36c64ccb6d5c6d" translate="yes" xml:space="preserve">
          <source>Join order</source>
          <target state="translated">Присоединиться к заказу</target>
        </trans-unit>
        <trans-unit id="63acacbd536ebc7829ae48a83492249201168016" translate="yes" xml:space="preserve">
          <source>Join reordering is automatic and usually works well enough that programmers do not have to think about it, especially if &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; has been used to gather statistics about the available indices. But occasionally some hints from the programmer are needed. Consider, for example, the following schema:</source>
          <target state="translated">Изменение порядка объединения происходит автоматически и обычно работает достаточно хорошо, чтобы программистам не приходилось думать об этом, особенно если &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; использовался для сбора статистики о доступных индексах. Но иногда нужны подсказки от программиста. Рассмотрим, например, следующую схему:</target>
        </trans-unit>
        <trans-unit id="36cb6826dbbbacc9f0915d9e44ccb82925b04c72" translate="yes" xml:space="preserve">
          <source>Joins</source>
          <target state="translated">Joins</target>
        </trans-unit>
        <trans-unit id="742ad08bca9c2e1be08d58aae42e6201c809dcf9" translate="yes" xml:space="preserve">
          <source>Journal File Format</source>
          <target state="translated">Формат файла журнала</target>
        </trans-unit>
        <trans-unit id="debc03f25ef5600d2ed4edf18b01b3412bb71c87" translate="yes" xml:space="preserve">
          <source>Journal Header Format</source>
          <target state="translated">Формат заголовка журнала</target>
        </trans-unit>
        <trans-unit id="ccdedfc7a4a23f259c6823eed7a5e93d7a6e430f" translate="yes" xml:space="preserve">
          <source>Journal Record Format</source>
          <target state="translated">Формат журнала Формат записи</target>
        </trans-unit>
        <trans-unit id="683ff0cc3706704c295b1d1835a7e2e4c3a2a6b7" translate="yes" xml:space="preserve">
          <source>Journal of the Association for Computing Machinery</source>
          <target state="translated">Журнал Ассоциации компьютерной техники</target>
        </trans-unit>
        <trans-unit id="769726f4101068333430cd9eee0a56b7dfd75235" translate="yes" xml:space="preserve">
          <source>JournalMode</source>
          <target state="translated">JournalMode</target>
        </trans-unit>
        <trans-unit id="c0e70f1bd285ac28ec38cf9261dd9cf6df3840dd" translate="yes" xml:space="preserve">
          <source>Journalling a Database Page</source>
          <target state="translated">Регистрация страницы базы данных</target>
        </trans-unit>
        <trans-unit id="b576bd921c8bd5cb6e5720fc3c6797d3e02e8d08" translate="yes" xml:space="preserve">
          <source>Journalling a page</source>
          <target state="translated">Регистрация страницы</target>
        </trans-unit>
        <trans-unit id="84e304128c1076094ba7ee02aeb09745e71eaf53" translate="yes" xml:space="preserve">
          <source>Julian day number</source>
          <target state="translated">номер дня Юлиана</target>
        </trans-unit>
        <trans-unit id="1eba140fdd9c6860a1730c408e3064aa417ca2a3" translate="yes" xml:space="preserve">
          <source>Jump</source>
          <target state="translated">Jump</target>
        </trans-unit>
        <trans-unit id="5d84018241481efa31572e7a64ddf20102d5a735" translate="yes" xml:space="preserve">
          <source>Jump to P2 if the value in register P1 is False. The value is considered false if it has a numeric value of zero. If the value in P1 is NULL then take the jump if and only if P3 is non-zero.</source>
          <target state="translated">Перейдите к P2,если значение в регистре P1 является False.Значение считается ложным,если оно имеет числовое значение ноль.Если значение в P1 равно NULL,то прыжок выполняется,если и только если P3 ненулевое.</target>
        </trans-unit>
        <trans-unit id="c02affea77793c1c3281caf3fff7c025052fcd28" translate="yes" xml:space="preserve">
          <source>Jump to P2 if the value in register P1 is NULL.</source>
          <target state="translated">Переходите к P2,если значение в регистре P1 равно NULL.</target>
        </trans-unit>
        <trans-unit id="9d04284895be3aad627f0d99db148ecf0772d61d" translate="yes" xml:space="preserve">
          <source>Jump to P2 if the value in register P1 is not NULL.</source>
          <target state="translated">Переходите к P2,если значение в регистре P1 не NULL.</target>
        </trans-unit>
        <trans-unit id="38d677f93cf11ed33026afa36fe1f252297e13d5" translate="yes" xml:space="preserve">
          <source>Jump to P2 if the value in register P1 is true. The value is considered true if it is numeric and non-zero. If the value in P1 is NULL then take the jump if and only if P3 is non-zero.</source>
          <target state="translated">Перейдите к P2,если значение в регистре P1 истинно.Значение считается истинным,если оно числовое и ненулевое.Если значение в P1 равно NULL,то переходите к P2,если и только если P3 ненулевое.</target>
        </trans-unit>
        <trans-unit id="04a8d1cd1316034cf886277bf2c8dd963c76b71c" translate="yes" xml:space="preserve">
          <source>Jump to the instruction at address P1, P2, or P3 depending on whether in the most recent &lt;a href=&quot;opcode#Compare&quot;&gt;Compare&lt;/a&gt; instruction the P1 vector was less than equal to, or greater than the P2 vector, respectively.</source>
          <target state="translated">Переход к инструкции по адресу P1, P2 или P3 в зависимости от того, был ли в последней инструкции &lt;a href=&quot;opcode#Compare&quot;&gt;сравнения&lt;/a&gt; вектор P1 меньше или больше вектора P2 соответственно.</target>
        </trans-unit>
        <trans-unit id="029dc808e2fcf8db0d9a3400f04a64bf760921ba" translate="yes" xml:space="preserve">
          <source>Jump to the next instruction after the address in register P1. After the jump, register P1 becomes undefined.</source>
          <target state="translated">Перейти к следующей инструкции после адреса в регистре P1.После прыжка регистр P1 становится неопределенным.</target>
        </trans-unit>
        <trans-unit id="be91c2cd21e07ee8ceb31ed436dfe5c08c9a83b6" translate="yes" xml:space="preserve">
          <source>Just as there is the &quot;zip&quot; program to manage ZIP Archives, and the &quot;tar&quot; program to manage Tarballs, the &lt;a href=&quot;https://sqlite.org/sqlar&quot;&gt;&quot;sqlar&quot; program&lt;/a&gt; exists to manage SQL Archives. The &quot;sqlar&quot; program is able to create a new SQLite Archive, list the content of an existing archive, add or remove files from the archive, and/or extract files from the archive. A separate &quot;sqlarfs&quot; program is able to mount the SQLite Archive as a &lt;a href=&quot;https://github.com/libfuse/libfuse&quot;&gt;Fuse Filesystem&lt;/a&gt;.</source>
          <target state="translated">Так же, как существует программа &amp;laquo;zip&amp;raquo; для управления архивами ZIP и программа &amp;laquo;tar&amp;raquo; для управления архивами tar, существует &lt;a href=&quot;https://sqlite.org/sqlar&quot;&gt;программа &amp;laquo;sqlar&amp;raquo;&lt;/a&gt; для управления архивами SQL. Программа sqlar может создать новый архив SQLite, составить список содержимого существующего архива, добавить или удалить файлы из архива и / или извлечь файлы из архива. Отдельная программа sqlarfs может смонтировать архив SQLite как &lt;a href=&quot;https://github.com/libfuse/libfuse&quot;&gt;файловую&lt;/a&gt; систему Fuse .</target>
        </trans-unit>
        <trans-unit id="dd65c1b4b3e66e765523873bd29cf5d6d6838189" translate="yes" xml:space="preserve">
          <source>KEY</source>
          <target state="translated">KEY</target>
        </trans-unit>
        <trans-unit id="d27c8f02c4abf5f11c1eced4acd8b35520a9fe80" translate="yes" xml:space="preserve">
          <source>Keep constant guard over the actions of your life.</source>
          <target state="translated">Держите постоянную бдительность за действиями в своей жизни.</target>
        </trans-unit>
        <trans-unit id="194e669a908d39900cf589c5a981d721d7c9618b" translate="yes" xml:space="preserve">
          <source>Keep death daily before your eyes.</source>
          <target state="translated">Ежедневно держите смерть на глазах.</target>
        </trans-unit>
        <trans-unit id="c25db8dd7484e7f7bee803cd3895b18495da35bc" translate="yes" xml:space="preserve">
          <source>Keep the full precision of integers (if possible) when casting to NUMERIC. Ticket #2364</source>
          <target state="translated">Сохраняйте полную точность целых чисел (если возможно)при приведении к ЧИСЛОТНОСТИ.Билет #2364</target>
        </trans-unit>
        <trans-unit id="4989895ac52269498fe4414b7697f7a4c22ad5aa" translate="yes" xml:space="preserve">
          <source>Key points:</source>
          <target state="translated">Ключевые моменты:</target>
        </trans-unit>
        <trans-unit id="08fa4eb3aedd30338134d345421fea84986b3d4a" translate="yes" xml:space="preserve">
          <source>Key take-aways from this essay:</source>
          <target state="translated">Ключевые выводы из этого эссе:</target>
        </trans-unit>
        <trans-unit id="8b3a8bbf2ec2d401e862eec6bf418d40320b88cb" translate="yes" xml:space="preserve">
          <source>Key/value store for the raw database file content. The key is the page number and the value is binary page content.</source>
          <target state="translated">Хранилище ключей/значений для содержимого файлов исходной базы данных.Ключом является номер страницы,а значением-содержимое двоичной страницы.</target>
        </trans-unit>
        <trans-unit id="7b687d48e96f480574af88076704d469738ac8fd" translate="yes" xml:space="preserve">
          <source>Keyword arguments can optionally appear in quotes. (Example: &lt;code&gt;'yes' [FALSE]&lt;/code&gt;.) Some pragmas takes a string literal as their argument. When pragma takes a keyword argument, it will usually also take a numeric equivalent as well. For example, &quot;0&quot; and &quot;no&quot; mean the same thing, as does &quot;1&quot; and &quot;yes&quot;. When querying the value of a setting, many pragmas return the number rather than the keyword.</source>
          <target state="translated">Аргументы ключевых слов могут при желании заключаться в кавычки. (Пример: &lt;code&gt;'yes' [FALSE]&lt;/code&gt; .) Некоторые прагмы принимают строковый литерал в качестве аргумента. Когда прагма принимает аргумент ключевого слова, он обычно также принимает числовой эквивалент. Например, &amp;laquo;0&amp;raquo; и &amp;laquo;нет&amp;raquo; означают то же самое, что и &amp;laquo;1&amp;raquo; и &amp;laquo;да&amp;raquo;. При запросе значения параметра многие прагмы возвращают число, а не ключевое слово.</target>
        </trans-unit>
        <trans-unit id="71d7d3fe2fa70220d2397ae5ef29dbf8ffba7a8b" translate="yes" xml:space="preserve">
          <source>Know for certain that God sees you everywhere.</source>
          <target state="translated">Знай наверняка,что Бог видит тебя повсюду.</target>
        </trans-unit>
        <trans-unit id="7e70d2e585c390da7abcf2a3249245e0e36e0092" translate="yes" xml:space="preserve">
          <source>LAST</source>
          <target state="translated">LAST</target>
        </trans-unit>
        <trans-unit id="969e2cc476ff76be41815b17d8fb9c685f97e243" translate="yes" xml:space="preserve">
          <source>LEFT</source>
          <target state="translated">LEFT</target>
        </trans-unit>
        <trans-unit id="fa443d7d6200af63823dccc305e61eed839b45c2" translate="yes" xml:space="preserve">
          <source>LEFT JOIN</source>
          <target state="translated">ЛЕВЫЙ СОВЕТ</target>
        </trans-unit>
        <trans-unit id="06214bf7efebdbadf0fc2e8285b451472a810158" translate="yes" xml:space="preserve">
          <source>LEFT JOIN elimination often comes up when LEFT JOINs are used inside of views, and then the view is used in such as way that none of the columns of the right-hand table of the LEFT JOIN are referenced.</source>
          <target state="translated">Устранение ЛЕВОГО СОЕДИНЕНИЯ часто возникает,когда ЛЕВОЕ СОЕДИНЕНИЕ используется внутри вида,а затем вид используется таким образом,что ни один из столбцов правой таблицы ЛЕВОГО СОЕДИНЕНИЯ не имеет ссылок.</target>
        </trans-unit>
        <trans-unit id="228baedd626cec5fb29f832c085ce530c565f626" translate="yes" xml:space="preserve">
          <source>LEFT JOIN strength reduction optimization</source>
          <target state="translated">ЛЕВАЯ ОПТИМИЗАЦИЯ СОКРАЩЕНИЯ ПРОЧНОСТИ</target>
        </trans-unit>
        <trans-unit id="e43376033cc5d4106eb2e868e3b049e3915b255f" translate="yes" xml:space="preserve">
          <source>LEFT OUTER JOIN is implemented, but not RIGHT OUTER JOIN or FULL OUTER JOIN.</source>
          <target state="translated">ЛЕВОЕ ВНЕШНЕЕЕ соединение реализовано,но не ПРАВОЕ ВНЕШНЕЕ и ПОЛНОЕ ВНЕШНЕЕШНЕЕ.</target>
        </trans-unit>
        <trans-unit id="5ddf6f04739d8bc3a11b487863b27a7bcaa6fc24" translate="yes" xml:space="preserve">
          <source>LIKE</source>
          <target state="translated">LIKE</target>
        </trans-unit>
        <trans-unit id="92323e665381f4f6e8310e0e8d0ab85b11facf9e" translate="yes" xml:space="preserve">
          <source>LIKE optimization</source>
          <target state="translated">оптимизация LIKE</target>
        </trans-unit>
        <trans-unit id="c385d79f275c108bd6a32af099948cfc74a92c05" translate="yes" xml:space="preserve">
          <source>LIKE optimization now works for columns with COLLATE NOCASE</source>
          <target state="translated">Оптимизация LIKE теперь работает для колонн с COLLATE NOCASE</target>
        </trans-unit>
        <trans-unit id="9c590af5665cfc2916823206547377e482547e1d" translate="yes" xml:space="preserve">
          <source>LIMIT</source>
          <target state="translated">LIMIT</target>
        </trans-unit>
        <trans-unit id="40c4547fe7d52f08474372a32d5cd65ef3e61db8" translate="yes" xml:space="preserve">
          <source>LIMIT 0 now shows no rows. Use LIMIT -1 to see all rows.</source>
          <target state="translated">LIMIT 0 теперь не показывает строк.Используйте LIMIT -1,чтобы увидеть все строки.</target>
        </trans-unit>
        <trans-unit id="e120f1515582fd60e3aa87caeded6a95706ff6a5" translate="yes" xml:space="preserve">
          <source>LIMIT 0 now works on subqueries</source>
          <target state="translated">LIMIT 0 теперь работает по подзапросам</target>
        </trans-unit>
        <trans-unit id="2726a4b3c5be6bc17db3c5aa67da0f6e30ea159f" translate="yes" xml:space="preserve">
          <source>LIMIT_ATTACH</source>
          <target state="translated">LIMIT_ATTACH</target>
        </trans-unit>
        <trans-unit id="e8bf21b0d0f3b850c955bb94b5141253b1ae7e2a" translate="yes" xml:space="preserve">
          <source>LIMIT_COLUMN</source>
          <target state="translated">LIMIT_COLUMN</target>
        </trans-unit>
        <trans-unit id="7b09e7eae5f068cca9e40a4e561d97d66518a255" translate="yes" xml:space="preserve">
          <source>LIMIT_COMPOUND_SELECT</source>
          <target state="translated">LIMIT_COMPOUND_SELECT</target>
        </trans-unit>
        <trans-unit id="b1c8f4255d541a1d18f761d25857086f40b1bf20" translate="yes" xml:space="preserve">
          <source>LIMIT_EXPR_DEPTH</source>
          <target state="translated">LIMIT_EXPR_DEPTH</target>
        </trans-unit>
        <trans-unit id="2a0de541f4fa62311ff3575519dfacbb5ae6b11e" translate="yes" xml:space="preserve">
          <source>LIMIT_FUNCTION_ARG</source>
          <target state="translated">LIMIT_FUNCTION_ARG</target>
        </trans-unit>
        <trans-unit id="1a3a784fe44fc702cae042a37cb3ba3e0f6fa7ac" translate="yes" xml:space="preserve">
          <source>LIMIT_LENGTH</source>
          <target state="translated">LIMIT_LENGTH</target>
        </trans-unit>
        <trans-unit id="72fc2492f41deaa54c2dac4538490fafaa14d0d6" translate="yes" xml:space="preserve">
          <source>LIMIT_LIKE_PATTERN_LENGTH</source>
          <target state="translated">LIMIT_LIKE_PATTERN_LENGTH</target>
        </trans-unit>
        <trans-unit id="5e8999dc05d8b9aa066f6d09239a0ae740e36f64" translate="yes" xml:space="preserve">
          <source>LIMIT_SQL_LENGTH</source>
          <target state="translated">LIMIT_SQL_LENGTH</target>
        </trans-unit>
        <trans-unit id="db5d695bfcc2c3ebffa6c7ffcd096c20b8eed97c" translate="yes" xml:space="preserve">
          <source>LIMIT_TRIGGER_DEPTH</source>
          <target state="translated">LIMIT_TRIGGER_DEPTH</target>
        </trans-unit>
        <trans-unit id="16d75adbe3aa654b347523eb12544c39563f5b43" translate="yes" xml:space="preserve">
          <source>LIMIT_VARIABLE_NUMBER</source>
          <target state="translated">LIMIT_VARIABLE_NUMBER</target>
        </trans-unit>
        <trans-unit id="a604921b15950316535a24537e634352270c370e" translate="yes" xml:space="preserve">
          <source>LIMIT_VDBE_OP</source>
          <target state="translated">LIMIT_VDBE_OP</target>
        </trans-unit>
        <trans-unit id="89b86ab0e66f527166d98df92ddbcf5416ed58f6" translate="yes" xml:space="preserve">
          <source>Language</source>
          <target state="translated">Language</target>
        </trans-unit>
        <trans-unit id="7428d00a0b1c6a4c3041c21ce5ceb9dbaa4b015a" translate="yes" xml:space="preserve">
          <source>Large WAL files</source>
          <target state="translated">Большие файлы WAL</target>
        </trans-unit>
        <trans-unit id="d1c69a859a9638b242f2dabf8acf1c0b1450ce6b" translate="yes" xml:space="preserve">
          <source>Last</source>
          <target state="translated">Last</target>
        </trans-unit>
        <trans-unit id="07235ffa8a70d2e51e9570c942d05e5b5851a313" translate="yes" xml:space="preserve">
          <source>Last Insert Rowid</source>
          <target state="translated">Последняя вставка Роид</target>
        </trans-unit>
        <trans-unit id="7f81d5c9ec25b5fa1a2640b99a8421ac6c71b017" translate="yes" xml:space="preserve">
          <source>Later, SQLite version 3.6.16 is released, as shown by circle (4) in the diagram. At the point, the private branch maintainer does a merge which takes all of the changes going from (1) to (4) and applies those changes to (3). The result is version (5), which is SQLite 3.6.16 plus edits.</source>
          <target state="translated">Позже выходит версия SQLite 3.6.16,как показано кружком (4)на диаграмме.В этот момент сопровождающий частной ветки производит слияние,которое принимает все изменения,идущие от (1)до (4),и применяет эти изменения к (3).В результате получается версия (5),которая представляет собой SQLite 3.6.16 плюс изменения.</target>
        </trans-unit>
        <trans-unit id="e07edacb2555a09c495279c3384f36a675435d8d" translate="yes" xml:space="preserve">
          <source>Le</source>
          <target state="translated">Le</target>
        </trans-unit>
        <trans-unit id="fa3757f35a67a972328ec50d59fdef6fec4d197a" translate="yes" xml:space="preserve">
          <source>Leading spaces are removed.</source>
          <target state="translated">Ведущие места удалены.</target>
        </trans-unit>
        <trans-unit id="1dae495d04abf17bb3895a89b30ae8efcca9f3f1" translate="yes" xml:space="preserve">
          <source>Leaf payload fraction. Must be 32.</source>
          <target state="translated">Листовая доля полезной нагрузки.Должно быть 32.</target>
        </trans-unit>
        <trans-unit id="e2626d2b1592bacc07397cf31582efd1c5b2420a" translate="yes" xml:space="preserve">
          <source>Left operand</source>
          <target state="translated">Левый операнд</target>
        </trans-unit>
        <trans-unit id="203223a5600f328f50c6338dfe2e4c11e8803475" translate="yes" xml:space="preserve">
          <source>Left operand found</source>
          <target state="translated">Левый операнд найден</target>
        </trans-unit>
        <trans-unit id="865d1c5dcc029d18d1621430419ee2f04f5f424f" translate="yes" xml:space="preserve">
          <source>Left-justify the value in the output. The default is to right-justify. If the width is zero or is otherwise less than the length of the value being substituted, then there is no padding and the &quot;-&quot; flag is a no-op.</source>
          <target state="translated">Оправдайте значение на выходе в левую сторону.По умолчанию используется правое оправдание.Если ширина равна нулю или иначе меньше длины подставляемого значения,то подкладка отсутствует,а флаг &quot;-&quot;-нет.</target>
        </trans-unit>
        <trans-unit id="1877e2f919fe86f5371e6a3e7d9d6b6080bf4d57" translate="yes" xml:space="preserve">
          <source>Legacy (older than 3.22.0) versions of the sessions module cannot capture changes made to the sqlite_stat1 table. Legacy versions of the sqlite3changeset_apply() function silently ignore any modifications to the sqlite_stat1 table that are part of a changeset or patchset.</source>
          <target state="translated">Устаревшие (старше 3.22.0)версии модуля сеансов не могут фиксировать изменения,внесённые в таблицу sqlite_stat1.Старые версии функции sqlite3changeset_apply()беззвучно игнорируют любые изменения таблицы sqlite_stat1,которые являются частью changeset или patchset.</target>
        </trans-unit>
        <trans-unit id="48078fcdb6dc318fa741d70a2ecdb6ae1437e609" translate="yes" xml:space="preserve">
          <source>Lemon does not have its own source repository. Rather, Lemon consists of a few files in the SQLite source tree:</source>
          <target state="translated">У Лемон нет собственного репозитория исходников.Скорее,Lemon состоит из нескольких файлов в дереве исходных текстов SQLite:</target>
        </trans-unit>
        <trans-unit id="bf0578b2a25d2e804bfd4deee5634450a8293393" translate="yes" xml:space="preserve">
          <source>Lemon generates an LALR(1) parser. It's operation is similar to the more familiar tools &lt;a href=&quot;https://en.wikipedia.org/wiki/Yacc&quot;&gt;Yacc&lt;/a&gt; and &lt;a href=&quot;https://en.wikipedia.org/wiki/GNU_bison&quot;&gt;Bison&lt;/a&gt;, but Lemon adds important improvements, including:</source>
          <target state="translated">Lemon генерирует парсер LALR (1). Его работа аналогична более знакомым инструментам &lt;a href=&quot;https://en.wikipedia.org/wiki/Yacc&quot;&gt;Yacc&lt;/a&gt; и &lt;a href=&quot;https://en.wikipedia.org/wiki/GNU_bison&quot;&gt;Bison&lt;/a&gt; , но Lemon добавляет важные улучшения, в том числе:</target>
        </trans-unit>
        <trans-unit id="ae32ad1b62e795e4b0f91393920f4a7aff7c555a" translate="yes" xml:space="preserve">
          <source>Lemon has the concept of a &quot;fallback&quot; tokens. The SQL language contains a large number of keywords and these keywords have the potential to collide with identifier names. Lemon has the ability to designate some keywords has being able to &quot;fallback&quot; to an identifier. If the keyword appears in the input token stream in a context that would otherwise be a syntax error, the token is automatically transformed into its fallback before the syntax error is raised. This feature allows the parser to be very forgiving of reserved words used as identifiers, which is a problem that comes up frequently in the SQL language.</source>
          <target state="translated">У Лемон есть понятие жетонов &quot;отступление&quot;.Язык SQL содержит большое количество ключевых слов,и эти ключевые слова потенциально могут столкнуться с именами идентификаторов.Lemon имеет возможность обозначить некоторые ключевые слова,имея возможность &quot;отступать&quot; к идентификатору.Если ключевое слово появляется в потоке входных токенов в контексте,который в противном случае был бы синтаксической ошибкой,то до появления синтаксической ошибки токен автоматически преобразуется в откат.Эта функция позволяет синтаксическому анализатору быть очень снисходительным к зарезервированным словам,используемым в качестве идентификаторов,что является проблемой,часто возникающей в языке SQL.</target>
        </trans-unit>
        <trans-unit id="2f9dc02cb8bf5b03f6591dbb44f0a7a4b90f82f4" translate="yes" xml:space="preserve">
          <source>Lemon has the concept of a non-terminal destructor that can be used to reclaim memory or other resources following a syntax error or other aborted parse.</source>
          <target state="translated">Lemon имеет понятие нетерминального деструктора,который может быть использован для восстановления памяти или других ресурсов после синтаксической ошибки или другого прерванного разбора.</target>
        </trans-unit>
        <trans-unit id="cee927c3e2d6e42d43d5738f627f3200d5121eac" translate="yes" xml:space="preserve">
          <source>Lemon is also used to generate parse for the query pattern expressions in the &lt;a href=&quot;fts5&quot;&gt;FTS5&lt;/a&gt; extension. In this case, the input grammar file is &lt;a href=&quot;https://sqlite.org/src/file/ext/fts5/fts5parse.y&quot;&gt;fts5parse.y&lt;/a&gt;.</source>
          <target state="translated">Lemon также используется для синтаксического анализа выражений шаблонов запросов в расширении &lt;a href=&quot;fts5&quot;&gt;FTS5&lt;/a&gt; . В данном случае входным файлом грамматики является &lt;a href=&quot;https://sqlite.org/src/file/ext/fts5/fts5parse.y&quot;&gt;fts5parse.y&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="611d0deb28e86cca8303457d918752428288861c" translate="yes" xml:space="preserve">
          <source>Lemon is used in two places in SQLite.</source>
          <target state="translated">Лемон используется в SQLite в двух местах.</target>
        </trans-unit>
        <trans-unit id="0045a01f71c39a54c68dbc362b5b7275372032f5" translate="yes" xml:space="preserve">
          <source>Lemon supports conditional compilation of grammar file rules, so that a different parser can be generated depending on compile-time options.</source>
          <target state="translated">Lemon поддерживает условную компиляцию правил грамматических файлов,так что в зависимости от настроек времени компиляции может быть сгенерирован другой парсер.</target>
        </trans-unit>
        <trans-unit id="c5c89f378ce33982d309c573eb1ff14dd3f01e8a" translate="yes" xml:space="preserve">
          <source>Lemon was original written by D. Richard Hipp (also the creator of SQLite) while he was in graduate school at Duke University between 1987 and 1992. The original creation date of Lemon has been lost, but was probably sometime around 1990. Lemon generates an LALR(1) parser. There was companion LL(1) parser generator tool named &quot;Lime&quot;, but the source code for Lime has been lost.</source>
          <target state="translated">Лемон была написана Д.Ричардом Хиппом (также создателем SQLite),когда он учился в аспирантуре университета Дьюка с 1987 по 1992 год.Первоначальная дата создания Lemon была утеряна,но,вероятно,около 1990 года.Лемон создает парсер LALR(1).Существовал компаньон LL(1),генерирующий парсер под названием &quot;Lime&quot;,но исходный код для Lime был потерян.</target>
        </trans-unit>
        <trans-unit id="aa1fa89453ad95c8f115feb4d323d1e9b329630d" translate="yes" xml:space="preserve">
          <source>Length Specifier</source>
          <target state="translated">Указатель длины</target>
        </trans-unit>
        <trans-unit id="c999fb0a278ca9591b2cd0c03ceaa3328da57984" translate="yes" xml:space="preserve">
          <source>Less administration means that programmers spend more time working on the software (SQLite in this case) and less time fussing with the version control system.</source>
          <target state="translated">Меньше администрирования означает,что программисты тратят больше времени на работу с программным обеспечением (в данном случае SQLite)и меньше времени на работу с системой контроля версий.</target>
        </trans-unit>
        <trans-unit id="cbcb5b1fa488787750d49ab79f8ec375ce5124b9" translate="yes" xml:space="preserve">
          <source>Less memory used</source>
          <target state="translated">Меньше используемой памяти</target>
        </trans-unit>
        <trans-unit id="bc720094b72d521a9bad35bfe37f02c776160039" translate="yes" xml:space="preserve">
          <source>Let K be M+((P-M)%(U-4)).</source>
          <target state="translated">Пусть K будет M+((P-M)%(U-4)).</target>
        </trans-unit>
        <trans-unit id="ec5fd8c108643b71cf1bdd72351ff3e987fc1a5d" translate="yes" xml:space="preserve">
          <source>Let X be ((U-12)*64/255)-23. If the payload size P is less than or equal to X then the entire payload is stored on the b-tree page. Let M be ((U-12)*32/255)-23 and let K be M+((P-M)%(U-4)). If P is greater than X then the number of bytes stored on the index b-tree page is K if K is less than or equal to X or M otherwise. The number of bytes stored on the index page is never less than M.</source>
          <target state="translated">Пусть X будет ((U-12)*64/255)-23.Если размер полезного груза P меньше или равен X,то вся полезная нагрузка хранится на странице b-дерева.Пусть M будет ((U-12)*32/255)-23 и пусть K будет M+((P-M)%(U-4)).Если P больше X,то количество байт,которое хранится в индексной b-деревянной странице,будет K,если K меньше или равно X или M иным образом.Количество байтов,хранящихся на индексной странице,никогда не должно быть меньше M.</target>
        </trans-unit>
        <trans-unit id="3814595cf4d53307c33619bbcfd8505bff49fec5" translate="yes" xml:space="preserve">
          <source>Let X be U-35. If the payload size P is less than or equal to X then the entire payload is stored on the b-tree leaf page. Let M be ((U-12)*32/255)-23 and let K be M+((P-M)%(U-4)). If P is greater than X then the number of bytes stored on the table b-tree leaf page is K if K is less or equal to X or M otherwise. The number of bytes stored on the leaf page is never less than M.</source>
          <target state="translated">Пусть Икс будет U-35.Если размер полезного груза P меньше или равен X,то вся полезная нагрузка хранится на странице b-деревянного листа.Пусть M будет ((U-12)*32/255)-23 и пусть K будет M+((P-M)%(U-4)).Если P больше X,то количество байт,хранящихся на странице b-деревянного листа таблицы,будет K,если K меньше или равно X или M в противном случае.Количество байтов,хранящихся на странице листа,никогда не должно быть меньше M.</target>
        </trans-unit>
        <trans-unit id="04ab6da7aca9e95067f1ce62f19a937e96ff6418" translate="yes" xml:space="preserve">
          <source>Let X be the expression in the WHERE clause of a partial index, and let W be the WHERE clause of a query that uses the table that is indexed. Then, the query is permitted to use the partial index if W&amp;rArr;X, where the &amp;rArr; operator (usually pronounced &quot;implies&quot;) is the logic operator equivalent to &quot;X or not W&quot;. Hence, determining whether or not a partial index is usable in a particular query reduces to proving a theorem in first-order logic.</source>
          <target state="translated">Пусть X будет выражением в предложении WHERE частичного индекса, а W будет предложением WHERE запроса, использующего индексируемую таблицу. Затем в запросе разрешается использовать частичный индекс, если W&amp;rArr;X, где оператор &amp;rArr; (обычно произносится как &amp;laquo;подразумевает&amp;raquo;) является логическим оператором, эквивалентным &amp;laquo;X или не W&amp;raquo;. Следовательно, определение того, можно ли использовать частичный индекс в конкретном запросе, сводится к доказательству теоремы в логике первого порядка.</target>
        </trans-unit>
        <trans-unit id="8e79f3f73bca370e5a0d09f6e67e4908583572b1" translate="yes" xml:space="preserve">
          <source>Let X be the largest set of consecutive integers {h, h+1, h+2, ..., h+N} such that for every j in X, aPgno[j%8192]!=0. The X set will be empty if aPgno[h%8192]==0. The X set is easily computed by starting with the value h%8192, and adding h%8192 to X and incrementing h until encountering the first aPgno[h%8192] entry that is zero.</source>
          <target state="translated">Пусть Х будет самым большим набором последовательных целых чисел {h,h+1,h+2,...,h+N}так,чтобы для каждого j в Х,aPgno[j%8192]!=0.Множество Х будет пустым,если aPgno[h%8192]==0.Множество Х легко вычисляется,начиная со значения h%8192,добавляя к Х h%8192 и увеличивая h до тех пор,пока не столкнется с первой записью aPgno[h%8192],которая равна нулю.</target>
        </trans-unit>
        <trans-unit id="37bafb8ebd6ac523c9fab977240fbaca2d2a4205" translate="yes" xml:space="preserve">
          <source>Let the database page size (the value of the integer at offset 24 in the journal header) be N. Then the format of a page record is as follows:</source>
          <target state="translated">Пусть размер страницы БД (значение целого числа со смещением 24 в заголовке журнала)будет N.Тогда формат записи страницы будет следующим:</target>
        </trans-unit>
        <trans-unit id="5da01c6ea976760415bf0eb965f5e685ea3c15ec" translate="yes" xml:space="preserve">
          <source>Let the datatypes &quot;u8&quot;, &quot;u16&quot;, and &quot;u32&quot; mean unsigned integers of length 8, 16, and 32 bits, respectively. Then, the first 32768-byte unit of the shm file is organized as follows:</source>
          <target state="translated">Пусть типы данных &quot;u8&quot;,&quot;u16&quot; и &quot;u32&quot; означают беззнаковые целые числа длиной 8,16 и 32 бита соответственно.Затем первая 32768-байтовая единица файла shm организована следующим образом:</target>
        </trans-unit>
        <trans-unit id="bd114f90a251306f5f9680610cc3593a57d82e5b" translate="yes" xml:space="preserve">
          <source>Let the number of alice nodes be M and the number of bob nodes be N. Consider two scenarios. In the first scenario, M and N are both 2 but there are thousands of edges on each node. In this case, option 1 is preferred. With option 1, the inner loop checks for the existence of an edge between a pair of nodes and outputs the result if found. But because there are only 2 alice and bob nodes each, the inner loop only has to run 4 times and the query is very quick. Option 2 would take much longer here. The outer loop of option 2 only executes twice, but because there are a large number of edges leaving each alice node, the middle loop has to iterate many thousands of times. It will be much slower. So in the first scenario, we prefer to use option 1.</source>
          <target state="translated">Пусть число вершин Алисы будет M,а число вершин Боба-N.Рассмотрим два сценария.В первом сценарии M и N равны 2,но на каждой вершине есть тысячи рёбер.В этом случае предпочтителен вариант 1.При использовании варианта 1 внутренний цикл проверяет наличие фронта между парой узлов и выдает результат,если он найден.Но так как существует только 2 alice и bob узла в каждом,то внутренний цикл должен выполняться только 4 раза,и запрос выполняется очень быстро.Вариант 2 здесь занял бы гораздо больше времени.Внешний цикл варианта 2 выполняется только дважды,но из-за большого количества ребер,оставляющих каждый узел Алисы,средний цикл вынужден повторять итерации много тысяч раз.Это будет намного медленнее.Поэтому в первом сценарии мы предпочитаем использовать вариант 1.</target>
        </trans-unit>
        <trans-unit id="74b220b56c9d6c3f209f91061a8b3234a645c429" translate="yes" xml:space="preserve">
          <source>Let the page count value at offset 8 in the journal header be M. If M is greater than zero then after M page records the journal file may be zero padded out to the next multiple of the sector size and another journal header may be inserted. All journal headers within the same journal must contain the same database page size and sector size.</source>
          <target state="translated">Пусть значение счета страниц со смещением 8 в заголовке журнала будет M.Если M больше нуля,то после записи страницы M файл журнала может быть обнулен до следующего кратного размера сектора,и в него может быть вставлен другой заголовок журнала.Все заголовки журнала внутри одного и того же журнала должны содержать одинаковый размер страницы базы данных и размер сектора.</target>
        </trans-unit>
        <trans-unit id="f44e417ae6158672e12bddd6f44e6cd28bdb55bb" translate="yes" xml:space="preserve">
          <source>Let us assume that you are using the amalgamation source code. Add the baseline to your project as follows:</source>
          <target state="translated">Предположим,что вы используете исходный код слияния.Добавьте исходный код к вашему проекту следующим образом:</target>
        </trans-unit>
        <trans-unit id="ae7bd817eacac0a262f119102109a97036180841" translate="yes" xml:space="preserve">
          <source>Let us suppose that instead of using a ZIP archive to store its files, OpenDocument used a very simple SQLite database with the following single-table schema:</source>
          <target state="translated">Предположим,что вместо того,чтобы использовать ZIP-архив для хранения своих файлов,в OpenDocument использовалась очень простая SQLite БД со следующей однотаблеточной схемой:</target>
        </trans-unit>
        <trans-unit id="ecc5e1e5e0ad7c0dd2b547a397bdb11d90ca6d36" translate="yes" xml:space="preserve">
          <source>Let us use the following notation (similar but not identical to Robson's notation):</source>
          <target state="translated">Используем следующую нотацию (похожую,но не идентичную нотации Робсона):</target>
        </trans-unit>
        <trans-unit id="2d2261f9e0cbec9edf95c4d47c5f5eb0cbcca2f7" translate="yes" xml:space="preserve">
          <source>Let's be real. Few people seriously dispute that Git provides a suboptimal user experience. A lot of the underlying implementation shows through into the user interface. The interface is so bad that there is even a parody site that generates &lt;a href=&quot;https://git-man-page-generator.lokaltog.net/&quot;&gt;fake git man pages&lt;/a&gt;.</source>
          <target state="translated">Давайте будем реальными. Мало кто серьезно оспаривает то, что Git обеспечивает неоптимальный пользовательский интерфейс. Большая часть базовой реализации просматривается в пользовательском интерфейсе. Интерфейс настолько плох, что существует даже пародийный сайт, генерирующий &lt;a href=&quot;https://git-man-page-generator.lokaltog.net/&quot;&gt;поддельные страницы руководства git&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0f0987eb98b35f60885158c865b4e995d0d04bc9" translate="yes" xml:space="preserve">
          <source>Let's look more closely at what is happening here. The first SELECT is implemented by the loop at instructions 5 through 10. Instruction 5 initializes the loop by rewinding its cursor. Instruction 6 extracts the value of the &quot;two&quot; column from &quot;examp&quot; and instruction 7 converts this into a row. Instruction 8 pushes an empty string onto the stack. Finally, instruction 9 writes the row into the temporary table. But remember, the PutStrKey opcode uses the top of the stack as the record data and the next on stack as the key. For an INSERT statement, the row generated by the MakeRecord opcode is the record data and the record key is an integer created by the NewRecno opcode. But here the roles are reversed and the row created by MakeRecord is the record key and the record data is just an empty string.</source>
          <target state="translated">Давайте посмотрим более внимательно на то,что здесь происходит.Первый SELECT реализуется циклом на инструкциях 5-10.Инструкция 5 инициализирует цикл перемоткой его курсора.Инструкция 6 извлекает значение столбца &quot;два&quot; из &quot;экзамена&quot;,а инструкция 7 преобразует его в строку.Инструкция 8 толкает пустую строку на стек.Наконец,Инструкция 9 записывает строку во временную таблицу.Но помните,что опкод PutStrKey использует вершину стека в качестве данных записи,а следующую на стеке в качестве ключа.Для оператора INSERT,строка,генерируемая опкодом MakeRecord,является данными записи,а ключом записи является целое число,созданное опкодом NewRecno.Но здесь роли перевернуты,а строка,созданная оператором MakeRecord,является ключом записи,а данные записи-просто пустой строкой.</target>
        </trans-unit>
        <trans-unit id="8ce47b13d09374c0748516f88f9567e0ba880c6e" translate="yes" xml:space="preserve">
          <source>Libraries written in C do not have a huge run-time dependency. In its minimum configuration, SQLite requires only the following routines from the standard C library:</source>
          <target state="translated">Библиотеки,написанные на C,не имеют огромной зависимости от времени исполнения.В своей минимальной конфигурации SQLite требует только следующих процедур из стандартной библиотеки на Си:</target>
        </trans-unit>
        <trans-unit id="16b9101f24846717dcb86cc74d99a08aad5ead61" translate="yes" xml:space="preserve">
          <source>Libraries written in C++ or Java can generally only be used by applications written in the same language. It is difficult to get an application written in Haskell or Java to invoke a library written in C++. On the other hand, libraries written in C are callable from any programming language.</source>
          <target state="translated">Библиотеки,написанные на C++или Java,как правило,могут использоваться только приложениями,написанными на том же языке.Сложно заставить приложение,написанное на Haskell или Java,ссылаться на библиотеку,написанную на С++.С другой стороны,библиотеки,написанные на Си,могут вызываться из любого языка программирования.</target>
        </trans-unit>
        <trans-unit id="8f218c8346bfddbca30ecf6b104e83b9f15b5e98" translate="yes" xml:space="preserve">
          <source>Library size optimizations.</source>
          <target state="translated">Оптимизация размера библиотеки.</target>
        </trans-unit>
        <trans-unit id="3769a60d2f565f40c7f7836558211471f7d8a029" translate="yes" xml:space="preserve">
          <source>Like --file, use file FILE as the archive, but open the file using the &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/appendvfs.c&quot;&gt;apndvfs VFS&lt;/a&gt; so that the archive will be appended to the end of FILE if FILE already exists.</source>
          <target state="translated">Как и --file, используйте файл FILE в качестве архива, но откройте файл с помощью &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/appendvfs.c&quot;&gt;apndvfs VFS,&lt;/a&gt; чтобы архив был добавлен в конец FILE, если FILE уже существует.</target>
        </trans-unit>
        <trans-unit id="0b095c3da7d05183eec1d9c68eafa22989981539" translate="yes" xml:space="preserve">
          <source>Like contentless tables, external content tables do not support REPLACE conflict handling. Any operations that specify REPLACE conflict handling are handled using ABORT.</source>
          <target state="translated">Подобно таблицам без содержания,внешние таблицы содержания не поддерживают обработку конфликтов REPLACE.Любые операции,указывающие на обработку конфликтов REPLACE,обрабатываются с помощью ABORT.</target>
        </trans-unit>
        <trans-unit id="231d089dd7b27b9cd1c3006b16a6dc21b83bfb7e" translate="yes" xml:space="preserve">
          <source>Like other virtual table types, new FTS tables are created using a &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; statement. The module name, which follows the USING keyword, is either &quot;fts3&quot; or &quot;fts4&quot;. The virtual table module arguments may be left empty, in which case an FTS table with a single user-defined column named &quot;content&quot; is created. Alternatively, the module arguments may be passed a list of comma separated column names.</source>
          <target state="translated">Как и другие типы виртуальных таблиц, новые таблицы FTS создаются с помощью оператора &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; . Имя модуля, следующее за ключевым словом USING, - &amp;laquo;fts3&amp;raquo; или &amp;laquo;fts4&amp;raquo;. Аргументы модуля виртуальной таблицы могут быть оставлены пустыми, и в этом случае создается таблица FTS с одним определяемым пользователем столбцом с именем &amp;laquo;контент&amp;raquo;. В качестве альтернативы аргументам модуля может быть передан список имен столбцов, разделенных запятыми.</target>
        </trans-unit>
        <trans-unit id="fd7d7c85c83f29484f2e117602dc4bec07bd365d" translate="yes" xml:space="preserve">
          <source>Like sqlite3rbu_step(), if the vacuum operation has finished, sqlite3rbu_close() returns SQLITE_DONE. If the vacuum has not finished but no error has occurred, SQLITE_OK is returned. Or, if an error has occurred, an SQLite error code is returned. If an error occurred as part of a prior call to sqlite3rbu_step(), sqlite3rbu_close() returns the same error code.</source>
          <target state="translated">Как и sqlite3rbu_step(),если операция вакуума закончена,sqlite3rbu_close()возвращает SQLITE_DONE.Если вакуум не закончился,но ошибка не произошла,возвращается SQLITE_OK.Или,если ошибка произошла,возвращается код ошибки SQLite.Если ошибка произошла в рамках предыдущего вызова sqlite3rbu_step(),sqlite3rbu_close()возвращает тот же код ошибки.</target>
        </trans-unit>
        <trans-unit id="7e8a69dbe9cf8dfea5767671aa0118b3491fc369" translate="yes" xml:space="preserve">
          <source>Like the &quot;.dump&quot; command, &quot;.recover&quot; attempts to convert the entire contents of a database file to text. The difference is that instead of reading data using the normal SQL database interface, &quot;.recover&quot; attempts to reassemble the database based on data extracted directly from as many database pages as possible. If the database is corrupt, &quot;.recover&quot; is usually able to recover data from all uncorrupted parts of the database, whereas &quot;.dump&quot; stops when the first sign of corruption is encountered.</source>
          <target state="translated">Подобно команде &quot;.dump&quot;,&quot;.recover&quot; пытается преобразовать все содержимое файла базы данных в текст.Разница в том,что вместо чтения данных с помощью обычного интерфейса базы данных SQL,&quot;.recover&quot; пытается собрать базу данных на основе данных,извлеченных непосредственно из как можно большего количества страниц базы данных.Если база данных повреждена,&quot;.recover&quot;,как правило,может восстановить данные из всех поврежденных частей базы данных,тогда как &quot;.dump&quot; останавливается при первом же признаке повреждения.</target>
        </trans-unit>
        <trans-unit id="86f2b5c75e6099a6cf032f5fc9564b20f9285845" translate="yes" xml:space="preserve">
          <source>Limit Setting</source>
          <target state="translated">Установка пределов</target>
        </trans-unit>
        <trans-unit id="dc00d8255b192a092dc29a4b67bc17a891ccaa1d" translate="yes" xml:space="preserve">
          <source>Limit the amount of output that &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt; generates.</source>
          <target state="translated">Ограничьте объем вывода, который генерирует &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA Integrity_check&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3bc4a74f4bc8f6fbe5d7600c2ffc0ce32f2df522" translate="yes" xml:space="preserve">
          <source>Limit the depth of recursion for JSON objects and arrays in order to avoid excess stack usage in the recursive descent parser. Fix for ticket &lt;a href=&quot;https://www.sqlite.org/src/info/981329adeef51011052&quot;&gt;981329adeef51011052&lt;/a&gt;.</source>
          <target state="translated">Ограничьте глубину рекурсии для объектов и массивов JSON, чтобы избежать чрезмерного использования стека в парсере рекурсивного спуска. Исправление для билета &lt;a href=&quot;https://www.sqlite.org/src/info/981329adeef51011052&quot;&gt;981329adeef51011052&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5c73db06777439f7e7a4e0b4ef090767959f015d" translate="yes" xml:space="preserve">
          <source>Limit the maximum amount of memory that SQLite will allocate using the &lt;a href=&quot;c3ref/hard_heap_limit64&quot;&gt;sqlite3_hard_heap_limit64()&lt;/a&gt; interface. This helps prevent denial-of-service attacks. To find out how much heap space an application actually needs, run the it against typical inputs and then measure the maximum instantaneous memory usage with the &lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_highwater()&lt;/a&gt; interface. Set the hard heap limit to the maximum observed instantaneous memory usage plus some margin.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7c04c64ed3f2a9374590c76c50d3b7f1b18e3da" translate="yes" xml:space="preserve">
          <source>Limitations</source>
          <target state="translated">Limitations</target>
        </trans-unit>
        <trans-unit id="cd047048aa9c975f33600c7ec5b79b0145824c1c" translate="yes" xml:space="preserve">
          <source>Limitations And Caveats</source>
          <target state="translated">Ограничения и пещеры</target>
        </trans-unit>
        <trans-unit id="140fa43a5b0009e4451c320039ee7a35af9ef59d" translate="yes" xml:space="preserve">
          <source>Limitations Of The OpenDocument Presentation Format</source>
          <target state="translated">Ограничения формата представления OpenDocument</target>
        </trans-unit>
        <trans-unit id="61a0ae3b849d95fb8185df69b96d0ec676fb0688" translate="yes" xml:space="preserve">
          <source>Limits</source>
          <target state="translated">Limits</target>
        </trans-unit>
        <trans-unit id="da74bbdf0c5ba1732a1bcf36654960401f556496" translate="yes" xml:space="preserve">
          <source>Limits In SQLite</source>
          <target state="translated">Ограничения в SQLite</target>
        </trans-unit>
        <trans-unit id="2b535e43758af2a0faba7d7491e8ccc0937261f7" translate="yes" xml:space="preserve">
          <source>Lines that begin with &quot;#&quot; and that are not in the middle of an SQL statement are interpreted as comments.</source>
          <target state="translated">Строки,которые начинаются с &quot;#&quot; и не находятся в середине SQL-оператора,интерпретируются как комментарии.</target>
        </trans-unit>
        <trans-unit id="56c40b8da457fccee36d2dd25cabffcd286e7be5" translate="yes" xml:space="preserve">
          <source>Link SQLite against a test program that runs approximately 30,000 SQL statements representing a typical workload.</source>
          <target state="translated">Соедините SQLite с тестовой программой,которая запускает около 30,000 SQL выражений,представляющих типичную рабочую нагрузку.</target>
        </trans-unit>
        <trans-unit id="aa106ea45c187562ead66ff45b2537ad9d39d113" translate="yes" xml:space="preserve">
          <source>Linus Torvalds used different words to say much the same thing on the Git mailing list on 2006-06-27:</source>
          <target state="translated">Линус Торвальдс использовал разные слова,чтобы сказать одно и то же в списке рассылки Git'а на 2006-06-27:</target>
        </trans-unit>
        <trans-unit id="518aa8e09ec633a2ee7ca4061837886754889a59" translate="yes" xml:space="preserve">
          <source>List Of Constants:</source>
          <target state="translated">Список постоянных:</target>
        </trans-unit>
        <trans-unit id="c88854d7fb661e5a305fcbc6e6989b1500fbf8a5" translate="yes" xml:space="preserve">
          <source>List Of Functions:</source>
          <target state="translated">Список функций:</target>
        </trans-unit>
        <trans-unit id="02564776632cdeb522e81ac2cc1d466134257360" translate="yes" xml:space="preserve">
          <source>List Of Objects:</source>
          <target state="translated">Список объектов:</target>
        </trans-unit>
        <trans-unit id="5976b759c2bbe27a2c436cf0d06c399c38f9db0a" translate="yes" xml:space="preserve">
          <source>List Of PRAGMAs</source>
          <target state="translated">Список PRAGMA</target>
        </trans-unit>
        <trans-unit id="198f4f9677551df3e26744118c9e2c5bcd812876" translate="yes" xml:space="preserve">
          <source>List Of SQLite Constants</source>
          <target state="translated">Список констант SQLite</target>
        </trans-unit>
        <trans-unit id="b6b508ee374f53a81be169f4d47397a7a1f331e0" translate="yes" xml:space="preserve">
          <source>List Of SQLite Functions</source>
          <target state="translated">Список функций SQLite</target>
        </trans-unit>
        <trans-unit id="52d4b531b52e9862c4189d27482ae4e958f97760" translate="yes" xml:space="preserve">
          <source>List Of SQLite Objects</source>
          <target state="translated">Список объектов SQLite</target>
        </trans-unit>
        <trans-unit id="68749615daec6b7db7287fc101bfd1803474c677" translate="yes" xml:space="preserve">
          <source>List Of Virtual Tables</source>
          <target state="translated">Список виртуальных таблиц</target>
        </trans-unit>
        <trans-unit id="9d1c029d1a64007ca37f5bf394575d02eef0574f" translate="yes" xml:space="preserve">
          <source>List each file as it is processed.</source>
          <target state="translated">Перечислите каждый файл в процессе обработки.</target>
        </trans-unit>
        <trans-unit id="a5d1705cc809076e6266257a5ff3fa27b21bc1d4" translate="yes" xml:space="preserve">
          <source>List the contents of the archive. If no arguments are specified, then all files are listed. Otherwise, only those specified as arguments are. Currently, the --verbose option does not change the behaviour of this command. That may change in the future.</source>
          <target state="translated">Перечислите содержимое архива.Если аргументы не указаны,то перечисляются все файлы.В противном случае,только те,которые указаны в качестве аргументов.На данный момент опция --verbose не изменяет поведение этой команды.Это может измениться в будущем.</target>
        </trans-unit>
        <trans-unit id="27424535e9c380832791dbc03c67071412b07455" translate="yes" xml:space="preserve">
          <source>List the files in the archive.</source>
          <target state="translated">Перечислите файлы в архиве.</target>
        </trans-unit>
        <trans-unit id="615e9625e4457bad91a4957735c233d58d384ed8" translate="yes" xml:space="preserve">
          <source>List values on the right-hand side of IN are treated as a subquery that must be materialized. In other words, the previous statement acts as if it were:</source>
          <target state="translated">Значения перечня,расположенные справа от IN,рассматриваются как подзапрос,который должен быть материализован.Другими словами,предыдущее утверждение действует так,как если бы оно было:</target>
        </trans-unit>
        <trans-unit id="f653dec85c31b3ff9b77fe72b2384cf749288d85" translate="yes" xml:space="preserve">
          <source>Listed below are some cases where it might make sense to add additional soundslike entries. The specific entries will depend on the application and the target language.</source>
          <target state="translated">Ниже перечислены некоторые случаи,когда имеет смысл добавить дополнительные звуковые записи.Конкретные записи будут зависеть от приложения и целевого языка.</target>
        </trans-unit>
        <trans-unit id="9a2828a10d993798b426c35ab47fdbeb8b46927a" translate="yes" xml:space="preserve">
          <source>Listen willingly to holy reading.</source>
          <target state="translated">Слушайте с готовностью святое чтение.</target>
        </trans-unit>
        <trans-unit id="3805c697baba47d8b6fac8ff193aac1d5aae53c5" translate="yes" xml:space="preserve">
          <source>Literal Values (Constants)</source>
          <target state="translated">Буквальные значения (постоянные)</target>
        </trans-unit>
        <trans-unit id="3c11cc0f06e28252855afe306ffae2efa4d23a55" translate="yes" xml:space="preserve">
          <source>Literal strings contain no byte-order-marks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a95fd3f55e521532b15bff8dba2b3aa3f6401a1a" translate="yes" xml:space="preserve">
          <source>Literal value</source>
          <target state="translated">Буквальное значение</target>
        </trans-unit>
        <trans-unit id="fc57b0cbf2f7891171194ad1bf1b86f68a201597" translate="yes" xml:space="preserve">
          <source>LoC Recommended Storage Format</source>
          <target state="translated">Рекомендуемый формат хранения LoC</target>
        </trans-unit>
        <trans-unit id="c1fd24450afa2a8ca3ccb54f712f70e15f33b7ed" translate="yes" xml:space="preserve">
          <source>Load An Extension</source>
          <target state="translated">Загрузить удлинитель</target>
        </trans-unit>
        <trans-unit id="f9c032c8f6af23d9ff803554a14cbcd6e3037cb8" translate="yes" xml:space="preserve">
          <source>Load The Difference Between Tables Into A Session</source>
          <target state="translated">Загрузить разницу между таблицами в сессию.</target>
        </trans-unit>
        <trans-unit id="9c794e6d2b53e1c944bf6d4f24a6f0f6be485378" translate="yes" xml:space="preserve">
          <source>Load the shared library or DLL file LIBRARY into SQLite prior to computing the differences. This can be used to add application-defined &lt;a href=&quot;datatype3#collation&quot;&gt;collating sequences&lt;/a&gt; that are required by the schema.</source>
          <target state="translated">Загрузите общую библиотеку или DLL-файл LIBRARY в SQLite до вычисления различий. Это можно использовать для добавления определяемых приложением &lt;a href=&quot;datatype3#collation&quot;&gt;последовательностей упорядочения&lt;/a&gt; , которые требуются для схемы.</target>
        </trans-unit>
        <trans-unit id="1f26dca858775a9ffdc6b130413dfda84cf7cc4a" translate="yes" xml:space="preserve">
          <source>LoadAnalysis</source>
          <target state="translated">LoadAnalysis</target>
        </trans-unit>
        <trans-unit id="494260ec047bea19460fac6ca8324736557ff1c6" translate="yes" xml:space="preserve">
          <source>Loadable Extension Thunk</source>
          <target state="translated">Загрузочное расширение Спасибо</target>
        </trans-unit>
        <trans-unit id="a8855a7ba639af1775ee3c99ff39ec45827a09ba" translate="yes" xml:space="preserve">
          <source>Loadable extensions are C-code. To compile them on most unix-like operating systems, the usual command is something like this:</source>
          <target state="translated">Загружаемые расширения-это C-код.Для компиляции их на большинстве unix-подобных операционных систем обычной командой является нечто подобное:</target>
        </trans-unit>
        <trans-unit id="16baeb9dc5c7b831d9570f59926debb8cb175348" translate="yes" xml:space="preserve">
          <source>Local DELETE</source>
          <target state="translated">Местная УДАЛЕТА</target>
        </trans-unit>
        <trans-unit id="ad4c5e9ed0fc895a0d42b932b2926861699fe92c" translate="yes" xml:space="preserve">
          <source>Local INSERT</source>
          <target state="translated">Местный иммиграционный контроль</target>
        </trans-unit>
        <trans-unit id="3e12d4ac47a72a1f8aa6fb2cd56dc176cf45a02b" translate="yes" xml:space="preserve">
          <source>Local UPDATE</source>
          <target state="translated">Локальная дата UPDATE</target>
        </trans-unit>
        <trans-unit id="e88556ba53a549a6a9fbf15298a71732177e868b" translate="yes" xml:space="preserve">
          <source>Localtime modifier</source>
          <target state="translated">Модификатор местного времени</target>
        </trans-unit>
        <trans-unit id="249beb765376acea4283a10da9faa975024e8fe9" translate="yes" xml:space="preserve">
          <source>Lock Name</source>
          <target state="translated">Имя замка</target>
        </trans-unit>
        <trans-unit id="d4795eaa0bbabf21615f9f3e359ab0c2e3631ccd" translate="yes" xml:space="preserve">
          <source>Lock offset</source>
          <target state="translated">Смещение блокировки</target>
        </trans-unit>
        <trans-unit id="eb6bc036bb67cd66abad9bfabc9e6cb6a5eaef00" translate="yes" xml:space="preserve">
          <source>Lock the btree to which cursor P1 is pointing so that the btree cannot be written by an other cursor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de20f3d1eb2301b2722958c2ff4a7d6bd4e9d117" translate="yes" xml:space="preserve">
          <source>Locking and Concurrency</source>
          <target state="translated">Блокировка и конвертация</target>
        </trans-unit>
        <trans-unit id="668186cf26fd89e59f391d180f6666c5c03f0bfa" translate="yes" xml:space="preserve">
          <source>Locking and concurrency control are handled by the &lt;a href=&quot;http://www.sqlite.org/src/finfo?name=src/pager.c&quot;&gt; pager module&lt;/a&gt;. The pager module is responsible for making SQLite &quot;ACID&quot; (Atomic, Consistent, Isolated, and Durable). The pager module makes sure changes happen all at once, that either all changes occur or none of them do, that two or more processes do not try to access the database in incompatible ways at the same time, and that once changes have been written they persist until explicitly deleted. The pager also provides a memory cache of some of the contents of the disk file.</source>
          <target state="translated">Управление блокировкой и параллелизмом осуществляется &lt;a href=&quot;http://www.sqlite.org/src/finfo?name=src/pager.c&quot;&gt;модулем пейджера&lt;/a&gt; . Модуль пейджера отвечает за создание SQLite &amp;laquo;ACID&amp;raquo; (атомарный, согласованный, изолированный и надежный). Модуль пейджера следит за тем, чтобы все изменения происходили одновременно, чтобы были либо все изменения, либо ни одно из них, что два или более процесса не пытались получить доступ к базе данных несовместимыми способами одновременно и что после того, как изменения были записаны, они сохраняются до тех пор, пока явно не будут удалены. Пейджер также обеспечивает кеш-память некоторого содержимого дискового файла.</target>
        </trans-unit>
        <trans-unit id="57d0597b0f360ba173ecb2d2a1f767cb5748ea2e" translate="yes" xml:space="preserve">
          <source>Long Option</source>
          <target state="translated">Длинный вариант</target>
        </trans-unit>
        <trans-unit id="76889c4037fcda94eba3afe630f0b45c824942de" translate="yes" xml:space="preserve">
          <source>Long Term Support</source>
          <target state="translated">Долгосрочная поддержка</target>
        </trans-unit>
        <trans-unit id="fce206f4d564c7fbca45ff9aebf22500127c7c61" translate="yes" xml:space="preserve">
          <source>Long and short style options may be mixed. For example, the following are equivalent:</source>
          <target state="translated">Длинные и короткие варианты стиля могут быть смешанными.Например,следующие варианты эквивалентны:</target>
        </trans-unit>
        <trans-unit id="1a01077cb8c85bad9873673a9051f4ee19688494" translate="yes" xml:space="preserve">
          <source>Longer answer: If you declare a column of a table to be &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;, then whenever you insert a NULL into that column of the table, the NULL is automatically converted into an integer which is one greater than the largest value of that column over all other rows in the table, or 1 if the table is empty. Or, if the largest existing integer key 9223372036854775807 is in use then an unused key value is chosen at random. For example, suppose you have a table like this:</source>
          <target state="translated">Более длинный ответ: если вы объявляете столбец таблицы как &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; , то всякий раз, когда вы вставляете NULL в этот столбец таблицы, NULL автоматически преобразуется в целое число, которое на единицу больше, чем наибольшее значение этого столбца. все остальные строки в таблице или 1, если таблица пуста. Или, если используется самый большой из существующих целочисленных ключей 9223372036854775807, то случайным образом выбирается неиспользуемое значение ключа. Например, предположим, что у вас есть такая таблица:</target>
        </trans-unit>
        <trans-unit id="6e9f2602cf3d1fd809e1312f33acfde2f150141f" translate="yes" xml:space="preserve">
          <source>Lookaside buffer allocations for new &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt;.</source>
          <target state="translated">Резервное выделение буфера для новых &lt;a href=&quot;c3ref/sqlite3&quot;&gt;подключений&lt;/a&gt; к базе данных .</target>
        </trans-unit>
        <trans-unit id="04bd7a984d3646ac5eb9c18de550a3f1e203e5b1" translate="yes" xml:space="preserve">
          <source>Lookaside memory allocator</source>
          <target state="translated">аллокатор Lookaside памяти</target>
        </trans-unit>
        <trans-unit id="fde137681e3baa6ad1143b905327accc0fb28e76" translate="yes" xml:space="preserve">
          <source>Lots of bug fixes.</source>
          <target state="translated">Много исправлений.</target>
        </trans-unit>
        <trans-unit id="990ee2bc3df995ba8afb44c45e674fd9a503ec05" translate="yes" xml:space="preserve">
          <source>Lots of little bug fixes.</source>
          <target state="translated">Множество маленьких исправлений.</target>
        </trans-unit>
        <trans-unit id="43de40a3e36d80f18de0a9c09a14efee88ae8d7f" translate="yes" xml:space="preserve">
          <source>Love chastity.</source>
          <target state="translated">Любовь к целомудрию.</target>
        </trans-unit>
        <trans-unit id="0bbc37af1e456bff56591e973337f95cdf967a70" translate="yes" xml:space="preserve">
          <source>Love fasting.</source>
          <target state="translated">Люблю пост.</target>
        </trans-unit>
        <trans-unit id="b7fcabbc1c2979a6343998251fb3b60ca2fcf13c" translate="yes" xml:space="preserve">
          <source>Love your enemies.</source>
          <target state="translated">Люби своих врагов.</target>
        </trans-unit>
        <trans-unit id="868ab24a96d3a2771240294f216c1eb308fe2112" translate="yes" xml:space="preserve">
          <source>Love your juniors.</source>
          <target state="translated">Любите своих юниоров.</target>
        </trans-unit>
        <trans-unit id="dcbca8259d75e252eae0048dd86f40340f8d0cd8" translate="yes" xml:space="preserve">
          <source>Low-Level Control Of Database Files</source>
          <target state="translated">Низкоуровневый контроль файлов базы данных</target>
        </trans-unit>
        <trans-unit id="c47d12b1a2b47bc6fe16c9cb80aba1cd8b334072" translate="yes" xml:space="preserve">
          <source>Low-dependency</source>
          <target state="translated">Low-dependency</target>
        </trans-unit>
        <trans-unit id="9b49cf9a88d0eb7571f152a707297d6594a2f0d2" translate="yes" xml:space="preserve">
          <source>Low-level system error code</source>
          <target state="translated">Низкоуровневый код системной ошибки</target>
        </trans-unit>
        <trans-unit id="0be209fef2b5ea9e4e344d9742cbe9598db19564" translate="yes" xml:space="preserve">
          <source>Lowest precedence (loosest grouping).</source>
          <target state="translated">Самый низкий приоритет (самая низкая группировка).</target>
        </trans-unit>
        <trans-unit id="f41a055096fba2f5ebbddc8916d81727739dbdb3" translate="yes" xml:space="preserve">
          <source>Lt</source>
          <target state="translated">Lt</target>
        </trans-unit>
        <trans-unit id="c63ae6dd4fc9f9dda66970e827d13f7c73fe841c" translate="yes" xml:space="preserve">
          <source>M</source>
          <target state="translated">M</target>
        </trans-unit>
        <trans-unit id="a4b52e49796d63ce942c6b8bfaa86fb7c20383ea" translate="yes" xml:space="preserve">
          <source>M is always ((U-12)*32/255)-23.</source>
          <target state="translated">M всегда ((U-12)*32/255)-23.</target>
        </trans-unit>
        <trans-unit id="1758fbe17031a1050ba647fef2f5a93784bd0bf5" translate="yes" xml:space="preserve">
          <source>M&lt;sub&gt;&lt;small&gt;left&lt;/small&gt;&lt;/sub&gt;</source>
          <target state="translated">M&lt;sub&gt;&lt;small&gt;left&lt;/small&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="5fbd2551d496e24af3eb24927ec50373a744a672" translate="yes" xml:space="preserve">
          <source>M&lt;sub&gt;&lt;small&gt;left&lt;/small&gt;&lt;/sub&gt;+M&lt;sub&gt;&lt;small&gt;right&lt;/small&gt;&lt;/sub&gt;</source>
          <target state="translated">M&lt;sub&gt;&lt;small&gt;left&lt;/small&gt;&lt;/sub&gt;+M&lt;sub&gt;&lt;small&gt;right&lt;/small&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="835c3f9feac04a1fedeecdc386e908df7274d7ab" translate="yes" xml:space="preserve">
          <source>M&lt;sub&gt;&lt;small&gt;right&lt;/small&gt;&lt;/sub&gt;</source>
          <target state="translated">M&lt;sub&gt;&lt;small&gt;right&lt;/small&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="7e3ce80c0f5019f27debc96398dd7ba53b449b32" translate="yes" xml:space="preserve">
          <source>MASK</source>
          <target state="translated">MASK</target>
        </trans-unit>
        <trans-unit id="4110e0d1b0232ec2802f84b8b4f2d0c2fb3fbbb7" translate="yes" xml:space="preserve">
          <source>MASK bit 0x02 is set.</source>
          <target state="translated">Бит MASK 0x02 установлен.</target>
        </trans-unit>
        <trans-unit id="ce71241b2af9817fe6f961964423ded83b2b2446" translate="yes" xml:space="preserve">
          <source>MATCH</source>
          <target state="translated">MATCH</target>
        </trans-unit>
        <trans-unit id="fb533649ca2f9e73b11b6bb948adb363f958ac9f" translate="yes" xml:space="preserve">
          <source>MEDIUMINT</source>
          <target state="translated">MEDIUMINT</target>
        </trans-unit>
        <trans-unit id="7c2c1a9b5cbb8b738dc37806d8007da0a4dabc51" translate="yes" xml:space="preserve">
          <source>MS-SQL</source>
          <target state="translated">MS-SQL</target>
        </trans-unit>
        <trans-unit id="e6557f13d224519bee5609849fa3b7fe2b045817" translate="yes" xml:space="preserve">
          <source>Macs are unix-like, but they do not follow the usual shared library conventions. To compile a shared library on a Mac, use a command like this:</source>
          <target state="translated">Масы Mac похожи на unix,но они не следуют обычным конвенциям об общих библиотеках.Для компиляции разделяемой библиотеки на Mac используйте команду,подобную этой:</target>
        </trans-unit>
        <trans-unit id="a1e5337bd6f525fef1a4495aefda7354ea999138" translate="yes" xml:space="preserve">
          <source>Made selected parameters in API functions &lt;b&gt;const&lt;/b&gt;. This should be fully backwards compatible.</source>
          <target state="translated">Сделал выбранные параметры в функциях API &lt;b&gt;const&lt;/b&gt; . Это должно быть полностью обратно совместимо.</target>
        </trans-unit>
        <trans-unit id="debb142b11cd7000f7ccf5be052a02bcc1c7f9ef" translate="yes" xml:space="preserve">
          <source>Made the &lt;a href=&quot;testing#aflfuzz&quot;&gt;American Fuzzy Lop fuzzer&lt;/a&gt; a standard part of SQLite's &lt;a href=&quot;testing&quot;&gt;testing strategy&lt;/a&gt;.</source>
          <target state="translated">Сделал &lt;a href=&quot;testing#aflfuzz&quot;&gt;американский фаззер Fuzzy Lop&lt;/a&gt; стандартной частью &lt;a href=&quot;testing&quot;&gt;стратегии тестирования&lt;/a&gt; SQLite .</target>
        </trans-unit>
        <trans-unit id="aadd04e928883126f21deaf37b5282558e747d50" translate="yes" xml:space="preserve">
          <source>Made the CACHE_SIZE pragma persistent</source>
          <target state="translated">Сделали прагму CACHE_SIZE упорной</target>
        </trans-unit>
        <trans-unit id="2d544f28a897acf54e3872442614c2de63e16acf" translate="yes" xml:space="preserve">
          <source>Magic number. 0x377f0682 or 0x377f0683</source>
          <target state="translated">Волшебное число.0x377f0682 или 0x377f0683</target>
        </trans-unit>
        <trans-unit id="a249757e280e4c1ed4596ef256151f0633cc5c86" translate="yes" xml:space="preserve">
          <source>Maintaining 100% MC/DC is laborious and time-consuming. The level of effort needed to maintain full-coverage testing is probably not cost effective for a typical application. However, we think that full-coverage testing is justified for a &lt;a href=&quot;https://sqlite.org/mostdeployed.html&quot;&gt;very widely deployed&lt;/a&gt; infrastructure library like SQLite, and especially for a database library which by its very nature &quot;remembers&quot; past mistakes.</source>
          <target state="translated">Поддержание 100% MC / DC трудоемко и требует много времени. Уровень усилий, необходимых для поддержки тестирования с полным покрытием, вероятно, не является рентабельным для типичного приложения. Однако мы считаем, что тестирование с полным покрытием оправдано для &lt;a href=&quot;https://sqlite.org/mostdeployed.html&quot;&gt;очень широко распространенной&lt;/a&gt; библиотеки инфраструктуры, такой как SQLite, и особенно для библиотеки баз данных, которая по самой своей природе &amp;laquo;помнит&amp;raquo; прошлые ошибки.</target>
        </trans-unit>
        <trans-unit id="0690809fdfc162c136b84c90c7f6551b5a7d6bb1" translate="yes" xml:space="preserve">
          <source>Maintaining Private Branches Of SQLite</source>
          <target state="translated">Поддержание частных филиалов SQLite</target>
        </trans-unit>
        <trans-unit id="74db8285437f292d07f23511a8853dab08df8f69" translate="yes" xml:space="preserve">
          <source>Make &lt;a href=&quot;c3ref/compileoption_get&quot;&gt;sqlite3_compileoption_used()&lt;/a&gt; responsive to the &lt;a href=&quot;compile#enable_dbstat_vtab&quot;&gt;SQLITE_ENABLE_DBSTAT_VTAB&lt;/a&gt; compile-time option.</source>
          <target state="translated">Сделайте &lt;a href=&quot;c3ref/compileoption_get&quot;&gt;sqlite3_compileoption_used () &lt;/a&gt;&lt;a href=&quot;compile#enable_dbstat_vtab&quot;&gt;зависимым&lt;/a&gt; от параметра времени компиляции SQLITE_ENABLE_DBSTAT_VTAB .</target>
        </trans-unit>
        <trans-unit id="f178a74cc1dcf57fcc7b73994685f97569f4844f" translate="yes" xml:space="preserve">
          <source>Make AreFileApisANSI() a no-op macro in WinCE since WinCE does not support this function.</source>
          <target state="translated">Сделайте AreFileApisANSI()нулевым макросом в WinCE,так как WinCE не поддерживает эту функцию.</target>
        </trans-unit>
        <trans-unit id="07dc88b6cef4d75e2f7c3880e8647593525aa07e" translate="yes" xml:space="preserve">
          <source>Make CSV (comma separate value) output from the command-line shell more closely aligned to accepted practice</source>
          <target state="translated">Сделать вывод CSV (значение,отделенное запятой)из командной строки,более близким к общепринятой практике</target>
        </trans-unit>
        <trans-unit id="7ebdddec87e9007589d5ada3e116c78e26d2e69a" translate="yes" xml:space="preserve">
          <source>Make LIMIT work on a compound SELECT statement.</source>
          <target state="translated">Заставьте LIMIT работать над комплексным заявлением SELECT.</target>
        </trans-unit>
        <trans-unit id="67a20c818425dd125a3dee8478ee3f7563c8b234" translate="yes" xml:space="preserve">
          <source>Make a copy of registers P1..P1+P3 into registers P2..P2+P3.</source>
          <target state="translated">Сделайте копию регистров P1...P1+P3 в регистры P2...P2+P3.</target>
        </trans-unit>
        <trans-unit id="8d0b0f116d9ed8fdf1c047e6cff51269d6d08bd0" translate="yes" xml:space="preserve">
          <source>Make a distinction between numeric and text values when sorting. Text values sort according to memcmp(). Numeric values sort in numeric order.</source>
          <target state="translated">При сортировке следует различать числовые и текстовые значения.Текстовые значения сортируются по функции memcmp().Числовые значения сортируются в числовом порядке.</target>
        </trans-unit>
        <trans-unit id="9f53feddfd33da18e3bb3466ea22bc837873fc9d" translate="yes" xml:space="preserve">
          <source>Make a shallow copy of register P1 into register P2.</source>
          <target state="translated">Сделайте неглубокую копию регистра P1 в регистр P2.</target>
        </trans-unit>
        <trans-unit id="c4914cad6e6db40e49d46939d936ae678cbe7888" translate="yes" xml:space="preserve">
          <source>Make every effort to allocate a new page. Only return NULL if allocating a new page is effectively impossible.</source>
          <target state="translated">Приложите все усилия,чтобы выделить новую страницу.Возвращайте NULL только в том случае,если выделение новой страницы фактически невозможно.</target>
        </trans-unit>
        <trans-unit id="94089eca234684dc20cbdb2f8434b3d3fb23b40c" translate="yes" xml:space="preserve">
          <source>Make peace with your adversary before the sun sets.</source>
          <target state="translated">Помиритесь с противником до захода солнца.</target>
        </trans-unit>
        <trans-unit id="b31d5954ede96c4a01bf917d9892337c3c9f6de7" translate="yes" xml:space="preserve">
          <source>Make sure ORDER BY puts rows in ascending order even if the DISTINCT operator is implemented using a descending index. Fix for ticket &lt;a href=&quot;https://www.sqlite.org/src/info/c5ea805691bfc4204b1cb9e&quot;&gt;c5ea805691bfc4204b1cb9e&lt;/a&gt;.</source>
          <target state="translated">Убедитесь, что ORDER BY помещает строки в порядке возрастания, даже если оператор DISTINCT реализован с использованием убывающего индекса. Исправление для билета &lt;a href=&quot;https://www.sqlite.org/src/info/c5ea805691bfc4204b1cb9e&quot;&gt;c5ea805691bfc4204b1cb9e&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fd7437d47e0ca64701851f46718248492d235445" translate="yes" xml:space="preserve">
          <source>Make sure VIEWs are created after their corresponding TABLEs in the output of the &lt;b&gt;.dump&lt;/b&gt; command in the shell.</source>
          <target state="translated">Убедитесь, что ВИДЫ создаются после соответствующих ТАБЛИЦ в выводе команды &lt;b&gt;.dump&lt;/b&gt; в оболочке.</target>
        </trans-unit>
        <trans-unit id="b8fc01ec14bc51db67a6c7f295254a0473ee78c4" translate="yes" xml:space="preserve">
          <source>Make sure all individual database files have an EXCLUSIVE lock and a valid journal.</source>
          <target state="translated">Убедитесь,что все отдельные файлы базы данных имеют ЭКСКЛЮЗИВНЫЙ БЛОКИРОВКУ и действующий журнал.</target>
        </trans-unit>
        <trans-unit id="39ceab29d21e2433cf3cad2d290185c2cdda1b07" translate="yes" xml:space="preserve">
          <source>Make sure all rollback journal data has actually been written to the surface of the disk (and is not just being held in the operating system's or disk controllers cache) so that if a power failure occurs the data will still be there after power is restored.</source>
          <target state="translated">Убедитесь,что все данные журнала отката действительно записаны на поверхность диска (а не просто хранятся в кэше операционной системы или контроллеров дисков),так что в случае отключения питания данные все равно останутся там после восстановления питания.</target>
        </trans-unit>
        <trans-unit id="faaff6cbdbf4873f3d095a4a0e2d87974475615a" translate="yes" xml:space="preserve">
          <source>Make sure functions expressions in the VALUES clause of an INSERT are correct.</source>
          <target state="translated">Убедитесь,что выражения функций в выражении VALUES в INSERT корректны.</target>
        </trans-unit>
        <trans-unit id="b3c87542457fbfa0848fd99500f7827664d328fc" translate="yes" xml:space="preserve">
          <source>Make sure that database filenames follow the 8+3 filename format and that they do not have an empty name or extension. In other words, the database filename must contain between 1 and 8 characters in the base name and between 1 and 3 characters in the extension. Blank extensions are not allowed.</source>
          <target state="translated">Убедитесь,что имена файлов базы данных соответствуют формату 8+3 и что у них нет пустого имени или расширения.Другими словами,имя файла базы данных должно содержать от 1 до 8 символов в базовом имени и от 1 до 3 символов в расширении.Пустые расширения не допускаются.</target>
        </trans-unit>
        <trans-unit id="559ee78af19e40cf8fa346787df1709761be2f3c" translate="yes" xml:space="preserve">
          <source>Make sure that when a connection blocks on a RESERVED lock that it is able to continue after the lock is released. (Ticket #3093)</source>
          <target state="translated">Убедитесь,что при блокировке соединения на блокировке RESERVED оно может продолжить работу после снятия блокировки.(Билет № 3093)</target>
        </trans-unit>
        <trans-unit id="6c2032f0b0a487670b92ae7b1f7c2a4d3713ca71" translate="yes" xml:space="preserve">
          <source>Make sure the &lt;a href=&quot;c3ref/get_auxdata&quot;&gt;sqlite3_set_auxdata()&lt;/a&gt; values from multiple triggers within a single statement do not interfere with one another. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/dc9b1c91&quot;&gt;dc9b1c91&lt;/a&gt;.</source>
          <target state="translated">Убедитесь, что значения &lt;a href=&quot;c3ref/get_auxdata&quot;&gt;sqlite3_set_auxdata ()&lt;/a&gt; из нескольких триггеров в одном операторе не мешают друг другу. Билет &lt;a href=&quot;https://www.sqlite.org/src/info/dc9b1c91&quot;&gt;dc9b1c91&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c6638940c401bf7e1c92493be7672af3af206b2b" translate="yes" xml:space="preserve">
          <source>Make sure the &lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_snprintf()&lt;/a&gt; interface does not zero-terminate the buffer if the buffer size is less than 1. Ticket #2341</source>
          <target state="translated">Убедитесь, что интерфейс &lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_snprintf ()&lt;/a&gt; не завершает буфер нулем, если размер буфера меньше 1. Билет № 2341</target>
        </trans-unit>
        <trans-unit id="3bc85b9279a5981ff83181cec093f69c7042f9c4" translate="yes" xml:space="preserve">
          <source>Make sure the MIN() and MAX() optimizations work within subqueries.</source>
          <target state="translated">Убедитесь,что оптимизации MIN()и MAX()работают внутри подзапросов.</target>
        </trans-unit>
        <trans-unit id="58ff8f836097af00b92625ae2c5e983cf4412032" translate="yes" xml:space="preserve">
          <source>Make sure the ORDER BY LIMIT optimization (from check-in &lt;a href=&quot;https://www.sqlite.org/src/info/559733b09e9630fa&quot;&gt;559733b09e&lt;/a&gt;) works with IN operators on INTEGER PRIMARY KEYs. Fix for ticket &lt;a href=&quot;https://www.sqlite.org/src/info/96c1454cbfd9509&quot;&gt;96c1454c&lt;/a&gt;</source>
          <target state="translated">Убедитесь, что оптимизация ORDER BY LIMIT (из проверки &lt;a href=&quot;https://www.sqlite.org/src/info/559733b09e9630fa&quot;&gt;559733b09e&lt;/a&gt; ) работает с операторами IN на INTEGER PRIMARY KEYs. Исправление для билета &lt;a href=&quot;https://www.sqlite.org/src/info/96c1454cbfd9509&quot;&gt;96c1454c&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3ea00b4a5adf172672ba7e54a20e155f2d4f11b3" translate="yes" xml:space="preserve">
          <source>Make sure the TCL language interface works correctly with 64-bit integers on 64-bit machines.</source>
          <target state="translated">Убедитесь,что интерфейс языка TCL корректно работает с 64-битными целыми числами на 64-битных машинах.</target>
        </trans-unit>
        <trans-unit id="2c7d7b5412a65ed5d6ce615755d9929fa6d57cca" translate="yes" xml:space="preserve">
          <source>Make sure the in-memory backend response sanely if malloc() fails.</source>
          <target state="translated">Убедитесь,что ответ бэкенда in-memory в здравом уме,если malloc()не срабатывает.</target>
        </trans-unit>
        <trans-unit id="eae9ed5b156bcdd54a8967008569fef435a53021" translate="yes" xml:space="preserve">
          <source>Make sure the query optimizer checks dependencies on all terms of a compound SELECT statement. Ticket #2640.</source>
          <target state="translated">Убедитесь,что оптимизатор запросов проверяет зависимости от всех условий составного SELECT-оператора.Билет № 2640.</target>
        </trans-unit>
        <trans-unit id="30c0cf0484d7a5f504b6b728788d263a9e41fc0c" translate="yes" xml:space="preserve">
          <source>Make sure you type a semicolon at the end of each SQL command! The sqlite3 program looks for a semicolon to know when your SQL command is complete. If you omit the semicolon, sqlite3 will give you a continuation prompt and wait for you to enter more text to be added to the current SQL command. This feature allows you to enter SQL commands that span multiple lines. For example:</source>
          <target state="translated">Убедитесь,что в конце каждой команды SQL вы напечатали точку с запятой! Программа sqlite3 ищет точку с запятой,чтобы узнать,когда Ваша команда SQL будет завершена.Если Вы опустите точку с запятой,sqlite3 даст Вам запрос на продолжение и будет ждать,пока Вы не введете больше текста для добавления в текущую команду SQL.Эта функция позволяет вводить команды SQL,которые охватывают несколько строк.Например:</target>
        </trans-unit>
        <trans-unit id="0f78a73d59843cf77efe52a3fb9a1c8bc577fb63" translate="yes" xml:space="preserve">
          <source>Make that script executable and put it on your $PATH. Then compile the kvtest program as follows:</source>
          <target state="translated">Сделайте этот сценарий исполняемым и положите его на ваш $PATH.Затем скомпилируйте программу kvtest следующим образом:</target>
        </trans-unit>
        <trans-unit id="55a8e3fef2599367be1f179f0eeae6e3f90c5562" translate="yes" xml:space="preserve">
          <source>Make the &quot;AS&quot; keyword optional again.</source>
          <target state="translated">Сделайте снова необязательным ключевое слово &quot;AS&quot;.</target>
        </trans-unit>
        <trans-unit id="e8d3c7849aaf72378ce97fad0ef58bb50dfa844b" translate="yes" xml:space="preserve">
          <source>Make the &lt;a href=&quot;dbstat&quot;&gt;dbstat virtual table&lt;/a&gt; part of standard builds when compiled with the &lt;a href=&quot;compile#enable_dbstat_vtab&quot;&gt;SQLITE_ENABLE_DBSTAT_VTAB&lt;/a&gt; option.</source>
          <target state="translated">Сделайте &lt;a href=&quot;dbstat&quot;&gt;виртуальную таблицу dbstat&lt;/a&gt; частью стандартных сборок при компиляции с опцией &lt;a href=&quot;compile#enable_dbstat_vtab&quot;&gt;SQLITE_ENABLE_DBSTAT_VTAB&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3cf1a1fb81ef7a54777705fadfc53565c39e040a" translate="yes" xml:space="preserve">
          <source>Make the GLOB and LIKE operators functions that can be overridden by a programmer. This allows, for example, the LIKE operator to be changed to be case sensitive.</source>
          <target state="translated">Сделайте функции операторов GLOB и LIKE,которые могут быть переопределены программистом.Это позволяет,например,изменять оператор LIKE на регистрозависимый.</target>
        </trans-unit>
        <trans-unit id="06d1ed76522acc5f77d35b87ff9bcb7713142c7d" translate="yes" xml:space="preserve">
          <source>Make the LIMIT clause work on subqueries. (ORDER BY still does not work, though.)</source>
          <target state="translated">Заставьте пункт LIMIT работать над подзапросами.(ЗАКАЗАТЕЛЬСТВО ЗАПРЕЩАЕТСЯ все равно не работает.)</target>
        </trans-unit>
        <trans-unit id="e949e24407b3c3e74908e043648105301add53c5" translate="yes" xml:space="preserve">
          <source>Make the library thread-safe. (The code is there and appears to work but has not been stressed.)</source>
          <target state="translated">Сделайте библиотеку безопасной для нитей.(Код есть,и кажется,что он работает,но не был подчеркнут).</target>
        </trans-unit>
        <trans-unit id="aa1b502d7a3d8467cdd71e12de59017bd7bf7832" translate="yes" xml:space="preserve">
          <source>Make the os.h header file more robust in detecting when the compile is for Windows and when it is for Unix.</source>
          <target state="translated">Сделайте заголовочный файл os.h более надежным в обнаружении,когда компиляция для Windows,а когда для Unix.</target>
        </trans-unit>
        <trans-unit id="5b70367d16489f70b60357dd49e971c66ecb7a25" translate="yes" xml:space="preserve">
          <source>Make use of OVERLAPPED in the windows &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; to avoid some system calls and thereby obtain a performance improvement.</source>
          <target state="translated">Используйте OVERLAPPED в Windows &lt;a href=&quot;vfs&quot;&gt;VFS,&lt;/a&gt; чтобы избежать некоторых системных вызовов и тем самым повысить производительность.</target>
        </trans-unit>
        <trans-unit id="bb3c80011eafc56757b5115bd6da6df2d3cc0bcf" translate="yes" xml:space="preserve">
          <source>Make use of the one-pass UPDATE and DELETE query plans in the &lt;a href=&quot;rtree&quot;&gt;R-Tree extension&lt;/a&gt; where appropriate.</source>
          <target state="translated">При необходимости используйте однопроходные планы запросов UPDATE и DELETE в &lt;a href=&quot;rtree&quot;&gt;расширении R-Tree&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9c7ffc0af1b5a78c06ebbd279554c53e269060be" translate="yes" xml:space="preserve">
          <source>MakeRecord</source>
          <target state="translated">MakeRecord</target>
        </trans-unit>
        <trans-unit id="decb5fb2e05d5246774c7c119193e5dd3eeab585" translate="yes" xml:space="preserve">
          <source>Makefile updates</source>
          <target state="translated">Обновления Makefile</target>
        </trans-unit>
        <trans-unit id="3e75c9edc23a32990a13f91bc222c1cd2fb310c7" translate="yes" xml:space="preserve">
          <source>Makefile updates and miscellaneous bug fixes.</source>
          <target state="translated">Обновления Makefile и различные исправления ошибок.</target>
        </trans-unit>
        <trans-unit id="bdecdca82af325fcab74535c838b3bad719fc7de" translate="yes" xml:space="preserve">
          <source>Makefile updates from A. Rottmann</source>
          <target state="translated">Обновления Makefile от A.Rottmann</target>
        </trans-unit>
        <trans-unit id="1a74e86adcd0000bd7de1be192d074c821dd68c1" translate="yes" xml:space="preserve">
          <source>Making Other Kinds Of Table Schema Changes</source>
          <target state="translated">Изменение схем таблиц других типов</target>
        </trans-unit>
        <trans-unit id="e6fe063cab95ff9f5d6ec0129688c23c296059b5" translate="yes" xml:space="preserve">
          <source>Malformed UTF-8 that SQLite converts to a UTF-16 byte-order-mark is embedded at the beginning of an SQL string literal value inserted into an FTS3 table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e30f6661f23230d01a3d07773b601db8982cabdd" translate="yes" xml:space="preserve">
          <source>Malformed database tests</source>
          <target state="translated">Испытания базы данных на наличие ошибок</target>
        </trans-unit>
        <trans-unit id="d6314779095d53af544ef97df23a24554ee88bdd" translate="yes" xml:space="preserve">
          <source>Managing SQLite Archives from the command-line</source>
          <target state="translated">Управление архивами SQLite из командной строки</target>
        </trans-unit>
        <trans-unit id="3fbc66cdb2efde39d2ec8d74f242ca151b4515bd" translate="yes" xml:space="preserve">
          <source>Manifest Typing and BLOB Support</source>
          <target state="translated">Манифест ввода и BLOB-поддержка</target>
        </trans-unit>
        <trans-unit id="bb55c1a865472533208270e05409a59df50af4d8" translate="yes" xml:space="preserve">
          <source>Manifest typing and BLOB support.</source>
          <target state="translated">Манифест набора и поддержка BLOB.</target>
        </trans-unit>
        <trans-unit id="1cc470a30ade4f894dfdc6d3819af02869f9a0ff" translate="yes" xml:space="preserve">
          <source>Manual Control Of Query Plans Using CROSS JOIN</source>
          <target state="translated">Ручное управление планами запросов с помощью CROSS JOIN</target>
        </trans-unit>
        <trans-unit id="cd08ce62fe23d2df3bf17c27439fcc586ae7eb2c" translate="yes" xml:space="preserve">
          <source>Manual Control Of Query Plans Using SQLITE_STAT Tables</source>
          <target state="translated">Ручное управление планами запросов с помощью таблиц SQLITE_STAT</target>
        </trans-unit>
        <trans-unit id="6ce25f14125bd349207477d6be9b5bb56a241bb2" translate="yes" xml:space="preserve">
          <source>Many SQLITE_OMIT_ macros inserts to omit features at compile-time and reduce the library footprint.</source>
          <target state="translated">Многие макросы SQLITE_OMIT_вставляются для того,чтобы опустить возможности во время компиляции и уменьшить нагрузку на библиотеку.</target>
        </trans-unit>
        <trans-unit id="58bc21cac299bf4ec03f599485fd07e14baffb8d" translate="yes" xml:space="preserve">
          <source>Many SQLite functions return an integer result code from the set shown here in order to indicate success or failure.</source>
          <target state="translated">Многие функции SQLite возвращают целочисленный код результата из приведенного здесь набора,чтобы указать на успех или неудачу.</target>
        </trans-unit>
        <trans-unit id="29bbffe8721f3a2848d887e1fb7a366159ccdc97" translate="yes" xml:space="preserve">
          <source>Many Small Queries Are Efficient In SQLite</source>
          <target state="translated">Многие малые запросы эффективны в SQLite</target>
        </trans-unit>
        <trans-unit id="b88b7072aba4a1d9cfba91839cebc05836eb0907" translate="yes" xml:space="preserve">
          <source>Many applications destroy their &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt; using calls to &lt;a href=&quot;c3ref/close&quot;&gt;sqlite3_close()&lt;/a&gt; at shutdown. Or, for example, an application that uses SQLite as its &lt;a href=&quot;appfileformat&quot;&gt;application file format&lt;/a&gt; might open &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt; in response to a File/Open menu action and then destroy the corresponding &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; in response to the File/Close menu.</source>
          <target state="translated">Многие приложения разрушают свои &lt;a href=&quot;c3ref/sqlite3&quot;&gt;соединения&lt;/a&gt; с базой данных, используя вызовы &lt;a href=&quot;c3ref/close&quot;&gt;sqlite3_close ()&lt;/a&gt; при завершении работы. Или, например, приложение, использующее SQLite в качестве &lt;a href=&quot;appfileformat&quot;&gt;формата файла приложения,&lt;/a&gt; может открывать &lt;a href=&quot;c3ref/sqlite3&quot;&gt;соединения с базой данных&lt;/a&gt; в ответ на действие меню &amp;laquo;Файл / Открыть&amp;raquo;, а затем разрушать соответствующее &lt;a href=&quot;c3ref/sqlite3&quot;&gt;соединение с базой данных&lt;/a&gt; в ответ на меню &amp;laquo;Файл / Закрыть&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="e4e81b55d5c98ead21919f5ad70f41ad3433a3b2" translate="yes" xml:space="preserve">
          <source>Many applications use SQLite as a cache of relevant content from an enterprise RDBMS. This reduces latency, since most queries now occur against the local cache and avoid a network round-trip. It also reduces the load on the network and on the central database server. And in many cases, it means that the client-side application can continue operating during network outages.</source>
          <target state="translated">Многие приложения используют SQLite в качестве кэша соответствующего контента корпоративной СУБД.Это сокращает задержки,поскольку большинство запросов теперь выполняется против локального кэша и позволяет избежать обхода сети.Это также снижает нагрузку на сеть и центральный сервер базы данных.А во многих случаях это означает,что клиентское приложение может продолжать работать во время сбоев в сети.</target>
        </trans-unit>
        <trans-unit id="0a456e7268dde3087ce48e51e3014a05bf0f0916" translate="yes" xml:space="preserve">
          <source>Many code simplifications and obscure bug fixes in support of providing &lt;a href=&quot;testing#coverage&quot;&gt;100% branch test coverage&lt;/a&gt;.</source>
          <target state="translated">Множество упрощений кода и неясных исправлений ошибок в поддержку обеспечения &lt;a href=&quot;testing#coverage&quot;&gt;100% покрытия тестами ветвей&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a1bfd103f34c0767adc1c7bc9d7d6d545e23cabf" translate="yes" xml:space="preserve">
          <source>Many documentation updates</source>
          <target state="translated">Многие обновления документации</target>
        </trans-unit>
        <trans-unit id="3c83fd215f6013569c8872261f46c5842b6f52ba" translate="yes" xml:space="preserve">
          <source>Many examples of complete and working loadable extensions can be seen in the SQLite source tree in the &lt;a href=&quot;https://www.sqlite.org/src/file/ext/misc&quot;&gt;ext/misc&lt;/a&gt; subdirectory. Each file in that directory is a separate extension. Documentation is provided by a header comment on the file. Here are brief notes on a few of the extensions in the &lt;a href=&quot;https://www.sqlite.org/src/file/ext/misc&quot;&gt;ext/misc&lt;/a&gt; subdirectory:</source>
          <target state="translated">Многие примеры полных и работающих загружаемых расширений можно увидеть в дереве исходного кода SQLite в подкаталоге &lt;a href=&quot;https://www.sqlite.org/src/file/ext/misc&quot;&gt;ext / misc&lt;/a&gt; . Каждый файл в этом каталоге имеет отдельное расширение. Документация предоставляется в виде комментария к файлу в заголовке. Вот краткие заметки о некоторых расширениях в подкаталоге &lt;a href=&quot;https://www.sqlite.org/src/file/ext/misc&quot;&gt;ext / misc&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="c27368aaf7a63c4c54dd85e130e6a371a0b652db" translate="yes" xml:space="preserve">
          <source>Many improvements and cleanups to the configure script</source>
          <target state="translated">Множество улучшений и чисток в сценарии настройки</target>
        </trans-unit>
        <trans-unit id="478a301b607ffcc6373478ce0ad5e01e286e6440" translate="yes" xml:space="preserve">
          <source>Many improvements and enhancements to the shell.</source>
          <target state="translated">Множество усовершенствований и улучшений в корпусе.</target>
        </trans-unit>
        <trans-unit id="86f119ce378fd6fb5c391277ea97047cef855bbe" translate="yes" xml:space="preserve">
          <source>Many improvements to the test suite. Test coverage now exceeded 98%</source>
          <target state="translated">Множество улучшений в тестовом комплекте.Покрытие теста теперь превысило 98%</target>
        </trans-unit>
        <trans-unit id="ec9cc9f8a731e2c88a6a0e04dca8da72cc53d489" translate="yes" xml:space="preserve">
          <source>Many micro-optimizations result in 20.3% more work for the same number of CPU cycles relative to the previous release. The cumulative performance increase since &lt;a href=&quot;#version_3_8_0&quot;&gt;version 3.8.0&lt;/a&gt; is 61%. (Measured using &lt;a href=&quot;http://valgrind.org/docs/manual/cg-manual.html&quot;&gt;cachegrind&lt;/a&gt; on the &lt;a href=&quot;http://www.sqlite.org/src/artifact/83f6b3318f7ee&quot;&gt;speedtest1.c&lt;/a&gt; workload on Ubuntu 13.10 x64 with gcc 4.8.1 and -Os. Your performance may vary.)</source>
          <target state="translated">Многие микрооптимизации приводят к увеличению объема работы на 20,3% при том же количестве циклов процессора по сравнению с предыдущим выпуском. Совокупное увеличение производительности с &lt;a href=&quot;#version_3_8_0&quot;&gt;версии 3.8.0&lt;/a&gt; составляет 61%. (Измерено с помощью &lt;a href=&quot;http://valgrind.org/docs/manual/cg-manual.html&quot;&gt;cachegrind&lt;/a&gt; на рабочей нагрузке &lt;a href=&quot;http://www.sqlite.org/src/artifact/83f6b3318f7ee&quot;&gt;speedtest1.c&lt;/a&gt; в Ubuntu 13.10 x64 с gcc 4.8.1 и -Os. Ваша производительность может отличаться.)</target>
        </trans-unit>
        <trans-unit id="1070ccc184f5ee6e5132e8f78957c23f5d18aeb1" translate="yes" xml:space="preserve">
          <source>Many micro-optimizations, resulting in a library that is faster than the previous release.</source>
          <target state="translated">Множество микро-оптимизаций,в результате чего библиотека быстрее предыдущего релиза.</target>
        </trans-unit>
        <trans-unit id="ef73d713f7e1172e113f066199b34719f6daec88" translate="yes" xml:space="preserve">
          <source>Many minor bug fixes</source>
          <target state="translated">Множество мелких исправлений</target>
        </trans-unit>
        <trans-unit id="d82e20d7c9c34c867cdbaaabca856ec1debc82ea" translate="yes" xml:space="preserve">
          <source>Many nuisance bugs fixed.</source>
          <target state="translated">Исправлено много неприятных ошибок.</target>
        </trans-unit>
        <trans-unit id="58cc54792f79ad7e4a6c20e286dbf7226ea88ce5" translate="yes" xml:space="preserve">
          <source>Many of the routines in the SQLite &lt;a href=&quot;c3ref/intro&quot;&gt;C-language Interface&lt;/a&gt; return numeric result codes indicating either success or failure, and in the event of a failure, providing some idea of the cause of the failure. This document strives to explain what each of those numeric result codes means.</source>
          <target state="translated">Многие подпрограммы в &lt;a href=&quot;c3ref/intro&quot;&gt;интерфейсе на языке C&lt;/a&gt; SQLite возвращают числовые коды результатов, указывающие на успех или неудачу, а в случае неудачи - на некоторое представление о причине сбоя. В этом документе делается попытка объяснить, что означает каждый из этих числовых кодов результатов.</target>
        </trans-unit>
        <trans-unit id="684a0cdf6fba65d365077c8562625db95e85aea3" translate="yes" xml:space="preserve">
          <source>Many operations, especially I/O intensive operations, can be faster since content does need to be copied between kernel space and user space.</source>
          <target state="translated">Многие операции,особенно интенсивные операции ввода/вывода,могут быть более быстрыми,так как содержимое необходимо копировать между пространством ядра и пространством пользователя.</target>
        </trans-unit>
        <trans-unit id="e75f87ad413b2b989beb9904a93bbc6902b68acd" translate="yes" xml:space="preserve">
          <source>Many programs use &lt;a href=&quot;http://man.he.net/man3/fopen&quot;&gt;fopen()&lt;/a&gt;, &lt;a href=&quot;http://man.he.net/man3/fread&quot;&gt;fread()&lt;/a&gt;, and &lt;a href=&quot;http://man.he.net/man3/fwrite&quot;&gt;fwrite()&lt;/a&gt; to create and manage files of data in home-grown formats. SQLite works particularly well as a replacement for these</source>
          <target state="translated">Многие программы используют &lt;a href=&quot;http://man.he.net/man3/fopen&quot;&gt;fopen ()&lt;/a&gt; , &lt;a href=&quot;http://man.he.net/man3/fread&quot;&gt;fread ()&lt;/a&gt; и &lt;a href=&quot;http://man.he.net/man3/fwrite&quot;&gt;fwrite ()&lt;/a&gt; для создания файлов данных в собственных форматах и ​​управления ими. SQLite особенно хорошо работает в качестве замены этих</target>
        </trans-unit>
        <trans-unit id="58c8d3506d92b491bec9b8982cb696fb925723f6" translate="yes" xml:space="preserve">
          <source>Many readers have recommended various third-party GUIs for Git that might do a better job of showing historical development activity. Maybe some of them do work better than native Git and/or GitHub, though they will all be hampered by the fact that Git does not preserve historical branch names across syncs. And even if those other tools are better, the fact that it is necessary to go to a third-party tool to get the information desired does not speak well of the core system.</source>
          <target state="translated">Многие читатели рекомендовали различные графические интерфейсы сторонних разработчиков для Git'а,которые могли бы лучше показать историческую активность в развитии.Может быть,некоторые из них работают лучше,чем родные Git и/или GitHub,хотя им всем будет мешать тот факт,что Git не сохраняет исторические названия ветвей через синхронизацию.И даже если эти другие инструменты лучше,тот факт,что для получения желаемой информации нужно обратиться к стороннему инструменту,не очень хорошо говорит о системе ядра.</target>
        </trans-unit>
        <trans-unit id="57a3139bc8f04dd188f9b7807c96ec2f953e86dc" translate="yes" xml:space="preserve">
          <source>Many small performance optimizations.</source>
          <target state="translated">Множество небольших оптимизаций производительности.</target>
        </trans-unit>
        <trans-unit id="575ebc9be57deafee12eee1cb275aca14943f68c" translate="yes" xml:space="preserve">
          <source>Many, many bug fixes and compatibility enhancements.</source>
          <target state="translated">Многие,многие исправления ошибок и улучшения совместимости.</target>
        </trans-unit>
        <trans-unit id="305801fe337dfa5f8bad0f9f9e15662ddae791a8" translate="yes" xml:space="preserve">
          <source>Many, many minor bug fixes and documentation updates.</source>
          <target state="translated">Много,много мелких исправлений и обновлений документации.</target>
        </trans-unit>
        <trans-unit id="35ddb236d4c17515cfe7146a42b5a461cee3e50c" translate="yes" xml:space="preserve">
          <source>Master Journal Pointer</source>
          <target state="translated">Мастер-Журнал Указка</target>
        </trans-unit>
        <trans-unit id="9abc1c7f8fc32d4d49746263693941601091cb5d" translate="yes" xml:space="preserve">
          <source>Master journal</source>
          <target state="translated">Мастер-журнал</target>
        </trans-unit>
        <trans-unit id="cb9cc1ceef6f81a9f36806b03b083dc9a2408c5e" translate="yes" xml:space="preserve">
          <source>Master journals</source>
          <target state="translated">магистрские журналы</target>
        </trans-unit>
        <trans-unit id="7b5111bfd1045a8ecdd3554c1e9631c35ec01ef6" translate="yes" xml:space="preserve">
          <source>Matches if both query1 and query2 match.</source>
          <target state="translated">Сопоставляется,если оба запроса1 и запрос2 совпадают.</target>
        </trans-unit>
        <trans-unit id="1abd40ea027c30a30c262947ec1298a0d519b4e6" translate="yes" xml:space="preserve">
          <source>Matches if either query1 or query2 match.</source>
          <target state="translated">Сопоставляется,если запрос1 или запрос2 совпадает.</target>
        </trans-unit>
        <trans-unit id="51cd172796c27ae8bf6aa95066f1e3c65189a939" translate="yes" xml:space="preserve">
          <source>Matches if query1 matches and query2 does not match.</source>
          <target state="translated">Совпадает,если запрос1 совпадает,а запрос2-нет.</target>
        </trans-unit>
        <trans-unit id="bd5c38104019f7a3a298ccf7253423afa28167b4" translate="yes" xml:space="preserve">
          <source>Matchinfo b flag</source>
          <target state="translated">Флаг Матчинфо b</target>
        </trans-unit>
        <trans-unit id="c836afd188ddb1668f2e9e6d198ffaad1a60d7a2" translate="yes" xml:space="preserve">
          <source>Matchinfo x flag</source>
          <target state="translated">флаг Matchinfo x</target>
        </trans-unit>
        <trans-unit id="1cd52c33bad6e28fab493f91164add2569119727" translate="yes" xml:space="preserve">
          <source>Matchinfo y flag</source>
          <target state="translated">Матчинфо и флаг</target>
        </trans-unit>
        <trans-unit id="eba78e6ccaca884931e9772ee282f8ff7b915236" translate="yes" xml:space="preserve">
          <source>Materializations of views and subqueries</source>
          <target state="translated">Материализации представлений и подзапросов</target>
        </trans-unit>
        <trans-unit id="b44a1f3f0332ddaecfe37d45239aca1621b1d815" translate="yes" xml:space="preserve">
          <source>Mathematical operators (+, -, *, /, %, &amp;lt;&amp;lt;, &amp;gt;&amp;gt;, &amp;amp;, and |) interpret both operands as if they were numbers. STRING or BLOB operands automatically convert into REAL or INTEGER values. If the STRING or BLOB looks like a real number (if it has a decimal point or an exponent) or if the value is outside the range that can be represented as a 64-bit signed integer, then it converts to REAL. Otherwise the operand converts to INTEGER. The implied type conversion of mathematical operands is slightly different from &lt;a href=&quot;lang_expr#castexpr&quot;&gt;CAST to NUMERIC&lt;/a&gt; in that string and BLOB values that look like real numbers but have no fractional part are kept as REAL instead of being converted into INTEGER as they would be for &lt;a href=&quot;lang_expr#castexpr&quot;&gt;CAST to NUMERIC&lt;/a&gt;. The conversion from STRING or BLOB into REAL or INTEGER is performed even if it is lossy and irreversible. Some mathematical operators (%, &amp;lt;&amp;lt;, &amp;gt;&amp;gt;, &amp;amp;, and |) expect INTEGER operands. For those operators, REAL operands are converted into INTEGER in the same way as a &lt;a href=&quot;lang_expr#castexpr&quot;&gt;CAST to INTEGER&lt;/a&gt;. The &amp;lt;&amp;lt;, &amp;gt;&amp;gt;, &amp;amp;, and | operators always return an INTEGER (or NULL) result, but the % operator returns either INTEGER or REAL (or NULL) depending on the type of its operands. A NULL operand on a mathematical operator yields a NULL result. An operand on a mathematical operator that does not look in any way numeric and is not NULL is converted to 0 or 0.0. Division by zero gives a result of NULL.</source>
          <target state="translated">Математические операторы (+, -, *, /,%, &amp;lt;&amp;lt;, &amp;gt;&amp;gt;, &amp;amp; и |) интерпретируют оба операнда, как если бы они были числами. Операнды STRING или BLOB автоматически преобразуются в значения REAL или INTEGER. Если СТРОКА или BLOB выглядит как вещественное число (если оно имеет десятичную точку или показатель степени) или если значение выходит за пределы диапазона, который может быть представлен как 64-битное целое число со знаком, то оно преобразуется в REAL. В противном случае операнд преобразуется в INTEGER. Подразумеваемое преобразование типов математических операндов немного отличается от &lt;a href=&quot;lang_expr#castexpr&quot;&gt;CAST в NUMERIC&lt;/a&gt; в этой строке, а значения BLOB, которые выглядят как действительные числа, но не имеют дробной части, сохраняются как REAL вместо преобразования в INTEGER, как это было бы для &lt;a href=&quot;lang_expr#castexpr&quot;&gt;CAST to NUMERIC&lt;/a&gt;. Преобразование из STRING или BLOB в REAL или INTEGER выполняется, даже если оно необратимо и с потерями. Некоторые математические операторы (%, &amp;lt;&amp;lt;, &amp;gt;&amp;gt;, &amp;amp; и |) ожидают операнды INTEGER. Для этих операторов операнды REAL преобразуются в INTEGER так же, как &lt;a href=&quot;lang_expr#castexpr&quot;&gt;CAST в INTEGER&lt;/a&gt; . &amp;lt;&amp;lt;, &amp;gt;&amp;gt;, &amp;amp; и | операторы всегда возвращают результат INTEGER (или NULL), но оператор% возвращает INTEGER или REAL (или NULL) в зависимости от типа его операндов. Операнд NULL в математическом операторе дает результат NULL. Операнд математического оператора, который никоим образом не выглядит числовым и не имеет значения NULL, преобразуется в 0 или 0,0. Деление на ноль дает результат NULL.</target>
        </trans-unit>
        <trans-unit id="1d9b8da2be0b14b678f29575b8bd5d6d1b4664b6" translate="yes" xml:space="preserve">
          <source>MaxPgcnt</source>
          <target state="translated">MaxPgcnt</target>
        </trans-unit>
        <trans-unit id="6cf7147e1932d9bf8b6d38604abfcfd205a85da8" translate="yes" xml:space="preserve">
          <source>Maximum embedded payload fraction. Must be 64.</source>
          <target state="translated">Максимальная встроенная доля полезной нагрузки.Должно быть 64.</target>
        </trans-unit>
        <trans-unit id="24d9373f317266755bd6dbb0fc6450a4905171c2" translate="yes" xml:space="preserve">
          <source>Maximum rowid</source>
          <target state="translated">Максимальный ряд</target>
        </trans-unit>
        <trans-unit id="5bc432c657fe4144bd45d936698c166acecd18fa" translate="yes" xml:space="preserve">
          <source>Maximum xShmLock index</source>
          <target state="translated">Максимальный индекс xShmLock</target>
        </trans-unit>
        <trans-unit id="77e5adb0194b8d8026832696c1f2c7818741ee2e" translate="yes" xml:space="preserve">
          <source>Maxopen parameter</source>
          <target state="translated">Макс.значение параметра</target>
        </trans-unit>
        <trans-unit id="0cccb688a9f1ffa766c4517a7aa3af7c04fd578c" translate="yes" xml:space="preserve">
          <source>May you do good and not evil</source>
          <target state="translated">Пусть ты делаешь добро,а не зло.</target>
        </trans-unit>
        <trans-unit id="8b1b4d5262b0d017f35623d6ebe39d0b87517497" translate="yes" xml:space="preserve">
          <source>May you find forgiveness for yourself and forgive others</source>
          <target state="translated">Пусть ты найдешь прощение для себя и простишь других.</target>
        </trans-unit>
        <trans-unit id="580b0f5d2afa3fc028fd1cbe9832972ae188e8d2" translate="yes" xml:space="preserve">
          <source>May you share freely, never taking more than you give.</source>
          <target state="translated">Пусть ты делишься свободно,никогда не беря больше,чем даешь.</target>
        </trans-unit>
        <trans-unit id="19cd7d185cfd95a703e62d43597e9ae28e0646e5" translate="yes" xml:space="preserve">
          <source>Meaning</source>
          <target state="translated">Meaning</target>
        </trans-unit>
        <trans-unit id="4916cdca74bd290a34e18174e1358515f2ca12e0" translate="yes" xml:space="preserve">
          <source>Measure the performance for reading blobs from the database and from individual files using these commands:</source>
          <target state="translated">Измерьте производительность для чтения блоков из базы данных и из отдельных файлов с помощью этих команд:</target>
        </trans-unit>
        <trans-unit id="32d3f574c379f02e466ab9d634b2afa7cedf3a39" translate="yes" xml:space="preserve">
          <source>Measure write performance by adding the --update option. This causes the blobs are overwritten in place with another random blob of exactly the same size.</source>
          <target state="translated">Измерьте производительность записи,добавив опцию -update.Это приводит к тому,что капли перезаписываются на месте другим случайным блоком точно такого же размера.</target>
        </trans-unit>
        <trans-unit id="f8f8ae177706bfa8cf72569452745c1f4cb10ab6" translate="yes" xml:space="preserve">
          <source>Measured using cachegrind on Ubuntu 16.04 on x64 with gcc 5.4.0 and -Os.</source>
          <target state="translated">Измерено с помощью кэшфренда на Ubuntu 16.04 на x64 с gcc 5.4.0 и -O.</target>
        </trans-unit>
        <trans-unit id="b32c8e35e5b4b276295d8f91c2b0f1620f45e186" translate="yes" xml:space="preserve">
          <source>Measurements above were conducted using SQLite version &lt;a href=&quot;https://sqlite.org/src/timeline?c=5594a121bf132a98&quot;&gt;5594a121bf132a98&lt;/a&gt; from 2017-10-08.</source>
          <target state="translated">Вышеуказанные измерения проводились с использованием SQLite версии &lt;a href=&quot;https://sqlite.org/src/timeline?c=5594a121bf132a98&quot;&gt;5594a121bf132a98&lt;/a&gt; от 08.10.2017.</target>
        </trans-unit>
        <trans-unit id="201062f4cfcc7a2c58dc61b839eac4c989004f31" translate="yes" xml:space="preserve">
          <source>Measuring and Reducing CPU Usage in SQLite</source>
          <target state="translated">Измерение и сокращение использования процессора в SQLite</target>
        </trans-unit>
        <trans-unit id="d815eeb251818f42b639c19483653cb9e9676a23" translate="yes" xml:space="preserve">
          <source>MemMax</source>
          <target state="translated">MemMax</target>
        </trans-unit>
        <trans-unit id="57b0394c856fac60e784f92bcfff68951cf81266" translate="yes" xml:space="preserve">
          <source>Memory Allocation Routines</source>
          <target state="translated">Маршруты распределения памяти</target>
        </trans-unit>
        <trans-unit id="3a30329db6460c4ed15bebe4d427af9052e6678f" translate="yes" xml:space="preserve">
          <source>Memory Allocation Subsystem</source>
          <target state="translated">Подсистема распределения памяти</target>
        </trans-unit>
        <trans-unit id="f5bd12480983914d8406751d31133ba86381302d" translate="yes" xml:space="preserve">
          <source>Memory Allocator Statistics</source>
          <target state="translated">Статистика распределителя памяти</target>
        </trans-unit>
        <trans-unit id="8ee60155b22e766b4de73dc4f683f3ac25fa009b" translate="yes" xml:space="preserve">
          <source>Memory Slot</source>
          <target state="translated">Слот памяти</target>
        </trans-unit>
        <trans-unit id="ea9be83a8f265809341121ab4ff9c58d527a1bdd" translate="yes" xml:space="preserve">
          <source>Memory accounting is disabled using a combination of the &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;#sqliteconfigmemstatus&quot;&gt;SQLITE_CONFIG_MEMSTATUS&lt;/a&gt;,...) start-time option and the &lt;a href=&quot;compile#default_memstatus&quot;&gt;SQLITE_DEFAULT_MEMSTATUS&lt;/a&gt; compile-time option.</source>
          <target state="translated">Учет памяти отключается с помощью комбинации параметра времени начала &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config&lt;/a&gt; ( &lt;a href=&quot;#sqliteconfigmemstatus&quot;&gt;SQLITE_CONFIG_MEMSTATUS&lt;/a&gt; , ...) и параметра &lt;a href=&quot;compile#default_memstatus&quot;&gt;времени&lt;/a&gt; компиляции SQLITE_DEFAULT_MEMSTATUS .</target>
        </trans-unit>
        <trans-unit id="83484b2c23e2c43deda0dd88234486f9158814f3" translate="yes" xml:space="preserve">
          <source>Memory accounting is disabled using a combination of the &lt;a href=&quot;config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c_config_covering_index_scan#sqliteconfigmemstatus&quot;&gt;SQLITE_CONFIG_MEMSTATUS&lt;/a&gt;,...) start-time option and the &lt;a href=&quot;../compile#default_memstatus&quot;&gt;SQLITE_DEFAULT_MEMSTATUS&lt;/a&gt; compile-time option.</source>
          <target state="translated">Учет памяти отключается с помощью комбинации параметра времени начала &lt;a href=&quot;config&quot;&gt;sqlite3_config&lt;/a&gt; ( &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigmemstatus&quot;&gt;SQLITE_CONFIG_MEMSTATUS&lt;/a&gt; , ...) и параметра &lt;a href=&quot;../compile#default_memstatus&quot;&gt;времени&lt;/a&gt; компиляции SQLITE_DEFAULT_MEMSTATUS .</target>
        </trans-unit>
        <trans-unit id="c90d2f9e1fbdf5d88900e51c0817d79397425f44" translate="yes" xml:space="preserve">
          <source>Memory allocation statistics are enabled by default unless SQLite is compiled with &lt;a href=&quot;../compile#default_memstatus&quot;&gt;SQLITE_DEFAULT_MEMSTATUS&lt;/a&gt;=0 in which case memory allocation statistics are disabled by default.</source>
          <target state="translated">Статистика выделения памяти включена по умолчанию, если SQLite не скомпилирован с &lt;a href=&quot;../compile#default_memstatus&quot;&gt;SQLITE_DEFAULT_MEMSTATUS&lt;/a&gt; = 0, и в этом случае статистика выделения памяти отключена по умолчанию.</target>
        </trans-unit>
        <trans-unit id="36fecd267945c46262e4527e9008734a419499a2" translate="yes" xml:space="preserve">
          <source>Memory allocation statistics are enabled by default unless SQLite is compiled with &lt;a href=&quot;compile#default_memstatus&quot;&gt;SQLITE_DEFAULT_MEMSTATUS&lt;/a&gt;=0 in which case memory allocation statistics are disabled by default.</source>
          <target state="translated">Статистика выделения памяти включена по умолчанию, если SQLite не скомпилирован с &lt;a href=&quot;compile#default_memstatus&quot;&gt;SQLITE_DEFAULT_MEMSTATUS&lt;/a&gt; = 0, и в этом случае статистика выделения памяти отключена по умолчанию.</target>
        </trans-unit>
        <trans-unit id="30cf1b800d03b60f9a295eac5e3ee911eb40a567" translate="yes" xml:space="preserve">
          <source>Memory allocation, caseless string comparison routines, portable text-to-number conversion routines, and other utilities are located in &lt;a href=&quot;https://sqlite.org/src/file/src/util.c&quot;&gt;util.c&lt;/a&gt;. Symbol tables used by the parser are maintained by hash tables found in &lt;a href=&quot;https://sqlite.org/src/file/src/hash.c&quot;&gt;hash.c&lt;/a&gt;. The &lt;a href=&quot;https://sqlite.org/src/file/src/utf.c&quot;&gt;utf.c&lt;/a&gt; source file contains Unicode conversion subroutines. SQLite has its own private implementation of &lt;a href=&quot;printf&quot;&gt;printf()&lt;/a&gt; (with some extensions) in &lt;a href=&quot;https://sqlite.org/src/file/src/printf.c&quot;&gt;printf.c&lt;/a&gt; and its own pseudo-random number generator (PRNG) in &lt;a href=&quot;https://sqlite.org/src/file/src/random.c&quot;&gt;random.c&lt;/a&gt;.</source>
          <target state="translated">Распределение памяти, подпрограммы сравнения строк без корпуса, портативные процедуры преобразования текста в номер и другие коммунальные услуги находятся в &lt;a href=&quot;https://sqlite.org/src/file/src/util.c&quot;&gt;util.c&lt;/a&gt; . Символ таблица , используемый анализатор поддерживается хэш - таблицами , найденных в &lt;a href=&quot;https://sqlite.org/src/file/src/hash.c&quot;&gt;hash.c&lt;/a&gt; . &lt;a href=&quot;https://sqlite.org/src/file/src/utf.c&quot;&gt;Utf.c&lt;/a&gt; исходный файл содержит подпрограммы преобразования Unicode. SQLite имеет собственную частную реализацию &lt;a href=&quot;printf&quot;&gt;printf ()&lt;/a&gt; (с некоторыми расширениями) в &lt;a href=&quot;https://sqlite.org/src/file/src/printf.c&quot;&gt;printf.c&lt;/a&gt; и собственный генератор псевдослучайных чисел (PRNG) в &lt;a href=&quot;https://sqlite.org/src/file/src/random.c&quot;&gt;random.c&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8351f935d7e0b92d4dbd88ff6014fc3cfebc6b06" translate="yes" xml:space="preserve">
          <source>Memory statistics</source>
          <target state="translated">Статистика памяти</target>
        </trans-unit>
        <trans-unit id="0b3951c84915f2636f64c4da056f2bbaa63121ac" translate="yes" xml:space="preserve">
          <source>Memory to hold the information returned by &lt;b&gt;sqlite_get_table&lt;/b&gt; is obtained from malloc(). But the calling function should not try to free this information directly. Instead, pass the complete table to &lt;b&gt;sqlite_free_table&lt;/b&gt; when the table is no longer needed. It is safe to call &lt;b&gt;sqlite_free_table&lt;/b&gt; with a NULL pointer such as would be returned if the result set is empty.</source>
          <target state="translated">Память для хранения информации, возвращаемой &lt;b&gt;sqlite_get_table&lt;/b&gt; , получается из malloc (). Но вызывающая функция не должна пытаться напрямую освободить эту информацию. Вместо этого передайте всю таблицу в &lt;b&gt;sqlite_free_table,&lt;/b&gt; когда таблица больше не нужна. Можно безопасно вызывать &lt;b&gt;sqlite_free_table&lt;/b&gt; с указателем NULL, который будет возвращен, если набор результатов пуст.</target>
        </trans-unit>
        <trans-unit id="0ebf6aa26b7b4fd9c6127be506bafbc4c2292df8" translate="yes" xml:space="preserve">
          <source>Memory-Mapped I/O</source>
          <target state="translated">Память-отображенные входы/выходы</target>
        </trans-unit>
        <trans-unit id="7640161f9a59fd693f768ecd9272e3177311b46c" translate="yes" xml:space="preserve">
          <source>Memsys4 and memsys6 were experimental memory allocators introduced in around 2007 and subsequently removed from the source tree in around 2008, after it became clear that they added no new value.</source>
          <target state="translated">Memsys4 и memsys6 были экспериментальными аллокаторами памяти,введенными примерно в 2007 году,а затем удаленными из дерева исходных текстов примерно в 2008 году,после того,как стало ясно,что они не добавили никакой новой ценности.</target>
        </trans-unit>
        <trans-unit id="53e5e9eaf00f6f480e84b07b830bf50ed69b3504" translate="yes" xml:space="preserve">
          <source>Merge development changes into the main trunk. Future work toward using a BTree file structure will use a separate CVS source tree. This CVS tree will continue to support the GDBM version of SQLite only.</source>
          <target state="translated">Объедините изменения развития в основной ствол.В дальнейшей работе по использованию файловой структуры BTree будет использоваться отдельное дерево исходников CVS.Это CVS-дерево будет продолжать поддерживать только GDBM-версию SQLite.</target>
        </trans-unit>
        <trans-unit id="1c69f87311ee49961b7db4c6959bf9e564173753" translate="yes" xml:space="preserve">
          <source>MergePatch can add, modify, or delete elements of a JSON Object, and so for JSON Objects, the json_patch() routine is a generalized replacement for &lt;a href=&quot;json1#jset&quot;&gt;json_set()&lt;/a&gt; and &lt;a href=&quot;json1#jrm&quot;&gt;json_remove()&lt;/a&gt;. However, MergePatch treats JSON Array objects as atomic. MergePatch cannot append to an Array nor modify individual elements of an Array. It can only insert, replace, or delete the whole Array as a single unit. Hence, json_patch() is not as useful when dealing with JSON that includes Arrays, especially Arrays with lots of substructure.</source>
          <target state="translated">MergePatch может добавлять, изменять или удалять элементы объекта JSON, поэтому для объектов JSON процедура json_patch () является обобщенной заменой для &lt;a href=&quot;json1#jset&quot;&gt;json_set ()&lt;/a&gt; и &lt;a href=&quot;json1#jrm&quot;&gt;json_remove ()&lt;/a&gt; . Однако MergePatch рассматривает объекты JSON Array как атомарные. MergePatch не может добавлять в массив или изменять отдельные элементы массива. Он может вставлять, заменять или удалять только весь массив как единое целое. Следовательно, json_patch () не так полезен при работе с JSON, который включает в себя массивы, особенно массивы с большим количеством подструктур.</target>
        </trans-unit>
        <trans-unit id="b34856a8252222662370c82e139676a40460db4d" translate="yes" xml:space="preserve">
          <source>Merged the &lt;a href=&quot;sessionintro&quot;&gt;session&lt;/a&gt; extension into trunk.</source>
          <target state="translated">Слил расширение &lt;a href=&quot;sessionintro&quot;&gt;сеанса&lt;/a&gt; в транк.</target>
        </trans-unit>
        <trans-unit id="dbaecd82c952801d0bb82c4bd7a41de66b9fda44" translate="yes" xml:space="preserve">
          <source>Metadata is returned by writing to the memory locations passed as the 5th and subsequent parameters to this function. Any of these arguments may be NULL, in which case the corresponding element of metadata is omitted.</source>
          <target state="translated">Метаданные возвращаются путем записи в ячейки памяти,переданные в качестве 5-го и последующих параметров этой функции.Любой из этих аргументов может быть NULL,в этом случае соответствующий элемент метаданных опускается.</target>
        </trans-unit>
        <trans-unit id="4d3732872bb2a9906cc1153aeb2590dd048c19aa" translate="yes" xml:space="preserve">
          <source>Method (2) offers a midpoint between (1) and (3). Using this method, a query such as '1s*' will match documents that contain the literal token &quot;1st&quot;, but not &quot;first&quot; (assuming the tokenizer is not able to provide synonyms for prefixes). However, a non-prefix query like '1st' will match against &quot;1st&quot; and &quot;first&quot;. This method does not require extra disk space, as no extra entries are added to the FTS index. On the other hand, it may require more CPU cycles to run MATCH queries, as separate queries of the FTS index are required for each synonym.</source>
          <target state="translated">Метод (2)предлагает среднюю точку между (1)и (3).При использовании этого метода запрос типа '1s*' будет сопоставлять документы,содержащие буквальную лексель &quot;1&quot;,но не &quot;первый&quot; (в предположении,что токенайзер не может предоставить синонимов для префиксов).Однако,не префиксный запрос типа '1' будет совпадать с &quot;1&quot; и &quot;первым&quot;.Этот метод не требует дополнительного дискового пространства,так как в индекс FTS не добавляются дополнительные записи.С другой стороны,для выполнения MATCH-запросов может потребоваться большее количество циклов процессора,так как для каждого синонима требуется отдельный запрос индекса FTS.</target>
        </trans-unit>
        <trans-unit id="1df213a45649b1f66258f5768182bafcd559f0b9" translate="yes" xml:space="preserve">
          <source>Methods: &lt;a href=&quot;#sqlite3_blob_bytes&quot;&gt;sqlite3_blob_bytes()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_blob_read&quot;&gt;sqlite3_blob_read()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_blob_reopen&quot;&gt;sqlite3_blob_reopen()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_blob_write&quot;&gt;sqlite3_blob_write()&lt;/a&gt;</source>
          <target state="translated">Методы: &lt;a href=&quot;#sqlite3_blob_bytes&quot;&gt;sqlite3_blob_bytes ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_blob_read&quot;&gt;sqlite3_blob_read ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_blob_reopen&quot;&gt;sqlite3_blob_reopen ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_blob_write&quot;&gt;sqlite3_blob_write ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1b9983b06e527d46d817373bc15d13089f4d3e12" translate="yes" xml:space="preserve">
          <source>Methods: &lt;a href=&quot;#sqlite3_snapshot_cmp&quot;&gt;sqlite3_snapshot_cmp()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_snapshot_open&quot;&gt;sqlite3_snapshot_open()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_snapshot_recover&quot;&gt;sqlite3_snapshot_recover()&lt;/a&gt;</source>
          <target state="translated">Методы: &lt;a href=&quot;#sqlite3_snapshot_cmp&quot;&gt;sqlite3_snapshot_cmp ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_snapshot_open&quot;&gt;sqlite3_snapshot_open ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_snapshot_recover&quot;&gt;sqlite3_snapshot_recover ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="547fb3fd92f4ba766d2b81080903dd2fa70ddd7a" translate="yes" xml:space="preserve">
          <source>Methods: &lt;a href=&quot;#sqlite3changegroup_add&quot;&gt;sqlite3changegroup_add()&lt;/a&gt;, &lt;a href=&quot;#sqlite3changegroup_output&quot;&gt;sqlite3changegroup_output()&lt;/a&gt;</source>
          <target state="translated">Методы: &lt;a href=&quot;#sqlite3changegroup_add&quot;&gt;sqlite3changegroup_add ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3changegroup_output&quot;&gt;sqlite3changegroup_output ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5ba8e151eaa184a6fb4bcf2ae01f52e3682b9b04" translate="yes" xml:space="preserve">
          <source>Methods: &lt;a href=&quot;blob_bytes&quot;&gt;sqlite3_blob_bytes()&lt;/a&gt;, &lt;a href=&quot;blob_read&quot;&gt;sqlite3_blob_read()&lt;/a&gt;, &lt;a href=&quot;blob_reopen&quot;&gt;sqlite3_blob_reopen()&lt;/a&gt;, &lt;a href=&quot;blob_write&quot;&gt;sqlite3_blob_write()&lt;/a&gt;</source>
          <target state="translated">Методы: &lt;a href=&quot;blob_bytes&quot;&gt;sqlite3_blob_bytes ()&lt;/a&gt; , &lt;a href=&quot;blob_read&quot;&gt;sqlite3_blob_read ()&lt;/a&gt; , &lt;a href=&quot;blob_reopen&quot;&gt;sqlite3_blob_reopen ()&lt;/a&gt; , &lt;a href=&quot;blob_write&quot;&gt;sqlite3_blob_write ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="05bb53e8fd80fd00914dd4034f12bb335994738a" translate="yes" xml:space="preserve">
          <source>Methods: &lt;a href=&quot;snapshot_cmp&quot;&gt;sqlite3_snapshot_cmp()&lt;/a&gt;, &lt;a href=&quot;snapshot_open&quot;&gt;sqlite3_snapshot_open()&lt;/a&gt;, &lt;a href=&quot;snapshot_recover&quot;&gt;sqlite3_snapshot_recover()&lt;/a&gt;</source>
          <target state="translated">Методы: &lt;a href=&quot;snapshot_cmp&quot;&gt;sqlite3_snapshot_cmp ()&lt;/a&gt; , &lt;a href=&quot;snapshot_open&quot;&gt;sqlite3_snapshot_open ()&lt;/a&gt; , &lt;a href=&quot;snapshot_recover&quot;&gt;sqlite3_snapshot_recover ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="80b86f6f0bb9183c80c83fe634331b034c5a3b6c" translate="yes" xml:space="preserve">
          <source>Methods: &lt;a href=&quot;sqlite3changegroup_add&quot;&gt;sqlite3changegroup_add()&lt;/a&gt;, &lt;a href=&quot;sqlite3changegroup_output&quot;&gt;sqlite3changegroup_output()&lt;/a&gt;</source>
          <target state="translated">Методы: &lt;a href=&quot;sqlite3changegroup_add&quot;&gt;sqlite3changegroup_add ()&lt;/a&gt; , &lt;a href=&quot;sqlite3changegroup_output&quot;&gt;sqlite3changegroup_output ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="91126b8550d89c2cabd56ad5c8ea6415436ef4e7" translate="yes" xml:space="preserve">
          <source>Millions and millions of test cases</source>
          <target state="translated">Миллионы и миллионы тестовых случаев</target>
        </trans-unit>
        <trans-unit id="8cb901663cd153748076b7a4eed655ac9c9ceb63" translate="yes" xml:space="preserve">
          <source>Minimum embedded payload fraction. Must be 32.</source>
          <target state="translated">Минимальная встроенная доля полезной нагрузки.Должно быть 32.</target>
        </trans-unit>
        <trans-unit id="9f5a0ef3646738848b65efb74e98db2b2c5a359b" translate="yes" xml:space="preserve">
          <source>Minimum rowid</source>
          <target state="translated">Минимальный ряд</target>
        </trans-unit>
        <trans-unit id="62a01943e842ea4e97ec6b470d86e59a45ec37a1" translate="yes" xml:space="preserve">
          <source>Minor revisions to the website.</source>
          <target state="translated">Незначительные изменения на сайте.</target>
        </trans-unit>
        <trans-unit id="e2f772b3f3e4226648620e3b2d22fc9e06b7af3b" translate="yes" xml:space="preserve">
          <source>Minor syntactic changes to support a wider variety of compilers.</source>
          <target state="translated">Незначительные синтаксические изменения для поддержки более широкого круга компиляторов.</target>
        </trans-unit>
        <trans-unit id="a207d914072a9004f7af9edb9092f93397750bdb" translate="yes" xml:space="preserve">
          <source>Minor tweaks to other code to make it run a little faster.</source>
          <target state="translated">Незначительные подстройки к другому коду,чтобы заставить его работать немного быстрее.</target>
        </trans-unit>
        <trans-unit id="5f2cbd107037ed23248e5058a7a64cd6bae05468" translate="yes" xml:space="preserve">
          <source>Miscellaneous</source>
          <target state="translated">Miscellaneous</target>
        </trans-unit>
        <trans-unit id="b80fca6a605a77935ff5f5e3122df5de2dfd1555" translate="yes" xml:space="preserve">
          <source>Miscellaneous &lt;a href=&quot;cpu#microopt&quot;&gt;microoptimizations&lt;/a&gt; reduce CPU usage by about 2.1%.</source>
          <target state="translated">Разные &lt;a href=&quot;cpu#microopt&quot;&gt;микрооптимизации&lt;/a&gt; снижают загрузку процессора примерно на 2,1%.</target>
        </trans-unit>
        <trans-unit id="28c8a44394b5bc456bad4c873373e406d652fe87" translate="yes" xml:space="preserve">
          <source>Miscellaneous code size optimizations and bug fixes</source>
          <target state="translated">Различные оптимизации размера кода и исправления ошибок</target>
        </trans-unit>
        <trans-unit id="bbb81db24ef06a2153135306601290fda608c2da" translate="yes" xml:space="preserve">
          <source>Miscellaneous documentation enhancements.</source>
          <target state="translated">Различные улучшения в документации.</target>
        </trans-unit>
        <trans-unit id="98990a8e0a243a1fdf56c721a0da9558936ac95e" translate="yes" xml:space="preserve">
          <source>Miscellaneous micro-optimizations reduce CPU usage by more than 7% on common workloads. Most optimization in this release has been on the front-end (&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt;).</source>
          <target state="translated">Разные микрооптимизации снижают использование ЦП более чем на 7% при обычных рабочих нагрузках. Большая часть оптимизации в этом выпуске была &lt;a href=&quot;c3ref/prepare&quot;&gt;сделана во внешнем&lt;/a&gt; интерфейсе ( sqlite3_prepare_v2 () ).</target>
        </trans-unit>
        <trans-unit id="fbdfeb6f538d5f7f87b9990239ba0793588dd6eb" translate="yes" xml:space="preserve">
          <source>Miscellaneous micro-optimizations result in 22.3% more work for the same number of CPU cycles relative to the previous release. SQLite now runs twice as fast as &lt;a href=&quot;#version_3_8_0&quot;&gt;version 3.8.0&lt;/a&gt; and three times as fast as &lt;a href=&quot;#version_3_3_9&quot;&gt;version 3.3.9&lt;/a&gt;. (Measured using &lt;a href=&quot;http://valgrind.org/docs/manual/cg-manual.html&quot;&gt;cachegrind&lt;/a&gt; on the &lt;a href=&quot;http://www.sqlite.org/src/artifact/83f6b3318f7ee&quot;&gt;speedtest1.c&lt;/a&gt; workload on Ubuntu 14.04 x64 with gcc 4.8.2 and -Os. Your performance may vary.)</source>
          <target state="translated">Различные микрооптимизации приводят к увеличению объема работы на 22,3% при том же количестве циклов процессора по сравнению с предыдущим выпуском. SQLite теперь работает в два раза быстрее, чем &lt;a href=&quot;#version_3_8_0&quot;&gt;версия 3.8.0,&lt;/a&gt; и в три раза быстрее, чем &lt;a href=&quot;#version_3_3_9&quot;&gt;версия 3.3.9&lt;/a&gt; . (Измерено с помощью &lt;a href=&quot;http://valgrind.org/docs/manual/cg-manual.html&quot;&gt;cachegrind&lt;/a&gt; на рабочей нагрузке &lt;a href=&quot;http://www.sqlite.org/src/artifact/83f6b3318f7ee&quot;&gt;speedtest1.c&lt;/a&gt; в Ubuntu 14.04 x64 с gcc 4.8.2 и -Os. Ваша производительность может отличаться.)</target>
        </trans-unit>
        <trans-unit id="fc459de1c05b709bda425ad3c5816738720eebc5" translate="yes" xml:space="preserve">
          <source>Miscellaneous minor bug fixes</source>
          <target state="translated">Различные мелкие исправления ошибок</target>
        </trans-unit>
        <trans-unit id="44d1c5c9aa54a9db91e7e7fe347ac18190d724ed" translate="yes" xml:space="preserve">
          <source>Miscellaneous optimizations result in a 2% reduction in &lt;a href=&quot;cpu&quot;&gt;CPU cycles used&lt;/a&gt;.</source>
          <target state="translated">Различные оптимизации приводят к сокращению &lt;a href=&quot;cpu&quot;&gt;используемых циклов процессора&lt;/a&gt; на 2% .</target>
        </trans-unit>
        <trans-unit id="f1774acabb62d5801f41470f6cd189b2c0aaaf3c" translate="yes" xml:space="preserve">
          <source>Miscellaneous performance enhancements</source>
          <target state="translated">Различные способы повышения эффективности</target>
        </trans-unit>
        <trans-unit id="276e26893215e7c8d37e726040961fa631182ebb" translate="yes" xml:space="preserve">
          <source>Miscellaneous problem words such as &quot;debt&quot;, &quot;tsetse&quot;, &quot;Nguyen&quot;, &quot;Van Nuyes&quot;.</source>
          <target state="translated">Различные проблемные слова,такие как &quot;долг&quot;,&quot;цецеце&quot;,&quot;Нгуен&quot;,&quot;Ван Нюэс&quot;.</target>
        </trans-unit>
        <trans-unit id="4f0711bb69728ffde416a549e0f91f702e273516" translate="yes" xml:space="preserve">
          <source>Misformatted records</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c46987b5699d45998eb4a1f03a81d222b78e342" translate="yes" xml:space="preserve">
          <source>Missing callback</source>
          <target state="translated">Пропущенный обратный звонок</target>
        </trans-unit>
        <trans-unit id="55fd1e5df760c82f67c5509ea619f439d18e5b37" translate="yes" xml:space="preserve">
          <source>Missing or surplus index entries</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96732b61a8d377ada7b914c38aba1cf0d28297dd" translate="yes" xml:space="preserve">
          <source>Missing pages</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1570b7a7267e412717981829df93815ef1f5214" translate="yes" xml:space="preserve">
          <source>Modern filesystems operate faster when disk accesses are sequential. Hence, SQLite will run faster if the content of the database file is on sequential pages. To find out what fraction of the pages in a database are sequential (and thus obtain a measurement that might be useful in determining when to &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt;), run a query like the following:</source>
          <target state="translated">Современные файловые системы работают быстрее при последовательном доступе к диску. Следовательно, SQLite будет работать быстрее, если содержимое файла базы данных находится на последовательных страницах. Чтобы узнать, какая часть страниц в базе данных является последовательной (и, таким образом, получить измерение, которое может быть полезно при определении того, когда выполнять &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; ), запустите запрос, подобный следующему:</target>
        </trans-unit>
        <trans-unit id="213d5e141cc4f1fbdb215e4e1d09c9f135e23841" translate="yes" xml:space="preserve">
          <source>Modifications to the &lt;a href=&quot;c3ref/vfs&quot;&gt;virtual file system&lt;/a&gt; interface to support a wider range of embedded systems. See &lt;a href=&quot;35to36&quot;&gt;35to36.html&lt;/a&gt; for additional information. *** Potentially incompatible change ***</source>
          <target state="translated">Модификации интерфейса &lt;a href=&quot;c3ref/vfs&quot;&gt;виртуальной файловой системы&lt;/a&gt; для поддержки более широкого диапазона встроенных систем. См. &lt;a href=&quot;35to36&quot;&gt;35to36.html&lt;/a&gt; для получения дополнительной информации. *** Потенциально несовместимое изменение ***</target>
        </trans-unit>
        <trans-unit id="846a3f594ccb25f4d8b90bf39076621c7a3da386" translate="yes" xml:space="preserve">
          <source>Modifications to the &lt;a href=&quot;lemon&quot;&gt;Lemon parser generator&lt;/a&gt; so that the parser tables are 4 times smaller.</source>
          <target state="translated">Модификации &lt;a href=&quot;lemon&quot;&gt;генератора синтаксического анализатора Lemon,&lt;/a&gt; чтобы таблицы синтаксического анализатора были в 4 раза меньше.</target>
        </trans-unit>
        <trans-unit id="a373b9c05e3506597302158ddcc81e7b79ce6310" translate="yes" xml:space="preserve">
          <source>Modified &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt; and &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigscratch&quot;&gt;SQLITE_CONFIG_SCRATCH&lt;/a&gt; to remove the &quot;+4&quot; magic number in the buffer size computation.</source>
          <target state="translated">Модифицированный &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt; и &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigscratch&quot;&gt;SQLITE_CONFIG_SCRATCH&lt;/a&gt; удалить &amp;laquo;+4&amp;raquo; магическое число в вычислении размера буфера.</target>
        </trans-unit>
        <trans-unit id="7ae047108ffb132cb41d3775cac528b7c36bd9c6" translate="yes" xml:space="preserve">
          <source>Modified the &lt;b&gt;sqlite&lt;/b&gt; shell program to print the schema for the built-in SQLITE_MASTER table, if explicitly requested.</source>
          <target state="translated">Измененный &lt;b&gt;SQLite&lt;/b&gt; оболочка программы для печати схемы для встроенного sqlite_master таблицы, если явно просил.</target>
        </trans-unit>
        <trans-unit id="64b762eca0515a688c77ad3f10cd0b574a4463f3" translate="yes" xml:space="preserve">
          <source>Modified the &lt;b&gt;sqlite&lt;/b&gt; shell program to use the new interface routines.</source>
          <target state="translated">Измененный &lt;b&gt;SQLite&lt;/b&gt; оболочки программы , чтобы использовать новые процедуры интерфейса.</target>
        </trans-unit>
        <trans-unit id="9bea3abf3349ced7a2bd684045cab38caa6bf680" translate="yes" xml:space="preserve">
          <source>Modified the &lt;b&gt;sqlite&lt;/b&gt; shell to make use of the new sqlite_get_table() API in order to print a list of tables in multiple columns, similar to the way &quot;ls&quot; prints filenames.</source>
          <target state="translated">Измененный &lt;b&gt;SQLite&lt;/b&gt; оболочку , чтобы сделать использование нового sqlite_get_table () API для того , чтобы напечатать список таблиц в нескольких столбцах, подобно тому, как &amp;laquo;LS&amp;raquo; печатает имена файлов.</target>
        </trans-unit>
        <trans-unit id="d9d09adf1be852d2030f454ddcb0fb1bbde85e4b" translate="yes" xml:space="preserve">
          <source>Modified the &lt;b&gt;sqlite&lt;/b&gt; shell to print a semicolon at the end of each CREATE statement in the output of the &quot;.schema&quot; command.</source>
          <target state="translated">Измененный &lt;b&gt;SQLite&lt;/b&gt; оболочку напечатать точку с запятой в конце каждого CREATE заявление в выводе команды &amp;laquo;.schema&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="cecf75f0a6c4e051f8158a879b4378a1d3e737c4" translate="yes" xml:space="preserve">
          <source>Modified the B-Tree and Pager modules so that disk pages that do not contain real data (free pages) are not journaled and are not written from memory back to the disk when they change. This does not impact database integrity, since the pages contain no real data, but it does make large INSERT operations about 2.5 times faster and large DELETEs about 5 times faster.</source>
          <target state="translated">Модули B-Tree и Pager были модифицированы таким образом,чтобы страницы диска,не содержащие реальных данных (свободные страницы),не записывались в журнал и не записывались из памяти обратно на диск при их изменении.Это не влияет на целостность базы данных,так как страницы не содержат реальных данных,но делают большие операции INSERT примерно в 2,5 раза быстрее,а большие операции DELETE примерно в 5 раз быстрее.</target>
        </trans-unit>
        <trans-unit id="2c4d4de8cb2205ec2b07c88e0fe421ab99dc0aaa" translate="yes" xml:space="preserve">
          <source>Modified the journal file format to make it more resistant to corruption that can occur after an OS crash or power failure.</source>
          <target state="translated">Изменен формат файла журнала,чтобы сделать его более устойчивым к повреждениям,которые могут произойти после сбоя операционной системы или отключения питания.</target>
        </trans-unit>
        <trans-unit id="3a7ea294bf33134dce4b142b8b7182de29b978b2" translate="yes" xml:space="preserve">
          <source>Modifiers</source>
          <target state="translated">Modifiers</target>
        </trans-unit>
        <trans-unit id="2d258a9a354e69d26a5737aed0d98ba4a12d4ab3" translate="yes" xml:space="preserve">
          <source>Modify the TCL interface to use &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt;.</source>
          <target state="translated">Измените интерфейс TCL, чтобы использовать &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9c186ff83bfc4ba49c92b1876d399ba40e64a0cc" translate="yes" xml:space="preserve">
          <source>Modify the test scripts to identify tests that depend on system load and processor speed and to warn the user that a failure of one of those (rare) tests does not necessarily mean the library is malfunctioning. No changes to code.</source>
          <target state="translated">Модифицируйте тестовые скрипты,чтобы определить тесты,зависящие от нагрузки системы и скорости процессора,и предупредить пользователя о том,что сбой одного из этих (редких)тестов не обязательно означает неисправность библиотеки.Никаких изменений в коде.</target>
        </trans-unit>
        <trans-unit id="ef40b73dad75552add2180adc162c800be16bf41" translate="yes" xml:space="preserve">
          <source>Modifying the contents of a database page.</source>
          <target state="translated">Изменение содержимого страницы базы данных.</target>
        </trans-unit>
        <trans-unit id="56d9419099fd345280bf9a9122ad284109000f7d" translate="yes" xml:space="preserve">
          <source>Modifying, Adding or Truncating a Database Page</source>
          <target state="translated">Изменение,добавление или усечение страницы базы данных</target>
        </trans-unit>
        <trans-unit id="d9ae0b87be39aed320fa35b9e4b820b36d71a71f" translate="yes" xml:space="preserve">
          <source>More aggressive &lt;a href=&quot;compile#omit_floating_point&quot;&gt;SQLITE_OMIT_FLOATING_POINT&lt;/a&gt;</source>
          <target state="translated">Более агрессивный &lt;a href=&quot;compile#omit_floating_point&quot;&gt;SQLITE_OMIT_FLOATING_POINT&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="150e84142afe50eae5e55924e9aafb441ae8328b" translate="yes" xml:space="preserve">
          <source>More aggressive optimization of the AND operator when one side or the other is always false.</source>
          <target state="translated">Более агрессивная оптимизация оператора AND,когда та или иная сторона всегда ложна.</target>
        </trans-unit>
        <trans-unit id="4dccd541fa7b33732e530432dc181f83dcc6ba6e" translate="yes" xml:space="preserve">
          <source>More complex queries may or may not be able to employ query flattening to avoid the temporary table. Whether or not the query can be flattened depends on such factors as whether or not the subquery or outer query contain aggregate functions, ORDER BY or GROUP BY clauses, LIMIT clauses, and so forth. The rules for when a query can and cannot be flattened are very complex and are beyond the scope of this document.</source>
          <target state="translated">Более сложные запросы могут использовать или не использовать сплющивание запросов,чтобы избежать временной таблицы.Сглаживание запроса зависит от таких факторов,как наличие или отсутствие в подзапросе или внешнем запросе агрегатных функций,оговорок ORDER BY или GROUP BY,оговорок LIMIT и так далее.Правила того,когда запрос может быть сплющен,а когда нет,очень сложны и выходят за рамки этого документа.</target>
        </trans-unit>
        <trans-unit id="0e965ef66116c7e835a08b23bc0aea20069b16ec" translate="yes" xml:space="preserve">
          <source>More efficient encoding of boolean values resulting in smaller database files</source>
          <target state="translated">Более эффективное кодирование булевых значений,что приводит к меньшему размеру файлов базы данных.</target>
        </trans-unit>
        <trans-unit id="bc15bc11932b9e3bb7aa3bd3cd6dd3273dc66921" translate="yes" xml:space="preserve">
          <source>More efficient handling of &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt;, especially in cases where the application defines hundreds or thousands of custom functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a3c60573ba6ac75355060c30752d85d7e4a4ea7" translate="yes" xml:space="preserve">
          <source>More efficient handling of &lt;a href=&quot;c3ref/create_function&quot;&gt;application-defined SQL functions&lt;/a&gt;, especially in cases where the application defines hundreds or thousands of custom functions.</source>
          <target state="translated">Более эффективная обработка &lt;a href=&quot;c3ref/create_function&quot;&gt;определяемых приложением функций SQL&lt;/a&gt; , особенно в случаях, когда приложение определяет сотни или тысячи пользовательских функций.</target>
        </trans-unit>
        <trans-unit id="bbf641e990dbd768fc579b21dbc73f3e38164565" translate="yes" xml:space="preserve">
          <source>More efficient implementation of sqliteFileExists() under Windows. (by Joel Luscy)</source>
          <target state="translated">Более эффективная реализация sqliteFileExists()под Windows.(автор Джоэл Ласси)</target>
        </trans-unit>
        <trans-unit id="da802536bedcdb71b26438d22c88c54625f47a34" translate="yes" xml:space="preserve">
          <source>More robust handling of out-of-memory errors.</source>
          <target state="translated">Более надежная обработка ошибок вне памяти.</target>
        </trans-unit>
        <trans-unit id="f0bbe298877a69ce96299f0684d775b43d33f438" translate="yes" xml:space="preserve">
          <source>More suggestions...</source>
          <target state="translated">Больше предложений...</target>
        </trans-unit>
        <trans-unit id="40a15bddc2f46eb54c50912ec8296652a2a161bf" translate="yes" xml:space="preserve">
          <source>More than one NEAR operator may appear in a single query. In this case each pair of terms or phrases separated by a NEAR operator must appear within the specified proximity of each other in the document. Using the same table and data as in the block of examples above:</source>
          <target state="translated">В одном запросе может появиться более одного оператора NEAR.В этом случае каждая пара терминов или словосочетаний,разделенных оператором NEAR,должна появляться в пределах указанной близости друг от друга в документе.Используйте ту же таблицу и данные,что и в блоке примеров выше:</target>
        </trans-unit>
        <trans-unit id="e8eaec9acde05ea65cc7e78b52370752d8ff824b" translate="yes" xml:space="preserve">
          <source>Most R*Tree queries use a depth-first search. This is accomplished by setting the rScore equal to iLevel. A depth-first search is usually preferred since it minimizes the number of elements in the priority queue, which reduces memory requirements and speeds processing. However, some application may prefer a breadth-first search, which can be accomplished by setting rScore to mxLevel-iLevel. By creating more complex formulas for rScore, applications can exercise detailed control over the order in which subtree are searched and leaf R*Tree entries are returned. For example, in an application with many millions of R*Tree entries, the rScore might be arranged so that the largest or most significant entries are returned first, allowing the application to display the most important information quickly, and filling in smaller and less important details as they become available.</source>
          <target state="translated">Большинство запросов R*Tree используют глубинный поиск.Это достигается установкой rScore равным iLevel.Обычно предпочтительнее использовать глубинный поиск,так как он минимизирует количество элементов в очереди приоритетов,что снижает требования к памяти и ускоряет обработку.Тем не менее,некоторые приложения могут предпочесть поиск по глубине,что можно сделать,установив rScore равным mxLevel-iLevel.Создавая более сложные формулы для rScore,приложения могут осуществлять детальный контроль над порядком,в котором выполняется поиск в поддереве и возвращаются элементы листа R*Tree.Например,в приложении с миллионами записей R*Tree,rScore может быть устроена так,что сначала будут возвращены самые большие или наиболее важные записи,что позволит приложению быстро отображать наиболее важную информацию,а также заполнять более мелкие и менее важные детали по мере их появления.</target>
        </trans-unit>
        <trans-unit id="0b7d92086a8e46f293a7dca57cb6a5c138416054" translate="yes" xml:space="preserve">
          <source>Most SQL database engines (every SQL database engine other than SQLite, as far as we know) uses static, rigid typing. With static typing, the datatype of a value is determined by its container - the particular column in which the value is stored.</source>
          <target state="translated">Большинство движков баз данных SQL (каждый движок баз данных SQL,кроме SQLite,насколько мы знаем)использует статический,жесткий набор текста.При статическом вводе тип значения определяется его контейнером-конкретным столбцом,в котором хранится значение.</target>
        </trans-unit>
        <trans-unit id="0b21de15eb7e27a08d9b4ec057ceb748bbaa22cd" translate="yes" xml:space="preserve">
          <source>Most SQL database engines are client/server based. Of those that are serverless, SQLite is the only one known to this author that allows multiple applications to access the same database at the same time.</source>
          <target state="translated">Большинство движков баз данных SQL основаны на клиенте/сервере.Из тех,которые являются безсерверными,SQLite-единственный известный этому автору,который позволяет нескольким приложениям получать доступ к одной базе данных одновременно.</target>
        </trans-unit>
        <trans-unit id="27297778565294594247653539b897aca8f2a9fb" translate="yes" xml:space="preserve">
          <source>Most SQL database engines are client/server based. Of those that are serverless, SQLite is the only one that this author knows of that allows multiple applications to access the same database at the same time.</source>
          <target state="translated">Большинство движков баз данных SQL основаны на клиенте/сервере.Из тех,которые являются безсерверными,SQLite-единственный,о котором знает автор,позволяющий нескольким приложениям получать доступ к одной и той же базе данных одновременно.</target>
        </trans-unit>
        <trans-unit id="260ad8dfcdd6cee164826174f5ff18a6d6796783" translate="yes" xml:space="preserve">
          <source>Most SQL database engines are implemented as a separate server process. Programs that want to access the database communicate with the server using some kind of interprocess communication (typically TCP/IP) to send requests to the server and to receive back results. SQLite does not work this way. With SQLite, the process that wants to access the database reads and writes directly from the database files on disk. There is no intermediary server process.</source>
          <target state="translated">Большинство движков баз данных SQL реализованы как отдельный серверный процесс.Программы,которые хотят получить доступ к базе данных,взаимодействуют с сервером,используя некий вид межпроцессного взаимодействия (обычно TCP/IP)для отправки запросов к серверу и получения обратно результатов.SQLite не работает таким образом.С SQLite процесс,который хочет получить доступ к базе данных,читает и записывает непосредственно из файлов базы данных на диск.Нет никакого промежуточного серверного процесса.</target>
        </trans-unit>
        <trans-unit id="e11debe28c45aae3eb5d59593787d087cef00a39" translate="yes" xml:space="preserve">
          <source>Most SQL database engines store the schema already parsed into various system tables. On those database engines, ALTER TABLE merely has to make modifications to the corresponding system tables.</source>
          <target state="translated">Большинство движков баз данных SQL хранят уже разобранную схему в различных системных таблицах.На этих двигателях БД ALTER TABLE приходится лишь вносить изменения в соответствующие системные таблицы.</target>
        </trans-unit>
        <trans-unit id="c8146f85b00a04238b33c2841ef39833177b149b" translate="yes" xml:space="preserve">
          <source>Most SQL database engines use static typing. A datatype is associated with each column in a table and only values of that particular datatype are allowed to be stored in that column. SQLite relaxes this restriction by using manifest typing. In manifest typing, the datatype is a property of the value itself, not of the column in which the value is stored. SQLite thus allows the user to store any value of any datatype into any column regardless of the declared type of that column. (There are some exceptions to this rule: An INTEGER PRIMARY KEY column may only store integers. And SQLite attempts to coerce values into the declared datatype of the column when it can.)</source>
          <target state="translated">Большинство движков баз данных SQL используют статический набор текста.Тип данных ассоциируется с каждым столбцом таблицы,и только значения этого типа данных могут храниться в этом столбце.SQLite снимает это ограничение,используя манифестный набор текста.При явном вводе тип данных является свойством самого значения,а не столбца,в котором хранится значение.Таким образом,SQLite позволяет пользователю хранить любое значение любого типа данных в любом столбце,независимо от объявленного типа этого столбца.(Есть некоторые исключения из этого правила:В столбце INTEGER PRIMARY KEY могут храниться только целые числа.И SQLite пытается принудить значения к декларированному типу данных столбца,когда это возможно).</target>
        </trans-unit>
        <trans-unit id="725952f518d7037ff04756bd99d602eae557b1ce" translate="yes" xml:space="preserve">
          <source>Most application formats fit into one of these three categories:</source>
          <target state="translated">Большинство форматов приложений попадает в одну из этих трех категорий:</target>
        </trans-unit>
        <trans-unit id="ce502bced488a9855f9633bf314ed3f557c5599e" translate="yes" xml:space="preserve">
          <source>Most applications will only use the session module functionality described in the previous section. However, the following additional functionality is available for the use and manipulation of changeset and patchset blobs:</source>
          <target state="translated">Большинство приложений будут использовать только функциональность сеансового модуля,описанную в предыдущем разделе.Однако для использования и манипулирования блоками changeset и patchset доступна следующая дополнительная функциональность:</target>
        </trans-unit>
        <trans-unit id="cd513c058fc14329a86bc7561ce2383e9150f5ca" translate="yes" xml:space="preserve">
          <source>Most applications work great with SQLite in its default configuration and with no special compile-time configuration. Most developers should be able to completely ignore this document and simply build SQLite from &lt;a href=&quot;amalgamation&quot;&gt;the amalgamation&lt;/a&gt; without any special knowledge and without taking any special actions.</source>
          <target state="translated">Большинство приложений отлично работают с SQLite в его конфигурации по умолчанию и без специальной конфигурации во время компиляции. Большинство разработчиков должны иметь возможность полностью игнорировать этот документ и просто создавать SQLite из &lt;a href=&quot;amalgamation&quot;&gt;объединения&lt;/a&gt; без каких-либо специальных знаний и без каких-либо специальных действий.</target>
        </trans-unit>
        <trans-unit id="635fff5a9d997771ed833778dcd946f9fa076040" translate="yes" xml:space="preserve">
          <source>Most builds also use the system memory allocation routines:</source>
          <target state="translated">Большинство сборок также используют процедуры выделения системной памяти:</target>
        </trans-unit>
        <trans-unit id="c757f57c7c0fc6a3a16a4ba481be29df77f7ba0d" translate="yes" xml:space="preserve">
          <source>Most built-in window functions ignore the frame-spec, the exceptions being first_value(), last_value() and nth_value(). It is a syntax error to specify a FILTER clause as part of a built-in window function invocation.</source>
          <target state="translated">Большинство встроенных оконных функций игнорируют frame-spec,исключениями являются first_value(),last_value()и nth_value().Синтаксической ошибкой является указание выражения FILTER как части вызова встроенной оконной функции.</target>
        </trans-unit>
        <trans-unit id="91aff38100948ec7606e7b9be6940203c42b637c" translate="yes" xml:space="preserve">
          <source>Most memory statistics are global, and therefore the tracking of statistics must be serialized with a mutex. Statistics are turned on by default, but an option exists to disable them. By disabling memory statistics, SQLite avoids entering and leaving a mutex on each memory allocation and deallocation. That savings can be noticeable on systems where mutex operations are expensive. To disable memory statistics, the following interface is used at start-time:</source>
          <target state="translated">Большинство статистических данных в памяти являются глобальными,поэтому отслеживание статистики должно быть сериализовано с помощью мьютекса.По умолчанию статистика включена,но есть возможность ее отключить.Отключая статистику памяти,SQLite избегает входа и выхода из мьютекса при каждом выделении и распределении памяти.Такая экономия может быть заметна на системах,где операции мьютекса стоят дорого.Для отключения статистики памяти при запуске используется следующий интерфейс:</target>
        </trans-unit>
        <trans-unit id="3ddc29325f5f8b33e852a6ad2b01d9c1a5b27979" translate="yes" xml:space="preserve">
          <source>Most object references may only resolve to a specific type of object (for example a reference that is part of a DROP TABLE statement may only resolve to a table object, not an index, trigger or view). However in some contexts (e.g. &lt;a href=&quot;lang_reindex&quot;&gt;REINDEX&lt;/a&gt;) an object reference may be resolve to more than one type of object. When searching database schemas for a named object, objects of types that cannot be used in the context of the reference are always ignored.</source>
          <target state="translated">Большинство ссылок на объекты могут разрешаться только в определенный тип объекта (например, ссылка, которая является частью оператора DROP TABLE, может разрешаться только в объект таблицы, а не в индекс, триггер или представление). Однако в некоторых контекстах (например, &lt;a href=&quot;lang_reindex&quot;&gt;REINDEX&lt;/a&gt; ) ссылка на объект может быть разрешена для более чем одного типа объекта. При поиске в схемах базы данных именованного объекта объекты типов, которые нельзя использовать в контексте ссылки, всегда игнорируются.</target>
        </trans-unit>
        <trans-unit id="1f85923bce6297c36b3c44bb82e688cbd09f35ee" translate="yes" xml:space="preserve">
          <source>Most of the code in the SQLite source tree is devoted purely to &lt;a href=&quot;testing&quot;&gt;testing and verification&lt;/a&gt;. Reliability is important to SQLite. Among the tasks of the test infrastructure is to ensure that SQLite does not misuse dynamically allocated memory, that SQLite does not leak memory, and that SQLite responds correctly to a dynamic memory allocation failure.</source>
          <target state="translated">Большая часть кода в дереве исходных текстов SQLite предназначена исключительно для &lt;a href=&quot;testing&quot;&gt;тестирования и проверки&lt;/a&gt; . Для SQLite важна надежность. Среди задач тестовой инфраструктуры - убедиться, что SQLite не злоупотребляет динамически выделяемой памятью, что SQLite не вызывает утечки памяти и что SQLite правильно реагирует на сбой динамического выделения памяти.</target>
        </trans-unit>
        <trans-unit id="4ea1351b2e34fd10311e1e13ffcc8b793141d24f" translate="yes" xml:space="preserve">
          <source>Most of the time, sqlite3 just reads lines of input and passes them on to the SQLite library for execution. But input lines that begin with a dot (&quot;.&quot;) are intercepted and interpreted by the sqlite3 program itself. These &quot;dot commands&quot; are typically used to change the output format of queries, or to execute certain prepackaged query statements. There were originally just a few dot commands, but over the years many new features have accumulated so that today there over 60.</source>
          <target state="translated">В большинстве случаев sqlite3 просто читает строки ввода и передает их на исполнение в библиотеку SQLite.Но строки ввода,начинающиеся с точки (&quot;.&quot;)перехватываются и интерпретируются самой программой sqlite3.Эти &quot;точечные команды&quot; обычно используются для изменения формата вывода запросов или для выполнения определенных предупакованных операторов запроса.Изначально было всего несколько точечных команд,но с годами накопилось много новых возможностей,так что сегодня их более 60.</target>
        </trans-unit>
        <trans-unit id="8140e633bb506b56ea3ecec29c87f47b39a7e315" translate="yes" xml:space="preserve">
          <source>Most of the time, the query planner in SQLite does a good job. However, the query planner needs indices to work with. These indices must normally be added by programmers. Rarely, the query planner AI will make a suboptimal algorithm choice. In those cases, programmers may want to provide additional hints to help the query planner do a better job.</source>
          <target state="translated">В большинстве случаев планировщик запросов в SQLite делает хорошую работу.Однако для работы планировщика запросов нужны индексы.Как правило,эти индексы должны добавляться программистами.Редко бывает,что AI планировщик запросов сделает выбор субоптимального алгоритма.В этих случаях программисты,возможно,захотят предоставить дополнительные подсказки,чтобы помочь планировщику запросов сделать работу лучше.</target>
        </trans-unit>
        <trans-unit id="4d637cb6d91465469dba952401dcd3c4590d5c67" translate="yes" xml:space="preserve">
          <source>Most other SQL database engines allocated a fixed amount of disk space for each row in most tables. They play special tricks for handling BLOBs and CLOBs which can be of wildly varying length. But for most tables, if you declare a column to be a VARCHAR(100) then the database engine will allocate 100 bytes of disk space regardless of how much information you actually store in that column.</source>
          <target state="translated">Большинство других движков баз данных SQL выделяют фиксированное дисковое пространство для каждой строки в большинстве таблиц.Они проигрывают специальные трюки для работы с BLOB и CLOB,которые могут быть различной длины.Но для большинства таблиц,если вы объявите столбец VARCHAR(100),то движок базы данных выделит 100 байт дискового пространства независимо от того,сколько информации вы на самом деле храните в этом столбце.</target>
        </trans-unit>
        <trans-unit id="b52c62ddb6e76f10df4280114ef18bdd833e392c" translate="yes" xml:space="preserve">
          <source>Most other SQL database engines are much larger than this. IBM boasts that its recently released CloudScape database engine is &quot;only&quot; a 2MiB jar file - an order of magnitude larger than SQLite even after it is compressed! Firebird boasts that its client-side library is only 350KiB. That's as big as SQLite and does not even contain the database engine. The Berkeley DB library from Oracle is 450KiB and it omits SQL support, providing the programmer with only simple key/value pairs.</source>
          <target state="translated">Большинство других движков баз данных SQL гораздо больше.IBM может похвастаться тем,что его недавно выпущенный движок базы данных CloudScape-это &quot;всего лишь&quot; 2MiB jar-файл-на порядок больше,чем SQLite,даже после его сжатия! Firebird может похвастаться тем,что его клиентская библиотека составляет всего 350 КБ.Она такая же большая,как и SQLite,и даже не содержит движка базы данных.Библиотека БД Беркли от Oracle составляет 450 КБ и в ней отсутствует поддержка SQL,предоставляя программисту только простые пары ключ/значение.</target>
        </trans-unit>
        <trans-unit id="5dfe3bda7177abf58f732623f4daabfa91229422" translate="yes" xml:space="preserve">
          <source>Most other SQL database engines require you to dump and restore the database when moving from one platform to another and often when upgrading to a newer version of the software.</source>
          <target state="translated">Большинство других движков баз данных SQL требуют дампа и восстановления базы данных при переходе с одной платформы на другую и часто при обновлении на более новую версию программного обеспечения.</target>
        </trans-unit>
        <trans-unit id="879c0198beea8a0459677487adc544c847a7576f" translate="yes" xml:space="preserve">
          <source>Most programmers compile SQLite into their applications using the &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt;. The &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt; is C-code but it is not &quot;source code&quot;. The &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt; is generated from source code by scripts.</source>
          <target state="translated">Большинство программистов компилируют SQLite в свои приложения, используя &lt;a href=&quot;amalgamation&quot;&gt;объединение&lt;/a&gt; . &lt;a href=&quot;amalgamation&quot;&gt;Объединение&lt;/a&gt; является C-код , но это не &amp;laquo;исходный код&amp;raquo;. &lt;a href=&quot;amalgamation&quot;&gt;Объединение&lt;/a&gt; генерируется из исходного кода при помощи скриптов.</target>
        </trans-unit>
        <trans-unit id="e8416192176e318d00a7b55e02e8a608d8bdbda6" translate="yes" xml:space="preserve">
          <source>Most tables in SQLite consist of zero or more rows with a unique integer key (the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; or &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;) followed by content. (The exception is &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables.) The rows are logically stored in order of increasing rowid. As an example, this article uses a table named &quot;FruitsForSale&quot; which relates various fruits to the state where they are grown and their unit price at market. The schema is this:</source>
          <target state="translated">Большинство таблиц в SQLite состоят из нуля или более строк с уникальным целочисленным ключом ( &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; или &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; ), за которым следует содержимое. (Исключение составляют таблицы &lt;a href=&quot;withoutrowid&quot;&gt;БЕЗ ROWID&lt;/a&gt; .) Строки логически сохраняются в порядке увеличения rowid. В качестве примера в этой статье используется таблица &amp;laquo;FruitsForSale&amp;raquo;, которая связывает различные фрукты со штатом, в котором они выращиваются, и их рыночной ценой за единицу. Схема такая:</target>
        </trans-unit>
        <trans-unit id="22d0e010589dcfa569bc8ab54799e70d1b27d453" translate="yes" xml:space="preserve">
          <source>Most tables in a typical SQLite database schema are rowid tables.</source>
          <target state="translated">Большинство таблиц в типичной схеме базы данных SQLite-это рядные таблицы.</target>
        </trans-unit>
        <trans-unit id="ab23b25ac3bb6f94df4203c5e40926f8de962adb" translate="yes" xml:space="preserve">
          <source>Most users of swarmvtab will only use the features described above. This section describes features designed for more esoteric use cases. These features all involve specifying extra optional parameters following the SQL statement as part of the CREATE VIRTUAL TABLE command. An optional parameter is specified using its name, followed by an &quot;=&quot; character, followed by an optionally quoted value. Whitespace may separate the name, &quot;=&quot; character and value. For example:</source>
          <target state="translated">Большинство пользователей swarmvtab будут использовать только функции,описанные выше.В этом разделе описаны функции,предназначенные для более эзотерических случаев использования.Все эти функции включают в себя указание дополнительных опциональных параметров,следующих за SQL-оператором,как часть команды CREATE VIRTUAL TABLE.Дополнительный параметр задается с использованием его имени,за которым следует символ &quot;=&quot;,а затем опционально цитируемое значение.Пробельные символы могут разделять имя,символ &quot;=&quot; и значение.Например:</target>
        </trans-unit>
        <trans-unit id="76cdb950721642b6b8596d36d5a39f7705028b99" translate="yes" xml:space="preserve">
          <source>Move</source>
          <target state="translated">Move</target>
        </trans-unit>
        <trans-unit id="7e894652e8d984064189391f996d60397e2a48ec" translate="yes" xml:space="preserve">
          <source>Move a BLOB Handle to a New Row</source>
          <target state="translated">Переместите ручку BLOB в новый ряд.</target>
        </trans-unit>
        <trans-unit id="b0ff33b105569af9f2119de68af4d3ef24773b02" translate="yes" xml:space="preserve">
          <source>Move the P3 values in register P1..P1+P3-1 over into registers P2..P2+P3-1. Registers P1..P1+P3-1 are left holding a NULL. It is an error for register ranges P1..P1+P3-1 and P2..P2+P3-1 to overlap. It is an error for P3 to be less than 1.</source>
          <target state="translated">Переместите значения P3 в регистре P1...P1+P3-1 в регистр P2...P2+P3-1.Регистры P1...P1+P3-1 оставлены с NULL.Это ошибка для перекрытия диапазонов регистров P1...P1+P3-1 и P2...P2+P3-1.Это ошибка,когда P3 меньше 1.</target>
        </trans-unit>
        <trans-unit id="43e629ad230f33beeec0dc2dfe68b2611f083ba6" translate="yes" xml:space="preserve">
          <source>Move the cursor P1 to a null row. Any &lt;a href=&quot;opcode#Column&quot;&gt;Column&lt;/a&gt; operations that occur while the cursor is on the null row will always write a NULL.</source>
          <target state="translated">Переместите курсор P1 в пустую строку. Любые операции со &lt;a href=&quot;opcode#Column&quot;&gt;столбцами,&lt;/a&gt; которые происходят, когда курсор находится на нулевой строке, всегда будут записывать NULL.</target>
        </trans-unit>
        <trans-unit id="ff17aceff7878d14b853ed0faf40490493d4491b" translate="yes" xml:space="preserve">
          <source>Move website and documentation files out of the source tree into a &lt;a href=&quot;http://www.sqlite.org/docsrc/&quot;&gt;separate CM system&lt;/a&gt;.</source>
          <target state="translated">Переместите файлы веб-сайта и документации из дерева исходных текстов в &lt;a href=&quot;http://www.sqlite.org/docsrc/&quot;&gt;отдельную систему CM&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="42fda9211198a462ad90d286a7b4b2828423cc34" translate="yes" xml:space="preserve">
          <source>Moved the CVS repository to www.sqlite.org</source>
          <target state="translated">Переместил CVS репозиторий на www.sqlite.org.</target>
        </trans-unit>
        <trans-unit id="dc586a90c5c94a44d1d972ced97472cbaf4b949e" translate="yes" xml:space="preserve">
          <source>Moving From SQLite 3.4.2 to 3.5.0</source>
          <target state="translated">Переход с SQLite 3.4.2 на 3.5.0</target>
        </trans-unit>
        <trans-unit id="d4fefbd0278cf9b39cd3f466ee48861cfc5e39db" translate="yes" xml:space="preserve">
          <source>Moving From SQLite 3.5.9 to 3.6.0</source>
          <target state="translated">Переход с SQLite 3.5.9 на 3.6.0</target>
        </trans-unit>
        <trans-unit id="f76bc373feee6b1842d340bd7d664f80273b9cc9" translate="yes" xml:space="preserve">
          <source>Moving a journal file from one database to another.</source>
          <target state="translated">Перемещение файла журнала из одной базы данных в другую.</target>
        </trans-unit>
        <trans-unit id="f0efafe4edefbbfdb22e09fc7f8e1939d65fc935" translate="yes" xml:space="preserve">
          <source>Much of the &lt;a href=&quot;c3ref/intro&quot;&gt;C-language Interface&lt;/a&gt; is found in source files &lt;a href=&quot;https://sqlite.org/src/file/src/main.c&quot;&gt;main.c&lt;/a&gt;, &lt;a href=&quot;https://sqlite.org/src/file/src/legacy.c&quot;&gt;legacy.c&lt;/a&gt;, and &lt;a href=&quot;https://sqlite.org/src/file/src/vdbeapi.c&quot;&gt;vdbeapi.c&lt;/a&gt; though some routines are scattered about in other files where they can have access to data structures with file scope. The &lt;a href=&quot;c3ref/free_table&quot;&gt;sqlite3_get_table()&lt;/a&gt; routine is implemented in &lt;a href=&quot;https://sqlite.org/src/file/src/table.c&quot;&gt;table.c&lt;/a&gt;. The &lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_mprintf()&lt;/a&gt; routine is found in &lt;a href=&quot;https://sqlite.org/src/file/src/printf.c&quot;&gt;printf.c&lt;/a&gt;. The &lt;a href=&quot;c3ref/complete&quot;&gt;sqlite3_complete()&lt;/a&gt; interface is in &lt;a href=&quot;https://sqlite.org/src/file/src/complete.c&quot;&gt;complete.c&lt;/a&gt;. The &lt;a href=&quot;tclsqlite&quot;&gt;TCL Interface&lt;/a&gt; is implemented by &lt;a href=&quot;https://sqlite.org/src/file/src/tclsqlite.c&quot;&gt;tclsqlite.c&lt;/a&gt;.</source>
          <target state="translated">Большая часть &lt;a href=&quot;c3ref/intro&quot;&gt;интерфейса на языке C&lt;/a&gt; находится в исходных файлах &lt;a href=&quot;https://sqlite.org/src/file/src/main.c&quot;&gt;main.c&lt;/a&gt; , &lt;a href=&quot;https://sqlite.org/src/file/src/legacy.c&quot;&gt;legacy.c&lt;/a&gt; и &lt;a href=&quot;https://sqlite.org/src/file/src/vdbeapi.c&quot;&gt;vdbeapi.c,&lt;/a&gt; хотя некоторые подпрограммы разбросаны по другим файлам, где они могут иметь доступ к структурам данных с файловой областью. &lt;a href=&quot;c3ref/free_table&quot;&gt;Sqlite3_get_table ()&lt;/a&gt; подпрограмма реализуется в &lt;a href=&quot;https://sqlite.org/src/file/src/table.c&quot;&gt;table.c&lt;/a&gt; . &lt;a href=&quot;c3ref/mprintf&quot;&gt;Sqlite3_mprintf ()&lt;/a&gt; подпрограмма находится в &lt;a href=&quot;https://sqlite.org/src/file/src/printf.c&quot;&gt;printf.c&lt;/a&gt; . Интерфейс &lt;a href=&quot;c3ref/complete&quot;&gt;sqlite3_complete ()&lt;/a&gt; находится в &lt;a href=&quot;https://sqlite.org/src/file/src/complete.c&quot;&gt;complete.c&lt;/a&gt; . &lt;a href=&quot;tclsqlite&quot;&gt;TCL Интерфейс&lt;/a&gt; реализован &lt;a href=&quot;https://sqlite.org/src/file/src/tclsqlite.c&quot;&gt;tclsqlite.c&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0aeaa0f6e5bc7f27528f2732350cce3993158ba7" translate="yes" xml:space="preserve">
          <source>Multi-File Transactions</source>
          <target state="translated">Многофайловые операции</target>
        </trans-unit>
        <trans-unit id="7bd215d0dc08a639766c0fd92af7ca6bd919b359" translate="yes" xml:space="preserve">
          <source>Multi-character insertions, deletions, and substitutions can be enumerated in the cost table.</source>
          <target state="translated">Многосимвольные вставки,удаления и замены могут быть перечислены в таблице стоимости.</target>
        </trans-unit>
        <trans-unit id="658e2e2d073be17c3d24649adb63bc8071c4e34c" translate="yes" xml:space="preserve">
          <source>Multi-column indexes</source>
          <target state="translated">Многоколоночные индексы</target>
        </trans-unit>
        <trans-unit id="b37d6f5d76bdf33c501015c981f38efa402cfb25" translate="yes" xml:space="preserve">
          <source>Multi-column indices only work if the constraint terms in the WHERE clause of the query are connected by AND. So Idx3 and Idx4 are helpful when the search is for items that are both Oranges and grown in California, but neither index would be that useful if we wanted all items that were either oranges</source>
          <target state="translated">Индексы из нескольких столбцов работают только в том случае,если ограничительные условия в выражении WHERE запроса связаны с помощью AND.Таким образом,индексы Idx3 и Idx4 полезны,когда поиск ведется для элементов,которые одновременно являются оранжевыми и выросли в Калифорнии,но ни один из индексов не будет настолько полезен,если мы хотим,чтобы все элементы,которые были либо оранжевыми.</target>
        </trans-unit>
        <trans-unit id="a6a2f3477040c5c780afe34563348a368c865f18" translate="yes" xml:space="preserve">
          <source>Multiple Programming Languages</source>
          <target state="translated">Языки многократного программирования</target>
        </trans-unit>
        <trans-unit id="8127845d9b0c204fa8283356e673cf21f966c9a0" translate="yes" xml:space="preserve">
          <source>Multiple VFSes can be registered at the same time. Each VFS has a unique names. Separate &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt; within the same process can be using different VFSes at the same time. For that matter, if a single database connection has multiple database files open using the &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; command, then each attached database might be using a different VFS.</source>
          <target state="translated">Одновременно можно зарегистрировать несколько VFS. Каждая VFS имеет уникальные имена. Отдельные &lt;a href=&quot;c3ref/sqlite3&quot;&gt;соединения с базами данных&lt;/a&gt; в пределах того же процесса могут быть с использованием различных VFSes в то же самое время. В этом отношении, если одно соединение с базой данных имеет несколько файлов базы данных, открытых с помощью команды &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; , тогда каждая присоединенная база данных может использовать другую VFS.</target>
        </trans-unit>
        <trans-unit id="dcdea0a58cadff7c782d97a6048e7da5d88f4991" translate="yes" xml:space="preserve">
          <source>Multiple b-tree structures are used instead of a single b-tree to reduce the cost of inserting records into FTS tables. When a new record is inserted into an FTS table that already contains a lot of data, it is likely that many of the terms in the new record are already present in a large number of existing records. If a single b-tree were used, then large doclist structures would have to be loaded from the database, amended to include the new docid and term-offset list, then written back to the database. Using multiple b-tree tables allows this to be avoided by creating a new b-tree which can be merged with the existing b-tree (or b-trees) later on. Merging of b-tree structures can be performed as a background task, or once a certain number of separate b-tree structures have been accumulated. Of course, this scheme makes queries more expensive (as the FTS code may have to look up individual terms in more than one b-tree and merge the results), but it has been found that in practice this overhead is often negligible.</source>
          <target state="translated">Вместо одного b-дерева используются несколько b-деревянных структур для снижения затрат на вставку записей в таблицы FTS.Когда новая запись вставляется в таблицу ФСТ,которая уже содержит большое количество данных,вполне вероятно,что многие из терминов в новой записи уже присутствуют в большом количестве существующих записей.Если бы использовалось одно b-дерево,то пришлось бы загружать из БД большие doclist-структуры,изменять их таким образом,чтобы они включали новый docid и term-offset-список,а затем записывать их обратно в БД.Использование нескольких b-деревьев позволяет избежать этого путем создания нового b-дерева,которое впоследствии может быть объединено с существующим b-деревом (или b-деревом).Слияние b-деревянных структур может быть выполнено как фоновая задача,так и после накопления определенного количества отдельных b-деревянных структур.Конечно,такая схема делает запросы более дорогостоящими (так как код ФСТ может быть вынужден искать отдельные термины более чем в одном b-дереве и сливать результаты),но было обнаружено,что на практике эти накладные расходы зачастую ничтожно малы.</target>
        </trans-unit>
        <trans-unit id="46b7208fbb4e603607fdd8e005b8c2b44c4f2832" translate="yes" xml:space="preserve">
          <source>Multiple bug fixes to the &lt;a href=&quot;rowvalue&quot;&gt;row value&lt;/a&gt; logic that was introduced in version 3.15.0.</source>
          <target state="translated">Множественные исправления ошибок в логике &lt;a href=&quot;rowvalue&quot;&gt;значений строк,&lt;/a&gt; которые были введены в версии 3.15.0.</target>
        </trans-unit>
        <trans-unit id="5bf9dc54bb3a9335bc64c25972bec9a940f13e21" translate="yes" xml:space="preserve">
          <source>Multiple commentators have expressed a desire to use dynamic strings for the pointer type, and to have SQLite take ownership of the type strings and to automatically free the type string when it has finished using it. That design is rejected for the following reasons:</source>
          <target state="translated">Несколько комментаторов выразили желание использовать динамические строки для типа указателя,а также заставить SQLite взять в собственность строки типа и автоматически освободить строку типа после того,как он закончит использовать ее.Такая конструкция отвергается по следующим причинам:</target>
        </trans-unit>
        <trans-unit id="5989cfc9447928ba4d05b443c6d4b672ed4ef531" translate="yes" xml:space="preserve">
          <source>Multiple connections from within a single process that use this implementation of asynchronous IO may access a single database file concurrently. From the point of view of the user, if all connections are from within a single process, there is no difference between the concurrency offered by &quot;normal&quot; SQLite and SQLite using the asynchronous backend.</source>
          <target state="translated">Несколько соединений внутри одного процесса,использующих эту реализацию асинхронного ввода-вывода,могут одновременно получать доступ к одному файлу БД.С точки зрения пользователя,если все соединения находятся внутри одного процесса,то нет разницы между параллельностью,предлагаемой &quot;нормальным&quot; SQLite и SQLite,использующим асинхронный бэкэнд.</target>
        </trans-unit>
        <trans-unit id="de5017f80cc138eb92a9fee1631567420f1d53b1" translate="yes" xml:space="preserve">
          <source>Multiple connections may hold a read-lock simultaneously. If many threads are acquiring overlapping read-locks, it might be the case that at least one thread is always holding a read lock. Then a table waiting for a write-lock will wait forever. This scenario is called &quot;writer starvation.&quot;</source>
          <target state="translated">Несколько соединений могут содержать одновременно блокировку чтения.Если многие потоки приобретают перекрывающиеся блокировки чтения,может случиться так,что по крайней мере один поток всегда будет держать блокировку чтения.Тогда стол,ожидающий блокировки записи,будет ждать вечно.Этот сценарий называется &quot;голодной записью&quot;.</target>
        </trans-unit>
        <trans-unit id="809241f3730c6379db2c7c73b89d2efee62ec7f1" translate="yes" xml:space="preserve">
          <source>Multiple databases on the same &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; using &lt;a href=&quot;lang_attach&quot;&gt;ATTACH DATABASE&lt;/a&gt;</source>
          <target state="translated">Несколько баз данных в одном &lt;a href=&quot;c3ref/sqlite3&quot;&gt;подключении к базе данных&lt;/a&gt; с помощью &lt;a href=&quot;lang_attach&quot;&gt;ATTACH DATABASE&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="45a728f83fed6326d4c43841ba1813e1ce7eb6dd" translate="yes" xml:space="preserve">
          <source>Multiple processes can attach to the same application file and can read and write without interfering with each another.</source>
          <target state="translated">Несколько процессов могут присоединяться к одному и тому же файлу приложения и могут читать и записывать,не мешая друг другу.</target>
        </trans-unit>
        <trans-unit id="2aa7ba24512eed1d018b442b661d99d24d2bbe28" translate="yes" xml:space="preserve">
          <source>Multiple processes can have the same database open at the same time. Multiple processes can be doing a SELECT at the same time. But only one process can be making changes to the database at any moment in time, however.</source>
          <target state="translated">Несколько процессов могут иметь одну и ту же базу данных одновременно.Несколько процессов могут выполнять SELECT одновременно.Но только один процесс может вносить изменения в базу данных в любой момент времени.</target>
        </trans-unit>
        <trans-unit id="933ed3deea04e9e9fbd7189bd88652e303cb225d" translate="yes" xml:space="preserve">
          <source>Multiple small sorts collectively use fewer CPU cycles than a single large sort.</source>
          <target state="translated">Множество маленьких сортов в совокупности используют меньше циклов процессора,чем один большой сорт.</target>
        </trans-unit>
        <trans-unit id="b20a305f06f0be2e3dd77e203ae365353776cf59" translate="yes" xml:space="preserve">
          <source>Multiply</source>
          <target state="translated">Multiply</target>
        </trans-unit>
        <trans-unit id="8e0df4037503e2d7d2784fedb62cdd6ec1bcce1f" translate="yes" xml:space="preserve">
          <source>Multiply the value in register P1 by the value in register P2 and store the result in register P3. If either input is NULL, the result is NULL.</source>
          <target state="translated">Умножьте значение в регистре P1 на значение в регистре P2 и сохраните результат в регистре P3.Если любой из входов имеет значение NULL,то результат будет NULL.</target>
        </trans-unit>
        <trans-unit id="96a8063d277e69bad9338f2cd2299ce555b10c74" translate="yes" xml:space="preserve">
          <source>Multiplying null by zero gives null</source>
          <target state="translated">Умножение нуля на ноль дает ноль</target>
        </trans-unit>
        <trans-unit id="0882d3aaa23d5575a8f63bfdd8452012d19a092f" translate="yes" xml:space="preserve">
          <source>MustBeInt</source>
          <target state="translated">MustBeInt</target>
        </trans-unit>
        <trans-unit id="ad84a5c1e8958f4a9c3429e8188a4603875d0079" translate="yes" xml:space="preserve">
          <source>Mutation test script</source>
          <target state="translated">Скрипт теста на мутацию</target>
        </trans-unit>
        <trans-unit id="20e073cd00cadf7d267e8b82f5b78e0e3f9214a2" translate="yes" xml:space="preserve">
          <source>Mutation testing can be slow, since each test can take up to 5 minutes on a fast workstation, and there are two tests for each branch instructions, and over 20,000 branch instructions. Efforts are made to expedite operation. For example, TH3 is compiled in such a way that it exits as soon as it finds the first error, and as many of the mutations are easily detected, many cycles happen in only a few seconds. Nevertheless, the mutation-test.tcl script includes command-line options to limit the range of code lines tested so that mutation testing only needs to be performed on blocks of code that have recently changed.</source>
          <target state="translated">Тестирование мутации может быть медленным,так как каждый тест может занять до 5 минут на быстрой рабочей станции,и есть два теста для каждой инструкции ветви,и более 20 000 инструкций ветви.Прилагаются усилия для ускорения работы.Например,TH3 скомпилирован таким образом,что выходит сразу после обнаружения первой ошибки,и поскольку многие мутации легко обнаруживаются,многие циклы происходят всего за несколько секунд.Тем не менее,скрипт mutation-test.tcl включает опции командной строки для ограничения диапазона проверяемых строк кода,так что проверка мутаций должна выполняться только на недавно изменившихся блоках кода.</target>
        </trans-unit>
        <trans-unit id="ee9066f4d731d8a141c6e684743ee9a9527de8b6" translate="yes" xml:space="preserve">
          <source>Mutex Handle</source>
          <target state="translated">рукоятка из мутекса</target>
        </trans-unit>
        <trans-unit id="9f117864c1709baa2c76d7b2cfa8d17c9f1bfe11" translate="yes" xml:space="preserve">
          <source>Mutex Methods Object</source>
          <target state="translated">Мютексные методы Объект</target>
        </trans-unit>
        <trans-unit id="83fb9a7fd1246d148749d832e1630432bf7c41eb" translate="yes" xml:space="preserve">
          <source>Mutex Types</source>
          <target state="translated">Типы мутекса</target>
        </trans-unit>
        <trans-unit id="9ca067080a430d66f997055e5f2d644e22736a96" translate="yes" xml:space="preserve">
          <source>Mutex Verification Routines</source>
          <target state="translated">Маршруты проверки Мьютекса</target>
        </trans-unit>
        <trans-unit id="82f2c9599c5c14be2ce92b9de958cb57db81b38f" translate="yes" xml:space="preserve">
          <source>Mutexes</source>
          <target state="translated">Mutexes</target>
        </trans-unit>
        <trans-unit id="5b84f7a78e5961ea2a526de843a9daab8f41a20c" translate="yes" xml:space="preserve">
          <source>Mutexes are cheap but they are not free, so performance will be better when mutexes are completely disabled. The resulting library footprint will also be a little smaller. Disabling the mutexes at compile-time is a recommended optimization for applications where it makes sense.</source>
          <target state="translated">Мютексы дешевы,но не бесплатны,поэтому производительность будет лучше,когда мютексы полностью отключены.В результате площадь,занимаемая библиотекой,также будет немного меньше.Отключение мьютексов во время компиляции является рекомендуемой оптимизацией для приложений,где это имеет смысл.</target>
        </trans-unit>
        <trans-unit id="b22446695cc6c25d3041d52dab780b6caac7cd1e" translate="yes" xml:space="preserve">
          <source>Mutexes are created using &lt;a href=&quot;#sqlite3_mutex_alloc&quot;&gt;sqlite3_mutex_alloc()&lt;/a&gt;.</source>
          <target state="translated">Мьютексы создаются с помощью &lt;a href=&quot;#sqlite3_mutex_alloc&quot;&gt;sqlite3_mutex_alloc ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a8bd3143e806972c1aad1cdeede17125b4f66fc3" translate="yes" xml:space="preserve">
          <source>Mutexes are created using &lt;a href=&quot;mutex_alloc&quot;&gt;sqlite3_mutex_alloc()&lt;/a&gt;.</source>
          <target state="translated">Мьютексы создаются с помощью &lt;a href=&quot;mutex_alloc&quot;&gt;sqlite3_mutex_alloc ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="90dba5f17bdba09d7b97e3f464ca3b8fa2e57394" translate="yes" xml:space="preserve">
          <source>My WHERE clause expression &lt;code&gt;column1=&quot;column1&quot;&lt;/code&gt; does not work. It causes every row of the table to be returned, not just the rows where column1 has the value &quot;column1&quot;.</source>
          <target state="translated">Мое выражение предложения WHERE &lt;code&gt;column1=&quot;column1&quot;&lt;/code&gt; не работает. Это приводит к возврату каждой строки таблицы, а не только строк, в которых column1 имеет значение &amp;laquo;column1&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="53dbb81c605812b9954b771e4d176a4b96f646d2" translate="yes" xml:space="preserve">
          <source>My query does not return the column name that I expect. Is this a bug?</source>
          <target state="translated">Мой запрос не возвращает имя столбца,которое я ожидаю.Это ошибка?</target>
        </trans-unit>
        <trans-unit id="deaa0c393a6613972aaccbf1fecfdad67aa21e88" translate="yes" xml:space="preserve">
          <source>MySQL</source>
          <target state="translated">MySQL</target>
        </trans-unit>
        <trans-unit id="424aa797f42c3aefebeedcebb618509b36642239" translate="yes" xml:space="preserve">
          <source>MySQL supports the UPDATE FROM idea, but it does so without using a FROM clause. Instead, the complete join specification is given in between the UPDATE and SET keywords. The equivalent MySQL statement would be like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5d56b96c147bc00244a87ca5dec3dbb343c2acd" translate="yes" xml:space="preserve">
          <source>MySQL version 3.23.41 does not support UNION.</source>
          <target state="translated">MySQL версия 3.23.41 не поддерживает UNION.</target>
        </trans-unit>
        <trans-unit id="e303d2711b51452d1cb5f1e99368e6acecd1238f" translate="yes" xml:space="preserve">
          <source>MySQL:</source>
          <target state="translated">MySQL:</target>
        </trans-unit>
        <trans-unit id="b51a60734da64be0e618bacbea2865a8a7dcd669" translate="yes" xml:space="preserve">
          <source>N</source>
          <target state="translated">N</target>
        </trans-unit>
        <trans-unit id="8942124b2b322d5ed5aaedb0379f2b4629d337ae" translate="yes" xml:space="preserve">
          <source>N&amp;ge;12 and even</source>
          <target state="translated">N&amp;ge;12 и даже</target>
        </trans-unit>
        <trans-unit id="65234a7e6be9327b0d7bbc7e6bf2ce41cdf5a33b" translate="yes" xml:space="preserve">
          <source>N&amp;ge;13 and odd</source>
          <target state="translated">N&amp;ge;13 и нечетное</target>
        </trans-unit>
        <trans-unit id="4bbff46d5e4a2066e44932399c1db699e807cf39" translate="yes" xml:space="preserve">
          <source>N+1</source>
          <target state="translated">N+1</target>
        </trans-unit>
        <trans-unit id="bd2f53c8c05f137a14d10bbea3ef6da285114906" translate="yes" xml:space="preserve">
          <source>N+4</source>
          <target state="translated">N+4</target>
        </trans-unit>
        <trans-unit id="08d2e98e6754af941484848930ccbaddfefe13d6" translate="yes" xml:space="preserve">
          <source>N/A</source>
          <target state="translated">N/A</target>
        </trans-unit>
        <trans-unit id="8dd6dc5b4967e63a1a79c5eb2a6c948692613a58" translate="yes" xml:space="preserve">
          <source>N1 (cost: 5.52)</source>
          <target state="translated">N1 (стоимость:5,52)</target>
        </trans-unit>
        <trans-unit id="798d9ffe324145d7424e3df912c7130f87d2bc5a" translate="yes" xml:space="preserve">
          <source>N2 (cost: 5.52)</source>
          <target state="translated">N2 (стоимость:5,52)</target>
        </trans-unit>
        <trans-unit id="15fbf39b576cc8bd369719e2a3d26f97ec889560" translate="yes" xml:space="preserve">
          <source>N2-N1 (cost: 11.04)</source>
          <target state="translated">N2-N1 (стоимость:11.04)</target>
        </trans-unit>
        <trans-unit id="5b4ea6d782abcd0ed1483d887c331af67374531e" translate="yes" xml:space="preserve">
          <source>N&lt;sub&gt;&lt;small&gt;left&lt;/small&gt;&lt;/sub&gt;</source>
          <target state="translated">N&lt;sub&gt;&lt;small&gt;left&lt;/small&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="e5c2df06ba96ff92a5b489615f6b10abd3bf147f" translate="yes" xml:space="preserve">
          <source>N&lt;sub&gt;&lt;small&gt;left&lt;/small&gt;&lt;/sub&gt;&amp;times;N&lt;sub&gt;&lt;small&gt;right&lt;/small&gt;&lt;/sub&gt;</source>
          <target state="translated">N&lt;sub&gt;&lt;small&gt;left&lt;/small&gt;&lt;/sub&gt;&amp;times;N&lt;sub&gt;&lt;small&gt;right&lt;/small&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="2c0a1bee57f9f58fc50d516a0bf15f88caa7689c" translate="yes" xml:space="preserve">
          <source>N&lt;sub&gt;&lt;small&gt;right&lt;/small&gt;&lt;/sub&gt;</source>
          <target state="translated">N&lt;sub&gt;&lt;small&gt;right&lt;/small&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="a9d371451b6909ac85117130b9153a96499a362c" translate="yes" xml:space="preserve">
          <source>NAME</source>
          <target state="translated">NAME</target>
        </trans-unit>
        <trans-unit id="5b0ac1bba3d09af88af51314ab9e3274563ae94b" translate="yes" xml:space="preserve">
          <source>NATIVE CHARACTER(70)</source>
          <target state="translated">РОДНОЙ СИМВОЛ(70)</target>
        </trans-unit>
        <trans-unit id="7b0c42d6ea58612c19c7961351b229254674e033" translate="yes" xml:space="preserve">
          <source>NATURAL</source>
          <target state="translated">NATURAL</target>
        </trans-unit>
        <trans-unit id="ea1a1d896196c614eb971163bd79e6b0f3ccbe73" translate="yes" xml:space="preserve">
          <source>NB: This extension is deprecated. [WAL mode] is recommended as a replacement.</source>
          <target state="translated">NB:Это расширение устарело.В качестве замены рекомендуется [режим WAL].</target>
        </trans-unit>
        <trans-unit id="9829174ea4702c19a86b2f2d0ae072ffd5bcdee0" translate="yes" xml:space="preserve">
          <source>NCHAR(55)</source>
          <target state="translated">NCHAR(55)</target>
        </trans-unit>
        <trans-unit id="b7fe5d20802ca2aca87db42d4b7dae9f148c0ed7" translate="yes" xml:space="preserve">
          <source>NEAR queries</source>
          <target state="translated">запросы NEAR</target>
        </trans-unit>
        <trans-unit id="ad140e1560939f826df416c1e0d8f81eaa5dd26a" translate="yes" xml:space="preserve">
          <source>NEAR queries are not available.</source>
          <target state="translated">Запросы NEAR недоступны.</target>
        </trans-unit>
        <trans-unit id="9bbceb6fd3a09583f532267c802c583270b6ed37" translate="yes" xml:space="preserve">
          <source>NEVER(X)</source>
          <target state="translated">NEVER(X)</target>
        </trans-unit>
        <trans-unit id="97b77dd54bade796fe382680ffda0d54d204b7ea" translate="yes" xml:space="preserve">
          <source>NEW and OLD references are valid</source>
          <target state="translated">Действительны НОВЫЕ и СТАРШИЕ ссылки</target>
        </trans-unit>
        <trans-unit id="a82d81a38474e7a2f1b05be86c3d0ec157924da9" translate="yes" xml:space="preserve">
          <source>NEW references are valid</source>
          <target state="translated">Действительны НОВЫЕ ссылки</target>
        </trans-unit>
        <trans-unit id="aa7b193ecb5f5e8127c45d86d672c669b4ad311a" translate="yes" xml:space="preserve">
          <source>NNN</source>
          <target state="translated">NNN</target>
        </trans-unit>
        <trans-unit id="cf99bc0053e83f8041fe548005de7972be838e08" translate="yes" xml:space="preserve">
          <source>NNN days</source>
          <target state="translated">NNN дни</target>
        </trans-unit>
        <trans-unit id="33c4ffa6e43390375c0bf9b4e04eedef73776044" translate="yes" xml:space="preserve">
          <source>NNN hours</source>
          <target state="translated">NNN часы</target>
        </trans-unit>
        <trans-unit id="4dc2b6e588bcda89bc862d480bc0a6894df9769a" translate="yes" xml:space="preserve">
          <source>NNN minutes</source>
          <target state="translated">NNN минут</target>
        </trans-unit>
        <trans-unit id="bf0082b4c02bd0d30ff30874661f393df82750f4" translate="yes" xml:space="preserve">
          <source>NNN months</source>
          <target state="translated">NNN месяцы</target>
        </trans-unit>
        <trans-unit id="afb2dbb2fb0e9adb5cd092d7e7b6d3ffb78523de" translate="yes" xml:space="preserve">
          <source>NNN years</source>
          <target state="translated">NNN годы</target>
        </trans-unit>
        <trans-unit id="b58c197b751c5ed1962a3c0390de8c10bb4951b3" translate="yes" xml:space="preserve">
          <source>NNN.NNNN seconds</source>
          <target state="translated">NNNN.NNNN секунд</target>
        </trans-unit>
        <trans-unit id="a0509b7780628bd9d9abc7eb8a2163477341053a" translate="yes" xml:space="preserve">
          <source>NO</source>
          <target state="translated">NO</target>
        </trans-unit>
        <trans-unit id="05fdd36e7692e52033451b07ec66dff9eb7e55c8" translate="yes" xml:space="preserve">
          <source>NOCASE</source>
          <target state="translated">NOCASE</target>
        </trans-unit>
        <trans-unit id="0654a028e5aea48c8fbb09871b8f397a186c883b" translate="yes" xml:space="preserve">
          <source>NONE</source>
          <target state="translated">NONE</target>
        </trans-unit>
        <trans-unit id="969e7d8dee132181523a501a068fec75bded3005" translate="yes" xml:space="preserve">
          <source>NOT</source>
          <target state="translated">NOT</target>
        </trans-unit>
        <trans-unit id="13e8b0dd0b366e8464e50db4ffa83a38db17f5c0" translate="yes" xml:space="preserve">
          <source>NOT EXISTS operator</source>
          <target state="translated">НЕ ВЫПАДАЕТ оператор</target>
        </trans-unit>
        <trans-unit id="c251201ede2fa823c20c38c57254fd75c17ce421" translate="yes" xml:space="preserve">
          <source>NOT IN operator</source>
          <target state="translated">НЕ В СЛУЧАЕ НЕОБХОДИМОСТИ</target>
        </trans-unit>
        <trans-unit id="f4a4efddb03a7d76572898f7eabe1ea34a780b2f" translate="yes" xml:space="preserve">
          <source>NOT NULL constraint</source>
          <target state="translated">НЕ НУЛЬШЕЕ ограничение</target>
        </trans-unit>
        <trans-unit id="6ff7e3eeee65666114a7a3854176937e0d8c1522" translate="yes" xml:space="preserve">
          <source>NOT NULL constraints are honored.</source>
          <target state="translated">НЕ НУЛЬШИЕ ограничения соблюдаются.</target>
        </trans-unit>
        <trans-unit id="c462e8fc3e502ae6d5489c34ffa0054b7073578f" translate="yes" xml:space="preserve">
          <source>NOTHING</source>
          <target state="translated">NOTHING</target>
        </trans-unit>
        <trans-unit id="d6a7f5abac5bd9faa0bac9e8bb7907ab9f614941" translate="yes" xml:space="preserve">
          <source>NOTNULL</source>
          <target state="translated">NOTNULL</target>
        </trans-unit>
        <trans-unit id="4771b572fc1de8c483abeb1a95a1bc516fa56a87" translate="yes" xml:space="preserve">
          <source>NUL characters (ASCII code 0x00 and Unicode \u0000) may appear in the middle of strings in SQLite. This can lead to unexpected behavior. See the &quot;&lt;a href=&quot;nulinstr&quot;&gt;NUL characters in strings&lt;/a&gt;&quot; document for further information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eef19c54306daa69eda49c0272623bdb5e2b341f" translate="yes" xml:space="preserve">
          <source>NULL</source>
          <target state="translated">NULL</target>
        </trans-unit>
        <trans-unit id="0d475d854a2a7eeffd82e1a01f92ca65e566328f" translate="yes" xml:space="preserve">
          <source>NULL Handling in SQLite</source>
          <target state="translated">NULL-обработка в SQLite</target>
        </trans-unit>
        <trans-unit id="7fac7bb3c1a767adbbac557d34135fb142c688ca" translate="yes" xml:space="preserve">
          <source>NULL Handling in SQLite Versus Other Database Engines</source>
          <target state="translated">NULL-обработка в SQLite против других двигателей баз данных</target>
        </trans-unit>
        <trans-unit id="248ab3abcb099e69f2fef53b64e651576012c852" translate="yes" xml:space="preserve">
          <source>NULL values (serial type 0) sort first.</source>
          <target state="translated">NULL-значения (последовательный тип 0)сортируются первыми.</target>
        </trans-unit>
        <trans-unit id="a1efa1e3b6119cae6664d71bdefea57f479d6ebf" translate="yes" xml:space="preserve">
          <source>NULL values are now reported to the callback as a NULL pointer rather than an empty string.</source>
          <target state="translated">NULL-значения теперь сообщаются в обратном вызове как NULL указатель,а не как пустая строка.</target>
        </trans-unit>
        <trans-unit id="743ef19013396d7d94a24cacbb830235275be9c8" translate="yes" xml:space="preserve">
          <source>NULLS</source>
          <target state="translated">NULLS</target>
        </trans-unit>
        <trans-unit id="fc81819cf87d3384597c4ae67d1976d82323a9b0" translate="yes" xml:space="preserve">
          <source>NULLS LAST</source>
          <target state="translated">ПОСЛЕДНИЙ</target>
        </trans-unit>
        <trans-unit id="8280c934b3178b2afed2c01f955aab5fe7295999" translate="yes" xml:space="preserve">
          <source>NULLs sort first</source>
          <target state="translated">NULLs сортируются первыми</target>
        </trans-unit>
        <trans-unit id="58ad270de77802cc63222e273fa800c4b248cdd7" translate="yes" xml:space="preserve">
          <source>NUMERIC</source>
          <target state="translated">NUMERIC</target>
        </trans-unit>
        <trans-unit id="024959fd2d5e8c9c205a2098591019699ae29143" translate="yes" xml:space="preserve">
          <source>NVARCHAR(100)</source>
          <target state="translated">NVARCHAR(100)</target>
        </trans-unit>
        <trans-unit id="709a23220f2c3d64d1e1d6d18c4d5280f8d82fca" translate="yes" xml:space="preserve">
          <source>Name</source>
          <target state="translated">Name</target>
        </trans-unit>
        <trans-unit id="daa5b774be0bfcbd2e2835e6bd0980fb6e06778a" translate="yes" xml:space="preserve">
          <source>Name Of A Host Parameter</source>
          <target state="translated">Имя параметра хозяина</target>
        </trans-unit>
        <trans-unit id="cb9e33f6b09bb7fe5d38a783b74c6905b2f43077" translate="yes" xml:space="preserve">
          <source>Name Of The Folder Holding Database Files</source>
          <target state="translated">Имя файла базы данных,хранящегося в папке</target>
        </trans-unit>
        <trans-unit id="7749c218b18b42cbe27f3f870da40b8d3d708ba1" translate="yes" xml:space="preserve">
          <source>Name Of The Folder Holding Temporary Files</source>
          <target state="translated">Имя папки,хранящей временные файлы</target>
        </trans-unit>
        <trans-unit id="fbb9c33e0412f25c0e798fd22a36fd452bd92012" translate="yes" xml:space="preserve">
          <source>Name of default collation sequence</source>
          <target state="translated">Имя последовательности сверки по умолчанию</target>
        </trans-unit>
        <trans-unit id="4e3a9de996d9196b59f293d51cf53aa5b2a8a36e" translate="yes" xml:space="preserve">
          <source>Named window-defn clauses may also be added to a SELECT statement using a WINDOW clause and then referred to by name within window function invocations. For example, the following SELECT statement contains two named window-defs clauses, &quot;win1&quot; and &quot;win2&quot;:</source>
          <target state="translated">Именованные клаузулы window-defn также могут быть добавлены в оператор SELECT с помощью клаузулы WINDOW,а затем на них можно ссылаться по имени в вызовах оконных функций.Например,следующий оператор SELECT содержит два именованных пункта windows-defs-&quot;win1&quot; и &quot;win2&quot;:</target>
        </trans-unit>
        <trans-unit id="02aead4c6c683a05b1c0ebf7ea825cf0f6d1b06c" translate="yes" xml:space="preserve">
          <source>Naming Changes</source>
          <target state="translated">Изменения в наименовании</target>
        </trans-unit>
        <trans-unit id="f736bf35e196e5f8a2152cf612783a7b401c2cad" translate="yes" xml:space="preserve">
          <source>Ne</source>
          <target state="translated">Ne</target>
        </trans-unit>
        <trans-unit id="28477357de69f5526193889fda40ed45cd101a03" translate="yes" xml:space="preserve">
          <source>Nearly all systems have the ability to call libraries written in C. This is not true of other implementation languages.</source>
          <target state="translated">Почти все системы имеют возможность вызывать библиотеки,написанные на C.Это не относится к другим языкам реализации.</target>
        </trans-unit>
        <trans-unit id="a37e5d1459b64bbf0f387b130668f0c8c4924e69" translate="yes" xml:space="preserve">
          <source>Negative numbers in the &quot;.width&quot; command cause right-alignment</source>
          <target state="translated">Отрицательные числа в команде &quot;.width&quot; вызывают выравнивание вправо.</target>
        </trans-unit>
        <trans-unit id="fec37acea6ebcef8454c4fc958c0b8f34d2b8c80" translate="yes" xml:space="preserve">
          <source>Nested transactions using &lt;a href=&quot;lang_savepoint&quot;&gt;SAVEPOINT&lt;/a&gt;, &lt;a href=&quot;lang_savepoint&quot;&gt;RELEASE&lt;/a&gt;, and &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK TO&lt;/a&gt;</source>
          <target state="translated">Вложенные транзакции с использованием &lt;a href=&quot;lang_savepoint&quot;&gt;SAVEPOINT&lt;/a&gt; , &lt;a href=&quot;lang_savepoint&quot;&gt;RELEASE&lt;/a&gt; и &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK TO&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9c791dcaae3666d9984fccf3b99d9aec11d78e88" translate="yes" xml:space="preserve">
          <source>Never despair of God's mercy.</source>
          <target state="translated">Никогда не отчаивайся от милости Божьей.</target>
        </trans-unit>
        <trans-unit id="cb1f0a8ca1cbcde19e25e6a553a1aa4154cf9c78" translate="yes" xml:space="preserve">
          <source>Nevertheless, application developers are admonished to monitor the state of the memory allocation subsystems and raise alarms when memory usage approaches or exceeds Robson limits. In this way, the application will provide operators with abundant warning well in advance of failure. The &lt;a href=&quot;malloc#memstatus&quot;&gt;memory statistics&lt;/a&gt; interfaces of SQLite provide the application with all the mechanism necessary to complete the monitoring portion of this task.</source>
          <target state="translated">Тем не менее, разработчикам приложений рекомендуется отслеживать состояние подсистем распределения памяти и подавать сигналы тревоги, когда использование памяти приближается к пределам Робсона или превышает их. Таким образом, приложение будет предоставлять операторам подробные предупреждения задолго до сбоя. Интерфейсы &lt;a href=&quot;malloc#memstatus&quot;&gt;статистики памяти&lt;/a&gt; SQLite предоставляют приложению все механизмы, необходимые для выполнения части мониторинга этой задачи.</target>
        </trans-unit>
        <trans-unit id="b14d2dd89e46e860f7449a61cc79bde67323500f" translate="yes" xml:space="preserve">
          <source>Nevertheless, bugs happen. If you are writing an application that sends untrusted SQL inputs or database files to SQLite, there are additional steps you can take to help reduce the attack surface and prevent zero-day exploits caused by undetected bugs.</source>
          <target state="translated">Тем не менее,жуки случаются.Если вы пишете приложение,которое посылает недоверенные SQL входы или файлы базы данных на SQLite,есть дополнительные шаги,которые помогут уменьшить поверхность атаки и предотвратить эксплойты нулевого дня,вызванные необнаруженными ошибками.</target>
        </trans-unit>
        <trans-unit id="fe8f48a38c1ee2d5e1ec0b569c50eb0f4be22e0d" translate="yes" xml:space="preserve">
          <source>Nevertheless, integer overflow in the computation of memory allocation sizes is a concern that SQLite would like to deal with. To prevent problems, all SQLite internal memory allocations occur using thin wrapper functions that take a signed 64-bit integer size parameter. The SQLite source code is audited to ensure that all size computations are carried out using 64-bit signed integers as well. SQLite will refuse to allocate more than about 2GB of memory at one go. (In common use, SQLite seldom ever allocates more than about 8KB of memory at a time so a 2GB allocation limit is not a burden.) So the 64-bit size parameter provides lots of headroom for detecting overflows. The same audit that verifies that all size computations are done as 64-bit signed integers also verifies that it is impossible to overflow a 64-bit integer during the computation.</source>
          <target state="translated">Тем не менее,целочисленное переполнение при вычислении размеров выделения памяти является проблемой,с которой SQLite хотел бы иметь дело.Для предотвращения проблем все выделения внутренней памяти SQLite происходят с использованием тонких оберточных функций,которые принимают знаковый 64-битный целочисленный параметр размера.Исходный код SQLite проверяется на предмет того,что все вычисления размера выполняются и с использованием 64-битных подписанных целых чисел.SQLite откажется выделять более 2 Гб памяти за один раз.(Обычно SQLite редко выделяет более 8 КБ памяти за один раз,поэтому лимит выделения 2 ГБ не является обузой).Таким образом,параметр 64-битного размера предоставляет много места для обнаружения переполнений.Тот же самый аудит,который проверяет,что все вычисления размера выполняются в виде 64-битных подписанных целых чисел,также проверяет невозможность переполнения 64-битного целого при вычислении.</target>
        </trans-unit>
        <trans-unit id="e49fc674e296beca34786edd4c2b299863546a78" translate="yes" xml:space="preserve">
          <source>Nevertheless, no software is 100% perfect. There have been a few historical bugs in SQLite (now fixed) that could cause database corruption. And there may be yet a few more that remain undiscovered. Because of the extensive testing and widespread use of SQLite, bugs that result in database corruption tend to be very obscure. The likelihood of an application encountering an SQLite bug is small. To illustrate this, an account is given below of all database-corruption bugs found in SQLite during the four-year period from 2009-04-01 to 2013-04-15. This account should give the reader an intuitive sense of the kinds of bugs in SQLite that manage to slip through testing procedures and make it into a release.</source>
          <target state="translated">Тем не менее,ни одно программное обеспечение не идеально на 100%.В SQLite было несколько исторических ошибок (теперь исправлено),которые могли привести к повреждению базы данных.И,возможно,есть еще несколько,которые остаются нераскрытыми.Из-за обширного тестирования и широкого использования SQLite,ошибки,которые приводят к повреждению базы данных,как правило,очень малоизвестны.Вероятность того,что приложение столкнется с ошибкой SQLite,невелика.Чтобы проиллюстрировать это,ниже приведен аккаунт всех ошибок,связанных с коррупцией баз данных,обнаруженных в SQLite за четырехлетний период с 2009-04-01 по 2013-04-15 гг.Этот аккаунт должен дать читателю интуитивное представление о том,какие ошибки в SQLite удается проскользнуть через процедуры тестирования и превратить его в релиз.</target>
        </trans-unit>
        <trans-unit id="0116882452ef2d4b8e1293a906b669874cb29ba7" translate="yes" xml:space="preserve">
          <source>New &lt;a href=&quot;compile#omitfeatures&quot;&gt;SQLITE_OMIT_...&lt;/a&gt; compile-time options added</source>
          <target state="translated">&lt;a href=&quot;compile#omitfeatures&quot;&gt;Добавлены&lt;/a&gt; новые параметры времени компиляции SQLITE_OMIT _...</target>
        </trans-unit>
        <trans-unit id="75836f6f6b6f280ffed2e7c97c8de38d49f8b36b" translate="yes" xml:space="preserve">
          <source>New Change</source>
          <target state="translated">Новое изменение</target>
        </trans-unit>
        <trans-unit id="519eb3711af9fb8ce8d81cf7983b569f9b988fc0" translate="yes" xml:space="preserve">
          <source>New File Format</source>
          <target state="translated">Новый формат файла</target>
        </trans-unit>
        <trans-unit id="05a025f4bcdcce620e0b66e603b7b96a2aa62567" translate="yes" xml:space="preserve">
          <source>New HH:MM:SS modifier to the built-in date/time functions.</source>
          <target state="translated">Новый модификатор HH:MM:SS для встроенных функций даты/времени.</target>
        </trans-unit>
        <trans-unit id="35afb195f0b01edb4e7140e0f143cfa5913617eb" translate="yes" xml:space="preserve">
          <source>New VFSes are registered with sqlite3_vfs_register(). Each new VFS becomes the default VFS if the makeDflt flag is set. The same VFS can be registered multiple times without injury. To make an existing VFS into the default VFS, register it again with the makeDflt flag set. If two different VFSes with the same name are registered, the behavior is undefined. If a VFS is registered with a name that is NULL or an empty string, then the behavior is undefined.</source>
          <target state="translated">Новые VFSes регистрируются функцией sqlite3_vfs_register().Каждая новая VFS становится VFS по умолчанию,если установлен флаг makeDflt.Одна и та же VFS может быть зарегистрирована несколько раз без повреждений.Чтобы превратить существующую VFS в VFS по умолчанию,зарегистрируйте ее снова с установленным флагом makeDflt.Если зарегистрированы две разные VFS с одним и тем же именем,поведение будет неопределенным.Если VFS регистрируется с именем NULL или пустой строкой,поведение будет неопределенным.</target>
        </trans-unit>
        <trans-unit id="9e6d8977d2335274bf96388fe98628d1d0b7e083" translate="yes" xml:space="preserve">
          <source>New applications should always invoke &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; instead of &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt;. The older &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; is retained for backwards compatibility. But &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; provides a much better interface.</source>
          <target state="translated">Новые приложения всегда должны вызывать &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; вместо &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare ()&lt;/a&gt; . Более старый &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare ()&lt;/a&gt; сохранен для обратной совместимости. Но &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; предоставляет гораздо лучший интерфейс.</target>
        </trans-unit>
        <trans-unit id="741f30a581517ffe6e7dcd8b6f50643914279724" translate="yes" xml:space="preserve">
          <source>New configuration options may be added in future releases of SQLite. Existing configuration options might be discontinued. Applications should check the return code from &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config()&lt;/a&gt; to make sure that the call worked. The &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config()&lt;/a&gt; interface will return a non-zero &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; if a discontinued or unsupported configuration option is invoked.</source>
          <target state="translated">В будущих выпусках SQLite могут быть добавлены новые параметры конфигурации. Существующие параметры конфигурации могут быть прекращены. Приложения должны проверить код возврата из &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config (),&lt;/a&gt; чтобы убедиться, что вызов сработал. Интерфейс &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config ()&lt;/a&gt; вернет ненулевой &lt;a href=&quot;rescode&quot;&gt;код ошибки,&lt;/a&gt; если вызывается неподдерживаемый или неподдерживаемый параметр конфигурации.</target>
        </trans-unit>
        <trans-unit id="dfd7ca29d835fc9c4dbb0540c0bcc6f89fdaa393" translate="yes" xml:space="preserve">
          <source>New configuration options may be added in future releases of SQLite. Existing configuration options might be discontinued. Applications should check the return code from &lt;a href=&quot;#sqlite3_db_config&quot;&gt;sqlite3_db_config()&lt;/a&gt; to make sure that the call worked. The &lt;a href=&quot;#sqlite3_db_config&quot;&gt;sqlite3_db_config()&lt;/a&gt; interface will return a non-zero &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; if a discontinued or unsupported configuration option is invoked.</source>
          <target state="translated">В будущих выпусках SQLite могут быть добавлены новые параметры конфигурации. Существующие параметры конфигурации могут быть прекращены. Приложения должны проверить код возврата из &lt;a href=&quot;#sqlite3_db_config&quot;&gt;sqlite3_db_config (),&lt;/a&gt; чтобы убедиться, что вызов сработал. Интерфейс &lt;a href=&quot;#sqlite3_db_config&quot;&gt;sqlite3_db_config ()&lt;/a&gt; вернет ненулевой &lt;a href=&quot;rescode&quot;&gt;код ошибки,&lt;/a&gt; если вызывается неподдерживаемый или неподдерживаемый параметр конфигурации.</target>
        </trans-unit>
        <trans-unit id="290c5a063c07711b910fa8250f0c45e5e6c8d5a9" translate="yes" xml:space="preserve">
          <source>New configuration options may be added in future releases of SQLite. Existing configuration options might be discontinued. Applications should check the return code from &lt;a href=&quot;config&quot;&gt;sqlite3_config()&lt;/a&gt; to make sure that the call worked. The &lt;a href=&quot;config&quot;&gt;sqlite3_config()&lt;/a&gt; interface will return a non-zero &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; if a discontinued or unsupported configuration option is invoked.</source>
          <target state="translated">В будущих выпусках SQLite могут быть добавлены новые параметры конфигурации. Существующие параметры конфигурации могут быть прекращены. Приложения должны проверить код возврата из &lt;a href=&quot;config&quot;&gt;sqlite3_config (),&lt;/a&gt; чтобы убедиться, что вызов сработал. Интерфейс &lt;a href=&quot;config&quot;&gt;sqlite3_config ()&lt;/a&gt; вернет ненулевой &lt;a href=&quot;../rescode&quot;&gt;код ошибки,&lt;/a&gt; если вызывается неподдерживаемый или неподдерживаемый параметр конфигурации.</target>
        </trans-unit>
        <trans-unit id="bef0fe1db7b5b12623a7cb6dd11860448e032b3e" translate="yes" xml:space="preserve">
          <source>New configuration options may be added in future releases of SQLite. Existing configuration options might be discontinued. Applications should check the return code from &lt;a href=&quot;db_config&quot;&gt;sqlite3_db_config()&lt;/a&gt; to make sure that the call worked. The &lt;a href=&quot;db_config&quot;&gt;sqlite3_db_config()&lt;/a&gt; interface will return a non-zero &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; if a discontinued or unsupported configuration option is invoked.</source>
          <target state="translated">В будущих выпусках SQLite могут быть добавлены новые параметры конфигурации. Существующие параметры конфигурации могут быть прекращены. Приложения должны проверить код возврата из &lt;a href=&quot;db_config&quot;&gt;sqlite3_db_config (),&lt;/a&gt; чтобы убедиться, что вызов сработал. Интерфейс &lt;a href=&quot;db_config&quot;&gt;sqlite3_db_config ()&lt;/a&gt; вернет ненулевой &lt;a href=&quot;../rescode&quot;&gt;код ошибки,&lt;/a&gt; если вызывается неподдерживаемый или неподдерживаемый параметр конфигурации.</target>
        </trans-unit>
        <trans-unit id="b448decebb78010dbfebbde65087fb4a352a7ae8" translate="yes" xml:space="preserve">
          <source>New database files created by SQLite use format 4 by default. The &lt;a href=&quot;pragma#pragma_legacy_file_format&quot;&gt;legacy_file_format pragma&lt;/a&gt; can be used to cause SQLite to create new database files using format 1. The format version number can be made to default to 1 instead of 4 by setting &lt;a href=&quot;compile#default_file_format&quot;&gt;SQLITE_DEFAULT_FILE_FORMAT&lt;/a&gt;=1 at compile-time.</source>
          <target state="translated">Новые файлы базы данных, созданные SQLite, по умолчанию используют формат 4. &lt;a href=&quot;pragma#pragma_legacy_file_format&quot;&gt;Legacy_file_format прагма&lt;/a&gt; может быть использован , чтобы вызвать SQLite для создания новых файлов базы данных с использованием формата 1. Формат номера версии можно по умолчанию 1 вместо 4, установив &lt;a href=&quot;compile#default_file_format&quot;&gt;SQLITE_DEFAULT_FILE_FORMAT&lt;/a&gt; = 1 во время компиляции.</target>
        </trans-unit>
        <trans-unit id="7fae2a2a8fa480fb532533df6e47c596e4029933" translate="yes" xml:space="preserve">
          <source>New error codes may be added in future versions of SQLite.</source>
          <target state="translated">Новые коды ошибок могут быть добавлены в будущие версии SQLite.</target>
        </trans-unit>
        <trans-unit id="02a2eef012a8248fed2ec4a5f4418e441dee6267" translate="yes" xml:space="preserve">
          <source>New extensions:</source>
          <target state="translated">Новые расширения:</target>
        </trans-unit>
        <trans-unit id="c375e60e4ec3e7a7421f6f6fc9277a408ea2286e" translate="yes" xml:space="preserve">
          <source>New file format that is 25% to 35% smaller for typical use.</source>
          <target state="translated">Новый формат файла,который на 25%-35% меньше для типичного использования.</target>
        </trans-unit>
        <trans-unit id="fd04fa0f053215d42b7f8b539b38e361266bd4c9" translate="yes" xml:space="preserve">
          <source>New flags may be added in future releases of SQLite.</source>
          <target state="translated">Новые флаги могут быть добавлены в будущих релизах SQLite.</target>
        </trans-unit>
        <trans-unit id="609f25b82bb11b34abf866257917b5188d15ee70" translate="yes" xml:space="preserve">
          <source>New interface &lt;a href=&quot;c3ref/context_db_handle&quot;&gt;sqlite3_context_db_handle()&lt;/a&gt; that returns the &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; handle that has invoked an application-defined SQL function.</source>
          <target state="translated">Новый интерфейс &lt;a href=&quot;c3ref/context_db_handle&quot;&gt;sqlite3_context_db_handle (),&lt;/a&gt; который возвращает дескриптор &lt;a href=&quot;c3ref/sqlite3&quot;&gt;соединения&lt;/a&gt; с базой данных , который вызвал определяемую приложением функцию SQL.</target>
        </trans-unit>
        <trans-unit id="97e454a0ee0ddbdb1207081ac8f340c9145f813d" translate="yes" xml:space="preserve">
          <source>New interface &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit()&lt;/a&gt; allows size and length limits to be set on a per-connection basis and at run-time.</source>
          <target state="translated">Новый интерфейс &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit ()&lt;/a&gt; позволяет устанавливать ограничения размера и длины для каждого соединения и во время выполнения.</target>
        </trans-unit>
        <trans-unit id="351a6ce815b5dd18ffcf850d512cce2a33e3cd28" translate="yes" xml:space="preserve">
          <source>New interface: sqlite3_bind_parameter_index()</source>
          <target state="translated">Новый интерфейс:sqlite3_bind_parameter_index()</target>
        </trans-unit>
        <trans-unit id="ff421fae0557a39a0bd809f33195e163ee4bb7ae" translate="yes" xml:space="preserve">
          <source>New interfaces added to the test_quota.c add-on module.</source>
          <target state="translated">В дополнение к test_quota.c добавлены новые интерфейсы.</target>
        </trans-unit>
        <trans-unit id="ae3613412d28080958e2d37e217b087b523b9aae" translate="yes" xml:space="preserve">
          <source>New internal schema objects names, always beginning with &quot;sqlite_&quot;, may be added to the SQLite file format in future releases.</source>
          <target state="translated">Новые имена внутренних объектов схемы,всегда начинающиеся с &quot;sqlite_&quot;,могут быть добавлены в формат файла SQLite в будущих релизах.</target>
        </trans-unit>
        <trans-unit id="26bcef71ccfa90b2e0cbb123ce577eb05e69bad7" translate="yes" xml:space="preserve">
          <source>New memory allocators do not have to be part of the SQLite source tree nor included in the sqlite3.c &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt;. Individual applications can supply their own memory allocators to SQLite at start-time.</source>
          <target state="translated">Новые распределители памяти не обязательно должны быть частью дерева исходных текстов SQLite или включаться в &lt;a href=&quot;amalgamation&quot;&gt;объединение&lt;/a&gt; sqlite3.c . Отдельные приложения могут предоставлять свои собственные распределители памяти для SQLite во время запуска.</target>
        </trans-unit>
        <trans-unit id="5e4800161f51168ad45c54c49952a916eb4c7f5a" translate="yes" xml:space="preserve">
          <source>New options to the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; for configuring auxiliary memory usage: --pagecache, --lookaside, and --scratch.</source>
          <target state="translated">Новые параметры &lt;a href=&quot;cli&quot;&gt;оболочки командной строки&lt;/a&gt; для настройки использования вспомогательной памяти: --pagecache, --lookaside и --scratch.</target>
        </trans-unit>
        <trans-unit id="33b435c4ed8f9927e4700fe7e7aeadeae900e749" translate="yes" xml:space="preserve">
          <source>New query optimizations:</source>
          <target state="translated">Новые оптимизации запросов:</target>
        </trans-unit>
        <trans-unit id="27a96e272ba4064e97b901622de6fb30f7bc2a07" translate="yes" xml:space="preserve">
          <source>New run-time limit categories may be added in future releases.</source>
          <target state="translated">В будущих релизах могут быть добавлены новые категории ограничений по времени исполнения.</target>
        </trans-unit>
        <trans-unit id="aa7ba8a90d79e3949a9a92f1f6dd6361b3924b13" translate="yes" xml:space="preserve">
          <source>New status parameters may be added from time to time.</source>
          <target state="translated">Время от времени могут добавляться новые параметры состояния.</target>
        </trans-unit>
        <trans-unit id="8001d5465bcc215e617045ec61b342b4c0fbe511" translate="yes" xml:space="preserve">
          <source>New tests added to the test suite.</source>
          <target state="translated">В набор тестов добавлены новые тесты.</target>
        </trans-unit>
        <trans-unit id="19df796618ecb880621a1ff2386886f64457fe9e" translate="yes" xml:space="preserve">
          <source>New text tokens may be added to the end of the stat column in future enhancements to SQLite. For compatibility, unrecognized tokens at the end of the stat column are silently ignored.</source>
          <target state="translated">Новые текстовые маркеры могут быть добавлены в конец колонки &quot;Статистика&quot; в будущих улучшениях SQLite.Для совместимости непризнанные маркеры в конце колонки stat игнорируются.</target>
        </trans-unit>
        <trans-unit id="d23050a62d4b2ebb32c827e3e8678911cb996090" translate="yes" xml:space="preserve">
          <source>New tracing constants may be added in future releases.</source>
          <target state="translated">В будущих выпусках могут быть добавлены новые константы трассировки.</target>
        </trans-unit>
        <trans-unit id="8ec81cf9bf3ff78a39346bf7439447032b8bc32c" translate="yes" xml:space="preserve">
          <source>New verbs may be added in future releases of SQLite. Existing verbs might be discontinued. Applications should check the return code from &lt;a href=&quot;#sqlite3_db_status&quot;&gt;sqlite3_db_status()&lt;/a&gt; to make sure that the call worked. The &lt;a href=&quot;#sqlite3_db_status&quot;&gt;sqlite3_db_status()&lt;/a&gt; interface will return a non-zero error code if a discontinued or unsupported verb is invoked.</source>
          <target state="translated">В будущих выпусках SQLite могут быть добавлены новые команды. Существующие глаголы могут быть прекращены. Приложения должны проверить код возврата от &lt;a href=&quot;#sqlite3_db_status&quot;&gt;sqlite3_db_status (),&lt;/a&gt; чтобы убедиться, что вызов сработал. Интерфейс &lt;a href=&quot;#sqlite3_db_status&quot;&gt;sqlite3_db_status ()&lt;/a&gt; вернет ненулевой код ошибки, если вызывается прекращенная или неподдерживаемая команда.</target>
        </trans-unit>
        <trans-unit id="6997236519e17b29acb8e0c21015208012814bff" translate="yes" xml:space="preserve">
          <source>New verbs may be added in future releases of SQLite. Existing verbs might be discontinued. Applications should check the return code from &lt;a href=&quot;db_status&quot;&gt;sqlite3_db_status()&lt;/a&gt; to make sure that the call worked. The &lt;a href=&quot;db_status&quot;&gt;sqlite3_db_status()&lt;/a&gt; interface will return a non-zero error code if a discontinued or unsupported verb is invoked.</source>
          <target state="translated">В будущих выпусках SQLite могут быть добавлены новые команды. Существующие глаголы могут быть прекращены. Приложения должны проверить код возврата от &lt;a href=&quot;db_status&quot;&gt;sqlite3_db_status (),&lt;/a&gt; чтобы убедиться, что вызов сработал. Интерфейс &lt;a href=&quot;db_status&quot;&gt;sqlite3_db_status ()&lt;/a&gt; вернет ненулевой код ошибки, если вызывается прекращенная или неподдерживаемая команда.</target>
        </trans-unit>
        <trans-unit id="b162b6ee72989cc021180a9aa2d3a7a0e2b57826" translate="yes" xml:space="preserve">
          <source>New zip archives may be constructed entirely within memory using the zipfile() aggregate function. Each row visited by the aggregate function adds an entry to the zip archive. The value returned is a blob containing the entire archive image.</source>
          <target state="translated">Новые zip-архивы могут быть построены полностью в памяти с помощью функции-агрегатора zipfile().Каждая строка,которую посещает агрегатная функция,добавляет запись в zip-архив.Возвращаемое значение представляет собой блок,содержащий весь образ архива.</target>
        </trans-unit>
        <trans-unit id="e327377c14f6ddd81b93544df605d7203e2995e8" translate="yes" xml:space="preserve">
          <source>NewRowid</source>
          <target state="translated">NewRowid</target>
        </trans-unit>
        <trans-unit id="6975bed1eebd03a852e5aa6a11d0f144cd34ff6e" translate="yes" xml:space="preserve">
          <source>Newer disk drives have begun using 4096 byte sectors however. Beginning with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_10.html&quot;&gt;version 3.7.10&lt;/a&gt; (2012-01-16), the SQLite development team experimented with changes xSectorSize to report 4096 bytes as the blast radius. This had the effect of increasing write overhead on many databases. For a database with a &lt;a href=&quot;pragma#pragma_page_size&quot;&gt;PRAGMA page_size&lt;/a&gt; of 1024 (a very common choice) making a change to a single page in the database now requires SQLite to backup three other adjacent pages to the rollback journal, whereas formerly it only had to backup the one page that was changing. In &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt;, each transaction had to be padded out to the next 4096-byte boundary in the WAL file, rather than the next 512-byte boundary, resulting in thousands of extra bytes being written per transaction.</source>
          <target state="translated">Однако более новые диски начали использовать сектора размером 4096 байт. Начиная с &lt;a href=&quot;https://sqlite.org/releaselog/3_7_10.html&quot;&gt;версии&lt;/a&gt; SQLite 3.7.10 (16 января 2012 г. ), команда разработчиков SQLite экспериментировала с изменениями xSectorSize, чтобы указать 4096 байт как радиус взрыва. Это привело к увеличению накладных расходов на запись во многих базах данных. Для базы данных с &lt;a href=&quot;pragma#pragma_page_size&quot;&gt;PRAGMA page_size равным&lt;/a&gt; 1024 (очень распространенный выбор) для внесения изменений на одну страницу в базе данных теперь требуется, чтобы SQLite сделал резервную копию трех других соседних страниц в журнале отката, тогда как раньше требовалось резервное копирование только одной страницы, которая менялось. В &lt;a href=&quot;wal&quot;&gt;режиме WAL&lt;/a&gt; каждая транзакция должна была быть дополнена до следующей границы в 4096 байт в файле WAL, а не до следующей границы в 512 байт, в результате на каждую транзакцию записывались тысячи дополнительных байтов.</target>
        </trans-unit>
        <trans-unit id="bc981983e7f547dc62e19a1e383acfe00782a6d5" translate="yes" xml:space="preserve">
          <source>Next</source>
          <target state="translated">Next</target>
        </trans-unit>
        <trans-unit id="bc1189b8a3e7e2b908b403ea79a8eb14b14bcd47" translate="yes" xml:space="preserve">
          <source>Next, make copies of all the blobs into individual files in a directory using a command like this:</source>
          <target state="translated">Далее,сделайте копии всех блоков в отдельные файлы в каталоге с помощью такой команды:</target>
        </trans-unit>
        <trans-unit id="73f7cfb7746314674a12b8d200b36135947e050b" translate="yes" xml:space="preserve">
          <source>Next, move the resulting kvtest-android executable to the Android device:</source>
          <target state="translated">Далее переместите полученный исполняемый файл kvtest-android на Android-устройство:</target>
        </trans-unit>
        <trans-unit id="21d2b394790e7b47b83f7c9d1daa6c55ee3c0c16" translate="yes" xml:space="preserve">
          <source>Next, suppose that you want to look up the price of not just any orange, but specifically California-grown oranges. The appropriate query would be as follows:</source>
          <target state="translated">Далее,предположим,что вы хотите посмотреть цену не просто на любой апельсин,а именно на выращенные в Калифорнии апельсины.Соответствующий запрос будет выглядеть следующим образом:</target>
        </trans-unit>
        <trans-unit id="816c52fd2bdd94a63cd0944823a6c0aa9384c103" translate="yes" xml:space="preserve">
          <source>No</source>
          <target state="translated">No</target>
        </trans-unit>
        <trans-unit id="dad2991d263e4aa51578f91e92e9777428d9762b" translate="yes" xml:space="preserve">
          <source>No (Note 1)</source>
          <target state="translated">Нет (Примечание 1)</target>
        </trans-unit>
        <trans-unit id="b4f66722cbcf69861e819a02ca8d6803b779fcd3" translate="yes" xml:space="preserve">
          <source>No Isolation Between Operations On The Same Database Connection</source>
          <target state="translated">Нет изоляции между операциями при одном и том же подключении к базе данных.</target>
        </trans-unit>
        <trans-unit id="8dae863821cb04b5484c9a0e7717d726d350b9bd" translate="yes" xml:space="preserve">
          <source>No application file I/O code to write and debug.</source>
          <target state="translated">Нет кода входа/выхода из файла приложения для написания и отладки.</target>
        </trans-unit>
        <trans-unit id="95ec05297c8cafc96feb998f4af109f4728d5530" translate="yes" xml:space="preserve">
          <source>No change</source>
          <target state="translated">Без изменений</target>
        </trans-unit>
        <trans-unit id="7f2ff41fbbf4963dea6c3e81c6aa743e95c596b5" translate="yes" xml:space="preserve">
          <source>No current or conflicting row information is provided. The only function it is possible to call on the supplied sqlite3_changeset_iter handle is sqlite3changeset_fk_conflicts().</source>
          <target state="translated">Никакой текущей или противоречивой информации о строках не предоставляется.Единственная функция,которую можно вызвать на поставляемом дескрипторе sqlite3_changeset_iter-sqlite3changeset_fk_conflicts().</target>
        </trans-unit>
        <trans-unit id="7c5c383086cc31c41ab2122a84d0a48706ccfc11" translate="yes" xml:space="preserve">
          <source>No error is raised if a width or precision exceeds SQLITE_PRINTF_PRECISION_LIMIT. Instead, the large width or precision is silently truncated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="662adfcee595804e0d0a40f3427892366f101024" translate="yes" xml:space="preserve">
          <source>No error messages are generated if an unknown pragma is issued. Unknown pragmas are simply ignored. This means if there is a typo in a pragma statement the library does not inform the user of the fact.</source>
          <target state="translated">Сообщения об ошибках не выдаются,если выдается неизвестная прагма.Неизвестные прагмы просто игнорируются.Это означает,что если в прагматическом высказывании есть опечатка,библиотека не информирует пользователя об этом факте.</target>
        </trans-unit>
        <trans-unit id="36386488a9bfa58ff6f23801ec174053b73ed777" translate="yes" xml:space="preserve">
          <source>No locking style. If none of the above can be supported, this locking style is used. No database locking mechanism is used. When this system is used it is not safe for a single database to be accessed by multiple clients.</source>
          <target state="translated">Никакого стиля блокировки.Если ни один из вышеперечисленных способов не поддерживается,используется этот стиль блокировки.Механизм блокировки БД не используется.При использовании этой системы обращение к одной БД для нескольких клиентов небезопасно.</target>
        </trans-unit>
        <trans-unit id="7b15426333f8adb77f306aae95c84b204b379d14" translate="yes" xml:space="preserve">
          <source>No locks are held on the database. The database may be neither read nor written. Any internally cached data is considered suspect and subject to verification against the database file before being used. Other processes can read or write the database as their own locking states permit. This is the default state.</source>
          <target state="translated">В базе данных нет замков.База данных не может быть ни прочитана,ни записана.Любые внутренние кэшированные данные считаются подозрительными и подлежат проверке по файлу базы данных перед использованием.Другие процессы могут читать или записывать БД,если позволяют их собственные состояния блокировки.Это состояние по умолчанию.</target>
        </trans-unit>
        <trans-unit id="589cdf57b87436c5bbc074aa5e48b70f3f3363e1" translate="yes" xml:space="preserve">
          <source>No longer in use.</source>
          <target state="translated">Больше не используется.</target>
        </trans-unit>
        <trans-unit id="7375825a734eee4acde64dd3de9ae4b6f89db26c" translate="yes" xml:space="preserve">
          <source>No longer used.</source>
          <target state="translated">Больше не используется.</target>
        </trans-unit>
        <trans-unit id="1cff8c4990053d03c141cc08cc6f740585898fb6" translate="yes" xml:space="preserve">
          <source>No one is required to follow The Rule, to know The Rule, or even to think that The Rule is a good idea. The Founder of SQLite believes that anyone who follows The Rule will live a happier and more productive life, but individuals are free to dispute or ignore that advice if they wish.</source>
          <target state="translated">Никто не обязан следовать Правилам,знать Правила или даже думать,что Правила-это хорошая идея.Основатель SQLite считает,что каждый,кто следует Правилам,будет жить более счастливой и продуктивной жизнью,но люди могут свободно спорить или игнорировать эти советы,если захотят.</target>
        </trans-unit>
        <trans-unit id="a4226fa0e8cf6311cf2613fee3e52c99bd81b607" translate="yes" xml:space="preserve">
          <source>No other processes can change the database so there is never a need to check the change counter and clear the user-space cache at the beginning of a transaction.</source>
          <target state="translated">Никакие другие процессы не могут изменить базу данных,поэтому нет необходимости проверять счетчик изменений и очищать кэш пользовательского пространства в начале транзакции.</target>
        </trans-unit>
        <trans-unit id="6b5b494aee4d1b7c43eaf07044f46f3778af61cd" translate="yes" xml:space="preserve">
          <source>No other writes may occur on the target database while the RBU update is being applied. A read-lock is held on the target database to prevent this.</source>
          <target state="translated">Во время обновления RBU в целевой базе данных не может происходить никаких других записей.Для предотвращения этого в целевой базе данных удерживается блокировка чтения.</target>
        </trans-unit>
        <trans-unit id="3943b575617ba52cb8729616c676b13dc34b8e79" translate="yes" xml:space="preserve">
          <source>No reads or writes occur except within a transaction. Any command that accesses the database (basically, any SQL command, except a few &lt;a href=&quot;pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt; statements) will automatically start a transaction if one is not already in effect. Automatically started transactions are committed when the last SQL statement finishes.</source>
          <target state="translated">Никаких операций чтения или записи не происходит, кроме как внутри транзакции. Любая команда, которая обращается к базе данных (в основном, любая команда SQL, кроме нескольких операторов &lt;a href=&quot;pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt; ), автоматически запускает транзакцию, если она еще не действует. Автоматически запущенные транзакции фиксируются после завершения последнего оператора SQL.</target>
        </trans-unit>
        <trans-unit id="2a9bc5ebe3cc4eba5a484c518ae347f8a47ccd50" translate="yes" xml:space="preserve">
          <source>No table in a union-vtab may contain entries that are outside of the rowid bounds established by the</source>
          <target state="translated">Ни одна из таблиц в профсоюзной записной книжке не может содержать записи,выходящие за пределы рядовых границ,установленных в</target>
        </trans-unit>
        <trans-unit id="7d5b25b567984a7a4091e940273bfff96cd2fed3" translate="yes" xml:space="preserve">
          <source>No. When you delete information from an SQLite database, the unused disk space is added to an internal &quot;free-list&quot; and is reused the next time you insert data. The disk space is not lost. But neither is it returned to the operating system.</source>
          <target state="translated">Нет.Когда вы удаляете информацию из базы данных SQLite,неиспользованное дисковое пространство добавляется во внутренний &quot;свободный список&quot; и при следующем вводе данных используется повторно.Дисковое пространство не теряется.Но и оно не возвращается в операционную систему.</target>
        </trans-unit>
        <trans-unit id="d4e9f5ef9057ec35a6f3d638ab0a7b961dadfa79" translate="yes" xml:space="preserve">
          <source>NoConflict</source>
          <target state="translated">NoConflict</target>
        </trans-unit>
        <trans-unit id="66290ce3e3466df1560e431a1eebe9e205ef9f1e" translate="yes" xml:space="preserve">
          <source>Non-ASCII range characters (i.e. unicode codepoints greater than 127), or</source>
          <target state="translated">Символы,не относящиеся к диапазону ASCII (т.е.кодовые точки юникода больше 127),или</target>
        </trans-unit>
        <trans-unit id="1bc1387523b6d25784112f80a2990511e6a57420" translate="yes" xml:space="preserve">
          <source>Non-Vista Windows platforms only support one set of DST rules. Vista only supports two. Therefore, on these platforms, historical DST calculations will be incorrect. For example, in the US, in 2007 the DST rules changed. Non-Vista Windows platforms apply the new 2007 DST rules to all previous years as well. Vista does somewhat better getting results correct back to 1986, when the rules were also changed.</source>
          <target state="translated">Платформы не для Windows Vista поддерживают только один набор правил DST.Vista поддерживает только два.Поэтому на этих платформах исторические вычисления DST будут некорректны.Например,в США в 2007 году изменились правила DST.Платформы Non-Vista Windows также применяют новые 2007 DST правила ко всем предыдущим годам.Vista делает несколько лучше,получая корректные результаты еще в 1986 году,когда правила тоже были изменены.</target>
        </trans-unit>
        <trans-unit id="b1b833538f0549b7c8aca0acf47c1aa5ac7f2fac" translate="yes" xml:space="preserve">
          <source>Non-deterministic functions might give different answers on each invocation, even if the arguments are always the same. The following are examples of non-deterministic functions:</source>
          <target state="translated">Недетерминистические функции могут давать разные ответы на каждый вызов,даже если аргументы всегда одни и те же.Ниже приведены примеры недетерминистических функций:</target>
        </trans-unit>
        <trans-unit id="cf3ad9f318d5d17809c32f85aa54a78cb4cda991" translate="yes" xml:space="preserve">
          <source>Non-streaming equivalent</source>
          <target state="translated">Непотоковый эквивалент</target>
        </trans-unit>
        <trans-unit id="1d0d5248c3c8dbbb61313817bba98f17697e01b6" translate="yes" xml:space="preserve">
          <source>Non-streaming functions that accept changesets (or patchsets) as input require that the entire changeset be stored in a single buffer in memory. Similarly, those that return a changeset or patchset do so by returning a pointer to a single large buffer allocated using sqlite3_malloc(). Normally this is convenient. However, if an application running in a low-memory environment is required to handle very large changesets, the large contiguous memory allocations required can become onerous.</source>
          <target state="translated">Непотоковые функции,которые принимают наборы изменений (или патч-сеты)в качестве входных,требуют,чтобы весь набор изменений хранился в одном буфере в памяти.Аналогичным образом,те,кто возвращает changeset или patchset,делают это,возвращая указатель на один большой буфер,выделенный с помощью sqlite3_malloc().Обычно это удобно.Однако,если приложению,работающему в среде с низкой памятью,необходимо обрабатывать очень большие changeset'ы,то требуемое большое последовательное выделение памяти может стать обременительным.</target>
        </trans-unit>
        <trans-unit id="09f7070838a5d668002d389cd9b3fec752e6c30d" translate="yes" xml:space="preserve">
          <source>None of the safe programming languages existed for the first 10 years of SQLite's existence. SQLite could be recoded in Go or Rust, but doing so would probably introduce far more bugs than would be fixed, and it seems also likely to result in slower code.</source>
          <target state="translated">За первые 10 лет существования SQLite не существовало ни одного безопасного языка программирования.SQLite можно было бы перекодировать в Go или Rust,но это,скорее всего,привело бы к появлению гораздо большего количества ошибок,чем было бы исправлено,а также,похоже,привело бы к замедлению работы кода.</target>
        </trans-unit>
        <trans-unit id="9b9f34e057f76ac2b419477d464548015d8ef844" translate="yes" xml:space="preserve">
          <source>None of the xSavepoint(), xRelease(), or xRollbackTo() methods will ever be called except in between calls to xBegin() and either xCommit() or xRollback().</source>
          <target state="translated">Ни один из методов xSavepoint(),xRelease()или xRollbackTo()никогда не будет вызван,кроме как между вызовами xBegin()и либо xCommit(),либо xRollback().</target>
        </trans-unit>
        <trans-unit id="a1fe0caa1d6e9f3e9dd7087ae4f2a9ea810cd170" translate="yes" xml:space="preserve">
          <source>Noop</source>
          <target state="translated">Noop</target>
        </trans-unit>
        <trans-unit id="2bbfb9d52741dbc3a4ff03abc70ca82cb8e2f1bc" translate="yes" xml:space="preserve">
          <source>Normal functions specify only xFunc and leave xStep and xFinal set to NULL. Aggregate functions specify xStep and xFinal and leave xFunc set to NULL. There is no separate sqlite3_create_aggregate() API.</source>
          <target state="translated">Нормальные функции указывают только xFunc и оставляют xStep и xFinal set в NULL.Функции агрегирования указывают xStep и xFinal и оставляют xFunc установлено в NULL.Отдельного API sqlite3_create_aggregate()нет.</target>
        </trans-unit>
        <trans-unit id="8feff5d8988d2d3b3f82fe7920cdb81d5ba04e3a" translate="yes" xml:space="preserve">
          <source>Normal meaning</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e304219719d389c0ea46b9c98590f2134fb67330" translate="yes" xml:space="preserve">
          <source>Normally, FTS5 maintains a special backing table within the database that stores the size of each column value in tokens inserted into the main FTS5 table in a separate table. This backing table is used by the &lt;a href=&quot;#xColumnSize&quot;&gt;xColumnSize&lt;/a&gt;&lt;a&gt; API function, which is in turn used by the built-in &lt;/a&gt;&lt;a href=&quot;fts5#the_bm25_function&quot;&gt;bm25 ranking function&lt;/a&gt; (and is likely to be useful to other ranking functions as well).</source>
          <target state="translated">Обычно FTS5 поддерживает специальную вспомогательную таблицу в базе данных, в которой размер каждого значения столбца в токенах, вставленных в основную таблицу FTS5, хранится в отдельной таблице. Эта &lt;a href=&quot;#xColumnSize&quot;&gt;вспомогательная&lt;/a&gt; таблица используется функцией &lt;a&gt;API &lt;/a&gt;xColumnSize , которая, в свою очередь, используется встроенной &lt;a href=&quot;fts5#the_bm25_function&quot;&gt;функцией ранжирования bm25&lt;/a&gt; (и, вероятно, также будет полезна для других функций ранжирования).</target>
        </trans-unit>
        <trans-unit id="866b49d7e3deb743a545b4433375afa6debe3327" translate="yes" xml:space="preserve">
          <source>Normally, NULL SQL results are stored in the array using the &lt;a href=&quot;#nullvalue&quot;&gt;nullvalue&lt;/a&gt; setting. However, if the &lt;b&gt;-withoutnulls&lt;/b&gt; option is used, then NULL SQL values cause the corresponding array element to be unset instead.</source>
          <target state="translated">Обычно результаты NULL SQL сохраняются в массиве с использованием значения &lt;a href=&quot;#nullvalue&quot;&gt;NULL&lt;/a&gt; . Однако, если используется опция &lt;b&gt;-withoutnulls&lt;/b&gt; , тогда значения NULL SQL заставляют вместо этого сбрасывать соответствующий элемент массива.</target>
        </trans-unit>
        <trans-unit id="d1f5712d735a4022fc9c1482cc2c46055815935d" translate="yes" xml:space="preserve">
          <source>Normally, SQLite assumes that if a power failure occurs while updating any portion of a sector then the contents of the entire device sector is suspect following recovery. After writing to any part of a sector within a file, it is assumed that the modified sector contents are held in a volatile buffer somewhere within the system (main memory, disk cache etc.). SQLite does not assume that the updated data has reached the persistent storage media, until after it has successfully</source>
          <target state="translated">Обычно SQLite предполагает,что если при обновлении любой части сектора происходит сбой электропитания,то после восстановления возникает подозрение на содержимое всего сектора устройства.После записи в любую часть сектора в файле предполагается,что содержимое измененного сектора хранится в переменном буфере где-то в системе (основная память,дисковый кэш и т.д.).SQLite не предполагает,что обновленные данные попали на постоянный носитель,до тех пор,пока не будет успешно восстановлено</target>
        </trans-unit>
        <trans-unit id="e5b528fefcff05064efc30021e7a7579eaaad4d2" translate="yes" xml:space="preserve">
          <source>Normally, a token or token prefix query is matched against the FTS table column specified as the left-hand side of the MATCH operator. Or, if the special column with the same name as the FTS table itself is specified, against all columns. This may be overridden by specifying a column-name followed by a &quot;:&quot; character before a basic term query. There may be space between the &quot;:&quot; and the term to query for, but not between the column-name and the &quot;:&quot; character. For example:</source>
          <target state="translated">Обычно запрос на токен или префикс токена сопоставляется со столбцом таблицы FTS,указанным в качестве левой стороны MATCH-оператора.Или,если указан специальный столбец с тем же именем,что и сама таблица FTS,против всех столбцов.Это может быть отменено путем указания имени столбца с последующим символом &quot;:&quot; перед запросом на основной термин.Между &quot;:&quot; и термином,в отношении которого осуществляется запрос,может быть пробел,но не пробел между именем столбца и символом &quot;:&quot;.Например:</target>
        </trans-unit>
        <trans-unit id="bf4491e66772ed8b491e6908438d7924fa774545" translate="yes" xml:space="preserve">
          <source>Normally, an SQL index references columns of a table. But an index can also be formed on expressions involving table columns.</source>
          <target state="translated">Обычно SQL-индекс ссылается на столбцы таблицы.Но индекс также может быть сформирован на выражениях,включающих столбцы таблицы.</target>
        </trans-unit>
        <trans-unit id="39e8cea13d3d48550994e6ce4ac623d3130ee592" translate="yes" xml:space="preserve">
          <source>Normally, fossil will modify all the files in your checkout when switching between the private and the public branches. But at this point, the files are identical in both branches so not modifications need to be made.</source>
          <target state="translated">Обычно при переключении между частным и государственным секторами ископаемые изменяют все файлы,находящиеся в вашей кассе.Но на данный момент файлы идентичны в обеих ветках,поэтому модификаций делать не нужно.</target>
        </trans-unit>
        <trans-unit id="d3d92a3c721eaacd534b06f545203c90c257b9b9" translate="yes" xml:space="preserve">
          <source>Normally, full-text queries are case-insensitive. However, this is dependent on the specific &lt;a href=&quot;fts3#tokenizer&quot;&gt;tokenizer&lt;/a&gt; used by the FTS table being queried. Refer to the section on &lt;a href=&quot;fts3#tokenizer&quot;&gt;tokenizers&lt;/a&gt; for details.</source>
          <target state="translated">Обычно в полнотекстовых запросах регистр не учитывается. Однако это зависит от конкретного &lt;a href=&quot;fts3#tokenizer&quot;&gt;токенизатора,&lt;/a&gt; используемого запрашиваемой таблицей FTS. Подробности см. В разделе &lt;a href=&quot;fts3#tokenizer&quot;&gt;токенизаторов&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="63e53b72fdcc0af9b1c300c26469b45178a485e4" translate="yes" xml:space="preserve">
          <source>Normally, the FTS module maintains an inverted index of all terms in all columns of the table. This option is used to specify the name of a column for which entries should not be added to the index. Multiple &quot;notindexed&quot; options may be used to specify that multiple columns should be omitted from the index. For example:</source>
          <target state="translated">Обычно модуль FTS поддерживает инвертированный индекс всех терминов во всех столбцах таблицы.Эта опция используется для указания названия столбца,для которого не следует добавлять записи в индекс.Можно использовать несколько опций &quot;неиндексировать&quot;,чтобы указать,что из индекса следует исключить несколько столбцов.Например:</target>
        </trans-unit>
        <trans-unit id="ebe2262110ee72155bb934332e4fc5587e66a440" translate="yes" xml:space="preserve">
          <source>Normally, the database &lt;a href=&quot;pragma#pragma_page_size&quot;&gt;page_size&lt;/a&gt; and whether or not the database supports &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum&lt;/a&gt; must be configured before the database file is actually created. However, when not in &lt;a href=&quot;wal&quot;&gt;write-ahead log&lt;/a&gt; mode, the &lt;a href=&quot;pragma#pragma_page_size&quot;&gt;page_size&lt;/a&gt; and/or &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum&lt;/a&gt; properties of an existing database may be changed by using the &lt;a href=&quot;pragma#pragma_page_size&quot;&gt;page_size&lt;/a&gt; and/or &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;pragma auto_vacuum&lt;/a&gt; pragmas and then immediately VACUUMing the database. When in &lt;a href=&quot;wal&quot;&gt;write-ahead log&lt;/a&gt; mode, only the &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum&lt;/a&gt; support property can be changed using VACUUM.</source>
          <target state="translated">Обычно &lt;a href=&quot;pragma#pragma_page_size&quot;&gt;размер page_size&lt;/a&gt; базы данных и то, поддерживает ли база данных &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum,&lt;/a&gt; должны быть настроены до фактического создания файла базы данных. Однако, когда он не находится в режиме &lt;a href=&quot;wal&quot;&gt;журнала&lt;/a&gt; с &lt;a href=&quot;pragma#pragma_page_size&quot;&gt;упреждающей &lt;/a&gt;&lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;записью,&lt;/a&gt; свойства page_size и / или auto_vacuum существующей базы данных могут быть изменены с помощью &lt;a href=&quot;pragma#pragma_page_size&quot;&gt;прагм page_size&lt;/a&gt; и / или &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;pragma auto_vacuum,&lt;/a&gt; а затем немедленно VACUUMing базы данных. В режиме &lt;a href=&quot;wal&quot;&gt;журнала упреждающей&lt;/a&gt; записи с помощью VACUUM можно изменить только &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;свойство&lt;/a&gt; поддержки auto_vacuum .</target>
        </trans-unit>
        <trans-unit id="5df62864e283fb4361bad80921bbac8b7ec57013" translate="yes" xml:space="preserve">
          <source>Normally, when SQLite writes to a database file, it waits until the write operation is finished before returning control to the calling application. Since writing to the file-system is usually very slow compared with CPU bound operations, this can be a performance bottleneck. The asynchronous I/O backend is an extension that causes SQLite to perform all write requests using a separate thread running in the background. Although this does not reduce the overall system resources (CPU, disk bandwidth etc.), it does allow SQLite to return control to the caller quickly even when writing to the database.</source>
          <target state="translated">Обычно,когда SQLite записывает в файл базы данных,он ждет завершения операции записи,прежде чем вернуть управление вызывающему приложению.Поскольку запись в файловую систему обычно происходит очень медленно по сравнению с операциями,связанными с процессором,это может быть узким местом в производительности.Бэкэнд асинхронного ввода/вывода является расширением,которое заставляет SQLite выполнять все запросы на запись с помощью отдельного потока,работающего в фоновом режиме.Хотя это и не уменьшает общие системные ресурсы (процессор,пропускную способность диска и т.д.),но позволяет SQLite быстро возвращать управление вызывающему абоненту даже при записи в базу данных.</target>
        </trans-unit>
        <trans-unit id="b810f7b8c9c4b12cca67db5205f27d6d0477e848" translate="yes" xml:space="preserve">
          <source>Normally, when a row is inserted into an FTS5 table, as well as the various full-text index entries and other data a copy of the row is stored in a private table managed by the FTS5 module. When column values are requested from the FTS5 table by the user or by an auxiliary function implementation, they are read from this private table. The &quot;content&quot; option may be used to create an FTS5 table that stores only FTS full-text index entries. Because the column values themselves are usually much larger than the associated full-text index entries, this can save significant database space.</source>
          <target state="translated">Обычно,когда строка вставляется в таблицу FTS5,а также различные полнотекстовые элементы индекса и другие данные,копия строки хранится в приватной таблице,управляемой модулем FTS5.Когда значения столбцов запрашиваются из таблицы FTS5 пользователем или реализацией вспомогательной функции,они считываются из этой закрытой таблицы.Опция &quot;содержимое&quot; может быть использована для создания таблицы FTS5,в которой хранятся только записи полнотекстового индекса FTS.Поскольку сами значения столбцов обычно намного больше,чем соответствующие элементы полнотекстового индекса,это может сэкономить значительное пространство в БД.</target>
        </trans-unit>
        <trans-unit id="ca1dd39379254ab3f3c73dbffb0d03d628b27d20" translate="yes" xml:space="preserve">
          <source>Not</source>
          <target state="translated">Not</target>
        </trans-unit>
        <trans-unit id="5927a7e485b2adcf5a36cf65c4801a2eed120fcc" translate="yes" xml:space="preserve">
          <source>Not all applications meet these conditions. Fortunately, the NGQP will still usually find good query plans, even without these conditions. However, cases do arise (rarely) where performance regressions can occur.</source>
          <target state="translated">Не все приложения соответствуют этим условиям.К счастью,NGQP все равно обычно находит хорошие планы запросов,даже без этих условий.Тем не менее,возникают (редко)случаи,когда могут произойти регрессии производительности.</target>
        </trans-unit>
        <trans-unit id="6938024f626f02a7276620a318f6367169f62576" translate="yes" xml:space="preserve">
          <source>Not all test cases can be handled this way. Some test cases check to verify that the optimizations really are reducing the amount of computation by counting the number of disk accesses, sort operations, full-scan steps, or other processing steps that occur during queries. Those test cases will appear to fail when optimizations are disabled. But the majority of test cases simply check that the correct answer was obtained, and all of those cases can be run successfully with and without the optimizations, in order to show that the optimizations do not cause malfunctions.</source>
          <target state="translated">Не все тестовые случаи могут быть решены таким образом.Некоторые тестовые случаи проверяют,что оптимизация действительно уменьшает объем вычислений путем подсчета количества обращений к диску,операций сортировки,шагов полного сканирования или других шагов обработки,которые происходят во время запросов.Эти тестовые случаи будут казаться неудачными,когда оптимизации отключены.Но большинство тестовых случаев просто проверяют,что получен правильный ответ,и все эти случаи могут быть успешно запущены с оптимизациями и без них,чтобы показать,что оптимизации не приводят к сбоям.</target>
        </trans-unit>
        <trans-unit id="593dbd15d49368a738585302a9107baf925136df" translate="yes" xml:space="preserve">
          <source>Not shown in the example above is that there are also &lt;a href=&quot;fts5#fts5_table_creation_and_initialization&quot;&gt;various options&lt;/a&gt; that may be provided to FTS5 as part of the CREATE VIRTUAL TABLE statement to configure various aspects of the new table. These may be used to modify the way in which the FTS5 table extracts terms from documents and queries, to create extra indexes on disk to speed up prefix queries, or to create an FTS5 table that acts as an index on content stored elsewhere.</source>
          <target state="translated">В приведенном выше примере не показано, что существуют также &lt;a href=&quot;fts5#fts5_table_creation_and_initialization&quot;&gt;различные параметры,&lt;/a&gt; которые могут быть предоставлены FTS5 как часть оператора CREATE VIRTUAL TABLE для настройки различных аспектов новой таблицы. Они могут использоваться для изменения способа, которым таблица FTS5 извлекает термины из документов и запросов, для создания дополнительных индексов на диске для ускорения префиксных запросов или для создания таблицы FTS5, которая действует как индекс для контента, хранящегося в другом месте.</target>
        </trans-unit>
        <trans-unit id="edbfab21e07e4e0dbe02fb875980c40bdd52ad0f" translate="yes" xml:space="preserve">
          <source>NotExists</source>
          <target state="translated">NotExists</target>
        </trans-unit>
        <trans-unit id="6f05e7cc9203f83829c08dcc46fafe9db426763f" translate="yes" xml:space="preserve">
          <source>NotFound</source>
          <target state="translated">NotFound</target>
        </trans-unit>
        <trans-unit id="85c73c74f4b29a9fb7ba8d0a5bc532eb27f0866a" translate="yes" xml:space="preserve">
          <source>NotNull</source>
          <target state="translated">NotNull</target>
        </trans-unit>
        <trans-unit id="7884a1030f088443b3e65dc8c7d9c833c3f14209" translate="yes" xml:space="preserve">
          <source>Nota bene:</source>
          <target state="translated">Не за что:</target>
        </trans-unit>
        <trans-unit id="59ab81d7ff99620547d7c60a07878ec16f88cba0" translate="yes" xml:space="preserve">
          <source>Note also that when adding a &lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK constraint&lt;/a&gt;, the CHECK constraint is not tested against preexisting rows of the table. This can result in a table that contains data that is in violation of the CHECK constraint. Future versions of SQLite might change to validate CHECK constraints as they are added.</source>
          <target state="translated">Также обратите внимание, что при добавлении &lt;a href=&quot;lang_createtable#ckconst&quot;&gt;ограничения CHECK ограничение&lt;/a&gt; CHECK не проверяется на ранее существовавших строках таблицы. В результате может получиться таблица, содержащая данные, нарушающие ограничение CHECK. Будущие версии SQLite могут измениться для проверки ограничений CHECK по мере их добавления.</target>
        </trans-unit>
        <trans-unit id="63cff68b4cc8b6d1593b377ca2761e4a780c9aef" translate="yes" xml:space="preserve">
          <source>Note that &quot;monotonically increasing&quot; does not imply that the ROWID always increases by exactly one. One is the usual increment. However, if an insert fails due to (for example) a uniqueness constraint, the ROWID of the failed insertion attempt might not be reused on subsequent inserts, resulting in gaps in the ROWID sequence. AUTOINCREMENT guarantees that automatically chosen ROWIDs will be increasing but not that they will be sequential.</source>
          <target state="translated">Обратите внимание,что &quot;монотонное увеличение&quot; не означает,что ROWID всегда увеличивается ровно на единицу.Одно из них-обычное увеличение.Однако,если вставка не удается из-за (например)ограничения уникальности,ROWID неудачной попытки вставки может не использоваться повторно на последующих вставках,что приведет к пробелам в последовательности ROWID.АВТОИНКРЕМЕНТ гарантирует,что автоматически выбранные ROWID будут увеличиваться,но не будут последовательными.</target>
        </trans-unit>
        <trans-unit id="4308667a324be6565f7e88fc7a4b19a7777f66dd" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;#sqlite3_create_function&quot;&gt;application-defined SQL functions&lt;/a&gt; or &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt; might change the database indirectly as a side effect. For example, if an application defines a function &quot;eval()&quot; that calls &lt;a href=&quot;#sqlite3_exec&quot;&gt;sqlite3_exec()&lt;/a&gt;, then the following SQL statement would change the database file through side-effects:</source>
          <target state="translated">Обратите внимание, что &lt;a href=&quot;#sqlite3_create_function&quot;&gt;определяемые приложением функции SQL&lt;/a&gt; или &lt;a href=&quot;vtab&quot;&gt;виртуальные таблицы&lt;/a&gt; могут косвенно изменять базу данных в качестве побочного эффекта. Например, если приложение определяет функцию eval (), которая вызывает &lt;a href=&quot;#sqlite3_exec&quot;&gt;sqlite3_exec ()&lt;/a&gt; , то следующий оператор SQL изменит файл базы данных из-за побочных эффектов:</target>
        </trans-unit>
        <trans-unit id="2de1256b9fbe19c405bb475cc7365f640da5726d" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;../appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt; or &lt;a href=&quot;../vtab&quot;&gt;virtual tables&lt;/a&gt; might change the database indirectly as a side effect. For example, if an application defines a function &quot;eval()&quot; that calls &lt;a href=&quot;exec&quot;&gt;sqlite3_exec()&lt;/a&gt;, then the following SQL statement would change the database file through side-effects:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a8f4592d0e17a85103883247d0a4447a3744957" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt; are by default considered non-deterministic and may not be used in a CREATE INDEX statement unless the &lt;a href=&quot;c3ref/c_deterministic#sqlitedeterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt; flag is used when the function is registered.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1de4b11ed42096116749429497dc130939876ea1" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt; or &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt; might change the database indirectly as a side effect. For example, if an application defines a function &quot;eval()&quot; that calls &lt;a href=&quot;#sqlite3_exec&quot;&gt;sqlite3_exec()&lt;/a&gt;, then the following SQL statement would change the database file through side-effects:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa33906842475ccf0659a59159f766bfacc10e93" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;c3ref/create_function&quot;&gt;application-defined SQL functions&lt;/a&gt; are by default considered non-deterministic and may not be used in a CREATE INDEX statement unless the &lt;a href=&quot;c3ref/c_deterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt; flag is used when the function is registered.</source>
          <target state="translated">Обратите внимание, что &lt;a href=&quot;c3ref/create_function&quot;&gt;определяемые приложением функции SQL&lt;/a&gt; по умолчанию считаются недетерминированными и не могут использоваться в операторе CREATE INDEX, если при &lt;a href=&quot;c3ref/c_deterministic&quot;&gt;регистрации функции&lt;/a&gt; не используется флаг SQLITE_DETERMINISTIC .</target>
        </trans-unit>
        <trans-unit id="5f9e6d6d8a3bf2c6d2a7e519940c1c6c58742f80" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;create_function&quot;&gt;application-defined SQL functions&lt;/a&gt; or &lt;a href=&quot;../vtab&quot;&gt;virtual tables&lt;/a&gt; might change the database indirectly as a side effect. For example, if an application defines a function &quot;eval()&quot; that calls &lt;a href=&quot;exec&quot;&gt;sqlite3_exec()&lt;/a&gt;, then the following SQL statement would change the database file through side-effects:</source>
          <target state="translated">Обратите внимание, что &lt;a href=&quot;create_function&quot;&gt;определяемые приложением функции SQL&lt;/a&gt; или &lt;a href=&quot;../vtab&quot;&gt;виртуальные таблицы&lt;/a&gt; могут косвенно изменять базу данных в качестве побочного эффекта. Например, если приложение определяет функцию eval (), которая вызывает &lt;a href=&quot;exec&quot;&gt;sqlite3_exec ()&lt;/a&gt; , то следующий оператор SQL изменит файл базы данных из-за побочных эффектов:</target>
        </trans-unit>
        <trans-unit id="f679875d06130633120a14b47faa759dd16975f1" translate="yes" xml:space="preserve">
          <source>Note that Idx3 contains all the same information as the original &lt;a href=&quot;#fig3&quot;&gt;Idx1&lt;/a&gt;. And so if we have Idx3, we do not really need Idx1 any more. The &quot;price of peaches&quot; query can be satisfied using Idx3 by simply ignoring the &quot;state&quot; column of Idx3:</source>
          <target state="translated">Обратите внимание, что Idx3 содержит всю ту же информацию, что и исходный &lt;a href=&quot;#fig3&quot;&gt;Idx1&lt;/a&gt; . Итак, если у нас есть Idx3, нам больше не нужен Idx1. Запрос &amp;laquo;цена персиков&amp;raquo; можно удовлетворить с помощью Idx3, просто игнорируя столбец &amp;laquo;состояние&amp;raquo; Idx3:</target>
        </trans-unit>
        <trans-unit id="8e97b2bc14d77a13e225d171f50b67e2004fff89" translate="yes" xml:space="preserve">
          <source>Note that MinGW generates 32-bit DLLs only. There is a separate MinGW64 project that can be used to generate 64-bit DLLs. Presumably the command-line syntax is similar. Also note that recent versions of MSVC generate DLLs that will not work on WinXP and earlier versions of Windows. So for maximum compatibility of your generated DLL, MinGW is recommended. A good rule-of-thumb is to generate 32-bit DLLs using MinGW and 64-bit DLLs using MSVC.</source>
          <target state="translated">Обратите внимание,что MinGW генерирует только 32-битные DLL.Существует отдельный проект MinGW64,который может быть использован для генерации 64-битных DLL.Предположительно,синтаксис командной строки аналогичен.Также обратите внимание,что последние версии MSVC генерируют DLL,которые не будут работать на WinXP и более ранних версиях Windows.Поэтому для максимальной совместимости с генерируемыми вами DLL рекомендуется MinGW.Хорошим правилом является генерация 32-битных DLL с использованием MinGW и 64-битных DLL с использованием MSVC.</target>
        </trans-unit>
        <trans-unit id="103d786acd07e894276011f9fe0ff0e5d6f3f4da" translate="yes" xml:space="preserve">
          <source>Note that SQLITE_IGNORE is also used as a &lt;a href=&quot;#SQLITE_FAIL&quot;&gt;conflict resolution mode&lt;/a&gt; returned from the &lt;a href=&quot;#sqlite3_vtab_on_conflict&quot;&gt;sqlite3_vtab_on_conflict()&lt;/a&gt; interface.</source>
          <target state="translated">Обратите внимание, что SQLITE_IGNORE также используется в качестве &lt;a href=&quot;#SQLITE_FAIL&quot;&gt;режима разрешения конфликтов,&lt;/a&gt; возвращаемого интерфейсом &lt;a href=&quot;#sqlite3_vtab_on_conflict&quot;&gt;sqlite3_vtab_on_conflict ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="82cf9ab6c420a3c604d44b14992c4f512d1f4c35" translate="yes" xml:space="preserve">
          <source>Note that SQLITE_IGNORE is also used as a &lt;a href=&quot;c_fail&quot;&gt;conflict resolution mode&lt;/a&gt; returned from the &lt;a href=&quot;vtab_on_conflict&quot;&gt;sqlite3_vtab_on_conflict()&lt;/a&gt; interface.</source>
          <target state="translated">Обратите внимание, что SQLITE_IGNORE также используется в качестве &lt;a href=&quot;c_fail&quot;&gt;режима разрешения конфликтов,&lt;/a&gt; возвращаемого интерфейсом &lt;a href=&quot;vtab_on_conflict&quot;&gt;sqlite3_vtab_on_conflict ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bd4aaf9aa187deca337c2af0406d2d0e3c9d07f4" translate="yes" xml:space="preserve">
          <source>Note that SQLite allows the parenthesized list of scalar values on the right-hand side of an IN or NOT IN operator to be an empty list but most other SQL database database engines and the SQL92 standard require the list to contain at least one element.</source>
          <target state="translated">Обратите внимание,что SQLite допускает пустой список со скалярными значениями в скобках справа от оператора IN или NOT IN,но большинство других движков баз данных SQL и стандарт SQL92 требуют,чтобы список содержал по крайней мере один элемент.</target>
        </trans-unit>
        <trans-unit id="069a48733ca46d6fc20e074068d69739ed664b2b" translate="yes" xml:space="preserve">
          <source>Note that SQLite automatically adds the appropriate extension suffix (&quot;.dll&quot; on windows, &quot;.dylib&quot; on Mac, &quot;.so&quot; on most other unixes) to the extension filename. It is generally a good idea to specify the full pathname of the extension.</source>
          <target state="translated">Обратите внимание,что SQLite автоматически добавляет соответствующий суффикс расширения (&quot;.dll&quot; в окнах,&quot;.dylib&quot; в Mac,&quot;.so&quot; в большинстве других unix)к имени файла расширения.Обычно рекомендуется указывать полное имя расширения.</target>
        </trans-unit>
        <trans-unit id="878abfb73c8f4fd7637bff37205a9854afa6975b" translate="yes" xml:space="preserve">
          <source>Note that SQLite comes with several &lt;a href=&quot;../malloc#altalloc&quot;&gt;built-in memory allocators&lt;/a&gt; that are perfectly adequate for the overwhelming majority of applications and that this object is only useful to a tiny minority of applications with specialized memory allocation requirements. This object is also used during testing of SQLite in order to specify an alternative memory allocator that simulates memory out-of-memory conditions in order to verify that SQLite recovers gracefully from such conditions.</source>
          <target state="translated">Обратите внимание, что SQLite поставляется с несколькими &lt;a href=&quot;../malloc#altalloc&quot;&gt;встроенными распределителями памяти&lt;/a&gt; , которые идеально подходят для подавляющего большинства приложений, и что этот объект полезен только для крошечного меньшинства приложений со специализированными требованиями к выделению памяти. Этот объект также используется во время тестирования SQLite, чтобы указать альтернативный распределитель памяти, который имитирует условия нехватки памяти, чтобы убедиться, что SQLite корректно восстанавливается из таких условий.</target>
        </trans-unit>
        <trans-unit id="8a9932e44739c8fef89cbf2d998599f354bb604b" translate="yes" xml:space="preserve">
          <source>Note that SQLite comes with several &lt;a href=&quot;malloc#altalloc&quot;&gt;built-in memory allocators&lt;/a&gt; that are perfectly adequate for the overwhelming majority of applications and that this object is only useful to a tiny minority of applications with specialized memory allocation requirements. This object is also used during testing of SQLite in order to specify an alternative memory allocator that simulates memory out-of-memory conditions in order to verify that SQLite recovers gracefully from such conditions.</source>
          <target state="translated">Обратите внимание, что SQLite поставляется с несколькими &lt;a href=&quot;malloc#altalloc&quot;&gt;встроенными распределителями памяти&lt;/a&gt; , которые идеально подходят для подавляющего большинства приложений, и что этот объект полезен только для крошечного меньшинства приложений со специализированными требованиями к выделению памяти. Этот объект также используется во время тестирования SQLite, чтобы указать альтернативный распределитель памяти, который имитирует условия нехватки памяти, чтобы убедиться, что SQLite корректно восстанавливается из таких условий.</target>
        </trans-unit>
        <trans-unit id="f1f541cbfa03c47b900f800f3f8afdec05b49044" translate="yes" xml:space="preserve">
          <source>Note that SQLite does not enforce the PRIMARY KEY for a WITHOUT ROWID virtual table. Enforcement is the responsibility of the underlying virtual table implementation. But SQLite does assume that the PRIMARY KEY constraint is valid - that the identified columns really are UNIQUE and NOT NULL - and it uses that assumption to optimize queries against the virtual table.</source>
          <target state="translated">Обратите внимание,что SQLite не применяет PRIMARY KEY для виртуальной таблицы БЕЗ РОУИДА.Ответственность за обеспечение соблюдения лежит на реализации виртуальной таблицы.Но SQLite предполагает,что ограничение PRIMARY KEY является действительным-что идентифицированные столбцы действительно являются UNIQUE и НЕ NULL-и использует это предположение для оптимизации запросов к виртуальной таблице.</target>
        </trans-unit>
        <trans-unit id="d3bdb4d9a8050dadd7145a64b6065f6da75ef0eb" translate="yes" xml:space="preserve">
          <source>Note that SQLite must believe whatever the operating system and hardware tell it about the status of sync requests. There is no way for SQLite to detect that either is lying and that writes might be occurring out-of-order. However, SQLite in &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt; is far more forgiving of out-of-order writes than in the default rollback journal modes. In WAL mode, the only time that a failed sync operation can cause database corruption is during a &lt;a href=&quot;wal#ckpt&quot;&gt;checkpoint&lt;/a&gt; operation. A sync failure during a COMMIT might result in loss of durability but not in a corrupt database file. Hence, one line of defense against database corruption due to failed sync operations is to use SQLite in WAL mode and to checkpoint as infrequently as possible.</source>
          <target state="translated">Обратите внимание, что SQLite должен верить тому, что операционная система и оборудование говорят ему о состоянии запросов на синхронизацию. SQLite не может обнаружить, что какой-либо из них лжет и что записи могут происходить не по порядку. Однако SQLite в &lt;a href=&quot;wal&quot;&gt;режиме WAL&lt;/a&gt; гораздо более снисходительно относится к неупорядоченной записи, чем в режимах журнала отката по умолчанию. В режиме WAL единственный раз, когда неудачная операция синхронизации может вызвать повреждение базы данных, - это операция &lt;a href=&quot;wal#ckpt&quot;&gt;контрольной точки&lt;/a&gt; . Сбой синхронизации во время COMMIT может привести к потере устойчивости, но не к повреждению файла базы данных. Следовательно, одной из линий защиты от повреждения базы данных из-за неудачных операций синхронизации является использование SQLite в режиме WAL и выполнение контрольных точек как можно реже.</target>
        </trans-unit>
        <trans-unit id="a2fee544cde41af143fe81786b7190276086b344" translate="yes" xml:space="preserve">
          <source>Note that SQLite uses b-trees, which are a sorted data structure, so indices can be used when the WHERE clause of the SELECT statement contains tests for equality or inequality. Queries like the following can use an index if it is available:</source>
          <target state="translated">Обратите внимание,что SQLite использует b-деревья,которые представляют собой отсортированную структуру данных,поэтому индексы могут использоваться,когда в пункте WHERE оператора SELECT содержатся тесты на равенство или неравенство.В таких запросах,как ниже,можно использовать индекс,если он доступен:</target>
        </trans-unit>
        <trans-unit id="5081483bfc5c0173b67743dd4507d0595797d951" translate="yes" xml:space="preserve">
          <source>Note that a declared type of &quot;FLOATING POINT&quot; would give INTEGER affinity, not REAL affinity, due to the &quot;INT&quot; at the end of &quot;POINT&quot;. And the declared type of &quot;STRING&quot; has an affinity of NUMERIC, not TEXT.</source>
          <target state="translated">Обратите внимание,что объявленный тип &quot;FLOATING POINT&quot; даст сродство INTEGER,а не REAL,из-за &quot;INT&quot; в конце &quot;POINT&quot;.А объявленный тип &quot;STRING&quot; имеет сродство ЧИСЛОВЫЙ,а не ТЕКСТ.</target>
        </trans-unit>
        <trans-unit id="6008db09d7c79dcc3b84a140fc5e215929e6ce79" translate="yes" xml:space="preserve">
          <source>Note that a transformation that flips the polygon might cause the order of vertexes to be reversed. In other words, the transformation might cause the vertexes to circulate in clockwise order instead of counter-clockwise. This can be corrected by sending the result through the &lt;a href=&quot;geopoly#ccw&quot;&gt;geopoly_ccw()&lt;/a&gt; function after transformation.</source>
          <target state="translated">Обратите внимание, что преобразование, которое переворачивает многоугольник, может привести к обратному порядку вершин. Другими словами, преобразование может привести к тому, что вершины будут перемещаться по часовой стрелке, а не против часовой стрелки. Это можно исправить, отправив результат через &lt;a href=&quot;geopoly#ccw&quot;&gt;функцию geopoly_ccw ()&lt;/a&gt; после преобразования.</target>
        </trans-unit>
        <trans-unit id="3eb1501d271603c6953bfb8ef829d45c83d17e8d" translate="yes" xml:space="preserve">
          <source>Note that an inner transaction might commit (using the RELEASE command) but then later have its work undone by a ROLLBACK in an outer transaction. A power failure or program crash or OS crash will cause the outer-most transaction to rollback, undoing all changes that have occurred within that outer transaction, even changes that have supposedly been &quot;committed&quot; by the RELEASE command. Content is not actually committed on the disk until the outermost transaction commits.</source>
          <target state="translated">Обратите внимание,что внутренняя транзакция может совершить фиксацию (с помощью команды RELEASE),но затем отменить ее работу с помощью команды ROLLBACK во внешней транзакции.Сбой питания,сбой программы или отказ операционной системы приведет к откату самой внешней транзакции,отменив все изменения,которые произошли внутри этой внешней транзакции,даже изменения,которые предположительно были &quot;зафиксированы&quot; командой RELEASE.Содержимое на самом деле не фиксируется на диске до тех пор,пока не зафиксирована самая внешняя транзакция.</target>
        </trans-unit>
        <trans-unit id="7c93fd99fb4687ad2997daf3b6769cc616b7c58e" translate="yes" xml:space="preserve">
          <source>Note that conflict resolutions from multiple remote changesets are combined on a per-field basis, not per-row. This means that in the case of multiple remote UPDATE operations, some fields of a single local change may be rebased for REPLACE while others are rebased for OMIT.</source>
          <target state="translated">Обратите внимание,что разрешения конфликтов от нескольких удаленных изменений объединяются на основе для каждого поля,а не для каждого ряда.Это означает,что в случае нескольких удаленных операций UPDATE,некоторые поля одного локального изменения могут быть возвращены в REPLACE,в то время как другие-в OMIT.</target>
        </trans-unit>
        <trans-unit id="e3af7101a58299023cb05d90e0fc88f9fa63608b" translate="yes" xml:space="preserve">
          <source>Note that conversions between UTF-16be and UTF-16le are always done in place and do not invalidate a prior pointer, though of course the content of the buffer that the prior pointer points to will have been modified. Other kinds of conversion are done in place when it is possible, but sometime it is not possible and in those cases prior pointers are invalidated.</source>
          <target state="translated">Обратите внимание,что преобразования между UTF-16be и UTF-16le всегда выполняются на месте и не делают недействительным предыдущий указатель,хотя,конечно,содержимое буфера,на который указывает предыдущий указатель,будет изменено.Другие виды преобразований выполняются на месте,когда это возможно,но иногда это невозможно,и в этих случаях предыдущие указатели становятся недействительными.</target>
        </trans-unit>
        <trans-unit id="f0c5f85c046ed0d0d783a57a522950f881e39de3" translate="yes" xml:space="preserve">
          <source>Note that deleting records from a zip archive does not reclaim the space used within the archive - it merely removes an entry from the archives &quot;Central Directory Structure&quot;, making the entry inaccessible. One way to work around this inefficiency is to create a new zip archive based on the contents of the edited archive. For example, after editing the archive accessed via virtual table temp.zzz:</source>
          <target state="translated">Обратите внимание,что удаление записей из zip-архива не восстанавливает использованное пространство внутри архива-оно просто удаляет запись из архива &quot;Central Directory Structure&quot;,делая ее недоступной.Одним из способов обойти эту неэффективность является создание нового zip-архива на основе содержимого отредактированного архива.Например,после редактирования архива доступ к нему осуществляется через виртуальную таблицу temp.zzz:</target>
        </trans-unit>
        <trans-unit id="710cdb120286dd832bd6798397cffbb5dfeed9ef" translate="yes" xml:space="preserve">
          <source>Note that different operating systems use different filename suffixes for their shared libraries. Windows use &quot;.dll&quot;, Mac uses &quot;.dylib&quot;, and most unixes other than mac use &quot;.so&quot;. If you want to make your code portable, you can omit the suffix from the shared library filename and the appropriate suffix will be added automatically by the &lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension()&lt;/a&gt; interface.</source>
          <target state="translated">Обратите внимание, что разные операционные системы используют разные суффиксы файлов для своих общих библиотек. Windows использует &amp;laquo;.dll&amp;raquo;, Mac использует &amp;laquo;.dylib&amp;raquo;, а большинство unix-файлов, кроме Mac, используют &amp;laquo;.so&amp;raquo;. Если вы хотите сделать свой код переносимым, вы можете опустить суффикс в имени файла общей библиотеки, и соответствующий суффикс будет автоматически добавлен интерфейсом &lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c12e1242a0c93cb2f83528b0161fb89fb73eac90" translate="yes" xml:space="preserve">
          <source>Note that each 32768-byte unit of the shm file has its own aHash and aPgno arrays. The aHash array for a single unit is only helpful in finding aPgno entries in that same unit. The overall FindFrame(P,M) function needs to do hash lookups beginning with the latest unit and working backwards to the oldest unit until it finds an answer.</source>
          <target state="translated">Обратите внимание,что каждая 32768-байтовая единица файла shm имеет свой собственный массив aHash и aPgno.Массив aHash для одного устройства полезен только для поиска записей aPgno в этом же устройстве.Функция FindFrame(P,M)в целом должна выполнять поиск хэша,начиная с последнего модуля и работая в обратном направлении до самого старого модуля,пока не найдет ответ.</target>
        </trans-unit>
        <trans-unit id="30f49c0b1079064845cadc4000f3f0cbc4ba7f9a" translate="yes" xml:space="preserve">
          <source>Note that enabling FTS3 also makes FTS4 available. There is not a separate SQLITE_ENABLE_FTS4 compile-time option. A build of SQLite either supports both FTS3 and FTS4 or it supports neither.</source>
          <target state="translated">Обратите внимание,что включение FTS3 также делает FTS4 доступным.Отдельной опции времени компиляции SQLITE_ENABLE_FTS4 не существует.Сборка SQLite либо поддерживает FTS3 и FTS4,либо не поддерживает ни то,ни другое.</target>
        </trans-unit>
        <trans-unit id="665e7a6fdd40011f21f13b4109b67442ccc2792c" translate="yes" xml:space="preserve">
          <source>Note that except for a few corner-case differences detailed above, WITHOUT ROWID tables and rowid tables work the same. They both generate the same answers given the same SQL statements. So it is a simple matter to run experiments on an application, late in the development cycle, to test whether or not the use of WITHOUT ROWID tables will be helpful. A good strategy is to simply not worry about WITHOUT ROWID until near the end of product development, then go back and run tests to see if adding WITHOUT ROWID to tables with non-integer PRIMARY KEYs helps or hurts performance, and retaining the WITHOUT ROWID only in those cases where it helps.</source>
          <target state="translated">Обратите внимание,что за исключением нескольких угловых разниц,описанных выше,таблицы БЕЗ РОУИДов и таблицы rowid работают одинаково.Они оба генерируют одни и те же ответы,давая одни и те же SQL-операторы.Таким образом,просто запустить эксперименты над приложением на поздних стадиях цикла разработки,чтобы проверить,будет ли полезно использование таблиц БЕЗ РОУИДов.Хорошая стратегия заключается в том,чтобы просто не беспокоиться о БЕЗ РОУИДА до окончания разработки продукта,а затем вернуться назад и запустить тесты,чтобы посмотреть,помогает ли добавление БЕЗ РОУИДА в таблицы с неинтегрированными PRIMARY KEYs или снижает производительность,и сохранение БЕЗ РОУИДА только в тех случаях,когда это помогает.</target>
        </trans-unit>
        <trans-unit id="bde5b3e09fe9bd78baf5c5b8cf655c1d83bf9828" translate="yes" xml:space="preserve">
          <source>Note that geopoly uses a traditional right-handed cartesian coordinate system with the origin at the lower left, whereas SVG uses a left-handed coordinate system with the origin at the upper left. The geopoly_svg() routine makes no attempt to transform the coordinate system, so the displayed images are shown in mirror image and rotated. If that is undesirable, the geopoly_xform() routine can be used to transform the output from cartesian to SVG coordinates prior to passing the polygons into geopoly_svg().</source>
          <target state="translated">Обратите внимание,что в геополитике используется традиционная правая картезианская система координат с началом отсчета в левом нижнем углу,в то время как в SVG используется левосторонняя система координат с началом отсчета в левом верхнем углу.В программе geopoly_svg()не делается никаких попыток преобразования системы координат,поэтому отображаемые изображения отображаются в зеркальном отображении и поворачиваются.Если это нежелательно,рутина geopoly_xform()может быть использована для преобразования вывода из картезианских в SVG координат до передачи полигонов в функцию geopoly_svg().</target>
        </trans-unit>
        <trans-unit id="98a440c913714baad6d711ca1c482bbb8e3fece7" translate="yes" xml:space="preserve">
          <source>Note that if a non-deterministic function is tagged with &lt;a href=&quot;c3ref/c_deterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt; and if that function ends up being used in the WHERE clause of a &lt;a href=&quot;partialindex&quot;&gt;partial index&lt;/a&gt; or in an &lt;a href=&quot;expridx&quot;&gt;expression index&lt;/a&gt;, then when the function begins to return different answers, the associated index may become corrupt. If an SQL function is nearly deterministic (which is to say, if it only rarely changes, like &lt;a href=&quot;lang_corefunc#sqlite_version&quot;&gt;sqlite_version()&lt;/a&gt;) and it is used in an index that becomes corrupt, the corruption can be fixed by running &lt;a href=&quot;lang_reindex&quot;&gt;REINDEX&lt;/a&gt;.</source>
          <target state="translated">Обратите внимание, что если недетерминированная функция помечена тегом &lt;a href=&quot;c3ref/c_deterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt; и если эта функция в конечном итоге используется в предложении WHERE &lt;a href=&quot;partialindex&quot;&gt;частичного индекса&lt;/a&gt; или в &lt;a href=&quot;expridx&quot;&gt;индексе выражения&lt;/a&gt; , то, когда функция начинает возвращать разные ответы, связанный индекс может стать поврежденным. . Если функция SQL почти детерминирована (то есть, если она меняется редко, например &lt;a href=&quot;lang_corefunc#sqlite_version&quot;&gt;sqlite_version ()&lt;/a&gt; ) и используется в индексе, который становится поврежденным, повреждение можно исправить, запустив &lt;a href=&quot;lang_reindex&quot;&gt;REINDEX&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c13f9095e78ebed2a9c8d270bb63e3a9b47c70fe" translate="yes" xml:space="preserve">
          <source>Note that if a non-deterministic function is tagged with &lt;a href=&quot;c3ref/c_deterministic#sqlitedeterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt; and if that function ends up being used in the WHERE clause of a &lt;a href=&quot;partialindex&quot;&gt;partial index&lt;/a&gt; or in an &lt;a href=&quot;expridx&quot;&gt;expression index&lt;/a&gt;, then when the function begins to return different answers, the associated index may become corrupt. If an SQL function is nearly deterministic (which is to say, if it only rarely changes, like &lt;a href=&quot;lang_corefunc#sqlite_version&quot;&gt;sqlite_version()&lt;/a&gt;) and it is used in an index that becomes corrupt, the corruption can be fixed by running &lt;a href=&quot;lang_reindex&quot;&gt;REINDEX&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e7ef1f945a3c3a6083df7d03b59a24fcefb7fd0" translate="yes" xml:space="preserve">
          <source>Note that if one of the dynamic mutex parameters (SQLITE_MUTEX_FAST or SQLITE_MUTEX_RECURSIVE) is used then sqlite3_mutex_alloc() returns a different mutex on every call. For the static mutex types, the same mutex is returned on every call that has the same type number.</source>
          <target state="translated">Обратите внимание,что если используется один из динамических параметров мьютекса (SQLITE_MUTEX_FAST или SQLITE_MUTEX_RECURSIVE),то sqlite3_mutex_alloc()возвращает при каждом вызове другой мьютекс.Для статических типов мьютексов при каждом вызове,имеющем один и тот же номер типа,возвращается один и тот же мьютекс.</target>
        </trans-unit>
        <trans-unit id="1c50891c113debf231642ee8d937768c49d352cf" translate="yes" xml:space="preserve">
          <source>Note that if you do not include the &quot;langid=N&quot; term in the WHERE clause, the search will be against language 0 (English in the example above.) All spellfix1 searches are against a single language id. There is no way to search all languages at once.</source>
          <target state="translated">Обратите внимание,что если вы не включите термин &quot;langid=N&quot; в выражение WHERE,то поиск будет осуществляться по языку 0 (английский в примере выше).Все поиски spellfix1 идут по одному языковому идентификатору.Невозможно выполнить поиск сразу по всем языкам.</target>
        </trans-unit>
        <trans-unit id="67f33837baeec763fa57cef78587afa10292c83d" translate="yes" xml:space="preserve">
          <source>Note that in most cases, SQLite will only use a single index for each table in the FROM clause of a query. The second OR-clause optimization described here is the exception to that rule. With an OR-clause, a different index might be used for each subterm in the OR-clause.</source>
          <target state="translated">Обратите внимание,что в большинстве случаев SQLite будет использовать только один индекс для каждой таблицы в выражении FROM запроса.Описанная здесь вторая оптимизация &quot;ИЛИ&quot; является исключением из этого правила.При использовании OR-постановки для каждого подтермина в OR-постановке может использоваться отдельный индекс.</target>
        </trans-unit>
        <trans-unit id="63fa9dab5a3c38f244560b4ee3d5231308f8ad59" translate="yes" xml:space="preserve">
          <source>Note that in order for the special &quot;:memory:&quot; name to apply and to create a pure in-memory database, there must be no additional text in the filename. Thus, a disk-based database can be created in a file by prepending a pathname, like this: &quot;./:memory:&quot;.</source>
          <target state="translated">Обратите внимание,что для того,чтобы применить специальное имя &quot;:memory:&quot; и создать чистую базу данных in-memory,в имени файла не должно быть дополнительного текста.Таким образом,дисковая база данных может быть создана в файле с помощью предваряющего файла с таким именем:&quot;./:память:&quot;.</target>
        </trans-unit>
        <trans-unit id="1b52e107709738a3260fec8ebd98ff46511f5c58" translate="yes" xml:space="preserve">
          <source>Note that in the diagram above, we showed the private edits as a single commit. This was for clarity of presentation only. There is nothing to stop you from doing dozens or hundreds of separate tiny changes and committing each separately. In fact, making many small changes is the preferred way to work. The only reason for doing all the changes in a single commit is that it makes the diagram easier to draw.</source>
          <target state="translated">Обратите внимание,что на диаграмме выше мы показывали приватные правки как один коммит.Это было сделано только для наглядности презентации.Ничто не помешает вам сделать десятки или сотни отдельных крошечных изменений и зафиксировать каждое в отдельности.На самом деле,внесение множества мелких изменений является предпочтительным способом работы.Единственная причина делать все изменения в одном коммите-это то,что он облегчает рисование диаграммы.</target>
        </trans-unit>
        <trans-unit id="705b7526443ed2af20dbc38ecc0ad5be9f1ce9d9" translate="yes" xml:space="preserve">
          <source>Note that in this design, the tokenizer calls the parser. People who are familiar with YACC and BISON may be accustomed to doing things the other way around &amp;mdash; having the parser call the tokenizer. Having the tokenizer call the parser is better, though, because it can be made threadsafe and it runs faster.</source>
          <target state="translated">Обратите внимание, что в этом дизайне токенизатор вызывает парсер. Люди, знакомые с YACC и BISON, могут быть привыкли делать все наоборот - использовать парсер для вызова токенизатора. Тем не менее, имея вызов токенизатора, анализатор лучше, потому что его можно сделать потокобезопасным и он работает быстрее.</target>
        </trans-unit>
        <trans-unit id="819e65339172e5dc379cf7c2c3439c1fadf7ced3" translate="yes" xml:space="preserve">
          <source>Note that infix functions (&lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt;, &lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt;, &lt;a href=&quot;lang_expr#regexp&quot;&gt;REGEXP&lt;/a&gt;, and &lt;a href=&quot;lang_expr#match&quot;&gt;MATCH&lt;/a&gt;) reverse the order of their arguments. So &quot;like(A,B)&quot; is equivalent to &quot;B like A&quot;. For the form &quot;B like A&quot; the B term is considered the first argument to the function. But for &quot;like(A,B)&quot; the A term is considered the first argument.</source>
          <target state="translated">Обратите внимание, что инфиксные функции ( &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; , &lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; , &lt;a href=&quot;lang_expr#regexp&quot;&gt;REGEXP&lt;/a&gt; и &lt;a href=&quot;lang_expr#match&quot;&gt;MATCH&lt;/a&gt; ) меняют порядок своих аргументов. Итак, &amp;laquo;like (A, B)&amp;raquo; эквивалентно &amp;laquo;B like A&amp;raquo;. Для формы &amp;laquo;B как A&amp;raquo; термин B считается первым аргументом функции. Но для &amp;laquo;как (A, B)&amp;raquo; термин A считается первым аргументом.</target>
        </trans-unit>
        <trans-unit id="35589dde916482f10a4613056291243d802b1cc4" translate="yes" xml:space="preserve">
          <source>Note that it is important to set the &quot;mode&quot; to &quot;csv&quot; before running the &quot;.import&quot; command. This is necessary to prevent the command-line shell from trying to interpret the input file text as some other format.</source>
          <target state="translated">Обратите внимание,что перед выполнением команды &quot;.импорт&quot; необходимо установить &quot;режим&quot; на &quot;csv&quot;.Это необходимо для того,чтобы оболочка командной строки не пыталась интерпретировать текст входного файла как какой-то другой формат.</target>
        </trans-unit>
        <trans-unit id="aab0f603b95c5838db66d31fe53b5c5afd66afd1" translate="yes" xml:space="preserve">
          <source>Note that it is not necessary for all coordinates in an R*Tree index to be constrained in order for the index search to be efficient. One might, for example, want to query all objects that overlap with the 35th parallel:</source>
          <target state="translated">Обратите внимание,что не обязательно,чтобы все координаты в индексе R*Tree были ограничены,чтобы поиск по индексу был эффективным.Например,можно запросить все объекты,которые пересекаются с 35 параллелью:</target>
        </trans-unit>
        <trans-unit id="750004cbbcdb4b09f134058116396d2802e69e0a" translate="yes" xml:space="preserve">
          <source>Note that it is not necessary to quote the $bigstring value. That happens automatically. If $bigstring is a large string or binary object, this technique is not only easier to write, it is also much more efficient since it avoids making a copy of the content of $bigstring.</source>
          <target state="translated">Обратите внимание,что нет необходимости цитировать значение $bigstring.Это происходит автоматически.Если $bigstring-большой строковый или двоичный объект,то эта техника не только проще в написании,но и намного эффективнее,так как позволяет избежать копирования содержимого $bigstring.</target>
        </trans-unit>
        <trans-unit id="aedf129a94b2c6ea4cf41bd3da4352659cc6bb37" translate="yes" xml:space="preserve">
          <source>Note that it is perfectly safe for two or more threads to access the same SQLite database file using the SQLite library. The unix drivers for SQLite know about the POSIX advisory locking quirks and work around them. This problem only arises when a thread tries to bypass the SQLite library and read the database file directly.</source>
          <target state="translated">Обратите внимание,что доступ к одному и тому же файлу базы данных SQLite с помощью библиотеки SQLite абсолютно безопасен для двух и более потоков.Драйверы unix для SQLite знают о тонкостях блокировки POSIX-советов и работают вокруг них.Данная проблема возникает только тогда,когда поток пытается обойти библиотеку SQLite и напрямую прочитать файл базы данных.</target>
        </trans-unit>
        <trans-unit id="af76f7d3a1b3eb149d8a26a0e9299bf38c7c0401" translate="yes" xml:space="preserve">
          <source>Note that it is very important that the database filename have some kind of extension. If there is no extension, then SQLite creates auxiliary filenames by appending to the base name of the file. Thus, a database named &quot;&lt;code&gt;db01&lt;/code&gt;&quot; would have a &lt;a href=&quot;lockingv3#rollback&quot;&gt;rollback journal&lt;/a&gt; file named &quot;&lt;code&gt;db01-journal&lt;/code&gt;&quot;. And as this filename has no extension to shorten to 3 characters, it will be used as-is, and will violate 8+3 naming rules.</source>
          <target state="translated">Обратите внимание, что очень важно, чтобы имя файла базы данных имело какое-то расширение. Если расширения нет, SQLite создает вспомогательные имена файлов, добавляя их к базовому имени файла. Таким образом, база данных с именем &amp;laquo; &lt;code&gt;db01&lt;/code&gt; &amp;raquo; будет иметь файл &lt;a href=&quot;lockingv3#rollback&quot;&gt;журнала отката с&lt;/a&gt; именем &amp;laquo; &lt;code&gt;db01-journal&lt;/code&gt; &amp;raquo;. И поскольку это имя файла не имеет расширения, которое можно было бы сократить до 3 символов, оно будет использоваться как есть и будет нарушать правила именования 8 + 3.</target>
        </trans-unit>
        <trans-unit id="19eeeefb37e5b82a70fbf6a86a847157f005c210" translate="yes" xml:space="preserve">
          <source>Note that prior to &lt;a href=&quot;https://sqlite.org/releaselog/3_9_0.html&quot;&gt;version 3.9.0&lt;/a&gt; (2015-10-14), SQLite did not check the xCreate method for NULL before invoking it. So if an eponymous-only virtual table is registered with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_11_1.html&quot;&gt;version 3.8.11.1&lt;/a&gt; (2015-07-29) or earlier and a &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; command is attempted against that virtual table module, a jump to a NULL pointer will occur, resulting in a crash.</source>
          <target state="translated">Обратите внимание, что до &lt;a href=&quot;https://sqlite.org/releaselog/3_9_0.html&quot;&gt;версии 3.9.0&lt;/a&gt; (2015-10-14) SQLite не проверял метод xCreate на NULL перед его вызовом. Таким образом, если виртуальная таблица только с одноименным &lt;a href=&quot;https://sqlite.org/releaselog/3_8_11_1.html&quot;&gt;именем&lt;/a&gt; зарегистрирована в SQLite версии 3.8.11.1 ( 2015-07-29 ) или более ранней, и команда &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; предпринимается для этого модуля виртуальной таблицы, произойдет переход к указателю NULL, что приведет к авария.</target>
        </trans-unit>
        <trans-unit id="7cb63274cd75ba4167c68c8885d57c07e7241aab" translate="yes" xml:space="preserve">
          <source>Note that running SQLite with gcov is not a test of SQLite &amp;mdash; it is a test of the test suite. The gcov run does not test SQLite because the -fprofile-args and -ftest-coverage options cause the compiler to generate different code. The gcov run merely verifies that the test suite provides 100% branch test coverage. The gcov run is a test of the test - a meta-test.</source>
          <target state="translated">Обратите внимание, что запуск SQLite с gcov - это не тест SQLite - это тест набора тестов. Запуск gcov не тестирует SQLite, потому что параметры -fprofile-args и -ftest-охват заставляют компилятор генерировать другой код. Запуск gcov просто проверяет, что набор тестов обеспечивает 100% тестовое покрытие ветвей. Запуск gcov - это тест теста - мета-тест.</target>
        </trans-unit>
        <trans-unit id="5a5f0aee350ad05534eee4c24d91d936725afa91" translate="yes" xml:space="preserve">
          <source>Note that the &lt;a href=&quot;#SQLITE_DENY&quot;&gt;SQLITE_IGNORE&lt;/a&gt; constant is also used as a potential return value from the &lt;a href=&quot;#sqlite3_set_authorizer&quot;&gt;sqlite3_set_authorizer()&lt;/a&gt; callback and that &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ABORT&lt;/a&gt; is also a &lt;a href=&quot;rescode&quot;&gt;result code&lt;/a&gt;.</source>
          <target state="translated">Обратите внимание, что константа &lt;a href=&quot;#SQLITE_DENY&quot;&gt;SQLITE_IGNORE&lt;/a&gt; также используется в качестве потенциального возвращаемого значения из обратного вызова &lt;a href=&quot;#sqlite3_set_authorizer&quot;&gt;sqlite3_set_authorizer ()&lt;/a&gt; и что &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ABORT&lt;/a&gt; также является &lt;a href=&quot;rescode&quot;&gt;кодом результата&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f4daa0a4c8ffbaa8c905b7b2b472738ae1e277cf" translate="yes" xml:space="preserve">
          <source>Note that the &lt;a href=&quot;c3ref/changes&quot;&gt;sqlite3_changes()&lt;/a&gt; and &lt;a href=&quot;c3ref/total_changes&quot;&gt;sqlite3_total_changes()&lt;/a&gt; interfaces do not count INSTEAD OF trigger firings, but the &lt;a href=&quot;pragma#pragma_count_changes&quot;&gt;count_changes pragma&lt;/a&gt; does count INSTEAD OF trigger firing.</source>
          <target state="translated">Обратите внимание, что интерфейсы &lt;a href=&quot;c3ref/changes&quot;&gt;sqlite3_changes ()&lt;/a&gt; и &lt;a href=&quot;c3ref/total_changes&quot;&gt;sqlite3_total_changes ()&lt;/a&gt; не учитывают срабатывания триггера INSTEAD OF, но &lt;a href=&quot;pragma#pragma_count_changes&quot;&gt;прагма count_changes&lt;/a&gt; учитывает срабатывание триггера INSTEAD OF.</target>
        </trans-unit>
        <trans-unit id="f4f048e66a09e44bfda0411919740620eea7756a" translate="yes" xml:space="preserve">
          <source>Note that the &lt;a href=&quot;c_deny&quot;&gt;SQLITE_IGNORE&lt;/a&gt; constant is also used as a potential return value from the &lt;a href=&quot;set_authorizer&quot;&gt;sqlite3_set_authorizer()&lt;/a&gt; callback and that &lt;a href=&quot;../rescode#abort&quot;&gt;SQLITE_ABORT&lt;/a&gt; is also a &lt;a href=&quot;../rescode&quot;&gt;result code&lt;/a&gt;.</source>
          <target state="translated">Обратите внимание, что константа &lt;a href=&quot;c_deny&quot;&gt;SQLITE_IGNORE&lt;/a&gt; также используется в качестве потенциального возвращаемого значения из обратного вызова &lt;a href=&quot;set_authorizer&quot;&gt;sqlite3_set_authorizer ()&lt;/a&gt; и что &lt;a href=&quot;../rescode#abort&quot;&gt;SQLITE_ABORT&lt;/a&gt; также является &lt;a href=&quot;../rescode&quot;&gt;кодом результата&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="732e678676cbad83be2195f0c9cbdf90bfcdfbeb" translate="yes" xml:space="preserve">
          <source>Note that the DO UPDATE clause acts only on the single row that experienced the constraint error during INSERT. It is not necessary to include a WHERE clause that restrictions the action to that one row. The only use for the WHERE clause at the end of the DO UPDATE is to optionally change the DO UPDATE into a no-op depending on the original and/or new values. For example:</source>
          <target state="translated">Обратите внимание,что выражение DO UPDATE действует только на единственной строке,в которой во время INSERT произошла ошибка ограничения.Нет необходимости включать условие WHERE,которое ограничивает действие одной строкой.Единственное использование выражения WHERE в конце DO UPDATE-это опциональное изменение DO UPDATE на no-op в зависимости от исходных и/или новых значений.Например:</target>
        </trans-unit>
        <trans-unit id="9e431af898d8e365308f86b50efb344365dfb157" translate="yes" xml:space="preserve">
          <source>Note that the SQLITE_TEXT constant was also used in SQLite version 2 for a completely different meaning. Software that links against both SQLite version 2 and SQLite version 3 should use SQLITE3_TEXT, not SQLITE_TEXT.</source>
          <target state="translated">Обратите внимание,что константа SQLITE_TEXT также использовалась в SQLite версии 2 в совершенно ином значении.Программное обеспечение,связанное как с SQLite версии 2,так и с SQLite версии 3,должно использовать SQLITE3_TEXT,а не SQLITE_TEXT.</target>
        </trans-unit>
        <trans-unit id="db7397560741b34c84d7c7b13b86a2bbf792ba5b" translate="yes" xml:space="preserve">
          <source>Note that the SQLite parser will not always generate code to use an index, even if it is possible to do so. The following queries will not currently use the index:</source>
          <target state="translated">Обратите внимание,что парсер SQLite не всегда будет генерировать код для использования индекса,даже если это возможно.Следующие запросы в настоящее время не будут использовать индекс:</target>
        </trans-unit>
        <trans-unit id="021cca6e0a1bc313b828c0c99864715910f5cf3d" translate="yes" xml:space="preserve">
          <source>Note that the UNION ALL operator for compound queries does not use transient indices by itself (though of course the right and left subqueries of the UNION ALL might use transient indices depending on how they are composed.)</source>
          <target state="translated">Обратите внимание,что оператор UNION ALL для составных запросов сам по себе не использует переходные индексы (хотя,конечно,правый и левый подзапросы UNION ALL могут использовать переходные индексы в зависимости от того,как они составлены).</target>
        </trans-unit>
        <trans-unit id="0676f5b60fd19b027ecab9b9999e5b7f746d671c" translate="yes" xml:space="preserve">
          <source>Note that the authorizer callback is invoked only during &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; or its variants. Authorization is not performed during statement evaluation in &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt;, unless as stated in the previous paragraph, sqlite3_step() invokes sqlite3_prepare_v2() to reprepare a statement after a schema change.</source>
          <target state="translated">Обратите внимание, что обратный вызов авторизатора вызывается только во время &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare ()&lt;/a&gt; или его вариантов. Авторизация не выполняется во время оценки оператора в &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step ()&lt;/a&gt; , если, как указано в предыдущем абзаце, sqlite3_step () не вызывает sqlite3_prepare_v2 () для представления оператора после изменения схемы.</target>
        </trans-unit>
        <trans-unit id="f1e28776761e0bfe4431c21ae77ea6373668b8fc" translate="yes" xml:space="preserve">
          <source>Note that the authorizer callback is invoked only during &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; or its variants. Authorization is not performed during statement evaluation in &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt;, unless as stated in the previous paragraph, sqlite3_step() invokes sqlite3_prepare_v2() to reprepare a statement after a schema change.</source>
          <target state="translated">Обратите внимание, что обратный вызов авторизатора вызывается только во время &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare ()&lt;/a&gt; или его вариантов. Авторизация не выполняется во время оценки оператора в &lt;a href=&quot;step&quot;&gt;sqlite3_step ()&lt;/a&gt; , если, как указано в предыдущем абзаце, sqlite3_step () не вызывает sqlite3_prepare_v2 () для представления оператора после изменения схемы.</target>
        </trans-unit>
        <trans-unit id="ac6d36a8492877c1ea3743d0c173020c27937cf2" translate="yes" xml:space="preserve">
          <source>Note that the character encoding mechanism used by SQLite cannot be changed at run-time. This is a compile-time option only. The &lt;b&gt;sqlite_encoding&lt;/b&gt; character string just tells you how the library was compiled.</source>
          <target state="translated">Обратите внимание, что механизм кодировки символов, используемый SQLite, нельзя изменить во время выполнения. Это опция только во время компиляции. &lt;b&gt;Sqlite_encoding&lt;/b&gt; символьная строка просто говорит вам , как была собрана библиотека.</target>
        </trans-unit>
        <trans-unit id="7febee2154ade1b2d3219ad0df6d8ce2b6d91690" translate="yes" xml:space="preserve">
          <source>Note that the checksums in the rollback journal are not necessary if the synchronous setting is FULL. We only depend on the checksums when synchronous is lowered to NORMAL. Nevertheless, the checksums never hurt and so they are included in the rollback journal regardless of the synchronous setting.</source>
          <target state="translated">Обратите внимание,что контрольные суммы в журнале отката не нужны,если настройка синхронизации FULL.Мы зависим только от контрольных сумм при снижении синхронной настройки до NORMAL.Тем не менее,контрольные суммы никогда не повреждаются и поэтому включаются в журнал отката независимо от синхронной установки.</target>
        </trans-unit>
        <trans-unit id="808239b91162b2ff74019b785a2c4443032a884a" translate="yes" xml:space="preserve">
          <source>Note that the command-line shell program has already enabled extension loading for you (by calling the &lt;a href=&quot;c3ref/enable_load_extension&quot;&gt;sqlite3_enable_load_extension()&lt;/a&gt; interface as part of its setup) so the command above works without any special switches, setup, or other complications.</source>
          <target state="translated">Обратите внимание, что программа оболочки командной строки уже включила для вас загрузку расширения (путем вызова интерфейса &lt;a href=&quot;c3ref/enable_load_extension&quot;&gt;sqlite3_enable_load_extension ()&lt;/a&gt; как части своей настройки), поэтому приведенная выше команда работает без каких-либо специальных переключателей, настройки или других сложностей.</target>
        </trans-unit>
        <trans-unit id="6e9cc72c28987333ade7d6e3571128f51c3b46dd" translate="yes" xml:space="preserve">
          <source>Note that the destructor function D is for the pointer value P, not for the type string T. The type string T should be a static string with an infinite lifetime.</source>
          <target state="translated">Обратите внимание,что функция деструктора D предназначена для значения указателя P,а не для строки типа T.Строка типа T должна быть статической строкой с бесконечным временем жизни.</target>
        </trans-unit>
        <trans-unit id="4cfa4e46e35f2a19630aea45991cffe3dd621ecd" translate="yes" xml:space="preserve">
          <source>Note that the integer key is one greater than the largest key that was in the table just prior to the insert. The new key will be unique over all keys currently in the table, but it might overlap with keys that have been previously deleted from the table. To create keys that are unique over the lifetime of the table, add the &lt;a href=&quot;autoinc&quot;&gt;AUTOINCREMENT&lt;/a&gt; keyword to the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; declaration. Then the key chosen will be one more than the largest key that has ever existed in that table. If the largest possible key has previously existed in that table, then the &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; will fail with an &lt;a href=&quot;rescode#full&quot;&gt;SQLITE_FULL&lt;/a&gt; error code.</source>
          <target state="translated">Обратите внимание, что целочисленный ключ на единицу больше, чем самый большой ключ, который был в таблице непосредственно перед вставкой. Новый ключ будет уникальным среди всех ключей, находящихся в настоящее время в таблице, но он может перекрываться с ключами, которые были ранее удалены из таблицы. Чтобы создать ключи, которые будут уникальными в течение всего времени существования таблицы, добавьте ключевое слово &lt;a href=&quot;autoinc&quot;&gt;AUTOINCREMENT&lt;/a&gt; в объявление &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; . Тогда выбранный ключ будет на один больше, чем самый большой ключ, который когда-либо существовал в этой таблице. Если в этой таблице ранее уже существовал самый большой из возможных ключей, то &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; завершится ошибкой с &lt;a href=&quot;rescode#full&quot;&gt;кодом SQLITE_FULL&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="228b63ead1b7d1b62a8c83539d4e8ab64da2dc4c" translate="yes" xml:space="preserve">
          <source>Note that the journal_mode for an &lt;a href=&quot;inmemorydb&quot;&gt;in-memory database&lt;/a&gt; is either MEMORY or OFF and can not be changed to a different value. An attempt to change the journal_mode of an &lt;a href=&quot;inmemorydb&quot;&gt;in-memory database&lt;/a&gt; to any setting other than MEMORY or OFF is ignored. Note also that the journal_mode cannot be changed while a transaction is active.</source>
          <target state="translated">Обратите внимание, что journal_mode для &lt;a href=&quot;inmemorydb&quot;&gt;базы данных в памяти&lt;/a&gt; имеет значение MEMORY или OFF и не может быть изменено на другое значение. Попытка изменить journal_mode &lt;a href=&quot;inmemorydb&quot;&gt;базы данных&lt;/a&gt; в памяти на любой параметр, кроме MEMORY или OFF, игнорируется. Также обратите внимание, что journal_mode нельзя изменить, пока транзакция активна.</target>
        </trans-unit>
        <trans-unit id="1150442b82dfad6909e59c690e94911009ab738b" translate="yes" xml:space="preserve">
          <source>Note that the list of routines above is conceptual rather than actual. Many of these routines come in multiple versions. For example, the list above shows a single routine named &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt; when in fact there are three separate routines that accomplish the same thing in slightly different ways: &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open16()&lt;/a&gt; and &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;. The list mentions &lt;a href=&quot;c3ref/column_blob&quot;&gt;sqlite3_column()&lt;/a&gt; when in fact no such routine exists. The &quot;sqlite3_column()&quot; shown in the list is a placeholder for an entire family of routines that extra column data in various datatypes.</source>
          <target state="translated">Обратите внимание, что приведенный выше список процедур является скорее концептуальным, чем фактическим. Многие из этих программ имеют несколько версий. Например, в приведенном выше списке показана одна подпрограмма с именем &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open (),&lt;/a&gt; хотя на самом деле есть три отдельных подпрограммы, которые выполняют одно и то же несколько разными способами: &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open ()&lt;/a&gt; , &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open16 ()&lt;/a&gt; и &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2 ()&lt;/a&gt; . В списке упоминается &lt;a href=&quot;c3ref/column_blob&quot;&gt;sqlite3_column (),&lt;/a&gt; хотя на самом деле такой процедуры не существует. Показанный в списке &amp;laquo;sqlite3_column ()&amp;raquo; является заполнителем для целого семейства подпрограмм, которые добавляют данные столбца в различные типы данных.</target>
        </trans-unit>
        <trans-unit id="4fdc00a153b8f8752a20bfd3564af15ee4f88900" translate="yes" xml:space="preserve">
          <source>Note that the memory leak detection logic continues to work even when the OOM overlay is being used. This verifies that SQLite does not leak memory even when it encounters memory allocation errors. Note also that the OOM overlay can work with any underlying memory allocator, including the instrumented memory allocator that checks for memory allocation misuse. In this way it is verified that OOM errors do not induce other kinds of memory usage errors.</source>
          <target state="translated">Обратите внимание,что логика обнаружения утечки памяти продолжает работать даже при использовании оверлея OOM.Это проверяет,что SQLite не утечка памяти,даже когда он сталкивается с ошибками выделения памяти.Заметьте также,что оверлей OOM может работать с любым аллокатором памяти,включая инструментированный аллокатор памяти,который проверяет неправильное выделение памяти.Таким образом,проверяется,что ошибки OOM не приводят к другим видам ошибок использования памяти.</target>
        </trans-unit>
        <trans-unit id="a2673a9d4ca364b864416763c5f28c9b8fac9ff0" translate="yes" xml:space="preserve">
          <source>Note that the number of keywords understood by SQLite can depend on compile-time options. For example, &quot;VACUUM&quot; is not a keyword if SQLite is compiled with the &lt;a href=&quot;../compile#omit_vacuum&quot;&gt;-DSQLITE_OMIT_VACUUM&lt;/a&gt; option. Also, new keywords may be added to future releases of SQLite.</source>
          <target state="translated">Обратите внимание, что количество ключевых слов, понимаемых SQLite, может зависеть от параметров времени компиляции. Например, &amp;laquo;VACUUM&amp;raquo; не является ключевым словом, если SQLite скомпилирован с параметром &lt;a href=&quot;../compile#omit_vacuum&quot;&gt;-DSQLITE_OMIT_VACUUM&lt;/a&gt; . Также новые ключевые слова могут быть добавлены в будущие выпуски SQLite.</target>
        </trans-unit>
        <trans-unit id="2d91b980ac2f1529b090c5eabcb20ce64f838c85" translate="yes" xml:space="preserve">
          <source>Note that the number of keywords understood by SQLite can depend on compile-time options. For example, &quot;VACUUM&quot; is not a keyword if SQLite is compiled with the &lt;a href=&quot;compile#omit_vacuum&quot;&gt;-DSQLITE_OMIT_VACUUM&lt;/a&gt; option. Also, new keywords may be added to future releases of SQLite.</source>
          <target state="translated">Обратите внимание, что количество ключевых слов, понимаемых SQLite, может зависеть от параметров времени компиляции. Например, &amp;laquo;VACUUM&amp;raquo; не является ключевым словом, если SQLite скомпилирован с параметром &lt;a href=&quot;compile#omit_vacuum&quot;&gt;-DSQLITE_OMIT_VACUUM&lt;/a&gt; . Также новые ключевые слова могут быть добавлены в будущие выпуски SQLite.</target>
        </trans-unit>
        <trans-unit id="4aca65a78510b061ab1efe777d7b5b2943653a08" translate="yes" xml:space="preserve">
          <source>Note that the order of the rules for determining column affinity is important. A column whose declared type is &quot;CHARINT&quot; will match both rules 1 and 2 but the first rule takes precedence and so the column affinity will be INTEGER.</source>
          <target state="translated">Обратите внимание,что порядок правил определения сродства столбцов важен.Столбец с объявленным типом &quot;CHARINT&quot; будет соответствовать и правилам 1 и 2,но первое правило имеет приоритет,поэтому сродство столбца будет INTEGER.</target>
        </trans-unit>
        <trans-unit id="1d73e69c69eafce89c99fd09f5dcbc2e6299190a" translate="yes" xml:space="preserve">
          <source>Note that the primary result code is always a part of the extended result code. Given a full 32-bit extended result code, the application can always find the corresponding primary result code merely by extracting the least significant 8 bits of the extended result code.</source>
          <target state="translated">Обратите внимание,что первичный код результата всегда является частью расширенного кода результата.При полном 32-битном расширенном результирующем коде приложение всегда может найти соответствующий код первичного результата,просто извлекая из расширенного результирующего кода наименее значащие 8 бит.</target>
        </trans-unit>
        <trans-unit id="299082c757bfbc2b1a98c9af13620cc48c49d3d4" translate="yes" xml:space="preserve">
          <source>Note that the program for this SELECT query didn't contain the Transaction and Commit instructions used in the INSERT example. Because the SELECT is a read operation that doesn't alter the database, it doesn't require a transaction.</source>
          <target state="translated">Обратите внимание,что программа для данного SELECT-запроса не содержала инструкций Transaction and Commit,используемых в примере INSERT.Поскольку SELECT-это операция чтения,которая не изменяет базу данных,она не требует транзакции.</target>
        </trans-unit>
        <trans-unit id="f586476195ef53b793699f052ad1af05d3a6c8e4" translate="yes" xml:space="preserve">
          <source>Note that the readfile(X) and writefile(X,Y) functions are extension functions and are not built into the core SQLite library. These routines are available as a &lt;a href=&quot;loadext&quot;&gt;loadable extension&lt;/a&gt; in the &lt;a href=&quot;http://www.sqlite.org/src/artifact?ci=trunk&amp;amp;filename=ext/misc/fileio.c&quot;&gt;ext/misc/fileio.c&lt;/a&gt; source file in the &lt;a href=&quot;https://sqlite.org/download.html#srctree&quot;&gt;SQLite source code repositories&lt;/a&gt;.</source>
          <target state="translated">Обратите внимание, что функции readfile (X) и writefile (X, Y) являются функциями расширения и не встроены в базовую библиотеку SQLite. Эти процедуры доступны в виде &lt;a href=&quot;loadext&quot;&gt;загружаемых расширений&lt;/a&gt; в исходном файле &lt;a href=&quot;http://www.sqlite.org/src/artifact?ci=trunk&amp;amp;filename=ext/misc/fileio.c&quot;&gt;ext / misc / fileio.c&lt;/a&gt; в &lt;a href=&quot;https://sqlite.org/download.html#srctree&quot;&gt;репозиториях исходного кода SQLite&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="64553501493418021ca0b221dddc1b5aa622fbc2" translate="yes" xml:space="preserve">
          <source>Note that the result from casting any non-BLOB value into a BLOB and the result from casting any BLOB value into a non-BLOB value may be different depending on whether the database &lt;a href=&quot;pragma#pragma_encoding&quot;&gt;encoding&lt;/a&gt; is UTF-8, UTF-16be, or UTF-16le.</source>
          <target state="translated">Обратите внимание, что результат преобразования любого значения, отличного от BLOB, в BLOB и результат преобразования любого значения BLOB в значение, отличное от BLOB, могут отличаться в зависимости от того, является ли &lt;a href=&quot;pragma#pragma_encoding&quot;&gt;кодировка&lt;/a&gt; базы данных UTF-8, UTF-16be или UTF-16le. .</target>
        </trans-unit>
        <trans-unit id="e984670ffac060fe0c3430de1a1c23ffe29028d1" translate="yes" xml:space="preserve">
          <source>Note that the sqlite3changeset_apply_v2() API is still &lt;b&gt;experimental&lt;/b&gt; and therefore subject to change.</source>
          <target state="translated">Обратите внимание, что API sqlite3changeset_apply_v2 () все еще является &lt;b&gt;экспериментальным&lt;/b&gt; и поэтому может быть изменен.</target>
        </trans-unit>
        <trans-unit id="a04165c5ad09a6b0ad2414206038c2e65d87aa51" translate="yes" xml:space="preserve">
          <source>Note that the sqlite3changeset_start_v2() API is still &lt;b&gt;experimental&lt;/b&gt; and therefore subject to change.</source>
          <target state="translated">Обратите внимание, что API sqlite3changeset_start_v2 () все еще является &lt;b&gt;экспериментальным&lt;/b&gt; и поэтому может быть изменен.</target>
        </trans-unit>
        <trans-unit id="6c55c88c2dea7079ec802efa3e99479f764ecf7e" translate="yes" xml:space="preserve">
          <source>Note that the unary *+* operator also removes &lt;a href=&quot;datatype3#affinity&quot;&gt;type affinity&lt;/a&gt; from an expression, and in some cases this can cause subtle changes in the meaning of an expression. In the example above, if column *x* has &lt;a href=&quot;datatype3#affinity&quot;&gt;TEXT affinity&lt;/a&gt; then the comparison &quot;x=5&quot; will be done as text. But the *+* operator removes the affinity. So the comparison &quot;+x=5&quot; will compare the text in column *x* with the numeric value 5 and will always be false.</source>
          <target state="translated">Обратите внимание, что унарный оператор * + * также удаляет &lt;a href=&quot;datatype3#affinity&quot;&gt;сходство типов&lt;/a&gt; из выражения, и в некоторых случаях это может вызвать незначительные изменения в значении выражения. В приведенном выше примере, если столбец * x * имеет соответствие &lt;a href=&quot;datatype3#affinity&quot;&gt;ТЕКСТА,&lt;/a&gt; тогда сравнение &amp;laquo;x = 5&amp;raquo; будет выполнено как текст. Но оператор * + * убирает сродство. Таким образом, сравнение &amp;laquo;+ x = 5&amp;raquo; будет сравнивать текст в столбце * x * с числовым значением 5 и всегда будет ложным.</target>
        </trans-unit>
        <trans-unit id="c990d58c5d0bc49b39ec476dafbb19955404bbcd" translate="yes" xml:space="preserve">
          <source>Note that there are paths through the syntax diagrams that are not allowed in practice. Some examples:</source>
          <target state="translated">Обратите внимание,что есть пути через синтаксические диаграммы,которые не разрешены на практике.Некоторые примеры:</target>
        </trans-unit>
        <trans-unit id="96acc3ff45ab0c01a0b94c0892486dbb72afce32" translate="yes" xml:space="preserve">
          <source>Note that there are two variations of the equals and not equals operators. Equals can be either</source>
          <target state="translated">Обратите внимание,что существует два варианта равенства и не равенства операторов.Равные могут быть также</target>
        </trans-unit>
        <trans-unit id="a67d64fb18ca2294fb42994c6d74eeb61ff03be8" translate="yes" xml:space="preserve">
          <source>Note that this is only a thought experiment. We are not suggesting that OpenDocument be changed. Nor is this article a criticism of the current OpenDocument design. The point of this essay is to suggest ways to improve future file format designs.</source>
          <target state="translated">Обратите внимание,что это всего лишь мыслительный эксперимент.Мы не предлагаем изменять OpenDocument.Эта статья также не является критикой текущего дизайна OpenDocument.Смысл этого эссе в том,чтобы предложить способы улучшения дизайна будущих форматов файлов.</target>
        </trans-unit>
        <trans-unit id="99c1505807d577ab62bcd4edbb24d5f3cd06e9f6" translate="yes" xml:space="preserve">
          <source>Note that this problem only occurs if the attempt to acquire the lock resulted in an I/O error. If the lock is simply not granted (because some other thread or process is already holding a conflicting lock) then no corruption will ever occur. We are not aware of any operating systems that will fail with an I/O error while attempting to get a file lock on shared memory. So this is a theoretical problem rather than a real problem. Needless to say, this problem has never been observed in the wild. The problem was discovered while doing stress testing of SQLite in a test harness that simulates I/O errors.</source>
          <target state="translated">Обратите внимание,что эта проблема возникает только в том случае,если попытка получения блокировки привела к ошибке ввода/вывода.Если блокировка просто не разрешена (потому что какой-то другой поток или процесс уже имеет конфликтующую блокировку),то повреждений никогда не произойдет.Мы не знаем ни одной операционной системы,которая бы не справилась с ошибкой ввода/вывода при попытке получить файловую блокировку в общей памяти.Таким образом,это скорее теоретическая проблема,чем реальная проблема.Нет нужды говорить,что эта проблема никогда не наблюдалась в дикой природе.Проблема была обнаружена во время стресс-тестирования SQLite в тестовом жгуте,который моделирует ошибки ввода/вывода.</target>
        </trans-unit>
        <trans-unit id="ebff595e74a177f5fa63d87902cc62cb3ce02f96" translate="yes" xml:space="preserve">
          <source>Note that this routine returns zero on a match and non-zero if the strings do not match, the same as &lt;a href=&quot;#sqlite3_stricmp&quot;&gt;sqlite3_stricmp()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_stricmp&quot;&gt;sqlite3_strnicmp()&lt;/a&gt;.</source>
          <target state="translated">Обратите внимание, что эта процедура возвращает ноль при совпадении и ненулевое значение, если строки не совпадают, так же, как &lt;a href=&quot;#sqlite3_stricmp&quot;&gt;sqlite3_stricmp ()&lt;/a&gt; и &lt;a href=&quot;#sqlite3_stricmp&quot;&gt;sqlite3_strnicmp ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0d629b76283bd20b6edf31050b7b9b764c009820" translate="yes" xml:space="preserve">
          <source>Note that this routine returns zero on a match and non-zero if the strings do not match, the same as &lt;a href=&quot;stricmp&quot;&gt;sqlite3_stricmp()&lt;/a&gt; and &lt;a href=&quot;stricmp&quot;&gt;sqlite3_strnicmp()&lt;/a&gt;.</source>
          <target state="translated">Обратите внимание, что эта процедура возвращает ноль при совпадении и ненулевое значение, если строки не совпадают, так же, как &lt;a href=&quot;stricmp&quot;&gt;sqlite3_stricmp ()&lt;/a&gt; и &lt;a href=&quot;stricmp&quot;&gt;sqlite3_strnicmp ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c810fa4c8943f66ac3d34092b7e767d31528340e" translate="yes" xml:space="preserve">
          <source>Note that triggers are automatically dropped when the associated table is dropped.</source>
          <target state="translated">Обратите внимание,что триггеры автоматически сбрасываются при сбросе соответствующей таблицы.</target>
        </trans-unit>
        <trans-unit id="d606f23ac3535efbf11c3a7516392c25071ecf15" translate="yes" xml:space="preserve">
          <source>Note that when SQLite is compiled with SQLITE_THREADSAFE=0, the code to make SQLite threadsafe is omitted from the build. When this occurs, it is impossible to change the &lt;a href=&quot;threadsafe&quot;&gt;threading mode&lt;/a&gt; at start-time or run-time.</source>
          <target state="translated">Обратите внимание, что когда SQLite скомпилирован с SQLITE_THREADSAFE = 0, код для обеспечения безопасности потоков SQLite не включается в сборку. Когда это происходит, невозможно изменить &lt;a href=&quot;threadsafe&quot;&gt;режим работы&lt;/a&gt; с потоками во время запуска или выполнения.</target>
        </trans-unit>
        <trans-unit id="32708b7e6e76296f6dad18be6a6d369658183e8b" translate="yes" xml:space="preserve">
          <source>Note that when the SQLITE_DBCONFIG_LEGACY_FILE_FORMAT setting is on, the &lt;a href=&quot;../lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; command will fail with an obscure error when attempting to process a table with generated columns and a descending index. This is not considered a bug since SQLite versions 3.3.0 and earlier do not support either generated columns or decending indexes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3822538f7b251248e21c02ba82556fd2e3a92957" translate="yes" xml:space="preserve">
          <source>Note that when the SQLITE_DBCONFIG_LEGACY_FILE_FORMAT setting is on, the &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; command will fail with an obscure error when attempting to process a table with generated columns and a descending index. This is not considered a bug since SQLite versions 3.3.0 and earlier do not support either generated columns or decending indexes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="789391b5c680547fd2d7df978b13d5bea4b6c611" translate="yes" xml:space="preserve">
          <source>Note that when the right-hand side of a LIKE or GLOB operator is a &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameter&lt;/a&gt; and the statement is prepared using &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; or &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare16_v2()&lt;/a&gt; then the statement is automatically reparsed and recompiled on the first &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; call of each run if the binding to the right-hand side parameter has changed since the previous run. This reparse and recompile is essentially the same action that occurs following a schema change. The recompile is necessary so that the query planner can examine the new value bound to the right-hand side of the LIKE or GLOB operator and determine whether or not to employ the optimization described above.</source>
          <target state="translated">Обратите внимание, что если правая часть оператора LIKE или GLOB является &lt;a href=&quot;lang_expr#varparam&quot;&gt;параметром&lt;/a&gt; и оператор подготовлен с использованием &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; или &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare16_v2 (),&lt;/a&gt; тогда оператор автоматически повторно анализируется и перекомпилируется при первом вызове &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step ()&lt;/a&gt; каждого запуска, если привязка к правому параметру изменилась по сравнению с предыдущим запуском. Этот повторный анализ и перекомпиляция - это, по сути, то же действие, которое происходит после изменения схемы. Перекомпиляция необходима для того, чтобы планировщик запросов мог проверить новое значение, привязанное к правой стороне оператора LIKE или GLOB, и определить, следует ли использовать оптимизацию, описанную выше.</target>
        </trans-unit>
        <trans-unit id="7aca89c620a18b6fdc63e568bea908a626dcadff" translate="yes" xml:space="preserve">
          <source>Note that when type conversions occur, pointers returned by prior calls to sqlite3_column_blob(), sqlite3_column_text(), and/or sqlite3_column_text16() may be invalidated. Type conversions and pointer invalidations might occur in the following cases:</source>
          <target state="translated">Обратите внимание,что при приведении типов указатели,возвращенные предыдущими вызовами sqlite3_column_blob(),sqlite3_column_text()и/или sqlite3_column_text16(),могут быть признаны недействительными.Приведение типов и аннулирование указателей может произойти в следующих случаях:</target>
        </trans-unit>
        <trans-unit id="1368e4859dec1f8b656ae1f17b0c284cfecc238a" translate="yes" xml:space="preserve">
          <source>Note that with &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous&lt;/a&gt; set to NORMAL, the checkpoint is the only operation to issue an I/O barrier or sync operation (fsync() on unix or FlushFileBuffers() on windows). If an application therefore runs checkpoint in a separate thread or process, the main thread or process that is doing database queries and updates will never block on a sync operation. This helps to prevent &quot;latch-up&quot; in applications running on a busy disk drive. The downside to this configuration is that transactions are no longer durable and might rollback following a power failure or hard reset.</source>
          <target state="translated">Обратите внимание, что с &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;синхронным PRAGMA,&lt;/a&gt; установленным на NORMAL, контрольная точка является единственной операцией, которая создает барьер ввода-вывода или операцию синхронизации (fsync () в unix или FlushFileBuffers () в Windows). Таким образом, если приложение запускает контрольную точку в отдельном потоке или процессе, основной поток или процесс, выполняющий запросы к базе данных и обновления, никогда не будет блокироваться при операции синхронизации. Это помогает предотвратить &amp;laquo;зависание&amp;raquo; приложений, работающих на загруженном диске. Обратной стороной этой конфигурации является то, что транзакции больше не являются надежными и могут откатиться после сбоя питания или жесткого сброса.</target>
        </trans-unit>
        <trans-unit id="8da0c032621fbb18df4dc03aaa124440bc316a57" translate="yes" xml:space="preserve">
          <source>Note that with ANALYZE the cost estimates are better aligned with reality and algorithm-1 is selected by both NN and N3.</source>
          <target state="translated">Обратите внимание,что при использовании ANALYZE смета расходов лучше согласуется с реальностью,а алгоритм-1 выбирается как NN,так и N3.</target>
        </trans-unit>
        <trans-unit id="695e607ef01e6db075031ffa227e23ca60904541" translate="yes" xml:space="preserve">
          <source>Note that xBestIndex will always be called before &lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter&lt;/a&gt;, since the idxNum and idxStr outputs from xBestIndex are required inputs to xFilter. However, there is no guarantee that xFilter will be called following a successful xBestIndex.</source>
          <target state="translated">Обратите внимание, что xBestIndex всегда будет вызываться перед &lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter&lt;/a&gt; , поскольку выходные данные idxNum и idxStr из xBestIndex являются обязательными входными данными для xFilter. Однако нет гарантии, что xFilter будет вызван после успешного xBestIndex.</target>
        </trans-unit>
        <trans-unit id="d227a38478007bafe1c5681fa0c0259f1628a846" translate="yes" xml:space="preserve">
          <source>Note the &quot;temp.&quot; qualifier before the virtual table name (&quot;stat&quot;). This qualifier causes the virtual table to be temporary - to only exist for the duration of the current database connection. This is the recommended approach.</source>
          <target state="translated">Обратите внимание на классификатор &quot;temp.&quot; перед именем виртуальной таблицы (&quot;stat&quot;).Этот классификатор приводит к тому,что виртуальная таблица будет временной-существовать только на время текущего подключения к БД.Это рекомендуемый подход.</target>
        </trans-unit>
        <trans-unit id="984a9d35869a9cec59e40e09a2d60d76afb99304" translate="yes" xml:space="preserve">
          <source>Note the last bullet in particular. The destructor X in sqlite3_set_auxdata(C,N,P,X) might be called immediately, before the sqlite3_set_auxdata() interface even returns. Hence sqlite3_set_auxdata() should be called near the end of the function implementation and the function implementation should not make any use of P after sqlite3_set_auxdata() has been called.</source>
          <target state="translated">Обратите внимание на последнюю пулю.Деструктор X в sqlite3_set_auxdata(C,N,P,X)может быть вызван сразу же,еще до того,как интерфейс sqlite3_set_auxdata()вернется.Следовательно,sqlite3_set_auxdata()должна вызываться ближе к концу реализации функции,а реализация функции не должна использовать P после вызова sqlite3_set_auxdata().</target>
        </trans-unit>
        <trans-unit id="be13ad345e0dba5ca596ce6f7266fdf09fc32236" translate="yes" xml:space="preserve">
          <source>Note the use of the &lt;a href=&quot;lang_corefunc#quote&quot;&gt;quote() SQL function&lt;/a&gt; in these triggers. The quote() function converts its argument into a form that is appropriate for inclusion in an SQL statement. Numeric values come through unchanged. Single quotes are added before and after strings and any internal single quotes are escaped. BLOB values are rendered using SQL-standard hexadecimal BLOB notation. The use of the quote() function ensures that the SQL statements used to undo and redo are always safe from SQL injection.</source>
          <target state="translated">Обратите внимание на использование в этих триггерах &lt;a href=&quot;lang_corefunc#quote&quot;&gt;SQL-функции quote ()&lt;/a&gt; . Функция quote () преобразует свой аргумент в форму, подходящую для включения в оператор SQL. Числовые значения остаются без изменений. Одиночные кавычки добавляются до и после строк, а любые внутренние одинарные кавычки экранируются. Значения BLOB отображаются с использованием стандартной шестнадцатеричной записи BLOB в стандарте SQL. Использование функции quote () гарантирует, что операторы SQL, используемые для отмены и повтора, всегда защищены от внедрения SQL.</target>
        </trans-unit>
        <trans-unit id="044b3a09040052b2232feb80c6848441318257d4" translate="yes" xml:space="preserve">
          <source>Note the warnings on the &quot;estimatedRows&quot;, &quot;idxFlags&quot;, and colUsed fields. These fields were added with SQLite versions 3.8.2, 3.9.0, and 3.10.0, respectively. Any extension that reads or writes these fields must first check that the version of the SQLite library in use is greater than or equal to appropriate version - perhaps comparing the value returned from &lt;a href=&quot;c3ref/libversion&quot;&gt;sqlite3_libversion_number()&lt;/a&gt; against constants 3008002, 3009000, and/or 3010000. The result of attempting to access these fields in an sqlite3_index_info structure created by an older version of SQLite are undefined.</source>
          <target state="translated">Обратите внимание на предупреждения в полях &amp;laquo;EstimatedRows&amp;raquo;, &amp;laquo;idxFlags&amp;raquo; и colUsed. Эти поля были добавлены в SQLite версий 3.8.2, 3.9.0 и 3.10.0 соответственно. Любое расширение, которое считывает или записывает эти поля, должно сначала проверить, что версия используемой библиотеки SQLite больше или равна соответствующей версии - возможно, сравнивая значение, возвращаемое функцией &lt;a href=&quot;c3ref/libversion&quot;&gt;sqlite3_libversion_number (),&lt;/a&gt; с константами 3008002, 3009000 и / или 3010000. Результат попытки доступа к этим полям в структуре sqlite3_index_info, созданной более старой версией SQLite, не определен.</target>
        </trans-unit>
        <trans-unit id="49bc1f28a1c9c886ae8bd63cbcbb27c797246229" translate="yes" xml:space="preserve">
          <source>Note: Functions marked with &quot;&lt;small&gt;&lt;i&gt;(exp)&lt;/i&gt;&lt;/small&gt;&quot; are &lt;a href=&quot;capi3ref&quot;&gt;experimental&lt;/a&gt; and functions whose names are &lt;s&gt;struck through&lt;/s&gt; are &lt;a href=&quot;capi3ref&quot;&gt;deprecated&lt;/a&gt;.</source>
          <target state="translated">Примечание. Функции, отмеченные знаком &amp;laquo; &lt;small&gt;&lt;i&gt;(exp)&lt;/i&gt;&lt;/small&gt; &amp;raquo;, являются &lt;a href=&quot;capi3ref&quot;&gt;экспериментальными,&lt;/a&gt; а функции, имена которых &lt;s&gt;зачеркнуты,&lt;/s&gt; считаются &lt;a href=&quot;capi3ref&quot;&gt;устаревшими&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="66ee76f5066068620f09c7e62f4bb8c158c87cf7" translate="yes" xml:space="preserve">
          <source>Note: Functions marked with &quot;&lt;small&gt;&lt;i&gt;(exp)&lt;/i&gt;&lt;/small&gt;&quot; are &lt;a href=&quot;experimental&quot;&gt;experimental&lt;/a&gt; and functions whose names are &lt;s&gt;struck through&lt;/s&gt; are &lt;a href=&quot;experimental&quot;&gt;deprecated&lt;/a&gt;.</source>
          <target state="translated">Примечание. Функции, отмеченные знаком &amp;laquo; &lt;small&gt;&lt;i&gt;(exp)&lt;/i&gt;&lt;/small&gt; &amp;raquo;, являются &lt;a href=&quot;experimental&quot;&gt;экспериментальными,&lt;/a&gt; а функции, имена которых &lt;s&gt;зачеркнуты,&lt;/s&gt; считаются &lt;a href=&quot;experimental&quot;&gt;устаревшими&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="03b148e28fde4df0887542e9d88b598d5e8f42db" translate="yes" xml:space="preserve">
          <source>Note: Sections 2.0 and 3.0 of this article were added in response to comments on &lt;a href=&quot;https://news.ycombinator.com/item?id=16585120&quot;&gt;Hacker News&lt;/a&gt; and &lt;a href=&quot;https://www.reddit.com/r/programming/comments/84fzoc/why_is_sqlite_coded_in_c/&quot;&gt;Reddit&lt;/a&gt;.</source>
          <target state="translated">Примечание. Разделы 2.0 и 3.0 этой статьи были добавлены в ответ на комментарии к &lt;a href=&quot;https://news.ycombinator.com/item?id=16585120&quot;&gt;Hacker News&lt;/a&gt; и &lt;a href=&quot;https://www.reddit.com/r/programming/comments/84fzoc/why_is_sqlite_coded_in_c/&quot;&gt;Reddit&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="85e051b1f236f895d99d48916ab5fd667388aec3" translate="yes" xml:space="preserve">
          <source>Note: This method is disabled on MacOS X 10.7 and iOS version 5.0 and will always return SQLITE_MISUSE. On those systems, shared cache mode should be enabled per-database connection via &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; with &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_SHAREDCACHE&lt;/a&gt;.</source>
          <target state="translated">Примечание. Этот метод отключен в MacOS X 10.7 и iOS версии 5.0 и всегда будет возвращать SQLITE_MISUSE. В этих системах режим общего кеша должен быть включен для подключения к базе данных через &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2 ()&lt;/a&gt; с &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_SHAREDCACHE&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ddf57deb38e4651cb3981116d2b9ec03a6feb885" translate="yes" xml:space="preserve">
          <source>Note: This method is disabled on MacOS X 10.7 and iOS version 5.0 and will always return SQLITE_MISUSE. On those systems, shared cache mode should be enabled per-database connection via &lt;a href=&quot;open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; with &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_SHAREDCACHE&lt;/a&gt;.</source>
          <target state="translated">Примечание. Этот метод отключен в MacOS X 10.7 и iOS версии 5.0 и всегда будет возвращать SQLITE_MISUSE. В этих системах режим общего кеша должен быть включен для подключения к базе данных через &lt;a href=&quot;open&quot;&gt;sqlite3_open_v2 ()&lt;/a&gt; с &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_SHAREDCACHE&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="70440046a3dc2e079f23ee1c57dfa76669b732aa" translate="yes" xml:space="preserve">
          <source>Notes</source>
          <target state="translated">Notes</target>
        </trans-unit>
        <trans-unit id="b7c62ae6be1885d1c5a81f6a7886c67b36419ed4" translate="yes" xml:space="preserve">
          <source>Notes on the &lt;a href=&quot;optoverview&quot;&gt;query optimizer&lt;/a&gt;.</source>
          <target state="translated">Примечания к &lt;a href=&quot;optoverview&quot;&gt;оптимизатору запросов&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9c3befe7e22c8667bc957541f49b0ee79970b588" translate="yes" xml:space="preserve">
          <source>Notes:</source>
          <target state="translated">Notes:</target>
        </trans-unit>
        <trans-unit id="bb5c89c5cb4409cab6ee44d716c6d95feaaddc62" translate="yes" xml:space="preserve">
          <source>Notice how the LIKE operator is implemented. It is a user-defined function in SQLite, so the address of its function definition is specified in P3. The operand P1 is the number of function arguments for it to take from the stack. In this case the LIKE() function takes 2 arguments. The arguments are taken off the stack in reverse order (right-to-left), so the pattern to match is the top stack element, and the next element is the data to compare. The return value is pushed onto the stack.</source>
          <target state="translated">Обратите внимание,как реализуется оператор LIKE.В SQLite это пользовательская функция,поэтому адрес ее определения указан в P3.Операнд P1-это количество аргументов функции,которое она может взять из стека.В этом случае функция LIKE()принимает 2 аргумента.Аргументы снимаются со стека в обратном порядке (справа налево),поэтому подходящий образец-верхний элемент стека,а следующий элемент-данные для сравнения.Возвращаемое значение перемещается в стек.</target>
        </trans-unit>
        <trans-unit id="5255c6a9b36d606aac6af8d3dbbceadb0d1f9b02" translate="yes" xml:space="preserve">
          <source>Notice how the query above works: The R*Tree index runs in the outer loop to find entries that are contained within the bounding box of longitude -81..-79.6 and latitude 35.0..36.2. For each object identifier found, SQLite looks up the corresponding entry in the demo_data table. It then uses the boundary field from the demo_data table as a parameter to the contained_in() function and if that function returns true, the objname field from the demo_data table is returned as the next row of query result.</source>
          <target state="translated">Обратите внимание,как работает вышеприведенный запрос:Индекс R*Tree запускается во внешнем цикле для поиска записей,которые содержатся в граничном поле долготы -81...-79.6 и широты 35.0...36.2.Для каждого найденного идентификатора объекта SQLite ищет соответствующую запись в таблице demo_data.Затем он использует граничное поле из таблицы demo_data в качестве параметра в функцию contain_in(),и если эта функция возвращает true,то поле объектного имени из таблицы demo_data возвращается в качестве следующей строки результата запроса.</target>
        </trans-unit>
        <trans-unit id="3b7384e004cca4a56bb485375c44be1a10c5774f" translate="yes" xml:space="preserve">
          <source>Notice that all other date and time functions can be expressed in terms of strftime():</source>
          <target state="translated">Обратите внимание,что все остальные функции даты и времени могут быть выражены с помощью функции strftime():</target>
        </trans-unit>
        <trans-unit id="a0897fe8cedb04900939c7986a4c19ddb9b29972" translate="yes" xml:space="preserve">
          <source>Notice that dividing up the content into smaller pieces using an SQLite table gives flexibility to the implementation. The application can choose to read all content into memory at startup. Or it can read just a few pages into memory and keep the rest on disk. Or it can read just single page into memory at a time. And different versions of the application can make different choices without having to make any changes to the file format. Such options are not available when all content is in a single big XML file in a ZIP archive.</source>
          <target state="translated">Обратите внимание,что разделение содержимого на более мелкие кусочки с помощью таблицы SQLite дает гибкость в реализации.При запуске приложение может выбрать чтение всего содержимого в память.Или же оно может прочитать всего несколько страниц в память,а остальное оставить на диске.Или же оно может читать только одну страницу в память одновременно.И разные версии приложения могут делать разный выбор без необходимости вносить изменения в формат файла.Такие опции недоступны,когда все содержимое находится в одном большом XML-файле в ZIP-архиве.</target>
        </trans-unit>
        <trans-unit id="8b6637336242d861c3d1aedafa06202a9a576add" translate="yes" xml:space="preserve">
          <source>Notice that the &quot;host&quot; value for the &quot;dummy&quot; record is NULL so the result[] array contains a NULL pointer at that slot.</source>
          <target state="translated">Обратите внимание,что значение &quot;host&quot; для записи &quot;dummy&quot; равно NULL,поэтому массив result[]содержит в этом слоте указатель NULL.</target>
        </trans-unit>
        <trans-unit id="81da02d10ebbcf526492f91d32dd8afa2884d608" translate="yes" xml:space="preserve">
          <source>Notice that the parameters to functions are now pointers to sqlite3_value structures instead of pointers to strings as in SQLite version 2.X. The following routines are used to extract useful information from these &quot;values&quot;:</source>
          <target state="translated">Обратите внимание,что параметры функций теперь являются указателями на структуры sqlite3_value вместо указателей на строки,как в SQLite версии 2.X.Следующие процедуры используются для извлечения полезной информации из этих &quot;значений&quot;:</target>
        </trans-unit>
        <trans-unit id="45ef496d245754f1f4daa860e31545d9feaf1aea" translate="yes" xml:space="preserve">
          <source>Notice that the shared lock is on the operating system disk cache, not on the disk itself. File locks really are just flags within the operating system kernel, usually. (The details depend on the specific OS layer interface.) Hence, the lock will instantly vanish if the operating system crashes or if there is a power loss. It is usually also the case that the lock will vanish if the process that created the lock exits.</source>
          <target state="translated">Обратите внимание,что разделяемая блокировка находится в кэше диска операционной системы,а не на самом диске.Файловые блокировки на самом деле-это просто флаги в ядре операционной системы,обычно.(Детали зависят от конкретного интерфейса уровня операционной системы.)Следовательно,блокировка мгновенно исчезнет,если операционная система выйдет из строя или произойдет отключение питания.Обычно блокировка также исчезает,если процесс,создавший блокировку,завершает свою работу.</target>
        </trans-unit>
        <trans-unit id="f8f4b80268c40011630e5371241e6ab982124215" translate="yes" xml:space="preserve">
          <source>Notice that the tokens in the result set from the fts3tokenize virtual table have been transformed according to the rules of the tokenizer. Since this example used the &quot;porter&quot; tokenizer, the &quot;This&quot; token was converted into &quot;thi&quot;. If the original text of the token is desired, it can be retrieved using the &quot;start&quot; and &quot;end&quot; columns with the &lt;a href=&quot;lang_corefunc#substr&quot;&gt;substr()&lt;/a&gt; function. For example:</source>
          <target state="translated">Обратите внимание, что токены в результирующем наборе из виртуальной таблицы fts3tokenize были преобразованы в соответствии с правилами токенизатора. Поскольку в этом примере использовался токенизатор &amp;laquo;porter&amp;raquo;, токен &amp;laquo;This&amp;raquo; был преобразован в &amp;laquo;thi&amp;raquo;. Если требуется исходный текст токена, его можно получить, используя столбцы &amp;laquo;начало&amp;raquo; и &amp;laquo;конец&amp;raquo; с помощью функции &lt;a href=&quot;lang_corefunc#substr&quot;&gt;substr ()&lt;/a&gt; . Например:</target>
        </trans-unit>
        <trans-unit id="af54971d34d4b499061179fcac4a7f0e1fee4c0f" translate="yes" xml:space="preserve">
          <source>Notice the similarity between the ListRead and Next instructions. Both operations work according to this rule:</source>
          <target state="translated">Обратите внимание на сходство между инструкциями ListRead и Next.Обе операции работают по этому правилу:</target>
        </trans-unit>
        <trans-unit id="7cec2e96076ffe89a48a9bb0d641ff84dbe2e0a2" translate="yes" xml:space="preserve">
          <source>Notice too that there is a tradeoff between average read performance and average write performance. To maximize the read performance, one wants to keep the WAL as small as possible and hence run checkpoints frequently, perhaps as often as every COMMIT. To maximize write performance, one wants to amortize the cost of each checkpoint over as many writes as possible, meaning that one wants to run checkpoints infrequently and let the WAL grow as large as possible before each checkpoint. The decision of how often to run checkpoints may therefore vary from one application to another depending on the relative read and write performance requirements of the application. The default strategy is to run a checkpoint once the WAL reaches 1000 pages and this strategy seems to work well in test applications on workstations, but other strategies might work better on different platforms or for different workloads.</source>
          <target state="translated">Заметьте также,что существует компромисс между средней производительностью чтения и средней производительностью записи.Чтобы максимизировать производительность при чтении,необходимо сохранять стены как можно меньше и,следовательно,запускать контрольно-пропускные пункты часто,возможно,так же часто,как и каждый КОММИТ.Чтобы максимизировать производительность записи,хочется амортизировать стоимость каждой контрольно-пропускной пункт над как можно большим количеством записей,а это значит,что хочется запускать контрольно-пропускные пункты нечасто,и пусть WAL растет как можно больше перед каждой контрольно-пропускной точкой.Решение о том,как часто запускать контрольно-пропускные пункты,следовательно,может варьироваться от одного приложения к другому в зависимости от относительного чтения и записи требования к производительности приложения.По умолчанию стратегия заключается в том,чтобы запустить контрольно-пропускной пункт,как только WAL достигнет 1000 страниц,и эта стратегия,кажется,хорошо работает в тестовых приложениях на рабочих станциях,но другие стратегии могут работать лучше на разных платформах или для разных рабочих нагрузок.</target>
        </trans-unit>
        <trans-unit id="d969bb722b85b5d0915700d40ff32bef3f77944d" translate="yes" xml:space="preserve">
          <source>Now compiles on MSVC++6 again</source>
          <target state="translated">Теперь снова компилирует на MSVC++6.</target>
        </trans-unit>
        <trans-unit id="6c31ef81ebda278449acfecbdc59bc58b62b9f81" translate="yes" xml:space="preserve">
          <source>Now compiles on Solaris and OpenBSD and other Unix variants that lack the fdatasync() function</source>
          <target state="translated">Теперь компилируется на Solaris и OpenBSD и других Unix-вариантах,в которых отсутствует функция fdatasync()</target>
        </trans-unit>
        <trans-unit id="d8eeae1a57da5c7c1fc46f998bfb914d868defe3" translate="yes" xml:space="preserve">
          <source>Now consider a query to find the names of everyone in the organization that is 180cm tall or taller:</source>
          <target state="translated">Теперь рассмотрим запрос,чтобы найти имена всех в организации ростом 180 см или выше:</target>
        </trans-unit>
        <trans-unit id="cace99b617f1285adb8e73b73b38a21bf398149e" translate="yes" xml:space="preserve">
          <source>Now consider the case where M and N are both 3500. Alice nodes are abundant. But suppose each of these nodes is connected by only one or two edges. In this case, option 2 is preferred. With option 2, the outer loop still has to run 3500 times, but the middle loop only runs once or twice for each outer loop and the inner loop will only run once for each middle loop, if at all. So the total number of iterations of the inner loop is around 7000. Option 1, on the other hand, has to run both its outer loop and its middle loop 3500 times each, resulting in 12 million iterations of the middle loop. Thus in the second scenario, option 2 is nearly 2000 times faster than option 1.</source>
          <target state="translated">Теперь рассмотрим случай,когда M и N оба 3500.Узлы Алисы обильны.Но предположим,что каждый из этих узлов связан только одним или двумя ребрами.В этом случае предпочтителен вариант 2.При варианте 2 внешний цикл все равно должен протекать 3500 раз,но средний-только один или два раза для каждого внешнего,а внутренний-только один раз для каждого среднего,если он вообще протекает.Таким образом,общее количество итераций внутреннего цикла составляет около 7000.Вариант 1,с другой стороны,должен прогонять как внешний,так и средний цикл 3500 раз,в результате чего средний цикл получит 12 миллионов итераций.Таким образом,во втором сценарии вариант 2 почти в 2000 раз быстрее варианта 1.</target>
        </trans-unit>
        <trans-unit id="ddfe6464a41b67622d5429681d09c2e30ec73502" translate="yes" xml:space="preserve">
          <source>Now it is time to make the private, custom modifications to SQLite which are the whole point of this exercise. Switch to the private branch (if you are not already there) using the &quot;&lt;code&gt;fossil update private&lt;/code&gt;&quot; command, then bring up the source files in your text editor and make whatever changes you want to make. Once you have finished making changes, commit those changes using this command:</source>
          <target state="translated">Пришло время внести в SQLite частные пользовательские изменения, которые и составляют основу этого упражнения. Переключитесь на частную ветку (если вас еще нет) с помощью команды &amp;laquo; &lt;code&gt;fossil update private&lt;/code&gt; &amp;raquo;, затем откройте исходные файлы в текстовом редакторе и внесите любые изменения, которые хотите внести. После того, как вы закончите вносить изменения, зафиксируйте их с помощью этой команды:</target>
        </trans-unit>
        <trans-unit id="421feb72f2bd97fb759d08871988b6f039784dca" translate="yes" xml:space="preserve">
          <source>Now let's look at how this index will be used. Consider the following query:</source>
          <target state="translated">Теперь давайте посмотрим,как будет использоваться этот индекс.Рассмотрим следующий вопрос:</target>
        </trans-unit>
        <trans-unit id="470c0db4772f894a123be1434e95e5d5a6304ade" translate="yes" xml:space="preserve">
          <source>Now suppose the user.phone field contains plain text if the user has only a single phone number and a JSON array if the user has multiple phone numbers. The same question is posed: &quot;Which users have a phone number in the 704 area code?&quot; But now the json_each() function can only be called for those users that have two or more phone numbers since json_each() requires well-formed JSON as its first argument:</source>
          <target state="translated">Теперь предположим,что поле user.phone содержит простой текст,если у пользователя только один телефонный номер,и массив JSON,если у пользователя несколько телефонных номеров.Тот же самый вопрос задается:&quot;У кого из пользователей есть телефонный номер в коде 704?&quot;.Но теперь функция json_each()может быть вызвана только для тех пользователей,которые имеют два или более телефонных номера,так как json_each()требует в качестве первого аргумента хорошо сформированного JSON:</target>
        </trans-unit>
        <trans-unit id="f22ea5fd82bf1b044f7951c4c771bd645f73f8d1" translate="yes" xml:space="preserve">
          <source>Now that the public and private branches are different, you can run the &quot;&lt;code&gt;fossil update trunk&lt;/code&gt;&quot; and &quot;&lt;code&gt;fossil update private&lt;/code&gt;&quot; commands and see that fossil really does change the files in the checkout as you switch back and forth between branches.</source>
          <target state="translated">Теперь, когда публичная и частная ветки различны, вы можете запустить команды &amp;laquo; &lt;code&gt;fossil update trunk&lt;/code&gt; &amp;raquo; и &amp;laquo; &lt;code&gt;fossil update private&lt;/code&gt; &amp;raquo; и увидеть, что fossil действительно изменяет файлы в кассе при переключении между ветвями.</target>
        </trans-unit>
        <trans-unit id="109085beaaa80ac89858b283a64f7c75d7e5bb12" translate="yes" xml:space="preserve">
          <source>Null</source>
          <target state="translated">Null</target>
        </trans-unit>
        <trans-unit id="5b7d454836a77f93829b713b5a5d0e3045934959" translate="yes" xml:space="preserve">
          <source>Null-indicator is an optional string that indicates a column value is null. The default is an empty string. Note that column-separator and null-indicator are optional positional arguments; if null-indicator is specified, a column-separator argument must be specified and precede the null-indicator argument.</source>
          <target state="translated">Null-индикатор-это необязательная строка,которая указывает на то,что значение столбца является нулевым.По умолчанию пустая строка.Обратите внимание,что аргументы &quot;столбец-сепаратор&quot; и &quot;нуль-индикатор&quot; являются необязательными позиционными аргументами;если указан нуль-индикатор,то должен быть указан аргумент &quot;столбец-сепаратор&quot;,который предшествует аргументу &quot;нуль-индикатор&quot;.</target>
        </trans-unit>
        <trans-unit id="a37aacd80c708abde1a03c3d5afe5b13fd00cfc3" translate="yes" xml:space="preserve">
          <source>NullRow</source>
          <target state="translated">NullRow</target>
        </trans-unit>
        <trans-unit id="eb0f5a21c19313cdefd12cf556538964ec1b60c1" translate="yes" xml:space="preserve">
          <source>Number Of Columns In A Result Set</source>
          <target state="translated">Количество столбцов в наборе результатов</target>
        </trans-unit>
        <trans-unit id="29a85c89c3b665d61a62026778cb1a84d89e00ac" translate="yes" xml:space="preserve">
          <source>Number Of SQL Parameters</source>
          <target state="translated">Количество параметров SQL</target>
        </trans-unit>
        <trans-unit id="a780fc260fcaca2d5e967db2577edefc7720d5d2" translate="yes" xml:space="preserve">
          <source>Number of WAL frames that have already been backfilled into the database by prior checkpoints</source>
          <target state="translated">Количество фреймов WAL,которые уже были занесены в базу данных по предыдущим контрольно-пропускным пунктам</target>
        </trans-unit>
        <trans-unit id="2a37475de2d92c9f14f2ea5c38819cea5766eaa7" translate="yes" xml:space="preserve">
          <source>Number of WAL frames that have attempted to be backfilled but which might not have been backfilled successfully.</source>
          <target state="translated">Количество кадров WAL,которые пытались залить обратно,но которые не были успешно засыплены.</target>
        </trans-unit>
        <trans-unit id="3b125f191573ae8fecea26a8fd5c1f85866a1737" translate="yes" xml:space="preserve">
          <source>Number of bytes of payload</source>
          <target state="translated">Количество байтов полезной нагрузки</target>
        </trans-unit>
        <trans-unit id="3bacc7e3374d56ead644519a8de907aa11ddb984" translate="yes" xml:space="preserve">
          <source>Number of cells on the current page or btree</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93e4ee2802912bc9542ff03c865140e0975aff48" translate="yes" xml:space="preserve">
          <source>Number of columns in a result set</source>
          <target state="translated">Количество столбцов в результирующем наборе</target>
        </trans-unit>
        <trans-unit id="2b00ff36e6009d3918fa275ec909bb841ed966c0" translate="yes" xml:space="preserve">
          <source>Number of valid and committed frames in the WAL file.</source>
          <target state="translated">Количество корректных и зафиксированных кадров в файле WAL.</target>
        </trans-unit>
        <trans-unit id="ff84d5af979f34eb1211b7993c06c6a08d3a99e3" translate="yes" xml:space="preserve">
          <source>Number-of-pages</source>
          <target state="translated">Number-of-pages</target>
        </trans-unit>
        <trans-unit id="2f32b7f17e88cd173c751d8cdc7e8c19cbcaed9f" translate="yes" xml:space="preserve">
          <source>Numeric and text types make a difference for the DISTINCT keyword too:</source>
          <target state="translated">Цифровой и текстовый типы также имеют значение для ключевого слова DISTINCT:</target>
        </trans-unit>
        <trans-unit id="c37c2e33a0fa0b90c0fc1ac3254fa39cce3fa242" translate="yes" xml:space="preserve">
          <source>Numeric values (serial types 1 through 9) sort after NULLs and in numeric order.</source>
          <target state="translated">Числовые значения (последовательные типы с 1 по 9)сортируются после NULL и в числовом порядке.</target>
        </trans-unit>
        <trans-unit id="16bebfa71033ff1ade58c6f0e6b14f281dfaba25" translate="yes" xml:space="preserve">
          <source>Numeric values sort next in numerical order</source>
          <target state="translated">Числовые значения сортируются следующим образом в числовом порядке</target>
        </trans-unit>
        <trans-unit id="0f5fd79254e55ff1fbee2cde5598536b3ec7dea6" translate="yes" xml:space="preserve">
          <source>Numerous bug fixes and documentation updates.</source>
          <target state="translated">Многочисленные исправления ошибок и обновления документации.</target>
        </trans-unit>
        <trans-unit id="dc11c061204c46d3ddd7e450955d3893423efff5" translate="yes" xml:space="preserve">
          <source>Numerous code optimizations, specially optimizations designed to make the code footprint smaller.</source>
          <target state="translated">Многочисленные оптимизации кода,специально оптимизированные для того,чтобы уменьшить объем кода.</target>
        </trans-unit>
        <trans-unit id="1608a6f49ab43b4c01022e79721183478aa81607" translate="yes" xml:space="preserve">
          <source>Numerous minor bug fixes</source>
          <target state="translated">Многочисленные незначительные исправления</target>
        </trans-unit>
        <trans-unit id="59f5ab25bf1e5a211679172dc18a637343443a9e" translate="yes" xml:space="preserve">
          <source>Numerous other performance enhancements</source>
          <target state="translated">Многочисленные другие улучшения производительности</target>
        </trans-unit>
        <trans-unit id="957b6bbcded8f49f8684b4d5e7a64d7f3a67b7a1" translate="yes" xml:space="preserve">
          <source>OCELOT</source>
          <target state="translated">OCELOT</target>
        </trans-unit>
        <trans-unit id="7481b4b2758d96d6c2ef2af6709c88460dc01560" translate="yes" xml:space="preserve">
          <source>ODP - The Open Document presentation format used by OpenOffice and others</source>
          <target state="translated">ODP-формат представления открытых документов,используемый OpenOffice и др.</target>
        </trans-unit>
        <trans-unit id="2a2888f26efa625ef4871988ca874037d8ea156c" translate="yes" xml:space="preserve">
          <source>ODT - The Open Document format used by OpenOffice and others</source>
          <target state="translated">ODT-Формат открытого документа,используемый OpenOffice и др.</target>
        </trans-unit>
        <trans-unit id="0cf81c47abad8b8dc52569f7edcc1b5b2d3511f9" translate="yes" xml:space="preserve">
          <source>OF</source>
          <target state="translated">OF</target>
        </trans-unit>
        <trans-unit id="acd2081fe0965992b6934d49ae30eed38ac749e0" translate="yes" xml:space="preserve">
          <source>OFFSET</source>
          <target state="translated">OFFSET</target>
        </trans-unit>
        <trans-unit id="4f963961751f0891a23f93bba4882f74f0ade805" translate="yes" xml:space="preserve">
          <source>OFFSET clause ignored on queries without a FROM clause. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/07d6a0453d&quot;&gt;07d6a0453d&lt;/a&gt;</source>
          <target state="translated">Предложение OFFSET игнорируется в запросах без предложения FROM. Билет &lt;a href=&quot;http://www.sqlite.org/src/info/07d6a0453d&quot;&gt;07d6a0453d&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="80f83fb7443c61c317b946841f59c0be3182f095" translate="yes" xml:space="preserve">
          <source>OFFSET gives the correct answer. However, OFFSET requires time proportional to the offset value. What really happens with &quot;LIMIT x OFFSET y&quot; is that SQLite computes the query as &quot;LIMIT x+y&quot; and discards the first y values without returning them to the application. So as the window scrolls down toward the bottom of a long list, and the y value becomes larger and larger, successive offset computations take more and more time.</source>
          <target state="translated">OFFSET дает правильный ответ.Однако,OFFSET требует времени,пропорционального значению смещения.Что на самом деле происходит с &quot;LIMIT x OFFSET y&quot;,так это то,что SQLite вычисляет запрос как &quot;LIMIT x+y&quot; и отбрасывает первые значения y,не возвращая их приложению.Так как окно прокручивается вниз к концу длинного списка,и значение y становится все больше и больше,последовательные вычисления смещения занимают все больше и больше времени.</target>
        </trans-unit>
        <trans-unit id="9c108e42d4ae43fd2c4c857619aacef018184aee" translate="yes" xml:space="preserve">
          <source>OLD references are valid</source>
          <target state="translated">Действительны ссылки на старые образцы</target>
        </trans-unit>
        <trans-unit id="387d7a59dbaaef002e0f9ac69ecd4443b9c5cef2" translate="yes" xml:space="preserve">
          <source>ON</source>
          <target state="translated">ON</target>
        </trans-unit>
        <trans-unit id="32bb503cc80e713ad933b48ce9053610aae7664e" translate="yes" xml:space="preserve">
          <source>ON CONFLICT clause</source>
          <target state="translated">ПО КОНФЛИКАТНОЙ оговорке</target>
        </trans-unit>
        <trans-unit id="c13d037157d8eb7ac7ee7af0a3380941dabf2fa2" translate="yes" xml:space="preserve">
          <source>OOM testing is accomplished by simulating OOM errors. SQLite allows an application to substitute an alternative malloc() implementation using the &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmalloc&quot;&gt;SQLITE_CONFIG_MALLOC&lt;/a&gt;,...) interface. The TCL and TH3 test harnesses are both capable of inserting a modified version of malloc() that can be rigged to fail after a certain number of allocations. These instrumented mallocs can be set to fail only once and then start working again, or to continue failing after the first failure. OOM tests are done in a loop. On the first iteration of the loop, the instrumented malloc is rigged to fail on the first allocation. Then some SQLite operation is carried out and checks are done to make sure SQLite handled the OOM error correctly. Then the time-to-failure counter on the instrumented malloc is increased by one and the test is repeated. The loop continues until the entire operation runs to completion without ever encountering a simulated OOM failure. Tests like this are run twice, once with the instrumented malloc set to fail only once, and again with the instrumented malloc set to fail continuously after the first failure.</source>
          <target state="translated">OOM-тестирование выполняется путем моделирования ошибок OOM. SQLite позволяет приложению заменять альтернативную реализацию malloc () с помощью &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt; ( &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmalloc&quot;&gt;SQLITE_CONFIG_MALLOC&lt;/a&gt;, ...) интерфейс. Тестовые жгуты TCL и TH3 способны вставлять модифицированную версию malloc (), которая может быть настроена на отказ после определенного количества распределений. Эти инструментированные маллоки могут быть настроены на сбой только один раз, а затем снова начать работать или продолжать сбой после первого сбоя. OOM-тесты выполняются в цикле. На первой итерации цикла инструментированный malloc настраивается на сбой при первом выделении. Затем выполняется некоторая операция SQLite и выполняется проверка, чтобы убедиться, что SQLite правильно обработал ошибку OOM. Затем счетчик времени до отказа на инструментированном malloc увеличивается на единицу, и тест повторяется. Цикл продолжается до тех пор, пока вся операция не завершится, даже не столкнувшись с имитацией сбоя OOM. Подобные тесты выполняются дважды,один раз с инструментированным malloc, установленным на сбой только один раз, и снова с инструментальным malloc, настроенным на постоянный сбой после первого сбоя.</target>
        </trans-unit>
        <trans-unit id="f579c523960af1aec824c6fdc57af6d4abd76a1f" translate="yes" xml:space="preserve">
          <source>OR</source>
          <target state="translated">OR</target>
        </trans-unit>
        <trans-unit id="683e61c81d390d130002106c2c28e827414b7056" translate="yes" xml:space="preserve">
          <source>ORDER</source>
          <target state="translated">ORDER</target>
        </trans-unit>
        <trans-unit id="2164bde64d5e67a9aad0e7c0543250365dc40e72" translate="yes" xml:space="preserve">
          <source>ORDER BY</source>
          <target state="translated">ЗАКАЗ</target>
        </trans-unit>
        <trans-unit id="e4ec6dd8b3c32fb2c490ae23010139de3ea19166" translate="yes" xml:space="preserve">
          <source>ORDER BY and GROUP BY now use bounded memory</source>
          <target state="translated">ЗАКАЗАТЕЛЬСТВО ЗАКАЗАТЕЛЬСТВА И ГРУППА теперь использует ограниченную память</target>
        </trans-unit>
        <trans-unit id="f9252c387c5a364e0aa75e161fd6ca4b31550d60" translate="yes" xml:space="preserve">
          <source>ORDER BY ignored if the query has an identical GROUP BY. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/b75a9ca6b0499&quot;&gt;b75a9ca6b0&lt;/a&gt;</source>
          <target state="translated">ORDER BY игнорируется, если запрос имеет идентичную GROUP BY. Билет &lt;a href=&quot;http://www.sqlite.org/src/info/b75a9ca6b0499&quot;&gt;b75a9ca6b0&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3d00407a3fb0d8ad7b8bcf4535e5d986d53520d0" translate="yes" xml:space="preserve">
          <source>ORDER BY works on subselects</source>
          <target state="translated">ЗАКАЗЫВАЙТЕ Работы по подгруппам</target>
        </trans-unit>
        <trans-unit id="fb1eb08d2d3f0a79b8449be8ce9ee77050e088a5" translate="yes" xml:space="preserve">
          <source>OS Interface</source>
          <target state="translated">интерфейс операционной системы</target>
        </trans-unit>
        <trans-unit id="7ea1a5ba1dffba576fe0a188bb466f1a65ef5c2d" translate="yes" xml:space="preserve">
          <source>OS Interface File Virtual Methods Object</source>
          <target state="translated">Файл интерфейса ОС Файл виртуальных методов Объект</target>
        </trans-unit>
        <trans-unit id="2fdd9f0dd04e20b2da0185c9864ac62e0fd49b33" translate="yes" xml:space="preserve">
          <source>OS Interface Object</source>
          <target state="translated">Объект интерфейса ОС</target>
        </trans-unit>
        <trans-unit id="e502b880ac4721322e02bb29b5215f15ab6c97e9" translate="yes" xml:space="preserve">
          <source>OS Interface Open File Handle</source>
          <target state="translated">Интерфейс ОС Открыть файловую ручку</target>
        </trans-unit>
        <trans-unit id="1bea0dbc1c9e6f1262f42405074e1a4e5f89e1c4" translate="yes" xml:space="preserve">
          <source>OSS Fuzz no longer finds historical bugs in SQLite. But it is still running and does occasionally find issues in new development check-ins. Examples: &lt;a href=&quot;https://www.sqlite.org/src/timeline?y=ci&amp;amp;c=c422afb507dc8757&quot;&gt;[1]&lt;/a&gt;&lt;a href=&quot;https://www.sqlite.org/src/timeline?y=ci&amp;amp;c=0a2eb949f8a759e5&quot;&gt;[2]&lt;/a&gt;&lt;a href=&quot;https://www.sqlite.org/src/timeline?y=ci&amp;amp;c=62f2235adf796c72&quot;&gt;[3]&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dee9889ad644e6e58468f0ff85f3a57aa76cfbd9" translate="yes" xml:space="preserve">
          <source>OTHERS</source>
          <target state="translated">OTHERS</target>
        </trans-unit>
        <trans-unit id="a032f6607e24aa99492871d19a553d714048e163" translate="yes" xml:space="preserve">
          <source>OUTER</source>
          <target state="translated">OUTER</target>
        </trans-unit>
        <trans-unit id="cc11826689203b888f22525a7551a5472c324526" translate="yes" xml:space="preserve">
          <source>OVER</source>
          <target state="translated">OVER</target>
        </trans-unit>
        <trans-unit id="829a2c0005fc7d37eb660c0d5cde206b5192f790" translate="yes" xml:space="preserve">
          <source>Obey in all things the commands of those whom God has placed in authority over you even though they (which God forbid) should act otherwise, mindful of the Lord's precept, &quot;Do what they say, but not what they do.&quot;</source>
          <target state="translated">Повинуйтесь во всем повелениям тех,кого Бог поставил над вами,даже если они (что Бог запрещает)должны поступать иначе,помня заповедь Господа:&quot;Делайте,что они говорят,а не то,что делают&quot;.</target>
        </trans-unit>
        <trans-unit id="a21a5206c75e38db5a2f38df79e6283758ee658a" translate="yes" xml:space="preserve">
          <source>Object-Oriented Design</source>
          <target state="translated">Объектно-ориентированный дизайн</target>
        </trans-unit>
        <trans-unit id="898a9f4f224c827df0fb00ecec65822c23a3936e" translate="yes" xml:space="preserve">
          <source>Object-Oriented is a design pattern, not a programming language. You can do object-oriented programming in any language you want, including assembly language. Some languages (ex: C++ or Java) make object-oriented easier. But you can still do object-oriented programming in languages like C.</source>
          <target state="translated">Объектно-ориентированный-это шаблон проектирования,а не язык программирования.Объектно-ориентированное программирование можно выполнять на любом языке,включая язык ассемблера.Некоторые языки (например,C++или Java)облегчают объектно-ориентированное программирование.Но вы все равно можете заниматься объектно-ориентированным программированием на таких языках,как Си.</target>
        </trans-unit>
        <trans-unit id="1e6159d8c90870c6430155592639731dac8033a3" translate="yes" xml:space="preserve">
          <source>Object-oriented is not the only valid design pattern. Many programmers have been taught to think purely in terms of objects. And, to be fair, objects are often a good way to decompose a problem. But objects are not the only way, and are not always the best way to decompose a problem. Sometimes good old procedural code is easier to write, easier to maintain and understand, and faster than object-oriented code.</source>
          <target state="translated">Объектно-ориентированный не единственный действительный образец конструкции.Многих программистов научили мыслить чисто в терминах объектов.И,справедливости ради,объекты часто являются хорошим способом разложения проблемы.Но объекты-это не единственный способ,и не всегда лучший способ разложить проблему.Иногда старый добрый процедурный код легче писать,легче поддерживать и понимать,и быстрее,чем объектно-ориентированный.</target>
        </trans-unit>
        <trans-unit id="ea838bb1557d80ce2bdbf51816fc7a1525503976" translate="yes" xml:space="preserve">
          <source>Objects:</source>
          <target state="translated">Objects:</target>
        </trans-unit>
        <trans-unit id="3a36347e6c9b66b32ae45cd886e8708db38d062b" translate="yes" xml:space="preserve">
          <source>Obscure bug fix on triggers (&lt;a href=&quot;http://www.sqlite.org/src/info/efc02f9779&quot;&gt;[efc02f9779]&lt;/a&gt;).</source>
          <target state="translated">Непонятное исправление ошибки триггеров ( &lt;a href=&quot;http://www.sqlite.org/src/info/efc02f9779&quot;&gt;[efc02f9779]&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="06705e47733fa2d26527ca5b13fe92c1b7ca1944" translate="yes" xml:space="preserve">
          <source>Obsolete Documents</source>
          <target state="translated">Устаревшие документы</target>
        </trans-unit>
        <trans-unit id="adcd55329b6153adb94eaf8a12d01ba2bc7cea95" translate="yes" xml:space="preserve">
          <source>Obtain A Composite Changeset From A Changegroup</source>
          <target state="translated">Получить композитный набор изменений из группы смены</target>
        </trans-unit>
        <trans-unit id="f036e380a093cadb7b7384e4b591b8c75c1ba145" translate="yes" xml:space="preserve">
          <source>Obtain Aggregate Function Context</source>
          <target state="translated">Получить контекст функции агрегата</target>
        </trans-unit>
        <trans-unit id="e79fb280b93973e6bfe3f8e79ba72b5b038ba1fa" translate="yes" xml:space="preserve">
          <source>Obtain Conflicting Row Values From A Changeset Iterator</source>
          <target state="translated">Получить противоречивые значения рядов от итератора изменений.</target>
        </trans-unit>
        <trans-unit id="d4c8c29e25fb3ccc649578fec3be2c67a658b123" translate="yes" xml:space="preserve">
          <source>Obtain The Current Operation From A Changeset Iterator</source>
          <target state="translated">Получить текущую операцию от итератора переменных параметров.</target>
        </trans-unit>
        <trans-unit id="7ada95f817f8fc624dbadc0c0f495b244a8d38b3" translate="yes" xml:space="preserve">
          <source>Obtain The Primary Key Definition Of A Table</source>
          <target state="translated">Получить определение первичного ключа таблицы А</target>
        </trans-unit>
        <trans-unit id="2f0f8596ef7c82c2d68f88fe0c2c42b22b20b24e" translate="yes" xml:space="preserve">
          <source>Obtain Values For URI Parameters</source>
          <target state="translated">Получить значения для параметров URI</target>
        </trans-unit>
        <trans-unit id="e719cf57b48331ec73c3d09816f240ac71d990d4" translate="yes" xml:space="preserve">
          <source>Obtain a PENDING lock and then an EXCLUSIVE lock on the database file. If other processes still have SHARED locks, the writer might have to wait until those SHARED locks clear before it is able to obtain an EXCLUSIVE lock.</source>
          <target state="translated">Получите блокировку PENDING,а затем EXCLUSIVE на файле базы данных.Если другие процессы все еще имеют блокировку SHARED,записывающему устройству,возможно,придется подождать,пока эти блокировки не будут сняты,прежде чем оно сможет получить ЭКСКЛЮЗИВНУЮ блокировку.</target>
        </trans-unit>
        <trans-unit id="c4c184719398e2fd529d288f83e902aa72fdd7b4" translate="yes" xml:space="preserve">
          <source>Obtain a buffer containing a changeset (or patchset) representing the current contents of the changegroup. If the inputs to the changegroup were themselves changesets, the output is a changeset. Or, if the inputs were patchsets, the output is also a patchset.</source>
          <target state="translated">Получить буфер,содержащий набор изменений (или патчсет),представляющий текущее содержимое группы изменений.Если входы в группу изменений были сами по себе changeset'ами,то на выходе будет changeset'ом.Или,если входы были патчсетами,выход также является патчсет.</target>
        </trans-unit>
        <trans-unit id="0ad736b5bee2570f5cbf619854f8b97d9b6134d1" translate="yes" xml:space="preserve">
          <source>Obtain a changeset containing changes to the tables attached to the session object passed as the first argument. If successful, set *ppChangeset to point to a buffer containing the changeset and *pnChangeset to the size of the changeset in bytes before returning SQLITE_OK. If an error occurs, set both *ppChangeset and *pnChangeset to zero and return an SQLite error code.</source>
          <target state="translated">Получить changeset,содержащий изменения в таблицах,прикрепленных к объекту сеанса,переданному в качестве первого аргумента.В случае успеха перед возвращением SQLITE_OK установите *ppChangeset в указатель на буфер,содержащий changeset,и *pnChangeset в размер changeset в байтах.В случае ошибки установите оба аргумента *ppChangeset и *pnChangeset в нулевое значение и верните код ошибки SQLite.</target>
        </trans-unit>
        <trans-unit id="4304c4d08f4f900e2ab1ec29540131e8bf87ae39" translate="yes" xml:space="preserve">
          <source>Obtain a lock on a particular table. This instruction is only used when the shared-cache feature is enabled.</source>
          <target state="translated">Получить замок на определенном столе.Эта инструкция используется только при включенной функции общего кэширования.</target>
        </trans-unit>
        <trans-unit id="35cc8c81bb0ab78babd3f65cb1b473a29bd69034" translate="yes" xml:space="preserve">
          <source>Obtain an EXCLUSIVE lock on the database file and make sure all memory changes have been written to the database file using the algorithm of steps 1-3 above.</source>
          <target state="translated">Получите ЭКСКЛЮЗИВНУЮ блокировку на файле БД и убедитесь,что все изменения в памяти записаны в файл БД по алгоритму,описанному выше в п.п.1-3.</target>
        </trans-unit>
        <trans-unit id="edc981514ab58076de28ce864d46ccc2641ec1d0" translate="yes" xml:space="preserve">
          <source>Obtain new.* Values From A Changeset Iterator</source>
          <target state="translated">Получите новые.Значения от итератора изменений.</target>
        </trans-unit>
        <trans-unit id="c31b9f4e355939157fe39f17fcb0e54282736c63" translate="yes" xml:space="preserve">
          <source>Obtain old.* Values From A Changeset Iterator</source>
          <target state="translated">Получите старое.*Ценности от итератора изменений.</target>
        </trans-unit>
        <trans-unit id="d399842fa2ae120f608cae0543637da5b44e2b8c" translate="yes" xml:space="preserve">
          <source>Obtain the latest SQLite code from fossil.</source>
          <target state="translated">Получите новейший код SQLite из ископаемых источников.</target>
        </trans-unit>
        <trans-unit id="9ed23644c9e9a46df1cd037be0519be726230e11" translate="yes" xml:space="preserve">
          <source>Obtaining SQL Values</source>
          <target state="translated">Получение значений SQL</target>
        </trans-unit>
        <trans-unit id="ffe740a4611067b4b4dd0b5b7a28183003203956" translate="yes" xml:space="preserve">
          <source>Obtaining the</source>
          <target state="translated">Получение</target>
        </trans-unit>
        <trans-unit id="a8fbf19c89308087d70d289986f946de344868c9" translate="yes" xml:space="preserve">
          <source>Obtains the mutex.</source>
          <target state="translated">Получает мьютекс.</target>
        </trans-unit>
        <trans-unit id="974debb0f023f79fb3eec2db47da68008b639181" translate="yes" xml:space="preserve">
          <source>Occasionally, a serious problem is found and a small &quot;patch&quot; release must be made against a regular maintenance release. Patch are distinct from maintenance releases in that the number of lines of code changed from the previous release is very small. Every effort is made to avoid patch releases by making sure that maintenance releases are bug free.</source>
          <target state="translated">Время от времени обнаруживается серьезная проблема,и необходимо сделать небольшую &quot;заплатку&quot; на регулярном техобслуживании.Патч отличается от релиза для обслуживания тем,что количество строк кода,измененных по сравнению с предыдущим релизом,очень мало.Прилагаются все усилия,чтобы избежать использования патчей,убедившись,что в релизах сопровождения нет ошибок.</target>
        </trans-unit>
        <trans-unit id="10b7fae72f94602297b15a7cf850a8e1ee7b4b31" translate="yes" xml:space="preserve">
          <source>Of course, ANALYZE only works effectively if you have a significant amount of content in your database in the first place. When creating a new database that you expect to accumulate a lot of data, you can run the command &quot;ANALYZE sqlite_master&quot; to create the SQLITE_STAT1 table, then prepopulate the SQLITE_STAT1 table (using ordinary INSERT statements) with content that describes a typical database for your application - perhaps content that you extracted after running ANALYZE on a well-populated template database in the lab.</source>
          <target state="translated">Конечно,ANALYZE работает эффективно только в том случае,если в Вашей базе данных имеется значительный объем контента.При создании новой БД,в которой вы ожидаете накопления большого количества данных,вы можете запустить команду &quot;ANALYZE sqlite_master&quot; для создания таблицы SQLITE_STAT1,а затем подготовить таблицу SQLITE_STAT1 (используя обычные операторы INSERT)с содержимым,описывающим типичную БД для вашего приложения-возможно,с содержимым,которое вы извлекли после запуска ANALYZE на хорошо заполненной шаблонной базе данных в лаборатории.</target>
        </trans-unit>
        <trans-unit id="3d4796f0a34c568634b9634297a83ac77168e0e1" translate="yes" xml:space="preserve">
          <source>Of course, ANALYZE only works effectively if you have a significant amount of content in your database in the first place. When creating a new database that you expect to accumulate a lot of data, you can run the command &quot;ANALYZE sqlite_schema&quot; to create the SQLITE_STAT1 table, then prepopulate the SQLITE_STAT1 table (using ordinary INSERT statements) with content that describes a typical database for your application - perhaps content that you extracted after running ANALYZE on a well-populated template database in the lab.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79c23fc170f4a6f6a03298037f6a0ed97740fe0f" translate="yes" xml:space="preserve">
          <source>Of course, an error may occur while attempting any of the 4 steps enumerated above. If this happens, then the</source>
          <target state="translated">Конечно,ошибка может произойти при попытке выполнить любой из 4 перечисленных выше шагов.Если это произойдет,то</target>
        </trans-unit>
        <trans-unit id="4144a21a0e5e7b5ef89db325c2463b409501b64d" translate="yes" xml:space="preserve">
          <source>Of course, an ordinary SQLite table will also do a query against its integer primary key efficiently, so the previous is no big deal. The real reason for using an R*Tree is so that you can efficiently do inequality queries against the coordinate ranges. To find all elements of the index that are contained within the vicinity of Charlotte, North Carolina, one might do:</source>
          <target state="translated">Конечно,обычная таблица SQLite также будет эффективно выполнять запрос к своему целочисленному первичному ключу,так что предыдущий-ничего страшного.Настоящая причина использования R*Tree заключается в том,что вы можете эффективно выполнять запросы неравенства по отношению к диапазонам координат.Найти все элементы индекса,которые содержатся в окрестностях Шарлотты,штат Северная Каролина,можно:</target>
        </trans-unit>
        <trans-unit id="ad9000f84241cbe168fcf9edea5a309a2f41cf64" translate="yes" xml:space="preserve">
          <source>Of course, it is also possible that it does exist following system recovery.</source>
          <target state="translated">Конечно,также возможно,что он существует и после восстановления системы.</target>
        </trans-unit>
        <trans-unit id="7a79fe7e88cf76ed8c1ab2e6617de9596ed474d8" translate="yes" xml:space="preserve">
          <source>Of course, it is usually not possible to atomically apply all the changes required by a</source>
          <target state="translated">Конечно,как правило,невозможно атоматически применить все изменения,необходимые для</target>
        </trans-unit>
        <trans-unit id="b8a4fe5b2fe5db1f855a348ab89c3de5aa545089" translate="yes" xml:space="preserve">
          <source>Of course, one wants to eventually transfer all the transactions that are appended in the WAL file back into the original database. Moving the WAL file transactions back into the database is called a &quot;</source>
          <target state="translated">Конечно же,хочется в конечном итоге перенести все транзакции,которые прилагаются к файлу WAL,обратно в исходную базу данных.Перемещение транзакций из файла WAL обратно в базу данных называется &quot;.</target>
        </trans-unit>
        <trans-unit id="a8d7cb464eb0b5300b1a2a71635654f684270965" translate="yes" xml:space="preserve">
          <source>Of course, ordering the output of a query by rowid is seldom useful. Usually one wants to order the output by some other column.</source>
          <target state="translated">Конечно,упорядочивание вывода запроса по rowid редко бывает полезным.Обычно хочется заказать вывод по какому-нибудь другому столбцу.</target>
        </trans-unit>
        <trans-unit id="178df5e8851c3ac34f7dcea098e85da7dbfe235b" translate="yes" xml:space="preserve">
          <source>Of course, substitute the desired index and imposter table names in place of the &quot;t1bc&quot; and &quot;t2&quot; shown in the example. The &quot;.imposter&quot; command reads the schema of the &quot;t1bc&quot; index, uses that information to construct a compatible CREATE TABLE statement for the imposter table, then makes all the necessary calls to create the transient imposter table automatically.</source>
          <target state="translated">Конечно же,вместо &quot;t1bc&quot; и &quot;t2&quot;,показанных в примере,подставьте нужные имена индексов и самозваных таблиц.Команда &quot;.imposter&quot; читает схему индекса &quot;t1bc&quot;,использует эту информацию для построения совместимого оператора CREATE TABLE для imposter-таблицы,затем автоматически делает все необходимые вызовы для создания переходной imposter-таблицы.</target>
        </trans-unit>
        <trans-unit id="116444cf2f220a0caf732f16ffb5a2f69fd9321c" translate="yes" xml:space="preserve">
          <source>Of course, the two queries above are not entirely equivalent. For example the LIKE query matches rows that contain terms such as &quot;linuxophobe&quot; or &quot;EnterpriseLinux&quot; (as it happens, the Enron E-Mail Dataset does not actually contain any such terms), whereas the MATCH query on the FTS3 table selects only those rows that contain &quot;linux&quot; as a discrete token. Both searches are case-insensitive. The FTS3 table consumes around 2006 MB on disk compared to just 1453 MB for the ordinary table. Using the same hardware configuration used to perform the SELECT queries above, the FTS3 table took just under 31 minutes to populate, versus 25 for the ordinary table.</source>
          <target state="translated">Конечно,два вышеприведенных вопроса не совсем эквивалентны.Например,запрос LIKE совпадает со строками,которые содержат такие термины,как &quot;linuxophobe&quot; или &quot;EnterpriseLinux&quot; (как это бывает,набор данных электронной почты Enron на самом деле не содержит таких терминов),в то время как MATCH-запрос на таблицу FTS3 выбирает только те строки,которые содержат &quot;linux&quot; в качестве дискретного токена.Оба поиска не чувствительны к регистру.Таблица FTS3 потребляет на диске около 2006 МБ по сравнению с 1453 МБ для обычной таблицы.Используя ту же самую аппаратную конфигурацию,которая использовалась для выполнения SELECT-запросов,описанных выше,таблица FTS3 заняла чуть менее 31 минуты,по сравнению с 25 для обычной таблицы.</target>
        </trans-unit>
        <trans-unit id="68b0ebb94fca52bc2076d132ead5c0f0cef17ce0" translate="yes" xml:space="preserve">
          <source>Of course, users would prefer code that is both robust in normal use and resistant to malicious attack. The SQLite developers are dedicated to providing that. The purpose of this section is merely to point out that doing both at the same time is hard.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6778acfecc08483f487870a27c4e0b19bb8701d" translate="yes" xml:space="preserve">
          <source>Of course, your mileage may vary depending on hardware, filesystem, and operating system. Double-check these figures on target hardware before committing to a particular design.</source>
          <target state="translated">Конечно,ваш пробег может варьироваться в зависимости от оборудования,файловой системы и операционной системы.Перепроверьте эти цифры на целевом аппаратном обеспечении перед тем,как совершить фиксацию на определенном дизайне.</target>
        </trans-unit>
        <trans-unit id="315230e941921effe51cc9ebfa05403b855f0476" translate="yes" xml:space="preserve">
          <source>Of these changes, only 1a and 2a through 2c are incompatibilities in any formal sense. But users who have previously made custom modifications to the SQLite source (for example to add a custom OS layer for embedded hardware) might find that these changes have a larger impact. On the other hand, an important goal of these changes is to make it much easier to customize SQLite for use on different operating systems.</source>
          <target state="translated">Из этих изменений только 1a и 2a-2c являются несовместимыми в любом формальном смысле.Но пользователи,которые ранее вносили пользовательские изменения в исходный текст SQLite (например,для добавления пользовательского уровня операционной системы для встроенного оборудования),могут обнаружить,что эти изменения оказывают большее влияние.С другой стороны,важной целью этих изменений является облегчение настройки SQLite для использования на различных операционных системах.</target>
        </trans-unit>
        <trans-unit id="e3de5ab0ca4c69dbf00e86d2558843e8d806bb49" translate="yes" xml:space="preserve">
          <source>Off</source>
          <target state="translated">Off</target>
        </trans-unit>
        <trans-unit id="ce667716547fa82bc8795ad7ef205e9410193ed0" translate="yes" xml:space="preserve">
          <source>Offset</source>
          <target state="translated">Offset</target>
        </trans-unit>
        <trans-unit id="58190317f4f075103c701ab1719a5146c7d71c8f" translate="yes" xml:space="preserve">
          <source>OffsetLimit</source>
          <target state="translated">OffsetLimit</target>
        </trans-unit>
        <trans-unit id="1ab3ac50fee719ce4797840a2df9f8c5ee707c03" translate="yes" xml:space="preserve">
          <source>Older versions of SQLite could not read a WAL-mode database that was read-only. In other words, write access was required in order to read a WAL-mode database. This constraint was relaxed beginning with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_22_0.html&quot;&gt;version 3.22.0&lt;/a&gt; (2018-01-22).</source>
          <target state="translated">Более старые версии SQLite не могли читать базу данных в режиме WAL, которая была доступна только для чтения. Другими словами, для чтения базы данных в режиме WAL требовался доступ на запись. Это ограничение было ослаблено, начиная с &lt;a href=&quot;https://sqlite.org/releaselog/3_22_0.html&quot;&gt;версии&lt;/a&gt; SQLite 3.22.0 (2018-01-22).</target>
        </trans-unit>
        <trans-unit id="28b3eeca1402aeadaf4db2bf8f6d2403ee957bf0" translate="yes" xml:space="preserve">
          <source>Older versions of firebird omits all NULLs from SELECT DISTINCT and from UNION.</source>
          <target state="translated">Старые версии firebird исключают все NULL из SELECT DISTINCT и UNION.</target>
        </trans-unit>
        <trans-unit id="8bfe5e60a5daf11fac21979e5a4fa9643a76bc3b" translate="yes" xml:space="preserve">
          <source>Omit all use of &quot;awk&quot; in the makefiles, to make building easier for MSVC users.</source>
          <target state="translated">Опустите все использование &quot;awk&quot; в makefiles,чтобы облегчить сборку для пользователей MSVC.</target>
        </trans-unit>
        <trans-unit id="bf4d0857bd27f59258be5d9b1e12776a9ff94992" translate="yes" xml:space="preserve">
          <source>Omitted parameters take on default values. STEP defaults to 1. END defaults to 9223372036854775807. START defaults to 0.</source>
          <target state="translated">Пропущенные параметры принимают значения по умолчанию.Шаг по умолчанию-1.Значения по умолчанию END-9223372036854775807.Значения по умолчанию для пуска-0.</target>
        </trans-unit>
        <trans-unit id="e0049a66519cae71159800bb77a35007bc2d76d3" translate="yes" xml:space="preserve">
          <source>On</source>
          <target state="translated">On</target>
        </trans-unit>
        <trans-unit id="0e46092ad025ac57fb1677f1d311680029cda2c1" translate="yes" xml:space="preserve">
          <source>On Android, we are told, there are many services that will blindly run arbitrary SQL that is passed to them by untrustworthy apps that have been downloaded from dodgy corners of the internet. Android services are suppose to be more guarded about running SQL from unvetted sources. This author does not have any specific examples to the contrary, but he has heard rumors that they exist. Even if all Android services are more careful and properly vet all the SQL they run, it would be difficult to audit them all in order to verify that they are safe. Hence, security-minded people are keen to ensure that no exploits are possible by passing arbitrary SQL text.</source>
          <target state="translated">На Android,как нам говорят,есть много сервисов,которые будут вслепую запускать произвольный SQL,который передается им ненадежными приложениями,которые были загружены из изворотливых уголков интернета.Предполагается,что сервисы Android будут более осторожны в запуске SQL из непроверенных источников.У этого автора нет конкретных примеров наоборот,но он слышал слухи о том,что они существуют.Даже если все службы Android будут более внимательны и правильно проверять все SQL,которые они запускают,будет сложно провести их аудит,чтобы убедиться,что они безопасны.Следовательно,люди,ориентированные на безопасность,стремятся к тому,чтобы гарантировать отсутствие эксплойтов путем передачи произвольного SQL-текста.</target>
        </trans-unit>
        <trans-unit id="26c3af907230190631617dbb8e5acb92e9854301" translate="yes" xml:space="preserve">
          <source>On Linux and other unix systems you will need to enter something like:</source>
          <target state="translated">На Linux и других unix-системах Вам нужно будет ввести что-то вроде:</target>
        </trans-unit>
        <trans-unit id="1273deeaf4de08300113723f337bae0ec716c243" translate="yes" xml:space="preserve">
          <source>On Win32, do not return an error when attempting to delete a file that does not exist.</source>
          <target state="translated">На Win32 не возвращайте ошибку при попытке удалить несуществующий файл.</target>
        </trans-unit>
        <trans-unit id="b2b2f36a4fafa25d031c2e6870c72d35c487959e" translate="yes" xml:space="preserve">
          <source>On Windows systems, folders are searched in the following order:</source>
          <target state="translated">В системах Windows поиск папок выполняется в следующем порядке:</target>
        </trans-unit>
        <trans-unit id="9d83a99bbbc3869a446954149b390c5195af03a3" translate="yes" xml:space="preserve">
          <source>On Windows with MSVC, use nmake with the Makefile.msc:</source>
          <target state="translated">На Windows с MSVC используйте nmake с Makefile.msc:</target>
        </trans-unit>
        <trans-unit id="e51bd18dd2b65a7e346c37ac44c1031b3f3942d7" translate="yes" xml:space="preserve">
          <source>On Windows, enter:</source>
          <target state="translated">На Windows,введите:</target>
        </trans-unit>
        <trans-unit id="aacb79e6ea038d7e3cda09880e0781239b1e3933" translate="yes" xml:space="preserve">
          <source>On a &lt;a href=&quot;wal#ckpt&quot;&gt;checkpoint&lt;/a&gt;, the WAL is first flushed to persistent storage using the xSync method of the &lt;a href=&quot;c3ref/io_methods&quot;&gt;VFS&lt;/a&gt;. Then valid content of the WAL is transferred into the database file. Finally, the database is flushed to persistent storage using another xSync method call. The xSync operations serve as write barriers - all writes launched before the xSync must complete before any write that launches after the xSync begins.</source>
          <target state="translated">На &lt;a href=&quot;wal#ckpt&quot;&gt;контрольной точке&lt;/a&gt; WAL сначала сбрасывается в постоянное хранилище с помощью метода xSync &lt;a href=&quot;c3ref/io_methods&quot;&gt;VFS&lt;/a&gt; . Затем действительное содержимое WAL переносится в файл базы данных. Наконец, база данных сбрасывается в постоянное хранилище с помощью другого вызова метода xSync. Операции xSync служат барьерами для записи - все записи, запущенные до xSync, должны завершиться до любой записи, которая запускается после начала xSync.</target>
        </trans-unit>
        <trans-unit id="ea7fd316bd0a1ed7abbfd63a2c9be9dcb14966c5" translate="yes" xml:space="preserve">
          <source>On a DISTINCT query that uses an index, try to skip ahead to the next distinct entry using the index rather than stepping through rows, when an appropriate index is available.</source>
          <target state="translated">В запросе DISTINCT,использующем индекс,попробуйте перейти к следующей отдельной записи,используя индекс,а не переходить по строкам,когда доступен соответствующий индекс.</target>
        </trans-unit>
        <trans-unit id="439b4340c2826997b9311dbcdfa182caed0bc968" translate="yes" xml:space="preserve">
          <source>On a traditional spinning disk, a sector is the minimum unit of transfer in both directions, both reading and writing. On flash memory, however, the minimum size of a read is typically much smaller than a minimum write. SQLite is only concerned with the minimum write amount and so for the purposes of this article, when we say &quot;sector&quot; we mean the minimum amount of data that can be written to mass storage in a single go.</source>
          <target state="translated">На традиционном прядильном диске сектор является минимальной единицей передачи в обоих направлениях,как при чтении,так и при записи.На флэш-памяти,однако,минимальный размер считываемого сектора обычно намного меньше минимального объема записи.SQLite заботится только о минимальном объеме записи,поэтому для целей данной статьи,когда мы говорим &quot;сектор&quot;,мы имеем в виду минимальный объем данных,который можно за один раз записать на массовое хранение.</target>
        </trans-unit>
        <trans-unit id="4d25766d7605da89f0dc45ce4758796da7aaedb1" translate="yes" xml:space="preserve">
          <source>On an &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;, if the ROWID or INTEGER PRIMARY KEY column is not explicitly given a value, then it will be filled automatically with an unused integer, usually one more than the largest ROWID currently in use. This is true regardless of whether or not the AUTOINCREMENT keyword is used.</source>
          <target state="translated">В &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; , если столбцу ROWID или INTEGER PRIMARY KEY явно не присвоено значение, он будет автоматически заполнен неиспользуемым целым числом, обычно на единицу больше, чем самый большой ROWID, используемый в настоящее время. Это верно независимо от того, используется ли ключевое слово AUTOINCREMENT.</target>
        </trans-unit>
        <trans-unit id="ebef8439735d14eb6033471fd2e7d318b20febc6" translate="yes" xml:space="preserve">
          <source>On an UPSERT when the order of constraint checks is rearranged, ensure that the affinity transformations on the inserted content occur before any of the constraint checks. Fix for ticket &lt;a href=&quot;https://www.sqlite.org/src/info/79cad5e4b2e219dd197242e9e&quot;&gt;79cad5e4b2e219dd197242e9e&lt;/a&gt;.</source>
          <target state="translated">В UPSERT, когда порядок проверок ограничений изменен, убедитесь, что преобразования сродства во вставленном содержимом происходят до любых проверок ограничений. Исправление для билета &lt;a href=&quot;https://www.sqlite.org/src/info/79cad5e4b2e219dd197242e9e&quot;&gt;79cad5e4b2e219dd197242e9e&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0a7e67fba14e6027ea80edde2148e2473e22f15f" translate="yes" xml:space="preserve">
          <source>On each call to undo::undo or undo::redo, the undo/redo module automatically invokes methods status_refresh and reload_all in all toplevel namespaces. These methods should be defined to reconstruct the display or otherwise update the state of the program based on the undone/redone changes to the database.</source>
          <target state="translated">При каждом вызове команды undo::undo или undo::redo модуль undo/redo автоматически вызывает методы status_refresh и reload_all во всех пространствах имен верхнего уровня.Эти методы должны быть определены,чтобы реконструировать отображение или иным образом обновить состояние программы на основании отмененных/восстановленных изменений в базе данных.</target>
        </trans-unit>
        <trans-unit id="51efe73d5459fecda0ebf237f9f8f384ca5daf31" translate="yes" xml:space="preserve">
          <source>On embedded systems with synchronous filesystems, TRUNCATE results in slower behavior than PERSIST. The commit operation is the same speed. But subsequent transactions are slower following a TRUNCATE because it is faster to overwrite existing content than to append to the end of a file. New journal file entries will always be appended following a TRUNCATE but will usually overwrite with PERSIST.</source>
          <target state="translated">На встраиваемых системах с синхронными файловыми системами TRUNCATE ведет себя медленнее,чем PERSIST.Операция фиксации происходит с той же скоростью.Но последующие транзакции после TRUNCATE выполняются медленнее,так как быстрее перезаписывать существующее содержимое,чем добавлять его в конец файла.Новые записи в файле журнала всегда будут добавляться после ТРУНКАТА,но обычно перезаписываются с помощью PERSIST.</target>
        </trans-unit>
        <trans-unit id="cff1aa0bee9c89492d085449129eae77e72bb5fa" translate="yes" xml:space="preserve">
          <source>On most systems, the malloc() system call returns a buffer that is aligned to an 8-byte boundary. But on some systems (ex: windows) malloc() returns 4-byte aligned pointer. This compile-time option must be used on systems that return 4-byte aligned pointers from malloc().</source>
          <target state="translated">На большинстве систем системный вызов malloc()возвращает буфер,который выровнен по границе 8 байт.Но на некоторых системах (ex:windows)malloc()возвращает указатель,выровненный по 4-байтной границе.Эта опция времени компиляции должна использоваться на системах,возвращающих указатели,выровненные по 4 байтам из malloc().</target>
        </trans-unit>
        <trans-unit id="87f5be0e7a33503458f9f1fc5e662122708d06fc" translate="yes" xml:space="preserve">
          <source>On newer versions of SQLite, a WAL-mode database on read-only media, or a WAL-mode database that lacks write permission, can still be read as long as one or more of the following conditions are met:</source>
          <target state="translated">На более новых версиях SQLite базу данных WAL-режима на носителе,доступном только для чтения,или базу данных WAL-режима,не имеющую разрешения на запись,можно читать до тех пор,пока выполняется одно или несколько из нижеперечисленных условий:</target>
        </trans-unit>
        <trans-unit id="0a3b32dd2c0c0446522505f738b73e43600ba9ad" translate="yes" xml:space="preserve">
          <source>On startup, the &lt;b&gt;sqlite3&lt;/b&gt; program will show a brief banner message then prompt you to enter SQL. Type in SQL statements (terminated by a semicolon), press &quot;Enter&quot; and the SQL will be executed.</source>
          <target state="translated">При запуске программа &lt;b&gt;sqlite3&lt;/b&gt; покажет краткое баннерное сообщение, а затем предложит вам ввести SQL. Введите операторы SQL (заканчивающиеся точкой с запятой), нажмите &amp;laquo;Enter&amp;raquo;, и SQL будет выполнен.</target>
        </trans-unit>
        <trans-unit id="a6133c9cbc7fd01002e1fd8f131c7ef4a48f7b82" translate="yes" xml:space="preserve">
          <source>On startup, the application first decides which version it wants to display. Since the versionId will naturally increase in time and one would normally want to see the latest version, an appropriate query might be:</source>
          <target state="translated">При запуске приложение сначала решает,какую версию оно хочет отобразить.Так как versionId будет естественным образом увеличиваться со временем,и человек обычно хочет видеть последнюю версию,то может быть сделан соответствующий запрос:</target>
        </trans-unit>
        <trans-unit id="d2a06dc722811f829dbda8827b08f5f0b5f36ae8" translate="yes" xml:space="preserve">
          <source>On success, &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; is returned and the new &lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB handle&lt;/a&gt; is stored in *ppBlob. Otherwise an &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; is returned and, unless the error code is SQLITE_MISUSE, *ppBlob is set to NULL. This means that, provided the API is not misused, it is always safe to call &lt;a href=&quot;#sqlite3_blob_close&quot;&gt;sqlite3_blob_close()&lt;/a&gt; on *ppBlob after this function it returns.</source>
          <target state="translated">В случае успеха &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;возвращается SQLITE_OK,&lt;/a&gt; а новый &lt;a href=&quot;#sqlite3_blob&quot;&gt;дескриптор&lt;/a&gt; большого двоичного объекта сохраняется в * ppBlob. В противном случае возвращается &lt;a href=&quot;rescode&quot;&gt;код ошибки&lt;/a&gt; и, если код ошибки не SQLITE_MISUSE, * ppBlob устанавливается в NULL. Это означает, что при условии, что API не используется неправильно, всегда безопасно вызывать &lt;a href=&quot;#sqlite3_blob_close&quot;&gt;sqlite3_blob_close ()&lt;/a&gt; для * ppBlob после того, как эта функция возвращает.</target>
        </trans-unit>
        <trans-unit id="749e0ca8bebcf0ea981a3b5d51013a9a74a29d29" translate="yes" xml:space="preserve">
          <source>On success, &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; is returned and the new &lt;a href=&quot;blob&quot;&gt;BLOB handle&lt;/a&gt; is stored in *ppBlob. Otherwise an &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; is returned and, unless the error code is SQLITE_MISUSE, *ppBlob is set to NULL. This means that, provided the API is not misused, it is always safe to call &lt;a href=&quot;blob_close&quot;&gt;sqlite3_blob_close()&lt;/a&gt; on *ppBlob after this function it returns.</source>
          <target state="translated">В случае успеха &lt;a href=&quot;../rescode#ok&quot;&gt;возвращается SQLITE_OK,&lt;/a&gt; а новый &lt;a href=&quot;blob&quot;&gt;дескриптор&lt;/a&gt; большого двоичного объекта сохраняется в * ppBlob. В противном случае возвращается &lt;a href=&quot;../rescode&quot;&gt;код ошибки&lt;/a&gt; и, если код ошибки не SQLITE_MISUSE, * ppBlob устанавливается в NULL. Это означает, что при условии, что API не используется неправильно, всегда безопасно вызывать &lt;a href=&quot;blob_close&quot;&gt;sqlite3_blob_close ()&lt;/a&gt; для * ppBlob после того, как эта функция возвращает.</target>
        </trans-unit>
        <trans-unit id="65eaebdd334ea618570d91e4458e0eb1b208375f" translate="yes" xml:space="preserve">
          <source>On success, &lt;b&gt;sqlite_compile&lt;/b&gt; returns SQLITE_OK. Otherwise and error code is returned.</source>
          <target state="translated">В случае успеха &lt;b&gt;sqlite_compile&lt;/b&gt; возвращает SQLITE_OK. В противном случае возвращается код ошибки.</target>
        </trans-unit>
        <trans-unit id="3e9b1d8e369d082b964c508c283e64eea1e0560c" translate="yes" xml:space="preserve">
          <source>On success, sqlite3_blob_read() returns SQLITE_OK. Otherwise, an &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; or an &lt;a href=&quot;../rescode#extrc&quot;&gt;extended error code&lt;/a&gt; is returned.</source>
          <target state="translated">В случае успеха sqlite3_blob_read () возвращает SQLITE_OK. В противном случае возвращается &lt;a href=&quot;../rescode&quot;&gt;код ошибки&lt;/a&gt; или &lt;a href=&quot;../rescode#extrc&quot;&gt;расширенный код ошибки&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e81bdc76837634caa6cec9a7812e38a822384af4" translate="yes" xml:space="preserve">
          <source>On success, sqlite3_blob_read() returns SQLITE_OK. Otherwise, an &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; or an &lt;a href=&quot;rescode#extrc&quot;&gt;extended error code&lt;/a&gt; is returned.</source>
          <target state="translated">В случае успеха sqlite3_blob_read () возвращает SQLITE_OK. В противном случае возвращается &lt;a href=&quot;rescode&quot;&gt;код ошибки&lt;/a&gt; или &lt;a href=&quot;rescode#extrc&quot;&gt;расширенный код ошибки&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="00223380eeb8684c87e10d42630c25143e83fb7d" translate="yes" xml:space="preserve">
          <source>On success, sqlite3_blob_write() returns SQLITE_OK. Otherwise, an &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; or an &lt;a href=&quot;../rescode#extrc&quot;&gt;extended error code&lt;/a&gt; is returned. Unless SQLITE_MISUSE is returned, this function sets the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; error code and message accessible via &lt;a href=&quot;errcode&quot;&gt;sqlite3_errcode()&lt;/a&gt; and &lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg()&lt;/a&gt; and related functions.</source>
          <target state="translated">В случае успеха sqlite3_blob_write () возвращает SQLITE_OK. В противном случае возвращается &lt;a href=&quot;../rescode&quot;&gt;код ошибки&lt;/a&gt; или &lt;a href=&quot;../rescode#extrc&quot;&gt;расширенный код ошибки&lt;/a&gt; . Если не возвращается SQLITE_MISUSE, эта функция устанавливает код ошибки &lt;a href=&quot;sqlite3&quot;&gt;подключения&lt;/a&gt; к базе данных и сообщение, доступное через &lt;a href=&quot;errcode&quot;&gt;sqlite3_errcode ()&lt;/a&gt; и &lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg ()&lt;/a&gt; и связанные с ними функции.</target>
        </trans-unit>
        <trans-unit id="e1d8319a0f054e12945ffdcd496271dbacaf81a2" translate="yes" xml:space="preserve">
          <source>On success, sqlite3_blob_write() returns SQLITE_OK. Otherwise, an &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; or an &lt;a href=&quot;rescode#extrc&quot;&gt;extended error code&lt;/a&gt; is returned. Unless SQLITE_MISUSE is returned, this function sets the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; error code and message accessible via &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errcode()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errmsg()&lt;/a&gt; and related functions.</source>
          <target state="translated">В случае успеха sqlite3_blob_write () возвращает SQLITE_OK. В противном случае возвращается &lt;a href=&quot;rescode&quot;&gt;код ошибки&lt;/a&gt; или &lt;a href=&quot;rescode#extrc&quot;&gt;расширенный код ошибки&lt;/a&gt; . Если не возвращается SQLITE_MISUSE, эта функция устанавливает код ошибки &lt;a href=&quot;#sqlite3&quot;&gt;подключения&lt;/a&gt; к базе данных и сообщение, доступное через &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errcode ()&lt;/a&gt; и &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errmsg ()&lt;/a&gt; и связанные с ними функции.</target>
        </trans-unit>
        <trans-unit id="8609e89a9e3f181cc9bf01d1a6238ab2d0959ed4" translate="yes" xml:space="preserve">
          <source>On success, the sqlite3_prepare() family of routines return &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt;; otherwise an &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; is returned.</source>
          <target state="translated">В случае успеха семейство подпрограмм sqlite3_prepare () вернет &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; ; в противном случае возвращается &lt;a href=&quot;rescode&quot;&gt;код ошибки&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3e16251e40927c67fe655d2518e028082c6fa9b3" translate="yes" xml:space="preserve">
          <source>On success, the sqlite3_prepare() family of routines return &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;; otherwise an &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; is returned.</source>
          <target state="translated">В случае успеха семейство подпрограмм sqlite3_prepare () вернет &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; ; в противном случае возвращается &lt;a href=&quot;../rescode&quot;&gt;код ошибки&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="79e4255a03a365ba20cd0884b8ee349e3d935179" translate="yes" xml:space="preserve">
          <source>On the Mac, you can set this pragma:</source>
          <target state="translated">На Маке ты можешь установить эту прагму:</target>
        </trans-unit>
        <trans-unit id="69a450284be9205b76c2e066c35f545c5c025beb" translate="yes" xml:space="preserve">
          <source>On the other hand, a database engine that uses a server can provide better protection from bugs in the client application - stray pointers in a client cannot corrupt memory on the server. And because a server is a single persistent process, it is able control database access with more precision, allowing for finer grain locking and better concurrency.</source>
          <target state="translated">С другой стороны,движок базы данных,использующий сервер,может обеспечить лучшую защиту от ошибок в клиентском приложении-блуждающие указатели в клиенте не могут повредить память на сервере.А поскольку сервер представляет собой единый постоянный процесс,он способен с большей точностью контролировать доступ к базе данных,позволяя более тонкую блокировку зерна и лучшее совпадение.</target>
        </trans-unit>
        <trans-unit id="84736c128a35123ea022380e6a3900484bf1a802" translate="yes" xml:space="preserve">
          <source>On the other hand, a database engine that uses a server can provide better protection from bugs in the client application - stray pointers in a client cannot corrupt memory on the server. And because a server is a single persistent process, it is able to control database access with more precision, allowing for finer-grained locking and better concurrency.</source>
          <target state="translated">С другой стороны,движок базы данных,использующий сервер,может обеспечить лучшую защиту от ошибок в клиентском приложении-блуждающие указатели в клиенте не могут повредить память на сервере.А поскольку сервер представляет собой единый постоянный процесс,он способен с большей точностью контролировать доступ к базе данных,позволяя более точную блокировку и лучшее совпадение.</target>
        </trans-unit>
        <trans-unit id="71cbc82c664fd1caf1a677d0c65b18293805a90f" translate="yes" xml:space="preserve">
          <source>On the other hand, an RBU Vacuum uses more CPU than a regular SQLite VACUUM - in one test as much as five times as much. For this reason, an RBU Vacuum is often significantly slower than an SQLite VACUUM under the same conditions.</source>
          <target state="translated">С другой стороны,RBU Vacuum использует больше CPU,чем обычный SQLite VACUUM-в одном тесте в пять раз больше.По этой причине,вакуум RBU часто значительно медленнее,чем SQLite VACUUM при тех же условиях.</target>
        </trans-unit>
        <trans-unit id="2ec9b50cf6f067a94359ec578926c021dba81fa8" translate="yes" xml:space="preserve">
          <source>On the other hand, dropping tables is not a very common operation so if SQLite takes a little longer, that is not seen as a big problem.</source>
          <target state="translated">С другой стороны,выпадающие таблицы-не очень распространенная операция,поэтому если SQLite занимает немного больше времени,то это не рассматривается как большая проблема.</target>
        </trans-unit>
        <trans-unit id="b75edbc4ccb51b3a0effc26ec943821968d21e88" translate="yes" xml:space="preserve">
          <source>On the other hand, if the result of the subquery must be scanned multiple times (because, for example, it is just one table in a join) then it is better to use a transient table to remember the entire result of the subquery, in order to avoid computing the subquery more than once.</source>
          <target state="translated">С другой стороны,если результат подзапроса должен быть отсканирован несколько раз (потому что,например,это всего лишь одна таблица в соединении),то лучше использовать переходную таблицу,чтобы запомнить весь результат подзапроса,чтобы избежать вычисления подзапроса более одного раза.</target>
        </trans-unit>
        <trans-unit id="4cb26bb6bd2845585001f514df8ac5e23d3a9784" translate="yes" xml:space="preserve">
          <source>On the other hand, read performance deteriorates as the WAL file grows in size since each reader must check the WAL file for the content and the time needed to check the WAL file is proportional to the size of the WAL file. The wal-index helps find content in the WAL file much faster, but performance still falls off with increasing WAL file size. Hence, to maintain good read performance it is important to keep the WAL file size down by running checkpoints at regular intervals.</source>
          <target state="translated">С другой стороны,производительность чтения ухудшается по мере роста размера файла WAL,поскольку каждый читатель должен проверять файл WAL на содержание,а время,необходимое для проверки файла WAL,пропорционально размеру файла WAL.Индекс wal-index помогает находить содержимое в файле WAL гораздо быстрее,но производительность все равно снижается с увеличением размера файла WAL.Следовательно,для поддержания хорошей производительности чтения важно уменьшить размер файла WAL за счет регулярного выполнения контрольных точек через определенные промежутки времени.</target>
        </trans-unit>
        <trans-unit id="9a0c49cb1cedb27f90f5b843b5321b6c2675c041" translate="yes" xml:space="preserve">
          <source>On the stack display, most entries are shown with a prefix that tells the datatype of that stack entry. Integers begin with &quot;&lt;code&gt;i:&lt;/code&gt;&quot;. Floating point values begin with &quot;&lt;code&gt;r:&lt;/code&gt;&quot;. (The &quot;r&quot; stands for &quot;real-number&quot;.) Strings begin with either &quot;&lt;code&gt;s:&lt;/code&gt;&quot;, &quot;&lt;code&gt;t:&lt;/code&gt;&quot;, &quot;&lt;code&gt;e:&lt;/code&gt;&quot; or &quot;&lt;code&gt;z:&lt;/code&gt;&quot;. The difference among the string prefixes is caused by how their memory is allocated. The z: strings are stored in memory obtained from &lt;b&gt;malloc()&lt;/b&gt;. The t: strings are statically allocated. The e: strings are ephemeral. All other strings have the s: prefix. This doesn't make any difference to you, the observer, but it is vitally important to the VDBE since the z: strings need to be passed to &lt;b&gt;free()&lt;/b&gt; when they are popped to avoid a memory leak. Note that only the first 10 characters of string values are displayed and that binary values (such as the result of the MakeRecord instruction) are treated as strings. The only other datatype that can be stored on the VDBE stack is a NULL, which is display without prefix as simply &quot;&lt;code&gt;NULL&lt;/code&gt;&quot;. If an integer has been placed on the stack as both an integer and a string, its prefix is &quot;&lt;code&gt;si:&lt;/code&gt;&quot;.</source>
          <target state="translated">На дисплее стека большинство записей отображается с префиксом, который указывает тип данных этой записи стека. Целые числа начинаются с &amp;laquo; &lt;code&gt;i:&lt;/code&gt; &amp;raquo;. Значения с плавающей запятой начинаются с &amp;laquo; &lt;code&gt;r:&lt;/code&gt; &amp;raquo;. (&amp;laquo;R&amp;raquo; означает &amp;laquo;действительное число&amp;raquo;.) Строки начинаются с &amp;laquo; &lt;code&gt;s:&lt;/code&gt; &amp;raquo;, &amp;laquo; &lt;code&gt;t:&lt;/code&gt; &amp;raquo;, &amp;laquo; &lt;code&gt;e:&lt;/code&gt; &amp;raquo; или &amp;laquo; &lt;code&gt;z:&lt;/code&gt; &amp;raquo;. Разница между строковыми префиксами обусловлена ​​тем, как распределяется их память. Строки z: хранятся в памяти, полученной из &lt;b&gt;malloc ()&lt;/b&gt; . Строки t: размещаются статически. Струны e: эфемерны. Все остальные строки имеют префикс s :. Это не имеет значения для вас, наблюдатель,но это жизненно важно для VDBE, поскольку строки z: должны передаваться в&lt;b&gt;free (),&lt;/b&gt; когда они появляются, чтобы избежать утечки памяти. Обратите внимание, что отображаются только первые 10 символов строковых значений и что двоичные значения (например, результат инструкции MakeRecord) обрабатываются как строки. Единственный другой тип данных, который может храниться в стеке VDBE, - это NULL, который отображается без префикса просто как &amp;laquo; &lt;code&gt;NULL&lt;/code&gt; &amp;raquo;. Если целое число было помещено в стек и как целое число, и как строка, его префикс - &amp;laquo; &lt;code&gt;si:&lt;/code&gt; &amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="e3336bd71adcf37ccf53527f3a1cc4855eac8894" translate="yes" xml:space="preserve">
          <source>On unix systems (or on Windows using cygwin or mingw+msys) the command typically looks something like this:</source>
          <target state="translated">На unix-системах (или в Windows с помощью cygwin или mingw+msys)команда обычно выглядит примерно так:</target>
        </trans-unit>
        <trans-unit id="287d1cbba1056569ceaf042e45ed9558181651a7" translate="yes" xml:space="preserve">
          <source>On unix, if a symlink to a database file is opened, then the corresponding journal files are based on the actual filename, not the symlink name.</source>
          <target state="translated">В unix,если открыта системная ссылка на файл базы данных,то соответствующие файлы журнала основываются на фактическом имени файла,а не на имени системной ссылки.</target>
        </trans-unit>
        <trans-unit id="6c70d0e29a89e83eef274cc81c5528ba689d997c" translate="yes" xml:space="preserve">
          <source>On unix-like systems, directories are searched in the following order:</source>
          <target state="translated">На unix-подобных системах поиск по каталогам осуществляется в следующем порядке:</target>
        </trans-unit>
        <trans-unit id="db7db60b91e81d2d39614db0d3144dc3caa85aa5" translate="yes" xml:space="preserve">
          <source>On windows only, convert all &quot;&lt;code&gt;\&lt;/code&gt;&quot; characters into &quot;&lt;code&gt;/&lt;/code&gt;&quot;.</source>
          <target state="translated">Только в Windows: конвертируйте все символы &amp;laquo; &lt;code&gt;\&lt;/code&gt; &amp;raquo; в &amp;laquo; &lt;code&gt;/&lt;/code&gt; &amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="aa996bed689bb081c327fe76624367885c13654f" translate="yes" xml:space="preserve">
          <source>On windows only, if the filename begins with a drive letter, prepend a single &quot;&lt;code&gt;/&lt;/code&gt;&quot; character.</source>
          <target state="translated">Только в Windows: если имя файла начинается с буквы диска, добавьте перед ним один символ &amp;laquo; &lt;code&gt;/&lt;/code&gt; &amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="d9c768782ea8653d485fb3b7f5aba21cb2ca7bf3" translate="yes" xml:space="preserve">
          <source>Once</source>
          <target state="translated">Once</target>
        </trans-unit>
        <trans-unit id="87f26aaf5f6994f877b899775d955216fa5722f5" translate="yes" xml:space="preserve">
          <source>Once a</source>
          <target state="translated">Один раз</target>
        </trans-unit>
        <trans-unit id="8464198c181050b3c7b7af3b57436c91d71a13de" translate="yes" xml:space="preserve">
          <source>Once a VFS has been registered, it should never be modified. If a change in behavior is required, a new VFS should be registered. The application could, perhaps, use &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_find()&lt;/a&gt; to locate the old VFS, make a copy of the old VFS into a new &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object, make the desired modifications to the new VFS, unregister the old VFS, then register the new VFS in its place. Existing database connections would continue to use the old VFS even after it is unregistered, but new database connections would use the new VFS.</source>
          <target state="translated">После регистрации VFS не следует изменять ее. Если требуется изменение поведения, необходимо зарегистрировать новую VFS. Приложение, возможно, могло бы использовать &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_find (),&lt;/a&gt; чтобы найти старую VFS, сделать копию старой VFS в новый объект &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; , внести желаемые изменения в новую VFS, отменить регистрацию старой VFS, а затем зарегистрировать новую VFS в ее место. Существующие соединения с базой данных будут продолжать использовать старую VFS даже после отмены регистрации, но новые соединения с базой данных будут использовать новую VFS.</target>
        </trans-unit>
        <trans-unit id="55b2eace4f6d572184649196769be324d9ec08aa" translate="yes" xml:space="preserve">
          <source>Once a connection obtains a table lock, it is not released until the current transaction (read or write) is concluded.</source>
          <target state="translated">Как только соединение получает блокировку таблицы,оно не освобождается до тех пор,пока не будет заключена текущая транзакция (чтение или запись).</target>
        </trans-unit>
        <trans-unit id="5e4e9f1432dcf3c9b2a4412dec01ffd3ea3a631b" translate="yes" xml:space="preserve">
          <source>Once a process obtains an exclusive lock, it is permitted to write to the database file. It then proceeds to read the original content of pages out of the rollback journal and write that content back to where it came from in the database file. Recall that the header of the rollback journal records the original size of the database file prior to the start of the aborted transaction. SQLite uses this information to truncate the database file back to its original size in cases where the incomplete transaction caused the database to grow. At the end of this step, the database should be the same size and contain the same information as it did before the start of the aborted transaction.</source>
          <target state="translated">Как только процесс получает эксклюзивный замок,разрешается запись в файл базы данных.Затем он переходит к чтению исходного содержимого страниц из журнала отката и записывает это содержимое обратно в файл базы данных,откуда оно пришло.Вспомните,что заголовок журнала отката записывает исходный размер файла базы данных до начала прерванной транзакции.SQLite использует эту информацию для усечения файла базы данных до исходного размера в тех случаях,когда неполная транзакция привела к росту базы данных.В конце этого шага БД должна быть того же размера и содержать ту же информацию,что и до начала прерванной транзакции.</target>
        </trans-unit>
        <trans-unit id="b42ea281b3fc7c07c016d5e3f2cf18291c599ca4" translate="yes" xml:space="preserve">
          <source>Once a table has been attached to a session object, the session object records the primary key values of all new rows inserted into the table. It also records the original primary key and other column values of any deleted or updated rows. For each unique primary key value, data is only recorded once - the first time a row with said primary key is inserted, updated or deleted in the lifetime of the session.</source>
          <target state="translated">После прикрепления таблицы к объекту сеанса,объект сеанса записывает первичные ключевые значения всех новых строк,вставленных в таблицу.Он также записывает исходный первичный ключ и другие значения столбцов любых удаленных или обновленных строк.Для каждого уникального значения первичного ключа данные записываются только один раз-это первый раз,когда строка с указанным первичным ключом вставляется,обновляется или удаляется в течение всего сеанса.</target>
        </trans-unit>
        <trans-unit id="9c0b7ad6ff995bbd9fed309a9d73615d47bfa0e5" translate="yes" xml:space="preserve">
          <source>Once a transaction has been opened, reading data from a database connection is a simple operation. Using the xRead() method of the file-handle open on the database file, the required database file pages are read one at a time. SQLite never reads partial pages and always uses a single call to xRead() for each required page.</source>
          <target state="translated">После открытия транзакции чтение данных из соединения с базой данных является простой операцией.С помощью метода xRead()файл-ручка,открытая на файле базы данных,считываются по очереди страницы требуемого файла базы данных.SQLite никогда не читает частичные страницы и всегда использует один вызов xRead()для каждой требуемой страницы.</target>
        </trans-unit>
        <trans-unit id="511dc23c3f8ad619f86fc49e5ac60cacc5f4cbfc" translate="yes" xml:space="preserve">
          <source>Once a virtual table has been created, it can be used like any other table with the exceptions noted above and imposed by specific virtual table implementations. A virtual table is destroyed using the ordinary &lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt; syntax.</source>
          <target state="translated">После создания виртуальной таблицы ее можно использовать как любую другую таблицу с исключениями, указанными выше и налагаемыми конкретными реализациями виртуальной таблицы. Виртуальная таблица уничтожается с использованием обычного синтаксиса &lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c3f695a7b377f8d655c6f7bd1deb78c481aa015e" translate="yes" xml:space="preserve">
          <source>Once again, practical implementations will likely subclass this structure to add additional private fields.</source>
          <target state="translated">Опять же,практические реализации,скорее всего,подразделят эту структуру на подклассы для добавления дополнительных приватных полей.</target>
        </trans-unit>
        <trans-unit id="44317a76e0c4f1b6b3d16db84fa92562885dc8a9" translate="yes" xml:space="preserve">
          <source>Once again, the SQL statements generate identical bytecode and thus do exactly the same job in exactly the same way. But the second form is made easier for humans to read by grouping the query parameters together into a single row value rather than scattering them across the WHERE clause.</source>
          <target state="translated">И снова SQL операторы генерируют идентичный байткод и таким образом делают точно такую же работу.Но вторую форму человеку проще прочитать,сгруппировав параметры запроса в одну строку,а не рассеивая их по пункту WHERE.</target>
        </trans-unit>
        <trans-unit id="d645ca4d6b0e5bfa41d1d0e06bb9cd91ff636156" translate="yes" xml:space="preserve">
          <source>Once all rollback journal files have been flushed to disk, it is safe to begin updating database files. We have to obtain an exclusive lock on all database files before writing the changes. After all the changes are written, it is important to flush the changes to disk so that they will be preserved in the event of a power failure or operating system crash.</source>
          <target state="translated">После того,как все файлы журналов отката будут записаны на диск,можно приступать к обновлению файлов базы данных.Перед записью изменений мы должны получить эксклюзивную блокировку всех файлов базы данных.После того,как все изменения записаны,важно промыть их на диск,чтобы они были сохранены в случае отключения питания или сбоя операционной системы.</target>
        </trans-unit>
        <trans-unit id="73fcb528effe6301ec78591adf7629a8ed98b913" translate="yes" xml:space="preserve">
          <source>Once an SQLite database is open, it can be controlled using methods of the</source>
          <target state="translated">После того,как база данных SQLite открыта,ею можно управлять с помощью метода</target>
        </trans-unit>
        <trans-unit id="1676ac6920d27f0701cc052fe7ff5982a44cea9d" translate="yes" xml:space="preserve">
          <source>Once an encoding has been set for a database, it cannot be changed.</source>
          <target state="translated">После установки кодировки для базы данных она не может быть изменена.</target>
        </trans-unit>
        <trans-unit id="1f61d0c0dc743205cfd592b973902a4df3bd2139" translate="yes" xml:space="preserve">
          <source>Once an exclusive lock is held, we know that no other processes are reading from the database file and it is safe to write changes into the database file. Usually those changes only go as far as the operating systems disk cache and do not make it all the way to mass storage.</source>
          <target state="translated">После того,как эксклюзивный замок снят,мы знаем,что никакие другие процессы не читают из файла базы данных,и можно безопасно записать изменения в файл базы данных.Обычно эти изменения заходят только в кэш диска операционной системы и не попадают в массовое хранилище.</target>
        </trans-unit>
        <trans-unit id="8d6da848ac7743477288c842a221e398489c8a06" translate="yes" xml:space="preserve">
          <source>Once any conversions have taken place, and neither value is NULL, the values are compared. If both values are blobs then memcmp() is used to determine the results of the comparison. If both values are text, then the appropriate collating function specified in P4 is used to do the comparison. If P4 is not specified then memcmp() is used to compare text string. If both values are numeric, then a numeric comparison is used. If the two values are of different types, then numbers are considered less than strings and strings are considered less than blobs.</source>
          <target state="translated">После любых преобразований,ни одно из которых не является NULL,значения сравниваются.Если оба значения являются блоками,то для определения результатов сравнения используется функция memcmp().Если оба значения являются текстовыми,то для проведения сравнения используется соответствующая функция сравнения,указанная в P4.Если P4 не указана,то для сравнения текстовой строки используется функция memcmp().Если оба значения являются числовыми,то для сравнения используется числовая функция.Если оба значения разного типа,то числа считаются меньше,чем строки,а строки считаются меньше,чем капли.</target>
        </trans-unit>
        <trans-unit id="4b170c45b3f098d917697616ac86ca3f213bd255" translate="yes" xml:space="preserve">
          <source>Once everything is ready, run the &quot;&lt;code&gt;fossil commit&lt;/code&gt;&quot; command to check in the changes. This creates circle (4) in the diagram above.</source>
          <target state="translated">Когда все будет готово, запустите команду &quot; &lt;code&gt;fossil commit&lt;/code&gt; &quot;, чтобы проверить изменения. Это создает круг (4) на схеме выше.</target>
        </trans-unit>
        <trans-unit id="89efbd20c0a9cf3f9851965660941121b8a57cbc" translate="yes" xml:space="preserve">
          <source>Once one is comfortable with the concept of storing each slide separately, it is a small step to support versioning of the presentation. Consider the following schema:</source>
          <target state="translated">После того,как вы уживаетесь с концепцией хранения каждого слайда в отдельности,это небольшой шаг для поддержки версионирования презентации.Рассмотрим следующую схему:</target>
        </trans-unit>
        <trans-unit id="05be8dd08c1c90f1df285706af044dc836d0d98a" translate="yes" xml:space="preserve">
          <source>Once populated, there are three ways to execute a full-text query against the contents of an FTS5 table:</source>
          <target state="translated">После заполнения существует три способа выполнения полнотекстового запроса к содержимому таблицы FTS5:</target>
        </trans-unit>
        <trans-unit id="e7dc51406db9bf51bbe6620c6512b34c3f0e8f5e" translate="yes" xml:space="preserve">
          <source>Once the dirty page being purged is writable, it is simply written into the database file.</source>
          <target state="translated">После того,как очищаемая грязная страница может быть записана,она просто записывается в файл базы данных.</target>
        </trans-unit>
        <trans-unit id="821430ef05c1ab204de759a3df24102ae4261d90" translate="yes" xml:space="preserve">
          <source>Once the input data from the FROM clause has been filtered by the WHERE clause expression (if any), the set of result rows for the simple SELECT are calculated. Exactly how this is done depends on whether the simple SELECT is an aggregate or non-aggregate query, and whether or not a GROUP BY clause was specified.</source>
          <target state="translated">После того,как входные данные из выражения FROM отфильтрованы выражением WHERE (если таковое имеется),вычисляется набор строк результата для простого SELECT.Точность этого зависит от того,является ли простой SELECT агрегированным или неагрегированным запросом и была ли указана оговорка GROUP BY или нет.</target>
        </trans-unit>
        <trans-unit id="79336569e93b2e9d0a83cc5e0a929d5ce48d2824" translate="yes" xml:space="preserve">
          <source>Once the project repository is created, create an open checkout of the project by moving to the directory where you want to keep all of the project source code and typing:</source>
          <target state="translated">После того,как репозиторий проекта создан,создайте открытую проверку проекта,перейдя в каталог,в котором вы хотите сохранить весь исходный код проекта и набрав его:</target>
        </trans-unit>
        <trans-unit id="c4e9c9ce3f592c90096798d4d198a8b0474086e9" translate="yes" xml:space="preserve">
          <source>Once the spellfix1 extension is loaded, an instance of the spellfix1 virtual table is created like this:</source>
          <target state="translated">После загрузки расширения spellfix1 создаётся экземпляр виртуальной таблицы spellfix1 таким образом:</target>
        </trans-unit>
        <trans-unit id="8513b43854c13df7657753be614db748baf13f7a" translate="yes" xml:space="preserve">
          <source>Once the test program is generated, it is run with no arguments to perform the tests. Progress information as well as error diagnostics appear on standard output. (Alternative output arrangements can be made using a compile-time option for embedded devices that lack a standard output channel.) The program returns zero if there are no errors and non-zero if any problems were detected.</source>
          <target state="translated">После того,как тестовая программа сгенерирована,она запускается без аргументов для выполнения тестов.Информация о ходе выполнения,а также диагностика ошибок появляется на стандартном выходе.(Для встраиваемых устройств,не имеющих стандартного выходного канала,можно использовать опцию &quot;время компиляции&quot;).Программа возвращает ноль при отсутствии ошибок и ненулевой при обнаружении проблем.</target>
        </trans-unit>
        <trans-unit id="bd0d76b14cf548de7ba347b074f1a4d3fbd73686" translate="yes" xml:space="preserve">
          <source>Once the virtual table is created, it can be queried as follows:</source>
          <target state="translated">После создания виртуальной таблицы ее можно запросить следующим образом:</target>
        </trans-unit>
        <trans-unit id="1f76d0dc14ccffaabe0506021b655e9b2d8e3d76" translate="yes" xml:space="preserve">
          <source>Once you locate a specific version, click on the hyperlink for that version to see the &quot;Check-in Information Page&quot;. Then click on either the &quot;Tarball&quot; link or the &quot;ZIP archive&quot; link to download the complete source tree.</source>
          <target state="translated">Как только вы найдете конкретную версию,нажмите на гиперссылку для этой версии,чтобы увидеть &quot;Страницу информации о регистрации&quot;.Затем нажмите либо на ссылку &quot;Tarball&quot;,либо на ссылку &quot;ZIP-архив&quot;,чтобы загрузить полное дерево исходных текстов.</target>
        </trans-unit>
        <trans-unit id="5d89aa77c530c282e22378ce0f5d708e01a8b4fb" translate="yes" xml:space="preserve">
          <source>One approach to this query is to use the fruit='Orange' term of the WHERE clause to find all rows dealing with oranges, then filter those rows by rejecting any that are from states other than California. This process is shown by &lt;a href=&quot;#fig7&quot;&gt;figure 7&lt;/a&gt; above. This is a perfectly reasonable approach in most cases. Yes, the database engine did have to do an extra binary search for the Florida orange row that was later rejected, so it was not as efficient as we might hope, though for many applications it is efficient enough.</source>
          <target state="translated">Один из подходов к этому запросу - использовать термин fruit = 'Orange' в предложении WHERE, чтобы найти все строки, относящиеся к апельсинам, а затем отфильтровать эти строки, отклоняя любые из штатов, отличных от Калифорнии. Этот процесс показан на &lt;a href=&quot;#fig7&quot;&gt;рисунке 7&lt;/a&gt; выше. В большинстве случаев это совершенно разумный подход. Да, движку базы данных действительно пришлось выполнить дополнительный двоичный поиск оранжевой строки Флориды, который позже был отклонен, поэтому он оказался не таким эффективным, как мы могли бы надеяться, хотя для многих приложений он достаточно эффективен.</target>
        </trans-unit>
        <trans-unit id="83e48e323326e14265bd89807dc478da45112a98" translate="yes" xml:space="preserve">
          <source>One can also provide comma-separated arguments to the module following the module name:</source>
          <target state="translated">Можно также предоставлять аргументы,разделенные запятыми,модулю,следующему за именем модуля:</target>
        </trans-unit>
        <trans-unit id="c99a07ebdfa971a90b20da9b4561b5f49cd6023c" translate="yes" xml:space="preserve">
          <source>One can also set the &lt;a href=&quot;cli&quot;&gt;CLI&lt;/a&gt; into automatic EXPLAIN QUERY PLAN mode using the &quot;.eqp on&quot; command:</source>
          <target state="translated">Также можно установить &lt;a href=&quot;cli&quot;&gt;CLI&lt;/a&gt; в автоматический режим EXPLAIN QUERY PLAN с помощью команды &quot;.eqp on&quot;:</target>
        </trans-unit>
        <trans-unit id="efbb187108974c009f143234a98d6989ff9c9ac6" translate="yes" xml:space="preserve">
          <source>One can also think of savepoints as &quot;marks&quot; in the transaction timeline. In this view, the SAVEPOINT command creates a new mark, the ROLLBACK TO command rewinds the timeline back to a point just after the named mark, and the RELEASE command erases marks from the timeline without actually making any changes to the database.</source>
          <target state="translated">Можно также думать о точках сохранения как о &quot;метках&quot; в графике транзакций.В этом представлении команда SAVEPOINT создает новую метку,команда ROLLBACK TO перематывает временную шкалу обратно в точку,расположенную сразу после именованной метки,а команда RELEASE стирает метки с временной шкалы,не внося никаких изменений в базу данных.</target>
        </trans-unit>
        <trans-unit id="3d55d95e5af6d3d744fa5a934dc2cc27683084a3" translate="yes" xml:space="preserve">
          <source>One can explicitly change out of WAL mode using a pragma such as this:</source>
          <target state="translated">Можно явно выйти из режима WAL,используя такую прагму:</target>
        </trans-unit>
        <trans-unit id="5812082b2084545c8ed5d26ce266777d4a58efe5" translate="yes" xml:space="preserve">
          <source>One can see how the OR-by-UNION technique could also be leveraged to use multiple indices on queries where the WHERE clause has terms connected by AND, by using an intersect operator in place of union. Many SQL database engines will do just that. But the performance gain over using just a single index is slight and so SQLite does not implement that technique at this time. However, a future version SQLite might be enhanced to support AND-by-INTERSECT.</source>
          <target state="translated">Можно увидеть,как можно использовать технику &quot;по ОРИ&quot; для использования нескольких индексов на запросах,где в пункте &quot;Где&quot; есть термины,связанные с И&quot;,с помощью оператора пересечения вместо объединения.Многие движки баз данных SQL сделают именно это.Но прирост производительности по сравнению с использованием только одного индекса невелик,и поэтому SQLite в настоящее время не реализует эту технику.Тем не менее,будущая версия SQLite может быть усовершенствована для поддержки AND-by-INTERSECT.</target>
        </trans-unit>
        <trans-unit id="18266c8f1da4ccb3784663f1422488207a89b45d" translate="yes" xml:space="preserve">
          <source>One cannot create a trigger on a virtual table.</source>
          <target state="translated">Нельзя создать триггер на виртуальном столе.</target>
        </trans-unit>
        <trans-unit id="08c14fea12c1a91b86b4eb3020bc8d201daa13d9" translate="yes" xml:space="preserve">
          <source>One cannot create additional indices on a virtual table. (Virtual tables can have indices but that must be built into the virtual table implementation. Indices cannot be added separately using &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt; statements.)</source>
          <target state="translated">На виртуальной таблице нельзя создать дополнительные индексы. (Виртуальные таблицы могут иметь индексы, но они должны быть встроены в реализацию виртуальной таблицы. Индексы нельзя добавлять отдельно с помощью операторов &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt; .)</target>
        </trans-unit>
        <trans-unit id="d3b50c178c087fb42ad06f0aba999c85b1ef895b" translate="yes" xml:space="preserve">
          <source>One cannot easily view, change, or extract the content of an OpenDocument presentation using generic tools. The only reasonable way to view or edit an OpenDocument document is to open it up using an application that is specifically designed to read or write OpenDocument (read: LibreOffice or one of its cousins). The situation could be worse. One can extract and view individual images (say) from a presentation using just the &quot;zip&quot; archiver tool. But it is not reasonable try to extract the text from a slide. Remember that all content is stored in a single &quot;context.xml&quot; file. That file is XML, so it is a text file. But it is not a text file that can be managed with an ordinary text editor. For the example presentation above, the content.xml file consist of exactly two lines. The first line of the file is just:</source>
          <target state="translated">Невозможно легко просмотреть,изменить или извлечь содержимое презентации OpenDocument с помощью общих инструментов.Единственный разумный способ просмотра или редактирования документа OpenDocument-это открыть его с помощью приложения,специально разработанного для чтения или написания OpenDocument (читать:LibreOffice или один из его двоюродных братьев).Ситуация может быть хуже.Можно извлекать и просматривать отдельные изображения (скажем)из презентации с помощью простого инструмента архиватора &quot;zip&quot;.Но пытаться извлечь текст из слайда нецелесообразно.Помните,что все содержимое хранится в одном файле &quot;context.xml&quot;.Этот файл является XML,то есть текстовым.Но это не текстовый файл,которым можно управлять с помощью обычного текстового редактора.Для вышеприведенного примера представления,файл content.xml состоит ровно из двух строк.Первая строка файла просто:</target>
        </trans-unit>
        <trans-unit id="8b60832325e280604faf68cf7c5149fd06825525" translate="yes" xml:space="preserve">
          <source>One cannot run &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE ... ADD COLUMN&lt;/a&gt; commands against a virtual table.</source>
          <target state="translated">Невозможно выполнить команды &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE ... ADD COLUMN&lt;/a&gt; для виртуальной таблицы.</target>
        </trans-unit>
        <trans-unit id="8229271a498b58a8b73749061ba175879d5bffff" translate="yes" xml:space="preserve">
          <source>One difference between Next and ListRead is their idea of a &quot;thing&quot;. The &quot;things&quot; for the Next instruction are records in a database file. &quot;Things&quot; for ListRead are integer keys in a list. Another difference is whether to jump or fall through if there is no next &quot;thing&quot;. In this case, Next falls through, and ListRead jumps. Later on, we will see other looping instructions (NextIdx and SortNext) that operate using the same principle.</source>
          <target state="translated">Одно из различий между Next и ListRead заключается в их представлении о &quot;вещи&quot;.Вещи&quot; для команды Next-это записи в файле базы данных.&quot;Вещи&quot; для ListRead-это целочисленные ключи в списке.Другое отличие-прыгать или проваливаться,если следующего &quot;вещи&quot; нет.В этом случае Next выпадает,а ListRead прыгает.Позже мы увидим другие инструкции по прыжкам (NextIdx и SortNext),которые работают по тому же принципу.</target>
        </trans-unit>
        <trans-unit id="0e2add845dd3757fedbc712aca0fdd2b6ebca768" translate="yes" xml:space="preserve">
          <source>One example of this occurred circa 2013-08-30 on the canonical repository for the &lt;a href=&quot;http://www.fossil-scm.org/&quot;&gt;Fossil DVCS&lt;/a&gt;. In that event, file descriptor 2 (standard error) was being erroneously closed (by &lt;a href=&quot;http://www.stunnel.org/&quot;&gt;stunnel&lt;/a&gt;, we suspect) prior to &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; so that the file descriptor used for the repository database file was 2. Later, an application bug caused an assert() statement to emit an error message by invoking write(2,...). But since file descriptor 2 was now connected to a database file, the error message overwrote part of the database. To guard against this kind of problem, SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_1.html&quot;&gt;version 3.8.1&lt;/a&gt; (2013-10-17) and later refuse to use low-numbered file descriptors for database files. (See &lt;a href=&quot;compile#minimum_file_descriptor&quot;&gt;SQLITE_MINIMUM_FILE_DESCRIPTOR&lt;/a&gt; for additional information.)</source>
          <target state="translated">Один из примеров этого произошел примерно 30 августа 2013 г. в каноническом репозитории &lt;a href=&quot;http://www.fossil-scm.org/&quot;&gt;Fossil DVCS&lt;/a&gt; . В этом случае файловый дескриптор 2 (стандартная ошибка) был ошибочно закрыт ( мы подозреваем, &lt;a href=&quot;http://www.stunnel.org/&quot;&gt;stunnel&lt;/a&gt; ) до &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2 (),&lt;/a&gt; так что файловый дескриптор, используемый для файла базы данных репозитория, был 2. Позже ошибка приложения вызвала assert ( ), чтобы выдать сообщение об ошибке, вызвав write (2, ...). Но поскольку файловый дескриптор 2 теперь был подключен к файлу базы данных, сообщение об ошибке перезаписало часть базы данных. Чтобы защититься от такого рода проблем, SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_1.html&quot;&gt;версии 3.8.1&lt;/a&gt; (2013-10-17) и более поздних версий отказываются использовать файловые дескрипторы с малыми номерами для файлов базы данных. (См. &lt;a href=&quot;compile#minimum_file_descriptor&quot;&gt;SQLITE_MINIMUM_FILE_DESCRIPTOR&lt;/a&gt; для дополнительной информации.)</target>
        </trans-unit>
        <trans-unit id="f155185b09ba1b186403646b80d41d02e18f29b2" translate="yes" xml:space="preserve">
          <source>One exception to the typelessness of SQLite is a column whose type is INTEGER PRIMARY KEY. (And you must use &quot;INTEGER&quot; not &quot;INT&quot;. A column of type INT PRIMARY KEY is typeless just like any other.) INTEGER PRIMARY KEY columns must contain a 32-bit signed integer. Any attempt to insert non-integer data will result in an error.</source>
          <target state="translated">Одним из исключений безпечатности SQLite является столбец,тип которого-INTEGER PRIMARY KEY.(И вы должны использовать &quot;INTEGER&quot;,а не &quot;INT&quot;.Столбец типа INT PRIMARY KEY является безпечатным,как и любой другой).Столбец типа INTEGER PRIMARY KEY должен содержать 32-битное знаковое целое число.Любая попытка вставить нецифровые данные приведет к ошибке.</target>
        </trans-unit>
        <trans-unit id="c476dc0c19b1ad151c922c972d11950866ac1040" translate="yes" xml:space="preserve">
          <source>One fuzzing researcher of particular note is &lt;a href=&quot;https://www.manuelrigger.at/&quot;&gt;Manuel Rigger&lt;/a&gt;, currently (as this paragraph is written on 2019-12-21) at &lt;a href=&quot;https://ethz.ch/en.html&quot;&gt;ETH Zurich&lt;/a&gt;. Most fuzzers only look for assertion faults, crashes, undefined behavior (UB), or other easily detected anomalies. Dr. Rigger's fuzzers, on the other hand, are able to find cases where SQLite computes an incorrect answer. Rigger has found &lt;a href=&quot;https://www.sqlite.org/src/timeline?y=t&amp;amp;u=mrigger&amp;amp;n=all&quot;&gt;many such cases&lt;/a&gt;. Most of these finds are fairly obscure corner cases involving type conversions and affinity transformations, and a good number of the finds are against unreleased features. Nevertheless, his finds are still important as they are real bugs, and the SQLite developers are grateful to be able to identify and fix the underlying problems. Rigger's work is currently unpublished. When it is released, it could be as influential as Zalewski's invention of AFL and profile-guided fuzzing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6bf8910e6414d0165fef0d30b0886bc0f8d4329" translate="yes" xml:space="preserve">
          <source>One implication of the above is that if a change is made and then unmade within a single session (for example if a row is inserted and then deleted again), the sessions module does not report any change at all. Or if a row is updated multiple times within the same session, all updates are coalesced into a single update within any changeset or patchset blob.</source>
          <target state="translated">Одно из последствий вышесказанного заключается в том,что если в течение одного сеанса (например,если вставляется строка,а затем снова удаляется)происходит изменение,то модуль сеансов вообще не сообщает об этом изменении.Или если строка обновляется несколько раз в течение одного сеанса,все обновления объединяются в одно обновление в любом changeset или patchset блоке.</target>
        </trans-unit>
        <trans-unit id="fc9f38831587103a404686b12cd389ecfbf1fe12" translate="yes" xml:space="preserve">
          <source>One might argue that it is ok, in this era of multi-gigabyte desktops, to read the entire document into memory. But it is not ok. For one, the amount of memory used far exceeds the (compressed) file size on disk. So a 50MB presentation might take 200MB or more RAM. That still is not a problem if one only edits a single document at a time. But when working on a talk, this author will typically have 10 or 15 different presentations up all at the same time (to facilitate copy/paste of slides from past presentation) and so gigabytes of memory are required. Add in an open web browser or two and a few other desktop apps, and suddenly the disk is whirling and the machine is swapping. And even having just a single document is a problem when working on an inexpensive Chromebook retrofitted with Ubuntu. Using less memory is always better.</source>
          <target state="translated">Можно поспорить,что в эту эпоху многогигабайтных рабочих столов нормально читать весь документ в память.Но это не нормально.Во-первых,объем используемой памяти намного превышает (сжатый)размер файла на диске.Так что для презентации на 50 МБ может потребоваться 200 МБ и более оперативной памяти.Это все равно не проблема,если редактировать только один документ за раз.Но при работе над докладом этот автор,как правило,имеет 10 или 15 различных презентаций одновременно (для облегчения копирования/вставки слайдов из прошлой презентации),поэтому требуется гигабайт памяти.Добавьте в открытый веб-браузер или два и несколько других настольных приложений,и вдруг диск закрутится,и машина поменяется местами.И даже иметь только один документ является проблемой при работе на недорогой Chromebook,модернизированный с Ubuntu.Использование меньшего количества памяти всегда лучше.</target>
        </trans-unit>
        <trans-unit id="f44cc341ba0d29ec39fe1d9113cc5db69afebdc7" translate="yes" xml:space="preserve">
          <source>One might want to provide other &lt;a href=&quot;compile&quot;&gt;compile-time options&lt;/a&gt; such as &lt;a href=&quot;compile#enable_fts4&quot;&gt;-DSQLITE_ENABLE_FTS4&lt;/a&gt; or &lt;a href=&quot;compile#enable_fts5&quot;&gt;-DSQLITE_ENABLE_FTS5&lt;/a&gt; for full-text search, &lt;a href=&quot;compile#enable_rtree&quot;&gt;-DSQLITE_ENABLE_RTREE&lt;/a&gt; for the R*Tree search engine extension, &lt;a href=&quot;compile#enable_json1&quot;&gt;-DSQLITE_ENABLE_JSON1&lt;/a&gt; to include &lt;a href=&quot;json1&quot;&gt;JSON SQL functions&lt;/a&gt;, or &lt;a href=&quot;compile#enable_dbstat_vtab&quot;&gt;-DSQLITE_ENABLE_DBSTAT_VTAB&lt;/a&gt; for the &lt;a href=&quot;dbstat&quot;&gt;dbstat virtual table&lt;/a&gt;. In order to see extra commentary in &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt; listings, add the &lt;a href=&quot;compile#enable_explain_comments&quot;&gt;-DSQLITE_ENABLE_EXPLAIN_COMMENTS&lt;/a&gt; option. On unix systems, add -DHAVE_USLEEP=1 if the host machine supports the usleep() system call. Add -DHAVE_READLINE and the -lreadline and -lncurses libraries to get command-line editing support. One might also want to specify some compiler optimization switches. (The precompiled CLI available for download from the SQLite website uses &quot;-Os&quot;.) There are countless possible variations here. A command to compile a full-featured shell might look something like this:</source>
          <target state="translated">Можно было бы хотеть , чтобы обеспечить другие &lt;a href=&quot;compile&quot;&gt;параметры компиляции&lt;/a&gt; , такие как &lt;a href=&quot;compile#enable_fts4&quot;&gt;-DSQLITE_ENABLE_FTS4&lt;/a&gt; или &lt;a href=&quot;compile#enable_fts5&quot;&gt;-DSQLITE_ENABLE_FTS5&lt;/a&gt; для полнотекстового поиска, &lt;a href=&quot;compile#enable_rtree&quot;&gt;-DSQLITE_ENABLE_RTREE&lt;/a&gt; для расширения поисковой системы R * Tree, &lt;a href=&quot;compile#enable_json1&quot;&gt;-DSQLITE_ENABLE_JSON1&lt;/a&gt; включать &lt;a href=&quot;json1&quot;&gt;функции JSON SQL&lt;/a&gt; или &lt;a href=&quot;compile#enable_dbstat_vtab&quot;&gt;-DSQLITE_ENABLE_DBSTAT_VTAB&lt;/a&gt; для &lt;a href=&quot;dbstat&quot;&gt;dbstat виртуальной таблицы&lt;/a&gt; . Чтобы увидеть дополнительные комментарии в списках &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt; , добавьте &lt;a href=&quot;compile#enable_explain_comments&quot;&gt;-DSQLITE_ENABLE_EXPLAIN_COMMENTS&lt;/a&gt;вариант. В системах unix добавьте -DHAVE_USLEEP = 1, если хост-машина поддерживает системный вызов usleep (). Добавьте -DHAVE_READLINE и библиотеки -lreadline и -lncurses, чтобы получить поддержку редактирования командной строки. Можно также указать некоторые переключатели оптимизации компилятора. (В предварительно скомпилированном интерфейсе командной строки, доступном для загрузки с веб-сайта SQLite, используется &amp;laquo;-O&amp;raquo;.) Здесь существует бесчисленное множество возможных вариантов. Команда для компиляции полнофункциональной оболочки может выглядеть примерно так:</target>
        </trans-unit>
        <trans-unit id="6a02d032d7380123e8a5e72e863e1054c5bd48cb" translate="yes" xml:space="preserve">
          <source>One minor downside of splitting content into smaller pieces is that compression does not work as well on shorter texts and so the size of the document might increase. But as the bulk of the document space is used to store images, a small reduction in the compression efficiency of the text content will hardly be noticeable, and is a small price to pay for an improved user experience.</source>
          <target state="translated">Один незначительный недостаток разделения содержания на более мелкие части заключается в том,что сжатие не работает так же хорошо на более короткие тексты,и поэтому размер документа может увеличиться.Но так как большая часть документального пространства используется для хранения изображений,небольшое снижение эффективности сжатия текстового содержимого вряд ли будет заметно,и это небольшая цена,которую нужно заплатить за улучшенный пользовательский опыт.</target>
        </trans-unit>
        <trans-unit id="b297ff44d76535e06e20e05a05458aba9a18af0a" translate="yes" xml:space="preserve">
          <source>One of the 10 decimal digit ASCII characters, or</source>
          <target state="translated">Один из 10 десятичных ASCII-символов или</target>
        </trans-unit>
        <trans-unit id="67403b0cb5390fcf0c705699aeb495a2edb6d96b" translate="yes" xml:space="preserve">
          <source>One of the 52 upper and lower case ASCII characters, or</source>
          <target state="translated">Один из 52 символов ASCII в верхнем и нижнем регистре,или</target>
        </trans-unit>
        <trans-unit id="cff101187bdbe5720613db95b3564ea1057f17a1" translate="yes" xml:space="preserve">
          <source>One of the &lt;a href=&quot;different&quot;&gt;distinctive features&lt;/a&gt; of SQLite is that a database consists of a single disk file. This simplifies the use of SQLite since moving or backing up a database is a simple as copying a single file. It also makes SQLite appropriate for use as an &lt;a href=&quot;whentouse#appfileformat&quot;&gt;application file format&lt;/a&gt;. But while a complete database is held in a single disk file, SQLite does make use of many temporary files during the course of processing a database.</source>
          <target state="translated">Одна из &lt;a href=&quot;different&quot;&gt;отличительных особенностей&lt;/a&gt; SQLite заключается в том, что база данных состоит из одного файла на диске. Это упрощает использование SQLite, поскольку перемещение или резервное копирование базы данных выполняется так же, как копирование одного файла. Это также делает SQLite подходящим для использования в качестве &lt;a href=&quot;whentouse#appfileformat&quot;&gt;формата файла приложения&lt;/a&gt; . Но хотя полная база данных хранится в одном файле на диске, SQLite действительно использует множество временных файлов в процессе обработки базы данных.</target>
        </trans-unit>
        <trans-unit id="e5c91de459561e96de8f3e9e77eaa61509cd18a7" translate="yes" xml:space="preserve">
          <source>One of the ALL or DISTINCT keywords may follow the SELECT keyword in a simple SELECT statement. If the simple SELECT is a SELECT ALL, then the entire set of result rows are returned by the SELECT. If neither ALL or DISTINCT are present, then the behavior is as if ALL were specified. If the simple SELECT is a SELECT DISTINCT, then duplicate rows are removed from the set of result rows before it is returned. For the purposes of detecting duplicate rows, two NULL values are considered to be equal. The &lt;a href=&quot;datatype3#colrules&quot;&gt;usual rules&lt;/a&gt; apply for selecting a collation sequence to compare text values.</source>
          <target state="translated">Одно из ключевых слов ALL или DISTINCT может следовать за ключевым словом SELECT в простой инструкции SELECT. Если простой SELECT - это SELECT ALL, тогда весь набор строк результатов возвращается SELECT. Если ни ALL, ни DISTINCT не присутствуют, поведение будет таким, как если бы было указано ALL. Если простой SELECT - это SELECT DISTINCT, то повторяющиеся строки удаляются из набора строк результата перед его возвратом. В целях обнаружения повторяющихся строк два значения NULL считаются равными. Для выбора последовательности сопоставления для сравнения текстовых значений применяются &lt;a href=&quot;datatype3#colrules&quot;&gt;обычные правила&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="148ba6e1c7e039de60e4599c768cf9921948e4c8" translate="yes" xml:space="preserve">
          <source>One of the advantages of hosting code generator tools as part of the project is that the tools can be optimized to serve specific needs of the overall project. Lemon has benefited from this effect. Over the years, the Lemon parser generator has been extended and enhanced to provide new capabilities and improved performance to SQLite. A few of the specific enhancements to Lemon that are specifically designed for use by SQLite include:</source>
          <target state="translated">Одним из преимуществ хостинга инструментов генератора кода как части проекта является то,что эти инструменты могут быть оптимизированы для удовлетворения специфических потребностей всего проекта в целом.Лемон извлекла выгоду из этого эффекта.С годами генератор парсера Lemon был расширен и усовершенствован для обеспечения новых возможностей и повышения производительности SQLite.Некоторые из специфических усовершенствований Lemon,которые специально разработаны для использования в SQLite,включают в себя:</target>
        </trans-unit>
        <trans-unit id="66a50c77336f3c9a6df53cb2e7363aee5a52fbbd" translate="yes" xml:space="preserve">
          <source>One of the interesting features of the VFS interface is that SQLite can support multiple VFSes at the same time. Each &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; has to choose a single VFS for its use when the connection is first opened using &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;. But if a process contains multiple &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt; each can choose a different VFS. VFSes can be added at run-time using the &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register()&lt;/a&gt; interface.</source>
          <target state="translated">Одна из интересных особенностей интерфейса VFS заключается в том, что SQLite может одновременно поддерживать несколько VFS. Каждое &lt;a href=&quot;c3ref/sqlite3&quot;&gt;соединение с базой данных&lt;/a&gt; должно выбрать одну VFS для использования при первом открытии соединения с помощью &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2 ()&lt;/a&gt; . Но если процесс содержит несколько &lt;a href=&quot;c3ref/sqlite3&quot;&gt;соединений с базой данных,&lt;/a&gt; каждый может выбрать другую VFS. VFS можно добавить во время выполнения с помощью интерфейса &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f1c2a440e7d12be65f7ff95454bfa77307c4b02e" translate="yes" xml:space="preserve">
          <source>One of the many reports that Fossil makes available is a timeline of changes to a single branch showing all merges in and out of that branch. See &lt;a href=&quot;http://www.sqlite.org/src/timeline?nd&amp;amp;n=200&amp;amp;r=trunk&quot;&gt;http://www.sqlite.org/src/timeline?nd&amp;amp;n=200&amp;amp;r=trunk&lt;/a&gt; for a typical example of such a report. Generating such a report normally takes just a few milliseconds. But after upgrading to the NGQP we noticed that this one report was taking closer to 10 seconds for the trunk of the repository.</source>
          <target state="translated">Один из многих отчетов, которые предоставляет Fossil, - это временная шкала изменений в одной ветке, показывающая все слияния внутри и вне этой ветви. См. &lt;a href=&quot;http://www.sqlite.org/src/timeline?nd&amp;amp;n=200&amp;amp;r=trunk&quot;&gt;Http://www.sqlite.org/src/timeline?nd&amp;amp;n=200&amp;amp;r=trunk&lt;/a&gt; для получения типичного примера такого отчета. Создание такого отчета обычно занимает всего несколько миллисекунд. Но после обновления до NGQP мы заметили, что этот отчет занимал около 10 секунд для магистрали репозитория.</target>
        </trans-unit>
        <trans-unit id="16f929fd09cef7d1acb11b165614f8e6f651a35f" translate="yes" xml:space="preserve">
          <source>One of the things that SQLite does to ensure that transactions are atomic across system crashes and power failures is to write all changes into the rollback journal file prior to changing the database. The TCL test harness contains an alternative &lt;a href=&quot;vfs&quot;&gt;OS backend&lt;/a&gt; implementation that helps to verify this is occurring correctly. The &quot;journal-test VFS&quot; monitors all disk I/O traffic between the database file and rollback journal, checking to make sure that nothing is written into the database file which has not first been written and synced to the rollback journal. If any discrepancies are found, an assertion fault is raised.</source>
          <target state="translated">Одна из вещей, которые SQLite делает для обеспечения атомарности транзакций при сбоях системы и сбоях питания, - это записывать все изменения в файл журнала отката до изменения базы данных. Пакет тестирования TCL содержит альтернативную &lt;a href=&quot;vfs&quot;&gt;внутреннюю&lt;/a&gt; реализацию ОС, которая помогает проверить, что это происходит правильно. VFS &quot;journal-test&quot; отслеживает весь дисковый трафик ввода-вывода между файлом базы данных и журналом отката, проверяя, что в файл базы данных не записано ничего, что не было предварительно записано и синхронизировано с журналом отката. Если обнаруживаются какие-либо несоответствия, возникает ошибка утверждения.</target>
        </trans-unit>
        <trans-unit id="8702bf42f5b52e2937e5261eb8fe5e53cb025817" translate="yes" xml:space="preserve">
          <source>One or more indexes of the table are currently unanalyzed &lt;em&gt;or&lt;/em&gt; the number of rows in the table has increased by 25 times or more since the last time ANALYZE was run.</source>
          <target state="translated">Один или несколько индексов таблицы в настоящее время не проанализированы, &lt;em&gt;или&lt;/em&gt; количество строк в таблице увеличилось в 25 или более раз с момента последнего запуска ANALYZE.</target>
        </trans-unit>
        <trans-unit id="c07477cd0e5dcf04189629377d839b6d5b58ba89" translate="yes" xml:space="preserve">
          <source>One or more transactions must have been written to the current wal file since it was created on disk (by any connection). This means that a snapshot cannot be taken on a wal mode database with no wal file immediately after it is first opened. At least one transaction must be written to it first.</source>
          <target state="translated">Одна или более транзакций должны были быть записаны в текущий wal-файл с момента его создания на диске (по любому соединению).Это означает,что снимки не могут быть сделаны в базе данных в режиме wal,где нет ни одного wal-файла сразу после его первого открытия.Сначала в нее должна быть записана хотя бы одна транзакция.</target>
        </trans-unit>
        <trans-unit id="b839504f0d97f30339eb42940d7178a50aed3e9b" translate="yes" xml:space="preserve">
          <source>One solution is to add an SQL foreign key constraint to the database schema to enforce the relationship between the</source>
          <target state="translated">Одним из решений является добавление ограничения по внешнему ключу SQL в схему базы данных,чтобы усилить связь между</target>
        </trans-unit>
        <trans-unit id="9e9e9e6d05419e1f1b802f612d5f17adfe32fb1a" translate="yes" xml:space="preserve">
          <source>One solution to this problem is to change SQLite to do an exhaustive search for the best path. But an exhaustive search requires time proportional to K! (where K is the number of tables in the join) and so when you get beyond a 10-way join, the time to run &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; becomes very large.</source>
          <target state="translated">Одним из решений этой проблемы является изменение SQLite для выполнения исчерпывающего поиска наилучшего пути. Но для полного перебора требуется время, пропорциональное K! (где K - количество таблиц в объединении), поэтому, когда вы выйдете за пределы 10-стороннего соединения, время выполнения &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare ()&lt;/a&gt; станет очень большим.</target>
        </trans-unit>
        <trans-unit id="3ea27e906845c470414940dc542a3a724c62dba9" translate="yes" xml:space="preserve">
          <source>One technique for avoiding a full table scan is to do lookups by rowid (or by the equivalent &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;). To lookup the price of peaches, one would query for the entry with a rowid of 4:</source>
          <target state="translated">Один из способов избежать полного сканирования таблицы - выполнить поиск по идентификатору строки (или эквивалентному &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; ). Чтобы узнать цену персиков, нужно запросить запись с идентификатором строки 4:</target>
        </trans-unit>
        <trans-unit id="9d59b48161b2263d40d4491d1bb939a7b7f92e6e" translate="yes" xml:space="preserve">
          <source>One user of both Git and Fossil &lt;a href=&quot;https://news.ycombinator.com/item?id=16806955&quot;&gt;writes in HN&lt;/a&gt;:</source>
          <target state="translated">Один пользователь как Git, так и Fossil &lt;a href=&quot;https://news.ycombinator.com/item?id=16806955&quot;&gt;пишет на HN&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="75f64ba853c8246c4f074dd74725d9448e0221f8" translate="yes" xml:space="preserve">
          <source>One verification technique used on SQLite is to run an entire test suite twice, once with optimizations left on and a second time with optimizations turned off, and verify that the same output is obtained both times. This shows that the optimizations do not introduce errors.</source>
          <target state="translated">Один метод верификации,используемый на SQLite,состоит в том,чтобы дважды запустить весь тестовый набор,один раз с включенными оптимизациями и второй раз с выключенными оптимизациями,и проверить,что один и тот же результат получен в оба раза.Это показывает,что оптимизации не вносят ошибок.</target>
        </trans-unit>
        <trans-unit id="1193850e31c2f1f6fdd8ba5f6d6a21ba1025f991" translate="yes" xml:space="preserve">
          <source>One very simple scheme might be to count the number of instances of the users search terms in each result document. Those documents that contain many instances of the terms are considered more relevant than those with a small number of instances of each term. In an FTS application, the number of term instances in each result could be determined by counting the number of integers in the return value of the &lt;a href=&quot;fts3#offsets&quot;&gt;offsets&lt;/a&gt; function. The following example shows a query that could be used to obtain the ten most relevant results for a query entered by the user:</source>
          <target state="translated">Одна очень простая схема может заключаться в подсчете количества экземпляров пользовательских условий поиска в каждом документе результатов. Те документы, которые содержат много экземпляров терминов, считаются более релевантными, чем документы с небольшим количеством экземпляров каждого термина. В приложении FTS количество экземпляров термина в каждом результате может быть определено путем подсчета количества целых чисел в возвращаемом значении функции &lt;a href=&quot;fts3#offsets&quot;&gt;смещения&lt;/a&gt; . В следующем примере показан запрос, который можно использовать для получения десяти наиболее релевантных результатов по запросу, введенному пользователем:</target>
        </trans-unit>
        <trans-unit id="ef8241368a545dcfd4804f314c3279bd316a6040" translate="yes" xml:space="preserve">
          <source>One way around this problem is to check the extended error code returned by an sqlite3_step() call. If there is a blocking connection, then the extended error code is set to SQLITE_LOCKED_SHAREDCACHE. Otherwise, in the special &quot;DROP TABLE/INDEX&quot; case, the extended error code is just SQLITE_LOCKED.</source>
          <target state="translated">Одним из способов решения этой проблемы является проверка расширенного кода ошибки,возвращаемого вызовом sqlite3_step().Если соединение блокируется,то расширенный код ошибки устанавливается в SQLITE_LOCKED_SHAREDCACHE.В противном случае,в специальном случае &quot;DROP TABLE/INDEX&quot;,расширенный код ошибки будет просто SQLITE_LOCKED.</target>
        </trans-unit>
        <trans-unit id="acee115381c0c09c4f7ee9640610c7e8117858b5" translate="yes" xml:space="preserve">
          <source>One way to compute FindFrame(P,M) would be to scan the aPgno array starting with the M-th entry and working backwards towards the beginning and return J where aPgno[J]==P. Such an algorithm would work, and it would be faster than searching the whole WAL file for the latest frame with page number P. But the search can be made much faster still by using the aHash structure.</source>
          <target state="translated">Одним из способов вычисления FindFrame(P,M)было бы сканирование массива aPgno,начинающегося с M-го элемента и работающего в обратном направлении к началу,и возврат J,где aPgno[J]==P.Такой алгоритм сработал бы,и это было бы быстрее,чем искать во всем файле WAL последний кадр с номером страницы P.Но поиск все равно можно сделать намного быстрее,используя структуру aHash.</target>
        </trans-unit>
        <trans-unit id="43ce70174605b98e2611ee3fa62c55d5c3b3d847" translate="yes" xml:space="preserve">
          <source>One way to create an imposter table is to directly edit the sqlite_master table to insert a new row that describes the table. For example, suppose the schema is like this:</source>
          <target state="translated">Один из способов создать таблицу imposter-напрямую отредактировать таблицу sqlite_master,чтобы вставить новую строку,описывающую таблицу.Например,предположим,что схема такая:</target>
        </trans-unit>
        <trans-unit id="84cd9c4bdeae83b60aa9ede1d4ab69d156255724" translate="yes" xml:space="preserve">
          <source>One way to create an imposter table is to directly edit the sqlite_schema table to insert a new row that describes the table. For example, suppose the schema is like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5371a62fb713016b88bf9cbe1ee3e53f088627a9" translate="yes" xml:space="preserve">
          <source>One way to use sqlite3 in a shell script is to use &quot;echo&quot; or &quot;cat&quot; to generate a sequence of commands in a file, then invoke sqlite3 while redirecting input from the generated command file. This works fine and is appropriate in many circumstances. But as an added convenience, sqlite3 allows a single SQL command to be entered on the command line as a second argument after the database name. When the sqlite3 program is launched with two arguments, the second argument is passed to the SQLite library for processing, the query results are printed on standard output in list mode, and the program exits. This mechanism is designed to make sqlite3 easy to use in conjunction with programs like &quot;awk&quot;. For example:</source>
          <target state="translated">Один из способов использования sqlite3 в скрипте оболочки-использовать &quot;echo&quot; или &quot;cat&quot; для генерации последовательности команд в файле,а затем вызывать sqlite3 при перенаправлении входных данных из сгенерированного командного файла.Это прекрасно работает и подходит во многих случаях.Но в качестве дополнительного удобства sqlite3 позволяет ввести в командную строку одну SQL-команду в качестве второго аргумента после имени БД.При запуске программы sqlite3 с двумя аргументами второй аргумент передается на обработку в библиотеку SQLite,результаты запроса выводятся на стандартный вывод в режиме списка,и программа завершает работу.Данный механизм предназначен для того,чтобы сделать sqlite3 простым в использовании совместно с программами типа &quot;awk&quot;.Например:</target>
        </trans-unit>
        <trans-unit id="c9f164cc934fc44dc3087a408a43d581d45a004f" translate="yes" xml:space="preserve">
          <source>One would get the same answer without the use of the R*Tree index using the following simpler query:</source>
          <target state="translated">Ответ можно было бы получить и без использования индекса R*Tree с помощью следующего более простого запроса:</target>
        </trans-unit>
        <trans-unit id="17f5a4fe2f5c62ecd81776d246b8c0c725190c25" translate="yes" xml:space="preserve">
          <source>One-Step Query Execution Interface</source>
          <target state="translated">Интерфейс выполнения одношаговых запросов</target>
        </trans-unit>
        <trans-unit id="aa3d3adac784c0d74a31276058a965e9e8ca9895" translate="yes" xml:space="preserve">
          <source>Online Backup API</source>
          <target state="translated">API онлайн-безопасность</target>
        </trans-unit>
        <trans-unit id="84ecd14ddbadabe468f63832d803f2392f405f33" translate="yes" xml:space="preserve">
          <source>Online Backup API.</source>
          <target state="translated">API Онлайн Резервного Копирования.</target>
        </trans-unit>
        <trans-unit id="df4435ab96f572a5ddc0d0575dab3a2326c426c1" translate="yes" xml:space="preserve">
          <source>Online Backup Object</source>
          <target state="translated">объект онлайн-безопасного копирования</target>
        </trans-unit>
        <trans-unit id="cf333df0d0137378797eeac3fd91be937936f09b" translate="yes" xml:space="preserve">
          <source>Only CPU cycle counts are being measured here. CPU cycle counts are a good proxy for energy consumption, but do not necessary correlate well with real-world timings. Time spent doing I/O is not reflected in the CPU cycle counts, and I/O time predominates in many SQLite usage scenarios.</source>
          <target state="translated">Здесь измеряется только количество циклов процессора.Подсчеты циклов ЦП являются хорошим показателем энергопотребления,но не обязательно хорошо коррелируют с реальными таймингами.Время,затрачиваемое на ввод/вывод,не отражается на счетах цикла ЦП,а время ввода/вывода превалирует во многих сценариях использования SQLite.</target>
        </trans-unit>
        <trans-unit id="d5604491374c9f17a80675ca75c6861a336b77e6" translate="yes" xml:space="preserve">
          <source>Only a single authorizer can be in place on a database connection at a time. Each call to sqlite3_set_authorizer overrides the previous call. Disable the authorizer by installing a NULL callback. The authorizer is disabled by default.</source>
          <target state="translated">Одновременно при подключении к базе данных может быть установлен только один авторизатор.Каждый вызов sqlite3_set_authorizer перекрывает предыдущий вызов.Отключите авторизатор,установив NULL обратный вызов.Авторизатор отключен по умолчанию.</target>
        </trans-unit>
        <trans-unit id="478d5d49691bd8c6240a1fe276d18045c9e67957" translate="yes" xml:space="preserve">
          <source>Only a single progress handler may be defined at one time per &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt;; setting a new progress handler cancels the old one. Setting parameter X to NULL disables the progress handler. The progress handler is also disabled by setting N to a value less than 1.</source>
          <target state="translated">Только один обработчик хода выполнения может быть определен одновременно для каждого &lt;a href=&quot;#sqlite3&quot;&gt;соединения с базой данных&lt;/a&gt; ; установка нового обработчика прогресса отменяет старый. Установка для параметра X значения NULL отключает обработчик хода выполнения. Обработчик хода выполнения также отключается путем установки для N значения меньше 1.</target>
        </trans-unit>
        <trans-unit id="94e56a9c57047e711c69e819b360a3dd7e101263" translate="yes" xml:space="preserve">
          <source>Only a single progress handler may be defined at one time per &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt;; setting a new progress handler cancels the old one. Setting parameter X to NULL disables the progress handler. The progress handler is also disabled by setting N to a value less than 1.</source>
          <target state="translated">Только один обработчик хода выполнения может быть определен одновременно для каждого &lt;a href=&quot;sqlite3&quot;&gt;соединения с базой данных&lt;/a&gt; ; установка нового обработчика прогресса отменяет старый. Установка для параметра X значения NULL отключает обработчик хода выполнения. Обработчик хода выполнения также отключается путем установки для N значения меньше 1.</target>
        </trans-unit>
        <trans-unit id="7036e4ebe3282d4cd750dee2b265f33019cf27cb" translate="yes" xml:space="preserve">
          <source>Only changes made directly by the INSERT, UPDATE or DELETE statement are considered - auxiliary changes caused by &lt;a href=&quot;../lang_createtrigger&quot;&gt;triggers&lt;/a&gt;, &lt;a href=&quot;../foreignkeys#fk_actions&quot;&gt;foreign key actions&lt;/a&gt; or &lt;a href=&quot;../lang_replace&quot;&gt;REPLACE&lt;/a&gt; constraint resolution are not counted.</source>
          <target state="translated">Учитываются только изменения, сделанные непосредственно оператором INSERT, UPDATE или DELETE - вспомогательные изменения, вызванные &lt;a href=&quot;../lang_createtrigger&quot;&gt;триггерами&lt;/a&gt; , &lt;a href=&quot;../foreignkeys#fk_actions&quot;&gt;действиями внешнего ключа&lt;/a&gt; или разрешением ограничения &lt;a href=&quot;../lang_replace&quot;&gt;REPLACE&lt;/a&gt; , не учитываются.</target>
        </trans-unit>
        <trans-unit id="c27ab9dbf00600e9d93b4dae249b72bd85740109" translate="yes" xml:space="preserve">
          <source>Only changes made directly by the INSERT, UPDATE or DELETE statement are considered - auxiliary changes caused by &lt;a href=&quot;lang_createtrigger&quot;&gt;triggers&lt;/a&gt;, &lt;a href=&quot;foreignkeys#fk_actions&quot;&gt;foreign key actions&lt;/a&gt; or &lt;a href=&quot;lang_replace&quot;&gt;REPLACE&lt;/a&gt; constraint resolution are not counted.</source>
          <target state="translated">Учитываются только изменения, сделанные непосредственно оператором INSERT, UPDATE или DELETE - вспомогательные изменения, вызванные &lt;a href=&quot;lang_createtrigger&quot;&gt;триггерами&lt;/a&gt; , &lt;a href=&quot;foreignkeys#fk_actions&quot;&gt;действиями внешнего ключа&lt;/a&gt; или разрешением ограничения &lt;a href=&quot;lang_replace&quot;&gt;REPLACE&lt;/a&gt; , не учитываются.</target>
        </trans-unit>
        <trans-unit id="9ca2d95ecc0496343a0233bd681510ca318c6946" translate="yes" xml:space="preserve">
          <source>Only columns a and b of the index would be usable. The d column would not be usable because column c is not constrained and there can be no gaps in the set of columns that usable by the index.</source>
          <target state="translated">Полезными будут только столбцы a и b индекса.Столбец d не будет использоваться,поскольку столбец c не ограничен,и в наборе столбцов,используемых индексом,не может быть пробелов.</target>
        </trans-unit>
        <trans-unit id="05736f4fee6c4c67dfd5428743f05e710b55053c" translate="yes" xml:space="preserve">
          <source>Only columns a, b, and c of the index would be usable. The d column would not be usable because it occurs to the right of c and c is constrained only by inequalities.</source>
          <target state="translated">Полезными будут только столбцы a,b и c индекса.Столбец d не может быть использован,поскольку он находится справа от столбцов c и c и ограничивается только неравенством.</target>
        </trans-unit>
        <trans-unit id="6822d83fba844c52182b6e2b1305124432ab29b8" translate="yes" xml:space="preserve">
          <source>Only create &lt;a href=&quot;tempfiles#masterjrnl&quot;&gt;master journal&lt;/a&gt; files if two or more attached databases are all modified, do not have &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous&lt;/a&gt; set to OFF, and do not have the &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;journal_mode&lt;/a&gt; set to OFF, MEMORY, or WAL.</source>
          <target state="translated">Только создать &lt;a href=&quot;tempfiles#masterjrnl&quot;&gt;мастер - журнальные&lt;/a&gt; файлы , если два или более подключенные баз данных все изменяется, не &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;Pragma синхронных&lt;/a&gt; отключаются, и не имеют &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;journal_mode&lt;/a&gt; отключаются, ПАМЯТЬ, или WAL.</target>
        </trans-unit>
        <trans-unit id="9d1635246b5aeaad6de58e92e5095276c845c10a" translate="yes" xml:space="preserve">
          <source>Only create &lt;a href=&quot;tempfiles#stmtjrnl&quot;&gt;statement journal&lt;/a&gt; files when their size exceeds a threshold. Otherwise the journal is held in memory and no I/O occurs. The threshold can be configured at compile-time using &lt;a href=&quot;compile#stmtjrnl_spill&quot;&gt;SQLITE_STMTJRNL_SPILL&lt;/a&gt; or at start-time using &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigstmtjrnlspill&quot;&gt;SQLITE_CONFIG_STMTJRNL_SPILL&lt;/a&gt;).</source>
          <target state="translated">&lt;a href=&quot;tempfiles#stmtjrnl&quot;&gt;Создавайте&lt;/a&gt; файлы журнала выписок только тогда, когда их размер превышает пороговое значение. В противном случае журнал сохраняется в памяти, и операций ввода-вывода не происходит. Порог можно настроить во время компиляции с помощью &lt;a href=&quot;compile#stmtjrnl_spill&quot;&gt;SQLITE_STMTJRNL_SPILL&lt;/a&gt; или во время запуска с помощью &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt; ( &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigstmtjrnlspill&quot;&gt;SQLITE_CONFIG_STMTJRNL_SPILL&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="04951ae9e91c50e633618b0424f4870112bf6e2c" translate="yes" xml:space="preserve">
          <source>Only create master journal files if two or more attached databases are all modified, do not have &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous&lt;/a&gt; set to OFF, and do not have the &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;journal_mode&lt;/a&gt; set to OFF, MEMORY, or WAL.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="610003d6616c61d3e569880b1cf6337a8bfaac43" translate="yes" xml:space="preserve">
          <source>Only rows of the table for which the WHERE clause evaluates to true are included in the index. If the WHERE clause expression evaluates to NULL or to false for some rows of the table, then those rows are omitted from the index.</source>
          <target state="translated">В индекс включаются только строки таблицы,для которой пункт WHERE оценивает как истинный.Если выражение из выражения WHERE для некоторых строк таблицы оценивается как NULL или false,то эти строки опускаются из индекса.</target>
        </trans-unit>
        <trans-unit id="255e530c466468dcdf3e2dbc7217cf60c632c517" translate="yes" xml:space="preserve">
          <source>Only terms of the vocabulary with a matching langid are searched. Hence, the same table can contain entries from multiple languages and only the requested language will be used. The default langid is 0.</source>
          <target state="translated">Поиск ведется только по словарю с совпадающим по значению словарным запасом.Таким образом,одна и та же таблица может содержать записи из нескольких языков,и будет использоваться только запрашиваемый язык.Лангид по умолчанию равен 0.</target>
        </trans-unit>
        <trans-unit id="2ece13f71abf0bca8da38ece8f95957b023f2f28" translate="yes" xml:space="preserve">
          <source>Only the &quot;ll&quot; length modifier ever makes a difference for SQLite. And it only makes a difference when using the C-language interfaces.</source>
          <target state="translated">Только модификатор длины &quot;ll&quot; когда-либо имеет значение для SQLite.И это имеет значение только при использовании интерфейсов на языке C.</target>
        </trans-unit>
        <trans-unit id="85148a6237828ed28c44695045ab73ff06e6fcad" translate="yes" xml:space="preserve">
          <source>Only the RENAME TABLE, ADD COLUMN, and RENAME COLUMN variants of the ALTER TABLE command are supported. Other kinds of ALTER TABLE operations such as DROP COLUMN, ALTER COLUMN, ADD CONSTRAINT, and so forth are omitted.</source>
          <target state="translated">Поддерживаются только варианты ALTER TABLE,ADD COLUMN и RENAME COLUMN.Другие виды операций ALTER TABLE,такие как DROP COLUMN,ALTER COLUMN,ADD CONSTRAINT и т.д.,опускаются.</target>
        </trans-unit>
        <trans-unit id="718ea1282b5847e8c3e9e8f8d5345c6ee50c38cc" translate="yes" xml:space="preserve">
          <source>Only the implicit version of the AND operator is supported. Specifying the string &quot;AND&quot; as part of a standard query syntax query is interpreted as a term query for the set of documents containing the term &quot;and&quot;.</source>
          <target state="translated">Поддерживается только неявная версия оператора AND.Указание строки &quot;AND&quot; как части стандартного синтаксического запроса интерпретируется как запрос на набор документов,содержащих термин &quot;и&quot;.</target>
        </trans-unit>
        <trans-unit id="1eda18e73564838ddd329dd3f15abb7d2f114fbe" translate="yes" xml:space="preserve">
          <source>Only the three core routines described in section 1.0 are required to use SQLite. But there are many other functions that provide useful interfaces. These extended routines are as follows:</source>
          <target state="translated">Для использования SQLite требуются только три основные подпрограммы,описанные в разделе 1.0.Однако существует множество других функций,которые предоставляют полезные интерфейсы.Эти расширенные процедуры следующие:</target>
        </trans-unit>
        <trans-unit id="9ddd9d23f19b01af8d3915a7bfd11c89aef2d1d4" translate="yes" xml:space="preserve">
          <source>Only use indexes-on-expressions to optimize ORDER BY or GROUP BY if the COLLATE is correct. Ticket &lt;a href=&quot;https://sqlite.org/src/info/e20dd54ab0e4383&quot;&gt;e20dd54ab0e4383&lt;/a&gt;</source>
          <target state="translated">Используйте индексы-по-выражениям только для оптимизации ORDER BY или GROUP BY, если COLLATE правильный. Билет &lt;a href=&quot;https://sqlite.org/src/info/e20dd54ab0e4383&quot;&gt;e20dd54ab0e4383&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c74dd7ced7cd4ea8002b3c96a9b1ecdff66b1e59" translate="yes" xml:space="preserve">
          <source>Opcode Name</source>
          <target state="translated">Имя опкода</target>
        </trans-unit>
        <trans-unit id="1682c59856887894432baf4bb39e98c21d42d731" translate="yes" xml:space="preserve">
          <source>Opcode definitions</source>
          <target state="translated">Определения опкодов</target>
        </trans-unit>
        <trans-unit id="313411b9bd1b97b8fcd666d91d350cb8e6bed0d1" translate="yes" xml:space="preserve">
          <source>Open A BLOB For Incremental I/O</source>
          <target state="translated">Открыть BLOB для инкрементального ввода/вывода</target>
        </trans-unit>
        <trans-unit id="beb2e15e058a69d62502daa1bdfb1095abeb86de" translate="yes" xml:space="preserve">
          <source>Open a cursor into the table to be queried.</source>
          <target state="translated">Откройте курсор в таблицу,которую нужно опросить.</target>
        </trans-unit>
        <trans-unit id="7e8e851c144078264ee423ec854e116a3d7fdff4" translate="yes" xml:space="preserve">
          <source>Open a new cursor P1 that points to the same ephemeral table as cursor P2. The P2 cursor must have been opened by a prior &lt;a href=&quot;opcode#OpenEphemeral&quot;&gt;OpenEphemeral&lt;/a&gt; opcode. Only ephemeral cursors may be duplicated.</source>
          <target state="translated">Откройте новый курсор P1, который указывает на ту же временную таблицу, что и курсор P2. Курсор P2 должен быть открыт предыдущим &lt;a href=&quot;opcode#OpenEphemeral&quot;&gt;кодом&lt;/a&gt; операции OpenEphemeral . Можно дублировать только эфемерные курсоры.</target>
        </trans-unit>
        <trans-unit id="57454cf77dc40f8ad1e1086dd9c199e6c88ed771" translate="yes" xml:space="preserve">
          <source>Open a new cursor P1 to a transient table. The cursor is always opened read/write even if the main database is read-only. The ephemeral table is deleted automatically when the cursor is closed.</source>
          <target state="translated">Откройте новый курсор P1 на переходную таблицу.Курсор всегда открыт на чтение/запись,даже если основная БД доступна только для чтения.Эфемерная таблица удаляется автоматически при закрытии курсора.</target>
        </trans-unit>
        <trans-unit id="545bc19bf66be6511144aed187f1840c5a4278d1" translate="yes" xml:space="preserve">
          <source>Open a new cursor that points to a fake table that contains a single row of data. The content of that one row is the content of memory register P2. In other words, cursor P1 becomes an alias for the MEM_Blob content contained in register P2.</source>
          <target state="translated">Открыть новый курсор,указывающий на поддельную таблицу,содержащую одну строку данных.Содержимое этой строки-содержимое регистра памяти P2.Другими словами,курсор P1 становится псевдонимом для содержимого MEM_Blob,содержащегося в регистре P2.</target>
        </trans-unit>
        <trans-unit id="135ddb8c48350a0a78c4aa223b6b8ae16522c7fd" translate="yes" xml:space="preserve">
          <source>Open a read-only cursor for the database table whose root page is P2 in a database file. The database file is determined by P3. P3==0 means the main database, P3==1 means the database used for temporary tables, and P3&amp;gt;1 means used the corresponding attached database. Give the new cursor an identifier of P1. The P1 values need not be contiguous but all P1 values should be small integers. It is an error for P1 to be negative.</source>
          <target state="translated">Откройте доступный только для чтения курсор для таблицы базы данных, корневой страницей которой является P2 в файле базы данных. Файл базы данных определяется P3. P3 == 0 означает основную базу данных, P3 == 1 означает базу данных, используемую для временных таблиц, а P3&amp;gt; 1 означает, что использовалась соответствующая присоединенная база данных. Дайте новому курсору идентификатор P1. Значения P1 не обязательно должны быть смежными, но все значения P1 должны быть небольшими целыми числами. Отрицательное значение P1 является ошибкой.</target>
        </trans-unit>
        <trans-unit id="84089bd01646e44fd57253086466eec04ccae47a" translate="yes" xml:space="preserve">
          <source>Open a read/write cursor named P1 on the table or index whose root page is P2 (or whose root page is held in register P2 if the OPFLAG_P2ISREG bit is set in P5 - see below).</source>
          <target state="translated">Откройте курсор чтения/записи с именем P1 на таблице или индексе,корневая страница которого равна P2 (или корневая страница которого находится в регистре P2,если бит OPFLAG_P2ISREG установлен в P5-см.ниже).</target>
        </trans-unit>
        <trans-unit id="4063448157b3ab2686e1495793b9571ba748ea89" translate="yes" xml:space="preserve">
          <source>Open an RBU handle using the sqlite3rbu_open(T,A,S) function.</source>
          <target state="translated">Открыть хэндл RBU,используя функцию sqlite3rbu_open(T,A,S).</target>
        </trans-unit>
        <trans-unit id="6423cf77a906b294f7ccb82649c19b9b21d337a4" translate="yes" xml:space="preserve">
          <source>Open file &quot;/home/fred/data.db&quot;. Use the special VFS &quot;unix-dotfile&quot; that uses dot-files in place of posix advisory locking.</source>
          <target state="translated">Открыть файл &quot;/home/fred/data.db&quot;.Используйте специальный VFS &quot;unix-файл точки&quot;,который использует dot-файлы вместо блокировки posix-советов.</target>
        </trans-unit>
        <trans-unit id="d23dfc68fcbe2b64c96946a59f2391f88d879ada" translate="yes" xml:space="preserve">
          <source>Open file &quot;data.db&quot; in the current directory for read-only access. Regardless of whether or not shared-cache mode is enabled by default, use a private cache.</source>
          <target state="translated">Открыть файл &quot;data.db&quot; в текущем каталоге для доступа только на чтение.Независимо от того,включен ли режим общего кэша по умолчанию,используйте частный кэш.</target>
        </trans-unit>
        <trans-unit id="32023375b26a0776fe1660f78af585c47d78b01e" translate="yes" xml:space="preserve">
          <source>Open the database file &quot;/home/fred/data.db&quot;.</source>
          <target state="translated">Открыть файл базы данных &quot;/home/fred/data.db&quot;.</target>
        </trans-unit>
        <trans-unit id="b140126e4bb0c579baba79fa4b78910264cad628" translate="yes" xml:space="preserve">
          <source>Open the database file and obtain a SHARED lock. If the SHARED lock cannot be obtained, fail immediately and return SQLITE_BUSY.</source>
          <target state="translated">Откройте файл базы данных и получите блокировку SHARED.Если блокировка SHARED не может быть получена,немедленно выйдите из строя и верните SQLITE_BUSY.</target>
        </trans-unit>
        <trans-unit id="1fdbee3b0460b37f393d93c476774730b651cdaf" translate="yes" xml:space="preserve">
          <source>Open the file &quot;data.db&quot; in the current directory.</source>
          <target state="translated">Откройте файл &quot;data.db&quot; в текущем каталоге.</target>
        </trans-unit>
        <trans-unit id="e305cdc0a6e58d2992d00df36114935a966f06eb" translate="yes" xml:space="preserve">
          <source>Open two cursors, one to each of the two tables being queried.</source>
          <target state="translated">Откройте два курсора,по одному на каждый из двух опрашиваемых таблиц.</target>
        </trans-unit>
        <trans-unit id="db8828ea77768020acda7b34e1bdcfb01f4a650b" translate="yes" xml:space="preserve">
          <source>Open, release or rollback the savepoint named by parameter P4, depending on the value of P1. To open a new savepoint set P1==0 (SAVEPOINT_BEGIN). To release (commit) an existing savepoint set P1==1 (SAVEPOINT_RELEASE). To rollback an existing savepoint set P1==2 (SAVEPOINT_ROLLBACK).</source>
          <target state="translated">Откройте,отпустите или откатите точку сохранения,названную параметром P4,в зависимости от значения P1.Для открытия нового набора точек сохранения P1==0 (SAVEPOINT_BEGIN).Чтобы освободить (зафиксировать)существующую точку сохранения P1==1 (SAVEPOINT_RELEASE).Чтобы откатить существующую точку сохранения P1==2 (SAVEPOINT_ROLLBACK).</target>
        </trans-unit>
        <trans-unit id="e54c6e14fb4a075fa699ffdaaaf395ff313982e8" translate="yes" xml:space="preserve">
          <source>OpenAutoindex</source>
          <target state="translated">OpenAutoindex</target>
        </trans-unit>
        <trans-unit id="4102c59c0ab3f6e830e46718de359a59f628ee07" translate="yes" xml:space="preserve">
          <source>OpenDup</source>
          <target state="translated">OpenDup</target>
        </trans-unit>
        <trans-unit id="ad5bdfbe38582d74f4e2d987d0014c4a061fc0bc" translate="yes" xml:space="preserve">
          <source>OpenEphemeral</source>
          <target state="translated">OpenEphemeral</target>
        </trans-unit>
        <trans-unit id="4a5d4d0e6cf7c26b571b8ed8b7d9e91f5a55707c" translate="yes" xml:space="preserve">
          <source>OpenPseudo</source>
          <target state="translated">OpenPseudo</target>
        </trans-unit>
        <trans-unit id="321f145cb1e3470cc293ca452256220e4b476cbf" translate="yes" xml:space="preserve">
          <source>OpenRead</source>
          <target state="translated">OpenRead</target>
        </trans-unit>
        <trans-unit id="3894e594709a936290c9439b10b580db3b56e3b5" translate="yes" xml:space="preserve">
          <source>OpenWrite</source>
          <target state="translated">OpenWrite</target>
        </trans-unit>
        <trans-unit id="10f17177db5db183ce11fbbf98483043f8f93d13" translate="yes" xml:space="preserve">
          <source>Openclose callback</source>
          <target state="translated">Обратный звонок в режиме &quot;открытость</target>
        </trans-unit>
        <trans-unit id="f1ba5b2c8dba45952ee1dd4e3e5587becf1e4832" translate="yes" xml:space="preserve">
          <source>Opening A New Database Connection</source>
          <target state="translated">Открытие нового соединения с базой данных</target>
        </trans-unit>
        <trans-unit id="8bea067fa84f98eb8cb08b76d377cd2759d84a48" translate="yes" xml:space="preserve">
          <source>Opening a New Connection</source>
          <target state="translated">Открытие нового соединения</target>
        </trans-unit>
        <trans-unit id="0fcdc2f790b5b05c0b11e1b00c614a1147af7a65" translate="yes" xml:space="preserve">
          <source>Opening a Read-Only Transaction</source>
          <target state="translated">Открытие сделки только для чтения</target>
        </trans-unit>
        <trans-unit id="8c328ea219e123938753dd011cc218695e36770e" translate="yes" xml:space="preserve">
          <source>Opening a connection.</source>
          <target state="translated">Открытие соединения.</target>
        </trans-unit>
        <trans-unit id="0a848c1fa6f5b691a8b43871dbf9920b32a63f8f" translate="yes" xml:space="preserve">
          <source>Opening a new database connection is a two-step process:</source>
          <target state="translated">Открытие нового соединения с БД-это двухступенчатый процесс:</target>
        </trans-unit>
        <trans-unit id="60a2e026abe5554a6164ccf369d3bdb712d462a6" translate="yes" xml:space="preserve">
          <source>Opening a read-only transaction.</source>
          <target state="translated">Открытие сделки только для чтения.</target>
        </trans-unit>
        <trans-unit id="d0a97ec8f1b3b761b48ba3f0b5793b7b063cf28e" translate="yes" xml:space="preserve">
          <source>Opening a read-write transaction.</source>
          <target state="translated">Открытие операции чтения и записи.</target>
        </trans-unit>
        <trans-unit id="5bef4a855a587c7ae88d0d6e7fbc4f0cf1d92d9c" translate="yes" xml:space="preserve">
          <source>Opening a statement transaction.</source>
          <target state="translated">Открытие операции по выписке.</target>
        </trans-unit>
        <trans-unit id="5f6fc2590106eab5d853e4838b574315ff3651ac" translate="yes" xml:space="preserve">
          <source>Operand P1 must be 0x7fffffff and P2 must positive.</source>
          <target state="translated">Операнд P1 должен быть 0x7fffff и P2 должен быть положительным.</target>
        </trans-unit>
        <trans-unit id="d0e687b079fb70f2208d1f8d2c75d64d74925496" translate="yes" xml:space="preserve">
          <source>Operator</source>
          <target state="translated">Operator</target>
        </trans-unit>
        <trans-unit id="e90414358dbfff0a68e4eb5d68a16978cf197d5a" translate="yes" xml:space="preserve">
          <source>Operators</source>
          <target state="translated">Operators</target>
        </trans-unit>
        <trans-unit id="653e79b2411d60c991c837c40648dc99da326979" translate="yes" xml:space="preserve">
          <source>Optimization: When doing an &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; on a table with &lt;a href=&quot;expridx&quot;&gt;indexes on expressions&lt;/a&gt;, do not update the expression indexes if they do not refer to any of the columns of the table being updated.</source>
          <target state="translated">Оптимизация: при выполнении &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; в таблице с &lt;a href=&quot;expridx&quot;&gt;индексами в выражениях&lt;/a&gt; не обновляйте индексы выражений, если они не относятся ни к одному из столбцов обновляемой таблицы.</target>
        </trans-unit>
        <trans-unit id="a794f9704b3031ad0771d79793775c086e03f157" translate="yes" xml:space="preserve">
          <source>Optimizations to the sqlite_mprintf() routine.</source>
          <target state="translated">Оптимизация рутины sqlite_mprintf().</target>
        </trans-unit>
        <trans-unit id="088089a3961fc329e20285999528f0da0604b13a" translate="yes" xml:space="preserve">
          <source>Optimize the &lt;a href=&quot;lang_corefunc#typeof&quot;&gt;typeof()&lt;/a&gt; and &lt;a href=&quot;lang_corefunc#length&quot;&gt;length()&lt;/a&gt; SQL functions so that they avoid unnecessary reading of database content from disk.</source>
          <target state="translated">Оптимизируйте функции SQL &lt;a href=&quot;lang_corefunc#typeof&quot;&gt;typeof ()&lt;/a&gt; и &lt;a href=&quot;lang_corefunc#length&quot;&gt;length (),&lt;/a&gt; чтобы они избегали ненужного чтения содержимого базы данных с диска.</target>
        </trans-unit>
        <trans-unit id="89ea4f0e94546aba0e6576de32f5af050f08375b" translate="yes" xml:space="preserve">
          <source>Optimizer does a better job of using indices to satisfy ORDER BY clauses that sort on the integer primary key</source>
          <target state="translated">Оптимизатор лучше использует индексы для удовлетворения пунктов ORDER BY,которые сортируют по целочисленному первичному ключу</target>
        </trans-unit>
        <trans-unit id="d859dd72c637fafc6319ca0f4f6cb8c1fd01736f" translate="yes" xml:space="preserve">
          <source>Optimizer enhancement: &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statements&lt;/a&gt; are automatically re-compiled when a binding on the RHS of a LIKE operator changes or when any range constraint changes under &lt;a href=&quot;compile#enable_stat2&quot;&gt;SQLITE_ENABLE_STAT2&lt;/a&gt;.</source>
          <target state="translated">Улучшение оптимизатора: &lt;a href=&quot;c3ref/stmt&quot;&gt;подготовленные операторы&lt;/a&gt; автоматически перекомпилируются при изменении привязки RHS оператора LIKE или при изменении любого ограничения диапазона в &lt;a href=&quot;compile#enable_stat2&quot;&gt;SQLITE_ENABLE_STAT2&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e31d972229de381b461860014dd710856361917a" translate="yes" xml:space="preserve">
          <source>Option</source>
          <target state="translated">Option</target>
        </trans-unit>
        <trans-unit id="6120d3ea8f989e319fa4157b88a6894abd99ea8b" translate="yes" xml:space="preserve">
          <source>Option 1:</source>
          <target state="translated">Вариант 1:</target>
        </trans-unit>
        <trans-unit id="787636b9cef675727f97423a49f2d6e8aeb5b354" translate="yes" xml:space="preserve">
          <source>Option 2:</source>
          <target state="translated">Вариант 2:</target>
        </trans-unit>
        <trans-unit id="620a38bc45cce1e89bad8abed95cee233ec74ca8" translate="yes" xml:space="preserve">
          <source>Optional LIMIT and ORDER BY Clauses</source>
          <target state="translated">Необязательно ОГРАНИЧИТЬ и ЗАКАЗАТЬ по пунктам</target>
        </trans-unit>
        <trans-unit id="4a8101f15dc88fa6899984a679049286645dada8" translate="yes" xml:space="preserve">
          <source>Optional LIMIT and ORDER BY clauses</source>
          <target state="translated">Необязательное ОГРАНИЧЕНИЕ и ЗАКАЗЫВАНИЕ ОРГАНИЗАЦИЕЙ</target>
        </trans-unit>
        <trans-unit id="147fccad2acf5d54cf4c9bd90959d2b685bb12a8" translate="yes" xml:space="preserve">
          <source>Optional READ UNCOMMITTED isolation (instead of the default isolation level of SERIALIZABLE) and table level locking when database connections share a common cache.</source>
          <target state="translated">Опционально READ UNCOMMITTED изоляция (вместо уровня изоляции по умолчанию SERIALIZABLE)и блокировка на уровне таблиц,когда соединения БД имеют общий кэш.</target>
        </trans-unit>
        <trans-unit id="99e39e3c25d749e303cfb0392ac6108be81a9ed0" translate="yes" xml:space="preserve">
          <source>Optionally, a &lt;a href=&quot;gencol&quot;&gt;generated column&lt;/a&gt; constraint.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3c4d258c19e0b0e32f1a0047f810a58bf67a8d7" translate="yes" xml:space="preserve">
          <source>Optionally, a PRIMARY KEY for the table. Both single column and composite (multiple column) primary keys are supported.</source>
          <target state="translated">Опционально,ПРАЙМАРИ КЕЙ для стола.Поддерживаются как одностолбцовые,так и составные (многостолбцовые)первичные ключи.</target>
        </trans-unit>
        <trans-unit id="afb65b09ecb1abf655b3870806d0d663e9055759" translate="yes" xml:space="preserve">
          <source>Options understood by the &lt;b&gt;sqlite3&lt;/b&gt; command include:</source>
          <target state="translated">Параметры, понимаемые командой &lt;b&gt;sqlite3,&lt;/b&gt; включают:</target>
        </trans-unit>
        <trans-unit id="e72184f55cc026514b7160d78c3c5aef63c2a050" translate="yes" xml:space="preserve">
          <source>Or</source>
          <target state="translated">Or</target>
        </trans-unit>
        <trans-unit id="1a5a89789f35d1adc160640f07b04eccb062e675" translate="yes" xml:space="preserve">
          <source>Or consider these identical queries:</source>
          <target state="translated">Или рассмотрим эти идентичные запросы:</target>
        </trans-unit>
        <trans-unit id="aa8e4bd6460fbb4edd20d4ab7cc84cb756c25fa7" translate="yes" xml:space="preserve">
          <source>Or on Windows with MSVC:</source>
          <target state="translated">Или на Windows с MSVC:</target>
        </trans-unit>
        <trans-unit id="65cc0e4d32009c846d3d67b851864fc0e2100eac" translate="yes" xml:space="preserve">
          <source>Or optimization</source>
          <target state="translated">Или оптимизация</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
