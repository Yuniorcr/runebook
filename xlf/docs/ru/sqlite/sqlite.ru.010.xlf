<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="sqlite">
    <body>
      <group id="sqlite">
        <trans-unit id="d664cf7cb7a8aa891620cace778bbb7e18301125" translate="yes" xml:space="preserve">
          <source>Improved optimization of queries containing aggregate min() or max().</source>
          <target state="translated">Улучшена оптимизация запросов,содержащих aggregate min()или max().</target>
        </trans-unit>
        <trans-unit id="85221cb8e52f1982bf5ad92049ab6c11d2f8041b" translate="yes" xml:space="preserve">
          <source>Improved performance of &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt; locking primitives in cases where there are hundreds of connections all accessing the same database file at once.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa1222b8dcd6d3acb1bb29b90eb9192b7d6106ad" translate="yes" xml:space="preserve">
          <source>Improved performance of queries like &quot;SELECT min(x) FROM t WHERE y IN (?,?,?)&quot; assuming an index on t(x,y).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84a557fad116fe49221d1a9424a92f1e575e49e1" translate="yes" xml:space="preserve">
          <source>Improved performance of queries with many OR-connected terms in the WHERE clause that can all be indexed.</source>
          <target state="translated">Улучшена производительность запросов с большим количеством ИЛИ-связанных терминов в пункте WHERE,которые все могут быть проиндексированы.</target>
        </trans-unit>
        <trans-unit id="fc268c97ccbef9521d6905694e7c21645578065f" translate="yes" xml:space="preserve">
          <source>Improved pthreads detection in configure scripts.</source>
          <target state="translated">Усовершенствованное обнаружение потоков в скриптах конфигураций.</target>
        </trans-unit>
        <trans-unit id="17ac50232b81e80729264e903268e1bebc9e53d7" translate="yes" xml:space="preserve">
          <source>Improved query plan optimization when the DISTINCT keyword is present.</source>
          <target state="translated">Улучшена оптимизация плана запроса при наличии ключевого слова DISTINCT.</target>
        </trans-unit>
        <trans-unit id="59b96d30821cc9cbdef8a394c82f7fd97d223fd7" translate="yes" xml:space="preserve">
          <source>Improved resistance against goofy query planner decisions caused by incomplete or incorrect modifications to the &lt;a href=&quot;fileformat2#stat1tab&quot;&gt;sqlite_stat1&lt;/a&gt; table by the application.</source>
          <target state="translated">Повышена устойчивость к ошибочным решениям планировщика запросов, вызванным неполными или неправильными изменениями таблицы &lt;a href=&quot;fileformat2#stat1tab&quot;&gt;sqlite_stat1&lt;/a&gt; приложением.</target>
        </trans-unit>
        <trans-unit id="6b8ef39e97edafb5ec621a586930697f00cfaa0e" translate="yes" xml:space="preserve">
          <source>Improved response to out-of-memory errors</source>
          <target state="translated">Улучшенная реакция на ошибки вне памяти</target>
        </trans-unit>
        <trans-unit id="5ae15f37694ee149c6eea70b18fae46fd07528e4" translate="yes" xml:space="preserve">
          <source>Improved robustness against corrupt database files.</source>
          <target state="translated">Улучшенная устойчивость к поврежденным файлам базы данных.</target>
        </trans-unit>
        <trans-unit id="166028811fd163330b2455278e9c44de42779fbe" translate="yes" xml:space="preserve">
          <source>Improved support for Cygwin.</source>
          <target state="translated">Улучшенная поддержка Cygwin.</target>
        </trans-unit>
        <trans-unit id="4c53e2cba5a1410927dfe514c0901b0fd71f140c" translate="yes" xml:space="preserve">
          <source>Improved support for using the STDCALL calling convention in winsqlite3.dll.</source>
          <target state="translated">Улучшена поддержка использования соглашения об использовании STDCALL-вызовов в winsqlite3.dll.</target>
        </trans-unit>
        <trans-unit id="92763dc3583bdd282b9026c7f80e9e51775413fc" translate="yes" xml:space="preserve">
          <source>Improved syntax error messages in the parser</source>
          <target state="translated">Улучшенные сообщения об ошибках синтаксиса в синтаксическом анализаторе</target>
        </trans-unit>
        <trans-unit id="35f950df2561f1db8f684a7b33f41fde15c8c04c" translate="yes" xml:space="preserve">
          <source>Improved test coverage</source>
          <target state="translated">Улучшенное тестовое покрытие</target>
        </trans-unit>
        <trans-unit id="6fb91ee1a232fc876617f991f25282c326c1cf11" translate="yes" xml:space="preserve">
          <source>Improved test coverage. Fixed a few obscure bugs found by the improved tests.</source>
          <target state="translated">Улучшенное тестовое покрытие.Исправлено несколько непонятных ошибок,найденных в улучшенных тестах.</target>
        </trans-unit>
        <trans-unit id="5177fb86b97cfe6466bc589640835c3dab84ade3" translate="yes" xml:space="preserve">
          <source>Improved the cost estimation for an index scan which includes a WHERE clause that can be partially or fully evaluated using columns in the index and without having to do a table lookup. This fixes a performance regression that occurred for some obscure queries following the ORDER BY LIMIT optimization introduced in &lt;a href=&quot;#version_3_12_0&quot;&gt;version 3.12.0&lt;/a&gt;.</source>
          <target state="translated">Улучшена оценка стоимости сканирования индекса, которая включает предложение WHERE, которое можно частично или полностью оценить с помощью столбцов в индексе и без необходимости выполнять поиск в таблице. Это устраняет &lt;a href=&quot;#version_3_12_0&quot;&gt;снижение&lt;/a&gt; производительности, которое произошло для некоторых неясных запросов после оптимизации ORDER BY LIMIT, представленной в версии 3.12.0 .</target>
        </trans-unit>
        <trans-unit id="9737446abc238ba64625d047b10e2ea194379924" translate="yes" xml:space="preserve">
          <source>Improved the query planner so that the &lt;a href=&quot;optoverview#or_opt&quot;&gt;OR optimization&lt;/a&gt; can be used on &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt; even if one or more of the disjuncts use the &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt;, &lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt;, &lt;a href=&quot;lang_expr#regexp&quot;&gt;REGEXP&lt;/a&gt;, &lt;a href=&quot;lang_expr#match&quot;&gt;MATCH&lt;/a&gt; operators.</source>
          <target state="translated">Улучшен планировщик запросов, так что &lt;a href=&quot;optoverview#or_opt&quot;&gt;оптимизацию OR&lt;/a&gt; можно использовать для &lt;a href=&quot;vtab&quot;&gt;виртуальных таблиц,&lt;/a&gt; даже если один или несколько дизъюнктов используют &lt;a href=&quot;lang_expr#regexp&quot;&gt;операторы &lt;/a&gt;&lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; , &lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; , REGEXP , &lt;a href=&quot;lang_expr#match&quot;&gt;MATCH&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7c7991b90a25fa494ea7173ba16f41d0e843c78b" translate="yes" xml:space="preserve">
          <source>Improved the windows VFS to better defend against interference from anti-virus software.</source>
          <target state="translated">Улучшены окна VFS для лучшей защиты от помех от антивирусного программного обеспечения.</target>
        </trans-unit>
        <trans-unit id="6c9542942225b685370a9ff791f1911ab55a40d4" translate="yes" xml:space="preserve">
          <source>Improved tracing and debugging facilities in the Windows &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;.</source>
          <target state="translated">Улучшенные средства трассировки и отладки в Windows &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c1ee9a0442382c4cebcfe1b576c0d1fff396e4cb" translate="yes" xml:space="preserve">
          <source>Improved unicode filename handling in the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; on Windows.</source>
          <target state="translated">Улучшена обработка файлов Unicode в &lt;a href=&quot;cli&quot;&gt;оболочке командной строки&lt;/a&gt; в Windows.</target>
        </trans-unit>
        <trans-unit id="09e6f225ca0ca885645a927e0763b14b484dc7f0" translate="yes" xml:space="preserve">
          <source>Improvements and bug-fixes in support for &lt;a href=&quot;compile#omit_floating_point&quot;&gt;SQLITE_OMIT_FLOATING_POINT&lt;/a&gt;.</source>
          <target state="translated">Улучшения и исправления ошибок в поддержке &lt;a href=&quot;compile#omit_floating_point&quot;&gt;SQLITE_OMIT_FLOATING_POINT&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c4b534f7c6c26f504f16d9c38af50fef3ae45002" translate="yes" xml:space="preserve">
          <source>Improvements to &quot;dot-command&quot; handling in the &lt;a href=&quot;cli&quot;&gt;Command Line Interface&lt;/a&gt;.</source>
          <target state="translated">Улучшения в обработке &quot;точечных команд&quot; в &lt;a href=&quot;cli&quot;&gt;интерфейсе командной строки&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="47099268e1cc1a7d37272d0a960d324c9d2e5b20" translate="yes" xml:space="preserve">
          <source>Improvements to &lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt;.</source>
          <target state="translated">Улучшения в &lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="18fe2fab208a9bdfd95bd5b0724b7f338ba76be8" translate="yes" xml:space="preserve">
          <source>Improvements to cost estimates for the &lt;a href=&quot;optoverview#skipscan&quot;&gt;skip-scan optimization&lt;/a&gt;.</source>
          <target state="translated">Улучшения в оценке затрат для &lt;a href=&quot;optoverview#skipscan&quot;&gt;оптимизации пропуска сканирования&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f56d95c4feb425fac688efbe211f20dca39f2585" translate="yes" xml:space="preserve">
          <source>Improvements to rounding behavior, so that the results of rounding binary numbers using the &lt;a href=&quot;lang_corefunc#round&quot;&gt;round()&lt;/a&gt; function are closer to what people who are used to thinking in decimal actually expect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5353c2af79675cc29c5733088967c970c2cbd2d3" translate="yes" xml:space="preserve">
          <source>Improvements to test coverage, other minor bugs fixed, memory leaks plugged, code refactored and/or recommended in places for easier reading.</source>
          <target state="translated">Улучшения в тестировании покрытия,исправлены другие незначительные ошибки,устранена утечка памяти,код восстановлен и/или рекомендован в местах для более легкого чтения.</target>
        </trans-unit>
        <trans-unit id="1672d028ed8042c2cdc755bd4feb4bfb1a305542" translate="yes" xml:space="preserve">
          <source>Improvements to the &quot;.help&quot; command.</source>
          <target state="translated">Улучшения в команде &quot;.help&quot;.</target>
        </trans-unit>
        <trans-unit id="9829e00db8ef5babdf62ad53520c9aed14ba5d0e" translate="yes" xml:space="preserve">
          <source>Improvements to the &quot;PRAGMA integrity_check&quot; command</source>
          <target state="translated">Улучшения команды &quot;PRAGMA integrity_check&quot;.</target>
        </trans-unit>
        <trans-unit id="e5c25ee1584b55a6798dccb371f9de65d6e26320" translate="yes" xml:space="preserve">
          <source>Improvements to the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt;:</source>
          <target state="translated">Улучшения &lt;a href=&quot;cli&quot;&gt;оболочки командной строки&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="7bd7a08c86f6e2927260bf75b7f206267bdb5a66" translate="yes" xml:space="preserve">
          <source>Improvements to the &lt;a href=&quot;cli#recover&quot;&gt;.recover dot-command&lt;/a&gt; in the &lt;a href=&quot;cli&quot;&gt;CLI&lt;/a&gt; so that it recovers more content from corrupt database files.</source>
          <target state="translated">Усовершенствования &lt;a href=&quot;cli#recover&quot;&gt;команды точки .recover&lt;/a&gt; в &lt;a href=&quot;cli&quot;&gt;интерфейсе &lt;/a&gt;командной строки, чтобы она восстанавливала больше содержимого из поврежденных файлов базы данных.</target>
        </trans-unit>
        <trans-unit id="56bedeb29e748e173925f592478fb7224bd2a9a7" translate="yes" xml:space="preserve">
          <source>Improvements to the &lt;a href=&quot;fts3#*fts4automergecmd&quot;&gt;automerge command&lt;/a&gt; of &lt;a href=&quot;fts3#fts4&quot;&gt;FTS4&lt;/a&gt; to better control the index size for a full-text index that is subject to a large number of updates.</source>
          <target state="translated">Улучшения в &lt;a href=&quot;fts3#*fts4automergecmd&quot;&gt;команду automerge&lt;/a&gt; из &lt;a href=&quot;fts3#fts4&quot;&gt;FTS4&lt;/a&gt; , чтобы лучше контролировать размер индекса для полнотекстового индекса , который является предметом большого количества обновлений.</target>
        </trans-unit>
        <trans-unit id="4f8a0d7434e9fa0e3d93bd594ec2f731beeeee4c" translate="yes" xml:space="preserve">
          <source>Improvements to the &lt;a href=&quot;optoverview&quot;&gt;query planner&lt;/a&gt;:</source>
          <target state="translated">Улучшения в &lt;a href=&quot;optoverview&quot;&gt;планировщике запросов&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="64a384308e143ce85fad7f48be7bf89bd88826a0" translate="yes" xml:space="preserve">
          <source>Improvements to the &lt;a href=&quot;syntaxdiagrams&quot;&gt;syntax bubble diagrams&lt;/a&gt;</source>
          <target state="translated">Улучшения &lt;a href=&quot;syntaxdiagrams&quot;&gt;синтаксических пузырьковых диаграмм&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="444f392b3ac06b6a270033461a34681437b33fc9" translate="yes" xml:space="preserve">
          <source>Improvements to the Makefiles and build scripts used by VisualStudio.</source>
          <target state="translated">Усовершенствования Makefiles и скриптов сборки,используемых VisualStudio.</target>
        </trans-unit>
        <trans-unit id="187c307e740f14eb7715914261b63385a7891140" translate="yes" xml:space="preserve">
          <source>Improvements to the amalgamation generator script so that all symbols are prefixed with either SQLITE_PRIVATE or SQLITE_API.</source>
          <target state="translated">Улучшен скрипт генератора слияний,так что все символы префиксованы либо SQLITE_PRIVATE,либо SQLITE_API.</target>
        </trans-unit>
        <trans-unit id="8487f548381bd47de49bbe554c9e3c26fcef5a1f" translate="yes" xml:space="preserve">
          <source>Improvements to the comments in the VDBE byte-code display when running &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt;.</source>
          <target state="translated">Улучшения комментариев в отображении байтового кода VDBE при запуске &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e6a8494de38f18f2b5e148ff117a682e5366a648" translate="yes" xml:space="preserve">
          <source>Improvements to the effectiveness and accuracy of the &lt;a href=&quot;lang_corefunc#likelihood&quot;&gt;likelihood()&lt;/a&gt;, &lt;a href=&quot;lang_corefunc#likely&quot;&gt;likely()&lt;/a&gt;, and &lt;a href=&quot;lang_corefunc#unlikely&quot;&gt;unlikely()&lt;/a&gt; SQL hint functions.</source>
          <target state="translated">Повышение эффективности и точности подсказок SQL-функций &lt;a href=&quot;lang_corefunc#likelihood&quot;&gt;правдоподобия ()&lt;/a&gt; , &lt;a href=&quot;lang_corefunc#likely&quot;&gt;вероятно ()&lt;/a&gt; и &lt;a href=&quot;lang_corefunc#unlikely&quot;&gt;маловероятно ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fb078db70835b73a43d340944c34ddf931e04436" translate="yes" xml:space="preserve">
          <source>Improvements to the handling of CSV inputs in the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt;</source>
          <target state="translated">Улучшения обработки входных данных CSV в &lt;a href=&quot;cli&quot;&gt;оболочке командной строки.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="35621122cb25f12ea29297b200f9cd7f54653df0" translate="yes" xml:space="preserve">
          <source>Improvements to the query planner so that it makes better estimates of plan costs and hence does a better job of choosing the right plan, especially when &lt;a href=&quot;compile#enable_stat2&quot;&gt;SQLITE_ENABLE_STAT2&lt;/a&gt; is used.</source>
          <target state="translated">Улучшения в планировщике запросов, чтобы он лучше оценивал плановые затраты и, следовательно, лучше справлялся с выбором правильного плана, особенно при использовании &lt;a href=&quot;compile#enable_stat2&quot;&gt;SQLITE_ENABLE_STAT2&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b56408ef9cd6514cec8e529db1c7c154a8214dac" translate="yes" xml:space="preserve">
          <source>Improvements to the windows makefiles and build processes.</source>
          <target state="translated">Улучшения в создании оконных файлов и процессах сборки.</target>
        </trans-unit>
        <trans-unit id="01c7395c54005792d7fd39d556adb0b44131f473" translate="yes" xml:space="preserve">
          <source>In &quot;column&quot; mode (and also in &quot;box&quot;, &quot;table&quot;, and &quot;markdown&quot; modes) the width of columns adjusts automatically. But you can override this, providing a minimum width for each column using the &quot;.width&quot; command. The arguments to &quot;.width&quot; are integers which are the minimum number of spaces to devote to each column. Negative numbers mean right-justify. Thus:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b24a3b4f842f4beb9d0cf338bd2105050638be32" translate="yes" xml:space="preserve">
          <source>In &quot;line&quot; mode, each column in a row of the database is shown on a line by itself. Each line consists of the column name, an equal sign and the column data. Successive records are separated by a blank line. Here is an example of line mode output:</source>
          <target state="translated">В режиме &quot;строка&quot; каждый столбец в строке БД отображается на строке сам по себе.Каждая строка состоит из названия столбца,знака равенства и данных столбца.Последующие записи разделены пустой строкой.Приведем пример вывода в &quot;строчном&quot; режиме:</target>
        </trans-unit>
        <trans-unit id="ba464cb54f172ce24a6d088a3cb06af2c611f784" translate="yes" xml:space="preserve">
          <source>In &quot;quote&quot; mode, the output is formatted as SQL literals. Strings are enclosed in single-quotes and internal single-quotes are escaped by doubling. Blobs are displayed in hexadecimal blob literal notation (Ex: x'abcd'). Numbers are displayed as ASCII text and NULL values are shown as &quot;NULL&quot;. All columns are separated from each other by a comma (or whatever alternative character is selected using &quot;.separator&quot;).</source>
          <target state="translated">В режиме &quot;кавычки&quot; вывод форматируется как SQL-литералы.Строки заключены в одинарные кавычки,а внутренние одинарные кавычки экранированы удвоением.Капли выводятся в шестнадцатеричной блочной литературной нотации (Ex:x'abcd').Цифры отображаются в виде ASCII текста,а NULL значения отображаются в виде &quot;NULL&quot;.Все столбцы отделены друг от друга запятой (или любым другим альтернативным символом,выбранным с помощью &quot;.разделителя&quot;).</target>
        </trans-unit>
        <trans-unit id="e70135d1b4c87e02724b6a6725f67c0cdcedb6a8" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;../wal&quot;&gt;WAL mode&lt;/a&gt;, multiple &lt;a href=&quot;sqlite3&quot;&gt;database connections&lt;/a&gt; that are open on the same database file can each be reading a different historical version of the database file. When a &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; begins a read transaction, that connection sees an unchanging copy of the database as it existed for the point in time when the transaction first started. Subsequent changes to the database from other connections are not seen by the reader until a new read transaction is started.</source>
          <target state="translated">В &lt;a href=&quot;../wal&quot;&gt;режиме WAL&lt;/a&gt; несколько &lt;a href=&quot;sqlite3&quot;&gt;соединений с базой данных&lt;/a&gt; , открытых для одного и того же файла базы данных, могут читать разные исторические версии файла базы данных. Когда &lt;a href=&quot;sqlite3&quot;&gt;соединение&lt;/a&gt; с базой данных начинает транзакцию чтения, это соединение видит неизменную копию базы данных в том виде, в котором она существовала на момент первого запуска транзакции. Последующие изменения в базе данных из других подключений не видны читателю, пока не будет запущена новая транзакция чтения.</target>
        </trans-unit>
        <trans-unit id="545faac3a749c9fbe686ac2c42b0a8ce0746bb4b" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;https://sqlite.org/releaselog/3_5_0.html&quot;&gt;version 3.5.0&lt;/a&gt; (2007-09-04), shared-cache mode was modified so that the same cache can be shared across an entire process rather than just within a single thread. Prior to this change, there were restrictions on passing database connections between threads. Those restrictions were dropped in 3.5.0 update. This document describes shared-cache mode as of version 3.5.0.</source>
          <target state="translated">В &lt;a href=&quot;https://sqlite.org/releaselog/3_5_0.html&quot;&gt;версии 3.5.0&lt;/a&gt; (2007-09-04) режим общего кэша был изменен таким образом, что один и тот же кеш может использоваться для всего процесса, а не только в пределах одного потока. До этого изменения существовали ограничения на передачу соединений с базой данных между потоками. Эти ограничения были сняты в обновлении 3.5.0. В этом документе описан режим общего кэша версии 3.5.0.</target>
        </trans-unit>
        <trans-unit id="8b22aada76f514795f041039b72ce60807690314" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode=TRUNCATE&lt;/a&gt; mode, call fsync() immediately after truncating the journal file to ensure that the transaction is durable across a power loss.</source>
          <target state="translated">В режиме &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode = TRUNCATE&lt;/a&gt; вызовите fsync () сразу после усечения файла журнала, чтобы гарантировать, что транзакция будет устойчивой при потере питания.</target>
        </trans-unit>
        <trans-unit id="b06cad3e4dffb16827f43add94eb56f4465695b9" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;sharedcache&quot;&gt;shared cache mode&lt;/a&gt;, attempting to attach the same database file more than once results in an error.</source>
          <target state="translated">В &lt;a href=&quot;sharedcache&quot;&gt;режиме общего кеша&lt;/a&gt; попытка подключить один и тот же файл базы данных более одного раза приводит к ошибке.</target>
        </trans-unit>
        <trans-unit id="9f41922c2aa21a0c294b4cbf9d4bf48e3b8e9e1c" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt;, if a writer crashes and leaves the &lt;a href=&quot;walformat#shm&quot;&gt;shm file&lt;/a&gt; in an inconsistent state, subsequent transactions are now able to recover the shm file even if there are active read transactions. Before this enhancement, shm file recovery that scenario would result in an &lt;a href=&quot;rescode#protocol&quot;&gt;SQLITE_PROTOCOL&lt;/a&gt; error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d45c296410a6677088e7e7ac84b1e93a1f22edc" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt;, multiple &lt;a href=&quot;#sqlite3&quot;&gt;database connections&lt;/a&gt; that are open on the same database file can each be reading a different historical version of the database file. When a &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; begins a read transaction, that connection sees an unchanging copy of the database as it existed for the point in time when the transaction first started. Subsequent changes to the database from other connections are not seen by the reader until a new read transaction is started.</source>
          <target state="translated">В &lt;a href=&quot;wal&quot;&gt;режиме WAL&lt;/a&gt; несколько &lt;a href=&quot;#sqlite3&quot;&gt;соединений с базой данных&lt;/a&gt; , открытых для одного и того же файла базы данных, могут читать разные исторические версии файла базы данных. Когда &lt;a href=&quot;#sqlite3&quot;&gt;соединение&lt;/a&gt; с базой данных начинает транзакцию чтения, это соединение видит неизменную копию базы данных в том виде, в котором она существовала на момент первого запуска транзакции. Последующие изменения в базе данных из других подключений не видны читателю, пока не будет запущена новая транзакция чтения.</target>
        </trans-unit>
        <trans-unit id="ddd420dd1a1ef7aee27736d7c043708aacde1ceb" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;wal&quot;&gt;WAL&lt;/a&gt; mode when synchronous is NORMAL (1), the WAL file is synchronized before each &lt;a href=&quot;wal#ckpt&quot;&gt;checkpoint&lt;/a&gt; and the database file is synchronized after each completed &lt;a href=&quot;wal#ckpt&quot;&gt;checkpoint&lt;/a&gt; and the WAL file header is synchronized when a WAL file begins to be reused after a checkpoint, but no sync operations occur during most transactions. With synchronous=FULL in WAL mode, an additional sync operation of the WAL file happens after each transaction commit. The extra WAL sync following each transaction help ensure that transactions are durable across a power loss. Transactions are consistent with or without the extra syncs provided by synchronous=FULL. If durability is not a concern, then synchronous=NORMAL is normally all one needs in WAL mode.</source>
          <target state="translated">В режиме &lt;a href=&quot;wal&quot;&gt;WAL,&lt;/a&gt; когда синхронный - NORMAL (1), файл WAL синхронизируется перед каждой &lt;a href=&quot;wal#ckpt&quot;&gt;контрольной точкой,&lt;/a&gt; а файл базы данных синхронизируется после каждой завершенной &lt;a href=&quot;wal#ckpt&quot;&gt;контрольной точки,&lt;/a&gt; а заголовок файла WAL синхронизируется, когда файл WAL начинает повторно использоваться после контрольной точки, но нет операции синхронизации происходят во время большинства транзакций. При synchronous = FULL в режиме WAL дополнительная операция синхронизации файла WAL происходит после каждой фиксации транзакции. Дополнительная синхронизация WAL после каждой транзакции помогает гарантировать долговечность транзакций при отключении питания. Транзакции согласуются с дополнительными синхронизациями, обеспечиваемыми параметром synchronous = FULL, или без них. Если долговечность не имеет значения, то в режиме WAL обычно достаточно synchronous = NORMAL.</target>
        </trans-unit>
        <trans-unit id="5a4b7cd3ba1686efa11d9b9c015db21adcf22977" translate="yes" xml:space="preserve">
          <source>In CHECK constraints of a table definition.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1207ec4eb27468881c3e5a75c509547ec16346af" translate="yes" xml:space="preserve">
          <source>In DDL</source>
          <target state="translated">В ЦБТ</target>
        </trans-unit>
        <trans-unit id="06bb676fb43ba64638eb5aba12a8d226fa52bf86" translate="yes" xml:space="preserve">
          <source>In DEFAULT constraints of a table definition.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fc22d3edb7a25933470b0fc98cd018feb112e2e" translate="yes" xml:space="preserve">
          <source>In DML</source>
          <target state="translated">В DML</target>
        </trans-unit>
        <trans-unit id="805c25b267572c14bae2116b6611f039f1f80c5c" translate="yes" xml:space="preserve">
          <source>In I/O error tests, after the I/O error simulation failure mechanism is disabled, the database is examined using &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt; to make sure that the I/O error has not introduced database corruption.</source>
          <target state="translated">В тестах ошибок ввода-вывода после того, как механизм сбоя моделирования ошибок ввода-вывода отключен, база данных проверяется с помощью &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integration_check,&lt;/a&gt; чтобы убедиться, что ошибка ввода-вывода не привела к повреждению базы данных.</target>
        </trans-unit>
        <trans-unit id="0f2cfcdcfc92b4b01bee8dec645ecb5ceaaa8098" translate="yes" xml:space="preserve">
          <source>In Lemon, the tokenizer calls the parser. Yacc operates the other way around, with the parser calling the tokenizer. The Lemon approach is reentrant and threadsafe, whereas Yacc uses global variables and is therefore neither. Reentrancy is especially important for SQLite since some SQL statements make recursive calls to the parser. For example, when parsing a CREATE TABLE statement, SQLite invokes the parser recursively to generate an INSERT statement to make a new entry in the &lt;a href=&quot;fileformat2#sqlite_master&quot;&gt;sqlite_master&lt;/a&gt; table.</source>
          <target state="translated">В Lemon токенизатор вызывает парсер. Yacc работает наоборот, парсер вызывает токенизатор. Подход Lemon является реентерабельным и потокобезопасным, тогда как Yacc использует глобальные переменные и поэтому ни то, ни другое. Повторный вход особенно важен для SQLite, поскольку некоторые операторы SQL рекурсивно обращаются к синтаксическому анализатору. Например, при синтаксическом анализе оператора CREATE TABLE SQLite рекурсивно вызывает синтаксический анализатор для генерации оператора INSERT для создания новой записи в таблице &lt;a href=&quot;fileformat2#sqlite_master&quot;&gt;sqlite_master&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="830b24ce26b7fcd4a09816d124ab8737256342ba" translate="yes" xml:space="preserve">
          <source>In Lemon, the tokenizer calls the parser. Yacc operates the other way around, with the parser calling the tokenizer. The Lemon approach is reentrant and threadsafe, whereas Yacc uses global variables and is therefore neither. Reentrancy is especially important for SQLite since some SQL statements make recursive calls to the parser. For example, when parsing a CREATE TABLE statement, SQLite invokes the parser recursively to generate an INSERT statement to make a new entry in the &lt;a href=&quot;schematab&quot;&gt;sqlite_schema&lt;/a&gt; table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3369588aeb6a765cf20a5709a06e66a042c401f" translate="yes" xml:space="preserve">
          <source>In NORMAL locking-mode (the default unless overridden at compile-time using &lt;a href=&quot;compile#default_locking_mode&quot;&gt;SQLITE_DEFAULT_LOCKING_MODE&lt;/a&gt;), a database connection unlocks the database file at the conclusion of each read or write transaction. When the locking-mode is set to EXCLUSIVE, the database connection never releases file-locks. The first time the database is read in EXCLUSIVE mode, a shared lock is obtained and held. The first time the database is written, an exclusive lock is obtained and held.</source>
          <target state="translated">В НОРМАЛЬНОМ режиме блокировки (по умолчанию, если он не переопределен во время компиляции с помощью &lt;a href=&quot;compile#default_locking_mode&quot;&gt;SQLITE_DEFAULT_LOCKING_MODE&lt;/a&gt; ), соединение с базой данных разблокирует файл базы данных при завершении каждой транзакции чтения или записи. Когда для режима блокировки установлено значение EXCLUSIVE, соединение с базой данных никогда не снимает блокировки файлов. При первом чтении базы данных в ЭКСКЛЮЗИВНОМ режиме получается и удерживается разделяемая блокировка. При первой записи в базу данных получается и удерживается исключительная блокировка.</target>
        </trans-unit>
        <trans-unit id="f8c693ba3fad2e1d7df97dd42327c19b66a284bb" translate="yes" xml:space="preserve">
          <source>In SQLite</source>
          <target state="translated">В SQLite</target>
        </trans-unit>
        <trans-unit id="e298a84cbd8720f440fc21a95dd67ebcefa40857" translate="yes" xml:space="preserve">
          <source>In SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_10_0.html&quot;&gt;version 3.10.0&lt;/a&gt; (2016-01-06) and later, the colUsed field is available to indicate which fields of the virtual table are actually used by the statement being prepared. If the lowest bit of colUsed is set, that means that the first column is used. The second lowest bit corresponds to the second column. And so forth. If the most significant bit of colUsed is set, that means that one or more columns other than the first 63 columns are used. If column usage information is needed by the &lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter&lt;/a&gt; method, then the required bits must be encoded into either the idxNum or idxStr output fields.</source>
          <target state="translated">В SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_10_0.html&quot;&gt;версии 3.10.0&lt;/a&gt; (2016-01-06) и более поздних версиях доступно поле colUsed, чтобы указать, какие поля виртуальной таблицы фактически используются подготавливаемым оператором. Если установлен младший бит colUsed, это означает, что используется первый столбец. Второй младший бит соответствует второму столбцу. И так далее. Если установлен самый старший бит colUsed, это означает, что используются один или несколько столбцов, кроме первых 63 столбцов. Если методу &lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter&lt;/a&gt; требуется информация об использовании столбца , то требуемые биты должны быть закодированы в выходные поля idxNum или idxStr.</target>
        </trans-unit>
        <trans-unit id="828bdde156beec9d0455bf5a047ac9dedf77b343" translate="yes" xml:space="preserve">
          <source>In SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_28_0.html&quot;&gt;version 3.28.0&lt;/a&gt; (2019-04-16), windows function support was extended to include the EXCLUDE clause, GROUPS frame types, window chaining, and support for &quot;&amp;lt;expr&amp;gt; PRECEDING&quot; and &quot;&amp;lt;expr&amp;gt; FOLLOWING&quot; boundaries in RANGE frames.</source>
          <target state="translated">В SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_28_0.html&quot;&gt;версии 3.28.0&lt;/a&gt; (2019-04-16) поддержка функций Windows была расширена за счет включения предложения EXCLUDE, типов фреймов GROUPS, цепочки окон и поддержки границ &amp;laquo;&amp;lt;expr&amp;gt; PRECEDING&amp;raquo; и &amp;laquo;&amp;lt;expr&amp;gt; FOLLOWING&amp;raquo; в ДИАПАЗОН кадров.</target>
        </trans-unit>
        <trans-unit id="7a9dbb486e8961eb98612eeeff0292e2cdc9f06c" translate="yes" xml:space="preserve">
          <source>In SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_6_23_1.html&quot;&gt;version 3.6.23.1&lt;/a&gt; (2010-03-26) and earlier, &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; used to always return &lt;a href=&quot;rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt; if it was invoked again after returning anything other than &lt;a href=&quot;rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt; without an intervening call to &lt;a href=&quot;c3ref/reset&quot;&gt;sqlite3_reset()&lt;/a&gt;. This caused problems on some poorly written smartphone applications which did not correctly handle the &lt;a href=&quot;rescode#locked&quot;&gt;SQLITE_LOCKED&lt;/a&gt; and &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; error returns. Rather than fix the many defective smartphone applications, the behavior of SQLite was changed in 3.6.23.2 to automatically reset the prepared statement. But that changed caused issues in other improperly implemented applications that were actually looking for an &lt;a href=&quot;rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt; return to terminate their query loops. (Anytime an application gets an SQLITE_MISUSE error code from SQLite, that means the application is misusing the SQLite interface and is thus incorrectly implemented.) The SQLITE_OMIT_AUTORESET interface was added to SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_5.html&quot;&gt;version 3.7.5&lt;/a&gt; (2011-02-01) in an effort to get all of the (broken) applications to work again without having to actually fix the applications.</source>
          <target state="translated">В &lt;a href=&quot;https://sqlite.org/releaselog/3_6_23_1.html&quot;&gt;версии&lt;/a&gt; SQLite 3.6.23.1 (2010-03-26) и ранее &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step ()&lt;/a&gt; всегда возвращал &lt;a href=&quot;rescode#misuse&quot;&gt;SQLITE_MISUSE,&lt;/a&gt; если он был вызван снова после возврата чего-либо, кроме &lt;a href=&quot;rescode#row&quot;&gt;SQLITE_ROW,&lt;/a&gt; без промежуточного вызова &lt;a href=&quot;c3ref/reset&quot;&gt;sqlite3_reset ()&lt;/a&gt; . Это вызывало проблемы в некоторых плохо написанных приложениях для смартфонов, которые некорректно обрабатывали &lt;a href=&quot;rescode#locked&quot;&gt;ошибки SQLITE_LOCKED&lt;/a&gt; и &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; . Вместо исправления многих дефектных приложений для смартфонов в 3.6.23.2 было изменено поведение SQLite для автоматического сброса подготовленного оператора. Но это изменение вызвало проблемы в других неправильно реализованных приложениях, которые фактически искали &lt;a href=&quot;rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt;вернуться, чтобы завершить цикл запросов. (Каждый раз, когда приложение получает код ошибки SQLITE_MISUSE от SQLite, это означает, что приложение неправильно использует интерфейс SQLite и, таким образом, неправильно реализовано.) Интерфейс SQLITE_OMIT_AUTORESET был добавлен в SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_5.html&quot;&gt;версии 3.7.5&lt;/a&gt; (01.02.2011) в попытке исправить заставить все (сломанные) приложения снова работать без необходимости исправлять приложения.</target>
        </trans-unit>
        <trans-unit id="69f5fb95e32697faf43d50fb7301e963589e0bce" translate="yes" xml:space="preserve">
          <source>In SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_0.html&quot;&gt;version 3.8.0&lt;/a&gt; (2013-08-26) and later, an &lt;a href=&quot;rescode#warning_autoindex&quot;&gt;SQLITE_WARNING_AUTOINDEX&lt;/a&gt; message is sent to the &lt;a href=&quot;errlog&quot;&gt;error log&lt;/a&gt; every time a statement is prepared that uses an automatic index. Application developers can and should use these warnings to identify the need for new persistent indexes in the schema.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae75dbb8c6b830d21fb52ab24e85cf97f8c0d055" translate="yes" xml:space="preserve">
          <source>In SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_0.html&quot;&gt;version 3.8.0&lt;/a&gt; (2013-08-26) and later, an &lt;a href=&quot;rescode#warning_autoindex&quot;&gt;SQLITE_WARNING_AUTOINDEX&lt;/a&gt; message is sent to the &lt;a href=&quot;errlog&quot;&gt;error log&lt;/a&gt; every time a statement is prepared that uses an automatic index. Application developers can and should use these warnings to identify the need for new persistent indices in the schema.</source>
          <target state="translated">В SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_0.html&quot;&gt;версии 3.8.0&lt;/a&gt; (2013-08-26) и более поздних &lt;a href=&quot;rescode#warning_autoindex&quot;&gt;версий&lt;/a&gt; сообщение SQLITE_WARNING_AUTOINDEX отправляется в &lt;a href=&quot;errlog&quot;&gt;журнал ошибок&lt;/a&gt; каждый раз, когда подготавливается инструкция, использующая автоматический индекс. Разработчики приложений могут и должны использовать эти предупреждения для определения потребности в новых постоянных индексах в схеме.</target>
        </trans-unit>
        <trans-unit id="311b836bebf13bf229bfb5d427d7d61edb397191" translate="yes" xml:space="preserve">
          <source>In SQLite Version 3</source>
          <target state="translated">В SQLite версии 3</target>
        </trans-unit>
        <trans-unit id="44b0d77bd3716352e42cf5f2569dabd7987b859f" translate="yes" xml:space="preserve">
          <source>In SQLite version 2</source>
          <target state="translated">В SQLite версии 2</target>
        </trans-unit>
        <trans-unit id="ab1b358df4951321dec42436274a7fc7055620c8" translate="yes" xml:space="preserve">
          <source>In SQLite version 2, if many processes are reading from the database, it might be the case that there is never a time when there are no active readers. And if there is always at least one read lock on the database, no process would ever be able to make changes to the database because it would be impossible to acquire a write lock. This situation is called &lt;em&gt;writer starvation&lt;/em&gt;.</source>
          <target state="translated">В SQLite версии 2, если многие процессы читают из базы данных, может случиться так, что никогда не бывает времени, когда нет активных читателей. И если в базе данных всегда есть хотя бы одна блокировка чтения, ни один процесс никогда не сможет внести изменения в базу данных, потому что было бы невозможно получить блокировку записи. Эта ситуация называется &lt;em&gt;писательским голодом&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="0e7545ebfe6eb34f26f31fe8304f6f550663c8e8" translate="yes" xml:space="preserve">
          <source>In SQLite version 3, the sqlite3_exec routine is just a wrapper around calls to the prepared statement interface.</source>
          <target state="translated">В SQLite версии 3 рутина sqlite3_exec-это просто обёртка вокруг вызовов подготовленного интерфейса оператора.</target>
        </trans-unit>
        <trans-unit id="e7a56207acc60b29c6f42211f54c5ca8f6e54fa3" translate="yes" xml:space="preserve">
          <source>In SQLite version 3.0, the rowid is a 64-bit signed integer. This is an expansion of SQLite version 2.8 which only permitted rowids of 32-bits.</source>
          <target state="translated">В SQLite версии 3.0 rowid представляет собой 64-битное целое число с цифровой подписью.Это расширение SQLite версии 2.8,которое разрешает использовать только рядки из 32 бит.</target>
        </trans-unit>
        <trans-unit id="eade6a0b14d85e68f1dde5969cd3e571c5e3e4f6" translate="yes" xml:space="preserve">
          <source>In SQLite version 3.5.0 and 3.5.1, it was possible to define the SQLITE_OMIT_MEMORY_ALLOCATION which would cause the built-in implementation of these routines to be omitted. That capability is no longer provided. Only built-in memory allocators can be used.</source>
          <target state="translated">В SQLite версий 3.5.0 и 3.5.1 можно было определить SQLITE_OMIT_MEMORY_ALLOCATION,что приведет к тому,что встроенная реализация этих подпрограмм будет опущена.Эта возможность больше не предоставляется.Можно использовать только встроенные аллокаторы памяти.</target>
        </trans-unit>
        <trans-unit id="7278a0046b6c686e7491a606645054d45ac6a9da" translate="yes" xml:space="preserve">
          <source>In SQLite versions 3.3.0 through 3.4.2 when shared-cache mode is enabled, a database connection may only be used by the thread that called &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt; to create it. And a connection could only share cache with another connection in the same thread. These restrictions were dropped beginning with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_5_0.html&quot;&gt;version 3.5.0&lt;/a&gt; (2007-09-04).</source>
          <target state="translated">В версиях SQLite с 3.3.0 по 3.4.2, когда включен режим общего кэша, соединение с базой данных может использоваться только тем потоком, который вызвал &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open ()&lt;/a&gt; для его создания. И соединение могло совместно использовать кеш только с другим соединением в том же потоке. Эти ограничения были сняты, начиная с &lt;a href=&quot;https://sqlite.org/releaselog/3_5_0.html&quot;&gt;версии&lt;/a&gt; SQLite 3.5.0 (2007-09-04).</target>
        </trans-unit>
        <trans-unit id="4af0e6be92f4dba4280a2c7e3664bbca74929393" translate="yes" xml:space="preserve">
          <source>In SQLite, a column with type INTEGER PRIMARY KEY is an alias for the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt; (except in &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables) which is always a 64-bit signed integer.</source>
          <target state="translated">В SQLite столбец с типом INTEGER PRIMARY KEY является псевдонимом для &lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt; (кроме таблиц &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; ), который всегда является 64-битным целым числом со знаком .</target>
        </trans-unit>
        <trans-unit id="d48f1e4d1dbe48d61b2a0bc14d1d629523402032" translate="yes" xml:space="preserve">
          <source>In SQLite, a database object (a table, index, trigger or view) is identified by the name of the object and the name of the database that it resides in. Database objects may reside in the main database, the temp database, or in an &lt;a href=&quot;lang_attach&quot;&gt;attached database&lt;/a&gt;.</source>
          <target state="translated">В SQLite объект базы данных (таблица, индекс, триггер или представление) идентифицируется по имени объекта и имени базы данных, в которой он находится. Объекты базы данных могут находиться в основной базе данных, временной базе данных или в &lt;a href=&quot;lang_attach&quot;&gt;прилагается база данных&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5d037fc285a8e821543df8fc13d9f7837388fd3a" translate="yes" xml:space="preserve">
          <source>In SQLite, table rows normally have a 64-bit signed integer &lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt; which is unique among all rows in the same table. (&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables are the exception.)</source>
          <target state="translated">В SQLite строки таблицы обычно имеют 64-разрядное целое число со &lt;a href=&quot;lang_createtable#rowid&quot;&gt;знаком ROWID,&lt;/a&gt; которое уникально среди всех строк в одной таблице. ( &lt;a href=&quot;withoutrowid&quot;&gt;Исключение составляют&lt;/a&gt; таблицы БЕЗ ROWID .)</target>
        </trans-unit>
        <trans-unit id="fe38d7c32db7d9028a7337d49fe5d30adb864ee5" translate="yes" xml:space="preserve">
          <source>In SQLite, the answer to the previous question is &quot;no&quot;. For testing purposes, the SQLite source code defines macros called ALWAYS() and NEVER(). The ALWAYS() macro surrounds conditions which are expected to always evaluate as true and NEVER() surrounds conditions that are always evaluated to false. These macros serve as comments to indicate that the conditions are defensive code. In release builds, these macros are pass-throughs:</source>
          <target state="translated">В SQLite ответ на предыдущий вопрос-&quot;нет&quot;.Для тестовых целей в исходном коде SQLite определены макросы с именами ALWAYS()и NEVER().Макрос ALWAYS()окружает условия,которые,как ожидается,всегда будут оцениваться как true и NEVER()окружает условия,которые всегда будут оцениваться как false.Эти макросы служат комментариями,указывающими на то,что условия являются защитным кодом.В сборках релизов эти макросы являются проходными:</target>
        </trans-unit>
        <trans-unit id="f43676df6968c4bb63677e4842db7886283fb3e7" translate="yes" xml:space="preserve">
          <source>In SQLite, the presence of assert(X) means that the developers have a proof that X is always true. Readers can depend upon X being true to help them reason about the code. An assert(X) is a strong statement about the truth of X. There is no doubt.</source>
          <target state="translated">В SQLite наличие assert(X)означает,что у разработчиков есть доказательство того,что X всегда верен.Читатели могут полагаться на то,что X верен,чтобы помочь им рассуждать о коде.Утверждение(X)является сильным утверждением об истинности Х.Нет никаких сомнений.</target>
        </trans-unit>
        <trans-unit id="afc867db69a6f0ff03a7d5c74a860a19b5e1f763" translate="yes" xml:space="preserve">
          <source>In WAL mode, changes to the database are detected using the wal-index and so the change counter is not needed. Hence, the change counter might not be incremented on each transaction in WAL mode.</source>
          <target state="translated">В режиме WAL изменения в базе данных определяются с помощью wal-index,поэтому счетчик изменений не нужен.Следовательно,в режиме WAL счетчик изменений может не увеличиваться на каждую транзакцию.</target>
        </trans-unit>
        <trans-unit id="56b4d5a656b5f1cb948b72fc909adc62f6fce99b" translate="yes" xml:space="preserve">
          <source>In a &lt;a href=&quot;lang_select#compound&quot;&gt;compound SELECT&lt;/a&gt; statement, all ORDER BY expressions are handled as aliases for one of the result columns of the compound. If an ORDER BY expression is not an integer alias, then SQLite searches the left-most SELECT in the compound for a result column that matches either the second or third rules above. If a match is found, the search stops and the expression is handled as an alias for the result column that it has been matched against. Otherwise, the next SELECT to the right is tried, and so on. If no matching expression can be found in the result columns of any constituent SELECT, it is an error. Each term of the ORDER BY clause is processed separately and may be matched against result columns from different SELECT statements in the compound.</source>
          <target state="translated">В &lt;a href=&quot;lang_select#compound&quot;&gt;составном операторе SELECT&lt;/a&gt; все выражения ORDER BY обрабатываются как псевдонимы для одного из столбцов результата составного. Если выражение ORDER BY не является целочисленным псевдонимом, то SQLite ищет в крайнем левом SELECT в соединении столбец результата, который соответствует второму или третьему правилу выше. Если совпадение найдено, поиск останавливается, и выражение обрабатывается как псевдоним для столбца результатов, с которым оно было сопоставлено. В противном случае выполняется попытка следующего выбора справа и так далее. Если в столбцах результатов какого-либо составного SELECT не может быть найдено ни одного соответствующего выражения, это является ошибкой. Каждый член предложения ORDER BY обрабатывается отдельно и может сравниваться с столбцами результатов из разных операторов SELECT в составе.</target>
        </trans-unit>
        <trans-unit id="7e23feed60f0ebed492861c5dd540e487916faa3" translate="yes" xml:space="preserve">
          <source>In a &lt;a href=&quot;lang_select#compound&quot;&gt;compound SELECT&lt;/a&gt; statement, only the last or right-most &lt;a href=&quot;lang_select#simpleselect&quot;&gt;simple SELECT&lt;/a&gt; may have an ORDER BY clause. That ORDER BY clause will apply across all elements of the compound. If the right-most element of a &lt;a href=&quot;lang_select#compound&quot;&gt;compound SELECT&lt;/a&gt; is a &lt;a href=&quot;lang_select#values&quot;&gt;VALUES&lt;/a&gt; clause, then no ORDER BY clause is allowed on that statement.</source>
          <target state="translated">В &lt;a href=&quot;lang_select#compound&quot;&gt;составном операторе SELECT&lt;/a&gt; только последний или самый правый &lt;a href=&quot;lang_select#simpleselect&quot;&gt;простой SELECT&lt;/a&gt; может иметь предложение ORDER BY. Предложение ORDER BY будет применяться ко всем элементам соединения. Если крайний правый элемент &lt;a href=&quot;lang_select#compound&quot;&gt;составного SELECT&lt;/a&gt; является предложением &lt;a href=&quot;lang_select#values&quot;&gt;VALUES&lt;/a&gt; , то предложение ORDER BY для этого оператора не допускается.</target>
        </trans-unit>
        <trans-unit id="60dd93ddbe8f5275cb023ced823e2e72128039a2" translate="yes" xml:space="preserve">
          <source>In a &lt;a href=&quot;lang_select#compound&quot;&gt;compound SELECT&lt;/a&gt;, only the last or right-most &lt;a href=&quot;lang_select#simpleselect&quot;&gt;simple SELECT&lt;/a&gt; may contain a LIMIT clause. In a &lt;a href=&quot;lang_select#compound&quot;&gt;compound SELECT&lt;/a&gt;, the LIMIT clause applies to the entire compound, not just the final SELECT. If the right-most &lt;a href=&quot;lang_select#simpleselect&quot;&gt;simple SELECT&lt;/a&gt; is a &lt;a href=&quot;lang_select#values&quot;&gt;VALUES clause&lt;/a&gt; then no LIMIT clause is allowed.</source>
          <target state="translated">В &lt;a href=&quot;lang_select#compound&quot;&gt;составном SELECT&lt;/a&gt; только последний или самый правый &lt;a href=&quot;lang_select#simpleselect&quot;&gt;простой SELECT&lt;/a&gt; может содержать предложение LIMIT. В &lt;a href=&quot;lang_select#compound&quot;&gt;составном SELECT&lt;/a&gt; предложение LIMIT применяется ко всему составному, а не только к окончательному SELECT. Если самый правый &lt;a href=&quot;lang_select#simpleselect&quot;&gt;простой SELECT&lt;/a&gt; является предложением &lt;a href=&quot;lang_select#values&quot;&gt;VALUES,&lt;/a&gt; то предложение LIMIT не допускается.</target>
        </trans-unit>
        <trans-unit id="4a8149bd98030a655ea899de201ec17546792e89" translate="yes" xml:space="preserve">
          <source>In a CASE with a base expression, the base expression is evaluated just once and the result is compared against the evaluation of each WHEN expression from left to right. The result of the CASE expression is the evaluation of the THEN expression that corresponds to the first WHEN expression for which the comparison is true. Or, if none of the WHEN expressions evaluate to a value equal to the base expression, the result of evaluating the ELSE expression, if any. If there is no ELSE expression and none of the WHEN expressions produce a result equal to the base expression, the overall result is NULL.</source>
          <target state="translated">В CASE с базовым выражением,базовое выражение оценивается всего один раз,и результат сравнивается с оценкой каждого выражения КОГДА слева направо.Результатом выражения CASE является оценка выражения THEN,которое соответствует первому выражению WHEN,для которого сравнение истинно.Или,если ни одно из выражений WHEN не оценивается до значения,равного базовому выражению,результат оценки выражения ELSE,если таковое имеется.Если отсутствует выражение ELSE и ни одно из выражений WHEN не дает результата,равного базовому выражению,то общий результат равен NULL.</target>
        </trans-unit>
        <trans-unit id="9908cac3e7af8453ade042a08abc46157b47dbc8" translate="yes" xml:space="preserve">
          <source>In a CASE without a base expression, each WHEN expression is evaluated and the result treated as a boolean, starting with the leftmost and continuing to the right. The result of the CASE expression is the evaluation of the THEN expression that corresponds to the first WHEN expression that evaluates to true. Or, if none of the WHEN expressions evaluate to true, the result of evaluating the ELSE expression, if any. If there is no ELSE expression and none of the WHEN expressions are true, then the overall result is NULL.</source>
          <target state="translated">В CASE без базового выражения,каждое КОГДА выражение оценивается и результат обрабатывается как булев,начиная с самого левого и заканчивая самым правым.Результатом выражения CASE является оценка выражения THEN,которое соответствует первому выражению WHEN,оцениваемому до истины.Или,если ни одно из выражений КОГДА не оценивается до истины,результатом оценки выражения ELSE,если таковое имеется.Если отсутствует выражение ELSE и ни одно из выражений WHEN не соответствует true,то общий результат будет NULL.</target>
        </trans-unit>
        <trans-unit id="6181d4389ce1218d0117e383d6876208b5204220" translate="yes" xml:space="preserve">
          <source>In a compound SELECT, all the constituent SELECTs must return the same number of result columns. As the components of a compound SELECT must be simple SELECT statements, they may not contain &lt;a href=&quot;lang_select#orderby&quot;&gt;ORDER BY&lt;/a&gt; or &lt;a href=&quot;lang_select#limitoffset&quot;&gt;LIMIT&lt;/a&gt; clauses. &lt;a href=&quot;lang_select#orderby&quot;&gt;ORDER BY&lt;/a&gt; and &lt;a href=&quot;lang_select#limitoffset&quot;&gt;LIMIT&lt;/a&gt; clauses may only occur at the end of the entire compound SELECT, and then only if the final element of the compound is not a &lt;a href=&quot;lang_select#values&quot;&gt;VALUES&lt;/a&gt; clause.</source>
          <target state="translated">В составном SELECT все составляющие SELECT должны возвращать одинаковое количество столбцов результатов. Поскольку компоненты составного SELECT должны быть простыми операторами SELECT, они не могут содержать предложений &lt;a href=&quot;lang_select#orderby&quot;&gt;ORDER BY&lt;/a&gt; или &lt;a href=&quot;lang_select#limitoffset&quot;&gt;LIMIT&lt;/a&gt; . &lt;a href=&quot;lang_select#orderby&quot;&gt;Предложения ORDER BY&lt;/a&gt; и &lt;a href=&quot;lang_select#limitoffset&quot;&gt;LIMIT&lt;/a&gt; могут встречаться только в конце всего составного SELECT и только тогда, если последний элемент составного элемента не является предложением &lt;a href=&quot;lang_select#values&quot;&gt;VALUES&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="78d71ac8fe601725ccb2ce14d7f5ff1b4e551c1c" translate="yes" xml:space="preserve">
          <source>In a custom format defined by the RBU application.</source>
          <target state="translated">В пользовательском формате,определенном приложением RBU.</target>
        </trans-unit>
        <trans-unit id="c01843d896cd964dc56835ee2c755615d047e3ab" translate="yes" xml:space="preserve">
          <source>In a database that uses ptrmap pages, all pages at locations identified by the computation in the previous paragraph must be ptrmap page and no other page may be a ptrmap page. Except, if the byte-lock page happens to fall on the same page number as a ptrmap page, then the ptrmap is moved to the following page for that one case.</source>
          <target state="translated">В базе данных,использующей ptrmap-страницы,все страницы в местах,определенных расчетами в предыдущем параграфе,должны быть ptrmap-страницами,и никакая другая страница не может быть ptrmap-страницей.За исключением случая,когда страница байт-блока случайно попадает на тот же номер страницы,что и ptrmap-страница,то для этого случая ptrmap перемещается на следующую страницу.</target>
        </trans-unit>
        <trans-unit id="27e8a07a53d50d810a0832f44496263b4918565d" translate="yes" xml:space="preserve">
          <source>In a database with ptrmap pages, the first ptrmap page is page 2. A ptrmap page consists of an array of 5-byte entries. Let J be the number of 5-byte entries that will fit in the usable space of a page. (In other words, J=U/5.) The first ptrmap page will contain back pointer information for pages 3 through J+2, inclusive. The second pointer map page will be on page J+3 and that ptrmap page will provide back pointer information for pages J+4 through 2*J+3 inclusive. And so forth for the entire database file.</source>
          <target state="translated">В базе данных с ptrmap-страницами первая ptrmap-страница-это страница 2.Страница ptrmap состоит из массива записей размером 5 байт.Пусть J-это количество 5-байтовых записей,которое поместится в используемое пространство страницы.(Другими словами,J=U/5.)Первая ptrmap-страница будет содержать информацию об указателе обратного хода для страниц от 3 до J+2 включительно.Вторая страница карты-индикатора будет находиться на странице J+3,а эта страница ptrmap будет содержать информацию об обратном указателе для страниц от J+4 до 2*J+3 включительно.И так далее для всего файла базы данных.</target>
        </trans-unit>
        <trans-unit id="413d5f86aecfe4e03a70ec087a2506b07314a985" translate="yes" xml:space="preserve">
          <source>In a general query, dependencies need not be on a single loop, and hence the matrix of dependencies might not be representable as a graph. For example, one of the WHERE clause constraints might be S.a=L.b+P.c, implying that the S loop must be an inner loop of both L and P. Such dependencies cannot be drawn as a graph since there is no way for an arc to originate at two or more nodes at once.</source>
          <target state="translated">В общем запросе,зависимости не обязательно должны быть на одном цикле,и,следовательно,матрица зависимостей может быть не представлена в виде графика.Например,одним из ограничений выражения WHERE может быть S.a=L.b+P.c,что означает,что цикл S должен быть внутренним циклом как L,так и P.Такие зависимости не могут быть построены как граф,т.к.не существует возможности возникновения дуги сразу в двух и более узлах.</target>
        </trans-unit>
        <trans-unit id="3cba367e5a45e9ef327972801946d29ebc579596" translate="yes" xml:space="preserve">
          <source>In a join, two or more tables are combined to generate a single result. The result table consists of every possible combination of rows from the tables being joined. The easiest and most natural way to implement this is with nested loops.</source>
          <target state="translated">В объединении две или более таблиц объединяются для получения одного результата.Таблица результатов состоит из всех возможных комбинаций строк соединяемых таблиц.Самый простой и естественный способ реализовать это-с помощью вложенных петель.</target>
        </trans-unit>
        <trans-unit id="ea43a43981be0da7d2383a4a8fa8f578ad332998" translate="yes" xml:space="preserve">
          <source>In a more complete build, SQLite also uses library routines like malloc() and free() and operating system interfaces for opening, reading, writing, and closing files. But even then, the number of dependencies is very small. Other &quot;modern&quot; language, in contrast, often require multi-megabyte runtimes loaded with thousands and thousands of interfaces.</source>
          <target state="translated">В более полной сборке SQLite также использует библиотечные подпрограммы,такие как malloc()и free(),и интерфейсы операционной системы для открытия,чтения,записи и закрытия файлов.Но даже в этом случае количество зависимостей очень мало.Другой &quot;современный&quot; язык,напротив,часто требует многомегабайтных запусков,загруженных тысячами и тысячами интерфейсов.</target>
        </trans-unit>
        <trans-unit id="84d7fa8dbd084f79299c977c5d7f182884242ce4" translate="yes" xml:space="preserve">
          <source>In a multi-threaded application, access to the &lt;a href=&quot;c3ref/mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt; is serialized if and only if &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmemstatus&quot;&gt;SQLITE_CONFIG_MEMSTATUS&lt;/a&gt; is enabled. If &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmemstatus&quot;&gt;SQLITE_CONFIG_MEMSTATUS&lt;/a&gt; is disabled then the methods in &lt;a href=&quot;c3ref/mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt; must take care of their own serialization needs.</source>
          <target state="translated">В многопоточном приложении доступ к &lt;a href=&quot;c3ref/mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt; сериализуется тогда и только тогда, &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmemstatus&quot;&gt;когда&lt;/a&gt; включен SQLITE_CONFIG_MEMSTATUS . Если &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmemstatus&quot;&gt;SQLITE_CONFIG_MEMSTATUS&lt;/a&gt; отключен, методы в &lt;a href=&quot;c3ref/mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt; должны позаботиться о своих собственных потребностях в сериализации.</target>
        </trans-unit>
        <trans-unit id="f07ff4f6d979804b51470d547e3016d910de27f0" translate="yes" xml:space="preserve">
          <source>In a multithreaded environment, SQLite uses mutexes to serialize access to shared resources. The mutex subsystem is only required for applications that access SQLite from multiple threads. For single-threaded applications, or applications which only call SQLite from a single thread, the mutex subsystem can be completely disabled by recompiling with the following option:</source>
          <target state="translated">В многопоточной среде SQLite использует мьютексы для сериализации доступа к общим ресурсам.Подсистема мьютекса требуется только для приложений,которые получают доступ к SQLite из нескольких потоков.Для однопоточных приложений или приложений,которые обращаются к SQLite только из одного потока,подсистема мьютекса может быть полностью отключена путем перекомпиляции со следующей опцией:</target>
        </trans-unit>
        <trans-unit id="4d4533ee698cc81c52715976a896f4db12f7a8cf" translate="yes" xml:space="preserve">
          <source>In a normal index, there is a one-to-one mapping between rows in a table and entries in each index associated with that table. However, in a &lt;a href=&quot;partialindex&quot;&gt;partial index&lt;/a&gt;, the index b-tree only contains entries corresponding to table rows for which the WHERE clause expression on the CREATE INDEX statement is true. Corresponding rows in the index and table b-trees share the same rowid or primary key values and contain the same value for all indexed columns.</source>
          <target state="translated">В нормальном индексе существует взаимно однозначное соответствие между строками в таблице и записями в каждом индексе, связанном с этой таблицей. Однако в &lt;a href=&quot;partialindex&quot;&gt;частичном индексе&lt;/a&gt; b-дерево индекса содержит только записи, соответствующие строкам таблицы, для которых выражение предложения WHERE в операторе CREATE INDEX истинно. Соответствующие строки в b-деревьях индекса и таблицы имеют одинаковые идентификаторы строки или значения первичного ключа и содержат одно и то же значение для всех индексированных столбцов.</target>
        </trans-unit>
        <trans-unit id="ce9e9da4042a8b1a6fff277efdbca241b2bb44b8" translate="yes" xml:space="preserve">
          <source>In a prefix search, the matchlen is the number of characters in the string that match against the prefix. For a non-prefix search, this is the same as length(word).</source>
          <target state="translated">При поиске с префиксом,matchlen-это количество символов в строке,которые совпадают с префиксом.Для не префиксного поиска это то же самое,что и длина(слово).</target>
        </trans-unit>
        <trans-unit id="540eb7e11b15dfedf16222538153a627d93ae118" translate="yes" xml:space="preserve">
          <source>In a well-formed sqlite_stat3 table, the samples for any single index must appear in the same order that they occur in the index. In other words, if the entry with left-most column S1 is earlier in the index b-tree than the entry with left-most column S2, then in the sqlite_stat3 table, sample S1 must have a smaller rowid than sample S2.</source>
          <target state="translated">В хорошо сформированной таблице sqlite_stat3 выборки для любого отдельного индекса должны располагаться в том же порядке,в котором они встречаются в индексе.Другими словами,если запись с крайним левым столбцом S1 в дереве индексов b раньше,чем запись с крайним левым столбцом S2,то в таблице sqlite_stat3 выборка S1 должна иметь меньший ряд,чем выборка S2.</target>
        </trans-unit>
        <trans-unit id="471a1674cd89ff60cc26aaa2e09dcb5715c114d4" translate="yes" xml:space="preserve">
          <source>In a well-formed sqlite_stat4 table, the samples for any single index must appear in the same order that they occur in the index. In other words, if entry S1 is earlier in the index b-tree than entry S2, then in the sqlite_stat4 table, sample S1 must have a smaller rowid than sample S2.</source>
          <target state="translated">В хорошо сформированной таблице sqlite_stat4 выборки для любого отдельного индекса должны располагаться в том же порядке,в котором они встречаются в индексе.Другими словами,если запись S1 в дереве индексов b раньше,чем запись S2,то в таблице sqlite_stat4 выборка S1 должна иметь меньший ряд,чем выборка S2.</target>
        </trans-unit>
        <trans-unit id="211f3f65b2d350ffdf823361c3c94beeb6b3685e" translate="yes" xml:space="preserve">
          <source>In addition to &quot;supporting&quot; SQLite through the year 2050, the developers also promise to keep the SQLite &lt;a href=&quot;cintro&quot;&gt;C-language API&lt;/a&gt; and &lt;a href=&quot;fileformat2&quot;&gt;on-disk format&lt;/a&gt; fully backwards compatible. This means that application written to use SQLite today should be able to link against and use future versions of SQLite released decades in the future.</source>
          <target state="translated">Помимо &amp;laquo;поддержки&amp;raquo; SQLite до 2050 года, разработчики также обещают сохранить полную обратную совместимость &lt;a href=&quot;cintro&quot;&gt;API языка C&lt;/a&gt; SQLite и &lt;a href=&quot;fileformat2&quot;&gt;дискового формата&lt;/a&gt; . Это означает, что приложение, написанное для использования SQLite сегодня, должно иметь возможность связываться с будущими версиями SQLite, выпущенными через десятилетия, и использовать их.</target>
        </trans-unit>
        <trans-unit id="2d62e10830dbc04e04eb1ce98ea4d36c1849dd6d" translate="yes" xml:space="preserve">
          <source>In addition to WHERE clause constraints, the SQLite core also tells the xBestIndex method about the ORDER BY clause. (In an aggregate query, the SQLite core might put in GROUP BY clause information in place of the ORDER BY clause information, but this fact should not make any difference to the xBestIndex method.) If all terms of the ORDER BY clause are columns in the virtual table, then nOrderBy will be the number of terms in the ORDER BY clause and the aOrderBy[] array will identify the column for each term in the order by clause and whether or not that column is ASC or DESC.</source>
          <target state="translated">В дополнение к ограничениям пункта WHERE,ядро SQLite также сообщает метод xBestIndex об оговорке ORDER BY.(В совокупном запросе ядро SQLite может поместить информацию из пункта GROUP BY вместо информации из пункта ORDER BY,но этот факт не должен иметь никакого отношения к методу xBestIndex).Если все термины в пункте ORDER BY являются столбцами в виртуальной таблице,то nOrderBy будет числом терминов в пункте ORDER BY,а массив aOrderBy[]будет идентифицировать столбец для каждого термина в порядке следования по пунктам и будет ли этот столбец ASC или DESC.</target>
        </trans-unit>
        <trans-unit id="ae32760f149e6ccbf9d662c3e5f266d79f8381ea" translate="yes" xml:space="preserve">
          <source>In addition to being a result code, the SQLITE_ABORT value is also used as a &lt;a href=&quot;c3ref/c_fail&quot;&gt;conflict resolution mode&lt;/a&gt; returned from the &lt;a href=&quot;c3ref/vtab_on_conflict&quot;&gt;sqlite3_vtab_on_conflict()&lt;/a&gt; interface.</source>
          <target state="translated">Помимо того, что это код результата, значение SQLITE_ABORT также используется в качестве &lt;a href=&quot;c3ref/c_fail&quot;&gt;режима разрешения конфликтов,&lt;/a&gt; возвращаемого интерфейсом &lt;a href=&quot;c3ref/vtab_on_conflict&quot;&gt;sqlite3_vtab_on_conflict ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7bf173fd8743d9addd4d23da77cbd1023dcac612" translate="yes" xml:space="preserve">
          <source>In addition to locking this byte, a connection running &lt;a href=&quot;walformat#recovery&quot;&gt;recovery&lt;/a&gt; also gets an exclusive lock on all other WAL locks except for WAL_READ_LOCK(0).</source>
          <target state="translated">Помимо блокировки этого байта, соединение, выполняющее &lt;a href=&quot;walformat#recovery&quot;&gt;восстановление,&lt;/a&gt; также получает эксклюзивную блокировку всех других блокировок WAL, кроме WAL_READ_LOCK (0).</target>
        </trans-unit>
        <trans-unit id="cb3414acfc85a9001c1b555d3204dd8c38c36eeb" translate="yes" xml:space="preserve">
          <source>In addition to making SQLite easier to incorporate into other projects, the amalgamation also makes it run faster. Many compilers are able to do additional optimizations on code when it is contained with in a single translation unit such as it is in the amalgamation. We have measured performance improvements of between 5 and 10% when we use the amalgamation to compile SQLite rather than individual source files. The downside of this is that the additional optimizations often take the form of function inlining which tends to make the size of the resulting binary image larger.</source>
          <target state="translated">Помимо того,что слияние облегчает интеграцию SQLite в другие проекты,оно также ускоряет его работу.Многие компиляторы могут выполнять дополнительные оптимизации кода,когда он содержится в единице трансляции,например,в слиянии.Мы измерили прирост производительности от 5 до 10% при использовании слияния для компиляции SQLite,а не отдельных исходных файлов.Недостатком этого является то,что дополнительные оптимизации часто принимают форму встраивания функции,которая,как правило,увеличивает размер получаемого двоичного изображения.</target>
        </trans-unit>
        <trans-unit id="dc82fe62c10524b3d4ccdfbeed7cfd03442b0fdf" translate="yes" xml:space="preserve">
          <source>In addition to providing built-in &quot;simple&quot;, &quot;porter&quot; and (possibly) &quot;icu&quot; and &quot;unicode61&quot; tokenizers, FTS provides an interface for applications to implement and register custom tokenizers written in C. The interface used to create a new tokenizer is defined and described in the fts3_tokenizer.h source file.</source>
          <target state="translated">В дополнение к встроенным &quot;простым&quot;,&quot;porter&quot; и (возможно)&quot;icu&quot; и &quot;unicode61&quot; токенайзерам,FTS предоставляет интерфейс для приложений,реализующих и регистрирующих пользовательские токенайзеры,написанные на C.Интерфейс,используемый для создания нового токенайзера,определен и описан в исходном файле fts3_tokenizer.h.</target>
        </trans-unit>
        <trans-unit id="96c71370cd3f6550d6c5dcd90baa2ddaf820ea27" translate="yes" xml:space="preserve">
          <source>In addition to reading and writing SQLite database files, the &lt;b&gt;sqlite3&lt;/b&gt; program will also read and write ZIP archives. Simply specify a ZIP archive filename in place of an SQLite database filename on the initial command line, or in the &quot;.open&quot; command, and &lt;b&gt;sqlite3&lt;/b&gt; will automatically detect that the file is a ZIP archive instead of an SQLite database and will open it as such. This works regardless of file suffix. So you can open JAR, DOCX, and ODP files and any other file format that is really a ZIP archive and SQLite will read it for you.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73759a104c50187a5dc43c3f84c36657f75e9027" translate="yes" xml:space="preserve">
          <source>In addition to the four main test harnesses, there several other small programs that implement specialized tests.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ffa68d498101dd69c9fe08bfcd580625d879a08" translate="yes" xml:space="preserve">
          <source>In addition to the incompatible changes listed above, SQLite version 3.6.0 adds the following backwards compatible changes and enhancements:</source>
          <target state="translated">В дополнение к вышеперечисленным несовместимым изменениям,в SQLite версии 3.6.0 добавлены следующие изменения и улучшения с обратной совместимостью:</target>
        </trans-unit>
        <trans-unit id="8f29eabb94163c908fdf9ce75645a4e743012d26" translate="yes" xml:space="preserve">
          <source>In addition to the official repositories, the developers typically keep complete clones of all software on their personal machines. And there are uncountable clones scattered about the internet.</source>
          <target state="translated">В дополнение к официальным репозиториям разработчики обычно хранят на своих персональных машинах полные клоны всего программного обеспечения.И есть неисчислимые клоны,разбросанные по интернету.</target>
        </trans-unit>
        <trans-unit id="7d07efab2f131a863a93f94a25375b6ef4bc7a4a" translate="yes" xml:space="preserve">
          <source>In addition to the primary vdbe.c source code file, there are other helper code files in the source tree, all of whose names begin with &quot;vdbe&quot; - short for &quot;Virtual DataBase Engine&quot;.</source>
          <target state="translated">Кроме основного файла исходного кода vdbe.c,в дереве исходных текстов есть и другие файлы справочного кода,все названия которых начинаются с &quot;vdbe&quot;-сокращение от &quot;Virtual DataBase Engine&quot;.</target>
        </trans-unit>
        <trans-unit id="e225e51508417bb108b16321c68b3adb1795c7b9" translate="yes" xml:space="preserve">
          <source>In addition to the required flags, the following optional flags are also supported:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77b9657ef03e307e851c2e7bae3bdd3ad8613131" translate="yes" xml:space="preserve">
          <source>In addition to the tables, indexes, views, and triggers created by the application and/or the developer using CREATE statements SQL, the sqlite_master table may contain zero or more entries for</source>
          <target state="translated">В дополнение к таблицам,индексам,представлениям и триггерам,созданным приложением и/или разработчиком с помощью SQL-запросов CREATE,таблица sqlite_master может содержать ноль и более записей для</target>
        </trans-unit>
        <trans-unit id="52a812fb18ec964152fad4865c6ca9189ffdf18b" translate="yes" xml:space="preserve">
          <source>In addition to the tables, indexes, views, and triggers created by the application and/or the developer using CREATE statements SQL, the sqlite_schema table may contain zero or more entries for</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a409c2d7a3384bc3f57eb2c0537e46f7868645bd" translate="yes" xml:space="preserve">
          <source>In addition to the three major test harnesses, there several other small programs that implement specialized tests.</source>
          <target state="translated">В дополнение к трем основным тестовым жгутам существует еще несколько небольших программ,реализующих специализированные тесты.</target>
        </trans-unit>
        <trans-unit id="0718e6fdf0cd1e299f6d920f46595f0908dd4b09" translate="yes" xml:space="preserve">
          <source>In addition, there are some defined constants:</source>
          <target state="translated">Кроме того,существуют определенные константы:</target>
        </trans-unit>
        <trans-unit id="db8b6c04e401904429f7905ea6f3cbc5116fbe03" translate="yes" xml:space="preserve">
          <source>In all cases, if if any discrepancies are found, the command fails with an &lt;a href=&quot;rescode#corrupt_vtab&quot;&gt;SQLITE_CORRUPT_VTAB&lt;/a&gt; error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbb8e299adb3ff32a155642d73390e9d9fa9566c" translate="yes" xml:space="preserve">
          <source>In all of the above, if F is not the name of a database, journal or WAL filename passed into the VFS from the SQLite core and F is not the return value from &lt;a href=&quot;#sqlite3_db_filename&quot;&gt;sqlite3_db_filename()&lt;/a&gt;, then the result is undefined and is likely a memory access violation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a6f4780ac68779fff537a2221e3188df1c6d53f" translate="yes" xml:space="preserve">
          <source>In all of the above, if F is not the name of a database, journal or WAL filename passed into the VFS from the SQLite core and F is not the return value from &lt;a href=&quot;db_filename&quot;&gt;sqlite3_db_filename()&lt;/a&gt;, then the result is undefined and is likely a memory access violation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="650bcf7f3c9667b8bca2e9d81188fd4ca62bdf99" translate="yes" xml:space="preserve">
          <source>In all of the full-text queries above, the right-hand operand of the MATCH operator is a string consisting of a single term. In this case, the MATCH expression evaluates to true for all documents that contain one or more instances of the specified word (&quot;sqlite&quot;, &quot;search&quot; or &quot;database&quot;, depending on which example you look at). Specifying a single term as the right-hand operand of the MATCH operator results in the simplest and most common type of full-text query possible. However more complicated queries are possible, including phrase searches, term-prefix searches and searches for documents containing combinations of terms occurring within a defined proximity of each other. The various ways in which the full-text index may be queried are &lt;a href=&quot;fts3#full_text_index_queries&quot;&gt;described below&lt;/a&gt;.</source>
          <target state="translated">Во всех полнотекстовых запросах выше правый операнд оператора MATCH представляет собой строку, состоящую из одного члена. В этом случае выражение MATCH оценивается как истинное для всех документов, содержащих один или несколько экземпляров указанного слова (&amp;laquo;sqlite&amp;raquo;, &amp;laquo;поиск&amp;raquo; или &amp;laquo;база данных&amp;raquo;, в зависимости от того, какой пример вы смотрите). Указание одного члена в качестве правого операнда оператора MATCH приводит к простейшему и наиболее распространенному типу полнотекстового запроса. Однако возможны более сложные запросы, включая поиск по фразам, поиск по префиксу терминов и поиск документов, содержащих комбинации терминов, встречающиеся в определенной близости друг от друга. Ниже &lt;a href=&quot;fts3#full_text_index_queries&quot;&gt;описаны&lt;/a&gt; различные способы запроса полнотекстового индекса .</target>
        </trans-unit>
        <trans-unit id="fec3ea71809f1fd12bdd320ecfb2400479f6f909" translate="yes" xml:space="preserve">
          <source>In all of the write tests, it is important to disable anti-virus software prior to running the direct-to-disk performance tests. We found that anti-virus software slows down direct-to-disk by an order of magnitude whereas it impacts SQLite writes very little. This is probably due to the fact that direct-to-disk changes thousands of separate files which all need to be checked by anti-virus, whereas SQLite writes only changes the single database file.</source>
          <target state="translated">Во всех тестах на запись важно отключить антивирусное программное обеспечение перед запуском тестов производительности непосредственно на диск.Мы обнаружили,что антивирусные программы замедляют прямую запись на диск на порядок,в то время как SQLite записывает очень мало.Вероятно,это связано с тем,что при прямой записи на диск изменяются тысячи отдельных файлов,которые необходимо проверить антивирусом,в то время как SQLite записывает только один файл базы данных.</target>
        </trans-unit>
        <trans-unit id="19fd1c2e26ad6ba4190cb1ba85655e3d415fb1a9" translate="yes" xml:space="preserve">
          <source>In all other cases this function returns SQLITE_MISUSE.</source>
          <target state="translated">Во всех остальных случаях эта функция возвращает SQLITE_MISUSE.</target>
        </trans-unit>
        <trans-unit id="a9b1d686d80c16cbd892850ec817e33e118fdb64" translate="yes" xml:space="preserve">
          <source>In all the examples above, there has only been a single SELECT statement. If a query contains sub-selects, those are shown as being children of the outer SELECT. For example:</source>
          <target state="translated">Во всех приведенных выше примерах было только одно утверждение SELECT.Если запрос содержит подвыборки,то они отображаются как дочерние элементы внешнего SELECT.Например:</target>
        </trans-unit>
        <trans-unit id="c9c18ce865540a24f1f5ee5d4ef74324465c3e44" translate="yes" xml:space="preserve">
          <source>In an &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; statement, a list of column names can be set to a row value of the same size.</source>
          <target state="translated">В операторе &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; список имен столбцов может быть установлен равным значению строки того же размера.</target>
        </trans-unit>
        <trans-unit id="34ecd17e630ff3ecf740af54bcb0cb9af6e271db" translate="yes" xml:space="preserve">
          <source>In an expression used as part of an &lt;a href=&quot;expridx&quot;&gt;expression index&lt;/a&gt;.</source>
          <target state="translated">В выражении, используемом как часть &lt;a href=&quot;expridx&quot;&gt;индекса выражения&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="68e31982331dd4f44aeeef7efedd25a5db6a0a14" translate="yes" xml:space="preserve">
          <source>In an index on a WITHOUT ROWID table, if a column of the PRIMARY KEY is also a column in the index and has a matching collating sequence, then the indexed column is not repeated in the table-key suffix on the end of the index record. As an example, consider the following SQL:</source>
          <target state="translated">В индексе в таблице БЕЗ РАЗРЕШЕНИЯ,если столбец PRIMARY KEY также является столбцом в индексе и имеет совпадающую коллизионную последовательность,то проиндексированный столбец не повторяется в суффиксе ключа таблицы в конце записи индекса.В качестве примера рассмотрим следующий SQL:</target>
        </trans-unit>
        <trans-unit id="b98eca53cbed3b51f01e882fbf03443737203ad3" translate="yes" xml:space="preserve">
          <source>In an interior b-tree page, the pointers and keys logically alternate with a pointer on both ends. (The previous sentence is to be understood conceptually - the actual layout of the keys and pointers within the page is more complicated and will be described in the sequel.) All keys within the same page are unique and are logically organized in ascending order from left to right. (Again, this ordering is logical, not physical. The actual location of keys within the page is arbitrary.) For any key X, pointers to the left of a X refer to b-tree pages on which all keys are less than or equal to X. Pointers to the right of X refer to pages where all keys are greater than X.</source>
          <target state="translated">Внутри страницы из b-дерева указатели и клавиши логически чередуются с указателем на обоих концах.(Предыдущее предложение следует понимать концептуально-фактическое расположение клавиш и указателей внутри страницы сложнее и будет описано в продолжении).Все клавиши внутри одной страницы уникальны и логически организованы в порядке возрастания слева направо.(Опять же,это упорядочение логично,а не физически.Реальное расположение ключей внутри страницы является произвольным).Для любого ключа X указатели слева от X относятся к страницам b-дерева,на которых все ключи меньше или равны X.Указатели справа от X относятся к страницам,на которых все ключи больше X.</target>
        </trans-unit>
        <trans-unit id="39488c0191328e370ea86a4f1833476c2e9dc423" translate="yes" xml:space="preserve">
          <source>In an ordinary SQLite table, the PRIMARY KEY is really just a &lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE&lt;/a&gt; index. The key used to look up records on disk is the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;. The special &quot;&lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;&quot; column type in ordinary SQLite tables causes the column to be an alias for the rowid, and so an INTEGER PRIMARY KEY is a true PRIMARY KEY. But any other kind of PRIMARY KEYs, including &quot;INT PRIMARY KEY&quot; are just unique indexes in an ordinary rowid table.</source>
          <target state="translated">В обычной таблице SQLite PRIMARY KEY - это просто &lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;УНИКАЛЬНЫЙ&lt;/a&gt; индекс. Ключ, используемый для поиска записей на диске, - это &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; . Специальный тип столбца &amp;laquo; &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; &amp;raquo; в обычных таблицах SQLite заставляет столбец быть псевдонимом для rowid, и поэтому INTEGER PRIMARY KEY является истинным PRIMARY KEY. Но любые другие типы PRIMARY KEY, включая INT PRIMARY KEY, являются просто уникальными индексами в обычной таблице rowid.</target>
        </trans-unit>
        <trans-unit id="2602231eda03cd82b0bfe3849f20e2339713b36f" translate="yes" xml:space="preserve">
          <source>In any aggregate function that takes a single argument, that argument can be preceded by the keyword DISTINCT. In such cases, duplicate elements are filtered before being passed into the aggregate function. For example, the function &quot;count(distinct X)&quot; will return the number of distinct values of column X instead of the total number of non-null values in column X.</source>
          <target state="translated">В любой совокупной функции,которая принимает один аргумент,этому аргументу может предшествовать ключевое слово DISTINCT.В таких случаях дублирующие элементы фильтруются перед передачей в агрегатную функцию.Например,функция &quot;count(distinct X)&quot; вернет количество отдельных значений в столбце X вместо общего количества ненулевых значений в столбце X.</target>
        </trans-unit>
        <trans-unit id="15eb51d3758bed15da54f5c0830882a735d49cb2" translate="yes" xml:space="preserve">
          <source>In any database file that contains ptrmap pages, all b-tree root pages must come before any non-root b-tree page, cell payload overflow page, or freelist page. This restriction ensures that a root page will never be moved during an auto-vacuum or incremental-vacuum. The auto-vacuum logic does not know how to update the root_page field of the sqlite_master table and so it is necessary to prevent root pages from being moved during an auto-vacuum in order to preserve the integrity of the sqlite_master table. Root pages are moved to the beginning of the database file by the CREATE TABLE, CREATE INDEX, DROP TABLE, and DROP INDEX operations.</source>
          <target state="translated">В любом файле базы данных,содержащем ptrmap-страницы,все b-деревянные корневые страницы должны находиться перед любой не корневой b-деревянной страницей,страницей переполнения ячеек или страницей фрилиста.Это ограничение гарантирует,что корневая страница никогда не будет перемещена во время автоматического вакуума или инкрементального вакуума.Логика авто-вакуума не знает,как обновить поле root_page таблицы sqlite_master,поэтому необходимо предотвратить перемещение корневых страниц во время авто-вакуума,чтобы сохранить целостность таблицы sqlite_master.Корневые страницы перемещаются в начало файла базы данных с помощью операций CREATE TABLE,CREATE INDEX,DROP TABLE и DROP INDEX.</target>
        </trans-unit>
        <trans-unit id="d9bc87111dc7feda77c011e8d21c00fc7e80e539" translate="yes" xml:space="preserve">
          <source>In any database file that contains ptrmap pages, all b-tree root pages must come before any non-root b-tree page, cell payload overflow page, or freelist page. This restriction ensures that a root page will never be moved during an auto-vacuum or incremental-vacuum. The auto-vacuum logic does not know how to update the root_page field of the sqlite_schema table and so it is necessary to prevent root pages from being moved during an auto-vacuum in order to preserve the integrity of the sqlite_schema table. Root pages are moved to the beginning of the database file by the CREATE TABLE, CREATE INDEX, DROP TABLE, and DROP INDEX operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="016fc239bf2f87e674a823e588afff2d09643b5a" translate="yes" xml:space="preserve">
          <source>In automatic EXPLAIN QUERY PLAN mode, the shell automatically runs a separate EXPLAIN QUERY PLAN query for each statement you enter and displays the result before actually running the query. Use the &quot;.eqp off&quot; command to turn automatic EXPLAIN QUERY PLAN mode back off.</source>
          <target state="translated">В автоматическом режиме EXPLAIN QUERY PLAN оболочка автоматически выполняет отдельный запрос EXPLAIN QUERY PLAN для каждого введенного вами запроса и отображает результат до фактического выполнения запроса.Используйте команду &quot;.eqp off&quot;,чтобы выключить автоматический режим EXPLAIN QUERY PLAN.</target>
        </trans-unit>
        <trans-unit id="a0296b5facf2017142e185ec710adebd650dd374" translate="yes" xml:space="preserve">
          <source>In batch-mode operation, where an FTS table is initially built up using a large number of INSERT operations, then queried repeatedly without further changes, it is often a good idea to run &quot;optimize&quot; after the last INSERT and before the first query.</source>
          <target state="translated">В пакетном режиме,когда таблица FTS изначально строится с использованием большого количества операций INSERT,а затем многократно опрашивается без дальнейших изменений,часто бывает хорошей идеей запустить &quot;оптимизацию&quot; после последнего INSERT и перед первым запросом.</target>
        </trans-unit>
        <trans-unit id="0f704787571a999cc9c3b84bb71144a5bcf64e37" translate="yes" xml:space="preserve">
          <source>In both cases, the split amalgamation can be obtained by substituting &quot;sqlite3-all.c&quot; for &quot;sqlite3.c&quot; as the make target.</source>
          <target state="translated">В обоих случаях дробное слияние можно получить,заменив &quot;sqlite3-all.c&quot; на &quot;sqlite3.c&quot; в качестве целевого показателя.</target>
        </trans-unit>
        <trans-unit id="fc2950d0c83c287a896b8aadaea3a0c15a77bfa3" translate="yes" xml:space="preserve">
          <source>In brief, sqlite3_wal_checkpoint(D,X) causes the content in the &lt;a href=&quot;../wal&quot;&gt;write-ahead log&lt;/a&gt; for database X on &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; D to be transferred into the database file and for the write-ahead log to be reset. See the &lt;a href=&quot;../wal#ckpt&quot;&gt;checkpointing&lt;/a&gt; documentation for addition information.</source>
          <target state="translated">Вкратце, sqlite3_wal_checkpoint (D, X) заставляет содержимое &lt;a href=&quot;../wal&quot;&gt;журнала упреждающей записи&lt;/a&gt; для базы данных X при &lt;a href=&quot;sqlite3&quot;&gt;подключении&lt;/a&gt; к базе данных D переноситься в файл базы данных и сбрасывать журнал упреждающей записи. Дополнительную информацию см. В документации по &lt;a href=&quot;../wal#ckpt&quot;&gt;контрольным точкам&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="05e7a053b7377f3e594b4b5661cacef3a8037473" translate="yes" xml:space="preserve">
          <source>In brief, sqlite3_wal_checkpoint(D,X) causes the content in the &lt;a href=&quot;wal&quot;&gt;write-ahead log&lt;/a&gt; for database X on &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; D to be transferred into the database file and for the write-ahead log to be reset. See the &lt;a href=&quot;wal#ckpt&quot;&gt;checkpointing&lt;/a&gt; documentation for addition information.</source>
          <target state="translated">Вкратце, sqlite3_wal_checkpoint (D, X) заставляет содержимое &lt;a href=&quot;wal&quot;&gt;журнала упреждающей записи&lt;/a&gt; для базы данных X при &lt;a href=&quot;#sqlite3&quot;&gt;подключении&lt;/a&gt; к базе данных D переноситься в файл базы данных и сбрасывать журнал упреждающей записи. Дополнительную информацию см. В документации по &lt;a href=&quot;wal#ckpt&quot;&gt;контрольным точкам&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9c00ece9c1ea98470c62a3e9e8dcd9514aa371cf" translate="yes" xml:space="preserve">
          <source>In brief, the CPU performance of SQLite is measured as follows:</source>
          <target state="translated">Вкратце,производительность процессора SQLite измеряется следующим образом:</target>
        </trans-unit>
        <trans-unit id="9e64879e9d401b77adebcff06d6d47d07d757ab4" translate="yes" xml:space="preserve">
          <source>In cases where it is complicated, the complications in applying a changeset lie in conflict resolution. Refer to the API documentation linked above for details.</source>
          <target state="translated">В тех случаях,когда это сложно,сложности в применении изменений заключаются в урегулировании конфликтов.Подробности см.в документации по API,ссылки на которую приведены выше.</target>
        </trans-unit>
        <trans-unit id="0d808e9f43de5ebbcabce2337be4b9dd05f38065" translate="yes" xml:space="preserve">
          <source>In cases where two or more phrase instances overlap (share one or more tokens in common), a single open and close marker is inserted for each set of overlapping phrases. For example:</source>
          <target state="translated">В случаях,когда два или более фразовых экземпляра перекрываются (совместно используют один или несколько маркеров),для каждого набора перекрывающихся фраз вставляется один маркер &quot;Открыть&quot; и &quot;Закрыть&quot;.Например:</target>
        </trans-unit>
        <trans-unit id="c541beea5651ea9308221a19ef6bad8134493156" translate="yes" xml:space="preserve">
          <source>In column mode, each record is shown on a separate line with the data aligned in columns. For example:</source>
          <target state="translated">В режиме столбцов каждая запись отображается отдельной строкой с данными,выровненными по столбцам.Например:</target>
        </trans-unit>
        <trans-unit id="27dcedbb38ae9d16b71fde759bf65bb67ce0f587" translate="yes" xml:space="preserve">
          <source>In common use, SQLite databases tend to range in size from a few kilobytes to a few gigabytes, though terabyte-size SQLite databases are known to exist in production.</source>
          <target state="translated">При обычном использовании базы данных SQLite имеют тенденцию варьироваться в размерах от нескольких килобайт до нескольких гигабайт,хотя известно,что базы данных SQLite размером в терабайт существуют в производстве.</target>
        </trans-unit>
        <trans-unit id="15ec9746d32bfb65e8d0e42717374e59fcc87690" translate="yes" xml:space="preserve">
          <source>In contrast, Fossil is a single standalone binary which is installed by putting it on $PATH. That one binary contains all the functionality of core Git and also GitHub and/or GitLab. It manages a community server with wiki, bug tracking, and forums, provides packaged downloads for consumers, login managements, and so forth, with no extra software required.</source>
          <target state="translated">Напротив,ископаемое-это одиночный бинарный файл,который устанавливается,ставя его на $PATH.Этот бинарный файл содержит все функциональные возможности ядра Git,а также GitHub и/или GitLab.Он управляет сервером сообщества с wiki,отслеживанием ошибок и форумами,обеспечивает пакетную загрузку для потребителей,управление входом в систему и т.д.,не требуя дополнительного программного обеспечения.</target>
        </trans-unit>
        <trans-unit id="b26360f9266d08eeb61923fd0c3bf7dd26b34599" translate="yes" xml:space="preserve">
          <source>In contrast, Fossil offers displays such as &lt;a href=&quot;https://sqlite.org/src/timeline?df=release&quot;&gt;https://sqlite.org/src/timeline?df=release&lt;/a&gt; to show all check-ins that are derived from the most recent release.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a51fb2bb312c4e04f9b038dff963c7e47c882987" translate="yes" xml:space="preserve">
          <source>In contrast, Fossil users only need to think about their working directory and the check-in they are working on. That is 60% less distraction. Every developer has a finite number of brain-cycles. Fossil requires fewer brain-cycles to operate, thus freeing up intellectual resources to focus on the software under development.</source>
          <target state="translated">В отличие от этого,пользователям,использующим ископаемые,нужно только подумать о своем рабочем каталоге и регистрации,над которой они работают.Это на 60% меньше отвлекает.У каждого разработчика есть ограниченное количество мозговых циклов.Ископаемым требуется меньше &quot;мозговых циклов&quot;,чтобы работать,высвобождая тем самым интеллектуальные ресурсы,чтобы сосредоточиться на разрабатываемом программном обеспечении.</target>
        </trans-unit>
        <trans-unit id="0fcdb16d38afda3fa9a7a2e8625220ffc33d6191" translate="yes" xml:space="preserve">
          <source>In either case, if performance problems do arise in an SQLite application those problems can often be resolved by adding one or two &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt; statements to the schema or perhaps running &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; one time and without having to touch a single line of application code. But if a performance problem comes up in a custom or pile-of-files format, the fix will often require extensive changes to application code to add and maintain new indices or to extract information using different algorithms.</source>
          <target state="translated">В любом случае, если в приложении SQLite действительно возникают проблемы с производительностью, эти проблемы часто можно решить, добавив в схему один или два оператора &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt; или, возможно, запустив &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; один раз и без необходимости касаться ни одной строчки кода приложения. Но если проблема с производительностью возникает в пользовательском формате или в формате кучи файлов, исправление часто потребует значительных изменений в коде приложения для добавления и поддержки новых индексов или для извлечения информации с использованием других алгоритмов.</target>
        </trans-unit>
        <trans-unit id="25aa68ecfd2b0c4f0ec2db607f906e4651bce4ef" translate="yes" xml:space="preserve">
          <source>In every case, the pager cache size was adjusted to keep the amount of cache memory at about 2MB. For example, a 2000 page cache was used for 1024 byte pages and a 31 page cache was used for 65536 byte pages. The BLOB values were read in a random order.</source>
          <target state="translated">В каждом случае размер кэш-памяти пейджера регулировался таким образом,чтобы объем кэш-памяти составлял около 2 Мб.Например,кэш 2000 страниц был использован для 1024 байтных страниц,а кэш 31 страницы-для 65536 байтных страниц.BLOB-значения читались в случайном порядке.</target>
        </trans-unit>
        <trans-unit id="cf40b39d63a8fb0ce771e83c7921ec57173f92f8" translate="yes" xml:space="preserve">
          <source>In extreme cases, consider compiling SQLite with the &lt;a href=&quot;compile#enable_memsys5&quot;&gt;-DSQLITE_ENABLE_MEMSYS5&lt;/a&gt; option and then providing SQLite with a fixed chunk of memory to use as its heap via the &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigheap&quot;&gt;SQLITE_CONFIG_HEAP&lt;/a&gt;) interface. This will prevent malicious SQL from executing a denial-of-service attack by using an excessive amount of memory. If (say) 5 MB of memory is provided for SQLite to use, once that much has been consumed, SQLite will start returning SQLITE_NOMEM errors, rather than soaking up memory needed by other parts of the application. This also sandboxes SQLite's memory so that a write-after-free error in some other part of the application will not cause problems for SQLite, or vice versa.</source>
          <target state="translated">В крайних случаях рассмотрите возможность компиляции SQLite с параметром &lt;a href=&quot;compile#enable_memsys5&quot;&gt;-DSQLITE_ENABLE_MEMSYS5,&lt;/a&gt; а затем предоставления SQLite фиксированного фрагмента памяти для использования в качестве кучи через интерфейс &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt; ( &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigheap&quot;&gt;SQLITE_CONFIG_HEAP&lt;/a&gt; ). Это предотвратит выполнение вредоносным SQL-кодом атаки отказа в обслуживании с использованием чрезмерного объема памяти. Если (скажем) 5 МБ памяти предоставлено для использования SQLite, как только эта большая часть будет израсходована, SQLite начнет возвращать ошибки SQLITE_NOMEM вместо того, чтобы поглощать память, необходимую для других частей приложения. Это также изолирует память SQLite, чтобы ошибка записи после освобождения в какой-либо другой части приложения не вызывала проблем для SQLite и наоборот.</target>
        </trans-unit>
        <trans-unit id="b60127a70276716ca6ce96b164af1caff22c34ff" translate="yes" xml:space="preserve">
          <source>In fairness to PostgreSQL, it started thrashing on this test. A knowledgeable administrator might be able to get PostgreSQL to run a lot faster here by tweaking and tuning the server a little.</source>
          <target state="translated">Честно говоря,PostgreSQL начал &quot;морочить голову&quot; на этом тесте.Знающий администратор мог бы заставить PostgreSQL работать здесь намного быстрее,немного отрегулировав и настроив сервер.</target>
        </trans-unit>
        <trans-unit id="776b2a0854afad2e6c812aae004c09f148d516c9" translate="yes" xml:space="preserve">
          <source>In fairness, having a built-in implementation of printf() also comes with some disadvantages. To wit:</source>
          <target state="translated">Справедливости ради следует отметить,что наличие встроенной реализации функции printf()также имеет некоторые недостатки.В частности:</target>
        </trans-unit>
        <trans-unit id="c2fda1dfe98bf18ac7aa5572676942f62e5e1fe2" translate="yes" xml:space="preserve">
          <source>In first form, if the main database has already been created, then this pragma returns the text encoding used by the main database, one of 'UTF-8', 'UTF-16le' (little-endian UTF-16 encoding) or 'UTF-16be' (big-endian UTF-16 encoding). If the main database has not already been created, then the value returned is the text encoding that will be used to create the main database, if it is created by this session.</source>
          <target state="translated">В первой форме,если основная БД уже создана,то эта прагма возвращает текстовую кодировку,используемую основной БД,одну из 'UTF-8','UTF-16le' (little-endian UTF-16 encoding)или 'UTF-16be' (big-endian UTF-16 encoding).Если основная БД еще не создана,то возвращаемым значением будет текстовая кодировка,которая будет использована для создания основной БД,если она будет создана данной сессией.</target>
        </trans-unit>
        <trans-unit id="b4265b09e5ee96a8a7b2a30c889a0bcc8a3fb773" translate="yes" xml:space="preserve">
          <source>In formats 4, 7, and 10, the fractional seconds value SS.SSS can have one or more digits following the decimal point. Exactly three digits are shown in the examples because only the first three digits are significant to the result, but the input string can have fewer or more than three digits and the date/time functions will still operate correctly. Similarly, format 12 is shown with 10 significant digits, but the date/time functions will really accept as many or as few digits as are necessary to represent the Julian day number.</source>
          <target state="translated">В форматах 4,7 и 10 значение SS.SSS в дробных секундах может иметь одну или несколько цифр после запятой.Точно три цифры показаны в примерах,потому что только первые три цифры имеют значение для результата,но входная строка может иметь меньше или больше трех цифр,и функции даты/времени все равно будут работать корректно.Аналогично,формат 12 показан с 10 значащими цифрами,но функции даты/времени действительно будут принимать столько или столько цифр,сколько необходимо для представления юлианского номера дня.</target>
        </trans-unit>
        <trans-unit id="af29b68f8112f5b3ba3c7546feb616bd5c5cfef7" translate="yes" xml:space="preserve">
          <source>In formats 5 through 7, the &quot;T&quot; is a literal character separating the date and the time, as required by &lt;a href=&quot;http://www.w3c.org/TR/NOTE-datetime&quot;&gt;ISO-8601&lt;/a&gt;. Formats 8 through 10 that specify only a time assume a date of 2000-01-01. Format 11, the string 'now', is converted into the current date and time as obtained from the xCurrentTime method of the &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object in use. The 'now' argument to date and time functions always returns exactly the same value for multiple invocations within the same &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; call. &lt;a href=&quot;http://en.wikipedia.org/wiki/Coordinated_Universal_Time&quot;&gt;Universal Coordinated Time (UTC)&lt;/a&gt; is used. Format 12 is the &lt;a href=&quot;http://en.wikipedia.org/wiki/Julian_day&quot;&gt;Julian day number&lt;/a&gt; expressed as a floating point value.</source>
          <target state="translated">В форматах с 5 по 7 буква &amp;laquo;T&amp;raquo; - это буквальный символ, разделяющий дату и время, в соответствии с требованиями &lt;a href=&quot;http://www.w3c.org/TR/NOTE-datetime&quot;&gt;ISO-8601&lt;/a&gt; . Форматы с 8 по 10, которые определяют только время, предполагают дату 2000-01-01. Формат 11, строка &amp;laquo;сейчас&amp;raquo;, преобразуется в текущую дату и время, получаемые из метода xCurrentTime используемого объекта &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; . Аргумент &amp;laquo;сейчас&amp;raquo; для функций даты и времени всегда возвращает одно и то же значение для нескольких вызовов в рамках одного и того же вызова &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step ()&lt;/a&gt; . Используется &lt;a href=&quot;http://en.wikipedia.org/wiki/Coordinated_Universal_Time&quot;&gt;универсальное координированное время (UTC)&lt;/a&gt; . Формат 12 - это &lt;a href=&quot;http://en.wikipedia.org/wiki/Julian_day&quot;&gt;число дней&lt;/a&gt; по юлианскому календарю, выраженное как значение с плавающей запятой.</target>
        </trans-unit>
        <trans-unit id="6d5b683fb78e2961a927a0de31b24ecad02f2548" translate="yes" xml:space="preserve">
          <source>In formats 5 through 7, the &quot;T&quot; is a literal character separating the date and the time, as required by &lt;a href=&quot;http://www.w3c.org/TR/NOTE-datetime&quot;&gt;ISO-8601&lt;/a&gt;. Formats 8 through 10 that specify only a time assume a date of 2000-01-01. Format 11, the string 'now', is converted into the current date and time as obtained from the xCurrentTime method of the &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object in use. The 'now' argument to date and time functions always returns exactly the same value for multiple invocations within the same &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; call. &lt;a href=&quot;https://en.wikipedia.org/wiki/Coordinated_Universal_Time&quot;&gt;Universal Coordinated Time (UTC)&lt;/a&gt; is used. Format 12 is the &lt;a href=&quot;https://en.wikipedia.org/wiki/Julian_day&quot;&gt;Julian day number&lt;/a&gt; expressed as an integer or floating point value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f289b58633d51c42244b9615eefef812e48059b3" translate="yes" xml:space="preserve">
          <source>In general, you can do anything with a &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; that can be done with an ordinary table, except that you cannot create indices or triggers on a virtual table. Some virtual table implementations might impose additional restrictions. For example, many virtual tables are read-only.</source>
          <target state="translated">В общем, вы можете делать с &lt;a href=&quot;vtab&quot;&gt;виртуальной таблицей все,&lt;/a&gt; что можно сделать с обычной таблицей, за исключением того, что вы не можете создавать индексы или триггеры для виртуальной таблицы. Некоторые реализации виртуальных таблиц могут налагать дополнительные ограничения. Например, многие виртуальные таблицы доступны только для чтения.</target>
        </trans-unit>
        <trans-unit id="eeca88e5ce04c05464f766d95ff0eeb5cfc7eabb" translate="yes" xml:space="preserve">
          <source>In hindsight, we should not have tried to make SQLite accept MySQL 3.x syntax, and should have never allowed double-quoted string literals. However, there are countless applications that make use of double-quoted string literals and so we continue to support that capability to avoid breaking legacy.</source>
          <target state="translated">Оглядываясь назад,мы не должны были пытаться заставить SQLite принять синтаксис MySQL 3.x,и никогда не должны были допускать использования строковых литералов в двойных кавычках.Однако,существует бесчисленное множество приложений,использующих строковые литералы в двойных кавычках,и поэтому мы продолжаем поддерживать эту возможность,чтобы не нарушить наследие.</target>
        </trans-unit>
        <trans-unit id="5bb614f9a4728b882cfa854761e8ce05293a6c53" translate="yes" xml:space="preserve">
          <source>In in TRIGGERSs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc71bff31ad5848828d3dd9115d5b5dfb6294eb3" translate="yes" xml:space="preserve">
          <source>In in VIEWs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8391805f21124b7f78b7878689397e781e990db" translate="yes" xml:space="preserve">
          <source>In interactive mode, sqlite3 reads input text (either SQL statements or &lt;a href=&quot;cli#dotcmd&quot;&gt;dot-commands&lt;/a&gt;) from the keyboard. You can also redirect input from a file when you launch sqlite3, of course, but then you do not have the ability to interact with the program. Sometimes it is useful to run an SQL script contained in a file entering other commands from the command-line. For this, the &quot;.read&quot; dot-command is provided.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3caa4201cfb419be724f72954ef422185458de8" translate="yes" xml:space="preserve">
          <source>In its default configuration, SQLite API routines return one of 30 integer &lt;a href=&quot;../rescode&quot;&gt;result codes&lt;/a&gt;. However, experience has shown that many of these result codes are too coarse-grained. They do not provide as much information about problems as programmers might like. In an effort to address this, newer versions of SQLite (version 3.3.8 2006-10-09 and later) include support for additional result codes that provide more detailed information about errors. These &lt;a href=&quot;../rescode#extrc&quot;&gt;extended result codes&lt;/a&gt; are enabled or disabled on a per database connection basis using the &lt;a href=&quot;extended_result_codes&quot;&gt;sqlite3_extended_result_codes()&lt;/a&gt; API. Or, the extended code for the most recent error can be obtained using &lt;a href=&quot;errcode&quot;&gt;sqlite3_extended_errcode()&lt;/a&gt;.</source>
          <target state="translated">В своей конфигурации по умолчанию процедуры API SQLite возвращают один из 30 целочисленных &lt;a href=&quot;../rescode&quot;&gt;кодов результата&lt;/a&gt; . Однако опыт показал, что многие из этих результирующих кодов слишком грубые. Они не предоставляют столько информации о проблемах, сколько хотелось бы программистам. Чтобы решить эту проблему, новые версии SQLite (версия 3.3.8 2006-10-09 и более поздние) включают поддержку дополнительных кодов результатов, которые предоставляют более подробную информацию об ошибках. Эти &lt;a href=&quot;../rescode#extrc&quot;&gt;расширенные коды результатов&lt;/a&gt; включаются или выключаются для каждого соединения с базой данных с помощью API &lt;a href=&quot;extended_result_codes&quot;&gt;sqlite3_extended_result_codes ()&lt;/a&gt; . Или расширенный код последней ошибки можно получить с помощью &lt;a href=&quot;errcode&quot;&gt;sqlite3_extended_errcode ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3039a66b6632d9561c27b79f80cd7bfba4d1c329" translate="yes" xml:space="preserve">
          <source>In its default configuration, SQLite API routines return one of 30 integer &lt;a href=&quot;rescode&quot;&gt;result codes&lt;/a&gt;. However, experience has shown that many of these result codes are too coarse-grained. They do not provide as much information about problems as programmers might like. In an effort to address this, newer versions of SQLite (version 3.3.8 2006-10-09 and later) include support for additional result codes that provide more detailed information about errors. These &lt;a href=&quot;rescode#extrc&quot;&gt;extended result codes&lt;/a&gt; are enabled or disabled on a per database connection basis using the &lt;a href=&quot;#sqlite3_extended_result_codes&quot;&gt;sqlite3_extended_result_codes()&lt;/a&gt; API. Or, the extended code for the most recent error can be obtained using &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_extended_errcode()&lt;/a&gt;.</source>
          <target state="translated">В своей конфигурации по умолчанию процедуры API SQLite возвращают один из 30 целочисленных &lt;a href=&quot;rescode&quot;&gt;кодов результата&lt;/a&gt; . Однако опыт показал, что многие из этих результирующих кодов слишком грубые. Они не предоставляют столько информации о проблемах, сколько хотелось бы программистам. Чтобы решить эту проблему, новые версии SQLite (версия 3.3.8 2006-10-09 и более поздние) включают поддержку дополнительных кодов результатов, которые предоставляют более подробную информацию об ошибках. Эти &lt;a href=&quot;rescode#extrc&quot;&gt;расширенные коды результатов&lt;/a&gt; включаются или выключаются для каждого соединения с базой данных с помощью API &lt;a href=&quot;#sqlite3_extended_result_codes&quot;&gt;sqlite3_extended_result_codes ()&lt;/a&gt; . Или расширенный код последней ошибки можно получить с помощью &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_extended_errcode ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c851426635cb37e8f1ffc6284cb9e22ec511a9f4" translate="yes" xml:space="preserve">
          <source>In keeping with the pile-of-files theme, OpenDocument stores all slide content in a single big XML file named &quot;content.xml&quot;. LibreOffice reads and parses this entire file just to display the first slide. LibreOffice also seems to read all images into memory as well, which makes sense seeing as when the user does &quot;File/Save&quot; it is going to have to write them all back out again, even though none of them changed. The net effect is that start-up is slow. Double-clicking an OpenDocument file brings up a progress bar rather than the first slide. This results in a bad user experience. The situation grows ever more annoying as the document size increases.</source>
          <target state="translated">В соответствии с темой &quot;куча файлов&quot;,OpenDocument хранит все содержимое слайдов в одном большом XML файле под названием &quot;content.xml&quot;.LibreOffice читает и анализирует весь этот файл только для отображения первого слайда.LibreOffice также,кажется,читает все изображения в память,что имеет смысл,так как когда пользователь делает &quot;Файл/Сохранить&quot;,ему придется записать их все обратно,несмотря на то,что ни одно из них не изменилось.Совокупный эффект заключается в том,что запуск происходит медленно.Двойной щелчок на файле OpenDocument приводит к появлению индикатора прогресса,а не первого слайда.Это приводит к плохим результатам работы пользователя.Ситуация становится все более раздражающей с увеличением размера документа.</target>
        </trans-unit>
        <trans-unit id="c55972e777545acb2431d05db4c4023b23be4d2b" translate="yes" xml:space="preserve">
          <source>In many cases, method (1) above is the best approach. It does not add extra data to the FTS index or require FTS5 to query for multiple terms, so it is efficient in terms of disk space and query speed. However, it does not support prefix queries very well. If, as suggested above, the token &quot;first&quot; is substituted for &quot;1st&quot; by the tokenizer, then the query:</source>
          <target state="translated">Во многих случаях лучшим подходом является метод (1),описанный выше.Он не добавляет дополнительные данные в индекс FTS и не требует от FTS5 запроса на несколько терминов,поэтому он эффективен с точки зрения дискового пространства и скорости запроса.Однако он не очень хорошо поддерживает префиксные запросы.Если,как предлагалось выше,токен &quot;первый&quot; заменяется токеном &quot;первый&quot; на токенайзер,то запрос:</target>
        </trans-unit>
        <trans-unit id="5d477280cde1f0cb61a1a86eeb18153043aeb432" translate="yes" xml:space="preserve">
          <source>In most SQL databases, if you have a &lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE&lt;/a&gt;, &lt;a href=&quot;lang_createtable#notnullconst&quot;&gt;NOT NULL&lt;/a&gt;, or &lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK&lt;/a&gt; constraint on a table and you try to do an &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; or &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; that violates the constraint, the database will abort the operation in progress, back out any prior changes associated with the same UPDATE or INSERT statement, and return an error. This is the default behavior of SQLite, though SQLite also allows one to define alternative ways for dealing with constraint violations. This article describes those alternatives and how to use them.</source>
          <target state="translated">В большинстве баз данных SQL, если у вас есть ограничение &lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE&lt;/a&gt; , &lt;a href=&quot;lang_createtable#notnullconst&quot;&gt;NOT NULL&lt;/a&gt; или &lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK&lt;/a&gt; для таблицы и вы пытаетесь выполнить &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; или &lt;a href=&quot;lang_insert&quot;&gt;INSERT,&lt;/a&gt; который нарушает ограничение, база данных прервет текущую операцию, отменив все предыдущие изменения, связанные с тот же оператор UPDATE или INSERT и возвращает ошибку. Это поведение SQLite по умолчанию, хотя SQLite также позволяет определять альтернативные способы работы с нарушениями ограничений. В этой статье описаны эти альтернативы и их использование.</target>
        </trans-unit>
        <trans-unit id="a92a8e52f2222eb943cf97b12f1b58ee960571a6" translate="yes" xml:space="preserve">
          <source>In most SQL implementations, output columns of an aggregate query may only reference aggregate functions or columns named in the GROUP BY clause. It does not make good sense to reference an ordinary column in an aggregate query because each output row might be composed from two or more rows in the input table(s).</source>
          <target state="translated">В большинстве реализаций SQL,выходные столбцы агрегированного запроса могут ссылаться только на агрегированные функции или столбцы,названные в пункте GROUP BY.Не имеет смысла ссылаться на обычный столбец в совокупном запросе,потому что каждая выходная строка может состоять из двух или более строк во входной таблице (таблицах).</target>
        </trans-unit>
        <trans-unit id="ebf21aed9282198e08f544c4b59f1cde35658d89" translate="yes" xml:space="preserve">
          <source>In most applications, the database page cache subsystem within SQLite uses more dynamically allocated memory than all other parts of SQLite combined. It is not unusual to see the database page cache consume over 10 times more memory than the rest of SQLite combined.</source>
          <target state="translated">В большинстве приложений подсистема кэширования страниц базы данных внутри SQLite использует больше динамически выделяемой памяти,чем все остальные части SQLite вместе взятые.Нет ничего необычного в том,что кэш страниц БД потребляет в 10 раз больше памяти,чем остальные части SQLite вместе взятые.</target>
        </trans-unit>
        <trans-unit id="ea5d93a0bdef6b6a869ec9bc6ec20416d6dd4af5" translate="yes" xml:space="preserve">
          <source>In most applications, the number of columns is small - a few dozen. There are places in the SQLite code generator that use algorithms that are O(N&amp;sup2;) where N is the number of columns. So if you redefine SQLITE_MAX_COLUMN to be a really huge number and you generate SQL that uses a large number of columns, you may find that &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; runs slowly.</source>
          <target state="translated">В большинстве приложений количество столбцов невелико - несколько десятков. В генераторе кода SQLite есть места, в которых используются алгоритмы O (N&amp;sup2;), где N - количество столбцов. Поэтому, если вы переопределите SQLITE_MAX_COLUMN, чтобы оно было действительно огромным числом, и сгенерировали SQL, который использует большое количество столбцов, вы можете обнаружить, что &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; работает медленно.</target>
        </trans-unit>
        <trans-unit id="5715db4d1b11556e8f8726b68f211a79da84d8fd" translate="yes" xml:space="preserve">
          <source>In most cases, UNIQUE and PRIMARY KEY constraints are implemented by creating a unique index in the database. (The exceptions are &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; and PRIMARY KEYs on &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables.) Hence, the following schemas are logically equivalent:</source>
          <target state="translated">В большинстве случаев ограничения UNIQUE и PRIMARY KEY реализуются путем создания уникального индекса в базе данных. (Исключениями являются &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; и PRIMARY KEY в таблицах &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; .) Следовательно, следующие схемы логически эквивалентны:</target>
        </trans-unit>
        <trans-unit id="5a1cd73f371732c3b6f817956ff2682bb7f1000a" translate="yes" xml:space="preserve">
          <source>In most cases, you will want to supplement the basic commands above with &lt;a href=&quot;compile&quot;&gt;compile-time options&lt;/a&gt; appropriate for your application. Commonly used compile-time options include:</source>
          <target state="translated">В большинстве случаев вы захотите дополнить приведенные выше базовые команды &lt;a href=&quot;compile&quot;&gt;параметрами времени компиляции,&lt;/a&gt; подходящими для вашего приложения. Обычно используемые параметры времени компиляции включают:</target>
        </trans-unit>
        <trans-unit id="97ef5a309f4aafbcba4ef803b72a915f31e696d6" translate="yes" xml:space="preserve">
          <source>In most contexts, the special &quot;rowid&quot; column of normal tables can also be called &quot;oid&quot; or &quot;_rowid_&quot;. However, only &quot;rowid&quot; works as the keyword in the CREATE TABLE statement.</source>
          <target state="translated">В большинстве контекстов специальный столбец &quot;rowid&quot; обычных таблиц также может называться &quot;oid&quot; или &quot;_rowid_&quot;.Однако,только &quot;rowid&quot; работает в качестве ключевого слова в операторе CREATE TABLE.</target>
        </trans-unit>
        <trans-unit id="08bdbf2096af9fe45fd4ac595bd3e0c7bb6e8da7" translate="yes" xml:space="preserve">
          <source>In most other SQL database engines the datatype is associated with the table column that holds the data - with the data container. In SQLite 3.0, the datatype is associated with the data itself, not with its container. &lt;a href=&quot;http://www.paulgraham.com/&quot;&gt;Paul Graham&lt;/a&gt; in his book</source>
          <target state="translated">В большинстве других механизмов баз данных SQL тип данных связан со столбцом таблицы, в котором хранятся данные, - с контейнером данных. В SQLite 3.0 тип данных связан с самими данными, а не с их контейнером. &lt;a href=&quot;http://www.paulgraham.com/&quot;&gt;Пол Грэм&lt;/a&gt; в своей книге</target>
        </trans-unit>
        <trans-unit id="9b4441386a86e2d230e048847afd960634eadb47" translate="yes" xml:space="preserve">
          <source>In normal cases, new content is appended to the WAL file until the WAL file accumulates about 1000 pages (and is thus about 4MB in size) at which point a checkpoint is automatically run and the WAL file is recycled. The checkpoint does not normally truncate the WAL file (unless the &lt;a href=&quot;pragma#pragma_journal_size_limit&quot;&gt;journal_size_limit pragma&lt;/a&gt; is set). Instead, it merely causes SQLite to start overwriting the WAL file from the beginning. This is done because it is normally faster to overwrite an existing file than to append. When the last connection to a database closes, that connection does one last checkpoint and then deletes the WAL and its associated shared-memory file, to clean up the disk.</source>
          <target state="translated">В обычных случаях новое содержимое добавляется к файлу WAL до тех пор, пока файл WAL не накапливает около 1000 страниц (и, таким образом, имеет размер около 4 МБ), после чего автоматически запускается контрольная точка, а файл WAL повторно используется. Контрольная точка обычно не &lt;a href=&quot;pragma#pragma_journal_size_limit&quot;&gt;усекает&lt;/a&gt; файл WAL (если не установлена ​​прагма journal_size_limit ). Вместо этого он просто заставляет SQLite начать перезапись файла WAL с самого начала. Это сделано потому, что обычно быстрее перезаписать существующий файл, чем добавить. Когда последнее соединение с базой данных закрывается, это соединение выполняет одну последнюю контрольную точку, а затем удаляет WAL и связанный с ним файл общей памяти для очистки диска.</target>
        </trans-unit>
        <trans-unit id="9b10dbf3c620afa11c457409454feda884f8c775" translate="yes" xml:space="preserve">
          <source>In older versions of SQLite, shared cache mode could not be used together with virtual tables. This restriction was removed in SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_6_17.html&quot;&gt;version 3.6.17&lt;/a&gt; (2009-08-10).</source>
          <target state="translated">В более старых версиях SQLite режим общего кэша нельзя было использовать вместе с виртуальными таблицами. Это ограничение было снято в SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_6_17.html&quot;&gt;версии 3.6.17&lt;/a&gt; ( 10.08.2009 ).</target>
        </trans-unit>
        <trans-unit id="c0ec8617fee4e8f946bad89174a49f940e3f428d" translate="yes" xml:space="preserve">
          <source>In one test that indexed a large set of emails (1636 MiB on disk), the FTS index was 743 MiB on disk with detail=full, 340 MiB with detail=column and 134 MiB with detail=none.</source>
          <target state="translated">В одном тесте,который индексировал большой набор электронных сообщений (1636 Мб на диске),индекс FTS составлял 743 Мб на диске с detail=full,340 Мб с detail=column и 134 Мб с detail=none.</target>
        </trans-unit>
        <trans-unit id="79708a29f43e4b6af877ac3750b35c58a6cfa4a6" translate="yes" xml:space="preserve">
          <source>In order for an application to &lt;a href=&quot;fts5#extending_fts5&quot;&gt;add new extensions to FTS5&lt;/a&gt;, such as new tokenizers, the application needs a pointer to the &quot;fts5_api&quot; object.</source>
          <target state="translated">Чтобы приложение &lt;a href=&quot;fts5#extending_fts5&quot;&gt;могло добавлять новые расширения в FTS5&lt;/a&gt; , такие как новые токенизаторы, приложению необходим указатель на объект &amp;laquo;fts5_api&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="28a836bfad6faf09ee027032e5467aeee1a64f66" translate="yes" xml:space="preserve">
          <source>In order for the OR-by-UNION technique shown above to be useful, there must be an index available that helps resolve every OR-connected term in the WHERE clause. If even a single OR-connected term is not indexed, then a full table scan would have to be done in order to find the rowids generated by the one term, and if SQLite has to do a full table scan, it might as well do it on the original table and get all of the results in a single pass without having to mess with union operations and follow-on binary searches.</source>
          <target state="translated">Для того,чтобы показанная выше техника &quot;по ИЛИ&quot; была полезной,должен быть доступен индекс,помогающий разрешить каждый ИЛИ-связанный термин в пункте ГДЕ.Если даже один термин,связанный с оператором &quot;OR&quot;,не индексируется,то необходимо выполнить полное сканирование таблицы,чтобы найти строки,сгенерированные одним термином,а если SQLite должен выполнить полное сканирование таблицы,то он может сделать это и на исходной таблице и получить все результаты за один проход,не связываясь с операциями объединения и последующим бинарным поиском.</target>
        </trans-unit>
        <trans-unit id="eb3713c378b1d1ce3d9a0c47d48cd2eaea6cff83" translate="yes" xml:space="preserve">
          <source>In order to allow multiple threads to use the same database connection at the same time, SQLite must make extensive use of mutexes. And for this reason a new mutex subsystem as been added. The mutex subsystem as the following interface:</source>
          <target state="translated">Для того чтобы несколько потоков могли использовать одно и то же подключение к базе данных одновременно,SQLite должен широко использовать мьютексы.И по этой причине была добавлена новая подсистема мьютексов.Подсистема мьютекса в качестве интерфейса:</target>
        </trans-unit>
        <trans-unit id="2b5d71d84c9eba5a8b5eeb690db9b2671be986f0" translate="yes" xml:space="preserve">
          <source>In order to avoid this problem, instead of a single large buffer, input is passed to a streaming API functions by way of a callback function that the sessions module invokes to incrementally request input data as it is required. In all cases, a pair of API function parameters such as</source>
          <target state="translated">Чтобы избежать этой проблемы,вместо одного большого буфера,вход передаётся в потоковое API-функции посредством функции обратного вызова,которую модуль сеансов вызывает для инкрементального запроса входных данных по мере необходимости.Во всех случаях пара параметров функции API,таких как</target>
        </trans-unit>
        <trans-unit id="4b125f2963fbbbf781a2aacf5295274d0ac9b884" translate="yes" xml:space="preserve">
          <source>In order to calculate a documents score, the full-text query is separated into its component phrases. The bm25 score for document</source>
          <target state="translated">Для вычисления оценки документов полнотекстовый запрос разделяется на составляющие его фразы.Оценка bm25 для документа</target>
        </trans-unit>
        <trans-unit id="7154e5ea3dd269ef8c7a3c815659cc160be40ee6" translate="yes" xml:space="preserve">
          <source>In order to change the mapping of the rank column for a single query, a term similar to either of the following is added to the WHERE clause of a query:</source>
          <target state="translated">Чтобы изменить отображение рангового столбца для одного запроса,в выражение WHERE запроса добавляется термин,аналогичный одному из следующих:</target>
        </trans-unit>
        <trans-unit id="2abb792779e09d00b7b2cceff1ab43c73c0ae359" translate="yes" xml:space="preserve">
          <source>In order to create an FTS4 table that does not store a copy of the indexed documents at all, the content option should be set to an empty string. For example, the following SQL creates such an FTS4 table with three columns - &quot;a&quot;, &quot;b&quot;, and &quot;c&quot;:</source>
          <target state="translated">Для создания таблицы FTS4,в которой вообще не хранится копия проиндексированных документов,параметр содержимого должен быть установлен в пустую строку.Например,следующий SQL создает такую таблицу FTS4 с тремя столбцами-&quot;a&quot;,&quot;b&quot; и &quot;c&quot;:</target>
        </trans-unit>
        <trans-unit id="dfa1c414109c4c2ee027ceb1647c28553c0a4044" translate="yes" xml:space="preserve">
          <source>In order to create or modify an existing zip file, a &quot;zipfile&quot; virtual table must be created in the database schema. The CREATE VIRTUAL TABLE statement expects a path to the zip file as its only argument. For example, to write to zip file &quot;test.zip&quot; in the current directory, a zipfile table may be created using:</source>
          <target state="translated">Для того,чтобы создать или изменить существующий zip-файл,в схеме базы данных должна быть создана виртуальная таблица &quot;zip-файл&quot;.Оператор CREATE VIRTUAL TABLE ожидает в качестве единственного аргумента путь к zip-файлу.Например,для записи в zip-файл &quot;test.zip&quot; в текущем каталоге можно создать zip-таблицу:</target>
        </trans-unit>
        <trans-unit id="46eb456df96a41735386e11e34c4d6e23c625078" translate="yes" xml:space="preserve">
          <source>In order to determine whether or not the database file has changed, SQLite uses a counter in the database header (in bytes 24 through 27) which is incremented during every change operation. SQLite saves a copy of this counter prior to releasing its database lock. Then after acquiring the next database lock it compares the saved counter value against the current counter value and erases the cache if the values are different, or reuses the cache if they are the same.</source>
          <target state="translated">Для того чтобы определить,изменился ли файл базы данных,SQLite использует счетчик в заголовке базы данных (в байтах с 24 по 27),который инкрементируется при каждой операции изменения.SQLite сохраняет копию этого счетчика до освобождения блокировки базы данных.Затем после получения следующей блокировки базы данных он сравнивает сохраненное значение счетчика с текущим значением счетчика и стирает кэш,если значения отличаются,или повторно использует кэш,если они совпадают.</target>
        </trans-unit>
        <trans-unit id="c5338f8b41864bbeb0f4c2c2e58a285f7e7a5717" translate="yes" xml:space="preserve">
          <source>In order to gain experience with the main ideas surrounding asynchronous IO, this implementation is deliberately kept simple. Additional capabilities may be added in the future.</source>
          <target state="translated">Для того,чтобы получить опыт работы с основными идеями,окружающими асинхронный ввод-вывод,эта реализация намеренно поддерживается простой.Дополнительные возможности могут быть добавлены в будущем.</target>
        </trans-unit>
        <trans-unit id="a809ecf69a6ad9ffe3bc78cfb9dbeacb5971a731" translate="yes" xml:space="preserve">
          <source>In order to guarantee that database files are always consistent, SQLite will occasionally ask the operating system to flush all pending writes to persistent storage then wait for that flush to complete. This is accomplished using the &lt;code&gt;fsync()&lt;/code&gt; system call under unix and &lt;code&gt;FlushFileBuffers()&lt;/code&gt; under Windows. We call this flush of pending writes a &quot;sync&quot;.</source>
          <target state="translated">Чтобы гарантировать, что файлы базы данных всегда согласованы, SQLite иногда запрашивает операционную систему сбросить все ожидающие записи в постоянное хранилище, а затем ждать завершения этой очистки. Это достигается с помощью системного вызова &lt;code&gt;fsync()&lt;/code&gt; в unix и &lt;code&gt;FlushFileBuffers()&lt;/code&gt; в Windows. Мы называем этот сброс отложенных записей &quot;синхронизацией&quot;.</target>
        </trans-unit>
        <trans-unit id="78171183b8bae18fcaabb772e335a2f85feaf3a5" translate="yes" xml:space="preserve">
          <source>In order to maintain backwards compatibility, this setting is ON by default. There are advantages to turning it off, and most applications will be unaffected if it is turned off. For that reason, all applications are encouraged to switch this setting off on every database connection as soon as that connection is opened.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d3d52a785446942df482ef9658c77840bb31674" translate="yes" xml:space="preserve">
          <source>In order to maintain full backwards compatibility for legacy applications, the URI filename capability is disabled by default. URI filenames can be enabled or disabled using the &lt;a href=&quot;compile#use_uri&quot;&gt;SQLITE_USE_URI=1&lt;/a&gt; or &lt;a href=&quot;compile#use_uri&quot;&gt;SQLITE_USE_URI=0&lt;/a&gt; compile-time options. The compile-time setting for URI filenames can be changed at start-time using the &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfiguri&quot;&gt;SQLITE_CONFIG_URI&lt;/a&gt;,1) or &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfiguri&quot;&gt;SQLITE_CONFIG_URI&lt;/a&gt;,0) configuration calls. Regardless of the compile-time or start-time settings, URI filenames can be enabled for individual database connections by including the &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_URI&lt;/a&gt; bit in the set of bits passed as the F parameter to &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2(N,P,F,V)&lt;/a&gt;.</source>
          <target state="translated">Чтобы поддерживать полную обратную совместимость для устаревших приложений, возможность использования имени файла URI по умолчанию отключена. Имена файлов URI могут быть включены или отключены с помощью параметров времени &lt;a href=&quot;compile#use_uri&quot;&gt;компиляции SQLITE_USE_URI = 1&lt;/a&gt; или &lt;a href=&quot;compile#use_uri&quot;&gt;SQLITE_USE_URI = 0&lt;/a&gt; . Настройка времени компиляции для имен файлов URI может быть изменена во время запуска с помощью вызовов конфигурации &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt; ( &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfiguri&quot;&gt;SQLITE_CONFIG_URI&lt;/a&gt; , 1) или &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt; ( &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfiguri&quot;&gt;SQLITE_CONFIG_URI&lt;/a&gt; , 0). Независимо от настроек времени компиляции или времени начала, имена файлов URI можно включить для отдельных подключений к базе данных, включив бит &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_URI&lt;/a&gt; в набор битов, переданных в качестве параметра F в &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2 (N, P, F, V)&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="ee9ce9696c9f5b398459fe9fa5003d871b602ba2" translate="yes" xml:space="preserve">
          <source>In order to maximize compatibility between SQLite and other database engines, and so that the example above will work on SQLite as it does on other SQL database engines, SQLite supports the concept of &quot;type affinity&quot; on columns. The type affinity of a column is the recommended type for data stored in that column. The important idea here is that the type is recommended, not required. Any column can still store any type of data. It is just that some columns, given the choice, will prefer to use one storage class over another. The preferred storage class for a column is called its &quot;affinity&quot;.</source>
          <target state="translated">Для обеспечения максимальной совместимости между SQLite и другими движками баз данных,а также для того,чтобы приведенный выше пример работал на SQLite так же,как он работает на других движках баз данных SQL,SQLite поддерживает концепцию &quot;сродства по типам&quot; на столбцах.Сродство к типу столбца является рекомендуемым типом для данных,хранящихся в этом столбце.Важной идеей здесь является то,что тип рекомендуется,а не требуется.Любой столбец может хранить данные любого типа.Просто некоторые столбцы,при наличии выбора,предпочтут использовать один класс хранения,а не другой.Предпочтительный для столбца класс хранения называется его &quot;родством&quot;.</target>
        </trans-unit>
        <trans-unit id="c4c58e4d4912a4704b0cbb27832e1afdc4578e5c" translate="yes" xml:space="preserve">
          <source>In order to port SQLite to a new operating system - an operating system not supported by default - the application must provide...</source>
          <target state="translated">Для того чтобы перенести SQLite на новую операционную систему-операционную систему,не поддерживаемую по умолчанию-приложение должно предоставить...</target>
        </trans-unit>
        <trans-unit id="9139039adfb729ff69195002226ce412be58a20b" translate="yes" xml:space="preserve">
          <source>In order to prevent the number of b-trees in the database from becoming too large (slowing down queries), smaller b-trees are periodically merged into single larger b-trees containing the same data. By default, this happens automatically within INSERT, UPDATE or DELETE statements that modify the full-text index. The 'automerge' parameter determines how many smaller b-trees are merged together at a time. Setting it to a small value can speed up queries (as they have to query and merge the results from fewer b-trees), but can also slow down writing to the database (as each INSERT, UPDATE or DELETE statement has to do more work as part of the automatic merging process).</source>
          <target state="translated">Для того чтобы количество b-деревьев в БД не становилось слишком большим (замедление запросов),меньшие b-деревьи периодически объединяются в одни более крупные b-деревьи,содержащие одни и те же данные.По умолчанию это происходит автоматически в операторах INSERT,UPDATE или DELETE,которые изменяют полнотекстовый индекс.Параметр 'automerge' определяет,сколько меньших b-деревьев объединяется одновременно.Установка небольшого значения может не только ускорить запросы (так как они должны запрашивать и объединять результаты из меньшего количества b-деревьев),но и замедлить запись в базу данных (так как каждый оператор INSERT,UPDATE или DELETE должен выполнять больше работы в рамках автоматического объединения).</target>
        </trans-unit>
        <trans-unit id="3d48be902e74206d36d33669d85fb41c800c7878" translate="yes" xml:space="preserve">
          <source>In order to provide portability between across operating systems, SQLite uses abstract object called the &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;. Each VFS provides methods for opening, read, writing, and closing files on disk, and for other OS-specific task such as finding the current time, or obtaining randomness to initialize the built-in pseudo-random number generator. SQLite currently provides VFSes for unix (in the &lt;a href=&quot;https://sqlite.org/src/file/src/os_unix.c&quot;&gt;os_unix.c&lt;/a&gt; file) and Windows (in the &lt;a href=&quot;https://sqlite.org/src/file/src/os_win.c&quot;&gt;os_win.c&lt;/a&gt; file).</source>
          <target state="translated">Чтобы обеспечить переносимость между операционными системами, SQLite использует абстрактный объект, называемый &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; . Каждая VFS предоставляет методы для открытия, чтения, записи и закрытия файлов на диске, а также для других задач, специфичных для ОС, таких как определение текущего времени или получение случайности для инициализации встроенного генератора псевдослучайных чисел. В настоящее время SQLite предоставляет VFS для unix (в файле &lt;a href=&quot;https://sqlite.org/src/file/src/os_unix.c&quot;&gt;os_unix.c&lt;/a&gt; ) и Windows (в файле &lt;a href=&quot;https://sqlite.org/src/file/src/os_win.c&quot;&gt;os_win.c&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="31ad990efe0b69348774fca33a1caeca8003e9e6" translate="yes" xml:space="preserve">
          <source>In order to rebase a local changeset, the remote changeset must first be applied to the local database using sqlite3changeset_apply_v2() and the buffer of rebase information captured. Then:</source>
          <target state="translated">Для того,чтобы выполнить ребейсинг локального changeset,необходимо сначала применить удаленный changeset к локальной базе данных с помощью sqlite3changeset_apply_v2()и перехватить буфер информации о ребейсинге.Затем:</target>
        </trans-unit>
        <trans-unit id="aa098185ca802c3d4bb821bfd07089d8121f87d8" translate="yes" xml:space="preserve">
          <source>In order to return data from the database to the user, for example as the results of a SELECT query, SQLite must at some point read data from the database file. Usually, data is read from the database file in aligned blocks of</source>
          <target state="translated">Чтобы вернуть данные из БД пользователю,например,как результаты SELECT-запроса,SQLite должен в какой-то момент прочитать данные из файла БД.Обычно данные считываются из файла базы данных в выровненных блоках из</target>
        </trans-unit>
        <trans-unit id="fbe7b2f0d6747492938cc0cedd14f11e91e462ca" translate="yes" xml:space="preserve">
          <source>In order to save space, this backing table may be omitted by setting the columnsize option to zero. For example:</source>
          <target state="translated">Чтобы сэкономить место,эту таблицу подложек можно опустить,установив опцию размера колонки на ноль.Например:</target>
        </trans-unit>
        <trans-unit id="1dc49d196adf92707040503b638c58b0d1b51283" translate="yes" xml:space="preserve">
          <source>In order to succeed, the database connection must not be in &lt;a href=&quot;#sqlite3_get_autocommit&quot;&gt;autocommit mode&lt;/a&gt; when &lt;a href=&quot;#sqlite3_snapshot_open&quot;&gt;sqlite3_snapshot_open(D,S,P)&lt;/a&gt; is called. If there is already a read transaction open on schema S, then the database handle must have no active statements (SELECT statements that have been passed to sqlite3_step() but not sqlite3_reset() or sqlite3_finalize()). SQLITE_ERROR is returned if either of these conditions is violated, or if schema S does not exist, or if the snapshot object is invalid.</source>
          <target state="translated">Для успешного выполнения соединение с базой данных не должно находиться в &lt;a href=&quot;#sqlite3_get_autocommit&quot;&gt;режиме &lt;/a&gt;&lt;a href=&quot;#sqlite3_snapshot_open&quot;&gt;автоматической &lt;/a&gt;фиксации при вызове sqlite3_snapshot_open (D, S, P) . Если в схеме S уже открыта транзакция чтения, то дескриптор базы данных не должен иметь активных операторов (операторы SELECT, которые были переданы в sqlite3_step (), но не в sqlite3_reset () или sqlite3_finalize ()). SQLITE_ERROR возвращается, если любое из этих условий нарушено, или если схема S не существует, или если объект моментального снимка недействителен.</target>
        </trans-unit>
        <trans-unit id="4bcc91176e8c72eef945e65a5e94e40093e70723" translate="yes" xml:space="preserve">
          <source>In order to succeed, the database connection must not be in &lt;a href=&quot;get_autocommit&quot;&gt;autocommit mode&lt;/a&gt; when &lt;a href=&quot;snapshot_open&quot;&gt;sqlite3_snapshot_open(D,S,P)&lt;/a&gt; is called. If there is already a read transaction open on schema S, then the database handle must have no active statements (SELECT statements that have been passed to sqlite3_step() but not sqlite3_reset() or sqlite3_finalize()). SQLITE_ERROR is returned if either of these conditions is violated, or if schema S does not exist, or if the snapshot object is invalid.</source>
          <target state="translated">Для успешного выполнения соединение с базой данных не должно находиться в &lt;a href=&quot;get_autocommit&quot;&gt;режиме &lt;/a&gt;&lt;a href=&quot;snapshot_open&quot;&gt;автоматической &lt;/a&gt;фиксации при вызове sqlite3_snapshot_open (D, S, P) . Если в схеме S уже открыта транзакция чтения, то дескриптор базы данных не должен иметь активных операторов (операторы SELECT, которые были переданы в sqlite3_step (), но не в sqlite3_reset () или sqlite3_finalize ()). SQLITE_ERROR возвращается, если любое из этих условий нарушено, или если схема S не существует, или если объект моментального снимка недействителен.</target>
        </trans-unit>
        <trans-unit id="3885c40685a2b0fc9bd29a3371e31ed82a66178a" translate="yes" xml:space="preserve">
          <source>In order to use FTS5 instead of FTS3 or FTS4, applications usually require minimal modifications. Most of these fall into three categories - changes required to the CREATE VIRTUAL TABLE statement used to create the FTS table, changes required to SELECT queries used to execute queries against the table, and changes required to applications that use &lt;a href=&quot;fts3#snippet&quot;&gt;FTS auxiliary functions&lt;/a&gt;.</source>
          <target state="translated">Чтобы использовать FTS5 вместо FTS3 или FTS4, приложения обычно требуют минимальных изменений. Большинство из них делятся на три категории: изменения, необходимые для оператора CREATE VIRTUAL TABLE, используемого для создания таблицы FTS, изменения, необходимые для запросов SELECT, используемых для выполнения запросов к таблице, и изменения, необходимые для приложений, использующих &lt;a href=&quot;fts3#snippet&quot;&gt;вспомогательные функции FTS&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="362a80a01b0db13fb3dac03d2ae8d3c5e2853e16" translate="yes" xml:space="preserve">
          <source>In order to use foreign key constraints in SQLite, the library must be compiled with neither &lt;a href=&quot;compile#omit_foreign_key&quot;&gt;SQLITE_OMIT_FOREIGN_KEY&lt;/a&gt; or &lt;a href=&quot;compile#omit_trigger&quot;&gt;SQLITE_OMIT_TRIGGER&lt;/a&gt; defined. If SQLITE_OMIT_TRIGGER is defined but SQLITE_OMIT_FOREIGN_KEY is not, then SQLite behaves as it did prior to &lt;a href=&quot;https://sqlite.org/releaselog/3_6_19.html&quot;&gt;version 3.6.19&lt;/a&gt; (2009-10-14) - foreign key definitions are parsed and may be queried using &lt;a href=&quot;pragma#pragma_foreign_key_list&quot;&gt;PRAGMA foreign_key_list&lt;/a&gt;, but foreign key constraints are not enforced. The &lt;a href=&quot;pragma#pragma_foreign_keys&quot;&gt;PRAGMA foreign_keys&lt;/a&gt; command is a no-op in this configuration. If OMIT_FOREIGN_KEY is defined, then foreign key definitions cannot even be parsed (attempting to specify a foreign key definition is a syntax error).</source>
          <target state="translated">Чтобы использовать ограничения внешнего ключа в SQLite, библиотека должна быть скомпилирована без определения &lt;a href=&quot;compile#omit_foreign_key&quot;&gt;SQLITE_OMIT_FOREIGN_KEY&lt;/a&gt; или &lt;a href=&quot;compile#omit_trigger&quot;&gt;SQLITE_OMIT_TRIGGER&lt;/a&gt; . Если SQLITE_OMIT_TRIGGER определен, а SQLITE_OMIT_FOREIGN_KEY - нет, то SQLite ведет себя так же, как и до &lt;a href=&quot;https://sqlite.org/releaselog/3_6_19.html&quot;&gt;версии 3.6.19&lt;/a&gt; (2009-10-14) - определения внешних ключей анализируются и могут запрашиваться с помощью &lt;a href=&quot;pragma#pragma_foreign_key_list&quot;&gt;PRAGMA foreign_key_list&lt;/a&gt; , но ограничения внешнего ключа не применяются. Команда &lt;a href=&quot;pragma#pragma_foreign_keys&quot;&gt;PRAGMA foreign_keys&lt;/a&gt; не работает в этой конфигурации. Если определен OMIT_FOREIGN_KEY, определения внешнего ключа не могут быть даже проанализированы (попытка указать определение внешнего ключа является синтаксической ошибкой).</target>
        </trans-unit>
        <trans-unit id="2a10b918ff09134ab69409cf683db7b4a9557318" translate="yes" xml:space="preserve">
          <source>In order to use this command to delete a row, the text value 'delete' must be inserted into the special column with the same name as the table. The rowid of the row to delete is inserted into the rowid column. The values inserted into the other columns must match the values currently stored in the table. For example:</source>
          <target state="translated">Для того,чтобы использовать эту команду для удаления строки,текстовое значение 'delete' должно быть вставлено в специальный столбец с тем же именем,что и таблица.В колонку вставляется шрифт удаляемой строки.Значения,вставленные в другие колонки,должны совпадать со значениями,хранящимися в таблице в данный момент.Например:</target>
        </trans-unit>
        <trans-unit id="18acf9de092948631a77a8a7268e93e0863d7575" translate="yes" xml:space="preserve">
          <source>In ordinary indexes, there is exactly one entry in the index for every row in the table. In partial indexes, only some subset of the rows in the table have corresponding index entries. For example, a partial index might omit entries for which the column being indexed is NULL. When used judiciously, partial indexes can result in smaller database files and improvements in both query and write performance.</source>
          <target state="translated">В обычных индексах на каждую строку таблицы приходится ровно одна запись.В частичных индексах только некоторые подмножества строк таблицы имеют соответствующие записи индекса.Например,в частичном индексе могут опускаться записи,для которых столбец индексируемого столбца является NULL.При разумном использовании частичные индексы могут привести к уменьшению файлов базы данных и улучшению производительности как при запросах,так и при записи.</target>
        </trans-unit>
        <trans-unit id="2aff0a10aa915dae8ca55cc20203451ac3b580cc" translate="yes" xml:space="preserve">
          <source>In other words, an SQLite database can do everything that a pile-of-files or wrapped pile-of-files format can do, plus much more, and with greater lucidity. An SQLite database is a more versatile container than key/value filesystem or a ZIP archive. (For a detailed example, see the &lt;a href=&quot;affcase1&quot;&gt;OpenOffice case study&lt;/a&gt; essay.)</source>
          <target state="translated">Другими словами, база данных SQLite может делать все, что могут делать форматы стопки файлов или обернутой стопки файлов, а также многое другое и с большей ясностью. База данных SQLite - более универсальный контейнер, чем файловая система ключ / значение или ZIP-архив. (Подробный пример см. В эссе с &lt;a href=&quot;affcase1&quot;&gt;тематическим исследованием OpenOffice&lt;/a&gt; .)</target>
        </trans-unit>
        <trans-unit id="a0407b322bda5c84932b9210d6c9dd55dfaff1cd" translate="yes" xml:space="preserve">
          <source>In other words, if X begins a write transaction using &lt;a href=&quot;lang_transaction#immediate&quot;&gt;BEGIN IMMEDIATE&lt;/a&gt; then issues one or more &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;, &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt;, and/or &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; statements, then those changes are visible to subsequent &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statements that are evaluated in database connection X. &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statements on a different database connection Y will show no changes until the X transaction commits. But &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statements in X will show the changes prior to the commit.</source>
          <target state="translated">Другими словами, если X начинает транзакцию записи с помощью &lt;a href=&quot;lang_transaction#immediate&quot;&gt;BEGIN IMMEDIATE,&lt;/a&gt; затем выдает один или несколько операторов &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; , &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; и / или &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; , тогда эти изменения видны последующим &lt;a href=&quot;lang_select&quot;&gt;операторам SELECT&lt;/a&gt; , которые оцениваются в соединении X с базой данных. Операторы &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; на другом соединение с базой данных Y не будет показывать никаких изменений, пока транзакция X не будет зафиксирована. Но &lt;a href=&quot;lang_select&quot;&gt;операторы SELECT&lt;/a&gt; в X покажут изменения до фиксации.</target>
        </trans-unit>
        <trans-unit id="b76e19862dad40faf099a9e663056c35b57f6bbd" translate="yes" xml:space="preserve">
          <source>In other words, make the same sqlite3_test_control() call except change the last two parameters to zero.</source>
          <target state="translated">Другими словами,сделать один и тот же вызов sqlite3_test_control(),за исключением изменения двух последних параметров на ноль.</target>
        </trans-unit>
        <trans-unit id="a943abceb2efdd003ead8aa4530811df4446fd2f" translate="yes" xml:space="preserve">
          <source>In other words, opening and using a database file that has two or more names results in behavior that is undefined and probably undesirable.</source>
          <target state="translated">Другими словами,открытие и использование файла базы данных,который имеет два или более имени,приводит к поведению,которое является неопределенным и,возможно,нежелательным.</target>
        </trans-unit>
        <trans-unit id="5f5d40599d0989dfe7615dba1f4690adcb6d4ca6" translate="yes" xml:space="preserve">
          <source>In other words, powersafe overwrite means that there is no &quot;collateral damage&quot; when a power loss occurs while writing. Only those bytes actually being written might be damaged.</source>
          <target state="translated">Другими словами,безопасная перезапись означает,что нет &quot;сопутствующих повреждений&quot;,когда происходит потеря мощности во время записи.Повреждения могут быть нанесены только тем байтам,которые действительно были записаны.</target>
        </trans-unit>
        <trans-unit id="ebd1e3e7febed4c7b9b73c22b3802bc322206c02" translate="yes" xml:space="preserve">
          <source>In other words, since 2004 all SQLite releases have been backwards compatible, though not necessarily forwards compatible.</source>
          <target state="translated">Другими словами,с 2004 года все выпуски SQLite имеют обратную совместимость,хотя и не обязательно обратную.</target>
        </trans-unit>
        <trans-unit id="1f360548804fb547b2c55aa98cf2f1549c641a34" translate="yes" xml:space="preserve">
          <source>In other words, the session extension provides a facility for SQLite database files that is similar to the unix &lt;a href=&quot;https://en.wikipedia.org/wiki/Patch_(Unix)&quot;&gt;patch&lt;/a&gt; utility program, or to the &quot;merge&quot; capabilities of version control systems such as &lt;a href=&quot;https://www.fossil-scm.org/&quot;&gt;Fossil&lt;/a&gt;, &lt;a href=&quot;https://git-scm.com&quot;&gt;Git&lt;/a&gt;, or &lt;a href=&quot;http://www.mercurial-scm.org/&quot;&gt;Mercurial&lt;/a&gt;.</source>
          <target state="translated">Другими словами, расширение сеанса предоставляет возможность для файлов базы данных SQLite, аналогичную служебной программе &lt;a href=&quot;https://en.wikipedia.org/wiki/Patch_(Unix)&quot;&gt;патча&lt;/a&gt; unix , или возможности &amp;laquo;слияния&amp;raquo; систем контроля версий, таких как &lt;a href=&quot;https://www.fossil-scm.org/&quot;&gt;Fossil&lt;/a&gt; , &lt;a href=&quot;https://git-scm.com&quot;&gt;Git&lt;/a&gt; или &lt;a href=&quot;http://www.mercurial-scm.org/&quot;&gt;Mercurial&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c9d46649fb7fd18d588f4a5f73a3e3c10dcafa53" translate="yes" xml:space="preserve">
          <source>In other words, unlinking or renaming an open database file results in behavior that is undefined and probably undesirable.</source>
          <target state="translated">Другими словами,развязывание или переименование открытого файла базы данных приводит к поведению,которое является неопределенным и,возможно,нежелательным.</target>
        </trans-unit>
        <trans-unit id="a8fad5ad802fc08a8688a68301e637bb10e07021" translate="yes" xml:space="preserve">
          <source>In other words, you should call sqlite3_column_text(), sqlite3_column_blob(), or sqlite3_column_text16() first to force the result into the desired format, then invoke sqlite3_column_bytes() or sqlite3_column_bytes16() to find the size of the result. Do not mix calls to sqlite3_column_text() or sqlite3_column_blob() with calls to sqlite3_column_bytes16(), and do not mix calls to sqlite3_column_text16() with calls to sqlite3_column_bytes().</source>
          <target state="translated">Другими словами,сначала нужно вызвать sqlite3_column_text(),sqlite3_column_blob()или sqlite3_column_text16(),чтобы форсировать результат в нужный формат,затем вызвать sqlite3_column_bytes()или sqlite3_column_bytes16(),чтобы найти размер результата.Не смешивайте вызовы sqlite3_column_text()или sqlite3_column_blob()с вызовами sqlite3_column_bytes16()и не смешивайте вызовы sqlite3_column_text16()с вызовами sqlite3_column_bytes().</target>
        </trans-unit>
        <trans-unit id="456e92a6a9d74515a6d36409e4455702906122d6" translate="yes" xml:space="preserve">
          <source>In practical terms, what the powersafe write property means is that when the disk controller detects an impending power loss, it finishes writing whatever sector it is working on prior to parking the heads. It means that individual sector writes will complete once started, even if there is a power loss.</source>
          <target state="translated">С практической точки зрения,свойство записи Powersafe означает,что когда контроллер диска обнаруживает грозящую потерю мощности,он заканчивает запись в любом секторе,над которым он работает,до того,как головки будут поставлены на стоянку.Это означает,что запись отдельного сектора будет завершена после начала,даже если произойдет потеря питания.</target>
        </trans-unit>
        <trans-unit id="9fe8084319ab239e87ac8042e3d629376c48f43e" translate="yes" xml:space="preserve">
          <source>In practice, metadata is preserved between function calls for function parameters that are compile-time constants, including literal values and &lt;a href=&quot;../lang_expr#varparam&quot;&gt;parameters&lt;/a&gt; and expressions composed from the same.</source>
          <target state="translated">На практике метаданные сохраняются между вызовами функций для параметров функции, которые являются константами времени компиляции, включая литеральные значения, &lt;a href=&quot;../lang_expr#varparam&quot;&gt;параметры&lt;/a&gt; и выражения, составленные из них.</target>
        </trans-unit>
        <trans-unit id="553ff79ef31136314c6f3a02cf8b8c9de3d93346" translate="yes" xml:space="preserve">
          <source>In practice, metadata is preserved between function calls for function parameters that are compile-time constants, including literal values and &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameters&lt;/a&gt; and expressions composed from the same.</source>
          <target state="translated">На практике метаданные сохраняются между вызовами функций для параметров функции, которые являются константами времени компиляции, включая литеральные значения, &lt;a href=&quot;lang_expr#varparam&quot;&gt;параметры&lt;/a&gt; и выражения, составленные из них.</target>
        </trans-unit>
        <trans-unit id="235238a95713f71f096fe2094b1d8d70514424be" translate="yes" xml:space="preserve">
          <source>In precompiled SQLite libraries available on the website, the Unix versions are compiled with THREADSAFE turned off but the Windows versions are compiled with THREADSAFE turned on. If you need something different that this you will have to recompile.</source>
          <target state="translated">В прекомпилированных SQLite библиотеках,доступных на сайте,версии Unix компилируются с выключенным THREADSAFE,а версии Windows компилируются с включенным THREADSAFE.Если вам нужно что-то другое,то вам придется это перекомпилировать.</target>
        </trans-unit>
        <trans-unit id="49d7b0c7067454bf2994ce5482f78c23710e1d3a" translate="yes" xml:space="preserve">
          <source>In prior discussion, it was assumed that each SQL statement is prepared once, evaluated, then destroyed. However, SQLite allows the same &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; to be evaluated multiple times. This is accomplished using the following routines:</source>
          <target state="translated">В предыдущем обсуждении предполагалось, что каждый оператор SQL готовится один раз, оценивается, а затем уничтожается. Однако SQLite позволяет выполнять многократную оценку одного и того же &lt;a href=&quot;c3ref/stmt&quot;&gt;подготовленного оператора&lt;/a&gt; . Это достигается с помощью следующих процедур:</target>
        </trans-unit>
        <trans-unit id="86c3b83aa53c8f50b7b8f707247a7f27be6c0dc8" translate="yes" xml:space="preserve">
          <source>In processing the query above, SQLite invokes the sumint callbacks as follows:</source>
          <target state="translated">При обработке вышеприведенного запроса SQLite вызывает обратные вызовы суммирования следующим образом:</target>
        </trans-unit>
        <trans-unit id="59cf5532e18c9ee34b181fd5de97a560addf74bf" translate="yes" xml:space="preserve">
          <source>In queries that are driven by a &lt;a href=&quot;partialindex&quot;&gt;partial index&lt;/a&gt;, avoid unnecessary tests of the constraint named in the WHERE clause of the partial index, since we know that constraint must always be true.</source>
          <target state="translated">В запросах, управляемых &lt;a href=&quot;partialindex&quot;&gt;частичным индексом&lt;/a&gt; , избегайте ненужных проверок ограничения, указанного в предложении WHERE частичного индекса, поскольку мы знаем, что это ограничение всегда должно быть истинным.</target>
        </trans-unit>
        <trans-unit id="82246b58b2662ec98735d83b367a59b70f82fb40" translate="yes" xml:space="preserve">
          <source>In rollback mode, SQLite implements isolation by locking the database file and preventing any reads by other database connections while each write transaction is underway. Readers can be be active at the beginning of a write, before any content is flushed to disk and while all changes are still held in the writer's private memory space. But before any changes are made to the database file on disk, all readers must be (temporally) expelled in order to give the writer exclusive access to the database file. Hence, readers are prohibited from seeing incomplete transactions by virtue of being locked out of the database while the transaction is being written to disk. Only after the transaction is completely written and synced to disk and commits are the readers allowed back into the database. Hence readers never get a chance to see partially written changes.</source>
          <target state="translated">В режиме отката SQLite реализует изоляцию,блокируя файл базы данных и предотвращая чтение другими соединениями к БД во время выполнения каждой транзакции записи.Читатели могут быть активны в начале записи,до того,как любое содержимое будет записано на диск,и в то время,как все изменения все еще хранятся в личном пространстве памяти записывающего устройства.Но перед тем,как внести какие-либо изменения в файл базы данных на диске,все читатели должны быть (временно)исключены,чтобы дать записывающему устройству эксклюзивный доступ к файлу базы данных.Следовательно,читателям запрещается видеть незавершенные транзакции в силу того,что во время записи транзакции на диск они заблокированы от БД.Только после того,как транзакция полностью записана и синхронизирована с диском и коммитами,читателям разрешается вернуться обратно в БД.Таким образом,читатели никогда не смогут увидеть частично записанные изменения.</target>
        </trans-unit>
        <trans-unit id="068d2699f531d0825115d300a0cccce10e48a71e" translate="yes" xml:space="preserve">
          <source>In spite of the disadvantages, the developers believe that having a built-in printf() implementation inside of SQLite is a net positive.</source>
          <target state="translated">Несмотря на недостатки,разработчики считают,что наличие встроенной реализации printf()внутри SQLite является положительным моментом.</target>
        </trans-unit>
        <trans-unit id="cf039b1afa32ebe62123ae1292d3fdd466d22e3b" translate="yes" xml:space="preserve">
          <source>In step 2 of the procedure above, the database file is not locked before it is read from. This is the only exception to the locking rules described in section</source>
          <target state="translated">На втором шаге процедуры,описанной выше,файл базы данных не блокируется перед его считыванием.Это единственное исключение из правил блокировки,описанных в разделе</target>
        </trans-unit>
        <trans-unit id="8ea8892717935eea12390eaf98af13ff334785db" translate="yes" xml:space="preserve">
          <source>In summary then, any query with aggregate functions is implemented by two loops. The first loop scans the input table and computes aggregate information into buckets and the second loop scans through all the buckets to compute the final result.</source>
          <target state="translated">Таким образом,любой запрос с агрегатными функциями реализуется двумя циклами.Первый цикл сканирует входную таблицу и вычисляет агрегированную информацию в ведра,а второй цикл сканирует все ведра,чтобы вычислить конечный результат.</target>
        </trans-unit>
        <trans-unit id="2fe8cccc0c3831ee16f379b0a96fc3ebe090262e" translate="yes" xml:space="preserve">
          <source>In summary, the claim of this essay is that using SQLite as a container for an application file format like OpenDocument and storing lots of smaller objects in that container works out much better than using a ZIP archive holding a few larger objects. To wit:</source>
          <target state="translated">Подводя итог,можно сказать,что использование SQLite в качестве контейнера для файла приложения в формате типа OpenDocument и хранение в этом контейнере множества более мелких объектов получается гораздо лучше,чем использование ZIP-архива,содержащего несколько более крупных объектов.В частности:</target>
        </trans-unit>
        <trans-unit id="14368b74fc6cabbc46f6b11af62f68ec319ac0f1" translate="yes" xml:space="preserve">
          <source>In support of the &lt;a href=&quot;testing#mcdc&quot;&gt;100% MC/DC testing&lt;/a&gt; goal for SQLite, the parser code generated by Lemon has no unreachable branches, and contains extra (compile-time selected) instrumentation useful for measuring test coverage.</source>
          <target state="translated">В поддержку цели &lt;a href=&quot;testing#mcdc&quot;&gt;100% тестирования MC / DC&lt;/a&gt; для SQLite, код парсера, сгенерированный Lemon, не имеет недостижимых ветвей и содержит дополнительные (выбранные во время компиляции) инструменты, полезные для измерения покрытия тестами.</target>
        </trans-unit>
        <trans-unit id="aad3b77ed5e3adba0d4656a1d99071301ddd4bc1" translate="yes" xml:space="preserve">
          <source>In the &quot;fossil delta&quot; format - the format used for blob deltas by the &lt;a href=&quot;http://fossil-scm.org&quot;&gt;Fossil source-code management system&lt;/a&gt;, or</source>
          <target state="translated">В формате &amp;laquo;fossil delta&amp;raquo; - формат, используемый для дельт blob системой управления &lt;a href=&quot;http://fossil-scm.org&quot;&gt;исходным кодом Fossil&lt;/a&gt; , или</target>
        </trans-unit>
        <trans-unit id="55105fedb19d062cb7afdaefe48e3eb4675905c5" translate="yes" xml:space="preserve">
          <source>In the &quot;fossil delta&quot; format - the format used for blob deltas by the &lt;a href=&quot;https://fossil-scm.org&quot;&gt;Fossil source-code management system&lt;/a&gt;, or</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30519768573ed5dd959ec460751bfce418bf4435" translate="yes" xml:space="preserve">
          <source>In the &quot;without ANALYZE&quot; case on the left, the NN algorithm chooses loop P (PLINK) as the outer loop because 4.9 is less than 5.2, resulting in path P-T which is algorithm-1. NN only looks at the single best choice at each step so it completely misses the fact that 5.2+4.4 makes a slightly cheaper plan than 4.9+4.8. But the N3 algorithm keeps track of the 5 best paths for a 2-way join, so it ends up selecting path T-P because of its slightly lower overall cost. Path T-P is algorithm-2.</source>
          <target state="translated">В случае &quot;без АНАЛЫЗА&quot; слева алгоритм NN выбирает петлю P (PLINK)в качестве внешней петли,так как 4.9 меньше 5.2,в результате чего получается путь P-T,который является алгоритмом-1.NN смотрит только на единственный лучший выбор на каждом шаге,поэтому полностью пропускает тот факт,что 5.2+4.4 делает план чуть дешевле,чем 4.9+4.8.Но алгоритм N3 отслеживает 5 лучших путей для 2-х стороннего соединения,поэтому в итоге выбирает путь T-P из-за его немного меньшей общей стоимости.Путь T-P-это алгоритм-2.</target>
        </trans-unit>
        <trans-unit id="88edd036016e74b41ab30f363489bc8baf2ff243" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;carray&quot;&gt;CARRAY extension&lt;/a&gt;, the application needs to tell the extension the location of a C-language array that contains the data for the table-valued function that the extension implements.</source>
          <target state="translated">В &lt;a href=&quot;carray&quot;&gt;расширении CARRAY&lt;/a&gt; приложению необходимо сообщить расширению расположение массива на языке C, который содержит данные для возвращающей табличное значение функции, которую реализует расширение.</target>
        </trans-unit>
        <trans-unit id="0673453ee376202611f58f23515a709feb8d4034" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt;, enhance the &quot;.mode&quot; command so that it restores the default column and row separators for modes &quot;line&quot;, &quot;list&quot;, &quot;column&quot;, and &quot;tcl&quot;.</source>
          <target state="translated">В &lt;a href=&quot;cli&quot;&gt;оболочке командной строки&lt;/a&gt; улучшите команду &amp;laquo;.mode&amp;raquo;, чтобы она восстанавливала разделители столбцов и строк по умолчанию для режимов &amp;laquo;строка&amp;raquo;, &amp;laquo;список&amp;raquo;, &amp;laquo;столбец&amp;raquo; и &amp;laquo;tcl&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="c5b3d2f7e7ec64c2ea66a15e4b9de436ddc07a10" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt; extension, the &lt;a href=&quot;fts3#full_text_index_queries&quot;&gt;MATCH operator&lt;/a&gt; (which does the full-text search) needs to communicate details of matching entries to the &lt;a href=&quot;fts3#snippet&quot;&gt;snippet()&lt;/a&gt;, &lt;a href=&quot;fts3#offsets&quot;&gt;offsets()&lt;/a&gt;, and &lt;a href=&quot;fts3#matchinfo&quot;&gt;matchinfo()&lt;/a&gt; functions so that those functions can convert the details of the match into useful output.</source>
          <target state="translated">В &lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt; выдвижении, &lt;a href=&quot;fts3#full_text_index_queries&quot;&gt;оператор MATCH&lt;/a&gt; (который делает полнотекстовой поиск) необходимо сообщить информацию о записи соответствия для &lt;a href=&quot;fts3#snippet&quot;&gt;сниппета ()&lt;/a&gt; , &lt;a href=&quot;fts3#offsets&quot;&gt;зачеты ()&lt;/a&gt; , и &lt;a href=&quot;fts3#matchinfo&quot;&gt;MatchInfo ()&lt;/a&gt; функции , так что эти функции могут преобразовать детали матча в полезный результат.</target>
        </trans-unit>
        <trans-unit id="7f5a2150475db6cefe817c8c9175290580ea2ad7" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;json1&quot;&gt;JSON extension&lt;/a&gt;, fix the JSON validator so that it correctly rejects invalid backslash escapes within strings.</source>
          <target state="translated">В &lt;a href=&quot;json1&quot;&gt;расширении JSON&lt;/a&gt; исправьте валидатор JSON, чтобы он правильно отклонял недопустимые escape-символы обратной косой черты в строках.</target>
        </trans-unit>
        <trans-unit id="29cf2e016ded4e45037d7dd8bd42e21681c156af" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;rbu&quot;&gt;RBU extension&lt;/a&gt;, add extra sync operations to avoid the possibility of corruption following a power failure.</source>
          <target state="translated">В &lt;a href=&quot;rbu&quot;&gt;расширении RBU&lt;/a&gt; добавьте дополнительные операции синхронизации, чтобы избежать возможности повреждения после сбоя питания.</target>
        </trans-unit>
        <trans-unit id="11f2b4a17490be52b1b76c1ff6aa70a95cb65d46" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;rtree&quot;&gt;RTREE&lt;/a&gt; extension, when rounding 64-bit floating point numbers to 32-bit for storage, always round in a direction that causes the bounding box to get larger.</source>
          <target state="translated">В расширении &lt;a href=&quot;rtree&quot;&gt;RTREE&lt;/a&gt; при округлении 64-битных чисел с плавающей запятой до 32-битных для хранения всегда округляйте в направлении, при котором ограничивающая рамка увеличивается.</target>
        </trans-unit>
        <trans-unit id="240fef4158af161eb22e60a820c151dc84eafe1e" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;tclsqlite&quot;&gt;TCL Interface&lt;/a&gt;, add the -uri option to the &quot;sqlite3&quot; TCL command used for creating new database connection objects.</source>
          <target state="translated">В &lt;a href=&quot;tclsqlite&quot;&gt;интерфейсе TCL&lt;/a&gt; добавьте параметр -uri к команде TCL sqlite3, используемой для создания новых объектов подключения к базе данных.</target>
        </trans-unit>
        <trans-unit id="156e69c7f61ba1dcce1a1142af151766e801c151" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;tclsqlite&quot;&gt;TCL language interface&lt;/a&gt;, &quot;@variable&quot; instead of &quot;$variable&quot; always binds as a blob.</source>
          <target state="translated">В &lt;a href=&quot;tclsqlite&quot;&gt;интерфейсе языка TCL&lt;/a&gt; &amp;laquo;@variable&amp;raquo; вместо &amp;laquo;$ variable&amp;raquo; всегда привязывается как blob.</target>
        </trans-unit>
        <trans-unit id="7ed9b7e87f45e28428e0b4c11b7a622203b8e9d6" translate="yes" xml:space="preserve">
          <source>In the BLOB output, you can clearly see the NUL character as the 4th character in the 7-character string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3bfa67674bb524ce3387e6563f15051a77fe593" translate="yes" xml:space="preserve">
          <source>In the C programming language where &lt;b&gt;&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;&lt;/b&gt; and &lt;b&gt;&lt;code&gt;||&lt;/code&gt;&lt;/b&gt; are &quot;short-circuit&quot; operators, MC/DC and branch coverage are very nearly the same thing. The primary difference is in boolean vector tests. One can test for any of several bits in bit-vector and still obtain 100% branch test coverage even though the second element of MC/DC - the requirement that each condition in a decision take on every possible outcome - might not be satisfied.</source>
          <target state="translated">В языке программирования C где &lt;b&gt; &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; &lt;/b&gt; и &lt;b&gt; &lt;code&gt;||&lt;/code&gt; &lt;/b&gt; являются операторами &quot;короткого замыкания&quot;, MC / DC и покрытие филиалов - это почти одно и то же. Основное отличие заключается в тестах логических векторов. Можно протестировать любой из нескольких битов в битовом векторе и при этом получить 100% тестовое покрытие ветвления, даже если второй элемент MC / DC - требование, чтобы каждое условие в решении принимало все возможные результаты, - может не выполняться.</target>
        </trans-unit>
        <trans-unit id="a49a291dae627f989ba703462ee2c7e1bcc8b060" translate="yes" xml:space="preserve">
          <source>In the C programming language, it is very easy to write code that has &quot;undefined&quot; or &quot;implementation defined&quot; behavior. That means that the code might work during development, but then give a different answer on a different system, or when recompiled using different compiler options. Examples of undefined and implementation-defined behavior in ANSI C include:</source>
          <target state="translated">В языке программирования Си очень легко написать код,имеющий поведение &quot;неопределенное&quot; или &quot;реализация определена&quot;.Это означает,что код может работать в процессе разработки,но затем дать другой ответ на другой системе,или при перекомпиляции с использованием разных опций компилятора.Примеры неопределенного и реализованно-определенного поведения в ANSI C включают в себя:</target>
        </trans-unit>
        <trans-unit id="c817a7331349197e219cdd351370db507b5f89c0" translate="yes" xml:space="preserve">
          <source>In the COPY command, backslash can now be used to escape a newline.</source>
          <target state="translated">В команде COPY обратный слеш теперь может быть использован для выхода из новой строки.</target>
        </trans-unit>
        <trans-unit id="cb9f3cc234a2699a8be8b939bc81e4cd1e3c8028" translate="yes" xml:space="preserve">
          <source>In the Fossil full-text search system, documents that participate in the full-text search (wiki pages, tickets, check-ins, documentation files, etc) are tracked by a table called &quot;ftsdocs&quot; (&lt;u&gt;f&lt;/u&gt;ull &lt;u&gt;t&lt;/u&gt;ext &lt;u&gt;s&lt;/u&gt;earch &lt;u&gt;doc&lt;/u&gt;ument&lt;u&gt;s&lt;/u&gt;). As new documents are added to the repository, they are not indexed right away. Indexing is deferred until there is a search request. The ftsdocs table contains an &quot;idxed&quot; field which is true if the document has been indexed and false if not.</source>
          <target state="translated">В системе полнотекстового поиска Fossil документы, которые участвуют в полнотекстовом поиске (вики-страницы, билеты, чекины, файлы документации и т. Д.), Отслеживаются таблицей под названием &quot;ftsdocs&quot; ( &lt;u&gt;f&lt;/u&gt; ull &lt;u&gt;t&lt;/u&gt; ext &lt;u&gt;s&lt;/u&gt; earch &lt;u&gt;doc&lt;/u&gt; ument &lt;u&gt;s&lt;/u&gt; ). При добавлении новых документов в репозиторий они не индексируются сразу. Индексирование откладывается до тех пор, пока не поступит поисковый запрос. Таблица ftsdocs содержит поле idxed, которое истинно, если документ был проиндексирован, и false, если нет.</target>
        </trans-unit>
        <trans-unit id="54570b346f4d608f2bbac12e4181cf27370c513d" translate="yes" xml:space="preserve">
          <source>In the SQL statement text input to &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; and its variants, literals may be replaced by a &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameter&lt;/a&gt; that matches one of following templates:</source>
          <target state="translated">При вводе текста оператора SQL в &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; и его варианты литералы могут быть заменены &lt;a href=&quot;lang_expr#varparam&quot;&gt;параметром,&lt;/a&gt; который соответствует одному из следующих шаблонов:</target>
        </trans-unit>
        <trans-unit id="2d198fd96a87b68a84840a27e15d7192fd58115f" translate="yes" xml:space="preserve">
          <source>In the SQL statement text input to &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; and its variants, literals may be replaced by a &lt;a href=&quot;../lang_expr#varparam&quot;&gt;parameter&lt;/a&gt; that matches one of following templates:</source>
          <target state="translated">При вводе текста оператора SQL в &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; и его варианты литералы могут быть заменены &lt;a href=&quot;../lang_expr#varparam&quot;&gt;параметром,&lt;/a&gt; который соответствует одному из следующих шаблонов:</target>
        </trans-unit>
        <trans-unit id="0bfef1786d8548ec0f82e3f4f67466b9d9c84839" translate="yes" xml:space="preserve">
          <source>In the TCL test harness, the crash simulation is done in a separate process. The main testing process spawns a child process which runs some SQLite operation and randomly crashes somewhere in the middle of a write operation. A special &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; randomly reorders and corrupts the unsynchronized write operations to simulate the effect of buffered filesystems. After the child dies, the original test process opens and reads the test database and verifies that the changes attempted by the child either completed successfully or else were completely rolled back. The &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;integrity_check&lt;/a&gt;&lt;a href=&quot;pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt; is used to make sure no database corruption occurs.</source>
          <target state="translated">В тестовой программе TCL моделирование сбоя выполняется в отдельном процессе. Основной процесс тестирования порождает дочерний процесс, который запускает некоторую операцию SQLite и случайным образом дает сбой где-то в середине операции записи. Специальная &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; случайным образом переупорядочивает и искажает несинхронизированные операции записи, чтобы имитировать эффект буферизованных файловых систем. После смерти ребенка открывается исходный процесс тестирования, который считывает тестовую базу данных и проверяет, что изменения, предпринятые дочерним элементом, были выполнены успешно или были полностью отменены. &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;Integrity_check &lt;/a&gt;&lt;a href=&quot;pragma#syntax&quot;&gt;ПРАГМА&lt;/a&gt; используется , чтобы убедиться , не происходит повреждения базы данных.</target>
        </trans-unit>
        <trans-unit id="2e83d8a255a88980125401cd881c484a48bd6dc6" translate="yes" xml:space="preserve">
          <source>In the TPC-H Q8 query, the setup costs are all negligible, all dependencies are between individual nodes, and there is no ORDER BY, GROUP BY, or DISTINCT clause. So for TPC-H Q8, the graph above is a reasonable representation of what needs to be computed. The general case involves a lot of extra complication, which for clarity is neglected in the remainder of this article.</source>
          <target state="translated">В запросе TPC-H Q8 все затраты на настройку ничтожно малы,все зависимости находятся между отдельными узлами,и нет пункта ORDER BY,GROUP BY или DISTINCT.Поэтому для TPC-H Q8 вышеприведенный график является разумным представлением того,что должно быть вычислено.Общий случай связан с множеством дополнительных осложнений,которые для ясности пренебрегаются в оставшейся части статьи.</target>
        </trans-unit>
        <trans-unit id="9f3539e13c22fa6c6ec2b58a1ccd7e90a2d77370" translate="yes" xml:space="preserve">
          <source>In the WHERE clause of a &lt;a href=&quot;partialindex&quot;&gt;partial index&lt;/a&gt;.</source>
          <target state="translated">В предложении WHERE &lt;a href=&quot;partialindex&quot;&gt;частичного индекса&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2ff78c844bf874e8944245ab0f90e378a482a538" translate="yes" xml:space="preserve">
          <source>In the WHERE clause of a partial index.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6311a2e6a2d0640df13bf33c58d5ba4044c66ce" translate="yes" xml:space="preserve">
          <source>In the Windows OS driver, reacquire a SHARED lock if an attempt to acquire an EXCLUSIVE lock fails. Ticket #2354</source>
          <target state="translated">В драйвере ОС Windows снова запросите блокировку SHARED,если попытка получить блокировку EXCLUSIVE не удалась.Билет № 2354</target>
        </trans-unit>
        <trans-unit id="c812acc1f415592dcfc5eeb302d23caa6a39526f" translate="yes" xml:space="preserve">
          <source>In the above paragraph, the term &quot;equal&quot; means equal when values are compared using the rules &lt;a href=&quot;datatype3#comparisons&quot;&gt;specified here&lt;/a&gt;. The following clarifications apply:</source>
          <target state="translated">В вышеприведенном абзаце термин &amp;laquo;равно&amp;raquo; означает равенство, когда значения сравниваются с использованием &lt;a href=&quot;datatype3#comparisons&quot;&gt;указанных здесь&lt;/a&gt; правил . Применяются следующие пояснения:</target>
        </trans-unit>
        <trans-unit id="94f9ba60d2631df2a644921fed4cce7a6456d2d7" translate="yes" xml:space="preserve">
          <source>In the above,</source>
          <target state="translated">В вышеизложенном,</target>
        </trans-unit>
        <trans-unit id="441e596237bc1ae031cea29bc5e12b44c88ed81c" translate="yes" xml:space="preserve">
          <source>In the above, &amp;lt;content&amp;gt; is replaced by the name of the content table. By default, &amp;lt;content_rowid&amp;gt; is replaced by the literal text &quot;rowid&quot;. Or, if the &quot;content_rowid&quot; option is set within the CREATE VIRTUAL TABLE statement, by the value of that option. &amp;lt;cols&amp;gt; is replaced by a comma-separated list of the FTS5 table column names. For example:</source>
          <target state="translated">В приведенном выше примере &amp;lt;content&amp;gt; заменяется именем таблицы содержимого. По умолчанию &amp;lt;content_rowid&amp;gt; заменяется буквальным текстом &amp;laquo;rowid&amp;raquo;. Или, если параметр content_rowid установлен в операторе CREATE VIRTUAL TABLE, по значению этой опции. &amp;lt;cols&amp;gt; заменяется списком разделенных запятыми имен столбцов таблицы FTS5. Например:</target>
        </trans-unit>
        <trans-unit id="a2464dd3bf1c506de33685f476dfeec6d3c9f83a" translate="yes" xml:space="preserve">
          <source>In the above, the user creates the database schema (a single table - &quot;x1&quot;), and then uses the &quot;.expert&quot; command to analyze a query, in this case &quot;SELECT * FROM x1 WHERE a=? AND b&amp;gt;?&quot;. The shell tool recommends that the user create a new index (index &quot;x1_idx_000123a7&quot;) and outputs the plan that the query would use in &lt;a href=&quot;eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; format. The user then creates an index with an equivalent schema and runs the analysis on the same query again. This time the shell tool does not recommend any new indexes, and outputs the plan that SQLite will use for the query given the existing indexes.</source>
          <target state="translated">В приведенном выше примере пользователь создает схему базы данных (одна таблица - &amp;laquo;x1&amp;raquo;), а затем использует команду &amp;laquo;.expert&amp;raquo; для анализа запроса, в данном случае &amp;laquo;SELECT * FROM x1 WHERE a =? AND b&amp;gt;? &quot;. Инструмент оболочки рекомендует пользователю создать новый индекс (индекс &amp;laquo;x1_idx_000123a7&amp;raquo;) и вывести план, который будет использовать запрос, в формате &lt;a href=&quot;eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; . Затем пользователь создает индекс с эквивалентной схемой и снова запускает анализ того же запроса. На этот раз инструмент оболочки не рекомендует никаких новых индексов и выводит план, который SQLite будет использовать для запроса с учетом существующих индексов.</target>
        </trans-unit>
        <trans-unit id="c0edb5d51a3281366e0040cd06804f7b08ee3eaa" translate="yes" xml:space="preserve">
          <source>In the argments to &quot;rtree&quot; in the CREATE VIRTUAL TABLE statement, the names of the columns are taken from the first token of each argument. All subsequent tokens within each argument are silently ignored. This means, for example, that if you try to give a column a &lt;a href=&quot;datatype3#affinity&quot;&gt;type affinity&lt;/a&gt; or add a constraint such as UNIQUE or NOT NULL or DEFAULT to a column, those extra tokens are accepted as valid, but they do not change the behavior of the rtree. In an RTREE virtual table, the first column always has a &lt;a href=&quot;datatype3#affinity&quot;&gt;type affinity&lt;/a&gt; of INTEGER and all other data columns have a &lt;a href=&quot;datatype3#affinity&quot;&gt;type affinity&lt;/a&gt; of NUMERIC.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94df2ec8cdab4e4a1c3463eb8499a5bac9b92ebf" translate="yes" xml:space="preserve">
          <source>In the call above, pBuf is a pointer to a large, contiguous chunk of memory space that SQLite will use to satisfy all of its memory allocation needs. pBuf might point to a static array or it might be memory obtained from some other application-specific mechanism. szBuf is an integer that is the number of bytes of memory space pointed to by pBuf. mnReq is another integer that is the minimum size of an allocation. Any call to &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc(N)&lt;/a&gt; where N is less than mnReq will be rounded up to mnReq. mnReq must be a power of two. We shall see later that the mnReq parameter is important in reducing the value of &lt;b&gt;n&lt;/b&gt; and hence the minimum memory size requirement in the &lt;a href=&quot;malloc#nofrag&quot;&gt;Robson proof&lt;/a&gt;.</source>
          <target state="translated">В приведенном выше вызове pBuf - это указатель на большой непрерывный кусок пространства памяти, который SQLite будет использовать для удовлетворения всех своих потребностей в распределении памяти. pBuf может указывать на статический массив или это может быть память, полученная из какого-либо другого механизма, специфичного для приложения. szBuf - это целое число, которое представляет собой количество байтов пространства памяти, на которое указывает pBuf. mnReq - еще одно целое число, которое представляет собой минимальный размер выделения. Любой вызов &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc (N),&lt;/a&gt; где N меньше mnReq, будет округлен до mnReq. mnReq должно быть степенью двойки. Позже мы увидим, что параметр mnReq важен для уменьшения значения &lt;b&gt;n&lt;/b&gt; и, следовательно, минимального требования к размеру памяти в &lt;a href=&quot;malloc#nofrag&quot;&gt;доказательстве Робсона&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="90165ee71034491a4c0d9359bc73082f9488de28" translate="yes" xml:space="preserve">
          <source>In the call above, pMem is a pointer to an &lt;a href=&quot;c3ref/mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt; object that defines the interface to the application-specific memory allocator. The &lt;a href=&quot;c3ref/mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt; object is really just a structure containing pointers to functions to implement the various memory allocation primitives.</source>
          <target state="translated">В приведенном выше вызове pMem - это указатель на объект &lt;a href=&quot;c3ref/mem_methods&quot;&gt;sqlite3_mem_methods,&lt;/a&gt; который определяет интерфейс к распределителю памяти для конкретного приложения. Объект &lt;a href=&quot;c3ref/mem_methods&quot;&gt;sqlite3_mem_methods на&lt;/a&gt; самом деле представляет собой просто структуру, содержащую указатели на функции для реализации различных примитивов распределения памяти.</target>
        </trans-unit>
        <trans-unit id="c159dc37c192a0696adfe0ed4e91dc6c74c10ae1" translate="yes" xml:space="preserve">
          <source>In the call sqlite3_vtab_config(D,C,...) the D parameter is the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; in which the virtual table is being created and which is passed in as the first argument to the &lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; or &lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; method that is invoking sqlite3_vtab_config(). The C parameter is one of the &lt;a href=&quot;#SQLITE_VTAB_CONSTRAINT_SUPPORT&quot;&gt;virtual table configuration options&lt;/a&gt;. The presence and meaning of parameters after C depend on which &lt;a href=&quot;#SQLITE_VTAB_CONSTRAINT_SUPPORT&quot;&gt;virtual table configuration option&lt;/a&gt; is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b10e05d68bb770ad4b44c8424ff81a8fc9e69978" translate="yes" xml:space="preserve">
          <source>In the call sqlite3_vtab_config(D,C,...) the D parameter is the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; in which the virtual table is being created and which is passed in as the first argument to the &lt;a href=&quot;../vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; or &lt;a href=&quot;../vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; method that is invoking sqlite3_vtab_config(). The C parameter is one of the &lt;a href=&quot;c_vtab_constraint_support&quot;&gt;virtual table configuration options&lt;/a&gt;. The presence and meaning of parameters after C depend on which &lt;a href=&quot;c_vtab_constraint_support&quot;&gt;virtual table configuration option&lt;/a&gt; is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="890332a4e5fd5b1fbcf7ece72dd3f24eeb42de4e" translate="yes" xml:space="preserve">
          <source>In the case of &lt;a href=&quot;expridx&quot;&gt;indexes on expressions&lt;/a&gt;, whenever the word &quot;column&quot; is used in the foregoing text, one can substitute &quot;indexed expression&quot; (meaning a copy of the expression that appears in the &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt; statement) and everything will work the same.</source>
          <target state="translated">В случае &lt;a href=&quot;expridx&quot;&gt;индексов в выражениях&lt;/a&gt; , всякий раз, когда в предыдущем тексте используется слово &amp;laquo;столбец&amp;raquo;, можно заменить &amp;laquo;индексированное выражение&amp;raquo; (что означает копию выражения, которое появляется в операторе &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt; ), и все будет работать так же.</target>
        </trans-unit>
        <trans-unit id="d6023ff2ef6625bf825c5177040f5f9d0c7e6eaa" translate="yes" xml:space="preserve">
          <source>In the case of sqlite3changeset_start_strm(), the xInput callback may be invoked by the sessions module at any point during the lifetime of the iterator. If such an xInput callback returns an error, the iterator enters an error state, whereby all subsequent calls to iterator functions immediately fail with the same error code as returned by xInput.</source>
          <target state="translated">В случае функции sqlite3changeset_start_strm()модуль сеансов может вызывать обратный вызов xInput в любой момент времени жизни итератора.Если такой обратный вызов xInput возвращает ошибку,то итератор входит в состояние ошибки,при котором все последующие вызовы итератора сразу же заканчиваются неудачей с тем же самым кодом ошибки,который возвращает xInput.</target>
        </trans-unit>
        <trans-unit id="2c842ccec3d83bffac0868a71bae98e55882c42d" translate="yes" xml:space="preserve">
          <source>In the cases above, the values returned by the function affects the information stored in the database file. The values of functions in CHECK constraints determines which entries are valid for a table, and functions in the WHERE clause of a partial index or in an index on an expression compute values stored in the index b-tree. If any of these functions later returns a different value, then the database might no longer be well-formed. Hence, to avoid database corruption, only deterministic functions can be used in the contexts above.</source>
          <target state="translated">В вышеперечисленных случаях возвращаемые функцией значения влияют на информацию,хранящуюся в файле базы данных.Значения функций в ограничениях CHECK определяют,какие записи действительны для таблицы,а функции в пункте WHERE частичного индекса или в индексе на выражении вычисляют значения,хранящиеся в b-дереве индекса.Если какая-либо из этих функций в дальнейшем вернет другое значение,то БД может оказаться плохо сформированной.Следовательно,чтобы избежать повреждения базы данных,в вышеприведённых контекстах можно использовать только детерминистические функции.</target>
        </trans-unit>
        <trans-unit id="212f1ca207fd318cb7601421ea08bad1d38b37aa" translate="yes" xml:space="preserve">
          <source>In the command-line shell, use popen() instead of fopen() if the first character of the argument to the &quot;.output&quot; command is &quot;|&quot;.</source>
          <target state="translated">В оболочке командной строки используйте popen()вместо fopen(),если первым символом аргумента в команде &quot;.output&quot; является &quot;|&quot;.</target>
        </trans-unit>
        <trans-unit id="bd2d277ff0771ee506fb5065fe7a06ad8e377ea0" translate="yes" xml:space="preserve">
          <source>In the current implementation of SQLite, the SQL parser only works with UTF-8 text. So if you supply UTF-16 text it will be converted. This is just an implementation issue and there is nothing to prevent future versions of SQLite from parsing UTF-16 encoded SQL natively.</source>
          <target state="translated">В текущей реализации SQLite парсер SQL работает только с UTF-8 текстом.Поэтому при поставке текста в кодировке UTF-16 он будет конвертирован.Это просто проблема реализации и ничто не мешает будущим версиям SQLite самостоятельно разобрать SQL в кодировке UTF-16.</target>
        </trans-unit>
        <trans-unit id="2904f602a19479b220a87ade171425cb57484f61" translate="yes" xml:space="preserve">
          <source>In the current implementation, a table is analyzed if and only if all of the following are true:</source>
          <target state="translated">В текущей реализации таблица анализируется,если и только если все нижеследующее верно:</target>
        </trans-unit>
        <trans-unit id="f2454c76bf66b1405ea30b83fd1ca60a2a98f0ef" translate="yes" xml:space="preserve">
          <source>In the current implementation, the update hook is not invoked when conflicting rows are deleted because of an &lt;a href=&quot;../lang_conflict&quot;&gt;ON CONFLICT REPLACE&lt;/a&gt; clause. Nor is the update hook invoked when rows are deleted using the &lt;a href=&quot;../lang_delete#truncateopt&quot;&gt;truncate optimization&lt;/a&gt;. The exceptions defined in this paragraph might change in a future release of SQLite.</source>
          <target state="translated">В текущей реализации ловушка обновления не вызывается при удалении конфликтующих строк из-за предложения &lt;a href=&quot;../lang_conflict&quot;&gt;ON CONFLICT REPLACE&lt;/a&gt; . Также не вызывается ловушка обновления, когда строки удаляются с использованием &lt;a href=&quot;../lang_delete#truncateopt&quot;&gt;оптимизации усечения&lt;/a&gt; . Исключения, определенные в этом абзаце, могут измениться в будущих версиях SQLite.</target>
        </trans-unit>
        <trans-unit id="fb481751cd63e35f2d57a7f24a37356fd4bf25b0" translate="yes" xml:space="preserve">
          <source>In the current implementation, the update hook is not invoked when conflicting rows are deleted because of an &lt;a href=&quot;lang_conflict&quot;&gt;ON CONFLICT REPLACE&lt;/a&gt; clause. Nor is the update hook invoked when rows are deleted using the &lt;a href=&quot;lang_delete#truncateopt&quot;&gt;truncate optimization&lt;/a&gt;. The exceptions defined in this paragraph might change in a future release of SQLite.</source>
          <target state="translated">В текущей реализации ловушка обновления не вызывается при удалении конфликтующих строк из-за предложения &lt;a href=&quot;lang_conflict&quot;&gt;ON CONFLICT REPLACE&lt;/a&gt; . Также не вызывается ловушка обновления, когда строки удаляются с использованием &lt;a href=&quot;lang_delete#truncateopt&quot;&gt;оптимизации усечения&lt;/a&gt; . Исключения, определенные в этом абзаце, могут измениться в будущих версиях SQLite.</target>
        </trans-unit>
        <trans-unit id="6c3c5dcd56d182703694f79901fe613441a9864b" translate="yes" xml:space="preserve">
          <source>In the current row, the number of times the phrase appears in the column.</source>
          <target state="translated">В текущей строке количество раз,когда фраза появляется в столбце.</target>
        </trans-unit>
        <trans-unit id="cee9466acdd5b62aa76761a9bf112fbd7910b30a" translate="yes" xml:space="preserve">
          <source>In the definitions of generated columns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="846ab6c42eae3f5d5a28f0437cb021d184a6da90" translate="yes" xml:space="preserve">
          <source>In the diagram above, initial-select means one or more non-recursive SELECT statements and recursive-select means one or more recursive SELECT statements. The most common case is for there to be exactly one initial-select and exactly one recursive-select but more than one of each is allowed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3116d32ea608324199d5e0469ef8b030b799865" translate="yes" xml:space="preserve">
          <source>In the diagram at the right, we show that the information that was held in user space is cleared when the lock is released. This used to be literally true for older versions of SQLite. But more recent versions of SQLite keep the user space information in memory in case it might be needed again at the start of the next transaction. It is cheaper to reuse information that is already in local memory than to transfer the information back from the operating system disk cache or to read it off of the disk drive again. Prior to reusing the information in user space, we must first reacquire the shared lock and then we have to check to make sure that no other process modified the database file while we were not holding a lock. There is a counter in the first page of the database that is incremented every time the database file is modified. We can find out if another process has modified the database by checking that counter. If the database was modified, then the user space cache must be cleared and reread. But it is commonly the case that no changes have been made and the user space cache can be reused for a significant performance savings.</source>
          <target state="translated">На диаграмме справа мы показываем,что информация,которая хранилась в пользовательском пространстве,очищается,когда замок освобождается.Раньше это было буквально так для старых версий SQLite.Но в более поздних версиях SQLite информация о пользовательском пространстве хранится в памяти на тот случай,если она может понадобиться снова при запуске следующей транзакции.Дешевле повторно использовать информацию,уже находящуюся в локальной памяти,чем переносить ее обратно из дискового кэша операционной системы или снова считывать с диска.Прежде чем повторно использовать информацию в пользовательском пространстве,мы должны сначала запросить общую блокировку,а затем проверить,чтобы убедиться,что никакой другой процесс не изменил файл базы данных в то время,когда у нас не было блокировки.На первой странице базы данных есть счетчик,который инкрементируется каждый раз,когда файл базы данных изменяется.Мы можем узнать,изменил ли другой процесс базу данных,проверив этот счетчик.Если база данных была изменена,то кэш пользовательского пространства должен быть очищен и перечитан.Но обычно так и бывает,что никаких изменений не было сделано,и кэш пользовательского пространства может быть использован повторно для значительной экономии производительности.</target>
        </trans-unit>
        <trans-unit id="bc4afe67e993812e607ae27c7ab087c30151c22e" translate="yes" xml:space="preserve">
          <source>In the diagram, each of the 8 tables in the FROM clause of the query is identified by a large circle with the label of the FROM-clause term: N2, S, L, P, O, C, N1 and R. The arcs in the graph represent the estimated cost of computing each term assuming that the origin of the arc is in an outer loop. For example, the cost of running the S loop as an inner loop to L is 2.30 whereas the cost of running the S loop as an outer loop to L is 9.17.</source>
          <target state="translated">На диаграмме каждая из 8 таблиц в выражении FROM запроса идентифицируется большим кружком с пометкой термина FROM-clause:N2,S,L,P,O,C,N1 и R.Дуги на графике представляют собой расчетную стоимость вычисления каждого члена в предположении,что начало дуги находится во внешней петле.Например,стоимость прогона петли S как внутренней петли на L равна 2,30,в то время как стоимость прогона петли S как внешней петли на L равна 9,17.</target>
        </trans-unit>
        <trans-unit id="395caf8810d6babac050840aec487ecca9bbc4bd" translate="yes" xml:space="preserve">
          <source>In the event of an operating system or power failure, the various combinations of file-system software and storage hardware available provide varying levels of guarantee as to the integrity of the data written to the file system just before or during the failure. The exact combination of IO operations that SQLite is required to perform in order to safely modify a database file depend on the exact characteristics of the target platform.</source>
          <target state="translated">В случае сбоя операционной системы или электропитания,различные комбинации доступного программного обеспечения файловой системы и аппаратного обеспечения хранения обеспечивают различные уровни гарантии целостности данных,записанных в файловую систему непосредственно перед или во время сбоя.Точная комбинация операций ввода-вывода,которую SQLite должен выполнить для того,чтобы безопасно модифицировать файл базы данных,зависит от точных характеристик целевой платформы.</target>
        </trans-unit>
        <trans-unit id="fbf76308006177e994e0ad525f9e6c338bce580b" translate="yes" xml:space="preserve">
          <source>In the example above, all the rows for each partition are grouped together in the final output. This is because the PARTITION BY clause is a prefix of the ORDER BY clause on the overall query. But that does not have to be the case. A partition can be composed of rows scattered about haphazardly within the result set. For example:</source>
          <target state="translated">В приведенном выше примере все строки для каждого раздела сгруппированы вместе в итоговом выводе.Это происходит потому,что пункт PARTITION BY является префиксом пункта ORDER BY в общем запросе.Но это не обязательно должно быть так.Раздел может состоять из строк,разбросанных беспорядочно в пределах результирующего множества.Например:</target>
        </trans-unit>
        <trans-unit id="5cf1e8a43e9d63b712df3d7090fc5c9414ccb7c0" translate="yes" xml:space="preserve">
          <source>In the example above, each triple identifies the location of a token instance by rowid, column number (columns are numbered sequentially starting at 0 from left to right) and position within the column value (the first token in a column value is 0, the second is 1, and so on). Using this index, FTS5 is able to provide timely answers to queries such as &quot;the set of all documents that contain the token 'A'&quot;, or &quot;the set of all documents that contain the sequence 'Y Z'&quot;. The list of instances associated with a single token is called an &quot;instance-list&quot;.</source>
          <target state="translated">В приведенном выше примере каждая тройка определяет местоположение экземпляра токена по rowid,номеру столбца (столбцы нумеруются последовательно,начиная с 0 слева направо)и позиции внутри значения столбца (первая токен в значении столбца-0,вторая-1 и т.д.).Используя этот индекс,FTS5 способен давать своевременные ответы на запросы,такие как &quot;набор всех документов,содержащих маркер 'A'&quot;,или &quot;набор всех документов,содержащих последовательность 'Y Z'&quot;.Список экземпляров,связанных с одним токеном,называется &quot;instance-list&quot;.</target>
        </trans-unit>
        <trans-unit id="6670429b3f62749505c4b98851abdba99076dc7b" translate="yes" xml:space="preserve">
          <source>In the example above, if most purchase orders do not have a &quot;parent&quot; purchase order, then most parent_po values will be NULL. That means only a small subset of the rows in the purchaseorder table will be indexed. Hence the index will take up much less space. And changes to the original purchaseorder table will run faster since the po_parent index only needs to be updated for those exceptional rows where parent_po is not NULL. But the index is still useful for querying. In particular, if one wants to know all &quot;children&quot; of a particular purchase order &quot;?1&quot;, the query would be:</source>
          <target state="translated">В приведенном выше примере,если большинство ордеров на покупку не имеют &quot;родительского&quot; ордера на покупку,то большинство значений параметра parent_po будет иметь значение NULL.Это означает,что будет проиндексировано только небольшое подмножество строк в таблице ордеров на покупку.Следовательно,индекс займет намного меньше места.А изменения в исходной таблице заказов на покупку будут выполняться быстрее,так как индекс po_parent нужно обновлять только для тех исключительных строк,где parent_po не NULL.Но индекс все равно полезен для запросов.В частности,если нужно знать все &quot;дочерние элементы&quot; конкретного заказа на покупку &quot;?1&quot;,то запрос будет:</target>
        </trans-unit>
        <trans-unit id="093d39a0dc19bc985afaed609f6ca65b1771f970" translate="yes" xml:space="preserve">
          <source>In the example above, the &quot;.header on&quot; line causes column labels to be printed as the first row of output. This means that the first row of the resulting CSV file will contain column labels. If column labels are not desired, set &quot;.header off&quot; instead. (The &quot;.header off&quot; setting is the default and can be omitted if the headers have not been previously turned on.)</source>
          <target state="translated">В приведенном выше примере,строка &quot;.header on&quot; (заголовок включен)вызывает печать меток столбцов как первой строки вывода.Это означает,что первая строка результирующего CSV-файла будет содержать метки столбцов.Если метки столбцов не нужны,установите &quot;.header off&quot; вместо этого.(Настройка &quot;.header off&quot; (Выключение заголовков)является настройкой по умолчанию и может быть опущена,если заголовки ранее не были включены).</target>
        </trans-unit>
        <trans-unit id="19c364b4c4bd5bb78a54b1baeb3476ed5a370176" translate="yes" xml:space="preserve">
          <source>In the example above, the &quot;.headers on&quot; line causes column labels to be printed as the first row of output. This means that the first row of the resulting CSV file will contain column labels. If column labels are not desired, set &quot;.headers off&quot; instead. (The &quot;.headers off&quot; setting is the default and can be omitted if the headers have not been previously turned on.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10cd93c52fe5f9cca786dee67c9404fab91f9de8" translate="yes" xml:space="preserve">
          <source>In the example above, the window frame consists of all rows between the previous row (&quot;1 PRECEDING&quot;) and the following row (&quot;1 FOLLOWING&quot;), inclusive, where rows are sorted according to the ORDER BY clause in the window-defn (in this case &quot;ORDER BY a&quot;). For example, the frame for the row with (a=3) consists of rows (2, 'B', 'two'), (3, 'C', 'three') and (4, 'D', 'one'). The result of group_concat(b, '.') for that row is therefore 'B.C.D'.</source>
          <target state="translated">В приведенном выше примере рамка окна состоит из всех строк между предыдущей строкой (&quot;1 ПОКАЗАТЕЛЬСТВО&quot;)и следующей строкой (&quot;1 ПОКАЗАТЕЛЬСТВО&quot;),включительно,где строки отсортированы в соответствии с пунктом &quot;ЗАКАЗАТЕЛЬСТВО ПО&quot; в окне-дефне (в данном случае &quot;ЗАКАЗАТЕЛЬСТВО ПО а&quot;).Например,рамка для строки с (a=3)состоит из строк (2,'B','два'),(3,'C','три')и (4,'D','один').Результат group_concat(b,'.')для этой строки,таким образом,является 'B.C.D'.</target>
        </trans-unit>
        <trans-unit id="b3d6a23d97e4594c0776e73b100f4f0f95f7c245" translate="yes" xml:space="preserve">
          <source>In the example queries above, every row of the table being queried must be loaded off of the disk and examined, even if only a small percentage of the rows end up in the result. This can take a long time on a big table. To speed things up, SQLite can use an index.</source>
          <target state="translated">В приведенных выше примерах запросов каждая строка опрашиваемой таблицы должна быть загружена с диска и рассмотрена,даже если в результате будет получен лишь небольшой процент строк.Это может занять много времени на большой таблице.Для ускорения работы SQLite может использовать индекс.</target>
        </trans-unit>
        <trans-unit id="097fb65fd13aa3cb8c9440796ac79504d1b2d367" translate="yes" xml:space="preserve">
          <source>In the example, instead of a single sort of 7 elements, there are 5 sorts of one-element each and 1 sort of 2 elements for the case of fruit=='Orange'.</source>
          <target state="translated">В примере,вместо одного вида из 7 элементов,есть 5 видов по одному элементу и 1 вид из 2 элементов для случая фрукта==&quot;Оранжевый&quot;.</target>
        </trans-unit>
        <trans-unit id="28b65ff31e772aaf95fd7eecfcefa7c33d5a2c49" translate="yes" xml:space="preserve">
          <source>In the example, the values in the &quot;term&quot; column are all lower case, even though they were inserted into table &quot;ft&quot; in mixed case. This is because an fts4aux table contains the terms as extracted from the document text by the &lt;a href=&quot;fts3#tokenizer&quot;&gt;tokenizer&lt;/a&gt;. In this case, since table &quot;ft&quot; uses the &lt;a href=&quot;fts3#tokenizer&quot;&gt;simple tokenizer&lt;/a&gt;, this means all terms have been folded to lower case. Also, there is (for example) no row with column &quot;term&quot; set to &quot;apple&quot; and column &quot;col&quot; set to 1. Since there are no instances of the term &quot;apple&quot; in column 1, no row is present in the fts4aux table.</source>
          <target state="translated">В этом примере значения в столбце &amp;laquo;term&amp;raquo; все в нижнем регистре, даже если они были вставлены в таблицу &amp;laquo;ft&amp;raquo; в смешанном регистре. Это связано с тем, что таблица fts4aux содержит термины, извлеченные из текста документа &lt;a href=&quot;fts3#tokenizer&quot;&gt;токенизатором&lt;/a&gt; . В этом случае, поскольку в таблице ft используется &lt;a href=&quot;fts3#tokenizer&quot;&gt;простой токенизатор&lt;/a&gt; , это означает, что все термины были свернуты в нижний регистр. Кроме того, (например) нет строки со столбцом &quot;term&quot;, установленным на &quot;яблоко&quot;, и столбцом &quot;col&quot;, установленным на 1. Поскольку в столбце 1 нет экземпляров термина &quot;apple&quot;, в столбце нет строки. таблица fts4aux.</target>
        </trans-unit>
        <trans-unit id="4d08492de7be0204d6bca6b75942d78b6a5e659c" translate="yes" xml:space="preserve">
          <source>In the examples above,</source>
          <target state="translated">В примерах выше,</target>
        </trans-unit>
        <trans-unit id="de880219c17c8178404452e7a6a65a0e25a5ab03" translate="yes" xml:space="preserve">
          <source>In the examples above, the APPCOST table would be interrogated to find the edit distance coefficients. It is the presence of the &quot;edit_cost_table=&quot; parameter to the spellfix1 module name that causes editdist3() to be used in place of the built-in edit distance function. If APPCOST is an empty string, then the built-in Wagner edit-distance function is used.</source>
          <target state="translated">В приведенных выше примерах таблица APPCOST будет опрашиваться для нахождения коэффициентов расстояния редактирования.Именно наличие параметра &quot;edit_cost_table=&quot; к имени модуля spellfix1 приводит к тому,что вместо встроенной функции расстояния редактирования используется editdist3().Если APPCOST является пустой строкой,то используется встроенная функция расстояния редактирования Вагнера.</target>
        </trans-unit>
        <trans-unit id="2400a1ee49a9dce2718b34cdfc5c379cec93c638" translate="yes" xml:space="preserve">
          <source>In the expression of a &lt;a href=&quot;gencol&quot;&gt;generated column&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3adc83f3d79277fad8353d570dcfc825d479731" translate="yes" xml:space="preserve">
          <source>In the expression of a &lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK constraint&lt;/a&gt;.</source>
          <target state="translated">В выражении &lt;a href=&quot;lang_createtable#ckconst&quot;&gt;ограничения CHECK&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1dc67cb87d0120f285414b41e4beb1e776521f83" translate="yes" xml:space="preserve">
          <source>In the expression part of an index on an expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ff8ef765e12ede160f30458a862b4edd37cec09" translate="yes" xml:space="preserve">
          <source>In the extreme case where the columns being indexed cover all columns of the PRIMARY KEY, the index will consist of only the columns being indexed. The ex25acde example above demonstrates this. Each entry in the ex25acde index consists of only the columns a, c, d, and e, in that order.</source>
          <target state="translated">В крайнем случае,когда индексируемые столбцы охватывают все столбцы PRIMARY KEY,индекс будет состоять только из индексируемых столбцов.Пример ex25acde,приведенный выше,демонстрирует это.Каждая запись в индексе ex25acde состоит только из столбцов a,c,d и e в этом порядке.</target>
        </trans-unit>
        <trans-unit id="f9d2f7bcd7e33c3c61f03684e92a0123ee2c50c1" translate="yes" xml:space="preserve">
          <source>In the first case, when the table does not previously exist, the table is automatically created and the content of the first row of the input CSV file is used to determine the name of all the columns in the table. In other words, if the table does not previously exist, the first row of the CSV file is interpreted to be column names and the actual data starts on the second row of the CSV file.</source>
          <target state="translated">В первом случае,когда таблица ранее не существовала,таблица создается автоматически и содержимое первой строки входного CSV-файла используется для определения имени всех столбцов таблицы.Другими словами,если таблица ранее не существовала,первая строка CSV-файла интерпретируется как имена столбцов,а фактические данные начинаются со второй строки CSV-файла.</target>
        </trans-unit>
        <trans-unit id="8cfb2ab353eeb9931ea61c166eef50db11918f37" translate="yes" xml:space="preserve">
          <source>In the following example, the window frame for each row consists of all rows from the current row to the end of the set, where rows are sorted according to &quot;ORDER BY a&quot;.</source>
          <target state="translated">В следующем примере оконная рамка для каждой строки состоит из всех строк от текущей строки до конца набора,где строки отсортированы в соответствии с &quot;ORDER BY a&quot;.</target>
        </trans-unit>
        <trans-unit id="26a8683102e2afa132677bc118b19b0b251deeec" translate="yes" xml:space="preserve">
          <source>In the following logically equivalent formulation of the same query, the substitution of &quot;CROSS JOIN&quot; for the &quot;,&quot; means that the order of tables must be N1, E, N2.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f7285bf84f2f7b9a693a0b5399377f6b0fc1389" translate="yes" xml:space="preserve">
          <source>In the following query, the optimizer is free to reorder the tables of FROM clause any way it sees fit:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad3b432372161232b364559d85e3c83dbfa80ec8" translate="yes" xml:space="preserve">
          <source>In the following query, the optimizer is free to reorder the tables of FROM clause anyway it sees fit:</source>
          <target state="translated">В следующем запросе оптимизатор может свободно переупорядочивать таблицы из пункта FROM,как ему заблагорассудится:</target>
        </trans-unit>
        <trans-unit id="213dce290e5c56de530174ae284660516d8c6333" translate="yes" xml:space="preserve">
          <source>In the future, this option may also disable other floating point functionality, for example the &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_double()&lt;/a&gt;, &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_double()&lt;/a&gt;, &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_double()&lt;/a&gt; and &lt;a href=&quot;c3ref/column_blob&quot;&gt;sqlite3_column_double()&lt;/a&gt; API functions.</source>
          <target state="translated">В будущем эта опция может также отключить другие функции с плавающей запятой, например , &lt;a href=&quot;c3ref/bind_blob&quot;&gt;функции&lt;/a&gt; API &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_double ()&lt;/a&gt; , sqlite3_bind_double () , &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_double ()&lt;/a&gt; и &lt;a href=&quot;c3ref/column_blob&quot;&gt;sqlite3_column_double ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="dfaedc6be2b7553cc537d3ce90c362a4be2c9a84" translate="yes" xml:space="preserve">
          <source>In the latter query, the query plan must be &lt;a href=&quot;#option2&quot;&gt;option 2&lt;/a&gt;. Note that you must use the keyword &quot;CROSS&quot; in order to disable the table reordering optimization; INNER JOIN, NATURAL JOIN, JOIN, and other similar combinations work just like a comma join in that the optimizer is free to reorder tables as it sees fit. (Table reordering is also disabled on an outer join, but that is because outer joins are not associative or commutative. Reordering tables in OUTER JOIN changes the result.)</source>
          <target state="translated">В последнем запросе план запроса должен быть &lt;a href=&quot;#option2&quot;&gt;вариантом 2&lt;/a&gt; . Обратите внимание, что вы должны использовать ключевое слово &amp;laquo;CROSS&amp;raquo;, чтобы отключить оптимизацию переупорядочения таблицы; INNER JOIN, NATURAL JOIN, JOIN и другие подобные комбинации работают так же, как соединение через запятую, в том смысле, что оптимизатор может изменять порядок таблиц по своему усмотрению. (Переупорядочение таблиц также отключено для внешнего соединения, но это потому, что внешние соединения не являются ассоциативными или коммутативными. Изменение порядка таблиц во OUTER JOIN меняет результат.)</target>
        </trans-unit>
        <trans-unit id="db1ceb5581cb83e63561f68248a7b5044a5f4d90" translate="yes" xml:space="preserve">
          <source>In the legacy interface, the return value will be either &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY&lt;/a&gt;, &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_DONE&lt;/a&gt;, &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ROW&lt;/a&gt;, &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt;, or &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_MISUSE&lt;/a&gt;. With the &quot;v2&quot; interface, any of the other &lt;a href=&quot;rescode&quot;&gt;result codes&lt;/a&gt; or &lt;a href=&quot;rescode#extrc&quot;&gt;extended result codes&lt;/a&gt; might be returned as well.</source>
          <target state="translated">В устаревшем интерфейсе возвращаемое значение будет либо &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY&lt;/a&gt; , &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_DONE&lt;/a&gt; , &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ROW&lt;/a&gt; , &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt; или &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_MISUSE&lt;/a&gt; . С интерфейсом &amp;laquo;v2&amp;raquo; также могут быть возвращены любые другие &lt;a href=&quot;rescode&quot;&gt;коды результатов&lt;/a&gt; или &lt;a href=&quot;rescode#extrc&quot;&gt;расширенные коды результатов&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c4f1e2e6a1b6e2882af269cc303fc56c8348c472" translate="yes" xml:space="preserve">
          <source>In the legacy interface, the return value will be either &lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;, &lt;a href=&quot;../rescode#done&quot;&gt;SQLITE_DONE&lt;/a&gt;, &lt;a href=&quot;../rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt;, &lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt;, or &lt;a href=&quot;../rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt;. With the &quot;v2&quot; interface, any of the other &lt;a href=&quot;../rescode&quot;&gt;result codes&lt;/a&gt; or &lt;a href=&quot;../rescode#extrc&quot;&gt;extended result codes&lt;/a&gt; might be returned as well.</source>
          <target state="translated">В устаревшем интерфейсе возвращаемое значение будет либо &lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; , &lt;a href=&quot;../rescode#done&quot;&gt;SQLITE_DONE&lt;/a&gt; , &lt;a href=&quot;../rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt; , &lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt; или &lt;a href=&quot;../rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt; . С интерфейсом &amp;laquo;v2&amp;raquo; также могут быть возвращены любые другие &lt;a href=&quot;../rescode&quot;&gt;коды результатов&lt;/a&gt; или &lt;a href=&quot;../rescode#extrc&quot;&gt;расширенные коды результатов&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3e24ef81342a9cacce2edb83f3edc5fc97054dd2" translate="yes" xml:space="preserve">
          <source>In the previous query the fruit='Peach' constraint narrowed the result down to a single row. But the same technique works even if multiple rows are obtained. Suppose we looked up the price of Oranges instead of Peaches:</source>
          <target state="translated">В предыдущем запросе ограничение fruit='Peach' сузило результат до одной строки.Но та же самая техника работает,даже если получено несколько строк.Предположим,мы посмотрели вверх цену &quot;Апельсинов&quot;,а не &quot;Персиков&quot;:</target>
        </trans-unit>
        <trans-unit id="33c558ed5ce36b119e16ee3e9d824eb5021f92cb" translate="yes" xml:space="preserve">
          <source>In the previous sections, we have seen how moving from a key/value store implemented as a ZIP archive to a simple SQLite database with just three tables can add significant capabilities to an application file format. We could continue to enhance the schema with new tables, with indexes added for performance, with triggers and views for programming convenience, and constraints to enforce consistency of content even in the face of programming errors. Further enhancement ideas include:</source>
          <target state="translated">В предыдущих разделах мы видели,как переход от хранилища ключей/значений,реализованный в виде ZIP-архива,к простой базе данных SQLite,содержащей всего три таблицы,может добавить значительные возможности формату файла приложения.Мы могли бы продолжать совершенствовать схему с новыми таблицами,с индексами,добавленными для повышения производительности,с триггерами и представлениями для удобства программирования,а также с ограничениями для обеспечения согласованности содержимого даже перед лицом ошибок программирования.Дальнейшие идеи по улучшению включают в себя:</target>
        </trans-unit>
        <trans-unit id="6567a872214501806e02589f934b8c11a8b0e4f5" translate="yes" xml:space="preserve">
          <source>In the previous, the &quot;type NOT IN ('object','array')&quot; term of the WHERE clause suppresses containers and only lets through leaf elements. The same effect could be achieved this way:</source>
          <target state="translated">В предыдущем пункте термин &quot;type NOT IN (&quot;объект&quot;,&quot;массив&quot;)&quot; пункта WHERE подавляет контейнеры и пропускает только элементы листа.Аналогичного эффекта можно добиться и таким образом:</target>
        </trans-unit>
        <trans-unit id="cbeb7859d795228eb3a3ec910c174670d8e945ef" translate="yes" xml:space="preserve">
          <source>In the query above, if both t1 and t2 have approximately N rows, then without any indexes the query will require O(N*N) time. On the other hand, creating an index on table t2 requires O(NlogN) time and using that index to evaluate the query requires an additional O(NlogN) time. In the absence of &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; information, SQLite guesses that N is one million and hence it believes that constructing the automatic index will be the cheaper approach.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1dd63ff23c59a1e0a739d0a06a35ed29c44ad2c6" translate="yes" xml:space="preserve">
          <source>In the query above, if both t1 and t2 have approximately N rows, then without any indices the query will require O(N*N) time. On the other hand, creating an index on table t2 requires O(NlogN) time and then use that index to evaluate the query requires an additional O(NlogN) time. In the absence of &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; information, SQLite guesses that N is one million and hence it believes that constructing the automatic index will be the cheaper approach.</source>
          <target state="translated">В приведенном выше запросе, если и t1, и t2 имеют приблизительно N строк, то без каких-либо индексов запрос потребует времени O (N * N). С другой стороны, создание индекса для таблицы t2 требует времени O (NlogN), а затем использование этого индекса для оценки запроса требует дополнительного времени O (NlogN). В отсутствие информации &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; SQLite предполагает, что N равно одному миллиону, и, следовательно, считает, что построение автоматического индекса будет более дешевым подходом.</target>
        </trans-unit>
        <trans-unit id="d42fa24dde8794f21d6a489ff49ead792c8bc812" translate="yes" xml:space="preserve">
          <source>In the query above, one would presumably bind the binary BLOB description of the precise boundary of the 12th district to the &quot;:boundary&quot; parameter.</source>
          <target state="translated">В вышеуказанном запросе предполагается связать двоичное BLOB-описание точной границы 12-ой округа с параметром &quot;:граница&quot;.</target>
        </trans-unit>
        <trans-unit id="5dbfd2d21d7bf5385c8b5fed28f3d0558f663390" translate="yes" xml:space="preserve">
          <source>In the query above, the &quot;PARTITION BY c&quot; clause breaks the result set up into three partitions. The first partition has three rows with c=='one'. The second partition has two rows with c=='three' and the third partition has two rows with c=='two'.</source>
          <target state="translated">В вышеприведенном запросе,пункт &quot;Участие в c&quot; разбивает результат,установленный на три простенка.Первый раздел имеет три строки с символом c=='one'.Второй простенок имеет две строки с c=='тремя',а третий простенок имеет две строки с c=='двумя'.</target>
        </trans-unit>
        <trans-unit id="ff23670a4dd151a2afe2511d238ffe5c9f59a6d2" translate="yes" xml:space="preserve">
          <source>In the query above, the &quot;a&quot; column is part of the GROUP BY clause and so each row of the output contains one of the distinct values for &quot;a&quot;. The &quot;c&quot; column is contained within the &lt;a href=&quot;lang_aggfunc#sumunc&quot;&gt;sum()&lt;/a&gt; aggregate function and so that output column is the sum of all &quot;c&quot; values in rows that have the same value for &quot;a&quot;. But what is the result of the bare column &quot;b&quot;? The answer is that the &quot;b&quot; result will be the value for &quot;b&quot; in one of the input rows that form the aggregate. The problem is that you usually do not know which input row is used to compute &quot;b&quot;, and so in many cases the value for &quot;b&quot; is undefined.</source>
          <target state="translated">В приведенном выше запросе столбец &amp;laquo;a&amp;raquo; является частью предложения GROUP BY, поэтому каждая строка вывода содержит одно из различных значений для &amp;laquo;a&amp;raquo;. Столбец &amp;laquo;c&amp;raquo; содержится в агрегатной функции &lt;a href=&quot;lang_aggfunc#sumunc&quot;&gt;sum (),&lt;/a&gt; поэтому выходной столбец представляет собой сумму всех значений &amp;laquo;c&amp;raquo; в строках, которые имеют одинаковое значение для &amp;laquo;a&amp;raquo;. Но каков результат голого столбца &amp;laquo;б&amp;raquo;? Ответ заключается в том, что результат &amp;laquo;b&amp;raquo; будет значением для &amp;laquo;b&amp;raquo; в одной из входных строк, образующих агрегат. Проблема в том, что вы обычно не знаете, какая входная строка используется для вычисления &amp;laquo;b&amp;raquo;, и поэтому во многих случаях значение &amp;laquo;b&amp;raquo; не определено.</target>
        </trans-unit>
        <trans-unit id="cd7c1539a48900d085cdab5fe3ab086624874b10" translate="yes" xml:space="preserve">
          <source>In the query above, the subquery &quot;SELECT b FROM ex2&quot; is evaluated and its results are stored in a temporary table (actually a temporary index) that allows one to determine whether or not a value ex2.b exists using a simple binary search. Once this table is constructed, the outer query is run and for each prospective result row a check is made to see if ex1.a is contained within the temporary table. The row is output only if the check is true.</source>
          <target state="translated">В вышеуказанном запросе вычисляется подзапрос &quot;SELECT b FROM ex2&quot;,результаты которого хранятся во временной таблице (фактически временном индексе),что позволяет определить,существует ли значение ex2.b с помощью простого двоичного поиска.После построения этой таблицы выполняется внешний запрос,и для каждой предполагаемой строки результата проверяется,содержится ли ex1.a во временной таблице.Строка выводится только в том случае,если проверка истинна.</target>
        </trans-unit>
        <trans-unit id="e4290c818e5599eff7616300b06206a049026a55" translate="yes" xml:space="preserve">
          <source>In the query above, the values for the first_name and last_name columns will correspond to the row that satisfied the max(salary) condition.</source>
          <target state="translated">В вышеуказанном запросе значения для столбцов first_name и last_name будут соответствовать строке,удовлетворяющей условию max(salary).</target>
        </trans-unit>
        <trans-unit id="812c0304c15e5adbac36486ee814e9ec1db44d78" translate="yes" xml:space="preserve">
          <source>In the revised query, the subquery implemented by a co-routine computes the five most recent values for &quot;a&quot;. Those five values are passed from the co-routine up into the outer query where the &quot;expensive_function()&quot; is invoked on only the specific rows that the application cares about.</source>
          <target state="translated">В пересмотренном запросе в подзапросе,реализованном с помощью ко-маршрута,вычисляются пять самых последних значений для &quot;a&quot;.Эти пять значений передаются из ко-маршрута во внешний запрос,где &quot;expensive_function()&quot; вызывается только на определенных строках,о которых заботится приложение.</target>
        </trans-unit>
        <trans-unit id="5464a60c31d2aba9c62ea2f61ec84b78e0768c87" translate="yes" xml:space="preserve">
          <source>In the second example, the expression in the DO UPDATE clause is of the form &quot;excluded.phonenumber&quot;. The &quot;excluded.&quot; prefix causes the &quot;phonenumber&quot; to refer to the value for phonenumber that would have been inserted had there been no conflict. Hence, the effect of the upsert is to insert a phonenumber of Alice if none exists, or to overwrite any prior phonenumber for Alice with the new one.</source>
          <target state="translated">Во втором примере выражение в пункте DO UPDATE имеет вид &quot;excluded.phonenumber&quot;.Префикс &quot;excluded.&quot; заставляет &quot;phonenumber&quot; ссылаться на значение для phonenumber,которое было бы вставлено,если бы не конфликт.Следовательно,эффект от выпадения заключается в том,чтобы вставить номер телефона Алисы,если таковой отсутствует,или переписать любой предыдущий номер телефона Алисы на новый.</target>
        </trans-unit>
        <trans-unit id="0d5709c51541d0085c2cbbc496ec178e66f3f72e" translate="yes" xml:space="preserve">
          <source>In the sequence on the left, the second insert will fail. In this case, the strings '0' and '0.0' are treated as numbers since they are being inserted into a numeric column but 0==0.0 which violates the uniqueness constraint. However, the second insert in the right-hand sequence works. In this case, the constants 0 and 0.0 are treated a strings which means that they are distinct.</source>
          <target state="translated">В последовательности слева вторая вставка будет неудачной.В этом случае строки '0' и '0.0' рассматриваются как числа,так как они вставляются в числовой столбец,но 0==0.0,что нарушает ограничение уникальности.Однако,вторая вставка в правой последовательности работает.В этом случае,константы 0 и 0.0 обрабатываются как строки,что означает,что они отличаются друг от друга.</target>
        </trans-unit>
        <trans-unit id="a547afdf67cd8d948e7c4160e0e5b6f6d4b49400" translate="yes" xml:space="preserve">
          <source>In the shell, &lt;b&gt;sqlite_interrupt()&lt;/b&gt; is invoked when the user presses Control-C</source>
          <target state="translated">В оболочке &lt;b&gt;sqlite_interrupt ()&lt;/b&gt; вызывается, когда пользователь нажимает Control-C</target>
        </trans-unit>
        <trans-unit id="8d983faa26111b1d1fcd83dfccc76792d6f87417" translate="yes" xml:space="preserve">
          <source>In the spellfix1 algorithm, cFrom is the text as the user entered it and cTo is the correctly spelled text as it exists in the database. The goal of the editdist3 algorithm is to determine how close the user-entered text is to the dictionary text.</source>
          <target state="translated">В алгоритме spellfix1 cFrom-это текст,как его ввел пользователь,а cTo-это правильно написанный текст,как он существует в базе данных.Цель алгоритма editdist3-определить,насколько близко пользовательский текст находится к тексту словаря.</target>
        </trans-unit>
        <trans-unit id="f33fd6db9521ba57d781c7a6cc1cb461b4a1e385" translate="yes" xml:space="preserve">
          <source>In the sqlite shell, now print the version number on initial startup.</source>
          <target state="translated">В оболочке sqlite теперь распечатайте номер версии при первом запуске.</target>
        </trans-unit>
        <trans-unit id="567ed9c7de12cfc6ba8542459479acb37712e779" translate="yes" xml:space="preserve">
          <source>In the sqlite shell, print the &quot;Database opened READ ONLY&quot; message to stderr instead of stdout.</source>
          <target state="translated">В sqlite оболочке вместо stdout выведите сообщение &quot;Database opened READ ONLY&quot; (&quot;База данных открыта ТОЛЬКО&quot;)в stderr.</target>
        </trans-unit>
        <trans-unit id="04b0bd3687019af0690c1810844c9c6e7505bacb" translate="yes" xml:space="preserve">
          <source>In the statement above, the FTS3 cursor pointer generated by the MATCH operator is send into the carray() table-valued function instead of its intended recipient snippet(). The carray() function treats the pointer as a pointer to an array of integers and returns each integer one by one, thus leaking the content of the FTS3 cursor object. Since the FTS3 cursor object contains pointers to other objects, the statement above would be a pointer leak.</source>
          <target state="translated">В приведенном выше утверждении указатель курсора FTS3,генерируемый оператором MATCH,посылается в функцию carray()table-valued вместо его предполагаемого получателя snippet().Функция carray()рассматривает указатель как указатель на массив целых чисел и возвращает каждое целое число по одному,тем самым пропуская содержимое объекта курсора FTS3.Поскольку объект курсора FTS3 содержит указатели на другие объекты,приведенное выше утверждение будет утечкой указателя.</target>
        </trans-unit>
        <trans-unit id="e5c24d1846d01f843a98c707910ed22a0e9486cc" translate="yes" xml:space="preserve">
          <source>In the templates above, NNN represents an integer literal, and VVV represents an alphanumeric identifier. The values of these parameters (also called &quot;host parameter names&quot; or &quot;SQL parameters&quot;) can be set using the sqlite3_bind_*() routines defined here.</source>
          <target state="translated">В приведенных выше шаблонах NNN представляет собой целое число букв,а VVV-буквенно-цифровой идентификатор.Значения этих параметров (также называемых &quot;имена параметров хоста&quot; или &quot;SQL-параметры&quot;)могут быть установлены с помощью определенных здесь процедур sqlite3_bind_*().</target>
        </trans-unit>
        <trans-unit id="dee8f982211055f9a9e8d1a438d7f794e0810555" translate="yes" xml:space="preserve">
          <source>In the underlying &lt;a href=&quot;fileformat2&quot;&gt;file format&lt;/a&gt;, each rowid is stored as a &lt;a href=&quot;fileformat2#varint&quot;&gt;variable-length integer&lt;/a&gt;. That means that small non-negative rowid values take up less disk space than large or negative rowid values.</source>
          <target state="translated">В базовом &lt;a href=&quot;fileformat2&quot;&gt;формате файла&lt;/a&gt; каждый rowid хранится как &lt;a href=&quot;fileformat2#varint&quot;&gt;целое число переменной длины&lt;/a&gt; . Это означает, что небольшие неотрицательные значения rowid занимают меньше места на диске, чем большие или отрицательные значения rowid.</target>
        </trans-unit>
        <trans-unit id="147d02b1e1e949a788ff444f3cb5e754276ba6d2" translate="yes" xml:space="preserve">
          <source>In this case the aConstraint[].op value is the same as the value returned by &lt;a href=&quot;vtab#xfindfunction&quot;&gt;xFindFunction()&lt;/a&gt; for FUNCTION.</source>
          <target state="translated">В этом случае значение aConstraint []. Op совпадает со значением, возвращаемым &lt;a href=&quot;vtab#xfindfunction&quot;&gt;xFindFunction ()&lt;/a&gt; для FUNCTION.</target>
        </trans-unit>
        <trans-unit id="b6bf8cbfac9c457904e9c2859da73ee4a95d3f0d" translate="yes" xml:space="preserve">
          <source>In this case using the temporary b-tree can be avoided by creating an index on t2(c), as follows:</source>
          <target state="translated">В этом случае использования временного b-дерева можно избежать,создав индекс на t2(c)следующим образом:</target>
        </trans-unit>
        <trans-unit id="a530fdc0efceb4d3e07dfc220358b90fa2145a02" translate="yes" xml:space="preserve">
          <source>In this case, SQLite still does a single binary search to find the first entry of the index where fruit='Orange'. Then it extracts the rowid from the index and uses that rowid to lookup the original table entry via binary search and output the price from the original table. But instead of quitting, the database engine then advances to the next row of index to repeat the process for next fruit='Orange' entry. Advancing to the next row of an index (or table) is much less costly than doing a binary search since the next row is often located on the same database page as the current row. In fact, the cost of advancing to the next row is so cheap in comparison to a binary search that we usually ignore it. So our estimate for the total cost of this query is 3 binary searches. If the number of rows of output is K and the number of rows in the table is N, then in general the cost of doing the query is proportional to (K+1)*logN.</source>
          <target state="translated">В этом случае SQLite все равно выполняет один двоичный поиск,чтобы найти первую запись индекса,где фрукт='Оранжевый'.Затем он извлекает строку из индекса и использует эту строку для поиска исходной записи таблицы с помощью бинарного поиска и вывода цены из исходной таблицы.Но вместо того,чтобы выйти,механизм базы данных затем переходит к следующей строке индекса,чтобы повторить процесс для следующего фрукта='Orange' запись.Переход к следующей строке индекса (или таблицы)намного дешевле,чем бинарный поиск,так как следующая строка часто располагается на той же странице базы данных,что и текущая строка.На самом деле,стоимость перехода к следующей строке настолько дешева по сравнению с бинарным поиском,что мы обычно игнорируем это.Таким образом,наша оценка общей стоимости этого запроса составляет 3 двоичных поиска.Если количество выводимых строк равно K,а количество строк в таблице N,то в общем случае стоимость выполнения запроса пропорциональна (K+1)*logN.</target>
        </trans-unit>
        <trans-unit id="419a046b4e9791c3dfbe6ecdc597fd0e975a6969" translate="yes" xml:space="preserve">
          <source>In this chart, an SQL statement (&quot;SELECT v FROM kv WHERE k=?1&quot;) is prepared once. Then for each blob, the blob key value is bound to the ?1 parameter and the statement is evaluated to extract the blob content.</source>
          <target state="translated">На этом графике один раз подготавливается SQL-оператор (&quot;SELECT v FROM kv WHERE k=?1&quot;).Затем для каждого блока значение ключа привязывается к параметру ?1 и оператор обрабатывается для извлечения содержимого блока.</target>
        </trans-unit>
        <trans-unit id="67f262080695617f0fd577e77df041ccaf828f11" translate="yes" xml:space="preserve">
          <source>In this example, the content of the docs.body field for the entry where docs.name is &quot;report-15&quot; will be sent to the editor. After the editor returns, the result will be written back into the docs.body field.</source>
          <target state="translated">В данном примере содержимое поля docs.body для записи,где docs.name-это &quot;report-15&quot;,будет отправлено в редактор.После возврата редактора результат будет записан обратно в поле docs.body.</target>
        </trans-unit>
        <trans-unit id="3455933a8fde6f3fc95c8e0f500aee581e4e0da2" translate="yes" xml:space="preserve">
          <source>In this example, the demo_data.boundary field is intended to hold some kind of binary representation of the precise boundaries of the object. The R*Tree index only holds an axis-aligned rectangular boundary for the object. The R*Tree boundary is just an approximation of the true object boundary. So what typically happens is that the R*Tree index is used to narrow a search down to a list of candidate objects and then more detailed and expensive computations are done on each candidate to find if the candidate truly meets the search criteria.</source>
          <target state="translated">В данном примере поле demo_data.boundary предназначено для проведения некоего двоичного представления точных границ объекта.Индекс R*Tree содержит только выровненную по оси прямоугольную границу объекта.Граница R*Tree является лишь аппроксимацией истинной границы объекта.Так что обычно происходит,что индекс R*Tree используется для сужения поиска до списка объектов-кандидатов,а затем проводятся более детальные и дорогие вычисления по каждому кандидату,чтобы найти,действительно ли кандидат соответствует критериям поиска.</target>
        </trans-unit>
        <trans-unit id="0eba84e3861d469d7f133f2d07dd6079cc3e76b6" translate="yes" xml:space="preserve">
          <source>In this example, the rowids are not consecutive but they are ordered. SQLite usually creates rowids beginning with one and increasing by one with each added row. But if rows are deleted, gaps can appear in the sequence. And the application can control the rowid assigned if desired, so that rows are not necessarily inserted at the bottom. But regardless of what happens, the rowids are always unique and in strictly ascending order.</source>
          <target state="translated">В данном примере рядовые не являются последовательными,а упорядочены.SQLite обычно создает рядки,начинающиеся с одного и увеличивающиеся на один с каждой добавленной строкой.Но если строки удаляются,то в последовательности могут появляться пробелы.При желании приложение может управлять назначенными rowid'ами,чтобы строки не обязательно вставлялись внизу.Но независимо от того,что происходит,ряды всегда уникальны и находятся в строго возрастающем порядке.</target>
        </trans-unit>
        <trans-unit id="5350836f804099dba5657839c67d9e6572dea27d" translate="yes" xml:space="preserve">
          <source>In this example, the t2 table is used in a subquery to translate values of the t1.b column. If each table contains N rows, SQLite expects that the subquery will run N times, and hence it will believe it is faster to construct an automatic, transient index on t2 first and then use that index to satisfy the N instances of the subquery.</source>
          <target state="translated">В данном примере таблица t2 используется в подзапросе для перевода значений столбца t1.b.Если каждая таблица содержит N строк,SQLite ожидает,что подзапрос будет выполняться N раз,и поэтому он поверит,что быстрее построить сначала автоматический переходный индекс по t2,а затем использовать этот индекс для удовлетворения N экземпляров подзапроса.</target>
        </trans-unit>
        <trans-unit id="c42a9794244d33827402d87bbb30dbcaf8693beb" translate="yes" xml:space="preserve">
          <source>In this last example, the phonebook2 entry is only updated if the validDate for the newly inserted value is newer than the entry already in the table. If the table already contains an entry with the same name and a current validDate, then the WHERE clause causes the DO UPDATE to become a no-op.</source>
          <target state="translated">В этом последнем примере запись в телефонной книге2 обновляется только в том случае,если validDate для только что вставленного значения будет более новой,чем запись,уже содержащаяся в таблице.Если таблица уже содержит запись с таким же именем и текущей датой validDate,то пункт WHERE приводит к тому,что DO UPDATE становится недействительной.</target>
        </trans-unit>
        <trans-unit id="25dff0fca0922d5e6626c7a322eba86698c2596d" translate="yes" xml:space="preserve">
          <source>In this latter table, there is only a single B-Tree which uses the &quot;word&quot; column as its key and the &quot;cnt&quot; column as its data. (Technicality: the low-level implementation actually stores both &quot;word&quot; and &quot;cnt&quot; in the &quot;key&quot; area of the B-Tree. But unless you are looking at the low-level byte encoding of the database file, that fact is unimportant.) Because there is only a single B-Tree, the text of the &quot;word&quot; column is only stored once in the database. Furthermore, querying the &quot;cnt&quot; value for a specific &quot;word&quot; only involves a single binary search into the main B-Tree, since the &quot;cnt&quot; value can be retrieved directly from the record found by that first search and without the need to do a second binary search on the rowid.</source>
          <target state="translated">В этой последней таблице есть только одно B-дерево,в котором в качестве ключа используется столбец &quot;слово&quot;,а в качестве данных-столбец &quot;cnt&quot;.(Техническая сторона:низкоуровневая реализация фактически хранит и &quot;слово&quot;,и &quot;cnt&quot; в области &quot;ключ&quot; B-дерева.Но если не смотреть на низкоуровневую байтовую кодировку файла БД,то этот факт не имеет значения).Поскольку существует только одно B-дерево,текст столбца &quot;word&quot; в БД хранится только один раз.Кроме того,запрос значения &quot;cnt&quot; для конкретного &quot;слова&quot; предполагает только один двоичный поиск в основном B-дереве,так как значение &quot;cnt&quot; может быть извлечено непосредственно из найденной при этом первом поиске записи и без необходимости выполнять второй двоичный поиск в рядке.</target>
        </trans-unit>
        <trans-unit id="27f1607d8d73cecfa7aadf0af1217d0ee5b1b3de" translate="yes" xml:space="preserve">
          <source>In this query, the &quot;xaxis&quot; and &quot;yaxis&quot; CTEs define the grid of points for which the Mandelbrot Set will be approximated. Each row in the &quot;m(iter,cx,cy,x,y)&quot; CTE means that after &quot;iter&quot; iterations, the Mandelbrot iteration starting at cx,cy has reached point x,y. The number of iterations in this example is limited to 28 (which severely limits the resolution of the computation, but is sufficient for low-resolution ASCII-art output). The &quot;m2(iter,cx,cy)&quot; CTE holds the maximum number of iterations reached when starting at point cx,cy. Finally, each row in the &quot;a(t)&quot; CTE holds a string which is a single line of the output ASCII-art. The SELECT statement at the end just queries the &quot;a&quot; CTE to retrieve all lines of ASCII-art, one by one.</source>
          <target state="translated">В данном запросе CTE &quot;xaxis&quot; и &quot;yaxis&quot; определяют сетку точек,для которых будет аппроксимирована группа Мандельброта.Каждая строка в &quot;m(iter,cx,cy,x,y)&quot; CTE означает,что после &quot;итерационных&quot; итераций,итерация Мандельброта,начинающаяся с cx,cy достигла точки x,y.Количество итераций в данном примере ограничено 28 (что существенно ограничивает разрешение расчета,но достаточно для вывода ASCII-art низкого разрешения).ЭОП &quot;m2(iter,cx,cy)&quot; удерживает максимальное количество итераций,достигнутое при старте в точке cx,cy.Наконец,каждая строка в &quot;a(t)&quot; CTE содержит строку,которая является единственной строкой выходного ASCII-art.Оператор SELECT в конце просто запрашивает &quot;a&quot; CTE,чтобы получить все строки ASCII-art,одну за другой.</target>
        </trans-unit>
        <trans-unit id="e3c6ef43db25cfa53ed4da6f4cdaac9eb93f9ff7" translate="yes" xml:space="preserve">
          <source>In this schema, instead of each slide having a page number that determines its order within the presentation, each slide has a unique integer identifier that is unrelated to where it occurs in sequence. The order of slides in the presentation is determined by a list of slideIds, stored as a text string in the MANIFEST column of the VERSION table. Since multiple entries are allowed in the VERSION table, that means that multiple presentations can be stored in the same document.</source>
          <target state="translated">В этой схеме вместо того,чтобы каждый слайд имел номер страницы,определяющий его порядок в представлении,каждый слайд имеет уникальный целочисленный идентификатор,не связанный с тем,где он происходит последовательно.Порядок слайдов в представлении определяется списком слайдов,хранящихся в виде текстовой строки в колонке MANIFEST таблицы VERSION.Поскольку в таблице VERSION разрешено несколько записей,это означает,что в одном и том же документе можно хранить несколько презентаций.</target>
        </trans-unit>
        <trans-unit id="0941893928b48e6ed8f71fafe5691ea7ff76077a" translate="yes" xml:space="preserve">
          <source>In this system, each entry in the song table is required to map to an entry in the album table with the same combination of artist and album.</source>
          <target state="translated">В этой системе каждая запись в таблице композиций должна быть сопоставлена с записью в таблице альбомов с той же комбинацией исполнителя и альбома.</target>
        </trans-unit>
        <trans-unit id="e2304a60e4555367ae83803d8a81dcbbc6bac3fc" translate="yes" xml:space="preserve">
          <source>In this way the new pointer-passing interface seems to solve all of the security problems associated with passing pointer values from one extension to another in SQLite.</source>
          <target state="translated">Таким образом,новый интерфейс обхода указателей,кажется,решает все проблемы безопасности,связанные с передачей значений указателей из одного расширения в другое в SQLite.</target>
        </trans-unit>
        <trans-unit id="5b4cc2bd1f16fd79626e9a2d355ec8140a8334dd" translate="yes" xml:space="preserve">
          <source>In those routines that have a fourth argument, its value is the number of bytes in the parameter. To be clear: the value is the number of &lt;u&gt;bytes&lt;/u&gt; in the value, not the number of characters. If the fourth parameter to sqlite3_bind_text() or sqlite3_bind_text16() is negative, then the length of the string is the number of bytes up to the first zero terminator. If the fourth parameter to sqlite3_bind_blob() is negative, then the behavior is undefined. If a non-negative fourth parameter is provided to sqlite3_bind_text() or sqlite3_bind_text16() or sqlite3_bind_text64() then that parameter must be the byte offset where the NUL terminator would occur assuming the string were NUL terminated. If any NUL characters occur at byte offsets less than the value of the fourth parameter then the resulting string value will contain embedded NULs. The result of expressions involving strings with embedded NULs is undefined.</source>
          <target state="translated">В тех подпрограммах, у которых есть четвертый аргумент, его значением является количество байтов в параметре. Для ясности: значение - это количество &lt;u&gt;байтов&lt;/u&gt;в значении, а не в количестве символов. Если четвертый параметр sqlite3_bind_text () или sqlite3_bind_text16 () отрицательный, то длина строки равна количеству байтов до первого нулевого ограничителя. Если четвертый параметр sqlite3_bind_blob () отрицательный, поведение не определено. Если неотрицательный четвертый параметр предоставлен sqlite3_bind_text (), sqlite3_bind_text16 () или sqlite3_bind_text64 (), тогда этот параметр должен быть байтовым смещением, в котором будет стоять символ конца NUL, если строка завершается NUL. Если какие-либо символы NUL встречаются при смещении байтов меньше значения четвертого параметра, тогда результирующее строковое значение будет содержать встроенные NUL. Результат выражений, содержащих строки со встроенными NUL, не определен.</target>
        </trans-unit>
        <trans-unit id="f5c0b6c1ce652bbe2a9ce301182f0e17dcf5f222" translate="yes" xml:space="preserve">
          <source>In those routines that have a fourth argument, its value is the number of bytes in the parameter. To be clear: the value is the number of &lt;u&gt;bytes&lt;/u&gt; in the value, not the number of characters. If the fourth parameter to sqlite3_bind_text() or sqlite3_bind_text16() is negative, then the length of the string is the number of bytes up to the first zero terminator. If the fourth parameter to sqlite3_bind_blob() is negative, then the behavior is undefined. If a non-negative fourth parameter is provided to sqlite3_bind_text() or sqlite3_bind_text16() or sqlite3_bind_text64() then that parameter must be the byte offset where the NUL terminator would occur assuming the string were NUL terminated. If any NUL characters occurs at byte offsets less than the value of the fourth parameter then the resulting string value will contain embedded NULs. The result of expressions involving strings with embedded NULs is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5828032be03f722c81b6852fba96bca0f86ff7f" translate="yes" xml:space="preserve">
          <source>In truncate journal mode, the transaction is committed by truncating the journal file to zero length rather than deleting the journal file (as in DELETE mode) or by zeroing the header (as in PERSIST mode). TRUNCATE mode shares the advantage of PERSIST mode that the directory that contains the journal file and database does not need to be updated. Hence truncating a file is often faster than deleting it. TRUNCATE has the additional advantage that it is not followed by a system call (ex: fsync()) to synchronize the change to disk. It might be safer if it did. But on many modern filesystems, a truncate is an atomic and synchronous operation and so we think that TRUNCATE will usually be safe in the face of power failures. If you are uncertain about whether or not TRUNCATE will be synchronous and atomic on your filesystem and it is important to you that your database survive a power loss or operating system crash that occurs during the truncation operation, then you might consider using a different journaling mode.</source>
          <target state="translated">В режиме усеченного журнала транзакция фиксируется путем усечения файла журнала на нулевую длину вместо удаления файла журнала (как в режиме DELETE)или путем обнуления заголовка (как в режиме PERSIST).Режим TRUNCATE имеет то преимущество режима PERSIST,что каталог,содержащий файл журнала и базу данных,не нуждается в обновлении.Поэтому усечение файла зачастую происходит быстрее,чем его удаление.Дополнительным преимуществом режима TRUNCATE является то,что за ним не следует системный вызов (например:fsync())для синхронизации изменения на диск.Это может быть безопаснее.Но на многих современных файловых системах усечение является атомарной и синхронной операцией,поэтому мы считаем,что TRUNCATE обычно будет безопасен при отключении питания.Если вы не уверены в том,будет ли TRUNCATE синхронным и атомарным в вашей файловой системе,и для вас важно,чтобы ваша база данных пережила потерю питания или сбой операционной системы,который происходит во время усечения,то вы можете подумать об использовании другого режима протоколирования.</target>
        </trans-unit>
        <trans-unit id="0ad1bfd687f56543c8ea5ff79723971d89b554aa" translate="yes" xml:space="preserve">
          <source>In version 3.5.9 the query above would return a single column named &quot;t1.a&quot;. In version 3.6.0 the column name is just &quot;a&quot;.</source>
          <target state="translated">В версии 3.5.9 вышеприведенный запрос возвращал бы один столбец под названием &quot;t1.a&quot;.В версии 3.6.0 название столбца просто &quot;a&quot;.</target>
        </trans-unit>
        <trans-unit id="b38dc06ca0b3ec94d37d385f6a25506410f69b7f" translate="yes" xml:space="preserve">
          <source>In very old versions of SQLite (before version 3.7.11 - 2012-03-20) the ROLLBACK will fail with an error code &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; if there are any pending queries. In more recent versions of SQLite, the ROLLBACK will proceed and pending statements will often be aborted, causing them to return an &lt;a href=&quot;rescode#abort&quot;&gt;SQLITE_ABORT&lt;/a&gt; or &lt;a href=&quot;rescode#abort_rollback&quot;&gt;SQLITE_ABORT_ROLLBACK&lt;/a&gt; error. In SQLite version 3.8.8 (2015-01-16) and later, a pending read will continue functioning after the ROLLBACK as long as the ROLLBACK does not modify the database schema.</source>
          <target state="translated">В очень старых версиях SQLite (до версии 3.7.11 - 2012-03-20) ROLLBACK завершится ошибкой с кодом &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY,&lt;/a&gt; если есть какие-либо ожидающие запросы. В более поздних версиях SQLite ROLLBACK будет продолжаться, и отложенные операторы часто прерываются, в результате чего они возвращают &lt;a href=&quot;rescode#abort&quot;&gt;ошибку SQLITE_ABORT&lt;/a&gt; или &lt;a href=&quot;rescode#abort_rollback&quot;&gt;SQLITE_ABORT_ROLLBACK&lt;/a&gt; . В SQLite версии 3.8.8 (2015-01-16) и более поздних версий ожидающее чтение будет продолжать функционировать после ROLLBACK, пока ROLLBACK не изменяет схему базы данных.</target>
        </trans-unit>
        <trans-unit id="b499aec31026161ef5b7e71ea3cf99793674a2a9" translate="yes" xml:space="preserve">
          <source>In words, we have a database table named &quot;examp&quot; that has two columns of data named &quot;one&quot; and &quot;two&quot;. Now suppose we want to insert a single record into this table. Like this:</source>
          <target state="translated">Иными словами,у нас есть таблица базы данных под названием &quot;экзамен&quot;,которая имеет две колонки данных под названием &quot;один&quot; и &quot;два&quot;.Теперь предположим,что мы хотим вставить в эту таблицу одну запись.Вот так:</target>
        </trans-unit>
        <trans-unit id="538f80f611dd84d930a92b9f7317e8773bd20fa3" translate="yes" xml:space="preserve">
          <source>In-Memory Databases</source>
          <target state="translated">Базы данных In-Memory</target>
        </trans-unit>
        <trans-unit id="d29dcc989f8aeac43865c646816b27c0bf5d86c1" translate="yes" xml:space="preserve">
          <source>In-memory Databases And Shared Cache</source>
          <target state="translated">Базы данных In-memory и общий кэш.</target>
        </trans-unit>
        <trans-unit id="f87e1ebcfb907fda4b66420b21bcba1a298d5d80" translate="yes" xml:space="preserve">
          <source>In-memory databases are allowed to use &lt;a href=&quot;sharedcache&quot;&gt;shared cache&lt;/a&gt; if they are opened using a &lt;a href=&quot;uri&quot;&gt;URI filename&lt;/a&gt;. If the unadorned &quot;:memory:&quot; name is used to specify the in-memory database, then that database always has a private cache and is this only visible to the database connection that originally opened it. However, the same in-memory database can be opened by two or more database connections as follows:</source>
          <target state="translated">Базы данных в памяти могут использовать &lt;a href=&quot;sharedcache&quot;&gt;общий кеш,&lt;/a&gt; если они открываются с использованием &lt;a href=&quot;uri&quot;&gt;имени файла URI&lt;/a&gt; . Если для указания базы данных в памяти используется неукрашенное имя &amp;laquo;: memory:&amp;raquo;, то эта база данных всегда имеет частный кеш, и он виден только тому соединению с базой данных, которое первоначально открыло ее. Однако одна и та же база данных в памяти может быть открыта двумя или более подключениями к базе данных следующим образом:</target>
        </trans-unit>
        <trans-unit id="4e5ba204b0641a7420c326e6c9ccf4a171f01a91" translate="yes" xml:space="preserve">
          <source>Include a digit somewhere in every identifier name.</source>
          <target state="translated">Включите цифру где-нибудь в имя каждого идентификатора.</target>
        </trans-unit>
        <trans-unit id="609cf98670fbb073608f2b25b70dd7c1c13a30bc" translate="yes" xml:space="preserve">
          <source>Include a static string in the library that responds to the RCS &quot;ident&quot; command and which contains the library version number.</source>
          <target state="translated">Включить в библиотеку статическую строку,которая отвечает на команду RCS &quot;ident&quot; и содержит номер версии библиотеки.</target>
        </trans-unit>
        <trans-unit id="c0417d1d2b8071cc5718dd6c321dee3ddd0e2b30" translate="yes" xml:space="preserve">
          <source>Incompatible changes are covered first since they are the most important to maintainers and programmers.</source>
          <target state="translated">Несовместимые изменения освещаются в первую очередь,так как они наиболее важны для сопровождающих и программистов.</target>
        </trans-unit>
        <trans-unit id="bc118ee16ef865aed415e5f3a8d6022aa76b72dd" translate="yes" xml:space="preserve">
          <source>Inconsistent result set column names between CREATE TABLE AS and a simple SELECT. Ticket &lt;a href=&quot;https://sqlite.org/src/info/3b4450072511e621&quot;&gt;3b4450072511e621&lt;/a&gt;</source>
          <target state="translated">Несогласованные имена столбцов набора результатов между CREATE TABLE AS и простым SELECT. Билет &lt;a href=&quot;https://sqlite.org/src/info/3b4450072511e621&quot;&gt;3b4450072511e621&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b7579773ac4d764f11e434b97ff14dade4554c12" translate="yes" xml:space="preserve">
          <source>Incorporate makefile patches form A. Rottmann to use LIBTOOL</source>
          <target state="translated">Включить makefile патчи от A.Rottmann для использования LIBTOOL</target>
        </trans-unit>
        <trans-unit id="78318ed3e6ca4f2006eecd671fb4e1b78bbf85cb" translate="yes" xml:space="preserve">
          <source>Incorrect</source>
          <target state="translated">Incorrect</target>
        </trans-unit>
        <trans-unit id="f074a009d21038c67513df8d49c6353ecce4802a" translate="yes" xml:space="preserve">
          <source>Incorrect assert() statement removed. Check-in &lt;a href=&quot;https://www.sqlite.org/src/info/823779d31eb09cda&quot;&gt;823779d31eb09cda&lt;/a&gt;.</source>
          <target state="translated">Удален неверный оператор assert (). Заезд &lt;a href=&quot;https://www.sqlite.org/src/info/823779d31eb09cda&quot;&gt;823779d31eb09cda&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="86f64d7d599af33f2e2d357b68bfbc2590e32e39" translate="yes" xml:space="preserve">
          <source>Incorrect column datatype reported. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/a8a0d2996a&quot;&gt;a8a0d2996a&lt;/a&gt;</source>
          <target state="translated">Сообщается о неверном типе данных столбца. Билет &lt;a href=&quot;http://www.sqlite.org/src/info/a8a0d2996a&quot;&gt;a8a0d2996a&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="87e0a937278327bb727372d43f146a781488670b" translate="yes" xml:space="preserve">
          <source>Incorrect column datatype reported. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/a8a0d2996a&quot;&gt;a8a0d2996a&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5010ff6ebfa98793b55410eccec7fb293111ca61" translate="yes" xml:space="preserve">
          <source>Incorrect query results on a join with a ORDER BY DESC. Ticket &lt;a href=&quot;https://sqlite.org/src/info/123c9ba32130a6c9&quot;&gt;123c9ba32130a6c9&lt;/a&gt;.</source>
          <target state="translated">Неверные результаты запроса при объединении с ORDER BY DESC. Билет &lt;a href=&quot;https://sqlite.org/src/info/123c9ba32130a6c9&quot;&gt;123c9ba32130a6c9&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d72bf52d94d169fcce6582014fa4914c962c4cbe" translate="yes" xml:space="preserve">
          <source>Incorrect query results when the skip-ahead-distinct optimization is used. Ticket &lt;a href=&quot;https://sqlite.org/src/info/ef9318757b152e3a&quot;&gt;ef9318757b152e3a&lt;/a&gt;.</source>
          <target state="translated">Неправильные результаты запроса при использовании оптимизации с пропуском вперед. Билет &lt;a href=&quot;https://sqlite.org/src/info/ef9318757b152e3a&quot;&gt;ef9318757b152e3a&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3b88b306633c693ef74330d871a60d1a4c0698aa" translate="yes" xml:space="preserve">
          <source>Incorrect result on the less-than operator in &lt;a href=&quot;rowvalue&quot;&gt;row values&lt;/a&gt;. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/f484b65f3d62305&quot;&gt;f484b65f3d62305&lt;/a&gt;</source>
          <target state="translated">Неправильный результат для оператора &amp;laquo;меньше&amp;raquo; в &lt;a href=&quot;rowvalue&quot;&gt;значениях строк&lt;/a&gt; . Билет &lt;a href=&quot;https://www.sqlite.org/src/info/f484b65f3d62305&quot;&gt;f484b65f3d62305&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="353e2ea7a72adf3f039c8f1d29d7d6a2765ce415" translate="yes" xml:space="preserve">
          <source>IncrVacuum</source>
          <target state="translated">IncrVacuum</target>
        </trans-unit>
        <trans-unit id="b26b9e9148cbb52c34e5ac01e22c1673ec213167" translate="yes" xml:space="preserve">
          <source>Increase or decrease the seekHit value for cursor P1, if necessary, so that it is no less than P2 and no greater than P3.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfb28e75251bc4d83a52b5697560b9c1115b80bf" translate="yes" xml:space="preserve">
          <source>Increase the &lt;a href=&quot;limits#max_variable_number&quot;&gt;default upper bound&lt;/a&gt; on the number of &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameters&lt;/a&gt; from 999 to 32766.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21ef0be270a54a1cdd6fa173d6d67cc79394e640" translate="yes" xml:space="preserve">
          <source>Increase the default &lt;a href=&quot;malloc#lookaside&quot;&gt;lookaside memory allocator&lt;/a&gt; allocation size from 100 to 128 bytes.</source>
          <target state="translated">Увеличьте размер выделения &lt;a href=&quot;malloc#lookaside&quot;&gt;резервной памяти&lt;/a&gt; по умолчанию со 100 до 128 байт.</target>
        </trans-unit>
        <trans-unit id="40e4fa7cf5d195215158819dc861b48ed9ae1b97" translate="yes" xml:space="preserve">
          <source>Increase the default &lt;a href=&quot;malloc#lookaside&quot;&gt;lookaside&lt;/a&gt; size from 512,125 to 1200,100 as this provides better performance while only adding 56KB of extra memory per connection. Memory-sensitive applications can restore the old default at compile-time, start-time, or run-time.</source>
          <target state="translated">Увеличьте &lt;a href=&quot;malloc#lookaside&quot;&gt;внешний&lt;/a&gt; размер по умолчанию с 512,125 до 1200,100, поскольку это обеспечивает лучшую производительность при добавлении только 56 КБ дополнительной памяти на каждое соединение. Приложения, чувствительные к памяти, могут восстанавливать старые значения по умолчанию во время компиляции, запуска или выполнения.</target>
        </trans-unit>
        <trans-unit id="0e1c35718b4f025f2f5dcc35d709e6b06c180f12" translate="yes" xml:space="preserve">
          <source>Increase the default size of a lookahead cache line from 100 to 128 bytes.</source>
          <target state="translated">Увеличить размер кэш-строки lookahead по умолчанию со 100 до 128 байт.</target>
        </trans-unit>
        <trans-unit id="7da2a83b3ac0a9788385c812ce2d8ccd3f55fd86" translate="yes" xml:space="preserve">
          <source>Increase the default value of &lt;a href=&quot;compile#max_schema_retry&quot;&gt;SQLITE_MAX_SCHEMA_RETRY&lt;/a&gt; to 50 and make sure that it is honored in every place that a schema change might force a statement retry.</source>
          <target state="translated">Увеличьте значение &lt;a href=&quot;compile#max_schema_retry&quot;&gt;SQLITE_MAX_SCHEMA_RETRY&lt;/a&gt; по умолчанию до 50 и убедитесь, что оно соблюдается в каждом месте, где изменение схемы может вызвать повторную попытку оператора.</target>
        </trans-unit>
        <trans-unit id="8609e4a99103452adeaaadda83f7438f10dd550a" translate="yes" xml:space="preserve">
          <source>Increase the maximum &quot;scope&quot; value for the &lt;a href=&quot;spellfix1&quot;&gt;spellfix1&lt;/a&gt; extension from 6 to 30.</source>
          <target state="translated">Увеличьте максимальное значение &quot;scope&quot; для расширения &lt;a href=&quot;spellfix1&quot;&gt;spellfix1&lt;/a&gt; с 6 до 30.</target>
        </trans-unit>
        <trans-unit id="c2f2fd643cba996348fe945409caf6a8045d3c9f" translate="yes" xml:space="preserve">
          <source>Increase the maximum size of a database pages from 32KiB to 64KiB.</source>
          <target state="translated">Увеличить максимальный размер страниц базы данных с 32КиБ до 64КиБ.</target>
        </trans-unit>
        <trans-unit id="c023946d393ce520944a7e8848356e945bf33b16" translate="yes" xml:space="preserve">
          <source>Increase the maximum size of database files to 281 TB.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45c470cb2d5edd4a76a24043774f958df34166de" translate="yes" xml:space="preserve">
          <source>Increase the maximum value of &lt;a href=&quot;limits#max_attached&quot;&gt;SQLITE_MAX_ATTACHED&lt;/a&gt; from 30 to 62 (though the default value remains at 10).</source>
          <target state="translated">Увеличьте максимальное значение &lt;a href=&quot;limits#max_attached&quot;&gt;SQLITE_MAX_ATTACHED&lt;/a&gt; с 30 до 62 (хотя значение по умолчанию остается равным 10).</target>
        </trans-unit>
        <trans-unit id="bb8cf068d7b2280526a2d202959cea91dd49770d" translate="yes" xml:space="preserve">
          <source>Increase the maximum value of &lt;a href=&quot;limits#max_attached&quot;&gt;SQLITE_MAX_ATTACHED&lt;/a&gt; from 62 to 125.</source>
          <target state="translated">Увеличьте максимальное значение &lt;a href=&quot;limits#max_attached&quot;&gt;SQLITE_MAX_ATTACHED&lt;/a&gt; с 62 до 125.</target>
        </trans-unit>
        <trans-unit id="69df92b5969bbc35734aa6107d3290339d53b888" translate="yes" xml:space="preserve">
          <source>Increase the timeout in &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt; before issuing an &lt;a href=&quot;rescode#protocol&quot;&gt;SQLITE_PROTOCOL&lt;/a&gt; error from 1 second to 10 seconds.</source>
          <target state="translated">Увеличьте время ожидания в &lt;a href=&quot;wal&quot;&gt;режиме WAL&lt;/a&gt; перед выдачей ошибки &lt;a href=&quot;rescode#protocol&quot;&gt;SQLITE_PROTOCOL&lt;/a&gt; с 1 до 10 секунд.</target>
        </trans-unit>
        <trans-unit id="9f009e1e744f83083af0b2cc7e6b2078c78f112f" translate="yes" xml:space="preserve">
          <source>Increased robustness against malicious SQL that is run against a maliciously corrupted database.</source>
          <target state="translated">Повышенная устойчивость к вредоносному SQL,который запускается против вредоносной базы данных.</target>
        </trans-unit>
        <trans-unit id="6b178246a9f68a2d5235ede0c3d198671a18c66b" translate="yes" xml:space="preserve">
          <source>Increased the version number on the &lt;a href=&quot;c3ref/vfs&quot;&gt;VFS object&lt;/a&gt; to 3 and added new methods xSetSysCall, xGetSysCall, and xNextSysCall used for doing full-coverage testing.</source>
          <target state="translated">Увеличен номер версии &lt;a href=&quot;c3ref/vfs&quot;&gt;объекта VFS&lt;/a&gt; до 3 и добавлены новые методы xSetSysCall, xGetSysCall и xNextSysCall, используемые для выполнения тестирования с полным покрытием.</target>
        </trans-unit>
        <trans-unit id="5b01748d80c9a44e0b5e68cd44f76d6fdcd5fbdb" translate="yes" xml:space="preserve">
          <source>Increment a &quot;constraint counter&quot; by P2 (P2 may be negative or positive). If P1 is non-zero, the database constraint counter is incremented (deferred foreign key constraints). Otherwise, if P1 is zero, the statement counter is incremented (immediate foreign key constraints).</source>
          <target state="translated">Увеличьте &quot;счетчик ограничений&quot; на P2 (P2 может быть отрицательным или положительным).Если P1 ненулевой,то увеличивается счетчик ограничений по базе данных (отложенные ограничения по внешнему ключу).В противном случае,если P1 равен нулю,счетчик операций инкрементируется (отложенные ограничения по внешнему ключу).</target>
        </trans-unit>
        <trans-unit id="9728ef186d1aa3193e57c71ddbd9cc22dfa95396" translate="yes" xml:space="preserve">
          <source>Increment the schema version number using &lt;a href=&quot;pragma#pragma_schema_version&quot;&gt;PRAGMA schema_version=X&lt;/a&gt; where X is one more than the old schema version number found in step 2 above.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_schema_version&quot;&gt;Увеличьте&lt;/a&gt; номер версии схемы, используя PRAGMA schema_version = X, где X на единицу больше, чем номер версии старой схемы, найденный на шаге 2 выше.</target>
        </trans-unit>
        <trans-unit id="8144fd658d7904e59a32604de5f5f1ca74f2f2ee" translate="yes" xml:space="preserve">
          <source>Increment the value of P1 so that &lt;a href=&quot;opcode#Once&quot;&gt;Once&lt;/a&gt; opcodes will jump the first time they are evaluated for this run.</source>
          <target state="translated">Увеличьте значение P1, чтобы коды операций &lt;a href=&quot;opcode#Once&quot;&gt;Once&lt;/a&gt; перескакивали в первый раз, когда они оцениваются для этого прогона.</target>
        </trans-unit>
        <trans-unit id="99958674e5ab051f627364f0e7aec7700da2c443" translate="yes" xml:space="preserve">
          <source>Incremental And Continuous Updates</source>
          <target state="translated">Инкрементальное и непрерывное обновление</target>
        </trans-unit>
        <trans-unit id="c978bfe7fe02498da062fb7e2f5271fe832940ed" translate="yes" xml:space="preserve">
          <source>Index B-Tree Interior Cell (header 0x02):</source>
          <target state="translated">Внутренняя ячейка Индекс B-Дерево (заголовок 0x02):</target>
        </trans-unit>
        <trans-unit id="4e71969581a513a52c19a67df3b923e84e3cb4d7" translate="yes" xml:space="preserve">
          <source>Index B-Tree Leaf Cell (header 0x0a):</source>
          <target state="translated">Клетка листьев дерева Индекс Б (заголовок 0x0a):</target>
        </trans-unit>
        <trans-unit id="6834f50285e5eaa6aab20cfc4003ad141369bccf" translate="yes" xml:space="preserve">
          <source>Index B-Tree Leaf Or Interior Cell:</source>
          <target state="translated">Индекс Б-Древесный лист или внутренняя клетка:</target>
        </trans-unit>
        <trans-unit id="d05474cb52cfb6c27f6a9c375d177e07d462e5e6" translate="yes" xml:space="preserve">
          <source>Index Interior (0x02)</source>
          <target state="translated">Индекс интерьера (0x02)</target>
        </trans-unit>
        <trans-unit id="f35ac0d24fd01ec25554f05ecc89c727c71a1e04" translate="yes" xml:space="preserve">
          <source>Index Leaf (0x0a)</source>
          <target state="translated">Индексный лист (0x0a)</target>
        </trans-unit>
        <trans-unit id="96c319248a56deb59ef179cae4ae3f7a3c92eca2" translate="yes" xml:space="preserve">
          <source>Index Of A Parameter With A Given Name</source>
          <target state="translated">Индекс параметра с заданным именем</target>
        </trans-unit>
        <trans-unit id="239b13bdf631a9f83fa9a8a3d5c3895198fcc15a" translate="yes" xml:space="preserve">
          <source>Indexes On Expressions</source>
          <target state="translated">Индексы на выражениях</target>
        </trans-unit>
        <trans-unit id="f48dd71980245b4a0803daa066444bcb1b77f26c" translate="yes" xml:space="preserve">
          <source>Indexes are removed with the &lt;a href=&quot;lang_dropindex&quot;&gt;DROP INDEX&lt;/a&gt; command.</source>
          <target state="translated">Индексы удаляются командой &lt;a href=&quot;lang_dropindex&quot;&gt;DROP INDEX&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="535c9c6ad77a4b24ea3df3e8a1b9f2c196027e6c" translate="yes" xml:space="preserve">
          <source>Indexes can use &lt;a href=&quot;lang_createindex#descidx&quot;&gt;DESC&lt;/a&gt; and &lt;a href=&quot;lang_createindex#collidx&quot;&gt;COLLATE&lt;/a&gt;</source>
          <target state="translated">Индексы могут использовать &lt;a href=&quot;lang_createindex#descidx&quot;&gt;DESC&lt;/a&gt; и &lt;a href=&quot;lang_createindex#collidx&quot;&gt;COLLATE&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5826c397297007e146b25d7bb80a3a9d200a4f00" translate="yes" xml:space="preserve">
          <source>Indices are not required for child key columns but they are almost always beneficial. Returning to the example in &lt;a href=&quot;#fk_basics&quot;&gt;section 1&lt;/a&gt;, each time an application deletes a row from the</source>
          <target state="translated">Для столбцов дочерних ключей индексы не требуются, но они почти всегда полезны. Возвращаясь к примеру в &lt;a href=&quot;#fk_basics&quot;&gt;разделе 1&lt;/a&gt; , каждый раз, когда приложение удаляет строку из</target>
        </trans-unit>
        <trans-unit id="952faf72c9a83e116cef336ce73f046eb32c95b9" translate="yes" xml:space="preserve">
          <source>Indices with names of the form &quot;sqlite_autoindex_TABLE_N&quot; that are used to implement &lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE&lt;/a&gt; and &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt; constraints on ordinary tables.</source>
          <target state="translated">Индексы с именами вида &quot;sqlite_autoindex_TABLE_N&quot;, которые используются для реализации ограничений &lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE&lt;/a&gt; и &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt; для обычных таблиц.</target>
        </trans-unit>
        <trans-unit id="853f712d884520adb0232cc6445c159a48a0d960" translate="yes" xml:space="preserve">
          <source>Individual database connections created using &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; can choose to participate or not participate in shared cache mode by using the &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_SHAREDCACHE&lt;/a&gt; or &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_PRIVATECACHE&lt;/a&gt; flags the third parameter. The use of either of these flags overrides the global shared cache mode setting established by &lt;a href=&quot;c3ref/enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache()&lt;/a&gt;. No more than one of the flags should be used; if both SQLITE_OPEN_SHAREDCACHE and SQLITE_OPEN_PRIVATECACHE flags are used in the third argument to &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; then the behavior is undefined.</source>
          <target state="translated">Отдельные соединения с базой данных, созданные с помощью &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2 (),&lt;/a&gt; могут выбрать, участвовать или не участвовать в режиме общего кэша, используя флаги &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_SHAREDCACHE&lt;/a&gt; или &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_PRIVATECACHE&lt;/a&gt; в третьем параметре. Использование любого из этих флагов отменяет настройку режима глобального общего кэша, установленную &lt;a href=&quot;c3ref/enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache ()&lt;/a&gt; . Следует использовать не более одного из флагов; если оба флага SQLITE_OPEN_SHAREDCACHE и SQLITE_OPEN_PRIVATECACHE используются в третьем аргументе &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2 (),&lt;/a&gt; то поведение не определено.</target>
        </trans-unit>
        <trans-unit id="e34e9639a7829e3d1eeead355b99441da28ac59a" translate="yes" xml:space="preserve">
          <source>Individual fields of the shm header, except for the salt values copied from the WAL header, are unsigned integers in the native byte-order of the host machine. The salt values are exact copies from the WAL header and are in whatever byte order is used by the WAL file. The size of integers may be 8, 16, 32, or 64 bits. A detailed breakout of the individual fields of the shm header follows:</source>
          <target state="translated">Отдельные поля заголовка shm,за исключением значений соли,скопированных из заголовка WAL,являются беззнаковыми целыми числами в родном порядке байт хост-машины.Значения соли являются точными копиями из заголовка WAL и находятся в любом порядке байт,используемом файлом WAL.Размер целых чисел может быть 8,16,32 или 64 бита.Далее следует подробная разбивка отдельных полей заголовка shm:</target>
        </trans-unit>
        <trans-unit id="afaa9b90ffb384cf537b3db99f57a1ca2ab340a0" translate="yes" xml:space="preserve">
          <source>Individual subterms might be a single comparison expression like *a=5* or *x&amp;gt;y* or they can be LIKE or BETWEEN expressions, or a subterm can be a parenthesized list of AND-connected sub-subterms. Each subterm is analyzed as if it were itself the entire WHERE clause in order to see if the subterm is indexable by itself. If &lt;u&gt;every&lt;/u&gt; subterm of an OR clause is separately indexable then the OR clause might be coded such that a separate index is used to evaluate each term of the OR clause. One way to think about how SQLite uses separate indices for each OR clause term is to imagine that the WHERE clause where rewritten as follows:</source>
          <target state="translated">Отдельные подтермы могут быть одним выражением сравнения, например * a = 5 * или * x&amp;gt; y *, или они могут быть выражениями LIKE или BETWEEN, или подтерм может быть заключенным в скобки списком подтермов, связанных AND. Каждый подтерм анализируется, как если бы он сам был целым предложением WHERE, чтобы увидеть, индексируется ли сам подтерм. Если &lt;u&gt;каждый&lt;/u&gt; подтерм предложения OR индексируется отдельно, то предложение OR может быть закодировано таким образом, чтобы для оценки каждого члена предложения OR использовался отдельный индекс. Один из способов подумать о том, как SQLite использует отдельные индексы для каждого термина предложения OR, - это представить, что предложение WHERE переписано следующим образом:</target>
        </trans-unit>
        <trans-unit id="b50964dcca8f7e2d2ab55601a57f00ff964447be" translate="yes" xml:space="preserve">
          <source>Individual subterms might be a single comparison expression like &lt;b&gt;a=5&lt;/b&gt; or &lt;b&gt;x&amp;gt;y&lt;/b&gt; or they can be LIKE or BETWEEN expressions, or a subterm can be a parenthesized list of AND-connected sub-subterms. Each subterm is analyzed as if it were itself the entire WHERE clause in order to see if the subterm is indexable by itself. If &lt;u&gt;every&lt;/u&gt; subterm of an OR clause is separately indexable then the OR clause might be coded such that a separate index is used to evaluate each term of the OR clause. One way to think about how SQLite uses separate indexes for each OR clause term is to imagine that the WHERE clause where rewritten as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a9fd17dd36196733342a48e4a93f680869a4f7c" translate="yes" xml:space="preserve">
          <source>Individual virtual table implementations might impose additional constraints. For example, some virtual implementations might provide read-only tables. Or some virtual table implementations might allow &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; or &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; but not &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;. Or some virtual table implementations might limit the kinds of UPDATEs that can be made.</source>
          <target state="translated">Реализации отдельных виртуальных таблиц могут налагать дополнительные ограничения. Например, некоторые виртуальные реализации могут предоставлять таблицы только для чтения. Или некоторые реализации виртуальных таблиц могут разрешать &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; или &lt;a href=&quot;lang_delete&quot;&gt;DELETE,&lt;/a&gt; но не &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; . Или некоторые реализации виртуальных таблиц могут ограничивать виды ОБНОВЛЕНИЙ, которые могут быть сделаны.</target>
        </trans-unit>
        <trans-unit id="b7ab8cb519f7ae8e1280427c18f93285db556ab6" translate="yes" xml:space="preserve">
          <source>Infinite loop on an UPDATE that uses an OR operator in the WHERE clause. Problem introduced with 3.17.0 and reported on the mailing list about one year later. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/47b2581aa9bfecec&quot;&gt;47b2581aa9bfecec&lt;/a&gt;.</source>
          <target state="translated">Бесконечный цикл для UPDATE, использующего оператор OR в предложении WHERE. Проблема появилась в версии 3.17.0 и появилась в списке рассылки примерно через год. Билет &lt;a href=&quot;https://www.sqlite.org/src/info/47b2581aa9bfecec&quot;&gt;47b2581aa9bfecec&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9779307227ff608723d6f1acc622b0fbd0d99060" translate="yes" xml:space="preserve">
          <source>Information about the ORDER BY clause is stored in aOrderBy[]. Each term of aOrderBy records a column of the ORDER BY clause.</source>
          <target state="translated">Информация о пункте ORDER BY хранится в aOrderBy[].Каждый термин aOrderBy записывает столбец пункта ORDER BY.</target>
        </trans-unit>
        <trans-unit id="8900519c8c00e46885e8acc9f5e07ba3fa96d336" translate="yes" xml:space="preserve">
          <source>Informix</source>
          <target state="translated">Informix</target>
        </trans-unit>
        <trans-unit id="19682bdb9185a5fa9d763d414d0443d3a0bc2456" translate="yes" xml:space="preserve">
          <source>Init</source>
          <target state="translated">Init</target>
        </trans-unit>
        <trans-unit id="c807a586d6078a7e14adef4ebb7912d0c6f4aa53" translate="yes" xml:space="preserve">
          <source>InitCoroutine</source>
          <target state="translated">InitCoroutine</target>
        </trans-unit>
        <trans-unit id="9ceecfe65e61c428178f61207aad8930969e6176" translate="yes" xml:space="preserve">
          <source>Initial Public Release of Alpha code</source>
          <target state="translated">Начальный публичный релиз Альфа-кода</target>
        </trans-unit>
        <trans-unit id="22e34d8b442d40192baed65a8aa102e6e94f33a1" translate="yes" xml:space="preserve">
          <source>Initial release of version 2.0. The idea of renaming the library to &quot;SQLus&quot; was abandoned in favor of keeping the &quot;SQLite&quot; name and bumping the major version number.</source>
          <target state="translated">Первоначальный релиз версии 2.0.Идея переименования библиотеки на &quot;SQLus&quot; была оставлена в пользу сохранения имени &quot;SQLite&quot; и обхода основного номера версии.</target>
        </trans-unit>
        <trans-unit id="8f5bfa371a731c186afb7ca1237eb5d4d7f1e077" translate="yes" xml:space="preserve">
          <source>Initial size of the database in pages</source>
          <target state="translated">Начальный размер базы данных в страницах</target>
        </trans-unit>
        <trans-unit id="7bf3e06594405eb1afbafdd083622d687011597a" translate="yes" xml:space="preserve">
          <source>Initialize The SQLite Library</source>
          <target state="translated">Инициализировать библиотеку SQLite</target>
        </trans-unit>
        <trans-unit id="d191407d44cf9ade286348bd4b44b9f7f3e25feb" translate="yes" xml:space="preserve">
          <source>Initialize index X to be N-200 (where N is the size of a database page in bytes.</source>
          <target state="translated">Инициализируйте индекс X как N-200 (где N-размер страницы базы данных в байтах).</target>
        </trans-unit>
        <trans-unit id="8e6cd4e5b42b5a543357e6d81e6f378b25c829f6" translate="yes" xml:space="preserve">
          <source>Initialize the &lt;b&gt;azColumnName[]&lt;/b&gt; array for the callback.</source>
          <target state="translated">Инициализируйте массив &lt;b&gt;azColumnName []&lt;/b&gt; для обратного вызова.</target>
        </trans-unit>
        <trans-unit id="5f7aab6a3275a65fb3b4985527f188c8b61dc3b5" translate="yes" xml:space="preserve">
          <source>Initialize the checksum to the checksum nonce value found in the journal header at offset 12.</source>
          <target state="translated">Инициализируйте контрольную сумму до контрольной нецелой величины,найденной в заголовке журнала со смещением 12.</target>
        </trans-unit>
        <trans-unit id="404f059fc8a52705cd25b69b3e9ff09c1be18ec9" translate="yes" xml:space="preserve">
          <source>Inner joins can be freely reordered. However a left outer join is neither commutative nor associative and hence will not be reordered. Inner joins to the left and right of the outer join might be reordered if the optimizer thinks that is advantageous but the outer joins are always evaluated in the order in which they occur.</source>
          <target state="translated">Внутренние соединения могут быть свободно переупорядочены.Однако левое внешнее соединение не является ни коммутационным,ни ассоциативным и,следовательно,не будет переупорядочиваться.Внутренние соединения слева и справа от внешнего соединения могут быть упорядочены по-другому,если оптимизатор считает это выгодным,но внешние соединения всегда оцениваются в том порядке,в котором они возникают.</target>
        </trans-unit>
        <trans-unit id="95802daab3a23990338179f72248350c1434cf39" translate="yes" xml:space="preserve">
          <source>Insert</source>
          <target state="translated">Insert</target>
        </trans-unit>
        <trans-unit id="6173fc45fc7b2219f9b313a58dd34b30a31fc6dc" translate="yes" xml:space="preserve">
          <source>Insert that single row into the recursive table</source>
          <target state="translated">Вставьте эту единственную строку в рекурсивную таблицу.</target>
        </trans-unit>
        <trans-unit id="e9c69a8b8aca121e6ec4067a03fd7e5c40db2b72" translate="yes" xml:space="preserve">
          <source>Insert the integer value held by register P2 into a RowSet object held in register P1.</source>
          <target state="translated">Вставить целое значение,удерживаемое регистром P2,в объект RowSet,удерживаемый регистром P1.</target>
        </trans-unit>
        <trans-unit id="85a8fe292b0b6ab92cb375e9d651b4f869ca615a" translate="yes" xml:space="preserve">
          <source>Inserting Records Into The Database</source>
          <target state="translated">Вставка записей в базу данных</target>
        </trans-unit>
        <trans-unit id="d9102185aa139480514433588d7c7980df39e939" translate="yes" xml:space="preserve">
          <source>Instead of a separate OFFSET clause, the LIMIT clause may specify two scalar expressions separated by a comma. In this case, the first expression is used as the OFFSET expression and the second as the LIMIT expression. This is counter-intuitive, as when using the OFFSET clause the second of the two expressions is the OFFSET and the first the LIMIT. This reversal of the offset and limit is intentional - it maximizes compatibility with other SQL database systems. However, to avoid confusion, programmers are strongly encouraged to use the form of the LIMIT clause that uses the &quot;OFFSET&quot; keyword and avoid using a LIMIT clause with a comma-separated offset.</source>
          <target state="translated">Вместо отдельного пункта OFFSET,пункт LIMIT может задавать два скалярных выражения,разделенных запятой.В этом случае первое выражение используется как выражение OFFSET,а второе-как выражение LIMIT.Это интуитивно понятно,так как при использовании пункта OFFSET вторым из двух выражений является OFFSET,а первым-LIMIT.Такое изменение смещения и предела является преднамеренным-оно максимизирует совместимость с другими системами СУБД SQL.Однако,чтобы избежать путаницы,программистам настоятельно рекомендуется использовать форму пункта LIMIT,в котором используется ключевое слово &quot;OFFSET&quot;,и избегать использования пункта LIMIT со смещением,разделенным запятыми.</target>
        </trans-unit>
        <trans-unit id="d84a58129471e483da1b069622f8ee436752fbf7" translate="yes" xml:space="preserve">
          <source>Instead of deleting records where the &quot;two&quot; column is less than 50, this statement just puts the &quot;one&quot; column in parentheses The VDBE program to implement this statement follows:</source>
          <target state="translated">Вместо того,чтобы удалять записи,где столбец &quot;два&quot; меньше 50,этот оператор просто заключает столбец &quot;один&quot; в круглые скобки Программа VDBE,реализующая этот оператор,следует далее:</target>
        </trans-unit>
        <trans-unit id="123ee948ecafb3b169cf486ec20a13fbb0b9103f" translate="yes" xml:space="preserve">
          <source>Instead of providing full Unicode case support by default, SQLite provides the ability to link against external Unicode comparison and conversion routines. The application can overload the built-in &lt;a href=&quot;datatype3#collation&quot;&gt;NOCASE&lt;/a&gt; collating sequence (using &lt;a href=&quot;c3ref/create_collation&quot;&gt;sqlite3_create_collation()&lt;/a&gt;) and the built-in &lt;a href=&quot;lang_corefunc#like&quot;&gt;like()&lt;/a&gt;, &lt;a href=&quot;lang_corefunc#upper&quot;&gt;upper()&lt;/a&gt;, and &lt;a href=&quot;lang_corefunc#lower&quot;&gt;lower()&lt;/a&gt; functions (using &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt;). The SQLite source code includes an &quot;ICU&quot; extension that does these overloads. Or, developers can write their own overloads based on their own Unicode-aware comparison routines already contained within their project.</source>
          <target state="translated">Вместо полной поддержки регистра Unicode по умолчанию, SQLite предоставляет возможность связываться с внешними процедурами сравнения и преобразования Unicode. Приложение может перегружать встроенную последовательность сортировки &lt;a href=&quot;datatype3#collation&quot;&gt;NOCASE&lt;/a&gt; (с использованием &lt;a href=&quot;c3ref/create_collation&quot;&gt;sqlite3_create_collation ()&lt;/a&gt; ) и встроенные функции &lt;a href=&quot;lang_corefunc#like&quot;&gt;like ()&lt;/a&gt; , &lt;a href=&quot;lang_corefunc#upper&quot;&gt;upper ()&lt;/a&gt; и &lt;a href=&quot;lang_corefunc#lower&quot;&gt;lower ()&lt;/a&gt; (с помощью &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function ()&lt;/a&gt; ). Исходный код SQLite включает расширение &amp;laquo;ICU&amp;raquo;, которое выполняет эти перегрузки. Или разработчики могут написать свои собственные перегрузки на основе собственных процедур сравнения с поддержкой Unicode, уже содержащихся в их проекте.</target>
        </trans-unit>
        <trans-unit id="e02d371a11cece5f4e01254e6fedf80303033a58" translate="yes" xml:space="preserve">
          <source>Instead of using a single data structure on disk to store the full-text index, FTS5 uses a series of b-trees. Each time a new transaction is committed, a new b-tree containing the contents of the committed transaction is written into the database file. When the full-text index is queried, each b-tree must be queried individually and the results merged before being returned to the user.</source>
          <target state="translated">Вместо использования единой структуры данных на диске для хранения полнотекстового индекса,FTS5 использует ряд b-деревьев.При каждой фиксации новой транзакции в файл базы данных записывается новое b-дерево,содержащее содержимое фиксации.При запросе полнотекстового индекса необходимо опрашивать каждое b-дерево по отдельности и объединять результаты,прежде чем возвращать их пользователю.</target>
        </trans-unit>
        <trans-unit id="17249ad26f29e1aabdd8d073e961780b07d76064" translate="yes" xml:space="preserve">
          <source>Instead of using bm25() with no trailing arguments, the specific auxiliary function mapped to the rank column may be configured either on a per-query basis, or by setting a different persistent default for the FTS table.</source>
          <target state="translated">Вместо того,чтобы использовать bm25()без трейлинговых аргументов,специальная вспомогательная функция,отображенная в столбце ранга,может быть сконфигурирована либо по запросу,либо путем установки другого постоянного значения по умолчанию для таблицы FTS.</target>
        </trans-unit>
        <trans-unit id="f96fd53b0d03f5a031e6bd07854c303b890ed6f3" translate="yes" xml:space="preserve">
          <source>Instead of writing separately to the full-text index and the content table, some users may wish to use database triggers to keep the full-text index up to date with respect to the set of documents stored in the content table. For example, using the tables from earlier examples:</source>
          <target state="translated">Вместо того,чтобы писать отдельно в полнотекстовый индекс и таблицу содержимого,некоторые пользователи могут использовать триггеры базы данных для поддержания полнотекстового индекса в актуальном состоянии по отношению к набору документов,хранящихся в таблице содержимого.Например,используя таблицы из более ранних примеров:</target>
        </trans-unit>
        <trans-unit id="2dfaa927aed3a85d724ea909cde490986f208ecf" translate="yes" xml:space="preserve">
          <source>Instruction 1 is of particular importance in this example. Normally, the Column instruction extracts the value of a column from a larger record in the data of an SQLite file entry. Instruction 1 sets a flag on the transient table so that Column will instead treat the key of the SQLite file entry as if it were data and extract column information from the key.</source>
          <target state="translated">В данном примере особое значение имеет Инструкция 1.Обычно инструкция Column извлекает значение столбца из более крупной записи в данных записи файла SQLite.В Инструкции 1 установлен флаг на переходной таблице,так что вместо колонки будет обрабатываться ключ записи в файле SQLite,как если бы это были данные,и извлекаться информация о колонке из ключа.</target>
        </trans-unit>
        <trans-unit id="5a41b63030179eee6fe726824158f303ff0039a4" translate="yes" xml:space="preserve">
          <source>Instructions 0 though 4 are as in the INSERT example. They start transactions for the main and temporary databases, verify the database schema for the main database, and open a read cursor on the table &quot;examp&quot;. Notice that the cursor is opened for reading, not writing. At this stage of the program we are only going to be scanning the table, not changing it. We will reopen the same table for writing later, at instruction 15.</source>
          <target state="translated">Инструкции 0,хотя и 4 такие же,как и в примере INSERT.Они начинают транзакции для основной и временной БД,проверяют схему БД для основной и открывают курсор чтения на таблице &quot;экзамен&quot;.Обратите внимание,что курсор открыт для чтения,а не для записи.На данном этапе программы мы будем только сканировать таблицу,не изменяя ее.Мы вновь откроем эту же таблицу для записи позже,в инструкции 15.</target>
        </trans-unit>
        <trans-unit id="b00a667a760d339b93dad1b03b5b7f4819103702" translate="yes" xml:space="preserve">
          <source>Instructions 11 through 18 implement a loop over all index records with the key that was fetched by instruction 8. All of the index records with this key will be contiguous in the index table, so we walk through them and fetch the corresponding table key from the index. This table key is then used to move the cursor to that row in the table. The rest of the loop is the same as the loop for the non-indexed SELECT query.</source>
          <target state="translated">В Инструкциях 11-18 реализован цикл над всеми записями индекса с ключом,который был получен с помощью Инструкции 8.Все записи индекса с этим ключом будут сопрягаться в индексной таблице,поэтому мы пройдем по ним и возьмем соответствующий ключ таблицы из индекса.Затем этот ключ таблицы используется для перемещения курсора на эту строку таблицы.Остальная часть цикла аналогична циклу для неиндексированного SELECT-запроса.</target>
        </trans-unit>
        <trans-unit id="93ad75caff49702ce2412b358044c514b17d458d" translate="yes" xml:space="preserve">
          <source>Instructions 18 through 23 implement a loop over every row of the table being indexed. For each table row, we first extract the integer key for that row using Recno in instruction 19, then get the value of the &quot;two&quot; column using Column in instruction 20. The &lt;a href=&quot;opcode#MakeIdxKey&quot;&gt;MakeIdxKey&lt;/a&gt; instruction at 21 converts data from the &quot;two&quot; column (which is on the top of the stack) into a valid index key. For an index on a single column, this is basically a no-op. But if the P1 operand to MakeIdxKey had been greater than one multiple entries would have been popped from the stack and converted into a single index key. The &lt;a href=&quot;opcode#IdxPut&quot;&gt;IdxPut&lt;/a&gt; instruction at 22 is what actually creates the index entry. IdxPut pops two elements from the stack. The top of the stack is used as a key to fetch an entry from the index table. Then the integer which was second on stack is added to the set of integers for that index and the new record is written back to the database file. Note that the same index entry can store multiple integers if there are two or more table entries with the same value for the two column.</source>
          <target state="translated">Инструкции с 18 по 23 реализуют цикл по каждой индексируемой строке таблицы. Для каждой строки таблицы мы сначала извлекаем целочисленный ключ для этой строки с помощью Recno в инструкции 19, затем получаем значение столбца &amp;laquo;два&amp;raquo; с помощью столбца в инструкции 20. Инструкция &lt;a href=&quot;opcode#MakeIdxKey&quot;&gt;MakeIdxKey&lt;/a&gt; в 21 преобразует данные из столбца &amp;laquo;два&amp;raquo; ( который находится наверху стека) в действительный индексный ключ. Для индекса по одному столбцу это практически невозможно. Но если бы операнд P1 для MakeIdxKey был больше, чем один, несколько записей были бы извлечены из стека и преобразованы в один индексный ключ. &lt;a href=&quot;opcode#IdxPut&quot;&gt;IdxPut&lt;/a&gt;инструкция в 22 - это то, что на самом деле создает запись индекса. IdxPut извлекает два элемента из стека. Верхняя часть стека используется как ключ для выборки записи из индексной таблицы. Затем целое число, которое было вторым в стеке, добавляется к набору целых чисел для этого индекса, и новая запись записывается обратно в файл базы данных. Обратите внимание, что одна и та же запись индекса может хранить несколько целых чисел, если есть две или более записи таблицы с одинаковым значением для двух столбцов.</target>
        </trans-unit>
        <trans-unit id="d073fd93c649c9cf841978f9cb4f52abf67079a9" translate="yes" xml:space="preserve">
          <source>Instructions 19 through 25 construct a new database record that will be used to replace the existing record. This is the same kind of code that we saw in the description of INSERT and will not be described further. After instruction 25 executes, the stack looks like this:</source>
          <target state="translated">В Инструкциях 19-25 создается новая запись в базе данных,которая будет использоваться для замены существующей записи.Это тот же самый код,который мы видели в описании INSERT и не будем описывать далее.После выполнения Инструкции 25 стек выглядит так:</target>
        </trans-unit>
        <trans-unit id="560e44647be24d5aca941bd1314e718abb8f4a57" translate="yes" xml:space="preserve">
          <source>Instructions 2 and 3 open a read cursor on the database table that is to be queried. This works the same as the OpenWrite instruction in the INSERT example except that the cursor is opened for reading this time instead of for writing. Instruction 4 verifies the database schema as in the INSERT example.</source>
          <target state="translated">Инструкции 2 и 3 открывают курсор чтения на таблице БД,которую необходимо опрашивать.Это работает так же,как и инструкция OpenWrite в примере INSERT,за исключением того,что курсор в этот раз открывается на чтение,а не на запись.Инструкция 4 проверяет схему БД,как в примере INSERT.</target>
        </trans-unit>
        <trans-unit id="fca2a6be701ffa87d686ce081ffdb761ec90891d" translate="yes" xml:space="preserve">
          <source>Instructions for compiling for Android are &lt;a href=&quot;#compile-android&quot;&gt;shown below&lt;/a&gt;.</source>
          <target state="translated">Инструкции по компиляции для Android &lt;a href=&quot;#compile-android&quot;&gt;приведены ниже&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="180fcbe698d0f2c44101a06215c472930bbd0a01" translate="yes" xml:space="preserve">
          <source>Int64</source>
          <target state="translated">Int64</target>
        </trans-unit>
        <trans-unit id="8245fcad9e0056a0d272c8564c605d1f5607526e" translate="yes" xml:space="preserve">
          <source>IntCopy</source>
          <target state="translated">IntCopy</target>
        </trans-unit>
        <trans-unit id="9edcffff4461c9083fbff857f8dcee0f0769cbd4" translate="yes" xml:space="preserve">
          <source>Integer</source>
          <target state="translated">Integer</target>
        </trans-unit>
        <trans-unit id="d591fd91d02ea91f2fb6bfc98baa68985aa1c55d" translate="yes" xml:space="preserve">
          <source>Integer arithmetic operations that would have resulted in overflow are now performed using floating-point instead.</source>
          <target state="translated">Целочисленные арифметические операции,которые привели бы к переполнению,теперь выполняются с плавающей точкой.</target>
        </trans-unit>
        <trans-unit id="a45ac87a27eab6aa76ce2b5c611f2a64d3669419" translate="yes" xml:space="preserve">
          <source>Integer values stored as part of segment b-tree nodes are encoded using the FTS varint format. This encoding is similar, but &lt;b&gt;not identical&lt;/b&gt;, to the &lt;a href=&quot;fileformat#varint_format&quot;&gt;SQLite varint format&lt;/a&gt;.</source>
          <target state="translated">Целочисленные значения, хранящиеся как часть узлов сегмента b-дерева, кодируются с использованием формата FTS varint. Эта кодировка подобна, но &lt;b&gt;не идентична&lt;/b&gt; , в &lt;a href=&quot;fileformat#varint_format&quot;&gt;формате SQLite varint&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="60896296e2cc4f360fd103b1acf3b75080d48243" translate="yes" xml:space="preserve">
          <source>Integrity of the freelist</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5d27de0bdb200a7cf8d08a229aa8daa78f0e8ef" translate="yes" xml:space="preserve">
          <source>IntegrityCk</source>
          <target state="translated">IntegrityCk</target>
        </trans-unit>
        <trans-unit id="825d7872ab454dde0951d75f4e8c3836556b73f2" translate="yes" xml:space="preserve">
          <source>Intended Use Of This Memory Slot</source>
          <target state="translated">Целевое использование этого слота памяти</target>
        </trans-unit>
        <trans-unit id="bad6e55f508278bbd1f2de2f51b2cfa41d861db7" translate="yes" xml:space="preserve">
          <source>Interbase</source>
          <target state="translated">Interbase</target>
        </trans-unit>
        <trans-unit id="7b4db7ef1fa23cfb5e115a2a2c89d46a6a2ebc4a" translate="yes" xml:space="preserve">
          <source>Interface</source>
          <target state="translated">Interface</target>
        </trans-unit>
        <trans-unit id="5fe5b201b27c997051ff6e5d94d0bbfdf6211714" translate="yes" xml:space="preserve">
          <source>Interior pages of table b-trees have no payload and so there is never any payload to spill.</source>
          <target state="translated">Внутренние страницы таблицы b-деревья не имеют полезной нагрузки и поэтому никогда не проливаются.</target>
        </trans-unit>
        <trans-unit id="fc9225a1693f44637be7aea70d7fcc2c5840704d" translate="yes" xml:space="preserve">
          <source>Internal</source>
          <target state="translated">Internal</target>
        </trans-unit>
        <trans-unit id="2e2e38ed2987465eebf4fce7929c514aa147e99c" translate="yes" xml:space="preserve">
          <source>Internal Versus External BLOBs</source>
          <target state="translated">Внутренний против внешнего BLOB</target>
        </trans-unit>
        <trans-unit id="8f5ed2d53487fd119b9560f28f441dc6f596f2d9" translate="yes" xml:space="preserve">
          <source>Internal Versus External BLOBs in SQLite</source>
          <target state="translated">Внутренние против внешних BLOB в SQLite</target>
        </trans-unit>
        <trans-unit id="e76edc7c42bb9553424aeb43d13659b70db42f10" translate="yes" xml:space="preserve">
          <source>Internal schema objects used by SQLite may include the following:</source>
          <target state="translated">Внутренние объекты схемы,используемые SQLite,могут включать в себя следующее:</target>
        </trans-unit>
        <trans-unit id="f7a3c018025e7b8852ebedd2735d4dc85161ed87" translate="yes" xml:space="preserve">
          <source>Internal table</source>
          <target state="translated">Внутренняя таблица</target>
        </trans-unit>
        <trans-unit id="43a9dae252aed092af4315626ccea64ecf3ea367" translate="yes" xml:space="preserve">
          <source>Internally, Geopoly stores polygons in a binary format - an SQL BLOB. Details of the binary format are given below. All of the Geopoly interfaces are able to accept polygons in either the GeoJSON format or in the binary format.</source>
          <target state="translated">Внутри Geopoly хранит полигоны в бинарном формате-SQL BLOB.Детали бинарного формата приведены ниже.Все интерфейсы Geopoly могут принимать полигоны как в формате GeoJSON,так и в бинарном формате.</target>
        </trans-unit>
        <trans-unit id="f1e37c3aeef00d8b7d2ca4c1560bedb3798f4927" translate="yes" xml:space="preserve">
          <source>Internationalization of the TRIM() function. Ticket #2323</source>
          <target state="translated">Интернационализация функции TRIM().Билет #2323</target>
        </trans-unit>
        <trans-unit id="888710a95af8568e1d72613950e6141b6fd4f17f" translate="yes" xml:space="preserve">
          <source>Interpret the byte at offset X into the page as an 8-bit unsigned integer and add the value of that integer to the checksum.</source>
          <target state="translated">Интерпретируйте байт при смещении X в страницу как 8-битное беззнаковое целое число и добавьте значение этого числа к контрольной сумме.</target>
        </trans-unit>
        <trans-unit id="0a6e9fc795cd5f992a07708fafc38d37296f0f2e" translate="yes" xml:space="preserve">
          <source>Interpret the content of register P1 as an integer. Store the ones-complement of the P1 value into register P2. If P1 holds a NULL then store a NULL in P2.</source>
          <target state="translated">Интерпретируйте содержимое регистра P1 как целое число.Хранить единичное целое значение P1 в регистре P2.Если P1 содержит NULL,то хранить NULL в P2.</target>
        </trans-unit>
        <trans-unit id="5e8db10d44914bca3da452a09d9353f35541c4d5" translate="yes" xml:space="preserve">
          <source>Interpret the data that cursor P1 points to as a structure built using the &lt;a href=&quot;opcode#MakeRecord&quot;&gt;MakeRecord&lt;/a&gt; instruction. (See the &lt;a href=&quot;opcode#MakeRecord&quot;&gt;MakeRecord&lt;/a&gt; opcode for additional information about the format of the data.) Extract the P2-th column from this record. If there are less that (P2+1) values in the record, extract a NULL.</source>
          <target state="translated">Интерпретируйте данные, на которые указывает курсор P1, как структуру, построенную с &lt;a href=&quot;opcode#MakeRecord&quot;&gt;помощью&lt;/a&gt; инструкции MakeRecord . (См. &lt;a href=&quot;opcode#MakeRecord&quot;&gt;Код&lt;/a&gt; операции MakeRecord для получения дополнительной информации о формате данных.) Извлеките столбец P2 из этой записи. Если в записи меньше (P2 + 1) значений, извлеките NULL.</target>
        </trans-unit>
        <trans-unit id="2f79feeee233aec484084c713d84bf8b19e18fec" translate="yes" xml:space="preserve">
          <source>Interpret the value in register P1 as a boolean value. Store that boolean (a 0 or 1) in register P2. Or if the value in register P1 is NULL, then the P3 is stored in register P2. Invert the answer if P4 is 1.</source>
          <target state="translated">Интерпретируйте значение в регистре P1 как логическое значение.Храните это булевое значение (0 или 1)в регистре P2.Или если значение в регистре P1 равно NULL,то P3 хранится в регистре P2.Инвертировать ответ,если P4 равен 1.</target>
        </trans-unit>
        <trans-unit id="11ded0e7491f472be93758e1becf6a72788c6084" translate="yes" xml:space="preserve">
          <source>Interpret the value in register P1 as a boolean value. Store the boolean complement in register P2. If the value in register P1 is NULL, then a NULL is stored in P2.</source>
          <target state="translated">Интерпретируйте значение в регистре P1 как логическое значение.Хранить булевое дополнение в регистре P2.Если значение в регистре P1 равно NULL,то NULL хранится в P2.</target>
        </trans-unit>
        <trans-unit id="15470fd033e12b800743519c6e594f7da0f4f0f0" translate="yes" xml:space="preserve">
          <source>Interpretation</source>
          <target state="translated">Interpretation</target>
        </trans-unit>
        <trans-unit id="1215cbe2c98ef14d7aa50ec46f17432a95774205" translate="yes" xml:space="preserve">
          <source>Interrupt A Long-Running Query</source>
          <target state="translated">Прервать длинный бегущий запрос</target>
        </trans-unit>
        <trans-unit id="5c1dd154209c449e02a41fa43190c4baa16c350d" translate="yes" xml:space="preserve">
          <source>Introduce extended error codes and add error codes for various kinds of I/O errors.</source>
          <target state="translated">Ввести расширенные коды ошибок и добавить коды ошибок для различных видов ошибок ввода/вывода.</target>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="99fc2e9eb55cb6b8a4a8e79d3fb3b2c33516ae12" translate="yes" xml:space="preserve">
          <source>Introspect the disk content of an SQLite database file (the &lt;a href=&quot;dbstat&quot;&gt;dbstat virtual table&lt;/a&gt;)</source>
          <target state="translated">Изучите содержимое диска файла базы данных SQLite ( &lt;a href=&quot;dbstat&quot;&gt;виртуальная таблица dbstat&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="eca078956e48bad9ba22213be258664ddfba5fe3" translate="yes" xml:space="preserve">
          <source>Intuitively, we humans understand that algorithm-1 is best. Each check-in is likely to have few children (one child is the most common case) and each child can be tested for the $trunk tag in logarithmic time. Indeed, algorithm-1 is the faster choice in practice. But the NGQP has no intuition. The NGQP must use hard math, and algorithm-2 is slightly better mathematically. This is because, in the absence of other information, the NGQP must assume that the indexes PLINK_I1 and TAGXREF_I1 are of equal quality and are equally selective. Algorithm-2 uses one field of the TAGXREF_I1 index and both fields of the PLINK_I1 index whereas algorithm-1 only uses the first field of each index. Since algorithm-2 uses more index material, the NGQP is correct to judge it to be the better algorithm. The scores are close and algorithm-2 just barely squeaks ahead of algorithm-1. But algorithm-2 really is the correct choice here.</source>
          <target state="translated">Интуитивно мы,люди,понимаем,что алгоритм-1-лучший.Скорее всего,у каждого заезда мало детей (чаще всего это один ребенок),и каждый ребенок может быть проверен на логарифмический тег $ ствола в логарифмическое время.Действительно,алгоритм-1 является более быстрым выбором на практике.Но у NGQP нет интуиции.NGQP должен использовать жесткую математику,а алгоритм-2 немного лучше с математической точки зрения.Это связано с тем,что в отсутствие другой информации NGQP должен исходить из того,что индексы PLINK_I1 и TAGXREF_I1 одинаково качественны и одинаково избирательны.Алгоритм-2 использует одно поле индекса TAGXREF_I1 и оба поля индекса PLINK_I1,тогда как алгоритм-1 использует только первое поле каждого индекса.Поскольку алгоритм-2 использует больше материала индекса,NGQP правильно оценивает его как лучший алгоритм.Оценки близки и алгоритм-2 едва пищит впереди алгоритма-1.Но алгоритм-2 действительно является правильным выбором.</target>
        </trans-unit>
        <trans-unit id="b761791d82a982a68e59a508cac1ee842272cd79" translate="yes" xml:space="preserve">
          <source>Invert A Changeset</source>
          <target state="translated">Инвертировать изменение</target>
        </trans-unit>
        <trans-unit id="e32caad6eec08f7fecc6a1b58616c917f68be530" translate="yes" xml:space="preserve">
          <source>Invert the changeset before applying it. This is equivalent to inverting a changeset using sqlite3changeset_invert() before applying it. It is an error to specify this flag with a patchset.</source>
          <target state="translated">Инвертируйте changeset перед применением.Это эквивалентно инвертированию changeset'а с помощью sqlite3changeset_invert()перед его применением.Ошибкой является указание этого флага с помощью патчсета.</target>
        </trans-unit>
        <trans-unit id="78ac8e24cc6e1af906f6d84df224cae4a5dbdc9c" translate="yes" xml:space="preserve">
          <source>Invert the changeset while iterating through it. This is equivalent to inverting a changeset using sqlite3changeset_invert() before applying it. It is an error to specify this flag with a patchset.</source>
          <target state="translated">Инвертируйте измененный набор во время итерации через него.Это эквивалентно инвертированию changeset'а с помощью sqlite3changeset_invert()перед его применением.Ошибкой является указание этого флага с помощью патчсета.</target>
        </trans-unit>
        <trans-unit id="7bcd843ccbf3ca2b0a46090c9286f7cf70d294d4" translate="yes" xml:space="preserve">
          <source>Invoke &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigtrustedschema&quot;&gt;SQLITE_DBCONFIG_TRUSTED_SCHEMA&lt;/a&gt;,0,0) on each &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; as soon as it is opened.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebc598ee05cff833de713e00e614680a147ad7e5" translate="yes" xml:space="preserve">
          <source>Invoke &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigtrustedschema&quot;&gt;SQLITE_DBCONFIG_TRUSTED_SCHEMA&lt;/a&gt;,0,0) on each &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; as soon as it is opened. This prevents application-defined functions from being used in places where an attacker might be able to surreptiously invoke them by modifying a database schema:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f705eccb3bd6ee22f3941d7379adda7f2017d82" translate="yes" xml:space="preserve">
          <source>Invoke &lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify()&lt;/a&gt; on the database connection handle associated with the supplied statement handle to register for an unlock-notify callback. If the call to unlock_notify() returns SQLITE_LOCKED, then return this value to the caller.</source>
          <target state="translated">Вызовите &lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify ()&lt;/a&gt; для дескриптора соединения с базой данных, связанного с предоставленным дескриптором оператора, чтобы зарегистрироваться для обратного вызова unlock-notify. Если вызов unlock_notify () возвращает SQLITE_LOCKED, то верните это значение вызывающей стороне.</target>
        </trans-unit>
        <trans-unit id="7c709a0509002cbc5917883c970a9481452275c1" translate="yes" xml:space="preserve">
          <source>Invoke a user function (P4 is a pointer to a FuncDef object that defines the function) with P5 arguments taken from register P2 and successors. The result of the function is stored in register P3. Register P3 must not be one of the function inputs.</source>
          <target state="translated">Вызвать пользовательскую функцию (P4-указатель на объект FuncDef,определяющий функцию)с аргументами P5,взятыми из регистра P2 и преемников.Результат функции хранится в регистре P3.Регистр P3 не должен быть одним из входов функции.</target>
        </trans-unit>
        <trans-unit id="d5afe87b60965605a9297c781c01328e7ab18fc9" translate="yes" xml:space="preserve">
          <source>Invoke a user function (P4 is a pointer to an sqlite3_context object that contains a pointer to the function to be run) with P5 arguments taken from register P2 and successors. The result of the function is stored in register P3. Register P3 must not be one of the function inputs.</source>
          <target state="translated">Вызвать пользовательскую функцию (P4-указатель на контекстный объект sqlite3_context,содержащий указатель на запускаемую функцию)с аргументами P5,взятыми из регистра P2 и преемников.Результат работы функции хранится в регистре P3.Регистр P3 не должен быть одним из входов функции.</target>
        </trans-unit>
        <trans-unit id="bf8b8c1d4d822ee5f5035e452152155ef6c1caa7" translate="yes" xml:space="preserve">
          <source>Invoke a user function (P4 is a pointer to an sqlite3_context object that contains a pointer to the function to be run) with arguments taken from register P2 and successors. The number of arguments is in the sqlite3_context object that P4 points to. The result of the function is stored in register P3. Register P3 must not be one of the function inputs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec3125db909dbad56a3a25ad8b3535b576369321" translate="yes" xml:space="preserve">
          <source>Invoke the 'merge' command once with the parameter set to -N, then</source>
          <target state="translated">Запустить команду 'слияние' один раз с параметром -N,затем</target>
        </trans-unit>
        <trans-unit id="7dd177608c23145959faf29e93b347c2a9c95d8f" translate="yes" xml:space="preserve">
          <source>Invoke the 'merge' command zero or more times with the parameter set to N.</source>
          <target state="translated">Вызовите команду 'слияние' ноль или более раз с параметром,установленным в N.</target>
        </trans-unit>
        <trans-unit id="66ccce8dbed894fb937993244705085ff4d8803a" translate="yes" xml:space="preserve">
          <source>Invoke the callback function for the current row of the result.</source>
          <target state="translated">Вызовите функцию обратного вызова для текущей строки результата.</target>
        </trans-unit>
        <trans-unit id="125398c8d0ddcbf991b86f4ee6d99da4c12cf932" translate="yes" xml:space="preserve">
          <source>Invoke the sqlite3rbu_step(X) function one or more times on the sqlite3rbu object pointer X. Each call to sqlite3rbu_step() performs a single b-tree operation, so thousands of calls may be required to apply a complete update. The sqlite3rbu_step() interface will return SQLITE_DONE when the update has been completely applied.</source>
          <target state="translated">Вызвать функцию sqlite3rbu_step(X)один или несколько раз по указателю объекта sqlite3rbu X.Каждый вызов sqlite3rbu_step()выполняет одну операцию в b-дереве,поэтому для применения полного обновления могут потребоваться тысячи вызовов.Интерфейс sqlite3rbu_step()вернет SQLITE_DONE после полного применения обновления.</target>
        </trans-unit>
        <trans-unit id="09ac0f478fa9c31ebe084063003a8993cc83456c" translate="yes" xml:space="preserve">
          <source>Invoke the xValue() function and store the result in register P3.</source>
          <target state="translated">Вызовите функцию xValue()и сохраните результат в регистре P3.</target>
        </trans-unit>
        <trans-unit id="ec2b47e7de90dfad0a6211ad1cb07982eafe0cde" translate="yes" xml:space="preserve">
          <source>Invoking sqlite3_finalize() on a NULL pointer is a harmless no-op.</source>
          <target state="translated">Призыв sqlite3_finalize()на указатель NULL является безобидным no-op.</target>
        </trans-unit>
        <trans-unit id="bd8202d31b1a7640473e2e12fd946892b1ec4008" translate="yes" xml:space="preserve">
          <source>Invoking this pragma with an argument is equivalent to calling the &lt;a href=&quot;c3ref/wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2()&lt;/a&gt; C interface with a &lt;a href=&quot;c3ref/c_checkpoint_full&quot;&gt;3rd parameter&lt;/a&gt; corresponding to the argument:</source>
          <target state="translated">Вызов этой прагмы с аргументом эквивалентен вызову интерфейса C &lt;a href=&quot;c3ref/wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2 ()&lt;/a&gt; с &lt;a href=&quot;c3ref/c_checkpoint_full&quot;&gt;третьим параметром,&lt;/a&gt; соответствующим аргументу:</target>
        </trans-unit>
        <trans-unit id="5f0e3d2a93c21482714b0b7a93ae0ad2d3dfb1f3" translate="yes" xml:space="preserve">
          <source>Invoking this pragma without an argument is equivalent to calling the &lt;a href=&quot;c3ref/wal_checkpoint&quot;&gt;sqlite3_wal_checkpoint()&lt;/a&gt; C interface.</source>
          <target state="translated">Вызов этой прагмы без аргументов эквивалентен вызову интерфейса C. &lt;a href=&quot;c3ref/wal_checkpoint&quot;&gt;sqlite3_wal_checkpoint ()&lt;/a&gt; C.</target>
        </trans-unit>
        <trans-unit id="8cedb7aa520fd9ec8eb114043f05f6f9d17e93dd" translate="yes" xml:space="preserve">
          <source>Is SQLite threadsafe?</source>
          <target state="translated">Безопасен ли SQLite для потоков?</target>
        </trans-unit>
        <trans-unit id="d993744fe6f739c6aa4d5f6de34d342868d7e529" translate="yes" xml:space="preserve">
          <source>Is replaced by:</source>
          <target state="translated">заменен:</target>
        </trans-unit>
        <trans-unit id="accaed01010f56d422eef5c33bfb4384f7eeeed3" translate="yes" xml:space="preserve">
          <source>IsNull</source>
          <target state="translated">IsNull</target>
        </trans-unit>
        <trans-unit id="a0830278e8f462114ebf33a9e4e362b34c86b01d" translate="yes" xml:space="preserve">
          <source>IsTrue</source>
          <target state="translated">IsTrue</target>
        </trans-unit>
        <trans-unit id="3dea5e42ca2754f9e6823ecfc4f51c71cf05676a" translate="yes" xml:space="preserve">
          <source>Isolation And Concurrency</source>
          <target state="translated">изоляция и концентрация</target>
        </trans-unit>
        <trans-unit id="6a3e64b57124b4061c4f707d69ad242f0d0e0ef1" translate="yes" xml:space="preserve">
          <source>Isolation Between Database Connections</source>
          <target state="translated">Изоляция между соединениями базы данных</target>
        </trans-unit>
        <trans-unit id="e3488e8cb34f4c736ddb072c649ba2a6c79489e5" translate="yes" xml:space="preserve">
          <source>Isolation In SQLite</source>
          <target state="translated">Изоляция в SQLite</target>
        </trans-unit>
        <trans-unit id="2dfabf57c5175b858eac45130bf0b51df7502b3e" translate="yes" xml:space="preserve">
          <source>Issue an &lt;a href=&quot;rescode#warning_autoindex&quot;&gt;SQLITE_WARNING_AUTOINDEX&lt;/a&gt; warning on the &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfiglog&quot;&gt;SQLITE_CONFIG_LOG&lt;/a&gt; whenever the query planner uses an automatic index.</source>
          <target state="translated">Составлять &lt;a href=&quot;rescode#warning_autoindex&quot;&gt;SQLITE_WARNING_AUTOINDEX&lt;/a&gt; предупреждение на &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfiglog&quot;&gt;SQLITE_CONFIG_LOG&lt;/a&gt; всякий раз , когда планировщик запросов использует автоматический индекс.</target>
        </trans-unit>
        <trans-unit id="ffb450eea3632a82507d6bc65c2b7d60604799db" translate="yes" xml:space="preserve">
          <source>Issue an SQLITE_WARNING message on the &lt;a href=&quot;errlog&quot;&gt;error log&lt;/a&gt; if a &lt;a href=&quot;quirks#dblquote&quot;&gt;double-quoted string literal&lt;/a&gt; is used.</source>
          <target state="translated">Выдать сообщение SQLITE_WARNING в &lt;a href=&quot;errlog&quot;&gt;журнал ошибок,&lt;/a&gt; если используется &lt;a href=&quot;quirks#dblquote&quot;&gt;строковый литерал&lt;/a&gt; в двойных кавычках .</target>
        </trans-unit>
        <trans-unit id="887bf7a7997457d1a84b4ef3887a47fd35509c6e" translate="yes" xml:space="preserve">
          <source>Issue an error rather instead of an assertion-fault or null-pointer dereference when the sqlite_master table is corrupted so that the sqlite_sequence table root page is really a btree-index page. Check-in &lt;a href=&quot;https://www.sqlite.org/src/info/525deb7a67fbd647&quot;&gt;525deb7a67fbd647&lt;/a&gt;</source>
          <target state="translated">Выдавать ошибку, а не разыменование ошибки утверждения или нулевого указателя, когда таблица sqlite_master повреждена, так что корневая страница таблицы sqlite_sequence действительно является страницей индекса btree. Заезд &lt;a href=&quot;https://www.sqlite.org/src/info/525deb7a67fbd647&quot;&gt;525deb7a67fbd647&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="265877cc565c8d7a6873f0a63d90a0fdd348de2c" translate="yes" xml:space="preserve">
          <source>It an error if database zFrom does not exist or does not contain the required compatible table.</source>
          <target state="translated">Ошибка,если база данных zFrom не существует или не содержит требуемой совместимой таблицы.</target>
        </trans-unit>
        <trans-unit id="0e154e176231a0aafc6a2d79aba315f0be81a2c2" translate="yes" xml:space="preserve">
          <source>It cannot be used to copy data to or from in-memory databases.</source>
          <target state="translated">Он не может быть использован для копирования данных в или из баз данных в памяти.</target>
        </trans-unit>
        <trans-unit id="6fd3c51616175d12c8323af133471dff22943ef2" translate="yes" xml:space="preserve">
          <source>It could handle a special case of SQLITE_LOCKED that can occur when dropping a table or index.</source>
          <target state="translated">Он может обрабатывать специальный случай SQLITE_LOCKED,который может возникнуть при падении таблицы или индекса.</target>
        </trans-unit>
        <trans-unit id="186b030c86f45f0c84d4dba2b997ab209083ef94" translate="yes" xml:space="preserve">
          <source>It could manage thread priorities.</source>
          <target state="translated">Он может управлять приоритетами потоков.</target>
        </trans-unit>
        <trans-unit id="46b90c15208f2a0e159c21cdb03813412db842c6" translate="yes" xml:space="preserve">
          <source>It exists, and</source>
          <target state="translated">Она существует,и</target>
        </trans-unit>
        <trans-unit id="40ecc5a776918cb0ff3984e5d8619d213f6f930d" translate="yes" xml:space="preserve">
          <source>It is a good idea to establish a convention for determining the RBU vacuum state database name based on the target database name. The example code below uses &quot;&amp;lt;target&amp;gt;-vacuum&quot;, where &amp;lt;target&amp;gt; is the name of the database being vacuumed.</source>
          <target state="translated">Рекомендуется установить соглашение для определения имени базы данных состояния вакуума RBU на основе имени целевой базы данных. В приведенном ниже примере кода используется &amp;laquo;&amp;lt;цель&amp;gt; -вакуум&amp;raquo;, где &amp;lt;цель&amp;gt; - это имя очищаемой базы данных.</target>
        </trans-unit>
        <trans-unit id="bc2605e225f0c06786d4d6602b4aa9c521bcd8db" translate="yes" xml:space="preserve">
          <source>It is acceptable to call &lt;b&gt;sqlite_finalize&lt;/b&gt; on a virtual machine before &lt;b&gt;sqlite_step&lt;/b&gt; has returned SQLITE_DONE. Doing so has the effect of interrupting the operation in progress. Partially completed changes will be rolled back and the database will be restored to its original state (unless an alternative recovery algorithm is selected using an ON CONFLICT clause in the SQL being executed.) The effect is the same as if a callback function of &lt;b&gt;sqlite_exec&lt;/b&gt; had returned non-zero.</source>
          <target state="translated">Допустимо вызывать &lt;b&gt;sqlite_finalize&lt;/b&gt; на виртуальной машине до того, как &lt;b&gt;sqlite_step&lt;/b&gt; вернет SQLITE_DONE. Это приведет к прерыванию выполняемой операции. Частично завершенные изменения будут отменены, и база данных будет восстановлена ​​в исходное состояние (если не выбран альтернативный алгоритм восстановления с помощью предложения ON CONFLICT в выполняемом SQL). Эффект такой же, как если бы функция обратного вызова &lt;b&gt;sqlite_exec&lt;/b&gt; имела вернул ненулевое значение.</target>
        </trans-unit>
        <trans-unit id="9b1cdd52a287f4e7becc07615494854f9dea1062" translate="yes" xml:space="preserve">
          <source>It is also acceptable to call &lt;b&gt;sqlite_finalize&lt;/b&gt; on a virtual machine that has never been passed to &lt;b&gt;sqlite_step&lt;/b&gt; even once.</source>
          <target state="translated">Также допустимо вызывать &lt;b&gt;sqlite_finalize&lt;/b&gt; на виртуальной машине, которая ни разу не была передана &lt;b&gt;sqlite_step&lt;/b&gt; ни разу.</target>
        </trans-unit>
        <trans-unit id="8524404ce2a2650e2fd11b49dcd571c2f2744c61" translate="yes" xml:space="preserve">
          <source>It is also possible to create custom tokenizers for FTS5. The API for doing so is &lt;a href=&quot;fts5#custom_tokenizers&quot;&gt;described here&lt;/a&gt;.</source>
          <target state="translated">Также можно создавать собственные токенизаторы для FTS5. API для этого &lt;a href=&quot;fts5#custom_tokenizers&quot;&gt;описан здесь&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="af4ea7504b8858e61227bf5cbac3c869a2ebb0cf" translate="yes" xml:space="preserve">
          <source>It is also possible to customize the set of codepoints that unicode61 treats as separator characters. The &quot;separators=&quot; option may be used to specify one or more extra characters that should be treated as separator characters, and the &quot;tokenchars=&quot; option may be used to specify one or more extra characters that should be treated as part of tokens instead of as separator characters. For example:</source>
          <target state="translated">Также можно настроить набор кодовых точек,которые unicode61 рассматривает как символы-разделители.Опция &quot;separators=&quot; может быть использована для указания одного или нескольких дополнительных символов,которые должны рассматриваться как символы-разделители,а опция &quot;tokenchars=&quot; может быть использована для указания одного или нескольких дополнительных символов,которые должны рассматриваться как часть токенов,а не как символы-разделители.Например:</target>
        </trans-unit>
        <trans-unit id="c5f2716f625be713954d4be305f323e2da4e7532" translate="yes" xml:space="preserve">
          <source>It is also possible to express this kind of simultaneous read and write on an R-Tree within a single query, for example if an UPDATE statement tries to change the value of one row of the R-Tree based on a complicated query from another row of the same R-Tree, perhaps something like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="756b3fcc2f7b6b94c8632586f6c6ecc720cec025" translate="yes" xml:space="preserve">
          <source>It is an error to add types, constraints or &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt; declarations to a CREATE VIRTUAL TABLE statement used to create an FTS5 table. Once created, an FTS5 table may be populated using &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;, &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; or &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; statements like any other table. Like any other table with no PRIMARY KEY declaration, an FTS5 table has an implicit INTEGER PRIMARY KEY field named rowid.</source>
          <target state="translated">Добавление типов, ограничений или объявлений &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt; к оператору CREATE VIRTUAL TABLE, используемому для создания таблицы FTS5, является ошибкой. После создания таблица FTS5 может быть заполнена с помощью операторов &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; , &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; или &lt;a href=&quot;lang_delete&quot;&gt;DELETE,&lt;/a&gt; как и любая другая таблица. Как и любая другая таблица без объявления PRIMARY KEY, таблица FTS5 имеет неявное поле INTEGER PRIMARY KEY с именем rowid.</target>
        </trans-unit>
        <trans-unit id="444eee32669789fe15a56475160491d70e6d7f57" translate="yes" xml:space="preserve">
          <source>It is an error to attempt to set the sz or rawdata field to any value other than NULL.</source>
          <target state="translated">Ошибкой является попытка установить для поля sz или rawdata любое значение,отличное от NULL.</target>
        </trans-unit>
        <trans-unit id="24bfd3e9a865c193cff416ba8b58e38e3815e72c" translate="yes" xml:space="preserve">
          <source>It is an error to set the columnsize option to any value other than 0 or 1.</source>
          <target state="translated">Ошибкой является установка параметра &quot;Размер столбца&quot; на любое значение,отличное от 0 или 1.</target>
        </trans-unit>
        <trans-unit id="66b8e09fbd7b220da38b0f56a632afa06ded1cc2" translate="yes" xml:space="preserve">
          <source>It is an error to specify the FTS5_TOKEN_COLOCATED flag the first time xToken() is called. Multiple synonyms may be specified for a single token by making multiple calls to xToken(FTS5_TOKEN_COLOCATED) in sequence. There is no limit to the number of synonyms that may be provided for a single token.</source>
          <target state="translated">Ошибкой является указание флага FTS5_TOKEN_COLOCATED при первом вызове xToken().Для одной лексемы можно указать несколько синонимов,последовательно вызывая xToken(FTS5_TOKEN_COLOCATED).Количество синонимов,которое может быть задано для одной лексемы,не ограничено.</target>
        </trans-unit>
        <trans-unit id="f8a103b729e696566ddb48fa0100f23ca6a9cb4a" translate="yes" xml:space="preserve">
          <source>It is assumed that the cursor is used only for appending and so if the cursor is valid, then the cursor must already be pointing at the end of the btree and so no changes are made to the cursor.</source>
          <target state="translated">Предполагается,что курсор используется только для прикрепления,и поэтому,если курсор действителен,то он уже должен быть указан на конец дерева,поэтому никаких изменений в курсоре не вносится.</target>
        </trans-unit>
        <trans-unit id="28727e9350bc13e9dd557e61676acaf81b800e9f" translate="yes" xml:space="preserve">
          <source>It is assumed that writing a series of sequential blocks of data to a file in order is faster than writing the same blocks in an arbitrary order.</source>
          <target state="translated">Предполагается,что запись серии последовательных блоков данных в файл по порядку быстрее,чем запись одних и тех же блоков в произвольном порядке.</target>
        </trans-unit>
        <trans-unit id="b7995ee897a4d7d38d5bc734c7b7a1490089b50f" translate="yes" xml:space="preserve">
          <source>It is common for an application to invoke sqlite3_create_function() multiple times for the same SQL function. For example, if an SQL function can take either 2 or 3 arguments, then sqlite3_create_function() would be invoked once for the 2-argument version and a second time for the 3-argument version. The underlying implementation (the callbacks) can be different for both variants.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90995e42fb1f9b39bc19b92ec7c0b1c1c734e41d" translate="yes" xml:space="preserve">
          <source>It is created using a call to sqlite3changegroup_new().</source>
          <target state="translated">Она создается с помощью вызова sqlite3changegroup_new().</target>
        </trans-unit>
        <trans-unit id="4e7aaf577a2ee286bdd21a85c82980a7edeb975b" translate="yes" xml:space="preserve">
          <source>It is difficult to update individual entries in a ZIP archive. It is especially difficult to update individual entries in a ZIP archive in a way that does not destroy the entire document if the computer loses power and/or crashes in the middle of the update. It is not impossible to do this, but it is sufficiently difficult that nobody actually does it. Instead, whenever the user selects &quot;File/Save&quot;, the entire ZIP archive is rewritten. Hence, &quot;File/Save&quot; takes longer than it ought, especially on older hardware. Newer machines are faster, but it is still bothersome that changing a single character in a 50 megabyte presentation causes one to burn through 50 megabytes of the finite write life on the SSD.</source>
          <target state="translated">Сложно обновлять отдельные записи в ZIP архиве.Особенно сложно обновить отдельные записи в ZIP архиве таким образом,чтобы не уничтожить весь документ,если компьютер выйдет из строя и/или выйдет из строя в середине обновления.Это не невозможно сделать,но достаточно сложно,чтобы никто не делал этого на самом деле.Вместо этого,всякий раз,когда пользователь выбирает &quot;Файл/Сохранить&quot;,весь ZIP-архив переписывается.Следовательно,&quot;Файл/Сохранить&quot; занимает больше времени,чем следовало бы,особенно на старом оборудовании.Новые машины работают быстрее,но все равно неприятно,что изменение одного символа в 50-мегабайтной презентации заставляет прожигать 50 мегабайт конечного срока службы записи на SSD.</target>
        </trans-unit>
        <trans-unit id="5567ffe2a8c6dd00685158eaaf03eb7345f63a44" translate="yes" xml:space="preserve">
          <source>It is illegal for P1 and P3 to be the same register. Sometimes, if P3 is the same register as P2, the implementation is able to avoid a memcpy().</source>
          <target state="translated">Незаконно,чтобы P1 и P3 были одним и тем же регистром.Иногда,если P3 является тем же самым регистром,что и P2,реализация способна избежать memcpy().</target>
        </trans-unit>
        <trans-unit id="e08adbd91885a13f3de038527a6e47107fedd5af" translate="yes" xml:space="preserve">
          <source>It is important that all connections to the same database file use the same locking protocol. If one application is using POSIX advisory locks and another application is using dot-file locking, then the two applications will not see each other's locks and will not be able to coordinate database access, possibly leading to database corruption.</source>
          <target state="translated">Важно,чтобы все соединения к одному и тому же файлу БД использовали один и тот же протокол блокировки.Если одно приложение использует POSIX-советование блокировок,а другое приложение использует точечную блокировку файлов,то эти два приложения не будут видеть блокировки друг друга и не смогут координировать доступ к базе данных,что может привести к повреждению базы данных.</target>
        </trans-unit>
        <trans-unit id="4db5c3705011df2246b430e36dddd9221cec5416" translate="yes" xml:space="preserve">
          <source>It is important that the file-handle lock is upgraded directly from</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c1111b9c3326c8dd11b23932594b685a7b1d3f7" translate="yes" xml:space="preserve">
          <source>It is important to note that changing versions of SQLite might cause changes in query plans. The same version of SQLite will always pick the same query plan, but if you relink your application to use a different version of SQLite, then query plans might change. In rare cases, an SQLite version change might lead to a performance regression. This is one reason you should consider statically linking your applications against SQLite rather than use a system-wide SQLite shared library which might change without your knowledge or control.</source>
          <target state="translated">Важно отметить,что изменение версий SQLite может привести к изменению планов запросов.Одна и та же версия SQLite всегда будет выбирать один и тот же план запросов,но если перекомпоновать приложение под другую версию SQLite,то планы запросов могут измениться.В редких случаях изменение версии SQLite может привести к регрессии производительности.Это одна из причин,по которой следует подумать о статическом связывании приложений с SQLite,а не об использовании общесистемной разделяемой библиотеки SQLite,которая может измениться без вашего ведома и контроля.</target>
        </trans-unit>
        <trans-unit id="2fb1bf740043ac6cffabf7ccc0393c49b8d377d2" translate="yes" xml:space="preserve">
          <source>It is important to realize that neither &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec()&lt;/a&gt; nor &lt;a href=&quot;c3ref/free_table&quot;&gt;sqlite3_get_table()&lt;/a&gt; do anything that cannot be accomplished using the core routines. In fact, these wrappers are implemented purely in terms of the core routines.</source>
          <target state="translated">Важно понимать, что ни &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec (),&lt;/a&gt; ни &lt;a href=&quot;c3ref/free_table&quot;&gt;sqlite3_get_table () не&lt;/a&gt; делают ничего, что не может быть выполнено с помощью основных процедур. Фактически, эти оболочки реализованы исключительно в терминах основных подпрограмм.</target>
        </trans-unit>
        <trans-unit id="e6f1d24d369dd36a94bbbfa574744f4d470ce689" translate="yes" xml:space="preserve">
          <source>It is important to store all pages of a sector in the rollback journal in order to prevent database corruption following a power loss while writing the sector. Suppose that pages 1, 2, 3, and 4 are all stored in sector 1 and that page 2 is modified. In order to write the changes to page 2, the underlying hardware must also rewrite the content of pages 1, 3, and 4 since the hardware must write the complete sector. If this write operation is interrupted by a power outage, one or more of the pages 1, 3, or 4 might be left with incorrect data. Hence, to avoid lasting corruption to the database, the original content of all of those pages must be contained in the rollback journal.</source>
          <target state="translated">Важно хранить все страницы сектора в журнале отката,чтобы предотвратить повреждение базы данных после потери электроэнергии при записи сектора.Предположим,что все страницы 1,2,3 и 4 хранятся в секторе 1,а страница 2 изменяется.Для того чтобы написать изменения на странице 2,соответствующее &quot;железо&quot; должно также переписать содержание страниц 1,3 и 4,так как &quot;железо&quot; должно написать весь сектор.Если эта операция записи прерывается из-за отключения электричества,то на одной или нескольких страницах 1,3 или 4 могут остаться неверные данные.Следовательно,чтобы избежать длительного повреждения базы данных,оригинальное содержание всех этих страниц должно содержаться в журнале отката.</target>
        </trans-unit>
        <trans-unit id="128a48935084af31c9e8080ab5a8fbf025139866" translate="yes" xml:space="preserve">
          <source>It is important to understand these two different definitions for &quot;serverless&quot;. When a database claims to be &quot;serverless&quot;, be sure to discern whether they mean &quot;classic serverless&quot; or &quot;neo-serverless&quot;.</source>
          <target state="translated">Важно понимать эти два разных определения для &quot;безсерверного&quot;.Когда база данных утверждает,что она &quot;бессерверная&quot;,убедитесь,что они означают &quot;классический бессерверный&quot; или &quot;бессерверный нео&quot;.</target>
        </trans-unit>
        <trans-unit id="fa9dd62d3bfcaf75e4033204e51b41d31455c6e9" translate="yes" xml:space="preserve">
          <source>It is important to verify that the gcov test run and the second real test run both give the same output. Any differences in output indicate either the use of undefined or indeterminate behavior in the SQLite code (and hence a bug), or a bug in the compiler. Note that SQLite has, over the previous decade, encountered bugs in each of GCC, Clang, and MSVC. Compiler bugs, while rare, do happen, which is why it is so important to test the code in an as-delivered configuration.</source>
          <target state="translated">Важно убедиться,что тест gcov и второй реальный тест дают один и тот же результат.Любые различия в выводимых данных указывают либо на использование неопределенного или неопределенного поведения в коде SQLite (и,следовательно,на ошибку),либо на ошибку в компиляторе.Обратите внимание,что за последнее десятилетие SQLite сталкивался с ошибками в каждом из GCC,Clang и MSVC.Ошибки компилятора,хотя и встречаются редко,но случаются,поэтому так важно тестировать код в конфигурации &quot;как есть&quot;.</target>
        </trans-unit>
        <trans-unit id="d1cea258b6006ec069fad2e48bb8e0ae1aa954d2" translate="yes" xml:space="preserve">
          <source>It is impossible to test every possible combination of compile-time options for SQLite. But the following set of compile-time options is one configuration that is always fully tested.</source>
          <target state="translated">Невозможно проверить все возможные комбинации опций времени компиляции для SQLite.Но следующий набор опций времени компиляции-это одна конфигурация,которая всегда полностью тестируется.</target>
        </trans-unit>
        <trans-unit id="15edf0a6c6c69dc4fe559f59d8b017e98f300472" translate="yes" xml:space="preserve">
          <source>It is impractical to do crash testing using real power failures, of course, and so crash testing is done in simulation. An alternative &lt;a href=&quot;c3ref/vfs&quot;&gt;Virtual File System&lt;/a&gt; is inserted that allows the test harness to simulate the state of the database file following a crash.</source>
          <target state="translated">Конечно, нецелесообразно проводить краш-тестирование с использованием реальных отказов питания, поэтому краш-тестирование проводится в симуляции. Добавлена ​​альтернативная &lt;a href=&quot;c3ref/vfs&quot;&gt;виртуальная файловая система,&lt;/a&gt; которая позволяет тестовой системе имитировать состояние файла базы данных после сбоя.</target>
        </trans-unit>
        <trans-unit id="e1d5ef237a2a6e6403153de4b153927de75448b8" translate="yes" xml:space="preserve">
          <source>It is not an error if the named table does not exist in the database. Nor is it an error if the named table does not have a PRIMARY KEY. However, no changes will be recorded in either of these scenarios.</source>
          <target state="translated">Это не является ошибкой,если именованная таблица не существует в БД.Это также не ошибка,если именованная таблица не имеет PRIMARY KEY.Однако ни в одном из этих сценариев изменения записываться не будут.</target>
        </trans-unit>
        <trans-unit id="d49fdf0ef1b4c639114a4ac63de04efc40c67c48" translate="yes" xml:space="preserve">
          <source>It is not an error to create a table that has the same name as an existing &lt;a href=&quot;lang_createtrigger&quot;&gt;trigger&lt;/a&gt;.</source>
          <target state="translated">Создание таблицы с тем же именем, что и существующий &lt;a href=&quot;lang_createtrigger&quot;&gt;триггер,&lt;/a&gt; не является ошибкой .</target>
        </trans-unit>
        <trans-unit id="8aaf6c77de556f14a491171c58f28d211cfbc9d4" translate="yes" xml:space="preserve">
          <source>It is not commonly useful to evaluate the &lt;em&gt;exact&lt;/em&gt; same SQL statement more than once. More often, one wants to evaluate similar statements. For example, you might want to evaluate an INSERT statement multiple times with different values. Or you might want to evaluate the same query multiple times using a different key in the WHERE clause. To accommodate this, SQLite allows SQL statements to contain &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameters&lt;/a&gt; which are &quot;bound&quot; to values prior to being evaluated. These values can later be changed and the same &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; can be evaluated a second time using the new values.</source>
          <target state="translated">Это обычно не полезно оценить &lt;em&gt;точно&lt;/em&gt; тот же оператор SQL более чем один раз. Чаще хочется оценить подобные утверждения. Например, вы можете захотеть несколько раз оценить оператор INSERT с разными значениями. Или вы можете захотеть оценить один и тот же запрос несколько раз, используя другой ключ в предложении WHERE. Чтобы приспособиться к этому, SQLite позволяет операторам SQL содержать &lt;a href=&quot;lang_expr#varparam&quot;&gt;параметры,&lt;/a&gt; которые &amp;laquo;привязаны&amp;raquo; к значениям до их оценки. Эти значения могут быть позже изменены, и тот же &lt;a href=&quot;c3ref/stmt&quot;&gt;подготовленный оператор&lt;/a&gt; может быть оценен во второй раз с использованием новых значений.</target>
        </trans-unit>
        <trans-unit id="8de5c77745aab508a14fca7f3c047cc5a41b83c4" translate="yes" xml:space="preserve">
          <source>It is not impossible to find the descendents of a check-in in Git. It is merely difficult. For example, there is a &lt;a href=&quot;https://stackoverflow.com/questions/27960605/find-all-the-direct-descendants-of-a-given-commit#27962018&quot;&gt;stackoverflow page&lt;/a&gt; showing the command sequence for finding the descendents of a check-in in unix:</source>
          <target state="translated">В Git возможно найти потомков регистрации. Это просто сложно. Например, есть &lt;a href=&quot;https://stackoverflow.com/questions/27960605/find-all-the-direct-descendants-of-a-given-commit#27962018&quot;&gt;страница stackoverflow,&lt;/a&gt; показывающая последовательность команд для поиска потомков регистрации в unix:</target>
        </trans-unit>
        <trans-unit id="968af02ea707c660eea2edbc719717453c1c09b4" translate="yes" xml:space="preserve">
          <source>It is not necessary for every column of an index to appear in a WHERE clause term in order for that index to be used. But there cannot be gaps in the columns of the index that are used. Thus for the example index above, if there is no WHERE clause term that constraints column c, then terms that constrain columns a and b can be used with the index but not terms that constraint columns d through z. Similarly, index columns will not normally be used (for indexing purposes) if they are to the right of a column that is constrained only by inequalities. (See the &lt;a href=&quot;optoverview#skipscan&quot;&gt;skip-scan optimization&lt;/a&gt; below for the exception.)</source>
          <target state="translated">Необязательно, чтобы каждый столбец индекса появлялся в термине предложения WHERE, чтобы этот индекс можно было использовать. Но в используемых столбцах индекса не может быть пробелов. Таким образом, для приведенного выше примера индекса, если нет термина предложения WHERE, ограничивающего столбец c, тогда термины, которые ограничивают столбцы a и b, могут использоваться с индексом, но не термины, которые ограничивают столбцы с d по z. Точно так же столбцы индекса обычно не используются (для целей индексации), если они находятся справа от столбца, который ограничен только неравенствами. (Для исключения см. &lt;a href=&quot;optoverview#skipscan&quot;&gt;Оптимизацию пропуска сканирования&lt;/a&gt; ниже.)</target>
        </trans-unit>
        <trans-unit id="2de5ebb77ad1ee7c30b198dc81894f078e037a10" translate="yes" xml:space="preserve">
          <source>It is not necessary for every column of an index to appear in a WHERE clause term in order for that index to be used. However, there cannot be gaps in the columns of the index that are used. Thus for the example index above, if there is no WHERE clause term that constrains column c, then terms that constrain columns a and b can be used with the index but not terms that constrain columns d through z. Similarly, index columns will not normally be used (for indexing purposes) if they are to the right of a column that is constrained only by inequalities. (See the &lt;a href=&quot;optoverview#skipscan&quot;&gt;skip-scan optimization&lt;/a&gt; below for the exception.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91c4a366eb8b7036569a617f444657bfe2829b75" translate="yes" xml:space="preserve">
          <source>It is not necessary to delete a session object after extracting a changeset or patchset from it. It can be left attached to the database handle and will continue monitoring for changes on the configured tables as before. However, if &lt;a href=&quot;session/sqlite3session_changeset&quot;&gt;sqlite3session_changeset()&lt;/a&gt; or &lt;a href=&quot;session/sqlite3session_patchset&quot;&gt;sqlite3session_patchset()&lt;/a&gt; is called a second time on a session object, the changeset or patchset will contain &lt;em&gt;all&lt;/em&gt; changes that have taken place on the connection since the session was created. In other words, a session object is not reset or zeroed by a call to sqlite3session_changeset() or sqlite3session_patchset().</source>
          <target state="translated">Нет необходимости удалять объект сеанса после извлечения из него набора изменений или патчей. Его можно оставить прикрепленным к дескриптору базы данных, и он будет продолжать отслеживать изменения в настроенных таблицах, как и раньше. Однако, если &lt;a href=&quot;session/sqlite3session_changeset&quot;&gt;sqlite3session_changeset ()&lt;/a&gt; или &lt;a href=&quot;session/sqlite3session_patchset&quot;&gt;sqlite3session_patchset ()&lt;/a&gt; вызывается второй раз для объекта сеанса, набор изменений или набор исправлений будет содержать &lt;em&gt;все&lt;/em&gt; изменения, которые произошли в соединении с момента создания сеанса. Другими словами, объект сеанса не сбрасывается или не обнуляется вызовом sqlite3session_changeset () или sqlite3session_patchset ().</target>
        </trans-unit>
        <trans-unit id="670d42dfe457729d9823abd17b04a227c0f7995a" translate="yes" xml:space="preserve">
          <source>It is not necessary to increment the change counter in the database header for transactions after the first transaction. This will often save a write of page one to both the rollback journal and the main database file.</source>
          <target state="translated">Нет необходимости увеличивать счетчик изменений в заголовке БД для транзакций после первой транзакции.Часто это позволяет сохранить запись первой страницы как в журнал отката,так и в основной файл БД.</target>
        </trans-unit>
        <trans-unit id="2403c6f4220d7ab7621d951d5ca316ce8bb167ec" translate="yes" xml:space="preserve">
          <source>It is not necessary to retrieve data in the format specify by sqlite3_column_type(). If a different format is requested, the data is converted automatically.</source>
          <target state="translated">Нет необходимости извлекать данные в формате,указанном функцией sqlite3_column_type().Если запрашивается другой формат,данные преобразуются автоматически.</target>
        </trans-unit>
        <trans-unit id="900bad887efaa153c1a2b75294545475e3b1d504" translate="yes" xml:space="preserve">
          <source>It is not possible for a single FTS query to return rows with different languageid values. The results of adding WHERE clauses that use other operators (e.g. lid!=5, or lid&amp;lt;=5) are undefined.</source>
          <target state="translated">Один запрос FTS не может возвращать строки с разными значениями languageid. Результаты добавления предложений WHERE, использующих другие операторы (например, lid! = 5 или lid &amp;lt;= 5), не определены.</target>
        </trans-unit>
        <trans-unit id="0859fe8615c2125c6e219976b0af5affb3b3243b" translate="yes" xml:space="preserve">
          <source>It is not possible to &lt;a href=&quot;lang_altertable#altertabaddcol&quot;&gt;ALTER TABLE ADD COLUMN&lt;/a&gt; a STORED column. One can add a VIRTUAL column, however.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d7041428ac37cb2fe5a20d78347fe7eb6acfbe1" translate="yes" xml:space="preserve">
          <source>It is not possible to UPDATE or DELETE a row stored in a contentless FTS4 table. Attempting to do so is an error.</source>
          <target state="translated">Невозможно ОБНАРУЖИВАТЬ или УДАЛИТЬ строку,хранящуюся в бесконтактной таблице FTS4.Попытка сделать это является ошибкой.</target>
        </trans-unit>
        <trans-unit id="9e4665d3e6caf2e43eb0161671eab0b61b62c13a" translate="yes" xml:space="preserve">
          <source>It is not possible to change the &lt;a href=&quot;pragma#pragma_page_size&quot;&gt;page_size&lt;/a&gt; after entering WAL mode, either on an empty database or by using &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; or by restoring from a backup using the &lt;a href=&quot;backup&quot;&gt;backup API&lt;/a&gt;. You must be in a rollback journal mode to change the page size.</source>
          <target state="translated">Невозможно изменить &lt;a href=&quot;pragma#pragma_page_size&quot;&gt;page_size&lt;/a&gt; после входа в режим WAL ни в пустой базе данных, ни с помощью &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM,&lt;/a&gt; ни путем восстановления из резервной копии с помощью &lt;a href=&quot;backup&quot;&gt;API резервного копирования&lt;/a&gt; . Чтобы изменить размер страницы, вы должны находиться в режиме журнала отката.</target>
        </trans-unit>
        <trans-unit id="deaab8f44371f477a4e7e55d31601e0d0d6a03fb" translate="yes" xml:space="preserve">
          <source>It is not possible to enable or disable foreign key constraints in the middle of a &lt;a href=&quot;lang_transaction&quot;&gt;multi-statement transaction&lt;/a&gt; (when SQLite is not in &lt;a href=&quot;c3ref/get_autocommit&quot;&gt;autocommit mode&lt;/a&gt;). Attempting to do so does not return an error; it simply has no effect.</source>
          <target state="translated">Невозможно включить или отключить ограничения внешнего ключа в середине &lt;a href=&quot;lang_transaction&quot;&gt;транзакции&lt;/a&gt; с несколькими операторами (когда SQLite не находится в &lt;a href=&quot;c3ref/get_autocommit&quot;&gt;режиме автоматической фиксации&lt;/a&gt; ). Попытка сделать это не вернет ошибку; это просто не действует.</target>
        </trans-unit>
        <trans-unit id="59d7023d400b2c4a42c25e47c1d1dae5bdb83625" translate="yes" xml:space="preserve">
          <source>It is not possible to use the &quot;ALTER TABLE ... ADD COLUMN&quot; syntax to add a column that includes a REFERENCES clause, unless the default value of the new column is NULL. Attempting to do so returns an error.</source>
          <target state="translated">Невозможно использовать &quot;АЛЬТЕР-ТАБЛИЦУ&quot; ...ADD COLUMN&quot; для добавления столбца,включающего пункт REFERENCES,если только значение по умолчанию нового столбца не равно NULL.Попытка сделать это возвращает ошибку.</target>
        </trans-unit>
        <trans-unit id="912f58b54e2d4f955145072d5727d208f46d87cf" translate="yes" xml:space="preserve">
          <source>It is not safe to read or modify this variable in more than one thread at a time. It is not safe to read or modify this variable if a &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; is being used at the same time in a separate thread. It is intended that this variable be set once as part of process initialization and before any SQLite interface routines have been called and that this variable remain unchanged thereafter.</source>
          <target state="translated">Прочитать или изменить эту переменную более чем в одном потоке одновременно небезопасно. Прочитать или изменить эту переменную небезопасно, если &lt;a href=&quot;#sqlite3&quot;&gt;соединение&lt;/a&gt; с базой данных используется одновременно в отдельном потоке. Предполагается, что эта переменная будет установлена ​​один раз как часть инициализации процесса и до того, как будут вызваны какие-либо процедуры интерфейса SQLite, и что эта переменная после этого останется неизменной.</target>
        </trans-unit>
        <trans-unit id="903cea61d0db784ec27805bae69d5dea09532edb" translate="yes" xml:space="preserve">
          <source>It is not safe to read or modify this variable in more than one thread at a time. It is not safe to read or modify this variable if a &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; is being used at the same time in a separate thread. It is intended that this variable be set once as part of process initialization and before any SQLite interface routines have been called and that this variable remain unchanged thereafter.</source>
          <target state="translated">Прочитать или изменить эту переменную более чем в одном потоке одновременно небезопасно. Прочитать или изменить эту переменную небезопасно, если &lt;a href=&quot;sqlite3&quot;&gt;соединение&lt;/a&gt; с базой данных используется одновременно в отдельном потоке. Предполагается, что эта переменная будет установлена ​​один раз как часть инициализации процесса и до того, как будут вызваны какие-либо процедуры интерфейса SQLite, и что эта переменная после этого останется неизменной.</target>
        </trans-unit>
        <trans-unit id="159cf71be6e4a6830ae2567917f78113abca0955" translate="yes" xml:space="preserve">
          <source>It is ok to make multiple entries for the same word as long as each entry has a different soundslike value. Note that if no soundslike value is specified, the soundslike defaults to the word itself.</source>
          <target state="translated">Можно делать несколько записей для одного и того же слова,если каждая запись имеет разное звуковое значение.Обратите внимание,что если звуковое значение не указано,звуковое значение по умолчанию будет соответствовать самому слову.</target>
        </trans-unit>
        <trans-unit id="42b6da3d325a27b4a54e5028535caa1fb0d83d7a" translate="yes" xml:space="preserve">
          <source>It is particularly important to use an entry point name that is based on the extension filename, rather than the generic &quot;sqlite3_extension_init&quot; entry point name, if you will be statically linking two or more extensions. If you use the generic name, there will be multiple definitions of the same symbol and the link will fail.</source>
          <target state="translated">Особенно важно использовать имя точки входа,которое основано на имени файла расширения,а не на общем имени точки входа &quot;sqlite3_extension_init&quot;,если вы будете статически связывать два или более расширения.Если вы используете общее имя,то будет несколько определений одного и того же символа,и ссылка будет неудачной.</target>
        </trans-unit>
        <trans-unit id="1f5372992ab68655b726354d1de85f6b9510df2c" translate="yes" xml:space="preserve">
          <source>It is permitted to register multiple implementations of the same functions with the same name but with either differing numbers of arguments or differing preferred text encodings. SQLite will use the implementation that most closely matches the way in which the SQL function is used. A function implementation with a non-negative nArg parameter is a better match than a function implementation with a negative nArg. A function where the preferred text encoding matches the database encoding is a better match than a function where the encoding is different. A function where the encoding difference is between UTF16le and UTF16be is a closer match than a function where the encoding difference is between UTF8 and UTF16.</source>
          <target state="translated">Разрешается регистрировать несколько реализаций одних и тех же функций с одним и тем же именем,но либо с разным количеством аргументов,либо с разными предпочтительными текстовыми кодировками.SQLite будет использовать реализацию,наиболее точно соответствующую способу использования функции SQL.Реализация функции с неотрицательным параметром nArg лучше подходит,чем реализация функции с отрицательным параметром nArg.Функция,в которой предпочитаемая текстовая кодировка совпадает с кодировкой БД,лучше подходит,чем функция,в которой кодировка отличается.Функция,где разница кодировок между UTF16le и UTF16be ближе,чем функция,где разница кодировок между UTF8 и UTF16.</target>
        </trans-unit>
        <trans-unit id="d335c80330cdb9262d358bd293d73594c1829762" translate="yes" xml:space="preserve">
          <source>It is possible for the library compile-time C preprocessor symbol &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; to override this pragma setting. The following table summarizes the interaction of the &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; preprocessor macro and the temp_store pragma:</source>
          <target state="translated">Символ препроцессора C времени компиляции &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; может переопределить эту настройку прагмы . В следующей таблице суммировано взаимодействие &lt;a href=&quot;compile#temp_store&quot;&gt;макроса&lt;/a&gt; препроцессора SQLITE_TEMP_STORE и прагмы temp_store:</target>
        </trans-unit>
        <trans-unit id="882d45108ae3506a475e868a2ed67d0f5c2e5629" translate="yes" xml:space="preserve">
          <source>It is possible that future enhancements to the prover might enable it to recognize that NULL inputs to certain built-in functions always result in a NULL answer. But not all built-in functions have that property (for example &lt;a href=&quot;lang_corefunc#coalesce&quot;&gt;coalesce()&lt;/a&gt;) and, of course, the prover will never be able to reason about &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="105eb1a524704db6ebed7c523dd9971899853505" translate="yes" xml:space="preserve">
          <source>It is possible that future enhancements to the prover might enable it to recognize that NULL inputs to certain built-in functions always result in a NULL answer. But not all built-in functions have that property (for example &lt;a href=&quot;lang_corefunc#coalesce&quot;&gt;coalesce()&lt;/a&gt;) and, of course, the prover will never be able to reason about &lt;a href=&quot;c3ref/create_function&quot;&gt;application-defined SQL functions&lt;/a&gt;.</source>
          <target state="translated">Возможно, что будущие усовершенствования программы доказательства могут позволить ему распознавать, что входные данные NULL для определенных встроенных функций всегда приводят к ответу NULL. Но не все встроенные функции обладают этим свойством (например, &lt;a href=&quot;lang_corefunc#coalesce&quot;&gt;coalesce ()&lt;/a&gt; ), и, конечно же, доказывающий никогда не сможет рассуждать о &lt;a href=&quot;c3ref/create_function&quot;&gt;функциях SQL, определяемых приложением&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="67a29506bbefedd972fbd5d580cbf8d20601e4a4" translate="yes" xml:space="preserve">
          <source>It is possible that future enhancements to the prover might enable it to recognize that NULL inputs to certain built-in functions always result in a NULL answer. However, not all built-in functions have that property (for example &lt;a href=&quot;lang_corefunc#coalesce&quot;&gt;coalesce()&lt;/a&gt;) and, of course, the prover will never be able to reason about &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2be5eee10a74ce784db26ece955361d8533b48cb" translate="yes" xml:space="preserve">
          <source>It is possible to build a special &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt; that will work with a predetermined set of SQLITE_OMIT_... options. Instructions for doing so can be found with the &lt;a href=&quot;compile#omitfeatures&quot;&gt;SQLITE_OMIT_... documentation&lt;/a&gt;.</source>
          <target state="translated">Можно создать специальное &lt;a href=&quot;amalgamation&quot;&gt;объединение,&lt;/a&gt; которое будет работать с заранее определенным набором параметров SQLITE_OMIT _.... Инструкции по этим вопросам можно найти с &lt;a href=&quot;compile#omitfeatures&quot;&gt;SQLITE_OMIT _... документации&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="321373a36254200d34f2e6be79e9dd835a4c4ba3" translate="yes" xml:space="preserve">
          <source>It is possible to create multiple session objects attached to a single database handle.</source>
          <target state="translated">Можно создать несколько объектов сеанса,прикрепленных к одному дескриптору базы данных.</target>
        </trans-unit>
        <trans-unit id="bed5d040f0bed9644c8d2600cb5ecf6e91531170" translate="yes" xml:space="preserve">
          <source>It is possible to extend custom or pile-of-files formats too, of course, but doing is often much harder. If indices are added, then all application code that changes the corresponding tables must be located and modified to keep those indices up-to-date. If columns are added, then all application code that accesses the corresponding table must be located and modified to take into account the new columns.</source>
          <target state="translated">Конечно,можно расширить и пользовательский формат или формат &quot;кучи файлов&quot;,но зачастую это гораздо сложнее сделать.Если добавляются индексы,то весь код приложения,который изменяет соответствующие таблицы,должен быть расположен и модифицирован,чтобы поддерживать эти индексы в актуальном состоянии.Если добавляются столбцы,то весь код приложения,получающего доступ к соответствующей таблице,должен быть расположен и изменен с учетом новых столбцов.</target>
        </trans-unit>
        <trans-unit id="e6a04c27b0773734dfa33829ac44458f0f513a43" translate="yes" xml:space="preserve">
          <source>It is possible to have an aggregate function with the same name as a simple function, as long as the number of arguments for the two forms of the function are different. For example, the &lt;a href=&quot;lang_aggfunc#maxggunc&quot;&gt;max()&lt;/a&gt; function with a single argument is an aggregate and the &lt;a href=&quot;lang_corefunc#maxoreunc&quot;&gt;max()&lt;/a&gt; function with two or more arguments is a simple function. Aggregate functions can usually also be used as window functions.</source>
          <target state="translated">Возможно иметь агрегатную функцию с тем же именем, что и у простой функции, если количество аргументов для двух форм функции различно. Например, функция &lt;a href=&quot;lang_aggfunc#maxggunc&quot;&gt;max ()&lt;/a&gt; с одним аргументом является агрегатом, а функция &lt;a href=&quot;lang_corefunc#maxoreunc&quot;&gt;max ()&lt;/a&gt; с двумя или более аргументами является простой функцией. Агрегатные функции обычно также могут использоваться как оконные.</target>
        </trans-unit>
        <trans-unit id="79fc85e42448050747bff9c78bdebc62767b73c0" translate="yes" xml:space="preserve">
          <source>It is possible to make SQLite treat NULLs as distinct for the purposes of the SELECT DISTINCT and UNION. To do so, one should change the value of the NULL_ALWAYS_DISTINCT #define in the &lt;code&gt;sqliteInt.h&lt;/code&gt; source file and recompile.</source>
          <target state="translated">Можно заставить SQLite обрабатывать NULL как разные для целей SELECT DISTINCT и UNION. Для этого необходимо изменить значение NULL_ALWAYS_DISTINCT #define в исходном файле &lt;code&gt;sqliteInt.h&lt;/code&gt; и перекомпилировать.</target>
        </trans-unit>
        <trans-unit id="ef8babc1f36de58a996ade599caa2a6556653b1a" translate="yes" xml:space="preserve">
          <source>It is possible to tell whether or not the 'merge' command found any b-trees to merge together by checking the value returned by the &lt;a href=&quot;c3ref/total_changes&quot;&gt;sqlite3_total_changes()&lt;/a&gt; API before and after the command is executed. If the difference between the two values is 2 or greater, then work was performed. If the difference is less than 2, then the 'merge' command was a no-op. In this case there is no reason to execute the same 'merge' command again, at least until after the FTS table is next updated.</source>
          <target state="translated">Можно определить, нашла ли команда 'merge' какие-либо b-деревья для слияния, проверив значение, возвращаемое API &lt;a href=&quot;c3ref/total_changes&quot;&gt;sqlite3_total_changes ()&lt;/a&gt; до и после выполнения команды. Если разница между двумя значениями составляет 2 или больше, значит работа выполнена. Если разница меньше 2, то команда &amp;laquo;слияние&amp;raquo; не выполнялась. В этом случае нет причин для повторного выполнения той же команды &amp;laquo;слияния&amp;raquo;, по крайней мере, до следующего обновления таблицы FTS.</target>
        </trans-unit>
        <trans-unit id="e63e80c9bba9974f9e6774ae97788b65cf7107ad" translate="yes" xml:space="preserve">
          <source>It is possible to write into the &quot;t2&quot; table, thus changing the content of the index. But doing so will get the &quot;t1bc&quot; index out of synchronization with its parent table &quot;t1&quot;. An out-of-sync index can result in incorrect query results.</source>
          <target state="translated">Можно записать в таблицу &quot;t2&quot;,тем самым изменив содержание индекса.Но при этом индекс &quot;t1bc&quot; выйдет из синхронизации с его родительской таблицей &quot;t1&quot;.Несинхронизированный индекс может привести к некорректным результатам запроса.</target>
        </trans-unit>
        <trans-unit id="0822da1b538a191177f07ef1dc3b36f0cff1be87" translate="yes" xml:space="preserve">
          <source>It is recommended that applications respond to the errors listed above by explicitly issuing a ROLLBACK command. If the transaction has already been rolled back automatically by the error response, then the ROLLBACK command will fail with an error, but no harm is caused by this.</source>
          <target state="translated">Рекомендуется,чтобы приложения отвечали на перечисленные выше ошибки явным выпуском команды ROLLBACK.Если транзакция уже откатилась автоматически в ответ на ошибку,то команда ROLLBACK не будет выполнена с ошибкой,но это не причинит никакого вреда.</target>
        </trans-unit>
        <trans-unit id="7b7eb3618faa363b4bb6cb76587e213a07280f4c" translate="yes" xml:space="preserve">
          <source>It is safe to call this routine from a thread different from the thread that is currently running the database operation. But it is not safe to call this routine with a &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; that is closed or might close before sqlite3_interrupt() returns.</source>
          <target state="translated">Эту процедуру можно безопасно вызывать из потока, отличного от потока, в котором в данный момент выполняется операция с базой данных. Но небезопасно вызывать эту процедуру при закрытом или закрытом &lt;a href=&quot;#sqlite3&quot;&gt;соединении&lt;/a&gt; с базой данных до возврата sqlite3_interrupt ().</target>
        </trans-unit>
        <trans-unit id="0d70d917087b8b111a765ae7a55cfbd2640b316e" translate="yes" xml:space="preserve">
          <source>It is safe to call this routine from a thread different from the thread that is currently running the database operation. But it is not safe to call this routine with a &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; that is closed or might close before sqlite3_interrupt() returns.</source>
          <target state="translated">Эту процедуру можно безопасно вызывать из потока, отличного от потока, в котором в данный момент выполняется операция с базой данных. Но небезопасно вызывать эту процедуру при закрытом или закрытом &lt;a href=&quot;sqlite3&quot;&gt;соединении&lt;/a&gt; с базой данных до возврата sqlite3_interrupt ().</target>
        </trans-unit>
        <trans-unit id="d9e98c95444e8fd3d643f309806f8f5b2d312406" translate="yes" xml:space="preserve">
          <source>It is safe to execute SQL statements, including those that write to the table that the callback related to, from within the xConflict callback. This can be used to further customize the application's conflict resolution strategy.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7155cc55f906067b466a3957abc2b2fa5ca703ab" translate="yes" xml:space="preserve">
          <source>It is safe to execute SQL statements, including those that write to the table that the callback related to, from within the xConflict callback. This can be used to further customize the applications conflict resolution strategy.</source>
          <target state="translated">Безопасно выполнять SQL-операторы,в том числе и те,которые пишут в таблицу,с которой связан обратный вызов,из xConflict callback.Это может быть использовано для дальнейшей настройки стратегии разрешения конфликтов приложений.</target>
        </trans-unit>
        <trans-unit id="33153f14bd397b5e62d91fe18b2589aae1781966" translate="yes" xml:space="preserve">
          <source>It is sometimes convenient for SQLite extensions to communicate non-SQL values between subcomponents or between the extension and the application. Some examples:</source>
          <target state="translated">Для расширений SQLite иногда удобно обмениваться не-SQL-значениями между подкомпонентами или между расширением и приложением.Некоторые примеры:</target>
        </trans-unit>
        <trans-unit id="4e37312abd7d96cc7759f842b46f93a1a662f8a0" translate="yes" xml:space="preserve">
          <source>It is still the responsibility of the user to ensure that the contents of an external content FTS5 table are kept up to date with the content table. One way to do this is with triggers. For example:</source>
          <target state="translated">Пользователь по-прежнему несет ответственность за то,чтобы содержание таблицы внешнего контента FTS5 было актуальным.Один из способов сделать это-с помощью триггеров.Например:</target>
        </trans-unit>
        <trans-unit id="9c7272134156136dee6648bc42ced66fabf0b75c" translate="yes" xml:space="preserve">
          <source>It is the nature of the Guttman R-Tree algorithm that any write might radically restructure the tree, and in the process change the scan order of the nodes. For this reason, it is not generally possible to modify the R-Tree in the middle of a query of the R-Tree. Attempts to do so will fail with a &lt;a href=&quot;rescode#locked&quot;&gt;SQLITE_LOCKED&lt;/a&gt; &quot;database table is locked&quot; error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5653d5d90f75b604cccae96a448a1866fdfa38fe" translate="yes" xml:space="preserve">
          <source>It is the responsibility of the caller to eventually call sqlite3_free() on the *ppOut pointer to free the buffer allocation following a successful call to this function.</source>
          <target state="translated">В обязанности вызывающего абонента входит,в конечном счете,вызов sqlite3_free()по указателю *ppOut,чтобы освободить выделение буфера после успешного вызова этой функции.</target>
        </trans-unit>
        <trans-unit id="ea70438336584a95d4e17716f1df0d6b713aeb3b" translate="yes" xml:space="preserve">
          <source>It is the responsibility of the caller to eventually destroy the iterator by passing it to &lt;a href=&quot;#sqlite3changeset_finalize&quot;&gt;sqlite3changeset_finalize()&lt;/a&gt;. The buffer containing the changeset (pChangeset) must remain valid until after the iterator is destroyed.</source>
          <target state="translated">Вызывающий &lt;a href=&quot;#sqlite3changeset_finalize&quot;&gt;объект обязан&lt;/a&gt; в конечном итоге уничтожить итератор, передав его в sqlite3changeset_finalize () . Буфер, содержащий набор изменений (pChangeset), должен оставаться действительным до тех пор, пока итератор не будет уничтожен.</target>
        </trans-unit>
        <trans-unit id="f0493c91af19ce8153b8e56f3f8a534dd5019c91" translate="yes" xml:space="preserve">
          <source>It is the responsibility of the caller to eventually destroy the iterator by passing it to &lt;a href=&quot;sqlite3changeset_finalize&quot;&gt;sqlite3changeset_finalize()&lt;/a&gt;. The buffer containing the changeset (pChangeset) must remain valid until after the iterator is destroyed.</source>
          <target state="translated">Вызывающий &lt;a href=&quot;sqlite3changeset_finalize&quot;&gt;объект обязан&lt;/a&gt; в конечном итоге уничтожить итератор, передав его в sqlite3changeset_finalize () . Буфер, содержащий набор изменений (pChangeset), должен оставаться действительным до тех пор, пока итератор не будет уничтожен.</target>
        </trans-unit>
        <trans-unit id="6d23d845a723659b2b2994a8ad4c9862067cda40" translate="yes" xml:space="preserve">
          <source>It is true that applications sometimes import complete binary SQLite database files from untrusted sources, and such imports could present a possible attack vector. However, those code paths in SQLite are limited and are extremely well tested. And pre-validation routines are available to applications that want to read untrusted databases that can help detect possible attacks prior to use.</source>
          <target state="translated">Правда,иногда приложения импортируют полные бинарные файлы базы данных SQLite из недоверенных источников,и такой импорт может представлять собой возможный вектор атаки.Однако такие пути кода в SQLite ограничены и очень хорошо протестированы.А для приложений,которые хотят читать недоверенные базы данных,доступны процедуры предварительной проверки,которые могут помочь обнаружить возможные атаки до их использования.</target>
        </trans-unit>
        <trans-unit id="c6122ba39afe0e09e2d2af761ca27152501399d2" translate="yes" xml:space="preserve">
          <source>It is usually an error to attempt to create a new table in a database that already contains a table, index or view of the same name. However, if the &quot;IF NOT EXISTS&quot; clause is specified as part of the CREATE TABLE statement and a table or view of the same name already exists, the CREATE TABLE command simply has no effect (and no error message is returned). An error is still returned if the table cannot be created because of an existing index, even if the &quot;IF NOT EXISTS&quot; clause is specified.</source>
          <target state="translated">Как правило,это ошибка при попытке создать новую таблицу в базе данных,которая уже содержит таблицу,индекс или представление с тем же именем.Однако,если в операторе CREATE TABLE указано &quot;IF NOT EXISTS&quot; и таблица или представление с таким же именем уже существует,команда CREATE TABLE просто не имеет никакого эффекта (и сообщение об ошибке не возвращается).Ошибка все равно возвращается,если таблица не может быть создана из-за существующего индекса,даже если указано выражение &quot;IF NOT EXISTS&quot;.</target>
        </trans-unit>
        <trans-unit id="6955fa966a557f5231f3a39e108f89afbdbb1b83" translate="yes" xml:space="preserve">
          <source>It may not be used on a database that contains &lt;a href=&quot;expridx&quot;&gt;indexes on expressions&lt;/a&gt;.</source>
          <target state="translated">Его нельзя использовать в базе данных, содержащей &lt;a href=&quot;expridx&quot;&gt;индексы по выражениям&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="16a2200cb76f9664274f3ef9da8045211e14cc43" translate="yes" xml:space="preserve">
          <source>It might be that there are conflicts in the merge. Conflicts occur when the same line of code was changed in different ways between circles (1) and (4) versus circles (2) and (3). The merge command will announce any conflicts and will include both versions of the conflicting lines in the output. You will need to bring up the files that contain conflicts and manually resolve the conflicts.</source>
          <target state="translated">Возможно,в слиянии есть конфликты.Конфликты возникают,когда одна и та же строка кода по-разному меняется между кругами (1)и (4)по сравнению с кругами (2)и (3).Команда слияния объявит о любых конфликтах и включит в вывод обе версии конфликтующих строк.Вам нужно будет вывести на экран файлы,содержащие конфликты,и разрешить их вручную.</target>
        </trans-unit>
        <trans-unit id="129a00b2ad750693913d2844d8acb7e806afdd09" translate="yes" xml:space="preserve">
          <source>It must not be possible to make the LIKE or GLOB operator true by having a numeric value (instead of a string or blob) on the left-hand side. This means that either:</source>
          <target state="translated">Нельзя сделать оператор LIKE или GLOB истинным,имея слева числовое значение (вместо строки или капли).Это означает,что и это тоже:</target>
        </trans-unit>
        <trans-unit id="48d86628c63409da486bd0d69fb891667a6d8475" translate="yes" xml:space="preserve">
          <source>It never hurts to run the VACUUM, even if you don't need it. If the database is in WAL mode, you should shutdown and reopen all database connections before continuing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e56780a95b18eed6f05e0be25053224b3c52ac99" translate="yes" xml:space="preserve">
          <source>It was necessary to move to version 3.0 to implement these features because each requires incompatible changes to the database file format. Other incompatible changes, such as a cleanup of the API, were introduced at the same time under the theory that it is best to get your incompatible changes out of the way all at once.</source>
          <target state="translated">Для реализации этих возможностей необходимо было перейти на версию 3.0,так как каждая из них требует несовместимых изменений формата файла базы данных.Другие несовместимые изменения,такие как очистка API,были введены одновременно с теорией о том,что лучше всего убрать несовместимые изменения с пути сразу.</target>
        </trans-unit>
        <trans-unit id="8d41777ca525f229dab6b56dd5c34598aff8efa5" translate="yes" xml:space="preserve">
          <source>It works with unicode (UTF8) text.</source>
          <target state="translated">Работает с текстом в кодировке Unicode (UTF8).</target>
        </trans-unit>
        <trans-unit id="829d920a492c6126eef1531c8e8c0e1ab7033bd1" translate="yes" xml:space="preserve">
          <source>Its master journal exists or the master journal name is an empty string, and</source>
          <target state="translated">Его главный журнал существует или имя главного журнала-пустая строка,и</target>
        </trans-unit>
        <trans-unit id="a9d92a1b4a228c7e648d8125ef5d3c71b3cd4ff7" translate="yes" xml:space="preserve">
          <source>Its size is greater than 512 bytes, and</source>
          <target state="translated">Его размер больше 512 байт,и</target>
        </trans-unit>
        <trans-unit id="0239a4728421bae8f8eeba1f3844a6c5e5e3d81b" translate="yes" xml:space="preserve">
          <source>Its super-journal exists or the super-journal name is an empty string, and</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73bd910d330560ea1012376a486871434fb0c82d" translate="yes" xml:space="preserve">
          <source>J. M. Robson. &quot;Bounds for Some Functions Concerning Dynamic Storage Allocation&quot;.</source>
          <target state="translated">J.М.Робсон.&quot;Ограничения для некоторых функций относительно динамического распределения хранилищ&quot;.</target>
        </trans-unit>
        <trans-unit id="9a3f6528f2606d1ed81f1e9f85b624a26b98cbbe" translate="yes" xml:space="preserve">
          <source>JOIN</source>
          <target state="translated">JOIN</target>
        </trans-unit>
        <trans-unit id="031a4e76f0b39d0df073d934da5fc48da8d737e5" translate="yes" xml:space="preserve">
          <source>JSON</source>
          <target state="translated">JSON</target>
        </trans-unit>
        <trans-unit id="935b885e280c10afb46d2bf45f85bbea09bc94ce" translate="yes" xml:space="preserve">
          <source>JSON support</source>
          <target state="translated">JSON поддержка</target>
        </trans-unit>
        <trans-unit id="69a65023a22e8f6d2ee1c6c6ee36c64ccb6d5c6d" translate="yes" xml:space="preserve">
          <source>Join order</source>
          <target state="translated">Присоединиться к заказу</target>
        </trans-unit>
        <trans-unit id="5b92551545cdfc2e412cb3b6272639906036d3da" translate="yes" xml:space="preserve">
          <source>Join reordering is automatic and usually works well enough that programmers do not have to think about it, especially if &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; has been used to gather statistics about the available indexes, though occasionally some hints from the programmer are needed. Consider, for example, the following schema:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63acacbd536ebc7829ae48a83492249201168016" translate="yes" xml:space="preserve">
          <source>Join reordering is automatic and usually works well enough that programmers do not have to think about it, especially if &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; has been used to gather statistics about the available indices. But occasionally some hints from the programmer are needed. Consider, for example, the following schema:</source>
          <target state="translated">Изменение порядка объединения происходит автоматически и обычно работает достаточно хорошо, чтобы программистам не приходилось думать об этом, особенно если &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; использовался для сбора статистики о доступных индексах. Но иногда нужны подсказки от программиста. Рассмотрим, например, следующую схему:</target>
        </trans-unit>
        <trans-unit id="36cb6826dbbbacc9f0915d9e44ccb82925b04c72" translate="yes" xml:space="preserve">
          <source>Joins</source>
          <target state="translated">Joins</target>
        </trans-unit>
        <trans-unit id="742ad08bca9c2e1be08d58aae42e6201c809dcf9" translate="yes" xml:space="preserve">
          <source>Journal File Format</source>
          <target state="translated">Формат файла журнала</target>
        </trans-unit>
        <trans-unit id="debc03f25ef5600d2ed4edf18b01b3412bb71c87" translate="yes" xml:space="preserve">
          <source>Journal Header Format</source>
          <target state="translated">Формат заголовка журнала</target>
        </trans-unit>
        <trans-unit id="ccdedfc7a4a23f259c6823eed7a5e93d7a6e430f" translate="yes" xml:space="preserve">
          <source>Journal Record Format</source>
          <target state="translated">Формат журнала Формат записи</target>
        </trans-unit>
        <trans-unit id="683ff0cc3706704c295b1d1835a7e2e4c3a2a6b7" translate="yes" xml:space="preserve">
          <source>Journal of the Association for Computing Machinery</source>
          <target state="translated">Журнал Ассоциации компьютерной техники</target>
        </trans-unit>
        <trans-unit id="769726f4101068333430cd9eee0a56b7dfd75235" translate="yes" xml:space="preserve">
          <source>JournalMode</source>
          <target state="translated">JournalMode</target>
        </trans-unit>
        <trans-unit id="c0e70f1bd285ac28ec38cf9261dd9cf6df3840dd" translate="yes" xml:space="preserve">
          <source>Journalling a Database Page</source>
          <target state="translated">Регистрация страницы базы данных</target>
        </trans-unit>
        <trans-unit id="b576bd921c8bd5cb6e5720fc3c6797d3e02e8d08" translate="yes" xml:space="preserve">
          <source>Journalling a page</source>
          <target state="translated">Регистрация страницы</target>
        </trans-unit>
        <trans-unit id="84e304128c1076094ba7ee02aeb09745e71eaf53" translate="yes" xml:space="preserve">
          <source>Julian day number</source>
          <target state="translated">номер дня Юлиана</target>
        </trans-unit>
        <trans-unit id="1eba140fdd9c6860a1730c408e3064aa417ca2a3" translate="yes" xml:space="preserve">
          <source>Jump</source>
          <target state="translated">Jump</target>
        </trans-unit>
        <trans-unit id="5d84018241481efa31572e7a64ddf20102d5a735" translate="yes" xml:space="preserve">
          <source>Jump to P2 if the value in register P1 is False. The value is considered false if it has a numeric value of zero. If the value in P1 is NULL then take the jump if and only if P3 is non-zero.</source>
          <target state="translated">Перейдите к P2,если значение в регистре P1 является False.Значение считается ложным,если оно имеет числовое значение ноль.Если значение в P1 равно NULL,то прыжок выполняется,если и только если P3 ненулевое.</target>
        </trans-unit>
        <trans-unit id="c02affea77793c1c3281caf3fff7c025052fcd28" translate="yes" xml:space="preserve">
          <source>Jump to P2 if the value in register P1 is NULL.</source>
          <target state="translated">Переходите к P2,если значение в регистре P1 равно NULL.</target>
        </trans-unit>
        <trans-unit id="9d04284895be3aad627f0d99db148ecf0772d61d" translate="yes" xml:space="preserve">
          <source>Jump to P2 if the value in register P1 is not NULL.</source>
          <target state="translated">Переходите к P2,если значение в регистре P1 не NULL.</target>
        </trans-unit>
        <trans-unit id="38d677f93cf11ed33026afa36fe1f252297e13d5" translate="yes" xml:space="preserve">
          <source>Jump to P2 if the value in register P1 is true. The value is considered true if it is numeric and non-zero. If the value in P1 is NULL then take the jump if and only if P3 is non-zero.</source>
          <target state="translated">Перейдите к P2,если значение в регистре P1 истинно.Значение считается истинным,если оно числовое и ненулевое.Если значение в P1 равно NULL,то переходите к P2,если и только если P3 ненулевое.</target>
        </trans-unit>
        <trans-unit id="04a8d1cd1316034cf886277bf2c8dd963c76b71c" translate="yes" xml:space="preserve">
          <source>Jump to the instruction at address P1, P2, or P3 depending on whether in the most recent &lt;a href=&quot;opcode#Compare&quot;&gt;Compare&lt;/a&gt; instruction the P1 vector was less than equal to, or greater than the P2 vector, respectively.</source>
          <target state="translated">Переход к инструкции по адресу P1, P2 или P3 в зависимости от того, был ли в последней инструкции &lt;a href=&quot;opcode#Compare&quot;&gt;сравнения&lt;/a&gt; вектор P1 меньше или больше вектора P2 соответственно.</target>
        </trans-unit>
        <trans-unit id="029dc808e2fcf8db0d9a3400f04a64bf760921ba" translate="yes" xml:space="preserve">
          <source>Jump to the next instruction after the address in register P1. After the jump, register P1 becomes undefined.</source>
          <target state="translated">Перейти к следующей инструкции после адреса в регистре P1.После прыжка регистр P1 становится неопределенным.</target>
        </trans-unit>
        <trans-unit id="be91c2cd21e07ee8ceb31ed436dfe5c08c9a83b6" translate="yes" xml:space="preserve">
          <source>Just as there is the &quot;zip&quot; program to manage ZIP Archives, and the &quot;tar&quot; program to manage Tarballs, the &lt;a href=&quot;https://sqlite.org/sqlar&quot;&gt;&quot;sqlar&quot; program&lt;/a&gt; exists to manage SQL Archives. The &quot;sqlar&quot; program is able to create a new SQLite Archive, list the content of an existing archive, add or remove files from the archive, and/or extract files from the archive. A separate &quot;sqlarfs&quot; program is able to mount the SQLite Archive as a &lt;a href=&quot;https://github.com/libfuse/libfuse&quot;&gt;Fuse Filesystem&lt;/a&gt;.</source>
          <target state="translated">Так же, как существует программа &amp;laquo;zip&amp;raquo; для управления архивами ZIP и программа &amp;laquo;tar&amp;raquo; для управления архивами tar, существует &lt;a href=&quot;https://sqlite.org/sqlar&quot;&gt;программа &amp;laquo;sqlar&amp;raquo;&lt;/a&gt; для управления архивами SQL. Программа sqlar может создать новый архив SQLite, составить список содержимого существующего архива, добавить или удалить файлы из архива и / или извлечь файлы из архива. Отдельная программа sqlarfs может смонтировать архив SQLite как &lt;a href=&quot;https://github.com/libfuse/libfuse&quot;&gt;файловую&lt;/a&gt; систему Fuse .</target>
        </trans-unit>
        <trans-unit id="dd65c1b4b3e66e765523873bd29cf5d6d6838189" translate="yes" xml:space="preserve">
          <source>KEY</source>
          <target state="translated">KEY</target>
        </trans-unit>
        <trans-unit id="d27c8f02c4abf5f11c1eced4acd8b35520a9fe80" translate="yes" xml:space="preserve">
          <source>Keep constant guard over the actions of your life.</source>
          <target state="translated">Держите постоянную бдительность за действиями в своей жизни.</target>
        </trans-unit>
        <trans-unit id="194e669a908d39900cf589c5a981d721d7c9618b" translate="yes" xml:space="preserve">
          <source>Keep death daily before your eyes.</source>
          <target state="translated">Ежедневно держите смерть на глазах.</target>
        </trans-unit>
        <trans-unit id="c25db8dd7484e7f7bee803cd3895b18495da35bc" translate="yes" xml:space="preserve">
          <source>Keep the full precision of integers (if possible) when casting to NUMERIC. Ticket #2364</source>
          <target state="translated">Сохраняйте полную точность целых чисел (если возможно)при приведении к ЧИСЛОТНОСТИ.Билет #2364</target>
        </trans-unit>
        <trans-unit id="4989895ac52269498fe4414b7697f7a4c22ad5aa" translate="yes" xml:space="preserve">
          <source>Key points:</source>
          <target state="translated">Ключевые моменты:</target>
        </trans-unit>
        <trans-unit id="08fa4eb3aedd30338134d345421fea84986b3d4a" translate="yes" xml:space="preserve">
          <source>Key take-aways from this essay:</source>
          <target state="translated">Ключевые выводы из этого эссе:</target>
        </trans-unit>
        <trans-unit id="8b3a8bbf2ec2d401e862eec6bf418d40320b88cb" translate="yes" xml:space="preserve">
          <source>Key/value store for the raw database file content. The key is the page number and the value is binary page content.</source>
          <target state="translated">Хранилище ключей/значений для содержимого файлов исходной базы данных.Ключом является номер страницы,а значением-содержимое двоичной страницы.</target>
        </trans-unit>
        <trans-unit id="7b687d48e96f480574af88076704d469738ac8fd" translate="yes" xml:space="preserve">
          <source>Keyword arguments can optionally appear in quotes. (Example: &lt;code&gt;'yes' [FALSE]&lt;/code&gt;.) Some pragmas takes a string literal as their argument. When pragma takes a keyword argument, it will usually also take a numeric equivalent as well. For example, &quot;0&quot; and &quot;no&quot; mean the same thing, as does &quot;1&quot; and &quot;yes&quot;. When querying the value of a setting, many pragmas return the number rather than the keyword.</source>
          <target state="translated">Аргументы ключевых слов могут при желании заключаться в кавычки. (Пример: &lt;code&gt;'yes' [FALSE]&lt;/code&gt; .) Некоторые прагмы принимают строковый литерал в качестве аргумента. Когда прагма принимает аргумент ключевого слова, он обычно также принимает числовой эквивалент. Например, &amp;laquo;0&amp;raquo; и &amp;laquo;нет&amp;raquo; означают то же самое, что и &amp;laquo;1&amp;raquo; и &amp;laquo;да&amp;raquo;. При запросе значения параметра многие прагмы возвращают число, а не ключевое слово.</target>
        </trans-unit>
        <trans-unit id="71d7d3fe2fa70220d2397ae5ef29dbf8ffba7a8b" translate="yes" xml:space="preserve">
          <source>Know for certain that God sees you everywhere.</source>
          <target state="translated">Знай наверняка,что Бог видит тебя повсюду.</target>
        </trans-unit>
        <trans-unit id="7e70d2e585c390da7abcf2a3249245e0e36e0092" translate="yes" xml:space="preserve">
          <source>LAST</source>
          <target state="translated">LAST</target>
        </trans-unit>
        <trans-unit id="969e2cc476ff76be41815b17d8fb9c685f97e243" translate="yes" xml:space="preserve">
          <source>LEFT</source>
          <target state="translated">LEFT</target>
        </trans-unit>
        <trans-unit id="fa443d7d6200af63823dccc305e61eed839b45c2" translate="yes" xml:space="preserve">
          <source>LEFT JOIN</source>
          <target state="translated">ЛЕВЫЙ СОВЕТ</target>
        </trans-unit>
        <trans-unit id="06214bf7efebdbadf0fc2e8285b451472a810158" translate="yes" xml:space="preserve">
          <source>LEFT JOIN elimination often comes up when LEFT JOINs are used inside of views, and then the view is used in such as way that none of the columns of the right-hand table of the LEFT JOIN are referenced.</source>
          <target state="translated">Устранение ЛЕВОГО СОЕДИНЕНИЯ часто возникает,когда ЛЕВОЕ СОЕДИНЕНИЕ используется внутри вида,а затем вид используется таким образом,что ни один из столбцов правой таблицы ЛЕВОГО СОЕДИНЕНИЯ не имеет ссылок.</target>
        </trans-unit>
        <trans-unit id="228baedd626cec5fb29f832c085ce530c565f626" translate="yes" xml:space="preserve">
          <source>LEFT JOIN strength reduction optimization</source>
          <target state="translated">ЛЕВАЯ ОПТИМИЗАЦИЯ СОКРАЩЕНИЯ ПРОЧНОСТИ</target>
        </trans-unit>
        <trans-unit id="e43376033cc5d4106eb2e868e3b049e3915b255f" translate="yes" xml:space="preserve">
          <source>LEFT OUTER JOIN is implemented, but not RIGHT OUTER JOIN or FULL OUTER JOIN.</source>
          <target state="translated">ЛЕВОЕ ВНЕШНЕЕЕ соединение реализовано,но не ПРАВОЕ ВНЕШНЕЕ и ПОЛНОЕ ВНЕШНЕЕШНЕЕ.</target>
        </trans-unit>
        <trans-unit id="5ddf6f04739d8bc3a11b487863b27a7bcaa6fc24" translate="yes" xml:space="preserve">
          <source>LIKE</source>
          <target state="translated">LIKE</target>
        </trans-unit>
        <trans-unit id="92323e665381f4f6e8310e0e8d0ab85b11facf9e" translate="yes" xml:space="preserve">
          <source>LIKE optimization</source>
          <target state="translated">оптимизация LIKE</target>
        </trans-unit>
        <trans-unit id="c385d79f275c108bd6a32af099948cfc74a92c05" translate="yes" xml:space="preserve">
          <source>LIKE optimization now works for columns with COLLATE NOCASE</source>
          <target state="translated">Оптимизация LIKE теперь работает для колонн с COLLATE NOCASE</target>
        </trans-unit>
        <trans-unit id="7bf74f2615b51b60a0f37ad079a71016710bd256" translate="yes" xml:space="preserve">
          <source>LIKE(</source>
          <target state="translated">LIKE(</target>
        </trans-unit>
        <trans-unit id="9c590af5665cfc2916823206547377e482547e1d" translate="yes" xml:space="preserve">
          <source>LIMIT</source>
          <target state="translated">LIMIT</target>
        </trans-unit>
        <trans-unit id="40c4547fe7d52f08474372a32d5cd65ef3e61db8" translate="yes" xml:space="preserve">
          <source>LIMIT 0 now shows no rows. Use LIMIT -1 to see all rows.</source>
          <target state="translated">LIMIT 0 теперь не показывает строк.Используйте LIMIT -1,чтобы увидеть все строки.</target>
        </trans-unit>
        <trans-unit id="e120f1515582fd60e3aa87caeded6a95706ff6a5" translate="yes" xml:space="preserve">
          <source>LIMIT 0 now works on subqueries</source>
          <target state="translated">LIMIT 0 теперь работает по подзапросам</target>
        </trans-unit>
        <trans-unit id="2726a4b3c5be6bc17db3c5aa67da0f6e30ea159f" translate="yes" xml:space="preserve">
          <source>LIMIT_ATTACH</source>
          <target state="translated">LIMIT_ATTACH</target>
        </trans-unit>
        <trans-unit id="e8bf21b0d0f3b850c955bb94b5141253b1ae7e2a" translate="yes" xml:space="preserve">
          <source>LIMIT_COLUMN</source>
          <target state="translated">LIMIT_COLUMN</target>
        </trans-unit>
        <trans-unit id="7b09e7eae5f068cca9e40a4e561d97d66518a255" translate="yes" xml:space="preserve">
          <source>LIMIT_COMPOUND_SELECT</source>
          <target state="translated">LIMIT_COMPOUND_SELECT</target>
        </trans-unit>
        <trans-unit id="b1c8f4255d541a1d18f761d25857086f40b1bf20" translate="yes" xml:space="preserve">
          <source>LIMIT_EXPR_DEPTH</source>
          <target state="translated">LIMIT_EXPR_DEPTH</target>
        </trans-unit>
        <trans-unit id="2a0de541f4fa62311ff3575519dfacbb5ae6b11e" translate="yes" xml:space="preserve">
          <source>LIMIT_FUNCTION_ARG</source>
          <target state="translated">LIMIT_FUNCTION_ARG</target>
        </trans-unit>
        <trans-unit id="1a3a784fe44fc702cae042a37cb3ba3e0f6fa7ac" translate="yes" xml:space="preserve">
          <source>LIMIT_LENGTH</source>
          <target state="translated">LIMIT_LENGTH</target>
        </trans-unit>
        <trans-unit id="72fc2492f41deaa54c2dac4538490fafaa14d0d6" translate="yes" xml:space="preserve">
          <source>LIMIT_LIKE_PATTERN_LENGTH</source>
          <target state="translated">LIMIT_LIKE_PATTERN_LENGTH</target>
        </trans-unit>
        <trans-unit id="5e8999dc05d8b9aa066f6d09239a0ae740e36f64" translate="yes" xml:space="preserve">
          <source>LIMIT_SQL_LENGTH</source>
          <target state="translated">LIMIT_SQL_LENGTH</target>
        </trans-unit>
        <trans-unit id="db5d695bfcc2c3ebffa6c7ffcd096c20b8eed97c" translate="yes" xml:space="preserve">
          <source>LIMIT_TRIGGER_DEPTH</source>
          <target state="translated">LIMIT_TRIGGER_DEPTH</target>
        </trans-unit>
        <trans-unit id="16d75adbe3aa654b347523eb12544c39563f5b43" translate="yes" xml:space="preserve">
          <source>LIMIT_VARIABLE_NUMBER</source>
          <target state="translated">LIMIT_VARIABLE_NUMBER</target>
        </trans-unit>
        <trans-unit id="a604921b15950316535a24537e634352270c370e" translate="yes" xml:space="preserve">
          <source>LIMIT_VDBE_OP</source>
          <target state="translated">LIMIT_VDBE_OP</target>
        </trans-unit>
        <trans-unit id="89b86ab0e66f527166d98df92ddbcf5416ed58f6" translate="yes" xml:space="preserve">
          <source>Language</source>
          <target state="translated">Language</target>
        </trans-unit>
        <trans-unit id="7428d00a0b1c6a4c3041c21ce5ceb9dbaa4b015a" translate="yes" xml:space="preserve">
          <source>Large WAL files</source>
          <target state="translated">Большие файлы WAL</target>
        </trans-unit>
        <trans-unit id="d1c69a859a9638b242f2dabf8acf1c0b1450ce6b" translate="yes" xml:space="preserve">
          <source>Last</source>
          <target state="translated">Last</target>
        </trans-unit>
        <trans-unit id="07235ffa8a70d2e51e9570c942d05e5b5851a313" translate="yes" xml:space="preserve">
          <source>Last Insert Rowid</source>
          <target state="translated">Последняя вставка Роид</target>
        </trans-unit>
        <trans-unit id="7f81d5c9ec25b5fa1a2640b99a8421ac6c71b017" translate="yes" xml:space="preserve">
          <source>Later, SQLite version 3.6.16 is released, as shown by circle (4) in the diagram. At the point, the private branch maintainer does a merge which takes all of the changes going from (1) to (4) and applies those changes to (3). The result is version (5), which is SQLite 3.6.16 plus edits.</source>
          <target state="translated">Позже выходит версия SQLite 3.6.16,как показано кружком (4)на диаграмме.В этот момент сопровождающий частной ветки производит слияние,которое принимает все изменения,идущие от (1)до (4),и применяет эти изменения к (3).В результате получается версия (5),которая представляет собой SQLite 3.6.16 плюс изменения.</target>
        </trans-unit>
        <trans-unit id="e07edacb2555a09c495279c3384f36a675435d8d" translate="yes" xml:space="preserve">
          <source>Le</source>
          <target state="translated">Le</target>
        </trans-unit>
        <trans-unit id="fa3757f35a67a972328ec50d59fdef6fec4d197a" translate="yes" xml:space="preserve">
          <source>Leading spaces are removed.</source>
          <target state="translated">Ведущие места удалены.</target>
        </trans-unit>
        <trans-unit id="e52b8a48a53a875ca174a915ae5c47d6e94c2665" translate="yes" xml:space="preserve">
          <source>Leading zeros are handled properly, in the sense that they do not mess of the maginitude comparison of embedded strings of digits. &quot;x00123y&quot; is equal to &quot;x123y&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1dae495d04abf17bb3895a89b30ae8efcca9f3f1" translate="yes" xml:space="preserve">
          <source>Leaf payload fraction. Must be 32.</source>
          <target state="translated">Листовая доля полезной нагрузки.Должно быть 32.</target>
        </trans-unit>
        <trans-unit id="e2626d2b1592bacc07397cf31582efd1c5b2420a" translate="yes" xml:space="preserve">
          <source>Left operand</source>
          <target state="translated">Левый операнд</target>
        </trans-unit>
        <trans-unit id="203223a5600f328f50c6338dfe2e4c11e8803475" translate="yes" xml:space="preserve">
          <source>Left operand found</source>
          <target state="translated">Левый операнд найден</target>
        </trans-unit>
        <trans-unit id="865d1c5dcc029d18d1621430419ee2f04f5f424f" translate="yes" xml:space="preserve">
          <source>Left-justify the value in the output. The default is to right-justify. If the width is zero or is otherwise less than the length of the value being substituted, then there is no padding and the &quot;-&quot; flag is a no-op.</source>
          <target state="translated">Оправдайте значение на выходе в левую сторону.По умолчанию используется правое оправдание.Если ширина равна нулю или иначе меньше длины подставляемого значения,то подкладка отсутствует,а флаг &quot;-&quot;-нет.</target>
        </trans-unit>
        <trans-unit id="1877e2f919fe86f5371e6a3e7d9d6b6080bf4d57" translate="yes" xml:space="preserve">
          <source>Legacy (older than 3.22.0) versions of the sessions module cannot capture changes made to the sqlite_stat1 table. Legacy versions of the sqlite3changeset_apply() function silently ignore any modifications to the sqlite_stat1 table that are part of a changeset or patchset.</source>
          <target state="translated">Устаревшие (старше 3.22.0)версии модуля сеансов не могут фиксировать изменения,внесённые в таблицу sqlite_stat1.Старые версии функции sqlite3changeset_apply()беззвучно игнорируют любые изменения таблицы sqlite_stat1,которые являются частью changeset или patchset.</target>
        </trans-unit>
        <trans-unit id="48078fcdb6dc318fa741d70a2ecdb6ae1437e609" translate="yes" xml:space="preserve">
          <source>Lemon does not have its own source repository. Rather, Lemon consists of a few files in the SQLite source tree:</source>
          <target state="translated">У Лемон нет собственного репозитория исходников.Скорее,Lemon состоит из нескольких файлов в дереве исходных текстов SQLite:</target>
        </trans-unit>
        <trans-unit id="bf0578b2a25d2e804bfd4deee5634450a8293393" translate="yes" xml:space="preserve">
          <source>Lemon generates an LALR(1) parser. It's operation is similar to the more familiar tools &lt;a href=&quot;https://en.wikipedia.org/wiki/Yacc&quot;&gt;Yacc&lt;/a&gt; and &lt;a href=&quot;https://en.wikipedia.org/wiki/GNU_bison&quot;&gt;Bison&lt;/a&gt;, but Lemon adds important improvements, including:</source>
          <target state="translated">Lemon генерирует парсер LALR (1). Его работа аналогична более знакомым инструментам &lt;a href=&quot;https://en.wikipedia.org/wiki/Yacc&quot;&gt;Yacc&lt;/a&gt; и &lt;a href=&quot;https://en.wikipedia.org/wiki/GNU_bison&quot;&gt;Bison&lt;/a&gt; , но Lemon добавляет важные улучшения, в том числе:</target>
        </trans-unit>
        <trans-unit id="e082b356dc26d0aea289ce00e7ec084aced6cb66" translate="yes" xml:space="preserve">
          <source>Lemon generates an LALR(1) parser. Its operation is similar to the more familiar tools &lt;a href=&quot;https://en.wikipedia.org/wiki/Yacc&quot;&gt;Yacc&lt;/a&gt; and &lt;a href=&quot;https://en.wikipedia.org/wiki/GNU_bison&quot;&gt;Bison&lt;/a&gt;, but Lemon adds important improvements, including:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efedecd644b64990e1efae314b3426de6b60b11e" translate="yes" xml:space="preserve">
          <source>Lemon has the concept of a &quot;fallback&quot; token. The SQL language contains a large number of keywords and these keywords have the potential to collide with identifier names. Lemon has the ability to designate some keywords has being able to &quot;fallback&quot; to an identifier. If the keyword appears in the input token stream in a context that would otherwise be a syntax error, the token is automatically transformed into its fallback before the syntax error is raised. This feature allows the parser to be very forgiving of reserved words used as identifiers, which is a problem that comes up frequently in the SQL language.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae32ad1b62e795e4b0f91393920f4a7aff7c555a" translate="yes" xml:space="preserve">
          <source>Lemon has the concept of a &quot;fallback&quot; tokens. The SQL language contains a large number of keywords and these keywords have the potential to collide with identifier names. Lemon has the ability to designate some keywords has being able to &quot;fallback&quot; to an identifier. If the keyword appears in the input token stream in a context that would otherwise be a syntax error, the token is automatically transformed into its fallback before the syntax error is raised. This feature allows the parser to be very forgiving of reserved words used as identifiers, which is a problem that comes up frequently in the SQL language.</source>
          <target state="translated">У Лемон есть понятие жетонов &quot;отступление&quot;.Язык SQL содержит большое количество ключевых слов,и эти ключевые слова потенциально могут столкнуться с именами идентификаторов.Lemon имеет возможность обозначить некоторые ключевые слова,имея возможность &quot;отступать&quot; к идентификатору.Если ключевое слово появляется в потоке входных токенов в контексте,который в противном случае был бы синтаксической ошибкой,то до появления синтаксической ошибки токен автоматически преобразуется в откат.Эта функция позволяет синтаксическому анализатору быть очень снисходительным к зарезервированным словам,используемым в качестве идентификаторов,что является проблемой,часто возникающей в языке SQL.</target>
        </trans-unit>
        <trans-unit id="2f9dc02cb8bf5b03f6591dbb44f0a7a4b90f82f4" translate="yes" xml:space="preserve">
          <source>Lemon has the concept of a non-terminal destructor that can be used to reclaim memory or other resources following a syntax error or other aborted parse.</source>
          <target state="translated">Lemon имеет понятие нетерминального деструктора,который может быть использован для восстановления памяти или других ресурсов после синтаксической ошибки или другого прерванного разбора.</target>
        </trans-unit>
        <trans-unit id="cee927c3e2d6e42d43d5738f627f3200d5121eac" translate="yes" xml:space="preserve">
          <source>Lemon is also used to generate parse for the query pattern expressions in the &lt;a href=&quot;fts5&quot;&gt;FTS5&lt;/a&gt; extension. In this case, the input grammar file is &lt;a href=&quot;https://sqlite.org/src/file/ext/fts5/fts5parse.y&quot;&gt;fts5parse.y&lt;/a&gt;.</source>
          <target state="translated">Lemon также используется для синтаксического анализа выражений шаблонов запросов в расширении &lt;a href=&quot;fts5&quot;&gt;FTS5&lt;/a&gt; . В данном случае входным файлом грамматики является &lt;a href=&quot;https://sqlite.org/src/file/ext/fts5/fts5parse.y&quot;&gt;fts5parse.y&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="81b122bf1a51d71a58a32df85cf2293735051ebd" translate="yes" xml:space="preserve">
          <source>Lemon is also used to generate the parser for the query pattern expressions in the &lt;a href=&quot;fts5&quot;&gt;FTS5&lt;/a&gt; extension. In this case, the input grammar file is &lt;a href=&quot;https://sqlite.org/src/file/ext/fts5/fts5parse.y&quot;&gt;fts5parse.y&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="611d0deb28e86cca8303457d918752428288861c" translate="yes" xml:space="preserve">
          <source>Lemon is used in two places in SQLite.</source>
          <target state="translated">Лемон используется в SQLite в двух местах.</target>
        </trans-unit>
        <trans-unit id="0045a01f71c39a54c68dbc362b5b7275372032f5" translate="yes" xml:space="preserve">
          <source>Lemon supports conditional compilation of grammar file rules, so that a different parser can be generated depending on compile-time options.</source>
          <target state="translated">Lemon поддерживает условную компиляцию правил грамматических файлов,так что в зависимости от настроек времени компиляции может быть сгенерирован другой парсер.</target>
        </trans-unit>
        <trans-unit id="c5c89f378ce33982d309c573eb1ff14dd3f01e8a" translate="yes" xml:space="preserve">
          <source>Lemon was original written by D. Richard Hipp (also the creator of SQLite) while he was in graduate school at Duke University between 1987 and 1992. The original creation date of Lemon has been lost, but was probably sometime around 1990. Lemon generates an LALR(1) parser. There was companion LL(1) parser generator tool named &quot;Lime&quot;, but the source code for Lime has been lost.</source>
          <target state="translated">Лемон была написана Д.Ричардом Хиппом (также создателем SQLite),когда он учился в аспирантуре университета Дьюка с 1987 по 1992 год.Первоначальная дата создания Lemon была утеряна,но,вероятно,около 1990 года.Лемон создает парсер LALR(1).Существовал компаньон LL(1),генерирующий парсер под названием &quot;Lime&quot;,но исходный код для Lime был потерян.</target>
        </trans-unit>
        <trans-unit id="c14807b5c54c06b6f5e4f638f48d2b24a5f7168b" translate="yes" xml:space="preserve">
          <source>Lemon was originally written by D. Richard Hipp (also the creator of SQLite) while he was in graduate school at Duke University between 1987 and 1992. The original creation date of Lemon has been lost, but was probably sometime around 1990. Lemon generates an LALR(1) parser. There was a companion LL(1) parser generator tool named &quot;Lime&quot;, but the source code for Lime has been lost.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa1fa89453ad95c8f115feb4d323d1e9b329630d" translate="yes" xml:space="preserve">
          <source>Length Specifier</source>
          <target state="translated">Указатель длины</target>
        </trans-unit>
        <trans-unit id="c999fb0a278ca9591b2cd0c03ceaa3328da57984" translate="yes" xml:space="preserve">
          <source>Less administration means that programmers spend more time working on the software (SQLite in this case) and less time fussing with the version control system.</source>
          <target state="translated">Меньше администрирования означает,что программисты тратят больше времени на работу с программным обеспечением (в данном случае SQLite)и меньше времени на работу с системой контроля версий.</target>
        </trans-unit>
        <trans-unit id="cbcb5b1fa488787750d49ab79f8ec375ce5124b9" translate="yes" xml:space="preserve">
          <source>Less memory used</source>
          <target state="translated">Меньше используемой памяти</target>
        </trans-unit>
        <trans-unit id="bc720094b72d521a9bad35bfe37f02c776160039" translate="yes" xml:space="preserve">
          <source>Let K be M+((P-M)%(U-4)).</source>
          <target state="translated">Пусть K будет M+((P-M)%(U-4)).</target>
        </trans-unit>
        <trans-unit id="ec5fd8c108643b71cf1bdd72351ff3e987fc1a5d" translate="yes" xml:space="preserve">
          <source>Let X be ((U-12)*64/255)-23. If the payload size P is less than or equal to X then the entire payload is stored on the b-tree page. Let M be ((U-12)*32/255)-23 and let K be M+((P-M)%(U-4)). If P is greater than X then the number of bytes stored on the index b-tree page is K if K is less than or equal to X or M otherwise. The number of bytes stored on the index page is never less than M.</source>
          <target state="translated">Пусть X будет ((U-12)*64/255)-23.Если размер полезного груза P меньше или равен X,то вся полезная нагрузка хранится на странице b-дерева.Пусть M будет ((U-12)*32/255)-23 и пусть K будет M+((P-M)%(U-4)).Если P больше X,то количество байт,которое хранится в индексной b-деревянной странице,будет K,если K меньше или равно X или M иным образом.Количество байтов,хранящихся на индексной странице,никогда не должно быть меньше M.</target>
        </trans-unit>
        <trans-unit id="3814595cf4d53307c33619bbcfd8505bff49fec5" translate="yes" xml:space="preserve">
          <source>Let X be U-35. If the payload size P is less than or equal to X then the entire payload is stored on the b-tree leaf page. Let M be ((U-12)*32/255)-23 and let K be M+((P-M)%(U-4)). If P is greater than X then the number of bytes stored on the table b-tree leaf page is K if K is less or equal to X or M otherwise. The number of bytes stored on the leaf page is never less than M.</source>
          <target state="translated">Пусть Икс будет U-35.Если размер полезного груза P меньше или равен X,то вся полезная нагрузка хранится на странице b-деревянного листа.Пусть M будет ((U-12)*32/255)-23 и пусть K будет M+((P-M)%(U-4)).Если P больше X,то количество байт,хранящихся на странице b-деревянного листа таблицы,будет K,если K меньше или равно X или M в противном случае.Количество байтов,хранящихся на странице листа,никогда не должно быть меньше M.</target>
        </trans-unit>
        <trans-unit id="04ab6da7aca9e95067f1ce62f19a937e96ff6418" translate="yes" xml:space="preserve">
          <source>Let X be the expression in the WHERE clause of a partial index, and let W be the WHERE clause of a query that uses the table that is indexed. Then, the query is permitted to use the partial index if W&amp;rArr;X, where the &amp;rArr; operator (usually pronounced &quot;implies&quot;) is the logic operator equivalent to &quot;X or not W&quot;. Hence, determining whether or not a partial index is usable in a particular query reduces to proving a theorem in first-order logic.</source>
          <target state="translated">Пусть X будет выражением в предложении WHERE частичного индекса, а W будет предложением WHERE запроса, использующего индексируемую таблицу. Затем в запросе разрешается использовать частичный индекс, если W&amp;rArr;X, где оператор &amp;rArr; (обычно произносится как &amp;laquo;подразумевает&amp;raquo;) является логическим оператором, эквивалентным &amp;laquo;X или не W&amp;raquo;. Следовательно, определение того, можно ли использовать частичный индекс в конкретном запросе, сводится к доказательству теоремы в логике первого порядка.</target>
        </trans-unit>
        <trans-unit id="8e79f3f73bca370e5a0d09f6e67e4908583572b1" translate="yes" xml:space="preserve">
          <source>Let X be the largest set of consecutive integers {h, h+1, h+2, ..., h+N} such that for every j in X, aPgno[j%8192]!=0. The X set will be empty if aPgno[h%8192]==0. The X set is easily computed by starting with the value h%8192, and adding h%8192 to X and incrementing h until encountering the first aPgno[h%8192] entry that is zero.</source>
          <target state="translated">Пусть Х будет самым большим набором последовательных целых чисел {h,h+1,h+2,...,h+N}так,чтобы для каждого j в Х,aPgno[j%8192]!=0.Множество Х будет пустым,если aPgno[h%8192]==0.Множество Х легко вычисляется,начиная со значения h%8192,добавляя к Х h%8192 и увеличивая h до тех пор,пока не столкнется с первой записью aPgno[h%8192],которая равна нулю.</target>
        </trans-unit>
        <trans-unit id="37bafb8ebd6ac523c9fab977240fbaca2d2a4205" translate="yes" xml:space="preserve">
          <source>Let the database page size (the value of the integer at offset 24 in the journal header) be N. Then the format of a page record is as follows:</source>
          <target state="translated">Пусть размер страницы БД (значение целого числа со смещением 24 в заголовке журнала)будет N.Тогда формат записи страницы будет следующим:</target>
        </trans-unit>
        <trans-unit id="5da01c6ea976760415bf0eb965f5e685ea3c15ec" translate="yes" xml:space="preserve">
          <source>Let the datatypes &quot;u8&quot;, &quot;u16&quot;, and &quot;u32&quot; mean unsigned integers of length 8, 16, and 32 bits, respectively. Then, the first 32768-byte unit of the shm file is organized as follows:</source>
          <target state="translated">Пусть типы данных &quot;u8&quot;,&quot;u16&quot; и &quot;u32&quot; означают беззнаковые целые числа длиной 8,16 и 32 бита соответственно.Затем первая 32768-байтовая единица файла shm организована следующим образом:</target>
        </trans-unit>
        <trans-unit id="35d97b78e6396cb7e0d5fdc8a5a3051973e7dd0f" translate="yes" xml:space="preserve">
          <source>Let the number of alice nodes be M and the number of bob nodes be N. Consider two scenarios. In the first scenario, M and N are both 2 but there are thousands of edges on each node. In this case, option 1 is preferred. With option 1, the inner loop checks for the existence of an edge between a pair of nodes and outputs the result if found. Because there are only 2 alice and bob nodes each, the inner loop only has to run four times and the query is very quick. Option 2 would take much longer here. The outer loop of option 2 only executes twice, but because there are a large number of edges leaving each alice node, the middle loop has to iterate many thousands of times. It will be much slower. So in the first scenario, we prefer to use option 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd114f90a251306f5f9680610cc3593a57d82e5b" translate="yes" xml:space="preserve">
          <source>Let the number of alice nodes be M and the number of bob nodes be N. Consider two scenarios. In the first scenario, M and N are both 2 but there are thousands of edges on each node. In this case, option 1 is preferred. With option 1, the inner loop checks for the existence of an edge between a pair of nodes and outputs the result if found. But because there are only 2 alice and bob nodes each, the inner loop only has to run 4 times and the query is very quick. Option 2 would take much longer here. The outer loop of option 2 only executes twice, but because there are a large number of edges leaving each alice node, the middle loop has to iterate many thousands of times. It will be much slower. So in the first scenario, we prefer to use option 1.</source>
          <target state="translated">Пусть число вершин Алисы будет M,а число вершин Боба-N.Рассмотрим два сценария.В первом сценарии M и N равны 2,но на каждой вершине есть тысячи рёбер.В этом случае предпочтителен вариант 1.При использовании варианта 1 внутренний цикл проверяет наличие фронта между парой узлов и выдает результат,если он найден.Но так как существует только 2 alice и bob узла в каждом,то внутренний цикл должен выполняться только 4 раза,и запрос выполняется очень быстро.Вариант 2 здесь занял бы гораздо больше времени.Внешний цикл варианта 2 выполняется только дважды,но из-за большого количества ребер,оставляющих каждый узел Алисы,средний цикл вынужден повторять итерации много тысяч раз.Это будет намного медленнее.Поэтому в первом сценарии мы предпочитаем использовать вариант 1.</target>
        </trans-unit>
        <trans-unit id="74b220b56c9d6c3f209f91061a8b3234a645c429" translate="yes" xml:space="preserve">
          <source>Let the page count value at offset 8 in the journal header be M. If M is greater than zero then after M page records the journal file may be zero padded out to the next multiple of the sector size and another journal header may be inserted. All journal headers within the same journal must contain the same database page size and sector size.</source>
          <target state="translated">Пусть значение счета страниц со смещением 8 в заголовке журнала будет M.Если M больше нуля,то после записи страницы M файл журнала может быть обнулен до следующего кратного размера сектора,и в него может быть вставлен другой заголовок журнала.Все заголовки журнала внутри одного и того же журнала должны содержать одинаковый размер страницы базы данных и размер сектора.</target>
        </trans-unit>
        <trans-unit id="f44e417ae6158672e12bddd6f44e6cd28bdb55bb" translate="yes" xml:space="preserve">
          <source>Let us assume that you are using the amalgamation source code. Add the baseline to your project as follows:</source>
          <target state="translated">Предположим,что вы используете исходный код слияния.Добавьте исходный код к вашему проекту следующим образом:</target>
        </trans-unit>
        <trans-unit id="ae7bd817eacac0a262f119102109a97036180841" translate="yes" xml:space="preserve">
          <source>Let us suppose that instead of using a ZIP archive to store its files, OpenDocument used a very simple SQLite database with the following single-table schema:</source>
          <target state="translated">Предположим,что вместо того,чтобы использовать ZIP-архив для хранения своих файлов,в OpenDocument использовалась очень простая SQLite БД со следующей однотаблеточной схемой:</target>
        </trans-unit>
        <trans-unit id="ecc5e1e5e0ad7c0dd2b547a397bdb11d90ca6d36" translate="yes" xml:space="preserve">
          <source>Let us use the following notation (similar but not identical to Robson's notation):</source>
          <target state="translated">Используем следующую нотацию (похожую,но не идентичную нотации Робсона):</target>
        </trans-unit>
        <trans-unit id="2d2261f9e0cbec9edf95c4d47c5f5eb0cbcca2f7" translate="yes" xml:space="preserve">
          <source>Let's be real. Few people seriously dispute that Git provides a suboptimal user experience. A lot of the underlying implementation shows through into the user interface. The interface is so bad that there is even a parody site that generates &lt;a href=&quot;https://git-man-page-generator.lokaltog.net/&quot;&gt;fake git man pages&lt;/a&gt;.</source>
          <target state="translated">Давайте будем реальными. Мало кто серьезно оспаривает то, что Git обеспечивает неоптимальный пользовательский интерфейс. Большая часть базовой реализации просматривается в пользовательском интерфейсе. Интерфейс настолько плох, что существует даже пародийный сайт, генерирующий &lt;a href=&quot;https://git-man-page-generator.lokaltog.net/&quot;&gt;поддельные страницы руководства git&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0f0987eb98b35f60885158c865b4e995d0d04bc9" translate="yes" xml:space="preserve">
          <source>Let's look more closely at what is happening here. The first SELECT is implemented by the loop at instructions 5 through 10. Instruction 5 initializes the loop by rewinding its cursor. Instruction 6 extracts the value of the &quot;two&quot; column from &quot;examp&quot; and instruction 7 converts this into a row. Instruction 8 pushes an empty string onto the stack. Finally, instruction 9 writes the row into the temporary table. But remember, the PutStrKey opcode uses the top of the stack as the record data and the next on stack as the key. For an INSERT statement, the row generated by the MakeRecord opcode is the record data and the record key is an integer created by the NewRecno opcode. But here the roles are reversed and the row created by MakeRecord is the record key and the record data is just an empty string.</source>
          <target state="translated">Давайте посмотрим более внимательно на то,что здесь происходит.Первый SELECT реализуется циклом на инструкциях 5-10.Инструкция 5 инициализирует цикл перемоткой его курсора.Инструкция 6 извлекает значение столбца &quot;два&quot; из &quot;экзамена&quot;,а инструкция 7 преобразует его в строку.Инструкция 8 толкает пустую строку на стек.Наконец,Инструкция 9 записывает строку во временную таблицу.Но помните,что опкод PutStrKey использует вершину стека в качестве данных записи,а следующую на стеке в качестве ключа.Для оператора INSERT,строка,генерируемая опкодом MakeRecord,является данными записи,а ключом записи является целое число,созданное опкодом NewRecno.Но здесь роли перевернуты,а строка,созданная оператором MakeRecord,является ключом записи,а данные записи-просто пустой строкой.</target>
        </trans-unit>
        <trans-unit id="8ce47b13d09374c0748516f88f9567e0ba880c6e" translate="yes" xml:space="preserve">
          <source>Libraries written in C do not have a huge run-time dependency. In its minimum configuration, SQLite requires only the following routines from the standard C library:</source>
          <target state="translated">Библиотеки,написанные на C,не имеют огромной зависимости от времени исполнения.В своей минимальной конфигурации SQLite требует только следующих процедур из стандартной библиотеки на Си:</target>
        </trans-unit>
        <trans-unit id="16b9101f24846717dcb86cc74d99a08aad5ead61" translate="yes" xml:space="preserve">
          <source>Libraries written in C++ or Java can generally only be used by applications written in the same language. It is difficult to get an application written in Haskell or Java to invoke a library written in C++. On the other hand, libraries written in C are callable from any programming language.</source>
          <target state="translated">Библиотеки,написанные на C++или Java,как правило,могут использоваться только приложениями,написанными на том же языке.Сложно заставить приложение,написанное на Haskell или Java,ссылаться на библиотеку,написанную на С++.С другой стороны,библиотеки,написанные на Си,могут вызываться из любого языка программирования.</target>
        </trans-unit>
        <trans-unit id="8f218c8346bfddbca30ecf6b104e83b9f15b5e98" translate="yes" xml:space="preserve">
          <source>Library size optimizations.</source>
          <target state="translated">Оптимизация размера библиотеки.</target>
        </trans-unit>
        <trans-unit id="3769a60d2f565f40c7f7836558211471f7d8a029" translate="yes" xml:space="preserve">
          <source>Like --file, use file FILE as the archive, but open the file using the &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/appendvfs.c&quot;&gt;apndvfs VFS&lt;/a&gt; so that the archive will be appended to the end of FILE if FILE already exists.</source>
          <target state="translated">Как и --file, используйте файл FILE в качестве архива, но откройте файл с помощью &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/appendvfs.c&quot;&gt;apndvfs VFS,&lt;/a&gt; чтобы архив был добавлен в конец FILE, если FILE уже существует.</target>
        </trans-unit>
        <trans-unit id="0b095c3da7d05183eec1d9c68eafa22989981539" translate="yes" xml:space="preserve">
          <source>Like contentless tables, external content tables do not support REPLACE conflict handling. Any operations that specify REPLACE conflict handling are handled using ABORT.</source>
          <target state="translated">Подобно таблицам без содержания,внешние таблицы содержания не поддерживают обработку конфликтов REPLACE.Любые операции,указывающие на обработку конфликтов REPLACE,обрабатываются с помощью ABORT.</target>
        </trans-unit>
        <trans-unit id="231d089dd7b27b9cd1c3006b16a6dc21b83bfb7e" translate="yes" xml:space="preserve">
          <source>Like other virtual table types, new FTS tables are created using a &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; statement. The module name, which follows the USING keyword, is either &quot;fts3&quot; or &quot;fts4&quot;. The virtual table module arguments may be left empty, in which case an FTS table with a single user-defined column named &quot;content&quot; is created. Alternatively, the module arguments may be passed a list of comma separated column names.</source>
          <target state="translated">Как и другие типы виртуальных таблиц, новые таблицы FTS создаются с помощью оператора &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; . Имя модуля, следующее за ключевым словом USING, - &amp;laquo;fts3&amp;raquo; или &amp;laquo;fts4&amp;raquo;. Аргументы модуля виртуальной таблицы могут быть оставлены пустыми, и в этом случае создается таблица FTS с одним определяемым пользователем столбцом с именем &amp;laquo;контент&amp;raquo;. В качестве альтернативы аргументам модуля может быть передан список имен столбцов, разделенных запятыми.</target>
        </trans-unit>
        <trans-unit id="fd7d7c85c83f29484f2e117602dc4bec07bd365d" translate="yes" xml:space="preserve">
          <source>Like sqlite3rbu_step(), if the vacuum operation has finished, sqlite3rbu_close() returns SQLITE_DONE. If the vacuum has not finished but no error has occurred, SQLITE_OK is returned. Or, if an error has occurred, an SQLite error code is returned. If an error occurred as part of a prior call to sqlite3rbu_step(), sqlite3rbu_close() returns the same error code.</source>
          <target state="translated">Как и sqlite3rbu_step(),если операция вакуума закончена,sqlite3rbu_close()возвращает SQLITE_DONE.Если вакуум не закончился,но ошибка не произошла,возвращается SQLITE_OK.Или,если ошибка произошла,возвращается код ошибки SQLite.Если ошибка произошла в рамках предыдущего вызова sqlite3rbu_step(),sqlite3rbu_close()возвращает тот же код ошибки.</target>
        </trans-unit>
        <trans-unit id="7e8a69dbe9cf8dfea5767671aa0118b3491fc369" translate="yes" xml:space="preserve">
          <source>Like the &quot;.dump&quot; command, &quot;.recover&quot; attempts to convert the entire contents of a database file to text. The difference is that instead of reading data using the normal SQL database interface, &quot;.recover&quot; attempts to reassemble the database based on data extracted directly from as many database pages as possible. If the database is corrupt, &quot;.recover&quot; is usually able to recover data from all uncorrupted parts of the database, whereas &quot;.dump&quot; stops when the first sign of corruption is encountered.</source>
          <target state="translated">Подобно команде &quot;.dump&quot;,&quot;.recover&quot; пытается преобразовать все содержимое файла базы данных в текст.Разница в том,что вместо чтения данных с помощью обычного интерфейса базы данных SQL,&quot;.recover&quot; пытается собрать базу данных на основе данных,извлеченных непосредственно из как можно большего количества страниц базы данных.Если база данных повреждена,&quot;.recover&quot;,как правило,может восстановить данные из всех поврежденных частей базы данных,тогда как &quot;.dump&quot; останавливается при первом же признаке повреждения.</target>
        </trans-unit>
        <trans-unit id="86f2b5c75e6099a6cf032f5fc9564b20f9285845" translate="yes" xml:space="preserve">
          <source>Limit Setting</source>
          <target state="translated">Установка пределов</target>
        </trans-unit>
        <trans-unit id="dc00d8255b192a092dc29a4b67bc17a891ccaa1d" translate="yes" xml:space="preserve">
          <source>Limit the amount of output that &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt; generates.</source>
          <target state="translated">Ограничьте объем вывода, который генерирует &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA Integrity_check&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3bc4a74f4bc8f6fbe5d7600c2ffc0ce32f2df522" translate="yes" xml:space="preserve">
          <source>Limit the depth of recursion for JSON objects and arrays in order to avoid excess stack usage in the recursive descent parser. Fix for ticket &lt;a href=&quot;https://www.sqlite.org/src/info/981329adeef51011052&quot;&gt;981329adeef51011052&lt;/a&gt;.</source>
          <target state="translated">Ограничьте глубину рекурсии для объектов и массивов JSON, чтобы избежать чрезмерного использования стека в парсере рекурсивного спуска. Исправление для билета &lt;a href=&quot;https://www.sqlite.org/src/info/981329adeef51011052&quot;&gt;981329adeef51011052&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5c73db06777439f7e7a4e0b4ef090767959f015d" translate="yes" xml:space="preserve">
          <source>Limit the maximum amount of memory that SQLite will allocate using the &lt;a href=&quot;c3ref/hard_heap_limit64&quot;&gt;sqlite3_hard_heap_limit64()&lt;/a&gt; interface. This helps prevent denial-of-service attacks. To find out how much heap space an application actually needs, run the it against typical inputs and then measure the maximum instantaneous memory usage with the &lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_highwater()&lt;/a&gt; interface. Set the hard heap limit to the maximum observed instantaneous memory usage plus some margin.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7c04c64ed3f2a9374590c76c50d3b7f1b18e3da" translate="yes" xml:space="preserve">
          <source>Limitations</source>
          <target state="translated">Limitations</target>
        </trans-unit>
        <trans-unit id="cd047048aa9c975f33600c7ec5b79b0145824c1c" translate="yes" xml:space="preserve">
          <source>Limitations And Caveats</source>
          <target state="translated">Ограничения и пещеры</target>
        </trans-unit>
        <trans-unit id="140fa43a5b0009e4451c320039ee7a35af9ef59d" translate="yes" xml:space="preserve">
          <source>Limitations Of The OpenDocument Presentation Format</source>
          <target state="translated">Ограничения формата представления OpenDocument</target>
        </trans-unit>
        <trans-unit id="61a0ae3b849d95fb8185df69b96d0ec676fb0688" translate="yes" xml:space="preserve">
          <source>Limits</source>
          <target state="translated">Limits</target>
        </trans-unit>
        <trans-unit id="da74bbdf0c5ba1732a1bcf36654960401f556496" translate="yes" xml:space="preserve">
          <source>Limits In SQLite</source>
          <target state="translated">Ограничения в SQLite</target>
        </trans-unit>
        <trans-unit id="2b535e43758af2a0faba7d7491e8ccc0937261f7" translate="yes" xml:space="preserve">
          <source>Lines that begin with &quot;#&quot; and that are not in the middle of an SQL statement are interpreted as comments.</source>
          <target state="translated">Строки,которые начинаются с &quot;#&quot; и не находятся в середине SQL-оператора,интерпретируются как комментарии.</target>
        </trans-unit>
        <trans-unit id="56c40b8da457fccee36d2dd25cabffcd286e7be5" translate="yes" xml:space="preserve">
          <source>Link SQLite against a test program that runs approximately 30,000 SQL statements representing a typical workload.</source>
          <target state="translated">Соедините SQLite с тестовой программой,которая запускает около 30,000 SQL выражений,представляющих типичную рабочую нагрузку.</target>
        </trans-unit>
        <trans-unit id="aa106ea45c187562ead66ff45b2537ad9d39d113" translate="yes" xml:space="preserve">
          <source>Linus Torvalds used different words to say much the same thing on the Git mailing list on 2006-06-27:</source>
          <target state="translated">Линус Торвальдс использовал разные слова,чтобы сказать одно и то же в списке рассылки Git'а на 2006-06-27:</target>
        </trans-unit>
        <trans-unit id="518aa8e09ec633a2ee7ca4061837886754889a59" translate="yes" xml:space="preserve">
          <source>List Of Constants:</source>
          <target state="translated">Список постоянных:</target>
        </trans-unit>
        <trans-unit id="c88854d7fb661e5a305fcbc6e6989b1500fbf8a5" translate="yes" xml:space="preserve">
          <source>List Of Functions:</source>
          <target state="translated">Список функций:</target>
        </trans-unit>
        <trans-unit id="02564776632cdeb522e81ac2cc1d466134257360" translate="yes" xml:space="preserve">
          <source>List Of Objects:</source>
          <target state="translated">Список объектов:</target>
        </trans-unit>
        <trans-unit id="5976b759c2bbe27a2c436cf0d06c399c38f9db0a" translate="yes" xml:space="preserve">
          <source>List Of PRAGMAs</source>
          <target state="translated">Список PRAGMA</target>
        </trans-unit>
        <trans-unit id="198f4f9677551df3e26744118c9e2c5bcd812876" translate="yes" xml:space="preserve">
          <source>List Of SQLite Constants</source>
          <target state="translated">Список констант SQLite</target>
        </trans-unit>
        <trans-unit id="b6b508ee374f53a81be169f4d47397a7a1f331e0" translate="yes" xml:space="preserve">
          <source>List Of SQLite Functions</source>
          <target state="translated">Список функций SQLite</target>
        </trans-unit>
        <trans-unit id="52d4b531b52e9862c4189d27482ae4e958f97760" translate="yes" xml:space="preserve">
          <source>List Of SQLite Objects</source>
          <target state="translated">Список объектов SQLite</target>
        </trans-unit>
        <trans-unit id="68749615daec6b7db7287fc101bfd1803474c677" translate="yes" xml:space="preserve">
          <source>List Of Virtual Tables</source>
          <target state="translated">Список виртуальных таблиц</target>
        </trans-unit>
        <trans-unit id="9d1c029d1a64007ca37f5bf394575d02eef0574f" translate="yes" xml:space="preserve">
          <source>List each file as it is processed.</source>
          <target state="translated">Перечислите каждый файл в процессе обработки.</target>
        </trans-unit>
        <trans-unit id="a5d1705cc809076e6266257a5ff3fa27b21bc1d4" translate="yes" xml:space="preserve">
          <source>List the contents of the archive. If no arguments are specified, then all files are listed. Otherwise, only those specified as arguments are. Currently, the --verbose option does not change the behaviour of this command. That may change in the future.</source>
          <target state="translated">Перечислите содержимое архива.Если аргументы не указаны,то перечисляются все файлы.В противном случае,только те,которые указаны в качестве аргументов.На данный момент опция --verbose не изменяет поведение этой команды.Это может измениться в будущем.</target>
        </trans-unit>
        <trans-unit id="27424535e9c380832791dbc03c67071412b07455" translate="yes" xml:space="preserve">
          <source>List the files in the archive.</source>
          <target state="translated">Перечислите файлы в архиве.</target>
        </trans-unit>
        <trans-unit id="615e9625e4457bad91a4957735c233d58d384ed8" translate="yes" xml:space="preserve">
          <source>List values on the right-hand side of IN are treated as a subquery that must be materialized. In other words, the previous statement acts as if it were:</source>
          <target state="translated">Значения перечня,расположенные справа от IN,рассматриваются как подзапрос,который должен быть материализован.Другими словами,предыдущее утверждение действует так,как если бы оно было:</target>
        </trans-unit>
        <trans-unit id="f653dec85c31b3ff9b77fe72b2384cf749288d85" translate="yes" xml:space="preserve">
          <source>Listed below are some cases where it might make sense to add additional soundslike entries. The specific entries will depend on the application and the target language.</source>
          <target state="translated">Ниже перечислены некоторые случаи,когда имеет смысл добавить дополнительные звуковые записи.Конкретные записи будут зависеть от приложения и целевого языка.</target>
        </trans-unit>
        <trans-unit id="9a2828a10d993798b426c35ab47fdbeb8b46927a" translate="yes" xml:space="preserve">
          <source>Listen willingly to holy reading.</source>
          <target state="translated">Слушайте с готовностью святое чтение.</target>
        </trans-unit>
        <trans-unit id="3805c697baba47d8b6fac8ff193aac1d5aae53c5" translate="yes" xml:space="preserve">
          <source>Literal Values (Constants)</source>
          <target state="translated">Буквальные значения (постоянные)</target>
        </trans-unit>
        <trans-unit id="3c11cc0f06e28252855afe306ffae2efa4d23a55" translate="yes" xml:space="preserve">
          <source>Literal strings contain no byte-order-marks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a95fd3f55e521532b15bff8dba2b3aa3f6401a1a" translate="yes" xml:space="preserve">
          <source>Literal value</source>
          <target state="translated">Буквальное значение</target>
        </trans-unit>
        <trans-unit id="402377f4fa54f586c7bcf70486179fb514f52098" translate="yes" xml:space="preserve">
          <source>Literal values: numeric or string constants.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc57b0cbf2f7891171194ad1bf1b86f68a201597" translate="yes" xml:space="preserve">
          <source>LoC Recommended Storage Format</source>
          <target state="translated">Рекомендуемый формат хранения LoC</target>
        </trans-unit>
        <trans-unit id="c1fd24450afa2a8ca3ccb54f712f70e15f33b7ed" translate="yes" xml:space="preserve">
          <source>Load An Extension</source>
          <target state="translated">Загрузить удлинитель</target>
        </trans-unit>
        <trans-unit id="f9c032c8f6af23d9ff803554a14cbcd6e3037cb8" translate="yes" xml:space="preserve">
          <source>Load The Difference Between Tables Into A Session</source>
          <target state="translated">Загрузить разницу между таблицами в сессию.</target>
        </trans-unit>
        <trans-unit id="9c794e6d2b53e1c944bf6d4f24a6f0f6be485378" translate="yes" xml:space="preserve">
          <source>Load the shared library or DLL file LIBRARY into SQLite prior to computing the differences. This can be used to add application-defined &lt;a href=&quot;datatype3#collation&quot;&gt;collating sequences&lt;/a&gt; that are required by the schema.</source>
          <target state="translated">Загрузите общую библиотеку или DLL-файл LIBRARY в SQLite до вычисления различий. Это можно использовать для добавления определяемых приложением &lt;a href=&quot;datatype3#collation&quot;&gt;последовательностей упорядочения&lt;/a&gt; , которые требуются для схемы.</target>
        </trans-unit>
        <trans-unit id="1f26dca858775a9ffdc6b130413dfda84cf7cc4a" translate="yes" xml:space="preserve">
          <source>LoadAnalysis</source>
          <target state="translated">LoadAnalysis</target>
        </trans-unit>
        <trans-unit id="494260ec047bea19460fac6ca8324736557ff1c6" translate="yes" xml:space="preserve">
          <source>Loadable Extension Thunk</source>
          <target state="translated">Загрузочное расширение Спасибо</target>
        </trans-unit>
        <trans-unit id="a8855a7ba639af1775ee3c99ff39ec45827a09ba" translate="yes" xml:space="preserve">
          <source>Loadable extensions are C-code. To compile them on most unix-like operating systems, the usual command is something like this:</source>
          <target state="translated">Загружаемые расширения-это C-код.Для компиляции их на большинстве unix-подобных операционных систем обычной командой является нечто подобное:</target>
        </trans-unit>
        <trans-unit id="16baeb9dc5c7b831d9570f59926debb8cb175348" translate="yes" xml:space="preserve">
          <source>Local DELETE</source>
          <target state="translated">Местная УДАЛЕТА</target>
        </trans-unit>
        <trans-unit id="ad4c5e9ed0fc895a0d42b932b2926861699fe92c" translate="yes" xml:space="preserve">
          <source>Local INSERT</source>
          <target state="translated">Местный иммиграционный контроль</target>
        </trans-unit>
        <trans-unit id="3e12d4ac47a72a1f8aa6fb2cd56dc176cf45a02b" translate="yes" xml:space="preserve">
          <source>Local UPDATE</source>
          <target state="translated">Локальная дата UPDATE</target>
        </trans-unit>
        <trans-unit id="e88556ba53a549a6a9fbf15298a71732177e868b" translate="yes" xml:space="preserve">
          <source>Localtime modifier</source>
          <target state="translated">Модификатор местного времени</target>
        </trans-unit>
        <trans-unit id="249beb765376acea4283a10da9faa975024e8fe9" translate="yes" xml:space="preserve">
          <source>Lock Name</source>
          <target state="translated">Имя замка</target>
        </trans-unit>
        <trans-unit id="d4795eaa0bbabf21615f9f3e359ab0c2e3631ccd" translate="yes" xml:space="preserve">
          <source>Lock offset</source>
          <target state="translated">Смещение блокировки</target>
        </trans-unit>
        <trans-unit id="eb6bc036bb67cd66abad9bfabc9e6cb6a5eaef00" translate="yes" xml:space="preserve">
          <source>Lock the btree to which cursor P1 is pointing so that the btree cannot be written by an other cursor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de20f3d1eb2301b2722958c2ff4a7d6bd4e9d117" translate="yes" xml:space="preserve">
          <source>Locking and Concurrency</source>
          <target state="translated">Блокировка и конвертация</target>
        </trans-unit>
        <trans-unit id="668186cf26fd89e59f391d180f6666c5c03f0bfa" translate="yes" xml:space="preserve">
          <source>Locking and concurrency control are handled by the &lt;a href=&quot;http://www.sqlite.org/src/finfo?name=src/pager.c&quot;&gt; pager module&lt;/a&gt;. The pager module is responsible for making SQLite &quot;ACID&quot; (Atomic, Consistent, Isolated, and Durable). The pager module makes sure changes happen all at once, that either all changes occur or none of them do, that two or more processes do not try to access the database in incompatible ways at the same time, and that once changes have been written they persist until explicitly deleted. The pager also provides a memory cache of some of the contents of the disk file.</source>
          <target state="translated">Управление блокировкой и параллелизмом осуществляется &lt;a href=&quot;http://www.sqlite.org/src/finfo?name=src/pager.c&quot;&gt;модулем пейджера&lt;/a&gt; . Модуль пейджера отвечает за создание SQLite &amp;laquo;ACID&amp;raquo; (атомарный, согласованный, изолированный и надежный). Модуль пейджера следит за тем, чтобы все изменения происходили одновременно, чтобы были либо все изменения, либо ни одно из них, что два или более процесса не пытались получить доступ к базе данных несовместимыми способами одновременно и что после того, как изменения были записаны, они сохраняются до тех пор, пока явно не будут удалены. Пейджер также обеспечивает кеш-память некоторого содержимого дискового файла.</target>
        </trans-unit>
        <trans-unit id="ed7186a4521b0a419cc417d0bc8ed17722029057" translate="yes" xml:space="preserve">
          <source>Locking and concurrency control are handled by the &lt;a href=&quot;https://www.sqlite.org/src/finfo?name=src/pager.c&quot;&gt; pager module&lt;/a&gt;. The pager module is responsible for making SQLite &quot;ACID&quot; (Atomic, Consistent, Isolated, and Durable). The pager module makes sure changes happen all at once, that either all changes occur or none of them do, that two or more processes do not try to access the database in incompatible ways at the same time, and that once changes have been written they persist until explicitly deleted. The pager also provides a memory cache of some of the contents of the disk file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57d0597b0f360ba173ecb2d2a1f767cb5748ea2e" translate="yes" xml:space="preserve">
          <source>Long Option</source>
          <target state="translated">Длинный вариант</target>
        </trans-unit>
        <trans-unit id="76889c4037fcda94eba3afe630f0b45c824942de" translate="yes" xml:space="preserve">
          <source>Long Term Support</source>
          <target state="translated">Долгосрочная поддержка</target>
        </trans-unit>
        <trans-unit id="fce206f4d564c7fbca45ff9aebf22500127c7c61" translate="yes" xml:space="preserve">
          <source>Long and short style options may be mixed. For example, the following are equivalent:</source>
          <target state="translated">Длинные и короткие варианты стиля могут быть смешанными.Например,следующие варианты эквивалентны:</target>
        </trans-unit>
        <trans-unit id="1a01077cb8c85bad9873673a9051f4ee19688494" translate="yes" xml:space="preserve">
          <source>Longer answer: If you declare a column of a table to be &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;, then whenever you insert a NULL into that column of the table, the NULL is automatically converted into an integer which is one greater than the largest value of that column over all other rows in the table, or 1 if the table is empty. Or, if the largest existing integer key 9223372036854775807 is in use then an unused key value is chosen at random. For example, suppose you have a table like this:</source>
          <target state="translated">Более длинный ответ: если вы объявляете столбец таблицы как &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; , то всякий раз, когда вы вставляете NULL в этот столбец таблицы, NULL автоматически преобразуется в целое число, которое на единицу больше, чем наибольшее значение этого столбца. все остальные строки в таблице или 1, если таблица пуста. Или, если используется самый большой из существующих целочисленных ключей 9223372036854775807, то случайным образом выбирается неиспользуемое значение ключа. Например, предположим, что у вас есть такая таблица:</target>
        </trans-unit>
        <trans-unit id="6e9f2602cf3d1fd809e1312f33acfde2f150141f" translate="yes" xml:space="preserve">
          <source>Lookaside buffer allocations for new &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt;.</source>
          <target state="translated">Резервное выделение буфера для новых &lt;a href=&quot;c3ref/sqlite3&quot;&gt;подключений&lt;/a&gt; к базе данных .</target>
        </trans-unit>
        <trans-unit id="04bd7a984d3646ac5eb9c18de550a3f1e203e5b1" translate="yes" xml:space="preserve">
          <source>Lookaside memory allocator</source>
          <target state="translated">аллокатор Lookaside памяти</target>
        </trans-unit>
        <trans-unit id="fde137681e3baa6ad1143b905327accc0fb28e76" translate="yes" xml:space="preserve">
          <source>Lots of bug fixes.</source>
          <target state="translated">Много исправлений.</target>
        </trans-unit>
        <trans-unit id="990ee2bc3df995ba8afb44c45e674fd9a503ec05" translate="yes" xml:space="preserve">
          <source>Lots of little bug fixes.</source>
          <target state="translated">Множество маленьких исправлений.</target>
        </trans-unit>
        <trans-unit id="43de40a3e36d80f18de0a9c09a14efee88ae8d7f" translate="yes" xml:space="preserve">
          <source>Love chastity.</source>
          <target state="translated">Любовь к целомудрию.</target>
        </trans-unit>
        <trans-unit id="0bbc37af1e456bff56591e973337f95cdf967a70" translate="yes" xml:space="preserve">
          <source>Love fasting.</source>
          <target state="translated">Люблю пост.</target>
        </trans-unit>
        <trans-unit id="b7fcabbc1c2979a6343998251fb3b60ca2fcf13c" translate="yes" xml:space="preserve">
          <source>Love your enemies.</source>
          <target state="translated">Люби своих врагов.</target>
        </trans-unit>
        <trans-unit id="868ab24a96d3a2771240294f216c1eb308fe2112" translate="yes" xml:space="preserve">
          <source>Love your juniors.</source>
          <target state="translated">Любите своих юниоров.</target>
        </trans-unit>
        <trans-unit id="dcbca8259d75e252eae0048dd86f40340f8d0cd8" translate="yes" xml:space="preserve">
          <source>Low-Level Control Of Database Files</source>
          <target state="translated">Низкоуровневый контроль файлов базы данных</target>
        </trans-unit>
        <trans-unit id="c47d12b1a2b47bc6fe16c9cb80aba1cd8b334072" translate="yes" xml:space="preserve">
          <source>Low-dependency</source>
          <target state="translated">Low-dependency</target>
        </trans-unit>
        <trans-unit id="9b49cf9a88d0eb7571f152a707297d6594a2f0d2" translate="yes" xml:space="preserve">
          <source>Low-level system error code</source>
          <target state="translated">Низкоуровневый код системной ошибки</target>
        </trans-unit>
        <trans-unit id="0be209fef2b5ea9e4e344d9742cbe9598db19564" translate="yes" xml:space="preserve">
          <source>Lowest precedence (loosest grouping).</source>
          <target state="translated">Самый низкий приоритет (самая низкая группировка).</target>
        </trans-unit>
        <trans-unit id="f41a055096fba2f5ebbddc8916d81727739dbdb3" translate="yes" xml:space="preserve">
          <source>Lt</source>
          <target state="translated">Lt</target>
        </trans-unit>
        <trans-unit id="c63ae6dd4fc9f9dda66970e827d13f7c73fe841c" translate="yes" xml:space="preserve">
          <source>M</source>
          <target state="translated">M</target>
        </trans-unit>
        <trans-unit id="1e549c8c539e5dd3fb33fffd4ca9bec2df1c3d6b" translate="yes" xml:space="preserve">
          <source>M &amp;amp;times 2&lt;sup&gt;&lt;small&gt;E&lt;/small&gt;&lt;/sup&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4b52e49796d63ce942c6b8bfaa86fb7c20383ea" translate="yes" xml:space="preserve">
          <source>M is always ((U-12)*32/255)-23.</source>
          <target state="translated">M всегда ((U-12)*32/255)-23.</target>
        </trans-unit>
        <trans-unit id="1758fbe17031a1050ba647fef2f5a93784bd0bf5" translate="yes" xml:space="preserve">
          <source>M&lt;sub&gt;&lt;small&gt;left&lt;/small&gt;&lt;/sub&gt;</source>
          <target state="translated">M&lt;sub&gt;&lt;small&gt;left&lt;/small&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="5fbd2551d496e24af3eb24927ec50373a744a672" translate="yes" xml:space="preserve">
          <source>M&lt;sub&gt;&lt;small&gt;left&lt;/small&gt;&lt;/sub&gt;+M&lt;sub&gt;&lt;small&gt;right&lt;/small&gt;&lt;/sub&gt;</source>
          <target state="translated">M&lt;sub&gt;&lt;small&gt;left&lt;/small&gt;&lt;/sub&gt;+M&lt;sub&gt;&lt;small&gt;right&lt;/small&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="835c3f9feac04a1fedeecdc386e908df7274d7ab" translate="yes" xml:space="preserve">
          <source>M&lt;sub&gt;&lt;small&gt;right&lt;/small&gt;&lt;/sub&gt;</source>
          <target state="translated">M&lt;sub&gt;&lt;small&gt;right&lt;/small&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="7e3ce80c0f5019f27debc96398dd7ba53b449b32" translate="yes" xml:space="preserve">
          <source>MASK</source>
          <target state="translated">MASK</target>
        </trans-unit>
        <trans-unit id="4110e0d1b0232ec2802f84b8b4f2d0c2fb3fbbb7" translate="yes" xml:space="preserve">
          <source>MASK bit 0x02 is set.</source>
          <target state="translated">Бит MASK 0x02 установлен.</target>
        </trans-unit>
        <trans-unit id="ce71241b2af9817fe6f961964423ded83b2b2446" translate="yes" xml:space="preserve">
          <source>MATCH</source>
          <target state="translated">MATCH</target>
        </trans-unit>
        <trans-unit id="b4455dc80d567e0a3665a73367ed14020b1b8091" translate="yes" xml:space="preserve">
          <source>MATCH(</source>
          <target state="translated">MATCH(</target>
        </trans-unit>
        <trans-unit id="fb533649ca2f9e73b11b6bb948adb363f958ac9f" translate="yes" xml:space="preserve">
          <source>MEDIUMINT</source>
          <target state="translated">MEDIUMINT</target>
        </trans-unit>
        <trans-unit id="7c2c1a9b5cbb8b738dc37806d8007da0a4dabc51" translate="yes" xml:space="preserve">
          <source>MS-SQL</source>
          <target state="translated">MS-SQL</target>
        </trans-unit>
        <trans-unit id="e6557f13d224519bee5609849fa3b7fe2b045817" translate="yes" xml:space="preserve">
          <source>Macs are unix-like, but they do not follow the usual shared library conventions. To compile a shared library on a Mac, use a command like this:</source>
          <target state="translated">Масы Mac похожи на unix,но они не следуют обычным конвенциям об общих библиотеках.Для компиляции разделяемой библиотеки на Mac используйте команду,подобную этой:</target>
        </trans-unit>
        <trans-unit id="a1e5337bd6f525fef1a4495aefda7354ea999138" translate="yes" xml:space="preserve">
          <source>Made selected parameters in API functions &lt;b&gt;const&lt;/b&gt;. This should be fully backwards compatible.</source>
          <target state="translated">Сделал выбранные параметры в функциях API &lt;b&gt;const&lt;/b&gt; . Это должно быть полностью обратно совместимо.</target>
        </trans-unit>
        <trans-unit id="debb142b11cd7000f7ccf5be052a02bcc1c7f9ef" translate="yes" xml:space="preserve">
          <source>Made the &lt;a href=&quot;testing#aflfuzz&quot;&gt;American Fuzzy Lop fuzzer&lt;/a&gt; a standard part of SQLite's &lt;a href=&quot;testing&quot;&gt;testing strategy&lt;/a&gt;.</source>
          <target state="translated">Сделал &lt;a href=&quot;testing#aflfuzz&quot;&gt;американский фаззер Fuzzy Lop&lt;/a&gt; стандартной частью &lt;a href=&quot;testing&quot;&gt;стратегии тестирования&lt;/a&gt; SQLite .</target>
        </trans-unit>
        <trans-unit id="aadd04e928883126f21deaf37b5282558e747d50" translate="yes" xml:space="preserve">
          <source>Made the CACHE_SIZE pragma persistent</source>
          <target state="translated">Сделали прагму CACHE_SIZE упорной</target>
        </trans-unit>
        <trans-unit id="2d544f28a897acf54e3872442614c2de63e16acf" translate="yes" xml:space="preserve">
          <source>Magic number. 0x377f0682 or 0x377f0683</source>
          <target state="translated">Волшебное число.0x377f0682 или 0x377f0683</target>
        </trans-unit>
        <trans-unit id="a249757e280e4c1ed4596ef256151f0633cc5c86" translate="yes" xml:space="preserve">
          <source>Maintaining 100% MC/DC is laborious and time-consuming. The level of effort needed to maintain full-coverage testing is probably not cost effective for a typical application. However, we think that full-coverage testing is justified for a &lt;a href=&quot;https://sqlite.org/mostdeployed.html&quot;&gt;very widely deployed&lt;/a&gt; infrastructure library like SQLite, and especially for a database library which by its very nature &quot;remembers&quot; past mistakes.</source>
          <target state="translated">Поддержание 100% MC / DC трудоемко и требует много времени. Уровень усилий, необходимых для поддержки тестирования с полным покрытием, вероятно, не является рентабельным для типичного приложения. Однако мы считаем, что тестирование с полным покрытием оправдано для &lt;a href=&quot;https://sqlite.org/mostdeployed.html&quot;&gt;очень широко распространенной&lt;/a&gt; библиотеки инфраструктуры, такой как SQLite, и особенно для библиотеки баз данных, которая по самой своей природе &amp;laquo;помнит&amp;raquo; прошлые ошибки.</target>
        </trans-unit>
        <trans-unit id="0690809fdfc162c136b84c90c7f6551b5a7d6bb1" translate="yes" xml:space="preserve">
          <source>Maintaining Private Branches Of SQLite</source>
          <target state="translated">Поддержание частных филиалов SQLite</target>
        </trans-unit>
        <trans-unit id="74db8285437f292d07f23511a8853dab08df8f69" translate="yes" xml:space="preserve">
          <source>Make &lt;a href=&quot;c3ref/compileoption_get&quot;&gt;sqlite3_compileoption_used()&lt;/a&gt; responsive to the &lt;a href=&quot;compile#enable_dbstat_vtab&quot;&gt;SQLITE_ENABLE_DBSTAT_VTAB&lt;/a&gt; compile-time option.</source>
          <target state="translated">Сделайте &lt;a href=&quot;c3ref/compileoption_get&quot;&gt;sqlite3_compileoption_used () &lt;/a&gt;&lt;a href=&quot;compile#enable_dbstat_vtab&quot;&gt;зависимым&lt;/a&gt; от параметра времени компиляции SQLITE_ENABLE_DBSTAT_VTAB .</target>
        </trans-unit>
        <trans-unit id="f178a74cc1dcf57fcc7b73994685f97569f4844f" translate="yes" xml:space="preserve">
          <source>Make AreFileApisANSI() a no-op macro in WinCE since WinCE does not support this function.</source>
          <target state="translated">Сделайте AreFileApisANSI()нулевым макросом в WinCE,так как WinCE не поддерживает эту функцию.</target>
        </trans-unit>
        <trans-unit id="07dc88b6cef4d75e2f7c3880e8647593525aa07e" translate="yes" xml:space="preserve">
          <source>Make CSV (comma separate value) output from the command-line shell more closely aligned to accepted practice</source>
          <target state="translated">Сделать вывод CSV (значение,отделенное запятой)из командной строки,более близким к общепринятой практике</target>
        </trans-unit>
        <trans-unit id="7ebdddec87e9007589d5ada3e116c78e26d2e69a" translate="yes" xml:space="preserve">
          <source>Make LIMIT work on a compound SELECT statement.</source>
          <target state="translated">Заставьте LIMIT работать над комплексным заявлением SELECT.</target>
        </trans-unit>
        <trans-unit id="67a20c818425dd125a3dee8478ee3f7563c8b234" translate="yes" xml:space="preserve">
          <source>Make a copy of registers P1..P1+P3 into registers P2..P2+P3.</source>
          <target state="translated">Сделайте копию регистров P1...P1+P3 в регистры P2...P2+P3.</target>
        </trans-unit>
        <trans-unit id="8d0b0f116d9ed8fdf1c047e6cff51269d6d08bd0" translate="yes" xml:space="preserve">
          <source>Make a distinction between numeric and text values when sorting. Text values sort according to memcmp(). Numeric values sort in numeric order.</source>
          <target state="translated">При сортировке следует различать числовые и текстовые значения.Текстовые значения сортируются по функции memcmp().Числовые значения сортируются в числовом порядке.</target>
        </trans-unit>
        <trans-unit id="9f53feddfd33da18e3bb3466ea22bc837873fc9d" translate="yes" xml:space="preserve">
          <source>Make a shallow copy of register P1 into register P2.</source>
          <target state="translated">Сделайте неглубокую копию регистра P1 в регистр P2.</target>
        </trans-unit>
        <trans-unit id="c4914cad6e6db40e49d46939d936ae678cbe7888" translate="yes" xml:space="preserve">
          <source>Make every effort to allocate a new page. Only return NULL if allocating a new page is effectively impossible.</source>
          <target state="translated">Приложите все усилия,чтобы выделить новую страницу.Возвращайте NULL только в том случае,если выделение новой страницы фактически невозможно.</target>
        </trans-unit>
        <trans-unit id="94089eca234684dc20cbdb2f8434b3d3fb23b40c" translate="yes" xml:space="preserve">
          <source>Make peace with your adversary before the sun sets.</source>
          <target state="translated">Помиритесь с противником до захода солнца.</target>
        </trans-unit>
        <trans-unit id="b31d5954ede96c4a01bf917d9892337c3c9f6de7" translate="yes" xml:space="preserve">
          <source>Make sure ORDER BY puts rows in ascending order even if the DISTINCT operator is implemented using a descending index. Fix for ticket &lt;a href=&quot;https://www.sqlite.org/src/info/c5ea805691bfc4204b1cb9e&quot;&gt;c5ea805691bfc4204b1cb9e&lt;/a&gt;.</source>
          <target state="translated">Убедитесь, что ORDER BY помещает строки в порядке возрастания, даже если оператор DISTINCT реализован с использованием убывающего индекса. Исправление для билета &lt;a href=&quot;https://www.sqlite.org/src/info/c5ea805691bfc4204b1cb9e&quot;&gt;c5ea805691bfc4204b1cb9e&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fd7437d47e0ca64701851f46718248492d235445" translate="yes" xml:space="preserve">
          <source>Make sure VIEWs are created after their corresponding TABLEs in the output of the &lt;b&gt;.dump&lt;/b&gt; command in the shell.</source>
          <target state="translated">Убедитесь, что ВИДЫ создаются после соответствующих ТАБЛИЦ в выводе команды &lt;b&gt;.dump&lt;/b&gt; в оболочке.</target>
        </trans-unit>
        <trans-unit id="b8fc01ec14bc51db67a6c7f295254a0473ee78c4" translate="yes" xml:space="preserve">
          <source>Make sure all individual database files have an EXCLUSIVE lock and a valid journal.</source>
          <target state="translated">Убедитесь,что все отдельные файлы базы данных имеют ЭКСКЛЮЗИВНЫЙ БЛОКИРОВКУ и действующий журнал.</target>
        </trans-unit>
        <trans-unit id="39ceab29d21e2433cf3cad2d290185c2cdda1b07" translate="yes" xml:space="preserve">
          <source>Make sure all rollback journal data has actually been written to the surface of the disk (and is not just being held in the operating system's or disk controllers cache) so that if a power failure occurs the data will still be there after power is restored.</source>
          <target state="translated">Убедитесь,что все данные журнала отката действительно записаны на поверхность диска (а не просто хранятся в кэше операционной системы или контроллеров дисков),так что в случае отключения питания данные все равно останутся там после восстановления питания.</target>
        </trans-unit>
        <trans-unit id="faaff6cbdbf4873f3d095a4a0e2d87974475615a" translate="yes" xml:space="preserve">
          <source>Make sure functions expressions in the VALUES clause of an INSERT are correct.</source>
          <target state="translated">Убедитесь,что выражения функций в выражении VALUES в INSERT корректны.</target>
        </trans-unit>
        <trans-unit id="b3c87542457fbfa0848fd99500f7827664d328fc" translate="yes" xml:space="preserve">
          <source>Make sure that database filenames follow the 8+3 filename format and that they do not have an empty name or extension. In other words, the database filename must contain between 1 and 8 characters in the base name and between 1 and 3 characters in the extension. Blank extensions are not allowed.</source>
          <target state="translated">Убедитесь,что имена файлов базы данных соответствуют формату 8+3 и что у них нет пустого имени или расширения.Другими словами,имя файла базы данных должно содержать от 1 до 8 символов в базовом имени и от 1 до 3 символов в расширении.Пустые расширения не допускаются.</target>
        </trans-unit>
        <trans-unit id="559ee78af19e40cf8fa346787df1709761be2f3c" translate="yes" xml:space="preserve">
          <source>Make sure that when a connection blocks on a RESERVED lock that it is able to continue after the lock is released. (Ticket #3093)</source>
          <target state="translated">Убедитесь,что при блокировке соединения на блокировке RESERVED оно может продолжить работу после снятия блокировки.(Билет № 3093)</target>
        </trans-unit>
        <trans-unit id="6c2032f0b0a487670b92ae7b1f7c2a4d3713ca71" translate="yes" xml:space="preserve">
          <source>Make sure the &lt;a href=&quot;c3ref/get_auxdata&quot;&gt;sqlite3_set_auxdata()&lt;/a&gt; values from multiple triggers within a single statement do not interfere with one another. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/dc9b1c91&quot;&gt;dc9b1c91&lt;/a&gt;.</source>
          <target state="translated">Убедитесь, что значения &lt;a href=&quot;c3ref/get_auxdata&quot;&gt;sqlite3_set_auxdata ()&lt;/a&gt; из нескольких триггеров в одном операторе не мешают друг другу. Билет &lt;a href=&quot;https://www.sqlite.org/src/info/dc9b1c91&quot;&gt;dc9b1c91&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c6638940c401bf7e1c92493be7672af3af206b2b" translate="yes" xml:space="preserve">
          <source>Make sure the &lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_snprintf()&lt;/a&gt; interface does not zero-terminate the buffer if the buffer size is less than 1. Ticket #2341</source>
          <target state="translated">Убедитесь, что интерфейс &lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_snprintf ()&lt;/a&gt; не завершает буфер нулем, если размер буфера меньше 1. Билет № 2341</target>
        </trans-unit>
        <trans-unit id="3bc85b9279a5981ff83181cec093f69c7042f9c4" translate="yes" xml:space="preserve">
          <source>Make sure the MIN() and MAX() optimizations work within subqueries.</source>
          <target state="translated">Убедитесь,что оптимизации MIN()и MAX()работают внутри подзапросов.</target>
        </trans-unit>
        <trans-unit id="58ff8f836097af00b92625ae2c5e983cf4412032" translate="yes" xml:space="preserve">
          <source>Make sure the ORDER BY LIMIT optimization (from check-in &lt;a href=&quot;https://www.sqlite.org/src/info/559733b09e9630fa&quot;&gt;559733b09e&lt;/a&gt;) works with IN operators on INTEGER PRIMARY KEYs. Fix for ticket &lt;a href=&quot;https://www.sqlite.org/src/info/96c1454cbfd9509&quot;&gt;96c1454c&lt;/a&gt;</source>
          <target state="translated">Убедитесь, что оптимизация ORDER BY LIMIT (из проверки &lt;a href=&quot;https://www.sqlite.org/src/info/559733b09e9630fa&quot;&gt;559733b09e&lt;/a&gt; ) работает с операторами IN на INTEGER PRIMARY KEYs. Исправление для билета &lt;a href=&quot;https://www.sqlite.org/src/info/96c1454cbfd9509&quot;&gt;96c1454c&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3ea00b4a5adf172672ba7e54a20e155f2d4f11b3" translate="yes" xml:space="preserve">
          <source>Make sure the TCL language interface works correctly with 64-bit integers on 64-bit machines.</source>
          <target state="translated">Убедитесь,что интерфейс языка TCL корректно работает с 64-битными целыми числами на 64-битных машинах.</target>
        </trans-unit>
        <trans-unit id="2c7d7b5412a65ed5d6ce615755d9929fa6d57cca" translate="yes" xml:space="preserve">
          <source>Make sure the in-memory backend response sanely if malloc() fails.</source>
          <target state="translated">Убедитесь,что ответ бэкенда in-memory в здравом уме,если malloc()не срабатывает.</target>
        </trans-unit>
        <trans-unit id="eae9ed5b156bcdd54a8967008569fef435a53021" translate="yes" xml:space="preserve">
          <source>Make sure the query optimizer checks dependencies on all terms of a compound SELECT statement. Ticket #2640.</source>
          <target state="translated">Убедитесь,что оптимизатор запросов проверяет зависимости от всех условий составного SELECT-оператора.Билет № 2640.</target>
        </trans-unit>
        <trans-unit id="30c0cf0484d7a5f504b6b728788d263a9e41fc0c" translate="yes" xml:space="preserve">
          <source>Make sure you type a semicolon at the end of each SQL command! The sqlite3 program looks for a semicolon to know when your SQL command is complete. If you omit the semicolon, sqlite3 will give you a continuation prompt and wait for you to enter more text to be added to the current SQL command. This feature allows you to enter SQL commands that span multiple lines. For example:</source>
          <target state="translated">Убедитесь,что в конце каждой команды SQL вы напечатали точку с запятой! Программа sqlite3 ищет точку с запятой,чтобы узнать,когда Ваша команда SQL будет завершена.Если Вы опустите точку с запятой,sqlite3 даст Вам запрос на продолжение и будет ждать,пока Вы не введете больше текста для добавления в текущую команду SQL.Эта функция позволяет вводить команды SQL,которые охватывают несколько строк.Например:</target>
        </trans-unit>
        <trans-unit id="0f78a73d59843cf77efe52a3fb9a1c8bc577fb63" translate="yes" xml:space="preserve">
          <source>Make that script executable and put it on your $PATH. Then compile the kvtest program as follows:</source>
          <target state="translated">Сделайте этот сценарий исполняемым и положите его на ваш $PATH.Затем скомпилируйте программу kvtest следующим образом:</target>
        </trans-unit>
        <trans-unit id="55a8e3fef2599367be1f179f0eeae6e3f90c5562" translate="yes" xml:space="preserve">
          <source>Make the &quot;AS&quot; keyword optional again.</source>
          <target state="translated">Сделайте снова необязательным ключевое слово &quot;AS&quot;.</target>
        </trans-unit>
        <trans-unit id="e8d3c7849aaf72378ce97fad0ef58bb50dfa844b" translate="yes" xml:space="preserve">
          <source>Make the &lt;a href=&quot;dbstat&quot;&gt;dbstat virtual table&lt;/a&gt; part of standard builds when compiled with the &lt;a href=&quot;compile#enable_dbstat_vtab&quot;&gt;SQLITE_ENABLE_DBSTAT_VTAB&lt;/a&gt; option.</source>
          <target state="translated">Сделайте &lt;a href=&quot;dbstat&quot;&gt;виртуальную таблицу dbstat&lt;/a&gt; частью стандартных сборок при компиляции с опцией &lt;a href=&quot;compile#enable_dbstat_vtab&quot;&gt;SQLITE_ENABLE_DBSTAT_VTAB&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3cf1a1fb81ef7a54777705fadfc53565c39e040a" translate="yes" xml:space="preserve">
          <source>Make the GLOB and LIKE operators functions that can be overridden by a programmer. This allows, for example, the LIKE operator to be changed to be case sensitive.</source>
          <target state="translated">Сделайте функции операторов GLOB и LIKE,которые могут быть переопределены программистом.Это позволяет,например,изменять оператор LIKE на регистрозависимый.</target>
        </trans-unit>
        <trans-unit id="06d1ed76522acc5f77d35b87ff9bcb7713142c7d" translate="yes" xml:space="preserve">
          <source>Make the LIMIT clause work on subqueries. (ORDER BY still does not work, though.)</source>
          <target state="translated">Заставьте пункт LIMIT работать над подзапросами.(ЗАКАЗАТЕЛЬСТВО ЗАПРЕЩАЕТСЯ все равно не работает.)</target>
        </trans-unit>
        <trans-unit id="e949e24407b3c3e74908e043648105301add53c5" translate="yes" xml:space="preserve">
          <source>Make the library thread-safe. (The code is there and appears to work but has not been stressed.)</source>
          <target state="translated">Сделайте библиотеку безопасной для нитей.(Код есть,и кажется,что он работает,но не был подчеркнут).</target>
        </trans-unit>
        <trans-unit id="aa1b502d7a3d8467cdd71e12de59017bd7bf7832" translate="yes" xml:space="preserve">
          <source>Make the os.h header file more robust in detecting when the compile is for Windows and when it is for Unix.</source>
          <target state="translated">Сделайте заголовочный файл os.h более надежным в обнаружении,когда компиляция для Windows,а когда для Unix.</target>
        </trans-unit>
        <trans-unit id="5b70367d16489f70b60357dd49e971c66ecb7a25" translate="yes" xml:space="preserve">
          <source>Make use of OVERLAPPED in the windows &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; to avoid some system calls and thereby obtain a performance improvement.</source>
          <target state="translated">Используйте OVERLAPPED в Windows &lt;a href=&quot;vfs&quot;&gt;VFS,&lt;/a&gt; чтобы избежать некоторых системных вызовов и тем самым повысить производительность.</target>
        </trans-unit>
        <trans-unit id="bb3c80011eafc56757b5115bd6da6df2d3cc0bcf" translate="yes" xml:space="preserve">
          <source>Make use of the one-pass UPDATE and DELETE query plans in the &lt;a href=&quot;rtree&quot;&gt;R-Tree extension&lt;/a&gt; where appropriate.</source>
          <target state="translated">При необходимости используйте однопроходные планы запросов UPDATE и DELETE в &lt;a href=&quot;rtree&quot;&gt;расширении R-Tree&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9c7ffc0af1b5a78c06ebbd279554c53e269060be" translate="yes" xml:space="preserve">
          <source>MakeRecord</source>
          <target state="translated">MakeRecord</target>
        </trans-unit>
        <trans-unit id="decb5fb2e05d5246774c7c119193e5dd3eeab585" translate="yes" xml:space="preserve">
          <source>Makefile updates</source>
          <target state="translated">Обновления Makefile</target>
        </trans-unit>
        <trans-unit id="3e75c9edc23a32990a13f91bc222c1cd2fb310c7" translate="yes" xml:space="preserve">
          <source>Makefile updates and miscellaneous bug fixes.</source>
          <target state="translated">Обновления Makefile и различные исправления ошибок.</target>
        </trans-unit>
        <trans-unit id="bdecdca82af325fcab74535c838b3bad719fc7de" translate="yes" xml:space="preserve">
          <source>Makefile updates from A. Rottmann</source>
          <target state="translated">Обновления Makefile от A.Rottmann</target>
        </trans-unit>
        <trans-unit id="1a74e86adcd0000bd7de1be192d074c821dd68c1" translate="yes" xml:space="preserve">
          <source>Making Other Kinds Of Table Schema Changes</source>
          <target state="translated">Изменение схем таблиц других типов</target>
        </trans-unit>
        <trans-unit id="e6fe063cab95ff9f5d6ec0129688c23c296059b5" translate="yes" xml:space="preserve">
          <source>Malformed UTF-8 that SQLite converts to a UTF-16 byte-order-mark is embedded at the beginning of an SQL string literal value inserted into an FTS3 table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e30f6661f23230d01a3d07773b601db8982cabdd" translate="yes" xml:space="preserve">
          <source>Malformed database tests</source>
          <target state="translated">Испытания базы данных на наличие ошибок</target>
        </trans-unit>
        <trans-unit id="aa578a91aad5dc4dab2da9a4bac602790d836ae2" translate="yes" xml:space="preserve">
          <source>Malicious SQL statement (an ALTER TABLE that tries to rename a &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; into one of its own &lt;a href=&quot;vtab#xshadowname&quot;&gt;shadow tables&lt;/a&gt;) causes an infinite loop and denial of service. &lt;a href=&quot;https://sqlite.org/src/info/eca0ba2cf4c0fdf7&quot;&gt;(details)&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3505da2486b779eca8455a74c0a2213782342dc" translate="yes" xml:space="preserve">
          <source>Malicious SQL statement causes a NULL pointer dereference and denial-of-service &lt;a href=&quot;https://www.sqlite.org/src/info/1bc783da63d58b05&quot;&gt;(details)&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b3de4ef5153133c67b1a8788b48babe0af12634" translate="yes" xml:space="preserve">
          <source>Malicious SQL statement causes a NULL pointer dereference and denial-of-service. &lt;a href=&quot;https://www.sqlite.org/src/info/862974312edf00e9&quot;&gt;(details)&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f05b51d00c5136f9765e2a5529ff25dd76521560" translate="yes" xml:space="preserve">
          <source>Malicious SQL statement causes a NULL pointer dereference and in the &lt;a href=&quot;zipfile&quot;&gt;Zipfile virtual table&lt;/a&gt; extension and denial-of-service. This is only possible when the optional &lt;a href=&quot;zipfile&quot;&gt;Zipfile virtual table&lt;/a&gt; extension is deployed, which is not the case in default builds. &lt;a href=&quot;https://www.sqlite.org/src/info/a80f84b511231204&quot;&gt;(details)&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3223f276a85bbea2e40f22c66ab04105f353da0b" translate="yes" xml:space="preserve">
          <source>Malicious SQL statement causes a NULL pointer dereference in the &lt;a href=&quot;zipfile&quot;&gt;Zipfile virtual table&lt;/a&gt; extension and denial-of-service. This is only possible when the optional &lt;a href=&quot;zipfile&quot;&gt;Zipfile virtual table&lt;/a&gt; extension is deployed, which is not the case in default builds. &lt;a href=&quot;https://www.sqlite.org/src/info/cc0fb00a128fd077&quot;&gt;(details)&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be787da663e373d3f7997d1441cd2ca035e3495f" translate="yes" xml:space="preserve">
          <source>Malicious SQL statement causes a read access to a NULL pointer and denial of service. &lt;a href=&quot;https://www.sqlite.org/src/info/7a5279a25c57adf1&quot;&gt;(details)&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b7808ef1d93533f98b34a6af3e305d6a4a79902" translate="yes" xml:space="preserve">
          <source>Malicious SQL statement causes a read of a NULL pointer in the &lt;a href=&quot;fts3#matchinfo&quot;&gt;matchinfo()&lt;/a&gt; SQL function of the &lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt; extension, resulting in denial of service. &lt;a href=&quot;https://sqlite.org/src/info/a4dd148928ea65bd&quot;&gt;(details)&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb5500a4c4534dd4662f8932a169f8e6f4053c24" translate="yes" xml:space="preserve">
          <source>Malicious SQL statement causes a read using an uninitialized pointer and denial-of-service &lt;a href=&quot;https://www.sqlite.org/src/info/4374860b29383380&quot;&gt;(details)&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08a51de55d02f39c503f43bf8dbb67b4a981750f" translate="yes" xml:space="preserve">
          <source>Malicious SQL statement causes a read using an uninitialized pointer and denial-of-service. &lt;a href=&quot;https://www.sqlite.org/src/info/af4556bb5c285c08&quot;&gt;(details)&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f420ed40458097230e18bc609dc3d6070a139e7" translate="yes" xml:space="preserve">
          <source>Malicious SQL statement causes a read-only use-after-free memory error. &lt;a href=&quot;https://sqlite.org/src/info/c8d3b9f0a750a529&quot;&gt;(details)&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c7315e30c332568a87d33624f52296d256dba71" translate="yes" xml:space="preserve">
          <source>Malicious SQL statement causes a read-only use-after-free, possibly resulting in a incorrect output from the &lt;a href=&quot;fts3#snippet&quot;&gt;snippet()&lt;/a&gt; SQL function of the &lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt; extension. There is no known way to exfiltrate data or crash the application using this bug. &lt;a href=&quot;https://sqlite.org/src/info/0d69f76f0865f962&quot;&gt;(details)&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="605174f0d56c0319ea8c88e54fd141ec899039f3" translate="yes" xml:space="preserve">
          <source>Malicious SQL statement causes a uninitialized pointer reference and denial-of-service. &lt;a href=&quot;https://www.sqlite.org/src/info/e2bddcd4c55ba3cb&quot;&gt;(details)&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a3d15a3efb587f7e5d31ca19ff99f19bff90311" translate="yes" xml:space="preserve">
          <source>Malicious SQL statement causes an read past the end of a heap buffer. &lt;a href=&quot;https://sqlite.org/src/info/8f157e8010b22af0&quot;&gt;(details)&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3460af9ab9b12af9da67324f2da63f63e80a6848" translate="yes" xml:space="preserve">
          <source>Malicious SQL statement causes an uninitialized pointer read and denial-of-service. &lt;a href=&quot;https://www.sqlite.org/src/info/cba2a2a44cdf138a&quot;&gt;(details)&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b341edff7ed671940a8d972691c324a8c7d62137" translate="yes" xml:space="preserve">
          <source>Malicious SQL statement causes an uninitialized pointer read and denial-of-service. &lt;a href=&quot;https://www.sqlite.org/src/timeline?r=better-error-handling-1&quot;&gt;(details)&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be80211b17a199f937f0a9b644dfd18f1e2cecb3" translate="yes" xml:space="preserve">
          <source>Malicious SQL statement causes read-only use-after-free of memory allocation if SQLite is compile with -DSQLITE_DEBUG. Does not affect release builds. &lt;a href=&quot;https://www.sqlite.org/src/info/4722bdab08cb1&quot;&gt;(details)&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90aacfe82b6d869ef75232c639a3bc16d905426f" translate="yes" xml:space="preserve">
          <source>Malicious SQL statement involving the printf() SQL function results in an integer overflow which can overwrite the stack with over 2 billion bytes of 0x30 or 0x20 (ASCII '0' or ' '). Even though this is a stack overwrite, there is no known way to redirect control or otherwise escalate the level of harm. This is a denial-of-service attack only. &lt;a href=&quot;https://www.sqlite.org/src/info/23439ea582241138&quot;&gt;(details)&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6314779095d53af544ef97df23a24554ee88bdd" translate="yes" xml:space="preserve">
          <source>Managing SQLite Archives from the command-line</source>
          <target state="translated">Управление архивами SQLite из командной строки</target>
        </trans-unit>
        <trans-unit id="3fbc66cdb2efde39d2ec8d74f242ca151b4515bd" translate="yes" xml:space="preserve">
          <source>Manifest Typing and BLOB Support</source>
          <target state="translated">Манифест ввода и BLOB-поддержка</target>
        </trans-unit>
        <trans-unit id="bb55c1a865472533208270e05409a59df50af4d8" translate="yes" xml:space="preserve">
          <source>Manifest typing and BLOB support.</source>
          <target state="translated">Манифест набора и поддержка BLOB.</target>
        </trans-unit>
        <trans-unit id="1cc470a30ade4f894dfdc6d3819af02869f9a0ff" translate="yes" xml:space="preserve">
          <source>Manual Control Of Query Plans Using CROSS JOIN</source>
          <target state="translated">Ручное управление планами запросов с помощью CROSS JOIN</target>
        </trans-unit>
        <trans-unit id="cd08ce62fe23d2df3bf17c27439fcc586ae7eb2c" translate="yes" xml:space="preserve">
          <source>Manual Control Of Query Plans Using SQLITE_STAT Tables</source>
          <target state="translated">Ручное управление планами запросов с помощью таблиц SQLITE_STAT</target>
        </trans-unit>
        <trans-unit id="6ce25f14125bd349207477d6be9b5bb56a241bb2" translate="yes" xml:space="preserve">
          <source>Many SQLITE_OMIT_ macros inserts to omit features at compile-time and reduce the library footprint.</source>
          <target state="translated">Многие макросы SQLITE_OMIT_вставляются для того,чтобы опустить возможности во время компиляции и уменьшить нагрузку на библиотеку.</target>
        </trans-unit>
        <trans-unit id="58bc21cac299bf4ec03f599485fd07e14baffb8d" translate="yes" xml:space="preserve">
          <source>Many SQLite functions return an integer result code from the set shown here in order to indicate success or failure.</source>
          <target state="translated">Многие функции SQLite возвращают целочисленный код результата из приведенного здесь набора,чтобы указать на успех или неудачу.</target>
        </trans-unit>
        <trans-unit id="29bbffe8721f3a2848d887e1fb7a366159ccdc97" translate="yes" xml:space="preserve">
          <source>Many Small Queries Are Efficient In SQLite</source>
          <target state="translated">Многие малые запросы эффективны в SQLite</target>
        </trans-unit>
        <trans-unit id="b88b7072aba4a1d9cfba91839cebc05836eb0907" translate="yes" xml:space="preserve">
          <source>Many applications destroy their &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt; using calls to &lt;a href=&quot;c3ref/close&quot;&gt;sqlite3_close()&lt;/a&gt; at shutdown. Or, for example, an application that uses SQLite as its &lt;a href=&quot;appfileformat&quot;&gt;application file format&lt;/a&gt; might open &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt; in response to a File/Open menu action and then destroy the corresponding &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; in response to the File/Close menu.</source>
          <target state="translated">Многие приложения разрушают свои &lt;a href=&quot;c3ref/sqlite3&quot;&gt;соединения&lt;/a&gt; с базой данных, используя вызовы &lt;a href=&quot;c3ref/close&quot;&gt;sqlite3_close ()&lt;/a&gt; при завершении работы. Или, например, приложение, использующее SQLite в качестве &lt;a href=&quot;appfileformat&quot;&gt;формата файла приложения,&lt;/a&gt; может открывать &lt;a href=&quot;c3ref/sqlite3&quot;&gt;соединения с базой данных&lt;/a&gt; в ответ на действие меню &amp;laquo;Файл / Открыть&amp;raquo;, а затем разрушать соответствующее &lt;a href=&quot;c3ref/sqlite3&quot;&gt;соединение с базой данных&lt;/a&gt; в ответ на меню &amp;laquo;Файл / Закрыть&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="e4e81b55d5c98ead21919f5ad70f41ad3433a3b2" translate="yes" xml:space="preserve">
          <source>Many applications use SQLite as a cache of relevant content from an enterprise RDBMS. This reduces latency, since most queries now occur against the local cache and avoid a network round-trip. It also reduces the load on the network and on the central database server. And in many cases, it means that the client-side application can continue operating during network outages.</source>
          <target state="translated">Многие приложения используют SQLite в качестве кэша соответствующего контента корпоративной СУБД.Это сокращает задержки,поскольку большинство запросов теперь выполняется против локального кэша и позволяет избежать обхода сети.Это также снижает нагрузку на сеть и центральный сервер базы данных.А во многих случаях это означает,что клиентское приложение может продолжать работать во время сбоев в сети.</target>
        </trans-unit>
        <trans-unit id="0a456e7268dde3087ce48e51e3014a05bf0f0916" translate="yes" xml:space="preserve">
          <source>Many code simplifications and obscure bug fixes in support of providing &lt;a href=&quot;testing#coverage&quot;&gt;100% branch test coverage&lt;/a&gt;.</source>
          <target state="translated">Множество упрощений кода и неясных исправлений ошибок в поддержку обеспечения &lt;a href=&quot;testing#coverage&quot;&gt;100% покрытия тестами ветвей&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a1bfd103f34c0767adc1c7bc9d7d6d545e23cabf" translate="yes" xml:space="preserve">
          <source>Many documentation updates</source>
          <target state="translated">Многие обновления документации</target>
        </trans-unit>
        <trans-unit id="3c83fd215f6013569c8872261f46c5842b6f52ba" translate="yes" xml:space="preserve">
          <source>Many examples of complete and working loadable extensions can be seen in the SQLite source tree in the &lt;a href=&quot;https://www.sqlite.org/src/file/ext/misc&quot;&gt;ext/misc&lt;/a&gt; subdirectory. Each file in that directory is a separate extension. Documentation is provided by a header comment on the file. Here are brief notes on a few of the extensions in the &lt;a href=&quot;https://www.sqlite.org/src/file/ext/misc&quot;&gt;ext/misc&lt;/a&gt; subdirectory:</source>
          <target state="translated">Многие примеры полных и работающих загружаемых расширений можно увидеть в дереве исходного кода SQLite в подкаталоге &lt;a href=&quot;https://www.sqlite.org/src/file/ext/misc&quot;&gt;ext / misc&lt;/a&gt; . Каждый файл в этом каталоге имеет отдельное расширение. Документация предоставляется в виде комментария к файлу в заголовке. Вот краткие заметки о некоторых расширениях в подкаталоге &lt;a href=&quot;https://www.sqlite.org/src/file/ext/misc&quot;&gt;ext / misc&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="8839fb36ad323ef0ec4cee25a22e0e9113f3684b" translate="yes" xml:space="preserve">
          <source>Many historical versions of the SQLite documentation used a different process for generating the syntax diagrams. The historical process was based on Tcl/Tk and is described at &lt;a href=&quot;http://wiki.tcl-lang.org/21708&quot;&gt;http://wiki.tcl-lang.org/21708&lt;/a&gt;. The newer Pikchr-based syntax diagrams first landed on trunk on 2020-09-26.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c27368aaf7a63c4c54dd85e130e6a371a0b652db" translate="yes" xml:space="preserve">
          <source>Many improvements and cleanups to the configure script</source>
          <target state="translated">Множество улучшений и чисток в сценарии настройки</target>
        </trans-unit>
        <trans-unit id="478a301b607ffcc6373478ce0ad5e01e286e6440" translate="yes" xml:space="preserve">
          <source>Many improvements and enhancements to the shell.</source>
          <target state="translated">Множество усовершенствований и улучшений в корпусе.</target>
        </trans-unit>
        <trans-unit id="86f119ce378fd6fb5c391277ea97047cef855bbe" translate="yes" xml:space="preserve">
          <source>Many improvements to the test suite. Test coverage now exceeded 98%</source>
          <target state="translated">Множество улучшений в тестовом комплекте.Покрытие теста теперь превысило 98%</target>
        </trans-unit>
        <trans-unit id="ec9cc9f8a731e2c88a6a0e04dca8da72cc53d489" translate="yes" xml:space="preserve">
          <source>Many micro-optimizations result in 20.3% more work for the same number of CPU cycles relative to the previous release. The cumulative performance increase since &lt;a href=&quot;#version_3_8_0&quot;&gt;version 3.8.0&lt;/a&gt; is 61%. (Measured using &lt;a href=&quot;http://valgrind.org/docs/manual/cg-manual.html&quot;&gt;cachegrind&lt;/a&gt; on the &lt;a href=&quot;http://www.sqlite.org/src/artifact/83f6b3318f7ee&quot;&gt;speedtest1.c&lt;/a&gt; workload on Ubuntu 13.10 x64 with gcc 4.8.1 and -Os. Your performance may vary.)</source>
          <target state="translated">Многие микрооптимизации приводят к увеличению объема работы на 20,3% при том же количестве циклов процессора по сравнению с предыдущим выпуском. Совокупное увеличение производительности с &lt;a href=&quot;#version_3_8_0&quot;&gt;версии 3.8.0&lt;/a&gt; составляет 61%. (Измерено с помощью &lt;a href=&quot;http://valgrind.org/docs/manual/cg-manual.html&quot;&gt;cachegrind&lt;/a&gt; на рабочей нагрузке &lt;a href=&quot;http://www.sqlite.org/src/artifact/83f6b3318f7ee&quot;&gt;speedtest1.c&lt;/a&gt; в Ubuntu 13.10 x64 с gcc 4.8.1 и -Os. Ваша производительность может отличаться.)</target>
        </trans-unit>
        <trans-unit id="e6450a66ff66bca179b7e4def9ab1ada6c17e749" translate="yes" xml:space="preserve">
          <source>Many micro-optimizations result in 20.3% more work for the same number of CPU cycles relative to the previous release. The cumulative performance increase since &lt;a href=&quot;#version_3_8_0&quot;&gt;version 3.8.0&lt;/a&gt; is 61%. (Measured using &lt;a href=&quot;http://valgrind.org/docs/manual/cg-manual.html&quot;&gt;cachegrind&lt;/a&gt; on the &lt;a href=&quot;https://www.sqlite.org/src/artifact/83f6b3318f7ee&quot;&gt;speedtest1.c&lt;/a&gt; workload on Ubuntu 13.10 x64 with gcc 4.8.1 and -Os. Your performance may vary.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1070ccc184f5ee6e5132e8f78957c23f5d18aeb1" translate="yes" xml:space="preserve">
          <source>Many micro-optimizations, resulting in a library that is faster than the previous release.</source>
          <target state="translated">Множество микро-оптимизаций,в результате чего библиотека быстрее предыдущего релиза.</target>
        </trans-unit>
        <trans-unit id="ef73d713f7e1172e113f066199b34719f6daec88" translate="yes" xml:space="preserve">
          <source>Many minor bug fixes</source>
          <target state="translated">Множество мелких исправлений</target>
        </trans-unit>
        <trans-unit id="d82e20d7c9c34c867cdbaaabca856ec1debc82ea" translate="yes" xml:space="preserve">
          <source>Many nuisance bugs fixed.</source>
          <target state="translated">Исправлено много неприятных ошибок.</target>
        </trans-unit>
        <trans-unit id="a8c23cdfb8fba87694bb2dbb013754a5354d8db3" translate="yes" xml:space="preserve">
          <source>Many of the parameters passed to the &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt; family of interfaces are common across the entire family.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58cc54792f79ad7e4a6c20e286dbf7226ea88ce5" translate="yes" xml:space="preserve">
          <source>Many of the routines in the SQLite &lt;a href=&quot;c3ref/intro&quot;&gt;C-language Interface&lt;/a&gt; return numeric result codes indicating either success or failure, and in the event of a failure, providing some idea of the cause of the failure. This document strives to explain what each of those numeric result codes means.</source>
          <target state="translated">Многие подпрограммы в &lt;a href=&quot;c3ref/intro&quot;&gt;интерфейсе на языке C&lt;/a&gt; SQLite возвращают числовые коды результатов, указывающие на успех или неудачу, а в случае неудачи - на некоторое представление о причине сбоя. В этом документе делается попытка объяснить, что означает каждый из этих числовых кодов результатов.</target>
        </trans-unit>
        <trans-unit id="684a0cdf6fba65d365077c8562625db95e85aea3" translate="yes" xml:space="preserve">
          <source>Many operations, especially I/O intensive operations, can be faster since content does need to be copied between kernel space and user space.</source>
          <target state="translated">Многие операции,особенно интенсивные операции ввода/вывода,могут быть более быстрыми,так как содержимое необходимо копировать между пространством ядра и пространством пользователя.</target>
        </trans-unit>
        <trans-unit id="e75f87ad413b2b989beb9904a93bbc6902b68acd" translate="yes" xml:space="preserve">
          <source>Many programs use &lt;a href=&quot;http://man.he.net/man3/fopen&quot;&gt;fopen()&lt;/a&gt;, &lt;a href=&quot;http://man.he.net/man3/fread&quot;&gt;fread()&lt;/a&gt;, and &lt;a href=&quot;http://man.he.net/man3/fwrite&quot;&gt;fwrite()&lt;/a&gt; to create and manage files of data in home-grown formats. SQLite works particularly well as a replacement for these</source>
          <target state="translated">Многие программы используют &lt;a href=&quot;http://man.he.net/man3/fopen&quot;&gt;fopen ()&lt;/a&gt; , &lt;a href=&quot;http://man.he.net/man3/fread&quot;&gt;fread ()&lt;/a&gt; и &lt;a href=&quot;http://man.he.net/man3/fwrite&quot;&gt;fwrite ()&lt;/a&gt; для создания файлов данных в собственных форматах и ​​управления ими. SQLite особенно хорошо работает в качестве замены этих</target>
        </trans-unit>
        <trans-unit id="58c8d3506d92b491bec9b8982cb696fb925723f6" translate="yes" xml:space="preserve">
          <source>Many readers have recommended various third-party GUIs for Git that might do a better job of showing historical development activity. Maybe some of them do work better than native Git and/or GitHub, though they will all be hampered by the fact that Git does not preserve historical branch names across syncs. And even if those other tools are better, the fact that it is necessary to go to a third-party tool to get the information desired does not speak well of the core system.</source>
          <target state="translated">Многие читатели рекомендовали различные графические интерфейсы сторонних разработчиков для Git'а,которые могли бы лучше показать историческую активность в развитии.Может быть,некоторые из них работают лучше,чем родные Git и/или GitHub,хотя им всем будет мешать тот факт,что Git не сохраняет исторические названия ветвей через синхронизацию.И даже если эти другие инструменты лучше,тот факт,что для получения желаемой информации нужно обратиться к стороннему инструменту,не очень хорошо говорит о системе ядра.</target>
        </trans-unit>
        <trans-unit id="57a3139bc8f04dd188f9b7807c96ec2f953e86dc" translate="yes" xml:space="preserve">
          <source>Many small performance optimizations.</source>
          <target state="translated">Множество небольших оптимизаций производительности.</target>
        </trans-unit>
        <trans-unit id="575ebc9be57deafee12eee1cb275aca14943f68c" translate="yes" xml:space="preserve">
          <source>Many, many bug fixes and compatibility enhancements.</source>
          <target state="translated">Многие,многие исправления ошибок и улучшения совместимости.</target>
        </trans-unit>
        <trans-unit id="305801fe337dfa5f8bad0f9f9e15662ddae791a8" translate="yes" xml:space="preserve">
          <source>Many, many minor bug fixes and documentation updates.</source>
          <target state="translated">Много,много мелких исправлений и обновлений документации.</target>
        </trans-unit>
        <trans-unit id="35ddb236d4c17515cfe7146a42b5a461cee3e50c" translate="yes" xml:space="preserve">
          <source>Master Journal Pointer</source>
          <target state="translated">Мастер-Журнал Указка</target>
        </trans-unit>
        <trans-unit id="9abc1c7f8fc32d4d49746263693941601091cb5d" translate="yes" xml:space="preserve">
          <source>Master journal</source>
          <target state="translated">Мастер-журнал</target>
        </trans-unit>
        <trans-unit id="cb9cc1ceef6f81a9f36806b03b083dc9a2408c5e" translate="yes" xml:space="preserve">
          <source>Master journals</source>
          <target state="translated">магистрские журналы</target>
        </trans-unit>
        <trans-unit id="7b5111bfd1045a8ecdd3554c1e9631c35ec01ef6" translate="yes" xml:space="preserve">
          <source>Matches if both query1 and query2 match.</source>
          <target state="translated">Сопоставляется,если оба запроса1 и запрос2 совпадают.</target>
        </trans-unit>
        <trans-unit id="1abd40ea027c30a30c262947ec1298a0d519b4e6" translate="yes" xml:space="preserve">
          <source>Matches if either query1 or query2 match.</source>
          <target state="translated">Сопоставляется,если запрос1 или запрос2 совпадает.</target>
        </trans-unit>
        <trans-unit id="51cd172796c27ae8bf6aa95066f1e3c65189a939" translate="yes" xml:space="preserve">
          <source>Matches if query1 matches and query2 does not match.</source>
          <target state="translated">Совпадает,если запрос1 совпадает,а запрос2-нет.</target>
        </trans-unit>
        <trans-unit id="bd5c38104019f7a3a298ccf7253423afa28167b4" translate="yes" xml:space="preserve">
          <source>Matchinfo b flag</source>
          <target state="translated">Флаг Матчинфо b</target>
        </trans-unit>
        <trans-unit id="c836afd188ddb1668f2e9e6d198ffaad1a60d7a2" translate="yes" xml:space="preserve">
          <source>Matchinfo x flag</source>
          <target state="translated">флаг Matchinfo x</target>
        </trans-unit>
        <trans-unit id="1cd52c33bad6e28fab493f91164add2569119727" translate="yes" xml:space="preserve">
          <source>Matchinfo y flag</source>
          <target state="translated">Матчинфо и флаг</target>
        </trans-unit>
        <trans-unit id="eba78e6ccaca884931e9772ee282f8ff7b915236" translate="yes" xml:space="preserve">
          <source>Materializations of views and subqueries</source>
          <target state="translated">Материализации представлений и подзапросов</target>
        </trans-unit>
        <trans-unit id="b44a1f3f0332ddaecfe37d45239aca1621b1d815" translate="yes" xml:space="preserve">
          <source>Mathematical operators (+, -, *, /, %, &amp;lt;&amp;lt;, &amp;gt;&amp;gt;, &amp;amp;, and |) interpret both operands as if they were numbers. STRING or BLOB operands automatically convert into REAL or INTEGER values. If the STRING or BLOB looks like a real number (if it has a decimal point or an exponent) or if the value is outside the range that can be represented as a 64-bit signed integer, then it converts to REAL. Otherwise the operand converts to INTEGER. The implied type conversion of mathematical operands is slightly different from &lt;a href=&quot;lang_expr#castexpr&quot;&gt;CAST to NUMERIC&lt;/a&gt; in that string and BLOB values that look like real numbers but have no fractional part are kept as REAL instead of being converted into INTEGER as they would be for &lt;a href=&quot;lang_expr#castexpr&quot;&gt;CAST to NUMERIC&lt;/a&gt;. The conversion from STRING or BLOB into REAL or INTEGER is performed even if it is lossy and irreversible. Some mathematical operators (%, &amp;lt;&amp;lt;, &amp;gt;&amp;gt;, &amp;amp;, and |) expect INTEGER operands. For those operators, REAL operands are converted into INTEGER in the same way as a &lt;a href=&quot;lang_expr#castexpr&quot;&gt;CAST to INTEGER&lt;/a&gt;. The &amp;lt;&amp;lt;, &amp;gt;&amp;gt;, &amp;amp;, and | operators always return an INTEGER (or NULL) result, but the % operator returns either INTEGER or REAL (or NULL) depending on the type of its operands. A NULL operand on a mathematical operator yields a NULL result. An operand on a mathematical operator that does not look in any way numeric and is not NULL is converted to 0 or 0.0. Division by zero gives a result of NULL.</source>
          <target state="translated">Математические операторы (+, -, *, /,%, &amp;lt;&amp;lt;, &amp;gt;&amp;gt;, &amp;amp; и |) интерпретируют оба операнда, как если бы они были числами. Операнды STRING или BLOB автоматически преобразуются в значения REAL или INTEGER. Если СТРОКА или BLOB выглядит как вещественное число (если оно имеет десятичную точку или показатель степени) или если значение выходит за пределы диапазона, который может быть представлен как 64-битное целое число со знаком, то оно преобразуется в REAL. В противном случае операнд преобразуется в INTEGER. Подразумеваемое преобразование типов математических операндов немного отличается от &lt;a href=&quot;lang_expr#castexpr&quot;&gt;CAST в NUMERIC&lt;/a&gt; в этой строке, а значения BLOB, которые выглядят как действительные числа, но не имеют дробной части, сохраняются как REAL вместо преобразования в INTEGER, как это было бы для &lt;a href=&quot;lang_expr#castexpr&quot;&gt;CAST to NUMERIC&lt;/a&gt;. Преобразование из STRING или BLOB в REAL или INTEGER выполняется, даже если оно необратимо и с потерями. Некоторые математические операторы (%, &amp;lt;&amp;lt;, &amp;gt;&amp;gt;, &amp;amp; и |) ожидают операнды INTEGER. Для этих операторов операнды REAL преобразуются в INTEGER так же, как &lt;a href=&quot;lang_expr#castexpr&quot;&gt;CAST в INTEGER&lt;/a&gt; . &amp;lt;&amp;lt;, &amp;gt;&amp;gt;, &amp;amp; и | операторы всегда возвращают результат INTEGER (или NULL), но оператор% возвращает INTEGER или REAL (или NULL) в зависимости от типа его операндов. Операнд NULL в математическом операторе дает результат NULL. Операнд математического оператора, который никоим образом не выглядит числовым и не имеет значения NULL, преобразуется в 0 или 0,0. Деление на ноль дает результат NULL.</target>
        </trans-unit>
        <trans-unit id="1d9b8da2be0b14b678f29575b8bd5d6d1b4664b6" translate="yes" xml:space="preserve">
          <source>MaxPgcnt</source>
          <target state="translated">MaxPgcnt</target>
        </trans-unit>
        <trans-unit id="6cf7147e1932d9bf8b6d38604abfcfd205a85da8" translate="yes" xml:space="preserve">
          <source>Maximum embedded payload fraction. Must be 64.</source>
          <target state="translated">Максимальная встроенная доля полезной нагрузки.Должно быть 64.</target>
        </trans-unit>
        <trans-unit id="24d9373f317266755bd6dbb0fc6450a4905171c2" translate="yes" xml:space="preserve">
          <source>Maximum rowid</source>
          <target state="translated">Максимальный ряд</target>
        </trans-unit>
        <trans-unit id="5bc432c657fe4144bd45d936698c166acecd18fa" translate="yes" xml:space="preserve">
          <source>Maximum xShmLock index</source>
          <target state="translated">Максимальный индекс xShmLock</target>
        </trans-unit>
        <trans-unit id="77e5adb0194b8d8026832696c1f2c7818741ee2e" translate="yes" xml:space="preserve">
          <source>Maxopen parameter</source>
          <target state="translated">Макс.значение параметра</target>
        </trans-unit>
        <trans-unit id="0cccb688a9f1ffa766c4517a7aa3af7c04fd578c" translate="yes" xml:space="preserve">
          <source>May you do good and not evil</source>
          <target state="translated">Пусть ты делаешь добро,а не зло.</target>
        </trans-unit>
        <trans-unit id="8b1b4d5262b0d017f35623d6ebe39d0b87517497" translate="yes" xml:space="preserve">
          <source>May you find forgiveness for yourself and forgive others</source>
          <target state="translated">Пусть ты найдешь прощение для себя и простишь других.</target>
        </trans-unit>
        <trans-unit id="580b0f5d2afa3fc028fd1cbe9832972ae188e8d2" translate="yes" xml:space="preserve">
          <source>May you share freely, never taking more than you give.</source>
          <target state="translated">Пусть ты делишься свободно,никогда не беря больше,чем даешь.</target>
        </trans-unit>
        <trans-unit id="19cd7d185cfd95a703e62d43597e9ae28e0646e5" translate="yes" xml:space="preserve">
          <source>Meaning</source>
          <target state="translated">Meaning</target>
        </trans-unit>
        <trans-unit id="4916cdca74bd290a34e18174e1358515f2ca12e0" translate="yes" xml:space="preserve">
          <source>Measure the performance for reading blobs from the database and from individual files using these commands:</source>
          <target state="translated">Измерьте производительность для чтения блоков из базы данных и из отдельных файлов с помощью этих команд:</target>
        </trans-unit>
        <trans-unit id="32d3f574c379f02e466ab9d634b2afa7cedf3a39" translate="yes" xml:space="preserve">
          <source>Measure write performance by adding the --update option. This causes the blobs are overwritten in place with another random blob of exactly the same size.</source>
          <target state="translated">Измерьте производительность записи,добавив опцию -update.Это приводит к тому,что капли перезаписываются на месте другим случайным блоком точно такого же размера.</target>
        </trans-unit>
        <trans-unit id="f8f8ae177706bfa8cf72569452745c1f4cb10ab6" translate="yes" xml:space="preserve">
          <source>Measured using cachegrind on Ubuntu 16.04 on x64 with gcc 5.4.0 and -Os.</source>
          <target state="translated">Измерено с помощью кэшфренда на Ubuntu 16.04 на x64 с gcc 5.4.0 и -O.</target>
        </trans-unit>
        <trans-unit id="b32c8e35e5b4b276295d8f91c2b0f1620f45e186" translate="yes" xml:space="preserve">
          <source>Measurements above were conducted using SQLite version &lt;a href=&quot;https://sqlite.org/src/timeline?c=5594a121bf132a98&quot;&gt;5594a121bf132a98&lt;/a&gt; from 2017-10-08.</source>
          <target state="translated">Вышеуказанные измерения проводились с использованием SQLite версии &lt;a href=&quot;https://sqlite.org/src/timeline?c=5594a121bf132a98&quot;&gt;5594a121bf132a98&lt;/a&gt; от 08.10.2017.</target>
        </trans-unit>
        <trans-unit id="201062f4cfcc7a2c58dc61b839eac4c989004f31" translate="yes" xml:space="preserve">
          <source>Measuring and Reducing CPU Usage in SQLite</source>
          <target state="translated">Измерение и сокращение использования процессора в SQLite</target>
        </trans-unit>
        <trans-unit id="d815eeb251818f42b639c19483653cb9e9676a23" translate="yes" xml:space="preserve">
          <source>MemMax</source>
          <target state="translated">MemMax</target>
        </trans-unit>
        <trans-unit id="57b0394c856fac60e784f92bcfff68951cf81266" translate="yes" xml:space="preserve">
          <source>Memory Allocation Routines</source>
          <target state="translated">Маршруты распределения памяти</target>
        </trans-unit>
        <trans-unit id="3a30329db6460c4ed15bebe4d427af9052e6678f" translate="yes" xml:space="preserve">
          <source>Memory Allocation Subsystem</source>
          <target state="translated">Подсистема распределения памяти</target>
        </trans-unit>
        <trans-unit id="f5bd12480983914d8406751d31133ba86381302d" translate="yes" xml:space="preserve">
          <source>Memory Allocator Statistics</source>
          <target state="translated">Статистика распределителя памяти</target>
        </trans-unit>
        <trans-unit id="8ee60155b22e766b4de73dc4f683f3ac25fa009b" translate="yes" xml:space="preserve">
          <source>Memory Slot</source>
          <target state="translated">Слот памяти</target>
        </trans-unit>
        <trans-unit id="ea9be83a8f265809341121ab4ff9c58d527a1bdd" translate="yes" xml:space="preserve">
          <source>Memory accounting is disabled using a combination of the &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;#sqliteconfigmemstatus&quot;&gt;SQLITE_CONFIG_MEMSTATUS&lt;/a&gt;,...) start-time option and the &lt;a href=&quot;compile#default_memstatus&quot;&gt;SQLITE_DEFAULT_MEMSTATUS&lt;/a&gt; compile-time option.</source>
          <target state="translated">Учет памяти отключается с помощью комбинации параметра времени начала &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config&lt;/a&gt; ( &lt;a href=&quot;#sqliteconfigmemstatus&quot;&gt;SQLITE_CONFIG_MEMSTATUS&lt;/a&gt; , ...) и параметра &lt;a href=&quot;compile#default_memstatus&quot;&gt;времени&lt;/a&gt; компиляции SQLITE_DEFAULT_MEMSTATUS .</target>
        </trans-unit>
        <trans-unit id="83484b2c23e2c43deda0dd88234486f9158814f3" translate="yes" xml:space="preserve">
          <source>Memory accounting is disabled using a combination of the &lt;a href=&quot;config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c_config_covering_index_scan#sqliteconfigmemstatus&quot;&gt;SQLITE_CONFIG_MEMSTATUS&lt;/a&gt;,...) start-time option and the &lt;a href=&quot;../compile#default_memstatus&quot;&gt;SQLITE_DEFAULT_MEMSTATUS&lt;/a&gt; compile-time option.</source>
          <target state="translated">Учет памяти отключается с помощью комбинации параметра времени начала &lt;a href=&quot;config&quot;&gt;sqlite3_config&lt;/a&gt; ( &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigmemstatus&quot;&gt;SQLITE_CONFIG_MEMSTATUS&lt;/a&gt; , ...) и параметра &lt;a href=&quot;../compile#default_memstatus&quot;&gt;времени&lt;/a&gt; компиляции SQLITE_DEFAULT_MEMSTATUS .</target>
        </trans-unit>
        <trans-unit id="c90d2f9e1fbdf5d88900e51c0817d79397425f44" translate="yes" xml:space="preserve">
          <source>Memory allocation statistics are enabled by default unless SQLite is compiled with &lt;a href=&quot;../compile#default_memstatus&quot;&gt;SQLITE_DEFAULT_MEMSTATUS&lt;/a&gt;=0 in which case memory allocation statistics are disabled by default.</source>
          <target state="translated">Статистика выделения памяти включена по умолчанию, если SQLite не скомпилирован с &lt;a href=&quot;../compile#default_memstatus&quot;&gt;SQLITE_DEFAULT_MEMSTATUS&lt;/a&gt; = 0, и в этом случае статистика выделения памяти отключена по умолчанию.</target>
        </trans-unit>
        <trans-unit id="36fecd267945c46262e4527e9008734a419499a2" translate="yes" xml:space="preserve">
          <source>Memory allocation statistics are enabled by default unless SQLite is compiled with &lt;a href=&quot;compile#default_memstatus&quot;&gt;SQLITE_DEFAULT_MEMSTATUS&lt;/a&gt;=0 in which case memory allocation statistics are disabled by default.</source>
          <target state="translated">Статистика выделения памяти включена по умолчанию, если SQLite не скомпилирован с &lt;a href=&quot;compile#default_memstatus&quot;&gt;SQLITE_DEFAULT_MEMSTATUS&lt;/a&gt; = 0, и в этом случае статистика выделения памяти отключена по умолчанию.</target>
        </trans-unit>
        <trans-unit id="30cf1b800d03b60f9a295eac5e3ee911eb40a567" translate="yes" xml:space="preserve">
          <source>Memory allocation, caseless string comparison routines, portable text-to-number conversion routines, and other utilities are located in &lt;a href=&quot;https://sqlite.org/src/file/src/util.c&quot;&gt;util.c&lt;/a&gt;. Symbol tables used by the parser are maintained by hash tables found in &lt;a href=&quot;https://sqlite.org/src/file/src/hash.c&quot;&gt;hash.c&lt;/a&gt;. The &lt;a href=&quot;https://sqlite.org/src/file/src/utf.c&quot;&gt;utf.c&lt;/a&gt; source file contains Unicode conversion subroutines. SQLite has its own private implementation of &lt;a href=&quot;printf&quot;&gt;printf()&lt;/a&gt; (with some extensions) in &lt;a href=&quot;https://sqlite.org/src/file/src/printf.c&quot;&gt;printf.c&lt;/a&gt; and its own pseudo-random number generator (PRNG) in &lt;a href=&quot;https://sqlite.org/src/file/src/random.c&quot;&gt;random.c&lt;/a&gt;.</source>
          <target state="translated">Распределение памяти, подпрограммы сравнения строк без корпуса, портативные процедуры преобразования текста в номер и другие коммунальные услуги находятся в &lt;a href=&quot;https://sqlite.org/src/file/src/util.c&quot;&gt;util.c&lt;/a&gt; . Символ таблица , используемый анализатор поддерживается хэш - таблицами , найденных в &lt;a href=&quot;https://sqlite.org/src/file/src/hash.c&quot;&gt;hash.c&lt;/a&gt; . &lt;a href=&quot;https://sqlite.org/src/file/src/utf.c&quot;&gt;Utf.c&lt;/a&gt; исходный файл содержит подпрограммы преобразования Unicode. SQLite имеет собственную частную реализацию &lt;a href=&quot;printf&quot;&gt;printf ()&lt;/a&gt; (с некоторыми расширениями) в &lt;a href=&quot;https://sqlite.org/src/file/src/printf.c&quot;&gt;printf.c&lt;/a&gt; и собственный генератор псевдослучайных чисел (PRNG) в &lt;a href=&quot;https://sqlite.org/src/file/src/random.c&quot;&gt;random.c&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8351f935d7e0b92d4dbd88ff6014fc3cfebc6b06" translate="yes" xml:space="preserve">
          <source>Memory statistics</source>
          <target state="translated">Статистика памяти</target>
        </trans-unit>
        <trans-unit id="0b3951c84915f2636f64c4da056f2bbaa63121ac" translate="yes" xml:space="preserve">
          <source>Memory to hold the information returned by &lt;b&gt;sqlite_get_table&lt;/b&gt; is obtained from malloc(). But the calling function should not try to free this information directly. Instead, pass the complete table to &lt;b&gt;sqlite_free_table&lt;/b&gt; when the table is no longer needed. It is safe to call &lt;b&gt;sqlite_free_table&lt;/b&gt; with a NULL pointer such as would be returned if the result set is empty.</source>
          <target state="translated">Память для хранения информации, возвращаемой &lt;b&gt;sqlite_get_table&lt;/b&gt; , получается из malloc (). Но вызывающая функция не должна пытаться напрямую освободить эту информацию. Вместо этого передайте всю таблицу в &lt;b&gt;sqlite_free_table,&lt;/b&gt; когда таблица больше не нужна. Можно безопасно вызывать &lt;b&gt;sqlite_free_table&lt;/b&gt; с указателем NULL, который будет возвращен, если набор результатов пуст.</target>
        </trans-unit>
        <trans-unit id="0ebf6aa26b7b4fd9c6127be506bafbc4c2292df8" translate="yes" xml:space="preserve">
          <source>Memory-Mapped I/O</source>
          <target state="translated">Память-отображенные входы/выходы</target>
        </trans-unit>
        <trans-unit id="7640161f9a59fd693f768ecd9272e3177311b46c" translate="yes" xml:space="preserve">
          <source>Memsys4 and memsys6 were experimental memory allocators introduced in around 2007 and subsequently removed from the source tree in around 2008, after it became clear that they added no new value.</source>
          <target state="translated">Memsys4 и memsys6 были экспериментальными аллокаторами памяти,введенными примерно в 2007 году,а затем удаленными из дерева исходных текстов примерно в 2008 году,после того,как стало ясно,что они не добавили никакой новой ценности.</target>
        </trans-unit>
        <trans-unit id="53e5e9eaf00f6f480e84b07b830bf50ed69b3504" translate="yes" xml:space="preserve">
          <source>Merge development changes into the main trunk. Future work toward using a BTree file structure will use a separate CVS source tree. This CVS tree will continue to support the GDBM version of SQLite only.</source>
          <target state="translated">Объедините изменения развития в основной ствол.В дальнейшей работе по использованию файловой структуры BTree будет использоваться отдельное дерево исходников CVS.Это CVS-дерево будет продолжать поддерживать только GDBM-версию SQLite.</target>
        </trans-unit>
        <trans-unit id="1c69f87311ee49961b7db4c6959bf9e564173753" translate="yes" xml:space="preserve">
          <source>MergePatch can add, modify, or delete elements of a JSON Object, and so for JSON Objects, the json_patch() routine is a generalized replacement for &lt;a href=&quot;json1#jset&quot;&gt;json_set()&lt;/a&gt; and &lt;a href=&quot;json1#jrm&quot;&gt;json_remove()&lt;/a&gt;. However, MergePatch treats JSON Array objects as atomic. MergePatch cannot append to an Array nor modify individual elements of an Array. It can only insert, replace, or delete the whole Array as a single unit. Hence, json_patch() is not as useful when dealing with JSON that includes Arrays, especially Arrays with lots of substructure.</source>
          <target state="translated">MergePatch может добавлять, изменять или удалять элементы объекта JSON, поэтому для объектов JSON процедура json_patch () является обобщенной заменой для &lt;a href=&quot;json1#jset&quot;&gt;json_set ()&lt;/a&gt; и &lt;a href=&quot;json1#jrm&quot;&gt;json_remove ()&lt;/a&gt; . Однако MergePatch рассматривает объекты JSON Array как атомарные. MergePatch не может добавлять в массив или изменять отдельные элементы массива. Он может вставлять, заменять или удалять только весь массив как единое целое. Следовательно, json_patch () не так полезен при работе с JSON, который включает в себя массивы, особенно массивы с большим количеством подструктур.</target>
        </trans-unit>
        <trans-unit id="b34856a8252222662370c82e139676a40460db4d" translate="yes" xml:space="preserve">
          <source>Merged the &lt;a href=&quot;sessionintro&quot;&gt;session&lt;/a&gt; extension into trunk.</source>
          <target state="translated">Слил расширение &lt;a href=&quot;sessionintro&quot;&gt;сеанса&lt;/a&gt; в транк.</target>
        </trans-unit>
        <trans-unit id="dbaecd82c952801d0bb82c4bd7a41de66b9fda44" translate="yes" xml:space="preserve">
          <source>Metadata is returned by writing to the memory locations passed as the 5th and subsequent parameters to this function. Any of these arguments may be NULL, in which case the corresponding element of metadata is omitted.</source>
          <target state="translated">Метаданные возвращаются путем записи в ячейки памяти,переданные в качестве 5-го и последующих параметров этой функции.Любой из этих аргументов может быть NULL,в этом случае соответствующий элемент метаданных опускается.</target>
        </trans-unit>
        <trans-unit id="4d3732872bb2a9906cc1153aeb2590dd048c19aa" translate="yes" xml:space="preserve">
          <source>Method (2) offers a midpoint between (1) and (3). Using this method, a query such as '1s*' will match documents that contain the literal token &quot;1st&quot;, but not &quot;first&quot; (assuming the tokenizer is not able to provide synonyms for prefixes). However, a non-prefix query like '1st' will match against &quot;1st&quot; and &quot;first&quot;. This method does not require extra disk space, as no extra entries are added to the FTS index. On the other hand, it may require more CPU cycles to run MATCH queries, as separate queries of the FTS index are required for each synonym.</source>
          <target state="translated">Метод (2)предлагает среднюю точку между (1)и (3).При использовании этого метода запрос типа '1s*' будет сопоставлять документы,содержащие буквальную лексель &quot;1&quot;,но не &quot;первый&quot; (в предположении,что токенайзер не может предоставить синонимов для префиксов).Однако,не префиксный запрос типа '1' будет совпадать с &quot;1&quot; и &quot;первым&quot;.Этот метод не требует дополнительного дискового пространства,так как в индекс FTS не добавляются дополнительные записи.С другой стороны,для выполнения MATCH-запросов может потребоваться большее количество циклов процессора,так как для каждого синонима требуется отдельный запрос индекса FTS.</target>
        </trans-unit>
        <trans-unit id="1df213a45649b1f66258f5768182bafcd559f0b9" translate="yes" xml:space="preserve">
          <source>Methods: &lt;a href=&quot;#sqlite3_blob_bytes&quot;&gt;sqlite3_blob_bytes()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_blob_read&quot;&gt;sqlite3_blob_read()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_blob_reopen&quot;&gt;sqlite3_blob_reopen()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_blob_write&quot;&gt;sqlite3_blob_write()&lt;/a&gt;</source>
          <target state="translated">Методы: &lt;a href=&quot;#sqlite3_blob_bytes&quot;&gt;sqlite3_blob_bytes ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_blob_read&quot;&gt;sqlite3_blob_read ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_blob_reopen&quot;&gt;sqlite3_blob_reopen ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_blob_write&quot;&gt;sqlite3_blob_write ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1b9983b06e527d46d817373bc15d13089f4d3e12" translate="yes" xml:space="preserve">
          <source>Methods: &lt;a href=&quot;#sqlite3_snapshot_cmp&quot;&gt;sqlite3_snapshot_cmp()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_snapshot_open&quot;&gt;sqlite3_snapshot_open()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_snapshot_recover&quot;&gt;sqlite3_snapshot_recover()&lt;/a&gt;</source>
          <target state="translated">Методы: &lt;a href=&quot;#sqlite3_snapshot_cmp&quot;&gt;sqlite3_snapshot_cmp ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_snapshot_open&quot;&gt;sqlite3_snapshot_open ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_snapshot_recover&quot;&gt;sqlite3_snapshot_recover ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="547fb3fd92f4ba766d2b81080903dd2fa70ddd7a" translate="yes" xml:space="preserve">
          <source>Methods: &lt;a href=&quot;#sqlite3changegroup_add&quot;&gt;sqlite3changegroup_add()&lt;/a&gt;, &lt;a href=&quot;#sqlite3changegroup_output&quot;&gt;sqlite3changegroup_output()&lt;/a&gt;</source>
          <target state="translated">Методы: &lt;a href=&quot;#sqlite3changegroup_add&quot;&gt;sqlite3changegroup_add ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3changegroup_output&quot;&gt;sqlite3changegroup_output ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5ba8e151eaa184a6fb4bcf2ae01f52e3682b9b04" translate="yes" xml:space="preserve">
          <source>Methods: &lt;a href=&quot;blob_bytes&quot;&gt;sqlite3_blob_bytes()&lt;/a&gt;, &lt;a href=&quot;blob_read&quot;&gt;sqlite3_blob_read()&lt;/a&gt;, &lt;a href=&quot;blob_reopen&quot;&gt;sqlite3_blob_reopen()&lt;/a&gt;, &lt;a href=&quot;blob_write&quot;&gt;sqlite3_blob_write()&lt;/a&gt;</source>
          <target state="translated">Методы: &lt;a href=&quot;blob_bytes&quot;&gt;sqlite3_blob_bytes ()&lt;/a&gt; , &lt;a href=&quot;blob_read&quot;&gt;sqlite3_blob_read ()&lt;/a&gt; , &lt;a href=&quot;blob_reopen&quot;&gt;sqlite3_blob_reopen ()&lt;/a&gt; , &lt;a href=&quot;blob_write&quot;&gt;sqlite3_blob_write ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="05bb53e8fd80fd00914dd4034f12bb335994738a" translate="yes" xml:space="preserve">
          <source>Methods: &lt;a href=&quot;snapshot_cmp&quot;&gt;sqlite3_snapshot_cmp()&lt;/a&gt;, &lt;a href=&quot;snapshot_open&quot;&gt;sqlite3_snapshot_open()&lt;/a&gt;, &lt;a href=&quot;snapshot_recover&quot;&gt;sqlite3_snapshot_recover()&lt;/a&gt;</source>
          <target state="translated">Методы: &lt;a href=&quot;snapshot_cmp&quot;&gt;sqlite3_snapshot_cmp ()&lt;/a&gt; , &lt;a href=&quot;snapshot_open&quot;&gt;sqlite3_snapshot_open ()&lt;/a&gt; , &lt;a href=&quot;snapshot_recover&quot;&gt;sqlite3_snapshot_recover ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="80b86f6f0bb9183c80c83fe634331b034c5a3b6c" translate="yes" xml:space="preserve">
          <source>Methods: &lt;a href=&quot;sqlite3changegroup_add&quot;&gt;sqlite3changegroup_add()&lt;/a&gt;, &lt;a href=&quot;sqlite3changegroup_output&quot;&gt;sqlite3changegroup_output()&lt;/a&gt;</source>
          <target state="translated">Методы: &lt;a href=&quot;sqlite3changegroup_add&quot;&gt;sqlite3changegroup_add ()&lt;/a&gt; , &lt;a href=&quot;sqlite3changegroup_output&quot;&gt;sqlite3changegroup_output ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="91126b8550d89c2cabd56ad5c8ea6415436ef4e7" translate="yes" xml:space="preserve">
          <source>Millions and millions of test cases</source>
          <target state="translated">Миллионы и миллионы тестовых случаев</target>
        </trans-unit>
        <trans-unit id="8cb901663cd153748076b7a4eed655ac9c9ceb63" translate="yes" xml:space="preserve">
          <source>Minimum embedded payload fraction. Must be 32.</source>
          <target state="translated">Минимальная встроенная доля полезной нагрузки.Должно быть 32.</target>
        </trans-unit>
        <trans-unit id="9f5a0ef3646738848b65efb74e98db2b2c5a359b" translate="yes" xml:space="preserve">
          <source>Minimum rowid</source>
          <target state="translated">Минимальный ряд</target>
        </trans-unit>
        <trans-unit id="62a01943e842ea4e97ec6b470d86e59a45ec37a1" translate="yes" xml:space="preserve">
          <source>Minor revisions to the website.</source>
          <target state="translated">Незначительные изменения на сайте.</target>
        </trans-unit>
        <trans-unit id="e2f772b3f3e4226648620e3b2d22fc9e06b7af3b" translate="yes" xml:space="preserve">
          <source>Minor syntactic changes to support a wider variety of compilers.</source>
          <target state="translated">Незначительные синтаксические изменения для поддержки более широкого круга компиляторов.</target>
        </trans-unit>
        <trans-unit id="a207d914072a9004f7af9edb9092f93397750bdb" translate="yes" xml:space="preserve">
          <source>Minor tweaks to other code to make it run a little faster.</source>
          <target state="translated">Незначительные подстройки к другому коду,чтобы заставить его работать немного быстрее.</target>
        </trans-unit>
        <trans-unit id="5f2cbd107037ed23248e5058a7a64cd6bae05468" translate="yes" xml:space="preserve">
          <source>Miscellaneous</source>
          <target state="translated">Miscellaneous</target>
        </trans-unit>
        <trans-unit id="b80fca6a605a77935ff5f5e3122df5de2dfd1555" translate="yes" xml:space="preserve">
          <source>Miscellaneous &lt;a href=&quot;cpu#microopt&quot;&gt;microoptimizations&lt;/a&gt; reduce CPU usage by about 2.1%.</source>
          <target state="translated">Разные &lt;a href=&quot;cpu#microopt&quot;&gt;микрооптимизации&lt;/a&gt; снижают загрузку процессора примерно на 2,1%.</target>
        </trans-unit>
        <trans-unit id="28c8a44394b5bc456bad4c873373e406d652fe87" translate="yes" xml:space="preserve">
          <source>Miscellaneous code size optimizations and bug fixes</source>
          <target state="translated">Различные оптимизации размера кода и исправления ошибок</target>
        </trans-unit>
        <trans-unit id="bbb81db24ef06a2153135306601290fda608c2da" translate="yes" xml:space="preserve">
          <source>Miscellaneous documentation enhancements.</source>
          <target state="translated">Различные улучшения в документации.</target>
        </trans-unit>
        <trans-unit id="98990a8e0a243a1fdf56c721a0da9558936ac95e" translate="yes" xml:space="preserve">
          <source>Miscellaneous micro-optimizations reduce CPU usage by more than 7% on common workloads. Most optimization in this release has been on the front-end (&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt;).</source>
          <target state="translated">Разные микрооптимизации снижают использование ЦП более чем на 7% при обычных рабочих нагрузках. Большая часть оптимизации в этом выпуске была &lt;a href=&quot;c3ref/prepare&quot;&gt;сделана во внешнем&lt;/a&gt; интерфейсе ( sqlite3_prepare_v2 () ).</target>
        </trans-unit>
        <trans-unit id="fbdfeb6f538d5f7f87b9990239ba0793588dd6eb" translate="yes" xml:space="preserve">
          <source>Miscellaneous micro-optimizations result in 22.3% more work for the same number of CPU cycles relative to the previous release. SQLite now runs twice as fast as &lt;a href=&quot;#version_3_8_0&quot;&gt;version 3.8.0&lt;/a&gt; and three times as fast as &lt;a href=&quot;#version_3_3_9&quot;&gt;version 3.3.9&lt;/a&gt;. (Measured using &lt;a href=&quot;http://valgrind.org/docs/manual/cg-manual.html&quot;&gt;cachegrind&lt;/a&gt; on the &lt;a href=&quot;http://www.sqlite.org/src/artifact/83f6b3318f7ee&quot;&gt;speedtest1.c&lt;/a&gt; workload on Ubuntu 14.04 x64 with gcc 4.8.2 and -Os. Your performance may vary.)</source>
          <target state="translated">Различные микрооптимизации приводят к увеличению объема работы на 22,3% при том же количестве циклов процессора по сравнению с предыдущим выпуском. SQLite теперь работает в два раза быстрее, чем &lt;a href=&quot;#version_3_8_0&quot;&gt;версия 3.8.0,&lt;/a&gt; и в три раза быстрее, чем &lt;a href=&quot;#version_3_3_9&quot;&gt;версия 3.3.9&lt;/a&gt; . (Измерено с помощью &lt;a href=&quot;http://valgrind.org/docs/manual/cg-manual.html&quot;&gt;cachegrind&lt;/a&gt; на рабочей нагрузке &lt;a href=&quot;http://www.sqlite.org/src/artifact/83f6b3318f7ee&quot;&gt;speedtest1.c&lt;/a&gt; в Ubuntu 14.04 x64 с gcc 4.8.2 и -Os. Ваша производительность может отличаться.)</target>
        </trans-unit>
        <trans-unit id="c1d9b076bc6c8344ea5542edf83c259a762c2a37" translate="yes" xml:space="preserve">
          <source>Miscellaneous micro-optimizations result in 22.3% more work for the same number of CPU cycles relative to the previous release. SQLite now runs twice as fast as &lt;a href=&quot;#version_3_8_0&quot;&gt;version 3.8.0&lt;/a&gt; and three times as fast as &lt;a href=&quot;#version_3_3_9&quot;&gt;version 3.3.9&lt;/a&gt;. (Measured using &lt;a href=&quot;http://valgrind.org/docs/manual/cg-manual.html&quot;&gt;cachegrind&lt;/a&gt; on the &lt;a href=&quot;https://www.sqlite.org/src/artifact/83f6b3318f7ee&quot;&gt;speedtest1.c&lt;/a&gt; workload on Ubuntu 14.04 x64 with gcc 4.8.2 and -Os. Your performance may vary.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc459de1c05b709bda425ad3c5816738720eebc5" translate="yes" xml:space="preserve">
          <source>Miscellaneous minor bug fixes</source>
          <target state="translated">Различные мелкие исправления ошибок</target>
        </trans-unit>
        <trans-unit id="44d1c5c9aa54a9db91e7e7fe347ac18190d724ed" translate="yes" xml:space="preserve">
          <source>Miscellaneous optimizations result in a 2% reduction in &lt;a href=&quot;cpu&quot;&gt;CPU cycles used&lt;/a&gt;.</source>
          <target state="translated">Различные оптимизации приводят к сокращению &lt;a href=&quot;cpu&quot;&gt;используемых циклов процессора&lt;/a&gt; на 2% .</target>
        </trans-unit>
        <trans-unit id="f1774acabb62d5801f41470f6cd189b2c0aaaf3c" translate="yes" xml:space="preserve">
          <source>Miscellaneous performance enhancements</source>
          <target state="translated">Различные способы повышения эффективности</target>
        </trans-unit>
        <trans-unit id="276e26893215e7c8d37e726040961fa631182ebb" translate="yes" xml:space="preserve">
          <source>Miscellaneous problem words such as &quot;debt&quot;, &quot;tsetse&quot;, &quot;Nguyen&quot;, &quot;Van Nuyes&quot;.</source>
          <target state="translated">Различные проблемные слова,такие как &quot;долг&quot;,&quot;цецеце&quot;,&quot;Нгуен&quot;,&quot;Ван Нюэс&quot;.</target>
        </trans-unit>
        <trans-unit id="4f0711bb69728ffde416a549e0f91f702e273516" translate="yes" xml:space="preserve">
          <source>Misformatted records</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c46987b5699d45998eb4a1f03a81d222b78e342" translate="yes" xml:space="preserve">
          <source>Missing callback</source>
          <target state="translated">Пропущенный обратный звонок</target>
        </trans-unit>
        <trans-unit id="55fd1e5df760c82f67c5509ea619f439d18e5b37" translate="yes" xml:space="preserve">
          <source>Missing or surplus index entries</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96732b61a8d377ada7b914c38aba1cf0d28297dd" translate="yes" xml:space="preserve">
          <source>Missing pages</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1570b7a7267e412717981829df93815ef1f5214" translate="yes" xml:space="preserve">
          <source>Modern filesystems operate faster when disk accesses are sequential. Hence, SQLite will run faster if the content of the database file is on sequential pages. To find out what fraction of the pages in a database are sequential (and thus obtain a measurement that might be useful in determining when to &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt;), run a query like the following:</source>
          <target state="translated">Современные файловые системы работают быстрее при последовательном доступе к диску. Следовательно, SQLite будет работать быстрее, если содержимое файла базы данных находится на последовательных страницах. Чтобы узнать, какая часть страниц в базе данных является последовательной (и, таким образом, получить измерение, которое может быть полезно при определении того, когда выполнять &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; ), запустите запрос, подобный следующему:</target>
        </trans-unit>
        <trans-unit id="213d5e141cc4f1fbdb215e4e1d09c9f135e23841" translate="yes" xml:space="preserve">
          <source>Modifications to the &lt;a href=&quot;c3ref/vfs&quot;&gt;virtual file system&lt;/a&gt; interface to support a wider range of embedded systems. See &lt;a href=&quot;35to36&quot;&gt;35to36.html&lt;/a&gt; for additional information. *** Potentially incompatible change ***</source>
          <target state="translated">Модификации интерфейса &lt;a href=&quot;c3ref/vfs&quot;&gt;виртуальной файловой системы&lt;/a&gt; для поддержки более широкого диапазона встроенных систем. См. &lt;a href=&quot;35to36&quot;&gt;35to36.html&lt;/a&gt; для получения дополнительной информации. *** Потенциально несовместимое изменение ***</target>
        </trans-unit>
        <trans-unit id="846a3f594ccb25f4d8b90bf39076621c7a3da386" translate="yes" xml:space="preserve">
          <source>Modifications to the &lt;a href=&quot;lemon&quot;&gt;Lemon parser generator&lt;/a&gt; so that the parser tables are 4 times smaller.</source>
          <target state="translated">Модификации &lt;a href=&quot;lemon&quot;&gt;генератора синтаксического анализатора Lemon,&lt;/a&gt; чтобы таблицы синтаксического анализатора были в 4 раза меньше.</target>
        </trans-unit>
        <trans-unit id="a373b9c05e3506597302158ddcc81e7b79ce6310" translate="yes" xml:space="preserve">
          <source>Modified &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt; and &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigscratch&quot;&gt;SQLITE_CONFIG_SCRATCH&lt;/a&gt; to remove the &quot;+4&quot; magic number in the buffer size computation.</source>
          <target state="translated">Модифицированный &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt; и &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigscratch&quot;&gt;SQLITE_CONFIG_SCRATCH&lt;/a&gt; удалить &amp;laquo;+4&amp;raquo; магическое число в вычислении размера буфера.</target>
        </trans-unit>
        <trans-unit id="7ae047108ffb132cb41d3775cac528b7c36bd9c6" translate="yes" xml:space="preserve">
          <source>Modified the &lt;b&gt;sqlite&lt;/b&gt; shell program to print the schema for the built-in SQLITE_MASTER table, if explicitly requested.</source>
          <target state="translated">Измененный &lt;b&gt;SQLite&lt;/b&gt; оболочка программы для печати схемы для встроенного sqlite_master таблицы, если явно просил.</target>
        </trans-unit>
        <trans-unit id="64b762eca0515a688c77ad3f10cd0b574a4463f3" translate="yes" xml:space="preserve">
          <source>Modified the &lt;b&gt;sqlite&lt;/b&gt; shell program to use the new interface routines.</source>
          <target state="translated">Измененный &lt;b&gt;SQLite&lt;/b&gt; оболочки программы , чтобы использовать новые процедуры интерфейса.</target>
        </trans-unit>
        <trans-unit id="9bea3abf3349ced7a2bd684045cab38caa6bf680" translate="yes" xml:space="preserve">
          <source>Modified the &lt;b&gt;sqlite&lt;/b&gt; shell to make use of the new sqlite_get_table() API in order to print a list of tables in multiple columns, similar to the way &quot;ls&quot; prints filenames.</source>
          <target state="translated">Измененный &lt;b&gt;SQLite&lt;/b&gt; оболочку , чтобы сделать использование нового sqlite_get_table () API для того , чтобы напечатать список таблиц в нескольких столбцах, подобно тому, как &amp;laquo;LS&amp;raquo; печатает имена файлов.</target>
        </trans-unit>
        <trans-unit id="d9d09adf1be852d2030f454ddcb0fb1bbde85e4b" translate="yes" xml:space="preserve">
          <source>Modified the &lt;b&gt;sqlite&lt;/b&gt; shell to print a semicolon at the end of each CREATE statement in the output of the &quot;.schema&quot; command.</source>
          <target state="translated">Измененный &lt;b&gt;SQLite&lt;/b&gt; оболочку напечатать точку с запятой в конце каждого CREATE заявление в выводе команды &amp;laquo;.schema&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="cecf75f0a6c4e051f8158a879b4378a1d3e737c4" translate="yes" xml:space="preserve">
          <source>Modified the B-Tree and Pager modules so that disk pages that do not contain real data (free pages) are not journaled and are not written from memory back to the disk when they change. This does not impact database integrity, since the pages contain no real data, but it does make large INSERT operations about 2.5 times faster and large DELETEs about 5 times faster.</source>
          <target state="translated">Модули B-Tree и Pager были модифицированы таким образом,чтобы страницы диска,не содержащие реальных данных (свободные страницы),не записывались в журнал и не записывались из памяти обратно на диск при их изменении.Это не влияет на целостность базы данных,так как страницы не содержат реальных данных,но делают большие операции INSERT примерно в 2,5 раза быстрее,а большие операции DELETE примерно в 5 раз быстрее.</target>
        </trans-unit>
        <trans-unit id="2c4d4de8cb2205ec2b07c88e0fe421ab99dc0aaa" translate="yes" xml:space="preserve">
          <source>Modified the journal file format to make it more resistant to corruption that can occur after an OS crash or power failure.</source>
          <target state="translated">Изменен формат файла журнала,чтобы сделать его более устойчивым к повреждениям,которые могут произойти после сбоя операционной системы или отключения питания.</target>
        </trans-unit>
        <trans-unit id="3a7ea294bf33134dce4b142b8b7182de29b978b2" translate="yes" xml:space="preserve">
          <source>Modifiers</source>
          <target state="translated">Modifiers</target>
        </trans-unit>
        <trans-unit id="2d258a9a354e69d26a5737aed0d98ba4a12d4ab3" translate="yes" xml:space="preserve">
          <source>Modify the TCL interface to use &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt;.</source>
          <target state="translated">Измените интерфейс TCL, чтобы использовать &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9c186ff83bfc4ba49c92b1876d399ba40e64a0cc" translate="yes" xml:space="preserve">
          <source>Modify the test scripts to identify tests that depend on system load and processor speed and to warn the user that a failure of one of those (rare) tests does not necessarily mean the library is malfunctioning. No changes to code.</source>
          <target state="translated">Модифицируйте тестовые скрипты,чтобы определить тесты,зависящие от нагрузки системы и скорости процессора,и предупредить пользователя о том,что сбой одного из этих (редких)тестов не обязательно означает неисправность библиотеки.Никаких изменений в коде.</target>
        </trans-unit>
        <trans-unit id="ef40b73dad75552add2180adc162c800be16bf41" translate="yes" xml:space="preserve">
          <source>Modifying the contents of a database page.</source>
          <target state="translated">Изменение содержимого страницы базы данных.</target>
        </trans-unit>
        <trans-unit id="56d9419099fd345280bf9a9122ad284109000f7d" translate="yes" xml:space="preserve">
          <source>Modifying, Adding or Truncating a Database Page</source>
          <target state="translated">Изменение,добавление или усечение страницы базы данных</target>
        </trans-unit>
        <trans-unit id="d9ae0b87be39aed320fa35b9e4b820b36d71a71f" translate="yes" xml:space="preserve">
          <source>More aggressive &lt;a href=&quot;compile#omit_floating_point&quot;&gt;SQLITE_OMIT_FLOATING_POINT&lt;/a&gt;</source>
          <target state="translated">Более агрессивный &lt;a href=&quot;compile#omit_floating_point&quot;&gt;SQLITE_OMIT_FLOATING_POINT&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="150e84142afe50eae5e55924e9aafb441ae8328b" translate="yes" xml:space="preserve">
          <source>More aggressive optimization of the AND operator when one side or the other is always false.</source>
          <target state="translated">Более агрессивная оптимизация оператора AND,когда та или иная сторона всегда ложна.</target>
        </trans-unit>
        <trans-unit id="4dccd541fa7b33732e530432dc181f83dcc6ba6e" translate="yes" xml:space="preserve">
          <source>More complex queries may or may not be able to employ query flattening to avoid the temporary table. Whether or not the query can be flattened depends on such factors as whether or not the subquery or outer query contain aggregate functions, ORDER BY or GROUP BY clauses, LIMIT clauses, and so forth. The rules for when a query can and cannot be flattened are very complex and are beyond the scope of this document.</source>
          <target state="translated">Более сложные запросы могут использовать или не использовать сплющивание запросов,чтобы избежать временной таблицы.Сглаживание запроса зависит от таких факторов,как наличие или отсутствие в подзапросе или внешнем запросе агрегатных функций,оговорок ORDER BY или GROUP BY,оговорок LIMIT и так далее.Правила того,когда запрос может быть сплющен,а когда нет,очень сложны и выходят за рамки этого документа.</target>
        </trans-unit>
        <trans-unit id="0e965ef66116c7e835a08b23bc0aea20069b16ec" translate="yes" xml:space="preserve">
          <source>More efficient encoding of boolean values resulting in smaller database files</source>
          <target state="translated">Более эффективное кодирование булевых значений,что приводит к меньшему размеру файлов базы данных.</target>
        </trans-unit>
        <trans-unit id="bc15bc11932b9e3bb7aa3bd3cd6dd3273dc66921" translate="yes" xml:space="preserve">
          <source>More efficient handling of &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt;, especially in cases where the application defines hundreds or thousands of custom functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a3c60573ba6ac75355060c30752d85d7e4a4ea7" translate="yes" xml:space="preserve">
          <source>More efficient handling of &lt;a href=&quot;c3ref/create_function&quot;&gt;application-defined SQL functions&lt;/a&gt;, especially in cases where the application defines hundreds or thousands of custom functions.</source>
          <target state="translated">Более эффективная обработка &lt;a href=&quot;c3ref/create_function&quot;&gt;определяемых приложением функций SQL&lt;/a&gt; , особенно в случаях, когда приложение определяет сотни или тысячи пользовательских функций.</target>
        </trans-unit>
        <trans-unit id="bbf641e990dbd768fc579b21dbc73f3e38164565" translate="yes" xml:space="preserve">
          <source>More efficient implementation of sqliteFileExists() under Windows. (by Joel Luscy)</source>
          <target state="translated">Более эффективная реализация sqliteFileExists()под Windows.(автор Джоэл Ласси)</target>
        </trans-unit>
        <trans-unit id="da802536bedcdb71b26438d22c88c54625f47a34" translate="yes" xml:space="preserve">
          <source>More robust handling of out-of-memory errors.</source>
          <target state="translated">Более надежная обработка ошибок вне памяти.</target>
        </trans-unit>
        <trans-unit id="f0bbe298877a69ce96299f0684d775b43d33f438" translate="yes" xml:space="preserve">
          <source>More suggestions...</source>
          <target state="translated">Больше предложений...</target>
        </trans-unit>
        <trans-unit id="40a15bddc2f46eb54c50912ec8296652a2a161bf" translate="yes" xml:space="preserve">
          <source>More than one NEAR operator may appear in a single query. In this case each pair of terms or phrases separated by a NEAR operator must appear within the specified proximity of each other in the document. Using the same table and data as in the block of examples above:</source>
          <target state="translated">В одном запросе может появиться более одного оператора NEAR.В этом случае каждая пара терминов или словосочетаний,разделенных оператором NEAR,должна появляться в пределах указанной близости друг от друга в документе.Используйте ту же таблицу и данные,что и в блоке примеров выше:</target>
        </trans-unit>
        <trans-unit id="759136a5c089af122dabc1e0771753f48776ccec" translate="yes" xml:space="preserve">
          <source>Most CVEs written about SQLite assume that the attacker is able to run arbitrary SQL scripts in SQLite. In most applications, this means that there must first be an SQL Injection vulnerability that allows the attacker to inject the malicious SQL.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8eaec9acde05ea65cc7e78b52370752d8ff824b" translate="yes" xml:space="preserve">
          <source>Most R*Tree queries use a depth-first search. This is accomplished by setting the rScore equal to iLevel. A depth-first search is usually preferred since it minimizes the number of elements in the priority queue, which reduces memory requirements and speeds processing. However, some application may prefer a breadth-first search, which can be accomplished by setting rScore to mxLevel-iLevel. By creating more complex formulas for rScore, applications can exercise detailed control over the order in which subtree are searched and leaf R*Tree entries are returned. For example, in an application with many millions of R*Tree entries, the rScore might be arranged so that the largest or most significant entries are returned first, allowing the application to display the most important information quickly, and filling in smaller and less important details as they become available.</source>
          <target state="translated">Большинство запросов R*Tree используют глубинный поиск.Это достигается установкой rScore равным iLevel.Обычно предпочтительнее использовать глубинный поиск,так как он минимизирует количество элементов в очереди приоритетов,что снижает требования к памяти и ускоряет обработку.Тем не менее,некоторые приложения могут предпочесть поиск по глубине,что можно сделать,установив rScore равным mxLevel-iLevel.Создавая более сложные формулы для rScore,приложения могут осуществлять детальный контроль над порядком,в котором выполняется поиск в поддереве и возвращаются элементы листа R*Tree.Например,в приложении с миллионами записей R*Tree,rScore может быть устроена так,что сначала будут возвращены самые большие или наиболее важные записи,что позволит приложению быстро отображать наиболее важную информацию,а также заполнять более мелкие и менее важные детали по мере их появления.</target>
        </trans-unit>
        <trans-unit id="0b7d92086a8e46f293a7dca57cb6a5c138416054" translate="yes" xml:space="preserve">
          <source>Most SQL database engines (every SQL database engine other than SQLite, as far as we know) uses static, rigid typing. With static typing, the datatype of a value is determined by its container - the particular column in which the value is stored.</source>
          <target state="translated">Большинство движков баз данных SQL (каждый движок баз данных SQL,кроме SQLite,насколько мы знаем)использует статический,жесткий набор текста.При статическом вводе тип значения определяется его контейнером-конкретным столбцом,в котором хранится значение.</target>
        </trans-unit>
        <trans-unit id="0b21de15eb7e27a08d9b4ec057ceb748bbaa22cd" translate="yes" xml:space="preserve">
          <source>Most SQL database engines are client/server based. Of those that are serverless, SQLite is the only one known to this author that allows multiple applications to access the same database at the same time.</source>
          <target state="translated">Большинство движков баз данных SQL основаны на клиенте/сервере.Из тех,которые являются безсерверными,SQLite-единственный известный этому автору,который позволяет нескольким приложениям получать доступ к одной базе данных одновременно.</target>
        </trans-unit>
        <trans-unit id="27297778565294594247653539b897aca8f2a9fb" translate="yes" xml:space="preserve">
          <source>Most SQL database engines are client/server based. Of those that are serverless, SQLite is the only one that this author knows of that allows multiple applications to access the same database at the same time.</source>
          <target state="translated">Большинство движков баз данных SQL основаны на клиенте/сервере.Из тех,которые являются безсерверными,SQLite-единственный,о котором знает автор,позволяющий нескольким приложениям получать доступ к одной и той же базе данных одновременно.</target>
        </trans-unit>
        <trans-unit id="260ad8dfcdd6cee164826174f5ff18a6d6796783" translate="yes" xml:space="preserve">
          <source>Most SQL database engines are implemented as a separate server process. Programs that want to access the database communicate with the server using some kind of interprocess communication (typically TCP/IP) to send requests to the server and to receive back results. SQLite does not work this way. With SQLite, the process that wants to access the database reads and writes directly from the database files on disk. There is no intermediary server process.</source>
          <target state="translated">Большинство движков баз данных SQL реализованы как отдельный серверный процесс.Программы,которые хотят получить доступ к базе данных,взаимодействуют с сервером,используя некий вид межпроцессного взаимодействия (обычно TCP/IP)для отправки запросов к серверу и получения обратно результатов.SQLite не работает таким образом.С SQLite процесс,который хочет получить доступ к базе данных,читает и записывает непосредственно из файлов базы данных на диск.Нет никакого промежуточного серверного процесса.</target>
        </trans-unit>
        <trans-unit id="e11debe28c45aae3eb5d59593787d087cef00a39" translate="yes" xml:space="preserve">
          <source>Most SQL database engines store the schema already parsed into various system tables. On those database engines, ALTER TABLE merely has to make modifications to the corresponding system tables.</source>
          <target state="translated">Большинство движков баз данных SQL хранят уже разобранную схему в различных системных таблицах.На этих двигателях БД ALTER TABLE приходится лишь вносить изменения в соответствующие системные таблицы.</target>
        </trans-unit>
        <trans-unit id="c8146f85b00a04238b33c2841ef39833177b149b" translate="yes" xml:space="preserve">
          <source>Most SQL database engines use static typing. A datatype is associated with each column in a table and only values of that particular datatype are allowed to be stored in that column. SQLite relaxes this restriction by using manifest typing. In manifest typing, the datatype is a property of the value itself, not of the column in which the value is stored. SQLite thus allows the user to store any value of any datatype into any column regardless of the declared type of that column. (There are some exceptions to this rule: An INTEGER PRIMARY KEY column may only store integers. And SQLite attempts to coerce values into the declared datatype of the column when it can.)</source>
          <target state="translated">Большинство движков баз данных SQL используют статический набор текста.Тип данных ассоциируется с каждым столбцом таблицы,и только значения этого типа данных могут храниться в этом столбце.SQLite снимает это ограничение,используя манифестный набор текста.При явном вводе тип данных является свойством самого значения,а не столбца,в котором хранится значение.Таким образом,SQLite позволяет пользователю хранить любое значение любого типа данных в любом столбце,независимо от объявленного типа этого столбца.(Есть некоторые исключения из этого правила:В столбце INTEGER PRIMARY KEY могут храниться только целые числа.И SQLite пытается принудить значения к декларированному типу данных столбца,когда это возможно).</target>
        </trans-unit>
        <trans-unit id="725952f518d7037ff04756bd99d602eae557b1ce" translate="yes" xml:space="preserve">
          <source>Most application formats fit into one of these three categories:</source>
          <target state="translated">Большинство форматов приложений попадает в одну из этих трех категорий:</target>
        </trans-unit>
        <trans-unit id="d19cf0ebd0035eff768792dfdb24fc34ef35cd23" translate="yes" xml:space="preserve">
          <source>Most applications can use SQLite without having to worry about bugs in obscure SQL inputs. If the application controls the SQL, and the application is not deliberately trying to break SQLite, then everything should just work. It is not necessary to have the latest patched version of SQLite. Any older version should work just fine.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce502bced488a9855f9633bf314ed3f557c5599e" translate="yes" xml:space="preserve">
          <source>Most applications will only use the session module functionality described in the previous section. However, the following additional functionality is available for the use and manipulation of changeset and patchset blobs:</source>
          <target state="translated">Большинство приложений будут использовать только функциональность сеансового модуля,описанную в предыдущем разделе.Однако для использования и манипулирования блоками changeset и patchset доступна следующая дополнительная функциональность:</target>
        </trans-unit>
        <trans-unit id="cd513c058fc14329a86bc7561ce2383e9150f5ca" translate="yes" xml:space="preserve">
          <source>Most applications work great with SQLite in its default configuration and with no special compile-time configuration. Most developers should be able to completely ignore this document and simply build SQLite from &lt;a href=&quot;amalgamation&quot;&gt;the amalgamation&lt;/a&gt; without any special knowledge and without taking any special actions.</source>
          <target state="translated">Большинство приложений отлично работают с SQLite в его конфигурации по умолчанию и без специальной конфигурации во время компиляции. Большинство разработчиков должны иметь возможность полностью игнорировать этот документ и просто создавать SQLite из &lt;a href=&quot;amalgamation&quot;&gt;объединения&lt;/a&gt; без каких-либо специальных знаний и без каких-либо специальных действий.</target>
        </trans-unit>
        <trans-unit id="635fff5a9d997771ed833778dcd946f9fa076040" translate="yes" xml:space="preserve">
          <source>Most builds also use the system memory allocation routines:</source>
          <target state="translated">Большинство сборок также используют процедуры выделения системной памяти:</target>
        </trans-unit>
        <trans-unit id="c757f57c7c0fc6a3a16a4ba481be29df77f7ba0d" translate="yes" xml:space="preserve">
          <source>Most built-in window functions ignore the frame-spec, the exceptions being first_value(), last_value() and nth_value(). It is a syntax error to specify a FILTER clause as part of a built-in window function invocation.</source>
          <target state="translated">Большинство встроенных оконных функций игнорируют frame-spec,исключениями являются first_value(),last_value()и nth_value().Синтаксической ошибкой является указание выражения FILTER как части вызова встроенной оконной функции.</target>
        </trans-unit>
        <trans-unit id="91aff38100948ec7606e7b9be6940203c42b637c" translate="yes" xml:space="preserve">
          <source>Most memory statistics are global, and therefore the tracking of statistics must be serialized with a mutex. Statistics are turned on by default, but an option exists to disable them. By disabling memory statistics, SQLite avoids entering and leaving a mutex on each memory allocation and deallocation. That savings can be noticeable on systems where mutex operations are expensive. To disable memory statistics, the following interface is used at start-time:</source>
          <target state="translated">Большинство статистических данных в памяти являются глобальными,поэтому отслеживание статистики должно быть сериализовано с помощью мьютекса.По умолчанию статистика включена,но есть возможность ее отключить.Отключая статистику памяти,SQLite избегает входа и выхода из мьютекса при каждом выделении и распределении памяти.Такая экономия может быть заметна на системах,где операции мьютекса стоят дорого.Для отключения статистики памяти при запуске используется следующий интерфейс:</target>
        </trans-unit>
        <trans-unit id="3ddc29325f5f8b33e852a6ad2b01d9c1a5b27979" translate="yes" xml:space="preserve">
          <source>Most object references may only resolve to a specific type of object (for example a reference that is part of a DROP TABLE statement may only resolve to a table object, not an index, trigger or view). However in some contexts (e.g. &lt;a href=&quot;lang_reindex&quot;&gt;REINDEX&lt;/a&gt;) an object reference may be resolve to more than one type of object. When searching database schemas for a named object, objects of types that cannot be used in the context of the reference are always ignored.</source>
          <target state="translated">Большинство ссылок на объекты могут разрешаться только в определенный тип объекта (например, ссылка, которая является частью оператора DROP TABLE, может разрешаться только в объект таблицы, а не в индекс, триггер или представление). Однако в некоторых контекстах (например, &lt;a href=&quot;lang_reindex&quot;&gt;REINDEX&lt;/a&gt; ) ссылка на объект может быть разрешена для более чем одного типа объекта. При поиске в схемах базы данных именованного объекта объекты типов, которые нельзя использовать в контексте ссылки, всегда игнорируются.</target>
        </trans-unit>
        <trans-unit id="1f85923bce6297c36b3c44bb82e688cbd09f35ee" translate="yes" xml:space="preserve">
          <source>Most of the code in the SQLite source tree is devoted purely to &lt;a href=&quot;testing&quot;&gt;testing and verification&lt;/a&gt;. Reliability is important to SQLite. Among the tasks of the test infrastructure is to ensure that SQLite does not misuse dynamically allocated memory, that SQLite does not leak memory, and that SQLite responds correctly to a dynamic memory allocation failure.</source>
          <target state="translated">Большая часть кода в дереве исходных текстов SQLite предназначена исключительно для &lt;a href=&quot;testing&quot;&gt;тестирования и проверки&lt;/a&gt; . Для SQLite важна надежность. Среди задач тестовой инфраструктуры - убедиться, что SQLite не злоупотребляет динамически выделяемой памятью, что SQLite не вызывает утечки памяти и что SQLite правильно реагирует на сбой динамического выделения памяти.</target>
        </trans-unit>
        <trans-unit id="4ea1351b2e34fd10311e1e13ffcc8b793141d24f" translate="yes" xml:space="preserve">
          <source>Most of the time, sqlite3 just reads lines of input and passes them on to the SQLite library for execution. But input lines that begin with a dot (&quot;.&quot;) are intercepted and interpreted by the sqlite3 program itself. These &quot;dot commands&quot; are typically used to change the output format of queries, or to execute certain prepackaged query statements. There were originally just a few dot commands, but over the years many new features have accumulated so that today there over 60.</source>
          <target state="translated">В большинстве случаев sqlite3 просто читает строки ввода и передает их на исполнение в библиотеку SQLite.Но строки ввода,начинающиеся с точки (&quot;.&quot;)перехватываются и интерпретируются самой программой sqlite3.Эти &quot;точечные команды&quot; обычно используются для изменения формата вывода запросов или для выполнения определенных предупакованных операторов запроса.Изначально было всего несколько точечных команд,но с годами накопилось много новых возможностей,так что сегодня их более 60.</target>
        </trans-unit>
        <trans-unit id="8140e633bb506b56ea3ecec29c87f47b39a7e315" translate="yes" xml:space="preserve">
          <source>Most of the time, the query planner in SQLite does a good job. However, the query planner needs indices to work with. These indices must normally be added by programmers. Rarely, the query planner AI will make a suboptimal algorithm choice. In those cases, programmers may want to provide additional hints to help the query planner do a better job.</source>
          <target state="translated">В большинстве случаев планировщик запросов в SQLite делает хорошую работу.Однако для работы планировщика запросов нужны индексы.Как правило,эти индексы должны добавляться программистами.Редко бывает,что AI планировщик запросов сделает выбор субоптимального алгоритма.В этих случаях программисты,возможно,захотят предоставить дополнительные подсказки,чтобы помочь планировщику запросов сделать работу лучше.</target>
        </trans-unit>
        <trans-unit id="4d637cb6d91465469dba952401dcd3c4590d5c67" translate="yes" xml:space="preserve">
          <source>Most other SQL database engines allocated a fixed amount of disk space for each row in most tables. They play special tricks for handling BLOBs and CLOBs which can be of wildly varying length. But for most tables, if you declare a column to be a VARCHAR(100) then the database engine will allocate 100 bytes of disk space regardless of how much information you actually store in that column.</source>
          <target state="translated">Большинство других движков баз данных SQL выделяют фиксированное дисковое пространство для каждой строки в большинстве таблиц.Они проигрывают специальные трюки для работы с BLOB и CLOB,которые могут быть различной длины.Но для большинства таблиц,если вы объявите столбец VARCHAR(100),то движок базы данных выделит 100 байт дискового пространства независимо от того,сколько информации вы на самом деле храните в этом столбце.</target>
        </trans-unit>
        <trans-unit id="b52c62ddb6e76f10df4280114ef18bdd833e392c" translate="yes" xml:space="preserve">
          <source>Most other SQL database engines are much larger than this. IBM boasts that its recently released CloudScape database engine is &quot;only&quot; a 2MiB jar file - an order of magnitude larger than SQLite even after it is compressed! Firebird boasts that its client-side library is only 350KiB. That's as big as SQLite and does not even contain the database engine. The Berkeley DB library from Oracle is 450KiB and it omits SQL support, providing the programmer with only simple key/value pairs.</source>
          <target state="translated">Большинство других движков баз данных SQL гораздо больше.IBM может похвастаться тем,что его недавно выпущенный движок базы данных CloudScape-это &quot;всего лишь&quot; 2MiB jar-файл-на порядок больше,чем SQLite,даже после его сжатия! Firebird может похвастаться тем,что его клиентская библиотека составляет всего 350 КБ.Она такая же большая,как и SQLite,и даже не содержит движка базы данных.Библиотека БД Беркли от Oracle составляет 450 КБ и в ней отсутствует поддержка SQL,предоставляя программисту только простые пары ключ/значение.</target>
        </trans-unit>
        <trans-unit id="5dfe3bda7177abf58f732623f4daabfa91229422" translate="yes" xml:space="preserve">
          <source>Most other SQL database engines require you to dump and restore the database when moving from one platform to another and often when upgrading to a newer version of the software.</source>
          <target state="translated">Большинство других движков баз данных SQL требуют дампа и восстановления базы данных при переходе с одной платформы на другую и часто при обновлении на более новую версию программного обеспечения.</target>
        </trans-unit>
        <trans-unit id="879c0198beea8a0459677487adc544c847a7576f" translate="yes" xml:space="preserve">
          <source>Most programmers compile SQLite into their applications using the &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt;. The &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt; is C-code but it is not &quot;source code&quot;. The &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt; is generated from source code by scripts.</source>
          <target state="translated">Большинство программистов компилируют SQLite в свои приложения, используя &lt;a href=&quot;amalgamation&quot;&gt;объединение&lt;/a&gt; . &lt;a href=&quot;amalgamation&quot;&gt;Объединение&lt;/a&gt; является C-код , но это не &amp;laquo;исходный код&amp;raquo;. &lt;a href=&quot;amalgamation&quot;&gt;Объединение&lt;/a&gt; генерируется из исходного кода при помощи скриптов.</target>
        </trans-unit>
        <trans-unit id="e8416192176e318d00a7b55e02e8a608d8bdbda6" translate="yes" xml:space="preserve">
          <source>Most tables in SQLite consist of zero or more rows with a unique integer key (the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; or &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;) followed by content. (The exception is &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables.) The rows are logically stored in order of increasing rowid. As an example, this article uses a table named &quot;FruitsForSale&quot; which relates various fruits to the state where they are grown and their unit price at market. The schema is this:</source>
          <target state="translated">Большинство таблиц в SQLite состоят из нуля или более строк с уникальным целочисленным ключом ( &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; или &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; ), за которым следует содержимое. (Исключение составляют таблицы &lt;a href=&quot;withoutrowid&quot;&gt;БЕЗ ROWID&lt;/a&gt; .) Строки логически сохраняются в порядке увеличения rowid. В качестве примера в этой статье используется таблица &amp;laquo;FruitsForSale&amp;raquo;, которая связывает различные фрукты со штатом, в котором они выращиваются, и их рыночной ценой за единицу. Схема такая:</target>
        </trans-unit>
        <trans-unit id="22d0e010589dcfa569bc8ab54799e70d1b27d453" translate="yes" xml:space="preserve">
          <source>Most tables in a typical SQLite database schema are rowid tables.</source>
          <target state="translated">Большинство таблиц в типичной схеме базы данных SQLite-это рядные таблицы.</target>
        </trans-unit>
        <trans-unit id="ab23b25ac3bb6f94df4203c5e40926f8de962adb" translate="yes" xml:space="preserve">
          <source>Most users of swarmvtab will only use the features described above. This section describes features designed for more esoteric use cases. These features all involve specifying extra optional parameters following the SQL statement as part of the CREATE VIRTUAL TABLE command. An optional parameter is specified using its name, followed by an &quot;=&quot; character, followed by an optionally quoted value. Whitespace may separate the name, &quot;=&quot; character and value. For example:</source>
          <target state="translated">Большинство пользователей swarmvtab будут использовать только функции,описанные выше.В этом разделе описаны функции,предназначенные для более эзотерических случаев использования.Все эти функции включают в себя указание дополнительных опциональных параметров,следующих за SQL-оператором,как часть команды CREATE VIRTUAL TABLE.Дополнительный параметр задается с использованием его имени,за которым следует символ &quot;=&quot;,а затем опционально цитируемое значение.Пробельные символы могут разделять имя,символ &quot;=&quot; и значение.Например:</target>
        </trans-unit>
        <trans-unit id="76cdb950721642b6b8596d36d5a39f7705028b99" translate="yes" xml:space="preserve">
          <source>Move</source>
          <target state="translated">Move</target>
        </trans-unit>
        <trans-unit id="7e894652e8d984064189391f996d60397e2a48ec" translate="yes" xml:space="preserve">
          <source>Move a BLOB Handle to a New Row</source>
          <target state="translated">Переместите ручку BLOB в новый ряд.</target>
        </trans-unit>
        <trans-unit id="b0ff33b105569af9f2119de68af4d3ef24773b02" translate="yes" xml:space="preserve">
          <source>Move the P3 values in register P1..P1+P3-1 over into registers P2..P2+P3-1. Registers P1..P1+P3-1 are left holding a NULL. It is an error for register ranges P1..P1+P3-1 and P2..P2+P3-1 to overlap. It is an error for P3 to be less than 1.</source>
          <target state="translated">Переместите значения P3 в регистре P1...P1+P3-1 в регистр P2...P2+P3-1.Регистры P1...P1+P3-1 оставлены с NULL.Это ошибка для перекрытия диапазонов регистров P1...P1+P3-1 и P2...P2+P3-1.Это ошибка,когда P3 меньше 1.</target>
        </trans-unit>
        <trans-unit id="43e629ad230f33beeec0dc2dfe68b2611f083ba6" translate="yes" xml:space="preserve">
          <source>Move the cursor P1 to a null row. Any &lt;a href=&quot;opcode#Column&quot;&gt;Column&lt;/a&gt; operations that occur while the cursor is on the null row will always write a NULL.</source>
          <target state="translated">Переместите курсор P1 в пустую строку. Любые операции со &lt;a href=&quot;opcode#Column&quot;&gt;столбцами,&lt;/a&gt; которые происходят, когда курсор находится на нулевой строке, всегда будут записывать NULL.</target>
        </trans-unit>
        <trans-unit id="ff17aceff7878d14b853ed0faf40490493d4491b" translate="yes" xml:space="preserve">
          <source>Move website and documentation files out of the source tree into a &lt;a href=&quot;http://www.sqlite.org/docsrc/&quot;&gt;separate CM system&lt;/a&gt;.</source>
          <target state="translated">Переместите файлы веб-сайта и документации из дерева исходных текстов в &lt;a href=&quot;http://www.sqlite.org/docsrc/&quot;&gt;отдельную систему CM&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b5bd873ad5c9f2c5c76a311ec509bc5304045928" translate="yes" xml:space="preserve">
          <source>Move website and documentation files out of the source tree into a &lt;a href=&quot;https://www.sqlite.org/docsrc/&quot;&gt;separate CM system&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42fda9211198a462ad90d286a7b4b2828423cc34" translate="yes" xml:space="preserve">
          <source>Moved the CVS repository to www.sqlite.org</source>
          <target state="translated">Переместил CVS репозиторий на www.sqlite.org.</target>
        </trans-unit>
        <trans-unit id="dc586a90c5c94a44d1d972ced97472cbaf4b949e" translate="yes" xml:space="preserve">
          <source>Moving From SQLite 3.4.2 to 3.5.0</source>
          <target state="translated">Переход с SQLite 3.4.2 на 3.5.0</target>
        </trans-unit>
        <trans-unit id="d4fefbd0278cf9b39cd3f466ee48861cfc5e39db" translate="yes" xml:space="preserve">
          <source>Moving From SQLite 3.5.9 to 3.6.0</source>
          <target state="translated">Переход с SQLite 3.5.9 на 3.6.0</target>
        </trans-unit>
        <trans-unit id="f76bc373feee6b1842d340bd7d664f80273b9cc9" translate="yes" xml:space="preserve">
          <source>Moving a journal file from one database to another.</source>
          <target state="translated">Перемещение файла журнала из одной базы данных в другую.</target>
        </trans-unit>
        <trans-unit id="f0efafe4edefbbfdb22e09fc7f8e1939d65fc935" translate="yes" xml:space="preserve">
          <source>Much of the &lt;a href=&quot;c3ref/intro&quot;&gt;C-language Interface&lt;/a&gt; is found in source files &lt;a href=&quot;https://sqlite.org/src/file/src/main.c&quot;&gt;main.c&lt;/a&gt;, &lt;a href=&quot;https://sqlite.org/src/file/src/legacy.c&quot;&gt;legacy.c&lt;/a&gt;, and &lt;a href=&quot;https://sqlite.org/src/file/src/vdbeapi.c&quot;&gt;vdbeapi.c&lt;/a&gt; though some routines are scattered about in other files where they can have access to data structures with file scope. The &lt;a href=&quot;c3ref/free_table&quot;&gt;sqlite3_get_table()&lt;/a&gt; routine is implemented in &lt;a href=&quot;https://sqlite.org/src/file/src/table.c&quot;&gt;table.c&lt;/a&gt;. The &lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_mprintf()&lt;/a&gt; routine is found in &lt;a href=&quot;https://sqlite.org/src/file/src/printf.c&quot;&gt;printf.c&lt;/a&gt;. The &lt;a href=&quot;c3ref/complete&quot;&gt;sqlite3_complete()&lt;/a&gt; interface is in &lt;a href=&quot;https://sqlite.org/src/file/src/complete.c&quot;&gt;complete.c&lt;/a&gt;. The &lt;a href=&quot;tclsqlite&quot;&gt;TCL Interface&lt;/a&gt; is implemented by &lt;a href=&quot;https://sqlite.org/src/file/src/tclsqlite.c&quot;&gt;tclsqlite.c&lt;/a&gt;.</source>
          <target state="translated">Большая часть &lt;a href=&quot;c3ref/intro&quot;&gt;интерфейса на языке C&lt;/a&gt; находится в исходных файлах &lt;a href=&quot;https://sqlite.org/src/file/src/main.c&quot;&gt;main.c&lt;/a&gt; , &lt;a href=&quot;https://sqlite.org/src/file/src/legacy.c&quot;&gt;legacy.c&lt;/a&gt; и &lt;a href=&quot;https://sqlite.org/src/file/src/vdbeapi.c&quot;&gt;vdbeapi.c,&lt;/a&gt; хотя некоторые подпрограммы разбросаны по другим файлам, где они могут иметь доступ к структурам данных с файловой областью. &lt;a href=&quot;c3ref/free_table&quot;&gt;Sqlite3_get_table ()&lt;/a&gt; подпрограмма реализуется в &lt;a href=&quot;https://sqlite.org/src/file/src/table.c&quot;&gt;table.c&lt;/a&gt; . &lt;a href=&quot;c3ref/mprintf&quot;&gt;Sqlite3_mprintf ()&lt;/a&gt; подпрограмма находится в &lt;a href=&quot;https://sqlite.org/src/file/src/printf.c&quot;&gt;printf.c&lt;/a&gt; . Интерфейс &lt;a href=&quot;c3ref/complete&quot;&gt;sqlite3_complete ()&lt;/a&gt; находится в &lt;a href=&quot;https://sqlite.org/src/file/src/complete.c&quot;&gt;complete.c&lt;/a&gt; . &lt;a href=&quot;tclsqlite&quot;&gt;TCL Интерфейс&lt;/a&gt; реализован &lt;a href=&quot;https://sqlite.org/src/file/src/tclsqlite.c&quot;&gt;tclsqlite.c&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0aeaa0f6e5bc7f27528f2732350cce3993158ba7" translate="yes" xml:space="preserve">
          <source>Multi-File Transactions</source>
          <target state="translated">Многофайловые операции</target>
        </trans-unit>
        <trans-unit id="7bd215d0dc08a639766c0fd92af7ca6bd919b359" translate="yes" xml:space="preserve">
          <source>Multi-character insertions, deletions, and substitutions can be enumerated in the cost table.</source>
          <target state="translated">Многосимвольные вставки,удаления и замены могут быть перечислены в таблице стоимости.</target>
        </trans-unit>
        <trans-unit id="658e2e2d073be17c3d24649adb63bc8071c4e34c" translate="yes" xml:space="preserve">
          <source>Multi-column indexes</source>
          <target state="translated">Многоколоночные индексы</target>
        </trans-unit>
        <trans-unit id="b37d6f5d76bdf33c501015c981f38efa402cfb25" translate="yes" xml:space="preserve">
          <source>Multi-column indices only work if the constraint terms in the WHERE clause of the query are connected by AND. So Idx3 and Idx4 are helpful when the search is for items that are both Oranges and grown in California, but neither index would be that useful if we wanted all items that were either oranges</source>
          <target state="translated">Индексы из нескольких столбцов работают только в том случае,если ограничительные условия в выражении WHERE запроса связаны с помощью AND.Таким образом,индексы Idx3 и Idx4 полезны,когда поиск ведется для элементов,которые одновременно являются оранжевыми и выросли в Калифорнии,но ни один из индексов не будет настолько полезен,если мы хотим,чтобы все элементы,которые были либо оранжевыми.</target>
        </trans-unit>
        <trans-unit id="a6a2f3477040c5c780afe34563348a368c865f18" translate="yes" xml:space="preserve">
          <source>Multiple Programming Languages</source>
          <target state="translated">Языки многократного программирования</target>
        </trans-unit>
        <trans-unit id="8127845d9b0c204fa8283356e673cf21f966c9a0" translate="yes" xml:space="preserve">
          <source>Multiple VFSes can be registered at the same time. Each VFS has a unique names. Separate &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt; within the same process can be using different VFSes at the same time. For that matter, if a single database connection has multiple database files open using the &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; command, then each attached database might be using a different VFS.</source>
          <target state="translated">Одновременно можно зарегистрировать несколько VFS. Каждая VFS имеет уникальные имена. Отдельные &lt;a href=&quot;c3ref/sqlite3&quot;&gt;соединения с базами данных&lt;/a&gt; в пределах того же процесса могут быть с использованием различных VFSes в то же самое время. В этом отношении, если одно соединение с базой данных имеет несколько файлов базы данных, открытых с помощью команды &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; , тогда каждая присоединенная база данных может использовать другую VFS.</target>
        </trans-unit>
        <trans-unit id="dcdea0a58cadff7c782d97a6048e7da5d88f4991" translate="yes" xml:space="preserve">
          <source>Multiple b-tree structures are used instead of a single b-tree to reduce the cost of inserting records into FTS tables. When a new record is inserted into an FTS table that already contains a lot of data, it is likely that many of the terms in the new record are already present in a large number of existing records. If a single b-tree were used, then large doclist structures would have to be loaded from the database, amended to include the new docid and term-offset list, then written back to the database. Using multiple b-tree tables allows this to be avoided by creating a new b-tree which can be merged with the existing b-tree (or b-trees) later on. Merging of b-tree structures can be performed as a background task, or once a certain number of separate b-tree structures have been accumulated. Of course, this scheme makes queries more expensive (as the FTS code may have to look up individual terms in more than one b-tree and merge the results), but it has been found that in practice this overhead is often negligible.</source>
          <target state="translated">Вместо одного b-дерева используются несколько b-деревянных структур для снижения затрат на вставку записей в таблицы FTS.Когда новая запись вставляется в таблицу ФСТ,которая уже содержит большое количество данных,вполне вероятно,что многие из терминов в новой записи уже присутствуют в большом количестве существующих записей.Если бы использовалось одно b-дерево,то пришлось бы загружать из БД большие doclist-структуры,изменять их таким образом,чтобы они включали новый docid и term-offset-список,а затем записывать их обратно в БД.Использование нескольких b-деревьев позволяет избежать этого путем создания нового b-дерева,которое впоследствии может быть объединено с существующим b-деревом (или b-деревом).Слияние b-деревянных структур может быть выполнено как фоновая задача,так и после накопления определенного количества отдельных b-деревянных структур.Конечно,такая схема делает запросы более дорогостоящими (так как код ФСТ может быть вынужден искать отдельные термины более чем в одном b-дереве и сливать результаты),но было обнаружено,что на практике эти накладные расходы зачастую ничтожно малы.</target>
        </trans-unit>
        <trans-unit id="46b7208fbb4e603607fdd8e005b8c2b44c4f2832" translate="yes" xml:space="preserve">
          <source>Multiple bug fixes to the &lt;a href=&quot;rowvalue&quot;&gt;row value&lt;/a&gt; logic that was introduced in version 3.15.0.</source>
          <target state="translated">Множественные исправления ошибок в логике &lt;a href=&quot;rowvalue&quot;&gt;значений строк,&lt;/a&gt; которые были введены в версии 3.15.0.</target>
        </trans-unit>
        <trans-unit id="5bf9dc54bb3a9335bc64c25972bec9a940f13e21" translate="yes" xml:space="preserve">
          <source>Multiple commentators have expressed a desire to use dynamic strings for the pointer type, and to have SQLite take ownership of the type strings and to automatically free the type string when it has finished using it. That design is rejected for the following reasons:</source>
          <target state="translated">Несколько комментаторов выразили желание использовать динамические строки для типа указателя,а также заставить SQLite взять в собственность строки типа и автоматически освободить строку типа после того,как он закончит использовать ее.Такая конструкция отвергается по следующим причинам:</target>
        </trans-unit>
        <trans-unit id="5989cfc9447928ba4d05b443c6d4b672ed4ef531" translate="yes" xml:space="preserve">
          <source>Multiple connections from within a single process that use this implementation of asynchronous IO may access a single database file concurrently. From the point of view of the user, if all connections are from within a single process, there is no difference between the concurrency offered by &quot;normal&quot; SQLite and SQLite using the asynchronous backend.</source>
          <target state="translated">Несколько соединений внутри одного процесса,использующих эту реализацию асинхронного ввода-вывода,могут одновременно получать доступ к одному файлу БД.С точки зрения пользователя,если все соединения находятся внутри одного процесса,то нет разницы между параллельностью,предлагаемой &quot;нормальным&quot; SQLite и SQLite,использующим асинхронный бэкэнд.</target>
        </trans-unit>
        <trans-unit id="de5017f80cc138eb92a9fee1631567420f1d53b1" translate="yes" xml:space="preserve">
          <source>Multiple connections may hold a read-lock simultaneously. If many threads are acquiring overlapping read-locks, it might be the case that at least one thread is always holding a read lock. Then a table waiting for a write-lock will wait forever. This scenario is called &quot;writer starvation.&quot;</source>
          <target state="translated">Несколько соединений могут содержать одновременно блокировку чтения.Если многие потоки приобретают перекрывающиеся блокировки чтения,может случиться так,что по крайней мере один поток всегда будет держать блокировку чтения.Тогда стол,ожидающий блокировки записи,будет ждать вечно.Этот сценарий называется &quot;голодной записью&quot;.</target>
        </trans-unit>
        <trans-unit id="809241f3730c6379db2c7c73b89d2efee62ec7f1" translate="yes" xml:space="preserve">
          <source>Multiple databases on the same &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; using &lt;a href=&quot;lang_attach&quot;&gt;ATTACH DATABASE&lt;/a&gt;</source>
          <target state="translated">Несколько баз данных в одном &lt;a href=&quot;c3ref/sqlite3&quot;&gt;подключении к базе данных&lt;/a&gt; с помощью &lt;a href=&quot;lang_attach&quot;&gt;ATTACH DATABASE&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="45a728f83fed6326d4c43841ba1813e1ce7eb6dd" translate="yes" xml:space="preserve">
          <source>Multiple processes can attach to the same application file and can read and write without interfering with each another.</source>
          <target state="translated">Несколько процессов могут присоединяться к одному и тому же файлу приложения и могут читать и записывать,не мешая друг другу.</target>
        </trans-unit>
        <trans-unit id="2aa7ba24512eed1d018b442b661d99d24d2bbe28" translate="yes" xml:space="preserve">
          <source>Multiple processes can have the same database open at the same time. Multiple processes can be doing a SELECT at the same time. But only one process can be making changes to the database at any moment in time, however.</source>
          <target state="translated">Несколько процессов могут иметь одну и ту же базу данных одновременно.Несколько процессов могут выполнять SELECT одновременно.Но только один процесс может вносить изменения в базу данных в любой момент времени.</target>
        </trans-unit>
        <trans-unit id="933ed3deea04e9e9fbd7189bd88652e303cb225d" translate="yes" xml:space="preserve">
          <source>Multiple small sorts collectively use fewer CPU cycles than a single large sort.</source>
          <target state="translated">Множество маленьких сортов в совокупности используют меньше циклов процессора,чем один большой сорт.</target>
        </trans-unit>
        <trans-unit id="b20a305f06f0be2e3dd77e203ae365353776cf59" translate="yes" xml:space="preserve">
          <source>Multiply</source>
          <target state="translated">Multiply</target>
        </trans-unit>
        <trans-unit id="8e0df4037503e2d7d2784fedb62cdd6ec1bcce1f" translate="yes" xml:space="preserve">
          <source>Multiply the value in register P1 by the value in register P2 and store the result in register P3. If either input is NULL, the result is NULL.</source>
          <target state="translated">Умножьте значение в регистре P1 на значение в регистре P2 и сохраните результат в регистре P3.Если любой из входов имеет значение NULL,то результат будет NULL.</target>
        </trans-unit>
        <trans-unit id="96a8063d277e69bad9338f2cd2299ce555b10c74" translate="yes" xml:space="preserve">
          <source>Multiplying null by zero gives null</source>
          <target state="translated">Умножение нуля на ноль дает ноль</target>
        </trans-unit>
        <trans-unit id="0882d3aaa23d5575a8f63bfdd8452012d19a092f" translate="yes" xml:space="preserve">
          <source>MustBeInt</source>
          <target state="translated">MustBeInt</target>
        </trans-unit>
        <trans-unit id="ad84a5c1e8958f4a9c3429e8188a4603875d0079" translate="yes" xml:space="preserve">
          <source>Mutation test script</source>
          <target state="translated">Скрипт теста на мутацию</target>
        </trans-unit>
        <trans-unit id="20e073cd00cadf7d267e8b82f5b78e0e3f9214a2" translate="yes" xml:space="preserve">
          <source>Mutation testing can be slow, since each test can take up to 5 minutes on a fast workstation, and there are two tests for each branch instructions, and over 20,000 branch instructions. Efforts are made to expedite operation. For example, TH3 is compiled in such a way that it exits as soon as it finds the first error, and as many of the mutations are easily detected, many cycles happen in only a few seconds. Nevertheless, the mutation-test.tcl script includes command-line options to limit the range of code lines tested so that mutation testing only needs to be performed on blocks of code that have recently changed.</source>
          <target state="translated">Тестирование мутации может быть медленным,так как каждый тест может занять до 5 минут на быстрой рабочей станции,и есть два теста для каждой инструкции ветви,и более 20 000 инструкций ветви.Прилагаются усилия для ускорения работы.Например,TH3 скомпилирован таким образом,что выходит сразу после обнаружения первой ошибки,и поскольку многие мутации легко обнаруживаются,многие циклы происходят всего за несколько секунд.Тем не менее,скрипт mutation-test.tcl включает опции командной строки для ограничения диапазона проверяемых строк кода,так что проверка мутаций должна выполняться только на недавно изменившихся блоках кода.</target>
        </trans-unit>
        <trans-unit id="ee9066f4d731d8a141c6e684743ee9a9527de8b6" translate="yes" xml:space="preserve">
          <source>Mutex Handle</source>
          <target state="translated">рукоятка из мутекса</target>
        </trans-unit>
        <trans-unit id="9f117864c1709baa2c76d7b2cfa8d17c9f1bfe11" translate="yes" xml:space="preserve">
          <source>Mutex Methods Object</source>
          <target state="translated">Мютексные методы Объект</target>
        </trans-unit>
        <trans-unit id="83fb9a7fd1246d148749d832e1630432bf7c41eb" translate="yes" xml:space="preserve">
          <source>Mutex Types</source>
          <target state="translated">Типы мутекса</target>
        </trans-unit>
        <trans-unit id="9ca067080a430d66f997055e5f2d644e22736a96" translate="yes" xml:space="preserve">
          <source>Mutex Verification Routines</source>
          <target state="translated">Маршруты проверки Мьютекса</target>
        </trans-unit>
        <trans-unit id="82f2c9599c5c14be2ce92b9de958cb57db81b38f" translate="yes" xml:space="preserve">
          <source>Mutexes</source>
          <target state="translated">Mutexes</target>
        </trans-unit>
        <trans-unit id="5b84f7a78e5961ea2a526de843a9daab8f41a20c" translate="yes" xml:space="preserve">
          <source>Mutexes are cheap but they are not free, so performance will be better when mutexes are completely disabled. The resulting library footprint will also be a little smaller. Disabling the mutexes at compile-time is a recommended optimization for applications where it makes sense.</source>
          <target state="translated">Мютексы дешевы,но не бесплатны,поэтому производительность будет лучше,когда мютексы полностью отключены.В результате площадь,занимаемая библиотекой,также будет немного меньше.Отключение мьютексов во время компиляции является рекомендуемой оптимизацией для приложений,где это имеет смысл.</target>
        </trans-unit>
        <trans-unit id="b22446695cc6c25d3041d52dab780b6caac7cd1e" translate="yes" xml:space="preserve">
          <source>Mutexes are created using &lt;a href=&quot;#sqlite3_mutex_alloc&quot;&gt;sqlite3_mutex_alloc()&lt;/a&gt;.</source>
          <target state="translated">Мьютексы создаются с помощью &lt;a href=&quot;#sqlite3_mutex_alloc&quot;&gt;sqlite3_mutex_alloc ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a8bd3143e806972c1aad1cdeede17125b4f66fc3" translate="yes" xml:space="preserve">
          <source>Mutexes are created using &lt;a href=&quot;mutex_alloc&quot;&gt;sqlite3_mutex_alloc()&lt;/a&gt;.</source>
          <target state="translated">Мьютексы создаются с помощью &lt;a href=&quot;mutex_alloc&quot;&gt;sqlite3_mutex_alloc ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="90dba5f17bdba09d7b97e3f464ca3b8fa2e57394" translate="yes" xml:space="preserve">
          <source>My WHERE clause expression &lt;code&gt;column1=&quot;column1&quot;&lt;/code&gt; does not work. It causes every row of the table to be returned, not just the rows where column1 has the value &quot;column1&quot;.</source>
          <target state="translated">Мое выражение предложения WHERE &lt;code&gt;column1=&quot;column1&quot;&lt;/code&gt; не работает. Это приводит к возврату каждой строки таблицы, а не только строк, в которых column1 имеет значение &amp;laquo;column1&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="53dbb81c605812b9954b771e4d176a4b96f646d2" translate="yes" xml:space="preserve">
          <source>My query does not return the column name that I expect. Is this a bug?</source>
          <target state="translated">Мой запрос не возвращает имя столбца,которое я ожидаю.Это ошибка?</target>
        </trans-unit>
        <trans-unit id="deaa0c393a6613972aaccbf1fecfdad67aa21e88" translate="yes" xml:space="preserve">
          <source>MySQL</source>
          <target state="translated">MySQL</target>
        </trans-unit>
        <trans-unit id="424aa797f42c3aefebeedcebb618509b36642239" translate="yes" xml:space="preserve">
          <source>MySQL supports the UPDATE FROM idea, but it does so without using a FROM clause. Instead, the complete join specification is given in between the UPDATE and SET keywords. The equivalent MySQL statement would be like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5d56b96c147bc00244a87ca5dec3dbb343c2acd" translate="yes" xml:space="preserve">
          <source>MySQL version 3.23.41 does not support UNION.</source>
          <target state="translated">MySQL версия 3.23.41 не поддерживает UNION.</target>
        </trans-unit>
        <trans-unit id="e303d2711b51452d1cb5f1e99368e6acecd1238f" translate="yes" xml:space="preserve">
          <source>MySQL:</source>
          <target state="translated">MySQL:</target>
        </trans-unit>
        <trans-unit id="b51a60734da64be0e618bacbea2865a8a7dcd669" translate="yes" xml:space="preserve">
          <source>N</source>
          <target state="translated">N</target>
        </trans-unit>
        <trans-unit id="8942124b2b322d5ed5aaedb0379f2b4629d337ae" translate="yes" xml:space="preserve">
          <source>N&amp;ge;12 and even</source>
          <target state="translated">N&amp;ge;12 и даже</target>
        </trans-unit>
        <trans-unit id="65234a7e6be9327b0d7bbc7e6bf2ce41cdf5a33b" translate="yes" xml:space="preserve">
          <source>N&amp;ge;13 and odd</source>
          <target state="translated">N&amp;ge;13 и нечетное</target>
        </trans-unit>
        <trans-unit id="4bbff46d5e4a2066e44932399c1db699e807cf39" translate="yes" xml:space="preserve">
          <source>N+1</source>
          <target state="translated">N+1</target>
        </trans-unit>
        <trans-unit id="bd2f53c8c05f137a14d10bbea3ef6da285114906" translate="yes" xml:space="preserve">
          <source>N+4</source>
          <target state="translated">N+4</target>
        </trans-unit>
        <trans-unit id="08d2e98e6754af941484848930ccbaddfefe13d6" translate="yes" xml:space="preserve">
          <source>N/A</source>
          <target state="translated">N/A</target>
        </trans-unit>
        <trans-unit id="8dd6dc5b4967e63a1a79c5eb2a6c948692613a58" translate="yes" xml:space="preserve">
          <source>N1 (cost: 5.52)</source>
          <target state="translated">N1 (стоимость:5,52)</target>
        </trans-unit>
        <trans-unit id="798d9ffe324145d7424e3df912c7130f87d2bc5a" translate="yes" xml:space="preserve">
          <source>N2 (cost: 5.52)</source>
          <target state="translated">N2 (стоимость:5,52)</target>
        </trans-unit>
        <trans-unit id="15fbf39b576cc8bd369719e2a3d26f97ec889560" translate="yes" xml:space="preserve">
          <source>N2-N1 (cost: 11.04)</source>
          <target state="translated">N2-N1 (стоимость:11.04)</target>
        </trans-unit>
        <trans-unit id="5b4ea6d782abcd0ed1483d887c331af67374531e" translate="yes" xml:space="preserve">
          <source>N&lt;sub&gt;&lt;small&gt;left&lt;/small&gt;&lt;/sub&gt;</source>
          <target state="translated">N&lt;sub&gt;&lt;small&gt;left&lt;/small&gt;&lt;/sub&gt;</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
