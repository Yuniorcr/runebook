<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="sqlite">
    <body>
      <group id="sqlite">
        <trans-unit id="33c558ed5ce36b119e16ee3e9d824eb5021f92cb" translate="yes" xml:space="preserve">
          <source>In the previous sections, we have seen how moving from a key/value store implemented as a ZIP archive to a simple SQLite database with just three tables can add significant capabilities to an application file format. We could continue to enhance the schema with new tables, with indexes added for performance, with triggers and views for programming convenience, and constraints to enforce consistency of content even in the face of programming errors. Further enhancement ideas include:</source>
          <target state="translated">В предыдущих разделах мы видели,как переход от хранилища ключей/значений,реализованный в виде ZIP-архива,к простой базе данных SQLite,содержащей всего три таблицы,может добавить значительные возможности формату файла приложения.Мы могли бы продолжать совершенствовать схему с новыми таблицами,с индексами,добавленными для повышения производительности,с триггерами и представлениями для удобства программирования,а также с ограничениями для обеспечения согласованности содержимого даже перед лицом ошибок программирования.Дальнейшие идеи по улучшению включают в себя:</target>
        </trans-unit>
        <trans-unit id="6567a872214501806e02589f934b8c11a8b0e4f5" translate="yes" xml:space="preserve">
          <source>In the previous, the &quot;type NOT IN ('object','array')&quot; term of the WHERE clause suppresses containers and only lets through leaf elements. The same effect could be achieved this way:</source>
          <target state="translated">В предыдущем пункте термин &quot;type NOT IN (&quot;объект&quot;,&quot;массив&quot;)&quot; пункта WHERE подавляет контейнеры и пропускает только элементы листа.Аналогичного эффекта можно добиться и таким образом:</target>
        </trans-unit>
        <trans-unit id="1dd63ff23c59a1e0a739d0a06a35ed29c44ad2c6" translate="yes" xml:space="preserve">
          <source>In the query above, if both t1 and t2 have approximately N rows, then without any indices the query will require O(N*N) time. On the other hand, creating an index on table t2 requires O(NlogN) time and then use that index to evaluate the query requires an additional O(NlogN) time. In the absence of &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; information, SQLite guesses that N is one million and hence it believes that constructing the automatic index will be the cheaper approach.</source>
          <target state="translated">В приведенном выше запросе, если и t1, и t2 имеют приблизительно N строк, то без каких-либо индексов запрос потребует времени O (N * N). С другой стороны, создание индекса для таблицы t2 требует времени O (NlogN), а затем использование этого индекса для оценки запроса требует дополнительного времени O (NlogN). В отсутствие информации &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; SQLite предполагает, что N равно одному миллиону, и, следовательно, считает, что построение автоматического индекса будет более дешевым подходом.</target>
        </trans-unit>
        <trans-unit id="d42fa24dde8794f21d6a489ff49ead792c8bc812" translate="yes" xml:space="preserve">
          <source>In the query above, one would presumably bind the binary BLOB description of the precise boundary of the 12th district to the &quot;:boundary&quot; parameter.</source>
          <target state="translated">В вышеуказанном запросе предполагается связать двоичное BLOB-описание точной границы 12-ой округа с параметром &quot;:граница&quot;.</target>
        </trans-unit>
        <trans-unit id="5dbfd2d21d7bf5385c8b5fed28f3d0558f663390" translate="yes" xml:space="preserve">
          <source>In the query above, the &quot;PARTITION BY c&quot; clause breaks the result set up into three partitions. The first partition has three rows with c=='one'. The second partition has two rows with c=='three' and the third partition has two rows with c=='two'.</source>
          <target state="translated">В вышеприведенном запросе,пункт &quot;Участие в c&quot; разбивает результат,установленный на три простенка.Первый раздел имеет три строки с символом c=='one'.Второй простенок имеет две строки с c=='тремя',а третий простенок имеет две строки с c=='двумя'.</target>
        </trans-unit>
        <trans-unit id="ff23670a4dd151a2afe2511d238ffe5c9f59a6d2" translate="yes" xml:space="preserve">
          <source>In the query above, the &quot;a&quot; column is part of the GROUP BY clause and so each row of the output contains one of the distinct values for &quot;a&quot;. The &quot;c&quot; column is contained within the &lt;a href=&quot;lang_aggfunc#sumunc&quot;&gt;sum()&lt;/a&gt; aggregate function and so that output column is the sum of all &quot;c&quot; values in rows that have the same value for &quot;a&quot;. But what is the result of the bare column &quot;b&quot;? The answer is that the &quot;b&quot; result will be the value for &quot;b&quot; in one of the input rows that form the aggregate. The problem is that you usually do not know which input row is used to compute &quot;b&quot;, and so in many cases the value for &quot;b&quot; is undefined.</source>
          <target state="translated">В приведенном выше запросе столбец &amp;laquo;a&amp;raquo; является частью предложения GROUP BY, поэтому каждая строка вывода содержит одно из различных значений для &amp;laquo;a&amp;raquo;. Столбец &amp;laquo;c&amp;raquo; содержится в агрегатной функции &lt;a href=&quot;lang_aggfunc#sumunc&quot;&gt;sum (),&lt;/a&gt; поэтому выходной столбец представляет собой сумму всех значений &amp;laquo;c&amp;raquo; в строках, которые имеют одинаковое значение для &amp;laquo;a&amp;raquo;. Но каков результат голого столбца &amp;laquo;б&amp;raquo;? Ответ заключается в том, что результат &amp;laquo;b&amp;raquo; будет значением для &amp;laquo;b&amp;raquo; в одной из входных строк, образующих агрегат. Проблема в том, что вы обычно не знаете, какая входная строка используется для вычисления &amp;laquo;b&amp;raquo;, и поэтому во многих случаях значение &amp;laquo;b&amp;raquo; не определено.</target>
        </trans-unit>
        <trans-unit id="cd7c1539a48900d085cdab5fe3ab086624874b10" translate="yes" xml:space="preserve">
          <source>In the query above, the subquery &quot;SELECT b FROM ex2&quot; is evaluated and its results are stored in a temporary table (actually a temporary index) that allows one to determine whether or not a value ex2.b exists using a simple binary search. Once this table is constructed, the outer query is run and for each prospective result row a check is made to see if ex1.a is contained within the temporary table. The row is output only if the check is true.</source>
          <target state="translated">В вышеуказанном запросе вычисляется подзапрос &quot;SELECT b FROM ex2&quot;,результаты которого хранятся во временной таблице (фактически временном индексе),что позволяет определить,существует ли значение ex2.b с помощью простого двоичного поиска.После построения этой таблицы выполняется внешний запрос,и для каждой предполагаемой строки результата проверяется,содержится ли ex1.a во временной таблице.Строка выводится только в том случае,если проверка истинна.</target>
        </trans-unit>
        <trans-unit id="e4290c818e5599eff7616300b06206a049026a55" translate="yes" xml:space="preserve">
          <source>In the query above, the values for the first_name and last_name columns will correspond to the row that satisfied the max(salary) condition.</source>
          <target state="translated">В вышеуказанном запросе значения для столбцов first_name и last_name будут соответствовать строке,удовлетворяющей условию max(salary).</target>
        </trans-unit>
        <trans-unit id="812c0304c15e5adbac36486ee814e9ec1db44d78" translate="yes" xml:space="preserve">
          <source>In the revised query, the subquery implemented by a co-routine computes the five most recent values for &quot;a&quot;. Those five values are passed from the co-routine up into the outer query where the &quot;expensive_function()&quot; is invoked on only the specific rows that the application cares about.</source>
          <target state="translated">В пересмотренном запросе в подзапросе,реализованном с помощью ко-маршрута,вычисляются пять самых последних значений для &quot;a&quot;.Эти пять значений передаются из ко-маршрута во внешний запрос,где &quot;expensive_function()&quot; вызывается только на определенных строках,о которых заботится приложение.</target>
        </trans-unit>
        <trans-unit id="5464a60c31d2aba9c62ea2f61ec84b78e0768c87" translate="yes" xml:space="preserve">
          <source>In the second example, the expression in the DO UPDATE clause is of the form &quot;excluded.phonenumber&quot;. The &quot;excluded.&quot; prefix causes the &quot;phonenumber&quot; to refer to the value for phonenumber that would have been inserted had there been no conflict. Hence, the effect of the upsert is to insert a phonenumber of Alice if none exists, or to overwrite any prior phonenumber for Alice with the new one.</source>
          <target state="translated">Во втором примере выражение в пункте DO UPDATE имеет вид &quot;excluded.phonenumber&quot;.Префикс &quot;excluded.&quot; заставляет &quot;phonenumber&quot; ссылаться на значение для phonenumber,которое было бы вставлено,если бы не конфликт.Следовательно,эффект от выпадения заключается в том,чтобы вставить номер телефона Алисы,если таковой отсутствует,или переписать любой предыдущий номер телефона Алисы на новый.</target>
        </trans-unit>
        <trans-unit id="0d5709c51541d0085c2cbbc496ec178e66f3f72e" translate="yes" xml:space="preserve">
          <source>In the sequence on the left, the second insert will fail. In this case, the strings '0' and '0.0' are treated as numbers since they are being inserted into a numeric column but 0==0.0 which violates the uniqueness constraint. However, the second insert in the right-hand sequence works. In this case, the constants 0 and 0.0 are treated a strings which means that they are distinct.</source>
          <target state="translated">В последовательности слева вторая вставка будет неудачной.В этом случае строки '0' и '0.0' рассматриваются как числа,так как они вставляются в числовой столбец,но 0==0.0,что нарушает ограничение уникальности.Однако,вторая вставка в правой последовательности работает.В этом случае,константы 0 и 0.0 обрабатываются как строки,что означает,что они отличаются друг от друга.</target>
        </trans-unit>
        <trans-unit id="a547afdf67cd8d948e7c4160e0e5b6f6d4b49400" translate="yes" xml:space="preserve">
          <source>In the shell, &lt;b&gt;sqlite_interrupt()&lt;/b&gt; is invoked when the user presses Control-C</source>
          <target state="translated">В оболочке &lt;b&gt;sqlite_interrupt ()&lt;/b&gt; вызывается, когда пользователь нажимает Control-C</target>
        </trans-unit>
        <trans-unit id="8d983faa26111b1d1fcd83dfccc76792d6f87417" translate="yes" xml:space="preserve">
          <source>In the spellfix1 algorithm, cFrom is the text as the user entered it and cTo is the correctly spelled text as it exists in the database. The goal of the editdist3 algorithm is to determine how close the user-entered text is to the dictionary text.</source>
          <target state="translated">В алгоритме spellfix1 cFrom-это текст,как его ввел пользователь,а cTo-это правильно написанный текст,как он существует в базе данных.Цель алгоритма editdist3-определить,насколько близко пользовательский текст находится к тексту словаря.</target>
        </trans-unit>
        <trans-unit id="f33fd6db9521ba57d781c7a6cc1cb461b4a1e385" translate="yes" xml:space="preserve">
          <source>In the sqlite shell, now print the version number on initial startup.</source>
          <target state="translated">В оболочке sqlite теперь распечатайте номер версии при первом запуске.</target>
        </trans-unit>
        <trans-unit id="567ed9c7de12cfc6ba8542459479acb37712e779" translate="yes" xml:space="preserve">
          <source>In the sqlite shell, print the &quot;Database opened READ ONLY&quot; message to stderr instead of stdout.</source>
          <target state="translated">В sqlite оболочке вместо stdout выведите сообщение &quot;Database opened READ ONLY&quot; (&quot;База данных открыта ТОЛЬКО&quot;)в stderr.</target>
        </trans-unit>
        <trans-unit id="04b0bd3687019af0690c1810844c9c6e7505bacb" translate="yes" xml:space="preserve">
          <source>In the statement above, the FTS3 cursor pointer generated by the MATCH operator is send into the carray() table-valued function instead of its intended recipient snippet(). The carray() function treats the pointer as a pointer to an array of integers and returns each integer one by one, thus leaking the content of the FTS3 cursor object. Since the FTS3 cursor object contains pointers to other objects, the statement above would be a pointer leak.</source>
          <target state="translated">В приведенном выше утверждении указатель курсора FTS3,генерируемый оператором MATCH,посылается в функцию carray()table-valued вместо его предполагаемого получателя snippet().Функция carray()рассматривает указатель как указатель на массив целых чисел и возвращает каждое целое число по одному,тем самым пропуская содержимое объекта курсора FTS3.Поскольку объект курсора FTS3 содержит указатели на другие объекты,приведенное выше утверждение будет утечкой указателя.</target>
        </trans-unit>
        <trans-unit id="e5c24d1846d01f843a98c707910ed22a0e9486cc" translate="yes" xml:space="preserve">
          <source>In the templates above, NNN represents an integer literal, and VVV represents an alphanumeric identifier. The values of these parameters (also called &quot;host parameter names&quot; or &quot;SQL parameters&quot;) can be set using the sqlite3_bind_*() routines defined here.</source>
          <target state="translated">В приведенных выше шаблонах NNN представляет собой целое число букв,а VVV-буквенно-цифровой идентификатор.Значения этих параметров (также называемых &quot;имена параметров хоста&quot; или &quot;SQL-параметры&quot;)могут быть установлены с помощью определенных здесь процедур sqlite3_bind_*().</target>
        </trans-unit>
        <trans-unit id="dee8f982211055f9a9e8d1a438d7f794e0810555" translate="yes" xml:space="preserve">
          <source>In the underlying &lt;a href=&quot;fileformat2&quot;&gt;file format&lt;/a&gt;, each rowid is stored as a &lt;a href=&quot;fileformat2#varint&quot;&gt;variable-length integer&lt;/a&gt;. That means that small non-negative rowid values take up less disk space than large or negative rowid values.</source>
          <target state="translated">В базовом &lt;a href=&quot;fileformat2&quot;&gt;формате файла&lt;/a&gt; каждый rowid хранится как &lt;a href=&quot;fileformat2#varint&quot;&gt;целое число переменной длины&lt;/a&gt; . Это означает, что небольшие неотрицательные значения rowid занимают меньше места на диске, чем большие или отрицательные значения rowid.</target>
        </trans-unit>
        <trans-unit id="147d02b1e1e949a788ff444f3cb5e754276ba6d2" translate="yes" xml:space="preserve">
          <source>In this case the aConstraint[].op value is the same as the value returned by &lt;a href=&quot;vtab#xfindfunction&quot;&gt;xFindFunction()&lt;/a&gt; for FUNCTION.</source>
          <target state="translated">В этом случае значение aConstraint []. Op совпадает со значением, возвращаемым &lt;a href=&quot;vtab#xfindfunction&quot;&gt;xFindFunction ()&lt;/a&gt; для FUNCTION.</target>
        </trans-unit>
        <trans-unit id="b6bf8cbfac9c457904e9c2859da73ee4a95d3f0d" translate="yes" xml:space="preserve">
          <source>In this case using the temporary b-tree can be avoided by creating an index on t2(c), as follows:</source>
          <target state="translated">В этом случае использования временного b-дерева можно избежать,создав индекс на t2(c)следующим образом:</target>
        </trans-unit>
        <trans-unit id="a530fdc0efceb4d3e07dfc220358b90fa2145a02" translate="yes" xml:space="preserve">
          <source>In this case, SQLite still does a single binary search to find the first entry of the index where fruit='Orange'. Then it extracts the rowid from the index and uses that rowid to lookup the original table entry via binary search and output the price from the original table. But instead of quitting, the database engine then advances to the next row of index to repeat the process for next fruit='Orange' entry. Advancing to the next row of an index (or table) is much less costly than doing a binary search since the next row is often located on the same database page as the current row. In fact, the cost of advancing to the next row is so cheap in comparison to a binary search that we usually ignore it. So our estimate for the total cost of this query is 3 binary searches. If the number of rows of output is K and the number of rows in the table is N, then in general the cost of doing the query is proportional to (K+1)*logN.</source>
          <target state="translated">В этом случае SQLite все равно выполняет один двоичный поиск,чтобы найти первую запись индекса,где фрукт='Оранжевый'.Затем он извлекает строку из индекса и использует эту строку для поиска исходной записи таблицы с помощью бинарного поиска и вывода цены из исходной таблицы.Но вместо того,чтобы выйти,механизм базы данных затем переходит к следующей строке индекса,чтобы повторить процесс для следующего фрукта='Orange' запись.Переход к следующей строке индекса (или таблицы)намного дешевле,чем бинарный поиск,так как следующая строка часто располагается на той же странице базы данных,что и текущая строка.На самом деле,стоимость перехода к следующей строке настолько дешева по сравнению с бинарным поиском,что мы обычно игнорируем это.Таким образом,наша оценка общей стоимости этого запроса составляет 3 двоичных поиска.Если количество выводимых строк равно K,а количество строк в таблице N,то в общем случае стоимость выполнения запроса пропорциональна (K+1)*logN.</target>
        </trans-unit>
        <trans-unit id="419a046b4e9791c3dfbe6ecdc597fd0e975a6969" translate="yes" xml:space="preserve">
          <source>In this chart, an SQL statement (&quot;SELECT v FROM kv WHERE k=?1&quot;) is prepared once. Then for each blob, the blob key value is bound to the ?1 parameter and the statement is evaluated to extract the blob content.</source>
          <target state="translated">На этом графике один раз подготавливается SQL-оператор (&quot;SELECT v FROM kv WHERE k=?1&quot;).Затем для каждого блока значение ключа привязывается к параметру ?1 и оператор обрабатывается для извлечения содержимого блока.</target>
        </trans-unit>
        <trans-unit id="67f262080695617f0fd577e77df041ccaf828f11" translate="yes" xml:space="preserve">
          <source>In this example, the content of the docs.body field for the entry where docs.name is &quot;report-15&quot; will be sent to the editor. After the editor returns, the result will be written back into the docs.body field.</source>
          <target state="translated">В данном примере содержимое поля docs.body для записи,где docs.name-это &quot;report-15&quot;,будет отправлено в редактор.После возврата редактора результат будет записан обратно в поле docs.body.</target>
        </trans-unit>
        <trans-unit id="3455933a8fde6f3fc95c8e0f500aee581e4e0da2" translate="yes" xml:space="preserve">
          <source>In this example, the demo_data.boundary field is intended to hold some kind of binary representation of the precise boundaries of the object. The R*Tree index only holds an axis-aligned rectangular boundary for the object. The R*Tree boundary is just an approximation of the true object boundary. So what typically happens is that the R*Tree index is used to narrow a search down to a list of candidate objects and then more detailed and expensive computations are done on each candidate to find if the candidate truly meets the search criteria.</source>
          <target state="translated">В данном примере поле demo_data.boundary предназначено для проведения некоего двоичного представления точных границ объекта.Индекс R*Tree содержит только выровненную по оси прямоугольную границу объекта.Граница R*Tree является лишь аппроксимацией истинной границы объекта.Так что обычно происходит,что индекс R*Tree используется для сужения поиска до списка объектов-кандидатов,а затем проводятся более детальные и дорогие вычисления по каждому кандидату,чтобы найти,действительно ли кандидат соответствует критериям поиска.</target>
        </trans-unit>
        <trans-unit id="0eba84e3861d469d7f133f2d07dd6079cc3e76b6" translate="yes" xml:space="preserve">
          <source>In this example, the rowids are not consecutive but they are ordered. SQLite usually creates rowids beginning with one and increasing by one with each added row. But if rows are deleted, gaps can appear in the sequence. And the application can control the rowid assigned if desired, so that rows are not necessarily inserted at the bottom. But regardless of what happens, the rowids are always unique and in strictly ascending order.</source>
          <target state="translated">В данном примере рядовые не являются последовательными,а упорядочены.SQLite обычно создает рядки,начинающиеся с одного и увеличивающиеся на один с каждой добавленной строкой.Но если строки удаляются,то в последовательности могут появляться пробелы.При желании приложение может управлять назначенными rowid'ами,чтобы строки не обязательно вставлялись внизу.Но независимо от того,что происходит,ряды всегда уникальны и находятся в строго возрастающем порядке.</target>
        </trans-unit>
        <trans-unit id="5350836f804099dba5657839c67d9e6572dea27d" translate="yes" xml:space="preserve">
          <source>In this example, the t2 table is used in a subquery to translate values of the t1.b column. If each table contains N rows, SQLite expects that the subquery will run N times, and hence it will believe it is faster to construct an automatic, transient index on t2 first and then use that index to satisfy the N instances of the subquery.</source>
          <target state="translated">В данном примере таблица t2 используется в подзапросе для перевода значений столбца t1.b.Если каждая таблица содержит N строк,SQLite ожидает,что подзапрос будет выполняться N раз,и поэтому он поверит,что быстрее построить сначала автоматический переходный индекс по t2,а затем использовать этот индекс для удовлетворения N экземпляров подзапроса.</target>
        </trans-unit>
        <trans-unit id="c42a9794244d33827402d87bbb30dbcaf8693beb" translate="yes" xml:space="preserve">
          <source>In this last example, the phonebook2 entry is only updated if the validDate for the newly inserted value is newer than the entry already in the table. If the table already contains an entry with the same name and a current validDate, then the WHERE clause causes the DO UPDATE to become a no-op.</source>
          <target state="translated">В этом последнем примере запись в телефонной книге2 обновляется только в том случае,если validDate для только что вставленного значения будет более новой,чем запись,уже содержащаяся в таблице.Если таблица уже содержит запись с таким же именем и текущей датой validDate,то пункт WHERE приводит к тому,что DO UPDATE становится недействительной.</target>
        </trans-unit>
        <trans-unit id="25dff0fca0922d5e6626c7a322eba86698c2596d" translate="yes" xml:space="preserve">
          <source>In this latter table, there is only a single B-Tree which uses the &quot;word&quot; column as its key and the &quot;cnt&quot; column as its data. (Technicality: the low-level implementation actually stores both &quot;word&quot; and &quot;cnt&quot; in the &quot;key&quot; area of the B-Tree. But unless you are looking at the low-level byte encoding of the database file, that fact is unimportant.) Because there is only a single B-Tree, the text of the &quot;word&quot; column is only stored once in the database. Furthermore, querying the &quot;cnt&quot; value for a specific &quot;word&quot; only involves a single binary search into the main B-Tree, since the &quot;cnt&quot; value can be retrieved directly from the record found by that first search and without the need to do a second binary search on the rowid.</source>
          <target state="translated">В этой последней таблице есть только одно B-дерево,в котором в качестве ключа используется столбец &quot;слово&quot;,а в качестве данных-столбец &quot;cnt&quot;.(Техническая сторона:низкоуровневая реализация фактически хранит и &quot;слово&quot;,и &quot;cnt&quot; в области &quot;ключ&quot; B-дерева.Но если не смотреть на низкоуровневую байтовую кодировку файла БД,то этот факт не имеет значения).Поскольку существует только одно B-дерево,текст столбца &quot;word&quot; в БД хранится только один раз.Кроме того,запрос значения &quot;cnt&quot; для конкретного &quot;слова&quot; предполагает только один двоичный поиск в основном B-дереве,так как значение &quot;cnt&quot; может быть извлечено непосредственно из найденной при этом первом поиске записи и без необходимости выполнять второй двоичный поиск в рядке.</target>
        </trans-unit>
        <trans-unit id="27f1607d8d73cecfa7aadf0af1217d0ee5b1b3de" translate="yes" xml:space="preserve">
          <source>In this query, the &quot;xaxis&quot; and &quot;yaxis&quot; CTEs define the grid of points for which the Mandelbrot Set will be approximated. Each row in the &quot;m(iter,cx,cy,x,y)&quot; CTE means that after &quot;iter&quot; iterations, the Mandelbrot iteration starting at cx,cy has reached point x,y. The number of iterations in this example is limited to 28 (which severely limits the resolution of the computation, but is sufficient for low-resolution ASCII-art output). The &quot;m2(iter,cx,cy)&quot; CTE holds the maximum number of iterations reached when starting at point cx,cy. Finally, each row in the &quot;a(t)&quot; CTE holds a string which is a single line of the output ASCII-art. The SELECT statement at the end just queries the &quot;a&quot; CTE to retrieve all lines of ASCII-art, one by one.</source>
          <target state="translated">В данном запросе CTE &quot;xaxis&quot; и &quot;yaxis&quot; определяют сетку точек,для которых будет аппроксимирована группа Мандельброта.Каждая строка в &quot;m(iter,cx,cy,x,y)&quot; CTE означает,что после &quot;итерационных&quot; итераций,итерация Мандельброта,начинающаяся с cx,cy достигла точки x,y.Количество итераций в данном примере ограничено 28 (что существенно ограничивает разрешение расчета,но достаточно для вывода ASCII-art низкого разрешения).ЭОП &quot;m2(iter,cx,cy)&quot; удерживает максимальное количество итераций,достигнутое при старте в точке cx,cy.Наконец,каждая строка в &quot;a(t)&quot; CTE содержит строку,которая является единственной строкой выходного ASCII-art.Оператор SELECT в конце просто запрашивает &quot;a&quot; CTE,чтобы получить все строки ASCII-art,одну за другой.</target>
        </trans-unit>
        <trans-unit id="e3c6ef43db25cfa53ed4da6f4cdaac9eb93f9ff7" translate="yes" xml:space="preserve">
          <source>In this schema, instead of each slide having a page number that determines its order within the presentation, each slide has a unique integer identifier that is unrelated to where it occurs in sequence. The order of slides in the presentation is determined by a list of slideIds, stored as a text string in the MANIFEST column of the VERSION table. Since multiple entries are allowed in the VERSION table, that means that multiple presentations can be stored in the same document.</source>
          <target state="translated">В этой схеме вместо того,чтобы каждый слайд имел номер страницы,определяющий его порядок в представлении,каждый слайд имеет уникальный целочисленный идентификатор,не связанный с тем,где он происходит последовательно.Порядок слайдов в представлении определяется списком слайдов,хранящихся в виде текстовой строки в колонке MANIFEST таблицы VERSION.Поскольку в таблице VERSION разрешено несколько записей,это означает,что в одном и том же документе можно хранить несколько презентаций.</target>
        </trans-unit>
        <trans-unit id="0941893928b48e6ed8f71fafe5691ea7ff76077a" translate="yes" xml:space="preserve">
          <source>In this system, each entry in the song table is required to map to an entry in the album table with the same combination of artist and album.</source>
          <target state="translated">В этой системе каждая запись в таблице композиций должна быть сопоставлена с записью в таблице альбомов с той же комбинацией исполнителя и альбома.</target>
        </trans-unit>
        <trans-unit id="e2304a60e4555367ae83803d8a81dcbbc6bac3fc" translate="yes" xml:space="preserve">
          <source>In this way the new pointer-passing interface seems to solve all of the security problems associated with passing pointer values from one extension to another in SQLite.</source>
          <target state="translated">Таким образом,новый интерфейс обхода указателей,кажется,решает все проблемы безопасности,связанные с передачей значений указателей из одного расширения в другое в SQLite.</target>
        </trans-unit>
        <trans-unit id="5b4cc2bd1f16fd79626e9a2d355ec8140a8334dd" translate="yes" xml:space="preserve">
          <source>In those routines that have a fourth argument, its value is the number of bytes in the parameter. To be clear: the value is the number of &lt;u&gt;bytes&lt;/u&gt; in the value, not the number of characters. If the fourth parameter to sqlite3_bind_text() or sqlite3_bind_text16() is negative, then the length of the string is the number of bytes up to the first zero terminator. If the fourth parameter to sqlite3_bind_blob() is negative, then the behavior is undefined. If a non-negative fourth parameter is provided to sqlite3_bind_text() or sqlite3_bind_text16() or sqlite3_bind_text64() then that parameter must be the byte offset where the NUL terminator would occur assuming the string were NUL terminated. If any NUL characters occur at byte offsets less than the value of the fourth parameter then the resulting string value will contain embedded NULs. The result of expressions involving strings with embedded NULs is undefined.</source>
          <target state="translated">В тех подпрограммах, у которых есть четвертый аргумент, его значением является количество байтов в параметре. Для ясности: значение - это количество &lt;u&gt;байтов&lt;/u&gt;в значении, а не в количестве символов. Если четвертый параметр sqlite3_bind_text () или sqlite3_bind_text16 () отрицательный, то длина строки равна количеству байтов до первого нулевого ограничителя. Если четвертый параметр sqlite3_bind_blob () отрицательный, поведение не определено. Если неотрицательный четвертый параметр предоставлен sqlite3_bind_text (), sqlite3_bind_text16 () или sqlite3_bind_text64 (), тогда этот параметр должен быть байтовым смещением, в котором будет стоять символ конца NUL, если строка завершается NUL. Если какие-либо символы NUL встречаются при смещении байтов меньше значения четвертого параметра, тогда результирующее строковое значение будет содержать встроенные NUL. Результат выражений, содержащих строки со встроенными NUL, не определен.</target>
        </trans-unit>
        <trans-unit id="f5c0b6c1ce652bbe2a9ce301182f0e17dcf5f222" translate="yes" xml:space="preserve">
          <source>In those routines that have a fourth argument, its value is the number of bytes in the parameter. To be clear: the value is the number of &lt;u&gt;bytes&lt;/u&gt; in the value, not the number of characters. If the fourth parameter to sqlite3_bind_text() or sqlite3_bind_text16() is negative, then the length of the string is the number of bytes up to the first zero terminator. If the fourth parameter to sqlite3_bind_blob() is negative, then the behavior is undefined. If a non-negative fourth parameter is provided to sqlite3_bind_text() or sqlite3_bind_text16() or sqlite3_bind_text64() then that parameter must be the byte offset where the NUL terminator would occur assuming the string were NUL terminated. If any NUL characters occurs at byte offsets less than the value of the fourth parameter then the resulting string value will contain embedded NULs. The result of expressions involving strings with embedded NULs is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5828032be03f722c81b6852fba96bca0f86ff7f" translate="yes" xml:space="preserve">
          <source>In truncate journal mode, the transaction is committed by truncating the journal file to zero length rather than deleting the journal file (as in DELETE mode) or by zeroing the header (as in PERSIST mode). TRUNCATE mode shares the advantage of PERSIST mode that the directory that contains the journal file and database does not need to be updated. Hence truncating a file is often faster than deleting it. TRUNCATE has the additional advantage that it is not followed by a system call (ex: fsync()) to synchronize the change to disk. It might be safer if it did. But on many modern filesystems, a truncate is an atomic and synchronous operation and so we think that TRUNCATE will usually be safe in the face of power failures. If you are uncertain about whether or not TRUNCATE will be synchronous and atomic on your filesystem and it is important to you that your database survive a power loss or operating system crash that occurs during the truncation operation, then you might consider using a different journaling mode.</source>
          <target state="translated">В режиме усеченного журнала транзакция фиксируется путем усечения файла журнала на нулевую длину вместо удаления файла журнала (как в режиме DELETE)или путем обнуления заголовка (как в режиме PERSIST).Режим TRUNCATE имеет то преимущество режима PERSIST,что каталог,содержащий файл журнала и базу данных,не нуждается в обновлении.Поэтому усечение файла зачастую происходит быстрее,чем его удаление.Дополнительным преимуществом режима TRUNCATE является то,что за ним не следует системный вызов (например:fsync())для синхронизации изменения на диск.Это может быть безопаснее.Но на многих современных файловых системах усечение является атомарной и синхронной операцией,поэтому мы считаем,что TRUNCATE обычно будет безопасен при отключении питания.Если вы не уверены в том,будет ли TRUNCATE синхронным и атомарным в вашей файловой системе,и для вас важно,чтобы ваша база данных пережила потерю питания или сбой операционной системы,который происходит во время усечения,то вы можете подумать об использовании другого режима протоколирования.</target>
        </trans-unit>
        <trans-unit id="0ad1bfd687f56543c8ea5ff79723971d89b554aa" translate="yes" xml:space="preserve">
          <source>In version 3.5.9 the query above would return a single column named &quot;t1.a&quot;. In version 3.6.0 the column name is just &quot;a&quot;.</source>
          <target state="translated">В версии 3.5.9 вышеприведенный запрос возвращал бы один столбец под названием &quot;t1.a&quot;.В версии 3.6.0 название столбца просто &quot;a&quot;.</target>
        </trans-unit>
        <trans-unit id="b38dc06ca0b3ec94d37d385f6a25506410f69b7f" translate="yes" xml:space="preserve">
          <source>In very old versions of SQLite (before version 3.7.11 - 2012-03-20) the ROLLBACK will fail with an error code &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; if there are any pending queries. In more recent versions of SQLite, the ROLLBACK will proceed and pending statements will often be aborted, causing them to return an &lt;a href=&quot;rescode#abort&quot;&gt;SQLITE_ABORT&lt;/a&gt; or &lt;a href=&quot;rescode#abort_rollback&quot;&gt;SQLITE_ABORT_ROLLBACK&lt;/a&gt; error. In SQLite version 3.8.8 (2015-01-16) and later, a pending read will continue functioning after the ROLLBACK as long as the ROLLBACK does not modify the database schema.</source>
          <target state="translated">В очень старых версиях SQLite (до версии 3.7.11 - 2012-03-20) ROLLBACK завершится ошибкой с кодом &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY,&lt;/a&gt; если есть какие-либо ожидающие запросы. В более поздних версиях SQLite ROLLBACK будет продолжаться, и отложенные операторы часто прерываются, в результате чего они возвращают &lt;a href=&quot;rescode#abort&quot;&gt;ошибку SQLITE_ABORT&lt;/a&gt; или &lt;a href=&quot;rescode#abort_rollback&quot;&gt;SQLITE_ABORT_ROLLBACK&lt;/a&gt; . В SQLite версии 3.8.8 (2015-01-16) и более поздних версий ожидающее чтение будет продолжать функционировать после ROLLBACK, пока ROLLBACK не изменяет схему базы данных.</target>
        </trans-unit>
        <trans-unit id="b499aec31026161ef5b7e71ea3cf99793674a2a9" translate="yes" xml:space="preserve">
          <source>In words, we have a database table named &quot;examp&quot; that has two columns of data named &quot;one&quot; and &quot;two&quot;. Now suppose we want to insert a single record into this table. Like this:</source>
          <target state="translated">Иными словами,у нас есть таблица базы данных под названием &quot;экзамен&quot;,которая имеет две колонки данных под названием &quot;один&quot; и &quot;два&quot;.Теперь предположим,что мы хотим вставить в эту таблицу одну запись.Вот так:</target>
        </trans-unit>
        <trans-unit id="538f80f611dd84d930a92b9f7317e8773bd20fa3" translate="yes" xml:space="preserve">
          <source>In-Memory Databases</source>
          <target state="translated">Базы данных In-Memory</target>
        </trans-unit>
        <trans-unit id="d29dcc989f8aeac43865c646816b27c0bf5d86c1" translate="yes" xml:space="preserve">
          <source>In-memory Databases And Shared Cache</source>
          <target state="translated">Базы данных In-memory и общий кэш.</target>
        </trans-unit>
        <trans-unit id="f87e1ebcfb907fda4b66420b21bcba1a298d5d80" translate="yes" xml:space="preserve">
          <source>In-memory databases are allowed to use &lt;a href=&quot;sharedcache&quot;&gt;shared cache&lt;/a&gt; if they are opened using a &lt;a href=&quot;uri&quot;&gt;URI filename&lt;/a&gt;. If the unadorned &quot;:memory:&quot; name is used to specify the in-memory database, then that database always has a private cache and is this only visible to the database connection that originally opened it. However, the same in-memory database can be opened by two or more database connections as follows:</source>
          <target state="translated">Базы данных в памяти могут использовать &lt;a href=&quot;sharedcache&quot;&gt;общий кеш,&lt;/a&gt; если они открываются с использованием &lt;a href=&quot;uri&quot;&gt;имени файла URI&lt;/a&gt; . Если для указания базы данных в памяти используется неукрашенное имя &amp;laquo;: memory:&amp;raquo;, то эта база данных всегда имеет частный кеш, и он виден только тому соединению с базой данных, которое первоначально открыло ее. Однако одна и та же база данных в памяти может быть открыта двумя или более подключениями к базе данных следующим образом:</target>
        </trans-unit>
        <trans-unit id="4e5ba204b0641a7420c326e6c9ccf4a171f01a91" translate="yes" xml:space="preserve">
          <source>Include a digit somewhere in every identifier name.</source>
          <target state="translated">Включите цифру где-нибудь в имя каждого идентификатора.</target>
        </trans-unit>
        <trans-unit id="609cf98670fbb073608f2b25b70dd7c1c13a30bc" translate="yes" xml:space="preserve">
          <source>Include a static string in the library that responds to the RCS &quot;ident&quot; command and which contains the library version number.</source>
          <target state="translated">Включить в библиотеку статическую строку,которая отвечает на команду RCS &quot;ident&quot; и содержит номер версии библиотеки.</target>
        </trans-unit>
        <trans-unit id="c0417d1d2b8071cc5718dd6c321dee3ddd0e2b30" translate="yes" xml:space="preserve">
          <source>Incompatible changes are covered first since they are the most important to maintainers and programmers.</source>
          <target state="translated">Несовместимые изменения освещаются в первую очередь,так как они наиболее важны для сопровождающих и программистов.</target>
        </trans-unit>
        <trans-unit id="bc118ee16ef865aed415e5f3a8d6022aa76b72dd" translate="yes" xml:space="preserve">
          <source>Inconsistent result set column names between CREATE TABLE AS and a simple SELECT. Ticket &lt;a href=&quot;https://sqlite.org/src/info/3b4450072511e621&quot;&gt;3b4450072511e621&lt;/a&gt;</source>
          <target state="translated">Несогласованные имена столбцов набора результатов между CREATE TABLE AS и простым SELECT. Билет &lt;a href=&quot;https://sqlite.org/src/info/3b4450072511e621&quot;&gt;3b4450072511e621&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b7579773ac4d764f11e434b97ff14dade4554c12" translate="yes" xml:space="preserve">
          <source>Incorporate makefile patches form A. Rottmann to use LIBTOOL</source>
          <target state="translated">Включить makefile патчи от A.Rottmann для использования LIBTOOL</target>
        </trans-unit>
        <trans-unit id="78318ed3e6ca4f2006eecd671fb4e1b78bbf85cb" translate="yes" xml:space="preserve">
          <source>Incorrect</source>
          <target state="translated">Incorrect</target>
        </trans-unit>
        <trans-unit id="f074a009d21038c67513df8d49c6353ecce4802a" translate="yes" xml:space="preserve">
          <source>Incorrect assert() statement removed. Check-in &lt;a href=&quot;https://www.sqlite.org/src/info/823779d31eb09cda&quot;&gt;823779d31eb09cda&lt;/a&gt;.</source>
          <target state="translated">Удален неверный оператор assert (). Заезд &lt;a href=&quot;https://www.sqlite.org/src/info/823779d31eb09cda&quot;&gt;823779d31eb09cda&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="86f64d7d599af33f2e2d357b68bfbc2590e32e39" translate="yes" xml:space="preserve">
          <source>Incorrect column datatype reported. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/a8a0d2996a&quot;&gt;a8a0d2996a&lt;/a&gt;</source>
          <target state="translated">Сообщается о неверном типе данных столбца. Билет &lt;a href=&quot;http://www.sqlite.org/src/info/a8a0d2996a&quot;&gt;a8a0d2996a&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5010ff6ebfa98793b55410eccec7fb293111ca61" translate="yes" xml:space="preserve">
          <source>Incorrect query results on a join with a ORDER BY DESC. Ticket &lt;a href=&quot;https://sqlite.org/src/info/123c9ba32130a6c9&quot;&gt;123c9ba32130a6c9&lt;/a&gt;.</source>
          <target state="translated">Неверные результаты запроса при объединении с ORDER BY DESC. Билет &lt;a href=&quot;https://sqlite.org/src/info/123c9ba32130a6c9&quot;&gt;123c9ba32130a6c9&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d72bf52d94d169fcce6582014fa4914c962c4cbe" translate="yes" xml:space="preserve">
          <source>Incorrect query results when the skip-ahead-distinct optimization is used. Ticket &lt;a href=&quot;https://sqlite.org/src/info/ef9318757b152e3a&quot;&gt;ef9318757b152e3a&lt;/a&gt;.</source>
          <target state="translated">Неправильные результаты запроса при использовании оптимизации с пропуском вперед. Билет &lt;a href=&quot;https://sqlite.org/src/info/ef9318757b152e3a&quot;&gt;ef9318757b152e3a&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3b88b306633c693ef74330d871a60d1a4c0698aa" translate="yes" xml:space="preserve">
          <source>Incorrect result on the less-than operator in &lt;a href=&quot;rowvalue&quot;&gt;row values&lt;/a&gt;. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/f484b65f3d62305&quot;&gt;f484b65f3d62305&lt;/a&gt;</source>
          <target state="translated">Неправильный результат для оператора &amp;laquo;меньше&amp;raquo; в &lt;a href=&quot;rowvalue&quot;&gt;значениях строк&lt;/a&gt; . Билет &lt;a href=&quot;https://www.sqlite.org/src/info/f484b65f3d62305&quot;&gt;f484b65f3d62305&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="353e2ea7a72adf3f039c8f1d29d7d6a2765ce415" translate="yes" xml:space="preserve">
          <source>IncrVacuum</source>
          <target state="translated">IncrVacuum</target>
        </trans-unit>
        <trans-unit id="bfb28e75251bc4d83a52b5697560b9c1115b80bf" translate="yes" xml:space="preserve">
          <source>Increase the &lt;a href=&quot;limits#max_variable_number&quot;&gt;default upper bound&lt;/a&gt; on the number of &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameters&lt;/a&gt; from 999 to 32766.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21ef0be270a54a1cdd6fa173d6d67cc79394e640" translate="yes" xml:space="preserve">
          <source>Increase the default &lt;a href=&quot;malloc#lookaside&quot;&gt;lookaside memory allocator&lt;/a&gt; allocation size from 100 to 128 bytes.</source>
          <target state="translated">Увеличьте размер выделения &lt;a href=&quot;malloc#lookaside&quot;&gt;резервной памяти&lt;/a&gt; по умолчанию со 100 до 128 байт.</target>
        </trans-unit>
        <trans-unit id="40e4fa7cf5d195215158819dc861b48ed9ae1b97" translate="yes" xml:space="preserve">
          <source>Increase the default &lt;a href=&quot;malloc#lookaside&quot;&gt;lookaside&lt;/a&gt; size from 512,125 to 1200,100 as this provides better performance while only adding 56KB of extra memory per connection. Memory-sensitive applications can restore the old default at compile-time, start-time, or run-time.</source>
          <target state="translated">Увеличьте &lt;a href=&quot;malloc#lookaside&quot;&gt;внешний&lt;/a&gt; размер по умолчанию с 512,125 до 1200,100, поскольку это обеспечивает лучшую производительность при добавлении только 56 КБ дополнительной памяти на каждое соединение. Приложения, чувствительные к памяти, могут восстанавливать старые значения по умолчанию во время компиляции, запуска или выполнения.</target>
        </trans-unit>
        <trans-unit id="0e1c35718b4f025f2f5dcc35d709e6b06c180f12" translate="yes" xml:space="preserve">
          <source>Increase the default size of a lookahead cache line from 100 to 128 bytes.</source>
          <target state="translated">Увеличить размер кэш-строки lookahead по умолчанию со 100 до 128 байт.</target>
        </trans-unit>
        <trans-unit id="7da2a83b3ac0a9788385c812ce2d8ccd3f55fd86" translate="yes" xml:space="preserve">
          <source>Increase the default value of &lt;a href=&quot;compile#max_schema_retry&quot;&gt;SQLITE_MAX_SCHEMA_RETRY&lt;/a&gt; to 50 and make sure that it is honored in every place that a schema change might force a statement retry.</source>
          <target state="translated">Увеличьте значение &lt;a href=&quot;compile#max_schema_retry&quot;&gt;SQLITE_MAX_SCHEMA_RETRY&lt;/a&gt; по умолчанию до 50 и убедитесь, что оно соблюдается в каждом месте, где изменение схемы может вызвать повторную попытку оператора.</target>
        </trans-unit>
        <trans-unit id="8609e4a99103452adeaaadda83f7438f10dd550a" translate="yes" xml:space="preserve">
          <source>Increase the maximum &quot;scope&quot; value for the &lt;a href=&quot;spellfix1&quot;&gt;spellfix1&lt;/a&gt; extension from 6 to 30.</source>
          <target state="translated">Увеличьте максимальное значение &quot;scope&quot; для расширения &lt;a href=&quot;spellfix1&quot;&gt;spellfix1&lt;/a&gt; с 6 до 30.</target>
        </trans-unit>
        <trans-unit id="c2f2fd643cba996348fe945409caf6a8045d3c9f" translate="yes" xml:space="preserve">
          <source>Increase the maximum size of a database pages from 32KiB to 64KiB.</source>
          <target state="translated">Увеличить максимальный размер страниц базы данных с 32КиБ до 64КиБ.</target>
        </trans-unit>
        <trans-unit id="c023946d393ce520944a7e8848356e945bf33b16" translate="yes" xml:space="preserve">
          <source>Increase the maximum size of database files to 281 TB.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45c470cb2d5edd4a76a24043774f958df34166de" translate="yes" xml:space="preserve">
          <source>Increase the maximum value of &lt;a href=&quot;limits#max_attached&quot;&gt;SQLITE_MAX_ATTACHED&lt;/a&gt; from 30 to 62 (though the default value remains at 10).</source>
          <target state="translated">Увеличьте максимальное значение &lt;a href=&quot;limits#max_attached&quot;&gt;SQLITE_MAX_ATTACHED&lt;/a&gt; с 30 до 62 (хотя значение по умолчанию остается равным 10).</target>
        </trans-unit>
        <trans-unit id="bb8cf068d7b2280526a2d202959cea91dd49770d" translate="yes" xml:space="preserve">
          <source>Increase the maximum value of &lt;a href=&quot;limits#max_attached&quot;&gt;SQLITE_MAX_ATTACHED&lt;/a&gt; from 62 to 125.</source>
          <target state="translated">Увеличьте максимальное значение &lt;a href=&quot;limits#max_attached&quot;&gt;SQLITE_MAX_ATTACHED&lt;/a&gt; с 62 до 125.</target>
        </trans-unit>
        <trans-unit id="69df92b5969bbc35734aa6107d3290339d53b888" translate="yes" xml:space="preserve">
          <source>Increase the timeout in &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt; before issuing an &lt;a href=&quot;rescode#protocol&quot;&gt;SQLITE_PROTOCOL&lt;/a&gt; error from 1 second to 10 seconds.</source>
          <target state="translated">Увеличьте время ожидания в &lt;a href=&quot;wal&quot;&gt;режиме WAL&lt;/a&gt; перед выдачей ошибки &lt;a href=&quot;rescode#protocol&quot;&gt;SQLITE_PROTOCOL&lt;/a&gt; с 1 до 10 секунд.</target>
        </trans-unit>
        <trans-unit id="9f009e1e744f83083af0b2cc7e6b2078c78f112f" translate="yes" xml:space="preserve">
          <source>Increased robustness against malicious SQL that is run against a maliciously corrupted database.</source>
          <target state="translated">Повышенная устойчивость к вредоносному SQL,который запускается против вредоносной базы данных.</target>
        </trans-unit>
        <trans-unit id="6b178246a9f68a2d5235ede0c3d198671a18c66b" translate="yes" xml:space="preserve">
          <source>Increased the version number on the &lt;a href=&quot;c3ref/vfs&quot;&gt;VFS object&lt;/a&gt; to 3 and added new methods xSetSysCall, xGetSysCall, and xNextSysCall used for doing full-coverage testing.</source>
          <target state="translated">Увеличен номер версии &lt;a href=&quot;c3ref/vfs&quot;&gt;объекта VFS&lt;/a&gt; до 3 и добавлены новые методы xSetSysCall, xGetSysCall и xNextSysCall, используемые для выполнения тестирования с полным покрытием.</target>
        </trans-unit>
        <trans-unit id="5b01748d80c9a44e0b5e68cd44f76d6fdcd5fbdb" translate="yes" xml:space="preserve">
          <source>Increment a &quot;constraint counter&quot; by P2 (P2 may be negative or positive). If P1 is non-zero, the database constraint counter is incremented (deferred foreign key constraints). Otherwise, if P1 is zero, the statement counter is incremented (immediate foreign key constraints).</source>
          <target state="translated">Увеличьте &quot;счетчик ограничений&quot; на P2 (P2 может быть отрицательным или положительным).Если P1 ненулевой,то увеличивается счетчик ограничений по базе данных (отложенные ограничения по внешнему ключу).В противном случае,если P1 равен нулю,счетчик операций инкрементируется (отложенные ограничения по внешнему ключу).</target>
        </trans-unit>
        <trans-unit id="9728ef186d1aa3193e57c71ddbd9cc22dfa95396" translate="yes" xml:space="preserve">
          <source>Increment the schema version number using &lt;a href=&quot;pragma#pragma_schema_version&quot;&gt;PRAGMA schema_version=X&lt;/a&gt; where X is one more than the old schema version number found in step 2 above.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_schema_version&quot;&gt;Увеличьте&lt;/a&gt; номер версии схемы, используя PRAGMA schema_version = X, где X на единицу больше, чем номер версии старой схемы, найденный на шаге 2 выше.</target>
        </trans-unit>
        <trans-unit id="8144fd658d7904e59a32604de5f5f1ca74f2f2ee" translate="yes" xml:space="preserve">
          <source>Increment the value of P1 so that &lt;a href=&quot;opcode#Once&quot;&gt;Once&lt;/a&gt; opcodes will jump the first time they are evaluated for this run.</source>
          <target state="translated">Увеличьте значение P1, чтобы коды операций &lt;a href=&quot;opcode#Once&quot;&gt;Once&lt;/a&gt; перескакивали в первый раз, когда они оцениваются для этого прогона.</target>
        </trans-unit>
        <trans-unit id="99958674e5ab051f627364f0e7aec7700da2c443" translate="yes" xml:space="preserve">
          <source>Incremental And Continuous Updates</source>
          <target state="translated">Инкрементальное и непрерывное обновление</target>
        </trans-unit>
        <trans-unit id="c978bfe7fe02498da062fb7e2f5271fe832940ed" translate="yes" xml:space="preserve">
          <source>Index B-Tree Interior Cell (header 0x02):</source>
          <target state="translated">Внутренняя ячейка Индекс B-Дерево (заголовок 0x02):</target>
        </trans-unit>
        <trans-unit id="4e71969581a513a52c19a67df3b923e84e3cb4d7" translate="yes" xml:space="preserve">
          <source>Index B-Tree Leaf Cell (header 0x0a):</source>
          <target state="translated">Клетка листьев дерева Индекс Б (заголовок 0x0a):</target>
        </trans-unit>
        <trans-unit id="6834f50285e5eaa6aab20cfc4003ad141369bccf" translate="yes" xml:space="preserve">
          <source>Index B-Tree Leaf Or Interior Cell:</source>
          <target state="translated">Индекс Б-Древесный лист или внутренняя клетка:</target>
        </trans-unit>
        <trans-unit id="d05474cb52cfb6c27f6a9c375d177e07d462e5e6" translate="yes" xml:space="preserve">
          <source>Index Interior (0x02)</source>
          <target state="translated">Индекс интерьера (0x02)</target>
        </trans-unit>
        <trans-unit id="f35ac0d24fd01ec25554f05ecc89c727c71a1e04" translate="yes" xml:space="preserve">
          <source>Index Leaf (0x0a)</source>
          <target state="translated">Индексный лист (0x0a)</target>
        </trans-unit>
        <trans-unit id="96c319248a56deb59ef179cae4ae3f7a3c92eca2" translate="yes" xml:space="preserve">
          <source>Index Of A Parameter With A Given Name</source>
          <target state="translated">Индекс параметра с заданным именем</target>
        </trans-unit>
        <trans-unit id="239b13bdf631a9f83fa9a8a3d5c3895198fcc15a" translate="yes" xml:space="preserve">
          <source>Indexes On Expressions</source>
          <target state="translated">Индексы на выражениях</target>
        </trans-unit>
        <trans-unit id="f48dd71980245b4a0803daa066444bcb1b77f26c" translate="yes" xml:space="preserve">
          <source>Indexes are removed with the &lt;a href=&quot;lang_dropindex&quot;&gt;DROP INDEX&lt;/a&gt; command.</source>
          <target state="translated">Индексы удаляются командой &lt;a href=&quot;lang_dropindex&quot;&gt;DROP INDEX&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="535c9c6ad77a4b24ea3df3e8a1b9f2c196027e6c" translate="yes" xml:space="preserve">
          <source>Indexes can use &lt;a href=&quot;lang_createindex#descidx&quot;&gt;DESC&lt;/a&gt; and &lt;a href=&quot;lang_createindex#collidx&quot;&gt;COLLATE&lt;/a&gt;</source>
          <target state="translated">Индексы могут использовать &lt;a href=&quot;lang_createindex#descidx&quot;&gt;DESC&lt;/a&gt; и &lt;a href=&quot;lang_createindex#collidx&quot;&gt;COLLATE&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5826c397297007e146b25d7bb80a3a9d200a4f00" translate="yes" xml:space="preserve">
          <source>Indices are not required for child key columns but they are almost always beneficial. Returning to the example in &lt;a href=&quot;#fk_basics&quot;&gt;section 1&lt;/a&gt;, each time an application deletes a row from the</source>
          <target state="translated">Для столбцов дочерних ключей индексы не требуются, но они почти всегда полезны. Возвращаясь к примеру в &lt;a href=&quot;#fk_basics&quot;&gt;разделе 1&lt;/a&gt; , каждый раз, когда приложение удаляет строку из</target>
        </trans-unit>
        <trans-unit id="952faf72c9a83e116cef336ce73f046eb32c95b9" translate="yes" xml:space="preserve">
          <source>Indices with names of the form &quot;sqlite_autoindex_TABLE_N&quot; that are used to implement &lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE&lt;/a&gt; and &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt; constraints on ordinary tables.</source>
          <target state="translated">Индексы с именами вида &quot;sqlite_autoindex_TABLE_N&quot;, которые используются для реализации ограничений &lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE&lt;/a&gt; и &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt; для обычных таблиц.</target>
        </trans-unit>
        <trans-unit id="853f712d884520adb0232cc6445c159a48a0d960" translate="yes" xml:space="preserve">
          <source>Individual database connections created using &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; can choose to participate or not participate in shared cache mode by using the &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_SHAREDCACHE&lt;/a&gt; or &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_PRIVATECACHE&lt;/a&gt; flags the third parameter. The use of either of these flags overrides the global shared cache mode setting established by &lt;a href=&quot;c3ref/enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache()&lt;/a&gt;. No more than one of the flags should be used; if both SQLITE_OPEN_SHAREDCACHE and SQLITE_OPEN_PRIVATECACHE flags are used in the third argument to &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; then the behavior is undefined.</source>
          <target state="translated">Отдельные соединения с базой данных, созданные с помощью &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2 (),&lt;/a&gt; могут выбрать, участвовать или не участвовать в режиме общего кэша, используя флаги &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_SHAREDCACHE&lt;/a&gt; или &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_PRIVATECACHE&lt;/a&gt; в третьем параметре. Использование любого из этих флагов отменяет настройку режима глобального общего кэша, установленную &lt;a href=&quot;c3ref/enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache ()&lt;/a&gt; . Следует использовать не более одного из флагов; если оба флага SQLITE_OPEN_SHAREDCACHE и SQLITE_OPEN_PRIVATECACHE используются в третьем аргументе &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2 (),&lt;/a&gt; то поведение не определено.</target>
        </trans-unit>
        <trans-unit id="e34e9639a7829e3d1eeead355b99441da28ac59a" translate="yes" xml:space="preserve">
          <source>Individual fields of the shm header, except for the salt values copied from the WAL header, are unsigned integers in the native byte-order of the host machine. The salt values are exact copies from the WAL header and are in whatever byte order is used by the WAL file. The size of integers may be 8, 16, 32, or 64 bits. A detailed breakout of the individual fields of the shm header follows:</source>
          <target state="translated">Отдельные поля заголовка shm,за исключением значений соли,скопированных из заголовка WAL,являются беззнаковыми целыми числами в родном порядке байт хост-машины.Значения соли являются точными копиями из заголовка WAL и находятся в любом порядке байт,используемом файлом WAL.Размер целых чисел может быть 8,16,32 или 64 бита.Далее следует подробная разбивка отдельных полей заголовка shm:</target>
        </trans-unit>
        <trans-unit id="afaa9b90ffb384cf537b3db99f57a1ca2ab340a0" translate="yes" xml:space="preserve">
          <source>Individual subterms might be a single comparison expression like *a=5* or *x&amp;gt;y* or they can be LIKE or BETWEEN expressions, or a subterm can be a parenthesized list of AND-connected sub-subterms. Each subterm is analyzed as if it were itself the entire WHERE clause in order to see if the subterm is indexable by itself. If &lt;u&gt;every&lt;/u&gt; subterm of an OR clause is separately indexable then the OR clause might be coded such that a separate index is used to evaluate each term of the OR clause. One way to think about how SQLite uses separate indices for each OR clause term is to imagine that the WHERE clause where rewritten as follows:</source>
          <target state="translated">Отдельные подтермы могут быть одним выражением сравнения, например * a = 5 * или * x&amp;gt; y *, или они могут быть выражениями LIKE или BETWEEN, или подтерм может быть заключенным в скобки списком подтермов, связанных AND. Каждый подтерм анализируется, как если бы он сам был целым предложением WHERE, чтобы увидеть, индексируется ли сам подтерм. Если &lt;u&gt;каждый&lt;/u&gt; подтерм предложения OR индексируется отдельно, то предложение OR может быть закодировано таким образом, чтобы для оценки каждого члена предложения OR использовался отдельный индекс. Один из способов подумать о том, как SQLite использует отдельные индексы для каждого термина предложения OR, - это представить, что предложение WHERE переписано следующим образом:</target>
        </trans-unit>
        <trans-unit id="7a9fd17dd36196733342a48e4a93f680869a4f7c" translate="yes" xml:space="preserve">
          <source>Individual virtual table implementations might impose additional constraints. For example, some virtual implementations might provide read-only tables. Or some virtual table implementations might allow &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; or &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; but not &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;. Or some virtual table implementations might limit the kinds of UPDATEs that can be made.</source>
          <target state="translated">Реализации отдельных виртуальных таблиц могут налагать дополнительные ограничения. Например, некоторые виртуальные реализации могут предоставлять таблицы только для чтения. Или некоторые реализации виртуальных таблиц могут разрешать &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; или &lt;a href=&quot;lang_delete&quot;&gt;DELETE,&lt;/a&gt; но не &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; . Или некоторые реализации виртуальных таблиц могут ограничивать виды ОБНОВЛЕНИЙ, которые могут быть сделаны.</target>
        </trans-unit>
        <trans-unit id="b7ab8cb519f7ae8e1280427c18f93285db556ab6" translate="yes" xml:space="preserve">
          <source>Infinite loop on an UPDATE that uses an OR operator in the WHERE clause. Problem introduced with 3.17.0 and reported on the mailing list about one year later. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/47b2581aa9bfecec&quot;&gt;47b2581aa9bfecec&lt;/a&gt;.</source>
          <target state="translated">Бесконечный цикл для UPDATE, использующего оператор OR в предложении WHERE. Проблема появилась в версии 3.17.0 и появилась в списке рассылки примерно через год. Билет &lt;a href=&quot;https://www.sqlite.org/src/info/47b2581aa9bfecec&quot;&gt;47b2581aa9bfecec&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9779307227ff608723d6f1acc622b0fbd0d99060" translate="yes" xml:space="preserve">
          <source>Information about the ORDER BY clause is stored in aOrderBy[]. Each term of aOrderBy records a column of the ORDER BY clause.</source>
          <target state="translated">Информация о пункте ORDER BY хранится в aOrderBy[].Каждый термин aOrderBy записывает столбец пункта ORDER BY.</target>
        </trans-unit>
        <trans-unit id="8900519c8c00e46885e8acc9f5e07ba3fa96d336" translate="yes" xml:space="preserve">
          <source>Informix</source>
          <target state="translated">Informix</target>
        </trans-unit>
        <trans-unit id="19682bdb9185a5fa9d763d414d0443d3a0bc2456" translate="yes" xml:space="preserve">
          <source>Init</source>
          <target state="translated">Init</target>
        </trans-unit>
        <trans-unit id="c807a586d6078a7e14adef4ebb7912d0c6f4aa53" translate="yes" xml:space="preserve">
          <source>InitCoroutine</source>
          <target state="translated">InitCoroutine</target>
        </trans-unit>
        <trans-unit id="9ceecfe65e61c428178f61207aad8930969e6176" translate="yes" xml:space="preserve">
          <source>Initial Public Release of Alpha code</source>
          <target state="translated">Начальный публичный релиз Альфа-кода</target>
        </trans-unit>
        <trans-unit id="22e34d8b442d40192baed65a8aa102e6e94f33a1" translate="yes" xml:space="preserve">
          <source>Initial release of version 2.0. The idea of renaming the library to &quot;SQLus&quot; was abandoned in favor of keeping the &quot;SQLite&quot; name and bumping the major version number.</source>
          <target state="translated">Первоначальный релиз версии 2.0.Идея переименования библиотеки на &quot;SQLus&quot; была оставлена в пользу сохранения имени &quot;SQLite&quot; и обхода основного номера версии.</target>
        </trans-unit>
        <trans-unit id="8f5bfa371a731c186afb7ca1237eb5d4d7f1e077" translate="yes" xml:space="preserve">
          <source>Initial size of the database in pages</source>
          <target state="translated">Начальный размер базы данных в страницах</target>
        </trans-unit>
        <trans-unit id="7bf3e06594405eb1afbafdd083622d687011597a" translate="yes" xml:space="preserve">
          <source>Initialize The SQLite Library</source>
          <target state="translated">Инициализировать библиотеку SQLite</target>
        </trans-unit>
        <trans-unit id="d191407d44cf9ade286348bd4b44b9f7f3e25feb" translate="yes" xml:space="preserve">
          <source>Initialize index X to be N-200 (where N is the size of a database page in bytes.</source>
          <target state="translated">Инициализируйте индекс X как N-200 (где N-размер страницы базы данных в байтах).</target>
        </trans-unit>
        <trans-unit id="8e6cd4e5b42b5a543357e6d81e6f378b25c829f6" translate="yes" xml:space="preserve">
          <source>Initialize the &lt;b&gt;azColumnName[]&lt;/b&gt; array for the callback.</source>
          <target state="translated">Инициализируйте массив &lt;b&gt;azColumnName []&lt;/b&gt; для обратного вызова.</target>
        </trans-unit>
        <trans-unit id="5f7aab6a3275a65fb3b4985527f188c8b61dc3b5" translate="yes" xml:space="preserve">
          <source>Initialize the checksum to the checksum nonce value found in the journal header at offset 12.</source>
          <target state="translated">Инициализируйте контрольную сумму до контрольной нецелой величины,найденной в заголовке журнала со смещением 12.</target>
        </trans-unit>
        <trans-unit id="404f059fc8a52705cd25b69b3e9ff09c1be18ec9" translate="yes" xml:space="preserve">
          <source>Inner joins can be freely reordered. However a left outer join is neither commutative nor associative and hence will not be reordered. Inner joins to the left and right of the outer join might be reordered if the optimizer thinks that is advantageous but the outer joins are always evaluated in the order in which they occur.</source>
          <target state="translated">Внутренние соединения могут быть свободно переупорядочены.Однако левое внешнее соединение не является ни коммутационным,ни ассоциативным и,следовательно,не будет переупорядочиваться.Внутренние соединения слева и справа от внешнего соединения могут быть упорядочены по-другому,если оптимизатор считает это выгодным,но внешние соединения всегда оцениваются в том порядке,в котором они возникают.</target>
        </trans-unit>
        <trans-unit id="95802daab3a23990338179f72248350c1434cf39" translate="yes" xml:space="preserve">
          <source>Insert</source>
          <target state="translated">Insert</target>
        </trans-unit>
        <trans-unit id="6173fc45fc7b2219f9b313a58dd34b30a31fc6dc" translate="yes" xml:space="preserve">
          <source>Insert that single row into the recursive table</source>
          <target state="translated">Вставьте эту единственную строку в рекурсивную таблицу.</target>
        </trans-unit>
        <trans-unit id="e9c69a8b8aca121e6ec4067a03fd7e5c40db2b72" translate="yes" xml:space="preserve">
          <source>Insert the integer value held by register P2 into a RowSet object held in register P1.</source>
          <target state="translated">Вставить целое значение,удерживаемое регистром P2,в объект RowSet,удерживаемый регистром P1.</target>
        </trans-unit>
        <trans-unit id="85a8fe292b0b6ab92cb375e9d651b4f869ca615a" translate="yes" xml:space="preserve">
          <source>Inserting Records Into The Database</source>
          <target state="translated">Вставка записей в базу данных</target>
        </trans-unit>
        <trans-unit id="d9102185aa139480514433588d7c7980df39e939" translate="yes" xml:space="preserve">
          <source>Instead of a separate OFFSET clause, the LIMIT clause may specify two scalar expressions separated by a comma. In this case, the first expression is used as the OFFSET expression and the second as the LIMIT expression. This is counter-intuitive, as when using the OFFSET clause the second of the two expressions is the OFFSET and the first the LIMIT. This reversal of the offset and limit is intentional - it maximizes compatibility with other SQL database systems. However, to avoid confusion, programmers are strongly encouraged to use the form of the LIMIT clause that uses the &quot;OFFSET&quot; keyword and avoid using a LIMIT clause with a comma-separated offset.</source>
          <target state="translated">Вместо отдельного пункта OFFSET,пункт LIMIT может задавать два скалярных выражения,разделенных запятой.В этом случае первое выражение используется как выражение OFFSET,а второе-как выражение LIMIT.Это интуитивно понятно,так как при использовании пункта OFFSET вторым из двух выражений является OFFSET,а первым-LIMIT.Такое изменение смещения и предела является преднамеренным-оно максимизирует совместимость с другими системами СУБД SQL.Однако,чтобы избежать путаницы,программистам настоятельно рекомендуется использовать форму пункта LIMIT,в котором используется ключевое слово &quot;OFFSET&quot;,и избегать использования пункта LIMIT со смещением,разделенным запятыми.</target>
        </trans-unit>
        <trans-unit id="d84a58129471e483da1b069622f8ee436752fbf7" translate="yes" xml:space="preserve">
          <source>Instead of deleting records where the &quot;two&quot; column is less than 50, this statement just puts the &quot;one&quot; column in parentheses The VDBE program to implement this statement follows:</source>
          <target state="translated">Вместо того,чтобы удалять записи,где столбец &quot;два&quot; меньше 50,этот оператор просто заключает столбец &quot;один&quot; в круглые скобки Программа VDBE,реализующая этот оператор,следует далее:</target>
        </trans-unit>
        <trans-unit id="123ee948ecafb3b169cf486ec20a13fbb0b9103f" translate="yes" xml:space="preserve">
          <source>Instead of providing full Unicode case support by default, SQLite provides the ability to link against external Unicode comparison and conversion routines. The application can overload the built-in &lt;a href=&quot;datatype3#collation&quot;&gt;NOCASE&lt;/a&gt; collating sequence (using &lt;a href=&quot;c3ref/create_collation&quot;&gt;sqlite3_create_collation()&lt;/a&gt;) and the built-in &lt;a href=&quot;lang_corefunc#like&quot;&gt;like()&lt;/a&gt;, &lt;a href=&quot;lang_corefunc#upper&quot;&gt;upper()&lt;/a&gt;, and &lt;a href=&quot;lang_corefunc#lower&quot;&gt;lower()&lt;/a&gt; functions (using &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt;). The SQLite source code includes an &quot;ICU&quot; extension that does these overloads. Or, developers can write their own overloads based on their own Unicode-aware comparison routines already contained within their project.</source>
          <target state="translated">Вместо полной поддержки регистра Unicode по умолчанию, SQLite предоставляет возможность связываться с внешними процедурами сравнения и преобразования Unicode. Приложение может перегружать встроенную последовательность сортировки &lt;a href=&quot;datatype3#collation&quot;&gt;NOCASE&lt;/a&gt; (с использованием &lt;a href=&quot;c3ref/create_collation&quot;&gt;sqlite3_create_collation ()&lt;/a&gt; ) и встроенные функции &lt;a href=&quot;lang_corefunc#like&quot;&gt;like ()&lt;/a&gt; , &lt;a href=&quot;lang_corefunc#upper&quot;&gt;upper ()&lt;/a&gt; и &lt;a href=&quot;lang_corefunc#lower&quot;&gt;lower ()&lt;/a&gt; (с помощью &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function ()&lt;/a&gt; ). Исходный код SQLite включает расширение &amp;laquo;ICU&amp;raquo;, которое выполняет эти перегрузки. Или разработчики могут написать свои собственные перегрузки на основе собственных процедур сравнения с поддержкой Unicode, уже содержащихся в их проекте.</target>
        </trans-unit>
        <trans-unit id="e02d371a11cece5f4e01254e6fedf80303033a58" translate="yes" xml:space="preserve">
          <source>Instead of using a single data structure on disk to store the full-text index, FTS5 uses a series of b-trees. Each time a new transaction is committed, a new b-tree containing the contents of the committed transaction is written into the database file. When the full-text index is queried, each b-tree must be queried individually and the results merged before being returned to the user.</source>
          <target state="translated">Вместо использования единой структуры данных на диске для хранения полнотекстового индекса,FTS5 использует ряд b-деревьев.При каждой фиксации новой транзакции в файл базы данных записывается новое b-дерево,содержащее содержимое фиксации.При запросе полнотекстового индекса необходимо опрашивать каждое b-дерево по отдельности и объединять результаты,прежде чем возвращать их пользователю.</target>
        </trans-unit>
        <trans-unit id="17249ad26f29e1aabdd8d073e961780b07d76064" translate="yes" xml:space="preserve">
          <source>Instead of using bm25() with no trailing arguments, the specific auxiliary function mapped to the rank column may be configured either on a per-query basis, or by setting a different persistent default for the FTS table.</source>
          <target state="translated">Вместо того,чтобы использовать bm25()без трейлинговых аргументов,специальная вспомогательная функция,отображенная в столбце ранга,может быть сконфигурирована либо по запросу,либо путем установки другого постоянного значения по умолчанию для таблицы FTS.</target>
        </trans-unit>
        <trans-unit id="f96fd53b0d03f5a031e6bd07854c303b890ed6f3" translate="yes" xml:space="preserve">
          <source>Instead of writing separately to the full-text index and the content table, some users may wish to use database triggers to keep the full-text index up to date with respect to the set of documents stored in the content table. For example, using the tables from earlier examples:</source>
          <target state="translated">Вместо того,чтобы писать отдельно в полнотекстовый индекс и таблицу содержимого,некоторые пользователи могут использовать триггеры базы данных для поддержания полнотекстового индекса в актуальном состоянии по отношению к набору документов,хранящихся в таблице содержимого.Например,используя таблицы из более ранних примеров:</target>
        </trans-unit>
        <trans-unit id="2dfaa927aed3a85d724ea909cde490986f208ecf" translate="yes" xml:space="preserve">
          <source>Instruction 1 is of particular importance in this example. Normally, the Column instruction extracts the value of a column from a larger record in the data of an SQLite file entry. Instruction 1 sets a flag on the transient table so that Column will instead treat the key of the SQLite file entry as if it were data and extract column information from the key.</source>
          <target state="translated">В данном примере особое значение имеет Инструкция 1.Обычно инструкция Column извлекает значение столбца из более крупной записи в данных записи файла SQLite.В Инструкции 1 установлен флаг на переходной таблице,так что вместо колонки будет обрабатываться ключ записи в файле SQLite,как если бы это были данные,и извлекаться информация о колонке из ключа.</target>
        </trans-unit>
        <trans-unit id="5a41b63030179eee6fe726824158f303ff0039a4" translate="yes" xml:space="preserve">
          <source>Instructions 0 though 4 are as in the INSERT example. They start transactions for the main and temporary databases, verify the database schema for the main database, and open a read cursor on the table &quot;examp&quot;. Notice that the cursor is opened for reading, not writing. At this stage of the program we are only going to be scanning the table, not changing it. We will reopen the same table for writing later, at instruction 15.</source>
          <target state="translated">Инструкции 0,хотя и 4 такие же,как и в примере INSERT.Они начинают транзакции для основной и временной БД,проверяют схему БД для основной и открывают курсор чтения на таблице &quot;экзамен&quot;.Обратите внимание,что курсор открыт для чтения,а не для записи.На данном этапе программы мы будем только сканировать таблицу,не изменяя ее.Мы вновь откроем эту же таблицу для записи позже,в инструкции 15.</target>
        </trans-unit>
        <trans-unit id="b00a667a760d339b93dad1b03b5b7f4819103702" translate="yes" xml:space="preserve">
          <source>Instructions 11 through 18 implement a loop over all index records with the key that was fetched by instruction 8. All of the index records with this key will be contiguous in the index table, so we walk through them and fetch the corresponding table key from the index. This table key is then used to move the cursor to that row in the table. The rest of the loop is the same as the loop for the non-indexed SELECT query.</source>
          <target state="translated">В Инструкциях 11-18 реализован цикл над всеми записями индекса с ключом,который был получен с помощью Инструкции 8.Все записи индекса с этим ключом будут сопрягаться в индексной таблице,поэтому мы пройдем по ним и возьмем соответствующий ключ таблицы из индекса.Затем этот ключ таблицы используется для перемещения курсора на эту строку таблицы.Остальная часть цикла аналогична циклу для неиндексированного SELECT-запроса.</target>
        </trans-unit>
        <trans-unit id="93ad75caff49702ce2412b358044c514b17d458d" translate="yes" xml:space="preserve">
          <source>Instructions 18 through 23 implement a loop over every row of the table being indexed. For each table row, we first extract the integer key for that row using Recno in instruction 19, then get the value of the &quot;two&quot; column using Column in instruction 20. The &lt;a href=&quot;opcode#MakeIdxKey&quot;&gt;MakeIdxKey&lt;/a&gt; instruction at 21 converts data from the &quot;two&quot; column (which is on the top of the stack) into a valid index key. For an index on a single column, this is basically a no-op. But if the P1 operand to MakeIdxKey had been greater than one multiple entries would have been popped from the stack and converted into a single index key. The &lt;a href=&quot;opcode#IdxPut&quot;&gt;IdxPut&lt;/a&gt; instruction at 22 is what actually creates the index entry. IdxPut pops two elements from the stack. The top of the stack is used as a key to fetch an entry from the index table. Then the integer which was second on stack is added to the set of integers for that index and the new record is written back to the database file. Note that the same index entry can store multiple integers if there are two or more table entries with the same value for the two column.</source>
          <target state="translated">Инструкции с 18 по 23 реализуют цикл по каждой индексируемой строке таблицы. Для каждой строки таблицы мы сначала извлекаем целочисленный ключ для этой строки с помощью Recno в инструкции 19, затем получаем значение столбца &amp;laquo;два&amp;raquo; с помощью столбца в инструкции 20. Инструкция &lt;a href=&quot;opcode#MakeIdxKey&quot;&gt;MakeIdxKey&lt;/a&gt; в 21 преобразует данные из столбца &amp;laquo;два&amp;raquo; ( который находится наверху стека) в действительный индексный ключ. Для индекса по одному столбцу это практически невозможно. Но если бы операнд P1 для MakeIdxKey был больше, чем один, несколько записей были бы извлечены из стека и преобразованы в один индексный ключ. &lt;a href=&quot;opcode#IdxPut&quot;&gt;IdxPut&lt;/a&gt;инструкция в 22 - это то, что на самом деле создает запись индекса. IdxPut извлекает два элемента из стека. Верхняя часть стека используется как ключ для выборки записи из индексной таблицы. Затем целое число, которое было вторым в стеке, добавляется к набору целых чисел для этого индекса, и новая запись записывается обратно в файл базы данных. Обратите внимание, что одна и та же запись индекса может хранить несколько целых чисел, если есть две или более записи таблицы с одинаковым значением для двух столбцов.</target>
        </trans-unit>
        <trans-unit id="d073fd93c649c9cf841978f9cb4f52abf67079a9" translate="yes" xml:space="preserve">
          <source>Instructions 19 through 25 construct a new database record that will be used to replace the existing record. This is the same kind of code that we saw in the description of INSERT and will not be described further. After instruction 25 executes, the stack looks like this:</source>
          <target state="translated">В Инструкциях 19-25 создается новая запись в базе данных,которая будет использоваться для замены существующей записи.Это тот же самый код,который мы видели в описании INSERT и не будем описывать далее.После выполнения Инструкции 25 стек выглядит так:</target>
        </trans-unit>
        <trans-unit id="560e44647be24d5aca941bd1314e718abb8f4a57" translate="yes" xml:space="preserve">
          <source>Instructions 2 and 3 open a read cursor on the database table that is to be queried. This works the same as the OpenWrite instruction in the INSERT example except that the cursor is opened for reading this time instead of for writing. Instruction 4 verifies the database schema as in the INSERT example.</source>
          <target state="translated">Инструкции 2 и 3 открывают курсор чтения на таблице БД,которую необходимо опрашивать.Это работает так же,как и инструкция OpenWrite в примере INSERT,за исключением того,что курсор в этот раз открывается на чтение,а не на запись.Инструкция 4 проверяет схему БД,как в примере INSERT.</target>
        </trans-unit>
        <trans-unit id="fca2a6be701ffa87d686ce081ffdb761ec90891d" translate="yes" xml:space="preserve">
          <source>Instructions for compiling for Android are &lt;a href=&quot;#compile-android&quot;&gt;shown below&lt;/a&gt;.</source>
          <target state="translated">Инструкции по компиляции для Android &lt;a href=&quot;#compile-android&quot;&gt;приведены ниже&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="180fcbe698d0f2c44101a06215c472930bbd0a01" translate="yes" xml:space="preserve">
          <source>Int64</source>
          <target state="translated">Int64</target>
        </trans-unit>
        <trans-unit id="8245fcad9e0056a0d272c8564c605d1f5607526e" translate="yes" xml:space="preserve">
          <source>IntCopy</source>
          <target state="translated">IntCopy</target>
        </trans-unit>
        <trans-unit id="9edcffff4461c9083fbff857f8dcee0f0769cbd4" translate="yes" xml:space="preserve">
          <source>Integer</source>
          <target state="translated">Integer</target>
        </trans-unit>
        <trans-unit id="d591fd91d02ea91f2fb6bfc98baa68985aa1c55d" translate="yes" xml:space="preserve">
          <source>Integer arithmetic operations that would have resulted in overflow are now performed using floating-point instead.</source>
          <target state="translated">Целочисленные арифметические операции,которые привели бы к переполнению,теперь выполняются с плавающей точкой.</target>
        </trans-unit>
        <trans-unit id="a45ac87a27eab6aa76ce2b5c611f2a64d3669419" translate="yes" xml:space="preserve">
          <source>Integer values stored as part of segment b-tree nodes are encoded using the FTS varint format. This encoding is similar, but &lt;b&gt;not identical&lt;/b&gt;, to the &lt;a href=&quot;fileformat#varint_format&quot;&gt;SQLite varint format&lt;/a&gt;.</source>
          <target state="translated">Целочисленные значения, хранящиеся как часть узлов сегмента b-дерева, кодируются с использованием формата FTS varint. Эта кодировка подобна, но &lt;b&gt;не идентична&lt;/b&gt; , в &lt;a href=&quot;fileformat#varint_format&quot;&gt;формате SQLite varint&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="60896296e2cc4f360fd103b1acf3b75080d48243" translate="yes" xml:space="preserve">
          <source>Integrity of the freelist</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5d27de0bdb200a7cf8d08a229aa8daa78f0e8ef" translate="yes" xml:space="preserve">
          <source>IntegrityCk</source>
          <target state="translated">IntegrityCk</target>
        </trans-unit>
        <trans-unit id="825d7872ab454dde0951d75f4e8c3836556b73f2" translate="yes" xml:space="preserve">
          <source>Intended Use Of This Memory Slot</source>
          <target state="translated">Целевое использование этого слота памяти</target>
        </trans-unit>
        <trans-unit id="bad6e55f508278bbd1f2de2f51b2cfa41d861db7" translate="yes" xml:space="preserve">
          <source>Interbase</source>
          <target state="translated">Interbase</target>
        </trans-unit>
        <trans-unit id="7b4db7ef1fa23cfb5e115a2a2c89d46a6a2ebc4a" translate="yes" xml:space="preserve">
          <source>Interface</source>
          <target state="translated">Interface</target>
        </trans-unit>
        <trans-unit id="5fe5b201b27c997051ff6e5d94d0bbfdf6211714" translate="yes" xml:space="preserve">
          <source>Interior pages of table b-trees have no payload and so there is never any payload to spill.</source>
          <target state="translated">Внутренние страницы таблицы b-деревья не имеют полезной нагрузки и поэтому никогда не проливаются.</target>
        </trans-unit>
        <trans-unit id="fc9225a1693f44637be7aea70d7fcc2c5840704d" translate="yes" xml:space="preserve">
          <source>Internal</source>
          <target state="translated">Internal</target>
        </trans-unit>
        <trans-unit id="2e2e38ed2987465eebf4fce7929c514aa147e99c" translate="yes" xml:space="preserve">
          <source>Internal Versus External BLOBs</source>
          <target state="translated">Внутренний против внешнего BLOB</target>
        </trans-unit>
        <trans-unit id="8f5ed2d53487fd119b9560f28f441dc6f596f2d9" translate="yes" xml:space="preserve">
          <source>Internal Versus External BLOBs in SQLite</source>
          <target state="translated">Внутренние против внешних BLOB в SQLite</target>
        </trans-unit>
        <trans-unit id="e76edc7c42bb9553424aeb43d13659b70db42f10" translate="yes" xml:space="preserve">
          <source>Internal schema objects used by SQLite may include the following:</source>
          <target state="translated">Внутренние объекты схемы,используемые SQLite,могут включать в себя следующее:</target>
        </trans-unit>
        <trans-unit id="f7a3c018025e7b8852ebedd2735d4dc85161ed87" translate="yes" xml:space="preserve">
          <source>Internal table</source>
          <target state="translated">Внутренняя таблица</target>
        </trans-unit>
        <trans-unit id="43a9dae252aed092af4315626ccea64ecf3ea367" translate="yes" xml:space="preserve">
          <source>Internally, Geopoly stores polygons in a binary format - an SQL BLOB. Details of the binary format are given below. All of the Geopoly interfaces are able to accept polygons in either the GeoJSON format or in the binary format.</source>
          <target state="translated">Внутри Geopoly хранит полигоны в бинарном формате-SQL BLOB.Детали бинарного формата приведены ниже.Все интерфейсы Geopoly могут принимать полигоны как в формате GeoJSON,так и в бинарном формате.</target>
        </trans-unit>
        <trans-unit id="f1e37c3aeef00d8b7d2ca4c1560bedb3798f4927" translate="yes" xml:space="preserve">
          <source>Internationalization of the TRIM() function. Ticket #2323</source>
          <target state="translated">Интернационализация функции TRIM().Билет #2323</target>
        </trans-unit>
        <trans-unit id="888710a95af8568e1d72613950e6141b6fd4f17f" translate="yes" xml:space="preserve">
          <source>Interpret the byte at offset X into the page as an 8-bit unsigned integer and add the value of that integer to the checksum.</source>
          <target state="translated">Интерпретируйте байт при смещении X в страницу как 8-битное беззнаковое целое число и добавьте значение этого числа к контрольной сумме.</target>
        </trans-unit>
        <trans-unit id="0a6e9fc795cd5f992a07708fafc38d37296f0f2e" translate="yes" xml:space="preserve">
          <source>Interpret the content of register P1 as an integer. Store the ones-complement of the P1 value into register P2. If P1 holds a NULL then store a NULL in P2.</source>
          <target state="translated">Интерпретируйте содержимое регистра P1 как целое число.Хранить единичное целое значение P1 в регистре P2.Если P1 содержит NULL,то хранить NULL в P2.</target>
        </trans-unit>
        <trans-unit id="5e8db10d44914bca3da452a09d9353f35541c4d5" translate="yes" xml:space="preserve">
          <source>Interpret the data that cursor P1 points to as a structure built using the &lt;a href=&quot;opcode#MakeRecord&quot;&gt;MakeRecord&lt;/a&gt; instruction. (See the &lt;a href=&quot;opcode#MakeRecord&quot;&gt;MakeRecord&lt;/a&gt; opcode for additional information about the format of the data.) Extract the P2-th column from this record. If there are less that (P2+1) values in the record, extract a NULL.</source>
          <target state="translated">Интерпретируйте данные, на которые указывает курсор P1, как структуру, построенную с &lt;a href=&quot;opcode#MakeRecord&quot;&gt;помощью&lt;/a&gt; инструкции MakeRecord . (См. &lt;a href=&quot;opcode#MakeRecord&quot;&gt;Код&lt;/a&gt; операции MakeRecord для получения дополнительной информации о формате данных.) Извлеките столбец P2 из этой записи. Если в записи меньше (P2 + 1) значений, извлеките NULL.</target>
        </trans-unit>
        <trans-unit id="2f79feeee233aec484084c713d84bf8b19e18fec" translate="yes" xml:space="preserve">
          <source>Interpret the value in register P1 as a boolean value. Store that boolean (a 0 or 1) in register P2. Or if the value in register P1 is NULL, then the P3 is stored in register P2. Invert the answer if P4 is 1.</source>
          <target state="translated">Интерпретируйте значение в регистре P1 как логическое значение.Храните это булевое значение (0 или 1)в регистре P2.Или если значение в регистре P1 равно NULL,то P3 хранится в регистре P2.Инвертировать ответ,если P4 равен 1.</target>
        </trans-unit>
        <trans-unit id="11ded0e7491f472be93758e1becf6a72788c6084" translate="yes" xml:space="preserve">
          <source>Interpret the value in register P1 as a boolean value. Store the boolean complement in register P2. If the value in register P1 is NULL, then a NULL is stored in P2.</source>
          <target state="translated">Интерпретируйте значение в регистре P1 как логическое значение.Хранить булевое дополнение в регистре P2.Если значение в регистре P1 равно NULL,то NULL хранится в P2.</target>
        </trans-unit>
        <trans-unit id="15470fd033e12b800743519c6e594f7da0f4f0f0" translate="yes" xml:space="preserve">
          <source>Interpretation</source>
          <target state="translated">Interpretation</target>
        </trans-unit>
        <trans-unit id="1215cbe2c98ef14d7aa50ec46f17432a95774205" translate="yes" xml:space="preserve">
          <source>Interrupt A Long-Running Query</source>
          <target state="translated">Прервать длинный бегущий запрос</target>
        </trans-unit>
        <trans-unit id="5c1dd154209c449e02a41fa43190c4baa16c350d" translate="yes" xml:space="preserve">
          <source>Introduce extended error codes and add error codes for various kinds of I/O errors.</source>
          <target state="translated">Ввести расширенные коды ошибок и добавить коды ошибок для различных видов ошибок ввода/вывода.</target>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="99fc2e9eb55cb6b8a4a8e79d3fb3b2c33516ae12" translate="yes" xml:space="preserve">
          <source>Introspect the disk content of an SQLite database file (the &lt;a href=&quot;dbstat&quot;&gt;dbstat virtual table&lt;/a&gt;)</source>
          <target state="translated">Изучите содержимое диска файла базы данных SQLite ( &lt;a href=&quot;dbstat&quot;&gt;виртуальная таблица dbstat&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="eca078956e48bad9ba22213be258664ddfba5fe3" translate="yes" xml:space="preserve">
          <source>Intuitively, we humans understand that algorithm-1 is best. Each check-in is likely to have few children (one child is the most common case) and each child can be tested for the $trunk tag in logarithmic time. Indeed, algorithm-1 is the faster choice in practice. But the NGQP has no intuition. The NGQP must use hard math, and algorithm-2 is slightly better mathematically. This is because, in the absence of other information, the NGQP must assume that the indexes PLINK_I1 and TAGXREF_I1 are of equal quality and are equally selective. Algorithm-2 uses one field of the TAGXREF_I1 index and both fields of the PLINK_I1 index whereas algorithm-1 only uses the first field of each index. Since algorithm-2 uses more index material, the NGQP is correct to judge it to be the better algorithm. The scores are close and algorithm-2 just barely squeaks ahead of algorithm-1. But algorithm-2 really is the correct choice here.</source>
          <target state="translated">Интуитивно мы,люди,понимаем,что алгоритм-1-лучший.Скорее всего,у каждого заезда мало детей (чаще всего это один ребенок),и каждый ребенок может быть проверен на логарифмический тег $ ствола в логарифмическое время.Действительно,алгоритм-1 является более быстрым выбором на практике.Но у NGQP нет интуиции.NGQP должен использовать жесткую математику,а алгоритм-2 немного лучше с математической точки зрения.Это связано с тем,что в отсутствие другой информации NGQP должен исходить из того,что индексы PLINK_I1 и TAGXREF_I1 одинаково качественны и одинаково избирательны.Алгоритм-2 использует одно поле индекса TAGXREF_I1 и оба поля индекса PLINK_I1,тогда как алгоритм-1 использует только первое поле каждого индекса.Поскольку алгоритм-2 использует больше материала индекса,NGQP правильно оценивает его как лучший алгоритм.Оценки близки и алгоритм-2 едва пищит впереди алгоритма-1.Но алгоритм-2 действительно является правильным выбором.</target>
        </trans-unit>
        <trans-unit id="b761791d82a982a68e59a508cac1ee842272cd79" translate="yes" xml:space="preserve">
          <source>Invert A Changeset</source>
          <target state="translated">Инвертировать изменение</target>
        </trans-unit>
        <trans-unit id="e32caad6eec08f7fecc6a1b58616c917f68be530" translate="yes" xml:space="preserve">
          <source>Invert the changeset before applying it. This is equivalent to inverting a changeset using sqlite3changeset_invert() before applying it. It is an error to specify this flag with a patchset.</source>
          <target state="translated">Инвертируйте changeset перед применением.Это эквивалентно инвертированию changeset'а с помощью sqlite3changeset_invert()перед его применением.Ошибкой является указание этого флага с помощью патчсета.</target>
        </trans-unit>
        <trans-unit id="78ac8e24cc6e1af906f6d84df224cae4a5dbdc9c" translate="yes" xml:space="preserve">
          <source>Invert the changeset while iterating through it. This is equivalent to inverting a changeset using sqlite3changeset_invert() before applying it. It is an error to specify this flag with a patchset.</source>
          <target state="translated">Инвертируйте измененный набор во время итерации через него.Это эквивалентно инвертированию changeset'а с помощью sqlite3changeset_invert()перед его применением.Ошибкой является указание этого флага с помощью патчсета.</target>
        </trans-unit>
        <trans-unit id="7bcd843ccbf3ca2b0a46090c9286f7cf70d294d4" translate="yes" xml:space="preserve">
          <source>Invoke &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigtrustedschema&quot;&gt;SQLITE_DBCONFIG_TRUSTED_SCHEMA&lt;/a&gt;,0,0) on each &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; as soon as it is opened.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebc598ee05cff833de713e00e614680a147ad7e5" translate="yes" xml:space="preserve">
          <source>Invoke &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigtrustedschema&quot;&gt;SQLITE_DBCONFIG_TRUSTED_SCHEMA&lt;/a&gt;,0,0) on each &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; as soon as it is opened. This prevents application-defined functions from being used in places where an attacker might be able to surreptiously invoke them by modifying a database schema:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f705eccb3bd6ee22f3941d7379adda7f2017d82" translate="yes" xml:space="preserve">
          <source>Invoke &lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify()&lt;/a&gt; on the database connection handle associated with the supplied statement handle to register for an unlock-notify callback. If the call to unlock_notify() returns SQLITE_LOCKED, then return this value to the caller.</source>
          <target state="translated">Вызовите &lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify ()&lt;/a&gt; для дескриптора соединения с базой данных, связанного с предоставленным дескриптором оператора, чтобы зарегистрироваться для обратного вызова unlock-notify. Если вызов unlock_notify () возвращает SQLITE_LOCKED, то верните это значение вызывающей стороне.</target>
        </trans-unit>
        <trans-unit id="7c709a0509002cbc5917883c970a9481452275c1" translate="yes" xml:space="preserve">
          <source>Invoke a user function (P4 is a pointer to a FuncDef object that defines the function) with P5 arguments taken from register P2 and successors. The result of the function is stored in register P3. Register P3 must not be one of the function inputs.</source>
          <target state="translated">Вызвать пользовательскую функцию (P4-указатель на объект FuncDef,определяющий функцию)с аргументами P5,взятыми из регистра P2 и преемников.Результат функции хранится в регистре P3.Регистр P3 не должен быть одним из входов функции.</target>
        </trans-unit>
        <trans-unit id="d5afe87b60965605a9297c781c01328e7ab18fc9" translate="yes" xml:space="preserve">
          <source>Invoke a user function (P4 is a pointer to an sqlite3_context object that contains a pointer to the function to be run) with P5 arguments taken from register P2 and successors. The result of the function is stored in register P3. Register P3 must not be one of the function inputs.</source>
          <target state="translated">Вызвать пользовательскую функцию (P4-указатель на контекстный объект sqlite3_context,содержащий указатель на запускаемую функцию)с аргументами P5,взятыми из регистра P2 и преемников.Результат работы функции хранится в регистре P3.Регистр P3 не должен быть одним из входов функции.</target>
        </trans-unit>
        <trans-unit id="bf8b8c1d4d822ee5f5035e452152155ef6c1caa7" translate="yes" xml:space="preserve">
          <source>Invoke a user function (P4 is a pointer to an sqlite3_context object that contains a pointer to the function to be run) with arguments taken from register P2 and successors. The number of arguments is in the sqlite3_context object that P4 points to. The result of the function is stored in register P3. Register P3 must not be one of the function inputs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec3125db909dbad56a3a25ad8b3535b576369321" translate="yes" xml:space="preserve">
          <source>Invoke the 'merge' command once with the parameter set to -N, then</source>
          <target state="translated">Запустить команду 'слияние' один раз с параметром -N,затем</target>
        </trans-unit>
        <trans-unit id="7dd177608c23145959faf29e93b347c2a9c95d8f" translate="yes" xml:space="preserve">
          <source>Invoke the 'merge' command zero or more times with the parameter set to N.</source>
          <target state="translated">Вызовите команду 'слияние' ноль или более раз с параметром,установленным в N.</target>
        </trans-unit>
        <trans-unit id="66ccce8dbed894fb937993244705085ff4d8803a" translate="yes" xml:space="preserve">
          <source>Invoke the callback function for the current row of the result.</source>
          <target state="translated">Вызовите функцию обратного вызова для текущей строки результата.</target>
        </trans-unit>
        <trans-unit id="125398c8d0ddcbf991b86f4ee6d99da4c12cf932" translate="yes" xml:space="preserve">
          <source>Invoke the sqlite3rbu_step(X) function one or more times on the sqlite3rbu object pointer X. Each call to sqlite3rbu_step() performs a single b-tree operation, so thousands of calls may be required to apply a complete update. The sqlite3rbu_step() interface will return SQLITE_DONE when the update has been completely applied.</source>
          <target state="translated">Вызвать функцию sqlite3rbu_step(X)один или несколько раз по указателю объекта sqlite3rbu X.Каждый вызов sqlite3rbu_step()выполняет одну операцию в b-дереве,поэтому для применения полного обновления могут потребоваться тысячи вызовов.Интерфейс sqlite3rbu_step()вернет SQLITE_DONE после полного применения обновления.</target>
        </trans-unit>
        <trans-unit id="09ac0f478fa9c31ebe084063003a8993cc83456c" translate="yes" xml:space="preserve">
          <source>Invoke the xValue() function and store the result in register P3.</source>
          <target state="translated">Вызовите функцию xValue()и сохраните результат в регистре P3.</target>
        </trans-unit>
        <trans-unit id="ec2b47e7de90dfad0a6211ad1cb07982eafe0cde" translate="yes" xml:space="preserve">
          <source>Invoking sqlite3_finalize() on a NULL pointer is a harmless no-op.</source>
          <target state="translated">Призыв sqlite3_finalize()на указатель NULL является безобидным no-op.</target>
        </trans-unit>
        <trans-unit id="bd8202d31b1a7640473e2e12fd946892b1ec4008" translate="yes" xml:space="preserve">
          <source>Invoking this pragma with an argument is equivalent to calling the &lt;a href=&quot;c3ref/wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2()&lt;/a&gt; C interface with a &lt;a href=&quot;c3ref/c_checkpoint_full&quot;&gt;3rd parameter&lt;/a&gt; corresponding to the argument:</source>
          <target state="translated">Вызов этой прагмы с аргументом эквивалентен вызову интерфейса C &lt;a href=&quot;c3ref/wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2 ()&lt;/a&gt; с &lt;a href=&quot;c3ref/c_checkpoint_full&quot;&gt;третьим параметром,&lt;/a&gt; соответствующим аргументу:</target>
        </trans-unit>
        <trans-unit id="5f0e3d2a93c21482714b0b7a93ae0ad2d3dfb1f3" translate="yes" xml:space="preserve">
          <source>Invoking this pragma without an argument is equivalent to calling the &lt;a href=&quot;c3ref/wal_checkpoint&quot;&gt;sqlite3_wal_checkpoint()&lt;/a&gt; C interface.</source>
          <target state="translated">Вызов этой прагмы без аргументов эквивалентен вызову интерфейса C. &lt;a href=&quot;c3ref/wal_checkpoint&quot;&gt;sqlite3_wal_checkpoint ()&lt;/a&gt; C.</target>
        </trans-unit>
        <trans-unit id="8cedb7aa520fd9ec8eb114043f05f6f9d17e93dd" translate="yes" xml:space="preserve">
          <source>Is SQLite threadsafe?</source>
          <target state="translated">Безопасен ли SQLite для потоков?</target>
        </trans-unit>
        <trans-unit id="d993744fe6f739c6aa4d5f6de34d342868d7e529" translate="yes" xml:space="preserve">
          <source>Is replaced by:</source>
          <target state="translated">заменен:</target>
        </trans-unit>
        <trans-unit id="accaed01010f56d422eef5c33bfb4384f7eeeed3" translate="yes" xml:space="preserve">
          <source>IsNull</source>
          <target state="translated">IsNull</target>
        </trans-unit>
        <trans-unit id="a0830278e8f462114ebf33a9e4e362b34c86b01d" translate="yes" xml:space="preserve">
          <source>IsTrue</source>
          <target state="translated">IsTrue</target>
        </trans-unit>
        <trans-unit id="3dea5e42ca2754f9e6823ecfc4f51c71cf05676a" translate="yes" xml:space="preserve">
          <source>Isolation And Concurrency</source>
          <target state="translated">изоляция и концентрация</target>
        </trans-unit>
        <trans-unit id="6a3e64b57124b4061c4f707d69ad242f0d0e0ef1" translate="yes" xml:space="preserve">
          <source>Isolation Between Database Connections</source>
          <target state="translated">Изоляция между соединениями базы данных</target>
        </trans-unit>
        <trans-unit id="e3488e8cb34f4c736ddb072c649ba2a6c79489e5" translate="yes" xml:space="preserve">
          <source>Isolation In SQLite</source>
          <target state="translated">Изоляция в SQLite</target>
        </trans-unit>
        <trans-unit id="2dfabf57c5175b858eac45130bf0b51df7502b3e" translate="yes" xml:space="preserve">
          <source>Issue an &lt;a href=&quot;rescode#warning_autoindex&quot;&gt;SQLITE_WARNING_AUTOINDEX&lt;/a&gt; warning on the &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfiglog&quot;&gt;SQLITE_CONFIG_LOG&lt;/a&gt; whenever the query planner uses an automatic index.</source>
          <target state="translated">Составлять &lt;a href=&quot;rescode#warning_autoindex&quot;&gt;SQLITE_WARNING_AUTOINDEX&lt;/a&gt; предупреждение на &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfiglog&quot;&gt;SQLITE_CONFIG_LOG&lt;/a&gt; всякий раз , когда планировщик запросов использует автоматический индекс.</target>
        </trans-unit>
        <trans-unit id="ffb450eea3632a82507d6bc65c2b7d60604799db" translate="yes" xml:space="preserve">
          <source>Issue an SQLITE_WARNING message on the &lt;a href=&quot;errlog&quot;&gt;error log&lt;/a&gt; if a &lt;a href=&quot;quirks#dblquote&quot;&gt;double-quoted string literal&lt;/a&gt; is used.</source>
          <target state="translated">Выдать сообщение SQLITE_WARNING в &lt;a href=&quot;errlog&quot;&gt;журнал ошибок,&lt;/a&gt; если используется &lt;a href=&quot;quirks#dblquote&quot;&gt;строковый литерал&lt;/a&gt; в двойных кавычках .</target>
        </trans-unit>
        <trans-unit id="887bf7a7997457d1a84b4ef3887a47fd35509c6e" translate="yes" xml:space="preserve">
          <source>Issue an error rather instead of an assertion-fault or null-pointer dereference when the sqlite_master table is corrupted so that the sqlite_sequence table root page is really a btree-index page. Check-in &lt;a href=&quot;https://www.sqlite.org/src/info/525deb7a67fbd647&quot;&gt;525deb7a67fbd647&lt;/a&gt;</source>
          <target state="translated">Выдавать ошибку, а не разыменование ошибки утверждения или нулевого указателя, когда таблица sqlite_master повреждена, так что корневая страница таблицы sqlite_sequence действительно является страницей индекса btree. Заезд &lt;a href=&quot;https://www.sqlite.org/src/info/525deb7a67fbd647&quot;&gt;525deb7a67fbd647&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="265877cc565c8d7a6873f0a63d90a0fdd348de2c" translate="yes" xml:space="preserve">
          <source>It an error if database zFrom does not exist or does not contain the required compatible table.</source>
          <target state="translated">Ошибка,если база данных zFrom не существует или не содержит требуемой совместимой таблицы.</target>
        </trans-unit>
        <trans-unit id="0e154e176231a0aafc6a2d79aba315f0be81a2c2" translate="yes" xml:space="preserve">
          <source>It cannot be used to copy data to or from in-memory databases.</source>
          <target state="translated">Он не может быть использован для копирования данных в или из баз данных в памяти.</target>
        </trans-unit>
        <trans-unit id="6fd3c51616175d12c8323af133471dff22943ef2" translate="yes" xml:space="preserve">
          <source>It could handle a special case of SQLITE_LOCKED that can occur when dropping a table or index.</source>
          <target state="translated">Он может обрабатывать специальный случай SQLITE_LOCKED,который может возникнуть при падении таблицы или индекса.</target>
        </trans-unit>
        <trans-unit id="186b030c86f45f0c84d4dba2b997ab209083ef94" translate="yes" xml:space="preserve">
          <source>It could manage thread priorities.</source>
          <target state="translated">Он может управлять приоритетами потоков.</target>
        </trans-unit>
        <trans-unit id="46b90c15208f2a0e159c21cdb03813412db842c6" translate="yes" xml:space="preserve">
          <source>It exists, and</source>
          <target state="translated">Она существует,и</target>
        </trans-unit>
        <trans-unit id="40ecc5a776918cb0ff3984e5d8619d213f6f930d" translate="yes" xml:space="preserve">
          <source>It is a good idea to establish a convention for determining the RBU vacuum state database name based on the target database name. The example code below uses &quot;&amp;lt;target&amp;gt;-vacuum&quot;, where &amp;lt;target&amp;gt; is the name of the database being vacuumed.</source>
          <target state="translated">Рекомендуется установить соглашение для определения имени базы данных состояния вакуума RBU на основе имени целевой базы данных. В приведенном ниже примере кода используется &amp;laquo;&amp;lt;цель&amp;gt; -вакуум&amp;raquo;, где &amp;lt;цель&amp;gt; - это имя очищаемой базы данных.</target>
        </trans-unit>
        <trans-unit id="bc2605e225f0c06786d4d6602b4aa9c521bcd8db" translate="yes" xml:space="preserve">
          <source>It is acceptable to call &lt;b&gt;sqlite_finalize&lt;/b&gt; on a virtual machine before &lt;b&gt;sqlite_step&lt;/b&gt; has returned SQLITE_DONE. Doing so has the effect of interrupting the operation in progress. Partially completed changes will be rolled back and the database will be restored to its original state (unless an alternative recovery algorithm is selected using an ON CONFLICT clause in the SQL being executed.) The effect is the same as if a callback function of &lt;b&gt;sqlite_exec&lt;/b&gt; had returned non-zero.</source>
          <target state="translated">Допустимо вызывать &lt;b&gt;sqlite_finalize&lt;/b&gt; на виртуальной машине до того, как &lt;b&gt;sqlite_step&lt;/b&gt; вернет SQLITE_DONE. Это приведет к прерыванию выполняемой операции. Частично завершенные изменения будут отменены, и база данных будет восстановлена ​​в исходное состояние (если не выбран альтернативный алгоритм восстановления с помощью предложения ON CONFLICT в выполняемом SQL). Эффект такой же, как если бы функция обратного вызова &lt;b&gt;sqlite_exec&lt;/b&gt; имела вернул ненулевое значение.</target>
        </trans-unit>
        <trans-unit id="9b1cdd52a287f4e7becc07615494854f9dea1062" translate="yes" xml:space="preserve">
          <source>It is also acceptable to call &lt;b&gt;sqlite_finalize&lt;/b&gt; on a virtual machine that has never been passed to &lt;b&gt;sqlite_step&lt;/b&gt; even once.</source>
          <target state="translated">Также допустимо вызывать &lt;b&gt;sqlite_finalize&lt;/b&gt; на виртуальной машине, которая ни разу не была передана &lt;b&gt;sqlite_step&lt;/b&gt; ни разу.</target>
        </trans-unit>
        <trans-unit id="8524404ce2a2650e2fd11b49dcd571c2f2744c61" translate="yes" xml:space="preserve">
          <source>It is also possible to create custom tokenizers for FTS5. The API for doing so is &lt;a href=&quot;fts5#custom_tokenizers&quot;&gt;described here&lt;/a&gt;.</source>
          <target state="translated">Также можно создавать собственные токенизаторы для FTS5. API для этого &lt;a href=&quot;fts5#custom_tokenizers&quot;&gt;описан здесь&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="af4ea7504b8858e61227bf5cbac3c869a2ebb0cf" translate="yes" xml:space="preserve">
          <source>It is also possible to customize the set of codepoints that unicode61 treats as separator characters. The &quot;separators=&quot; option may be used to specify one or more extra characters that should be treated as separator characters, and the &quot;tokenchars=&quot; option may be used to specify one or more extra characters that should be treated as part of tokens instead of as separator characters. For example:</source>
          <target state="translated">Также можно настроить набор кодовых точек,которые unicode61 рассматривает как символы-разделители.Опция &quot;separators=&quot; может быть использована для указания одного или нескольких дополнительных символов,которые должны рассматриваться как символы-разделители,а опция &quot;tokenchars=&quot; может быть использована для указания одного или нескольких дополнительных символов,которые должны рассматриваться как часть токенов,а не как символы-разделители.Например:</target>
        </trans-unit>
        <trans-unit id="c5f2716f625be713954d4be305f323e2da4e7532" translate="yes" xml:space="preserve">
          <source>It is also possible to express this kind of simultaneous read and write on an R-Tree within a single query, for example if an UPDATE statement tries to change the value of one row of the R-Tree based on a complicated query from another row of the same R-Tree, perhaps something like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="756b3fcc2f7b6b94c8632586f6c6ecc720cec025" translate="yes" xml:space="preserve">
          <source>It is an error to add types, constraints or &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt; declarations to a CREATE VIRTUAL TABLE statement used to create an FTS5 table. Once created, an FTS5 table may be populated using &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;, &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; or &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; statements like any other table. Like any other table with no PRIMARY KEY declaration, an FTS5 table has an implicit INTEGER PRIMARY KEY field named rowid.</source>
          <target state="translated">Добавление типов, ограничений или объявлений &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt; к оператору CREATE VIRTUAL TABLE, используемому для создания таблицы FTS5, является ошибкой. После создания таблица FTS5 может быть заполнена с помощью операторов &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; , &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; или &lt;a href=&quot;lang_delete&quot;&gt;DELETE,&lt;/a&gt; как и любая другая таблица. Как и любая другая таблица без объявления PRIMARY KEY, таблица FTS5 имеет неявное поле INTEGER PRIMARY KEY с именем rowid.</target>
        </trans-unit>
        <trans-unit id="444eee32669789fe15a56475160491d70e6d7f57" translate="yes" xml:space="preserve">
          <source>It is an error to attempt to set the sz or rawdata field to any value other than NULL.</source>
          <target state="translated">Ошибкой является попытка установить для поля sz или rawdata любое значение,отличное от NULL.</target>
        </trans-unit>
        <trans-unit id="24bfd3e9a865c193cff416ba8b58e38e3815e72c" translate="yes" xml:space="preserve">
          <source>It is an error to set the columnsize option to any value other than 0 or 1.</source>
          <target state="translated">Ошибкой является установка параметра &quot;Размер столбца&quot; на любое значение,отличное от 0 или 1.</target>
        </trans-unit>
        <trans-unit id="66b8e09fbd7b220da38b0f56a632afa06ded1cc2" translate="yes" xml:space="preserve">
          <source>It is an error to specify the FTS5_TOKEN_COLOCATED flag the first time xToken() is called. Multiple synonyms may be specified for a single token by making multiple calls to xToken(FTS5_TOKEN_COLOCATED) in sequence. There is no limit to the number of synonyms that may be provided for a single token.</source>
          <target state="translated">Ошибкой является указание флага FTS5_TOKEN_COLOCATED при первом вызове xToken().Для одной лексемы можно указать несколько синонимов,последовательно вызывая xToken(FTS5_TOKEN_COLOCATED).Количество синонимов,которое может быть задано для одной лексемы,не ограничено.</target>
        </trans-unit>
        <trans-unit id="f8a103b729e696566ddb48fa0100f23ca6a9cb4a" translate="yes" xml:space="preserve">
          <source>It is assumed that the cursor is used only for appending and so if the cursor is valid, then the cursor must already be pointing at the end of the btree and so no changes are made to the cursor.</source>
          <target state="translated">Предполагается,что курсор используется только для прикрепления,и поэтому,если курсор действителен,то он уже должен быть указан на конец дерева,поэтому никаких изменений в курсоре не вносится.</target>
        </trans-unit>
        <trans-unit id="28727e9350bc13e9dd557e61676acaf81b800e9f" translate="yes" xml:space="preserve">
          <source>It is assumed that writing a series of sequential blocks of data to a file in order is faster than writing the same blocks in an arbitrary order.</source>
          <target state="translated">Предполагается,что запись серии последовательных блоков данных в файл по порядку быстрее,чем запись одних и тех же блоков в произвольном порядке.</target>
        </trans-unit>
        <trans-unit id="b7995ee897a4d7d38d5bc734c7b7a1490089b50f" translate="yes" xml:space="preserve">
          <source>It is common for an application to invoke sqlite3_create_function() multiple times for the same SQL function. For example, if an SQL function can take either 2 or 3 arguments, then sqlite3_create_function() would be invoked once for the 2-argument version and a second time for the 3-argument version. The underlying implementation (the callbacks) can be different for both variants.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90995e42fb1f9b39bc19b92ec7c0b1c1c734e41d" translate="yes" xml:space="preserve">
          <source>It is created using a call to sqlite3changegroup_new().</source>
          <target state="translated">Она создается с помощью вызова sqlite3changegroup_new().</target>
        </trans-unit>
        <trans-unit id="4e7aaf577a2ee286bdd21a85c82980a7edeb975b" translate="yes" xml:space="preserve">
          <source>It is difficult to update individual entries in a ZIP archive. It is especially difficult to update individual entries in a ZIP archive in a way that does not destroy the entire document if the computer loses power and/or crashes in the middle of the update. It is not impossible to do this, but it is sufficiently difficult that nobody actually does it. Instead, whenever the user selects &quot;File/Save&quot;, the entire ZIP archive is rewritten. Hence, &quot;File/Save&quot; takes longer than it ought, especially on older hardware. Newer machines are faster, but it is still bothersome that changing a single character in a 50 megabyte presentation causes one to burn through 50 megabytes of the finite write life on the SSD.</source>
          <target state="translated">Сложно обновлять отдельные записи в ZIP архиве.Особенно сложно обновить отдельные записи в ZIP архиве таким образом,чтобы не уничтожить весь документ,если компьютер выйдет из строя и/или выйдет из строя в середине обновления.Это не невозможно сделать,но достаточно сложно,чтобы никто не делал этого на самом деле.Вместо этого,всякий раз,когда пользователь выбирает &quot;Файл/Сохранить&quot;,весь ZIP-архив переписывается.Следовательно,&quot;Файл/Сохранить&quot; занимает больше времени,чем следовало бы,особенно на старом оборудовании.Новые машины работают быстрее,но все равно неприятно,что изменение одного символа в 50-мегабайтной презентации заставляет прожигать 50 мегабайт конечного срока службы записи на SSD.</target>
        </trans-unit>
        <trans-unit id="5567ffe2a8c6dd00685158eaaf03eb7345f63a44" translate="yes" xml:space="preserve">
          <source>It is illegal for P1 and P3 to be the same register. Sometimes, if P3 is the same register as P2, the implementation is able to avoid a memcpy().</source>
          <target state="translated">Незаконно,чтобы P1 и P3 были одним и тем же регистром.Иногда,если P3 является тем же самым регистром,что и P2,реализация способна избежать memcpy().</target>
        </trans-unit>
        <trans-unit id="e08adbd91885a13f3de038527a6e47107fedd5af" translate="yes" xml:space="preserve">
          <source>It is important that all connections to the same database file use the same locking protocol. If one application is using POSIX advisory locks and another application is using dot-file locking, then the two applications will not see each other's locks and will not be able to coordinate database access, possibly leading to database corruption.</source>
          <target state="translated">Важно,чтобы все соединения к одному и тому же файлу БД использовали один и тот же протокол блокировки.Если одно приложение использует POSIX-советование блокировок,а другое приложение использует точечную блокировку файлов,то эти два приложения не будут видеть блокировки друг друга и не смогут координировать доступ к базе данных,что может привести к повреждению базы данных.</target>
        </trans-unit>
        <trans-unit id="8c1111b9c3326c8dd11b23932594b685a7b1d3f7" translate="yes" xml:space="preserve">
          <source>It is important to note that changing versions of SQLite might cause changes in query plans. The same version of SQLite will always pick the same query plan, but if you relink your application to use a different version of SQLite, then query plans might change. In rare cases, an SQLite version change might lead to a performance regression. This is one reason you should consider statically linking your applications against SQLite rather than use a system-wide SQLite shared library which might change without your knowledge or control.</source>
          <target state="translated">Важно отметить,что изменение версий SQLite может привести к изменению планов запросов.Одна и та же версия SQLite всегда будет выбирать один и тот же план запросов,но если перекомпоновать приложение под другую версию SQLite,то планы запросов могут измениться.В редких случаях изменение версии SQLite может привести к регрессии производительности.Это одна из причин,по которой следует подумать о статическом связывании приложений с SQLite,а не об использовании общесистемной разделяемой библиотеки SQLite,которая может измениться без вашего ведома и контроля.</target>
        </trans-unit>
        <trans-unit id="2fb1bf740043ac6cffabf7ccc0393c49b8d377d2" translate="yes" xml:space="preserve">
          <source>It is important to realize that neither &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec()&lt;/a&gt; nor &lt;a href=&quot;c3ref/free_table&quot;&gt;sqlite3_get_table()&lt;/a&gt; do anything that cannot be accomplished using the core routines. In fact, these wrappers are implemented purely in terms of the core routines.</source>
          <target state="translated">Важно понимать, что ни &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec (),&lt;/a&gt; ни &lt;a href=&quot;c3ref/free_table&quot;&gt;sqlite3_get_table () не&lt;/a&gt; делают ничего, что не может быть выполнено с помощью основных процедур. Фактически, эти оболочки реализованы исключительно в терминах основных подпрограмм.</target>
        </trans-unit>
        <trans-unit id="e6f1d24d369dd36a94bbbfa574744f4d470ce689" translate="yes" xml:space="preserve">
          <source>It is important to store all pages of a sector in the rollback journal in order to prevent database corruption following a power loss while writing the sector. Suppose that pages 1, 2, 3, and 4 are all stored in sector 1 and that page 2 is modified. In order to write the changes to page 2, the underlying hardware must also rewrite the content of pages 1, 3, and 4 since the hardware must write the complete sector. If this write operation is interrupted by a power outage, one or more of the pages 1, 3, or 4 might be left with incorrect data. Hence, to avoid lasting corruption to the database, the original content of all of those pages must be contained in the rollback journal.</source>
          <target state="translated">Важно хранить все страницы сектора в журнале отката,чтобы предотвратить повреждение базы данных после потери электроэнергии при записи сектора.Предположим,что все страницы 1,2,3 и 4 хранятся в секторе 1,а страница 2 изменяется.Для того чтобы написать изменения на странице 2,соответствующее &quot;железо&quot; должно также переписать содержание страниц 1,3 и 4,так как &quot;железо&quot; должно написать весь сектор.Если эта операция записи прерывается из-за отключения электричества,то на одной или нескольких страницах 1,3 или 4 могут остаться неверные данные.Следовательно,чтобы избежать длительного повреждения базы данных,оригинальное содержание всех этих страниц должно содержаться в журнале отката.</target>
        </trans-unit>
        <trans-unit id="128a48935084af31c9e8080ab5a8fbf025139866" translate="yes" xml:space="preserve">
          <source>It is important to understand these two different definitions for &quot;serverless&quot;. When a database claims to be &quot;serverless&quot;, be sure to discern whether they mean &quot;classic serverless&quot; or &quot;neo-serverless&quot;.</source>
          <target state="translated">Важно понимать эти два разных определения для &quot;безсерверного&quot;.Когда база данных утверждает,что она &quot;бессерверная&quot;,убедитесь,что они означают &quot;классический бессерверный&quot; или &quot;бессерверный нео&quot;.</target>
        </trans-unit>
        <trans-unit id="fa9dd62d3bfcaf75e4033204e51b41d31455c6e9" translate="yes" xml:space="preserve">
          <source>It is important to verify that the gcov test run and the second real test run both give the same output. Any differences in output indicate either the use of undefined or indeterminate behavior in the SQLite code (and hence a bug), or a bug in the compiler. Note that SQLite has, over the previous decade, encountered bugs in each of GCC, Clang, and MSVC. Compiler bugs, while rare, do happen, which is why it is so important to test the code in an as-delivered configuration.</source>
          <target state="translated">Важно убедиться,что тест gcov и второй реальный тест дают один и тот же результат.Любые различия в выводимых данных указывают либо на использование неопределенного или неопределенного поведения в коде SQLite (и,следовательно,на ошибку),либо на ошибку в компиляторе.Обратите внимание,что за последнее десятилетие SQLite сталкивался с ошибками в каждом из GCC,Clang и MSVC.Ошибки компилятора,хотя и встречаются редко,но случаются,поэтому так важно тестировать код в конфигурации &quot;как есть&quot;.</target>
        </trans-unit>
        <trans-unit id="d1cea258b6006ec069fad2e48bb8e0ae1aa954d2" translate="yes" xml:space="preserve">
          <source>It is impossible to test every possible combination of compile-time options for SQLite. But the following set of compile-time options is one configuration that is always fully tested.</source>
          <target state="translated">Невозможно проверить все возможные комбинации опций времени компиляции для SQLite.Но следующий набор опций времени компиляции-это одна конфигурация,которая всегда полностью тестируется.</target>
        </trans-unit>
        <trans-unit id="15edf0a6c6c69dc4fe559f59d8b017e98f300472" translate="yes" xml:space="preserve">
          <source>It is impractical to do crash testing using real power failures, of course, and so crash testing is done in simulation. An alternative &lt;a href=&quot;c3ref/vfs&quot;&gt;Virtual File System&lt;/a&gt; is inserted that allows the test harness to simulate the state of the database file following a crash.</source>
          <target state="translated">Конечно, нецелесообразно проводить краш-тестирование с использованием реальных отказов питания, поэтому краш-тестирование проводится в симуляции. Добавлена ​​альтернативная &lt;a href=&quot;c3ref/vfs&quot;&gt;виртуальная файловая система,&lt;/a&gt; которая позволяет тестовой системе имитировать состояние файла базы данных после сбоя.</target>
        </trans-unit>
        <trans-unit id="e1d5ef237a2a6e6403153de4b153927de75448b8" translate="yes" xml:space="preserve">
          <source>It is not an error if the named table does not exist in the database. Nor is it an error if the named table does not have a PRIMARY KEY. However, no changes will be recorded in either of these scenarios.</source>
          <target state="translated">Это не является ошибкой,если именованная таблица не существует в БД.Это также не ошибка,если именованная таблица не имеет PRIMARY KEY.Однако ни в одном из этих сценариев изменения записываться не будут.</target>
        </trans-unit>
        <trans-unit id="d49fdf0ef1b4c639114a4ac63de04efc40c67c48" translate="yes" xml:space="preserve">
          <source>It is not an error to create a table that has the same name as an existing &lt;a href=&quot;lang_createtrigger&quot;&gt;trigger&lt;/a&gt;.</source>
          <target state="translated">Создание таблицы с тем же именем, что и существующий &lt;a href=&quot;lang_createtrigger&quot;&gt;триггер,&lt;/a&gt; не является ошибкой .</target>
        </trans-unit>
        <trans-unit id="8aaf6c77de556f14a491171c58f28d211cfbc9d4" translate="yes" xml:space="preserve">
          <source>It is not commonly useful to evaluate the &lt;em&gt;exact&lt;/em&gt; same SQL statement more than once. More often, one wants to evaluate similar statements. For example, you might want to evaluate an INSERT statement multiple times with different values. Or you might want to evaluate the same query multiple times using a different key in the WHERE clause. To accommodate this, SQLite allows SQL statements to contain &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameters&lt;/a&gt; which are &quot;bound&quot; to values prior to being evaluated. These values can later be changed and the same &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; can be evaluated a second time using the new values.</source>
          <target state="translated">Это обычно не полезно оценить &lt;em&gt;точно&lt;/em&gt; тот же оператор SQL более чем один раз. Чаще хочется оценить подобные утверждения. Например, вы можете захотеть несколько раз оценить оператор INSERT с разными значениями. Или вы можете захотеть оценить один и тот же запрос несколько раз, используя другой ключ в предложении WHERE. Чтобы приспособиться к этому, SQLite позволяет операторам SQL содержать &lt;a href=&quot;lang_expr#varparam&quot;&gt;параметры,&lt;/a&gt; которые &amp;laquo;привязаны&amp;raquo; к значениям до их оценки. Эти значения могут быть позже изменены, и тот же &lt;a href=&quot;c3ref/stmt&quot;&gt;подготовленный оператор&lt;/a&gt; может быть оценен во второй раз с использованием новых значений.</target>
        </trans-unit>
        <trans-unit id="8de5c77745aab508a14fca7f3c047cc5a41b83c4" translate="yes" xml:space="preserve">
          <source>It is not impossible to find the descendents of a check-in in Git. It is merely difficult. For example, there is a &lt;a href=&quot;https://stackoverflow.com/questions/27960605/find-all-the-direct-descendants-of-a-given-commit#27962018&quot;&gt;stackoverflow page&lt;/a&gt; showing the command sequence for finding the descendents of a check-in in unix:</source>
          <target state="translated">В Git возможно найти потомков регистрации. Это просто сложно. Например, есть &lt;a href=&quot;https://stackoverflow.com/questions/27960605/find-all-the-direct-descendants-of-a-given-commit#27962018&quot;&gt;страница stackoverflow,&lt;/a&gt; показывающая последовательность команд для поиска потомков регистрации в unix:</target>
        </trans-unit>
        <trans-unit id="968af02ea707c660eea2edbc719717453c1c09b4" translate="yes" xml:space="preserve">
          <source>It is not necessary for every column of an index to appear in a WHERE clause term in order for that index to be used. But there cannot be gaps in the columns of the index that are used. Thus for the example index above, if there is no WHERE clause term that constraints column c, then terms that constrain columns a and b can be used with the index but not terms that constraint columns d through z. Similarly, index columns will not normally be used (for indexing purposes) if they are to the right of a column that is constrained only by inequalities. (See the &lt;a href=&quot;optoverview#skipscan&quot;&gt;skip-scan optimization&lt;/a&gt; below for the exception.)</source>
          <target state="translated">Необязательно, чтобы каждый столбец индекса появлялся в термине предложения WHERE, чтобы этот индекс можно было использовать. Но в используемых столбцах индекса не может быть пробелов. Таким образом, для приведенного выше примера индекса, если нет термина предложения WHERE, ограничивающего столбец c, тогда термины, которые ограничивают столбцы a и b, могут использоваться с индексом, но не термины, которые ограничивают столбцы с d по z. Точно так же столбцы индекса обычно не используются (для целей индексации), если они находятся справа от столбца, который ограничен только неравенствами. (Для исключения см. &lt;a href=&quot;optoverview#skipscan&quot;&gt;Оптимизацию пропуска сканирования&lt;/a&gt; ниже.)</target>
        </trans-unit>
        <trans-unit id="91c4a366eb8b7036569a617f444657bfe2829b75" translate="yes" xml:space="preserve">
          <source>It is not necessary to delete a session object after extracting a changeset or patchset from it. It can be left attached to the database handle and will continue monitoring for changes on the configured tables as before. However, if &lt;a href=&quot;session/sqlite3session_changeset&quot;&gt;sqlite3session_changeset()&lt;/a&gt; or &lt;a href=&quot;session/sqlite3session_patchset&quot;&gt;sqlite3session_patchset()&lt;/a&gt; is called a second time on a session object, the changeset or patchset will contain &lt;em&gt;all&lt;/em&gt; changes that have taken place on the connection since the session was created. In other words, a session object is not reset or zeroed by a call to sqlite3session_changeset() or sqlite3session_patchset().</source>
          <target state="translated">Нет необходимости удалять объект сеанса после извлечения из него набора изменений или патчей. Его можно оставить прикрепленным к дескриптору базы данных, и он будет продолжать отслеживать изменения в настроенных таблицах, как и раньше. Однако, если &lt;a href=&quot;session/sqlite3session_changeset&quot;&gt;sqlite3session_changeset ()&lt;/a&gt; или &lt;a href=&quot;session/sqlite3session_patchset&quot;&gt;sqlite3session_patchset ()&lt;/a&gt; вызывается второй раз для объекта сеанса, набор изменений или набор исправлений будет содержать &lt;em&gt;все&lt;/em&gt; изменения, которые произошли в соединении с момента создания сеанса. Другими словами, объект сеанса не сбрасывается или не обнуляется вызовом sqlite3session_changeset () или sqlite3session_patchset ().</target>
        </trans-unit>
        <trans-unit id="670d42dfe457729d9823abd17b04a227c0f7995a" translate="yes" xml:space="preserve">
          <source>It is not necessary to increment the change counter in the database header for transactions after the first transaction. This will often save a write of page one to both the rollback journal and the main database file.</source>
          <target state="translated">Нет необходимости увеличивать счетчик изменений в заголовке БД для транзакций после первой транзакции.Часто это позволяет сохранить запись первой страницы как в журнал отката,так и в основной файл БД.</target>
        </trans-unit>
        <trans-unit id="2403c6f4220d7ab7621d951d5ca316ce8bb167ec" translate="yes" xml:space="preserve">
          <source>It is not necessary to retrieve data in the format specify by sqlite3_column_type(). If a different format is requested, the data is converted automatically.</source>
          <target state="translated">Нет необходимости извлекать данные в формате,указанном функцией sqlite3_column_type().Если запрашивается другой формат,данные преобразуются автоматически.</target>
        </trans-unit>
        <trans-unit id="900bad887efaa153c1a2b75294545475e3b1d504" translate="yes" xml:space="preserve">
          <source>It is not possible for a single FTS query to return rows with different languageid values. The results of adding WHERE clauses that use other operators (e.g. lid!=5, or lid&amp;lt;=5) are undefined.</source>
          <target state="translated">Один запрос FTS не может возвращать строки с разными значениями languageid. Результаты добавления предложений WHERE, использующих другие операторы (например, lid! = 5 или lid &amp;lt;= 5), не определены.</target>
        </trans-unit>
        <trans-unit id="0859fe8615c2125c6e219976b0af5affb3b3243b" translate="yes" xml:space="preserve">
          <source>It is not possible to &lt;a href=&quot;lang_altertable#altertabaddcol&quot;&gt;ALTER TABLE ADD COLUMN&lt;/a&gt; a STORED column. One can add a VIRTUAL column, however.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d7041428ac37cb2fe5a20d78347fe7eb6acfbe1" translate="yes" xml:space="preserve">
          <source>It is not possible to UPDATE or DELETE a row stored in a contentless FTS4 table. Attempting to do so is an error.</source>
          <target state="translated">Невозможно ОБНАРУЖИВАТЬ или УДАЛИТЬ строку,хранящуюся в бесконтактной таблице FTS4.Попытка сделать это является ошибкой.</target>
        </trans-unit>
        <trans-unit id="9e4665d3e6caf2e43eb0161671eab0b61b62c13a" translate="yes" xml:space="preserve">
          <source>It is not possible to change the &lt;a href=&quot;pragma#pragma_page_size&quot;&gt;page_size&lt;/a&gt; after entering WAL mode, either on an empty database or by using &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; or by restoring from a backup using the &lt;a href=&quot;backup&quot;&gt;backup API&lt;/a&gt;. You must be in a rollback journal mode to change the page size.</source>
          <target state="translated">Невозможно изменить &lt;a href=&quot;pragma#pragma_page_size&quot;&gt;page_size&lt;/a&gt; после входа в режим WAL ни в пустой базе данных, ни с помощью &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM,&lt;/a&gt; ни путем восстановления из резервной копии с помощью &lt;a href=&quot;backup&quot;&gt;API резервного копирования&lt;/a&gt; . Чтобы изменить размер страницы, вы должны находиться в режиме журнала отката.</target>
        </trans-unit>
        <trans-unit id="deaab8f44371f477a4e7e55d31601e0d0d6a03fb" translate="yes" xml:space="preserve">
          <source>It is not possible to enable or disable foreign key constraints in the middle of a &lt;a href=&quot;lang_transaction&quot;&gt;multi-statement transaction&lt;/a&gt; (when SQLite is not in &lt;a href=&quot;c3ref/get_autocommit&quot;&gt;autocommit mode&lt;/a&gt;). Attempting to do so does not return an error; it simply has no effect.</source>
          <target state="translated">Невозможно включить или отключить ограничения внешнего ключа в середине &lt;a href=&quot;lang_transaction&quot;&gt;транзакции&lt;/a&gt; с несколькими операторами (когда SQLite не находится в &lt;a href=&quot;c3ref/get_autocommit&quot;&gt;режиме автоматической фиксации&lt;/a&gt; ). Попытка сделать это не вернет ошибку; это просто не действует.</target>
        </trans-unit>
        <trans-unit id="59d7023d400b2c4a42c25e47c1d1dae5bdb83625" translate="yes" xml:space="preserve">
          <source>It is not possible to use the &quot;ALTER TABLE ... ADD COLUMN&quot; syntax to add a column that includes a REFERENCES clause, unless the default value of the new column is NULL. Attempting to do so returns an error.</source>
          <target state="translated">Невозможно использовать &quot;АЛЬТЕР-ТАБЛИЦУ&quot; ...ADD COLUMN&quot; для добавления столбца,включающего пункт REFERENCES,если только значение по умолчанию нового столбца не равно NULL.Попытка сделать это возвращает ошибку.</target>
        </trans-unit>
        <trans-unit id="912f58b54e2d4f955145072d5727d208f46d87cf" translate="yes" xml:space="preserve">
          <source>It is not safe to read or modify this variable in more than one thread at a time. It is not safe to read or modify this variable if a &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; is being used at the same time in a separate thread. It is intended that this variable be set once as part of process initialization and before any SQLite interface routines have been called and that this variable remain unchanged thereafter.</source>
          <target state="translated">Прочитать или изменить эту переменную более чем в одном потоке одновременно небезопасно. Прочитать или изменить эту переменную небезопасно, если &lt;a href=&quot;#sqlite3&quot;&gt;соединение&lt;/a&gt; с базой данных используется одновременно в отдельном потоке. Предполагается, что эта переменная будет установлена ​​один раз как часть инициализации процесса и до того, как будут вызваны какие-либо процедуры интерфейса SQLite, и что эта переменная после этого останется неизменной.</target>
        </trans-unit>
        <trans-unit id="903cea61d0db784ec27805bae69d5dea09532edb" translate="yes" xml:space="preserve">
          <source>It is not safe to read or modify this variable in more than one thread at a time. It is not safe to read or modify this variable if a &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; is being used at the same time in a separate thread. It is intended that this variable be set once as part of process initialization and before any SQLite interface routines have been called and that this variable remain unchanged thereafter.</source>
          <target state="translated">Прочитать или изменить эту переменную более чем в одном потоке одновременно небезопасно. Прочитать или изменить эту переменную небезопасно, если &lt;a href=&quot;sqlite3&quot;&gt;соединение&lt;/a&gt; с базой данных используется одновременно в отдельном потоке. Предполагается, что эта переменная будет установлена ​​один раз как часть инициализации процесса и до того, как будут вызваны какие-либо процедуры интерфейса SQLite, и что эта переменная после этого останется неизменной.</target>
        </trans-unit>
        <trans-unit id="159cf71be6e4a6830ae2567917f78113abca0955" translate="yes" xml:space="preserve">
          <source>It is ok to make multiple entries for the same word as long as each entry has a different soundslike value. Note that if no soundslike value is specified, the soundslike defaults to the word itself.</source>
          <target state="translated">Можно делать несколько записей для одного и того же слова,если каждая запись имеет разное звуковое значение.Обратите внимание,что если звуковое значение не указано,звуковое значение по умолчанию будет соответствовать самому слову.</target>
        </trans-unit>
        <trans-unit id="42b6da3d325a27b4a54e5028535caa1fb0d83d7a" translate="yes" xml:space="preserve">
          <source>It is particularly important to use an entry point name that is based on the extension filename, rather than the generic &quot;sqlite3_extension_init&quot; entry point name, if you will be statically linking two or more extensions. If you use the generic name, there will be multiple definitions of the same symbol and the link will fail.</source>
          <target state="translated">Особенно важно использовать имя точки входа,которое основано на имени файла расширения,а не на общем имени точки входа &quot;sqlite3_extension_init&quot;,если вы будете статически связывать два или более расширения.Если вы используете общее имя,то будет несколько определений одного и того же символа,и ссылка будет неудачной.</target>
        </trans-unit>
        <trans-unit id="1f5372992ab68655b726354d1de85f6b9510df2c" translate="yes" xml:space="preserve">
          <source>It is permitted to register multiple implementations of the same functions with the same name but with either differing numbers of arguments or differing preferred text encodings. SQLite will use the implementation that most closely matches the way in which the SQL function is used. A function implementation with a non-negative nArg parameter is a better match than a function implementation with a negative nArg. A function where the preferred text encoding matches the database encoding is a better match than a function where the encoding is different. A function where the encoding difference is between UTF16le and UTF16be is a closer match than a function where the encoding difference is between UTF8 and UTF16.</source>
          <target state="translated">Разрешается регистрировать несколько реализаций одних и тех же функций с одним и тем же именем,но либо с разным количеством аргументов,либо с разными предпочтительными текстовыми кодировками.SQLite будет использовать реализацию,наиболее точно соответствующую способу использования функции SQL.Реализация функции с неотрицательным параметром nArg лучше подходит,чем реализация функции с отрицательным параметром nArg.Функция,в которой предпочитаемая текстовая кодировка совпадает с кодировкой БД,лучше подходит,чем функция,в которой кодировка отличается.Функция,где разница кодировок между UTF16le и UTF16be ближе,чем функция,где разница кодировок между UTF8 и UTF16.</target>
        </trans-unit>
        <trans-unit id="d335c80330cdb9262d358bd293d73594c1829762" translate="yes" xml:space="preserve">
          <source>It is possible for the library compile-time C preprocessor symbol &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; to override this pragma setting. The following table summarizes the interaction of the &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; preprocessor macro and the temp_store pragma:</source>
          <target state="translated">Символ препроцессора C времени компиляции &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; может переопределить эту настройку прагмы . В следующей таблице суммировано взаимодействие &lt;a href=&quot;compile#temp_store&quot;&gt;макроса&lt;/a&gt; препроцессора SQLITE_TEMP_STORE и прагмы temp_store:</target>
        </trans-unit>
        <trans-unit id="882d45108ae3506a475e868a2ed67d0f5c2e5629" translate="yes" xml:space="preserve">
          <source>It is possible that future enhancements to the prover might enable it to recognize that NULL inputs to certain built-in functions always result in a NULL answer. But not all built-in functions have that property (for example &lt;a href=&quot;lang_corefunc#coalesce&quot;&gt;coalesce()&lt;/a&gt;) and, of course, the prover will never be able to reason about &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="105eb1a524704db6ebed7c523dd9971899853505" translate="yes" xml:space="preserve">
          <source>It is possible that future enhancements to the prover might enable it to recognize that NULL inputs to certain built-in functions always result in a NULL answer. But not all built-in functions have that property (for example &lt;a href=&quot;lang_corefunc#coalesce&quot;&gt;coalesce()&lt;/a&gt;) and, of course, the prover will never be able to reason about &lt;a href=&quot;c3ref/create_function&quot;&gt;application-defined SQL functions&lt;/a&gt;.</source>
          <target state="translated">Возможно, что будущие усовершенствования программы доказательства могут позволить ему распознавать, что входные данные NULL для определенных встроенных функций всегда приводят к ответу NULL. Но не все встроенные функции обладают этим свойством (например, &lt;a href=&quot;lang_corefunc#coalesce&quot;&gt;coalesce ()&lt;/a&gt; ), и, конечно же, доказывающий никогда не сможет рассуждать о &lt;a href=&quot;c3ref/create_function&quot;&gt;функциях SQL, определяемых приложением&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2be5eee10a74ce784db26ece955361d8533b48cb" translate="yes" xml:space="preserve">
          <source>It is possible to build a special &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt; that will work with a predetermined set of SQLITE_OMIT_... options. Instructions for doing so can be found with the &lt;a href=&quot;compile#omitfeatures&quot;&gt;SQLITE_OMIT_... documentation&lt;/a&gt;.</source>
          <target state="translated">Можно создать специальное &lt;a href=&quot;amalgamation&quot;&gt;объединение,&lt;/a&gt; которое будет работать с заранее определенным набором параметров SQLITE_OMIT _.... Инструкции по этим вопросам можно найти с &lt;a href=&quot;compile#omitfeatures&quot;&gt;SQLITE_OMIT _... документации&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="321373a36254200d34f2e6be79e9dd835a4c4ba3" translate="yes" xml:space="preserve">
          <source>It is possible to create multiple session objects attached to a single database handle.</source>
          <target state="translated">Можно создать несколько объектов сеанса,прикрепленных к одному дескриптору базы данных.</target>
        </trans-unit>
        <trans-unit id="bed5d040f0bed9644c8d2600cb5ecf6e91531170" translate="yes" xml:space="preserve">
          <source>It is possible to extend custom or pile-of-files formats too, of course, but doing is often much harder. If indices are added, then all application code that changes the corresponding tables must be located and modified to keep those indices up-to-date. If columns are added, then all application code that accesses the corresponding table must be located and modified to take into account the new columns.</source>
          <target state="translated">Конечно,можно расширить и пользовательский формат или формат &quot;кучи файлов&quot;,но зачастую это гораздо сложнее сделать.Если добавляются индексы,то весь код приложения,который изменяет соответствующие таблицы,должен быть расположен и модифицирован,чтобы поддерживать эти индексы в актуальном состоянии.Если добавляются столбцы,то весь код приложения,получающего доступ к соответствующей таблице,должен быть расположен и изменен с учетом новых столбцов.</target>
        </trans-unit>
        <trans-unit id="e6a04c27b0773734dfa33829ac44458f0f513a43" translate="yes" xml:space="preserve">
          <source>It is possible to have an aggregate function with the same name as a simple function, as long as the number of arguments for the two forms of the function are different. For example, the &lt;a href=&quot;lang_aggfunc#maxggunc&quot;&gt;max()&lt;/a&gt; function with a single argument is an aggregate and the &lt;a href=&quot;lang_corefunc#maxoreunc&quot;&gt;max()&lt;/a&gt; function with two or more arguments is a simple function. Aggregate functions can usually also be used as window functions.</source>
          <target state="translated">Возможно иметь агрегатную функцию с тем же именем, что и у простой функции, если количество аргументов для двух форм функции различно. Например, функция &lt;a href=&quot;lang_aggfunc#maxggunc&quot;&gt;max ()&lt;/a&gt; с одним аргументом является агрегатом, а функция &lt;a href=&quot;lang_corefunc#maxoreunc&quot;&gt;max ()&lt;/a&gt; с двумя или более аргументами является простой функцией. Агрегатные функции обычно также могут использоваться как оконные.</target>
        </trans-unit>
        <trans-unit id="79fc85e42448050747bff9c78bdebc62767b73c0" translate="yes" xml:space="preserve">
          <source>It is possible to make SQLite treat NULLs as distinct for the purposes of the SELECT DISTINCT and UNION. To do so, one should change the value of the NULL_ALWAYS_DISTINCT #define in the &lt;code&gt;sqliteInt.h&lt;/code&gt; source file and recompile.</source>
          <target state="translated">Можно заставить SQLite обрабатывать NULL как разные для целей SELECT DISTINCT и UNION. Для этого необходимо изменить значение NULL_ALWAYS_DISTINCT #define в исходном файле &lt;code&gt;sqliteInt.h&lt;/code&gt; и перекомпилировать.</target>
        </trans-unit>
        <trans-unit id="ef8babc1f36de58a996ade599caa2a6556653b1a" translate="yes" xml:space="preserve">
          <source>It is possible to tell whether or not the 'merge' command found any b-trees to merge together by checking the value returned by the &lt;a href=&quot;c3ref/total_changes&quot;&gt;sqlite3_total_changes()&lt;/a&gt; API before and after the command is executed. If the difference between the two values is 2 or greater, then work was performed. If the difference is less than 2, then the 'merge' command was a no-op. In this case there is no reason to execute the same 'merge' command again, at least until after the FTS table is next updated.</source>
          <target state="translated">Можно определить, нашла ли команда 'merge' какие-либо b-деревья для слияния, проверив значение, возвращаемое API &lt;a href=&quot;c3ref/total_changes&quot;&gt;sqlite3_total_changes ()&lt;/a&gt; до и после выполнения команды. Если разница между двумя значениями составляет 2 или больше, значит работа выполнена. Если разница меньше 2, то команда &amp;laquo;слияние&amp;raquo; не выполнялась. В этом случае нет причин для повторного выполнения той же команды &amp;laquo;слияния&amp;raquo;, по крайней мере, до следующего обновления таблицы FTS.</target>
        </trans-unit>
        <trans-unit id="e63e80c9bba9974f9e6774ae97788b65cf7107ad" translate="yes" xml:space="preserve">
          <source>It is possible to write into the &quot;t2&quot; table, thus changing the content of the index. But doing so will get the &quot;t1bc&quot; index out of synchronization with its parent table &quot;t1&quot;. An out-of-sync index can result in incorrect query results.</source>
          <target state="translated">Можно записать в таблицу &quot;t2&quot;,тем самым изменив содержание индекса.Но при этом индекс &quot;t1bc&quot; выйдет из синхронизации с его родительской таблицей &quot;t1&quot;.Несинхронизированный индекс может привести к некорректным результатам запроса.</target>
        </trans-unit>
        <trans-unit id="0822da1b538a191177f07ef1dc3b36f0cff1be87" translate="yes" xml:space="preserve">
          <source>It is recommended that applications respond to the errors listed above by explicitly issuing a ROLLBACK command. If the transaction has already been rolled back automatically by the error response, then the ROLLBACK command will fail with an error, but no harm is caused by this.</source>
          <target state="translated">Рекомендуется,чтобы приложения отвечали на перечисленные выше ошибки явным выпуском команды ROLLBACK.Если транзакция уже откатилась автоматически в ответ на ошибку,то команда ROLLBACK не будет выполнена с ошибкой,но это не причинит никакого вреда.</target>
        </trans-unit>
        <trans-unit id="7b7eb3618faa363b4bb6cb76587e213a07280f4c" translate="yes" xml:space="preserve">
          <source>It is safe to call this routine from a thread different from the thread that is currently running the database operation. But it is not safe to call this routine with a &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; that is closed or might close before sqlite3_interrupt() returns.</source>
          <target state="translated">Эту процедуру можно безопасно вызывать из потока, отличного от потока, в котором в данный момент выполняется операция с базой данных. Но небезопасно вызывать эту процедуру при закрытом или закрытом &lt;a href=&quot;#sqlite3&quot;&gt;соединении&lt;/a&gt; с базой данных до возврата sqlite3_interrupt ().</target>
        </trans-unit>
        <trans-unit id="0d70d917087b8b111a765ae7a55cfbd2640b316e" translate="yes" xml:space="preserve">
          <source>It is safe to call this routine from a thread different from the thread that is currently running the database operation. But it is not safe to call this routine with a &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; that is closed or might close before sqlite3_interrupt() returns.</source>
          <target state="translated">Эту процедуру можно безопасно вызывать из потока, отличного от потока, в котором в данный момент выполняется операция с базой данных. Но небезопасно вызывать эту процедуру при закрытом или закрытом &lt;a href=&quot;sqlite3&quot;&gt;соединении&lt;/a&gt; с базой данных до возврата sqlite3_interrupt ().</target>
        </trans-unit>
        <trans-unit id="d9e98c95444e8fd3d643f309806f8f5b2d312406" translate="yes" xml:space="preserve">
          <source>It is safe to execute SQL statements, including those that write to the table that the callback related to, from within the xConflict callback. This can be used to further customize the application's conflict resolution strategy.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7155cc55f906067b466a3957abc2b2fa5ca703ab" translate="yes" xml:space="preserve">
          <source>It is safe to execute SQL statements, including those that write to the table that the callback related to, from within the xConflict callback. This can be used to further customize the applications conflict resolution strategy.</source>
          <target state="translated">Безопасно выполнять SQL-операторы,в том числе и те,которые пишут в таблицу,с которой связан обратный вызов,из xConflict callback.Это может быть использовано для дальнейшей настройки стратегии разрешения конфликтов приложений.</target>
        </trans-unit>
        <trans-unit id="33153f14bd397b5e62d91fe18b2589aae1781966" translate="yes" xml:space="preserve">
          <source>It is sometimes convenient for SQLite extensions to communicate non-SQL values between subcomponents or between the extension and the application. Some examples:</source>
          <target state="translated">Для расширений SQLite иногда удобно обмениваться не-SQL-значениями между подкомпонентами или между расширением и приложением.Некоторые примеры:</target>
        </trans-unit>
        <trans-unit id="4e37312abd7d96cc7759f842b46f93a1a662f8a0" translate="yes" xml:space="preserve">
          <source>It is still the responsibility of the user to ensure that the contents of an external content FTS5 table are kept up to date with the content table. One way to do this is with triggers. For example:</source>
          <target state="translated">Пользователь по-прежнему несет ответственность за то,чтобы содержание таблицы внешнего контента FTS5 было актуальным.Один из способов сделать это-с помощью триггеров.Например:</target>
        </trans-unit>
        <trans-unit id="9c7272134156136dee6648bc42ced66fabf0b75c" translate="yes" xml:space="preserve">
          <source>It is the nature of the Guttman R-Tree algorithm that any write might radically restructure the tree, and in the process change the scan order of the nodes. For this reason, it is not generally possible to modify the R-Tree in the middle of a query of the R-Tree. Attempts to do so will fail with a &lt;a href=&quot;rescode#locked&quot;&gt;SQLITE_LOCKED&lt;/a&gt; &quot;database table is locked&quot; error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5653d5d90f75b604cccae96a448a1866fdfa38fe" translate="yes" xml:space="preserve">
          <source>It is the responsibility of the caller to eventually call sqlite3_free() on the *ppOut pointer to free the buffer allocation following a successful call to this function.</source>
          <target state="translated">В обязанности вызывающего абонента входит,в конечном счете,вызов sqlite3_free()по указателю *ppOut,чтобы освободить выделение буфера после успешного вызова этой функции.</target>
        </trans-unit>
        <trans-unit id="ea70438336584a95d4e17716f1df0d6b713aeb3b" translate="yes" xml:space="preserve">
          <source>It is the responsibility of the caller to eventually destroy the iterator by passing it to &lt;a href=&quot;#sqlite3changeset_finalize&quot;&gt;sqlite3changeset_finalize()&lt;/a&gt;. The buffer containing the changeset (pChangeset) must remain valid until after the iterator is destroyed.</source>
          <target state="translated">Вызывающий &lt;a href=&quot;#sqlite3changeset_finalize&quot;&gt;объект обязан&lt;/a&gt; в конечном итоге уничтожить итератор, передав его в sqlite3changeset_finalize () . Буфер, содержащий набор изменений (pChangeset), должен оставаться действительным до тех пор, пока итератор не будет уничтожен.</target>
        </trans-unit>
        <trans-unit id="f0493c91af19ce8153b8e56f3f8a534dd5019c91" translate="yes" xml:space="preserve">
          <source>It is the responsibility of the caller to eventually destroy the iterator by passing it to &lt;a href=&quot;sqlite3changeset_finalize&quot;&gt;sqlite3changeset_finalize()&lt;/a&gt;. The buffer containing the changeset (pChangeset) must remain valid until after the iterator is destroyed.</source>
          <target state="translated">Вызывающий &lt;a href=&quot;sqlite3changeset_finalize&quot;&gt;объект обязан&lt;/a&gt; в конечном итоге уничтожить итератор, передав его в sqlite3changeset_finalize () . Буфер, содержащий набор изменений (pChangeset), должен оставаться действительным до тех пор, пока итератор не будет уничтожен.</target>
        </trans-unit>
        <trans-unit id="6d23d845a723659b2b2994a8ad4c9862067cda40" translate="yes" xml:space="preserve">
          <source>It is true that applications sometimes import complete binary SQLite database files from untrusted sources, and such imports could present a possible attack vector. However, those code paths in SQLite are limited and are extremely well tested. And pre-validation routines are available to applications that want to read untrusted databases that can help detect possible attacks prior to use.</source>
          <target state="translated">Правда,иногда приложения импортируют полные бинарные файлы базы данных SQLite из недоверенных источников,и такой импорт может представлять собой возможный вектор атаки.Однако такие пути кода в SQLite ограничены и очень хорошо протестированы.А для приложений,которые хотят читать недоверенные базы данных,доступны процедуры предварительной проверки,которые могут помочь обнаружить возможные атаки до их использования.</target>
        </trans-unit>
        <trans-unit id="c6122ba39afe0e09e2d2af761ca27152501399d2" translate="yes" xml:space="preserve">
          <source>It is usually an error to attempt to create a new table in a database that already contains a table, index or view of the same name. However, if the &quot;IF NOT EXISTS&quot; clause is specified as part of the CREATE TABLE statement and a table or view of the same name already exists, the CREATE TABLE command simply has no effect (and no error message is returned). An error is still returned if the table cannot be created because of an existing index, even if the &quot;IF NOT EXISTS&quot; clause is specified.</source>
          <target state="translated">Как правило,это ошибка при попытке создать новую таблицу в базе данных,которая уже содержит таблицу,индекс или представление с тем же именем.Однако,если в операторе CREATE TABLE указано &quot;IF NOT EXISTS&quot; и таблица или представление с таким же именем уже существует,команда CREATE TABLE просто не имеет никакого эффекта (и сообщение об ошибке не возвращается).Ошибка все равно возвращается,если таблица не может быть создана из-за существующего индекса,даже если указано выражение &quot;IF NOT EXISTS&quot;.</target>
        </trans-unit>
        <trans-unit id="6955fa966a557f5231f3a39e108f89afbdbb1b83" translate="yes" xml:space="preserve">
          <source>It may not be used on a database that contains &lt;a href=&quot;expridx&quot;&gt;indexes on expressions&lt;/a&gt;.</source>
          <target state="translated">Его нельзя использовать в базе данных, содержащей &lt;a href=&quot;expridx&quot;&gt;индексы по выражениям&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="16a2200cb76f9664274f3ef9da8045211e14cc43" translate="yes" xml:space="preserve">
          <source>It might be that there are conflicts in the merge. Conflicts occur when the same line of code was changed in different ways between circles (1) and (4) versus circles (2) and (3). The merge command will announce any conflicts and will include both versions of the conflicting lines in the output. You will need to bring up the files that contain conflicts and manually resolve the conflicts.</source>
          <target state="translated">Возможно,в слиянии есть конфликты.Конфликты возникают,когда одна и та же строка кода по-разному меняется между кругами (1)и (4)по сравнению с кругами (2)и (3).Команда слияния объявит о любых конфликтах и включит в вывод обе версии конфликтующих строк.Вам нужно будет вывести на экран файлы,содержащие конфликты,и разрешить их вручную.</target>
        </trans-unit>
        <trans-unit id="129a00b2ad750693913d2844d8acb7e806afdd09" translate="yes" xml:space="preserve">
          <source>It must not be possible to make the LIKE or GLOB operator true by having a numeric value (instead of a string or blob) on the left-hand side. This means that either:</source>
          <target state="translated">Нельзя сделать оператор LIKE или GLOB истинным,имея слева числовое значение (вместо строки или капли).Это означает,что и это тоже:</target>
        </trans-unit>
        <trans-unit id="48d86628c63409da486bd0d69fb891667a6d8475" translate="yes" xml:space="preserve">
          <source>It never hurts to run the VACUUM, even if you don't need it. If the database is in WAL mode, you should shutdown and reopen all database connections before continuing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e56780a95b18eed6f05e0be25053224b3c52ac99" translate="yes" xml:space="preserve">
          <source>It was necessary to move to version 3.0 to implement these features because each requires incompatible changes to the database file format. Other incompatible changes, such as a cleanup of the API, were introduced at the same time under the theory that it is best to get your incompatible changes out of the way all at once.</source>
          <target state="translated">Для реализации этих возможностей необходимо было перейти на версию 3.0,так как каждая из них требует несовместимых изменений формата файла базы данных.Другие несовместимые изменения,такие как очистка API,были введены одновременно с теорией о том,что лучше всего убрать несовместимые изменения с пути сразу.</target>
        </trans-unit>
        <trans-unit id="8d41777ca525f229dab6b56dd5c34598aff8efa5" translate="yes" xml:space="preserve">
          <source>It works with unicode (UTF8) text.</source>
          <target state="translated">Работает с текстом в кодировке Unicode (UTF8).</target>
        </trans-unit>
        <trans-unit id="829d920a492c6126eef1531c8e8c0e1ab7033bd1" translate="yes" xml:space="preserve">
          <source>Its master journal exists or the master journal name is an empty string, and</source>
          <target state="translated">Его главный журнал существует или имя главного журнала-пустая строка,и</target>
        </trans-unit>
        <trans-unit id="a9d92a1b4a228c7e648d8125ef5d3c71b3cd4ff7" translate="yes" xml:space="preserve">
          <source>Its size is greater than 512 bytes, and</source>
          <target state="translated">Его размер больше 512 байт,и</target>
        </trans-unit>
        <trans-unit id="0239a4728421bae8f8eeba1f3844a6c5e5e3d81b" translate="yes" xml:space="preserve">
          <source>Its super-journal exists or the super-journal name is an empty string, and</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73bd910d330560ea1012376a486871434fb0c82d" translate="yes" xml:space="preserve">
          <source>J. M. Robson. &quot;Bounds for Some Functions Concerning Dynamic Storage Allocation&quot;.</source>
          <target state="translated">J.М.Робсон.&quot;Ограничения для некоторых функций относительно динамического распределения хранилищ&quot;.</target>
        </trans-unit>
        <trans-unit id="9a3f6528f2606d1ed81f1e9f85b624a26b98cbbe" translate="yes" xml:space="preserve">
          <source>JOIN</source>
          <target state="translated">JOIN</target>
        </trans-unit>
        <trans-unit id="031a4e76f0b39d0df073d934da5fc48da8d737e5" translate="yes" xml:space="preserve">
          <source>JSON</source>
          <target state="translated">JSON</target>
        </trans-unit>
        <trans-unit id="935b885e280c10afb46d2bf45f85bbea09bc94ce" translate="yes" xml:space="preserve">
          <source>JSON support</source>
          <target state="translated">JSON поддержка</target>
        </trans-unit>
        <trans-unit id="69a65023a22e8f6d2ee1c6c6ee36c64ccb6d5c6d" translate="yes" xml:space="preserve">
          <source>Join order</source>
          <target state="translated">Присоединиться к заказу</target>
        </trans-unit>
        <trans-unit id="63acacbd536ebc7829ae48a83492249201168016" translate="yes" xml:space="preserve">
          <source>Join reordering is automatic and usually works well enough that programmers do not have to think about it, especially if &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; has been used to gather statistics about the available indices. But occasionally some hints from the programmer are needed. Consider, for example, the following schema:</source>
          <target state="translated">Изменение порядка объединения происходит автоматически и обычно работает достаточно хорошо, чтобы программистам не приходилось думать об этом, особенно если &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; использовался для сбора статистики о доступных индексах. Но иногда нужны подсказки от программиста. Рассмотрим, например, следующую схему:</target>
        </trans-unit>
        <trans-unit id="36cb6826dbbbacc9f0915d9e44ccb82925b04c72" translate="yes" xml:space="preserve">
          <source>Joins</source>
          <target state="translated">Joins</target>
        </trans-unit>
        <trans-unit id="742ad08bca9c2e1be08d58aae42e6201c809dcf9" translate="yes" xml:space="preserve">
          <source>Journal File Format</source>
          <target state="translated">Формат файла журнала</target>
        </trans-unit>
        <trans-unit id="debc03f25ef5600d2ed4edf18b01b3412bb71c87" translate="yes" xml:space="preserve">
          <source>Journal Header Format</source>
          <target state="translated">Формат заголовка журнала</target>
        </trans-unit>
        <trans-unit id="ccdedfc7a4a23f259c6823eed7a5e93d7a6e430f" translate="yes" xml:space="preserve">
          <source>Journal Record Format</source>
          <target state="translated">Формат журнала Формат записи</target>
        </trans-unit>
        <trans-unit id="683ff0cc3706704c295b1d1835a7e2e4c3a2a6b7" translate="yes" xml:space="preserve">
          <source>Journal of the Association for Computing Machinery</source>
          <target state="translated">Журнал Ассоциации компьютерной техники</target>
        </trans-unit>
        <trans-unit id="769726f4101068333430cd9eee0a56b7dfd75235" translate="yes" xml:space="preserve">
          <source>JournalMode</source>
          <target state="translated">JournalMode</target>
        </trans-unit>
        <trans-unit id="c0e70f1bd285ac28ec38cf9261dd9cf6df3840dd" translate="yes" xml:space="preserve">
          <source>Journalling a Database Page</source>
          <target state="translated">Регистрация страницы базы данных</target>
        </trans-unit>
        <trans-unit id="b576bd921c8bd5cb6e5720fc3c6797d3e02e8d08" translate="yes" xml:space="preserve">
          <source>Journalling a page</source>
          <target state="translated">Регистрация страницы</target>
        </trans-unit>
        <trans-unit id="84e304128c1076094ba7ee02aeb09745e71eaf53" translate="yes" xml:space="preserve">
          <source>Julian day number</source>
          <target state="translated">номер дня Юлиана</target>
        </trans-unit>
        <trans-unit id="1eba140fdd9c6860a1730c408e3064aa417ca2a3" translate="yes" xml:space="preserve">
          <source>Jump</source>
          <target state="translated">Jump</target>
        </trans-unit>
        <trans-unit id="5d84018241481efa31572e7a64ddf20102d5a735" translate="yes" xml:space="preserve">
          <source>Jump to P2 if the value in register P1 is False. The value is considered false if it has a numeric value of zero. If the value in P1 is NULL then take the jump if and only if P3 is non-zero.</source>
          <target state="translated">Перейдите к P2,если значение в регистре P1 является False.Значение считается ложным,если оно имеет числовое значение ноль.Если значение в P1 равно NULL,то прыжок выполняется,если и только если P3 ненулевое.</target>
        </trans-unit>
        <trans-unit id="c02affea77793c1c3281caf3fff7c025052fcd28" translate="yes" xml:space="preserve">
          <source>Jump to P2 if the value in register P1 is NULL.</source>
          <target state="translated">Переходите к P2,если значение в регистре P1 равно NULL.</target>
        </trans-unit>
        <trans-unit id="9d04284895be3aad627f0d99db148ecf0772d61d" translate="yes" xml:space="preserve">
          <source>Jump to P2 if the value in register P1 is not NULL.</source>
          <target state="translated">Переходите к P2,если значение в регистре P1 не NULL.</target>
        </trans-unit>
        <trans-unit id="38d677f93cf11ed33026afa36fe1f252297e13d5" translate="yes" xml:space="preserve">
          <source>Jump to P2 if the value in register P1 is true. The value is considered true if it is numeric and non-zero. If the value in P1 is NULL then take the jump if and only if P3 is non-zero.</source>
          <target state="translated">Перейдите к P2,если значение в регистре P1 истинно.Значение считается истинным,если оно числовое и ненулевое.Если значение в P1 равно NULL,то переходите к P2,если и только если P3 ненулевое.</target>
        </trans-unit>
        <trans-unit id="04a8d1cd1316034cf886277bf2c8dd963c76b71c" translate="yes" xml:space="preserve">
          <source>Jump to the instruction at address P1, P2, or P3 depending on whether in the most recent &lt;a href=&quot;opcode#Compare&quot;&gt;Compare&lt;/a&gt; instruction the P1 vector was less than equal to, or greater than the P2 vector, respectively.</source>
          <target state="translated">Переход к инструкции по адресу P1, P2 или P3 в зависимости от того, был ли в последней инструкции &lt;a href=&quot;opcode#Compare&quot;&gt;сравнения&lt;/a&gt; вектор P1 меньше или больше вектора P2 соответственно.</target>
        </trans-unit>
        <trans-unit id="029dc808e2fcf8db0d9a3400f04a64bf760921ba" translate="yes" xml:space="preserve">
          <source>Jump to the next instruction after the address in register P1. After the jump, register P1 becomes undefined.</source>
          <target state="translated">Перейти к следующей инструкции после адреса в регистре P1.После прыжка регистр P1 становится неопределенным.</target>
        </trans-unit>
        <trans-unit id="be91c2cd21e07ee8ceb31ed436dfe5c08c9a83b6" translate="yes" xml:space="preserve">
          <source>Just as there is the &quot;zip&quot; program to manage ZIP Archives, and the &quot;tar&quot; program to manage Tarballs, the &lt;a href=&quot;https://sqlite.org/sqlar&quot;&gt;&quot;sqlar&quot; program&lt;/a&gt; exists to manage SQL Archives. The &quot;sqlar&quot; program is able to create a new SQLite Archive, list the content of an existing archive, add or remove files from the archive, and/or extract files from the archive. A separate &quot;sqlarfs&quot; program is able to mount the SQLite Archive as a &lt;a href=&quot;https://github.com/libfuse/libfuse&quot;&gt;Fuse Filesystem&lt;/a&gt;.</source>
          <target state="translated">Так же, как существует программа &amp;laquo;zip&amp;raquo; для управления архивами ZIP и программа &amp;laquo;tar&amp;raquo; для управления архивами tar, существует &lt;a href=&quot;https://sqlite.org/sqlar&quot;&gt;программа &amp;laquo;sqlar&amp;raquo;&lt;/a&gt; для управления архивами SQL. Программа sqlar может создать новый архив SQLite, составить список содержимого существующего архива, добавить или удалить файлы из архива и / или извлечь файлы из архива. Отдельная программа sqlarfs может смонтировать архив SQLite как &lt;a href=&quot;https://github.com/libfuse/libfuse&quot;&gt;файловую&lt;/a&gt; систему Fuse .</target>
        </trans-unit>
        <trans-unit id="dd65c1b4b3e66e765523873bd29cf5d6d6838189" translate="yes" xml:space="preserve">
          <source>KEY</source>
          <target state="translated">KEY</target>
        </trans-unit>
        <trans-unit id="d27c8f02c4abf5f11c1eced4acd8b35520a9fe80" translate="yes" xml:space="preserve">
          <source>Keep constant guard over the actions of your life.</source>
          <target state="translated">Держите постоянную бдительность за действиями в своей жизни.</target>
        </trans-unit>
        <trans-unit id="194e669a908d39900cf589c5a981d721d7c9618b" translate="yes" xml:space="preserve">
          <source>Keep death daily before your eyes.</source>
          <target state="translated">Ежедневно держите смерть на глазах.</target>
        </trans-unit>
        <trans-unit id="c25db8dd7484e7f7bee803cd3895b18495da35bc" translate="yes" xml:space="preserve">
          <source>Keep the full precision of integers (if possible) when casting to NUMERIC. Ticket #2364</source>
          <target state="translated">Сохраняйте полную точность целых чисел (если возможно)при приведении к ЧИСЛОТНОСТИ.Билет #2364</target>
        </trans-unit>
        <trans-unit id="4989895ac52269498fe4414b7697f7a4c22ad5aa" translate="yes" xml:space="preserve">
          <source>Key points:</source>
          <target state="translated">Ключевые моменты:</target>
        </trans-unit>
        <trans-unit id="08fa4eb3aedd30338134d345421fea84986b3d4a" translate="yes" xml:space="preserve">
          <source>Key take-aways from this essay:</source>
          <target state="translated">Ключевые выводы из этого эссе:</target>
        </trans-unit>
        <trans-unit id="8b3a8bbf2ec2d401e862eec6bf418d40320b88cb" translate="yes" xml:space="preserve">
          <source>Key/value store for the raw database file content. The key is the page number and the value is binary page content.</source>
          <target state="translated">Хранилище ключей/значений для содержимого файлов исходной базы данных.Ключом является номер страницы,а значением-содержимое двоичной страницы.</target>
        </trans-unit>
        <trans-unit id="7b687d48e96f480574af88076704d469738ac8fd" translate="yes" xml:space="preserve">
          <source>Keyword arguments can optionally appear in quotes. (Example: &lt;code&gt;'yes' [FALSE]&lt;/code&gt;.) Some pragmas takes a string literal as their argument. When pragma takes a keyword argument, it will usually also take a numeric equivalent as well. For example, &quot;0&quot; and &quot;no&quot; mean the same thing, as does &quot;1&quot; and &quot;yes&quot;. When querying the value of a setting, many pragmas return the number rather than the keyword.</source>
          <target state="translated">Аргументы ключевых слов могут при желании заключаться в кавычки. (Пример: &lt;code&gt;'yes' [FALSE]&lt;/code&gt; .) Некоторые прагмы принимают строковый литерал в качестве аргумента. Когда прагма принимает аргумент ключевого слова, он обычно также принимает числовой эквивалент. Например, &amp;laquo;0&amp;raquo; и &amp;laquo;нет&amp;raquo; означают то же самое, что и &amp;laquo;1&amp;raquo; и &amp;laquo;да&amp;raquo;. При запросе значения параметра многие прагмы возвращают число, а не ключевое слово.</target>
        </trans-unit>
        <trans-unit id="71d7d3fe2fa70220d2397ae5ef29dbf8ffba7a8b" translate="yes" xml:space="preserve">
          <source>Know for certain that God sees you everywhere.</source>
          <target state="translated">Знай наверняка,что Бог видит тебя повсюду.</target>
        </trans-unit>
        <trans-unit id="7e70d2e585c390da7abcf2a3249245e0e36e0092" translate="yes" xml:space="preserve">
          <source>LAST</source>
          <target state="translated">LAST</target>
        </trans-unit>
        <trans-unit id="969e2cc476ff76be41815b17d8fb9c685f97e243" translate="yes" xml:space="preserve">
          <source>LEFT</source>
          <target state="translated">LEFT</target>
        </trans-unit>
        <trans-unit id="fa443d7d6200af63823dccc305e61eed839b45c2" translate="yes" xml:space="preserve">
          <source>LEFT JOIN</source>
          <target state="translated">ЛЕВЫЙ СОВЕТ</target>
        </trans-unit>
        <trans-unit id="06214bf7efebdbadf0fc2e8285b451472a810158" translate="yes" xml:space="preserve">
          <source>LEFT JOIN elimination often comes up when LEFT JOINs are used inside of views, and then the view is used in such as way that none of the columns of the right-hand table of the LEFT JOIN are referenced.</source>
          <target state="translated">Устранение ЛЕВОГО СОЕДИНЕНИЯ часто возникает,когда ЛЕВОЕ СОЕДИНЕНИЕ используется внутри вида,а затем вид используется таким образом,что ни один из столбцов правой таблицы ЛЕВОГО СОЕДИНЕНИЯ не имеет ссылок.</target>
        </trans-unit>
        <trans-unit id="228baedd626cec5fb29f832c085ce530c565f626" translate="yes" xml:space="preserve">
          <source>LEFT JOIN strength reduction optimization</source>
          <target state="translated">ЛЕВАЯ ОПТИМИЗАЦИЯ СОКРАЩЕНИЯ ПРОЧНОСТИ</target>
        </trans-unit>
        <trans-unit id="e43376033cc5d4106eb2e868e3b049e3915b255f" translate="yes" xml:space="preserve">
          <source>LEFT OUTER JOIN is implemented, but not RIGHT OUTER JOIN or FULL OUTER JOIN.</source>
          <target state="translated">ЛЕВОЕ ВНЕШНЕЕЕ соединение реализовано,но не ПРАВОЕ ВНЕШНЕЕ и ПОЛНОЕ ВНЕШНЕЕШНЕЕ.</target>
        </trans-unit>
        <trans-unit id="5ddf6f04739d8bc3a11b487863b27a7bcaa6fc24" translate="yes" xml:space="preserve">
          <source>LIKE</source>
          <target state="translated">LIKE</target>
        </trans-unit>
        <trans-unit id="92323e665381f4f6e8310e0e8d0ab85b11facf9e" translate="yes" xml:space="preserve">
          <source>LIKE optimization</source>
          <target state="translated">оптимизация LIKE</target>
        </trans-unit>
        <trans-unit id="c385d79f275c108bd6a32af099948cfc74a92c05" translate="yes" xml:space="preserve">
          <source>LIKE optimization now works for columns with COLLATE NOCASE</source>
          <target state="translated">Оптимизация LIKE теперь работает для колонн с COLLATE NOCASE</target>
        </trans-unit>
        <trans-unit id="9c590af5665cfc2916823206547377e482547e1d" translate="yes" xml:space="preserve">
          <source>LIMIT</source>
          <target state="translated">LIMIT</target>
        </trans-unit>
        <trans-unit id="40c4547fe7d52f08474372a32d5cd65ef3e61db8" translate="yes" xml:space="preserve">
          <source>LIMIT 0 now shows no rows. Use LIMIT -1 to see all rows.</source>
          <target state="translated">LIMIT 0 теперь не показывает строк.Используйте LIMIT -1,чтобы увидеть все строки.</target>
        </trans-unit>
        <trans-unit id="e120f1515582fd60e3aa87caeded6a95706ff6a5" translate="yes" xml:space="preserve">
          <source>LIMIT 0 now works on subqueries</source>
          <target state="translated">LIMIT 0 теперь работает по подзапросам</target>
        </trans-unit>
        <trans-unit id="2726a4b3c5be6bc17db3c5aa67da0f6e30ea159f" translate="yes" xml:space="preserve">
          <source>LIMIT_ATTACH</source>
          <target state="translated">LIMIT_ATTACH</target>
        </trans-unit>
        <trans-unit id="e8bf21b0d0f3b850c955bb94b5141253b1ae7e2a" translate="yes" xml:space="preserve">
          <source>LIMIT_COLUMN</source>
          <target state="translated">LIMIT_COLUMN</target>
        </trans-unit>
        <trans-unit id="7b09e7eae5f068cca9e40a4e561d97d66518a255" translate="yes" xml:space="preserve">
          <source>LIMIT_COMPOUND_SELECT</source>
          <target state="translated">LIMIT_COMPOUND_SELECT</target>
        </trans-unit>
        <trans-unit id="b1c8f4255d541a1d18f761d25857086f40b1bf20" translate="yes" xml:space="preserve">
          <source>LIMIT_EXPR_DEPTH</source>
          <target state="translated">LIMIT_EXPR_DEPTH</target>
        </trans-unit>
        <trans-unit id="2a0de541f4fa62311ff3575519dfacbb5ae6b11e" translate="yes" xml:space="preserve">
          <source>LIMIT_FUNCTION_ARG</source>
          <target state="translated">LIMIT_FUNCTION_ARG</target>
        </trans-unit>
        <trans-unit id="1a3a784fe44fc702cae042a37cb3ba3e0f6fa7ac" translate="yes" xml:space="preserve">
          <source>LIMIT_LENGTH</source>
          <target state="translated">LIMIT_LENGTH</target>
        </trans-unit>
        <trans-unit id="72fc2492f41deaa54c2dac4538490fafaa14d0d6" translate="yes" xml:space="preserve">
          <source>LIMIT_LIKE_PATTERN_LENGTH</source>
          <target state="translated">LIMIT_LIKE_PATTERN_LENGTH</target>
        </trans-unit>
        <trans-unit id="5e8999dc05d8b9aa066f6d09239a0ae740e36f64" translate="yes" xml:space="preserve">
          <source>LIMIT_SQL_LENGTH</source>
          <target state="translated">LIMIT_SQL_LENGTH</target>
        </trans-unit>
        <trans-unit id="db5d695bfcc2c3ebffa6c7ffcd096c20b8eed97c" translate="yes" xml:space="preserve">
          <source>LIMIT_TRIGGER_DEPTH</source>
          <target state="translated">LIMIT_TRIGGER_DEPTH</target>
        </trans-unit>
        <trans-unit id="16d75adbe3aa654b347523eb12544c39563f5b43" translate="yes" xml:space="preserve">
          <source>LIMIT_VARIABLE_NUMBER</source>
          <target state="translated">LIMIT_VARIABLE_NUMBER</target>
        </trans-unit>
        <trans-unit id="a604921b15950316535a24537e634352270c370e" translate="yes" xml:space="preserve">
          <source>LIMIT_VDBE_OP</source>
          <target state="translated">LIMIT_VDBE_OP</target>
        </trans-unit>
        <trans-unit id="89b86ab0e66f527166d98df92ddbcf5416ed58f6" translate="yes" xml:space="preserve">
          <source>Language</source>
          <target state="translated">Language</target>
        </trans-unit>
        <trans-unit id="7428d00a0b1c6a4c3041c21ce5ceb9dbaa4b015a" translate="yes" xml:space="preserve">
          <source>Large WAL files</source>
          <target state="translated">Большие файлы WAL</target>
        </trans-unit>
        <trans-unit id="d1c69a859a9638b242f2dabf8acf1c0b1450ce6b" translate="yes" xml:space="preserve">
          <source>Last</source>
          <target state="translated">Last</target>
        </trans-unit>
        <trans-unit id="07235ffa8a70d2e51e9570c942d05e5b5851a313" translate="yes" xml:space="preserve">
          <source>Last Insert Rowid</source>
          <target state="translated">Последняя вставка Роид</target>
        </trans-unit>
        <trans-unit id="7f81d5c9ec25b5fa1a2640b99a8421ac6c71b017" translate="yes" xml:space="preserve">
          <source>Later, SQLite version 3.6.16 is released, as shown by circle (4) in the diagram. At the point, the private branch maintainer does a merge which takes all of the changes going from (1) to (4) and applies those changes to (3). The result is version (5), which is SQLite 3.6.16 plus edits.</source>
          <target state="translated">Позже выходит версия SQLite 3.6.16,как показано кружком (4)на диаграмме.В этот момент сопровождающий частной ветки производит слияние,которое принимает все изменения,идущие от (1)до (4),и применяет эти изменения к (3).В результате получается версия (5),которая представляет собой SQLite 3.6.16 плюс изменения.</target>
        </trans-unit>
        <trans-unit id="e07edacb2555a09c495279c3384f36a675435d8d" translate="yes" xml:space="preserve">
          <source>Le</source>
          <target state="translated">Le</target>
        </trans-unit>
        <trans-unit id="fa3757f35a67a972328ec50d59fdef6fec4d197a" translate="yes" xml:space="preserve">
          <source>Leading spaces are removed.</source>
          <target state="translated">Ведущие места удалены.</target>
        </trans-unit>
        <trans-unit id="e52b8a48a53a875ca174a915ae5c47d6e94c2665" translate="yes" xml:space="preserve">
          <source>Leading zeros are handled properly, in the sense that they do not mess of the maginitude comparison of embedded strings of digits. &quot;x00123y&quot; is equal to &quot;x123y&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1dae495d04abf17bb3895a89b30ae8efcca9f3f1" translate="yes" xml:space="preserve">
          <source>Leaf payload fraction. Must be 32.</source>
          <target state="translated">Листовая доля полезной нагрузки.Должно быть 32.</target>
        </trans-unit>
        <trans-unit id="e2626d2b1592bacc07397cf31582efd1c5b2420a" translate="yes" xml:space="preserve">
          <source>Left operand</source>
          <target state="translated">Левый операнд</target>
        </trans-unit>
        <trans-unit id="203223a5600f328f50c6338dfe2e4c11e8803475" translate="yes" xml:space="preserve">
          <source>Left operand found</source>
          <target state="translated">Левый операнд найден</target>
        </trans-unit>
        <trans-unit id="865d1c5dcc029d18d1621430419ee2f04f5f424f" translate="yes" xml:space="preserve">
          <source>Left-justify the value in the output. The default is to right-justify. If the width is zero or is otherwise less than the length of the value being substituted, then there is no padding and the &quot;-&quot; flag is a no-op.</source>
          <target state="translated">Оправдайте значение на выходе в левую сторону.По умолчанию используется правое оправдание.Если ширина равна нулю или иначе меньше длины подставляемого значения,то подкладка отсутствует,а флаг &quot;-&quot;-нет.</target>
        </trans-unit>
        <trans-unit id="1877e2f919fe86f5371e6a3e7d9d6b6080bf4d57" translate="yes" xml:space="preserve">
          <source>Legacy (older than 3.22.0) versions of the sessions module cannot capture changes made to the sqlite_stat1 table. Legacy versions of the sqlite3changeset_apply() function silently ignore any modifications to the sqlite_stat1 table that are part of a changeset or patchset.</source>
          <target state="translated">Устаревшие (старше 3.22.0)версии модуля сеансов не могут фиксировать изменения,внесённые в таблицу sqlite_stat1.Старые версии функции sqlite3changeset_apply()беззвучно игнорируют любые изменения таблицы sqlite_stat1,которые являются частью changeset или patchset.</target>
        </trans-unit>
        <trans-unit id="48078fcdb6dc318fa741d70a2ecdb6ae1437e609" translate="yes" xml:space="preserve">
          <source>Lemon does not have its own source repository. Rather, Lemon consists of a few files in the SQLite source tree:</source>
          <target state="translated">У Лемон нет собственного репозитория исходников.Скорее,Lemon состоит из нескольких файлов в дереве исходных текстов SQLite:</target>
        </trans-unit>
        <trans-unit id="bf0578b2a25d2e804bfd4deee5634450a8293393" translate="yes" xml:space="preserve">
          <source>Lemon generates an LALR(1) parser. It's operation is similar to the more familiar tools &lt;a href=&quot;https://en.wikipedia.org/wiki/Yacc&quot;&gt;Yacc&lt;/a&gt; and &lt;a href=&quot;https://en.wikipedia.org/wiki/GNU_bison&quot;&gt;Bison&lt;/a&gt;, but Lemon adds important improvements, including:</source>
          <target state="translated">Lemon генерирует парсер LALR (1). Его работа аналогична более знакомым инструментам &lt;a href=&quot;https://en.wikipedia.org/wiki/Yacc&quot;&gt;Yacc&lt;/a&gt; и &lt;a href=&quot;https://en.wikipedia.org/wiki/GNU_bison&quot;&gt;Bison&lt;/a&gt; , но Lemon добавляет важные улучшения, в том числе:</target>
        </trans-unit>
        <trans-unit id="ae32ad1b62e795e4b0f91393920f4a7aff7c555a" translate="yes" xml:space="preserve">
          <source>Lemon has the concept of a &quot;fallback&quot; tokens. The SQL language contains a large number of keywords and these keywords have the potential to collide with identifier names. Lemon has the ability to designate some keywords has being able to &quot;fallback&quot; to an identifier. If the keyword appears in the input token stream in a context that would otherwise be a syntax error, the token is automatically transformed into its fallback before the syntax error is raised. This feature allows the parser to be very forgiving of reserved words used as identifiers, which is a problem that comes up frequently in the SQL language.</source>
          <target state="translated">У Лемон есть понятие жетонов &quot;отступление&quot;.Язык SQL содержит большое количество ключевых слов,и эти ключевые слова потенциально могут столкнуться с именами идентификаторов.Lemon имеет возможность обозначить некоторые ключевые слова,имея возможность &quot;отступать&quot; к идентификатору.Если ключевое слово появляется в потоке входных токенов в контексте,который в противном случае был бы синтаксической ошибкой,то до появления синтаксической ошибки токен автоматически преобразуется в откат.Эта функция позволяет синтаксическому анализатору быть очень снисходительным к зарезервированным словам,используемым в качестве идентификаторов,что является проблемой,часто возникающей в языке SQL.</target>
        </trans-unit>
        <trans-unit id="2f9dc02cb8bf5b03f6591dbb44f0a7a4b90f82f4" translate="yes" xml:space="preserve">
          <source>Lemon has the concept of a non-terminal destructor that can be used to reclaim memory or other resources following a syntax error or other aborted parse.</source>
          <target state="translated">Lemon имеет понятие нетерминального деструктора,который может быть использован для восстановления памяти или других ресурсов после синтаксической ошибки или другого прерванного разбора.</target>
        </trans-unit>
        <trans-unit id="cee927c3e2d6e42d43d5738f627f3200d5121eac" translate="yes" xml:space="preserve">
          <source>Lemon is also used to generate parse for the query pattern expressions in the &lt;a href=&quot;fts5&quot;&gt;FTS5&lt;/a&gt; extension. In this case, the input grammar file is &lt;a href=&quot;https://sqlite.org/src/file/ext/fts5/fts5parse.y&quot;&gt;fts5parse.y&lt;/a&gt;.</source>
          <target state="translated">Lemon также используется для синтаксического анализа выражений шаблонов запросов в расширении &lt;a href=&quot;fts5&quot;&gt;FTS5&lt;/a&gt; . В данном случае входным файлом грамматики является &lt;a href=&quot;https://sqlite.org/src/file/ext/fts5/fts5parse.y&quot;&gt;fts5parse.y&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="611d0deb28e86cca8303457d918752428288861c" translate="yes" xml:space="preserve">
          <source>Lemon is used in two places in SQLite.</source>
          <target state="translated">Лемон используется в SQLite в двух местах.</target>
        </trans-unit>
        <trans-unit id="0045a01f71c39a54c68dbc362b5b7275372032f5" translate="yes" xml:space="preserve">
          <source>Lemon supports conditional compilation of grammar file rules, so that a different parser can be generated depending on compile-time options.</source>
          <target state="translated">Lemon поддерживает условную компиляцию правил грамматических файлов,так что в зависимости от настроек времени компиляции может быть сгенерирован другой парсер.</target>
        </trans-unit>
        <trans-unit id="c5c89f378ce33982d309c573eb1ff14dd3f01e8a" translate="yes" xml:space="preserve">
          <source>Lemon was original written by D. Richard Hipp (also the creator of SQLite) while he was in graduate school at Duke University between 1987 and 1992. The original creation date of Lemon has been lost, but was probably sometime around 1990. Lemon generates an LALR(1) parser. There was companion LL(1) parser generator tool named &quot;Lime&quot;, but the source code for Lime has been lost.</source>
          <target state="translated">Лемон была написана Д.Ричардом Хиппом (также создателем SQLite),когда он учился в аспирантуре университета Дьюка с 1987 по 1992 год.Первоначальная дата создания Lemon была утеряна,но,вероятно,около 1990 года.Лемон создает парсер LALR(1).Существовал компаньон LL(1),генерирующий парсер под названием &quot;Lime&quot;,но исходный код для Lime был потерян.</target>
        </trans-unit>
        <trans-unit id="aa1fa89453ad95c8f115feb4d323d1e9b329630d" translate="yes" xml:space="preserve">
          <source>Length Specifier</source>
          <target state="translated">Указатель длины</target>
        </trans-unit>
        <trans-unit id="c999fb0a278ca9591b2cd0c03ceaa3328da57984" translate="yes" xml:space="preserve">
          <source>Less administration means that programmers spend more time working on the software (SQLite in this case) and less time fussing with the version control system.</source>
          <target state="translated">Меньше администрирования означает,что программисты тратят больше времени на работу с программным обеспечением (в данном случае SQLite)и меньше времени на работу с системой контроля версий.</target>
        </trans-unit>
        <trans-unit id="cbcb5b1fa488787750d49ab79f8ec375ce5124b9" translate="yes" xml:space="preserve">
          <source>Less memory used</source>
          <target state="translated">Меньше используемой памяти</target>
        </trans-unit>
        <trans-unit id="bc720094b72d521a9bad35bfe37f02c776160039" translate="yes" xml:space="preserve">
          <source>Let K be M+((P-M)%(U-4)).</source>
          <target state="translated">Пусть K будет M+((P-M)%(U-4)).</target>
        </trans-unit>
        <trans-unit id="ec5fd8c108643b71cf1bdd72351ff3e987fc1a5d" translate="yes" xml:space="preserve">
          <source>Let X be ((U-12)*64/255)-23. If the payload size P is less than or equal to X then the entire payload is stored on the b-tree page. Let M be ((U-12)*32/255)-23 and let K be M+((P-M)%(U-4)). If P is greater than X then the number of bytes stored on the index b-tree page is K if K is less than or equal to X or M otherwise. The number of bytes stored on the index page is never less than M.</source>
          <target state="translated">Пусть X будет ((U-12)*64/255)-23.Если размер полезного груза P меньше или равен X,то вся полезная нагрузка хранится на странице b-дерева.Пусть M будет ((U-12)*32/255)-23 и пусть K будет M+((P-M)%(U-4)).Если P больше X,то количество байт,которое хранится в индексной b-деревянной странице,будет K,если K меньше или равно X или M иным образом.Количество байтов,хранящихся на индексной странице,никогда не должно быть меньше M.</target>
        </trans-unit>
        <trans-unit id="3814595cf4d53307c33619bbcfd8505bff49fec5" translate="yes" xml:space="preserve">
          <source>Let X be U-35. If the payload size P is less than or equal to X then the entire payload is stored on the b-tree leaf page. Let M be ((U-12)*32/255)-23 and let K be M+((P-M)%(U-4)). If P is greater than X then the number of bytes stored on the table b-tree leaf page is K if K is less or equal to X or M otherwise. The number of bytes stored on the leaf page is never less than M.</source>
          <target state="translated">Пусть Икс будет U-35.Если размер полезного груза P меньше или равен X,то вся полезная нагрузка хранится на странице b-деревянного листа.Пусть M будет ((U-12)*32/255)-23 и пусть K будет M+((P-M)%(U-4)).Если P больше X,то количество байт,хранящихся на странице b-деревянного листа таблицы,будет K,если K меньше или равно X или M в противном случае.Количество байтов,хранящихся на странице листа,никогда не должно быть меньше M.</target>
        </trans-unit>
        <trans-unit id="04ab6da7aca9e95067f1ce62f19a937e96ff6418" translate="yes" xml:space="preserve">
          <source>Let X be the expression in the WHERE clause of a partial index, and let W be the WHERE clause of a query that uses the table that is indexed. Then, the query is permitted to use the partial index if W&amp;rArr;X, where the &amp;rArr; operator (usually pronounced &quot;implies&quot;) is the logic operator equivalent to &quot;X or not W&quot;. Hence, determining whether or not a partial index is usable in a particular query reduces to proving a theorem in first-order logic.</source>
          <target state="translated">Пусть X будет выражением в предложении WHERE частичного индекса, а W будет предложением WHERE запроса, использующего индексируемую таблицу. Затем в запросе разрешается использовать частичный индекс, если W&amp;rArr;X, где оператор &amp;rArr; (обычно произносится как &amp;laquo;подразумевает&amp;raquo;) является логическим оператором, эквивалентным &amp;laquo;X или не W&amp;raquo;. Следовательно, определение того, можно ли использовать частичный индекс в конкретном запросе, сводится к доказательству теоремы в логике первого порядка.</target>
        </trans-unit>
        <trans-unit id="8e79f3f73bca370e5a0d09f6e67e4908583572b1" translate="yes" xml:space="preserve">
          <source>Let X be the largest set of consecutive integers {h, h+1, h+2, ..., h+N} such that for every j in X, aPgno[j%8192]!=0. The X set will be empty if aPgno[h%8192]==0. The X set is easily computed by starting with the value h%8192, and adding h%8192 to X and incrementing h until encountering the first aPgno[h%8192] entry that is zero.</source>
          <target state="translated">Пусть Х будет самым большим набором последовательных целых чисел {h,h+1,h+2,...,h+N}так,чтобы для каждого j в Х,aPgno[j%8192]!=0.Множество Х будет пустым,если aPgno[h%8192]==0.Множество Х легко вычисляется,начиная со значения h%8192,добавляя к Х h%8192 и увеличивая h до тех пор,пока не столкнется с первой записью aPgno[h%8192],которая равна нулю.</target>
        </trans-unit>
        <trans-unit id="37bafb8ebd6ac523c9fab977240fbaca2d2a4205" translate="yes" xml:space="preserve">
          <source>Let the database page size (the value of the integer at offset 24 in the journal header) be N. Then the format of a page record is as follows:</source>
          <target state="translated">Пусть размер страницы БД (значение целого числа со смещением 24 в заголовке журнала)будет N.Тогда формат записи страницы будет следующим:</target>
        </trans-unit>
        <trans-unit id="5da01c6ea976760415bf0eb965f5e685ea3c15ec" translate="yes" xml:space="preserve">
          <source>Let the datatypes &quot;u8&quot;, &quot;u16&quot;, and &quot;u32&quot; mean unsigned integers of length 8, 16, and 32 bits, respectively. Then, the first 32768-byte unit of the shm file is organized as follows:</source>
          <target state="translated">Пусть типы данных &quot;u8&quot;,&quot;u16&quot; и &quot;u32&quot; означают беззнаковые целые числа длиной 8,16 и 32 бита соответственно.Затем первая 32768-байтовая единица файла shm организована следующим образом:</target>
        </trans-unit>
        <trans-unit id="bd114f90a251306f5f9680610cc3593a57d82e5b" translate="yes" xml:space="preserve">
          <source>Let the number of alice nodes be M and the number of bob nodes be N. Consider two scenarios. In the first scenario, M and N are both 2 but there are thousands of edges on each node. In this case, option 1 is preferred. With option 1, the inner loop checks for the existence of an edge between a pair of nodes and outputs the result if found. But because there are only 2 alice and bob nodes each, the inner loop only has to run 4 times and the query is very quick. Option 2 would take much longer here. The outer loop of option 2 only executes twice, but because there are a large number of edges leaving each alice node, the middle loop has to iterate many thousands of times. It will be much slower. So in the first scenario, we prefer to use option 1.</source>
          <target state="translated">Пусть число вершин Алисы будет M,а число вершин Боба-N.Рассмотрим два сценария.В первом сценарии M и N равны 2,но на каждой вершине есть тысячи рёбер.В этом случае предпочтителен вариант 1.При использовании варианта 1 внутренний цикл проверяет наличие фронта между парой узлов и выдает результат,если он найден.Но так как существует только 2 alice и bob узла в каждом,то внутренний цикл должен выполняться только 4 раза,и запрос выполняется очень быстро.Вариант 2 здесь занял бы гораздо больше времени.Внешний цикл варианта 2 выполняется только дважды,но из-за большого количества ребер,оставляющих каждый узел Алисы,средний цикл вынужден повторять итерации много тысяч раз.Это будет намного медленнее.Поэтому в первом сценарии мы предпочитаем использовать вариант 1.</target>
        </trans-unit>
        <trans-unit id="74b220b56c9d6c3f209f91061a8b3234a645c429" translate="yes" xml:space="preserve">
          <source>Let the page count value at offset 8 in the journal header be M. If M is greater than zero then after M page records the journal file may be zero padded out to the next multiple of the sector size and another journal header may be inserted. All journal headers within the same journal must contain the same database page size and sector size.</source>
          <target state="translated">Пусть значение счета страниц со смещением 8 в заголовке журнала будет M.Если M больше нуля,то после записи страницы M файл журнала может быть обнулен до следующего кратного размера сектора,и в него может быть вставлен другой заголовок журнала.Все заголовки журнала внутри одного и того же журнала должны содержать одинаковый размер страницы базы данных и размер сектора.</target>
        </trans-unit>
        <trans-unit id="f44e417ae6158672e12bddd6f44e6cd28bdb55bb" translate="yes" xml:space="preserve">
          <source>Let us assume that you are using the amalgamation source code. Add the baseline to your project as follows:</source>
          <target state="translated">Предположим,что вы используете исходный код слияния.Добавьте исходный код к вашему проекту следующим образом:</target>
        </trans-unit>
        <trans-unit id="ae7bd817eacac0a262f119102109a97036180841" translate="yes" xml:space="preserve">
          <source>Let us suppose that instead of using a ZIP archive to store its files, OpenDocument used a very simple SQLite database with the following single-table schema:</source>
          <target state="translated">Предположим,что вместо того,чтобы использовать ZIP-архив для хранения своих файлов,в OpenDocument использовалась очень простая SQLite БД со следующей однотаблеточной схемой:</target>
        </trans-unit>
        <trans-unit id="ecc5e1e5e0ad7c0dd2b547a397bdb11d90ca6d36" translate="yes" xml:space="preserve">
          <source>Let us use the following notation (similar but not identical to Robson's notation):</source>
          <target state="translated">Используем следующую нотацию (похожую,но не идентичную нотации Робсона):</target>
        </trans-unit>
        <trans-unit id="2d2261f9e0cbec9edf95c4d47c5f5eb0cbcca2f7" translate="yes" xml:space="preserve">
          <source>Let's be real. Few people seriously dispute that Git provides a suboptimal user experience. A lot of the underlying implementation shows through into the user interface. The interface is so bad that there is even a parody site that generates &lt;a href=&quot;https://git-man-page-generator.lokaltog.net/&quot;&gt;fake git man pages&lt;/a&gt;.</source>
          <target state="translated">Давайте будем реальными. Мало кто серьезно оспаривает то, что Git обеспечивает неоптимальный пользовательский интерфейс. Большая часть базовой реализации просматривается в пользовательском интерфейсе. Интерфейс настолько плох, что существует даже пародийный сайт, генерирующий &lt;a href=&quot;https://git-man-page-generator.lokaltog.net/&quot;&gt;поддельные страницы руководства git&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0f0987eb98b35f60885158c865b4e995d0d04bc9" translate="yes" xml:space="preserve">
          <source>Let's look more closely at what is happening here. The first SELECT is implemented by the loop at instructions 5 through 10. Instruction 5 initializes the loop by rewinding its cursor. Instruction 6 extracts the value of the &quot;two&quot; column from &quot;examp&quot; and instruction 7 converts this into a row. Instruction 8 pushes an empty string onto the stack. Finally, instruction 9 writes the row into the temporary table. But remember, the PutStrKey opcode uses the top of the stack as the record data and the next on stack as the key. For an INSERT statement, the row generated by the MakeRecord opcode is the record data and the record key is an integer created by the NewRecno opcode. But here the roles are reversed and the row created by MakeRecord is the record key and the record data is just an empty string.</source>
          <target state="translated">Давайте посмотрим более внимательно на то,что здесь происходит.Первый SELECT реализуется циклом на инструкциях 5-10.Инструкция 5 инициализирует цикл перемоткой его курсора.Инструкция 6 извлекает значение столбца &quot;два&quot; из &quot;экзамена&quot;,а инструкция 7 преобразует его в строку.Инструкция 8 толкает пустую строку на стек.Наконец,Инструкция 9 записывает строку во временную таблицу.Но помните,что опкод PutStrKey использует вершину стека в качестве данных записи,а следующую на стеке в качестве ключа.Для оператора INSERT,строка,генерируемая опкодом MakeRecord,является данными записи,а ключом записи является целое число,созданное опкодом NewRecno.Но здесь роли перевернуты,а строка,созданная оператором MakeRecord,является ключом записи,а данные записи-просто пустой строкой.</target>
        </trans-unit>
        <trans-unit id="8ce47b13d09374c0748516f88f9567e0ba880c6e" translate="yes" xml:space="preserve">
          <source>Libraries written in C do not have a huge run-time dependency. In its minimum configuration, SQLite requires only the following routines from the standard C library:</source>
          <target state="translated">Библиотеки,написанные на C,не имеют огромной зависимости от времени исполнения.В своей минимальной конфигурации SQLite требует только следующих процедур из стандартной библиотеки на Си:</target>
        </trans-unit>
        <trans-unit id="16b9101f24846717dcb86cc74d99a08aad5ead61" translate="yes" xml:space="preserve">
          <source>Libraries written in C++ or Java can generally only be used by applications written in the same language. It is difficult to get an application written in Haskell or Java to invoke a library written in C++. On the other hand, libraries written in C are callable from any programming language.</source>
          <target state="translated">Библиотеки,написанные на C++или Java,как правило,могут использоваться только приложениями,написанными на том же языке.Сложно заставить приложение,написанное на Haskell или Java,ссылаться на библиотеку,написанную на С++.С другой стороны,библиотеки,написанные на Си,могут вызываться из любого языка программирования.</target>
        </trans-unit>
        <trans-unit id="8f218c8346bfddbca30ecf6b104e83b9f15b5e98" translate="yes" xml:space="preserve">
          <source>Library size optimizations.</source>
          <target state="translated">Оптимизация размера библиотеки.</target>
        </trans-unit>
        <trans-unit id="3769a60d2f565f40c7f7836558211471f7d8a029" translate="yes" xml:space="preserve">
          <source>Like --file, use file FILE as the archive, but open the file using the &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/appendvfs.c&quot;&gt;apndvfs VFS&lt;/a&gt; so that the archive will be appended to the end of FILE if FILE already exists.</source>
          <target state="translated">Как и --file, используйте файл FILE в качестве архива, но откройте файл с помощью &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/appendvfs.c&quot;&gt;apndvfs VFS,&lt;/a&gt; чтобы архив был добавлен в конец FILE, если FILE уже существует.</target>
        </trans-unit>
        <trans-unit id="0b095c3da7d05183eec1d9c68eafa22989981539" translate="yes" xml:space="preserve">
          <source>Like contentless tables, external content tables do not support REPLACE conflict handling. Any operations that specify REPLACE conflict handling are handled using ABORT.</source>
          <target state="translated">Подобно таблицам без содержания,внешние таблицы содержания не поддерживают обработку конфликтов REPLACE.Любые операции,указывающие на обработку конфликтов REPLACE,обрабатываются с помощью ABORT.</target>
        </trans-unit>
        <trans-unit id="231d089dd7b27b9cd1c3006b16a6dc21b83bfb7e" translate="yes" xml:space="preserve">
          <source>Like other virtual table types, new FTS tables are created using a &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; statement. The module name, which follows the USING keyword, is either &quot;fts3&quot; or &quot;fts4&quot;. The virtual table module arguments may be left empty, in which case an FTS table with a single user-defined column named &quot;content&quot; is created. Alternatively, the module arguments may be passed a list of comma separated column names.</source>
          <target state="translated">Как и другие типы виртуальных таблиц, новые таблицы FTS создаются с помощью оператора &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; . Имя модуля, следующее за ключевым словом USING, - &amp;laquo;fts3&amp;raquo; или &amp;laquo;fts4&amp;raquo;. Аргументы модуля виртуальной таблицы могут быть оставлены пустыми, и в этом случае создается таблица FTS с одним определяемым пользователем столбцом с именем &amp;laquo;контент&amp;raquo;. В качестве альтернативы аргументам модуля может быть передан список имен столбцов, разделенных запятыми.</target>
        </trans-unit>
        <trans-unit id="fd7d7c85c83f29484f2e117602dc4bec07bd365d" translate="yes" xml:space="preserve">
          <source>Like sqlite3rbu_step(), if the vacuum operation has finished, sqlite3rbu_close() returns SQLITE_DONE. If the vacuum has not finished but no error has occurred, SQLITE_OK is returned. Or, if an error has occurred, an SQLite error code is returned. If an error occurred as part of a prior call to sqlite3rbu_step(), sqlite3rbu_close() returns the same error code.</source>
          <target state="translated">Как и sqlite3rbu_step(),если операция вакуума закончена,sqlite3rbu_close()возвращает SQLITE_DONE.Если вакуум не закончился,но ошибка не произошла,возвращается SQLITE_OK.Или,если ошибка произошла,возвращается код ошибки SQLite.Если ошибка произошла в рамках предыдущего вызова sqlite3rbu_step(),sqlite3rbu_close()возвращает тот же код ошибки.</target>
        </trans-unit>
        <trans-unit id="7e8a69dbe9cf8dfea5767671aa0118b3491fc369" translate="yes" xml:space="preserve">
          <source>Like the &quot;.dump&quot; command, &quot;.recover&quot; attempts to convert the entire contents of a database file to text. The difference is that instead of reading data using the normal SQL database interface, &quot;.recover&quot; attempts to reassemble the database based on data extracted directly from as many database pages as possible. If the database is corrupt, &quot;.recover&quot; is usually able to recover data from all uncorrupted parts of the database, whereas &quot;.dump&quot; stops when the first sign of corruption is encountered.</source>
          <target state="translated">Подобно команде &quot;.dump&quot;,&quot;.recover&quot; пытается преобразовать все содержимое файла базы данных в текст.Разница в том,что вместо чтения данных с помощью обычного интерфейса базы данных SQL,&quot;.recover&quot; пытается собрать базу данных на основе данных,извлеченных непосредственно из как можно большего количества страниц базы данных.Если база данных повреждена,&quot;.recover&quot;,как правило,может восстановить данные из всех поврежденных частей базы данных,тогда как &quot;.dump&quot; останавливается при первом же признаке повреждения.</target>
        </trans-unit>
        <trans-unit id="86f2b5c75e6099a6cf032f5fc9564b20f9285845" translate="yes" xml:space="preserve">
          <source>Limit Setting</source>
          <target state="translated">Установка пределов</target>
        </trans-unit>
        <trans-unit id="dc00d8255b192a092dc29a4b67bc17a891ccaa1d" translate="yes" xml:space="preserve">
          <source>Limit the amount of output that &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt; generates.</source>
          <target state="translated">Ограничьте объем вывода, который генерирует &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA Integrity_check&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3bc4a74f4bc8f6fbe5d7600c2ffc0ce32f2df522" translate="yes" xml:space="preserve">
          <source>Limit the depth of recursion for JSON objects and arrays in order to avoid excess stack usage in the recursive descent parser. Fix for ticket &lt;a href=&quot;https://www.sqlite.org/src/info/981329adeef51011052&quot;&gt;981329adeef51011052&lt;/a&gt;.</source>
          <target state="translated">Ограничьте глубину рекурсии для объектов и массивов JSON, чтобы избежать чрезмерного использования стека в парсере рекурсивного спуска. Исправление для билета &lt;a href=&quot;https://www.sqlite.org/src/info/981329adeef51011052&quot;&gt;981329adeef51011052&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5c73db06777439f7e7a4e0b4ef090767959f015d" translate="yes" xml:space="preserve">
          <source>Limit the maximum amount of memory that SQLite will allocate using the &lt;a href=&quot;c3ref/hard_heap_limit64&quot;&gt;sqlite3_hard_heap_limit64()&lt;/a&gt; interface. This helps prevent denial-of-service attacks. To find out how much heap space an application actually needs, run the it against typical inputs and then measure the maximum instantaneous memory usage with the &lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_highwater()&lt;/a&gt; interface. Set the hard heap limit to the maximum observed instantaneous memory usage plus some margin.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7c04c64ed3f2a9374590c76c50d3b7f1b18e3da" translate="yes" xml:space="preserve">
          <source>Limitations</source>
          <target state="translated">Limitations</target>
        </trans-unit>
        <trans-unit id="cd047048aa9c975f33600c7ec5b79b0145824c1c" translate="yes" xml:space="preserve">
          <source>Limitations And Caveats</source>
          <target state="translated">Ограничения и пещеры</target>
        </trans-unit>
        <trans-unit id="140fa43a5b0009e4451c320039ee7a35af9ef59d" translate="yes" xml:space="preserve">
          <source>Limitations Of The OpenDocument Presentation Format</source>
          <target state="translated">Ограничения формата представления OpenDocument</target>
        </trans-unit>
        <trans-unit id="61a0ae3b849d95fb8185df69b96d0ec676fb0688" translate="yes" xml:space="preserve">
          <source>Limits</source>
          <target state="translated">Limits</target>
        </trans-unit>
        <trans-unit id="da74bbdf0c5ba1732a1bcf36654960401f556496" translate="yes" xml:space="preserve">
          <source>Limits In SQLite</source>
          <target state="translated">Ограничения в SQLite</target>
        </trans-unit>
        <trans-unit id="2b535e43758af2a0faba7d7491e8ccc0937261f7" translate="yes" xml:space="preserve">
          <source>Lines that begin with &quot;#&quot; and that are not in the middle of an SQL statement are interpreted as comments.</source>
          <target state="translated">Строки,которые начинаются с &quot;#&quot; и не находятся в середине SQL-оператора,интерпретируются как комментарии.</target>
        </trans-unit>
        <trans-unit id="56c40b8da457fccee36d2dd25cabffcd286e7be5" translate="yes" xml:space="preserve">
          <source>Link SQLite against a test program that runs approximately 30,000 SQL statements representing a typical workload.</source>
          <target state="translated">Соедините SQLite с тестовой программой,которая запускает около 30,000 SQL выражений,представляющих типичную рабочую нагрузку.</target>
        </trans-unit>
        <trans-unit id="aa106ea45c187562ead66ff45b2537ad9d39d113" translate="yes" xml:space="preserve">
          <source>Linus Torvalds used different words to say much the same thing on the Git mailing list on 2006-06-27:</source>
          <target state="translated">Линус Торвальдс использовал разные слова,чтобы сказать одно и то же в списке рассылки Git'а на 2006-06-27:</target>
        </trans-unit>
        <trans-unit id="518aa8e09ec633a2ee7ca4061837886754889a59" translate="yes" xml:space="preserve">
          <source>List Of Constants:</source>
          <target state="translated">Список постоянных:</target>
        </trans-unit>
        <trans-unit id="c88854d7fb661e5a305fcbc6e6989b1500fbf8a5" translate="yes" xml:space="preserve">
          <source>List Of Functions:</source>
          <target state="translated">Список функций:</target>
        </trans-unit>
        <trans-unit id="02564776632cdeb522e81ac2cc1d466134257360" translate="yes" xml:space="preserve">
          <source>List Of Objects:</source>
          <target state="translated">Список объектов:</target>
        </trans-unit>
        <trans-unit id="5976b759c2bbe27a2c436cf0d06c399c38f9db0a" translate="yes" xml:space="preserve">
          <source>List Of PRAGMAs</source>
          <target state="translated">Список PRAGMA</target>
        </trans-unit>
        <trans-unit id="198f4f9677551df3e26744118c9e2c5bcd812876" translate="yes" xml:space="preserve">
          <source>List Of SQLite Constants</source>
          <target state="translated">Список констант SQLite</target>
        </trans-unit>
        <trans-unit id="b6b508ee374f53a81be169f4d47397a7a1f331e0" translate="yes" xml:space="preserve">
          <source>List Of SQLite Functions</source>
          <target state="translated">Список функций SQLite</target>
        </trans-unit>
        <trans-unit id="52d4b531b52e9862c4189d27482ae4e958f97760" translate="yes" xml:space="preserve">
          <source>List Of SQLite Objects</source>
          <target state="translated">Список объектов SQLite</target>
        </trans-unit>
        <trans-unit id="68749615daec6b7db7287fc101bfd1803474c677" translate="yes" xml:space="preserve">
          <source>List Of Virtual Tables</source>
          <target state="translated">Список виртуальных таблиц</target>
        </trans-unit>
        <trans-unit id="9d1c029d1a64007ca37f5bf394575d02eef0574f" translate="yes" xml:space="preserve">
          <source>List each file as it is processed.</source>
          <target state="translated">Перечислите каждый файл в процессе обработки.</target>
        </trans-unit>
        <trans-unit id="a5d1705cc809076e6266257a5ff3fa27b21bc1d4" translate="yes" xml:space="preserve">
          <source>List the contents of the archive. If no arguments are specified, then all files are listed. Otherwise, only those specified as arguments are. Currently, the --verbose option does not change the behaviour of this command. That may change in the future.</source>
          <target state="translated">Перечислите содержимое архива.Если аргументы не указаны,то перечисляются все файлы.В противном случае,только те,которые указаны в качестве аргументов.На данный момент опция --verbose не изменяет поведение этой команды.Это может измениться в будущем.</target>
        </trans-unit>
        <trans-unit id="27424535e9c380832791dbc03c67071412b07455" translate="yes" xml:space="preserve">
          <source>List the files in the archive.</source>
          <target state="translated">Перечислите файлы в архиве.</target>
        </trans-unit>
        <trans-unit id="615e9625e4457bad91a4957735c233d58d384ed8" translate="yes" xml:space="preserve">
          <source>List values on the right-hand side of IN are treated as a subquery that must be materialized. In other words, the previous statement acts as if it were:</source>
          <target state="translated">Значения перечня,расположенные справа от IN,рассматриваются как подзапрос,который должен быть материализован.Другими словами,предыдущее утверждение действует так,как если бы оно было:</target>
        </trans-unit>
        <trans-unit id="f653dec85c31b3ff9b77fe72b2384cf749288d85" translate="yes" xml:space="preserve">
          <source>Listed below are some cases where it might make sense to add additional soundslike entries. The specific entries will depend on the application and the target language.</source>
          <target state="translated">Ниже перечислены некоторые случаи,когда имеет смысл добавить дополнительные звуковые записи.Конкретные записи будут зависеть от приложения и целевого языка.</target>
        </trans-unit>
        <trans-unit id="9a2828a10d993798b426c35ab47fdbeb8b46927a" translate="yes" xml:space="preserve">
          <source>Listen willingly to holy reading.</source>
          <target state="translated">Слушайте с готовностью святое чтение.</target>
        </trans-unit>
        <trans-unit id="3805c697baba47d8b6fac8ff193aac1d5aae53c5" translate="yes" xml:space="preserve">
          <source>Literal Values (Constants)</source>
          <target state="translated">Буквальные значения (постоянные)</target>
        </trans-unit>
        <trans-unit id="3c11cc0f06e28252855afe306ffae2efa4d23a55" translate="yes" xml:space="preserve">
          <source>Literal strings contain no byte-order-marks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a95fd3f55e521532b15bff8dba2b3aa3f6401a1a" translate="yes" xml:space="preserve">
          <source>Literal value</source>
          <target state="translated">Буквальное значение</target>
        </trans-unit>
        <trans-unit id="402377f4fa54f586c7bcf70486179fb514f52098" translate="yes" xml:space="preserve">
          <source>Literal values: numeric or string constants.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc57b0cbf2f7891171194ad1bf1b86f68a201597" translate="yes" xml:space="preserve">
          <source>LoC Recommended Storage Format</source>
          <target state="translated">Рекомендуемый формат хранения LoC</target>
        </trans-unit>
        <trans-unit id="c1fd24450afa2a8ca3ccb54f712f70e15f33b7ed" translate="yes" xml:space="preserve">
          <source>Load An Extension</source>
          <target state="translated">Загрузить удлинитель</target>
        </trans-unit>
        <trans-unit id="f9c032c8f6af23d9ff803554a14cbcd6e3037cb8" translate="yes" xml:space="preserve">
          <source>Load The Difference Between Tables Into A Session</source>
          <target state="translated">Загрузить разницу между таблицами в сессию.</target>
        </trans-unit>
        <trans-unit id="9c794e6d2b53e1c944bf6d4f24a6f0f6be485378" translate="yes" xml:space="preserve">
          <source>Load the shared library or DLL file LIBRARY into SQLite prior to computing the differences. This can be used to add application-defined &lt;a href=&quot;datatype3#collation&quot;&gt;collating sequences&lt;/a&gt; that are required by the schema.</source>
          <target state="translated">Загрузите общую библиотеку или DLL-файл LIBRARY в SQLite до вычисления различий. Это можно использовать для добавления определяемых приложением &lt;a href=&quot;datatype3#collation&quot;&gt;последовательностей упорядочения&lt;/a&gt; , которые требуются для схемы.</target>
        </trans-unit>
        <trans-unit id="1f26dca858775a9ffdc6b130413dfda84cf7cc4a" translate="yes" xml:space="preserve">
          <source>LoadAnalysis</source>
          <target state="translated">LoadAnalysis</target>
        </trans-unit>
        <trans-unit id="494260ec047bea19460fac6ca8324736557ff1c6" translate="yes" xml:space="preserve">
          <source>Loadable Extension Thunk</source>
          <target state="translated">Загрузочное расширение Спасибо</target>
        </trans-unit>
        <trans-unit id="a8855a7ba639af1775ee3c99ff39ec45827a09ba" translate="yes" xml:space="preserve">
          <source>Loadable extensions are C-code. To compile them on most unix-like operating systems, the usual command is something like this:</source>
          <target state="translated">Загружаемые расширения-это C-код.Для компиляции их на большинстве unix-подобных операционных систем обычной командой является нечто подобное:</target>
        </trans-unit>
        <trans-unit id="16baeb9dc5c7b831d9570f59926debb8cb175348" translate="yes" xml:space="preserve">
          <source>Local DELETE</source>
          <target state="translated">Местная УДАЛЕТА</target>
        </trans-unit>
        <trans-unit id="ad4c5e9ed0fc895a0d42b932b2926861699fe92c" translate="yes" xml:space="preserve">
          <source>Local INSERT</source>
          <target state="translated">Местный иммиграционный контроль</target>
        </trans-unit>
        <trans-unit id="3e12d4ac47a72a1f8aa6fb2cd56dc176cf45a02b" translate="yes" xml:space="preserve">
          <source>Local UPDATE</source>
          <target state="translated">Локальная дата UPDATE</target>
        </trans-unit>
        <trans-unit id="e88556ba53a549a6a9fbf15298a71732177e868b" translate="yes" xml:space="preserve">
          <source>Localtime modifier</source>
          <target state="translated">Модификатор местного времени</target>
        </trans-unit>
        <trans-unit id="249beb765376acea4283a10da9faa975024e8fe9" translate="yes" xml:space="preserve">
          <source>Lock Name</source>
          <target state="translated">Имя замка</target>
        </trans-unit>
        <trans-unit id="d4795eaa0bbabf21615f9f3e359ab0c2e3631ccd" translate="yes" xml:space="preserve">
          <source>Lock offset</source>
          <target state="translated">Смещение блокировки</target>
        </trans-unit>
        <trans-unit id="eb6bc036bb67cd66abad9bfabc9e6cb6a5eaef00" translate="yes" xml:space="preserve">
          <source>Lock the btree to which cursor P1 is pointing so that the btree cannot be written by an other cursor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de20f3d1eb2301b2722958c2ff4a7d6bd4e9d117" translate="yes" xml:space="preserve">
          <source>Locking and Concurrency</source>
          <target state="translated">Блокировка и конвертация</target>
        </trans-unit>
        <trans-unit id="668186cf26fd89e59f391d180f6666c5c03f0bfa" translate="yes" xml:space="preserve">
          <source>Locking and concurrency control are handled by the &lt;a href=&quot;http://www.sqlite.org/src/finfo?name=src/pager.c&quot;&gt; pager module&lt;/a&gt;. The pager module is responsible for making SQLite &quot;ACID&quot; (Atomic, Consistent, Isolated, and Durable). The pager module makes sure changes happen all at once, that either all changes occur or none of them do, that two or more processes do not try to access the database in incompatible ways at the same time, and that once changes have been written they persist until explicitly deleted. The pager also provides a memory cache of some of the contents of the disk file.</source>
          <target state="translated">Управление блокировкой и параллелизмом осуществляется &lt;a href=&quot;http://www.sqlite.org/src/finfo?name=src/pager.c&quot;&gt;модулем пейджера&lt;/a&gt; . Модуль пейджера отвечает за создание SQLite &amp;laquo;ACID&amp;raquo; (атомарный, согласованный, изолированный и надежный). Модуль пейджера следит за тем, чтобы все изменения происходили одновременно, чтобы были либо все изменения, либо ни одно из них, что два или более процесса не пытались получить доступ к базе данных несовместимыми способами одновременно и что после того, как изменения были записаны, они сохраняются до тех пор, пока явно не будут удалены. Пейджер также обеспечивает кеш-память некоторого содержимого дискового файла.</target>
        </trans-unit>
        <trans-unit id="57d0597b0f360ba173ecb2d2a1f767cb5748ea2e" translate="yes" xml:space="preserve">
          <source>Long Option</source>
          <target state="translated">Длинный вариант</target>
        </trans-unit>
        <trans-unit id="76889c4037fcda94eba3afe630f0b45c824942de" translate="yes" xml:space="preserve">
          <source>Long Term Support</source>
          <target state="translated">Долгосрочная поддержка</target>
        </trans-unit>
        <trans-unit id="fce206f4d564c7fbca45ff9aebf22500127c7c61" translate="yes" xml:space="preserve">
          <source>Long and short style options may be mixed. For example, the following are equivalent:</source>
          <target state="translated">Длинные и короткие варианты стиля могут быть смешанными.Например,следующие варианты эквивалентны:</target>
        </trans-unit>
        <trans-unit id="1a01077cb8c85bad9873673a9051f4ee19688494" translate="yes" xml:space="preserve">
          <source>Longer answer: If you declare a column of a table to be &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;, then whenever you insert a NULL into that column of the table, the NULL is automatically converted into an integer which is one greater than the largest value of that column over all other rows in the table, or 1 if the table is empty. Or, if the largest existing integer key 9223372036854775807 is in use then an unused key value is chosen at random. For example, suppose you have a table like this:</source>
          <target state="translated">Более длинный ответ: если вы объявляете столбец таблицы как &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; , то всякий раз, когда вы вставляете NULL в этот столбец таблицы, NULL автоматически преобразуется в целое число, которое на единицу больше, чем наибольшее значение этого столбца. все остальные строки в таблице или 1, если таблица пуста. Или, если используется самый большой из существующих целочисленных ключей 9223372036854775807, то случайным образом выбирается неиспользуемое значение ключа. Например, предположим, что у вас есть такая таблица:</target>
        </trans-unit>
        <trans-unit id="6e9f2602cf3d1fd809e1312f33acfde2f150141f" translate="yes" xml:space="preserve">
          <source>Lookaside buffer allocations for new &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt;.</source>
          <target state="translated">Резервное выделение буфера для новых &lt;a href=&quot;c3ref/sqlite3&quot;&gt;подключений&lt;/a&gt; к базе данных .</target>
        </trans-unit>
        <trans-unit id="04bd7a984d3646ac5eb9c18de550a3f1e203e5b1" translate="yes" xml:space="preserve">
          <source>Lookaside memory allocator</source>
          <target state="translated">аллокатор Lookaside памяти</target>
        </trans-unit>
        <trans-unit id="fde137681e3baa6ad1143b905327accc0fb28e76" translate="yes" xml:space="preserve">
          <source>Lots of bug fixes.</source>
          <target state="translated">Много исправлений.</target>
        </trans-unit>
        <trans-unit id="990ee2bc3df995ba8afb44c45e674fd9a503ec05" translate="yes" xml:space="preserve">
          <source>Lots of little bug fixes.</source>
          <target state="translated">Множество маленьких исправлений.</target>
        </trans-unit>
        <trans-unit id="43de40a3e36d80f18de0a9c09a14efee88ae8d7f" translate="yes" xml:space="preserve">
          <source>Love chastity.</source>
          <target state="translated">Любовь к целомудрию.</target>
        </trans-unit>
        <trans-unit id="0bbc37af1e456bff56591e973337f95cdf967a70" translate="yes" xml:space="preserve">
          <source>Love fasting.</source>
          <target state="translated">Люблю пост.</target>
        </trans-unit>
        <trans-unit id="b7fcabbc1c2979a6343998251fb3b60ca2fcf13c" translate="yes" xml:space="preserve">
          <source>Love your enemies.</source>
          <target state="translated">Люби своих врагов.</target>
        </trans-unit>
        <trans-unit id="868ab24a96d3a2771240294f216c1eb308fe2112" translate="yes" xml:space="preserve">
          <source>Love your juniors.</source>
          <target state="translated">Любите своих юниоров.</target>
        </trans-unit>
        <trans-unit id="dcbca8259d75e252eae0048dd86f40340f8d0cd8" translate="yes" xml:space="preserve">
          <source>Low-Level Control Of Database Files</source>
          <target state="translated">Низкоуровневый контроль файлов базы данных</target>
        </trans-unit>
        <trans-unit id="c47d12b1a2b47bc6fe16c9cb80aba1cd8b334072" translate="yes" xml:space="preserve">
          <source>Low-dependency</source>
          <target state="translated">Low-dependency</target>
        </trans-unit>
        <trans-unit id="9b49cf9a88d0eb7571f152a707297d6594a2f0d2" translate="yes" xml:space="preserve">
          <source>Low-level system error code</source>
          <target state="translated">Низкоуровневый код системной ошибки</target>
        </trans-unit>
        <trans-unit id="0be209fef2b5ea9e4e344d9742cbe9598db19564" translate="yes" xml:space="preserve">
          <source>Lowest precedence (loosest grouping).</source>
          <target state="translated">Самый низкий приоритет (самая низкая группировка).</target>
        </trans-unit>
        <trans-unit id="f41a055096fba2f5ebbddc8916d81727739dbdb3" translate="yes" xml:space="preserve">
          <source>Lt</source>
          <target state="translated">Lt</target>
        </trans-unit>
        <trans-unit id="c63ae6dd4fc9f9dda66970e827d13f7c73fe841c" translate="yes" xml:space="preserve">
          <source>M</source>
          <target state="translated">M</target>
        </trans-unit>
        <trans-unit id="1e549c8c539e5dd3fb33fffd4ca9bec2df1c3d6b" translate="yes" xml:space="preserve">
          <source>M &amp;amp;times 2&lt;sup&gt;&lt;small&gt;E&lt;/small&gt;&lt;/sup&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4b52e49796d63ce942c6b8bfaa86fb7c20383ea" translate="yes" xml:space="preserve">
          <source>M is always ((U-12)*32/255)-23.</source>
          <target state="translated">M всегда ((U-12)*32/255)-23.</target>
        </trans-unit>
        <trans-unit id="1758fbe17031a1050ba647fef2f5a93784bd0bf5" translate="yes" xml:space="preserve">
          <source>M&lt;sub&gt;&lt;small&gt;left&lt;/small&gt;&lt;/sub&gt;</source>
          <target state="translated">M&lt;sub&gt;&lt;small&gt;left&lt;/small&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="5fbd2551d496e24af3eb24927ec50373a744a672" translate="yes" xml:space="preserve">
          <source>M&lt;sub&gt;&lt;small&gt;left&lt;/small&gt;&lt;/sub&gt;+M&lt;sub&gt;&lt;small&gt;right&lt;/small&gt;&lt;/sub&gt;</source>
          <target state="translated">M&lt;sub&gt;&lt;small&gt;left&lt;/small&gt;&lt;/sub&gt;+M&lt;sub&gt;&lt;small&gt;right&lt;/small&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="835c3f9feac04a1fedeecdc386e908df7274d7ab" translate="yes" xml:space="preserve">
          <source>M&lt;sub&gt;&lt;small&gt;right&lt;/small&gt;&lt;/sub&gt;</source>
          <target state="translated">M&lt;sub&gt;&lt;small&gt;right&lt;/small&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="7e3ce80c0f5019f27debc96398dd7ba53b449b32" translate="yes" xml:space="preserve">
          <source>MASK</source>
          <target state="translated">MASK</target>
        </trans-unit>
        <trans-unit id="4110e0d1b0232ec2802f84b8b4f2d0c2fb3fbbb7" translate="yes" xml:space="preserve">
          <source>MASK bit 0x02 is set.</source>
          <target state="translated">Бит MASK 0x02 установлен.</target>
        </trans-unit>
        <trans-unit id="ce71241b2af9817fe6f961964423ded83b2b2446" translate="yes" xml:space="preserve">
          <source>MATCH</source>
          <target state="translated">MATCH</target>
        </trans-unit>
        <trans-unit id="fb533649ca2f9e73b11b6bb948adb363f958ac9f" translate="yes" xml:space="preserve">
          <source>MEDIUMINT</source>
          <target state="translated">MEDIUMINT</target>
        </trans-unit>
        <trans-unit id="7c2c1a9b5cbb8b738dc37806d8007da0a4dabc51" translate="yes" xml:space="preserve">
          <source>MS-SQL</source>
          <target state="translated">MS-SQL</target>
        </trans-unit>
        <trans-unit id="e6557f13d224519bee5609849fa3b7fe2b045817" translate="yes" xml:space="preserve">
          <source>Macs are unix-like, but they do not follow the usual shared library conventions. To compile a shared library on a Mac, use a command like this:</source>
          <target state="translated">Масы Mac похожи на unix,но они не следуют обычным конвенциям об общих библиотеках.Для компиляции разделяемой библиотеки на Mac используйте команду,подобную этой:</target>
        </trans-unit>
        <trans-unit id="a1e5337bd6f525fef1a4495aefda7354ea999138" translate="yes" xml:space="preserve">
          <source>Made selected parameters in API functions &lt;b&gt;const&lt;/b&gt;. This should be fully backwards compatible.</source>
          <target state="translated">Сделал выбранные параметры в функциях API &lt;b&gt;const&lt;/b&gt; . Это должно быть полностью обратно совместимо.</target>
        </trans-unit>
        <trans-unit id="debb142b11cd7000f7ccf5be052a02bcc1c7f9ef" translate="yes" xml:space="preserve">
          <source>Made the &lt;a href=&quot;testing#aflfuzz&quot;&gt;American Fuzzy Lop fuzzer&lt;/a&gt; a standard part of SQLite's &lt;a href=&quot;testing&quot;&gt;testing strategy&lt;/a&gt;.</source>
          <target state="translated">Сделал &lt;a href=&quot;testing#aflfuzz&quot;&gt;американский фаззер Fuzzy Lop&lt;/a&gt; стандартной частью &lt;a href=&quot;testing&quot;&gt;стратегии тестирования&lt;/a&gt; SQLite .</target>
        </trans-unit>
        <trans-unit id="aadd04e928883126f21deaf37b5282558e747d50" translate="yes" xml:space="preserve">
          <source>Made the CACHE_SIZE pragma persistent</source>
          <target state="translated">Сделали прагму CACHE_SIZE упорной</target>
        </trans-unit>
        <trans-unit id="2d544f28a897acf54e3872442614c2de63e16acf" translate="yes" xml:space="preserve">
          <source>Magic number. 0x377f0682 or 0x377f0683</source>
          <target state="translated">Волшебное число.0x377f0682 или 0x377f0683</target>
        </trans-unit>
        <trans-unit id="a249757e280e4c1ed4596ef256151f0633cc5c86" translate="yes" xml:space="preserve">
          <source>Maintaining 100% MC/DC is laborious and time-consuming. The level of effort needed to maintain full-coverage testing is probably not cost effective for a typical application. However, we think that full-coverage testing is justified for a &lt;a href=&quot;https://sqlite.org/mostdeployed.html&quot;&gt;very widely deployed&lt;/a&gt; infrastructure library like SQLite, and especially for a database library which by its very nature &quot;remembers&quot; past mistakes.</source>
          <target state="translated">Поддержание 100% MC / DC трудоемко и требует много времени. Уровень усилий, необходимых для поддержки тестирования с полным покрытием, вероятно, не является рентабельным для типичного приложения. Однако мы считаем, что тестирование с полным покрытием оправдано для &lt;a href=&quot;https://sqlite.org/mostdeployed.html&quot;&gt;очень широко распространенной&lt;/a&gt; библиотеки инфраструктуры, такой как SQLite, и особенно для библиотеки баз данных, которая по самой своей природе &amp;laquo;помнит&amp;raquo; прошлые ошибки.</target>
        </trans-unit>
        <trans-unit id="0690809fdfc162c136b84c90c7f6551b5a7d6bb1" translate="yes" xml:space="preserve">
          <source>Maintaining Private Branches Of SQLite</source>
          <target state="translated">Поддержание частных филиалов SQLite</target>
        </trans-unit>
        <trans-unit id="74db8285437f292d07f23511a8853dab08df8f69" translate="yes" xml:space="preserve">
          <source>Make &lt;a href=&quot;c3ref/compileoption_get&quot;&gt;sqlite3_compileoption_used()&lt;/a&gt; responsive to the &lt;a href=&quot;compile#enable_dbstat_vtab&quot;&gt;SQLITE_ENABLE_DBSTAT_VTAB&lt;/a&gt; compile-time option.</source>
          <target state="translated">Сделайте &lt;a href=&quot;c3ref/compileoption_get&quot;&gt;sqlite3_compileoption_used () &lt;/a&gt;&lt;a href=&quot;compile#enable_dbstat_vtab&quot;&gt;зависимым&lt;/a&gt; от параметра времени компиляции SQLITE_ENABLE_DBSTAT_VTAB .</target>
        </trans-unit>
        <trans-unit id="f178a74cc1dcf57fcc7b73994685f97569f4844f" translate="yes" xml:space="preserve">
          <source>Make AreFileApisANSI() a no-op macro in WinCE since WinCE does not support this function.</source>
          <target state="translated">Сделайте AreFileApisANSI()нулевым макросом в WinCE,так как WinCE не поддерживает эту функцию.</target>
        </trans-unit>
        <trans-unit id="07dc88b6cef4d75e2f7c3880e8647593525aa07e" translate="yes" xml:space="preserve">
          <source>Make CSV (comma separate value) output from the command-line shell more closely aligned to accepted practice</source>
          <target state="translated">Сделать вывод CSV (значение,отделенное запятой)из командной строки,более близким к общепринятой практике</target>
        </trans-unit>
        <trans-unit id="7ebdddec87e9007589d5ada3e116c78e26d2e69a" translate="yes" xml:space="preserve">
          <source>Make LIMIT work on a compound SELECT statement.</source>
          <target state="translated">Заставьте LIMIT работать над комплексным заявлением SELECT.</target>
        </trans-unit>
        <trans-unit id="67a20c818425dd125a3dee8478ee3f7563c8b234" translate="yes" xml:space="preserve">
          <source>Make a copy of registers P1..P1+P3 into registers P2..P2+P3.</source>
          <target state="translated">Сделайте копию регистров P1...P1+P3 в регистры P2...P2+P3.</target>
        </trans-unit>
        <trans-unit id="8d0b0f116d9ed8fdf1c047e6cff51269d6d08bd0" translate="yes" xml:space="preserve">
          <source>Make a distinction between numeric and text values when sorting. Text values sort according to memcmp(). Numeric values sort in numeric order.</source>
          <target state="translated">При сортировке следует различать числовые и текстовые значения.Текстовые значения сортируются по функции memcmp().Числовые значения сортируются в числовом порядке.</target>
        </trans-unit>
        <trans-unit id="9f53feddfd33da18e3bb3466ea22bc837873fc9d" translate="yes" xml:space="preserve">
          <source>Make a shallow copy of register P1 into register P2.</source>
          <target state="translated">Сделайте неглубокую копию регистра P1 в регистр P2.</target>
        </trans-unit>
        <trans-unit id="c4914cad6e6db40e49d46939d936ae678cbe7888" translate="yes" xml:space="preserve">
          <source>Make every effort to allocate a new page. Only return NULL if allocating a new page is effectively impossible.</source>
          <target state="translated">Приложите все усилия,чтобы выделить новую страницу.Возвращайте NULL только в том случае,если выделение новой страницы фактически невозможно.</target>
        </trans-unit>
        <trans-unit id="94089eca234684dc20cbdb2f8434b3d3fb23b40c" translate="yes" xml:space="preserve">
          <source>Make peace with your adversary before the sun sets.</source>
          <target state="translated">Помиритесь с противником до захода солнца.</target>
        </trans-unit>
        <trans-unit id="b31d5954ede96c4a01bf917d9892337c3c9f6de7" translate="yes" xml:space="preserve">
          <source>Make sure ORDER BY puts rows in ascending order even if the DISTINCT operator is implemented using a descending index. Fix for ticket &lt;a href=&quot;https://www.sqlite.org/src/info/c5ea805691bfc4204b1cb9e&quot;&gt;c5ea805691bfc4204b1cb9e&lt;/a&gt;.</source>
          <target state="translated">Убедитесь, что ORDER BY помещает строки в порядке возрастания, даже если оператор DISTINCT реализован с использованием убывающего индекса. Исправление для билета &lt;a href=&quot;https://www.sqlite.org/src/info/c5ea805691bfc4204b1cb9e&quot;&gt;c5ea805691bfc4204b1cb9e&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fd7437d47e0ca64701851f46718248492d235445" translate="yes" xml:space="preserve">
          <source>Make sure VIEWs are created after their corresponding TABLEs in the output of the &lt;b&gt;.dump&lt;/b&gt; command in the shell.</source>
          <target state="translated">Убедитесь, что ВИДЫ создаются после соответствующих ТАБЛИЦ в выводе команды &lt;b&gt;.dump&lt;/b&gt; в оболочке.</target>
        </trans-unit>
        <trans-unit id="b8fc01ec14bc51db67a6c7f295254a0473ee78c4" translate="yes" xml:space="preserve">
          <source>Make sure all individual database files have an EXCLUSIVE lock and a valid journal.</source>
          <target state="translated">Убедитесь,что все отдельные файлы базы данных имеют ЭКСКЛЮЗИВНЫЙ БЛОКИРОВКУ и действующий журнал.</target>
        </trans-unit>
        <trans-unit id="39ceab29d21e2433cf3cad2d290185c2cdda1b07" translate="yes" xml:space="preserve">
          <source>Make sure all rollback journal data has actually been written to the surface of the disk (and is not just being held in the operating system's or disk controllers cache) so that if a power failure occurs the data will still be there after power is restored.</source>
          <target state="translated">Убедитесь,что все данные журнала отката действительно записаны на поверхность диска (а не просто хранятся в кэше операционной системы или контроллеров дисков),так что в случае отключения питания данные все равно останутся там после восстановления питания.</target>
        </trans-unit>
        <trans-unit id="faaff6cbdbf4873f3d095a4a0e2d87974475615a" translate="yes" xml:space="preserve">
          <source>Make sure functions expressions in the VALUES clause of an INSERT are correct.</source>
          <target state="translated">Убедитесь,что выражения функций в выражении VALUES в INSERT корректны.</target>
        </trans-unit>
        <trans-unit id="b3c87542457fbfa0848fd99500f7827664d328fc" translate="yes" xml:space="preserve">
          <source>Make sure that database filenames follow the 8+3 filename format and that they do not have an empty name or extension. In other words, the database filename must contain between 1 and 8 characters in the base name and between 1 and 3 characters in the extension. Blank extensions are not allowed.</source>
          <target state="translated">Убедитесь,что имена файлов базы данных соответствуют формату 8+3 и что у них нет пустого имени или расширения.Другими словами,имя файла базы данных должно содержать от 1 до 8 символов в базовом имени и от 1 до 3 символов в расширении.Пустые расширения не допускаются.</target>
        </trans-unit>
        <trans-unit id="559ee78af19e40cf8fa346787df1709761be2f3c" translate="yes" xml:space="preserve">
          <source>Make sure that when a connection blocks on a RESERVED lock that it is able to continue after the lock is released. (Ticket #3093)</source>
          <target state="translated">Убедитесь,что при блокировке соединения на блокировке RESERVED оно может продолжить работу после снятия блокировки.(Билет № 3093)</target>
        </trans-unit>
        <trans-unit id="6c2032f0b0a487670b92ae7b1f7c2a4d3713ca71" translate="yes" xml:space="preserve">
          <source>Make sure the &lt;a href=&quot;c3ref/get_auxdata&quot;&gt;sqlite3_set_auxdata()&lt;/a&gt; values from multiple triggers within a single statement do not interfere with one another. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/dc9b1c91&quot;&gt;dc9b1c91&lt;/a&gt;.</source>
          <target state="translated">Убедитесь, что значения &lt;a href=&quot;c3ref/get_auxdata&quot;&gt;sqlite3_set_auxdata ()&lt;/a&gt; из нескольких триггеров в одном операторе не мешают друг другу. Билет &lt;a href=&quot;https://www.sqlite.org/src/info/dc9b1c91&quot;&gt;dc9b1c91&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c6638940c401bf7e1c92493be7672af3af206b2b" translate="yes" xml:space="preserve">
          <source>Make sure the &lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_snprintf()&lt;/a&gt; interface does not zero-terminate the buffer if the buffer size is less than 1. Ticket #2341</source>
          <target state="translated">Убедитесь, что интерфейс &lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_snprintf ()&lt;/a&gt; не завершает буфер нулем, если размер буфера меньше 1. Билет № 2341</target>
        </trans-unit>
        <trans-unit id="3bc85b9279a5981ff83181cec093f69c7042f9c4" translate="yes" xml:space="preserve">
          <source>Make sure the MIN() and MAX() optimizations work within subqueries.</source>
          <target state="translated">Убедитесь,что оптимизации MIN()и MAX()работают внутри подзапросов.</target>
        </trans-unit>
        <trans-unit id="58ff8f836097af00b92625ae2c5e983cf4412032" translate="yes" xml:space="preserve">
          <source>Make sure the ORDER BY LIMIT optimization (from check-in &lt;a href=&quot;https://www.sqlite.org/src/info/559733b09e9630fa&quot;&gt;559733b09e&lt;/a&gt;) works with IN operators on INTEGER PRIMARY KEYs. Fix for ticket &lt;a href=&quot;https://www.sqlite.org/src/info/96c1454cbfd9509&quot;&gt;96c1454c&lt;/a&gt;</source>
          <target state="translated">Убедитесь, что оптимизация ORDER BY LIMIT (из проверки &lt;a href=&quot;https://www.sqlite.org/src/info/559733b09e9630fa&quot;&gt;559733b09e&lt;/a&gt; ) работает с операторами IN на INTEGER PRIMARY KEYs. Исправление для билета &lt;a href=&quot;https://www.sqlite.org/src/info/96c1454cbfd9509&quot;&gt;96c1454c&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3ea00b4a5adf172672ba7e54a20e155f2d4f11b3" translate="yes" xml:space="preserve">
          <source>Make sure the TCL language interface works correctly with 64-bit integers on 64-bit machines.</source>
          <target state="translated">Убедитесь,что интерфейс языка TCL корректно работает с 64-битными целыми числами на 64-битных машинах.</target>
        </trans-unit>
        <trans-unit id="2c7d7b5412a65ed5d6ce615755d9929fa6d57cca" translate="yes" xml:space="preserve">
          <source>Make sure the in-memory backend response sanely if malloc() fails.</source>
          <target state="translated">Убедитесь,что ответ бэкенда in-memory в здравом уме,если malloc()не срабатывает.</target>
        </trans-unit>
        <trans-unit id="eae9ed5b156bcdd54a8967008569fef435a53021" translate="yes" xml:space="preserve">
          <source>Make sure the query optimizer checks dependencies on all terms of a compound SELECT statement. Ticket #2640.</source>
          <target state="translated">Убедитесь,что оптимизатор запросов проверяет зависимости от всех условий составного SELECT-оператора.Билет № 2640.</target>
        </trans-unit>
        <trans-unit id="30c0cf0484d7a5f504b6b728788d263a9e41fc0c" translate="yes" xml:space="preserve">
          <source>Make sure you type a semicolon at the end of each SQL command! The sqlite3 program looks for a semicolon to know when your SQL command is complete. If you omit the semicolon, sqlite3 will give you a continuation prompt and wait for you to enter more text to be added to the current SQL command. This feature allows you to enter SQL commands that span multiple lines. For example:</source>
          <target state="translated">Убедитесь,что в конце каждой команды SQL вы напечатали точку с запятой! Программа sqlite3 ищет точку с запятой,чтобы узнать,когда Ваша команда SQL будет завершена.Если Вы опустите точку с запятой,sqlite3 даст Вам запрос на продолжение и будет ждать,пока Вы не введете больше текста для добавления в текущую команду SQL.Эта функция позволяет вводить команды SQL,которые охватывают несколько строк.Например:</target>
        </trans-unit>
        <trans-unit id="0f78a73d59843cf77efe52a3fb9a1c8bc577fb63" translate="yes" xml:space="preserve">
          <source>Make that script executable and put it on your $PATH. Then compile the kvtest program as follows:</source>
          <target state="translated">Сделайте этот сценарий исполняемым и положите его на ваш $PATH.Затем скомпилируйте программу kvtest следующим образом:</target>
        </trans-unit>
        <trans-unit id="55a8e3fef2599367be1f179f0eeae6e3f90c5562" translate="yes" xml:space="preserve">
          <source>Make the &quot;AS&quot; keyword optional again.</source>
          <target state="translated">Сделайте снова необязательным ключевое слово &quot;AS&quot;.</target>
        </trans-unit>
        <trans-unit id="e8d3c7849aaf72378ce97fad0ef58bb50dfa844b" translate="yes" xml:space="preserve">
          <source>Make the &lt;a href=&quot;dbstat&quot;&gt;dbstat virtual table&lt;/a&gt; part of standard builds when compiled with the &lt;a href=&quot;compile#enable_dbstat_vtab&quot;&gt;SQLITE_ENABLE_DBSTAT_VTAB&lt;/a&gt; option.</source>
          <target state="translated">Сделайте &lt;a href=&quot;dbstat&quot;&gt;виртуальную таблицу dbstat&lt;/a&gt; частью стандартных сборок при компиляции с опцией &lt;a href=&quot;compile#enable_dbstat_vtab&quot;&gt;SQLITE_ENABLE_DBSTAT_VTAB&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3cf1a1fb81ef7a54777705fadfc53565c39e040a" translate="yes" xml:space="preserve">
          <source>Make the GLOB and LIKE operators functions that can be overridden by a programmer. This allows, for example, the LIKE operator to be changed to be case sensitive.</source>
          <target state="translated">Сделайте функции операторов GLOB и LIKE,которые могут быть переопределены программистом.Это позволяет,например,изменять оператор LIKE на регистрозависимый.</target>
        </trans-unit>
        <trans-unit id="06d1ed76522acc5f77d35b87ff9bcb7713142c7d" translate="yes" xml:space="preserve">
          <source>Make the LIMIT clause work on subqueries. (ORDER BY still does not work, though.)</source>
          <target state="translated">Заставьте пункт LIMIT работать над подзапросами.(ЗАКАЗАТЕЛЬСТВО ЗАПРЕЩАЕТСЯ все равно не работает.)</target>
        </trans-unit>
        <trans-unit id="e949e24407b3c3e74908e043648105301add53c5" translate="yes" xml:space="preserve">
          <source>Make the library thread-safe. (The code is there and appears to work but has not been stressed.)</source>
          <target state="translated">Сделайте библиотеку безопасной для нитей.(Код есть,и кажется,что он работает,но не был подчеркнут).</target>
        </trans-unit>
        <trans-unit id="aa1b502d7a3d8467cdd71e12de59017bd7bf7832" translate="yes" xml:space="preserve">
          <source>Make the os.h header file more robust in detecting when the compile is for Windows and when it is for Unix.</source>
          <target state="translated">Сделайте заголовочный файл os.h более надежным в обнаружении,когда компиляция для Windows,а когда для Unix.</target>
        </trans-unit>
        <trans-unit id="5b70367d16489f70b60357dd49e971c66ecb7a25" translate="yes" xml:space="preserve">
          <source>Make use of OVERLAPPED in the windows &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; to avoid some system calls and thereby obtain a performance improvement.</source>
          <target state="translated">Используйте OVERLAPPED в Windows &lt;a href=&quot;vfs&quot;&gt;VFS,&lt;/a&gt; чтобы избежать некоторых системных вызовов и тем самым повысить производительность.</target>
        </trans-unit>
        <trans-unit id="bb3c80011eafc56757b5115bd6da6df2d3cc0bcf" translate="yes" xml:space="preserve">
          <source>Make use of the one-pass UPDATE and DELETE query plans in the &lt;a href=&quot;rtree&quot;&gt;R-Tree extension&lt;/a&gt; where appropriate.</source>
          <target state="translated">При необходимости используйте однопроходные планы запросов UPDATE и DELETE в &lt;a href=&quot;rtree&quot;&gt;расширении R-Tree&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9c7ffc0af1b5a78c06ebbd279554c53e269060be" translate="yes" xml:space="preserve">
          <source>MakeRecord</source>
          <target state="translated">MakeRecord</target>
        </trans-unit>
        <trans-unit id="decb5fb2e05d5246774c7c119193e5dd3eeab585" translate="yes" xml:space="preserve">
          <source>Makefile updates</source>
          <target state="translated">Обновления Makefile</target>
        </trans-unit>
        <trans-unit id="3e75c9edc23a32990a13f91bc222c1cd2fb310c7" translate="yes" xml:space="preserve">
          <source>Makefile updates and miscellaneous bug fixes.</source>
          <target state="translated">Обновления Makefile и различные исправления ошибок.</target>
        </trans-unit>
        <trans-unit id="bdecdca82af325fcab74535c838b3bad719fc7de" translate="yes" xml:space="preserve">
          <source>Makefile updates from A. Rottmann</source>
          <target state="translated">Обновления Makefile от A.Rottmann</target>
        </trans-unit>
        <trans-unit id="1a74e86adcd0000bd7de1be192d074c821dd68c1" translate="yes" xml:space="preserve">
          <source>Making Other Kinds Of Table Schema Changes</source>
          <target state="translated">Изменение схем таблиц других типов</target>
        </trans-unit>
        <trans-unit id="e6fe063cab95ff9f5d6ec0129688c23c296059b5" translate="yes" xml:space="preserve">
          <source>Malformed UTF-8 that SQLite converts to a UTF-16 byte-order-mark is embedded at the beginning of an SQL string literal value inserted into an FTS3 table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e30f6661f23230d01a3d07773b601db8982cabdd" translate="yes" xml:space="preserve">
          <source>Malformed database tests</source>
          <target state="translated">Испытания базы данных на наличие ошибок</target>
        </trans-unit>
        <trans-unit id="aa578a91aad5dc4dab2da9a4bac602790d836ae2" translate="yes" xml:space="preserve">
          <source>Malicious SQL statement (an ALTER TABLE that tries to rename a &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; into one of its own &lt;a href=&quot;vtab#xshadowname&quot;&gt;shadow tables&lt;/a&gt;) causes an infinite loop and denial of service. &lt;a href=&quot;https://sqlite.org/src/info/eca0ba2cf4c0fdf7&quot;&gt;(details)&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3505da2486b779eca8455a74c0a2213782342dc" translate="yes" xml:space="preserve">
          <source>Malicious SQL statement causes a NULL pointer dereference and denial-of-service &lt;a href=&quot;https://www.sqlite.org/src/info/1bc783da63d58b05&quot;&gt;(details)&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b3de4ef5153133c67b1a8788b48babe0af12634" translate="yes" xml:space="preserve">
          <source>Malicious SQL statement causes a NULL pointer dereference and denial-of-service. &lt;a href=&quot;https://www.sqlite.org/src/info/862974312edf00e9&quot;&gt;(details)&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f05b51d00c5136f9765e2a5529ff25dd76521560" translate="yes" xml:space="preserve">
          <source>Malicious SQL statement causes a NULL pointer dereference and in the &lt;a href=&quot;zipfile&quot;&gt;Zipfile virtual table&lt;/a&gt; extension and denial-of-service. This is only possible when the optional &lt;a href=&quot;zipfile&quot;&gt;Zipfile virtual table&lt;/a&gt; extension is deployed, which is not the case in default builds. &lt;a href=&quot;https://www.sqlite.org/src/info/a80f84b511231204&quot;&gt;(details)&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3223f276a85bbea2e40f22c66ab04105f353da0b" translate="yes" xml:space="preserve">
          <source>Malicious SQL statement causes a NULL pointer dereference in the &lt;a href=&quot;zipfile&quot;&gt;Zipfile virtual table&lt;/a&gt; extension and denial-of-service. This is only possible when the optional &lt;a href=&quot;zipfile&quot;&gt;Zipfile virtual table&lt;/a&gt; extension is deployed, which is not the case in default builds. &lt;a href=&quot;https://www.sqlite.org/src/info/cc0fb00a128fd077&quot;&gt;(details)&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be787da663e373d3f7997d1441cd2ca035e3495f" translate="yes" xml:space="preserve">
          <source>Malicious SQL statement causes a read access to a NULL pointer and denial of service. &lt;a href=&quot;https://www.sqlite.org/src/info/7a5279a25c57adf1&quot;&gt;(details)&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b7808ef1d93533f98b34a6af3e305d6a4a79902" translate="yes" xml:space="preserve">
          <source>Malicious SQL statement causes a read of a NULL pointer in the &lt;a href=&quot;fts3#matchinfo&quot;&gt;matchinfo()&lt;/a&gt; SQL function of the &lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt; extension, resulting in denial of service. &lt;a href=&quot;https://sqlite.org/src/info/a4dd148928ea65bd&quot;&gt;(details)&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb5500a4c4534dd4662f8932a169f8e6f4053c24" translate="yes" xml:space="preserve">
          <source>Malicious SQL statement causes a read using an uninitialized pointer and denial-of-service &lt;a href=&quot;https://www.sqlite.org/src/info/4374860b29383380&quot;&gt;(details)&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08a51de55d02f39c503f43bf8dbb67b4a981750f" translate="yes" xml:space="preserve">
          <source>Malicious SQL statement causes a read using an uninitialized pointer and denial-of-service. &lt;a href=&quot;https://www.sqlite.org/src/info/af4556bb5c285c08&quot;&gt;(details)&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f420ed40458097230e18bc609dc3d6070a139e7" translate="yes" xml:space="preserve">
          <source>Malicious SQL statement causes a read-only use-after-free memory error. &lt;a href=&quot;https://sqlite.org/src/info/c8d3b9f0a750a529&quot;&gt;(details)&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c7315e30c332568a87d33624f52296d256dba71" translate="yes" xml:space="preserve">
          <source>Malicious SQL statement causes a read-only use-after-free, possibly resulting in a incorrect output from the &lt;a href=&quot;fts3#snippet&quot;&gt;snippet()&lt;/a&gt; SQL function of the &lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt; extension. There is no known way to exfiltrate data or crash the application using this bug. &lt;a href=&quot;https://sqlite.org/src/info/0d69f76f0865f962&quot;&gt;(details)&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="605174f0d56c0319ea8c88e54fd141ec899039f3" translate="yes" xml:space="preserve">
          <source>Malicious SQL statement causes a uninitialized pointer reference and denial-of-service. &lt;a href=&quot;https://www.sqlite.org/src/info/e2bddcd4c55ba3cb&quot;&gt;(details)&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a3d15a3efb587f7e5d31ca19ff99f19bff90311" translate="yes" xml:space="preserve">
          <source>Malicious SQL statement causes an read past the end of a heap buffer. &lt;a href=&quot;https://sqlite.org/src/info/8f157e8010b22af0&quot;&gt;(details)&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3460af9ab9b12af9da67324f2da63f63e80a6848" translate="yes" xml:space="preserve">
          <source>Malicious SQL statement causes an uninitialized pointer read and denial-of-service. &lt;a href=&quot;https://www.sqlite.org/src/info/cba2a2a44cdf138a&quot;&gt;(details)&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b341edff7ed671940a8d972691c324a8c7d62137" translate="yes" xml:space="preserve">
          <source>Malicious SQL statement causes an uninitialized pointer read and denial-of-service. &lt;a href=&quot;https://www.sqlite.org/src/timeline?r=better-error-handling-1&quot;&gt;(details)&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be80211b17a199f937f0a9b644dfd18f1e2cecb3" translate="yes" xml:space="preserve">
          <source>Malicious SQL statement causes read-only use-after-free of memory allocation if SQLite is compile with -DSQLITE_DEBUG. Does not affect release builds. &lt;a href=&quot;https://www.sqlite.org/src/info/4722bdab08cb1&quot;&gt;(details)&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90aacfe82b6d869ef75232c639a3bc16d905426f" translate="yes" xml:space="preserve">
          <source>Malicious SQL statement involving the printf() SQL function results in an integer overflow which can overwrite the stack with over 2 billion bytes of 0x30 or 0x20 (ASCII '0' or ' '). Even though this is a stack overwrite, there is no known way to redirect control or otherwise escalate the level of harm. This is a denial-of-service attack only. &lt;a href=&quot;https://www.sqlite.org/src/info/23439ea582241138&quot;&gt;(details)&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6314779095d53af544ef97df23a24554ee88bdd" translate="yes" xml:space="preserve">
          <source>Managing SQLite Archives from the command-line</source>
          <target state="translated">Управление архивами SQLite из командной строки</target>
        </trans-unit>
        <trans-unit id="3fbc66cdb2efde39d2ec8d74f242ca151b4515bd" translate="yes" xml:space="preserve">
          <source>Manifest Typing and BLOB Support</source>
          <target state="translated">Манифест ввода и BLOB-поддержка</target>
        </trans-unit>
        <trans-unit id="bb55c1a865472533208270e05409a59df50af4d8" translate="yes" xml:space="preserve">
          <source>Manifest typing and BLOB support.</source>
          <target state="translated">Манифест набора и поддержка BLOB.</target>
        </trans-unit>
        <trans-unit id="1cc470a30ade4f894dfdc6d3819af02869f9a0ff" translate="yes" xml:space="preserve">
          <source>Manual Control Of Query Plans Using CROSS JOIN</source>
          <target state="translated">Ручное управление планами запросов с помощью CROSS JOIN</target>
        </trans-unit>
        <trans-unit id="cd08ce62fe23d2df3bf17c27439fcc586ae7eb2c" translate="yes" xml:space="preserve">
          <source>Manual Control Of Query Plans Using SQLITE_STAT Tables</source>
          <target state="translated">Ручное управление планами запросов с помощью таблиц SQLITE_STAT</target>
        </trans-unit>
        <trans-unit id="6ce25f14125bd349207477d6be9b5bb56a241bb2" translate="yes" xml:space="preserve">
          <source>Many SQLITE_OMIT_ macros inserts to omit features at compile-time and reduce the library footprint.</source>
          <target state="translated">Многие макросы SQLITE_OMIT_вставляются для того,чтобы опустить возможности во время компиляции и уменьшить нагрузку на библиотеку.</target>
        </trans-unit>
        <trans-unit id="58bc21cac299bf4ec03f599485fd07e14baffb8d" translate="yes" xml:space="preserve">
          <source>Many SQLite functions return an integer result code from the set shown here in order to indicate success or failure.</source>
          <target state="translated">Многие функции SQLite возвращают целочисленный код результата из приведенного здесь набора,чтобы указать на успех или неудачу.</target>
        </trans-unit>
        <trans-unit id="29bbffe8721f3a2848d887e1fb7a366159ccdc97" translate="yes" xml:space="preserve">
          <source>Many Small Queries Are Efficient In SQLite</source>
          <target state="translated">Многие малые запросы эффективны в SQLite</target>
        </trans-unit>
        <trans-unit id="b88b7072aba4a1d9cfba91839cebc05836eb0907" translate="yes" xml:space="preserve">
          <source>Many applications destroy their &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt; using calls to &lt;a href=&quot;c3ref/close&quot;&gt;sqlite3_close()&lt;/a&gt; at shutdown. Or, for example, an application that uses SQLite as its &lt;a href=&quot;appfileformat&quot;&gt;application file format&lt;/a&gt; might open &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt; in response to a File/Open menu action and then destroy the corresponding &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; in response to the File/Close menu.</source>
          <target state="translated">Многие приложения разрушают свои &lt;a href=&quot;c3ref/sqlite3&quot;&gt;соединения&lt;/a&gt; с базой данных, используя вызовы &lt;a href=&quot;c3ref/close&quot;&gt;sqlite3_close ()&lt;/a&gt; при завершении работы. Или, например, приложение, использующее SQLite в качестве &lt;a href=&quot;appfileformat&quot;&gt;формата файла приложения,&lt;/a&gt; может открывать &lt;a href=&quot;c3ref/sqlite3&quot;&gt;соединения с базой данных&lt;/a&gt; в ответ на действие меню &amp;laquo;Файл / Открыть&amp;raquo;, а затем разрушать соответствующее &lt;a href=&quot;c3ref/sqlite3&quot;&gt;соединение с базой данных&lt;/a&gt; в ответ на меню &amp;laquo;Файл / Закрыть&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="e4e81b55d5c98ead21919f5ad70f41ad3433a3b2" translate="yes" xml:space="preserve">
          <source>Many applications use SQLite as a cache of relevant content from an enterprise RDBMS. This reduces latency, since most queries now occur against the local cache and avoid a network round-trip. It also reduces the load on the network and on the central database server. And in many cases, it means that the client-side application can continue operating during network outages.</source>
          <target state="translated">Многие приложения используют SQLite в качестве кэша соответствующего контента корпоративной СУБД.Это сокращает задержки,поскольку большинство запросов теперь выполняется против локального кэша и позволяет избежать обхода сети.Это также снижает нагрузку на сеть и центральный сервер базы данных.А во многих случаях это означает,что клиентское приложение может продолжать работать во время сбоев в сети.</target>
        </trans-unit>
        <trans-unit id="0a456e7268dde3087ce48e51e3014a05bf0f0916" translate="yes" xml:space="preserve">
          <source>Many code simplifications and obscure bug fixes in support of providing &lt;a href=&quot;testing#coverage&quot;&gt;100% branch test coverage&lt;/a&gt;.</source>
          <target state="translated">Множество упрощений кода и неясных исправлений ошибок в поддержку обеспечения &lt;a href=&quot;testing#coverage&quot;&gt;100% покрытия тестами ветвей&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a1bfd103f34c0767adc1c7bc9d7d6d545e23cabf" translate="yes" xml:space="preserve">
          <source>Many documentation updates</source>
          <target state="translated">Многие обновления документации</target>
        </trans-unit>
        <trans-unit id="3c83fd215f6013569c8872261f46c5842b6f52ba" translate="yes" xml:space="preserve">
          <source>Many examples of complete and working loadable extensions can be seen in the SQLite source tree in the &lt;a href=&quot;https://www.sqlite.org/src/file/ext/misc&quot;&gt;ext/misc&lt;/a&gt; subdirectory. Each file in that directory is a separate extension. Documentation is provided by a header comment on the file. Here are brief notes on a few of the extensions in the &lt;a href=&quot;https://www.sqlite.org/src/file/ext/misc&quot;&gt;ext/misc&lt;/a&gt; subdirectory:</source>
          <target state="translated">Многие примеры полных и работающих загружаемых расширений можно увидеть в дереве исходного кода SQLite в подкаталоге &lt;a href=&quot;https://www.sqlite.org/src/file/ext/misc&quot;&gt;ext / misc&lt;/a&gt; . Каждый файл в этом каталоге имеет отдельное расширение. Документация предоставляется в виде комментария к файлу в заголовке. Вот краткие заметки о некоторых расширениях в подкаталоге &lt;a href=&quot;https://www.sqlite.org/src/file/ext/misc&quot;&gt;ext / misc&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="c27368aaf7a63c4c54dd85e130e6a371a0b652db" translate="yes" xml:space="preserve">
          <source>Many improvements and cleanups to the configure script</source>
          <target state="translated">Множество улучшений и чисток в сценарии настройки</target>
        </trans-unit>
        <trans-unit id="478a301b607ffcc6373478ce0ad5e01e286e6440" translate="yes" xml:space="preserve">
          <source>Many improvements and enhancements to the shell.</source>
          <target state="translated">Множество усовершенствований и улучшений в корпусе.</target>
        </trans-unit>
        <trans-unit id="86f119ce378fd6fb5c391277ea97047cef855bbe" translate="yes" xml:space="preserve">
          <source>Many improvements to the test suite. Test coverage now exceeded 98%</source>
          <target state="translated">Множество улучшений в тестовом комплекте.Покрытие теста теперь превысило 98%</target>
        </trans-unit>
        <trans-unit id="ec9cc9f8a731e2c88a6a0e04dca8da72cc53d489" translate="yes" xml:space="preserve">
          <source>Many micro-optimizations result in 20.3% more work for the same number of CPU cycles relative to the previous release. The cumulative performance increase since &lt;a href=&quot;#version_3_8_0&quot;&gt;version 3.8.0&lt;/a&gt; is 61%. (Measured using &lt;a href=&quot;http://valgrind.org/docs/manual/cg-manual.html&quot;&gt;cachegrind&lt;/a&gt; on the &lt;a href=&quot;http://www.sqlite.org/src/artifact/83f6b3318f7ee&quot;&gt;speedtest1.c&lt;/a&gt; workload on Ubuntu 13.10 x64 with gcc 4.8.1 and -Os. Your performance may vary.)</source>
          <target state="translated">Многие микрооптимизации приводят к увеличению объема работы на 20,3% при том же количестве циклов процессора по сравнению с предыдущим выпуском. Совокупное увеличение производительности с &lt;a href=&quot;#version_3_8_0&quot;&gt;версии 3.8.0&lt;/a&gt; составляет 61%. (Измерено с помощью &lt;a href=&quot;http://valgrind.org/docs/manual/cg-manual.html&quot;&gt;cachegrind&lt;/a&gt; на рабочей нагрузке &lt;a href=&quot;http://www.sqlite.org/src/artifact/83f6b3318f7ee&quot;&gt;speedtest1.c&lt;/a&gt; в Ubuntu 13.10 x64 с gcc 4.8.1 и -Os. Ваша производительность может отличаться.)</target>
        </trans-unit>
        <trans-unit id="1070ccc184f5ee6e5132e8f78957c23f5d18aeb1" translate="yes" xml:space="preserve">
          <source>Many micro-optimizations, resulting in a library that is faster than the previous release.</source>
          <target state="translated">Множество микро-оптимизаций,в результате чего библиотека быстрее предыдущего релиза.</target>
        </trans-unit>
        <trans-unit id="ef73d713f7e1172e113f066199b34719f6daec88" translate="yes" xml:space="preserve">
          <source>Many minor bug fixes</source>
          <target state="translated">Множество мелких исправлений</target>
        </trans-unit>
        <trans-unit id="d82e20d7c9c34c867cdbaaabca856ec1debc82ea" translate="yes" xml:space="preserve">
          <source>Many nuisance bugs fixed.</source>
          <target state="translated">Исправлено много неприятных ошибок.</target>
        </trans-unit>
        <trans-unit id="a8c23cdfb8fba87694bb2dbb013754a5354d8db3" translate="yes" xml:space="preserve">
          <source>Many of the parameters passed to the &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt; family of interfaces are common across the entire family.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58cc54792f79ad7e4a6c20e286dbf7226ea88ce5" translate="yes" xml:space="preserve">
          <source>Many of the routines in the SQLite &lt;a href=&quot;c3ref/intro&quot;&gt;C-language Interface&lt;/a&gt; return numeric result codes indicating either success or failure, and in the event of a failure, providing some idea of the cause of the failure. This document strives to explain what each of those numeric result codes means.</source>
          <target state="translated">Многие подпрограммы в &lt;a href=&quot;c3ref/intro&quot;&gt;интерфейсе на языке C&lt;/a&gt; SQLite возвращают числовые коды результатов, указывающие на успех или неудачу, а в случае неудачи - на некоторое представление о причине сбоя. В этом документе делается попытка объяснить, что означает каждый из этих числовых кодов результатов.</target>
        </trans-unit>
        <trans-unit id="684a0cdf6fba65d365077c8562625db95e85aea3" translate="yes" xml:space="preserve">
          <source>Many operations, especially I/O intensive operations, can be faster since content does need to be copied between kernel space and user space.</source>
          <target state="translated">Многие операции,особенно интенсивные операции ввода/вывода,могут быть более быстрыми,так как содержимое необходимо копировать между пространством ядра и пространством пользователя.</target>
        </trans-unit>
        <trans-unit id="e75f87ad413b2b989beb9904a93bbc6902b68acd" translate="yes" xml:space="preserve">
          <source>Many programs use &lt;a href=&quot;http://man.he.net/man3/fopen&quot;&gt;fopen()&lt;/a&gt;, &lt;a href=&quot;http://man.he.net/man3/fread&quot;&gt;fread()&lt;/a&gt;, and &lt;a href=&quot;http://man.he.net/man3/fwrite&quot;&gt;fwrite()&lt;/a&gt; to create and manage files of data in home-grown formats. SQLite works particularly well as a replacement for these</source>
          <target state="translated">Многие программы используют &lt;a href=&quot;http://man.he.net/man3/fopen&quot;&gt;fopen ()&lt;/a&gt; , &lt;a href=&quot;http://man.he.net/man3/fread&quot;&gt;fread ()&lt;/a&gt; и &lt;a href=&quot;http://man.he.net/man3/fwrite&quot;&gt;fwrite ()&lt;/a&gt; для создания файлов данных в собственных форматах и ​​управления ими. SQLite особенно хорошо работает в качестве замены этих</target>
        </trans-unit>
        <trans-unit id="58c8d3506d92b491bec9b8982cb696fb925723f6" translate="yes" xml:space="preserve">
          <source>Many readers have recommended various third-party GUIs for Git that might do a better job of showing historical development activity. Maybe some of them do work better than native Git and/or GitHub, though they will all be hampered by the fact that Git does not preserve historical branch names across syncs. And even if those other tools are better, the fact that it is necessary to go to a third-party tool to get the information desired does not speak well of the core system.</source>
          <target state="translated">Многие читатели рекомендовали различные графические интерфейсы сторонних разработчиков для Git'а,которые могли бы лучше показать историческую активность в развитии.Может быть,некоторые из них работают лучше,чем родные Git и/или GitHub,хотя им всем будет мешать тот факт,что Git не сохраняет исторические названия ветвей через синхронизацию.И даже если эти другие инструменты лучше,тот факт,что для получения желаемой информации нужно обратиться к стороннему инструменту,не очень хорошо говорит о системе ядра.</target>
        </trans-unit>
        <trans-unit id="57a3139bc8f04dd188f9b7807c96ec2f953e86dc" translate="yes" xml:space="preserve">
          <source>Many small performance optimizations.</source>
          <target state="translated">Множество небольших оптимизаций производительности.</target>
        </trans-unit>
        <trans-unit id="575ebc9be57deafee12eee1cb275aca14943f68c" translate="yes" xml:space="preserve">
          <source>Many, many bug fixes and compatibility enhancements.</source>
          <target state="translated">Многие,многие исправления ошибок и улучшения совместимости.</target>
        </trans-unit>
        <trans-unit id="305801fe337dfa5f8bad0f9f9e15662ddae791a8" translate="yes" xml:space="preserve">
          <source>Many, many minor bug fixes and documentation updates.</source>
          <target state="translated">Много,много мелких исправлений и обновлений документации.</target>
        </trans-unit>
        <trans-unit id="35ddb236d4c17515cfe7146a42b5a461cee3e50c" translate="yes" xml:space="preserve">
          <source>Master Journal Pointer</source>
          <target state="translated">Мастер-Журнал Указка</target>
        </trans-unit>
        <trans-unit id="9abc1c7f8fc32d4d49746263693941601091cb5d" translate="yes" xml:space="preserve">
          <source>Master journal</source>
          <target state="translated">Мастер-журнал</target>
        </trans-unit>
        <trans-unit id="cb9cc1ceef6f81a9f36806b03b083dc9a2408c5e" translate="yes" xml:space="preserve">
          <source>Master journals</source>
          <target state="translated">магистрские журналы</target>
        </trans-unit>
        <trans-unit id="7b5111bfd1045a8ecdd3554c1e9631c35ec01ef6" translate="yes" xml:space="preserve">
          <source>Matches if both query1 and query2 match.</source>
          <target state="translated">Сопоставляется,если оба запроса1 и запрос2 совпадают.</target>
        </trans-unit>
        <trans-unit id="1abd40ea027c30a30c262947ec1298a0d519b4e6" translate="yes" xml:space="preserve">
          <source>Matches if either query1 or query2 match.</source>
          <target state="translated">Сопоставляется,если запрос1 или запрос2 совпадает.</target>
        </trans-unit>
        <trans-unit id="51cd172796c27ae8bf6aa95066f1e3c65189a939" translate="yes" xml:space="preserve">
          <source>Matches if query1 matches and query2 does not match.</source>
          <target state="translated">Совпадает,если запрос1 совпадает,а запрос2-нет.</target>
        </trans-unit>
        <trans-unit id="bd5c38104019f7a3a298ccf7253423afa28167b4" translate="yes" xml:space="preserve">
          <source>Matchinfo b flag</source>
          <target state="translated">Флаг Матчинфо b</target>
        </trans-unit>
        <trans-unit id="c836afd188ddb1668f2e9e6d198ffaad1a60d7a2" translate="yes" xml:space="preserve">
          <source>Matchinfo x flag</source>
          <target state="translated">флаг Matchinfo x</target>
        </trans-unit>
        <trans-unit id="1cd52c33bad6e28fab493f91164add2569119727" translate="yes" xml:space="preserve">
          <source>Matchinfo y flag</source>
          <target state="translated">Матчинфо и флаг</target>
        </trans-unit>
        <trans-unit id="eba78e6ccaca884931e9772ee282f8ff7b915236" translate="yes" xml:space="preserve">
          <source>Materializations of views and subqueries</source>
          <target state="translated">Материализации представлений и подзапросов</target>
        </trans-unit>
        <trans-unit id="b44a1f3f0332ddaecfe37d45239aca1621b1d815" translate="yes" xml:space="preserve">
          <source>Mathematical operators (+, -, *, /, %, &amp;lt;&amp;lt;, &amp;gt;&amp;gt;, &amp;amp;, and |) interpret both operands as if they were numbers. STRING or BLOB operands automatically convert into REAL or INTEGER values. If the STRING or BLOB looks like a real number (if it has a decimal point or an exponent) or if the value is outside the range that can be represented as a 64-bit signed integer, then it converts to REAL. Otherwise the operand converts to INTEGER. The implied type conversion of mathematical operands is slightly different from &lt;a href=&quot;lang_expr#castexpr&quot;&gt;CAST to NUMERIC&lt;/a&gt; in that string and BLOB values that look like real numbers but have no fractional part are kept as REAL instead of being converted into INTEGER as they would be for &lt;a href=&quot;lang_expr#castexpr&quot;&gt;CAST to NUMERIC&lt;/a&gt;. The conversion from STRING or BLOB into REAL or INTEGER is performed even if it is lossy and irreversible. Some mathematical operators (%, &amp;lt;&amp;lt;, &amp;gt;&amp;gt;, &amp;amp;, and |) expect INTEGER operands. For those operators, REAL operands are converted into INTEGER in the same way as a &lt;a href=&quot;lang_expr#castexpr&quot;&gt;CAST to INTEGER&lt;/a&gt;. The &amp;lt;&amp;lt;, &amp;gt;&amp;gt;, &amp;amp;, and | operators always return an INTEGER (or NULL) result, but the % operator returns either INTEGER or REAL (or NULL) depending on the type of its operands. A NULL operand on a mathematical operator yields a NULL result. An operand on a mathematical operator that does not look in any way numeric and is not NULL is converted to 0 or 0.0. Division by zero gives a result of NULL.</source>
          <target state="translated">Математические операторы (+, -, *, /,%, &amp;lt;&amp;lt;, &amp;gt;&amp;gt;, &amp;amp; и |) интерпретируют оба операнда, как если бы они были числами. Операнды STRING или BLOB автоматически преобразуются в значения REAL или INTEGER. Если СТРОКА или BLOB выглядит как вещественное число (если оно имеет десятичную точку или показатель степени) или если значение выходит за пределы диапазона, который может быть представлен как 64-битное целое число со знаком, то оно преобразуется в REAL. В противном случае операнд преобразуется в INTEGER. Подразумеваемое преобразование типов математических операндов немного отличается от &lt;a href=&quot;lang_expr#castexpr&quot;&gt;CAST в NUMERIC&lt;/a&gt; в этой строке, а значения BLOB, которые выглядят как действительные числа, но не имеют дробной части, сохраняются как REAL вместо преобразования в INTEGER, как это было бы для &lt;a href=&quot;lang_expr#castexpr&quot;&gt;CAST to NUMERIC&lt;/a&gt;. Преобразование из STRING или BLOB в REAL или INTEGER выполняется, даже если оно необратимо и с потерями. Некоторые математические операторы (%, &amp;lt;&amp;lt;, &amp;gt;&amp;gt;, &amp;amp; и |) ожидают операнды INTEGER. Для этих операторов операнды REAL преобразуются в INTEGER так же, как &lt;a href=&quot;lang_expr#castexpr&quot;&gt;CAST в INTEGER&lt;/a&gt; . &amp;lt;&amp;lt;, &amp;gt;&amp;gt;, &amp;amp; и | операторы всегда возвращают результат INTEGER (или NULL), но оператор% возвращает INTEGER или REAL (или NULL) в зависимости от типа его операндов. Операнд NULL в математическом операторе дает результат NULL. Операнд математического оператора, который никоим образом не выглядит числовым и не имеет значения NULL, преобразуется в 0 или 0,0. Деление на ноль дает результат NULL.</target>
        </trans-unit>
        <trans-unit id="1d9b8da2be0b14b678f29575b8bd5d6d1b4664b6" translate="yes" xml:space="preserve">
          <source>MaxPgcnt</source>
          <target state="translated">MaxPgcnt</target>
        </trans-unit>
        <trans-unit id="6cf7147e1932d9bf8b6d38604abfcfd205a85da8" translate="yes" xml:space="preserve">
          <source>Maximum embedded payload fraction. Must be 64.</source>
          <target state="translated">Максимальная встроенная доля полезной нагрузки.Должно быть 64.</target>
        </trans-unit>
        <trans-unit id="24d9373f317266755bd6dbb0fc6450a4905171c2" translate="yes" xml:space="preserve">
          <source>Maximum rowid</source>
          <target state="translated">Максимальный ряд</target>
        </trans-unit>
        <trans-unit id="5bc432c657fe4144bd45d936698c166acecd18fa" translate="yes" xml:space="preserve">
          <source>Maximum xShmLock index</source>
          <target state="translated">Максимальный индекс xShmLock</target>
        </trans-unit>
        <trans-unit id="77e5adb0194b8d8026832696c1f2c7818741ee2e" translate="yes" xml:space="preserve">
          <source>Maxopen parameter</source>
          <target state="translated">Макс.значение параметра</target>
        </trans-unit>
        <trans-unit id="0cccb688a9f1ffa766c4517a7aa3af7c04fd578c" translate="yes" xml:space="preserve">
          <source>May you do good and not evil</source>
          <target state="translated">Пусть ты делаешь добро,а не зло.</target>
        </trans-unit>
        <trans-unit id="8b1b4d5262b0d017f35623d6ebe39d0b87517497" translate="yes" xml:space="preserve">
          <source>May you find forgiveness for yourself and forgive others</source>
          <target state="translated">Пусть ты найдешь прощение для себя и простишь других.</target>
        </trans-unit>
        <trans-unit id="580b0f5d2afa3fc028fd1cbe9832972ae188e8d2" translate="yes" xml:space="preserve">
          <source>May you share freely, never taking more than you give.</source>
          <target state="translated">Пусть ты делишься свободно,никогда не беря больше,чем даешь.</target>
        </trans-unit>
        <trans-unit id="19cd7d185cfd95a703e62d43597e9ae28e0646e5" translate="yes" xml:space="preserve">
          <source>Meaning</source>
          <target state="translated">Meaning</target>
        </trans-unit>
        <trans-unit id="4916cdca74bd290a34e18174e1358515f2ca12e0" translate="yes" xml:space="preserve">
          <source>Measure the performance for reading blobs from the database and from individual files using these commands:</source>
          <target state="translated">Измерьте производительность для чтения блоков из базы данных и из отдельных файлов с помощью этих команд:</target>
        </trans-unit>
        <trans-unit id="32d3f574c379f02e466ab9d634b2afa7cedf3a39" translate="yes" xml:space="preserve">
          <source>Measure write performance by adding the --update option. This causes the blobs are overwritten in place with another random blob of exactly the same size.</source>
          <target state="translated">Измерьте производительность записи,добавив опцию -update.Это приводит к тому,что капли перезаписываются на месте другим случайным блоком точно такого же размера.</target>
        </trans-unit>
        <trans-unit id="f8f8ae177706bfa8cf72569452745c1f4cb10ab6" translate="yes" xml:space="preserve">
          <source>Measured using cachegrind on Ubuntu 16.04 on x64 with gcc 5.4.0 and -Os.</source>
          <target state="translated">Измерено с помощью кэшфренда на Ubuntu 16.04 на x64 с gcc 5.4.0 и -O.</target>
        </trans-unit>
        <trans-unit id="b32c8e35e5b4b276295d8f91c2b0f1620f45e186" translate="yes" xml:space="preserve">
          <source>Measurements above were conducted using SQLite version &lt;a href=&quot;https://sqlite.org/src/timeline?c=5594a121bf132a98&quot;&gt;5594a121bf132a98&lt;/a&gt; from 2017-10-08.</source>
          <target state="translated">Вышеуказанные измерения проводились с использованием SQLite версии &lt;a href=&quot;https://sqlite.org/src/timeline?c=5594a121bf132a98&quot;&gt;5594a121bf132a98&lt;/a&gt; от 08.10.2017.</target>
        </trans-unit>
        <trans-unit id="201062f4cfcc7a2c58dc61b839eac4c989004f31" translate="yes" xml:space="preserve">
          <source>Measuring and Reducing CPU Usage in SQLite</source>
          <target state="translated">Измерение и сокращение использования процессора в SQLite</target>
        </trans-unit>
        <trans-unit id="d815eeb251818f42b639c19483653cb9e9676a23" translate="yes" xml:space="preserve">
          <source>MemMax</source>
          <target state="translated">MemMax</target>
        </trans-unit>
        <trans-unit id="57b0394c856fac60e784f92bcfff68951cf81266" translate="yes" xml:space="preserve">
          <source>Memory Allocation Routines</source>
          <target state="translated">Маршруты распределения памяти</target>
        </trans-unit>
        <trans-unit id="3a30329db6460c4ed15bebe4d427af9052e6678f" translate="yes" xml:space="preserve">
          <source>Memory Allocation Subsystem</source>
          <target state="translated">Подсистема распределения памяти</target>
        </trans-unit>
        <trans-unit id="f5bd12480983914d8406751d31133ba86381302d" translate="yes" xml:space="preserve">
          <source>Memory Allocator Statistics</source>
          <target state="translated">Статистика распределителя памяти</target>
        </trans-unit>
        <trans-unit id="8ee60155b22e766b4de73dc4f683f3ac25fa009b" translate="yes" xml:space="preserve">
          <source>Memory Slot</source>
          <target state="translated">Слот памяти</target>
        </trans-unit>
        <trans-unit id="ea9be83a8f265809341121ab4ff9c58d527a1bdd" translate="yes" xml:space="preserve">
          <source>Memory accounting is disabled using a combination of the &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;#sqliteconfigmemstatus&quot;&gt;SQLITE_CONFIG_MEMSTATUS&lt;/a&gt;,...) start-time option and the &lt;a href=&quot;compile#default_memstatus&quot;&gt;SQLITE_DEFAULT_MEMSTATUS&lt;/a&gt; compile-time option.</source>
          <target state="translated">Учет памяти отключается с помощью комбинации параметра времени начала &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config&lt;/a&gt; ( &lt;a href=&quot;#sqliteconfigmemstatus&quot;&gt;SQLITE_CONFIG_MEMSTATUS&lt;/a&gt; , ...) и параметра &lt;a href=&quot;compile#default_memstatus&quot;&gt;времени&lt;/a&gt; компиляции SQLITE_DEFAULT_MEMSTATUS .</target>
        </trans-unit>
        <trans-unit id="83484b2c23e2c43deda0dd88234486f9158814f3" translate="yes" xml:space="preserve">
          <source>Memory accounting is disabled using a combination of the &lt;a href=&quot;config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c_config_covering_index_scan#sqliteconfigmemstatus&quot;&gt;SQLITE_CONFIG_MEMSTATUS&lt;/a&gt;,...) start-time option and the &lt;a href=&quot;../compile#default_memstatus&quot;&gt;SQLITE_DEFAULT_MEMSTATUS&lt;/a&gt; compile-time option.</source>
          <target state="translated">Учет памяти отключается с помощью комбинации параметра времени начала &lt;a href=&quot;config&quot;&gt;sqlite3_config&lt;/a&gt; ( &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigmemstatus&quot;&gt;SQLITE_CONFIG_MEMSTATUS&lt;/a&gt; , ...) и параметра &lt;a href=&quot;../compile#default_memstatus&quot;&gt;времени&lt;/a&gt; компиляции SQLITE_DEFAULT_MEMSTATUS .</target>
        </trans-unit>
        <trans-unit id="c90d2f9e1fbdf5d88900e51c0817d79397425f44" translate="yes" xml:space="preserve">
          <source>Memory allocation statistics are enabled by default unless SQLite is compiled with &lt;a href=&quot;../compile#default_memstatus&quot;&gt;SQLITE_DEFAULT_MEMSTATUS&lt;/a&gt;=0 in which case memory allocation statistics are disabled by default.</source>
          <target state="translated">Статистика выделения памяти включена по умолчанию, если SQLite не скомпилирован с &lt;a href=&quot;../compile#default_memstatus&quot;&gt;SQLITE_DEFAULT_MEMSTATUS&lt;/a&gt; = 0, и в этом случае статистика выделения памяти отключена по умолчанию.</target>
        </trans-unit>
        <trans-unit id="36fecd267945c46262e4527e9008734a419499a2" translate="yes" xml:space="preserve">
          <source>Memory allocation statistics are enabled by default unless SQLite is compiled with &lt;a href=&quot;compile#default_memstatus&quot;&gt;SQLITE_DEFAULT_MEMSTATUS&lt;/a&gt;=0 in which case memory allocation statistics are disabled by default.</source>
          <target state="translated">Статистика выделения памяти включена по умолчанию, если SQLite не скомпилирован с &lt;a href=&quot;compile#default_memstatus&quot;&gt;SQLITE_DEFAULT_MEMSTATUS&lt;/a&gt; = 0, и в этом случае статистика выделения памяти отключена по умолчанию.</target>
        </trans-unit>
        <trans-unit id="30cf1b800d03b60f9a295eac5e3ee911eb40a567" translate="yes" xml:space="preserve">
          <source>Memory allocation, caseless string comparison routines, portable text-to-number conversion routines, and other utilities are located in &lt;a href=&quot;https://sqlite.org/src/file/src/util.c&quot;&gt;util.c&lt;/a&gt;. Symbol tables used by the parser are maintained by hash tables found in &lt;a href=&quot;https://sqlite.org/src/file/src/hash.c&quot;&gt;hash.c&lt;/a&gt;. The &lt;a href=&quot;https://sqlite.org/src/file/src/utf.c&quot;&gt;utf.c&lt;/a&gt; source file contains Unicode conversion subroutines. SQLite has its own private implementation of &lt;a href=&quot;printf&quot;&gt;printf()&lt;/a&gt; (with some extensions) in &lt;a href=&quot;https://sqlite.org/src/file/src/printf.c&quot;&gt;printf.c&lt;/a&gt; and its own pseudo-random number generator (PRNG) in &lt;a href=&quot;https://sqlite.org/src/file/src/random.c&quot;&gt;random.c&lt;/a&gt;.</source>
          <target state="translated">Распределение памяти, подпрограммы сравнения строк без корпуса, портативные процедуры преобразования текста в номер и другие коммунальные услуги находятся в &lt;a href=&quot;https://sqlite.org/src/file/src/util.c&quot;&gt;util.c&lt;/a&gt; . Символ таблица , используемый анализатор поддерживается хэш - таблицами , найденных в &lt;a href=&quot;https://sqlite.org/src/file/src/hash.c&quot;&gt;hash.c&lt;/a&gt; . &lt;a href=&quot;https://sqlite.org/src/file/src/utf.c&quot;&gt;Utf.c&lt;/a&gt; исходный файл содержит подпрограммы преобразования Unicode. SQLite имеет собственную частную реализацию &lt;a href=&quot;printf&quot;&gt;printf ()&lt;/a&gt; (с некоторыми расширениями) в &lt;a href=&quot;https://sqlite.org/src/file/src/printf.c&quot;&gt;printf.c&lt;/a&gt; и собственный генератор псевдослучайных чисел (PRNG) в &lt;a href=&quot;https://sqlite.org/src/file/src/random.c&quot;&gt;random.c&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8351f935d7e0b92d4dbd88ff6014fc3cfebc6b06" translate="yes" xml:space="preserve">
          <source>Memory statistics</source>
          <target state="translated">Статистика памяти</target>
        </trans-unit>
        <trans-unit id="0b3951c84915f2636f64c4da056f2bbaa63121ac" translate="yes" xml:space="preserve">
          <source>Memory to hold the information returned by &lt;b&gt;sqlite_get_table&lt;/b&gt; is obtained from malloc(). But the calling function should not try to free this information directly. Instead, pass the complete table to &lt;b&gt;sqlite_free_table&lt;/b&gt; when the table is no longer needed. It is safe to call &lt;b&gt;sqlite_free_table&lt;/b&gt; with a NULL pointer such as would be returned if the result set is empty.</source>
          <target state="translated">Память для хранения информации, возвращаемой &lt;b&gt;sqlite_get_table&lt;/b&gt; , получается из malloc (). Но вызывающая функция не должна пытаться напрямую освободить эту информацию. Вместо этого передайте всю таблицу в &lt;b&gt;sqlite_free_table,&lt;/b&gt; когда таблица больше не нужна. Можно безопасно вызывать &lt;b&gt;sqlite_free_table&lt;/b&gt; с указателем NULL, который будет возвращен, если набор результатов пуст.</target>
        </trans-unit>
        <trans-unit id="0ebf6aa26b7b4fd9c6127be506bafbc4c2292df8" translate="yes" xml:space="preserve">
          <source>Memory-Mapped I/O</source>
          <target state="translated">Память-отображенные входы/выходы</target>
        </trans-unit>
        <trans-unit id="7640161f9a59fd693f768ecd9272e3177311b46c" translate="yes" xml:space="preserve">
          <source>Memsys4 and memsys6 were experimental memory allocators introduced in around 2007 and subsequently removed from the source tree in around 2008, after it became clear that they added no new value.</source>
          <target state="translated">Memsys4 и memsys6 были экспериментальными аллокаторами памяти,введенными примерно в 2007 году,а затем удаленными из дерева исходных текстов примерно в 2008 году,после того,как стало ясно,что они не добавили никакой новой ценности.</target>
        </trans-unit>
        <trans-unit id="53e5e9eaf00f6f480e84b07b830bf50ed69b3504" translate="yes" xml:space="preserve">
          <source>Merge development changes into the main trunk. Future work toward using a BTree file structure will use a separate CVS source tree. This CVS tree will continue to support the GDBM version of SQLite only.</source>
          <target state="translated">Объедините изменения развития в основной ствол.В дальнейшей работе по использованию файловой структуры BTree будет использоваться отдельное дерево исходников CVS.Это CVS-дерево будет продолжать поддерживать только GDBM-версию SQLite.</target>
        </trans-unit>
        <trans-unit id="1c69f87311ee49961b7db4c6959bf9e564173753" translate="yes" xml:space="preserve">
          <source>MergePatch can add, modify, or delete elements of a JSON Object, and so for JSON Objects, the json_patch() routine is a generalized replacement for &lt;a href=&quot;json1#jset&quot;&gt;json_set()&lt;/a&gt; and &lt;a href=&quot;json1#jrm&quot;&gt;json_remove()&lt;/a&gt;. However, MergePatch treats JSON Array objects as atomic. MergePatch cannot append to an Array nor modify individual elements of an Array. It can only insert, replace, or delete the whole Array as a single unit. Hence, json_patch() is not as useful when dealing with JSON that includes Arrays, especially Arrays with lots of substructure.</source>
          <target state="translated">MergePatch может добавлять, изменять или удалять элементы объекта JSON, поэтому для объектов JSON процедура json_patch () является обобщенной заменой для &lt;a href=&quot;json1#jset&quot;&gt;json_set ()&lt;/a&gt; и &lt;a href=&quot;json1#jrm&quot;&gt;json_remove ()&lt;/a&gt; . Однако MergePatch рассматривает объекты JSON Array как атомарные. MergePatch не может добавлять в массив или изменять отдельные элементы массива. Он может вставлять, заменять или удалять только весь массив как единое целое. Следовательно, json_patch () не так полезен при работе с JSON, который включает в себя массивы, особенно массивы с большим количеством подструктур.</target>
        </trans-unit>
        <trans-unit id="b34856a8252222662370c82e139676a40460db4d" translate="yes" xml:space="preserve">
          <source>Merged the &lt;a href=&quot;sessionintro&quot;&gt;session&lt;/a&gt; extension into trunk.</source>
          <target state="translated">Слил расширение &lt;a href=&quot;sessionintro&quot;&gt;сеанса&lt;/a&gt; в транк.</target>
        </trans-unit>
        <trans-unit id="dbaecd82c952801d0bb82c4bd7a41de66b9fda44" translate="yes" xml:space="preserve">
          <source>Metadata is returned by writing to the memory locations passed as the 5th and subsequent parameters to this function. Any of these arguments may be NULL, in which case the corresponding element of metadata is omitted.</source>
          <target state="translated">Метаданные возвращаются путем записи в ячейки памяти,переданные в качестве 5-го и последующих параметров этой функции.Любой из этих аргументов может быть NULL,в этом случае соответствующий элемент метаданных опускается.</target>
        </trans-unit>
        <trans-unit id="4d3732872bb2a9906cc1153aeb2590dd048c19aa" translate="yes" xml:space="preserve">
          <source>Method (2) offers a midpoint between (1) and (3). Using this method, a query such as '1s*' will match documents that contain the literal token &quot;1st&quot;, but not &quot;first&quot; (assuming the tokenizer is not able to provide synonyms for prefixes). However, a non-prefix query like '1st' will match against &quot;1st&quot; and &quot;first&quot;. This method does not require extra disk space, as no extra entries are added to the FTS index. On the other hand, it may require more CPU cycles to run MATCH queries, as separate queries of the FTS index are required for each synonym.</source>
          <target state="translated">Метод (2)предлагает среднюю точку между (1)и (3).При использовании этого метода запрос типа '1s*' будет сопоставлять документы,содержащие буквальную лексель &quot;1&quot;,но не &quot;первый&quot; (в предположении,что токенайзер не может предоставить синонимов для префиксов).Однако,не префиксный запрос типа '1' будет совпадать с &quot;1&quot; и &quot;первым&quot;.Этот метод не требует дополнительного дискового пространства,так как в индекс FTS не добавляются дополнительные записи.С другой стороны,для выполнения MATCH-запросов может потребоваться большее количество циклов процессора,так как для каждого синонима требуется отдельный запрос индекса FTS.</target>
        </trans-unit>
        <trans-unit id="1df213a45649b1f66258f5768182bafcd559f0b9" translate="yes" xml:space="preserve">
          <source>Methods: &lt;a href=&quot;#sqlite3_blob_bytes&quot;&gt;sqlite3_blob_bytes()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_blob_read&quot;&gt;sqlite3_blob_read()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_blob_reopen&quot;&gt;sqlite3_blob_reopen()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_blob_write&quot;&gt;sqlite3_blob_write()&lt;/a&gt;</source>
          <target state="translated">Методы: &lt;a href=&quot;#sqlite3_blob_bytes&quot;&gt;sqlite3_blob_bytes ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_blob_read&quot;&gt;sqlite3_blob_read ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_blob_reopen&quot;&gt;sqlite3_blob_reopen ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_blob_write&quot;&gt;sqlite3_blob_write ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1b9983b06e527d46d817373bc15d13089f4d3e12" translate="yes" xml:space="preserve">
          <source>Methods: &lt;a href=&quot;#sqlite3_snapshot_cmp&quot;&gt;sqlite3_snapshot_cmp()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_snapshot_open&quot;&gt;sqlite3_snapshot_open()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_snapshot_recover&quot;&gt;sqlite3_snapshot_recover()&lt;/a&gt;</source>
          <target state="translated">Методы: &lt;a href=&quot;#sqlite3_snapshot_cmp&quot;&gt;sqlite3_snapshot_cmp ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_snapshot_open&quot;&gt;sqlite3_snapshot_open ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_snapshot_recover&quot;&gt;sqlite3_snapshot_recover ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="547fb3fd92f4ba766d2b81080903dd2fa70ddd7a" translate="yes" xml:space="preserve">
          <source>Methods: &lt;a href=&quot;#sqlite3changegroup_add&quot;&gt;sqlite3changegroup_add()&lt;/a&gt;, &lt;a href=&quot;#sqlite3changegroup_output&quot;&gt;sqlite3changegroup_output()&lt;/a&gt;</source>
          <target state="translated">Методы: &lt;a href=&quot;#sqlite3changegroup_add&quot;&gt;sqlite3changegroup_add ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3changegroup_output&quot;&gt;sqlite3changegroup_output ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5ba8e151eaa184a6fb4bcf2ae01f52e3682b9b04" translate="yes" xml:space="preserve">
          <source>Methods: &lt;a href=&quot;blob_bytes&quot;&gt;sqlite3_blob_bytes()&lt;/a&gt;, &lt;a href=&quot;blob_read&quot;&gt;sqlite3_blob_read()&lt;/a&gt;, &lt;a href=&quot;blob_reopen&quot;&gt;sqlite3_blob_reopen()&lt;/a&gt;, &lt;a href=&quot;blob_write&quot;&gt;sqlite3_blob_write()&lt;/a&gt;</source>
          <target state="translated">Методы: &lt;a href=&quot;blob_bytes&quot;&gt;sqlite3_blob_bytes ()&lt;/a&gt; , &lt;a href=&quot;blob_read&quot;&gt;sqlite3_blob_read ()&lt;/a&gt; , &lt;a href=&quot;blob_reopen&quot;&gt;sqlite3_blob_reopen ()&lt;/a&gt; , &lt;a href=&quot;blob_write&quot;&gt;sqlite3_blob_write ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="05bb53e8fd80fd00914dd4034f12bb335994738a" translate="yes" xml:space="preserve">
          <source>Methods: &lt;a href=&quot;snapshot_cmp&quot;&gt;sqlite3_snapshot_cmp()&lt;/a&gt;, &lt;a href=&quot;snapshot_open&quot;&gt;sqlite3_snapshot_open()&lt;/a&gt;, &lt;a href=&quot;snapshot_recover&quot;&gt;sqlite3_snapshot_recover()&lt;/a&gt;</source>
          <target state="translated">Методы: &lt;a href=&quot;snapshot_cmp&quot;&gt;sqlite3_snapshot_cmp ()&lt;/a&gt; , &lt;a href=&quot;snapshot_open&quot;&gt;sqlite3_snapshot_open ()&lt;/a&gt; , &lt;a href=&quot;snapshot_recover&quot;&gt;sqlite3_snapshot_recover ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="80b86f6f0bb9183c80c83fe634331b034c5a3b6c" translate="yes" xml:space="preserve">
          <source>Methods: &lt;a href=&quot;sqlite3changegroup_add&quot;&gt;sqlite3changegroup_add()&lt;/a&gt;, &lt;a href=&quot;sqlite3changegroup_output&quot;&gt;sqlite3changegroup_output()&lt;/a&gt;</source>
          <target state="translated">Методы: &lt;a href=&quot;sqlite3changegroup_add&quot;&gt;sqlite3changegroup_add ()&lt;/a&gt; , &lt;a href=&quot;sqlite3changegroup_output&quot;&gt;sqlite3changegroup_output ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="91126b8550d89c2cabd56ad5c8ea6415436ef4e7" translate="yes" xml:space="preserve">
          <source>Millions and millions of test cases</source>
          <target state="translated">Миллионы и миллионы тестовых случаев</target>
        </trans-unit>
        <trans-unit id="8cb901663cd153748076b7a4eed655ac9c9ceb63" translate="yes" xml:space="preserve">
          <source>Minimum embedded payload fraction. Must be 32.</source>
          <target state="translated">Минимальная встроенная доля полезной нагрузки.Должно быть 32.</target>
        </trans-unit>
        <trans-unit id="9f5a0ef3646738848b65efb74e98db2b2c5a359b" translate="yes" xml:space="preserve">
          <source>Minimum rowid</source>
          <target state="translated">Минимальный ряд</target>
        </trans-unit>
        <trans-unit id="62a01943e842ea4e97ec6b470d86e59a45ec37a1" translate="yes" xml:space="preserve">
          <source>Minor revisions to the website.</source>
          <target state="translated">Незначительные изменения на сайте.</target>
        </trans-unit>
        <trans-unit id="e2f772b3f3e4226648620e3b2d22fc9e06b7af3b" translate="yes" xml:space="preserve">
          <source>Minor syntactic changes to support a wider variety of compilers.</source>
          <target state="translated">Незначительные синтаксические изменения для поддержки более широкого круга компиляторов.</target>
        </trans-unit>
        <trans-unit id="a207d914072a9004f7af9edb9092f93397750bdb" translate="yes" xml:space="preserve">
          <source>Minor tweaks to other code to make it run a little faster.</source>
          <target state="translated">Незначительные подстройки к другому коду,чтобы заставить его работать немного быстрее.</target>
        </trans-unit>
        <trans-unit id="5f2cbd107037ed23248e5058a7a64cd6bae05468" translate="yes" xml:space="preserve">
          <source>Miscellaneous</source>
          <target state="translated">Miscellaneous</target>
        </trans-unit>
        <trans-unit id="b80fca6a605a77935ff5f5e3122df5de2dfd1555" translate="yes" xml:space="preserve">
          <source>Miscellaneous &lt;a href=&quot;cpu#microopt&quot;&gt;microoptimizations&lt;/a&gt; reduce CPU usage by about 2.1%.</source>
          <target state="translated">Разные &lt;a href=&quot;cpu#microopt&quot;&gt;микрооптимизации&lt;/a&gt; снижают загрузку процессора примерно на 2,1%.</target>
        </trans-unit>
        <trans-unit id="28c8a44394b5bc456bad4c873373e406d652fe87" translate="yes" xml:space="preserve">
          <source>Miscellaneous code size optimizations and bug fixes</source>
          <target state="translated">Различные оптимизации размера кода и исправления ошибок</target>
        </trans-unit>
        <trans-unit id="bbb81db24ef06a2153135306601290fda608c2da" translate="yes" xml:space="preserve">
          <source>Miscellaneous documentation enhancements.</source>
          <target state="translated">Различные улучшения в документации.</target>
        </trans-unit>
        <trans-unit id="98990a8e0a243a1fdf56c721a0da9558936ac95e" translate="yes" xml:space="preserve">
          <source>Miscellaneous micro-optimizations reduce CPU usage by more than 7% on common workloads. Most optimization in this release has been on the front-end (&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt;).</source>
          <target state="translated">Разные микрооптимизации снижают использование ЦП более чем на 7% при обычных рабочих нагрузках. Большая часть оптимизации в этом выпуске была &lt;a href=&quot;c3ref/prepare&quot;&gt;сделана во внешнем&lt;/a&gt; интерфейсе ( sqlite3_prepare_v2 () ).</target>
        </trans-unit>
        <trans-unit id="fbdfeb6f538d5f7f87b9990239ba0793588dd6eb" translate="yes" xml:space="preserve">
          <source>Miscellaneous micro-optimizations result in 22.3% more work for the same number of CPU cycles relative to the previous release. SQLite now runs twice as fast as &lt;a href=&quot;#version_3_8_0&quot;&gt;version 3.8.0&lt;/a&gt; and three times as fast as &lt;a href=&quot;#version_3_3_9&quot;&gt;version 3.3.9&lt;/a&gt;. (Measured using &lt;a href=&quot;http://valgrind.org/docs/manual/cg-manual.html&quot;&gt;cachegrind&lt;/a&gt; on the &lt;a href=&quot;http://www.sqlite.org/src/artifact/83f6b3318f7ee&quot;&gt;speedtest1.c&lt;/a&gt; workload on Ubuntu 14.04 x64 with gcc 4.8.2 and -Os. Your performance may vary.)</source>
          <target state="translated">Различные микрооптимизации приводят к увеличению объема работы на 22,3% при том же количестве циклов процессора по сравнению с предыдущим выпуском. SQLite теперь работает в два раза быстрее, чем &lt;a href=&quot;#version_3_8_0&quot;&gt;версия 3.8.0,&lt;/a&gt; и в три раза быстрее, чем &lt;a href=&quot;#version_3_3_9&quot;&gt;версия 3.3.9&lt;/a&gt; . (Измерено с помощью &lt;a href=&quot;http://valgrind.org/docs/manual/cg-manual.html&quot;&gt;cachegrind&lt;/a&gt; на рабочей нагрузке &lt;a href=&quot;http://www.sqlite.org/src/artifact/83f6b3318f7ee&quot;&gt;speedtest1.c&lt;/a&gt; в Ubuntu 14.04 x64 с gcc 4.8.2 и -Os. Ваша производительность может отличаться.)</target>
        </trans-unit>
        <trans-unit id="fc459de1c05b709bda425ad3c5816738720eebc5" translate="yes" xml:space="preserve">
          <source>Miscellaneous minor bug fixes</source>
          <target state="translated">Различные мелкие исправления ошибок</target>
        </trans-unit>
        <trans-unit id="44d1c5c9aa54a9db91e7e7fe347ac18190d724ed" translate="yes" xml:space="preserve">
          <source>Miscellaneous optimizations result in a 2% reduction in &lt;a href=&quot;cpu&quot;&gt;CPU cycles used&lt;/a&gt;.</source>
          <target state="translated">Различные оптимизации приводят к сокращению &lt;a href=&quot;cpu&quot;&gt;используемых циклов процессора&lt;/a&gt; на 2% .</target>
        </trans-unit>
        <trans-unit id="f1774acabb62d5801f41470f6cd189b2c0aaaf3c" translate="yes" xml:space="preserve">
          <source>Miscellaneous performance enhancements</source>
          <target state="translated">Различные способы повышения эффективности</target>
        </trans-unit>
        <trans-unit id="276e26893215e7c8d37e726040961fa631182ebb" translate="yes" xml:space="preserve">
          <source>Miscellaneous problem words such as &quot;debt&quot;, &quot;tsetse&quot;, &quot;Nguyen&quot;, &quot;Van Nuyes&quot;.</source>
          <target state="translated">Различные проблемные слова,такие как &quot;долг&quot;,&quot;цецеце&quot;,&quot;Нгуен&quot;,&quot;Ван Нюэс&quot;.</target>
        </trans-unit>
        <trans-unit id="4f0711bb69728ffde416a549e0f91f702e273516" translate="yes" xml:space="preserve">
          <source>Misformatted records</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c46987b5699d45998eb4a1f03a81d222b78e342" translate="yes" xml:space="preserve">
          <source>Missing callback</source>
          <target state="translated">Пропущенный обратный звонок</target>
        </trans-unit>
        <trans-unit id="55fd1e5df760c82f67c5509ea619f439d18e5b37" translate="yes" xml:space="preserve">
          <source>Missing or surplus index entries</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96732b61a8d377ada7b914c38aba1cf0d28297dd" translate="yes" xml:space="preserve">
          <source>Missing pages</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1570b7a7267e412717981829df93815ef1f5214" translate="yes" xml:space="preserve">
          <source>Modern filesystems operate faster when disk accesses are sequential. Hence, SQLite will run faster if the content of the database file is on sequential pages. To find out what fraction of the pages in a database are sequential (and thus obtain a measurement that might be useful in determining when to &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt;), run a query like the following:</source>
          <target state="translated">Современные файловые системы работают быстрее при последовательном доступе к диску. Следовательно, SQLite будет работать быстрее, если содержимое файла базы данных находится на последовательных страницах. Чтобы узнать, какая часть страниц в базе данных является последовательной (и, таким образом, получить измерение, которое может быть полезно при определении того, когда выполнять &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; ), запустите запрос, подобный следующему:</target>
        </trans-unit>
        <trans-unit id="213d5e141cc4f1fbdb215e4e1d09c9f135e23841" translate="yes" xml:space="preserve">
          <source>Modifications to the &lt;a href=&quot;c3ref/vfs&quot;&gt;virtual file system&lt;/a&gt; interface to support a wider range of embedded systems. See &lt;a href=&quot;35to36&quot;&gt;35to36.html&lt;/a&gt; for additional information. *** Potentially incompatible change ***</source>
          <target state="translated">Модификации интерфейса &lt;a href=&quot;c3ref/vfs&quot;&gt;виртуальной файловой системы&lt;/a&gt; для поддержки более широкого диапазона встроенных систем. См. &lt;a href=&quot;35to36&quot;&gt;35to36.html&lt;/a&gt; для получения дополнительной информации. *** Потенциально несовместимое изменение ***</target>
        </trans-unit>
        <trans-unit id="846a3f594ccb25f4d8b90bf39076621c7a3da386" translate="yes" xml:space="preserve">
          <source>Modifications to the &lt;a href=&quot;lemon&quot;&gt;Lemon parser generator&lt;/a&gt; so that the parser tables are 4 times smaller.</source>
          <target state="translated">Модификации &lt;a href=&quot;lemon&quot;&gt;генератора синтаксического анализатора Lemon,&lt;/a&gt; чтобы таблицы синтаксического анализатора были в 4 раза меньше.</target>
        </trans-unit>
        <trans-unit id="a373b9c05e3506597302158ddcc81e7b79ce6310" translate="yes" xml:space="preserve">
          <source>Modified &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt; and &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigscratch&quot;&gt;SQLITE_CONFIG_SCRATCH&lt;/a&gt; to remove the &quot;+4&quot; magic number in the buffer size computation.</source>
          <target state="translated">Модифицированный &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt; и &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigscratch&quot;&gt;SQLITE_CONFIG_SCRATCH&lt;/a&gt; удалить &amp;laquo;+4&amp;raquo; магическое число в вычислении размера буфера.</target>
        </trans-unit>
        <trans-unit id="7ae047108ffb132cb41d3775cac528b7c36bd9c6" translate="yes" xml:space="preserve">
          <source>Modified the &lt;b&gt;sqlite&lt;/b&gt; shell program to print the schema for the built-in SQLITE_MASTER table, if explicitly requested.</source>
          <target state="translated">Измененный &lt;b&gt;SQLite&lt;/b&gt; оболочка программы для печати схемы для встроенного sqlite_master таблицы, если явно просил.</target>
        </trans-unit>
        <trans-unit id="64b762eca0515a688c77ad3f10cd0b574a4463f3" translate="yes" xml:space="preserve">
          <source>Modified the &lt;b&gt;sqlite&lt;/b&gt; shell program to use the new interface routines.</source>
          <target state="translated">Измененный &lt;b&gt;SQLite&lt;/b&gt; оболочки программы , чтобы использовать новые процедуры интерфейса.</target>
        </trans-unit>
        <trans-unit id="9bea3abf3349ced7a2bd684045cab38caa6bf680" translate="yes" xml:space="preserve">
          <source>Modified the &lt;b&gt;sqlite&lt;/b&gt; shell to make use of the new sqlite_get_table() API in order to print a list of tables in multiple columns, similar to the way &quot;ls&quot; prints filenames.</source>
          <target state="translated">Измененный &lt;b&gt;SQLite&lt;/b&gt; оболочку , чтобы сделать использование нового sqlite_get_table () API для того , чтобы напечатать список таблиц в нескольких столбцах, подобно тому, как &amp;laquo;LS&amp;raquo; печатает имена файлов.</target>
        </trans-unit>
        <trans-unit id="d9d09adf1be852d2030f454ddcb0fb1bbde85e4b" translate="yes" xml:space="preserve">
          <source>Modified the &lt;b&gt;sqlite&lt;/b&gt; shell to print a semicolon at the end of each CREATE statement in the output of the &quot;.schema&quot; command.</source>
          <target state="translated">Измененный &lt;b&gt;SQLite&lt;/b&gt; оболочку напечатать точку с запятой в конце каждого CREATE заявление в выводе команды &amp;laquo;.schema&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="cecf75f0a6c4e051f8158a879b4378a1d3e737c4" translate="yes" xml:space="preserve">
          <source>Modified the B-Tree and Pager modules so that disk pages that do not contain real data (free pages) are not journaled and are not written from memory back to the disk when they change. This does not impact database integrity, since the pages contain no real data, but it does make large INSERT operations about 2.5 times faster and large DELETEs about 5 times faster.</source>
          <target state="translated">Модули B-Tree и Pager были модифицированы таким образом,чтобы страницы диска,не содержащие реальных данных (свободные страницы),не записывались в журнал и не записывались из памяти обратно на диск при их изменении.Это не влияет на целостность базы данных,так как страницы не содержат реальных данных,но делают большие операции INSERT примерно в 2,5 раза быстрее,а большие операции DELETE примерно в 5 раз быстрее.</target>
        </trans-unit>
        <trans-unit id="2c4d4de8cb2205ec2b07c88e0fe421ab99dc0aaa" translate="yes" xml:space="preserve">
          <source>Modified the journal file format to make it more resistant to corruption that can occur after an OS crash or power failure.</source>
          <target state="translated">Изменен формат файла журнала,чтобы сделать его более устойчивым к повреждениям,которые могут произойти после сбоя операционной системы или отключения питания.</target>
        </trans-unit>
        <trans-unit id="3a7ea294bf33134dce4b142b8b7182de29b978b2" translate="yes" xml:space="preserve">
          <source>Modifiers</source>
          <target state="translated">Modifiers</target>
        </trans-unit>
        <trans-unit id="2d258a9a354e69d26a5737aed0d98ba4a12d4ab3" translate="yes" xml:space="preserve">
          <source>Modify the TCL interface to use &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt;.</source>
          <target state="translated">Измените интерфейс TCL, чтобы использовать &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9c186ff83bfc4ba49c92b1876d399ba40e64a0cc" translate="yes" xml:space="preserve">
          <source>Modify the test scripts to identify tests that depend on system load and processor speed and to warn the user that a failure of one of those (rare) tests does not necessarily mean the library is malfunctioning. No changes to code.</source>
          <target state="translated">Модифицируйте тестовые скрипты,чтобы определить тесты,зависящие от нагрузки системы и скорости процессора,и предупредить пользователя о том,что сбой одного из этих (редких)тестов не обязательно означает неисправность библиотеки.Никаких изменений в коде.</target>
        </trans-unit>
        <trans-unit id="ef40b73dad75552add2180adc162c800be16bf41" translate="yes" xml:space="preserve">
          <source>Modifying the contents of a database page.</source>
          <target state="translated">Изменение содержимого страницы базы данных.</target>
        </trans-unit>
        <trans-unit id="56d9419099fd345280bf9a9122ad284109000f7d" translate="yes" xml:space="preserve">
          <source>Modifying, Adding or Truncating a Database Page</source>
          <target state="translated">Изменение,добавление или усечение страницы базы данных</target>
        </trans-unit>
        <trans-unit id="d9ae0b87be39aed320fa35b9e4b820b36d71a71f" translate="yes" xml:space="preserve">
          <source>More aggressive &lt;a href=&quot;compile#omit_floating_point&quot;&gt;SQLITE_OMIT_FLOATING_POINT&lt;/a&gt;</source>
          <target state="translated">Более агрессивный &lt;a href=&quot;compile#omit_floating_point&quot;&gt;SQLITE_OMIT_FLOATING_POINT&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="150e84142afe50eae5e55924e9aafb441ae8328b" translate="yes" xml:space="preserve">
          <source>More aggressive optimization of the AND operator when one side or the other is always false.</source>
          <target state="translated">Более агрессивная оптимизация оператора AND,когда та или иная сторона всегда ложна.</target>
        </trans-unit>
        <trans-unit id="4dccd541fa7b33732e530432dc181f83dcc6ba6e" translate="yes" xml:space="preserve">
          <source>More complex queries may or may not be able to employ query flattening to avoid the temporary table. Whether or not the query can be flattened depends on such factors as whether or not the subquery or outer query contain aggregate functions, ORDER BY or GROUP BY clauses, LIMIT clauses, and so forth. The rules for when a query can and cannot be flattened are very complex and are beyond the scope of this document.</source>
          <target state="translated">Более сложные запросы могут использовать или не использовать сплющивание запросов,чтобы избежать временной таблицы.Сглаживание запроса зависит от таких факторов,как наличие или отсутствие в подзапросе или внешнем запросе агрегатных функций,оговорок ORDER BY или GROUP BY,оговорок LIMIT и так далее.Правила того,когда запрос может быть сплющен,а когда нет,очень сложны и выходят за рамки этого документа.</target>
        </trans-unit>
        <trans-unit id="0e965ef66116c7e835a08b23bc0aea20069b16ec" translate="yes" xml:space="preserve">
          <source>More efficient encoding of boolean values resulting in smaller database files</source>
          <target state="translated">Более эффективное кодирование булевых значений,что приводит к меньшему размеру файлов базы данных.</target>
        </trans-unit>
        <trans-unit id="bc15bc11932b9e3bb7aa3bd3cd6dd3273dc66921" translate="yes" xml:space="preserve">
          <source>More efficient handling of &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt;, especially in cases where the application defines hundreds or thousands of custom functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a3c60573ba6ac75355060c30752d85d7e4a4ea7" translate="yes" xml:space="preserve">
          <source>More efficient handling of &lt;a href=&quot;c3ref/create_function&quot;&gt;application-defined SQL functions&lt;/a&gt;, especially in cases where the application defines hundreds or thousands of custom functions.</source>
          <target state="translated">Более эффективная обработка &lt;a href=&quot;c3ref/create_function&quot;&gt;определяемых приложением функций SQL&lt;/a&gt; , особенно в случаях, когда приложение определяет сотни или тысячи пользовательских функций.</target>
        </trans-unit>
        <trans-unit id="bbf641e990dbd768fc579b21dbc73f3e38164565" translate="yes" xml:space="preserve">
          <source>More efficient implementation of sqliteFileExists() under Windows. (by Joel Luscy)</source>
          <target state="translated">Более эффективная реализация sqliteFileExists()под Windows.(автор Джоэл Ласси)</target>
        </trans-unit>
        <trans-unit id="da802536bedcdb71b26438d22c88c54625f47a34" translate="yes" xml:space="preserve">
          <source>More robust handling of out-of-memory errors.</source>
          <target state="translated">Более надежная обработка ошибок вне памяти.</target>
        </trans-unit>
        <trans-unit id="f0bbe298877a69ce96299f0684d775b43d33f438" translate="yes" xml:space="preserve">
          <source>More suggestions...</source>
          <target state="translated">Больше предложений...</target>
        </trans-unit>
        <trans-unit id="40a15bddc2f46eb54c50912ec8296652a2a161bf" translate="yes" xml:space="preserve">
          <source>More than one NEAR operator may appear in a single query. In this case each pair of terms or phrases separated by a NEAR operator must appear within the specified proximity of each other in the document. Using the same table and data as in the block of examples above:</source>
          <target state="translated">В одном запросе может появиться более одного оператора NEAR.В этом случае каждая пара терминов или словосочетаний,разделенных оператором NEAR,должна появляться в пределах указанной близости друг от друга в документе.Используйте ту же таблицу и данные,что и в блоке примеров выше:</target>
        </trans-unit>
        <trans-unit id="759136a5c089af122dabc1e0771753f48776ccec" translate="yes" xml:space="preserve">
          <source>Most CVEs written about SQLite assume that the attacker is able to run arbitrary SQL scripts in SQLite. In most applications, this means that there must first be an SQL Injection vulnerability that allows the attacker to inject the malicious SQL.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8eaec9acde05ea65cc7e78b52370752d8ff824b" translate="yes" xml:space="preserve">
          <source>Most R*Tree queries use a depth-first search. This is accomplished by setting the rScore equal to iLevel. A depth-first search is usually preferred since it minimizes the number of elements in the priority queue, which reduces memory requirements and speeds processing. However, some application may prefer a breadth-first search, which can be accomplished by setting rScore to mxLevel-iLevel. By creating more complex formulas for rScore, applications can exercise detailed control over the order in which subtree are searched and leaf R*Tree entries are returned. For example, in an application with many millions of R*Tree entries, the rScore might be arranged so that the largest or most significant entries are returned first, allowing the application to display the most important information quickly, and filling in smaller and less important details as they become available.</source>
          <target state="translated">Большинство запросов R*Tree используют глубинный поиск.Это достигается установкой rScore равным iLevel.Обычно предпочтительнее использовать глубинный поиск,так как он минимизирует количество элементов в очереди приоритетов,что снижает требования к памяти и ускоряет обработку.Тем не менее,некоторые приложения могут предпочесть поиск по глубине,что можно сделать,установив rScore равным mxLevel-iLevel.Создавая более сложные формулы для rScore,приложения могут осуществлять детальный контроль над порядком,в котором выполняется поиск в поддереве и возвращаются элементы листа R*Tree.Например,в приложении с миллионами записей R*Tree,rScore может быть устроена так,что сначала будут возвращены самые большие или наиболее важные записи,что позволит приложению быстро отображать наиболее важную информацию,а также заполнять более мелкие и менее важные детали по мере их появления.</target>
        </trans-unit>
        <trans-unit id="0b7d92086a8e46f293a7dca57cb6a5c138416054" translate="yes" xml:space="preserve">
          <source>Most SQL database engines (every SQL database engine other than SQLite, as far as we know) uses static, rigid typing. With static typing, the datatype of a value is determined by its container - the particular column in which the value is stored.</source>
          <target state="translated">Большинство движков баз данных SQL (каждый движок баз данных SQL,кроме SQLite,насколько мы знаем)использует статический,жесткий набор текста.При статическом вводе тип значения определяется его контейнером-конкретным столбцом,в котором хранится значение.</target>
        </trans-unit>
        <trans-unit id="0b21de15eb7e27a08d9b4ec057ceb748bbaa22cd" translate="yes" xml:space="preserve">
          <source>Most SQL database engines are client/server based. Of those that are serverless, SQLite is the only one known to this author that allows multiple applications to access the same database at the same time.</source>
          <target state="translated">Большинство движков баз данных SQL основаны на клиенте/сервере.Из тех,которые являются безсерверными,SQLite-единственный известный этому автору,который позволяет нескольким приложениям получать доступ к одной базе данных одновременно.</target>
        </trans-unit>
        <trans-unit id="27297778565294594247653539b897aca8f2a9fb" translate="yes" xml:space="preserve">
          <source>Most SQL database engines are client/server based. Of those that are serverless, SQLite is the only one that this author knows of that allows multiple applications to access the same database at the same time.</source>
          <target state="translated">Большинство движков баз данных SQL основаны на клиенте/сервере.Из тех,которые являются безсерверными,SQLite-единственный,о котором знает автор,позволяющий нескольким приложениям получать доступ к одной и той же базе данных одновременно.</target>
        </trans-unit>
        <trans-unit id="260ad8dfcdd6cee164826174f5ff18a6d6796783" translate="yes" xml:space="preserve">
          <source>Most SQL database engines are implemented as a separate server process. Programs that want to access the database communicate with the server using some kind of interprocess communication (typically TCP/IP) to send requests to the server and to receive back results. SQLite does not work this way. With SQLite, the process that wants to access the database reads and writes directly from the database files on disk. There is no intermediary server process.</source>
          <target state="translated">Большинство движков баз данных SQL реализованы как отдельный серверный процесс.Программы,которые хотят получить доступ к базе данных,взаимодействуют с сервером,используя некий вид межпроцессного взаимодействия (обычно TCP/IP)для отправки запросов к серверу и получения обратно результатов.SQLite не работает таким образом.С SQLite процесс,который хочет получить доступ к базе данных,читает и записывает непосредственно из файлов базы данных на диск.Нет никакого промежуточного серверного процесса.</target>
        </trans-unit>
        <trans-unit id="e11debe28c45aae3eb5d59593787d087cef00a39" translate="yes" xml:space="preserve">
          <source>Most SQL database engines store the schema already parsed into various system tables. On those database engines, ALTER TABLE merely has to make modifications to the corresponding system tables.</source>
          <target state="translated">Большинство движков баз данных SQL хранят уже разобранную схему в различных системных таблицах.На этих двигателях БД ALTER TABLE приходится лишь вносить изменения в соответствующие системные таблицы.</target>
        </trans-unit>
        <trans-unit id="c8146f85b00a04238b33c2841ef39833177b149b" translate="yes" xml:space="preserve">
          <source>Most SQL database engines use static typing. A datatype is associated with each column in a table and only values of that particular datatype are allowed to be stored in that column. SQLite relaxes this restriction by using manifest typing. In manifest typing, the datatype is a property of the value itself, not of the column in which the value is stored. SQLite thus allows the user to store any value of any datatype into any column regardless of the declared type of that column. (There are some exceptions to this rule: An INTEGER PRIMARY KEY column may only store integers. And SQLite attempts to coerce values into the declared datatype of the column when it can.)</source>
          <target state="translated">Большинство движков баз данных SQL используют статический набор текста.Тип данных ассоциируется с каждым столбцом таблицы,и только значения этого типа данных могут храниться в этом столбце.SQLite снимает это ограничение,используя манифестный набор текста.При явном вводе тип данных является свойством самого значения,а не столбца,в котором хранится значение.Таким образом,SQLite позволяет пользователю хранить любое значение любого типа данных в любом столбце,независимо от объявленного типа этого столбца.(Есть некоторые исключения из этого правила:В столбце INTEGER PRIMARY KEY могут храниться только целые числа.И SQLite пытается принудить значения к декларированному типу данных столбца,когда это возможно).</target>
        </trans-unit>
        <trans-unit id="725952f518d7037ff04756bd99d602eae557b1ce" translate="yes" xml:space="preserve">
          <source>Most application formats fit into one of these three categories:</source>
          <target state="translated">Большинство форматов приложений попадает в одну из этих трех категорий:</target>
        </trans-unit>
        <trans-unit id="d19cf0ebd0035eff768792dfdb24fc34ef35cd23" translate="yes" xml:space="preserve">
          <source>Most applications can use SQLite without having to worry about bugs in obscure SQL inputs. If the application controls the SQL, and the application is not deliberately trying to break SQLite, then everything should just work. It is not necessary to have the latest patched version of SQLite. Any older version should work just fine.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce502bced488a9855f9633bf314ed3f557c5599e" translate="yes" xml:space="preserve">
          <source>Most applications will only use the session module functionality described in the previous section. However, the following additional functionality is available for the use and manipulation of changeset and patchset blobs:</source>
          <target state="translated">Большинство приложений будут использовать только функциональность сеансового модуля,описанную в предыдущем разделе.Однако для использования и манипулирования блоками changeset и patchset доступна следующая дополнительная функциональность:</target>
        </trans-unit>
        <trans-unit id="cd513c058fc14329a86bc7561ce2383e9150f5ca" translate="yes" xml:space="preserve">
          <source>Most applications work great with SQLite in its default configuration and with no special compile-time configuration. Most developers should be able to completely ignore this document and simply build SQLite from &lt;a href=&quot;amalgamation&quot;&gt;the amalgamation&lt;/a&gt; without any special knowledge and without taking any special actions.</source>
          <target state="translated">Большинство приложений отлично работают с SQLite в его конфигурации по умолчанию и без специальной конфигурации во время компиляции. Большинство разработчиков должны иметь возможность полностью игнорировать этот документ и просто создавать SQLite из &lt;a href=&quot;amalgamation&quot;&gt;объединения&lt;/a&gt; без каких-либо специальных знаний и без каких-либо специальных действий.</target>
        </trans-unit>
        <trans-unit id="635fff5a9d997771ed833778dcd946f9fa076040" translate="yes" xml:space="preserve">
          <source>Most builds also use the system memory allocation routines:</source>
          <target state="translated">Большинство сборок также используют процедуры выделения системной памяти:</target>
        </trans-unit>
        <trans-unit id="c757f57c7c0fc6a3a16a4ba481be29df77f7ba0d" translate="yes" xml:space="preserve">
          <source>Most built-in window functions ignore the frame-spec, the exceptions being first_value(), last_value() and nth_value(). It is a syntax error to specify a FILTER clause as part of a built-in window function invocation.</source>
          <target state="translated">Большинство встроенных оконных функций игнорируют frame-spec,исключениями являются first_value(),last_value()и nth_value().Синтаксической ошибкой является указание выражения FILTER как части вызова встроенной оконной функции.</target>
        </trans-unit>
        <trans-unit id="91aff38100948ec7606e7b9be6940203c42b637c" translate="yes" xml:space="preserve">
          <source>Most memory statistics are global, and therefore the tracking of statistics must be serialized with a mutex. Statistics are turned on by default, but an option exists to disable them. By disabling memory statistics, SQLite avoids entering and leaving a mutex on each memory allocation and deallocation. That savings can be noticeable on systems where mutex operations are expensive. To disable memory statistics, the following interface is used at start-time:</source>
          <target state="translated">Большинство статистических данных в памяти являются глобальными,поэтому отслеживание статистики должно быть сериализовано с помощью мьютекса.По умолчанию статистика включена,но есть возможность ее отключить.Отключая статистику памяти,SQLite избегает входа и выхода из мьютекса при каждом выделении и распределении памяти.Такая экономия может быть заметна на системах,где операции мьютекса стоят дорого.Для отключения статистики памяти при запуске используется следующий интерфейс:</target>
        </trans-unit>
        <trans-unit id="3ddc29325f5f8b33e852a6ad2b01d9c1a5b27979" translate="yes" xml:space="preserve">
          <source>Most object references may only resolve to a specific type of object (for example a reference that is part of a DROP TABLE statement may only resolve to a table object, not an index, trigger or view). However in some contexts (e.g. &lt;a href=&quot;lang_reindex&quot;&gt;REINDEX&lt;/a&gt;) an object reference may be resolve to more than one type of object. When searching database schemas for a named object, objects of types that cannot be used in the context of the reference are always ignored.</source>
          <target state="translated">Большинство ссылок на объекты могут разрешаться только в определенный тип объекта (например, ссылка, которая является частью оператора DROP TABLE, может разрешаться только в объект таблицы, а не в индекс, триггер или представление). Однако в некоторых контекстах (например, &lt;a href=&quot;lang_reindex&quot;&gt;REINDEX&lt;/a&gt; ) ссылка на объект может быть разрешена для более чем одного типа объекта. При поиске в схемах базы данных именованного объекта объекты типов, которые нельзя использовать в контексте ссылки, всегда игнорируются.</target>
        </trans-unit>
        <trans-unit id="1f85923bce6297c36b3c44bb82e688cbd09f35ee" translate="yes" xml:space="preserve">
          <source>Most of the code in the SQLite source tree is devoted purely to &lt;a href=&quot;testing&quot;&gt;testing and verification&lt;/a&gt;. Reliability is important to SQLite. Among the tasks of the test infrastructure is to ensure that SQLite does not misuse dynamically allocated memory, that SQLite does not leak memory, and that SQLite responds correctly to a dynamic memory allocation failure.</source>
          <target state="translated">Большая часть кода в дереве исходных текстов SQLite предназначена исключительно для &lt;a href=&quot;testing&quot;&gt;тестирования и проверки&lt;/a&gt; . Для SQLite важна надежность. Среди задач тестовой инфраструктуры - убедиться, что SQLite не злоупотребляет динамически выделяемой памятью, что SQLite не вызывает утечки памяти и что SQLite правильно реагирует на сбой динамического выделения памяти.</target>
        </trans-unit>
        <trans-unit id="4ea1351b2e34fd10311e1e13ffcc8b793141d24f" translate="yes" xml:space="preserve">
          <source>Most of the time, sqlite3 just reads lines of input and passes them on to the SQLite library for execution. But input lines that begin with a dot (&quot;.&quot;) are intercepted and interpreted by the sqlite3 program itself. These &quot;dot commands&quot; are typically used to change the output format of queries, or to execute certain prepackaged query statements. There were originally just a few dot commands, but over the years many new features have accumulated so that today there over 60.</source>
          <target state="translated">В большинстве случаев sqlite3 просто читает строки ввода и передает их на исполнение в библиотеку SQLite.Но строки ввода,начинающиеся с точки (&quot;.&quot;)перехватываются и интерпретируются самой программой sqlite3.Эти &quot;точечные команды&quot; обычно используются для изменения формата вывода запросов или для выполнения определенных предупакованных операторов запроса.Изначально было всего несколько точечных команд,но с годами накопилось много новых возможностей,так что сегодня их более 60.</target>
        </trans-unit>
        <trans-unit id="8140e633bb506b56ea3ecec29c87f47b39a7e315" translate="yes" xml:space="preserve">
          <source>Most of the time, the query planner in SQLite does a good job. However, the query planner needs indices to work with. These indices must normally be added by programmers. Rarely, the query planner AI will make a suboptimal algorithm choice. In those cases, programmers may want to provide additional hints to help the query planner do a better job.</source>
          <target state="translated">В большинстве случаев планировщик запросов в SQLite делает хорошую работу.Однако для работы планировщика запросов нужны индексы.Как правило,эти индексы должны добавляться программистами.Редко бывает,что AI планировщик запросов сделает выбор субоптимального алгоритма.В этих случаях программисты,возможно,захотят предоставить дополнительные подсказки,чтобы помочь планировщику запросов сделать работу лучше.</target>
        </trans-unit>
        <trans-unit id="4d637cb6d91465469dba952401dcd3c4590d5c67" translate="yes" xml:space="preserve">
          <source>Most other SQL database engines allocated a fixed amount of disk space for each row in most tables. They play special tricks for handling BLOBs and CLOBs which can be of wildly varying length. But for most tables, if you declare a column to be a VARCHAR(100) then the database engine will allocate 100 bytes of disk space regardless of how much information you actually store in that column.</source>
          <target state="translated">Большинство других движков баз данных SQL выделяют фиксированное дисковое пространство для каждой строки в большинстве таблиц.Они проигрывают специальные трюки для работы с BLOB и CLOB,которые могут быть различной длины.Но для большинства таблиц,если вы объявите столбец VARCHAR(100),то движок базы данных выделит 100 байт дискового пространства независимо от того,сколько информации вы на самом деле храните в этом столбце.</target>
        </trans-unit>
        <trans-unit id="b52c62ddb6e76f10df4280114ef18bdd833e392c" translate="yes" xml:space="preserve">
          <source>Most other SQL database engines are much larger than this. IBM boasts that its recently released CloudScape database engine is &quot;only&quot; a 2MiB jar file - an order of magnitude larger than SQLite even after it is compressed! Firebird boasts that its client-side library is only 350KiB. That's as big as SQLite and does not even contain the database engine. The Berkeley DB library from Oracle is 450KiB and it omits SQL support, providing the programmer with only simple key/value pairs.</source>
          <target state="translated">Большинство других движков баз данных SQL гораздо больше.IBM может похвастаться тем,что его недавно выпущенный движок базы данных CloudScape-это &quot;всего лишь&quot; 2MiB jar-файл-на порядок больше,чем SQLite,даже после его сжатия! Firebird может похвастаться тем,что его клиентская библиотека составляет всего 350 КБ.Она такая же большая,как и SQLite,и даже не содержит движка базы данных.Библиотека БД Беркли от Oracle составляет 450 КБ и в ней отсутствует поддержка SQL,предоставляя программисту только простые пары ключ/значение.</target>
        </trans-unit>
        <trans-unit id="5dfe3bda7177abf58f732623f4daabfa91229422" translate="yes" xml:space="preserve">
          <source>Most other SQL database engines require you to dump and restore the database when moving from one platform to another and often when upgrading to a newer version of the software.</source>
          <target state="translated">Большинство других движков баз данных SQL требуют дампа и восстановления базы данных при переходе с одной платформы на другую и часто при обновлении на более новую версию программного обеспечения.</target>
        </trans-unit>
        <trans-unit id="879c0198beea8a0459677487adc544c847a7576f" translate="yes" xml:space="preserve">
          <source>Most programmers compile SQLite into their applications using the &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt;. The &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt; is C-code but it is not &quot;source code&quot;. The &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt; is generated from source code by scripts.</source>
          <target state="translated">Большинство программистов компилируют SQLite в свои приложения, используя &lt;a href=&quot;amalgamation&quot;&gt;объединение&lt;/a&gt; . &lt;a href=&quot;amalgamation&quot;&gt;Объединение&lt;/a&gt; является C-код , но это не &amp;laquo;исходный код&amp;raquo;. &lt;a href=&quot;amalgamation&quot;&gt;Объединение&lt;/a&gt; генерируется из исходного кода при помощи скриптов.</target>
        </trans-unit>
        <trans-unit id="e8416192176e318d00a7b55e02e8a608d8bdbda6" translate="yes" xml:space="preserve">
          <source>Most tables in SQLite consist of zero or more rows with a unique integer key (the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; or &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;) followed by content. (The exception is &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables.) The rows are logically stored in order of increasing rowid. As an example, this article uses a table named &quot;FruitsForSale&quot; which relates various fruits to the state where they are grown and their unit price at market. The schema is this:</source>
          <target state="translated">Большинство таблиц в SQLite состоят из нуля или более строк с уникальным целочисленным ключом ( &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; или &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; ), за которым следует содержимое. (Исключение составляют таблицы &lt;a href=&quot;withoutrowid&quot;&gt;БЕЗ ROWID&lt;/a&gt; .) Строки логически сохраняются в порядке увеличения rowid. В качестве примера в этой статье используется таблица &amp;laquo;FruitsForSale&amp;raquo;, которая связывает различные фрукты со штатом, в котором они выращиваются, и их рыночной ценой за единицу. Схема такая:</target>
        </trans-unit>
        <trans-unit id="22d0e010589dcfa569bc8ab54799e70d1b27d453" translate="yes" xml:space="preserve">
          <source>Most tables in a typical SQLite database schema are rowid tables.</source>
          <target state="translated">Большинство таблиц в типичной схеме базы данных SQLite-это рядные таблицы.</target>
        </trans-unit>
        <trans-unit id="ab23b25ac3bb6f94df4203c5e40926f8de962adb" translate="yes" xml:space="preserve">
          <source>Most users of swarmvtab will only use the features described above. This section describes features designed for more esoteric use cases. These features all involve specifying extra optional parameters following the SQL statement as part of the CREATE VIRTUAL TABLE command. An optional parameter is specified using its name, followed by an &quot;=&quot; character, followed by an optionally quoted value. Whitespace may separate the name, &quot;=&quot; character and value. For example:</source>
          <target state="translated">Большинство пользователей swarmvtab будут использовать только функции,описанные выше.В этом разделе описаны функции,предназначенные для более эзотерических случаев использования.Все эти функции включают в себя указание дополнительных опциональных параметров,следующих за SQL-оператором,как часть команды CREATE VIRTUAL TABLE.Дополнительный параметр задается с использованием его имени,за которым следует символ &quot;=&quot;,а затем опционально цитируемое значение.Пробельные символы могут разделять имя,символ &quot;=&quot; и значение.Например:</target>
        </trans-unit>
        <trans-unit id="76cdb950721642b6b8596d36d5a39f7705028b99" translate="yes" xml:space="preserve">
          <source>Move</source>
          <target state="translated">Move</target>
        </trans-unit>
        <trans-unit id="7e894652e8d984064189391f996d60397e2a48ec" translate="yes" xml:space="preserve">
          <source>Move a BLOB Handle to a New Row</source>
          <target state="translated">Переместите ручку BLOB в новый ряд.</target>
        </trans-unit>
        <trans-unit id="b0ff33b105569af9f2119de68af4d3ef24773b02" translate="yes" xml:space="preserve">
          <source>Move the P3 values in register P1..P1+P3-1 over into registers P2..P2+P3-1. Registers P1..P1+P3-1 are left holding a NULL. It is an error for register ranges P1..P1+P3-1 and P2..P2+P3-1 to overlap. It is an error for P3 to be less than 1.</source>
          <target state="translated">Переместите значения P3 в регистре P1...P1+P3-1 в регистр P2...P2+P3-1.Регистры P1...P1+P3-1 оставлены с NULL.Это ошибка для перекрытия диапазонов регистров P1...P1+P3-1 и P2...P2+P3-1.Это ошибка,когда P3 меньше 1.</target>
        </trans-unit>
        <trans-unit id="43e629ad230f33beeec0dc2dfe68b2611f083ba6" translate="yes" xml:space="preserve">
          <source>Move the cursor P1 to a null row. Any &lt;a href=&quot;opcode#Column&quot;&gt;Column&lt;/a&gt; operations that occur while the cursor is on the null row will always write a NULL.</source>
          <target state="translated">Переместите курсор P1 в пустую строку. Любые операции со &lt;a href=&quot;opcode#Column&quot;&gt;столбцами,&lt;/a&gt; которые происходят, когда курсор находится на нулевой строке, всегда будут записывать NULL.</target>
        </trans-unit>
        <trans-unit id="ff17aceff7878d14b853ed0faf40490493d4491b" translate="yes" xml:space="preserve">
          <source>Move website and documentation files out of the source tree into a &lt;a href=&quot;http://www.sqlite.org/docsrc/&quot;&gt;separate CM system&lt;/a&gt;.</source>
          <target state="translated">Переместите файлы веб-сайта и документации из дерева исходных текстов в &lt;a href=&quot;http://www.sqlite.org/docsrc/&quot;&gt;отдельную систему CM&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="42fda9211198a462ad90d286a7b4b2828423cc34" translate="yes" xml:space="preserve">
          <source>Moved the CVS repository to www.sqlite.org</source>
          <target state="translated">Переместил CVS репозиторий на www.sqlite.org.</target>
        </trans-unit>
        <trans-unit id="dc586a90c5c94a44d1d972ced97472cbaf4b949e" translate="yes" xml:space="preserve">
          <source>Moving From SQLite 3.4.2 to 3.5.0</source>
          <target state="translated">Переход с SQLite 3.4.2 на 3.5.0</target>
        </trans-unit>
        <trans-unit id="d4fefbd0278cf9b39cd3f466ee48861cfc5e39db" translate="yes" xml:space="preserve">
          <source>Moving From SQLite 3.5.9 to 3.6.0</source>
          <target state="translated">Переход с SQLite 3.5.9 на 3.6.0</target>
        </trans-unit>
        <trans-unit id="f76bc373feee6b1842d340bd7d664f80273b9cc9" translate="yes" xml:space="preserve">
          <source>Moving a journal file from one database to another.</source>
          <target state="translated">Перемещение файла журнала из одной базы данных в другую.</target>
        </trans-unit>
        <trans-unit id="f0efafe4edefbbfdb22e09fc7f8e1939d65fc935" translate="yes" xml:space="preserve">
          <source>Much of the &lt;a href=&quot;c3ref/intro&quot;&gt;C-language Interface&lt;/a&gt; is found in source files &lt;a href=&quot;https://sqlite.org/src/file/src/main.c&quot;&gt;main.c&lt;/a&gt;, &lt;a href=&quot;https://sqlite.org/src/file/src/legacy.c&quot;&gt;legacy.c&lt;/a&gt;, and &lt;a href=&quot;https://sqlite.org/src/file/src/vdbeapi.c&quot;&gt;vdbeapi.c&lt;/a&gt; though some routines are scattered about in other files where they can have access to data structures with file scope. The &lt;a href=&quot;c3ref/free_table&quot;&gt;sqlite3_get_table()&lt;/a&gt; routine is implemented in &lt;a href=&quot;https://sqlite.org/src/file/src/table.c&quot;&gt;table.c&lt;/a&gt;. The &lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_mprintf()&lt;/a&gt; routine is found in &lt;a href=&quot;https://sqlite.org/src/file/src/printf.c&quot;&gt;printf.c&lt;/a&gt;. The &lt;a href=&quot;c3ref/complete&quot;&gt;sqlite3_complete()&lt;/a&gt; interface is in &lt;a href=&quot;https://sqlite.org/src/file/src/complete.c&quot;&gt;complete.c&lt;/a&gt;. The &lt;a href=&quot;tclsqlite&quot;&gt;TCL Interface&lt;/a&gt; is implemented by &lt;a href=&quot;https://sqlite.org/src/file/src/tclsqlite.c&quot;&gt;tclsqlite.c&lt;/a&gt;.</source>
          <target state="translated">Большая часть &lt;a href=&quot;c3ref/intro&quot;&gt;интерфейса на языке C&lt;/a&gt; находится в исходных файлах &lt;a href=&quot;https://sqlite.org/src/file/src/main.c&quot;&gt;main.c&lt;/a&gt; , &lt;a href=&quot;https://sqlite.org/src/file/src/legacy.c&quot;&gt;legacy.c&lt;/a&gt; и &lt;a href=&quot;https://sqlite.org/src/file/src/vdbeapi.c&quot;&gt;vdbeapi.c,&lt;/a&gt; хотя некоторые подпрограммы разбросаны по другим файлам, где они могут иметь доступ к структурам данных с файловой областью. &lt;a href=&quot;c3ref/free_table&quot;&gt;Sqlite3_get_table ()&lt;/a&gt; подпрограмма реализуется в &lt;a href=&quot;https://sqlite.org/src/file/src/table.c&quot;&gt;table.c&lt;/a&gt; . &lt;a href=&quot;c3ref/mprintf&quot;&gt;Sqlite3_mprintf ()&lt;/a&gt; подпрограмма находится в &lt;a href=&quot;https://sqlite.org/src/file/src/printf.c&quot;&gt;printf.c&lt;/a&gt; . Интерфейс &lt;a href=&quot;c3ref/complete&quot;&gt;sqlite3_complete ()&lt;/a&gt; находится в &lt;a href=&quot;https://sqlite.org/src/file/src/complete.c&quot;&gt;complete.c&lt;/a&gt; . &lt;a href=&quot;tclsqlite&quot;&gt;TCL Интерфейс&lt;/a&gt; реализован &lt;a href=&quot;https://sqlite.org/src/file/src/tclsqlite.c&quot;&gt;tclsqlite.c&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0aeaa0f6e5bc7f27528f2732350cce3993158ba7" translate="yes" xml:space="preserve">
          <source>Multi-File Transactions</source>
          <target state="translated">Многофайловые операции</target>
        </trans-unit>
        <trans-unit id="7bd215d0dc08a639766c0fd92af7ca6bd919b359" translate="yes" xml:space="preserve">
          <source>Multi-character insertions, deletions, and substitutions can be enumerated in the cost table.</source>
          <target state="translated">Многосимвольные вставки,удаления и замены могут быть перечислены в таблице стоимости.</target>
        </trans-unit>
        <trans-unit id="658e2e2d073be17c3d24649adb63bc8071c4e34c" translate="yes" xml:space="preserve">
          <source>Multi-column indexes</source>
          <target state="translated">Многоколоночные индексы</target>
        </trans-unit>
        <trans-unit id="b37d6f5d76bdf33c501015c981f38efa402cfb25" translate="yes" xml:space="preserve">
          <source>Multi-column indices only work if the constraint terms in the WHERE clause of the query are connected by AND. So Idx3 and Idx4 are helpful when the search is for items that are both Oranges and grown in California, but neither index would be that useful if we wanted all items that were either oranges</source>
          <target state="translated">Индексы из нескольких столбцов работают только в том случае,если ограничительные условия в выражении WHERE запроса связаны с помощью AND.Таким образом,индексы Idx3 и Idx4 полезны,когда поиск ведется для элементов,которые одновременно являются оранжевыми и выросли в Калифорнии,но ни один из индексов не будет настолько полезен,если мы хотим,чтобы все элементы,которые были либо оранжевыми.</target>
        </trans-unit>
        <trans-unit id="a6a2f3477040c5c780afe34563348a368c865f18" translate="yes" xml:space="preserve">
          <source>Multiple Programming Languages</source>
          <target state="translated">Языки многократного программирования</target>
        </trans-unit>
        <trans-unit id="8127845d9b0c204fa8283356e673cf21f966c9a0" translate="yes" xml:space="preserve">
          <source>Multiple VFSes can be registered at the same time. Each VFS has a unique names. Separate &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt; within the same process can be using different VFSes at the same time. For that matter, if a single database connection has multiple database files open using the &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; command, then each attached database might be using a different VFS.</source>
          <target state="translated">Одновременно можно зарегистрировать несколько VFS. Каждая VFS имеет уникальные имена. Отдельные &lt;a href=&quot;c3ref/sqlite3&quot;&gt;соединения с базами данных&lt;/a&gt; в пределах того же процесса могут быть с использованием различных VFSes в то же самое время. В этом отношении, если одно соединение с базой данных имеет несколько файлов базы данных, открытых с помощью команды &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; , тогда каждая присоединенная база данных может использовать другую VFS.</target>
        </trans-unit>
        <trans-unit id="dcdea0a58cadff7c782d97a6048e7da5d88f4991" translate="yes" xml:space="preserve">
          <source>Multiple b-tree structures are used instead of a single b-tree to reduce the cost of inserting records into FTS tables. When a new record is inserted into an FTS table that already contains a lot of data, it is likely that many of the terms in the new record are already present in a large number of existing records. If a single b-tree were used, then large doclist structures would have to be loaded from the database, amended to include the new docid and term-offset list, then written back to the database. Using multiple b-tree tables allows this to be avoided by creating a new b-tree which can be merged with the existing b-tree (or b-trees) later on. Merging of b-tree structures can be performed as a background task, or once a certain number of separate b-tree structures have been accumulated. Of course, this scheme makes queries more expensive (as the FTS code may have to look up individual terms in more than one b-tree and merge the results), but it has been found that in practice this overhead is often negligible.</source>
          <target state="translated">Вместо одного b-дерева используются несколько b-деревянных структур для снижения затрат на вставку записей в таблицы FTS.Когда новая запись вставляется в таблицу ФСТ,которая уже содержит большое количество данных,вполне вероятно,что многие из терминов в новой записи уже присутствуют в большом количестве существующих записей.Если бы использовалось одно b-дерево,то пришлось бы загружать из БД большие doclist-структуры,изменять их таким образом,чтобы они включали новый docid и term-offset-список,а затем записывать их обратно в БД.Использование нескольких b-деревьев позволяет избежать этого путем создания нового b-дерева,которое впоследствии может быть объединено с существующим b-деревом (или b-деревом).Слияние b-деревянных структур может быть выполнено как фоновая задача,так и после накопления определенного количества отдельных b-деревянных структур.Конечно,такая схема делает запросы более дорогостоящими (так как код ФСТ может быть вынужден искать отдельные термины более чем в одном b-дереве и сливать результаты),но было обнаружено,что на практике эти накладные расходы зачастую ничтожно малы.</target>
        </trans-unit>
        <trans-unit id="46b7208fbb4e603607fdd8e005b8c2b44c4f2832" translate="yes" xml:space="preserve">
          <source>Multiple bug fixes to the &lt;a href=&quot;rowvalue&quot;&gt;row value&lt;/a&gt; logic that was introduced in version 3.15.0.</source>
          <target state="translated">Множественные исправления ошибок в логике &lt;a href=&quot;rowvalue&quot;&gt;значений строк,&lt;/a&gt; которые были введены в версии 3.15.0.</target>
        </trans-unit>
        <trans-unit id="5bf9dc54bb3a9335bc64c25972bec9a940f13e21" translate="yes" xml:space="preserve">
          <source>Multiple commentators have expressed a desire to use dynamic strings for the pointer type, and to have SQLite take ownership of the type strings and to automatically free the type string when it has finished using it. That design is rejected for the following reasons:</source>
          <target state="translated">Несколько комментаторов выразили желание использовать динамические строки для типа указателя,а также заставить SQLite взять в собственность строки типа и автоматически освободить строку типа после того,как он закончит использовать ее.Такая конструкция отвергается по следующим причинам:</target>
        </trans-unit>
        <trans-unit id="5989cfc9447928ba4d05b443c6d4b672ed4ef531" translate="yes" xml:space="preserve">
          <source>Multiple connections from within a single process that use this implementation of asynchronous IO may access a single database file concurrently. From the point of view of the user, if all connections are from within a single process, there is no difference between the concurrency offered by &quot;normal&quot; SQLite and SQLite using the asynchronous backend.</source>
          <target state="translated">Несколько соединений внутри одного процесса,использующих эту реализацию асинхронного ввода-вывода,могут одновременно получать доступ к одному файлу БД.С точки зрения пользователя,если все соединения находятся внутри одного процесса,то нет разницы между параллельностью,предлагаемой &quot;нормальным&quot; SQLite и SQLite,использующим асинхронный бэкэнд.</target>
        </trans-unit>
        <trans-unit id="de5017f80cc138eb92a9fee1631567420f1d53b1" translate="yes" xml:space="preserve">
          <source>Multiple connections may hold a read-lock simultaneously. If many threads are acquiring overlapping read-locks, it might be the case that at least one thread is always holding a read lock. Then a table waiting for a write-lock will wait forever. This scenario is called &quot;writer starvation.&quot;</source>
          <target state="translated">Несколько соединений могут содержать одновременно блокировку чтения.Если многие потоки приобретают перекрывающиеся блокировки чтения,может случиться так,что по крайней мере один поток всегда будет держать блокировку чтения.Тогда стол,ожидающий блокировки записи,будет ждать вечно.Этот сценарий называется &quot;голодной записью&quot;.</target>
        </trans-unit>
        <trans-unit id="809241f3730c6379db2c7c73b89d2efee62ec7f1" translate="yes" xml:space="preserve">
          <source>Multiple databases on the same &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; using &lt;a href=&quot;lang_attach&quot;&gt;ATTACH DATABASE&lt;/a&gt;</source>
          <target state="translated">Несколько баз данных в одном &lt;a href=&quot;c3ref/sqlite3&quot;&gt;подключении к базе данных&lt;/a&gt; с помощью &lt;a href=&quot;lang_attach&quot;&gt;ATTACH DATABASE&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="45a728f83fed6326d4c43841ba1813e1ce7eb6dd" translate="yes" xml:space="preserve">
          <source>Multiple processes can attach to the same application file and can read and write without interfering with each another.</source>
          <target state="translated">Несколько процессов могут присоединяться к одному и тому же файлу приложения и могут читать и записывать,не мешая друг другу.</target>
        </trans-unit>
        <trans-unit id="2aa7ba24512eed1d018b442b661d99d24d2bbe28" translate="yes" xml:space="preserve">
          <source>Multiple processes can have the same database open at the same time. Multiple processes can be doing a SELECT at the same time. But only one process can be making changes to the database at any moment in time, however.</source>
          <target state="translated">Несколько процессов могут иметь одну и ту же базу данных одновременно.Несколько процессов могут выполнять SELECT одновременно.Но только один процесс может вносить изменения в базу данных в любой момент времени.</target>
        </trans-unit>
        <trans-unit id="933ed3deea04e9e9fbd7189bd88652e303cb225d" translate="yes" xml:space="preserve">
          <source>Multiple small sorts collectively use fewer CPU cycles than a single large sort.</source>
          <target state="translated">Множество маленьких сортов в совокупности используют меньше циклов процессора,чем один большой сорт.</target>
        </trans-unit>
        <trans-unit id="b20a305f06f0be2e3dd77e203ae365353776cf59" translate="yes" xml:space="preserve">
          <source>Multiply</source>
          <target state="translated">Multiply</target>
        </trans-unit>
        <trans-unit id="8e0df4037503e2d7d2784fedb62cdd6ec1bcce1f" translate="yes" xml:space="preserve">
          <source>Multiply the value in register P1 by the value in register P2 and store the result in register P3. If either input is NULL, the result is NULL.</source>
          <target state="translated">Умножьте значение в регистре P1 на значение в регистре P2 и сохраните результат в регистре P3.Если любой из входов имеет значение NULL,то результат будет NULL.</target>
        </trans-unit>
        <trans-unit id="96a8063d277e69bad9338f2cd2299ce555b10c74" translate="yes" xml:space="preserve">
          <source>Multiplying null by zero gives null</source>
          <target state="translated">Умножение нуля на ноль дает ноль</target>
        </trans-unit>
        <trans-unit id="0882d3aaa23d5575a8f63bfdd8452012d19a092f" translate="yes" xml:space="preserve">
          <source>MustBeInt</source>
          <target state="translated">MustBeInt</target>
        </trans-unit>
        <trans-unit id="ad84a5c1e8958f4a9c3429e8188a4603875d0079" translate="yes" xml:space="preserve">
          <source>Mutation test script</source>
          <target state="translated">Скрипт теста на мутацию</target>
        </trans-unit>
        <trans-unit id="20e073cd00cadf7d267e8b82f5b78e0e3f9214a2" translate="yes" xml:space="preserve">
          <source>Mutation testing can be slow, since each test can take up to 5 minutes on a fast workstation, and there are two tests for each branch instructions, and over 20,000 branch instructions. Efforts are made to expedite operation. For example, TH3 is compiled in such a way that it exits as soon as it finds the first error, and as many of the mutations are easily detected, many cycles happen in only a few seconds. Nevertheless, the mutation-test.tcl script includes command-line options to limit the range of code lines tested so that mutation testing only needs to be performed on blocks of code that have recently changed.</source>
          <target state="translated">Тестирование мутации может быть медленным,так как каждый тест может занять до 5 минут на быстрой рабочей станции,и есть два теста для каждой инструкции ветви,и более 20 000 инструкций ветви.Прилагаются усилия для ускорения работы.Например,TH3 скомпилирован таким образом,что выходит сразу после обнаружения первой ошибки,и поскольку многие мутации легко обнаруживаются,многие циклы происходят всего за несколько секунд.Тем не менее,скрипт mutation-test.tcl включает опции командной строки для ограничения диапазона проверяемых строк кода,так что проверка мутаций должна выполняться только на недавно изменившихся блоках кода.</target>
        </trans-unit>
        <trans-unit id="ee9066f4d731d8a141c6e684743ee9a9527de8b6" translate="yes" xml:space="preserve">
          <source>Mutex Handle</source>
          <target state="translated">рукоятка из мутекса</target>
        </trans-unit>
        <trans-unit id="9f117864c1709baa2c76d7b2cfa8d17c9f1bfe11" translate="yes" xml:space="preserve">
          <source>Mutex Methods Object</source>
          <target state="translated">Мютексные методы Объект</target>
        </trans-unit>
        <trans-unit id="83fb9a7fd1246d148749d832e1630432bf7c41eb" translate="yes" xml:space="preserve">
          <source>Mutex Types</source>
          <target state="translated">Типы мутекса</target>
        </trans-unit>
        <trans-unit id="9ca067080a430d66f997055e5f2d644e22736a96" translate="yes" xml:space="preserve">
          <source>Mutex Verification Routines</source>
          <target state="translated">Маршруты проверки Мьютекса</target>
        </trans-unit>
        <trans-unit id="82f2c9599c5c14be2ce92b9de958cb57db81b38f" translate="yes" xml:space="preserve">
          <source>Mutexes</source>
          <target state="translated">Mutexes</target>
        </trans-unit>
        <trans-unit id="5b84f7a78e5961ea2a526de843a9daab8f41a20c" translate="yes" xml:space="preserve">
          <source>Mutexes are cheap but they are not free, so performance will be better when mutexes are completely disabled. The resulting library footprint will also be a little smaller. Disabling the mutexes at compile-time is a recommended optimization for applications where it makes sense.</source>
          <target state="translated">Мютексы дешевы,но не бесплатны,поэтому производительность будет лучше,когда мютексы полностью отключены.В результате площадь,занимаемая библиотекой,также будет немного меньше.Отключение мьютексов во время компиляции является рекомендуемой оптимизацией для приложений,где это имеет смысл.</target>
        </trans-unit>
        <trans-unit id="b22446695cc6c25d3041d52dab780b6caac7cd1e" translate="yes" xml:space="preserve">
          <source>Mutexes are created using &lt;a href=&quot;#sqlite3_mutex_alloc&quot;&gt;sqlite3_mutex_alloc()&lt;/a&gt;.</source>
          <target state="translated">Мьютексы создаются с помощью &lt;a href=&quot;#sqlite3_mutex_alloc&quot;&gt;sqlite3_mutex_alloc ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a8bd3143e806972c1aad1cdeede17125b4f66fc3" translate="yes" xml:space="preserve">
          <source>Mutexes are created using &lt;a href=&quot;mutex_alloc&quot;&gt;sqlite3_mutex_alloc()&lt;/a&gt;.</source>
          <target state="translated">Мьютексы создаются с помощью &lt;a href=&quot;mutex_alloc&quot;&gt;sqlite3_mutex_alloc ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="90dba5f17bdba09d7b97e3f464ca3b8fa2e57394" translate="yes" xml:space="preserve">
          <source>My WHERE clause expression &lt;code&gt;column1=&quot;column1&quot;&lt;/code&gt; does not work. It causes every row of the table to be returned, not just the rows where column1 has the value &quot;column1&quot;.</source>
          <target state="translated">Мое выражение предложения WHERE &lt;code&gt;column1=&quot;column1&quot;&lt;/code&gt; не работает. Это приводит к возврату каждой строки таблицы, а не только строк, в которых column1 имеет значение &amp;laquo;column1&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="53dbb81c605812b9954b771e4d176a4b96f646d2" translate="yes" xml:space="preserve">
          <source>My query does not return the column name that I expect. Is this a bug?</source>
          <target state="translated">Мой запрос не возвращает имя столбца,которое я ожидаю.Это ошибка?</target>
        </trans-unit>
        <trans-unit id="deaa0c393a6613972aaccbf1fecfdad67aa21e88" translate="yes" xml:space="preserve">
          <source>MySQL</source>
          <target state="translated">MySQL</target>
        </trans-unit>
        <trans-unit id="424aa797f42c3aefebeedcebb618509b36642239" translate="yes" xml:space="preserve">
          <source>MySQL supports the UPDATE FROM idea, but it does so without using a FROM clause. Instead, the complete join specification is given in between the UPDATE and SET keywords. The equivalent MySQL statement would be like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5d56b96c147bc00244a87ca5dec3dbb343c2acd" translate="yes" xml:space="preserve">
          <source>MySQL version 3.23.41 does not support UNION.</source>
          <target state="translated">MySQL версия 3.23.41 не поддерживает UNION.</target>
        </trans-unit>
        <trans-unit id="e303d2711b51452d1cb5f1e99368e6acecd1238f" translate="yes" xml:space="preserve">
          <source>MySQL:</source>
          <target state="translated">MySQL:</target>
        </trans-unit>
        <trans-unit id="b51a60734da64be0e618bacbea2865a8a7dcd669" translate="yes" xml:space="preserve">
          <source>N</source>
          <target state="translated">N</target>
        </trans-unit>
        <trans-unit id="8942124b2b322d5ed5aaedb0379f2b4629d337ae" translate="yes" xml:space="preserve">
          <source>N&amp;ge;12 and even</source>
          <target state="translated">N&amp;ge;12 и даже</target>
        </trans-unit>
        <trans-unit id="65234a7e6be9327b0d7bbc7e6bf2ce41cdf5a33b" translate="yes" xml:space="preserve">
          <source>N&amp;ge;13 and odd</source>
          <target state="translated">N&amp;ge;13 и нечетное</target>
        </trans-unit>
        <trans-unit id="4bbff46d5e4a2066e44932399c1db699e807cf39" translate="yes" xml:space="preserve">
          <source>N+1</source>
          <target state="translated">N+1</target>
        </trans-unit>
        <trans-unit id="bd2f53c8c05f137a14d10bbea3ef6da285114906" translate="yes" xml:space="preserve">
          <source>N+4</source>
          <target state="translated">N+4</target>
        </trans-unit>
        <trans-unit id="08d2e98e6754af941484848930ccbaddfefe13d6" translate="yes" xml:space="preserve">
          <source>N/A</source>
          <target state="translated">N/A</target>
        </trans-unit>
        <trans-unit id="8dd6dc5b4967e63a1a79c5eb2a6c948692613a58" translate="yes" xml:space="preserve">
          <source>N1 (cost: 5.52)</source>
          <target state="translated">N1 (стоимость:5,52)</target>
        </trans-unit>
        <trans-unit id="798d9ffe324145d7424e3df912c7130f87d2bc5a" translate="yes" xml:space="preserve">
          <source>N2 (cost: 5.52)</source>
          <target state="translated">N2 (стоимость:5,52)</target>
        </trans-unit>
        <trans-unit id="15fbf39b576cc8bd369719e2a3d26f97ec889560" translate="yes" xml:space="preserve">
          <source>N2-N1 (cost: 11.04)</source>
          <target state="translated">N2-N1 (стоимость:11.04)</target>
        </trans-unit>
        <trans-unit id="5b4ea6d782abcd0ed1483d887c331af67374531e" translate="yes" xml:space="preserve">
          <source>N&lt;sub&gt;&lt;small&gt;left&lt;/small&gt;&lt;/sub&gt;</source>
          <target state="translated">N&lt;sub&gt;&lt;small&gt;left&lt;/small&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="e5c2df06ba96ff92a5b489615f6b10abd3bf147f" translate="yes" xml:space="preserve">
          <source>N&lt;sub&gt;&lt;small&gt;left&lt;/small&gt;&lt;/sub&gt;&amp;times;N&lt;sub&gt;&lt;small&gt;right&lt;/small&gt;&lt;/sub&gt;</source>
          <target state="translated">N&lt;sub&gt;&lt;small&gt;left&lt;/small&gt;&lt;/sub&gt;&amp;times;N&lt;sub&gt;&lt;small&gt;right&lt;/small&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="2c0a1bee57f9f58fc50d516a0bf15f88caa7689c" translate="yes" xml:space="preserve">
          <source>N&lt;sub&gt;&lt;small&gt;right&lt;/small&gt;&lt;/sub&gt;</source>
          <target state="translated">N&lt;sub&gt;&lt;small&gt;right&lt;/small&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="a9d371451b6909ac85117130b9153a96499a362c" translate="yes" xml:space="preserve">
          <source>NAME</source>
          <target state="translated">NAME</target>
        </trans-unit>
        <trans-unit id="5b0ac1bba3d09af88af51314ab9e3274563ae94b" translate="yes" xml:space="preserve">
          <source>NATIVE CHARACTER(70)</source>
          <target state="translated">РОДНОЙ СИМВОЛ(70)</target>
        </trans-unit>
        <trans-unit id="7b0c42d6ea58612c19c7961351b229254674e033" translate="yes" xml:space="preserve">
          <source>NATURAL</source>
          <target state="translated">NATURAL</target>
        </trans-unit>
        <trans-unit id="ea1a1d896196c614eb971163bd79e6b0f3ccbe73" translate="yes" xml:space="preserve">
          <source>NB: This extension is deprecated. [WAL mode] is recommended as a replacement.</source>
          <target state="translated">NB:Это расширение устарело.В качестве замены рекомендуется [режим WAL].</target>
        </trans-unit>
        <trans-unit id="9829174ea4702c19a86b2f2d0ae072ffd5bcdee0" translate="yes" xml:space="preserve">
          <source>NCHAR(55)</source>
          <target state="translated">NCHAR(55)</target>
        </trans-unit>
        <trans-unit id="b7fe5d20802ca2aca87db42d4b7dae9f148c0ed7" translate="yes" xml:space="preserve">
          <source>NEAR queries</source>
          <target state="translated">запросы NEAR</target>
        </trans-unit>
        <trans-unit id="ad140e1560939f826df416c1e0d8f81eaa5dd26a" translate="yes" xml:space="preserve">
          <source>NEAR queries are not available.</source>
          <target state="translated">Запросы NEAR недоступны.</target>
        </trans-unit>
        <trans-unit id="9bbceb6fd3a09583f532267c802c583270b6ed37" translate="yes" xml:space="preserve">
          <source>NEVER(X)</source>
          <target state="translated">NEVER(X)</target>
        </trans-unit>
        <trans-unit id="97b77dd54bade796fe382680ffda0d54d204b7ea" translate="yes" xml:space="preserve">
          <source>NEW and OLD references are valid</source>
          <target state="translated">Действительны НОВЫЕ и СТАРШИЕ ссылки</target>
        </trans-unit>
        <trans-unit id="a82d81a38474e7a2f1b05be86c3d0ec157924da9" translate="yes" xml:space="preserve">
          <source>NEW references are valid</source>
          <target state="translated">Действительны НОВЫЕ ссылки</target>
        </trans-unit>
        <trans-unit id="aa7b193ecb5f5e8127c45d86d672c669b4ad311a" translate="yes" xml:space="preserve">
          <source>NNN</source>
          <target state="translated">NNN</target>
        </trans-unit>
        <trans-unit id="cf99bc0053e83f8041fe548005de7972be838e08" translate="yes" xml:space="preserve">
          <source>NNN days</source>
          <target state="translated">NNN дни</target>
        </trans-unit>
        <trans-unit id="33c4ffa6e43390375c0bf9b4e04eedef73776044" translate="yes" xml:space="preserve">
          <source>NNN hours</source>
          <target state="translated">NNN часы</target>
        </trans-unit>
        <trans-unit id="4dc2b6e588bcda89bc862d480bc0a6894df9769a" translate="yes" xml:space="preserve">
          <source>NNN minutes</source>
          <target state="translated">NNN минут</target>
        </trans-unit>
        <trans-unit id="bf0082b4c02bd0d30ff30874661f393df82750f4" translate="yes" xml:space="preserve">
          <source>NNN months</source>
          <target state="translated">NNN месяцы</target>
        </trans-unit>
        <trans-unit id="afb2dbb2fb0e9adb5cd092d7e7b6d3ffb78523de" translate="yes" xml:space="preserve">
          <source>NNN years</source>
          <target state="translated">NNN годы</target>
        </trans-unit>
        <trans-unit id="b58c197b751c5ed1962a3c0390de8c10bb4951b3" translate="yes" xml:space="preserve">
          <source>NNN.NNNN seconds</source>
          <target state="translated">NNNN.NNNN секунд</target>
        </trans-unit>
        <trans-unit id="a0509b7780628bd9d9abc7eb8a2163477341053a" translate="yes" xml:space="preserve">
          <source>NO</source>
          <target state="translated">NO</target>
        </trans-unit>
        <trans-unit id="05fdd36e7692e52033451b07ec66dff9eb7e55c8" translate="yes" xml:space="preserve">
          <source>NOCASE</source>
          <target state="translated">NOCASE</target>
        </trans-unit>
        <trans-unit id="0654a028e5aea48c8fbb09871b8f397a186c883b" translate="yes" xml:space="preserve">
          <source>NONE</source>
          <target state="translated">NONE</target>
        </trans-unit>
        <trans-unit id="969e7d8dee132181523a501a068fec75bded3005" translate="yes" xml:space="preserve">
          <source>NOT</source>
          <target state="translated">NOT</target>
        </trans-unit>
        <trans-unit id="13e8b0dd0b366e8464e50db4ffa83a38db17f5c0" translate="yes" xml:space="preserve">
          <source>NOT EXISTS operator</source>
          <target state="translated">НЕ ВЫПАДАЕТ оператор</target>
        </trans-unit>
        <trans-unit id="c251201ede2fa823c20c38c57254fd75c17ce421" translate="yes" xml:space="preserve">
          <source>NOT IN operator</source>
          <target state="translated">НЕ В СЛУЧАЕ НЕОБХОДИМОСТИ</target>
        </trans-unit>
        <trans-unit id="f4a4efddb03a7d76572898f7eabe1ea34a780b2f" translate="yes" xml:space="preserve">
          <source>NOT NULL constraint</source>
          <target state="translated">НЕ НУЛЬШЕЕ ограничение</target>
        </trans-unit>
        <trans-unit id="6ff7e3eeee65666114a7a3854176937e0d8c1522" translate="yes" xml:space="preserve">
          <source>NOT NULL constraints are honored.</source>
          <target state="translated">НЕ НУЛЬШИЕ ограничения соблюдаются.</target>
        </trans-unit>
        <trans-unit id="c462e8fc3e502ae6d5489c34ffa0054b7073578f" translate="yes" xml:space="preserve">
          <source>NOTHING</source>
          <target state="translated">NOTHING</target>
        </trans-unit>
        <trans-unit id="d6a7f5abac5bd9faa0bac9e8bb7907ab9f614941" translate="yes" xml:space="preserve">
          <source>NOTNULL</source>
          <target state="translated">NOTNULL</target>
        </trans-unit>
        <trans-unit id="545dacd66301f165f41f75a11471135695f4dede" translate="yes" xml:space="preserve">
          <source>NUL Characters In Strings</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4771b572fc1de8c483abeb1a95a1bc516fa56a87" translate="yes" xml:space="preserve">
          <source>NUL characters (ASCII code 0x00 and Unicode \u0000) may appear in the middle of strings in SQLite. This can lead to unexpected behavior. See the &quot;&lt;a href=&quot;nulinstr&quot;&gt;NUL characters in strings&lt;/a&gt;&quot; document for further information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eef19c54306daa69eda49c0272623bdb5e2b341f" translate="yes" xml:space="preserve">
          <source>NULL</source>
          <target state="translated">NULL</target>
        </trans-unit>
        <trans-unit id="0d475d854a2a7eeffd82e1a01f92ca65e566328f" translate="yes" xml:space="preserve">
          <source>NULL Handling in SQLite</source>
          <target state="translated">NULL-обработка в SQLite</target>
        </trans-unit>
        <trans-unit id="7fac7bb3c1a767adbbac557d34135fb142c688ca" translate="yes" xml:space="preserve">
          <source>NULL Handling in SQLite Versus Other Database Engines</source>
          <target state="translated">NULL-обработка в SQLite против других двигателей баз данных</target>
        </trans-unit>
        <trans-unit id="248ab3abcb099e69f2fef53b64e651576012c852" translate="yes" xml:space="preserve">
          <source>NULL values (serial type 0) sort first.</source>
          <target state="translated">NULL-значения (последовательный тип 0)сортируются первыми.</target>
        </trans-unit>
        <trans-unit id="a1efa1e3b6119cae6664d71bdefea57f479d6ebf" translate="yes" xml:space="preserve">
          <source>NULL values are now reported to the callback as a NULL pointer rather than an empty string.</source>
          <target state="translated">NULL-значения теперь сообщаются в обратном вызове как NULL указатель,а не как пустая строка.</target>
        </trans-unit>
        <trans-unit id="743ef19013396d7d94a24cacbb830235275be9c8" translate="yes" xml:space="preserve">
          <source>NULLS</source>
          <target state="translated">NULLS</target>
        </trans-unit>
        <trans-unit id="fc81819cf87d3384597c4ae67d1976d82323a9b0" translate="yes" xml:space="preserve">
          <source>NULLS LAST</source>
          <target state="translated">ПОСЛЕДНИЙ</target>
        </trans-unit>
        <trans-unit id="8280c934b3178b2afed2c01f955aab5fe7295999" translate="yes" xml:space="preserve">
          <source>NULLs sort first</source>
          <target state="translated">NULLs сортируются первыми</target>
        </trans-unit>
        <trans-unit id="58ad270de77802cc63222e273fa800c4b248cdd7" translate="yes" xml:space="preserve">
          <source>NUMERIC</source>
          <target state="translated">NUMERIC</target>
        </trans-unit>
        <trans-unit id="024959fd2d5e8c9c205a2098591019699ae29143" translate="yes" xml:space="preserve">
          <source>NVARCHAR(100)</source>
          <target state="translated">NVARCHAR(100)</target>
        </trans-unit>
        <trans-unit id="709a23220f2c3d64d1e1d6d18c4d5280f8d82fca" translate="yes" xml:space="preserve">
          <source>Name</source>
          <target state="translated">Name</target>
        </trans-unit>
        <trans-unit id="daa5b774be0bfcbd2e2835e6bd0980fb6e06778a" translate="yes" xml:space="preserve">
          <source>Name Of A Host Parameter</source>
          <target state="translated">Имя параметра хозяина</target>
        </trans-unit>
        <trans-unit id="cb9e33f6b09bb7fe5d38a783b74c6905b2f43077" translate="yes" xml:space="preserve">
          <source>Name Of The Folder Holding Database Files</source>
          <target state="translated">Имя файла базы данных,хранящегося в папке</target>
        </trans-unit>
        <trans-unit id="7749c218b18b42cbe27f3f870da40b8d3d708ba1" translate="yes" xml:space="preserve">
          <source>Name Of The Folder Holding Temporary Files</source>
          <target state="translated">Имя папки,хранящей временные файлы</target>
        </trans-unit>
        <trans-unit id="fbb9c33e0412f25c0e798fd22a36fd452bd92012" translate="yes" xml:space="preserve">
          <source>Name of default collation sequence</source>
          <target state="translated">Имя последовательности сверки по умолчанию</target>
        </trans-unit>
        <trans-unit id="4e3a9de996d9196b59f293d51cf53aa5b2a8a36e" translate="yes" xml:space="preserve">
          <source>Named window-defn clauses may also be added to a SELECT statement using a WINDOW clause and then referred to by name within window function invocations. For example, the following SELECT statement contains two named window-defs clauses, &quot;win1&quot; and &quot;win2&quot;:</source>
          <target state="translated">Именованные клаузулы window-defn также могут быть добавлены в оператор SELECT с помощью клаузулы WINDOW,а затем на них можно ссылаться по имени в вызовах оконных функций.Например,следующий оператор SELECT содержит два именованных пункта windows-defs-&quot;win1&quot; и &quot;win2&quot;:</target>
        </trans-unit>
        <trans-unit id="02aead4c6c683a05b1c0ebf7ea825cf0f6d1b06c" translate="yes" xml:space="preserve">
          <source>Naming Changes</source>
          <target state="translated">Изменения в наименовании</target>
        </trans-unit>
        <trans-unit id="f736bf35e196e5f8a2152cf612783a7b401c2cad" translate="yes" xml:space="preserve">
          <source>Ne</source>
          <target state="translated">Ne</target>
        </trans-unit>
        <trans-unit id="28477357de69f5526193889fda40ed45cd101a03" translate="yes" xml:space="preserve">
          <source>Nearly all systems have the ability to call libraries written in C. This is not true of other implementation languages.</source>
          <target state="translated">Почти все системы имеют возможность вызывать библиотеки,написанные на C.Это не относится к другим языкам реализации.</target>
        </trans-unit>
        <trans-unit id="a37e5d1459b64bbf0f387b130668f0c8c4924e69" translate="yes" xml:space="preserve">
          <source>Negative numbers in the &quot;.width&quot; command cause right-alignment</source>
          <target state="translated">Отрицательные числа в команде &quot;.width&quot; вызывают выравнивание вправо.</target>
        </trans-unit>
        <trans-unit id="fec37acea6ebcef8454c4fc958c0b8f34d2b8c80" translate="yes" xml:space="preserve">
          <source>Nested transactions using &lt;a href=&quot;lang_savepoint&quot;&gt;SAVEPOINT&lt;/a&gt;, &lt;a href=&quot;lang_savepoint&quot;&gt;RELEASE&lt;/a&gt;, and &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK TO&lt;/a&gt;</source>
          <target state="translated">Вложенные транзакции с использованием &lt;a href=&quot;lang_savepoint&quot;&gt;SAVEPOINT&lt;/a&gt; , &lt;a href=&quot;lang_savepoint&quot;&gt;RELEASE&lt;/a&gt; и &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK TO&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9c791dcaae3666d9984fccf3b99d9aec11d78e88" translate="yes" xml:space="preserve">
          <source>Never despair of God's mercy.</source>
          <target state="translated">Никогда не отчаивайся от милости Божьей.</target>
        </trans-unit>
        <trans-unit id="56cdefb3df5828b1fdbe0c79de688ed68de09460" translate="yes" xml:space="preserve">
          <source>Never tag an application-defined SQL function with &lt;a href=&quot;c3ref/c_deterministic#sqliteinnocuous&quot;&gt;SQLITE_INNOCUOUS&lt;/a&gt; unless you really need to and you have checked the implementation closely and are certain that it can do no harm even if it falls under the control of an attacker.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb1f0a8ca1cbcde19e25e6a553a1aa4154cf9c78" translate="yes" xml:space="preserve">
          <source>Nevertheless, application developers are admonished to monitor the state of the memory allocation subsystems and raise alarms when memory usage approaches or exceeds Robson limits. In this way, the application will provide operators with abundant warning well in advance of failure. The &lt;a href=&quot;malloc#memstatus&quot;&gt;memory statistics&lt;/a&gt; interfaces of SQLite provide the application with all the mechanism necessary to complete the monitoring portion of this task.</source>
          <target state="translated">Тем не менее, разработчикам приложений рекомендуется отслеживать состояние подсистем распределения памяти и подавать сигналы тревоги, когда использование памяти приближается к пределам Робсона или превышает их. Таким образом, приложение будет предоставлять операторам подробные предупреждения задолго до сбоя. Интерфейсы &lt;a href=&quot;malloc#memstatus&quot;&gt;статистики памяти&lt;/a&gt; SQLite предоставляют приложению все механизмы, необходимые для выполнения части мониторинга этой задачи.</target>
        </trans-unit>
        <trans-unit id="b14d2dd89e46e860f7449a61cc79bde67323500f" translate="yes" xml:space="preserve">
          <source>Nevertheless, bugs happen. If you are writing an application that sends untrusted SQL inputs or database files to SQLite, there are additional steps you can take to help reduce the attack surface and prevent zero-day exploits caused by undetected bugs.</source>
          <target state="translated">Тем не менее,жуки случаются.Если вы пишете приложение,которое посылает недоверенные SQL входы или файлы базы данных на SQLite,есть дополнительные шаги,которые помогут уменьшить поверхность атаки и предотвратить эксплойты нулевого дня,вызванные необнаруженными ошибками.</target>
        </trans-unit>
        <trans-unit id="fe8f48a38c1ee2d5e1ec0b569c50eb0f4be22e0d" translate="yes" xml:space="preserve">
          <source>Nevertheless, integer overflow in the computation of memory allocation sizes is a concern that SQLite would like to deal with. To prevent problems, all SQLite internal memory allocations occur using thin wrapper functions that take a signed 64-bit integer size parameter. The SQLite source code is audited to ensure that all size computations are carried out using 64-bit signed integers as well. SQLite will refuse to allocate more than about 2GB of memory at one go. (In common use, SQLite seldom ever allocates more than about 8KB of memory at a time so a 2GB allocation limit is not a burden.) So the 64-bit size parameter provides lots of headroom for detecting overflows. The same audit that verifies that all size computations are done as 64-bit signed integers also verifies that it is impossible to overflow a 64-bit integer during the computation.</source>
          <target state="translated">Тем не менее,целочисленное переполнение при вычислении размеров выделения памяти является проблемой,с которой SQLite хотел бы иметь дело.Для предотвращения проблем все выделения внутренней памяти SQLite происходят с использованием тонких оберточных функций,которые принимают знаковый 64-битный целочисленный параметр размера.Исходный код SQLite проверяется на предмет того,что все вычисления размера выполняются и с использованием 64-битных подписанных целых чисел.SQLite откажется выделять более 2 Гб памяти за один раз.(Обычно SQLite редко выделяет более 8 КБ памяти за один раз,поэтому лимит выделения 2 ГБ не является обузой).Таким образом,параметр 64-битного размера предоставляет много места для обнаружения переполнений.Тот же самый аудит,который проверяет,что все вычисления размера выполняются в виде 64-битных подписанных целых чисел,также проверяет невозможность переполнения 64-битного целого при вычислении.</target>
        </trans-unit>
        <trans-unit id="e49fc674e296beca34786edd4c2b299863546a78" translate="yes" xml:space="preserve">
          <source>Nevertheless, no software is 100% perfect. There have been a few historical bugs in SQLite (now fixed) that could cause database corruption. And there may be yet a few more that remain undiscovered. Because of the extensive testing and widespread use of SQLite, bugs that result in database corruption tend to be very obscure. The likelihood of an application encountering an SQLite bug is small. To illustrate this, an account is given below of all database-corruption bugs found in SQLite during the four-year period from 2009-04-01 to 2013-04-15. This account should give the reader an intuitive sense of the kinds of bugs in SQLite that manage to slip through testing procedures and make it into a release.</source>
          <target state="translated">Тем не менее,ни одно программное обеспечение не идеально на 100%.В SQLite было несколько исторических ошибок (теперь исправлено),которые могли привести к повреждению базы данных.И,возможно,есть еще несколько,которые остаются нераскрытыми.Из-за обширного тестирования и широкого использования SQLite,ошибки,которые приводят к повреждению базы данных,как правило,очень малоизвестны.Вероятность того,что приложение столкнется с ошибкой SQLite,невелика.Чтобы проиллюстрировать это,ниже приведен аккаунт всех ошибок,связанных с коррупцией баз данных,обнаруженных в SQLite за четырехлетний период с 2009-04-01 по 2013-04-15 гг.Этот аккаунт должен дать читателю интуитивное представление о том,какие ошибки в SQLite удается проскользнуть через процедуры тестирования и превратить его в релиз.</target>
        </trans-unit>
        <trans-unit id="0116882452ef2d4b8e1293a906b669874cb29ba7" translate="yes" xml:space="preserve">
          <source>New &lt;a href=&quot;compile#omitfeatures&quot;&gt;SQLITE_OMIT_...&lt;/a&gt; compile-time options added</source>
          <target state="translated">&lt;a href=&quot;compile#omitfeatures&quot;&gt;Добавлены&lt;/a&gt; новые параметры времени компиляции SQLITE_OMIT _...</target>
        </trans-unit>
        <trans-unit id="75836f6f6b6f280ffed2e7c97c8de38d49f8b36b" translate="yes" xml:space="preserve">
          <source>New Change</source>
          <target state="translated">Новое изменение</target>
        </trans-unit>
        <trans-unit id="519eb3711af9fb8ce8d81cf7983b569f9b988fc0" translate="yes" xml:space="preserve">
          <source>New File Format</source>
          <target state="translated">Новый формат файла</target>
        </trans-unit>
        <trans-unit id="05a025f4bcdcce620e0b66e603b7b96a2aa62567" translate="yes" xml:space="preserve">
          <source>New HH:MM:SS modifier to the built-in date/time functions.</source>
          <target state="translated">Новый модификатор HH:MM:SS для встроенных функций даты/времени.</target>
        </trans-unit>
        <trans-unit id="35afb195f0b01edb4e7140e0f143cfa5913617eb" translate="yes" xml:space="preserve">
          <source>New VFSes are registered with sqlite3_vfs_register(). Each new VFS becomes the default VFS if the makeDflt flag is set. The same VFS can be registered multiple times without injury. To make an existing VFS into the default VFS, register it again with the makeDflt flag set. If two different VFSes with the same name are registered, the behavior is undefined. If a VFS is registered with a name that is NULL or an empty string, then the behavior is undefined.</source>
          <target state="translated">Новые VFSes регистрируются функцией sqlite3_vfs_register().Каждая новая VFS становится VFS по умолчанию,если установлен флаг makeDflt.Одна и та же VFS может быть зарегистрирована несколько раз без повреждений.Чтобы превратить существующую VFS в VFS по умолчанию,зарегистрируйте ее снова с установленным флагом makeDflt.Если зарегистрированы две разные VFS с одним и тем же именем,поведение будет неопределенным.Если VFS регистрируется с именем NULL или пустой строкой,поведение будет неопределенным.</target>
        </trans-unit>
        <trans-unit id="9e6d8977d2335274bf96388fe98628d1d0b7e083" translate="yes" xml:space="preserve">
          <source>New applications should always invoke &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; instead of &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt;. The older &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; is retained for backwards compatibility. But &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; provides a much better interface.</source>
          <target state="translated">Новые приложения всегда должны вызывать &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; вместо &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare ()&lt;/a&gt; . Более старый &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare ()&lt;/a&gt; сохранен для обратной совместимости. Но &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; предоставляет гораздо лучший интерфейс.</target>
        </trans-unit>
        <trans-unit id="741f30a581517ffe6e7dcd8b6f50643914279724" translate="yes" xml:space="preserve">
          <source>New configuration options may be added in future releases of SQLite. Existing configuration options might be discontinued. Applications should check the return code from &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config()&lt;/a&gt; to make sure that the call worked. The &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config()&lt;/a&gt; interface will return a non-zero &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; if a discontinued or unsupported configuration option is invoked.</source>
          <target state="translated">В будущих выпусках SQLite могут быть добавлены новые параметры конфигурации. Существующие параметры конфигурации могут быть прекращены. Приложения должны проверить код возврата из &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config (),&lt;/a&gt; чтобы убедиться, что вызов сработал. Интерфейс &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config ()&lt;/a&gt; вернет ненулевой &lt;a href=&quot;rescode&quot;&gt;код ошибки,&lt;/a&gt; если вызывается неподдерживаемый или неподдерживаемый параметр конфигурации.</target>
        </trans-unit>
        <trans-unit id="dfd7ca29d835fc9c4dbb0540c0bcc6f89fdaa393" translate="yes" xml:space="preserve">
          <source>New configuration options may be added in future releases of SQLite. Existing configuration options might be discontinued. Applications should check the return code from &lt;a href=&quot;#sqlite3_db_config&quot;&gt;sqlite3_db_config()&lt;/a&gt; to make sure that the call worked. The &lt;a href=&quot;#sqlite3_db_config&quot;&gt;sqlite3_db_config()&lt;/a&gt; interface will return a non-zero &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; if a discontinued or unsupported configuration option is invoked.</source>
          <target state="translated">В будущих выпусках SQLite могут быть добавлены новые параметры конфигурации. Существующие параметры конфигурации могут быть прекращены. Приложения должны проверить код возврата из &lt;a href=&quot;#sqlite3_db_config&quot;&gt;sqlite3_db_config (),&lt;/a&gt; чтобы убедиться, что вызов сработал. Интерфейс &lt;a href=&quot;#sqlite3_db_config&quot;&gt;sqlite3_db_config ()&lt;/a&gt; вернет ненулевой &lt;a href=&quot;rescode&quot;&gt;код ошибки,&lt;/a&gt; если вызывается неподдерживаемый или неподдерживаемый параметр конфигурации.</target>
        </trans-unit>
        <trans-unit id="290c5a063c07711b910fa8250f0c45e5e6c8d5a9" translate="yes" xml:space="preserve">
          <source>New configuration options may be added in future releases of SQLite. Existing configuration options might be discontinued. Applications should check the return code from &lt;a href=&quot;config&quot;&gt;sqlite3_config()&lt;/a&gt; to make sure that the call worked. The &lt;a href=&quot;config&quot;&gt;sqlite3_config()&lt;/a&gt; interface will return a non-zero &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; if a discontinued or unsupported configuration option is invoked.</source>
          <target state="translated">В будущих выпусках SQLite могут быть добавлены новые параметры конфигурации. Существующие параметры конфигурации могут быть прекращены. Приложения должны проверить код возврата из &lt;a href=&quot;config&quot;&gt;sqlite3_config (),&lt;/a&gt; чтобы убедиться, что вызов сработал. Интерфейс &lt;a href=&quot;config&quot;&gt;sqlite3_config ()&lt;/a&gt; вернет ненулевой &lt;a href=&quot;../rescode&quot;&gt;код ошибки,&lt;/a&gt; если вызывается неподдерживаемый или неподдерживаемый параметр конфигурации.</target>
        </trans-unit>
        <trans-unit id="bef0fe1db7b5b12623a7cb6dd11860448e032b3e" translate="yes" xml:space="preserve">
          <source>New configuration options may be added in future releases of SQLite. Existing configuration options might be discontinued. Applications should check the return code from &lt;a href=&quot;db_config&quot;&gt;sqlite3_db_config()&lt;/a&gt; to make sure that the call worked. The &lt;a href=&quot;db_config&quot;&gt;sqlite3_db_config()&lt;/a&gt; interface will return a non-zero &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; if a discontinued or unsupported configuration option is invoked.</source>
          <target state="translated">В будущих выпусках SQLite могут быть добавлены новые параметры конфигурации. Существующие параметры конфигурации могут быть прекращены. Приложения должны проверить код возврата из &lt;a href=&quot;db_config&quot;&gt;sqlite3_db_config (),&lt;/a&gt; чтобы убедиться, что вызов сработал. Интерфейс &lt;a href=&quot;db_config&quot;&gt;sqlite3_db_config ()&lt;/a&gt; вернет ненулевой &lt;a href=&quot;../rescode&quot;&gt;код ошибки,&lt;/a&gt; если вызывается неподдерживаемый или неподдерживаемый параметр конфигурации.</target>
        </trans-unit>
        <trans-unit id="b448decebb78010dbfebbde65087fb4a352a7ae8" translate="yes" xml:space="preserve">
          <source>New database files created by SQLite use format 4 by default. The &lt;a href=&quot;pragma#pragma_legacy_file_format&quot;&gt;legacy_file_format pragma&lt;/a&gt; can be used to cause SQLite to create new database files using format 1. The format version number can be made to default to 1 instead of 4 by setting &lt;a href=&quot;compile#default_file_format&quot;&gt;SQLITE_DEFAULT_FILE_FORMAT&lt;/a&gt;=1 at compile-time.</source>
          <target state="translated">Новые файлы базы данных, созданные SQLite, по умолчанию используют формат 4. &lt;a href=&quot;pragma#pragma_legacy_file_format&quot;&gt;Legacy_file_format прагма&lt;/a&gt; может быть использован , чтобы вызвать SQLite для создания новых файлов базы данных с использованием формата 1. Формат номера версии можно по умолчанию 1 вместо 4, установив &lt;a href=&quot;compile#default_file_format&quot;&gt;SQLITE_DEFAULT_FILE_FORMAT&lt;/a&gt; = 1 во время компиляции.</target>
        </trans-unit>
        <trans-unit id="7fae2a2a8fa480fb532533df6e47c596e4029933" translate="yes" xml:space="preserve">
          <source>New error codes may be added in future versions of SQLite.</source>
          <target state="translated">Новые коды ошибок могут быть добавлены в будущие версии SQLite.</target>
        </trans-unit>
        <trans-unit id="02a2eef012a8248fed2ec4a5f4418e441dee6267" translate="yes" xml:space="preserve">
          <source>New extensions:</source>
          <target state="translated">Новые расширения:</target>
        </trans-unit>
        <trans-unit id="c375e60e4ec3e7a7421f6f6fc9277a408ea2286e" translate="yes" xml:space="preserve">
          <source>New file format that is 25% to 35% smaller for typical use.</source>
          <target state="translated">Новый формат файла,который на 25%-35% меньше для типичного использования.</target>
        </trans-unit>
        <trans-unit id="fd04fa0f053215d42b7f8b539b38e361266bd4c9" translate="yes" xml:space="preserve">
          <source>New flags may be added in future releases of SQLite.</source>
          <target state="translated">Новые флаги могут быть добавлены в будущих релизах SQLite.</target>
        </trans-unit>
        <trans-unit id="609f25b82bb11b34abf866257917b5188d15ee70" translate="yes" xml:space="preserve">
          <source>New interface &lt;a href=&quot;c3ref/context_db_handle&quot;&gt;sqlite3_context_db_handle()&lt;/a&gt; that returns the &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; handle that has invoked an application-defined SQL function.</source>
          <target state="translated">Новый интерфейс &lt;a href=&quot;c3ref/context_db_handle&quot;&gt;sqlite3_context_db_handle (),&lt;/a&gt; который возвращает дескриптор &lt;a href=&quot;c3ref/sqlite3&quot;&gt;соединения&lt;/a&gt; с базой данных , который вызвал определяемую приложением функцию SQL.</target>
        </trans-unit>
        <trans-unit id="97e454a0ee0ddbdb1207081ac8f340c9145f813d" translate="yes" xml:space="preserve">
          <source>New interface &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit()&lt;/a&gt; allows size and length limits to be set on a per-connection basis and at run-time.</source>
          <target state="translated">Новый интерфейс &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit ()&lt;/a&gt; позволяет устанавливать ограничения размера и длины для каждого соединения и во время выполнения.</target>
        </trans-unit>
        <trans-unit id="351a6ce815b5dd18ffcf850d512cce2a33e3cd28" translate="yes" xml:space="preserve">
          <source>New interface: sqlite3_bind_parameter_index()</source>
          <target state="translated">Новый интерфейс:sqlite3_bind_parameter_index()</target>
        </trans-unit>
        <trans-unit id="ff421fae0557a39a0bd809f33195e163ee4bb7ae" translate="yes" xml:space="preserve">
          <source>New interfaces added to the test_quota.c add-on module.</source>
          <target state="translated">В дополнение к test_quota.c добавлены новые интерфейсы.</target>
        </trans-unit>
        <trans-unit id="ae3613412d28080958e2d37e217b087b523b9aae" translate="yes" xml:space="preserve">
          <source>New internal schema objects names, always beginning with &quot;sqlite_&quot;, may be added to the SQLite file format in future releases.</source>
          <target state="translated">Новые имена внутренних объектов схемы,всегда начинающиеся с &quot;sqlite_&quot;,могут быть добавлены в формат файла SQLite в будущих релизах.</target>
        </trans-unit>
        <trans-unit id="26bcef71ccfa90b2e0cbb123ce577eb05e69bad7" translate="yes" xml:space="preserve">
          <source>New memory allocators do not have to be part of the SQLite source tree nor included in the sqlite3.c &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt;. Individual applications can supply their own memory allocators to SQLite at start-time.</source>
          <target state="translated">Новые распределители памяти не обязательно должны быть частью дерева исходных текстов SQLite или включаться в &lt;a href=&quot;amalgamation&quot;&gt;объединение&lt;/a&gt; sqlite3.c . Отдельные приложения могут предоставлять свои собственные распределители памяти для SQLite во время запуска.</target>
        </trans-unit>
        <trans-unit id="5e4800161f51168ad45c54c49952a916eb4c7f5a" translate="yes" xml:space="preserve">
          <source>New options to the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; for configuring auxiliary memory usage: --pagecache, --lookaside, and --scratch.</source>
          <target state="translated">Новые параметры &lt;a href=&quot;cli&quot;&gt;оболочки командной строки&lt;/a&gt; для настройки использования вспомогательной памяти: --pagecache, --lookaside и --scratch.</target>
        </trans-unit>
        <trans-unit id="33b435c4ed8f9927e4700fe7e7aeadeae900e749" translate="yes" xml:space="preserve">
          <source>New query optimizations:</source>
          <target state="translated">Новые оптимизации запросов:</target>
        </trans-unit>
        <trans-unit id="27a96e272ba4064e97b901622de6fb30f7bc2a07" translate="yes" xml:space="preserve">
          <source>New run-time limit categories may be added in future releases.</source>
          <target state="translated">В будущих релизах могут быть добавлены новые категории ограничений по времени исполнения.</target>
        </trans-unit>
        <trans-unit id="aa7ba8a90d79e3949a9a92f1f6dd6361b3924b13" translate="yes" xml:space="preserve">
          <source>New status parameters may be added from time to time.</source>
          <target state="translated">Время от времени могут добавляться новые параметры состояния.</target>
        </trans-unit>
        <trans-unit id="8001d5465bcc215e617045ec61b342b4c0fbe511" translate="yes" xml:space="preserve">
          <source>New tests added to the test suite.</source>
          <target state="translated">В набор тестов добавлены новые тесты.</target>
        </trans-unit>
        <trans-unit id="19df796618ecb880621a1ff2386886f64457fe9e" translate="yes" xml:space="preserve">
          <source>New text tokens may be added to the end of the stat column in future enhancements to SQLite. For compatibility, unrecognized tokens at the end of the stat column are silently ignored.</source>
          <target state="translated">Новые текстовые маркеры могут быть добавлены в конец колонки &quot;Статистика&quot; в будущих улучшениях SQLite.Для совместимости непризнанные маркеры в конце колонки stat игнорируются.</target>
        </trans-unit>
        <trans-unit id="d23050a62d4b2ebb32c827e3e8678911cb996090" translate="yes" xml:space="preserve">
          <source>New tracing constants may be added in future releases.</source>
          <target state="translated">В будущих выпусках могут быть добавлены новые константы трассировки.</target>
        </trans-unit>
        <trans-unit id="8ec81cf9bf3ff78a39346bf7439447032b8bc32c" translate="yes" xml:space="preserve">
          <source>New verbs may be added in future releases of SQLite. Existing verbs might be discontinued. Applications should check the return code from &lt;a href=&quot;#sqlite3_db_status&quot;&gt;sqlite3_db_status()&lt;/a&gt; to make sure that the call worked. The &lt;a href=&quot;#sqlite3_db_status&quot;&gt;sqlite3_db_status()&lt;/a&gt; interface will return a non-zero error code if a discontinued or unsupported verb is invoked.</source>
          <target state="translated">В будущих выпусках SQLite могут быть добавлены новые команды. Существующие глаголы могут быть прекращены. Приложения должны проверить код возврата от &lt;a href=&quot;#sqlite3_db_status&quot;&gt;sqlite3_db_status (),&lt;/a&gt; чтобы убедиться, что вызов сработал. Интерфейс &lt;a href=&quot;#sqlite3_db_status&quot;&gt;sqlite3_db_status ()&lt;/a&gt; вернет ненулевой код ошибки, если вызывается прекращенная или неподдерживаемая команда.</target>
        </trans-unit>
        <trans-unit id="6997236519e17b29acb8e0c21015208012814bff" translate="yes" xml:space="preserve">
          <source>New verbs may be added in future releases of SQLite. Existing verbs might be discontinued. Applications should check the return code from &lt;a href=&quot;db_status&quot;&gt;sqlite3_db_status()&lt;/a&gt; to make sure that the call worked. The &lt;a href=&quot;db_status&quot;&gt;sqlite3_db_status()&lt;/a&gt; interface will return a non-zero error code if a discontinued or unsupported verb is invoked.</source>
          <target state="translated">В будущих выпусках SQLite могут быть добавлены новые команды. Существующие глаголы могут быть прекращены. Приложения должны проверить код возврата от &lt;a href=&quot;db_status&quot;&gt;sqlite3_db_status (),&lt;/a&gt; чтобы убедиться, что вызов сработал. Интерфейс &lt;a href=&quot;db_status&quot;&gt;sqlite3_db_status ()&lt;/a&gt; вернет ненулевой код ошибки, если вызывается прекращенная или неподдерживаемая команда.</target>
        </trans-unit>
        <trans-unit id="b162b6ee72989cc021180a9aa2d3a7a0e2b57826" translate="yes" xml:space="preserve">
          <source>New zip archives may be constructed entirely within memory using the zipfile() aggregate function. Each row visited by the aggregate function adds an entry to the zip archive. The value returned is a blob containing the entire archive image.</source>
          <target state="translated">Новые zip-архивы могут быть построены полностью в памяти с помощью функции-агрегатора zipfile().Каждая строка,которую посещает агрегатная функция,добавляет запись в zip-архив.Возвращаемое значение представляет собой блок,содержащий весь образ архива.</target>
        </trans-unit>
        <trans-unit id="e327377c14f6ddd81b93544df605d7203e2995e8" translate="yes" xml:space="preserve">
          <source>NewRowid</source>
          <target state="translated">NewRowid</target>
        </trans-unit>
        <trans-unit id="6975bed1eebd03a852e5aa6a11d0f144cd34ff6e" translate="yes" xml:space="preserve">
          <source>Newer disk drives have begun using 4096 byte sectors however. Beginning with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_10.html&quot;&gt;version 3.7.10&lt;/a&gt; (2012-01-16), the SQLite development team experimented with changes xSectorSize to report 4096 bytes as the blast radius. This had the effect of increasing write overhead on many databases. For a database with a &lt;a href=&quot;pragma#pragma_page_size&quot;&gt;PRAGMA page_size&lt;/a&gt; of 1024 (a very common choice) making a change to a single page in the database now requires SQLite to backup three other adjacent pages to the rollback journal, whereas formerly it only had to backup the one page that was changing. In &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt;, each transaction had to be padded out to the next 4096-byte boundary in the WAL file, rather than the next 512-byte boundary, resulting in thousands of extra bytes being written per transaction.</source>
          <target state="translated">Однако более новые диски начали использовать сектора размером 4096 байт. Начиная с &lt;a href=&quot;https://sqlite.org/releaselog/3_7_10.html&quot;&gt;версии&lt;/a&gt; SQLite 3.7.10 (16 января 2012 г. ), команда разработчиков SQLite экспериментировала с изменениями xSectorSize, чтобы указать 4096 байт как радиус взрыва. Это привело к увеличению накладных расходов на запись во многих базах данных. Для базы данных с &lt;a href=&quot;pragma#pragma_page_size&quot;&gt;PRAGMA page_size равным&lt;/a&gt; 1024 (очень распространенный выбор) для внесения изменений на одну страницу в базе данных теперь требуется, чтобы SQLite сделал резервную копию трех других соседних страниц в журнале отката, тогда как раньше требовалось резервное копирование только одной страницы, которая менялось. В &lt;a href=&quot;wal&quot;&gt;режиме WAL&lt;/a&gt; каждая транзакция должна была быть дополнена до следующей границы в 4096 байт в файле WAL, а не до следующей границы в 512 байт, в результате на каждую транзакцию записывались тысячи дополнительных байтов.</target>
        </trans-unit>
        <trans-unit id="bc981983e7f547dc62e19a1e383acfe00782a6d5" translate="yes" xml:space="preserve">
          <source>Next</source>
          <target state="translated">Next</target>
        </trans-unit>
        <trans-unit id="bc1189b8a3e7e2b908b403ea79a8eb14b14bcd47" translate="yes" xml:space="preserve">
          <source>Next, make copies of all the blobs into individual files in a directory using a command like this:</source>
          <target state="translated">Далее,сделайте копии всех блоков в отдельные файлы в каталоге с помощью такой команды:</target>
        </trans-unit>
        <trans-unit id="73f7cfb7746314674a12b8d200b36135947e050b" translate="yes" xml:space="preserve">
          <source>Next, move the resulting kvtest-android executable to the Android device:</source>
          <target state="translated">Далее переместите полученный исполняемый файл kvtest-android на Android-устройство:</target>
        </trans-unit>
        <trans-unit id="21d2b394790e7b47b83f7c9d1daa6c55ee3c0c16" translate="yes" xml:space="preserve">
          <source>Next, suppose that you want to look up the price of not just any orange, but specifically California-grown oranges. The appropriate query would be as follows:</source>
          <target state="translated">Далее,предположим,что вы хотите посмотреть цену не просто на любой апельсин,а именно на выращенные в Калифорнии апельсины.Соответствующий запрос будет выглядеть следующим образом:</target>
        </trans-unit>
        <trans-unit id="816c52fd2bdd94a63cd0944823a6c0aa9384c103" translate="yes" xml:space="preserve">
          <source>No</source>
          <target state="translated">No</target>
        </trans-unit>
        <trans-unit id="dad2991d263e4aa51578f91e92e9777428d9762b" translate="yes" xml:space="preserve">
          <source>No (Note 1)</source>
          <target state="translated">Нет (Примечание 1)</target>
        </trans-unit>
        <trans-unit id="b4f66722cbcf69861e819a02ca8d6803b779fcd3" translate="yes" xml:space="preserve">
          <source>No Isolation Between Operations On The Same Database Connection</source>
          <target state="translated">Нет изоляции между операциями при одном и том же подключении к базе данных.</target>
        </trans-unit>
        <trans-unit id="8dae863821cb04b5484c9a0e7717d726d350b9bd" translate="yes" xml:space="preserve">
          <source>No application file I/O code to write and debug.</source>
          <target state="translated">Нет кода входа/выхода из файла приложения для написания и отладки.</target>
        </trans-unit>
        <trans-unit id="95ec05297c8cafc96feb998f4af109f4728d5530" translate="yes" xml:space="preserve">
          <source>No change</source>
          <target state="translated">Без изменений</target>
        </trans-unit>
        <trans-unit id="7f2ff41fbbf4963dea6c3e81c6aa743e95c596b5" translate="yes" xml:space="preserve">
          <source>No current or conflicting row information is provided. The only function it is possible to call on the supplied sqlite3_changeset_iter handle is sqlite3changeset_fk_conflicts().</source>
          <target state="translated">Никакой текущей или противоречивой информации о строках не предоставляется.Единственная функция,которую можно вызвать на поставляемом дескрипторе sqlite3_changeset_iter-sqlite3changeset_fk_conflicts().</target>
        </trans-unit>
        <trans-unit id="7c5c383086cc31c41ab2122a84d0a48706ccfc11" translate="yes" xml:space="preserve">
          <source>No error is raised if a width or precision exceeds SQLITE_PRINTF_PRECISION_LIMIT. Instead, the large width or precision is silently truncated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="662adfcee595804e0d0a40f3427892366f101024" translate="yes" xml:space="preserve">
          <source>No error messages are generated if an unknown pragma is issued. Unknown pragmas are simply ignored. This means if there is a typo in a pragma statement the library does not inform the user of the fact.</source>
          <target state="translated">Сообщения об ошибках не выдаются,если выдается неизвестная прагма.Неизвестные прагмы просто игнорируются.Это означает,что если в прагматическом высказывании есть опечатка,библиотека не информирует пользователя об этом факте.</target>
        </trans-unit>
        <trans-unit id="36386488a9bfa58ff6f23801ec174053b73ed777" translate="yes" xml:space="preserve">
          <source>No locking style. If none of the above can be supported, this locking style is used. No database locking mechanism is used. When this system is used it is not safe for a single database to be accessed by multiple clients.</source>
          <target state="translated">Никакого стиля блокировки.Если ни один из вышеперечисленных способов не поддерживается,используется этот стиль блокировки.Механизм блокировки БД не используется.При использовании этой системы обращение к одной БД для нескольких клиентов небезопасно.</target>
        </trans-unit>
        <trans-unit id="7b15426333f8adb77f306aae95c84b204b379d14" translate="yes" xml:space="preserve">
          <source>No locks are held on the database. The database may be neither read nor written. Any internally cached data is considered suspect and subject to verification against the database file before being used. Other processes can read or write the database as their own locking states permit. This is the default state.</source>
          <target state="translated">В базе данных нет замков.База данных не может быть ни прочитана,ни записана.Любые внутренние кэшированные данные считаются подозрительными и подлежат проверке по файлу базы данных перед использованием.Другие процессы могут читать или записывать БД,если позволяют их собственные состояния блокировки.Это состояние по умолчанию.</target>
        </trans-unit>
        <trans-unit id="589cdf57b87436c5bbc074aa5e48b70f3f3363e1" translate="yes" xml:space="preserve">
          <source>No longer in use.</source>
          <target state="translated">Больше не используется.</target>
        </trans-unit>
        <trans-unit id="7375825a734eee4acde64dd3de9ae4b6f89db26c" translate="yes" xml:space="preserve">
          <source>No longer used.</source>
          <target state="translated">Больше не используется.</target>
        </trans-unit>
        <trans-unit id="1cff8c4990053d03c141cc08cc6f740585898fb6" translate="yes" xml:space="preserve">
          <source>No one is required to follow The Rule, to know The Rule, or even to think that The Rule is a good idea. The Founder of SQLite believes that anyone who follows The Rule will live a happier and more productive life, but individuals are free to dispute or ignore that advice if they wish.</source>
          <target state="translated">Никто не обязан следовать Правилам,знать Правила или даже думать,что Правила-это хорошая идея.Основатель SQLite считает,что каждый,кто следует Правилам,будет жить более счастливой и продуктивной жизнью,но люди могут свободно спорить или игнорировать эти советы,если захотят.</target>
        </trans-unit>
        <trans-unit id="a4226fa0e8cf6311cf2613fee3e52c99bd81b607" translate="yes" xml:space="preserve">
          <source>No other processes can change the database so there is never a need to check the change counter and clear the user-space cache at the beginning of a transaction.</source>
          <target state="translated">Никакие другие процессы не могут изменить базу данных,поэтому нет необходимости проверять счетчик изменений и очищать кэш пользовательского пространства в начале транзакции.</target>
        </trans-unit>
        <trans-unit id="6b5b494aee4d1b7c43eaf07044f46f3778af61cd" translate="yes" xml:space="preserve">
          <source>No other writes may occur on the target database while the RBU update is being applied. A read-lock is held on the target database to prevent this.</source>
          <target state="translated">Во время обновления RBU в целевой базе данных не может происходить никаких других записей.Для предотвращения этого в целевой базе данных удерживается блокировка чтения.</target>
        </trans-unit>
        <trans-unit id="3943b575617ba52cb8729616c676b13dc34b8e79" translate="yes" xml:space="preserve">
          <source>No reads or writes occur except within a transaction. Any command that accesses the database (basically, any SQL command, except a few &lt;a href=&quot;pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt; statements) will automatically start a transaction if one is not already in effect. Automatically started transactions are committed when the last SQL statement finishes.</source>
          <target state="translated">Никаких операций чтения или записи не происходит, кроме как внутри транзакции. Любая команда, которая обращается к базе данных (в основном, любая команда SQL, кроме нескольких операторов &lt;a href=&quot;pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt; ), автоматически запускает транзакцию, если она еще не действует. Автоматически запущенные транзакции фиксируются после завершения последнего оператора SQL.</target>
        </trans-unit>
        <trans-unit id="2a9bc5ebe3cc4eba5a484c518ae347f8a47ccd50" translate="yes" xml:space="preserve">
          <source>No table in a union-vtab may contain entries that are outside of the rowid bounds established by the</source>
          <target state="translated">Ни одна из таблиц в профсоюзной записной книжке не может содержать записи,выходящие за пределы рядовых границ,установленных в</target>
        </trans-unit>
        <trans-unit id="7d5b25b567984a7a4091e940273bfff96cd2fed3" translate="yes" xml:space="preserve">
          <source>No. When you delete information from an SQLite database, the unused disk space is added to an internal &quot;free-list&quot; and is reused the next time you insert data. The disk space is not lost. But neither is it returned to the operating system.</source>
          <target state="translated">Нет.Когда вы удаляете информацию из базы данных SQLite,неиспользованное дисковое пространство добавляется во внутренний &quot;свободный список&quot; и при следующем вводе данных используется повторно.Дисковое пространство не теряется.Но и оно не возвращается в операционную систему.</target>
        </trans-unit>
        <trans-unit id="d4e9f5ef9057ec35a6f3d638ab0a7b961dadfa79" translate="yes" xml:space="preserve">
          <source>NoConflict</source>
          <target state="translated">NoConflict</target>
        </trans-unit>
        <trans-unit id="66290ce3e3466df1560e431a1eebe9e205ef9f1e" translate="yes" xml:space="preserve">
          <source>Non-ASCII range characters (i.e. unicode codepoints greater than 127), or</source>
          <target state="translated">Символы,не относящиеся к диапазону ASCII (т.е.кодовые точки юникода больше 127),или</target>
        </trans-unit>
        <trans-unit id="1bc1387523b6d25784112f80a2990511e6a57420" translate="yes" xml:space="preserve">
          <source>Non-Vista Windows platforms only support one set of DST rules. Vista only supports two. Therefore, on these platforms, historical DST calculations will be incorrect. For example, in the US, in 2007 the DST rules changed. Non-Vista Windows platforms apply the new 2007 DST rules to all previous years as well. Vista does somewhat better getting results correct back to 1986, when the rules were also changed.</source>
          <target state="translated">Платформы не для Windows Vista поддерживают только один набор правил DST.Vista поддерживает только два.Поэтому на этих платформах исторические вычисления DST будут некорректны.Например,в США в 2007 году изменились правила DST.Платформы Non-Vista Windows также применяют новые 2007 DST правила ко всем предыдущим годам.Vista делает несколько лучше,получая корректные результаты еще в 1986 году,когда правила тоже были изменены.</target>
        </trans-unit>
        <trans-unit id="b1b833538f0549b7c8aca0acf47c1aa5ac7f2fac" translate="yes" xml:space="preserve">
          <source>Non-deterministic functions might give different answers on each invocation, even if the arguments are always the same. The following are examples of non-deterministic functions:</source>
          <target state="translated">Недетерминистические функции могут давать разные ответы на каждый вызов,даже если аргументы всегда одни и те же.Ниже приведены примеры недетерминистических функций:</target>
        </trans-unit>
        <trans-unit id="cf3ad9f318d5d17809c32f85aa54a78cb4cda991" translate="yes" xml:space="preserve">
          <source>Non-streaming equivalent</source>
          <target state="translated">Непотоковый эквивалент</target>
        </trans-unit>
        <trans-unit id="1d0d5248c3c8dbbb61313817bba98f17697e01b6" translate="yes" xml:space="preserve">
          <source>Non-streaming functions that accept changesets (or patchsets) as input require that the entire changeset be stored in a single buffer in memory. Similarly, those that return a changeset or patchset do so by returning a pointer to a single large buffer allocated using sqlite3_malloc(). Normally this is convenient. However, if an application running in a low-memory environment is required to handle very large changesets, the large contiguous memory allocations required can become onerous.</source>
          <target state="translated">Непотоковые функции,которые принимают наборы изменений (или патч-сеты)в качестве входных,требуют,чтобы весь набор изменений хранился в одном буфере в памяти.Аналогичным образом,те,кто возвращает changeset или patchset,делают это,возвращая указатель на один большой буфер,выделенный с помощью sqlite3_malloc().Обычно это удобно.Однако,если приложению,работающему в среде с низкой памятью,необходимо обрабатывать очень большие changeset'ы,то требуемое большое последовательное выделение памяти может стать обременительным.</target>
        </trans-unit>
        <trans-unit id="09f7070838a5d668002d389cd9b3fec752e6c30d" translate="yes" xml:space="preserve">
          <source>None of the safe programming languages existed for the first 10 years of SQLite's existence. SQLite could be recoded in Go or Rust, but doing so would probably introduce far more bugs than would be fixed, and it seems also likely to result in slower code.</source>
          <target state="translated">За первые 10 лет существования SQLite не существовало ни одного безопасного языка программирования.SQLite можно было бы перекодировать в Go или Rust,но это,скорее всего,привело бы к появлению гораздо большего количества ошибок,чем было бы исправлено,а также,похоже,привело бы к замедлению работы кода.</target>
        </trans-unit>
        <trans-unit id="9b9f34e057f76ac2b419477d464548015d8ef844" translate="yes" xml:space="preserve">
          <source>None of the xSavepoint(), xRelease(), or xRollbackTo() methods will ever be called except in between calls to xBegin() and either xCommit() or xRollback().</source>
          <target state="translated">Ни один из методов xSavepoint(),xRelease()или xRollbackTo()никогда не будет вызван,кроме как между вызовами xBegin()и либо xCommit(),либо xRollback().</target>
        </trans-unit>
        <trans-unit id="a1fe0caa1d6e9f3e9dd7087ae4f2a9ea810cd170" translate="yes" xml:space="preserve">
          <source>Noop</source>
          <target state="translated">Noop</target>
        </trans-unit>
        <trans-unit id="2bbfb9d52741dbc3a4ff03abc70ca82cb8e2f1bc" translate="yes" xml:space="preserve">
          <source>Normal functions specify only xFunc and leave xStep and xFinal set to NULL. Aggregate functions specify xStep and xFinal and leave xFunc set to NULL. There is no separate sqlite3_create_aggregate() API.</source>
          <target state="translated">Нормальные функции указывают только xFunc и оставляют xStep и xFinal set в NULL.Функции агрегирования указывают xStep и xFinal и оставляют xFunc установлено в NULL.Отдельного API sqlite3_create_aggregate()нет.</target>
        </trans-unit>
        <trans-unit id="8feff5d8988d2d3b3f82fe7920cdb81d5ba04e3a" translate="yes" xml:space="preserve">
          <source>Normal meaning</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e304219719d389c0ea46b9c98590f2134fb67330" translate="yes" xml:space="preserve">
          <source>Normally, FTS5 maintains a special backing table within the database that stores the size of each column value in tokens inserted into the main FTS5 table in a separate table. This backing table is used by the &lt;a href=&quot;#xColumnSize&quot;&gt;xColumnSize&lt;/a&gt;&lt;a&gt; API function, which is in turn used by the built-in &lt;/a&gt;&lt;a href=&quot;fts5#the_bm25_function&quot;&gt;bm25 ranking function&lt;/a&gt; (and is likely to be useful to other ranking functions as well).</source>
          <target state="translated">Обычно FTS5 поддерживает специальную вспомогательную таблицу в базе данных, в которой размер каждого значения столбца в токенах, вставленных в основную таблицу FTS5, хранится в отдельной таблице. Эта &lt;a href=&quot;#xColumnSize&quot;&gt;вспомогательная&lt;/a&gt; таблица используется функцией &lt;a&gt;API &lt;/a&gt;xColumnSize , которая, в свою очередь, используется встроенной &lt;a href=&quot;fts5#the_bm25_function&quot;&gt;функцией ранжирования bm25&lt;/a&gt; (и, вероятно, также будет полезна для других функций ранжирования).</target>
        </trans-unit>
        <trans-unit id="866b49d7e3deb743a545b4433375afa6debe3327" translate="yes" xml:space="preserve">
          <source>Normally, NULL SQL results are stored in the array using the &lt;a href=&quot;#nullvalue&quot;&gt;nullvalue&lt;/a&gt; setting. However, if the &lt;b&gt;-withoutnulls&lt;/b&gt; option is used, then NULL SQL values cause the corresponding array element to be unset instead.</source>
          <target state="translated">Обычно результаты NULL SQL сохраняются в массиве с использованием значения &lt;a href=&quot;#nullvalue&quot;&gt;NULL&lt;/a&gt; . Однако, если используется опция &lt;b&gt;-withoutnulls&lt;/b&gt; , тогда значения NULL SQL заставляют вместо этого сбрасывать соответствующий элемент массива.</target>
        </trans-unit>
        <trans-unit id="d1f5712d735a4022fc9c1482cc2c46055815935d" translate="yes" xml:space="preserve">
          <source>Normally, SQLite assumes that if a power failure occurs while updating any portion of a sector then the contents of the entire device sector is suspect following recovery. After writing to any part of a sector within a file, it is assumed that the modified sector contents are held in a volatile buffer somewhere within the system (main memory, disk cache etc.). SQLite does not assume that the updated data has reached the persistent storage media, until after it has successfully</source>
          <target state="translated">Обычно SQLite предполагает,что если при обновлении любой части сектора происходит сбой электропитания,то после восстановления возникает подозрение на содержимое всего сектора устройства.После записи в любую часть сектора в файле предполагается,что содержимое измененного сектора хранится в переменном буфере где-то в системе (основная память,дисковый кэш и т.д.).SQLite не предполагает,что обновленные данные попали на постоянный носитель,до тех пор,пока не будет успешно восстановлено</target>
        </trans-unit>
        <trans-unit id="e5b528fefcff05064efc30021e7a7579eaaad4d2" translate="yes" xml:space="preserve">
          <source>Normally, a token or token prefix query is matched against the FTS table column specified as the left-hand side of the MATCH operator. Or, if the special column with the same name as the FTS table itself is specified, against all columns. This may be overridden by specifying a column-name followed by a &quot;:&quot; character before a basic term query. There may be space between the &quot;:&quot; and the term to query for, but not between the column-name and the &quot;:&quot; character. For example:</source>
          <target state="translated">Обычно запрос на токен или префикс токена сопоставляется со столбцом таблицы FTS,указанным в качестве левой стороны MATCH-оператора.Или,если указан специальный столбец с тем же именем,что и сама таблица FTS,против всех столбцов.Это может быть отменено путем указания имени столбца с последующим символом &quot;:&quot; перед запросом на основной термин.Между &quot;:&quot; и термином,в отношении которого осуществляется запрос,может быть пробел,но не пробел между именем столбца и символом &quot;:&quot;.Например:</target>
        </trans-unit>
        <trans-unit id="bf4491e66772ed8b491e6908438d7924fa774545" translate="yes" xml:space="preserve">
          <source>Normally, an SQL index references columns of a table. But an index can also be formed on expressions involving table columns.</source>
          <target state="translated">Обычно SQL-индекс ссылается на столбцы таблицы.Но индекс также может быть сформирован на выражениях,включающих столбцы таблицы.</target>
        </trans-unit>
        <trans-unit id="39e8cea13d3d48550994e6ce4ac623d3130ee592" translate="yes" xml:space="preserve">
          <source>Normally, fossil will modify all the files in your checkout when switching between the private and the public branches. But at this point, the files are identical in both branches so not modifications need to be made.</source>
          <target state="translated">Обычно при переключении между частным и государственным секторами ископаемые изменяют все файлы,находящиеся в вашей кассе.Но на данный момент файлы идентичны в обеих ветках,поэтому модификаций делать не нужно.</target>
        </trans-unit>
        <trans-unit id="d3d92a3c721eaacd534b06f545203c90c257b9b9" translate="yes" xml:space="preserve">
          <source>Normally, full-text queries are case-insensitive. However, this is dependent on the specific &lt;a href=&quot;fts3#tokenizer&quot;&gt;tokenizer&lt;/a&gt; used by the FTS table being queried. Refer to the section on &lt;a href=&quot;fts3#tokenizer&quot;&gt;tokenizers&lt;/a&gt; for details.</source>
          <target state="translated">Обычно в полнотекстовых запросах регистр не учитывается. Однако это зависит от конкретного &lt;a href=&quot;fts3#tokenizer&quot;&gt;токенизатора,&lt;/a&gt; используемого запрашиваемой таблицей FTS. Подробности см. В разделе &lt;a href=&quot;fts3#tokenizer&quot;&gt;токенизаторов&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="63e53b72fdcc0af9b1c300c26469b45178a485e4" translate="yes" xml:space="preserve">
          <source>Normally, the FTS module maintains an inverted index of all terms in all columns of the table. This option is used to specify the name of a column for which entries should not be added to the index. Multiple &quot;notindexed&quot; options may be used to specify that multiple columns should be omitted from the index. For example:</source>
          <target state="translated">Обычно модуль FTS поддерживает инвертированный индекс всех терминов во всех столбцах таблицы.Эта опция используется для указания названия столбца,для которого не следует добавлять записи в индекс.Можно использовать несколько опций &quot;неиндексировать&quot;,чтобы указать,что из индекса следует исключить несколько столбцов.Например:</target>
        </trans-unit>
        <trans-unit id="ebe2262110ee72155bb934332e4fc5587e66a440" translate="yes" xml:space="preserve">
          <source>Normally, the database &lt;a href=&quot;pragma#pragma_page_size&quot;&gt;page_size&lt;/a&gt; and whether or not the database supports &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum&lt;/a&gt; must be configured before the database file is actually created. However, when not in &lt;a href=&quot;wal&quot;&gt;write-ahead log&lt;/a&gt; mode, the &lt;a href=&quot;pragma#pragma_page_size&quot;&gt;page_size&lt;/a&gt; and/or &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum&lt;/a&gt; properties of an existing database may be changed by using the &lt;a href=&quot;pragma#pragma_page_size&quot;&gt;page_size&lt;/a&gt; and/or &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;pragma auto_vacuum&lt;/a&gt; pragmas and then immediately VACUUMing the database. When in &lt;a href=&quot;wal&quot;&gt;write-ahead log&lt;/a&gt; mode, only the &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum&lt;/a&gt; support property can be changed using VACUUM.</source>
          <target state="translated">Обычно &lt;a href=&quot;pragma#pragma_page_size&quot;&gt;размер page_size&lt;/a&gt; базы данных и то, поддерживает ли база данных &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum,&lt;/a&gt; должны быть настроены до фактического создания файла базы данных. Однако, когда он не находится в режиме &lt;a href=&quot;wal&quot;&gt;журнала&lt;/a&gt; с &lt;a href=&quot;pragma#pragma_page_size&quot;&gt;упреждающей &lt;/a&gt;&lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;записью,&lt;/a&gt; свойства page_size и / или auto_vacuum существующей базы данных могут быть изменены с помощью &lt;a href=&quot;pragma#pragma_page_size&quot;&gt;прагм page_size&lt;/a&gt; и / или &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;pragma auto_vacuum,&lt;/a&gt; а затем немедленно VACUUMing базы данных. В режиме &lt;a href=&quot;wal&quot;&gt;журнала упреждающей&lt;/a&gt; записи с помощью VACUUM можно изменить только &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;свойство&lt;/a&gt; поддержки auto_vacuum .</target>
        </trans-unit>
        <trans-unit id="5df62864e283fb4361bad80921bbac8b7ec57013" translate="yes" xml:space="preserve">
          <source>Normally, when SQLite writes to a database file, it waits until the write operation is finished before returning control to the calling application. Since writing to the file-system is usually very slow compared with CPU bound operations, this can be a performance bottleneck. The asynchronous I/O backend is an extension that causes SQLite to perform all write requests using a separate thread running in the background. Although this does not reduce the overall system resources (CPU, disk bandwidth etc.), it does allow SQLite to return control to the caller quickly even when writing to the database.</source>
          <target state="translated">Обычно,когда SQLite записывает в файл базы данных,он ждет завершения операции записи,прежде чем вернуть управление вызывающему приложению.Поскольку запись в файловую систему обычно происходит очень медленно по сравнению с операциями,связанными с процессором,это может быть узким местом в производительности.Бэкэнд асинхронного ввода/вывода является расширением,которое заставляет SQLite выполнять все запросы на запись с помощью отдельного потока,работающего в фоновом режиме.Хотя это и не уменьшает общие системные ресурсы (процессор,пропускную способность диска и т.д.),но позволяет SQLite быстро возвращать управление вызывающему абоненту даже при записи в базу данных.</target>
        </trans-unit>
        <trans-unit id="b810f7b8c9c4b12cca67db5205f27d6d0477e848" translate="yes" xml:space="preserve">
          <source>Normally, when a row is inserted into an FTS5 table, as well as the various full-text index entries and other data a copy of the row is stored in a private table managed by the FTS5 module. When column values are requested from the FTS5 table by the user or by an auxiliary function implementation, they are read from this private table. The &quot;content&quot; option may be used to create an FTS5 table that stores only FTS full-text index entries. Because the column values themselves are usually much larger than the associated full-text index entries, this can save significant database space.</source>
          <target state="translated">Обычно,когда строка вставляется в таблицу FTS5,а также различные полнотекстовые элементы индекса и другие данные,копия строки хранится в приватной таблице,управляемой модулем FTS5.Когда значения столбцов запрашиваются из таблицы FTS5 пользователем или реализацией вспомогательной функции,они считываются из этой закрытой таблицы.Опция &quot;содержимое&quot; может быть использована для создания таблицы FTS5,в которой хранятся только записи полнотекстового индекса FTS.Поскольку сами значения столбцов обычно намного больше,чем соответствующие элементы полнотекстового индекса,это может сэкономить значительное пространство в БД.</target>
        </trans-unit>
        <trans-unit id="ca1dd39379254ab3f3c73dbffb0d03d628b27d20" translate="yes" xml:space="preserve">
          <source>Not</source>
          <target state="translated">Not</target>
        </trans-unit>
        <trans-unit id="5927a7e485b2adcf5a36cf65c4801a2eed120fcc" translate="yes" xml:space="preserve">
          <source>Not all applications meet these conditions. Fortunately, the NGQP will still usually find good query plans, even without these conditions. However, cases do arise (rarely) where performance regressions can occur.</source>
          <target state="translated">Не все приложения соответствуют этим условиям.К счастью,NGQP все равно обычно находит хорошие планы запросов,даже без этих условий.Тем не менее,возникают (редко)случаи,когда могут произойти регрессии производительности.</target>
        </trans-unit>
        <trans-unit id="6938024f626f02a7276620a318f6367169f62576" translate="yes" xml:space="preserve">
          <source>Not all test cases can be handled this way. Some test cases check to verify that the optimizations really are reducing the amount of computation by counting the number of disk accesses, sort operations, full-scan steps, or other processing steps that occur during queries. Those test cases will appear to fail when optimizations are disabled. But the majority of test cases simply check that the correct answer was obtained, and all of those cases can be run successfully with and without the optimizations, in order to show that the optimizations do not cause malfunctions.</source>
          <target state="translated">Не все тестовые случаи могут быть решены таким образом.Некоторые тестовые случаи проверяют,что оптимизация действительно уменьшает объем вычислений путем подсчета количества обращений к диску,операций сортировки,шагов полного сканирования или других шагов обработки,которые происходят во время запросов.Эти тестовые случаи будут казаться неудачными,когда оптимизации отключены.Но большинство тестовых случаев просто проверяют,что получен правильный ответ,и все эти случаи могут быть успешно запущены с оптимизациями и без них,чтобы показать,что оптимизации не приводят к сбоям.</target>
        </trans-unit>
        <trans-unit id="d047995ecc6203bb86f7cef3de1f0a2b4fa5dba8" translate="yes" xml:space="preserve">
          <source>Not ever decimal number with fewer than 16 significant digits can be represented exactly as a binary64 number. In fact, most decimal numbers with digits to the right of the decimal point lack an exact binary64 equivalent. For example, if you have a database column that is intended to hold an item price in dollars and cents, the only cents value that can be exactly represented are 0.00, 0.25, 0.50, and 0.75. Any other numbers to the right of the decimal point result in an approximation. If you provide a &quot;price&quot; value of 47.49, that number will be represented in binary64 as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="593dbd15d49368a738585302a9107baf925136df" translate="yes" xml:space="preserve">
          <source>Not shown in the example above is that there are also &lt;a href=&quot;fts5#fts5_table_creation_and_initialization&quot;&gt;various options&lt;/a&gt; that may be provided to FTS5 as part of the CREATE VIRTUAL TABLE statement to configure various aspects of the new table. These may be used to modify the way in which the FTS5 table extracts terms from documents and queries, to create extra indexes on disk to speed up prefix queries, or to create an FTS5 table that acts as an index on content stored elsewhere.</source>
          <target state="translated">В приведенном выше примере не показано, что существуют также &lt;a href=&quot;fts5#fts5_table_creation_and_initialization&quot;&gt;различные параметры,&lt;/a&gt; которые могут быть предоставлены FTS5 как часть оператора CREATE VIRTUAL TABLE для настройки различных аспектов новой таблицы. Они могут использоваться для изменения способа, которым таблица FTS5 извлекает термины из документов и запросов, для создания дополнительных индексов на диске для ускорения префиксных запросов или для создания таблицы FTS5, которая действует как индекс для контента, хранящегося в другом месте.</target>
        </trans-unit>
        <trans-unit id="edbfab21e07e4e0dbe02fb875980c40bdd52ad0f" translate="yes" xml:space="preserve">
          <source>NotExists</source>
          <target state="translated">NotExists</target>
        </trans-unit>
        <trans-unit id="6f05e7cc9203f83829c08dcc46fafe9db426763f" translate="yes" xml:space="preserve">
          <source>NotFound</source>
          <target state="translated">NotFound</target>
        </trans-unit>
        <trans-unit id="85c73c74f4b29a9fb7ba8d0a5bc532eb27f0866a" translate="yes" xml:space="preserve">
          <source>NotNull</source>
          <target state="translated">NotNull</target>
        </trans-unit>
        <trans-unit id="7884a1030f088443b3e65dc8c7d9c833c3f14209" translate="yes" xml:space="preserve">
          <source>Nota bene:</source>
          <target state="translated">Не за что:</target>
        </trans-unit>
        <trans-unit id="59ab81d7ff99620547d7c60a07878ec16f88cba0" translate="yes" xml:space="preserve">
          <source>Note also that when adding a &lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK constraint&lt;/a&gt;, the CHECK constraint is not tested against preexisting rows of the table. This can result in a table that contains data that is in violation of the CHECK constraint. Future versions of SQLite might change to validate CHECK constraints as they are added.</source>
          <target state="translated">Также обратите внимание, что при добавлении &lt;a href=&quot;lang_createtable#ckconst&quot;&gt;ограничения CHECK ограничение&lt;/a&gt; CHECK не проверяется на ранее существовавших строках таблицы. В результате может получиться таблица, содержащая данные, нарушающие ограничение CHECK. Будущие версии SQLite могут измениться для проверки ограничений CHECK по мере их добавления.</target>
        </trans-unit>
        <trans-unit id="63cff68b4cc8b6d1593b377ca2761e4a780c9aef" translate="yes" xml:space="preserve">
          <source>Note that &quot;monotonically increasing&quot; does not imply that the ROWID always increases by exactly one. One is the usual increment. However, if an insert fails due to (for example) a uniqueness constraint, the ROWID of the failed insertion attempt might not be reused on subsequent inserts, resulting in gaps in the ROWID sequence. AUTOINCREMENT guarantees that automatically chosen ROWIDs will be increasing but not that they will be sequential.</source>
          <target state="translated">Обратите внимание,что &quot;монотонное увеличение&quot; не означает,что ROWID всегда увеличивается ровно на единицу.Одно из них-обычное увеличение.Однако,если вставка не удается из-за (например)ограничения уникальности,ROWID неудачной попытки вставки может не использоваться повторно на последующих вставках,что приведет к пробелам в последовательности ROWID.АВТОИНКРЕМЕНТ гарантирует,что автоматически выбранные ROWID будут увеличиваться,но не будут последовательными.</target>
        </trans-unit>
        <trans-unit id="4308667a324be6565f7e88fc7a4b19a7777f66dd" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;#sqlite3_create_function&quot;&gt;application-defined SQL functions&lt;/a&gt; or &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt; might change the database indirectly as a side effect. For example, if an application defines a function &quot;eval()&quot; that calls &lt;a href=&quot;#sqlite3_exec&quot;&gt;sqlite3_exec()&lt;/a&gt;, then the following SQL statement would change the database file through side-effects:</source>
          <target state="translated">Обратите внимание, что &lt;a href=&quot;#sqlite3_create_function&quot;&gt;определяемые приложением функции SQL&lt;/a&gt; или &lt;a href=&quot;vtab&quot;&gt;виртуальные таблицы&lt;/a&gt; могут косвенно изменять базу данных в качестве побочного эффекта. Например, если приложение определяет функцию eval (), которая вызывает &lt;a href=&quot;#sqlite3_exec&quot;&gt;sqlite3_exec ()&lt;/a&gt; , то следующий оператор SQL изменит файл базы данных из-за побочных эффектов:</target>
        </trans-unit>
        <trans-unit id="2de1256b9fbe19c405bb475cc7365f640da5726d" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;../appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt; or &lt;a href=&quot;../vtab&quot;&gt;virtual tables&lt;/a&gt; might change the database indirectly as a side effect. For example, if an application defines a function &quot;eval()&quot; that calls &lt;a href=&quot;exec&quot;&gt;sqlite3_exec()&lt;/a&gt;, then the following SQL statement would change the database file through side-effects:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a8f4592d0e17a85103883247d0a4447a3744957" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt; are by default considered non-deterministic and may not be used in a CREATE INDEX statement unless the &lt;a href=&quot;c3ref/c_deterministic#sqlitedeterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt; flag is used when the function is registered.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1de4b11ed42096116749429497dc130939876ea1" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt; or &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt; might change the database indirectly as a side effect. For example, if an application defines a function &quot;eval()&quot; that calls &lt;a href=&quot;#sqlite3_exec&quot;&gt;sqlite3_exec()&lt;/a&gt;, then the following SQL statement would change the database file through side-effects:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa33906842475ccf0659a59159f766bfacc10e93" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;c3ref/create_function&quot;&gt;application-defined SQL functions&lt;/a&gt; are by default considered non-deterministic and may not be used in a CREATE INDEX statement unless the &lt;a href=&quot;c3ref/c_deterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt; flag is used when the function is registered.</source>
          <target state="translated">Обратите внимание, что &lt;a href=&quot;c3ref/create_function&quot;&gt;определяемые приложением функции SQL&lt;/a&gt; по умолчанию считаются недетерминированными и не могут использоваться в операторе CREATE INDEX, если при &lt;a href=&quot;c3ref/c_deterministic&quot;&gt;регистрации функции&lt;/a&gt; не используется флаг SQLITE_DETERMINISTIC .</target>
        </trans-unit>
        <trans-unit id="5f9e6d6d8a3bf2c6d2a7e519940c1c6c58742f80" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;create_function&quot;&gt;application-defined SQL functions&lt;/a&gt; or &lt;a href=&quot;../vtab&quot;&gt;virtual tables&lt;/a&gt; might change the database indirectly as a side effect. For example, if an application defines a function &quot;eval()&quot; that calls &lt;a href=&quot;exec&quot;&gt;sqlite3_exec()&lt;/a&gt;, then the following SQL statement would change the database file through side-effects:</source>
          <target state="translated">Обратите внимание, что &lt;a href=&quot;create_function&quot;&gt;определяемые приложением функции SQL&lt;/a&gt; или &lt;a href=&quot;../vtab&quot;&gt;виртуальные таблицы&lt;/a&gt; могут косвенно изменять базу данных в качестве побочного эффекта. Например, если приложение определяет функцию eval (), которая вызывает &lt;a href=&quot;exec&quot;&gt;sqlite3_exec ()&lt;/a&gt; , то следующий оператор SQL изменит файл базы данных из-за побочных эффектов:</target>
        </trans-unit>
        <trans-unit id="f679875d06130633120a14b47faa759dd16975f1" translate="yes" xml:space="preserve">
          <source>Note that Idx3 contains all the same information as the original &lt;a href=&quot;#fig3&quot;&gt;Idx1&lt;/a&gt;. And so if we have Idx3, we do not really need Idx1 any more. The &quot;price of peaches&quot; query can be satisfied using Idx3 by simply ignoring the &quot;state&quot; column of Idx3:</source>
          <target state="translated">Обратите внимание, что Idx3 содержит всю ту же информацию, что и исходный &lt;a href=&quot;#fig3&quot;&gt;Idx1&lt;/a&gt; . Итак, если у нас есть Idx3, нам больше не нужен Idx1. Запрос &amp;laquo;цена персиков&amp;raquo; можно удовлетворить с помощью Idx3, просто игнорируя столбец &amp;laquo;состояние&amp;raquo; Idx3:</target>
        </trans-unit>
        <trans-unit id="8e97b2bc14d77a13e225d171f50b67e2004fff89" translate="yes" xml:space="preserve">
          <source>Note that MinGW generates 32-bit DLLs only. There is a separate MinGW64 project that can be used to generate 64-bit DLLs. Presumably the command-line syntax is similar. Also note that recent versions of MSVC generate DLLs that will not work on WinXP and earlier versions of Windows. So for maximum compatibility of your generated DLL, MinGW is recommended. A good rule-of-thumb is to generate 32-bit DLLs using MinGW and 64-bit DLLs using MSVC.</source>
          <target state="translated">Обратите внимание,что MinGW генерирует только 32-битные DLL.Существует отдельный проект MinGW64,который может быть использован для генерации 64-битных DLL.Предположительно,синтаксис командной строки аналогичен.Также обратите внимание,что последние версии MSVC генерируют DLL,которые не будут работать на WinXP и более ранних версиях Windows.Поэтому для максимальной совместимости с генерируемыми вами DLL рекомендуется MinGW.Хорошим правилом является генерация 32-битных DLL с использованием MinGW и 64-битных DLL с использованием MSVC.</target>
        </trans-unit>
        <trans-unit id="103d786acd07e894276011f9fe0ff0e5d6f3f4da" translate="yes" xml:space="preserve">
          <source>Note that SQLITE_IGNORE is also used as a &lt;a href=&quot;#SQLITE_FAIL&quot;&gt;conflict resolution mode&lt;/a&gt; returned from the &lt;a href=&quot;#sqlite3_vtab_on_conflict&quot;&gt;sqlite3_vtab_on_conflict()&lt;/a&gt; interface.</source>
          <target state="translated">Обратите внимание, что SQLITE_IGNORE также используется в качестве &lt;a href=&quot;#SQLITE_FAIL&quot;&gt;режима разрешения конфликтов,&lt;/a&gt; возвращаемого интерфейсом &lt;a href=&quot;#sqlite3_vtab_on_conflict&quot;&gt;sqlite3_vtab_on_conflict ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="82cf9ab6c420a3c604d44b14992c4f512d1f4c35" translate="yes" xml:space="preserve">
          <source>Note that SQLITE_IGNORE is also used as a &lt;a href=&quot;c_fail&quot;&gt;conflict resolution mode&lt;/a&gt; returned from the &lt;a href=&quot;vtab_on_conflict&quot;&gt;sqlite3_vtab_on_conflict()&lt;/a&gt; interface.</source>
          <target state="translated">Обратите внимание, что SQLITE_IGNORE также используется в качестве &lt;a href=&quot;c_fail&quot;&gt;режима разрешения конфликтов,&lt;/a&gt; возвращаемого интерфейсом &lt;a href=&quot;vtab_on_conflict&quot;&gt;sqlite3_vtab_on_conflict ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="63e763dca84d9237a89baecc3d0c141975e41415" translate="yes" xml:space="preserve">
          <source>Note that SQLite allows the number of reserve-bytes to be increased but not decreased. So if a database file already has a reserve-bytes value greater than 8, there is no way to activate checksumming on that database, other than to dump and restore the database file. Note also that other extensions might also make use of the reserve-bytes. Checksumming will be incompatible with those other extensions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd4aaf9aa187deca337c2af0406d2d0e3c9d07f4" translate="yes" xml:space="preserve">
          <source>Note that SQLite allows the parenthesized list of scalar values on the right-hand side of an IN or NOT IN operator to be an empty list but most other SQL database database engines and the SQL92 standard require the list to contain at least one element.</source>
          <target state="translated">Обратите внимание,что SQLite допускает пустой список со скалярными значениями в скобках справа от оператора IN или NOT IN,но большинство других движков баз данных SQL и стандарт SQL92 требуют,чтобы список содержал по крайней мере один элемент.</target>
        </trans-unit>
        <trans-unit id="069a48733ca46d6fc20e074068d69739ed664b2b" translate="yes" xml:space="preserve">
          <source>Note that SQLite automatically adds the appropriate extension suffix (&quot;.dll&quot; on windows, &quot;.dylib&quot; on Mac, &quot;.so&quot; on most other unixes) to the extension filename. It is generally a good idea to specify the full pathname of the extension.</source>
          <target state="translated">Обратите внимание,что SQLite автоматически добавляет соответствующий суффикс расширения (&quot;.dll&quot; в окнах,&quot;.dylib&quot; в Mac,&quot;.so&quot; в большинстве других unix)к имени файла расширения.Обычно рекомендуется указывать полное имя расширения.</target>
        </trans-unit>
        <trans-unit id="878abfb73c8f4fd7637bff37205a9854afa6975b" translate="yes" xml:space="preserve">
          <source>Note that SQLite comes with several &lt;a href=&quot;../malloc#altalloc&quot;&gt;built-in memory allocators&lt;/a&gt; that are perfectly adequate for the overwhelming majority of applications and that this object is only useful to a tiny minority of applications with specialized memory allocation requirements. This object is also used during testing of SQLite in order to specify an alternative memory allocator that simulates memory out-of-memory conditions in order to verify that SQLite recovers gracefully from such conditions.</source>
          <target state="translated">Обратите внимание, что SQLite поставляется с несколькими &lt;a href=&quot;../malloc#altalloc&quot;&gt;встроенными распределителями памяти&lt;/a&gt; , которые идеально подходят для подавляющего большинства приложений, и что этот объект полезен только для крошечного меньшинства приложений со специализированными требованиями к выделению памяти. Этот объект также используется во время тестирования SQLite, чтобы указать альтернативный распределитель памяти, который имитирует условия нехватки памяти, чтобы убедиться, что SQLite корректно восстанавливается из таких условий.</target>
        </trans-unit>
        <trans-unit id="8a9932e44739c8fef89cbf2d998599f354bb604b" translate="yes" xml:space="preserve">
          <source>Note that SQLite comes with several &lt;a href=&quot;malloc#altalloc&quot;&gt;built-in memory allocators&lt;/a&gt; that are perfectly adequate for the overwhelming majority of applications and that this object is only useful to a tiny minority of applications with specialized memory allocation requirements. This object is also used during testing of SQLite in order to specify an alternative memory allocator that simulates memory out-of-memory conditions in order to verify that SQLite recovers gracefully from such conditions.</source>
          <target state="translated">Обратите внимание, что SQLite поставляется с несколькими &lt;a href=&quot;malloc#altalloc&quot;&gt;встроенными распределителями памяти&lt;/a&gt; , которые идеально подходят для подавляющего большинства приложений, и что этот объект полезен только для крошечного меньшинства приложений со специализированными требованиями к выделению памяти. Этот объект также используется во время тестирования SQLite, чтобы указать альтернативный распределитель памяти, который имитирует условия нехватки памяти, чтобы убедиться, что SQLite корректно восстанавливается из таких условий.</target>
        </trans-unit>
        <trans-unit id="f1f541cbfa03c47b900f800f3f8afdec05b49044" translate="yes" xml:space="preserve">
          <source>Note that SQLite does not enforce the PRIMARY KEY for a WITHOUT ROWID virtual table. Enforcement is the responsibility of the underlying virtual table implementation. But SQLite does assume that the PRIMARY KEY constraint is valid - that the identified columns really are UNIQUE and NOT NULL - and it uses that assumption to optimize queries against the virtual table.</source>
          <target state="translated">Обратите внимание,что SQLite не применяет PRIMARY KEY для виртуальной таблицы БЕЗ РОУИДА.Ответственность за обеспечение соблюдения лежит на реализации виртуальной таблицы.Но SQLite предполагает,что ограничение PRIMARY KEY является действительным-что идентифицированные столбцы действительно являются UNIQUE и НЕ NULL-и использует это предположение для оптимизации запросов к виртуальной таблице.</target>
        </trans-unit>
        <trans-unit id="d3bdb4d9a8050dadd7145a64b6065f6da75ef0eb" translate="yes" xml:space="preserve">
          <source>Note that SQLite must believe whatever the operating system and hardware tell it about the status of sync requests. There is no way for SQLite to detect that either is lying and that writes might be occurring out-of-order. However, SQLite in &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt; is far more forgiving of out-of-order writes than in the default rollback journal modes. In WAL mode, the only time that a failed sync operation can cause database corruption is during a &lt;a href=&quot;wal#ckpt&quot;&gt;checkpoint&lt;/a&gt; operation. A sync failure during a COMMIT might result in loss of durability but not in a corrupt database file. Hence, one line of defense against database corruption due to failed sync operations is to use SQLite in WAL mode and to checkpoint as infrequently as possible.</source>
          <target state="translated">Обратите внимание, что SQLite должен верить тому, что операционная система и оборудование говорят ему о состоянии запросов на синхронизацию. SQLite не может обнаружить, что какой-либо из них лжет и что записи могут происходить не по порядку. Однако SQLite в &lt;a href=&quot;wal&quot;&gt;режиме WAL&lt;/a&gt; гораздо более снисходительно относится к неупорядоченной записи, чем в режимах журнала отката по умолчанию. В режиме WAL единственный раз, когда неудачная операция синхронизации может вызвать повреждение базы данных, - это операция &lt;a href=&quot;wal#ckpt&quot;&gt;контрольной точки&lt;/a&gt; . Сбой синхронизации во время COMMIT может привести к потере устойчивости, но не к повреждению файла базы данных. Следовательно, одной из линий защиты от повреждения базы данных из-за неудачных операций синхронизации является использование SQLite в режиме WAL и выполнение контрольных точек как можно реже.</target>
        </trans-unit>
        <trans-unit id="a2fee544cde41af143fe81786b7190276086b344" translate="yes" xml:space="preserve">
          <source>Note that SQLite uses b-trees, which are a sorted data structure, so indices can be used when the WHERE clause of the SELECT statement contains tests for equality or inequality. Queries like the following can use an index if it is available:</source>
          <target state="translated">Обратите внимание,что SQLite использует b-деревья,которые представляют собой отсортированную структуру данных,поэтому индексы могут использоваться,когда в пункте WHERE оператора SELECT содержатся тесты на равенство или неравенство.В таких запросах,как ниже,можно использовать индекс,если он доступен:</target>
        </trans-unit>
        <trans-unit id="5081483bfc5c0173b67743dd4507d0595797d951" translate="yes" xml:space="preserve">
          <source>Note that a declared type of &quot;FLOATING POINT&quot; would give INTEGER affinity, not REAL affinity, due to the &quot;INT&quot; at the end of &quot;POINT&quot;. And the declared type of &quot;STRING&quot; has an affinity of NUMERIC, not TEXT.</source>
          <target state="translated">Обратите внимание,что объявленный тип &quot;FLOATING POINT&quot; даст сродство INTEGER,а не REAL,из-за &quot;INT&quot; в конце &quot;POINT&quot;.А объявленный тип &quot;STRING&quot; имеет сродство ЧИСЛОВЫЙ,а не ТЕКСТ.</target>
        </trans-unit>
        <trans-unit id="6008db09d7c79dcc3b84a140fc5e215929e6ce79" translate="yes" xml:space="preserve">
          <source>Note that a transformation that flips the polygon might cause the order of vertexes to be reversed. In other words, the transformation might cause the vertexes to circulate in clockwise order instead of counter-clockwise. This can be corrected by sending the result through the &lt;a href=&quot;geopoly#ccw&quot;&gt;geopoly_ccw()&lt;/a&gt; function after transformation.</source>
          <target state="translated">Обратите внимание, что преобразование, которое переворачивает многоугольник, может привести к обратному порядку вершин. Другими словами, преобразование может привести к тому, что вершины будут перемещаться по часовой стрелке, а не против часовой стрелки. Это можно исправить, отправив результат через &lt;a href=&quot;geopoly#ccw&quot;&gt;функцию geopoly_ccw ()&lt;/a&gt; после преобразования.</target>
        </trans-unit>
        <trans-unit id="3eb1501d271603c6953bfb8ef829d45c83d17e8d" translate="yes" xml:space="preserve">
          <source>Note that an inner transaction might commit (using the RELEASE command) but then later have its work undone by a ROLLBACK in an outer transaction. A power failure or program crash or OS crash will cause the outer-most transaction to rollback, undoing all changes that have occurred within that outer transaction, even changes that have supposedly been &quot;committed&quot; by the RELEASE command. Content is not actually committed on the disk until the outermost transaction commits.</source>
          <target state="translated">Обратите внимание,что внутренняя транзакция может совершить фиксацию (с помощью команды RELEASE),но затем отменить ее работу с помощью команды ROLLBACK во внешней транзакции.Сбой питания,сбой программы или отказ операционной системы приведет к откату самой внешней транзакции,отменив все изменения,которые произошли внутри этой внешней транзакции,даже изменения,которые предположительно были &quot;зафиксированы&quot; командой RELEASE.Содержимое на самом деле не фиксируется на диске до тех пор,пока не зафиксирована самая внешняя транзакция.</target>
        </trans-unit>
        <trans-unit id="7c93fd99fb4687ad2997daf3b6769cc616b7c58e" translate="yes" xml:space="preserve">
          <source>Note that conflict resolutions from multiple remote changesets are combined on a per-field basis, not per-row. This means that in the case of multiple remote UPDATE operations, some fields of a single local change may be rebased for REPLACE while others are rebased for OMIT.</source>
          <target state="translated">Обратите внимание,что разрешения конфликтов от нескольких удаленных изменений объединяются на основе для каждого поля,а не для каждого ряда.Это означает,что в случае нескольких удаленных операций UPDATE,некоторые поля одного локального изменения могут быть возвращены в REPLACE,в то время как другие-в OMIT.</target>
        </trans-unit>
        <trans-unit id="e3af7101a58299023cb05d90e0fc88f9fa63608b" translate="yes" xml:space="preserve">
          <source>Note that conversions between UTF-16be and UTF-16le are always done in place and do not invalidate a prior pointer, though of course the content of the buffer that the prior pointer points to will have been modified. Other kinds of conversion are done in place when it is possible, but sometime it is not possible and in those cases prior pointers are invalidated.</source>
          <target state="translated">Обратите внимание,что преобразования между UTF-16be и UTF-16le всегда выполняются на месте и не делают недействительным предыдущий указатель,хотя,конечно,содержимое буфера,на который указывает предыдущий указатель,будет изменено.Другие виды преобразований выполняются на месте,когда это возможно,но иногда это невозможно,и в этих случаях предыдущие указатели становятся недействительными.</target>
        </trans-unit>
        <trans-unit id="f0c5f85c046ed0d0d783a57a522950f881e39de3" translate="yes" xml:space="preserve">
          <source>Note that deleting records from a zip archive does not reclaim the space used within the archive - it merely removes an entry from the archives &quot;Central Directory Structure&quot;, making the entry inaccessible. One way to work around this inefficiency is to create a new zip archive based on the contents of the edited archive. For example, after editing the archive accessed via virtual table temp.zzz:</source>
          <target state="translated">Обратите внимание,что удаление записей из zip-архива не восстанавливает использованное пространство внутри архива-оно просто удаляет запись из архива &quot;Central Directory Structure&quot;,делая ее недоступной.Одним из способов обойти эту неэффективность является создание нового zip-архива на основе содержимого отредактированного архива.Например,после редактирования архива доступ к нему осуществляется через виртуальную таблицу temp.zzz:</target>
        </trans-unit>
        <trans-unit id="710cdb120286dd832bd6798397cffbb5dfeed9ef" translate="yes" xml:space="preserve">
          <source>Note that different operating systems use different filename suffixes for their shared libraries. Windows use &quot;.dll&quot;, Mac uses &quot;.dylib&quot;, and most unixes other than mac use &quot;.so&quot;. If you want to make your code portable, you can omit the suffix from the shared library filename and the appropriate suffix will be added automatically by the &lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension()&lt;/a&gt; interface.</source>
          <target state="translated">Обратите внимание, что разные операционные системы используют разные суффиксы файлов для своих общих библиотек. Windows использует &amp;laquo;.dll&amp;raquo;, Mac использует &amp;laquo;.dylib&amp;raquo;, а большинство unix-файлов, кроме Mac, используют &amp;laquo;.so&amp;raquo;. Если вы хотите сделать свой код переносимым, вы можете опустить суффикс в имени файла общей библиотеки, и соответствующий суффикс будет автоматически добавлен интерфейсом &lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c12e1242a0c93cb2f83528b0161fb89fb73eac90" translate="yes" xml:space="preserve">
          <source>Note that each 32768-byte unit of the shm file has its own aHash and aPgno arrays. The aHash array for a single unit is only helpful in finding aPgno entries in that same unit. The overall FindFrame(P,M) function needs to do hash lookups beginning with the latest unit and working backwards to the oldest unit until it finds an answer.</source>
          <target state="translated">Обратите внимание,что каждая 32768-байтовая единица файла shm имеет свой собственный массив aHash и aPgno.Массив aHash для одного устройства полезен только для поиска записей aPgno в этом же устройстве.Функция FindFrame(P,M)в целом должна выполнять поиск хэша,начиная с последнего модуля и работая в обратном направлении до самого старого модуля,пока не найдет ответ.</target>
        </trans-unit>
        <trans-unit id="30f49c0b1079064845cadc4000f3f0cbc4ba7f9a" translate="yes" xml:space="preserve">
          <source>Note that enabling FTS3 also makes FTS4 available. There is not a separate SQLITE_ENABLE_FTS4 compile-time option. A build of SQLite either supports both FTS3 and FTS4 or it supports neither.</source>
          <target state="translated">Обратите внимание,что включение FTS3 также делает FTS4 доступным.Отдельной опции времени компиляции SQLITE_ENABLE_FTS4 не существует.Сборка SQLite либо поддерживает FTS3 и FTS4,либо не поддерживает ни то,ни другое.</target>
        </trans-unit>
        <trans-unit id="665e7a6fdd40011f21f13b4109b67442ccc2792c" translate="yes" xml:space="preserve">
          <source>Note that except for a few corner-case differences detailed above, WITHOUT ROWID tables and rowid tables work the same. They both generate the same answers given the same SQL statements. So it is a simple matter to run experiments on an application, late in the development cycle, to test whether or not the use of WITHOUT ROWID tables will be helpful. A good strategy is to simply not worry about WITHOUT ROWID until near the end of product development, then go back and run tests to see if adding WITHOUT ROWID to tables with non-integer PRIMARY KEYs helps or hurts performance, and retaining the WITHOUT ROWID only in those cases where it helps.</source>
          <target state="translated">Обратите внимание,что за исключением нескольких угловых разниц,описанных выше,таблицы БЕЗ РОУИДов и таблицы rowid работают одинаково.Они оба генерируют одни и те же ответы,давая одни и те же SQL-операторы.Таким образом,просто запустить эксперименты над приложением на поздних стадиях цикла разработки,чтобы проверить,будет ли полезно использование таблиц БЕЗ РОУИДов.Хорошая стратегия заключается в том,чтобы просто не беспокоиться о БЕЗ РОУИДА до окончания разработки продукта,а затем вернуться назад и запустить тесты,чтобы посмотреть,помогает ли добавление БЕЗ РОУИДА в таблицы с неинтегрированными PRIMARY KEYs или снижает производительность,и сохранение БЕЗ РОУИДА только в тех случаях,когда это помогает.</target>
        </trans-unit>
        <trans-unit id="bde5b3e09fe9bd78baf5c5b8cf655c1d83bf9828" translate="yes" xml:space="preserve">
          <source>Note that geopoly uses a traditional right-handed cartesian coordinate system with the origin at the lower left, whereas SVG uses a left-handed coordinate system with the origin at the upper left. The geopoly_svg() routine makes no attempt to transform the coordinate system, so the displayed images are shown in mirror image and rotated. If that is undesirable, the geopoly_xform() routine can be used to transform the output from cartesian to SVG coordinates prior to passing the polygons into geopoly_svg().</source>
          <target state="translated">Обратите внимание,что в геополитике используется традиционная правая картезианская система координат с началом отсчета в левом нижнем углу,в то время как в SVG используется левосторонняя система координат с началом отсчета в левом верхнем углу.В программе geopoly_svg()не делается никаких попыток преобразования системы координат,поэтому отображаемые изображения отображаются в зеркальном отображении и поворачиваются.Если это нежелательно,рутина geopoly_xform()может быть использована для преобразования вывода из картезианских в SVG координат до передачи полигонов в функцию geopoly_svg().</target>
        </trans-unit>
        <trans-unit id="98a440c913714baad6d711ca1c482bbb8e3fece7" translate="yes" xml:space="preserve">
          <source>Note that if a non-deterministic function is tagged with &lt;a href=&quot;c3ref/c_deterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt; and if that function ends up being used in the WHERE clause of a &lt;a href=&quot;partialindex&quot;&gt;partial index&lt;/a&gt; or in an &lt;a href=&quot;expridx&quot;&gt;expression index&lt;/a&gt;, then when the function begins to return different answers, the associated index may become corrupt. If an SQL function is nearly deterministic (which is to say, if it only rarely changes, like &lt;a href=&quot;lang_corefunc#sqlite_version&quot;&gt;sqlite_version()&lt;/a&gt;) and it is used in an index that becomes corrupt, the corruption can be fixed by running &lt;a href=&quot;lang_reindex&quot;&gt;REINDEX&lt;/a&gt;.</source>
          <target state="translated">Обратите внимание, что если недетерминированная функция помечена тегом &lt;a href=&quot;c3ref/c_deterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt; и если эта функция в конечном итоге используется в предложении WHERE &lt;a href=&quot;partialindex&quot;&gt;частичного индекса&lt;/a&gt; или в &lt;a href=&quot;expridx&quot;&gt;индексе выражения&lt;/a&gt; , то, когда функция начинает возвращать разные ответы, связанный индекс может стать поврежденным. . Если функция SQL почти детерминирована (то есть, если она меняется редко, например &lt;a href=&quot;lang_corefunc#sqlite_version&quot;&gt;sqlite_version ()&lt;/a&gt; ) и используется в индексе, который становится поврежденным, повреждение можно исправить, запустив &lt;a href=&quot;lang_reindex&quot;&gt;REINDEX&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c13f9095e78ebed2a9c8d270bb63e3a9b47c70fe" translate="yes" xml:space="preserve">
          <source>Note that if a non-deterministic function is tagged with &lt;a href=&quot;c3ref/c_deterministic#sqlitedeterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt; and if that function ends up being used in the WHERE clause of a &lt;a href=&quot;partialindex&quot;&gt;partial index&lt;/a&gt; or in an &lt;a href=&quot;expridx&quot;&gt;expression index&lt;/a&gt;, then when the function begins to return different answers, the associated index may become corrupt. If an SQL function is nearly deterministic (which is to say, if it only rarely changes, like &lt;a href=&quot;lang_corefunc#sqlite_version&quot;&gt;sqlite_version()&lt;/a&gt;) and it is used in an index that becomes corrupt, the corruption can be fixed by running &lt;a href=&quot;lang_reindex&quot;&gt;REINDEX&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e7ef1f945a3c3a6083df7d03b59a24fcefb7fd0" translate="yes" xml:space="preserve">
          <source>Note that if one of the dynamic mutex parameters (SQLITE_MUTEX_FAST or SQLITE_MUTEX_RECURSIVE) is used then sqlite3_mutex_alloc() returns a different mutex on every call. For the static mutex types, the same mutex is returned on every call that has the same type number.</source>
          <target state="translated">Обратите внимание,что если используется один из динамических параметров мьютекса (SQLITE_MUTEX_FAST или SQLITE_MUTEX_RECURSIVE),то sqlite3_mutex_alloc()возвращает при каждом вызове другой мьютекс.Для статических типов мьютексов при каждом вызове,имеющем один и тот же номер типа,возвращается один и тот же мьютекс.</target>
        </trans-unit>
        <trans-unit id="1c50891c113debf231642ee8d937768c49d352cf" translate="yes" xml:space="preserve">
          <source>Note that if you do not include the &quot;langid=N&quot; term in the WHERE clause, the search will be against language 0 (English in the example above.) All spellfix1 searches are against a single language id. There is no way to search all languages at once.</source>
          <target state="translated">Обратите внимание,что если вы не включите термин &quot;langid=N&quot; в выражение WHERE,то поиск будет осуществляться по языку 0 (английский в примере выше).Все поиски spellfix1 идут по одному языковому идентификатору.Невозможно выполнить поиск сразу по всем языкам.</target>
        </trans-unit>
        <trans-unit id="67f33837baeec763fa57cef78587afa10292c83d" translate="yes" xml:space="preserve">
          <source>Note that in most cases, SQLite will only use a single index for each table in the FROM clause of a query. The second OR-clause optimization described here is the exception to that rule. With an OR-clause, a different index might be used for each subterm in the OR-clause.</source>
          <target state="translated">Обратите внимание,что в большинстве случаев SQLite будет использовать только один индекс для каждой таблицы в выражении FROM запроса.Описанная здесь вторая оптимизация &quot;ИЛИ&quot; является исключением из этого правила.При использовании OR-постановки для каждого подтермина в OR-постановке может использоваться отдельный индекс.</target>
        </trans-unit>
        <trans-unit id="63fa9dab5a3c38f244560b4ee3d5231308f8ad59" translate="yes" xml:space="preserve">
          <source>Note that in order for the special &quot;:memory:&quot; name to apply and to create a pure in-memory database, there must be no additional text in the filename. Thus, a disk-based database can be created in a file by prepending a pathname, like this: &quot;./:memory:&quot;.</source>
          <target state="translated">Обратите внимание,что для того,чтобы применить специальное имя &quot;:memory:&quot; и создать чистую базу данных in-memory,в имени файла не должно быть дополнительного текста.Таким образом,дисковая база данных может быть создана в файле с помощью предваряющего файла с таким именем:&quot;./:память:&quot;.</target>
        </trans-unit>
        <trans-unit id="1b52e107709738a3260fec8ebd98ff46511f5c58" translate="yes" xml:space="preserve">
          <source>Note that in the diagram above, we showed the private edits as a single commit. This was for clarity of presentation only. There is nothing to stop you from doing dozens or hundreds of separate tiny changes and committing each separately. In fact, making many small changes is the preferred way to work. The only reason for doing all the changes in a single commit is that it makes the diagram easier to draw.</source>
          <target state="translated">Обратите внимание,что на диаграмме выше мы показывали приватные правки как один коммит.Это было сделано только для наглядности презентации.Ничто не помешает вам сделать десятки или сотни отдельных крошечных изменений и зафиксировать каждое в отдельности.На самом деле,внесение множества мелких изменений является предпочтительным способом работы.Единственная причина делать все изменения в одном коммите-это то,что он облегчает рисование диаграммы.</target>
        </trans-unit>
        <trans-unit id="705b7526443ed2af20dbc38ecc0ad5be9f1ce9d9" translate="yes" xml:space="preserve">
          <source>Note that in this design, the tokenizer calls the parser. People who are familiar with YACC and BISON may be accustomed to doing things the other way around &amp;mdash; having the parser call the tokenizer. Having the tokenizer call the parser is better, though, because it can be made threadsafe and it runs faster.</source>
          <target state="translated">Обратите внимание, что в этом дизайне токенизатор вызывает парсер. Люди, знакомые с YACC и BISON, могут быть привыкли делать все наоборот - использовать парсер для вызова токенизатора. Тем не менее, имея вызов токенизатора, анализатор лучше, потому что его можно сделать потокобезопасным и он работает быстрее.</target>
        </trans-unit>
        <trans-unit id="819e65339172e5dc379cf7c2c3439c1fadf7ced3" translate="yes" xml:space="preserve">
          <source>Note that infix functions (&lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt;, &lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt;, &lt;a href=&quot;lang_expr#regexp&quot;&gt;REGEXP&lt;/a&gt;, and &lt;a href=&quot;lang_expr#match&quot;&gt;MATCH&lt;/a&gt;) reverse the order of their arguments. So &quot;like(A,B)&quot; is equivalent to &quot;B like A&quot;. For the form &quot;B like A&quot; the B term is considered the first argument to the function. But for &quot;like(A,B)&quot; the A term is considered the first argument.</source>
          <target state="translated">Обратите внимание, что инфиксные функции ( &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; , &lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; , &lt;a href=&quot;lang_expr#regexp&quot;&gt;REGEXP&lt;/a&gt; и &lt;a href=&quot;lang_expr#match&quot;&gt;MATCH&lt;/a&gt; ) меняют порядок своих аргументов. Итак, &amp;laquo;like (A, B)&amp;raquo; эквивалентно &amp;laquo;B like A&amp;raquo;. Для формы &amp;laquo;B как A&amp;raquo; термин B считается первым аргументом функции. Но для &amp;laquo;как (A, B)&amp;raquo; термин A считается первым аргументом.</target>
        </trans-unit>
        <trans-unit id="35589dde916482f10a4613056291243d802b1cc4" translate="yes" xml:space="preserve">
          <source>Note that it is important to set the &quot;mode&quot; to &quot;csv&quot; before running the &quot;.import&quot; command. This is necessary to prevent the command-line shell from trying to interpret the input file text as some other format.</source>
          <target state="translated">Обратите внимание,что перед выполнением команды &quot;.импорт&quot; необходимо установить &quot;режим&quot; на &quot;csv&quot;.Это необходимо для того,чтобы оболочка командной строки не пыталась интерпретировать текст входного файла как какой-то другой формат.</target>
        </trans-unit>
        <trans-unit id="aab0f603b95c5838db66d31fe53b5c5afd66afd1" translate="yes" xml:space="preserve">
          <source>Note that it is not necessary for all coordinates in an R*Tree index to be constrained in order for the index search to be efficient. One might, for example, want to query all objects that overlap with the 35th parallel:</source>
          <target state="translated">Обратите внимание,что не обязательно,чтобы все координаты в индексе R*Tree были ограничены,чтобы поиск по индексу был эффективным.Например,можно запросить все объекты,которые пересекаются с 35 параллелью:</target>
        </trans-unit>
        <trans-unit id="750004cbbcdb4b09f134058116396d2802e69e0a" translate="yes" xml:space="preserve">
          <source>Note that it is not necessary to quote the $bigstring value. That happens automatically. If $bigstring is a large string or binary object, this technique is not only easier to write, it is also much more efficient since it avoids making a copy of the content of $bigstring.</source>
          <target state="translated">Обратите внимание,что нет необходимости цитировать значение $bigstring.Это происходит автоматически.Если $bigstring-большой строковый или двоичный объект,то эта техника не только проще в написании,но и намного эффективнее,так как позволяет избежать копирования содержимого $bigstring.</target>
        </trans-unit>
        <trans-unit id="aedf129a94b2c6ea4cf41bd3da4352659cc6bb37" translate="yes" xml:space="preserve">
          <source>Note that it is perfectly safe for two or more threads to access the same SQLite database file using the SQLite library. The unix drivers for SQLite know about the POSIX advisory locking quirks and work around them. This problem only arises when a thread tries to bypass the SQLite library and read the database file directly.</source>
          <target state="translated">Обратите внимание,что доступ к одному и тому же файлу базы данных SQLite с помощью библиотеки SQLite абсолютно безопасен для двух и более потоков.Драйверы unix для SQLite знают о тонкостях блокировки POSIX-советов и работают вокруг них.Данная проблема возникает только тогда,когда поток пытается обойти библиотеку SQLite и напрямую прочитать файл базы данных.</target>
        </trans-unit>
        <trans-unit id="af76f7d3a1b3eb149d8a26a0e9299bf38c7c0401" translate="yes" xml:space="preserve">
          <source>Note that it is very important that the database filename have some kind of extension. If there is no extension, then SQLite creates auxiliary filenames by appending to the base name of the file. Thus, a database named &quot;&lt;code&gt;db01&lt;/code&gt;&quot; would have a &lt;a href=&quot;lockingv3#rollback&quot;&gt;rollback journal&lt;/a&gt; file named &quot;&lt;code&gt;db01-journal&lt;/code&gt;&quot;. And as this filename has no extension to shorten to 3 characters, it will be used as-is, and will violate 8+3 naming rules.</source>
          <target state="translated">Обратите внимание, что очень важно, чтобы имя файла базы данных имело какое-то расширение. Если расширения нет, SQLite создает вспомогательные имена файлов, добавляя их к базовому имени файла. Таким образом, база данных с именем &amp;laquo; &lt;code&gt;db01&lt;/code&gt; &amp;raquo; будет иметь файл &lt;a href=&quot;lockingv3#rollback&quot;&gt;журнала отката с&lt;/a&gt; именем &amp;laquo; &lt;code&gt;db01-journal&lt;/code&gt; &amp;raquo;. И поскольку это имя файла не имеет расширения, которое можно было бы сократить до 3 символов, оно будет использоваться как есть и будет нарушать правила именования 8 + 3.</target>
        </trans-unit>
        <trans-unit id="19eeeefb37e5b82a70fbf6a86a847157f005c210" translate="yes" xml:space="preserve">
          <source>Note that prior to &lt;a href=&quot;https://sqlite.org/releaselog/3_9_0.html&quot;&gt;version 3.9.0&lt;/a&gt; (2015-10-14), SQLite did not check the xCreate method for NULL before invoking it. So if an eponymous-only virtual table is registered with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_11_1.html&quot;&gt;version 3.8.11.1&lt;/a&gt; (2015-07-29) or earlier and a &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; command is attempted against that virtual table module, a jump to a NULL pointer will occur, resulting in a crash.</source>
          <target state="translated">Обратите внимание, что до &lt;a href=&quot;https://sqlite.org/releaselog/3_9_0.html&quot;&gt;версии 3.9.0&lt;/a&gt; (2015-10-14) SQLite не проверял метод xCreate на NULL перед его вызовом. Таким образом, если виртуальная таблица только с одноименным &lt;a href=&quot;https://sqlite.org/releaselog/3_8_11_1.html&quot;&gt;именем&lt;/a&gt; зарегистрирована в SQLite версии 3.8.11.1 ( 2015-07-29 ) или более ранней, и команда &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; предпринимается для этого модуля виртуальной таблицы, произойдет переход к указателю NULL, что приведет к авария.</target>
        </trans-unit>
        <trans-unit id="7cb63274cd75ba4167c68c8885d57c07e7241aab" translate="yes" xml:space="preserve">
          <source>Note that running SQLite with gcov is not a test of SQLite &amp;mdash; it is a test of the test suite. The gcov run does not test SQLite because the -fprofile-args and -ftest-coverage options cause the compiler to generate different code. The gcov run merely verifies that the test suite provides 100% branch test coverage. The gcov run is a test of the test - a meta-test.</source>
          <target state="translated">Обратите внимание, что запуск SQLite с gcov - это не тест SQLite - это тест набора тестов. Запуск gcov не тестирует SQLite, потому что параметры -fprofile-args и -ftest-охват заставляют компилятор генерировать другой код. Запуск gcov просто проверяет, что набор тестов обеспечивает 100% тестовое покрытие ветвей. Запуск gcov - это тест теста - мета-тест.</target>
        </trans-unit>
        <trans-unit id="5a5f0aee350ad05534eee4c24d91d936725afa91" translate="yes" xml:space="preserve">
          <source>Note that the &lt;a href=&quot;#SQLITE_DENY&quot;&gt;SQLITE_IGNORE&lt;/a&gt; constant is also used as a potential return value from the &lt;a href=&quot;#sqlite3_set_authorizer&quot;&gt;sqlite3_set_authorizer()&lt;/a&gt; callback and that &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ABORT&lt;/a&gt; is also a &lt;a href=&quot;rescode&quot;&gt;result code&lt;/a&gt;.</source>
          <target state="translated">Обратите внимание, что константа &lt;a href=&quot;#SQLITE_DENY&quot;&gt;SQLITE_IGNORE&lt;/a&gt; также используется в качестве потенциального возвращаемого значения из обратного вызова &lt;a href=&quot;#sqlite3_set_authorizer&quot;&gt;sqlite3_set_authorizer ()&lt;/a&gt; и что &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ABORT&lt;/a&gt; также является &lt;a href=&quot;rescode&quot;&gt;кодом результата&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f4daa0a4c8ffbaa8c905b7b2b472738ae1e277cf" translate="yes" xml:space="preserve">
          <source>Note that the &lt;a href=&quot;c3ref/changes&quot;&gt;sqlite3_changes()&lt;/a&gt; and &lt;a href=&quot;c3ref/total_changes&quot;&gt;sqlite3_total_changes()&lt;/a&gt; interfaces do not count INSTEAD OF trigger firings, but the &lt;a href=&quot;pragma#pragma_count_changes&quot;&gt;count_changes pragma&lt;/a&gt; does count INSTEAD OF trigger firing.</source>
          <target state="translated">Обратите внимание, что интерфейсы &lt;a href=&quot;c3ref/changes&quot;&gt;sqlite3_changes ()&lt;/a&gt; и &lt;a href=&quot;c3ref/total_changes&quot;&gt;sqlite3_total_changes ()&lt;/a&gt; не учитывают срабатывания триггера INSTEAD OF, но &lt;a href=&quot;pragma#pragma_count_changes&quot;&gt;прагма count_changes&lt;/a&gt; учитывает срабатывание триггера INSTEAD OF.</target>
        </trans-unit>
        <trans-unit id="f4f048e66a09e44bfda0411919740620eea7756a" translate="yes" xml:space="preserve">
          <source>Note that the &lt;a href=&quot;c_deny&quot;&gt;SQLITE_IGNORE&lt;/a&gt; constant is also used as a potential return value from the &lt;a href=&quot;set_authorizer&quot;&gt;sqlite3_set_authorizer()&lt;/a&gt; callback and that &lt;a href=&quot;../rescode#abort&quot;&gt;SQLITE_ABORT&lt;/a&gt; is also a &lt;a href=&quot;../rescode&quot;&gt;result code&lt;/a&gt;.</source>
          <target state="translated">Обратите внимание, что константа &lt;a href=&quot;c_deny&quot;&gt;SQLITE_IGNORE&lt;/a&gt; также используется в качестве потенциального возвращаемого значения из обратного вызова &lt;a href=&quot;set_authorizer&quot;&gt;sqlite3_set_authorizer ()&lt;/a&gt; и что &lt;a href=&quot;../rescode#abort&quot;&gt;SQLITE_ABORT&lt;/a&gt; также является &lt;a href=&quot;../rescode&quot;&gt;кодом результата&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="732e678676cbad83be2195f0c9cbdf90bfcdfbeb" translate="yes" xml:space="preserve">
          <source>Note that the DO UPDATE clause acts only on the single row that experienced the constraint error during INSERT. It is not necessary to include a WHERE clause that restrictions the action to that one row. The only use for the WHERE clause at the end of the DO UPDATE is to optionally change the DO UPDATE into a no-op depending on the original and/or new values. For example:</source>
          <target state="translated">Обратите внимание,что выражение DO UPDATE действует только на единственной строке,в которой во время INSERT произошла ошибка ограничения.Нет необходимости включать условие WHERE,которое ограничивает действие одной строкой.Единственное использование выражения WHERE в конце DO UPDATE-это опциональное изменение DO UPDATE на no-op в зависимости от исходных и/или новых значений.Например:</target>
        </trans-unit>
        <trans-unit id="9e431af898d8e365308f86b50efb344365dfb157" translate="yes" xml:space="preserve">
          <source>Note that the SQLITE_TEXT constant was also used in SQLite version 2 for a completely different meaning. Software that links against both SQLite version 2 and SQLite version 3 should use SQLITE3_TEXT, not SQLITE_TEXT.</source>
          <target state="translated">Обратите внимание,что константа SQLITE_TEXT также использовалась в SQLite версии 2 в совершенно ином значении.Программное обеспечение,связанное как с SQLite версии 2,так и с SQLite версии 3,должно использовать SQLITE3_TEXT,а не SQLITE_TEXT.</target>
        </trans-unit>
        <trans-unit id="db7397560741b34c84d7c7b13b86a2bbf792ba5b" translate="yes" xml:space="preserve">
          <source>Note that the SQLite parser will not always generate code to use an index, even if it is possible to do so. The following queries will not currently use the index:</source>
          <target state="translated">Обратите внимание,что парсер SQLite не всегда будет генерировать код для использования индекса,даже если это возможно.Следующие запросы в настоящее время не будут использовать индекс:</target>
        </trans-unit>
        <trans-unit id="021cca6e0a1bc313b828c0c99864715910f5cf3d" translate="yes" xml:space="preserve">
          <source>Note that the UNION ALL operator for compound queries does not use transient indices by itself (though of course the right and left subqueries of the UNION ALL might use transient indices depending on how they are composed.)</source>
          <target state="translated">Обратите внимание,что оператор UNION ALL для составных запросов сам по себе не использует переходные индексы (хотя,конечно,правый и левый подзапросы UNION ALL могут использовать переходные индексы в зависимости от того,как они составлены).</target>
        </trans-unit>
        <trans-unit id="0676f5b60fd19b027ecab9b9999e5b7f746d671c" translate="yes" xml:space="preserve">
          <source>Note that the authorizer callback is invoked only during &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; or its variants. Authorization is not performed during statement evaluation in &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt;, unless as stated in the previous paragraph, sqlite3_step() invokes sqlite3_prepare_v2() to reprepare a statement after a schema change.</source>
          <target state="translated">Обратите внимание, что обратный вызов авторизатора вызывается только во время &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare ()&lt;/a&gt; или его вариантов. Авторизация не выполняется во время оценки оператора в &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step ()&lt;/a&gt; , если, как указано в предыдущем абзаце, sqlite3_step () не вызывает sqlite3_prepare_v2 () для представления оператора после изменения схемы.</target>
        </trans-unit>
        <trans-unit id="f1e28776761e0bfe4431c21ae77ea6373668b8fc" translate="yes" xml:space="preserve">
          <source>Note that the authorizer callback is invoked only during &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; or its variants. Authorization is not performed during statement evaluation in &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt;, unless as stated in the previous paragraph, sqlite3_step() invokes sqlite3_prepare_v2() to reprepare a statement after a schema change.</source>
          <target state="translated">Обратите внимание, что обратный вызов авторизатора вызывается только во время &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare ()&lt;/a&gt; или его вариантов. Авторизация не выполняется во время оценки оператора в &lt;a href=&quot;step&quot;&gt;sqlite3_step ()&lt;/a&gt; , если, как указано в предыдущем абзаце, sqlite3_step () не вызывает sqlite3_prepare_v2 () для представления оператора после изменения схемы.</target>
        </trans-unit>
        <trans-unit id="ac6d36a8492877c1ea3743d0c173020c27937cf2" translate="yes" xml:space="preserve">
          <source>Note that the character encoding mechanism used by SQLite cannot be changed at run-time. This is a compile-time option only. The &lt;b&gt;sqlite_encoding&lt;/b&gt; character string just tells you how the library was compiled.</source>
          <target state="translated">Обратите внимание, что механизм кодировки символов, используемый SQLite, нельзя изменить во время выполнения. Это опция только во время компиляции. &lt;b&gt;Sqlite_encoding&lt;/b&gt; символьная строка просто говорит вам , как была собрана библиотека.</target>
        </trans-unit>
        <trans-unit id="7febee2154ade1b2d3219ad0df6d8ce2b6d91690" translate="yes" xml:space="preserve">
          <source>Note that the checksums in the rollback journal are not necessary if the synchronous setting is FULL. We only depend on the checksums when synchronous is lowered to NORMAL. Nevertheless, the checksums never hurt and so they are included in the rollback journal regardless of the synchronous setting.</source>
          <target state="translated">Обратите внимание,что контрольные суммы в журнале отката не нужны,если настройка синхронизации FULL.Мы зависим только от контрольных сумм при снижении синхронной настройки до NORMAL.Тем не менее,контрольные суммы никогда не повреждаются и поэтому включаются в журнал отката независимо от синхронной установки.</target>
        </trans-unit>
        <trans-unit id="808239b91162b2ff74019b785a2c4443032a884a" translate="yes" xml:space="preserve">
          <source>Note that the command-line shell program has already enabled extension loading for you (by calling the &lt;a href=&quot;c3ref/enable_load_extension&quot;&gt;sqlite3_enable_load_extension()&lt;/a&gt; interface as part of its setup) so the command above works without any special switches, setup, or other complications.</source>
          <target state="translated">Обратите внимание, что программа оболочки командной строки уже включила для вас загрузку расширения (путем вызова интерфейса &lt;a href=&quot;c3ref/enable_load_extension&quot;&gt;sqlite3_enable_load_extension ()&lt;/a&gt; как части своей настройки), поэтому приведенная выше команда работает без каких-либо специальных переключателей, настройки или других сложностей.</target>
        </trans-unit>
        <trans-unit id="6e9cc72c28987333ade7d6e3571128f51c3b46dd" translate="yes" xml:space="preserve">
          <source>Note that the destructor function D is for the pointer value P, not for the type string T. The type string T should be a static string with an infinite lifetime.</source>
          <target state="translated">Обратите внимание,что функция деструктора D предназначена для значения указателя P,а не для строки типа T.Строка типа T должна быть статической строкой с бесконечным временем жизни.</target>
        </trans-unit>
        <trans-unit id="4cfa4e46e35f2a19630aea45991cffe3dd621ecd" translate="yes" xml:space="preserve">
          <source>Note that the integer key is one greater than the largest key that was in the table just prior to the insert. The new key will be unique over all keys currently in the table, but it might overlap with keys that have been previously deleted from the table. To create keys that are unique over the lifetime of the table, add the &lt;a href=&quot;autoinc&quot;&gt;AUTOINCREMENT&lt;/a&gt; keyword to the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; declaration. Then the key chosen will be one more than the largest key that has ever existed in that table. If the largest possible key has previously existed in that table, then the &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; will fail with an &lt;a href=&quot;rescode#full&quot;&gt;SQLITE_FULL&lt;/a&gt; error code.</source>
          <target state="translated">Обратите внимание, что целочисленный ключ на единицу больше, чем самый большой ключ, который был в таблице непосредственно перед вставкой. Новый ключ будет уникальным среди всех ключей, находящихся в настоящее время в таблице, но он может перекрываться с ключами, которые были ранее удалены из таблицы. Чтобы создать ключи, которые будут уникальными в течение всего времени существования таблицы, добавьте ключевое слово &lt;a href=&quot;autoinc&quot;&gt;AUTOINCREMENT&lt;/a&gt; в объявление &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; . Тогда выбранный ключ будет на один больше, чем самый большой ключ, который когда-либо существовал в этой таблице. Если в этой таблице ранее уже существовал самый большой из возможных ключей, то &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; завершится ошибкой с &lt;a href=&quot;rescode#full&quot;&gt;кодом SQLITE_FULL&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="228b63ead1b7d1b62a8c83539d4e8ab64da2dc4c" translate="yes" xml:space="preserve">
          <source>Note that the journal_mode for an &lt;a href=&quot;inmemorydb&quot;&gt;in-memory database&lt;/a&gt; is either MEMORY or OFF and can not be changed to a different value. An attempt to change the journal_mode of an &lt;a href=&quot;inmemorydb&quot;&gt;in-memory database&lt;/a&gt; to any setting other than MEMORY or OFF is ignored. Note also that the journal_mode cannot be changed while a transaction is active.</source>
          <target state="translated">Обратите внимание, что journal_mode для &lt;a href=&quot;inmemorydb&quot;&gt;базы данных в памяти&lt;/a&gt; имеет значение MEMORY или OFF и не может быть изменено на другое значение. Попытка изменить journal_mode &lt;a href=&quot;inmemorydb&quot;&gt;базы данных&lt;/a&gt; в памяти на любой параметр, кроме MEMORY или OFF, игнорируется. Также обратите внимание, что journal_mode нельзя изменить, пока транзакция активна.</target>
        </trans-unit>
        <trans-unit id="1150442b82dfad6909e59c690e94911009ab738b" translate="yes" xml:space="preserve">
          <source>Note that the list of routines above is conceptual rather than actual. Many of these routines come in multiple versions. For example, the list above shows a single routine named &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt; when in fact there are three separate routines that accomplish the same thing in slightly different ways: &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open16()&lt;/a&gt; and &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;. The list mentions &lt;a href=&quot;c3ref/column_blob&quot;&gt;sqlite3_column()&lt;/a&gt; when in fact no such routine exists. The &quot;sqlite3_column()&quot; shown in the list is a placeholder for an entire family of routines that extra column data in various datatypes.</source>
          <target state="translated">Обратите внимание, что приведенный выше список процедур является скорее концептуальным, чем фактическим. Многие из этих программ имеют несколько версий. Например, в приведенном выше списке показана одна подпрограмма с именем &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open (),&lt;/a&gt; хотя на самом деле есть три отдельных подпрограммы, которые выполняют одно и то же несколько разными способами: &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open ()&lt;/a&gt; , &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open16 ()&lt;/a&gt; и &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2 ()&lt;/a&gt; . В списке упоминается &lt;a href=&quot;c3ref/column_blob&quot;&gt;sqlite3_column (),&lt;/a&gt; хотя на самом деле такой процедуры не существует. Показанный в списке &amp;laquo;sqlite3_column ()&amp;raquo; является заполнителем для целого семейства подпрограмм, которые добавляют данные столбца в различные типы данных.</target>
        </trans-unit>
        <trans-unit id="4fdc00a153b8f8752a20bfd3564af15ee4f88900" translate="yes" xml:space="preserve">
          <source>Note that the memory leak detection logic continues to work even when the OOM overlay is being used. This verifies that SQLite does not leak memory even when it encounters memory allocation errors. Note also that the OOM overlay can work with any underlying memory allocator, including the instrumented memory allocator that checks for memory allocation misuse. In this way it is verified that OOM errors do not induce other kinds of memory usage errors.</source>
          <target state="translated">Обратите внимание,что логика обнаружения утечки памяти продолжает работать даже при использовании оверлея OOM.Это проверяет,что SQLite не утечка памяти,даже когда он сталкивается с ошибками выделения памяти.Заметьте также,что оверлей OOM может работать с любым аллокатором памяти,включая инструментированный аллокатор памяти,который проверяет неправильное выделение памяти.Таким образом,проверяется,что ошибки OOM не приводят к другим видам ошибок использования памяти.</target>
        </trans-unit>
        <trans-unit id="a2673a9d4ca364b864416763c5f28c9b8fac9ff0" translate="yes" xml:space="preserve">
          <source>Note that the number of keywords understood by SQLite can depend on compile-time options. For example, &quot;VACUUM&quot; is not a keyword if SQLite is compiled with the &lt;a href=&quot;../compile#omit_vacuum&quot;&gt;-DSQLITE_OMIT_VACUUM&lt;/a&gt; option. Also, new keywords may be added to future releases of SQLite.</source>
          <target state="translated">Обратите внимание, что количество ключевых слов, понимаемых SQLite, может зависеть от параметров времени компиляции. Например, &amp;laquo;VACUUM&amp;raquo; не является ключевым словом, если SQLite скомпилирован с параметром &lt;a href=&quot;../compile#omit_vacuum&quot;&gt;-DSQLITE_OMIT_VACUUM&lt;/a&gt; . Также новые ключевые слова могут быть добавлены в будущие выпуски SQLite.</target>
        </trans-unit>
        <trans-unit id="2d91b980ac2f1529b090c5eabcb20ce64f838c85" translate="yes" xml:space="preserve">
          <source>Note that the number of keywords understood by SQLite can depend on compile-time options. For example, &quot;VACUUM&quot; is not a keyword if SQLite is compiled with the &lt;a href=&quot;compile#omit_vacuum&quot;&gt;-DSQLITE_OMIT_VACUUM&lt;/a&gt; option. Also, new keywords may be added to future releases of SQLite.</source>
          <target state="translated">Обратите внимание, что количество ключевых слов, понимаемых SQLite, может зависеть от параметров времени компиляции. Например, &amp;laquo;VACUUM&amp;raquo; не является ключевым словом, если SQLite скомпилирован с параметром &lt;a href=&quot;compile#omit_vacuum&quot;&gt;-DSQLITE_OMIT_VACUUM&lt;/a&gt; . Также новые ключевые слова могут быть добавлены в будущие выпуски SQLite.</target>
        </trans-unit>
        <trans-unit id="4aca65a78510b061ab1efe777d7b5b2943653a08" translate="yes" xml:space="preserve">
          <source>Note that the order of the rules for determining column affinity is important. A column whose declared type is &quot;CHARINT&quot; will match both rules 1 and 2 but the first rule takes precedence and so the column affinity will be INTEGER.</source>
          <target state="translated">Обратите внимание,что порядок правил определения сродства столбцов важен.Столбец с объявленным типом &quot;CHARINT&quot; будет соответствовать и правилам 1 и 2,но первое правило имеет приоритет,поэтому сродство столбца будет INTEGER.</target>
        </trans-unit>
        <trans-unit id="1d73e69c69eafce89c99fd09f5dcbc2e6299190a" translate="yes" xml:space="preserve">
          <source>Note that the primary result code is always a part of the extended result code. Given a full 32-bit extended result code, the application can always find the corresponding primary result code merely by extracting the least significant 8 bits of the extended result code.</source>
          <target state="translated">Обратите внимание,что первичный код результата всегда является частью расширенного кода результата.При полном 32-битном расширенном результирующем коде приложение всегда может найти соответствующий код первичного результата,просто извлекая из расширенного результирующего кода наименее значащие 8 бит.</target>
        </trans-unit>
        <trans-unit id="299082c757bfbc2b1a98c9af13620cc48c49d3d4" translate="yes" xml:space="preserve">
          <source>Note that the program for this SELECT query didn't contain the Transaction and Commit instructions used in the INSERT example. Because the SELECT is a read operation that doesn't alter the database, it doesn't require a transaction.</source>
          <target state="translated">Обратите внимание,что программа для данного SELECT-запроса не содержала инструкций Transaction and Commit,используемых в примере INSERT.Поскольку SELECT-это операция чтения,которая не изменяет базу данных,она не требует транзакции.</target>
        </trans-unit>
        <trans-unit id="f586476195ef53b793699f052ad1af05d3a6c8e4" translate="yes" xml:space="preserve">
          <source>Note that the readfile(X) and writefile(X,Y) functions are extension functions and are not built into the core SQLite library. These routines are available as a &lt;a href=&quot;loadext&quot;&gt;loadable extension&lt;/a&gt; in the &lt;a href=&quot;http://www.sqlite.org/src/artifact?ci=trunk&amp;amp;filename=ext/misc/fileio.c&quot;&gt;ext/misc/fileio.c&lt;/a&gt; source file in the &lt;a href=&quot;https://sqlite.org/download.html#srctree&quot;&gt;SQLite source code repositories&lt;/a&gt;.</source>
          <target state="translated">Обратите внимание, что функции readfile (X) и writefile (X, Y) являются функциями расширения и не встроены в базовую библиотеку SQLite. Эти процедуры доступны в виде &lt;a href=&quot;loadext&quot;&gt;загружаемых расширений&lt;/a&gt; в исходном файле &lt;a href=&quot;http://www.sqlite.org/src/artifact?ci=trunk&amp;amp;filename=ext/misc/fileio.c&quot;&gt;ext / misc / fileio.c&lt;/a&gt; в &lt;a href=&quot;https://sqlite.org/download.html#srctree&quot;&gt;репозиториях исходного кода SQLite&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="64553501493418021ca0b221dddc1b5aa622fbc2" translate="yes" xml:space="preserve">
          <source>Note that the result from casting any non-BLOB value into a BLOB and the result from casting any BLOB value into a non-BLOB value may be different depending on whether the database &lt;a href=&quot;pragma#pragma_encoding&quot;&gt;encoding&lt;/a&gt; is UTF-8, UTF-16be, or UTF-16le.</source>
          <target state="translated">Обратите внимание, что результат преобразования любого значения, отличного от BLOB, в BLOB и результат преобразования любого значения BLOB в значение, отличное от BLOB, могут отличаться в зависимости от того, является ли &lt;a href=&quot;pragma#pragma_encoding&quot;&gt;кодировка&lt;/a&gt; базы данных UTF-8, UTF-16be или UTF-16le. .</target>
        </trans-unit>
        <trans-unit id="e984670ffac060fe0c3430de1a1c23ffe29028d1" translate="yes" xml:space="preserve">
          <source>Note that the sqlite3changeset_apply_v2() API is still &lt;b&gt;experimental&lt;/b&gt; and therefore subject to change.</source>
          <target state="translated">Обратите внимание, что API sqlite3changeset_apply_v2 () все еще является &lt;b&gt;экспериментальным&lt;/b&gt; и поэтому может быть изменен.</target>
        </trans-unit>
        <trans-unit id="a04165c5ad09a6b0ad2414206038c2e65d87aa51" translate="yes" xml:space="preserve">
          <source>Note that the sqlite3changeset_start_v2() API is still &lt;b&gt;experimental&lt;/b&gt; and therefore subject to change.</source>
          <target state="translated">Обратите внимание, что API sqlite3changeset_start_v2 () все еще является &lt;b&gt;экспериментальным&lt;/b&gt; и поэтому может быть изменен.</target>
        </trans-unit>
        <trans-unit id="6c55c88c2dea7079ec802efa3e99479f764ecf7e" translate="yes" xml:space="preserve">
          <source>Note that the unary *+* operator also removes &lt;a href=&quot;datatype3#affinity&quot;&gt;type affinity&lt;/a&gt; from an expression, and in some cases this can cause subtle changes in the meaning of an expression. In the example above, if column *x* has &lt;a href=&quot;datatype3#affinity&quot;&gt;TEXT affinity&lt;/a&gt; then the comparison &quot;x=5&quot; will be done as text. But the *+* operator removes the affinity. So the comparison &quot;+x=5&quot; will compare the text in column *x* with the numeric value 5 and will always be false.</source>
          <target state="translated">Обратите внимание, что унарный оператор * + * также удаляет &lt;a href=&quot;datatype3#affinity&quot;&gt;сходство типов&lt;/a&gt; из выражения, и в некоторых случаях это может вызвать незначительные изменения в значении выражения. В приведенном выше примере, если столбец * x * имеет соответствие &lt;a href=&quot;datatype3#affinity&quot;&gt;ТЕКСТА,&lt;/a&gt; тогда сравнение &amp;laquo;x = 5&amp;raquo; будет выполнено как текст. Но оператор * + * убирает сродство. Таким образом, сравнение &amp;laquo;+ x = 5&amp;raquo; будет сравнивать текст в столбце * x * с числовым значением 5 и всегда будет ложным.</target>
        </trans-unit>
        <trans-unit id="c990d58c5d0bc49b39ec476dafbb19955404bbcd" translate="yes" xml:space="preserve">
          <source>Note that there are paths through the syntax diagrams that are not allowed in practice. Some examples:</source>
          <target state="translated">Обратите внимание,что есть пути через синтаксические диаграммы,которые не разрешены на практике.Некоторые примеры:</target>
        </trans-unit>
        <trans-unit id="96acc3ff45ab0c01a0b94c0892486dbb72afce32" translate="yes" xml:space="preserve">
          <source>Note that there are two variations of the equals and not equals operators. Equals can be either</source>
          <target state="translated">Обратите внимание,что существует два варианта равенства и не равенства операторов.Равные могут быть также</target>
        </trans-unit>
        <trans-unit id="a67d64fb18ca2294fb42994c6d74eeb61ff03be8" translate="yes" xml:space="preserve">
          <source>Note that this is only a thought experiment. We are not suggesting that OpenDocument be changed. Nor is this article a criticism of the current OpenDocument design. The point of this essay is to suggest ways to improve future file format designs.</source>
          <target state="translated">Обратите внимание,что это всего лишь мыслительный эксперимент.Мы не предлагаем изменять OpenDocument.Эта статья также не является критикой текущего дизайна OpenDocument.Смысл этого эссе в том,чтобы предложить способы улучшения дизайна будущих форматов файлов.</target>
        </trans-unit>
        <trans-unit id="99c1505807d577ab62bcd4edbb24d5f3cd06e9f6" translate="yes" xml:space="preserve">
          <source>Note that this problem only occurs if the attempt to acquire the lock resulted in an I/O error. If the lock is simply not granted (because some other thread or process is already holding a conflicting lock) then no corruption will ever occur. We are not aware of any operating systems that will fail with an I/O error while attempting to get a file lock on shared memory. So this is a theoretical problem rather than a real problem. Needless to say, this problem has never been observed in the wild. The problem was discovered while doing stress testing of SQLite in a test harness that simulates I/O errors.</source>
          <target state="translated">Обратите внимание,что эта проблема возникает только в том случае,если попытка получения блокировки привела к ошибке ввода/вывода.Если блокировка просто не разрешена (потому что какой-то другой поток или процесс уже имеет конфликтующую блокировку),то повреждений никогда не произойдет.Мы не знаем ни одной операционной системы,которая бы не справилась с ошибкой ввода/вывода при попытке получить файловую блокировку в общей памяти.Таким образом,это скорее теоретическая проблема,чем реальная проблема.Нет нужды говорить,что эта проблема никогда не наблюдалась в дикой природе.Проблема была обнаружена во время стресс-тестирования SQLite в тестовом жгуте,который моделирует ошибки ввода/вывода.</target>
        </trans-unit>
        <trans-unit id="ebff595e74a177f5fa63d87902cc62cb3ce02f96" translate="yes" xml:space="preserve">
          <source>Note that this routine returns zero on a match and non-zero if the strings do not match, the same as &lt;a href=&quot;#sqlite3_stricmp&quot;&gt;sqlite3_stricmp()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_stricmp&quot;&gt;sqlite3_strnicmp()&lt;/a&gt;.</source>
          <target state="translated">Обратите внимание, что эта процедура возвращает ноль при совпадении и ненулевое значение, если строки не совпадают, так же, как &lt;a href=&quot;#sqlite3_stricmp&quot;&gt;sqlite3_stricmp ()&lt;/a&gt; и &lt;a href=&quot;#sqlite3_stricmp&quot;&gt;sqlite3_strnicmp ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0d629b76283bd20b6edf31050b7b9b764c009820" translate="yes" xml:space="preserve">
          <source>Note that this routine returns zero on a match and non-zero if the strings do not match, the same as &lt;a href=&quot;stricmp&quot;&gt;sqlite3_stricmp()&lt;/a&gt; and &lt;a href=&quot;stricmp&quot;&gt;sqlite3_strnicmp()&lt;/a&gt;.</source>
          <target state="translated">Обратите внимание, что эта процедура возвращает ноль при совпадении и ненулевое значение, если строки не совпадают, так же, как &lt;a href=&quot;stricmp&quot;&gt;sqlite3_stricmp ()&lt;/a&gt; и &lt;a href=&quot;stricmp&quot;&gt;sqlite3_strnicmp ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c810fa4c8943f66ac3d34092b7e767d31528340e" translate="yes" xml:space="preserve">
          <source>Note that triggers are automatically dropped when the associated table is dropped.</source>
          <target state="translated">Обратите внимание,что триггеры автоматически сбрасываются при сбросе соответствующей таблицы.</target>
        </trans-unit>
        <trans-unit id="d606f23ac3535efbf11c3a7516392c25071ecf15" translate="yes" xml:space="preserve">
          <source>Note that when SQLite is compiled with SQLITE_THREADSAFE=0, the code to make SQLite threadsafe is omitted from the build. When this occurs, it is impossible to change the &lt;a href=&quot;threadsafe&quot;&gt;threading mode&lt;/a&gt; at start-time or run-time.</source>
          <target state="translated">Обратите внимание, что когда SQLite скомпилирован с SQLITE_THREADSAFE = 0, код для обеспечения безопасности потоков SQLite не включается в сборку. Когда это происходит, невозможно изменить &lt;a href=&quot;threadsafe&quot;&gt;режим работы&lt;/a&gt; с потоками во время запуска или выполнения.</target>
        </trans-unit>
        <trans-unit id="32708b7e6e76296f6dad18be6a6d369658183e8b" translate="yes" xml:space="preserve">
          <source>Note that when the SQLITE_DBCONFIG_LEGACY_FILE_FORMAT setting is on, the &lt;a href=&quot;../lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; command will fail with an obscure error when attempting to process a table with generated columns and a descending index. This is not considered a bug since SQLite versions 3.3.0 and earlier do not support either generated columns or decending indexes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3822538f7b251248e21c02ba82556fd2e3a92957" translate="yes" xml:space="preserve">
          <source>Note that when the SQLITE_DBCONFIG_LEGACY_FILE_FORMAT setting is on, the &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; command will fail with an obscure error when attempting to process a table with generated columns and a descending index. This is not considered a bug since SQLite versions 3.3.0 and earlier do not support either generated columns or decending indexes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="789391b5c680547fd2d7df978b13d5bea4b6c611" translate="yes" xml:space="preserve">
          <source>Note that when the right-hand side of a LIKE or GLOB operator is a &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameter&lt;/a&gt; and the statement is prepared using &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; or &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare16_v2()&lt;/a&gt; then the statement is automatically reparsed and recompiled on the first &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; call of each run if the binding to the right-hand side parameter has changed since the previous run. This reparse and recompile is essentially the same action that occurs following a schema change. The recompile is necessary so that the query planner can examine the new value bound to the right-hand side of the LIKE or GLOB operator and determine whether or not to employ the optimization described above.</source>
          <target state="translated">Обратите внимание, что если правая часть оператора LIKE или GLOB является &lt;a href=&quot;lang_expr#varparam&quot;&gt;параметром&lt;/a&gt; и оператор подготовлен с использованием &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; или &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare16_v2 (),&lt;/a&gt; тогда оператор автоматически повторно анализируется и перекомпилируется при первом вызове &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step ()&lt;/a&gt; каждого запуска, если привязка к правому параметру изменилась по сравнению с предыдущим запуском. Этот повторный анализ и перекомпиляция - это, по сути, то же действие, которое происходит после изменения схемы. Перекомпиляция необходима для того, чтобы планировщик запросов мог проверить новое значение, привязанное к правой стороне оператора LIKE или GLOB, и определить, следует ли использовать оптимизацию, описанную выше.</target>
        </trans-unit>
        <trans-unit id="7aca89c620a18b6fdc63e568bea908a626dcadff" translate="yes" xml:space="preserve">
          <source>Note that when type conversions occur, pointers returned by prior calls to sqlite3_column_blob(), sqlite3_column_text(), and/or sqlite3_column_text16() may be invalidated. Type conversions and pointer invalidations might occur in the following cases:</source>
          <target state="translated">Обратите внимание,что при приведении типов указатели,возвращенные предыдущими вызовами sqlite3_column_blob(),sqlite3_column_text()и/или sqlite3_column_text16(),могут быть признаны недействительными.Приведение типов и аннулирование указателей может произойти в следующих случаях:</target>
        </trans-unit>
        <trans-unit id="1368e4859dec1f8b656ae1f17b0c284cfecc238a" translate="yes" xml:space="preserve">
          <source>Note that with &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous&lt;/a&gt; set to NORMAL, the checkpoint is the only operation to issue an I/O barrier or sync operation (fsync() on unix or FlushFileBuffers() on windows). If an application therefore runs checkpoint in a separate thread or process, the main thread or process that is doing database queries and updates will never block on a sync operation. This helps to prevent &quot;latch-up&quot; in applications running on a busy disk drive. The downside to this configuration is that transactions are no longer durable and might rollback following a power failure or hard reset.</source>
          <target state="translated">Обратите внимание, что с &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;синхронным PRAGMA,&lt;/a&gt; установленным на NORMAL, контрольная точка является единственной операцией, которая создает барьер ввода-вывода или операцию синхронизации (fsync () в unix или FlushFileBuffers () в Windows). Таким образом, если приложение запускает контрольную точку в отдельном потоке или процессе, основной поток или процесс, выполняющий запросы к базе данных и обновления, никогда не будет блокироваться при операции синхронизации. Это помогает предотвратить &amp;laquo;зависание&amp;raquo; приложений, работающих на загруженном диске. Обратной стороной этой конфигурации является то, что транзакции больше не являются надежными и могут откатиться после сбоя питания или жесткого сброса.</target>
        </trans-unit>
        <trans-unit id="8da0c032621fbb18df4dc03aaa124440bc316a57" translate="yes" xml:space="preserve">
          <source>Note that with ANALYZE the cost estimates are better aligned with reality and algorithm-1 is selected by both NN and N3.</source>
          <target state="translated">Обратите внимание,что при использовании ANALYZE смета расходов лучше согласуется с реальностью,а алгоритм-1 выбирается как NN,так и N3.</target>
        </trans-unit>
        <trans-unit id="695e607ef01e6db075031ffa227e23ca60904541" translate="yes" xml:space="preserve">
          <source>Note that xBestIndex will always be called before &lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter&lt;/a&gt;, since the idxNum and idxStr outputs from xBestIndex are required inputs to xFilter. However, there is no guarantee that xFilter will be called following a successful xBestIndex.</source>
          <target state="translated">Обратите внимание, что xBestIndex всегда будет вызываться перед &lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter&lt;/a&gt; , поскольку выходные данные idxNum и idxStr из xBestIndex являются обязательными входными данными для xFilter. Однако нет гарантии, что xFilter будет вызван после успешного xBestIndex.</target>
        </trans-unit>
        <trans-unit id="d227a38478007bafe1c5681fa0c0259f1628a846" translate="yes" xml:space="preserve">
          <source>Note the &quot;temp.&quot; qualifier before the virtual table name (&quot;stat&quot;). This qualifier causes the virtual table to be temporary - to only exist for the duration of the current database connection. This is the recommended approach.</source>
          <target state="translated">Обратите внимание на классификатор &quot;temp.&quot; перед именем виртуальной таблицы (&quot;stat&quot;).Этот классификатор приводит к тому,что виртуальная таблица будет временной-существовать только на время текущего подключения к БД.Это рекомендуемый подход.</target>
        </trans-unit>
        <trans-unit id="984a9d35869a9cec59e40e09a2d60d76afb99304" translate="yes" xml:space="preserve">
          <source>Note the last bullet in particular. The destructor X in sqlite3_set_auxdata(C,N,P,X) might be called immediately, before the sqlite3_set_auxdata() interface even returns. Hence sqlite3_set_auxdata() should be called near the end of the function implementation and the function implementation should not make any use of P after sqlite3_set_auxdata() has been called.</source>
          <target state="translated">Обратите внимание на последнюю пулю.Деструктор X в sqlite3_set_auxdata(C,N,P,X)может быть вызван сразу же,еще до того,как интерфейс sqlite3_set_auxdata()вернется.Следовательно,sqlite3_set_auxdata()должна вызываться ближе к концу реализации функции,а реализация функции не должна использовать P после вызова sqlite3_set_auxdata().</target>
        </trans-unit>
        <trans-unit id="be13ad345e0dba5ca596ce6f7266fdf09fc32236" translate="yes" xml:space="preserve">
          <source>Note the use of the &lt;a href=&quot;lang_corefunc#quote&quot;&gt;quote() SQL function&lt;/a&gt; in these triggers. The quote() function converts its argument into a form that is appropriate for inclusion in an SQL statement. Numeric values come through unchanged. Single quotes are added before and after strings and any internal single quotes are escaped. BLOB values are rendered using SQL-standard hexadecimal BLOB notation. The use of the quote() function ensures that the SQL statements used to undo and redo are always safe from SQL injection.</source>
          <target state="translated">Обратите внимание на использование в этих триггерах &lt;a href=&quot;lang_corefunc#quote&quot;&gt;SQL-функции quote ()&lt;/a&gt; . Функция quote () преобразует свой аргумент в форму, подходящую для включения в оператор SQL. Числовые значения остаются без изменений. Одиночные кавычки добавляются до и после строк, а любые внутренние одинарные кавычки экранируются. Значения BLOB отображаются с использованием стандартной шестнадцатеричной записи BLOB в стандарте SQL. Использование функции quote () гарантирует, что операторы SQL, используемые для отмены и повтора, всегда защищены от внедрения SQL.</target>
        </trans-unit>
        <trans-unit id="044b3a09040052b2232feb80c6848441318257d4" translate="yes" xml:space="preserve">
          <source>Note the warnings on the &quot;estimatedRows&quot;, &quot;idxFlags&quot;, and colUsed fields. These fields were added with SQLite versions 3.8.2, 3.9.0, and 3.10.0, respectively. Any extension that reads or writes these fields must first check that the version of the SQLite library in use is greater than or equal to appropriate version - perhaps comparing the value returned from &lt;a href=&quot;c3ref/libversion&quot;&gt;sqlite3_libversion_number()&lt;/a&gt; against constants 3008002, 3009000, and/or 3010000. The result of attempting to access these fields in an sqlite3_index_info structure created by an older version of SQLite are undefined.</source>
          <target state="translated">Обратите внимание на предупреждения в полях &amp;laquo;EstimatedRows&amp;raquo;, &amp;laquo;idxFlags&amp;raquo; и colUsed. Эти поля были добавлены в SQLite версий 3.8.2, 3.9.0 и 3.10.0 соответственно. Любое расширение, которое считывает или записывает эти поля, должно сначала проверить, что версия используемой библиотеки SQLite больше или равна соответствующей версии - возможно, сравнивая значение, возвращаемое функцией &lt;a href=&quot;c3ref/libversion&quot;&gt;sqlite3_libversion_number (),&lt;/a&gt; с константами 3008002, 3009000 и / или 3010000. Результат попытки доступа к этим полям в структуре sqlite3_index_info, созданной более старой версией SQLite, не определен.</target>
        </trans-unit>
        <trans-unit id="49bc1f28a1c9c886ae8bd63cbcbb27c797246229" translate="yes" xml:space="preserve">
          <source>Note: Functions marked with &quot;&lt;small&gt;&lt;i&gt;(exp)&lt;/i&gt;&lt;/small&gt;&quot; are &lt;a href=&quot;capi3ref&quot;&gt;experimental&lt;/a&gt; and functions whose names are &lt;s&gt;struck through&lt;/s&gt; are &lt;a href=&quot;capi3ref&quot;&gt;deprecated&lt;/a&gt;.</source>
          <target state="translated">Примечание. Функции, отмеченные знаком &amp;laquo; &lt;small&gt;&lt;i&gt;(exp)&lt;/i&gt;&lt;/small&gt; &amp;raquo;, являются &lt;a href=&quot;capi3ref&quot;&gt;экспериментальными,&lt;/a&gt; а функции, имена которых &lt;s&gt;зачеркнуты,&lt;/s&gt; считаются &lt;a href=&quot;capi3ref&quot;&gt;устаревшими&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="66ee76f5066068620f09c7e62f4bb8c158c87cf7" translate="yes" xml:space="preserve">
          <source>Note: Functions marked with &quot;&lt;small&gt;&lt;i&gt;(exp)&lt;/i&gt;&lt;/small&gt;&quot; are &lt;a href=&quot;experimental&quot;&gt;experimental&lt;/a&gt; and functions whose names are &lt;s&gt;struck through&lt;/s&gt; are &lt;a href=&quot;experimental&quot;&gt;deprecated&lt;/a&gt;.</source>
          <target state="translated">Примечание. Функции, отмеченные знаком &amp;laquo; &lt;small&gt;&lt;i&gt;(exp)&lt;/i&gt;&lt;/small&gt; &amp;raquo;, являются &lt;a href=&quot;experimental&quot;&gt;экспериментальными,&lt;/a&gt; а функции, имена которых &lt;s&gt;зачеркнуты,&lt;/s&gt; считаются &lt;a href=&quot;experimental&quot;&gt;устаревшими&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="03b148e28fde4df0887542e9d88b598d5e8f42db" translate="yes" xml:space="preserve">
          <source>Note: Sections 2.0 and 3.0 of this article were added in response to comments on &lt;a href=&quot;https://news.ycombinator.com/item?id=16585120&quot;&gt;Hacker News&lt;/a&gt; and &lt;a href=&quot;https://www.reddit.com/r/programming/comments/84fzoc/why_is_sqlite_coded_in_c/&quot;&gt;Reddit&lt;/a&gt;.</source>
          <target state="translated">Примечание. Разделы 2.0 и 3.0 этой статьи были добавлены в ответ на комментарии к &lt;a href=&quot;https://news.ycombinator.com/item?id=16585120&quot;&gt;Hacker News&lt;/a&gt; и &lt;a href=&quot;https://www.reddit.com/r/programming/comments/84fzoc/why_is_sqlite_coded_in_c/&quot;&gt;Reddit&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="85e051b1f236f895d99d48916ab5fd667388aec3" translate="yes" xml:space="preserve">
          <source>Note: This method is disabled on MacOS X 10.7 and iOS version 5.0 and will always return SQLITE_MISUSE. On those systems, shared cache mode should be enabled per-database connection via &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; with &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_SHAREDCACHE&lt;/a&gt;.</source>
          <target state="translated">Примечание. Этот метод отключен в MacOS X 10.7 и iOS версии 5.0 и всегда будет возвращать SQLITE_MISUSE. В этих системах режим общего кеша должен быть включен для подключения к базе данных через &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2 ()&lt;/a&gt; с &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_SHAREDCACHE&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ddf57deb38e4651cb3981116d2b9ec03a6feb885" translate="yes" xml:space="preserve">
          <source>Note: This method is disabled on MacOS X 10.7 and iOS version 5.0 and will always return SQLITE_MISUSE. On those systems, shared cache mode should be enabled per-database connection via &lt;a href=&quot;open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; with &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_SHAREDCACHE&lt;/a&gt;.</source>
          <target state="translated">Примечание. Этот метод отключен в MacOS X 10.7 и iOS версии 5.0 и всегда будет возвращать SQLITE_MISUSE. В этих системах режим общего кеша должен быть включен для подключения к базе данных через &lt;a href=&quot;open&quot;&gt;sqlite3_open_v2 ()&lt;/a&gt; с &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_SHAREDCACHE&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="70440046a3dc2e079f23ee1c57dfa76669b732aa" translate="yes" xml:space="preserve">
          <source>Notes</source>
          <target state="translated">Notes</target>
        </trans-unit>
        <trans-unit id="b7c62ae6be1885d1c5a81f6a7886c67b36419ed4" translate="yes" xml:space="preserve">
          <source>Notes on the &lt;a href=&quot;optoverview&quot;&gt;query optimizer&lt;/a&gt;.</source>
          <target state="translated">Примечания к &lt;a href=&quot;optoverview&quot;&gt;оптимизатору запросов&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9c3befe7e22c8667bc957541f49b0ee79970b588" translate="yes" xml:space="preserve">
          <source>Notes:</source>
          <target state="translated">Notes:</target>
        </trans-unit>
        <trans-unit id="bb5c89c5cb4409cab6ee44d716c6d95feaaddc62" translate="yes" xml:space="preserve">
          <source>Notice how the LIKE operator is implemented. It is a user-defined function in SQLite, so the address of its function definition is specified in P3. The operand P1 is the number of function arguments for it to take from the stack. In this case the LIKE() function takes 2 arguments. The arguments are taken off the stack in reverse order (right-to-left), so the pattern to match is the top stack element, and the next element is the data to compare. The return value is pushed onto the stack.</source>
          <target state="translated">Обратите внимание,как реализуется оператор LIKE.В SQLite это пользовательская функция,поэтому адрес ее определения указан в P3.Операнд P1-это количество аргументов функции,которое она может взять из стека.В этом случае функция LIKE()принимает 2 аргумента.Аргументы снимаются со стека в обратном порядке (справа налево),поэтому подходящий образец-верхний элемент стека,а следующий элемент-данные для сравнения.Возвращаемое значение перемещается в стек.</target>
        </trans-unit>
        <trans-unit id="5255c6a9b36d606aac6af8d3dbbceadb0d1f9b02" translate="yes" xml:space="preserve">
          <source>Notice how the query above works: The R*Tree index runs in the outer loop to find entries that are contained within the bounding box of longitude -81..-79.6 and latitude 35.0..36.2. For each object identifier found, SQLite looks up the corresponding entry in the demo_data table. It then uses the boundary field from the demo_data table as a parameter to the contained_in() function and if that function returns true, the objname field from the demo_data table is returned as the next row of query result.</source>
          <target state="translated">Обратите внимание,как работает вышеприведенный запрос:Индекс R*Tree запускается во внешнем цикле для поиска записей,которые содержатся в граничном поле долготы -81...-79.6 и широты 35.0...36.2.Для каждого найденного идентификатора объекта SQLite ищет соответствующую запись в таблице demo_data.Затем он использует граничное поле из таблицы demo_data в качестве параметра в функцию contain_in(),и если эта функция возвращает true,то поле объектного имени из таблицы demo_data возвращается в качестве следующей строки результата запроса.</target>
        </trans-unit>
        <trans-unit id="3b7384e004cca4a56bb485375c44be1a10c5774f" translate="yes" xml:space="preserve">
          <source>Notice that all other date and time functions can be expressed in terms of strftime():</source>
          <target state="translated">Обратите внимание,что все остальные функции даты и времени могут быть выражены с помощью функции strftime():</target>
        </trans-unit>
        <trans-unit id="a0897fe8cedb04900939c7986a4c19ddb9b29972" translate="yes" xml:space="preserve">
          <source>Notice that dividing up the content into smaller pieces using an SQLite table gives flexibility to the implementation. The application can choose to read all content into memory at startup. Or it can read just a few pages into memory and keep the rest on disk. Or it can read just single page into memory at a time. And different versions of the application can make different choices without having to make any changes to the file format. Such options are not available when all content is in a single big XML file in a ZIP archive.</source>
          <target state="translated">Обратите внимание,что разделение содержимого на более мелкие кусочки с помощью таблицы SQLite дает гибкость в реализации.При запуске приложение может выбрать чтение всего содержимого в память.Или же оно может прочитать всего несколько страниц в память,а остальное оставить на диске.Или же оно может читать только одну страницу в память одновременно.И разные версии приложения могут делать разный выбор без необходимости вносить изменения в формат файла.Такие опции недоступны,когда все содержимое находится в одном большом XML-файле в ZIP-архиве.</target>
        </trans-unit>
        <trans-unit id="8b6637336242d861c3d1aedafa06202a9a576add" translate="yes" xml:space="preserve">
          <source>Notice that the &quot;host&quot; value for the &quot;dummy&quot; record is NULL so the result[] array contains a NULL pointer at that slot.</source>
          <target state="translated">Обратите внимание,что значение &quot;host&quot; для записи &quot;dummy&quot; равно NULL,поэтому массив result[]содержит в этом слоте указатель NULL.</target>
        </trans-unit>
        <trans-unit id="81da02d10ebbcf526492f91d32dd8afa2884d608" translate="yes" xml:space="preserve">
          <source>Notice that the parameters to functions are now pointers to sqlite3_value structures instead of pointers to strings as in SQLite version 2.X. The following routines are used to extract useful information from these &quot;values&quot;:</source>
          <target state="translated">Обратите внимание,что параметры функций теперь являются указателями на структуры sqlite3_value вместо указателей на строки,как в SQLite версии 2.X.Следующие процедуры используются для извлечения полезной информации из этих &quot;значений&quot;:</target>
        </trans-unit>
        <trans-unit id="45ef496d245754f1f4daa860e31545d9feaf1aea" translate="yes" xml:space="preserve">
          <source>Notice that the shared lock is on the operating system disk cache, not on the disk itself. File locks really are just flags within the operating system kernel, usually. (The details depend on the specific OS layer interface.) Hence, the lock will instantly vanish if the operating system crashes or if there is a power loss. It is usually also the case that the lock will vanish if the process that created the lock exits.</source>
          <target state="translated">Обратите внимание,что разделяемая блокировка находится в кэше диска операционной системы,а не на самом диске.Файловые блокировки на самом деле-это просто флаги в ядре операционной системы,обычно.(Детали зависят от конкретного интерфейса уровня операционной системы.)Следовательно,блокировка мгновенно исчезнет,если операционная система выйдет из строя или произойдет отключение питания.Обычно блокировка также исчезает,если процесс,создавший блокировку,завершает свою работу.</target>
        </trans-unit>
        <trans-unit id="f8f4b80268c40011630e5371241e6ab982124215" translate="yes" xml:space="preserve">
          <source>Notice that the tokens in the result set from the fts3tokenize virtual table have been transformed according to the rules of the tokenizer. Since this example used the &quot;porter&quot; tokenizer, the &quot;This&quot; token was converted into &quot;thi&quot;. If the original text of the token is desired, it can be retrieved using the &quot;start&quot; and &quot;end&quot; columns with the &lt;a href=&quot;lang_corefunc#substr&quot;&gt;substr()&lt;/a&gt; function. For example:</source>
          <target state="translated">Обратите внимание, что токены в результирующем наборе из виртуальной таблицы fts3tokenize были преобразованы в соответствии с правилами токенизатора. Поскольку в этом примере использовался токенизатор &amp;laquo;porter&amp;raquo;, токен &amp;laquo;This&amp;raquo; был преобразован в &amp;laquo;thi&amp;raquo;. Если требуется исходный текст токена, его можно получить, используя столбцы &amp;laquo;начало&amp;raquo; и &amp;laquo;конец&amp;raquo; с помощью функции &lt;a href=&quot;lang_corefunc#substr&quot;&gt;substr ()&lt;/a&gt; . Например:</target>
        </trans-unit>
        <trans-unit id="af54971d34d4b499061179fcac4a7f0e1fee4c0f" translate="yes" xml:space="preserve">
          <source>Notice the similarity between the ListRead and Next instructions. Both operations work according to this rule:</source>
          <target state="translated">Обратите внимание на сходство между инструкциями ListRead и Next.Обе операции работают по этому правилу:</target>
        </trans-unit>
        <trans-unit id="7cec2e96076ffe89a48a9bb0d641ff84dbe2e0a2" translate="yes" xml:space="preserve">
          <source>Notice too that there is a tradeoff between average read performance and average write performance. To maximize the read performance, one wants to keep the WAL as small as possible and hence run checkpoints frequently, perhaps as often as every COMMIT. To maximize write performance, one wants to amortize the cost of each checkpoint over as many writes as possible, meaning that one wants to run checkpoints infrequently and let the WAL grow as large as possible before each checkpoint. The decision of how often to run checkpoints may therefore vary from one application to another depending on the relative read and write performance requirements of the application. The default strategy is to run a checkpoint once the WAL reaches 1000 pages and this strategy seems to work well in test applications on workstations, but other strategies might work better on different platforms or for different workloads.</source>
          <target state="translated">Заметьте также,что существует компромисс между средней производительностью чтения и средней производительностью записи.Чтобы максимизировать производительность при чтении,необходимо сохранять стены как можно меньше и,следовательно,запускать контрольно-пропускные пункты часто,возможно,так же часто,как и каждый КОММИТ.Чтобы максимизировать производительность записи,хочется амортизировать стоимость каждой контрольно-пропускной пункт над как можно большим количеством записей,а это значит,что хочется запускать контрольно-пропускные пункты нечасто,и пусть WAL растет как можно больше перед каждой контрольно-пропускной точкой.Решение о том,как часто запускать контрольно-пропускные пункты,следовательно,может варьироваться от одного приложения к другому в зависимости от относительного чтения и записи требования к производительности приложения.По умолчанию стратегия заключается в том,чтобы запустить контрольно-пропускной пункт,как только WAL достигнет 1000 страниц,и эта стратегия,кажется,хорошо работает в тестовых приложениях на рабочих станциях,но другие стратегии могут работать лучше на разных платформах или для разных рабочих нагрузок.</target>
        </trans-unit>
        <trans-unit id="d969bb722b85b5d0915700d40ff32bef3f77944d" translate="yes" xml:space="preserve">
          <source>Now compiles on MSVC++6 again</source>
          <target state="translated">Теперь снова компилирует на MSVC++6.</target>
        </trans-unit>
        <trans-unit id="6c31ef81ebda278449acfecbdc59bc58b62b9f81" translate="yes" xml:space="preserve">
          <source>Now compiles on Solaris and OpenBSD and other Unix variants that lack the fdatasync() function</source>
          <target state="translated">Теперь компилируется на Solaris и OpenBSD и других Unix-вариантах,в которых отсутствует функция fdatasync()</target>
        </trans-unit>
        <trans-unit id="d8eeae1a57da5c7c1fc46f998bfb914d868defe3" translate="yes" xml:space="preserve">
          <source>Now consider a query to find the names of everyone in the organization that is 180cm tall or taller:</source>
          <target state="translated">Теперь рассмотрим запрос,чтобы найти имена всех в организации ростом 180 см или выше:</target>
        </trans-unit>
        <trans-unit id="cace99b617f1285adb8e73b73b38a21bf398149e" translate="yes" xml:space="preserve">
          <source>Now consider the case where M and N are both 3500. Alice nodes are abundant. But suppose each of these nodes is connected by only one or two edges. In this case, option 2 is preferred. With option 2, the outer loop still has to run 3500 times, but the middle loop only runs once or twice for each outer loop and the inner loop will only run once for each middle loop, if at all. So the total number of iterations of the inner loop is around 7000. Option 1, on the other hand, has to run both its outer loop and its middle loop 3500 times each, resulting in 12 million iterations of the middle loop. Thus in the second scenario, option 2 is nearly 2000 times faster than option 1.</source>
          <target state="translated">Теперь рассмотрим случай,когда M и N оба 3500.Узлы Алисы обильны.Но предположим,что каждый из этих узлов связан только одним или двумя ребрами.В этом случае предпочтителен вариант 2.При варианте 2 внешний цикл все равно должен протекать 3500 раз,но средний-только один или два раза для каждого внешнего,а внутренний-только один раз для каждого среднего,если он вообще протекает.Таким образом,общее количество итераций внутреннего цикла составляет около 7000.Вариант 1,с другой стороны,должен прогонять как внешний,так и средний цикл 3500 раз,в результате чего средний цикл получит 12 миллионов итераций.Таким образом,во втором сценарии вариант 2 почти в 2000 раз быстрее варианта 1.</target>
        </trans-unit>
        <trans-unit id="ddfe6464a41b67622d5429681d09c2e30ec73502" translate="yes" xml:space="preserve">
          <source>Now it is time to make the private, custom modifications to SQLite which are the whole point of this exercise. Switch to the private branch (if you are not already there) using the &quot;&lt;code&gt;fossil update private&lt;/code&gt;&quot; command, then bring up the source files in your text editor and make whatever changes you want to make. Once you have finished making changes, commit those changes using this command:</source>
          <target state="translated">Пришло время внести в SQLite частные пользовательские изменения, которые и составляют основу этого упражнения. Переключитесь на частную ветку (если вас еще нет) с помощью команды &amp;laquo; &lt;code&gt;fossil update private&lt;/code&gt; &amp;raquo;, затем откройте исходные файлы в текстовом редакторе и внесите любые изменения, которые хотите внести. После того, как вы закончите вносить изменения, зафиксируйте их с помощью этой команды:</target>
        </trans-unit>
        <trans-unit id="421feb72f2bd97fb759d08871988b6f039784dca" translate="yes" xml:space="preserve">
          <source>Now let's look at how this index will be used. Consider the following query:</source>
          <target state="translated">Теперь давайте посмотрим,как будет использоваться этот индекс.Рассмотрим следующий вопрос:</target>
        </trans-unit>
        <trans-unit id="470c0db4772f894a123be1434e95e5d5a6304ade" translate="yes" xml:space="preserve">
          <source>Now suppose the user.phone field contains plain text if the user has only a single phone number and a JSON array if the user has multiple phone numbers. The same question is posed: &quot;Which users have a phone number in the 704 area code?&quot; But now the json_each() function can only be called for those users that have two or more phone numbers since json_each() requires well-formed JSON as its first argument:</source>
          <target state="translated">Теперь предположим,что поле user.phone содержит простой текст,если у пользователя только один телефонный номер,и массив JSON,если у пользователя несколько телефонных номеров.Тот же самый вопрос задается:&quot;У кого из пользователей есть телефонный номер в коде 704?&quot;.Но теперь функция json_each()может быть вызвана только для тех пользователей,которые имеют два или более телефонных номера,так как json_each()требует в качестве первого аргумента хорошо сформированного JSON:</target>
        </trans-unit>
        <trans-unit id="f22ea5fd82bf1b044f7951c4c771bd645f73f8d1" translate="yes" xml:space="preserve">
          <source>Now that the public and private branches are different, you can run the &quot;&lt;code&gt;fossil update trunk&lt;/code&gt;&quot; and &quot;&lt;code&gt;fossil update private&lt;/code&gt;&quot; commands and see that fossil really does change the files in the checkout as you switch back and forth between branches.</source>
          <target state="translated">Теперь, когда публичная и частная ветки различны, вы можете запустить команды &amp;laquo; &lt;code&gt;fossil update trunk&lt;/code&gt; &amp;raquo; и &amp;laquo; &lt;code&gt;fossil update private&lt;/code&gt; &amp;raquo; и увидеть, что fossil действительно изменяет файлы в кассе при переключении между ветвями.</target>
        </trans-unit>
        <trans-unit id="109085beaaa80ac89858b283a64f7c75d7e5bb12" translate="yes" xml:space="preserve">
          <source>Null</source>
          <target state="translated">Null</target>
        </trans-unit>
        <trans-unit id="5b7d454836a77f93829b713b5a5d0e3045934959" translate="yes" xml:space="preserve">
          <source>Null-indicator is an optional string that indicates a column value is null. The default is an empty string. Note that column-separator and null-indicator are optional positional arguments; if null-indicator is specified, a column-separator argument must be specified and precede the null-indicator argument.</source>
          <target state="translated">Null-индикатор-это необязательная строка,которая указывает на то,что значение столбца является нулевым.По умолчанию пустая строка.Обратите внимание,что аргументы &quot;столбец-сепаратор&quot; и &quot;нуль-индикатор&quot; являются необязательными позиционными аргументами;если указан нуль-индикатор,то должен быть указан аргумент &quot;столбец-сепаратор&quot;,который предшествует аргументу &quot;нуль-индикатор&quot;.</target>
        </trans-unit>
        <trans-unit id="a37aacd80c708abde1a03c3d5afe5b13fd00cfc3" translate="yes" xml:space="preserve">
          <source>NullRow</source>
          <target state="translated">NullRow</target>
        </trans-unit>
        <trans-unit id="eb0f5a21c19313cdefd12cf556538964ec1b60c1" translate="yes" xml:space="preserve">
          <source>Number Of Columns In A Result Set</source>
          <target state="translated">Количество столбцов в наборе результатов</target>
        </trans-unit>
        <trans-unit id="29a85c89c3b665d61a62026778cb1a84d89e00ac" translate="yes" xml:space="preserve">
          <source>Number Of SQL Parameters</source>
          <target state="translated">Количество параметров SQL</target>
        </trans-unit>
        <trans-unit id="a780fc260fcaca2d5e967db2577edefc7720d5d2" translate="yes" xml:space="preserve">
          <source>Number of WAL frames that have already been backfilled into the database by prior checkpoints</source>
          <target state="translated">Количество фреймов WAL,которые уже были занесены в базу данных по предыдущим контрольно-пропускным пунктам</target>
        </trans-unit>
        <trans-unit id="2a37475de2d92c9f14f2ea5c38819cea5766eaa7" translate="yes" xml:space="preserve">
          <source>Number of WAL frames that have attempted to be backfilled but which might not have been backfilled successfully.</source>
          <target state="translated">Количество кадров WAL,которые пытались залить обратно,но которые не были успешно засыплены.</target>
        </trans-unit>
        <trans-unit id="3b125f191573ae8fecea26a8fd5c1f85866a1737" translate="yes" xml:space="preserve">
          <source>Number of bytes of payload</source>
          <target state="translated">Количество байтов полезной нагрузки</target>
        </trans-unit>
        <trans-unit id="3bacc7e3374d56ead644519a8de907aa11ddb984" translate="yes" xml:space="preserve">
          <source>Number of cells on the current page or btree</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93e4ee2802912bc9542ff03c865140e0975aff48" translate="yes" xml:space="preserve">
          <source>Number of columns in a result set</source>
          <target state="translated">Количество столбцов в результирующем наборе</target>
        </trans-unit>
        <trans-unit id="2b00ff36e6009d3918fa275ec909bb841ed966c0" translate="yes" xml:space="preserve">
          <source>Number of valid and committed frames in the WAL file.</source>
          <target state="translated">Количество корректных и зафиксированных кадров в файле WAL.</target>
        </trans-unit>
        <trans-unit id="ff84d5af979f34eb1211b7993c06c6a08d3a99e3" translate="yes" xml:space="preserve">
          <source>Number-of-pages</source>
          <target state="translated">Number-of-pages</target>
        </trans-unit>
        <trans-unit id="2f32b7f17e88cd173c751d8cdc7e8c19cbcaed9f" translate="yes" xml:space="preserve">
          <source>Numeric and text types make a difference for the DISTINCT keyword too:</source>
          <target state="translated">Цифровой и текстовый типы также имеют значение для ключевого слова DISTINCT:</target>
        </trans-unit>
        <trans-unit id="c37c2e33a0fa0b90c0fc1ac3254fa39cce3fa242" translate="yes" xml:space="preserve">
          <source>Numeric values (serial types 1 through 9) sort after NULLs and in numeric order.</source>
          <target state="translated">Числовые значения (последовательные типы с 1 по 9)сортируются после NULL и в числовом порядке.</target>
        </trans-unit>
        <trans-unit id="16bebfa71033ff1ade58c6f0e6b14f281dfaba25" translate="yes" xml:space="preserve">
          <source>Numeric values sort next in numerical order</source>
          <target state="translated">Числовые значения сортируются следующим образом в числовом порядке</target>
        </trans-unit>
        <trans-unit id="0f5fd79254e55ff1fbee2cde5598536b3ec7dea6" translate="yes" xml:space="preserve">
          <source>Numerous bug fixes and documentation updates.</source>
          <target state="translated">Многочисленные исправления ошибок и обновления документации.</target>
        </trans-unit>
        <trans-unit id="dc11c061204c46d3ddd7e450955d3893423efff5" translate="yes" xml:space="preserve">
          <source>Numerous code optimizations, specially optimizations designed to make the code footprint smaller.</source>
          <target state="translated">Многочисленные оптимизации кода,специально оптимизированные для того,чтобы уменьшить объем кода.</target>
        </trans-unit>
        <trans-unit id="1608a6f49ab43b4c01022e79721183478aa81607" translate="yes" xml:space="preserve">
          <source>Numerous minor bug fixes</source>
          <target state="translated">Многочисленные незначительные исправления</target>
        </trans-unit>
        <trans-unit id="59f5ab25bf1e5a211679172dc18a637343443a9e" translate="yes" xml:space="preserve">
          <source>Numerous other performance enhancements</source>
          <target state="translated">Многочисленные другие улучшения производительности</target>
        </trans-unit>
        <trans-unit id="957b6bbcded8f49f8684b4d5e7a64d7f3a67b7a1" translate="yes" xml:space="preserve">
          <source>OCELOT</source>
          <target state="translated">OCELOT</target>
        </trans-unit>
        <trans-unit id="7481b4b2758d96d6c2ef2af6709c88460dc01560" translate="yes" xml:space="preserve">
          <source>ODP - The Open Document presentation format used by OpenOffice and others</source>
          <target state="translated">ODP-формат представления открытых документов,используемый OpenOffice и др.</target>
        </trans-unit>
        <trans-unit id="2a2888f26efa625ef4871988ca874037d8ea156c" translate="yes" xml:space="preserve">
          <source>ODT - The Open Document format used by OpenOffice and others</source>
          <target state="translated">ODT-Формат открытого документа,используемый OpenOffice и др.</target>
        </trans-unit>
        <trans-unit id="0cf81c47abad8b8dc52569f7edcc1b5b2d3511f9" translate="yes" xml:space="preserve">
          <source>OF</source>
          <target state="translated">OF</target>
        </trans-unit>
        <trans-unit id="acd2081fe0965992b6934d49ae30eed38ac749e0" translate="yes" xml:space="preserve">
          <source>OFFSET</source>
          <target state="translated">OFFSET</target>
        </trans-unit>
        <trans-unit id="4f963961751f0891a23f93bba4882f74f0ade805" translate="yes" xml:space="preserve">
          <source>OFFSET clause ignored on queries without a FROM clause. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/07d6a0453d&quot;&gt;07d6a0453d&lt;/a&gt;</source>
          <target state="translated">Предложение OFFSET игнорируется в запросах без предложения FROM. Билет &lt;a href=&quot;http://www.sqlite.org/src/info/07d6a0453d&quot;&gt;07d6a0453d&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="80f83fb7443c61c317b946841f59c0be3182f095" translate="yes" xml:space="preserve">
          <source>OFFSET gives the correct answer. However, OFFSET requires time proportional to the offset value. What really happens with &quot;LIMIT x OFFSET y&quot; is that SQLite computes the query as &quot;LIMIT x+y&quot; and discards the first y values without returning them to the application. So as the window scrolls down toward the bottom of a long list, and the y value becomes larger and larger, successive offset computations take more and more time.</source>
          <target state="translated">OFFSET дает правильный ответ.Однако,OFFSET требует времени,пропорционального значению смещения.Что на самом деле происходит с &quot;LIMIT x OFFSET y&quot;,так это то,что SQLite вычисляет запрос как &quot;LIMIT x+y&quot; и отбрасывает первые значения y,не возвращая их приложению.Так как окно прокручивается вниз к концу длинного списка,и значение y становится все больше и больше,последовательные вычисления смещения занимают все больше и больше времени.</target>
        </trans-unit>
        <trans-unit id="9c108e42d4ae43fd2c4c857619aacef018184aee" translate="yes" xml:space="preserve">
          <source>OLD references are valid</source>
          <target state="translated">Действительны ссылки на старые образцы</target>
        </trans-unit>
        <trans-unit id="387d7a59dbaaef002e0f9ac69ecd4443b9c5cef2" translate="yes" xml:space="preserve">
          <source>ON</source>
          <target state="translated">ON</target>
        </trans-unit>
        <trans-unit id="32bb503cc80e713ad933b48ce9053610aae7664e" translate="yes" xml:space="preserve">
          <source>ON CONFLICT clause</source>
          <target state="translated">ПО КОНФЛИКАТНОЙ оговорке</target>
        </trans-unit>
        <trans-unit id="c13d037157d8eb7ac7ee7af0a3380941dabf2fa2" translate="yes" xml:space="preserve">
          <source>OOM testing is accomplished by simulating OOM errors. SQLite allows an application to substitute an alternative malloc() implementation using the &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmalloc&quot;&gt;SQLITE_CONFIG_MALLOC&lt;/a&gt;,...) interface. The TCL and TH3 test harnesses are both capable of inserting a modified version of malloc() that can be rigged to fail after a certain number of allocations. These instrumented mallocs can be set to fail only once and then start working again, or to continue failing after the first failure. OOM tests are done in a loop. On the first iteration of the loop, the instrumented malloc is rigged to fail on the first allocation. Then some SQLite operation is carried out and checks are done to make sure SQLite handled the OOM error correctly. Then the time-to-failure counter on the instrumented malloc is increased by one and the test is repeated. The loop continues until the entire operation runs to completion without ever encountering a simulated OOM failure. Tests like this are run twice, once with the instrumented malloc set to fail only once, and again with the instrumented malloc set to fail continuously after the first failure.</source>
          <target state="translated">OOM-тестирование выполняется путем моделирования ошибок OOM. SQLite позволяет приложению заменять альтернативную реализацию malloc () с помощью &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt; ( &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmalloc&quot;&gt;SQLITE_CONFIG_MALLOC&lt;/a&gt;, ...) интерфейс. Тестовые жгуты TCL и TH3 способны вставлять модифицированную версию malloc (), которая может быть настроена на отказ после определенного количества распределений. Эти инструментированные маллоки могут быть настроены на сбой только один раз, а затем снова начать работать или продолжать сбой после первого сбоя. OOM-тесты выполняются в цикле. На первой итерации цикла инструментированный malloc настраивается на сбой при первом выделении. Затем выполняется некоторая операция SQLite и выполняется проверка, чтобы убедиться, что SQLite правильно обработал ошибку OOM. Затем счетчик времени до отказа на инструментированном malloc увеличивается на единицу, и тест повторяется. Цикл продолжается до тех пор, пока вся операция не завершится, даже не столкнувшись с имитацией сбоя OOM. Подобные тесты выполняются дважды,один раз с инструментированным malloc, установленным на сбой только один раз, и снова с инструментальным malloc, настроенным на постоянный сбой после первого сбоя.</target>
        </trans-unit>
        <trans-unit id="f579c523960af1aec824c6fdc57af6d4abd76a1f" translate="yes" xml:space="preserve">
          <source>OR</source>
          <target state="translated">OR</target>
        </trans-unit>
        <trans-unit id="683e61c81d390d130002106c2c28e827414b7056" translate="yes" xml:space="preserve">
          <source>ORDER</source>
          <target state="translated">ORDER</target>
        </trans-unit>
        <trans-unit id="2164bde64d5e67a9aad0e7c0543250365dc40e72" translate="yes" xml:space="preserve">
          <source>ORDER BY</source>
          <target state="translated">ЗАКАЗ</target>
        </trans-unit>
        <trans-unit id="e4ec6dd8b3c32fb2c490ae23010139de3ea19166" translate="yes" xml:space="preserve">
          <source>ORDER BY and GROUP BY now use bounded memory</source>
          <target state="translated">ЗАКАЗАТЕЛЬСТВО ЗАКАЗАТЕЛЬСТВА И ГРУППА теперь использует ограниченную память</target>
        </trans-unit>
        <trans-unit id="f9252c387c5a364e0aa75e161fd6ca4b31550d60" translate="yes" xml:space="preserve">
          <source>ORDER BY ignored if the query has an identical GROUP BY. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/b75a9ca6b0499&quot;&gt;b75a9ca6b0&lt;/a&gt;</source>
          <target state="translated">ORDER BY игнорируется, если запрос имеет идентичную GROUP BY. Билет &lt;a href=&quot;http://www.sqlite.org/src/info/b75a9ca6b0499&quot;&gt;b75a9ca6b0&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3d00407a3fb0d8ad7b8bcf4535e5d986d53520d0" translate="yes" xml:space="preserve">
          <source>ORDER BY works on subselects</source>
          <target state="translated">ЗАКАЗЫВАЙТЕ Работы по подгруппам</target>
        </trans-unit>
        <trans-unit id="fb1eb08d2d3f0a79b8449be8ce9ee77050e088a5" translate="yes" xml:space="preserve">
          <source>OS Interface</source>
          <target state="translated">интерфейс операционной системы</target>
        </trans-unit>
        <trans-unit id="7ea1a5ba1dffba576fe0a188bb466f1a65ef5c2d" translate="yes" xml:space="preserve">
          <source>OS Interface File Virtual Methods Object</source>
          <target state="translated">Файл интерфейса ОС Файл виртуальных методов Объект</target>
        </trans-unit>
        <trans-unit id="2fdd9f0dd04e20b2da0185c9864ac62e0fd49b33" translate="yes" xml:space="preserve">
          <source>OS Interface Object</source>
          <target state="translated">Объект интерфейса ОС</target>
        </trans-unit>
        <trans-unit id="e502b880ac4721322e02bb29b5215f15ab6c97e9" translate="yes" xml:space="preserve">
          <source>OS Interface Open File Handle</source>
          <target state="translated">Интерфейс ОС Открыть файловую ручку</target>
        </trans-unit>
        <trans-unit id="1bea0dbc1c9e6f1262f42405074e1a4e5f89e1c4" translate="yes" xml:space="preserve">
          <source>OSS Fuzz no longer finds historical bugs in SQLite. But it is still running and does occasionally find issues in new development check-ins. Examples: &lt;a href=&quot;https://www.sqlite.org/src/timeline?y=ci&amp;amp;c=c422afb507dc8757&quot;&gt;[1]&lt;/a&gt;&lt;a href=&quot;https://www.sqlite.org/src/timeline?y=ci&amp;amp;c=0a2eb949f8a759e5&quot;&gt;[2]&lt;/a&gt;&lt;a href=&quot;https://www.sqlite.org/src/timeline?y=ci&amp;amp;c=62f2235adf796c72&quot;&gt;[3]&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dee9889ad644e6e58468f0ff85f3a57aa76cfbd9" translate="yes" xml:space="preserve">
          <source>OTHERS</source>
          <target state="translated">OTHERS</target>
        </trans-unit>
        <trans-unit id="a032f6607e24aa99492871d19a553d714048e163" translate="yes" xml:space="preserve">
          <source>OUTER</source>
          <target state="translated">OUTER</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
