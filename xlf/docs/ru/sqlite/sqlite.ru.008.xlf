<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="sqlite">
    <body>
      <group id="sqlite">
        <trans-unit id="4297ce915073f569ab40d9b2eef2a6a433c9c771" translate="yes" xml:space="preserve">
          <source>Fix a long-standing bug in the byte-code engine that can cause a &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; command report as success when in fact it failed to commit. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/810dc8038872e212&quot;&gt;810dc8038872e212&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e421af2a92eeb75b68bc6dee75d2cded7fea49f" translate="yes" xml:space="preserve">
          <source>Fix a long-standing bug in the query planner that caused incorrect results on a LEFT JOIN where the left-hand table is a subquery and the join constraint is a bare column name coming from the left-hand subquery. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/2df0107b&quot;&gt;2df0107b&lt;/a&gt;.</source>
          <target state="translated">Исправьте давнюю ошибку в планировщике запросов, которая приводила к неверным результатам при LEFT JOIN, где левая таблица является подзапросом, а ограничение соединения - это пустое имя столбца, полученное из левого подзапроса. Билет &lt;a href=&quot;https://www.sqlite.org/src/info/2df0107b&quot;&gt;2df0107b&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5fd66bb0d12f0c4694325a08e38b8332a42b240a" translate="yes" xml:space="preserve">
          <source>Fix a long-standing bug in the storage engine that would (very rarely) cause a spurious report of an SQLITE_CORRUPT error but which was otherwise harmless. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/6bfb98dfc0c&quot;&gt;6bfb98dfc0c&lt;/a&gt;.</source>
          <target state="translated">Исправьте давнюю ошибку в механизме хранения, которая (очень редко) приводила к ложному сообщению об ошибке SQLITE_CORRUPT, но в остальном была безвредной. Билет &lt;a href=&quot;http://www.sqlite.org/src/info/6bfb98dfc0c&quot;&gt;6bfb98dfc0c&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="71423e6b2d68869ba9f90d3de52635f50c9c7337" translate="yes" xml:space="preserve">
          <source>Fix a long-standing problem in &lt;a href=&quot;c3ref/changes&quot;&gt;sqlite3_changes()&lt;/a&gt; for &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables that was reported a few hours after the 3.8.11 release.</source>
          <target state="translated">Устраните давнюю проблему в &lt;a href=&quot;c3ref/changes&quot;&gt;sqlite3_changes ()&lt;/a&gt; для таблиц &lt;a href=&quot;withoutrowid&quot;&gt;БЕЗ ROWID,&lt;/a&gt; о которой сообщалось через несколько часов после выпуска 3.8.11.</target>
        </trans-unit>
        <trans-unit id="29e8d63f91df6bbd58bdb3b0c96b08a128597488" translate="yes" xml:space="preserve">
          <source>Fix a long-standing problem wherein a corrupt schema on the &lt;a href=&quot;fileformat2#seqtab&quot;&gt;sqlite_sequence&lt;/a&gt; table used by &lt;a href=&quot;autoinc&quot;&gt;AUTOINCREMENT&lt;/a&gt; can lead to a crash. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/d8dc2b3a58cd5dc29&quot;&gt;d8dc2b3a58cd5dc2918a1&lt;/a&gt;</source>
          <target state="translated">Исправьте давнюю проблему, когда поврежденная схема в таблице &lt;a href=&quot;fileformat2#seqtab&quot;&gt;sqlite_sequence,&lt;/a&gt; используемой &lt;a href=&quot;autoinc&quot;&gt;AUTOINCREMENT,&lt;/a&gt; может привести к сбою. Билет &lt;a href=&quot;https://www.sqlite.org/src/info/d8dc2b3a58cd5dc29&quot;&gt;d8dc2b3a58cd5dc2918a1&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4d123dda0b40a993f6ee01005258efb1310831bb" translate="yes" xml:space="preserve">
          <source>Fix a memory allocation error in the new ADD COLUMN comment.</source>
          <target state="translated">Исправлена ошибка выделения памяти в новом комментарии ADD COLUMN.</target>
        </trans-unit>
        <trans-unit id="557f85fef49a7d6b5ef7280b85eaabf9d86a9cbc" translate="yes" xml:space="preserve">
          <source>Fix a memory leak that can occur following a disk I/O error.</source>
          <target state="translated">Устранение утечки памяти,которая может произойти после ошибки дискового ввода/вывода.</target>
        </trans-unit>
        <trans-unit id="b2e50e850f4bad5e2b888790e4a27dda05de65d0" translate="yes" xml:space="preserve">
          <source>Fix a memory leak that can occur following a failure to open error in the &lt;a href=&quot;csv&quot;&gt;CSV virtual table&lt;/a&gt;</source>
          <target state="translated">Устранение утечки памяти, которая может произойти из-за ошибки при открытии &lt;a href=&quot;csv&quot;&gt;виртуальной таблицы CSV.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="08e2d33c27f7ca8760cc5e591fecb5972898df17" translate="yes" xml:space="preserve">
          <source>Fix a memory leak that occurred when sqlite_open() failed.</source>
          <target state="translated">Исправлена утечка памяти,которая возникала при ошибке sqlite_open().</target>
        </trans-unit>
        <trans-unit id="475ca6beba2ec99949495af6c237c0b95d23fba9" translate="yes" xml:space="preserve">
          <source>Fix a missing &quot;sync&quot; that when omitted could lead to database corruption if a power failure or OS crash occurred just as a ROLLBACK operation was finishing.</source>
          <target state="translated">Исправление отсутствующей &quot;синхронизации&quot;,которая при опускании могла привести к повреждению базы данных,если отключение питания или сбой операционной системы происходил точно так же,как и при завершении операции ROLLBACK.</target>
        </trans-unit>
        <trans-unit id="dd148f4d09fd6cc6bad30b19733a82972a2cebe0" translate="yes" xml:space="preserve">
          <source>Fix a naming conflict between sqlite.h and sqlite3.h.</source>
          <target state="translated">Исправить конфликт именования между sqlite.h и sqlite3.h.</target>
        </trans-unit>
        <trans-unit id="86cbab0ce9e871e04d98798d23ca791be9552d16" translate="yes" xml:space="preserve">
          <source>Fix a parser bug that prevented the use of parentheses around table-valued functions.</source>
          <target state="translated">Исправлена ошибка в синтаксическом анализаторе,которая препятствовала использованию скобок вокруг функций с табличным значением.</target>
        </trans-unit>
        <trans-unit id="1ea82017fb31c1e817b4ca5fcdba2b68c62a7e38" translate="yes" xml:space="preserve">
          <source>Fix a performance bug in the pager cache, ticket #3844</source>
          <target state="translated">Исправлена ошибка производительности в кэше пейджера,билет № 3844.</target>
        </trans-unit>
        <trans-unit id="0b4a31de7ab7e54e3e4f0e6dd796fb43aef54770" translate="yes" xml:space="preserve">
          <source>Fix a performance regression on LEFT JOIN (see ticket #3015) that was mistakenly introduced in &lt;a href=&quot;#version_3_5_8&quot;&gt;version 3.5.8&lt;/a&gt;.</source>
          <target state="translated">Исправьте снижение производительности LEFT JOIN (см. Билет № 3015), которое было ошибочно введено в &lt;a href=&quot;#version_3_5_8&quot;&gt;версии 3.5.8&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="51a1cd95a4c2ce3fd6ef13919dca1d81326877a9" translate="yes" xml:space="preserve">
          <source>Fix a performance regression related to the query planner enhancements of version 3.7.0.</source>
          <target state="translated">Исправлена регрессия производительности,связанная с улучшениями планировщика запросов версии 3.7.0.</target>
        </trans-unit>
        <trans-unit id="59850e50fa6095504ef5b88efd743956885d3a6e" translate="yes" xml:space="preserve">
          <source>Fix a possible infinite loop on VACUUM for corrupt database files. Check-in &lt;a href=&quot;https://www.sqlite.org/src/info/27754b74ddf64&quot;&gt;27754b74ddf64&lt;/a&gt;</source>
          <target state="translated">Исправьте возможный бесконечный цикл VACUUM для поврежденных файлов базы данных. Заезд &lt;a href=&quot;https://www.sqlite.org/src/info/27754b74ddf64&quot;&gt;27754b74ddf64&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="16de14f899013ff24b7caea8ce7237c3023ffe3c" translate="yes" xml:space="preserve">
          <source>Fix a possible segfault with DELETE when table is a &lt;a href=&quot;rowidtable&quot;&gt;rowid table&lt;/a&gt; with an &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; and the WHERE clause contains a OR and the table has one or more indexes that are able to trigger the OR optimization, but none of the indexes reference any table columns other than the INTEGER PRIMARY KEY. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/16c9801ceba49&quot;&gt;16c9801ceba49&lt;/a&gt;.</source>
          <target state="translated">Исправьте возможный segfault с помощью DELETE, когда таблица является таблицей &lt;a href=&quot;rowidtable&quot;&gt;rowid&lt;/a&gt; с &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY,&lt;/a&gt; а предложение WHERE содержит OR, а таблица имеет один или несколько индексов, которые могут запускать оптимизацию OR, но ни один из индексов не ссылается на какие-либо столбцы таблицы кроме INTEGER PRIMARY KEY. Билет &lt;a href=&quot;https://www.sqlite.org/src/info/16c9801ceba49&quot;&gt;16c9801ceba49&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d502547575294f85b69c2db2bf60e7be17520a7d" translate="yes" xml:space="preserve">
          <source>Fix a potential 32-bit integer overflow problem in the &lt;a href=&quot;c3ref/blob_read&quot;&gt;sqlite3_blob_read()&lt;/a&gt; and &lt;a href=&quot;c3ref/blob_write&quot;&gt;sqlite3_blob_write()&lt;/a&gt; interfaces.</source>
          <target state="translated">Устраните потенциальную проблему переполнения 32-битных целых чисел в интерфейсах &lt;a href=&quot;c3ref/blob_read&quot;&gt;sqlite3_blob_read ()&lt;/a&gt; и &lt;a href=&quot;c3ref/blob_write&quot;&gt;sqlite3_blob_write ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="86abca115efafefa4d8227ca90c204f72ac25973" translate="yes" xml:space="preserve">
          <source>Fix a potential buffer overread that could result when trying to search a corrupt database file.</source>
          <target state="translated">Устранение потенциального переполнения буфера,которое могло возникнуть при попытке поиска поврежденного файла базы данных.</target>
        </trans-unit>
        <trans-unit id="e6cf1ce475579b639fd9a6e590dcc754d75c144f" translate="yes" xml:space="preserve">
          <source>Fix a potential database corruption bug that can occur if version 3.7.0 and version 3.6.23.1 alternately write to the same database file. &lt;a href=&quot;http://www.sqlite.org/src/info/51ae9cad317a1&quot;&gt; Ticket [51ae9cad317a1]&lt;/a&gt;</source>
          <target state="translated">Исправьте потенциальную ошибку повреждения базы данных, которая может возникнуть, если версии 3.7.0 и 3.6.23.1 поочередно записывают в один и тот же файл базы данных. &lt;a href=&quot;http://www.sqlite.org/src/info/51ae9cad317a1&quot;&gt;Билет [51ae9cad317a1]&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2326ddb13e351e1098f9d7af1605ec053a972e00" translate="yes" xml:space="preserve">
          <source>Fix a potential database corruption problem on Unix caused by the fact that all POSIX advisory locks are cleared whenever you close() a file. The work around it to embargo all close() calls while locks are outstanding.</source>
          <target state="translated">Устранение потенциальной проблемы повреждения базы данных в Unix,вызванной тем,что все POSIX-советующие блокировки удаляются всякий раз,когда вы закрываете()файл.Работа вокруг него по запрещению всех вызовов close()в то время,как блокировки остались незавершенными.</target>
        </trans-unit>
        <trans-unit id="3c1404201cf0f45ed7d26fb3ee3e025fabad8654" translate="yes" xml:space="preserve">
          <source>Fix a potential integer overflow problem when compiling a particular horrendous common table expression. This was another problem discovered by OSSFuzz. Check-in &lt;a href=&quot;https://sqlite.org/src/info/6ee8cb6ae5&quot;&gt;6ee8cb6ae5&lt;/a&gt;.</source>
          <target state="translated">Устранение потенциальной проблемы целочисленного переполнения при компиляции определенного ужасного общего табличного выражения. Это была еще одна проблема, обнаруженная OSSFuzz. Заезд &lt;a href=&quot;https://sqlite.org/src/info/6ee8cb6ae5&quot;&gt;6ee8cb6ae5&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fa021a738435d20102aefd6ba8aa9227f2196bfd" translate="yes" xml:space="preserve">
          <source>Fix a potential memory leak in &lt;a href=&quot;rowvalue&quot;&gt;row value&lt;/a&gt; processing. Check-in &lt;a href=&quot;https://www.sqlite.org/src/info/2df6bbf1b8ca8&quot;&gt;2df6bbf1b8ca8&lt;/a&gt;</source>
          <target state="translated">Исправьте потенциальную утечку памяти при обработке &lt;a href=&quot;rowvalue&quot;&gt;значений строки&lt;/a&gt; . Заезд &lt;a href=&quot;https://www.sqlite.org/src/info/2df6bbf1b8ca8&quot;&gt;2df6bbf1b8ca8&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9d59a5b1204741917d207d0911c7f5b60cccb2e8" translate="yes" xml:space="preserve">
          <source>Fix a potential memory leak in the new &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer()&lt;/a&gt; interface. Ticket &lt;a href=&quot;https://sqlite.org/src/info/7486aa54b968e9b5&quot;&gt;7486aa54b968e9b5&lt;/a&gt;.</source>
          <target state="translated">Устраните потенциальную утечку памяти в новом интерфейсе &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer ()&lt;/a&gt; . Билет &lt;a href=&quot;https://sqlite.org/src/info/7486aa54b968e9b5&quot;&gt;7486aa54b968e9b5&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0c9b94c0ee4da7edac18db1b27719d5740439e09" translate="yes" xml:space="preserve">
          <source>Fix a potential out-of-bound read when querying a corrupt database file, a problem detected by Natalie Silvanovich of Google Project Zero. Check-in &lt;a href=&quot;https://sqlite.org/src/info/04925dee41a21f&quot;&gt;04925dee41a21f&lt;/a&gt;.</source>
          <target state="translated">Устранение потенциальной возможности чтения вне границы при запросе поврежденного файла базы данных - проблема, обнаруженная Натали Сильванович из Google Project Zero. Заезд &lt;a href=&quot;https://sqlite.org/src/info/04925dee41a21f&quot;&gt;04925dee41a21f&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="94450756c5f997edafdb983263e971e139725961" translate="yes" xml:space="preserve">
          <source>Fix a potential segfault in complex recursive triggers, resulting from a bug in the OP_Once opcode introduced as part of a performance optimization in version 3.15.0. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/06796225f59c057c&quot;&gt;06796225f59c057c&lt;/a&gt;</source>
          <target state="translated">Исправьте потенциальный segfault в сложных рекурсивных триггерах, возникающий из-за ошибки в коде операции OP_Once, представленной как часть оптимизации производительности в версии 3.15.0. Билет &lt;a href=&quot;https://www.sqlite.org/src/info/06796225f59c057c&quot;&gt;06796225f59c057c&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9c23851f526115afe862ef20f590dcfe854957d3" translate="yes" xml:space="preserve">
          <source>Fix a potential segfault when destroying locks on WinCE in a multi-threaded environment.</source>
          <target state="translated">Исправление потенциального сегментации при уничтожении блокировок на WinCE в многопоточной среде.</target>
        </trans-unit>
        <trans-unit id="c5254d73f95694f4312acfaaba5e2519c7f711c7" translate="yes" xml:space="preserve">
          <source>Fix a problem in &lt;a href=&quot;lang_replace&quot;&gt;REPLACE&lt;/a&gt; that can result in a corrupt database containing two or more rows with the same &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;. Fix for ticket &lt;a href=&quot;https://www.sqlite.org/src/info/f68dc596c4e6018d&quot;&gt;f68dc596c4e6018d&lt;/a&gt;.</source>
          <target state="translated">Устраните проблему в &lt;a href=&quot;lang_replace&quot;&gt;REPLACE,&lt;/a&gt; которая может привести к повреждению базы данных, содержащей две или более строк с одинаковым &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; . Исправление для билета &lt;a href=&quot;https://www.sqlite.org/src/info/f68dc596c4e6018d&quot;&gt;f68dc596c4e6018d&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cce51ec3d9eafc83d9bef6eb168bd83fba551391" translate="yes" xml:space="preserve">
          <source>Fix a problem in &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt; that was causing a subsequent &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; to behave suboptimally.</source>
          <target state="translated">Исправьте проблему в &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integration_check&lt;/a&gt; , из-за которой последующий &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; работал неоптимально.</target>
        </trans-unit>
        <trans-unit id="e2ab7efe53f641d1c01e53f622fc41a617719096" translate="yes" xml:space="preserve">
          <source>Fix a problem in CSV import in the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; where if the leftmost field of the first row in the CSV file was both zero bytes in size and unquoted no data would be imported.</source>
          <target state="translated">Устранение проблемы при импорте CSV в &lt;a href=&quot;cli&quot;&gt;оболочку командной строки, при&lt;/a&gt; которой, если крайнее левое поле первой строки в файле CSV имело нулевой размер и не было заключено в кавычки, данные не были бы импортированы.</target>
        </trans-unit>
        <trans-unit id="b8e5e51fd7781a4a270ea3403c1d91e18539fa5d" translate="yes" xml:space="preserve">
          <source>Fix a problem in FTS4 where the left-most column that contained the &lt;a href=&quot;fts3#fts4notindexed&quot;&gt;notindexed column&lt;/a&gt; name as a prefix was not indexed rather than the column whose name matched exactly.</source>
          <target state="translated">Исправьте проблему в FTS4, когда крайний левый столбец, который содержал &lt;a href=&quot;fts3#fts4notindexed&quot;&gt;неиндексированное&lt;/a&gt; имя столбца в качестве префикса, не был проиндексирован, а не столбец, имя которого точно совпало.</target>
        </trans-unit>
        <trans-unit id="ed16f1842283c33640adef4111628a226934ccb4" translate="yes" xml:space="preserve">
          <source>Fix a problem in the &lt;a href=&quot;c3ref/result_subtype&quot;&gt;sqlite3_result_subtype()&lt;/a&gt; interface that could cause problems for the &lt;a href=&quot;json1&quot;&gt;json1&lt;/a&gt; extension under obscure circumstances. Fix for ticket &lt;a href=&quot;https://www.sqlite.org/src/info/f45ac567eaa9f9&quot;&gt;f45ac567eaa9f9&lt;/a&gt;.</source>
          <target state="translated">Устраните проблему в интерфейсе &lt;a href=&quot;c3ref/result_subtype&quot;&gt;sqlite3_result_subtype (),&lt;/a&gt; которая могла вызвать проблемы для расширения &lt;a href=&quot;json1&quot;&gt;json1&lt;/a&gt; при неясных обстоятельствах. Исправление для билета &lt;a href=&quot;https://www.sqlite.org/src/info/f45ac567eaa9f9&quot;&gt;f45ac567eaa9f9&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7871f6059f0a9d8ae6199f7ed5e914925c1946d3" translate="yes" xml:space="preserve">
          <source>Fix a problem in the query planner that results when a row-value expression is used with a PRIMARY KEY with redundant columns. Ticket &lt;a href=&quot;https://sqlite.org/src/info/1a84668dcfdebaf12415d&quot;&gt;1a84668dcfdebaf12415d&lt;/a&gt;</source>
          <target state="translated">Устранение проблемы в планировщике запросов, которая возникает, когда выражение значения строки используется с ПЕРВИЧНЫМ КЛЮЧОМ с избыточными столбцами. Билет &lt;a href=&quot;https://sqlite.org/src/info/1a84668dcfdebaf12415d&quot;&gt;1a84668dcfdebaf12415d&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ee14ad300b53edffc750ba4ada032439baf8cf04" translate="yes" xml:space="preserve">
          <source>Fix a problem in the virtual table commit mechanism that was causing a crash in FTS3. Ticket #3497.</source>
          <target state="translated">Устранение проблемы в механизме фиксации виртуальной таблицы,приводившей к аварийному завершению работы в FTS3.Билет №3497.</target>
        </trans-unit>
        <trans-unit id="367c86dcc3176132b397b28f7554be7148358015" translate="yes" xml:space="preserve">
          <source>Fix a problem that was causing excess memory usage with large &lt;a href=&quot;wal&quot;&gt;WAL&lt;/a&gt; transactions in win32 systems.</source>
          <target state="translated">Устраните проблему, которая приводила к чрезмерному использованию памяти при больших транзакциях &lt;a href=&quot;wal&quot;&gt;WAL&lt;/a&gt; в системах win32.</target>
        </trans-unit>
        <trans-unit id="e4c5c3190d6e5398a03cc1624a8ad085afe03197" translate="yes" xml:space="preserve">
          <source>Fix a problem that was causing poor performance when many thousands of SQL statements were executed by a single sqlite_exec() call.</source>
          <target state="translated">Устранение проблемы,которая приводила к низкой производительности,когда многие тысячи SQL выражений выполнялись одним вызовом sqlite_exec().</target>
        </trans-unit>
        <trans-unit id="d6546ef65a68047eca9a74f928d58465048048f8" translate="yes" xml:space="preserve">
          <source>Fix a problem that will corrupt the database file if you drop a table from the main database that has a TEMP index.</source>
          <target state="translated">Устранение проблемы,которая может привести к повреждению файла базы данных,если вы уронили таблицу из основной базы данных,которая имеет индекс TEMP.</target>
        </trans-unit>
        <trans-unit id="6a895d74574faf7c3e5b7c17bfc4a1aebd1bd35a" translate="yes" xml:space="preserve">
          <source>Fix a problem that will corrupt the indices on a table if you do an INSERT OR REPLACE or an UPDATE OR REPLACE on a table that contains an INTEGER PRIMARY KEY plus one or more indices.</source>
          <target state="translated">Устранение проблемы,которая приведет к повреждению индексов в таблице,если вы делаете INSERT OR REPLACE или UPDATE OR REPLACE в таблице,содержащей INTEGER PRIMARY KEY плюс один или более индексов.</target>
        </trans-unit>
        <trans-unit id="fa339d6b0d5c93a4f64854920f80fba0a5a92e67" translate="yes" xml:space="preserve">
          <source>Fix a problem where &lt;a href=&quot;pragma#pragma_count_changes&quot;&gt;PRAGMA count_changes&lt;/a&gt; was causing incorrect results for updates on tables with triggers</source>
          <target state="translated">Устранена проблема, при которой &lt;a href=&quot;pragma#pragma_count_changes&quot;&gt;PRAGMA count_changes приводила&lt;/a&gt; к неверным результатам для обновлений таблиц с триггерами.</target>
        </trans-unit>
        <trans-unit id="2367f688e4ee0ae00d13a38bb5c62a10fab4c4f9" translate="yes" xml:space="preserve">
          <source>Fix a problem with 3-way joins that do not use indices</source>
          <target state="translated">Устранение проблемы с 3-сторонними соединениями,не использующими индексы.</target>
        </trans-unit>
        <trans-unit id="fc131893314d3ec5912c469546ad607795fe252a" translate="yes" xml:space="preserve">
          <source>Fix a problem with &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt; which could cause transactions to silently rollback if the &lt;a href=&quot;pragma#pragma_cache_size&quot;&gt;cache_size&lt;/a&gt; is set very small (less than 10) and SQLite comes under memory pressure.</source>
          <target state="translated">Исправьте проблему с &lt;a href=&quot;wal&quot;&gt;режимом WAL, из-за&lt;/a&gt; которой транзакции могли &lt;a href=&quot;pragma#pragma_cache_size&quot;&gt;откатиться без уведомления,&lt;/a&gt; если cache_size установлен очень маленьким (менее 10) и SQLite испытывает нехватку памяти.</target>
        </trans-unit>
        <trans-unit id="1f2f150e12c534df43b52ade585282148590c894" translate="yes" xml:space="preserve">
          <source>Fix a problem with VACUUM on databases from which tables containing AUTOINCREMENT have been dropped.</source>
          <target state="translated">Исправлена проблема с VACUUM на базах данных,из которых были удалены таблицы,содержащие АВТОИНКРЕМЕНТ.</target>
        </trans-unit>
        <trans-unit id="e98ac2eb09507917a285747f2d5bd3a4164f2534" translate="yes" xml:space="preserve">
          <source>Fix a problem with string memory management in the VDBE</source>
          <target state="translated">Устранение проблемы со строковым управлением памятью в VDBE</target>
        </trans-unit>
        <trans-unit id="1c1c998fb53575b975370a5727818e77b27c3b5a" translate="yes" xml:space="preserve">
          <source>Fix a problem with the &lt;a href=&quot;optoverview#leftjoinreduction&quot;&gt;LEFT JOIN strength reduction optimization&lt;/a&gt; in which the optimization was being applied inappropriately due to an IS NOT NULL operator. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/5948e09b8c415bc45d&quot;&gt;5948e09b8c415bc45d&lt;/a&gt;.</source>
          <target state="translated">Устраните проблему с &lt;a href=&quot;optoverview#leftjoinreduction&quot;&gt;оптимизацией уменьшения силы LEFT JOIN,&lt;/a&gt; в которой оптимизация применялась неправильно из-за оператора IS NOT NULL. Билет &lt;a href=&quot;https://www.sqlite.org/src/info/5948e09b8c415bc45d&quot;&gt;5948e09b8c415bc45d&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3e42c3e04422e8992158af198fdedf65d8a494b4" translate="yes" xml:space="preserve">
          <source>Fix a problem with the &lt;a href=&quot;optoverview#or_opt&quot;&gt;OR optimization&lt;/a&gt; on &lt;a href=&quot;expridx&quot;&gt;indexes on expressions&lt;/a&gt;. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/d96eba87698a428c1d&quot;&gt;d96eba87698a428c1d&lt;/a&gt;.</source>
          <target state="translated">Устранена проблема с &lt;a href=&quot;optoverview#or_opt&quot;&gt;оптимизацией ИЛИ&lt;/a&gt; для &lt;a href=&quot;expridx&quot;&gt;индексов в выражениях&lt;/a&gt; . Билет &lt;a href=&quot;https://www.sqlite.org/src/info/d96eba87698a428c1d&quot;&gt;d96eba87698a428c1d&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a552a20d99699b5fa85e0ed7fb142721053399d9" translate="yes" xml:space="preserve">
          <source>Fix a problem with the multi-row one-pass DELETE optimization that was causing it to compute incorrect answers with a self-referential subquery in the WHERE clause. Fix for ticket &lt;a href=&quot;https://www.sqlite.org/src/info/dc6ebeda9396087&quot;&gt;dc6ebeda9396087&lt;/a&gt;</source>
          <target state="translated">Устраните проблему с многострочной однопроходной оптимизацией DELETE, из-за которой она вычисляла неправильные ответы с помощью подзапроса со ссылками на себя в предложении WHERE. Исправление для билета &lt;a href=&quot;https://www.sqlite.org/src/info/dc6ebeda9396087&quot;&gt;dc6ebeda9396087&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="070ed03b719700575899432a2c98f057535dbcc4" translate="yes" xml:space="preserve">
          <source>Fix a problem with the new &lt;a href=&quot;windowfunctions&quot;&gt;window functions&lt;/a&gt; implementation that caused a malfunction when complicated expressions involving window functions were used inside of a view.</source>
          <target state="translated">Исправлена ​​проблема с новой реализацией &lt;a href=&quot;windowfunctions&quot;&gt;оконных функций,&lt;/a&gt; которая вызвала сбой, когда внутри представления использовались сложные выражения, включающие оконные функции.</target>
        </trans-unit>
        <trans-unit id="ef0924214b0eb9fe23d46afbb07aaf1261d67d0a" translate="yes" xml:space="preserve">
          <source>Fix a problem with the sort order when comparing upper-case strings against characters greater than 'Z' but less than 'a'.</source>
          <target state="translated">Исправлена проблема с порядком сортировки при сравнении строк в верхнем регистре с символами больше 'Z',но меньше 'a'.</target>
        </trans-unit>
        <trans-unit id="5e753a491c25e8edb1492253042a4e79f112f875" translate="yes" xml:space="preserve">
          <source>Fix a problem with the use of &lt;a href=&quot;windowfunctions&quot;&gt;window functions&lt;/a&gt; used within &lt;a href=&quot;lang_expr#cosub&quot;&gt;correlated subqueries&lt;/a&gt;. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/d0866b26f83e9c55e3&quot;&gt;d0866b26f83e9c55e3&lt;/a&gt;</source>
          <target state="translated">Исправьте проблему с использованием &lt;a href=&quot;windowfunctions&quot;&gt;оконных функций,&lt;/a&gt; используемых в &lt;a href=&quot;lang_expr#cosub&quot;&gt;коррелированных подзапросах&lt;/a&gt; . Билет &lt;a href=&quot;https://www.sqlite.org/src/info/d0866b26f83e9c55e3&quot;&gt;d0866b26f83e9c55e3&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="551f44e055f1b2367c902fea7be697c804fc97a8" translate="yes" xml:space="preserve">
          <source>Fix a problem with using the &lt;a href=&quot;optoverview#like_opt&quot;&gt;LIKE optimization&lt;/a&gt; on an &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;. Check-in &lt;a href=&quot;https://www.sqlite.org/src/info/b850dd159918af56&quot;&gt;b850dd159918af56&lt;/a&gt;.</source>
          <target state="translated">Устраните проблему с использованием &lt;a href=&quot;optoverview#like_opt&quot;&gt;оптимизации LIKE&lt;/a&gt; для &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; . Заезд &lt;a href=&quot;https://www.sqlite.org/src/info/b850dd159918af56&quot;&gt;b850dd159918af56&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="293886e1e2fac8f6d1689e1a0e83ac48f4add2fd" translate="yes" xml:space="preserve">
          <source>Fix a query planner bug involving a LEFT JOIN with a BETWEEN or LIKE/GLOB constraint and then another INNER JOIN to the right that involves an OR constraint.</source>
          <target state="translated">Исправьте ошибку в планировании запросов,связанную с ЛЕВЫМ СОЕДИНЕНИЕМ с ограничением BETWEEN или LIKE/GLOB,а затем с другим СОЕДИНЕНИЕМ ИННЕРА справа,которое включает ограничение ИЛИ.</target>
        </trans-unit>
        <trans-unit id="8ff17cc556a87f30aa15241b1ac5c7a361de91a4" translate="yes" xml:space="preserve">
          <source>Fix a query planner bug that could result in a segfault when querying tables with a UNIQUE or PRIMARY KEY constraint with more than four columns.</source>
          <target state="translated">Устранение ошибки планировщика запросов,которая могла привести к сегрегации при запросе таблиц с ограничением UNIQUE или PRIMARY KEY с более чем четырьмя столбцами.</target>
        </trans-unit>
        <trans-unit id="9fb45458b64cd84ba2a2f30a7bfee1435ad64176" translate="yes" xml:space="preserve">
          <source>Fix a query planner bug that might cause a table to be scanned in the wrong direction (thus reversing the order of output) when a DESC index is used to implement the ORDER BY clause on a query that has an identical GROUP BY clause. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/ba7cbfaedc7e6&quot;&gt;ba7cbfaedc7e6&lt;/a&gt;.</source>
          <target state="translated">Исправьте ошибку планировщика запросов, из-за которой таблица могла сканироваться в неправильном направлении (таким образом, изменяя порядок вывода), когда индекс DESC используется для реализации предложения ORDER BY в запросе, который имеет идентичное предложение GROUP BY. Билет &lt;a href=&quot;http://www.sqlite.org/src/info/ba7cbfaedc7e6&quot;&gt;ba7cbfaedc7e6&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="09bdfd52ac4cb9f3c70abc6d5f401e62168b1225" translate="yes" xml:space="preserve">
          <source>Fix a query planner problem that could result in an incorrect answer due to the use of &lt;a href=&quot;optoverview#autoindex&quot;&gt;automatic indexing&lt;/a&gt; in subqueries in the FROM clause of a correlated scalar subqueries. Fix for ticket &lt;a href=&quot;https://www.sqlite.org/src/info/8a2adec1&quot;&gt;8a2adec1&lt;/a&gt;.</source>
          <target state="translated">Исправьте проблему планировщика запросов, которая могла привести к неправильному ответу из-за использования &lt;a href=&quot;optoverview#autoindex&quot;&gt;автоматической индексации&lt;/a&gt; в подзапросах в предложении FROM коррелированных скалярных подзапросов. Исправление для билета &lt;a href=&quot;https://www.sqlite.org/src/info/8a2adec1&quot;&gt;8a2adec1&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3db45cb5a06554ceffd3c2fab04e67abb9573838" translate="yes" xml:space="preserve">
          <source>Fix a race condition in AUTOVACUUM that can lead to corrupt databases</source>
          <target state="translated">Исправьте состояние гонки в АВТОВАКУМе,которое может привести к поврежденным базам данных.</target>
        </trans-unit>
        <trans-unit id="96a8e915a1becae62cd060b6c6ea6fdc08fd0da2" translate="yes" xml:space="preserve">
          <source>Fix a race condition in test_async.c.</source>
          <target state="translated">Исправление состояния гонки в test_async.c.</target>
        </trans-unit>
        <trans-unit id="625e5e94c16544ff24dd9e860382b39ea7c80a87" translate="yes" xml:space="preserve">
          <source>Fix a segfault that can occur for queries that use table-valued functions in an IN or EXISTS subquery. Ticket &lt;a href=&quot;https://sqlite.org/src/info/b899b6042f97f5&quot;&gt;b899b6042f97f5&lt;/a&gt;</source>
          <target state="translated">Исправьте ошибку сегментации, которая может возникнуть для запросов, использующих возвращающие табличное значение функции в подзапросе IN или EXISTS. Билет &lt;a href=&quot;https://sqlite.org/src/info/b899b6042f97f5&quot;&gt;b899b6042f97f5&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a280dd5a4ba61a6ed5b8a4172311dcec663fd176" translate="yes" xml:space="preserve">
          <source>Fix a serious bug in the INSERT command which was causing data to go into the wrong columns if the data source was a SELECT and the INSERT clauses specified its columns in some order other than the default.</source>
          <target state="translated">Исправлена серьезная ошибка в команде INSERT,из-за которой данные попадали не в те столбцы,если источником данных был SELECT,а пункты INSERT указывали их столбцы в некотором порядке,отличном от заданного по умолчанию.</target>
        </trans-unit>
        <trans-unit id="a11d09fcf4c5c4f534bed3e95aeaedc75d2eadb8" translate="yes" xml:space="preserve">
          <source>Fix a strange (but valid) C declaration that was causing problems for QNX. No logical changes.</source>
          <target state="translated">Исправьте странное (но действительное)объявление C,которое вызывало проблемы для QNX.Логические изменения отсутствуют.</target>
        </trans-unit>
        <trans-unit id="7c6a164c4c1dd8fe7b071d0ade9de88fbde73880" translate="yes" xml:space="preserve">
          <source>Fix a typos in the sqlite3ext.h header file that prevented the &lt;a href=&quot;c3ref/stmt_isexplain&quot;&gt;sqlite3_stmt_isexplain()&lt;/a&gt; and &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_frombind()&lt;/a&gt; interfaces from being called from &lt;a href=&quot;loadext&quot;&gt;run-time loadable extensions&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a54239aed950f147b9530647f9884464a8a7700" translate="yes" xml:space="preserve">
          <source>Fix a use-after-free that can occur when SQLite is compiled with -DSQLITE_HAS_CODEC.</source>
          <target state="translated">Исправление ситуации,когда SQLite компилировался с помощью -DSQLITE_HAS_CODEC.</target>
        </trans-unit>
        <trans-unit id="65b8ad24259b51f708505579d558096b74643e0f" translate="yes" xml:space="preserve">
          <source>Fix an 64-bit alignment bug on HP/UX and Sparc</source>
          <target state="translated">Исправлена ошибка 64-битного выравнивания на HP/UX и Sparc</target>
        </trans-unit>
        <trans-unit id="8d3940a154d321cca0d2eb2aa13ea157138409fd" translate="yes" xml:space="preserve">
          <source>Fix an &lt;a href=&quot;fts5&quot;&gt;FTS5&lt;/a&gt; issue in which the 'optimize' command could cause index corruption.</source>
          <target state="translated">Исправьте &lt;a href=&quot;fts5&quot;&gt;ошибку FTS5,&lt;/a&gt; при которой команда optimize могла вызвать повреждение индекса.</target>
        </trans-unit>
        <trans-unit id="cf27be06b87f8658f160d75e065a66b3575cb593" translate="yes" xml:space="preserve">
          <source>Fix an &lt;a href=&quot;http://www.sqlite.org/src/info/5e10420e8d&quot;&gt; old and very obscure bug&lt;/a&gt; that can lead to corruption of the database &lt;a href=&quot;fileformat2#freelist&quot;&gt;free-page list&lt;/a&gt; when &lt;a href=&quot;pragma#pragma_incremental_vacuum&quot;&gt;incremental_vacuum&lt;/a&gt; is used.</source>
          <target state="translated">Исправьте &lt;a href=&quot;http://www.sqlite.org/src/info/5e10420e8d&quot;&gt;старую и очень малоизвестную ошибку,&lt;/a&gt; которая может привести к повреждению &lt;a href=&quot;fileformat2#freelist&quot;&gt;списка свободных страниц&lt;/a&gt; базы данных при использовании &lt;a href=&quot;pragma#pragma_incremental_vacuum&quot;&gt;incremental_vacuum&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2b834d02e62a3f123a1b8d14a7dd0d0f55d7a363" translate="yes" xml:space="preserve">
          <source>Fix an alignment problem on 64-bit machines</source>
          <target state="translated">Исправление проблемы выравнивания на 64-битных машинах</target>
        </trans-unit>
        <trans-unit id="22b28f14aad0849b7f089af3e0ae2de83c9cc448" translate="yes" xml:space="preserve">
          <source>Fix an assertion failure that occurred when deleting all rows of a table with the &quot;count_changes&quot; pragma turned on.</source>
          <target state="translated">Исправлена ошибка утверждения,возникавшая при удалении всех строк таблицы с включенной прагмой &quot;count_changes&quot;.</target>
        </trans-unit>
        <trans-unit id="24c083d9fe654c2c6b13e8a4783ebdcf071478d1" translate="yes" xml:space="preserve">
          <source>Fix an assertion fault that can occur when updating the NULL value of a field at the end of a table that was added using &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE ADD COLUMN&lt;/a&gt;.</source>
          <target state="translated">Исправьте ошибку утверждения, которая может возникнуть при обновлении значения NULL поля в конце таблицы, добавленной с помощью &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE ADD COLUMN&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="24c0b7a3124e531d424b372570a621483ca0c334" translate="yes" xml:space="preserve">
          <source>Fix an assertion fault that could occur following &lt;a href=&quot;pragma#pragma_reverse_unordered_selects&quot;&gt;PRAGMA reverse_unordered_selects&lt;/a&gt;. Ticket &lt;a href=&quot;https://sqlite.org/src/info/cb91bf4290c211d&quot;&gt;cb91bf4290c211d&lt;/a&gt;</source>
          <target state="translated">Исправьте ошибку утверждения, которая могла возникнуть после &lt;a href=&quot;pragma#pragma_reverse_unordered_selects&quot;&gt;PRAGMA reverse_unordered_selects&lt;/a&gt; . Билет &lt;a href=&quot;https://sqlite.org/src/info/cb91bf4290c211d&quot;&gt;cb91bf4290c211d&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="28b592fe11bf16075b14f304072980cfa741f4d3" translate="yes" xml:space="preserve">
          <source>Fix an assertion fault that occurred on deeply nested views.</source>
          <target state="translated">Исправить ошибку утверждения,которая произошла на глубоко вложенных взглядах.</target>
        </trans-unit>
        <trans-unit id="5a204d98c949cf8975212c05340c51bd92e0547a" translate="yes" xml:space="preserve">
          <source>Fix an assertion fault that was coming up when the expression in an index-on-expressions is really a constant. Ticket &lt;a href=&quot;https://sqlite.org/src/info/aa98619ad08ddca&quot;&gt;aa98619ad08ddca&lt;/a&gt;</source>
          <target state="translated">Исправьте ошибку утверждения, которая возникала, когда выражение в выражениях индекса действительно было константой. Билет &lt;a href=&quot;https://sqlite.org/src/info/aa98619ad08ddca&quot;&gt;aa98619ad08ddca&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5edfc637acd59a3db220a001c5781ab4bd7de9b5" translate="yes" xml:space="preserve">
          <source>Fix an index corruption issue introduced by &lt;a href=&quot;#version_3_8_7&quot;&gt;version 3.8.7&lt;/a&gt;. An index with a TEXT key can be corrupted by an &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; into the corresponding table if the table has two nested triggers that convert the key value to INTEGER and back to TEXT again. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/34cd55d68e0e6e7c9a0711aab81a2ee3c354b4c0&quot;&gt;34cd55d68e0&lt;/a&gt;</source>
          <target state="translated">Исправить проблему повреждения индекса, &lt;a href=&quot;#version_3_8_7&quot;&gt;появившуюся в версии 3.8.7&lt;/a&gt; . Индекс с ключом TEXT может быть поврежден &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; в соответствующую таблицу, если таблица имеет два вложенных триггера, которые преобразуют значение ключа в INTEGER и снова обратно в TEXT. Билет &lt;a href=&quot;https://www.sqlite.org/src/info/34cd55d68e0e6e7c9a0711aab81a2ee3c354b4c0&quot;&gt;34cd55d68e0&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8eeeaac39b440e493474edfe8a18c8edd3970590" translate="yes" xml:space="preserve">
          <source>Fix an infinite-loop in the query planner that could occur on malformed &lt;a href=&quot;lang_with&quot;&gt;common table expressions&lt;/a&gt;.</source>
          <target state="translated">Исправьте бесконечный цикл в планировщике запросов, который мог произойти в искаженных &lt;a href=&quot;lang_with&quot;&gt;общих табличных выражениях&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e7f2f6913b7c03deeb2b6b41e2ed3b92c354b90f" translate="yes" xml:space="preserve">
          <source>Fix an internal code generator problem that was causing some &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; operations to no-op. Ticket &lt;a href=&quot;https://sqlite.org/src/info/ef360601&quot;&gt;ef360601&lt;/a&gt;</source>
          <target state="translated">Исправьте проблему с внутренним генератором кода, из-за которой некоторые операции &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; не выполнялись. Билет &lt;a href=&quot;https://sqlite.org/src/info/ef360601&quot;&gt;ef360601&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="337ef48955d3bd9a0a84bd4a9dd181f41e6cabab" translate="yes" xml:space="preserve">
          <source>Fix an issue in the fsdir(PATH) &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued function&lt;/a&gt; to the &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/fileio.c&quot;&gt;fileio.c&lt;/a&gt; extension, that caused a segfault if the fsdir() table was used as the inner table of a join. Problem reported on the mailing list and fixed by check-in &lt;a href=&quot;https://www.sqlite.org/src/info/7ce4e71c1b7251be&quot;&gt;7ce4e71c1b7251be&lt;/a&gt;</source>
          <target state="translated">Исправьте проблему в функции fsdir (PATH), возвращающей &lt;a href=&quot;vtab#tabfunc2&quot;&gt;табличное значение,&lt;/a&gt; для расширения &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/fileio.c&quot;&gt;fileio.c&lt;/a&gt; , которая вызвала segfault, если таблица fsdir () использовалась как внутренняя таблица соединения. Проблема сообщена в списке рассылки и решена при регистрации &lt;a href=&quot;https://www.sqlite.org/src/info/7ce4e71c1b7251be&quot;&gt;7ce4e71c1b7251be&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6f2b91637b2c2c39f1dab693ce0e485fd3cd7d63" translate="yes" xml:space="preserve">
          <source>Fix an issue with incorrect sharing of VDBE temporary registers between co-routines that could cause incorrect query results in obscure cases. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/d06a25c84454a&quot;&gt;d06a25c84454a&lt;/a&gt;.</source>
          <target state="translated">Устранена проблема с неправильным совместным использованием временных регистров VDBE между сопрограммами, которая могла приводить к неверным результатам запроса в неясных случаях. Билет &lt;a href=&quot;https://www.sqlite.org/src/info/d06a25c84454a&quot;&gt;d06a25c84454a&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7c984a9789b89b098bf54d9a87bf8ad24379596a" translate="yes" xml:space="preserve">
          <source>Fix an obscure and relatively harmless problem that might have caused a resource leak following an I/O error.</source>
          <target state="translated">Исправьте неясную и относительно безобидную проблему,которая могла привести к утечке ресурсов после ошибки ввода/вывода.</target>
        </trans-unit>
        <trans-unit id="9af5e2e7bb886d04f6d1d3a91c18b1bcfc2e680c" translate="yes" xml:space="preserve">
          <source>Fix an obscure bug that can cause database corruption under the following unusual circumstances: A large INSERT or UPDATE statement which is part of an even larger transaction fails due to a uniqueness constraint but the containing transaction commits.</source>
          <target state="translated">Исправьте непонятную ошибку,которая может привести к повреждению базы данных при следующих необычных обстоятельствах:Большой оператор INSERT или UPDATE,являющийся частью еще более крупной транзакции,терпит неудачу из-за уникального ограничения,но содержащего коммиты транзакции.</target>
        </trans-unit>
        <trans-unit id="0096a0fca1b6b43797d06b363272bd306cbf7ce9" translate="yes" xml:space="preserve">
          <source>Fix an obscure bug that can cause database corruption under the following unusual circumstances: A large INSERT or UPDATE statement which is part of an even larger transaction fails due to a uniqueness contraint but the containing transaction commits.</source>
          <target state="translated">Исправьте непонятную ошибку,которая может привести к повреждению базы данных при следующих необычных обстоятельствах:Большое утверждение INSERT или UPDATE,являющееся частью еще более крупной транзакции,терпит неудачу из-за уникального противоречия,но содержащего коммиты транзакции.</target>
        </trans-unit>
        <trans-unit id="ce8d90d9be96ff29e6eda51d841a97e900370a1d" translate="yes" xml:space="preserve">
          <source>Fix an obscure memory leak in &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer()&lt;/a&gt;. Ticket &lt;a href=&quot;https://sqlite.org/src/info/7486aa54b968e9b&quot;&gt;7486aa54b968e9b&lt;/a&gt;</source>
          <target state="translated">Исправьте скрытую утечку памяти в &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer ()&lt;/a&gt; . Билет &lt;a href=&quot;https://sqlite.org/src/info/7486aa54b968e9b&quot;&gt;7486aa54b968e9b&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a9faef411a2ddeadaf79ebd73389c10f7af52120" translate="yes" xml:space="preserve">
          <source>Fix an obscure segfault in UTF-8 to UTF-16 conversions</source>
          <target state="translated">Исправление неясного сегмента в конверсии UTF-8 в UTF-16.</target>
        </trans-unit>
        <trans-unit id="b5c1f0802c64a77b99076bfc9059cf131dd55807" translate="yes" xml:space="preserve">
          <source>Fix an off-by-one error that caused quoted empty string at the end of a CRNL-terminated line of CSV input to be misread by the command-line shell.</source>
          <target state="translated">Исправлена ошибка &quot;off-by-one&quot;,из-за которой пустая строка в конце CRNL-терминированной строки CSV-входа была неправильно прочитана оболочкой командной строки.</target>
        </trans-unit>
        <trans-unit id="30b0fd93ee02b86cc24f6cc7bd2523397f033eee" translate="yes" xml:space="preserve">
          <source>Fix an optimizer bug involving subqueries in a compound SELECT that has both an ORDER BY and a LIMIT clause. Ticket #2339.</source>
          <target state="translated">Исправлена ошибка оптимизатора,связанная с подзапросами в составном SELECT,который имеет как пункт ORDER BY,так и пункт LIMIT.Билет #2339.</target>
        </trans-unit>
        <trans-unit id="683ed4e4563f819c0aec9579fc2147e259103b73" translate="yes" xml:space="preserve">
          <source>Fix an optimizer bug that could have caused some unusual LEFT OUTER JOINs to give incorrect results.</source>
          <target state="translated">Исправлена ошибка оптимизатора,которая могла привести к некорректному результату некоторых необычных входов ЛЕВОГО ВЫШЕЙДА.</target>
        </trans-unit>
        <trans-unit id="762e5ec5f054c66d660a449bf35057af7025d512" translate="yes" xml:space="preserve">
          <source>Fix an uninitialized variable in pager.c which could (with a probability of about 1 in 4 billion) result in a corrupted database.</source>
          <target state="translated">Исправить неинициализированную переменную на пейджере,которая могла (с вероятностью около 1 к 4 миллиардам)привести к повреждению базы данных.</target>
        </trans-unit>
        <trans-unit id="4ff50f16c16225e491f827922f36f0a1b00ee9e8" translate="yes" xml:space="preserve">
          <source>Fix another bug in the IS NULL optimization that was added in version 3.3.9.</source>
          <target state="translated">Исправлена еще одна ошибка в IS NULL оптимизации,которая была добавлена в версии 3.3.9.</target>
        </trans-unit>
        <trans-unit id="e8f06a6dcd8a035bb10d1fb00994a8c1617f3e5c" translate="yes" xml:space="preserve">
          <source>Fix another bug in the implementation of the new &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; API. We'll get it right eventually...</source>
          <target state="translated">Исправьте еще одну ошибку в реализации нового API &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; . В конце концов мы все исправим ...</target>
        </trans-unit>
        <trans-unit id="6f129ae803d9883975a2438f98f71935a3f57c27" translate="yes" xml:space="preserve">
          <source>Fix bugs in pager.c that could lead to database corruption if two processes both try to recover a hot journal at the same instant</source>
          <target state="translated">Исправление ошибок в pager.c,которые могли привести к повреждению базы данных,если два процесса пытались восстановить горячий журнал в один и тот же момент.</target>
        </trans-unit>
        <trans-unit id="e51c167c962ab37e883d84e10e98aee9dad05d15" translate="yes" xml:space="preserve">
          <source>Fix bugs in the implementation of the new &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; API that can lead to segfaults.</source>
          <target state="translated">Исправьте ошибки в реализации нового API &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2 (),&lt;/a&gt; которые могут привести к сбою в работе.</target>
        </trans-unit>
        <trans-unit id="15b10b87ff343116def15b81c85457d634788432" translate="yes" xml:space="preserve">
          <source>Fix bugs that can (rarely) lead to incorrect query results when the CAST or OR operators are used in the WHERE clause of a query.</source>
          <target state="translated">Исправление ошибок,которые (редко)могут приводить к неправильным результатам запроса,когда в выражении ГДЕ запроса используются операторы CAST или OR.</target>
        </trans-unit>
        <trans-unit id="3d935fe3f3737292749bd1972d56f443d7c93968" translate="yes" xml:space="preserve">
          <source>Fix byte alignment problems on 64-bit architectures.</source>
          <target state="translated">Исправлены проблемы с выравниванием байтов на 64-битных архитектурах.</target>
        </trans-unit>
        <trans-unit id="7bca40ab59e8b9695f58ea94f5115e8c80d7a7c3" translate="yes" xml:space="preserve">
          <source>Fix commenting errors and improve the comments generated on &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt; listings when the &lt;a href=&quot;compile#enable_explain_comments&quot;&gt;-DSQLITE_ENABLE_EXPLAIN_COMMENTS&lt;/a&gt; compile-time option is used.</source>
          <target state="translated">Исправьте ошибки комментирования и улучшите комментарии, генерируемые в списках &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN,&lt;/a&gt; когда используется параметр &lt;a href=&quot;compile#enable_explain_comments&quot;&gt;-DSQLITE_ENABLE_EXPLAIN_COMMENTS&lt;/a&gt; во время компиляции.</target>
        </trans-unit>
        <trans-unit id="f6a563b99fee018f87bcc6d45b57949ce6d02874" translate="yes" xml:space="preserve">
          <source>Fix data races that might occur under stress when running with many threads in &lt;a href=&quot;sharedcache&quot;&gt;shared cache mode&lt;/a&gt; where some of the threads are opening and closing connections.</source>
          <target state="translated">Устранение гонок данных, которые могут возникать при нагрузке при работе со многими потоками в &lt;a href=&quot;sharedcache&quot;&gt;режиме общего кэша,&lt;/a&gt; когда некоторые из потоков открывают и закрывают соединения.</target>
        </trans-unit>
        <trans-unit id="3810fcb3cfb91e5274e7723b80500a70b2e4eef7" translate="yes" xml:space="preserve">
          <source>Fix data structure alignment issues on Sparc. Ticket #3777.</source>
          <target state="translated">Исправьте проблемы с выравниванием структуры данных на Sparc.Билет № 3777.</target>
        </trans-unit>
        <trans-unit id="a7f89cd0a1f20da8469d2ab54509c35e86684ab3" translate="yes" xml:space="preserve">
          <source>Fix editline support in the command-line shell.</source>
          <target state="translated">Исправлена поддержка редактирования в командной строке оболочки.</target>
        </trans-unit>
        <trans-unit id="87d44c2123224749ec741fa602897daad30b0e0b" translate="yes" xml:space="preserve">
          <source>Fix for a bug in the ORDER BY optimizer that was introduced in &lt;a href=&quot;#version_3_7_15&quot;&gt;version 3.7.15&lt;/a&gt; which would sometimes optimize out the sorting step when in fact the sort was required. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/a179fe7465&quot;&gt;a179fe7465&lt;/a&gt;</source>
          <target state="translated">Исправление ошибки в оптимизаторе ORDER BY, представленной в &lt;a href=&quot;#version_3_7_15&quot;&gt;версии 3.7.15,&lt;/a&gt; которая иногда оптимизирует этап сортировки, когда на самом деле сортировка требовалась. Билет &lt;a href=&quot;http://www.sqlite.org/src/info/a179fe7465&quot;&gt;a179fe7465&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0a782f7686d7d9707b5dc5190d2cb994db1da8ac" translate="yes" xml:space="preserve">
          <source>Fix for a bug in the SELECT DISTINCT logic that was introduced by the prior version.</source>
          <target state="translated">Исправление ошибки в логике SELECT DISTINCT,которая была введена в предыдущей версии.</target>
        </trans-unit>
        <trans-unit id="293d91bd4dad89365956202fbbdc05193695a217" translate="yes" xml:space="preserve">
          <source>Fix for another problem (unrelated to the one fixed in 2.1.4) that sometimes causes &lt;b&gt;sqlite_exec()&lt;/b&gt; to return SQLITE_PROTOCOL unnecessarily. This time the bug was in the POSIX locking code and should not effect Windows users.</source>
          <target state="translated">Исправление другой проблемы (не связанной с той, которая была исправлена ​​в 2.1.4), которая иногда заставляет &lt;b&gt;sqlite_exec () без&lt;/b&gt; необходимости возвращать SQLITE_PROTOCOL. На этот раз ошибка была в коде блокировки POSIX и не должна влиять на пользователей Windows.</target>
        </trans-unit>
        <trans-unit id="692cc3acdf11cc382c710566eb5e8d41ae9a76e6" translate="yes" xml:space="preserve">
          <source>Fix inconsistent integer to floating-point comparison operations that could result in a corrupt index if the index is created on a table column that contains both large integers and floating point values of similar magnitude. Ticket &lt;a href=&quot;https://www.sqlite.org/src/tktview?name=38a97a87a6&quot;&gt;38a97a87a6&lt;/a&gt;.</source>
          <target state="translated">Исправьте несовместимые целые числа с операциями сравнения с плавающей запятой, которые могут привести к повреждению индекса, если индекс создается для столбца таблицы, который содержит как большие целые числа, так и значения с плавающей запятой аналогичной величины. Билет &lt;a href=&quot;https://www.sqlite.org/src/tktview?name=38a97a87a6&quot;&gt;38a97a87a6&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cbe4713574b5e7e1bf3ea574e5968f7da369b174" translate="yes" xml:space="preserve">
          <source>Fix incorrect result with complex OR-connected WHERE and STAT4. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/ec32177c99ccac2&quot;&gt;ec32177c99ccac2&lt;/a&gt;</source>
          <target state="translated">Исправить неверный результат со сложным ИЛИ, соединенным WHERE и STAT4. Билет &lt;a href=&quot;https://www.sqlite.org/src/info/ec32177c99ccac2&quot;&gt;ec32177c99ccac2&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="32ba32659ea655886bad57a0dd08fbe5d98856b9" translate="yes" xml:space="preserve">
          <source>Fix locking behavior under Windows</source>
          <target state="translated">Исправить поведение блокировки под Windows</target>
        </trans-unit>
        <trans-unit id="1f35665eab7b4eb2d565f64daa7ab9de3e2952ac" translate="yes" xml:space="preserve">
          <source>Fix many obscure problems discovered while &lt;a href=&quot;testing#fuzztesting&quot;&gt;SQL fuzzing&lt;/a&gt;.</source>
          <target state="translated">Устранение многих неясных проблем, обнаруженных при &lt;a href=&quot;testing#fuzztesting&quot;&gt;фаззинге SQL&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8e786cb80b44d5b0bc787df47e982713af4c0ff9" translate="yes" xml:space="preserve">
          <source>Fix many potential segfaults that could be caused by malicious SQL statements.</source>
          <target state="translated">Исправление многих потенциальных сегрегаций,которые могли быть вызваны вредоносными SQL-запросами.</target>
        </trans-unit>
        <trans-unit id="0ab2336b4ec301e575c6d8af5dd4486d9002cf92" translate="yes" xml:space="preserve">
          <source>Fix memory leaks that used to occur after a malloc() failure.</source>
          <target state="translated">Исправление утечек памяти,которые раньше происходили после сбоя malloc().</target>
        </trans-unit>
        <trans-unit id="6b6c482ed533b8d025b0b530bd86fd284d9ab805" translate="yes" xml:space="preserve">
          <source>Fix memory size tracking so that it works even if SQLite uses more than 2GiB of memory.</source>
          <target state="translated">Исправить отслеживание размера памяти так,чтобы оно работало,даже если SQLite использует более 2 Гб памяти.</target>
        </trans-unit>
        <trans-unit id="83c4e0c639eeed5339ef3f3550050703ea306329" translate="yes" xml:space="preserve">
          <source>Fix minor issues with the &lt;a href=&quot;dbstat&quot;&gt;dbstat virtual table&lt;/a&gt;.</source>
          <target state="translated">Исправьте мелкие проблемы с &lt;a href=&quot;dbstat&quot;&gt;виртуальной таблицей dbstat&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6d8fc1c13727f748ff40e9e6be94b0b7005ead11" translate="yes" xml:space="preserve">
          <source>Fix misbehavior of the FTS5 xBestIndex method. Ticket &lt;a href=&quot;https://sqlite.org/src/info/2b8aed9f7c9e61e8&quot;&gt;2b8aed9f7c9e61e8&lt;/a&gt;.</source>
          <target state="translated">Исправить некорректное поведение метода FTS5 xBestIndex. Билет &lt;a href=&quot;https://sqlite.org/src/info/2b8aed9f7c9e61e8&quot;&gt;2b8aed9f7c9e61e8&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d6aeb35ac1eb7c66584445cf87b55f99254ca966" translate="yes" xml:space="preserve">
          <source>Fix more bugs in the LEFT JOIN &lt;a href=&quot;optoverview#flattening&quot;&gt;flattening optimization&lt;/a&gt;. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/7fde638e94287d2c&quot;&gt;7fde638e94287d2c&lt;/a&gt;.</source>
          <target state="translated">Исправьте больше ошибок в &lt;a href=&quot;optoverview#flattening&quot;&gt;оптимизации выравнивания&lt;/a&gt; LEFT JOIN . Билет &lt;a href=&quot;https://www.sqlite.org/src/info/7fde638e94287d2c&quot;&gt;7fde638e94287d2c&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1506d1bb252e85d5b0e36b68a46cf1665d4a7c8f" translate="yes" xml:space="preserve">
          <source>Fix more problems with rollback. Enhance the test suite to exercise the rollback logic extensively in order to prevent any future problems.</source>
          <target state="translated">Исправьте больше проблем с откатом.Усовершенствуйте набор тестов для интенсивной тренировки логики отката,чтобы предотвратить любые проблемы в будущем.</target>
        </trans-unit>
        <trans-unit id="3fb27e5b00960417518969df0f918d06f25d9624" translate="yes" xml:space="preserve">
          <source>Fix multiple bugs that can occur following a malloc() failure.</source>
          <target state="translated">Исправление нескольких ошибок,которые могут возникать после сбоя malloc().</target>
        </trans-unit>
        <trans-unit id="8252f0ee7c2b56c6e1d2a3ae12fb9ec74fcaf061" translate="yes" xml:space="preserve">
          <source>Fix obscure crash bugs found by &lt;a href=&quot;http://lcamtuf.coredump.cx/afl/&quot;&gt;american fuzzy lop&lt;/a&gt;. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/a59ae93ee990a55&quot;&gt;a59ae93ee990a55&lt;/a&gt;.</source>
          <target state="translated">Исправьте неясные ошибки сбоя, найденные &lt;a href=&quot;http://lcamtuf.coredump.cx/afl/&quot;&gt;американским нечетким лопом&lt;/a&gt; . Билет &lt;a href=&quot;https://www.sqlite.org/src/info/a59ae93ee990a55&quot;&gt;a59ae93ee990a55&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="029dc6c7c9dc876556264390601510f43467cb42" translate="yes" xml:space="preserve">
          <source>Fix other minor problems with using small soft heap limits.</source>
          <target state="translated">Исправьте другие незначительные проблемы,используя небольшую мягкую кучу.</target>
        </trans-unit>
        <trans-unit id="2953bbeca888101c80fba41134554ee3b46a5872" translate="yes" xml:space="preserve">
          <source>Fix portability problems for MinGW/MSYS.</source>
          <target state="translated">Исправление проблем с портативностью для MinGW/MSYS.</target>
        </trans-unit>
        <trans-unit id="46269c4cd0e4bb26c3e434c946d6ad61c56e3d22" translate="yes" xml:space="preserve">
          <source>Fix potential corruption in &lt;a href=&quot;expridx&quot;&gt;indexes on expressions&lt;/a&gt; due to automatic datatype conversions. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/343634942dd54ab&quot;&gt;343634942dd54ab&lt;/a&gt;</source>
          <target state="translated">Устранение потенциального повреждения &lt;a href=&quot;expridx&quot;&gt;индексов в выражениях&lt;/a&gt; из-за автоматического преобразования типов данных. Билет &lt;a href=&quot;https://www.sqlite.org/src/info/343634942dd54ab&quot;&gt;343634942dd54ab&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6e4b60b2ce1e9e806c6a1d1ab2efe5b7b8417ffc" translate="yes" xml:space="preserve">
          <source>Fix problems found on 64-bit systems.</source>
          <target state="translated">Исправление проблем,найденных на 64-битных системах.</target>
        </trans-unit>
        <trans-unit id="07f0a4d00027e8a55978e27f100b7e116a031b97" translate="yes" xml:space="preserve">
          <source>Fix problems with the handling of ORDER BY expressions on compound SELECT statements in subqueries.</source>
          <target state="translated">Исправление проблем с обработкой выражений ORDER BY на составных операторах SELECT в подзапросах.</target>
        </trans-unit>
        <trans-unit id="3f1665257f79bd93e546dd7e3d88c5139efb7056" translate="yes" xml:space="preserve">
          <source>Fix rare false-positives in &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt; when run on a database connection with &lt;a href=&quot;lang_attach&quot;&gt;attached databases&lt;/a&gt;. Ticket &lt;a href=&quot;https://sqlite.org/src/info/a4e06e75a9ab61a12&quot;&gt;a4e06e75a9ab61a12&lt;/a&gt;</source>
          <target state="translated">Исправление редких ложных срабатываний в &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA Integrity_check&lt;/a&gt; при запуске в соединении с &lt;a href=&quot;lang_attach&quot;&gt;базой данных&lt;/a&gt; . Билет &lt;a href=&quot;https://sqlite.org/src/info/a4e06e75a9ab61a12&quot;&gt;a4e06e75a9ab61a12&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="715572171eb76d3d2c9de665f3a896a9b21d3581" translate="yes" xml:space="preserve">
          <source>Fix several important bugs in the new ATTACH and DETACH commands.</source>
          <target state="translated">Исправлено несколько важных ошибок в новых командах ATTACH и DETACH.</target>
        </trans-unit>
        <trans-unit id="ddb3a4c421a408022b093da748a9383a9c659be4" translate="yes" xml:space="preserve">
          <source>Fix several nuisance bugs.</source>
          <target state="translated">Исправьте несколько неприятных ошибок.</target>
        </trans-unit>
        <trans-unit id="893a9bc034bf998aa3ff5b40cdc26495f66e42a9" translate="yes" xml:space="preserve">
          <source>Fix table rename feature so that it also updates references to the renamed table in &lt;a href=&quot;lang_createtrigger&quot;&gt;triggers&lt;/a&gt; and &lt;a href=&quot;lang_createview&quot;&gt;views&lt;/a&gt;.</source>
          <target state="translated">Исправьте функцию переименования таблицы, чтобы она также обновляла ссылки на переименованную таблицу в &lt;a href=&quot;lang_createtrigger&quot;&gt;триггерах&lt;/a&gt; и &lt;a href=&quot;lang_createview&quot;&gt;представлениях&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6c93787ec12e369e67cea4716187fa506565c4de" translate="yes" xml:space="preserve">
          <source>Fix the &quot;.import&quot; command of the shell so that it ignores \r characters at the end of lines.</source>
          <target state="translated">Исправить команду &quot;.import&quot; оболочки так,чтобы она игнорировала символы \r в конце строк.</target>
        </trans-unit>
        <trans-unit id="efa608a017df9d7fa42cace30fce54f90785e7c6" translate="yes" xml:space="preserve">
          <source>Fix the &quot;.read&quot; command in the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; so that it understands that its input is not interactive.</source>
          <target state="translated">Исправьте команду &amp;laquo;.read&amp;raquo; в &lt;a href=&quot;cli&quot;&gt;оболочке командной строки,&lt;/a&gt; чтобы она понимала, что ее ввод не интерактивен.</target>
        </trans-unit>
        <trans-unit id="7dd018e621c55cac03b1d82cf14914c81075f182" translate="yes" xml:space="preserve">
          <source>Fix the --enable-threadsafe option on the configure script</source>
          <target state="translated">Исправлена опция --enable-threadsafe в сценарии конфигурации.</target>
        </trans-unit>
        <trans-unit id="4f27e177384472d9d1a0c017bbab8f18de27d2fa" translate="yes" xml:space="preserve">
          <source>Fix the &lt;a href=&quot;c3ref/db_readonly&quot;&gt;sqlite3_db_readonly()&lt;/a&gt; interface so that it returns true if the database is read-only due to the file format write version number being too large.</source>
          <target state="translated">Исправьте интерфейс &lt;a href=&quot;c3ref/db_readonly&quot;&gt;sqlite3_db_readonly (),&lt;/a&gt; чтобы он возвращал истину, если база данных доступна только для чтения из-за слишком большого номера версии записи формата файла.</target>
        </trans-unit>
        <trans-unit id="bec6839af346a0afcfd8b6b2618aee85250ace7f" translate="yes" xml:space="preserve">
          <source>Fix the &lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_used()&lt;/a&gt; and &lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_highwater()&lt;/a&gt; interfaces so that they actually do provide a 64-bit answer.</source>
          <target state="translated">Исправьте интерфейсы &lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_used ()&lt;/a&gt; и &lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_highwater (),&lt;/a&gt; чтобы они действительно обеспечивали 64-битный ответ.</target>
        </trans-unit>
        <trans-unit id="9ba95583c49ccb4f7efb59b2718e52202fa58e8d" translate="yes" xml:space="preserve">
          <source>Fix the &lt;a href=&quot;c3ref/stmt_busy&quot;&gt;sqlite3_stmt_busy()&lt;/a&gt; interface so that it gives the correct answer for &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt; statements that have been stepped but never reset.</source>
          <target state="translated">Исправьте интерфейс &lt;a href=&quot;c3ref/stmt_busy&quot;&gt;sqlite3_stmt_busy (),&lt;/a&gt; чтобы он давал правильный ответ для операторов &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt; , которые выполнялись пошагово, но никогда не сбрасывались.</target>
        </trans-unit>
        <trans-unit id="0d8b77554fdfe7204548bebac009120f0ab4ce5d" translate="yes" xml:space="preserve">
          <source>Fix the &lt;a href=&quot;c3ref/trace_v2&quot;&gt;sqlite3_trace_v2()&lt;/a&gt; interface so that it is disabled if either the callback or the mask arguments are zero, in accordance with the documentation.</source>
          <target state="translated">Исправьте интерфейс &lt;a href=&quot;c3ref/trace_v2&quot;&gt;sqlite3_trace_v2 (),&lt;/a&gt; чтобы он отключался, если аргументы обратного вызова или маски равны нулю, в соответствии с документацией.</target>
        </trans-unit>
        <trans-unit id="956e98f8a5992e566b23150a8321e220d594d919" translate="yes" xml:space="preserve">
          <source>Fix the &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_text()&lt;/a&gt; interface so that it correctly translates content generated by &lt;a href=&quot;lang_corefunc#zeroblob&quot;&gt;zeroblob()&lt;/a&gt; into a string of all 0x00 characters. This is a long-standing issue discovered after the 3.16.1 release by &lt;a href=&quot;https://github.com/google/oss-fuzz&quot;&gt;OSS-Fuzz&lt;/a&gt;</source>
          <target state="translated">Исправьте интерфейс &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_text (),&lt;/a&gt; чтобы он правильно переводил содержимое, созданное &lt;a href=&quot;lang_corefunc#zeroblob&quot;&gt;функцией zeroblob (),&lt;/a&gt; в строку, состоящую из всех символов 0x00. Это давняя проблема, обнаруженная &lt;a href=&quot;https://github.com/google/oss-fuzz&quot;&gt;OSS-Fuzz&lt;/a&gt; после выпуска 3.16.1.</target>
        </trans-unit>
        <trans-unit id="56c77cb746417e9f9c249b6c4c57b8b0bd6b303c" translate="yes" xml:space="preserve">
          <source>Fix the &lt;a href=&quot;cli&quot;&gt;CLI&lt;/a&gt; so that it builds with -DSQLITE_UNTESTABLE</source>
          <target state="translated">Исправьте &lt;a href=&quot;cli&quot;&gt;CLI,&lt;/a&gt; чтобы он строился с -DSQLITE_UNTESTABLE</target>
        </trans-unit>
        <trans-unit id="2ac07a1bdc161b16f3469a85c1d0b7329721b6d7" translate="yes" xml:space="preserve">
          <source>Fix the &lt;a href=&quot;cli#fileio&quot;&gt;readfile()&lt;/a&gt; function so that it returns an empty BLOB rather than throwing an out-of-memory error when reading an empty file.</source>
          <target state="translated">Исправьте &lt;a href=&quot;cli#fileio&quot;&gt;функцию readfile (),&lt;/a&gt; чтобы она возвращала пустой BLOB, а не выдавала ошибку нехватки памяти при чтении пустого файла.</target>
        </trans-unit>
        <trans-unit id="403d90d10026656bd2341e3610eb64ec19d4191d" translate="yes" xml:space="preserve">
          <source>Fix the &lt;a href=&quot;cli#fileio&quot;&gt;writefile()&lt;/a&gt; function so that when it creates new directories along the path of a new file, it gives them umask permissions rather than the same permissions as the file.</source>
          <target state="translated">Исправьте &lt;a href=&quot;cli#fileio&quot;&gt;функцию writefile (),&lt;/a&gt; чтобы при создании новых каталогов по пути к новому файлу она давала им разрешения umask, а не те же разрешения, что и у файла.</target>
        </trans-unit>
        <trans-unit id="c637b1ba45c5e9182867d4d4a220fb33c1f49c9d" translate="yes" xml:space="preserve">
          <source>Fix the &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/eval.c&quot;&gt;eval.c&lt;/a&gt; extension so that it works with &lt;a href=&quot;pragma#pragma_empty_result_callbacks&quot;&gt;PRAGMA empty_result_callbacks=ON&lt;/a&gt;.</source>
          <target state="translated">Исправьте расширение &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/eval.c&quot;&gt;eval.c,&lt;/a&gt; чтобы оно &lt;a href=&quot;pragma#pragma_empty_result_callbacks&quot;&gt;работало&lt;/a&gt; с PRAGMA empty_result_callbacks = ON .</target>
        </trans-unit>
        <trans-unit id="742c65bbfe2ba6c5ffb22d31b0549c4b28db3ce5" translate="yes" xml:space="preserve">
          <source>Fix the &lt;a href=&quot;json1#jeach&quot;&gt;json_each()&lt;/a&gt; function so that it returns valid results on its &quot;fullkey&quot; column when the input is a simple value rather than an array or object.</source>
          <target state="translated">Исправьте &lt;a href=&quot;json1#jeach&quot;&gt;функцию json_each (),&lt;/a&gt; чтобы она возвращала действительные результаты в своем столбце &amp;laquo;fullkey&amp;raquo;, когда входными данными является простое значение, а не массив или объект.</target>
        </trans-unit>
        <trans-unit id="6faddebbbfb3cf6bd640c7723cc149f43cca6d2e" translate="yes" xml:space="preserve">
          <source>Fix the &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE&lt;/a&gt; command so that it does not corrupt &lt;a href=&quot;lang_createindex#descidx&quot;&gt;descending indexes&lt;/a&gt; when adding a column to a &lt;a href=&quot;pragma#pragma_legacy_file_format&quot;&gt;legacy file format&lt;/a&gt; database. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/f68bf68513a1c15f&quot;&gt;f68bf68513a1c15f&lt;/a&gt;</source>
          <target state="translated">Исправьте команду &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE,&lt;/a&gt; чтобы она не повреждала &lt;a href=&quot;lang_createindex#descidx&quot;&gt;нисходящие индексы&lt;/a&gt; при добавлении столбца в базу данных &lt;a href=&quot;pragma#pragma_legacy_file_format&quot;&gt;устаревшего формата файлов&lt;/a&gt; . Билет &lt;a href=&quot;https://www.sqlite.org/src/info/f68bf68513a1c15f&quot;&gt;f68bf68513a1c15f&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="02f53a9fc9d770e6300288b8428f8e92433fe895" translate="yes" xml:space="preserve">
          <source>Fix the &lt;a href=&quot;lang_altertable#altertabmvcol&quot;&gt;ALTER TABLE RENAME COLUMN&lt;/a&gt; command so that it works for tables that have redundant UNIQUE constraints. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/bc8d94f0fbd633fd9a&quot;&gt;bc8d94f0fbd633fd9a&lt;/a&gt;</source>
          <target state="translated">Исправьте команду &lt;a href=&quot;lang_altertable#altertabmvcol&quot;&gt;ALTER TABLE RENAME COLUMN,&lt;/a&gt; чтобы она работала для таблиц с избыточными ограничениями UNIQUE. Билет &lt;a href=&quot;https://www.sqlite.org/src/info/bc8d94f0fbd633fd9a&quot;&gt;bc8d94f0fbd633fd9a&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="97c52dd1e73a0efdc1a5a635f402eb42bf6e057e" translate="yes" xml:space="preserve">
          <source>Fix the &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; command so that it adds correct samples for &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables in the &lt;a href=&quot;fileformat2#stat4tab&quot;&gt;sqlite_stat4&lt;/a&gt; table. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/b2fa5424e6fcb15&quot;&gt;b2fa5424e6fcb15&lt;/a&gt;.</source>
          <target state="translated">Исправьте команду &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE,&lt;/a&gt; чтобы она добавляла правильные образцы для таблиц &lt;a href=&quot;withoutrowid&quot;&gt;БЕЗ ROWID&lt;/a&gt; в таблицу &lt;a href=&quot;fileformat2#stat4tab&quot;&gt;sqlite_stat4&lt;/a&gt; . Билет &lt;a href=&quot;http://www.sqlite.org/src/info/b2fa5424e6fcb15&quot;&gt;b2fa5424e6fcb15&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8d872c8e6bb3c85572831647367d9180d6f56948" translate="yes" xml:space="preserve">
          <source>Fix the &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; command so that it computes statistics on tables whose names begin with &quot;sqlite&quot;. Check-in &lt;a href=&quot;https://sqlite.org/src/info/0249d9aecf69948d&quot;&gt;0249d9aecf69948d&lt;/a&gt;</source>
          <target state="translated">Исправьте команду &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE,&lt;/a&gt; чтобы она вычисляла статистику для таблиц, имена которых начинаются с &amp;laquo;sqlite&amp;raquo;. Заезд &lt;a href=&quot;https://sqlite.org/src/info/0249d9aecf69948d&quot;&gt;0249d9aecf69948d&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bc9460bbb01c2af9870b809ff07c3b2b7356fe99" translate="yes" xml:space="preserve">
          <source>Fix the &lt;a href=&quot;lang_replace&quot;&gt;REPLACE&lt;/a&gt; command so that it is no longer able to sneak a NULL value into a NOT NULL column even if the NOT NULL column has a default value of NULL. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/e6f1f2e34dceeb1ed6&quot;&gt;e6f1f2e34dceeb1ed6&lt;/a&gt;</source>
          <target state="translated">Исправьте команду &lt;a href=&quot;lang_replace&quot;&gt;REPLACE,&lt;/a&gt; чтобы она больше не могла скрыть значение NULL в столбце NOT NULL, даже если столбец NOT NULL имеет значение по умолчанию NULL. Билет &lt;a href=&quot;https://www.sqlite.org/src/info/e6f1f2e34dceeb1ed6&quot;&gt;e6f1f2e34dceeb1ed6&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0d54e2533360cb4659b717a0226d2d7a1dbf1bbf" translate="yes" xml:space="preserve">
          <source>Fix the &lt;a href=&quot;lang_replace&quot;&gt;REPLACE&lt;/a&gt; statement for &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables that lack secondary indexes so that it works correctly with triggers and foreign keys. This was a new bug caused by performance optimizations added in version 3.16.0. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/30027b613b4&quot;&gt;30027b613b4&lt;/a&gt;</source>
          <target state="translated">Исправьте оператор &lt;a href=&quot;lang_replace&quot;&gt;REPLACE&lt;/a&gt; для таблиц &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; , в которых отсутствуют вторичные индексы, чтобы он правильно работал с триггерами и внешними ключами. Это была новая ошибка, вызванная оптимизацией производительности, добавленной в версии 3.16.0. Билет &lt;a href=&quot;https://www.sqlite.org/src/info/30027b613b4&quot;&gt;30027b613b4&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d509397fe960e4575a2e26f651dde6ff90b84a19" translate="yes" xml:space="preserve">
          <source>Fix the &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; command so that it spills excess content to disk rather than holding everything in memory, and possible causing an out-of-memory error for larger database files. This fixes an issue introduced by version 3.15.0.</source>
          <target state="translated">Исправьте команду &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM,&lt;/a&gt; чтобы она вытесняла лишнее содержимое на диск, а не удерживала все в памяти, и могла вызвать ошибку нехватки памяти для больших файлов базы данных. Это устраняет проблему, появившуюся в версии 3.15.0.</target>
        </trans-unit>
        <trans-unit id="b036730fcf1ecafecf0573d1d74619be57162b96" translate="yes" xml:space="preserve">
          <source>Fix the &lt;a href=&quot;optoverview#flattening&quot;&gt;query flattener&lt;/a&gt; so that it works on queries that contain subqueries that use &lt;a href=&quot;windowfunctions&quot;&gt;window functions&lt;/a&gt;. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/f09fcd17810f65f717&quot;&gt;709fcd17810f65f717&lt;/a&gt;</source>
          <target state="translated">Исправьте &lt;a href=&quot;optoverview#flattening&quot;&gt;выравниватель запросов,&lt;/a&gt; чтобы он работал с запросами, содержащими подзапросы, использующие &lt;a href=&quot;windowfunctions&quot;&gt;оконные функции&lt;/a&gt; . Билет &lt;a href=&quot;https://www.sqlite.org/src/info/f09fcd17810f65f717&quot;&gt;709fcd17810f65f717&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7a295aba8a2bc4b671641db0bf3a60e0d6006706" translate="yes" xml:space="preserve">
          <source>Fix the &lt;a href=&quot;optoverview#or_opt&quot;&gt;OR optimization&lt;/a&gt; so that it always ignores subplans that do not use an index.</source>
          <target state="translated">Исправьте &lt;a href=&quot;optoverview#or_opt&quot;&gt;оптимизацию OR,&lt;/a&gt; чтобы она всегда игнорировала подпланы, в которых не используется индекс.</target>
        </trans-unit>
        <trans-unit id="69a683f5bb13785c6e99f6455ca83c519f9c2e7d" translate="yes" xml:space="preserve">
          <source>Fix the &lt;a href=&quot;optoverview#skipscan&quot;&gt;skip-scan optimization&lt;/a&gt; so that it works correctly when the &lt;a href=&quot;optoverview#or_opt&quot;&gt;OR optimization&lt;/a&gt; is used on &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/8fd39115d8f46&quot;&gt;8fd39115d8f46&lt;/a&gt;</source>
          <target state="translated">Исправьте &lt;a href=&quot;optoverview#skipscan&quot;&gt;оптимизацию пропуска сканирования,&lt;/a&gt; чтобы она &lt;a href=&quot;withoutrowid&quot;&gt;работала&lt;/a&gt; правильно, когда &lt;a href=&quot;optoverview#or_opt&quot;&gt;оптимизация ИЛИ&lt;/a&gt; используется в таблицах БЕЗ ROWID . Билет &lt;a href=&quot;https://www.sqlite.org/src/info/8fd39115d8f46&quot;&gt;8fd39115d8f46&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d64c703876098dc69084f33c7133d65be1531802" translate="yes" xml:space="preserve">
          <source>Fix the &lt;a href=&quot;pragma#pragma_foreign_key_check&quot;&gt;PRAGMA foreign_key_check&lt;/a&gt; command so that it works correctly with foreign keys on &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables.</source>
          <target state="translated">Исправьте команду &lt;a href=&quot;pragma#pragma_foreign_key_check&quot;&gt;PRAGMA foreign_key_check,&lt;/a&gt; чтобы она корректно &lt;a href=&quot;withoutrowid&quot;&gt;работала&lt;/a&gt; с внешними ключами в таблицах БЕЗ ROWID .</target>
        </trans-unit>
        <trans-unit id="0d608a4f7657ad4f577e7889d266b51e07ca7fe6" translate="yes" xml:space="preserve">
          <source>Fix the &lt;a href=&quot;series&quot;&gt;generate_series&lt;/a&gt; virtual table so that it correctly returns no rows if any of its constraints are NULL.</source>
          <target state="translated">Исправьте виртуальную таблицу &lt;a href=&quot;series&quot;&gt;generate_series,&lt;/a&gt; чтобы она правильно не возвращала никаких строк, если какое-либо из ее ограничений равно NULL.</target>
        </trans-unit>
        <trans-unit id="16b43b19be563d99895b6b7aa73c97080f1c15c0" translate="yes" xml:space="preserve">
          <source>Fix the REPLACE() function so that it returns NULL if the second argument is an empty string. Ticket #2324.</source>
          <target state="translated">Исправлена функция REPLACE(),возвращающая NULL,если второй аргумент-пустая строка.Тикет #2324.</target>
        </trans-unit>
        <trans-unit id="b71b83145fe1ea70f5f98014557a62cf7f2c2ec4" translate="yes" xml:space="preserve">
          <source>Fix the TCL interface so that the &quot;nullvalue&quot; setting is honored for TCL implementations of SQL functions.</source>
          <target state="translated">Исправить TCL-интерфейс таким образом,чтобы для TCL-реализаций функций SQL соблюдалась установка &quot;nullvalue&quot;.</target>
        </trans-unit>
        <trans-unit id="681e860e148ced87ec9dd7b3cfb9b43a75c2065d" translate="yes" xml:space="preserve">
          <source>Fix the behavior of &lt;a href=&quot;c3ref/column_name&quot;&gt;sqlite3_column_name()&lt;/a&gt; for queries that use the &lt;a href=&quot;optoverview#flattening&quot;&gt;flattening optimization&lt;/a&gt; so that the result is consistent with other queries that do not use that optimization, and with PostgreSQL, MySQL, and SQLServer. Ticket &lt;a href=&quot;https://sqlite.org/src/info/de3403bf5ae&quot;&gt;de3403bf5ae&lt;/a&gt;.</source>
          <target state="translated">Исправьте поведение &lt;a href=&quot;c3ref/column_name&quot;&gt;sqlite3_column_name ()&lt;/a&gt; для запросов, использующих &lt;a href=&quot;optoverview#flattening&quot;&gt;оптимизацию сглаживания,&lt;/a&gt; чтобы результат согласовывался с другими запросами, которые не используют эту оптимизацию, а также с PostgreSQL, MySQL и SQLServer. Билет &lt;a href=&quot;https://sqlite.org/src/info/de3403bf5ae&quot;&gt;de3403bf5ae&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7e2fb92f8546f34175b1dda79777c363dd68d103" translate="yes" xml:space="preserve">
          <source>Fix the behavior of comparison operators (ex: &quot;&lt;b&gt;&amp;amp;lt&lt;/b&gt;&quot;, &quot;&lt;b&gt;==&lt;/b&gt;&quot;, etc.) so that they are consistent with the order of entries in an index.</source>
          <target state="translated">Исправьте поведение операторов сравнения (например, &amp;laquo; &lt;b&gt;&amp;amp; lt&lt;/b&gt; &amp;raquo;, &amp;laquo; &lt;b&gt;==&lt;/b&gt; &amp;raquo; и т. Д.), Чтобы они соответствовали порядку записей в индексе.</target>
        </trans-unit>
        <trans-unit id="a6cdb1736bb68b0b3c4ede9fdba04199758b7855" translate="yes" xml:space="preserve">
          <source>Fix the behavior of comparison operators (ex: &quot;&lt;b&gt;&amp;lt;&lt;/b&gt;&quot;, &quot;&lt;b&gt;==&lt;/b&gt;&quot;, etc.) so that they are consistent with the order of entries in an index.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a8e8cd65707752281f4a6188d7da381520e451a" translate="yes" xml:space="preserve">
          <source>Fix the behavior of typeof() and length() on virtual tables. Ticket &lt;a href=&quot;https://sqlite.org/src/info/69d642332d25aa3b7315a6d385&quot;&gt;69d642332d25aa3b7315a6d385&lt;/a&gt;</source>
          <target state="translated">Исправьте поведение typeof () и length () в виртуальных таблицах. Билет &lt;a href=&quot;https://sqlite.org/src/info/69d642332d25aa3b7315a6d385&quot;&gt;69d642332d25aa3b7315a6d385&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="df05e2dc4f6d16d80624e7984c8465e501af7d3b" translate="yes" xml:space="preserve">
          <source>Fix the build so that it works with -DSQLITE_OMIT_WAL.</source>
          <target state="translated">Исправить сборку так,чтобы она работала с -DSQLITE_OMIT_WAL.</target>
        </trans-unit>
        <trans-unit id="2766a0c67ddd6ed7f5aaccb304bc1ba6ad153261" translate="yes" xml:space="preserve">
          <source>Fix the built-in printf logic so that it prints &quot;NaN&quot; not &quot;Inf&quot; for floating-point NaNs. Ticket #2345</source>
          <target state="translated">Исправлена встроенная логика печати так,чтобы она печатала &quot;NaN&quot;,а не &quot;Inf&quot; для NaN с плавающей точкой.Билет № 2345</target>
        </trans-unit>
        <trans-unit id="5bfcd9ce8f5df54205f92dd3b6c0521e656224b0" translate="yes" xml:space="preserve">
          <source>Fix the bytecode generator to deal with a subquery in the FROM clause that is itself a UNION ALL where one side of the UNION ALL is a view that contains an ORDER BY. This is a long-standing issue that was discovered after the release of 3.16.1. See ticket &lt;a href=&quot;https://www.sqlite.org/src/info/190c2507&quot;&gt;190c2507&lt;/a&gt;.</source>
          <target state="translated">Исправьте генератор байт-кода для работы с подзапросом в предложении FROM, который сам является UNION ALL, где одна сторона UNION ALL - это представление, содержащее ORDER BY. Это давняя проблема, которая была обнаружена после выпуска 3.16.1. См. Билет &lt;a href=&quot;https://www.sqlite.org/src/info/190c2507&quot;&gt;190c2507&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d203309fb6041974c7687fc93bbf99d6e93873bc" translate="yes" xml:space="preserve">
          <source>Fix the code generator for expressions of the form &quot;x IN (SELECT...)&quot; where the SELECT statement on the RHS is a correlated subquery. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/5e3c886796e5512e&quot;&gt;5e3c886796e5512e&lt;/a&gt;.</source>
          <target state="translated">Исправьте генератор кода для выражений вида &amp;laquo;x IN (SELECT ...)&amp;raquo;, где оператор SELECT в RHS является коррелированным подзапросом. Билет &lt;a href=&quot;https://www.sqlite.org/src/info/5e3c886796e5512e&quot;&gt;5e3c886796e5512e&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="13a43d34f4444938ebdb413873a4acf48769174e" translate="yes" xml:space="preserve">
          <source>Fix the configure script for the amalgamation so that the --readline option works again on Raspberry PIs.</source>
          <target state="translated">Исправьте скрипт настройки слияния так,чтобы опция --readline снова работала на Raspberry PI.</target>
        </trans-unit>
        <trans-unit id="0dffaab8602b04f745c3456ad0e79054b8bf2a09" translate="yes" xml:space="preserve">
          <source>Fix the function prototype for the open(2) system call to agree with POSIX. Without this fix, pthreads does not work correctly on NetBSD.</source>
          <target state="translated">Исправление прототипа функции для системного вызова open(2)для согласования с POSIX.Без этого исправления pthreads некорректно работает на NetBSD.</target>
        </trans-unit>
        <trans-unit id="0cdcb447680d92da840bf449347a30236662eba4" translate="yes" xml:space="preserve">
          <source>Fix the locking mechanism yet again to prevent &lt;b&gt;sqlite_exec()&lt;/b&gt; from returning SQLITE_PROTOCOL unnecessarily. This time the bug was a race condition in the locking code. This change affects both POSIX and Windows users.</source>
          <target state="translated">Еще раз &lt;b&gt;исправьте&lt;/b&gt; механизм блокировки, чтобы &lt;b&gt;sqlite_exec () не&lt;/b&gt; возвращал SQLITE_PROTOCOL без необходимости. На этот раз ошибка заключалась в состязании кода блокировки. Это изменение затрагивает пользователей POSIX и Windows.</target>
        </trans-unit>
        <trans-unit id="007c6c873e32f4b431e8ac6f01127288ee55c964" translate="yes" xml:space="preserve">
          <source>Fix the min() and max() optimizer so that it works when the FROM clause consists of a subquery.</source>
          <target state="translated">Исправить оптимизатор min()и max()так,чтобы он работал,когда выражение FROM состоит из подзапроса.</target>
        </trans-unit>
        <trans-unit id="b12f6e9f1f8f67709743497fbebb71ef8c53459f" translate="yes" xml:space="preserve">
          <source>Fix the parser to accept valid &lt;a href=&quot;rowvalue&quot;&gt;row value&lt;/a&gt; syntax. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/7310e2fb3d046a5&quot;&gt;7310e2fb3d046a5&lt;/a&gt;</source>
          <target state="translated">Исправьте синтаксический анализатор, чтобы он принимал допустимый синтаксис &lt;a href=&quot;rowvalue&quot;&gt;значения строки&lt;/a&gt; . Билет &lt;a href=&quot;https://www.sqlite.org/src/info/7310e2fb3d046a5&quot;&gt;7310e2fb3d046a5&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="13f421298ab97922575edd88af10f5d60d0152b2" translate="yes" xml:space="preserve">
          <source>Fix the query optimizer to correctly handle constant expressions in the ON clause of a LEFT JOIN. Ticket #2403</source>
          <target state="translated">Исправлен оптимизатор запросов для корректной обработки константных выражений в пункте ON левого JOIN.Тикет #2403</target>
        </trans-unit>
        <trans-unit id="40584ba785f1b7ac57821c3d2f85216f2b32614c" translate="yes" xml:space="preserve">
          <source>Fix the query optimizer to handle rowid comparisons to NULL correctly. Ticket #2404</source>
          <target state="translated">Исправлена ошибка в оптимизаторе запросов,позволяющая корректно обрабатывать сравнения рядов с NULL.Билет #2404</target>
        </trans-unit>
        <trans-unit id="dfa9a47acf25a2f05ea48c9410e4c4747561d320" translate="yes" xml:space="preserve">
          <source>Fix the query planner so that IS and IS NULL operators are able to drive an index on a LEFT OUTER JOIN.</source>
          <target state="translated">Исправьте планировщик запросов таким образом,чтобы операторы IS и IS NULL могли управлять индексом на ЛЕВОМ ВЫХОДЕ.</target>
        </trans-unit>
        <trans-unit id="5653a698bc06b9d4be42b0c1c2f59e7a1e2b1d3a" translate="yes" xml:space="preserve">
          <source>Fix the query planner so that it knows not to use &lt;a href=&quot;optoverview#autoindex&quot;&gt;automatic indexes&lt;/a&gt; on the right table of LEFT JOIN if the WHERE clause uses the &lt;a href=&quot;lang_expr#isisnot&quot;&gt;IS operator&lt;/a&gt;. Fix for &lt;a href=&quot;https://sqlite.org/src/info/ce68383bf6aba&quot;&gt;ce68383bf6aba&lt;/a&gt;.</source>
          <target state="translated">Исправьте планировщик запросов, чтобы он знал, что нельзя использовать &lt;a href=&quot;optoverview#autoindex&quot;&gt;автоматические индексы&lt;/a&gt; в правой таблице LEFT JOIN, если в предложении WHERE используется &lt;a href=&quot;lang_expr#isisnot&quot;&gt;оператор IS&lt;/a&gt; . Исправление для &lt;a href=&quot;https://sqlite.org/src/info/ce68383bf6aba&quot;&gt;ce68383bf6aba&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f099fcbe9d8c0841133d0c1acb48be9e9aec8aff" translate="yes" xml:space="preserve">
          <source>Fix the query planner so that it takes into account dependencies in the arguments to table-valued functions in subexpressions in the WHERE clause. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/80177f0c226ff54&quot;&gt;80177f0c226ff54&lt;/a&gt;</source>
          <target state="translated">Исправьте планировщик запросов, чтобы он учитывал зависимости в аргументах функций с табличным значением в подвыражениях в предложении WHERE. Билет &lt;a href=&quot;https://www.sqlite.org/src/info/80177f0c226ff54&quot;&gt;80177f0c226ff54&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c51036bc7729aa3fd5a9f1ed633c206de4f498ea" translate="yes" xml:space="preserve">
          <source>Fix the query planner so that it works correctly for IS NOT NULL operators in the ON clause of a LEFT JOIN with the SQLITE_ENABLE_STAT4 compile-time option. &lt;a href=&quot;https://sqlite.org/src/info/65eb38f6e46de8c75e188a17ec&quot;&gt;65eb38f6e46de8c75e188a17ec&lt;/a&gt;</source>
          <target state="translated">Исправьте планировщик запросов, чтобы он работал правильно для операторов IS NOT NULL в предложении ON LEFT JOIN с параметром времени компиляции SQLITE_ENABLE_STAT4. &lt;a href=&quot;https://sqlite.org/src/info/65eb38f6e46de8c75e188a17ec&quot;&gt;65eb38f6e46de8c75e188a17ec&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2e67f4820003d691c4c8b5a0ce32d382b50cc512" translate="yes" xml:space="preserve">
          <source>Fix the regression test suite so that it works with Tcl8.5</source>
          <target state="translated">Исправить набор регрессионных тестов,чтобы он работал с Tcl8.5.</target>
        </trans-unit>
        <trans-unit id="6d468d38a1ed912125e5b1192b25781bdc29bb56" translate="yes" xml:space="preserve">
          <source>Fix the schema parser so that it interprets certain (obscure and ill-formed) CREATE TABLE statements the same as legacy. Fix for ticket &lt;a href=&quot;https://www.sqlite.org/src/info/ac661962a2aeab3c331&quot;&gt;ac661962a2aeab3c331&lt;/a&gt;</source>
          <target state="translated">Исправьте синтаксический анализатор схемы так, чтобы он интерпретировал некоторые (неясные и неправильно сформированные) операторы CREATE TABLE так же, как устаревшие. Исправление для билета &lt;a href=&quot;https://www.sqlite.org/src/info/ac661962a2aeab3c331&quot;&gt;ac661962a2aeab3c331&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="29c5cfa4d69ee4c85bc560fdea69b6008202a144" translate="yes" xml:space="preserve">
          <source>Fix to UPDATE triggers on TEMP tables.</source>
          <target state="translated">Исправление триггеров UPDATE на таблицах TEMP.</target>
        </trans-unit>
        <trans-unit id="8ac8e543b0bc738b6dc67d65d9b587bde27a9189" translate="yes" xml:space="preserve">
          <source>Fix to the --rbu option of &lt;a href=&quot;sqldiff&quot;&gt;sqldiff&lt;/a&gt;.</source>
          <target state="translated">Исправьте параметр --rbu в &lt;a href=&quot;sqldiff&quot;&gt;sqldiff&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="dce0daf2e8b6a6a74ce23add5bf251c814f89da9" translate="yes" xml:space="preserve">
          <source>Fix two bugs in the locking protocol. (One was masking the other.)</source>
          <target state="translated">Исправлены две ошибки в протоколе блокировки.(Одна маскировала другую.)</target>
        </trans-unit>
        <trans-unit id="140466bf745b30af0254a8472b1f139b069fbb53" translate="yes" xml:space="preserve">
          <source>Fix two bugs, which when combined might result in incorrect query results. Both bugs were harmless by themselves; only when they team up do they cause problems. Ticket #3581.</source>
          <target state="translated">Исправлены две ошибки,которые при объединении могли привести к некорректным результатам запроса.Обе ошибки были безвредны сами по себе;только когда они объединяются в команду,они создают проблемы.Билет #3581.</target>
        </trans-unit>
        <trans-unit id="e9669895532c079b8fe44ba1553500c34f15f036" translate="yes" xml:space="preserve">
          <source>Fix two long-standing bugs that allow malicious SQL statements to crash the process that is running SQLite. These bugs were announced by a third-party approximately 24 hours after the 3.32.0 release but are not specific to the 3.32.0 release.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6b3c2eac5340186aa60ec6ef1bd320d9af1b4cf" translate="yes" xml:space="preserve">
          <source>Fix two problems in the new &lt;a href=&quot;optoverview#leftjoinreduction&quot;&gt;LEFT JOIN strength reduction optimization&lt;/a&gt;. Tickets &lt;a href=&quot;https://sqlite.org/src/info/1e39b966ae9ee739&quot;&gt;1e39b966ae9ee739&lt;/a&gt; and &lt;a href=&quot;https://sqlite.org/src/info/fac496b61722daf2&quot;&gt;fac496b61722daf2&lt;/a&gt;.</source>
          <target state="translated">Исправьте две проблемы в новой &lt;a href=&quot;optoverview#leftjoinreduction&quot;&gt;оптимизации уменьшения силы LEFT JOIN&lt;/a&gt; . Билеты &lt;a href=&quot;https://sqlite.org/src/info/1e39b966ae9ee739&quot;&gt;1e39b966ae9ee739&lt;/a&gt; и &lt;a href=&quot;https://sqlite.org/src/info/fac496b61722daf2&quot;&gt;fac496b61722daf2&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ce60dbf83ec6124a3874f74bb112313a53e7aca8" translate="yes" xml:space="preserve">
          <source>Fix type coercion rules for the IN operator</source>
          <target state="translated">Исправить правила принуждения типа для оператора IN</target>
        </trans-unit>
        <trans-unit id="1ef59214b1b8979108ab36722686dbe71717d826" translate="yes" xml:space="preserve">
          <source>Fix typos in documentation.</source>
          <target state="translated">Исправить опечатки в документации.</target>
        </trans-unit>
        <trans-unit id="c5df6889e7873170528ac5b7149060416fb8a48c" translate="yes" xml:space="preserve">
          <source>Fix typos in the documentation</source>
          <target state="translated">Исправить опечатки в документации</target>
        </trans-unit>
        <trans-unit id="a8caeeab6423273de2d0f3b9037854eda089993c" translate="yes" xml:space="preserve">
          <source>Fix uninitialized variables causing malfunctions for various obscure queries</source>
          <target state="translated">Исправление неинициализированных переменных,приводивших к сбоям в работе при различных непонятных запросах</target>
        </trans-unit>
        <trans-unit id="334faf48b2d08d39ac3f83df69ba4313064d2eca" translate="yes" xml:space="preserve">
          <source>Fix various documentation typos</source>
          <target state="translated">Исправление различных опечаток документации</target>
        </trans-unit>
        <trans-unit id="bfc06020350fd18063be73e1e193870b6478ef89" translate="yes" xml:space="preserve">
          <source>Fix various other minor test script problems.</source>
          <target state="translated">Исправление различных других незначительных проблем с тестовым скриптом.</target>
        </trans-unit>
        <trans-unit id="04a80b08dce7f337318b3de8005ba6821f9088b9" translate="yes" xml:space="preserve">
          <source>Fix warning messages in VC++ 7.0. (Patches from nicolas352001)</source>
          <target state="translated">Исправление предупреждающих сообщений в VC++7.0.(Патчи от Николаса352001).</target>
        </trans-unit>
        <trans-unit id="e356e2b704a2e01de653ed2ebbf706f69ff2717e" translate="yes" xml:space="preserve">
          <source>Fixed &lt;b&gt;sqlite.h&lt;/b&gt; so that it is usable from C++</source>
          <target state="translated">Исправлен &lt;b&gt;sqlite.h,&lt;/b&gt; чтобы его можно было использовать из C ++</target>
        </trans-unit>
        <trans-unit id="79e373e30e82498299cb604bd835209f11c2361f" translate="yes" xml:space="preserve">
          <source>Fixed a bug in the &quot;copy&quot; method of the TCL interface.</source>
          <target state="translated">Исправлена ошибка в методе &quot;копирования&quot; интерфейса TCL.</target>
        </trans-unit>
        <trans-unit id="c148872cc8b9ab806e9be600a6bc5019b39f4b73" translate="yes" xml:space="preserve">
          <source>Fixed a bug in the processing of LEFT OUTER JOIN</source>
          <target state="translated">Исправлена ошибка в обработке ЛЕВОГО ВНЕШНЕГО СОВЕТА</target>
        </trans-unit>
        <trans-unit id="8958f58770783b2b2d9b98f41e760b01637c6fbf" translate="yes" xml:space="preserve">
          <source>Fixed a bug in the query planner that caused performance regressions relative to 3.6.23.1 on some complex joins.</source>
          <target state="translated">Исправлена ошибка в планировщике запросов,приводившая к регрессиям производительности относительно 3.6.23.1 на некоторых сложных соединениях.</target>
        </trans-unit>
        <trans-unit id="ce57a2f7dac9c404f24a8b0780affccd90fd36f4" translate="yes" xml:space="preserve">
          <source>Fixed a bug that caused database corruption when an &lt;a href=&quot;pragma#pragma_incremental_vacuum&quot;&gt;incremental_vacuum&lt;/a&gt; is rolled back in an in-memory database. Ticket #3761.</source>
          <target state="translated">Исправлена ​​ошибка, приводившая к повреждению базы данных при откате &lt;a href=&quot;pragma#pragma_incremental_vacuum&quot;&gt;incremental_vacuum&lt;/a&gt; в базе данных в памяти. Билет № 3761.</target>
        </trans-unit>
        <trans-unit id="47075269c498ed42295ff1e4b7548fb034943cbd" translate="yes" xml:space="preserve">
          <source>Fixed a bug that was causing updates to fail inside of transactions when the database contained a temporary table.</source>
          <target state="translated">Исправлена ошибка,приводившая к отказу обновлений внутри транзакций,когда база данных содержала временную таблицу.</target>
        </trans-unit>
        <trans-unit id="479bbff8b43af13fac5ef791395960b4f803b850" translate="yes" xml:space="preserve">
          <source>Fixed a critical bug in the &lt;a href=&quot;https://www.sqlite.org/see/doc/trunk/www/readme.wiki&quot;&gt;SQLite Encryption Extension&lt;/a&gt; that could cause the database to become unreadable and unrecoverable if a &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; command changed the size of the encryption nonce.</source>
          <target state="translated">Исправлена ​​критическая ошибка в &lt;a href=&quot;https://www.sqlite.org/see/doc/trunk/www/readme.wiki&quot;&gt;расширении шифрования SQLite&lt;/a&gt; , из-за которой база данных могла стать нечитаемой и невосстановимой, если команда &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; изменяла размер одноразового номера шифрования.</target>
        </trans-unit>
        <trans-unit id="59729403a0ff39e62d5592f59ad0496bc74d3cb0" translate="yes" xml:space="preserve">
          <source>Fixed a typo in the OS/2 backend.</source>
          <target state="translated">Исправлена опечатка в бэкэнде OS/2.</target>
        </trans-unit>
        <trans-unit id="639269284376af975435d947ede551d59f7c8a90" translate="yes" xml:space="preserve">
          <source>Fixed an off-by-one error that was causing a coredump in the '%q' format directive of the new &lt;b&gt;sqlite_..._printf()&lt;/b&gt; routines.</source>
          <target state="translated">Исправлена ​​ошибка нечеткости, которая приводила к отказу ядра в директиве формата '% q' новых &lt;b&gt;подпрограмм sqlite _..._ printf ()&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="2f93f642c24bc3ca9d72401aa0c30d511f868145" translate="yes" xml:space="preserve">
          <source>Fixed lots of spelling errors in the source-code comments</source>
          <target state="translated">Исправлено большое количество орфографических ошибок в комментариях к исходному коду</target>
        </trans-unit>
        <trans-unit id="fd59e954365ccfc713ffa89ef7eee7b8910b50c3" translate="yes" xml:space="preserve">
          <source>Fixed naming conflicts so that versions 2.8 and 3.0 can be linked and used together in the same ANSI-C source file.</source>
          <target state="translated">Исправлены конфликты именования,так что версии 2.8 и 3.0 можно было связывать и использовать вместе в одном исходном файле ANSI-C.</target>
        </trans-unit>
        <trans-unit id="8dc0276046c4c36ea547c5cf770bbba66b28361f" translate="yes" xml:space="preserve">
          <source>Fixed performance problems and potential stack overflows when creating &lt;a href=&quot;lang_createview&quot;&gt;views&lt;/a&gt; from multi-row VALUES clauses with hundreds of thousands of rows.</source>
          <target state="translated">Исправлены проблемы с производительностью и потенциальное переполнение стека при создании &lt;a href=&quot;lang_createview&quot;&gt;представлений&lt;/a&gt; из многострочных предложений VALUES с сотнями тысяч строк.</target>
        </trans-unit>
        <trans-unit id="48a5b411b131a16a7c3a81ff9ffe341d205ab7e3" translate="yes" xml:space="preserve">
          <source>Fixed some instances where &lt;b&gt;sqlite_exec()&lt;/b&gt; was returning the wrong error code.</source>
          <target state="translated">Исправлены некоторые случаи, когда &lt;b&gt;sqlite_exec ()&lt;/b&gt; возвращал неправильный код ошибки.</target>
        </trans-unit>
        <trans-unit id="d2abd59d7529d7221419b75d94eed0ee9277c4cd" translate="yes" xml:space="preserve">
          <source>Fixed the &quot;.dump&quot; command in the command-line shell to show indices, triggers and views again.</source>
          <target state="translated">Исправлена команда &quot;.dump&quot; в командной строке оболочки для повторного отображения индексов,триггеров и представлений.</target>
        </trans-unit>
        <trans-unit id="923cc8fbcaf6842679b5f1e15d6df83e508e85ec" translate="yes" xml:space="preserve">
          <source>Fixed the &lt;a href=&quot;lang_delete#truncateopt&quot;&gt;truncate optimization&lt;/a&gt; so that &lt;a href=&quot;c3ref/changes&quot;&gt;sqlite3_changes()&lt;/a&gt; and &lt;a href=&quot;c3ref/total_changes&quot;&gt;sqlite3_total_changes()&lt;/a&gt; interfaces and the &lt;a href=&quot;pragma#pragma_count_changes&quot;&gt;count_changes pragma&lt;/a&gt; return the correct values.</source>
          <target state="translated">Исправлена &lt;a href=&quot;lang_delete#truncateopt&quot;&gt;оптимизация усечения,&lt;/a&gt; так что интерфейсы &lt;a href=&quot;c3ref/changes&quot;&gt;sqlite3_changes ()&lt;/a&gt; и &lt;a href=&quot;c3ref/total_changes&quot;&gt;sqlite3_total_changes ()&lt;/a&gt; и &lt;a href=&quot;pragma#pragma_count_changes&quot;&gt;прагма count_changes&lt;/a&gt; возвращали правильные значения.</target>
        </trans-unit>
        <trans-unit id="9e28c4773e158241fde9583f9f170c5ef9db0282" translate="yes" xml:space="preserve">
          <source>Fixed the operator precedence for the ~ operator.</source>
          <target state="translated">Исправлен приоритет оператора для оператора ~.</target>
        </trans-unit>
        <trans-unit id="7effc13b7d809cd0670d65239ee3df045defba54" translate="yes" xml:space="preserve">
          <source>Fixes for various minor bugs.</source>
          <target state="translated">Исправление различных мелких ошибок.</target>
        </trans-unit>
        <trans-unit id="6db891bdea0dad81fb2181f92e7eface672bbf02" translate="yes" xml:space="preserve">
          <source>Fixes for various other compiler warnings and minor problems associated with obscure configurations.</source>
          <target state="translated">Исправление различных других предупреждений компилятора и мелких проблем,связанных с неясными конфигурациями.</target>
        </trans-unit>
        <trans-unit id="2582d7cc3520de6113cfebc05a4c0c40c10d2aea" translate="yes" xml:space="preserve">
          <source>Fixes to the rollback and locking behavior</source>
          <target state="translated">Исправлены ошибки при откате и блокировке</target>
        </trans-unit>
        <trans-unit id="300a0178f58415dda787e9c4b1d46e58f9cdc26d" translate="yes" xml:space="preserve">
          <source>FkCounter</source>
          <target state="translated">FkCounter</target>
        </trans-unit>
        <trans-unit id="a7826ae0da180dcf999c042085ef7ac58cfd77ff" translate="yes" xml:space="preserve">
          <source>FkIfZero</source>
          <target state="translated">FkIfZero</target>
        </trans-unit>
        <trans-unit id="a774409a00c21de377cf8ed5c6a56b8547973042" translate="yes" xml:space="preserve">
          <source>Flag</source>
          <target state="translated">Flag</target>
        </trans-unit>
        <trans-unit id="502eddf598188b96c0b40f89e8492bff9de3fa43" translate="yes" xml:space="preserve">
          <source>Flags For File Open Operations</source>
          <target state="translated">Флаги для операций открытия файла</target>
        </trans-unit>
        <trans-unit id="9e0bdeb766ef28db46f01b095bdb326b4da9f972" translate="yes" xml:space="preserve">
          <source>Flags consist of zero or more characters that immediately follow the &quot;%&quot; that introduces the substitution. The various flags and their meanings are as follows:</source>
          <target state="translated">Флаги состоят из нуля и более символов,которые следуют сразу за &quot;%&quot;,вводящим подстановку.Различные флаги и их значения следующие:</target>
        </trans-unit>
        <trans-unit id="e52973142fb5309e0599d0aece55b28093c55ec5" translate="yes" xml:space="preserve">
          <source>Flags for sqlite3_deserialize()</source>
          <target state="translated">Флаги для sqlite3_deserialize()</target>
        </trans-unit>
        <trans-unit id="763319af81f124ab801773d718a34a5b48132717" translate="yes" xml:space="preserve">
          <source>Flags for sqlite3_serialize</source>
          <target state="translated">Флаги для sqlite3_serialize</target>
        </trans-unit>
        <trans-unit id="f15088d96e03c231ed7711a618b87a23e40d38d1" translate="yes" xml:space="preserve">
          <source>Flags for sqlite3changeset_apply_v2</source>
          <target state="translated">Флаги для sqlite3changeset_apply_v2</target>
        </trans-unit>
        <trans-unit id="9c6b7b2401c21ffe043e97decac28ab2c77bcf8f" translate="yes" xml:space="preserve">
          <source>Flags for sqlite3changeset_start_v2</source>
          <target state="translated">Флаги для sqlite3changeset_start_v2</target>
        </trans-unit>
        <trans-unit id="8565c5e3d19dd91c15d8aea38675feb62cbfe94b" translate="yes" xml:space="preserve">
          <source>Flags for the xAccess VFS method</source>
          <target state="translated">Флаги для метода xAccess VFS</target>
        </trans-unit>
        <trans-unit id="caa91d141d9230cced8ac027e0837943663b4e27" translate="yes" xml:space="preserve">
          <source>Flags for the xShmLock VFS method</source>
          <target state="translated">Флаги для метода xShmLock VFS</target>
        </trans-unit>
        <trans-unit id="a4c5b52302ff6c09b0d29efa63650e0dd9711b0a" translate="yes" xml:space="preserve">
          <source>Flexible typing is considered a feature of SQLite, not a bug. Nevertheless, we recognize that this feature does sometimes cause confusion and pain for developers who are acustomed to working with other databases that are more judgemental with regard to data types. In retrospect, perhaps it would have been better if SQLite had merely implemented an ANY datatype so that developers could explicitly state when they wanted to use flexible typing, rather than making flexible typing the default. But that is not something that can be changed now without breaking the millions of applications and trillions of database files that already use SQLite's flexible typing feature.</source>
          <target state="translated">Гибкий набор текста считается особенностью SQLite,а не ошибкой.Тем не менее,мы признаем,что эта особенность иногда вызывает путаницу и боль у разработчиков,привыкших работать с другими базами данных,которые более судимы в отношении типов данных.Оглядываясь назад,возможно,было бы лучше,если бы SQLite просто реализовал ЛЮБОЙ тип данных,чтобы разработчики могли явно указывать,когда они хотят использовать гибкий набор текста,вместо того,чтобы делать гибкий набор текста по умолчанию.Но это не то,что можно изменить сейчас,не разбивая миллионы приложений и триллионы файлов баз данных,которые уже используют функцию гибкой печати SQLite.</target>
        </trans-unit>
        <trans-unit id="f7fca84542efdc71814460460268fade242aaf16" translate="yes" xml:space="preserve">
          <source>Flexible typing is considered a feature of SQLite, not a bug. Nevertheless, we recognize that this feature does sometimes cause confusion and pain for developers who are acustomed to working with other databases that are more judgmental with regard to data types. In retrospect, perhaps it would have been better if SQLite had merely implemented an ANY datatype so that developers could explicitly state when they wanted to use flexible typing, rather than making flexible typing the default. But that is not something that can be changed now without breaking the millions of applications and trillions of database files that already use SQLite's flexible typing feature.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="595acd952f7adef405182868a3f64d0a5da38dfd" translate="yes" xml:space="preserve">
          <source>Flock locking style. This is used for file-systems that do not support POSIX locking style. Locks are obtained and released using the flock() system call.</source>
          <target state="translated">Стиль блокировки замка.Используется для файловых систем,не поддерживающих стиль блокировки POSIX.Блокировки получаются и освобождаются с помощью системного вызова flock().</target>
        </trans-unit>
        <trans-unit id="c57073033af4c5995ecd6e60b89e343929d9d2c9" translate="yes" xml:space="preserve">
          <source>Flush all database file changes to the disk. Wait for those changes to actually be written onto the disk surface.</source>
          <target state="translated">Промойте все изменения файлов базы данных на диске.Подождите,пока эти изменения действительно будут записаны на поверхность диска.</target>
        </trans-unit>
        <trans-unit id="de39ff51371c017e6227bb21dd0f83307b8a58ff" translate="yes" xml:space="preserve">
          <source>Flush caches to disk mid-transaction</source>
          <target state="translated">Кэш флеш на диск в середине транзакции</target>
        </trans-unit>
        <trans-unit id="f57e8f8a92192df5f1207764618acfad2559efdf" translate="yes" xml:space="preserve">
          <source>Follow these steps to create your own virtual table:</source>
          <target state="translated">Следуйте этим шагам,чтобы создать свой собственный виртуальный стол:</target>
        </trans-unit>
        <trans-unit id="95cf2c9a54fa89f9d97591c92b0397a9def66730" translate="yes" xml:space="preserve">
          <source>Following a successful call to this function, it is the responsibility of the caller to eventually free the buffer that *ppChangeset points to using &lt;a href=&quot;../c3ref/free&quot;&gt;sqlite3_free()&lt;/a&gt;.</source>
          <target state="translated">После успешного вызова этой функции вызывающая сторона должна в конечном итоге освободить буфер, на который указывает * ppChangeset с помощью &lt;a href=&quot;../c3ref/free&quot;&gt;sqlite3_free ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="94243dad6fb7fd03cdf4ccdea9ad8045597be29a" translate="yes" xml:space="preserve">
          <source>Following a successful call to this function, it is the responsibility of the caller to eventually free the buffer that *ppChangeset points to using &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_free()&lt;/a&gt;.</source>
          <target state="translated">После успешного вызова этой функции вызывающая сторона должна в конечном итоге освободить буфер, на который указывает * ppChangeset с помощью &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_free ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6ecbb1f3edb4dd34a3fdff354068e2c4ff752166" translate="yes" xml:space="preserve">
          <source>Following a system recovery, if a device sector is deemed to be untrustworthy as defined by A21008 and neither A21011 or A21012 apply to the range of bytes written, then no assumption can be made about the content of the sector following recovery. It is assumed that it is possible for such a sector to be written correctly, not written at all, populated with garbage data or any combination thereof.</source>
          <target state="translated">После восстановления системы,если сектор устройства считается ненадежным в соответствии с определением A21008,и ни A21011,ни A21012 не относятся к диапазону записанных байтов,то после восстановления нельзя делать никаких предположений о содержимом сектора.Предполагается,что такой сектор может быть записан корректно,вовсе не записан,наполнен мусорными данными или любой их комбинацией.</target>
        </trans-unit>
        <trans-unit id="1945818b9ff5e13872866426c7d8f1fe8a043f70" translate="yes" xml:space="preserve">
          <source>Following the header is the array of coordinate pairs. Each coordinate is a 32-bit floating point number. The use of 32-bit floating point values for coordinates means that any point on the earth's surface can be mapped with a resolution of approximately 2.5 meters. Higher resolutions are of course possible if the map is restricted to a single continent or country. Note that the resolution of coordinates in the geopoly module is similar in magnitude to daily movement of points on the earth's surface due to tidal forces.</source>
          <target state="translated">За заголовком расположен массив пар координат.Каждая координата является 32-битным числом с плавающей точкой.Использование 32-битных значений с плавающей точкой для координат означает,что любая точка земной поверхности может быть нанесена на карту с разрешением примерно 2.5 метра.Более высокое разрешение,конечно,возможно,если карта ограничена одним континентом или страной.Отметим,что разрешение координат в геополитическом модуле аналогично суточному перемещению точек на земной поверхности под действием приливно-отливных сил.</target>
        </trans-unit>
        <trans-unit id="581c115a7d0dc8fd1981c305296d4c558b5b086c" translate="yes" xml:space="preserve">
          <source>Following the single big &quot;timeline&quot; query, there are additional queries for each timeline element. Fossil is using the &quot;N+1 Query&quot; pattern rather than trying to grab all the information in as few queries as possible. But that is ok because there is no unnecessary IPC overhead. At the bottom of each timeline page, Fossil shows approximately how long it took to generate the page. For a 50-entry timeline, the latency is usually less than 25 milliseconds. Profiling shows that few of those milliseconds were spent inside the database engine.</source>
          <target state="translated">После одного большого запроса &quot;хронологической шкалы&quot;,для каждого элемента хронологической шкалы существуют дополнительные запросы.Ископаемый использует шаблон &quot;N+1 запрос&quot; вместо того,чтобы пытаться собрать всю информацию в как можно меньшем количестве запросов.Но это нормально,потому что нет ненужных накладных расходов IPC.В нижней части каждой страницы шкалы времени Fossil показывает,сколько времени понадобилось для создания страницы.Для 50-входной временной шкалы задержка обычно составляет менее 25 миллисекунд.Профилирование показывает,что несколько из этих миллисекунд были потрачены внутри движка базы данных.</target>
        </trans-unit>
        <trans-unit id="19775ac9542956e84e3786d1a483a9c9a75b880c" translate="yes" xml:space="preserve">
          <source>For BLOBs smaller than 100KB, reads are faster when the BLOBs are stored directly in the database file. For BLOBs larger than 100KB, reads from a separate file are faster.</source>
          <target state="translated">Для BLOB размером менее 100KB,чтение происходит быстрее,когда BLOB-файлы хранятся непосредственно в файле базы данных.Для BLOB размером более 100KB,чтение из отдельного файла происходит быстрее.</target>
        </trans-unit>
        <trans-unit id="395ae193aa1eadd77633da6e02ed51db87786473" translate="yes" xml:space="preserve">
          <source>For SQLite</source>
          <target state="translated">Для SQLite</target>
        </trans-unit>
        <trans-unit id="f3c131948733abd40fff7115bdc1ab412d61d9a8" translate="yes" xml:space="preserve">
          <source>For SQLite version 2.6.3 and earlier, all values used the numeric datatype. The text datatype appears in version 2.7.0 and later. In the sequel it is assumed that you are using version 2.7.0 or later of SQLite.</source>
          <target state="translated">Для SQLite версии 2.6.3 и более ранних версий во всех значениях использовался цифровой тип данных.Текстовый тип данных появился в версии 2.7.0 и выше.В сиквеле предполагается,что вы используете SQLite версии 2.7.0 или более поздней.</target>
        </trans-unit>
        <trans-unit id="942453851992f474fda1456f6f181f26cf640d20" translate="yes" xml:space="preserve">
          <source>For SQLite versions prior to 3.24.0 (2018-06-04), the only information that an R*Tree index stores about an object is its integer ID and its bounding box. Additional information needs to be stored in separate tables and related to the R*Tree index using the primary key. For the example above, one might create an auxiliary table as follows:</source>
          <target state="translated">Для версий SQLite до 3.24.0 (2018-06-04)единственной информацией,которая хранится в R*Tree индексе об объекте,является его целочисленный ID и граничное поле.Дополнительная информация должна храниться в отдельных таблицах и относиться к индексу R*Tree с использованием первичного ключа.В приведенном выше примере можно создать вспомогательную таблицу следующим образом:</target>
        </trans-unit>
        <trans-unit id="50f58131252372876ea89c95a887df9a9f6004ed" translate="yes" xml:space="preserve">
          <source>For UTF-16 databases, when using the &quot;simple&quot; tokenizer, it is possible to use malformed unicode strings to cause the &lt;a href=&quot;#integcheck&quot;&gt;integrity-check special command&lt;/a&gt; to falsely report corruption, or for &lt;a href=&quot;#snippet&quot;&gt;auxiliary functions&lt;/a&gt; to return incorrect results. More specifically, the bug can be triggered by any of the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a64fca4030b56c7de05a5fe2b410b314416229df" translate="yes" xml:space="preserve">
          <source>For UTF16 input text to the sqlite3_result_text16(), sqlite3_result_text16be(), sqlite3_result_text16le(), and sqlite3_result_text64() routines, if the text contains invalid UTF16 characters, the invalid characters might be converted into the unicode replacement character, U+FFFD.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55b4a9ef398b6737e332f74269051f6a928aaf6c" translate="yes" xml:space="preserve">
          <source>For a &lt;b&gt;DELETE&lt;/b&gt; change, the payload consists of the PRIMARY KEY fields only. The original values of other fields are not stored as part of a patchset.</source>
          <target state="translated">Для изменения &lt;b&gt;DELETE&lt;/b&gt; полезная нагрузка состоит только из полей PRIMARY KEY. Исходные значения других полей не сохраняются как часть набора исправлений.</target>
        </trans-unit>
        <trans-unit id="bad0ea706b018c5833dc966db96c3bbf3f0b2138" translate="yes" xml:space="preserve">
          <source>For a JOIN or INNER JOIN or CROSS JOIN, there is no difference between a constraint expression in the WHERE clause and one in the ON clause. However, for a LEFT JOIN or LEFT OUTER JOIN, the difference is very important. In a LEFT JOIN, the extra NULL row for the right-hand table is added after ON clause processing but before WHERE clause processing. A constraint of the form &quot;left.x=right.y&quot; in an ON clause will therefore allow through the added all-NULL rows of the right table. But if that same constraint is in the WHERE clause a NULL in &quot;right.y&quot; will prevent the expression &quot;left.x=right.y&quot; from being true, and thus exclude that row from the output.</source>
          <target state="translated">Для JOIN,INNER JOIN или CROSS JOIN нет никакой разницы между выражением ограничения в пункте WHERE и в пункте ON.Однако для ЛЕВОГО СОЮЗА или ЛЕВОГО ВЫШЕГО СОЮЗА различие очень важно.В LEFT JOIN дополнительная строка NULL для правой таблицы добавляется после обработки пункта ON,но перед обработкой пункта WHERE.Ограничение формы &quot;left.x=right.y&quot; в положении ON позволит,таким образом,пропустить через добавленные all-NULL строки правой таблицы.Но если это же ограничение находится в предложении WHERE,то NULL в выражении &quot;right.y&quot; будет препятствовать тому,чтобы выражение &quot;left.x=right.y&quot; было истинным,и,таким образом,исключит эту строку из вывода.</target>
        </trans-unit>
        <trans-unit id="2837a8bb64314525a9077bf3440c2ed144dbb1b8" translate="yes" xml:space="preserve">
          <source>For a LEFT OUTER JOIN the situation is more complex. The following two queries are not equivalent:</source>
          <target state="translated">Для ЛЕВОГО ВНЕШНЕГО СОВЕТА ситуация более сложная.Следующие два запроса не эквивалентны:</target>
        </trans-unit>
        <trans-unit id="ad715a95908c984b7542ffaa9563f1288257e6ce" translate="yes" xml:space="preserve">
          <source>For a SELECT query that uses the full-text index, the offsets() function returns a text value containing a series of space-separated integers. For each term in each &lt;a href=&quot;#matchable&quot;&gt;phrase match&lt;/a&gt; of the current row, there are four integers in the returned list. Each set of four integers is interpreted as follows:</source>
          <target state="translated">Для запроса SELECT, использующего полнотекстовый индекс, функция offsets () возвращает текстовое значение, содержащее серию целых чисел, разделенных пробелами. Для каждого термина в каждом &lt;a href=&quot;#matchable&quot;&gt;фразовом совпадении&lt;/a&gt; текущей строки в возвращаемом списке есть четыре целых числа. Каждый набор из четырех целых чисел интерпретируется следующим образом:</target>
        </trans-unit>
        <trans-unit id="6eca1d9c3f6f9db89f4bb4081945f8167605d308" translate="yes" xml:space="preserve">
          <source>For a command of the form &quot;REINDEX</source>
          <target state="translated">Для команды формы &quot;REINDEX</target>
        </trans-unit>
        <trans-unit id="06d5551761da6c159b879a307caa21c04cdacf8a" translate="yes" xml:space="preserve">
          <source>For a commit involving multiple databases and a master journal, if the various databases were on different disk volumes and a power failure occurs during the commit, then when the machine comes back up the disks might be remounted with different names. Or some disks might not be mounted at all. When this happens the individual file journals and the master journal might not be able to find each other. The worst outcome from this scenario is that the commit ceases to be atomic. Some databases might be rolled back and others might not. All databases will continue to be self-consistent. To defend against this problem, keep all databases on the same disk volume and/or remount disks using exactly the same names after a power failure.</source>
          <target state="translated">Для коммита с несколькими базами данных и основным журналом,если различные базы данных находились на разных томах дисков и во время коммита произошел сбой питания,то при возвращении машины обратно диски могут быть заново смонтированы с разными именами.Или некоторые диски могут быть вообще не смонтированы.Когда это происходит,отдельные файловые журналы и главный журнал могут не найти друг друга.Худшим результатом этого сценария является то,что коммит перестаёт быть атомарным.Некоторые базы данных могут быть откачены,а другие-нет.Все базы данных будут продолжать быть самосогласованными.Чтобы защититься от этой проблемы,держите все базы данных на одном томе диска и/или перемонтируйте диски,используя точно такие же имена после отключения питания.</target>
        </trans-unit>
        <trans-unit id="e40bdd6eb01aba5fc405b17e2bcc433fd88a3c9f" translate="yes" xml:space="preserve">
          <source>For a commit involving multiple databases and a super-journal, if the various databases were on different disk volumes and a power failure occurs during the commit, then when the machine comes back up the disks might be remounted with different names. Or some disks might not be mounted at all. When this happens the individual file journals and the super-journal might not be able to find each other. The worst outcome from this scenario is that the commit ceases to be atomic. Some databases might be rolled back and others might not. All databases will continue to be self-consistent. To defend against this problem, keep all databases on the same disk volume and/or remount disks using exactly the same names after a power failure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb9e9e569c28385b62c9d2cc5d8fba70bcf036db" translate="yes" xml:space="preserve">
          <source>For a directory entry, any value inserted into this field is ignored. Otherwise, if it is set to 0, then the file data or symbolic link target is stored as is in the zip archive and the compression method set to 0. If it is set to 8, then the file data or link target is compressed using deflate compression before it is stored and the compression method set to 8. Finally, if a NULL value is written to this field, the zipfile module automatically decides whether or not to compress the data before storing it.</source>
          <target state="translated">Для записи записной книжки любое значение,вставленное в это поле,игнорируется.В противном случае,если оно установлено в 0,то данные файла или цель символической ссылки сохраняются как есть в zip-архиве,а метод сжатия устанавливается в 0.Если оно установлено в 8,то данные файла или цель ссылки перед хранением сжимаются с помощью сдувающего сжатия,а метод сжатия устанавливается в 8.Наконец,если в это поле записано значение NULL,то модуль zip-архива автоматически решает,сжимать данные перед их хранением или нет.</target>
        </trans-unit>
        <trans-unit id="60b588cb6440e5757b3bffacb57c3da76e66f360" translate="yes" xml:space="preserve">
          <source>For a listing of the available dot commands, you can enter &quot;.help&quot; with no arguments. Or enter &quot;.help TOPIC&quot; for detailed information about TOPIC. The list of available dot-commands follows:</source>
          <target state="translated">Для списка доступных точечных команд можно ввести &quot;.help&quot; без аргументов.Или введите &quot;.help TOPIC&quot; для получения подробной информации о TOPIC.Далее следует список доступных точечных команд:</target>
        </trans-unit>
        <trans-unit id="d4baaae0b83211d05bdb6a6f17481963667e90c7" translate="yes" xml:space="preserve">
          <source>For a program that uses an SQLite database as its &lt;a href=&quot;appfileformat&quot;&gt;application file-format&lt;/a&gt;, when a new database instance is first created the &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; command is ineffective because the database contain no data from which to gather statistics. In that case, one could construct a large prototype database containing typical data during development and run the &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; command on this prototype database to gather statistics, then save the prototype statistics as part of the application. After deployment, when the application goes to create a new database file, it can run the &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; command in order to create the statistics tables, then copy the precomputed statistics obtained from the prototype database into these new statistics tables. In that way, statistics from large working data sets can be preloaded into newly created application files.</source>
          <target state="translated">Для программы, которая использует базу данных SQLite в качестве &lt;a href=&quot;appfileformat&quot;&gt;формата файла приложения&lt;/a&gt; , при первом создании нового экземпляра базы данных команда &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; неэффективна, поскольку база данных не содержит данных, из которых можно было бы собирать статистику. В этом случае можно создать большую базу данных прототипа, содержащую типичные данные во время разработки, и запустить команду &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; для этой базы данных прототипа для сбора статистики, а затем сохранить статистику прототипа как часть приложения. После развертывания, когда приложение переходит к созданию нового файла базы данных, оно может запустить &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt;для создания таблиц статистики, затем скопируйте предварительно вычисленную статистику, полученную из базы данных прототипа, в эти новые таблицы статистики. Таким образом, статистика из больших наборов рабочих данных может быть предварительно загружена во вновь созданные файлы приложения.</target>
        </trans-unit>
        <trans-unit id="a94574556e6541171dc1e77628bd7786ebcc44a5" translate="yes" xml:space="preserve">
          <source>For a row-value &lt;a href=&quot;lang_expr#in_op&quot;&gt;IN operator&lt;/a&gt;, the left-hand side (hereafter &quot;LHS&quot;) can be either a parenthesized list of values or a subquery with multiple columns. But the right-hand side (hereafter &quot;RHS&quot;) must be a subquery expression.</source>
          <target state="translated">Для &lt;a href=&quot;lang_expr#in_op&quot;&gt;оператора IN со&lt;/a&gt; значением строки левая сторона (далее &amp;laquo;LHS&amp;raquo;) может быть либо списком значений в скобках, либо подзапросом с несколькими столбцами. Но правая часть (далее &amp;laquo;RHS&amp;raquo;) должна быть выражением подзапроса.</target>
        </trans-unit>
        <trans-unit id="1f6b45d36586c69d55b8983f8d799c1d8e89a8c6" translate="yes" xml:space="preserve">
          <source>For a string value X, the length(X) function returns the number of characters (not bytes) in X prior to the first NUL character. Since SQLite strings do not normally contain NUL characters, the length(X) function will usually return the total number of characters in the string X. For a blob value X, length(X) returns the number of bytes in the blob. If X is NULL then length(X) is NULL. If X is numeric then length(X) returns the length of a string representation of X.</source>
          <target state="translated">Для строкового значения X функция length(X)возвращает количество символов (не байт)в X до первого символа NUL.Так как строки SQLite обычно не содержат NUL символов,функция length(X)обычно возвращает общее количество символов в строке X.Для блока значения X,length(X)возвращает количество байт в блоке.Если X равно NULL,то length(X)равно NULL.Если X-числовое значение,то length(X)возвращает длину строкового представления X.</target>
        </trans-unit>
        <trans-unit id="d7e042b4a217a46e364221bac2287b2e16ce5e8f" translate="yes" xml:space="preserve">
          <source>For added readability, also set &quot;.echo on&quot; so that the output contains the original SQL text.</source>
          <target state="translated">Для дополнительной удобочитаемости,также установите &quot;.echo on&quot; так,чтобы вывод содержал исходный текст SQL.</target>
        </trans-unit>
        <trans-unit id="464bd448fbdde2a69f1880b4aadf91dc5c60e76e" translate="yes" xml:space="preserve">
          <source>For additional information on how the SQLite library functions, the reader is directed to look at the SQLite source code directly. If you understand the material in this article, you should not have much difficulty in following the sources. Serious students of the internals of SQLite will probably also want to make a careful study of the VDBE opcodes as documented &lt;a href=&quot;opcode&quot;&gt;here&lt;/a&gt;. Most of the opcode documentation is extracted from comments in the source code using a script so you can also get information about the various opcodes directly from the &lt;b&gt;vdbe.c&lt;/b&gt; source file. If you have successfully read this far, you should have little difficulty understanding the rest.</source>
          <target state="translated">Для получения дополнительной информации о том, как работает библиотека SQLite, читатель может напрямую ознакомиться с исходным кодом SQLite. Если вы понимаете материал этой статьи, у вас не должно возникнуть особых трудностей в использовании источников. Серьезные изучающие внутреннее устройство SQLite, вероятно, также захотят внимательно изучить коды операций VDBE, как описано &lt;a href=&quot;opcode&quot;&gt;здесь&lt;/a&gt; . Большая часть документации по кодам операций извлекается из комментариев в исходном коде с помощью сценария, поэтому вы также можете получить информацию о различных &lt;b&gt;кодах&lt;/b&gt; операций непосредственно из исходного файла &lt;b&gt;vdbe.c.&lt;/b&gt; Если вы успешно дочитали до этого места, вам не составит труда понять остальное.</target>
        </trans-unit>
        <trans-unit id="5cc0c6c827845b6d255c4013e6ccd3c888188ba4" translate="yes" xml:space="preserve">
          <source>For aggregate functions, the &lt;b&gt;xStep&lt;/b&gt; callback is invoked once for each row in the result and then &lt;b&gt;xFinalize&lt;/b&gt; is invoked at the end to compute a final answer. The xStep routine can use the &lt;b&gt;sqlite_aggregate_context()&lt;/b&gt; interface to allocate memory that will be unique to that particular instance of the SQL function. This memory will be automatically deleted after xFinalize is called. The &lt;b&gt;sqlite_aggregate_count()&lt;/b&gt; routine can be used to find out how many rows of data were passed to the aggregate. The xFinalize callback should invoke one of the &lt;b&gt;sqlite_set_result_...&lt;/b&gt; interfaces to set the final result of the aggregate.</source>
          <target state="translated">Для агрегатных функций &lt;b&gt;обратный&lt;/b&gt; вызов &lt;b&gt;xStep&lt;/b&gt; вызывается один раз для каждой строки результата, а затем в &lt;b&gt;конце&lt;/b&gt; вызывается &lt;b&gt;xFinalize&lt;/b&gt; для вычисления окончательного ответа. Подпрограмма xStep может использовать интерфейс &lt;b&gt;sqlite_aggregate_context ()&lt;/b&gt; для выделения памяти, которая будет уникальной для этого конкретного экземпляра функции SQL. Эта память будет автоматически удалена после вызова xFinalize. &lt;b&gt;Sqlite_aggregate_count ()&lt;/b&gt; процедура может быть использована , чтобы узнать, сколько строк данных были переданы в совокупности. Обратный вызов xFinalize должен вызывать один из интерфейсов &lt;b&gt;sqlite_set_result _...&lt;/b&gt; для установки окончательного результата агрегирования.</target>
        </trans-unit>
        <trans-unit id="4a2b8e655022b370f7bf1cade1de14d9df62358a" translate="yes" xml:space="preserve">
          <source>For all of these errors, SQLite attempts to undo just the one statement it was working on and leave changes from prior statements within the same transaction intact and continue with the transaction. However, depending on the statement being evaluated and the point at which the error occurs, it might be necessary for SQLite to rollback and cancel the entire transaction. An application can tell which course of action SQLite took by using the &lt;a href=&quot;c3ref/get_autocommit&quot;&gt;sqlite3_get_autocommit()&lt;/a&gt; C-language interface.</source>
          <target state="translated">Для всех этих ошибок SQLite пытается отменить только один оператор, над которым он работал, и оставить изменения из предыдущих операторов в той же транзакции без изменений и продолжить транзакцию. Однако, в зависимости от оцениваемого оператора и точки, в которой возникает ошибка, SQLite может потребоваться откат и отмена всей транзакции. Приложение может определить, какой курс действий предпринял SQLite, с помощью интерфейса языка Си &lt;a href=&quot;c3ref/get_autocommit&quot;&gt;sqlite3_get_autocommit ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="edd867afbc99c464b46e982c8bdb271f01de00a1" translate="yes" xml:space="preserve">
          <source>For all versions of SQLite up to and including 3.6.23.1, a call to &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset()&lt;/a&gt; was required after sqlite3_step() returned anything other than &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ROW&lt;/a&gt; before any subsequent invocation of sqlite3_step(). Failure to reset the prepared statement using &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset()&lt;/a&gt; would result in an &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_MISUSE&lt;/a&gt; return from sqlite3_step(). But after &lt;a href=&quot;https://sqlite.org/releaselog/3_6_23_1.html&quot;&gt;version 3.6.23.1&lt;/a&gt; (2010-03-26, sqlite3_step() began calling &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset()&lt;/a&gt; automatically in this circumstance rather than returning &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_MISUSE&lt;/a&gt;. This is not considered a compatibility break because any application that ever receives an SQLITE_MISUSE error is broken by definition. The &lt;a href=&quot;compile#omit_autoreset&quot;&gt;SQLITE_OMIT_AUTORESET&lt;/a&gt; compile-time option can be used to restore the legacy behavior.</source>
          <target state="translated">Для всех версий SQLite до 3.6.23.1 включительно вызов &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset ()&lt;/a&gt; требовался после того, как sqlite3_step () вернул что-либо, кроме &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ROW,&lt;/a&gt; перед любым последующим вызовом sqlite3_step (). Невозможность сбросить подготовленный оператор с помощью &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset ()&lt;/a&gt; приведет к возврату &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_MISUSE&lt;/a&gt; из sqlite3_step (). Но после &lt;a href=&quot;https://sqlite.org/releaselog/3_6_23_1.html&quot;&gt;версии 3.6.23.1&lt;/a&gt; ( 26.03.2010 , sqlite3_step () в этом случае начала автоматически вызывать &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset (),&lt;/a&gt; а не возвращать &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_MISUSE&lt;/a&gt; . Это не считается нарушением совместимости, потому что любое приложение, которое когда-либо получало ошибку SQLITE_MISUSE, нарушается по определению . &lt;a href=&quot;compile#omit_autoreset&quot;&gt;SQLITE_OMIT_AUTORESET&lt;/a&gt;Параметр времени компиляции может использоваться для восстановления прежнего поведения.</target>
        </trans-unit>
        <trans-unit id="c8ec8a08c58f886e596c21082f16011397cbdb2b" translate="yes" xml:space="preserve">
          <source>For all versions of SQLite up to and including 3.6.23.1, a call to &lt;a href=&quot;reset&quot;&gt;sqlite3_reset()&lt;/a&gt; was required after sqlite3_step() returned anything other than &lt;a href=&quot;../rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt; before any subsequent invocation of sqlite3_step(). Failure to reset the prepared statement using &lt;a href=&quot;reset&quot;&gt;sqlite3_reset()&lt;/a&gt; would result in an &lt;a href=&quot;../rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt; return from sqlite3_step(). But after &lt;a href=&quot;https://sqlite.org/releaselog/3_6_23_1.html&quot;&gt;version 3.6.23.1&lt;/a&gt; (2010-03-26, sqlite3_step() began calling &lt;a href=&quot;reset&quot;&gt;sqlite3_reset()&lt;/a&gt; automatically in this circumstance rather than returning &lt;a href=&quot;../rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt;. This is not considered a compatibility break because any application that ever receives an SQLITE_MISUSE error is broken by definition. The &lt;a href=&quot;../compile#omit_autoreset&quot;&gt;SQLITE_OMIT_AUTORESET&lt;/a&gt; compile-time option can be used to restore the legacy behavior.</source>
          <target state="translated">Для всех версий SQLite до 3.6.23.1 включительно вызов &lt;a href=&quot;reset&quot;&gt;sqlite3_reset ()&lt;/a&gt; требовался после того, как sqlite3_step () вернул что-либо, кроме &lt;a href=&quot;../rescode#row&quot;&gt;SQLITE_ROW,&lt;/a&gt; перед любым последующим вызовом sqlite3_step (). Невозможность сбросить подготовленный оператор с помощью &lt;a href=&quot;reset&quot;&gt;sqlite3_reset ()&lt;/a&gt; приведет к возврату &lt;a href=&quot;../rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt; из sqlite3_step (). Но после &lt;a href=&quot;https://sqlite.org/releaselog/3_6_23_1.html&quot;&gt;версии 3.6.23.1&lt;/a&gt; ( 26.03.2010 , sqlite3_step () в этом случае начала автоматически вызывать &lt;a href=&quot;reset&quot;&gt;sqlite3_reset (),&lt;/a&gt; а не возвращать &lt;a href=&quot;../rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt; . Это не считается нарушением совместимости, потому что любое приложение, которое когда-либо получало ошибку SQLITE_MISUSE, нарушается по определению . &lt;a href=&quot;../compile#omit_autoreset&quot;&gt;SQLITE_OMIT_AUTORESET&lt;/a&gt;Параметр времени компиляции может использоваться для восстановления прежнего поведения.</target>
        </trans-unit>
        <trans-unit id="cb3ef573edb29303f7422a9886c28f0ac60f646d" translate="yes" xml:space="preserve">
          <source>For allocators other than &lt;a href=&quot;malloc#memsys5&quot;&gt;memsys5&lt;/a&gt;, all memory allocations are of the same size. Hence, &lt;b&gt;n&lt;/b&gt;=1 and therefore &lt;b&gt;N&lt;/b&gt;=&lt;b&gt;M&lt;/b&gt;. In other words, the memory pool need be no larger than the largest amount of memory in use at any given moment.</source>
          <target state="translated">Для других распределителей, кроме &lt;a href=&quot;malloc#memsys5&quot;&gt;memsys5&lt;/a&gt; , все выделения памяти имеют одинаковый размер. Следовательно, &lt;b&gt;п&lt;/b&gt; = 1 и , следовательно , &lt;b&gt;N&lt;/b&gt; = &lt;b&gt;M&lt;/b&gt; . Другими словами, пул памяти должен быть не больше, чем самый большой объем памяти, используемый в любой данный момент.</target>
        </trans-unit>
        <trans-unit id="a2e786b5782b352cf04ddbf2d2c01d46af6ed148" translate="yes" xml:space="preserve">
          <source>For an &lt;b&gt;UPDATE&lt;/b&gt; change, the payload consists of the PRIMARY KEY fields and the new values of modified fields only. The original values of modified fields are not stored as part of a patchset.</source>
          <target state="translated">Для изменения &lt;b&gt;UPDATE&lt;/b&gt; полезная нагрузка состоит только из полей PRIMARY KEY и новых значений измененных полей. Исходные значения измененных полей не сохраняются как часть набора исправлений.</target>
        </trans-unit>
        <trans-unit id="87c8bcb65c916a4e76edf02935c7238f192ed71f" translate="yes" xml:space="preserve">
          <source>For an UPDATE or DELETE operation on a &lt;a href=&quot;../rowidtable&quot;&gt;rowid table&lt;/a&gt;, the sixth parameter passed to the preupdate callback is the initial &lt;a href=&quot;../lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; of the row being modified or deleted. For an INSERT operation on a rowid table, or any operation on a WITHOUT ROWID table, the value of the sixth parameter is undefined. For an INSERT or UPDATE on a rowid table the seventh parameter is the final rowid value of the row being inserted or updated. The value of the seventh parameter passed to the callback function is not defined for operations on WITHOUT ROWID tables, or for INSERT operations on rowid tables.</source>
          <target state="translated">Для операции UPDATE или DELETE в &lt;a href=&quot;../rowidtable&quot;&gt;таблице&lt;/a&gt; rowid шестой параметр, переданный в обратный вызов preupdate, является начальным &lt;a href=&quot;../lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; изменяемой или удаляемой строки. Для операции INSERT в таблице rowid или любой операции в таблице WITHOUT ROWID значение шестого параметра не определено. Для INSERT или UPDATE в таблице rowid седьмой параметр - это последнее значение rowid вставляемой или обновляемой строки. Значение седьмого параметра, переданного в функцию обратного вызова, не определено для операций с таблицами БЕЗ ROWID или для операций INSERT с таблицами идентификаторов строк.</target>
        </trans-unit>
        <trans-unit id="3fa74a389b030ce220f00901508abe1120507900" translate="yes" xml:space="preserve">
          <source>For an UPDATE or DELETE operation on a &lt;a href=&quot;rowidtable&quot;&gt;rowid table&lt;/a&gt;, the sixth parameter passed to the preupdate callback is the initial &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; of the row being modified or deleted. For an INSERT operation on a rowid table, or any operation on a WITHOUT ROWID table, the value of the sixth parameter is undefined. For an INSERT or UPDATE on a rowid table the seventh parameter is the final rowid value of the row being inserted or updated. The value of the seventh parameter passed to the callback function is not defined for operations on WITHOUT ROWID tables, or for INSERT operations on rowid tables.</source>
          <target state="translated">Для операции UPDATE или DELETE в &lt;a href=&quot;rowidtable&quot;&gt;таблице&lt;/a&gt; rowid шестой параметр, переданный в обратный вызов preupdate, является начальным &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; изменяемой или удаляемой строки. Для операции INSERT в таблице rowid или любой операции в таблице WITHOUT ROWID значение шестого параметра не определено. Для INSERT или UPDATE в таблице rowid седьмой параметр - это последнее значение rowid вставляемой или обновляемой строки. Значение седьмого параметра, переданного в функцию обратного вызова, не определено для операций с таблицами БЕЗ ROWID или для операций INSERT с таблицами идентификаторов строк.</target>
        </trans-unit>
        <trans-unit id="6babaeb551e0ac84ca65632772689ec35209b982" translate="yes" xml:space="preserve">
          <source>For an example of an INSTEAD OF trigger, consider the following schema:</source>
          <target state="translated">Для примера ИНСТЕЙДА ВЫКЛЮЧЕНИЯ триггера рассмотрим следующую схему:</target>
        </trans-unit>
        <trans-unit id="1cb2ec7dc6172161d64c33e9d01d6ab6fb648efe" translate="yes" xml:space="preserve">
          <source>For an expression, the datatype of the result is often determined by the outermost operator. For example, arithmetic operators (&quot;+&quot;, &quot;*&quot;, &quot;%&quot;) always return a numeric results. The string concatenation operator (&quot;||&quot;) returns a text result. And so forth. If you are ever in doubt about the datatype of an expression you can use the special &lt;b&gt;typeof()&lt;/b&gt; SQL function to determine what the datatype is. For example:</source>
          <target state="translated">Для выражения тип данных результата часто определяется внешним оператором. Например, арифметические операторы (&amp;laquo;+&amp;raquo;, &amp;laquo;*&amp;raquo;, &amp;laquo;%&amp;raquo;) всегда возвращают числовые результаты. Оператор конкатенации строк (&amp;laquo;||&amp;raquo;) возвращает текстовый результат. И так далее. Если вы когда-либо сомневаетесь в типе данных выражения, вы можете использовать специальную функцию SQL &lt;b&gt;typeof (),&lt;/b&gt; чтобы определить, что это за тип данных. Например:</target>
        </trans-unit>
        <trans-unit id="8771671648f56259c0348d58066fbd244a9f5761" translate="yes" xml:space="preserve">
          <source>For an inner join, the two queries above would be identical. But special processing applies to the ON and USING clauses of an OUTER join: specifically, the constraints in an ON or USING clause do not apply if the right table of the join is on a null row, but the constraints do apply in the WHERE clause. The net effect is that putting the ON or USING clause expressions for a LEFT JOIN in the WHERE clause effectively converts the query to an ordinary INNER JOIN - albeit an inner join that runs more slowly.</source>
          <target state="translated">Для внутреннего соединения два вышеприведенных запроса были бы идентичны.Но специальная обработка применяется к пунктам ON и USING ВНЕШНЕГО соединения:в частности,ограничения в пункте ON или USING не применяются,если правая таблица соединения находится в нулевой строке,но ограничения применяются в пункте WHERE.Чистый эффект заключается в том,что помещение выражений в пункте ON или USING для LEFT JOIN в пункте WHERE эффективно преобразует запрос в обычное INNER JOIN-хотя внутренний join работает медленнее.</target>
        </trans-unit>
        <trans-unit id="a4c04f89a73080a41ad80cd0704141b22ed403a6" translate="yes" xml:space="preserve">
          <source>For an ordinary on-disk database file, the serialization is just a copy of the disk file. For an in-memory database or a &quot;TEMP&quot; database, the serialization is the same sequence of bytes which would be written to disk if that database where backed up to disk.</source>
          <target state="translated">Для обычного файла базы данных на диске сериализация является просто копией дискового файла.Для базы данных,хранящейся в памяти,или базы данных &quot;TEMP&quot;,сериализация представляет собой ту же последовательность байт,которая была бы записана на диск,если бы эта база данных была скопирована на диск.</target>
        </trans-unit>
        <trans-unit id="363689c9e649bf1c45ea48634a5a7f396dccdc2a" translate="yes" xml:space="preserve">
          <source>For any given SQL statement, there might be hundreds or thousands or even millions of different algorithms of performing the operation. All of these algorithms will get the correct answer, though some will run faster than others. The query planner is an &lt;a href=&quot;https://en.wikipedia.org/wiki/Artificial_intelligence&quot;&gt;AI&lt;/a&gt; that tries to pick the fastest and most efficient algorithm for each SQL statement.</source>
          <target state="translated">Для любого данного оператора SQL могут существовать сотни, тысячи или даже миллионы различных алгоритмов выполнения операции. Все эти алгоритмы дадут правильный ответ, хотя некоторые из них будут работать быстрее, чем другие. Планировщик запросов - это &lt;a href=&quot;https://en.wikipedia.org/wiki/Artificial_intelligence&quot;&gt;ИИ,&lt;/a&gt; который пытается выбрать самый быстрый и эффективный алгоритм для каждого оператора SQL.</target>
        </trans-unit>
        <trans-unit id="20178a76e031f6e0dd46cd965f669f77257d11d8" translate="yes" xml:space="preserve">
          <source>For any given query, the fact that the OR-clause optimization described here can be used does not guarantee that it will be used. SQLite uses a cost-based query planner that estimates the CPU and disk I/O costs of various competing query plans and chooses the plan that it thinks will be the fastest. If there are many OR terms in the WHERE clause or if some of the indices on individual OR-clause subterms are not very selective, then SQLite might decide that it is faster to use a different query algorithm, or even a full-table scan. Application developers can use the &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; prefix on a statement to get a high-level overview of the chosen query strategy.</source>
          <target state="translated">Для любого заданного запроса тот факт, что можно использовать оптимизацию с предложением OR, описанную здесь, не гарантирует, что он будет использоваться. SQLite использует планировщик запросов на основе затрат, который оценивает затраты ЦП и дискового ввода-вывода для различных конкурирующих планов запросов и выбирает план, который, по его мнению, будет самым быстрым. Если в предложении WHERE содержится много терминов OR или если некоторые индексы в отдельных подтерминах OR-clause не очень избирательны, то SQLite может решить, что быстрее использовать другой алгоритм запроса или даже сканирование всей таблицы. Разработчики приложений могут использовать префикс &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; в операторе, чтобы получить общий обзор выбранной стратегии запроса.</target>
        </trans-unit>
        <trans-unit id="16c7cb0ca5e5ce3a2a0070ff33c0953ef0a2395f" translate="yes" xml:space="preserve">
          <source>For any historical version of SQLite, the source tree can be obtained from the &lt;a href=&quot;http://www.fossil-scm.org/&quot;&gt;Fossil&lt;/a&gt; version control system, either downloading a tarball or ZIP archive for a specific version, or by cloning the entire project history.</source>
          <target state="translated">Для любой исторической версии SQLite дерево исходного кода можно получить из системы управления версиями &lt;a href=&quot;http://www.fossil-scm.org/&quot;&gt;Fossil&lt;/a&gt; , либо загрузив tarball или ZIP-архив для конкретной версии, либо клонировав всю историю проекта.</target>
        </trans-unit>
        <trans-unit id="6136d5ebef73dfa5b00893d194ed16a2a41f54ee" translate="yes" xml:space="preserve">
          <source>For auxiliary columns, only the name of the column matters. The &lt;a href=&quot;datatype3#affinity&quot;&gt;type affinity&lt;/a&gt; is ignored. Constraints such as NOT NULL, UNIQUE, REFERENCES, or CHECK are also ignored. However, future versions of SQLite might start paying attention to the type affinity and constraints, so users of auxiliary columns are advised to leave both blank, to avoid future compatibility problems.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38f9906eb0f1f05679eef0c31ffe0e8cfcb13adf" translate="yes" xml:space="preserve">
          <source>For backwards compatibility with older versions of SQLite that lack the &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_initialize()&lt;/a&gt; interface, the &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_initialize()&lt;/a&gt; interface is called automatically upon entry to certain key interfaces such as &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register()&lt;/a&gt;, and &lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_mprintf()&lt;/a&gt;. The overhead of invoking &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_initialize()&lt;/a&gt; automatically in this way may be omitted by building SQLite with the SQLITE_OMIT_AUTOINIT C-preprocessor macro. When built using SQLITE_OMIT_AUTOINIT, SQLite will not automatically initialize itself and the application is required to invoke &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_initialize()&lt;/a&gt; directly prior to beginning use of the SQLite library.</source>
          <target state="translated">Для обратной совместимости со старыми версиями SQLite, в которых отсутствует интерфейс &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_initialize (),&lt;/a&gt; интерфейс &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_initialize ()&lt;/a&gt; вызывается автоматически при входе в определенные ключевые интерфейсы, такие как &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open ()&lt;/a&gt; , &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register ()&lt;/a&gt; и &lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_mprintf ()&lt;/a&gt; . Накладные расходы, связанные с автоматическим вызовом &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_initialize ()&lt;/a&gt; таким образом, могут быть исключены путем построения SQLite с помощью макроса SQLITE_OMIT_AUTOINIT C-препроцессора. При построении с использованием SQLITE_OMIT_AUTOINIT SQLite не будет автоматически инициализироваться, и приложение должно вызывать &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_initialize ()&lt;/a&gt; непосредственно перед началом использования библиотеки SQLite.</target>
        </trans-unit>
        <trans-unit id="2d1531a5da60e68beb6877ebc84583e140b012b5" translate="yes" xml:space="preserve">
          <source>For best security, do not use this method unless truly needed, and run &lt;a href=&quot;pragma#pragma_trusted_schema&quot;&gt;PRAGMA trusted_schema=OFF&lt;/a&gt; or the &quot;&lt;a href=&quot;#config&quot;&gt;db config trusted_schema 0&lt;/a&gt;&quot; method &lt;u&gt;before&lt;/u&gt; invoking this method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c2a0d57a438475dac09b9669a68b59949b61514" translate="yes" xml:space="preserve">
          <source>For best security, the &lt;a href=&quot;#sqlitedirectonly&quot;&gt;SQLITE_DIRECTONLY&lt;/a&gt; flag is recommended for all application-defined SQL functions that do not need to be used inside of triggers, view, CHECK constraints, or other elements of the database schema. This flags is especially recommended for SQL functions that have side effects or reveal internal application state. Without this flag, an attacker might be able to modify the schema of a database file to include invocations of the function with parameters chosen by the attacker, which the application will then execute when the database file is opened and read.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a82f5f85ed3a810b5bb82f46aed446a44b2ed973" translate="yes" xml:space="preserve">
          <source>For best security, the &lt;a href=&quot;c_deterministic#sqlitedirectonly&quot;&gt;SQLITE_DIRECTONLY&lt;/a&gt; flag is recommended for all application-defined SQL functions that do not need to be used inside of triggers, view, CHECK constraints, or other elements of the database schema. This flags is especially recommended for SQL functions that have side effects or reveal internal application state. Without this flag, an attacker might be able to modify the schema of a database file to include invocations of the function with parameters chosen by the attacker, which the application will then execute when the database file is opened and read.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad7a915b64d6fe6bb79ac5b4ba72d86b2b8e4dad" translate="yes" xml:space="preserve">
          <source>For bitmask tests, &lt;code&gt;testcase()&lt;/code&gt; macros are used to verify that every bit of the bitmask affects the outcome. For example, in the following block of code, the condition is true if the mask contains either of two bits indicating either a MAIN_DB or a TEMP_DB is being opened. The &lt;code&gt;testcase()&lt;/code&gt; macros that precede the if statement verify that both cases are tested:</source>
          <target state="translated">Для тестов битовой маски используются макросы &lt;code&gt;testcase()&lt;/code&gt; для проверки того, что каждый бит битовой маски влияет на результат. Например, в следующем блоке кода условие истинно, если маска содержит один из двух битов, указывающих, что открывается MAIN_DB или TEMP_DB. &lt;code&gt;testcase()&lt;/code&gt; макросы , которые предшествуют если заявление проверить , что в обоих случаях проверяются:</target>
        </trans-unit>
        <trans-unit id="1eab60de14b7b002b878e809e16b0c4001fb65d3" translate="yes" xml:space="preserve">
          <source>For both text and numeric values, NULL sorts before any other value. A comparison of any value against NULL using operators like &quot;&amp;lt;&quot; or &quot;&amp;gt;=&quot; is always false.</source>
          <target state="translated">Как для текстовых, так и для числовых значений NULL сортируется перед любым другим значением. Сравнение любого значения с NULL с использованием операторов типа &amp;laquo;&amp;lt;&amp;raquo; или &amp;laquo;&amp;gt; =&amp;raquo; всегда неверно.</target>
        </trans-unit>
        <trans-unit id="0001dc558eb2ab6e42a7bb8e2fadd29ee6f23dde" translate="yes" xml:space="preserve">
          <source>For brevity, the diagrams in this section are simplified from those that came before. Blue color still signifies original content and pink still signifies new content. But the individual pages in the rollback journal and the database file are not shown and we are not making the distinction between information in the operating system cache and information that is on disk. All of these factors still apply in a multi-file commit scenario. They just take up a lot of space in the diagrams and they do not add any new information, so they are omitted here.</source>
          <target state="translated">Для краткости,диаграммы в этом разделе упрощены по сравнению с теми,которые пришли раньше.Синий цвет по-прежнему означает оригинальное содержание,а розовый-новое содержание.Но отдельные страницы в журнале отката и в файле базы данных не показываются,и мы не делаем различия между информацией в кэше операционной системы и информацией,которая находится на диске.Все эти факторы все еще применяются в сценарии многофайловых коммитов.Они просто занимают много места на диаграммах и не добавляют никакой новой информации,поэтому здесь они опускаются.</target>
        </trans-unit>
        <trans-unit id="4e31069a755a0df659f64899fd564b4a8cf6e824" translate="yes" xml:space="preserve">
          <source>For command-line usage, add the short style command-line options immediately following the &quot;-A&quot;, without an intervening space. All subsequent arguments are considered to be part of the .archive command. For example, the following commands are equivalent:</source>
          <target state="translated">Для использования в командной строке добавьте опции короткой командной строки сразу после &quot;-A&quot;,без промежутка времени.Все последующие аргументы считаются частью команды .archive.Например,следующие команды эквивалентны:</target>
        </trans-unit>
        <trans-unit id="b9d0d974a63b482f33f7f36907a5721a5611077f" translate="yes" xml:space="preserve">
          <source>For commit records, the size of the database file in pages after the commit. For all other records, zero.</source>
          <target state="translated">Для записей коммита-размер файла базы данных в страницах после коммита.Для всех остальных записей-ноль.</target>
        </trans-unit>
        <trans-unit id="e91c377baed35ec4162bb3c1ca2f7aeb4671aa6f" translate="yes" xml:space="preserve">
          <source>For compatibility with older &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; implementations, this flag is turned on temporarily while the &lt;a href=&quot;vtab#xrename&quot;&gt;sqlite3_module.xRename&lt;/a&gt; method is being run. The value of this flag is restore after the &lt;a href=&quot;vtab#xrename&quot;&gt;sqlite3_module.xRename&lt;/a&gt; method finishes.</source>
          <target state="translated">Для совместимости со старыми реализациями &lt;a href=&quot;vtab&quot;&gt;виртуальных таблиц&lt;/a&gt; этот флаг временно включается, пока выполняется метод &lt;a href=&quot;vtab#xrename&quot;&gt;sqlite3_module.xRename&lt;/a&gt; . Значение этого флага восстанавливается после завершения метода &lt;a href=&quot;vtab#xrename&quot;&gt;sqlite3_module.xRename&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="da9484ca4033054fc98b8e99fd5bf556ff20f8cb" translate="yes" xml:space="preserve">
          <source>For completeness, some of the higher level formatting information contains in the &lt;a href=&quot;fileformat2&quot;&gt;file format&lt;/a&gt; document and elsewhere is replicated here, when it pertains to WAL mode processing.</source>
          <target state="translated">Для полноты, некоторая информация о форматировании более высокого уровня содержится в документе &lt;a href=&quot;fileformat2&quot;&gt;формата файла&lt;/a&gt; и в другом месте реплицируется здесь, когда она относится к обработке в режиме WAL.</target>
        </trans-unit>
        <trans-unit id="e99fbef35a40e331c478cf6f191e30ae20bee3b1" translate="yes" xml:space="preserve">
          <source>For correct operation of the &lt;a href=&quot;cli#sqlar&quot;&gt;.archive command&lt;/a&gt;, make a copy of the &lt;a href=&quot;https://zlib.net&quot;&gt;zlib source code&lt;/a&gt; into the compat/zlib subdirectory of the source tree and compile this way:</source>
          <target state="translated">Для правильной работы команды &lt;a href=&quot;cli#sqlar&quot;&gt;.archive&lt;/a&gt; сделайте копию &lt;a href=&quot;https://zlib.net&quot;&gt;исходного кода&lt;/a&gt; zlib в подкаталог compat / zlib дерева исходных текстов и скомпилируйте следующим образом:</target>
        </trans-unit>
        <trans-unit id="a28c51fc9c57d328cc18317fd43208e2e391d0d1" translate="yes" xml:space="preserve">
          <source>For device-local storage with low writer concurrency and less than a terabyte of content, SQLite is almost always a better solution. SQLite is fast and reliable and it requires no configuration or maintenance. It keeps thing simple. SQLite &quot;just works&quot;.</source>
          <target state="translated">Для локальных устройств хранения данных с низкой параллельностью записи и объемом менее терабайта контента,SQLite почти всегда является лучшим решением.SQLite быстр и надежен и не требует настройки и обслуживания.Он делает все просто.SQLite &quot;просто работает&quot;.</target>
        </trans-unit>
        <trans-unit id="72afef4549faaf3eb91dc5ed7c4f9e5ba9217a77" translate="yes" xml:space="preserve">
          <source>For device-local storage with low writer concurrency and less than a terabyte of content, SQLite is almost always a better solution. SQLite is fast and reliable and it requires no configuration or maintenance. It keeps things simple. SQLite &quot;just works&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14026abb0078c30fcbc6bf88b3e2948c23e3f5c6" translate="yes" xml:space="preserve">
          <source>For doclists for which the term appears in more than one column of the FTS virtual table, term-offset lists within the doclist are stored in column number order. This ensures that the term-offset list associated with column 0 (if any) is always first, allowing the first two fields of the term-offset list to be omitted in this case.</source>
          <target state="translated">Для круглых столбцов,для которых термин фигурирует более чем в одном столбце виртуальной таблицы ФСТ,списки смещения терминов внутри круглого стола хранятся в порядке следования номеров столбцов.Это гарантирует,что список смещения,связанный со столбцом 0 (если таковой имеется),всегда является первым,что позволяет в этом случае опустить первые два поля списка смещения.</target>
        </trans-unit>
        <trans-unit id="89b4ec40df531b5b987432b4a7fed5ea5b3e27ac" translate="yes" xml:space="preserve">
          <source>For each DELETE change, the function checks if the target database contains a row with the same primary key value (or values) as the original row values stored in the changeset. If it does, and the values stored in all non-primary key columns also match the values stored in the changeset the row is deleted from the target database.</source>
          <target state="translated">Для каждого изменения DELETE функция проверяет,содержит ли целевая база данных строку с тем же значением (или значениями)первичного ключа,что и исходные значения строк,сохраненные в changeset.Если это так,и значения,сохраненные во всех столбцах без первичного ключа,также совпадают со значениями,сохраненными в changeset,то строка удаляется из целевой базы данных.</target>
        </trans-unit>
        <trans-unit id="1fb2d165bb57742263f5c19d2ad3dc7e863bddd8" translate="yes" xml:space="preserve">
          <source>For each FTS virtual table in a database, three to five real (non-virtual) tables are created to store the underlying data. These real tables are called &quot;shadow tables&quot;. The real tables are named &quot;%_content&quot;, &quot;%_segdir&quot;, &quot;%_segments&quot;, &quot;%_stat&quot;, and &quot;%_docsize&quot;, where &quot;%&quot; is replaced by the name of the FTS virtual table.</source>
          <target state="translated">Для каждой виртуальной таблицы FTS в базе данных создаются от трех до пяти реальных (невиртуальных)таблиц для хранения базовых данных.Эти реальные таблицы называются &quot;теневыми&quot;.Реальные таблицы называются &quot;%_контент&quot;,&quot;%_сегдир&quot;,&quot;%_сегменты&quot;,&quot;%_стат&quot; и &quot;%_досье&quot;,где &quot;%&quot; заменяется именем виртуальной таблицы FTS.</target>
        </trans-unit>
        <trans-unit id="ca14bfe0c8ef783300da3fae2f2faf6123712788" translate="yes" xml:space="preserve">
          <source>For each INSERT change, an attempt is made to insert the new row into the database. If the changeset row contains fewer fields than the database table, the trailing fields are populated with their default values.</source>
          <target state="translated">Для каждого изменения INSERT делается попытка вставить новую строку в базу данных.Если строка changeset содержит меньше полей,чем таблица БД,то поля трейлинга заполняются значениями по умолчанию.</target>
        </trans-unit>
        <trans-unit id="af26a43594c40c8d5075b1d213281d1a0d5d674e" translate="yes" xml:space="preserve">
          <source>For each UPDATE change, the function checks if the target database contains a row with the same primary key value (or values) as the original row values stored in the changeset. If it does, and the values stored in all modified non-primary key columns also match the values stored in the changeset the row is updated within the target database.</source>
          <target state="translated">Для каждого изменения UPDATE функция проверяет,содержит ли целевая БД строку с тем же значением (или значениями)первичного ключа,что и исходные значения строк,сохраненные в changeset.Если это так,и значения,сохраненные во всех столбцах не с первичным ключом,также совпадают со значениями,сохраненными в changeset,то строка обновляется в целевой базе данных.</target>
        </trans-unit>
        <trans-unit id="4c2b6b338ac313921ef720ea9cbd33ced2c0a043" translate="yes" xml:space="preserve">
          <source>For each UPDATE change, the old.* and new.* values are exchanged.</source>
          <target state="translated">Для каждого изменения UPDATE происходит обмен старыми и новыми значениями.</target>
        </trans-unit>
        <trans-unit id="d2a86ead2de9a7fdab60caec05b45cc30754d41b" translate="yes" xml:space="preserve">
          <source>For each cell in the r-tree structure (%_node table), that:</source>
          <target state="translated">Для каждой ячейки в r-деревянной структуре (таблица %_node)это:</target>
        </trans-unit>
        <trans-unit id="44564b0e8d37eeca09117cb0ce5677dfdd15f643" translate="yes" xml:space="preserve">
          <source>For each change for which there is a compatible table, an attempt is made to modify the table contents according to the UPDATE, INSERT or DELETE change. If a change cannot be applied cleanly, the conflict handler function passed as the fifth argument to sqlite3changeset_apply() may be invoked. A description of exactly when the conflict handler is invoked for each type of change is below.</source>
          <target state="translated">Для каждого изменения,для которого имеется совместимая таблица,делается попытка изменить содержимое таблицы в соответствии с изменением UPDATE,INSERT или DELETE.Если изменение не может быть применено чисто,то может быть вызвана функция-обработчик конфликтов,переданная в качестве пятого аргумента sqlite3changeset_apply().Описание того,когда именно вызывается обработчик конфликтов для каждого типа изменения,приведено ниже.</target>
        </trans-unit>
        <trans-unit id="fabf5b0df1d79746c4d3b0f7c3d3e26095a89ed6" translate="yes" xml:space="preserve">
          <source>For each column in a row of the result, the name of that column is used as an index in to array and the value of the column is stored in the corresponding array entry. (Caution: If two or more columns in the result set of a query have the same name, then the last column with that name will overwrite prior values and earlier columns with the same name will be inaccessible.) The special array index * is used to store a list of column names in the order that they appear.</source>
          <target state="translated">Для каждого столбца в строке результата имя этого столбца используется в качестве индекса в массиве,а значение столбца хранится в соответствующей записи массива.(Внимание:Если два или более столбцов в результирующем множестве запроса имеют одно и то же имя,то последний столбец с таким именем будет перезаписывать предыдущие значения,а более ранние столбцы с таким же именем будут недоступны).Специальный индекс массива*используется для хранения списка имен столбцов в порядке их появления.</target>
        </trans-unit>
        <trans-unit id="c334738444e4ad47d383e7911a76c91bc19cd2c6" translate="yes" xml:space="preserve">
          <source>For each column, the average number of tokens in the text values stored in the column (considering all rows in the FTS4 table). This value is only available when querying FTS4 tables, not FTS3.</source>
          <target state="translated">Для каждого столбца-среднее количество маркеров в текстовых значениях,хранящихся в столбце (с учетом всех строк в таблице FTS4).Это значение доступно только при запросе таблиц FTS4,а не FTS3.</target>
        </trans-unit>
        <trans-unit id="7a8f829d184d100e174a5aa5857d53deb24e800d" translate="yes" xml:space="preserve">
          <source>For each column, the length of the longest subsequence of phrase matches that the column value has in common with the query text. For example, if a table column contains the text 'a b c d e' and the query is 'a c &quot;d e&quot;', then the length of the longest common subsequence is 2 (phrase &quot;c&quot; followed by phrase &quot;d e&quot;).</source>
          <target state="translated">Для каждого столбца длина самой длинной подпоследовательности фразы совпадает со значением столбца в тексте запроса.Например,если столбец таблицы содержит текст 'a c d e',а запрос-'a c &quot;d e&quot;',то длина самой длинной общей подпоследовательности равна 2 (фраза &quot;c&quot;,за которой следует фраза &quot;d e&quot;).</target>
        </trans-unit>
        <trans-unit id="a1353b0cd18d624357976b5c201f2ed175d084b1" translate="yes" xml:space="preserve">
          <source>For each column, the length of the value stored in the current row of the FTS4 table, in tokens. This value is only available when querying FTS4 tables, not FTS3. And only if the &quot;matchinfo=fts3&quot; directive was not specified as part of the &quot;CREATE VIRTUAL TABLE&quot; statement used to create the FTS4 table.</source>
          <target state="translated">Для каждого столбца длина значения,сохраненного в текущей строке таблицы FTS4,в маркерах.Это значение доступно только при запросе таблиц FTS4,а не FTS3.И только в том случае,если директива &quot;matchinfo=fts3&quot; не была указана как часть оператора &quot;CREATE VIRTUAL TABLE&quot;,используемого для создания таблицы FTS4.</target>
        </trans-unit>
        <trans-unit id="6e8b6483ba6be5818f8c523c79ce85a1e7ccc3ba" translate="yes" xml:space="preserve">
          <source>For each distinct combination of a phrase and table column, the following three values:</source>
          <target state="translated">Для каждой отдельной комбинации фразы и столбца таблицы следующие три значения:</target>
        </trans-unit>
        <trans-unit id="cf92fe281dadfcf306551aea2a8a2fccc4c37192" translate="yes" xml:space="preserve">
          <source>For each distinct combination of a phrase and table column, the number of usable phrase matches that appear in the column. This is usually identical to the first value in each set of three returned by the &lt;a href=&quot;fts3#matchinfo-x&quot; id=&quot;matchinfo-y&quot;&gt;matchinfo 'x' flag&lt;/a&gt;. However, the number of hits reported by the 'y' flag is zero for any phrase that is part of a sub-expression that does not match the current row. This makes a difference for expressions that contain AND operators that are descendants of OR operators. For example, consider the expression:</source>
          <target state="translated">Для каждой отдельной комбинации фразы и столбца таблицы - количество подходящих совпадений фраз, отображаемых в столбце. Обычно оно идентично первому значению в каждом наборе из трех, возвращаемом &lt;a href=&quot;fts3#matchinfo-x&quot; id=&quot;matchinfo-y&quot;&gt;флагом matchinfo 'x'&lt;/a&gt; . Однако количество совпадений, о которых сообщает флаг &amp;laquo;y&amp;raquo;, равно нулю для любой фразы, которая является частью подвыражения, не соответствующего текущей строке. Это имеет значение для выражений, содержащих операторы И, которые являются потомками операторов ИЛИ. Например, рассмотрим выражение:</target>
        </trans-unit>
        <trans-unit id="fffbd38440022e9244e6e0693275b0d19d1857ad" translate="yes" xml:space="preserve">
          <source>For each modified table, a changeset includes the following:</source>
          <target state="translated">Для каждой измененной таблицы набор изменений включает следующее:</target>
        </trans-unit>
        <trans-unit id="a24f08d30b83fb31d42fefd2e7c6a4eb2dab4115" translate="yes" xml:space="preserve">
          <source>For each pair of columns identified by a USING clause, the column from the right-hand dataset is omitted from the joined dataset. This is the only difference between a USING clause and its equivalent ON constraint.</source>
          <target state="translated">Для каждой пары столбцов,идентифицируемых с помощью пункта USING,столбец из правого набора данных опускается из объединенного набора данных.Это единственное различие между пунктом USING и эквивалентным ему ограничением ON.</target>
        </trans-unit>
        <trans-unit id="9c5c3e6a930debab2d5dd5b538d4a23999481e17" translate="yes" xml:space="preserve">
          <source>For each primary key recorded as a result of an INSERT operation, the sessions module checks if there is a row with a matching primary key still in the table. If so, an INSERT change is added to the changeset.</source>
          <target state="translated">Для каждого первичного ключа,записанного в результате операции INSERT,модуль сеансов проверяет,есть ли в таблице строка с соответствующим первичным ключом.Если да,то в changeset добавляется изменение INSERT.</target>
        </trans-unit>
        <trans-unit id="829855e999389ecdd1577f6b633317b639cef854" translate="yes" xml:space="preserve">
          <source>For each primary key recorded as a result of an UPDATE or DELETE operation, the sessions module also checks for a row with a matching primary key within the table. If one can be found, but one or more of the non-PRIMARY KEY fields does not match the original recorded value, an UPDATE is added to the changeset. Or, if there is no row at all with the specified primary key, a DELETE is added to the changeset. If the row does exist but none of the non-PRIMARY KEY fields have been modified, no change is added to the changeset.</source>
          <target state="translated">Для каждого первичного ключа,записанного в результате операции UPDATE или DELETE,модуль сеансов также проверяет строку с соответствующим первичным ключом в таблице.Если один из них может быть найден,но одно или несколько не-PRIMARY KEY полей не совпадают с исходным записанным значением,в changeset добавляется UPDATE.Или,если строки с указанным первичным ключом вообще нет,в changeset добавляется DELETE.Если строка существует,но ни одно из полей,не относящихся к PRIMARY KEY,не было изменено,то в changeset не добавляется никаких изменений.</target>
        </trans-unit>
        <trans-unit id="d07e7398b3da8e6434d5c2443839062a6f35040b" translate="yes" xml:space="preserve">
          <source>For each record generated by an insert, the database is queried for a row with a matching primary key. If one is found, an INSERT change is added to the changeset. If no such row is found, no change is added to the changeset.</source>
          <target state="translated">Для каждой записи,сгенерированной вставкой,запрашивается база данных для строки с соответствующим первичным ключом.Если она найдена,в changeset добавляется изменение INSERT.Если такая строка не найдена,изменения в changeset не добавляются.</target>
        </trans-unit>
        <trans-unit id="9651a17487870ac448b95f61451215a9e031bca7" translate="yes" xml:space="preserve">
          <source>For each record generated by an update or delete, the database is queried for a row with a matching primary key. If such a row is found and one or more of the non-primary key fields have been modified from their original values, an UPDATE change is added to the changeset. Or, if no such row is found in the table, a DELETE change is added to the changeset. If there is a row with a matching primary key in the database, but all fields contain their original values, no change is added to the changeset.</source>
          <target state="translated">Для каждой записи,генерируемой обновлением или удалением,запрашивается база данных для строки с соответствующим первичным ключом.Если такая строка найдена и одно или несколько полей не с первичным ключом были изменены по сравнению с их исходными значениями,в changeset добавляется изменение UPDATE.Или,если такая строка не найдена в таблице,в changeset добавляется изменение DELETE.Если в базе данных есть строка с соответствующим первичным ключом,но все поля содержат исходные значения,то изменение в changeset не добавляется.</target>
        </trans-unit>
        <trans-unit id="1d85944e801be901ece01bab4a06681779097370" translate="yes" xml:space="preserve">
          <source>For each record in the first table, do:</source>
          <target state="translated">Для каждой записи в первой таблице,сделайте:</target>
        </trans-unit>
        <trans-unit id="db1b960f818a6af8cfaa2c24a19e780d2703af81" translate="yes" xml:space="preserve">
          <source>For each record in the second table do:</source>
          <target state="translated">Для каждой записи во второй таблице сделайте:</target>
        </trans-unit>
        <trans-unit id="07832e91f880502fa8c96087f4d7417bdd043461" translate="yes" xml:space="preserve">
          <source>For each record in the table, do:</source>
          <target state="translated">Для каждой записи в таблице,сделайте:</target>
        </trans-unit>
        <trans-unit id="87586acdd8d3aae53c73008136985fcb94271fa7" translate="yes" xml:space="preserve">
          <source>For each row (primary key) that exists in both tables, but features different non-PK values in each, an UPDATE record is added to the session.</source>
          <target state="translated">Для каждой строки (первичный ключ),которая существует в обеих таблицах,но имеет различные значения без PK,в сеанс добавляется запись UPDATE.</target>
        </trans-unit>
        <trans-unit id="6b65ebd60d0a165260cae83ea942ac1bc3113efb" translate="yes" xml:space="preserve">
          <source>For each row (primary key) that exists in the to-table but not in the from-table, a DELETE record is added to the session object.</source>
          <target state="translated">Для каждой строки (первичный ключ),которая существует в таблице to-таблицы,но не в таблице from-таблицы,к объекту сеанса добавляется запись DELETE.</target>
        </trans-unit>
        <trans-unit id="9d14fe0322a1c66d129265052088ccffec38ab12" translate="yes" xml:space="preserve">
          <source>For each row (primary key) that exists in the to-table but not in the from-table, an INSERT record is added to the session object.</source>
          <target state="translated">Для каждой строки (первичный ключ),которая существует в таблице to-таблицы,но не в таблице from-таблицы,к объекту сеанса добавляется запись INSERT.</target>
        </trans-unit>
        <trans-unit id="cf4da03b9da8c161d1cf42bd495a3368247989f4" translate="yes" xml:space="preserve">
          <source>For each row in the FTS table, the %_docsize table contains a corresponding row with the same &quot;docid&quot; value. The &quot;size&quot; field contains a blob consisting of</source>
          <target state="translated">Для каждой строки таблицы FTS таблица %_docsize содержит соответствующую строку с одинаковым значением &quot;docid&quot;.В поле &quot;Размер&quot; содержится блок,состоящий из</target>
        </trans-unit>
        <trans-unit id="a8c233269c53521f30c5ffc0bf77144b7402512d" translate="yes" xml:space="preserve">
          <source>For each row to DELETE from the target database as part of the RBU update, the corresponding data_% table should contain a single record with the &quot;rbu_control&quot; column set to contain integer value 1. The real primary key values of the row to delete should be stored in the corresponding columns of the data_% table. The values stored in the other columns are not used.</source>
          <target state="translated">Для каждой строки в DELETE из целевой базы данных в рамках обновления RBU соответствующая таблица data_% должна содержать единственную запись со столбцом &quot;rbu_control&quot;,в котором установлено целое значение 1.Реальные значения первичного ключа строки для удаления должны храниться в соответствующих столбцах таблицы data_%.Значения,хранящиеся в других столбцах,не используются.</target>
        </trans-unit>
        <trans-unit id="6a5706b24e2b237dcb339a0ad1090fb73a23781f" translate="yes" xml:space="preserve">
          <source>For each row to INSERT into the target database as part of the RBU update, the corresponding data_% table should contain a single record with the &quot;rbu_control&quot; column set to contain integer value 0. The other columns should be set to the values that make up the new record to insert.</source>
          <target state="translated">Для каждой строки INSERT в целевую базу данных в рамках обновления RBU соответствующая таблица data_% должна содержать единственную запись со столбцом &quot;rbu_control&quot;,содержащим целое значение 0.Остальные столбцы должны быть установлены в значения,составляющие новую запись для вставки.</target>
        </trans-unit>
        <trans-unit id="34669c17538b482482cba6957b264502d60d1060" translate="yes" xml:space="preserve">
          <source>For each row to UPDATE from the target database as part of the RBU update, the corresponding data_% table should contain a single record with the &quot;rbu_control&quot; column set to contain a value of type text. The real primary key values identifying the row to update should be stored in the corresponding columns of the data_% table row, as should the new values of all columns being update. The text value in the &quot;rbu_control&quot; column must contain the same number of characters as there are columns in the target database table, and must consist entirely of 'x' and '.' characters (or in some special cases 'd' - see below). For each column that is being updated, the corresponding character is set to 'x'. For those that remain as they are, the corresponding character of the rbu_control value should be set to '.'. For example, given the tables above, the update statement:</source>
          <target state="translated">Для каждой строки в UPDATE из целевой базы данных в рамках обновления RBU соответствующая таблица data_% должна содержать единственную запись со столбцом &quot;rbu_control&quot;,в которой должно содержаться значение типа текста.Реальные значения первичного ключа,идентифицирующие обновляемую строку,должны храниться в соответствующих столбцах строки таблицы data_%,так же как и новые значения всех обновляемых столбцов.Текстовое значение в столбце &quot;rbu_control&quot; должно содержать такое же количество символов,что и колонки в целевой таблице БД,и должно состоять полностью из символов 'x' и '.' (или в некоторых особых случаях 'd'-см.ниже).Для каждого обновляемого столбца соответствующий символ устанавливается в 'x'.Для тех,которые остаются неизменными,соответствующий символ значения rbu_control должен быть установлен в '.'.Например,учитывая таблицы выше,оператор обновления:</target>
        </trans-unit>
        <trans-unit id="a430b6812c406e37a693a08685ab05caa617b118" translate="yes" xml:space="preserve">
          <source>For each such constraint, the aConstraint[].iColumn field indicates which column appears on the left-hand side of the constraint. The first column of the virtual table is column 0. The rowid of the virtual table is column -1. The aConstraint[].op field indicates which operator is used. The SQLITE_INDEX_CONSTRAINT_* constants map integer constants into operator values. Columns occur in the order they were defined by the call to &lt;a href=&quot;c3ref/declare_vtab&quot;&gt;sqlite3_declare_vtab()&lt;/a&gt; in the &lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; or &lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; method. Hidden columns are counted when determining the column index.</source>
          <target state="translated">Для каждого такого ограничения поле aConstraint []. IColumn указывает, какой столбец появляется в левой части ограничения. Первый столбец виртуальной таблицы - это столбец 0. Идентификатор строки виртуальной таблицы - столбец -1. Поле aConstraint []. Op указывает, какой оператор используется. Константы SQLITE_INDEX_CONSTRAINT_ * отображают целочисленные константы в значения операторов. Столбцы располагаются в том порядке, в котором они были определены вызовом &lt;a href=&quot;c3ref/declare_vtab&quot;&gt;sqlite3_declare_vtab ()&lt;/a&gt; в &lt;a href=&quot;vtab#xcreate&quot;&gt;методе xCreate&lt;/a&gt; или &lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; . Скрытые столбцы учитываются при определении индекса столбца.</target>
        </trans-unit>
        <trans-unit id="f5aad29ac204438525f336e09bd7bc093d292717" translate="yes" xml:space="preserve">
          <source>For each table in the target database that will be modified by the update, a corresponding table is created within the RBU database. The RBU database table schema is not the same as that of the target database, but is derived from it as &lt;a href=&quot;rbu#database_tables&quot;&gt;described below&lt;/a&gt;.</source>
          <target state="translated">Для каждой таблицы в целевой базе данных, которая будет изменена при обновлении, в базе данных RBU создается соответствующая таблица. Схема таблицы базы данных RBU не такая же, как у целевой базы данных, но получена из нее, как &lt;a href=&quot;rbu#database_tables&quot;&gt;описано ниже&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f11dacd70a0954440fff36de5fbb6ca308465c38" translate="yes" xml:space="preserve">
          <source>For each table in the target database, the RBU database should contain a table named &quot;data&amp;lt;</source>
          <target state="translated">Для каждой таблицы в целевой базе данных база данных RBU должна содержать таблицу с именем &quot;data &amp;lt;</target>
        </trans-unit>
        <trans-unit id="42f788bf7b6ac170ed8ce05feddfec2cba592bef" translate="yes" xml:space="preserve">
          <source>For each table read by the query, the output of EXPLAIN QUERY PLAN includes a record for which the value in the &quot;detail&quot; column begins with either &quot;SCAN&quot; or &quot;SEARCH&quot;. &quot;SCAN&quot; is used for a full-table scan, including cases where SQLite iterates through all records in a table in an order defined by an index. &quot;SEARCH&quot; indicates that only a subset of the table rows are visited. Each SCAN or SEARCH record includes the following information:</source>
          <target state="translated">Для каждой таблицы,прочитанной запросом,вывод EXPLAIN QUERY PLAN включает в себя запись,для которой значение в столбце &quot;Детали&quot; начинается либо с &quot;SCAN&quot;,либо с &quot;SEARCH&quot;.&quot;SCAN&quot; используется для полнотабельного сканирования,включая случаи,когда SQLite выполняет итерацию по всем записям в таблице в порядке,определяемом индексом.&quot;Поиск&quot; означает,что посещается только подмножество строк таблицы.Каждая запись SCAN или &quot;Поиск&quot; включает в себя следующую информацию:</target>
        </trans-unit>
        <trans-unit id="ecba2625cd566548c3eee164f8360eb376f2aaad" translate="yes" xml:space="preserve">
          <source>For each table that is not excluded by the filter callback, this function tests that the target database contains a compatible table. A table is considered compatible if all of the following are true:</source>
          <target state="translated">Для каждой таблицы,которая не исключается обратным вызовом фильтра,эта функция проверяет,что целевая БД содержит совместимую таблицу.Таблица считается совместимой,если все нижеследующее верно:</target>
        </trans-unit>
        <trans-unit id="a67fb3e6d59fc22a676badf1b731424e48e59895" translate="yes" xml:space="preserve">
          <source>For each term in a document, the FTS index maintained by FTS5 stores the rowid of the document, the column number of the column that contains the term and the offset of the term within the column value. The &quot;detail&quot; option may be used to omit some of this information. This reduces the space that the index consumes within the database file, but also reduces the capability and efficiency of the system.</source>
          <target state="translated">Для каждого термина в документе индекс FTS,поддерживаемый FTS5,хранит строку документа,номер столбца столбца,который содержит термин,и смещение термина в пределах значения столбца.Опция &quot;подробно&quot; может использоваться для опускания части этой информации.Это сокращает пространство,занимаемое индексом в файле базы данных,а также снижает возможности и эффективность системы.</target>
        </trans-unit>
        <trans-unit id="ec159e8f6dc1a68285f736b240d086ca832050e3" translate="yes" xml:space="preserve">
          <source>For each term present in the FTS table, there are between 2 and N+1 rows in the fts4aux table, where N is the number of user-defined columns in the associated FTS table. An fts4aux table always has the same four columns, as follows, from left to right:</source>
          <target state="translated">Для каждого термина,присутствующего в таблице FTS,имеется от 2 до N+1 строк в таблице fts4aux,где N-это количество пользовательских столбцов в соответствующей таблице FTS.В таблице fts4aux всегда слева направо стоят одни и те же четыре столбца:</target>
        </trans-unit>
        <trans-unit id="2bdf0037f493d99e63f11ef023d4ede2161885e4" translate="yes" xml:space="preserve">
          <source>For each token in the input string, the supplied callback xToken() must be invoked. The first argument to it should be a copy of the pointer passed as the second argument to xTokenize(). The third and fourth arguments are a pointer to a buffer containing the token text, and the size of the token in bytes. The 4th and 5th arguments are the byte offsets of the first byte of and first byte immediately following the text from which the token is derived within the input.</source>
          <target state="translated">Для каждой лексемы во входной строке должен быть вызван поставляемый обратный вызов xToken().Первый аргумент к нему должен быть копией указателя,переданного в качестве второго аргумента в xTokenize().Третий и четвертый аргументы-указатель на буфер,содержащий текст лексемы,и размер лексемы в байтах.Четвертый и пятый аргументы-это смещение байта первого байта и первого байта,следующего непосредственно за текстом,из которого выводится токен внутри входного текста.</target>
        </trans-unit>
        <trans-unit id="77d69c67e1a2a185641c2031933b357307710ee5" translate="yes" xml:space="preserve">
          <source>For each token in the text fragment that is part of a phrase match, the &quot;start match&quot; text is inserted into the fragment before the token, and the &quot;end match&quot; text is inserted immediately after it.</source>
          <target state="translated">Для каждого токена во фрагменте текста,являющегося частью фразового совпадения,перед токеном вставляется текст &quot;стартового совпадения&quot;,а сразу после него-текст &quot;конечного совпадения&quot;.</target>
        </trans-unit>
        <trans-unit id="4d08b18694ad651bc6411787c4cb9cda3d56703c" translate="yes" xml:space="preserve">
          <source>For embedded systems, consider compiling SQLite with the &lt;a href=&quot;compile#enable_memsys5&quot;&gt;-DSQLITE_ENABLE_MEMSYS5&lt;/a&gt; option and then providing SQLite with a fixed chunk of memory to use as its heap via the &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigheap&quot;&gt;SQLITE_CONFIG_HEAP&lt;/a&gt;) interface. This will prevent malicious SQL from executing a denial-of-service attack by using an excessive amount of memory. If (say) 5 MB of memory is provided for SQLite to use, once that much has been consumed, SQLite will start returning SQLITE_NOMEM errors rather than soaking up memory needed by other parts of the application. This also sandboxes SQLite's memory so that a write-after-free error in some other part of the application will not cause problems for SQLite, or vice versa.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c5274d9826ac0360165a29a3e66a8506f1ab799" translate="yes" xml:space="preserve">
          <source>For every successful call to this method, the SQLite core will later invoke the &lt;a href=&quot;vtab#xclose&quot;&gt;xClose&lt;/a&gt; method to destroy the allocated cursor.</source>
          <target state="translated">Для каждого успешного вызова этого метода ядро ​​SQLite позже вызовет метод &lt;a href=&quot;vtab#xclose&quot;&gt;xClose&lt;/a&gt; для уничтожения выделенного курсора.</target>
        </trans-unit>
        <trans-unit id="c6c48664cbefae23df70df3591300d92263e5f4c" translate="yes" xml:space="preserve">
          <source>For example to find the highest paid employee:</source>
          <target state="translated">Например,найти самого высокооплачиваемого сотрудника:</target>
        </trans-unit>
        <trans-unit id="2479f1e642da058be56d1001ffac81d069a0ba6c" translate="yes" xml:space="preserve">
          <source>For example, a &lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt; statement cannot be run while another thread is reading from that table on the same &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; because dropping the table would delete the table out from under the concurrent reader.</source>
          <target state="translated">Например, оператор &lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt; не может быть запущен, пока другой поток читает из этой таблицы в том же &lt;a href=&quot;c3ref/sqlite3&quot;&gt;соединении с базой данных,&lt;/a&gt; потому что при удалении таблицы таблица будет удалена из-под одновременного чтения.</target>
        </trans-unit>
        <trans-unit id="6761f7f398c5e173f6115ef00ea11329cb9f3d54" translate="yes" xml:space="preserve">
          <source>For example, a query like the following might be used to find all R*Tree entries that overlap with a circle centered a 45.3,22.9 with a radius of 5.0:</source>
          <target state="translated">Например,запрос,подобный приведенному ниже,может быть использован для поиска всех записей R*Tree,которые пересекаются с окружностью по центру 45.3,22.9 с радиусом 5.0:</target>
        </trans-unit>
        <trans-unit id="42fbeb339bf81a5c29e36447b781a19ea1d40440" translate="yes" xml:space="preserve">
          <source>For example, adding an &quot;ON UPDATE CASCADE&quot; clause to the foreign key as shown below enhances the example schema from section 1 to allow the user to update the artistid (the parent key of the foreign key constraint) column without breaking referential integrity:</source>
          <target state="translated">Например,добавление пункта &quot;ON UPDATE CASCADE&quot; к внешнему ключу,как показано ниже,улучшает примерную схему из раздела 1,чтобы позволить пользователю обновить колонку artistid (родительский ключ ограничения внешнего ключа)без нарушения ссылочной целостности:</target>
        </trans-unit>
        <trans-unit id="68a7b041107b28bf1e4e9feea5241e1ae83cb4f3" translate="yes" xml:space="preserve">
          <source>For example, as currently implemented, if writes are happening at a steady stream that exceeds the I/O capability of the background writer thread, the queue of pending write operations will grow without bound. If this goes on for long enough, the host system could run out of memory. A more sophisticated module could to keep track of the quantity of pending writes and stop accepting new write requests when the queue of pending writes grows too large.</source>
          <target state="translated">Например,как сейчас реализовано,если записи происходят при постоянном потоке,превышающем возможности ввода/вывода потока фоновой записи,очередь отложенных операций записи будет расти без привязки.Если это будет продолжаться достаточно долго,то память хост-системы может закончиться.Более сложный модуль мог бы отслеживать количество отложенных записей и прекращать принимать новые запросы на запись,когда очередь отложенных записей вырастет слишком большой.</target>
        </trans-unit>
        <trans-unit id="74530ffba7f866870009106e3c8e5c0a0af944ca" translate="yes" xml:space="preserve">
          <source>For example, given the database schema:</source>
          <target state="translated">Например,учитывая схему базы данных:</target>
        </trans-unit>
        <trans-unit id="c7f52cca71f3aa80082462a01861b0a720f46594" translate="yes" xml:space="preserve">
          <source>For example, if a prepared statement is created using the SQL text &quot;SELECT $abc,:xyz&quot; and if parameter $abc is bound to integer 2345 and parameter :xyz is unbound, then sqlite3_sql() will return the original string, &quot;SELECT $abc,:xyz&quot; but sqlite3_expanded_sql() will return &quot;SELECT 2345,NULL&quot;.</source>
          <target state="translated">Например,если подготовленный оператор создается с помощью SQL-текста &quot;SELECT $abc,:xyz&quot; и если параметр $abc привязан к целому числу 2345 и параметр :xyz не привязан,то sqlite3_sql()вернет исходную строку,&quot;SELECT $abc,:xyz&quot;,а sqlite3_expanded_sql()вернет &quot;SELECT 2345,NULL&quot;.</target>
        </trans-unit>
        <trans-unit id="06bed93067ff2c82141c677c5fde8b31f46e4d93" translate="yes" xml:space="preserve">
          <source>For example, if both the local and remote changesets contain an INSERT of the same key on &quot;CREATE TABLE t1(a PRIMARY KEY, b)&quot;:</source>
          <target state="translated">Например,если и локальная,и удаленная версети содержат ИНСЕРТ одного и того же ключа на &quot;CREATE TABLE t1(a PRIMARY KEY,b)&quot;:</target>
        </trans-unit>
        <trans-unit id="336ff6fc840939163a24ab8fbcfd1876f5d7462b" translate="yes" xml:space="preserve">
          <source>For example, if each of the 517430 documents in the &quot;&lt;a href=&quot;http://www.cs.cmu.edu/~enron/&quot;&gt;Enron E-Mail Dataset&lt;/a&gt;&quot; is inserted into both an FTS table and an ordinary SQLite table created using the following SQL script:</source>
          <target state="translated">Например, если каждый из 517430 документов в &amp;laquo;наборе &lt;a href=&quot;http://www.cs.cmu.edu/~enron/&quot;&gt;данных электронной почты Enron&lt;/a&gt; &amp;raquo; вставлен как в таблицу FTS, так и в обычную таблицу SQLite, созданную с помощью следующего сценария SQL:</target>
        </trans-unit>
        <trans-unit id="9af2b0a0be2507f901ab349b61afc42441edaa60" translate="yes" xml:space="preserve">
          <source>For example, if nCol is the number of columns in the table, to determine if phrase p is present in column c:</source>
          <target state="translated">Например,если nCol-это количество столбцов в таблице,чтобы определить,присутствует ли фраза p в столбце c:</target>
        </trans-unit>
        <trans-unit id="4ff402b57bb3c7de072fb37615e2f1f44b822435" translate="yes" xml:space="preserve">
          <source>For example, if process A is in the middle of a large write transaction and at the same time process B attempts to start a new write transaction, process B will get back an SQLITE_BUSY result because SQLite only supports one writer at a time. Process B will need to wait for process A to finish its transaction before starting a new transaction. The &lt;a href=&quot;c3ref/busy_timeout&quot;&gt;sqlite3_busy_timeout()&lt;/a&gt; and &lt;a href=&quot;c3ref/busy_handler&quot;&gt;sqlite3_busy_handler()&lt;/a&gt; interfaces and the &lt;a href=&quot;pragma#pragma_busy_timeout&quot;&gt;busy_timeout pragma&lt;/a&gt; are available to process B to help it deal with SQLITE_BUSY errors.</source>
          <target state="translated">Например, если процесс A находится в середине большой транзакции записи и в то же время процесс B пытается начать новую транзакцию записи, процесс B вернет результат SQLITE_BUSY, потому что SQLite поддерживает только одну запись за раз. Процессу B нужно будет дождаться, пока процесс A завершит свою транзакцию, прежде чем начинать новую транзакцию. Интерфейсы &lt;a href=&quot;c3ref/busy_timeout&quot;&gt;sqlite3_busy_timeout ()&lt;/a&gt; и &lt;a href=&quot;c3ref/busy_handler&quot;&gt;sqlite3_busy_handler ()&lt;/a&gt; и &lt;a href=&quot;pragma#pragma_busy_timeout&quot;&gt;прагма busy_timeout&lt;/a&gt; доступны для процесса B, чтобы помочь ему справиться с ошибками SQLITE_BUSY.</target>
        </trans-unit>
        <trans-unit id="d347b5f74f99e1b9952eb3244ae0159feff20d3e" translate="yes" xml:space="preserve">
          <source>For example, if the</source>
          <target state="translated">Например,если</target>
        </trans-unit>
        <trans-unit id="c3622449954a6635d6d6221d72610b7472bd6c7b" translate="yes" xml:space="preserve">
          <source>For example, if the aConstraint[3].argvIndex is set to 1, then when xFilter is called, the argv[0] passed to xFilter will have the EXPR value of the aConstraint[3] constraint.</source>
          <target state="translated">Например,если aConstraint[3].argvIndex установлен в 1,то при вызове xFilter переданный в xFilter argv[0]будет иметь значение EXPR ограничения aConstraint[3].</target>
        </trans-unit>
        <trans-unit id="7f637c26bc4431eea662487596dfe6901f17e071" translate="yes" xml:space="preserve">
          <source>For example, if the following SQL is passed to &lt;a href=&quot;c3ref/declare_vtab&quot;&gt;sqlite3_declare_vtab()&lt;/a&gt;:</source>
          <target state="translated">Например, если в &lt;a href=&quot;c3ref/declare_vtab&quot;&gt;sqlite3_declare_vtab ()&lt;/a&gt; передается следующий SQL :</target>
        </trans-unit>
        <trans-unit id="9d9a182c3de2bb26679903dabe753f3a90f09588" translate="yes" xml:space="preserve">
          <source>For example, if you have a table column declared to be of type &quot;INTEGER&quot; and you try to insert a string, the column will look at the text string and see if it looks like a number. If the string does look like a number it is converted into a number and into an integer if the number does not have a fractional part, and stored that way. But if the string is not a well-formed number it is still stored as a string. A column with a type of &quot;TEXT&quot; tries to convert numbers into an ASCII-Text representation before storing them. But BLOBs are stored in TEXT columns as BLOBs because you cannot in general convert a BLOB into text.</source>
          <target state="translated">Например,если у вас столбец таблицы,объявленный как тип &quot;INTEGER&quot; и вы пытаетесь вставить строку,то столбец посмотрит на текстовую строку и увидит,не выглядит ли она как число.Если строка действительно выглядит как число,то она преобразуется в число и в целое число,если число не имеет дробной части,и сохраняется таким образом.Но если строка не является хорошо сформированным числом,она все равно хранится как строка.Столбец с типом &quot;TEXT&quot; пытается преобразовать числа в ASCII-Text представление перед их хранением.Но BLOB-номера хранятся в TEXT-столбцах как BLOB-номера,так как в общем случае невозможно преобразовать BLOB-номера в текст.</target>
        </trans-unit>
        <trans-unit id="2e8d78d9a4a4ef5a078d77893775dee024ca144a" translate="yes" xml:space="preserve">
          <source>For example, in gdb, to see the complete hierarchy of an Expr node (that is to say, the Expr node and all of its children), given a pointer &quot;pExpr&quot; to that node, type:</source>
          <target state="translated">Например,в gdb,чтобы увидеть полную иерархию узла Expr (то есть узла Expr и всех его дочерних элементов),дается указатель &quot;pExpr&quot; на этот узел,тип:</target>
        </trans-unit>
        <trans-unit id="65de8cd85e7f9352044ea42fa34fc26263f7d653" translate="yes" xml:space="preserve">
          <source>For example, in the following call to json_object(), the</source>
          <target state="translated">Например,в следующем вызове json_object(),в функции</target>
        </trans-unit>
        <trans-unit id="376c3a63c2d900eda2a882017f3f3a33aef34667" translate="yes" xml:space="preserve">
          <source>For example, information about the columns in an index can be read using the &lt;a href=&quot;pragma#pragma_index_info&quot;&gt;index_info pragma&lt;/a&gt; as follows:</source>
          <target state="translated">Например, информацию о столбцах в индексе можно прочитать с помощью &lt;a href=&quot;pragma#pragma_index_info&quot;&gt;прагмы index_info&lt;/a&gt; следующим образом:</target>
        </trans-unit>
        <trans-unit id="6bccea8458a0de711e349540a29ecfcb98a65f40" translate="yes" xml:space="preserve">
          <source>For example, let the index be</source>
          <target state="translated">Например,пусть индекс будет</target>
        </trans-unit>
        <trans-unit id="3da423bea60d2f28b9bd6c6b606ccc9294140d5b" translate="yes" xml:space="preserve">
          <source>For example, many words of Greek origin begin with letters &quot;ps&quot; where the &quot;p&quot; is silent. Ex: psalm, pseudonym, psoriasis, psyche. In another example, many Scottish surnames can be spelled with an initial &quot;Mac&quot; or &quot;Mc&quot;. Thus, &quot;MacKay&quot; and &quot;McKay&quot; are both pronounced the same.</source>
          <target state="translated">Например,многие слова греческого происхождения начинаются с буквы &quot;ps&quot;,где &quot;p&quot; молчит.Бывший:псалом,псевдоним,псориаз,психика.В другом примере многие шотландские фамилии могут быть написаны с начальной буквы &quot;Mac&quot; или &quot;Mc&quot;.Таким образом,&quot;Маккей&quot; и &quot;Маккей&quot; произносятся одинаково.</target>
        </trans-unit>
        <trans-unit id="20083fcfe31a171e687fd7f98763b1bd15a6a1ec" translate="yes" xml:space="preserve">
          <source>For example, say the SQL statement returns the following data when executed:</source>
          <target state="translated">Например,скажем,SQL-оператор при выполнении возвращает следующие данные:</target>
        </trans-unit>
        <trans-unit id="2fbaaa7d12d4edb21ff19c0963b0289115f32a55" translate="yes" xml:space="preserve">
          <source>For example, suppose an additional database is attached to the database connection using a statement like this:</source>
          <target state="translated">Например,предположим,что к соединению с БД подключена дополнительная БД с помощью такого утверждения:</target>
        </trans-unit>
        <trans-unit id="81c47bbba7e6d3bcfa83f9d58601629924b27df8" translate="yes" xml:space="preserve">
          <source>For example, suppose the input word is &quot;Paskagula&quot;. The phonetic key is &quot;BACACALA&quot; which is then truncated to 4 characters &quot;BACA&quot;. The edit distance is then run on the 4980 entries (out of 272,597 entries total) of the vocabulary whose k2 values begin with BACA, yielding &quot;Pascagoula&quot; as the best match.</source>
          <target state="translated">Например,предположим,что входным словом является &quot;Паскагула&quot;.Фонетическая клавиша-&quot;BACACALA&quot;,которая затем усечена до 4 символов &quot;BACA&quot;.Расстояние редактирования затем выполняется по 4980 записям (из 272 597 записей в общей сложности)словаря,значения k2 которого начинаются с BACA,в результате чего &quot;Паскагула&quot; как лучшее совпадение.</target>
        </trans-unit>
        <trans-unit id="bd462d6a706c77e5432cc4b960d8cc42361a6e96" translate="yes" xml:space="preserve">
          <source>For example, suppose you have a database of the members of a large organization where each person is assigned to a particular &quot;team&quot;. Each team has a &quot;leader&quot; who is also a member of that team. The table might look something like this:</source>
          <target state="translated">Например,предположим,что у Вас есть база данных членов большой организации,где каждый человек закреплен за определенной &quot;командой&quot;.У каждой команды есть &quot;лидер&quot;,который также является членом этой команды.Таблица может выглядеть примерно так:</target>
        </trans-unit>
        <trans-unit id="2d2ab8533e293c8a84090c9b6694f2a969c007bb" translate="yes" xml:space="preserve">
          <source>For example, suppose you have a table named &quot;t1&quot; with columns names &quot;a&quot;, &quot;b&quot;, and &quot;c&quot; and that you want to delete column &quot;c&quot; from this table. The following steps illustrate how this could be done:</source>
          <target state="translated">Например,предположим,что у вас есть таблица с именем &quot;t1&quot; и названиями столбцов &quot;a&quot;,&quot;b&quot; и &quot;c&quot;,и что вы хотите удалить столбец &quot;c&quot; из этой таблицы.Следующие шаги иллюстрируют,как это можно сделать:</target>
        </trans-unit>
        <trans-unit id="e8c74e845df3aa4e4554ece864cf2478aa417801" translate="yes" xml:space="preserve">
          <source>For example, suppose you wanted undo/redo on a class (table) that looks like this:</source>
          <target state="translated">Например,предположим,что вы хотели отменить/повтормозить в классе (таблице),который выглядит следующим образом:</target>
        </trans-unit>
        <trans-unit id="c888ac7552fad64c94327f4d9dde6c1939c79ffa" translate="yes" xml:space="preserve">
          <source>For example, the &quot;generate_series&quot; extension (located in the &lt;a href=&quot;http://www.sqlite.org/src/artifact?ci=trunk&amp;amp;filename=ext/misc/series.c&quot;&gt;ext/misc/series.c&lt;/a&gt; file in the &lt;a href=&quot;http://www.sqlite.org/src/tree?ci=trunk&quot;&gt;source tree&lt;/a&gt;) implements an &lt;a href=&quot;vtab#epovtab&quot;&gt;eponymous virtual table&lt;/a&gt; with the following schema:</source>
          <target state="translated">Например, расширение &quot;generate_series&quot; (расположенное в файле &lt;a href=&quot;http://www.sqlite.org/src/artifact?ci=trunk&amp;amp;filename=ext/misc/series.c&quot;&gt;ext / misc / series.c&lt;/a&gt; в &lt;a href=&quot;http://www.sqlite.org/src/tree?ci=trunk&quot;&gt;дереве исходного кода&lt;/a&gt; ) реализует &lt;a href=&quot;vtab#epovtab&quot;&gt;одноименную виртуальную таблицу&lt;/a&gt; со следующей схемой:</target>
        </trans-unit>
        <trans-unit id="a41d4a0a2c571159c4d3d9a9bcfe397816127e93" translate="yes" xml:space="preserve">
          <source>For example, the first argument to the &lt;a href=&quot;fts3#snippet&quot;&gt;snippet()&lt;/a&gt; function is supposed to be a special column of the FTS3 table that contains a pointer to an fts3cursor object that contains information about the current full text search match. That pointer was formerly passed as a BLOB. For example, if the FTS3 table is named &quot;t1&quot; and has a column named &quot;cx&quot;, one might write:</source>
          <target state="translated">Например, первым аргументом функции &lt;a href=&quot;fts3#snippet&quot;&gt;snippet ()&lt;/a&gt; должен быть специальный столбец таблицы FTS3, который содержит указатель на объект fts3cursor, который содержит информацию о текущем совпадении полнотекстового поиска. Этот указатель ранее передавался как BLOB. Например, если таблица FTS3 называется &amp;laquo;t1&amp;raquo; и имеет столбец с именем &amp;laquo;cx&amp;raquo;, можно написать:</target>
        </trans-unit>
        <trans-unit id="a1719c0fad0c46d95494599fc76472814afb3096" translate="yes" xml:space="preserve">
          <source>For example, the following EXPLAIN QUERY PLAN command operates on a SELECT statement that is implemented by performing a full-table scan on table t1:</source>
          <target state="translated">Например,следующая команда EXPLAIN QUERY PLAN работает с оператором SELECT,который реализуется путем выполнения полного сканирования таблицы t1:</target>
        </trans-unit>
        <trans-unit id="f54bfe9858a294d74efc1029b390f83e76127bc5" translate="yes" xml:space="preserve">
          <source>For example, the following JSON describes an isosceles triangle, sitting on the X axis and with an area of 0.5:</source>
          <target state="translated">Например,следующий JSON описывает равнобедренный треугольник,сидящий по оси X и имеющий площадь 0,5:</target>
        </trans-unit>
        <trans-unit id="83a6fbeea816f56be60daf62a9ac68c383f63398" translate="yes" xml:space="preserve">
          <source>For example, the following code implements a collating sequence called &quot;NOCASE&quot; that sorts in text order without regard to case:</source>
          <target state="translated">Например,в следующем коде реализована коллекционная последовательность под названием &quot;NOCASE&quot;,которая сортирует в текстовом порядке без учета регистра:</target>
        </trans-unit>
        <trans-unit id="9c27a0d3845f1eceb95943662637d42bbbaddf2a" translate="yes" xml:space="preserve">
          <source>For example, the following statement is valid in SQLite:</source>
          <target state="translated">Например,в SQLite действителен следующий оператор:</target>
        </trans-unit>
        <trans-unit id="c949165d26ebc110da68da66e13bc86685e04c18" translate="yes" xml:space="preserve">
          <source>For example, the values NULL, 0.0, 0, 'english' and '0' are all considered to be false. Values 1, 1.0, 0.1, -0.1 and '1english' are considered to be true.</source>
          <target state="translated">Например,значения NULL,0.0,0,'английский' и '0' считаются ложными.Значения 1,1.0,0.1,-0.1 и '1english' считаются истинными.</target>
        </trans-unit>
        <trans-unit id="a80abcae23d48d4d5c71b5964b931b771a14df0d" translate="yes" xml:space="preserve">
          <source>For example, this row:</source>
          <target state="translated">Например,эта строка:</target>
        </trans-unit>
        <trans-unit id="f0774215613f5a93e554bf719be214f376054f20" translate="yes" xml:space="preserve">
          <source>For example, to avoid adding the contents of the &quot;uuid&quot; field to the FTS index:</source>
          <target state="translated">Например,чтобы избежать добавления содержимого поля &quot;uuid&quot; в индекс FTS:</target>
        </trans-unit>
        <trans-unit id="e25e9fcbc6cbbe4aa86a860fba9ee3e23406906c" translate="yes" xml:space="preserve">
          <source>For example, to create a new SQLite database named &quot;ex1&quot; with a single table named &quot;tbl1&quot;, you might do this:</source>
          <target state="translated">Например,чтобы создать новую базу данных SQLite с именем &quot;ex1&quot; и одной таблицей с именем &quot;tbl1&quot;,вы можете сделать это:</target>
        </trans-unit>
        <trans-unit id="0a8b8eec2dca22f4460d3c1b6d1607de62d83c18" translate="yes" xml:space="preserve">
          <source>For example, to create an archive containing two text files, &quot;a.txt&quot; and &quot;b.txt&quot;, containing the text &quot;abc&quot; and &quot;123&quot; respectively:</source>
          <target state="translated">Например,создать архив,содержащий два текстовых файла,&quot;a.txt&quot; и &quot;b.txt&quot;,содержащие тексты &quot;abc&quot; и &quot;123&quot; соответственно:</target>
        </trans-unit>
        <trans-unit id="e1c45bec4422b2834e5d74273014f0905a33b70e" translate="yes" xml:space="preserve">
          <source>For example, to inspect the contents of zip archive &quot;test.zip&quot; from the current directory:</source>
          <target state="translated">Например,для проверки содержимого zip-архива &quot;test.zip&quot; из текущего каталога:</target>
        </trans-unit>
        <trans-unit id="460920e6960fc9166bdf09c3d3e3d2d1b9cb1172" translate="yes" xml:space="preserve">
          <source>For example, to optimize the full-text index for an FTS table named &quot;docs&quot;:</source>
          <target state="translated">Например,для оптимизации полнотекстового индекса для таблицы FTS под названием &quot;docs&quot;:</target>
        </trans-unit>
        <trans-unit id="8112859719fda223d11dd9ecc671a2d731113a48" translate="yes" xml:space="preserve">
          <source>For example, to see a list of the tables in the database, you can enter &quot;.tables&quot;.</source>
          <target state="translated">Например,чтобы увидеть список таблиц в БД,можно ввести &quot;.таблицы&quot;.</target>
        </trans-unit>
        <trans-unit id="3403f20bef06b9f62c829264d38a448f07fbf25f" translate="yes" xml:space="preserve">
          <source>For example, using the tables created above:</source>
          <target state="translated">Например,используя таблицы,созданные выше:</target>
        </trans-unit>
        <trans-unit id="8baebd4e0fce8f0dca8a23890fbbeb7b6c6bd6f4" translate="yes" xml:space="preserve">
          <source>For example, when a document containing the text &quot;Right now, they're very frustrated.&quot;, the terms extracted from the document and added to the full-text index are, in order, &quot;right now they re very frustrated&quot;. Such a document would match a full-text query such as &quot;MATCH 'Frustrated'&quot;, as the simple tokenizer transforms the term in the query to lowercase before searching the full-text index.</source>
          <target state="translated">Например,когда документ,содержащий текст &quot;Прямо сейчас они очень расстроены&quot;,термины,извлеченные из документа и добавленные в полнотекстовый указатель,в порядке &quot;прямо сейчас они очень расстроены&quot;.Такой документ соответствовал бы полнотекстовому запросу типа &quot;MATCH 'Frustrated'&quot;,так как простой токенизор преобразует термин в запросе в нижний регистр перед поиском в полнотекстовом индексе.</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">Например:</target>
        </trans-unit>
        <trans-unit id="0dc693a709e03c8a242ebc99f829d5a5f0d7f07e" translate="yes" xml:space="preserve">
          <source>For examples of how the SQLite C/C++ interface can be used, refer to the source code for the &lt;b&gt;sqlite&lt;/b&gt; program in the file &lt;a href=&quot;https://sqlite.org/src/file/src/shell.c.in&quot;&gt;src/shell.c&lt;/a&gt; of the source tree. Additional information about sqlite is available at &lt;a href=&quot;cli&quot;&gt;cli.html&lt;/a&gt;. See also the sources to the Tcl interface for SQLite in the source file &lt;a href=&quot;https://sqlite.org/src/file/src/tclsqlite.c&quot;&gt;src/tclsqlite.c&lt;/a&gt;.</source>
          <target state="translated">Примеры использования интерфейса SQLite C / C ++ см. В исходном коде программы &lt;b&gt;sqlite&lt;/b&gt; в файле &lt;a href=&quot;https://sqlite.org/src/file/src/shell.c.in&quot;&gt;src / shell.c&lt;/a&gt; исходного дерева. Дополнительная информация о sqlite доступна на &lt;a href=&quot;cli&quot;&gt;cli.html&lt;/a&gt; . См. Также источники интерфейса Tcl для SQLite в исходном файле &lt;a href=&quot;https://sqlite.org/src/file/src/tclsqlite.c&quot;&gt;src / tclsqlite.c&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="db416b5f222a1960fcc408837e83b440afa98ccd" translate="yes" xml:space="preserve">
          <source>For floating-point substitutions (%e, %E, %f, %g, %G) the precision specifies the number of digits to display to the right of the decimal point.</source>
          <target state="translated">Для замен с плавающей точкой (%e,%E,%f,%g,%G)точность задает количество цифр,отображаемых справа от десятичной точки.</target>
        </trans-unit>
        <trans-unit id="cf9d217953f034811d5791d9759455b504d70d86" translate="yes" xml:space="preserve">
          <source>For full prefix support, method (3) may be preferred. In this case, because the index contains entries for both &quot;first&quot; and &quot;1st&quot;, prefix queries such as 'fi*' or '1s*' will match correctly. However, because extra entries are added to the FTS index, this method uses more space within the database.</source>
          <target state="translated">Для полной поддержки префиксов может быть предпочтительным метод (3).В этом случае,так как индекс содержит записи как для &quot;первого&quot;,так и для &quot;первого&quot;,префиксные запросы типа 'fi*' или '1s*' будут корректно совпадать.Однако,поскольку в индекс FTS добавляются дополнительные записи,этот метод использует больше места в базе данных.</target>
        </trans-unit>
        <trans-unit id="af625b5ec940a13ac3f0b796c61917d55c083bf9" translate="yes" xml:space="preserve">
          <source>For functions that accept &quot;</source>
          <target state="translated">Для функций,которые принимают &quot;</target>
        </trans-unit>
        <trans-unit id="8e0c304ceb8d93d914d671ff91751c10ea1ee104" translate="yes" xml:space="preserve">
          <source>For functions that accept JSON as their first argument, that argument can be a JSON object, array, number, string, or null. SQLite numeric values and NULL values are interpreted as JSON numbers and nulls, respectively. SQLite text values can be understood as JSON objects, arrays, or strings. If an SQLite text value that is not a well-formed JSON object, array, or string is passed into json1 function, that function will usually throw an error. (Exceptions to this rule are &lt;a href=&quot;json1#jvalid&quot;&gt;json_valid()&lt;/a&gt; and &lt;a href=&quot;json1#jquote&quot;&gt;json_quote()&lt;/a&gt;.)</source>
          <target state="translated">Для функций, которые принимают JSON в качестве первого аргумента, этот аргумент может быть объектом JSON, массивом, числом, строкой или нулем. Числовые значения SQLite и значения NULL интерпретируются как числа JSON и значения NULL соответственно. Текстовые значения SQLite можно понимать как объекты JSON, массивы или строки. Если текстовое значение SQLite, которое не является правильно сформированным объектом JSON, массивом или строкой, передается в функцию json1, эта функция обычно вызывает ошибку. (Исключениями из этого правила являются &lt;a href=&quot;json1#jvalid&quot;&gt;json_valid ()&lt;/a&gt; и &lt;a href=&quot;json1#jquote&quot;&gt;json_quote ()&lt;/a&gt; .)</target>
        </trans-unit>
        <trans-unit id="f4454df1a142f9ac3cdff944002d68d2bfdcbcbb" translate="yes" xml:space="preserve">
          <source>For functions that accept PATH arguments, that PATH must be well-formed or else the function will throw an error. A well-formed PATH is a text value that begins with exactly one '$' character followed by zero or more instances of &quot;.</source>
          <target state="translated">Для функций,которые принимают аргументы PATH,этот PATH должен быть хорошо сформирован,иначе функция выдаст ошибку.Хорошо сформированный PATH-это текстовое значение,которое начинается ровно с одного символа '$',за которым следует ноль или несколько экземпляров &quot;.</target>
        </trans-unit>
        <trans-unit id="8848d7d3d9820023afd4f5c595baf809ffcb7c92" translate="yes" xml:space="preserve">
          <source>For general use in cases where the workload contains few UPDATE or DELETE operations, a good choice for automerge is 8. If the workload contains many UPDATE or DELETE commands, or if query speed is a concern, it may be advantageous to reduce automerge to 2.</source>
          <target state="translated">Для общего использования в случаях,когда рабочая нагрузка содержит мало операций UPDATE или DELETE,хорошим выбором для automerge является 8.Если рабочая нагрузка содержит много команд UPDATE или DELETE,или если речь идет о скорости запроса,то может быть выгодно уменьшить automerge до 2.</target>
        </trans-unit>
        <trans-unit id="bf5110604d852a2448723644607996c9499bf3c7" translate="yes" xml:space="preserve">
          <source>For historic compatibility, the C-language interfaces return primary result codes by default. The extended result code for the most recent error can be retrieved using the &lt;a href=&quot;c3ref/errcode&quot;&gt;sqlite3_extended_errcode()&lt;/a&gt; interface. The &lt;a href=&quot;c3ref/extended_result_codes&quot;&gt;sqlite3_extended_result_codes()&lt;/a&gt; interface can be used to put a &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; into a mode where it returns the extended result codes instead of the primary result codes.</source>
          <target state="translated">Для исторической совместимости интерфейсы на языке C по умолчанию возвращают первичные коды результатов. Расширенный код результата для самой последней ошибки можно получить с помощью интерфейса &lt;a href=&quot;c3ref/errcode&quot;&gt;sqlite3_extended_errcode ()&lt;/a&gt; . Интерфейс &lt;a href=&quot;c3ref/extended_result_codes&quot;&gt;sqlite3_extended_result_codes ()&lt;/a&gt; можно использовать для &lt;a href=&quot;c3ref/sqlite3&quot;&gt;перевода соединения&lt;/a&gt; с базой данных в режим, в котором он возвращает расширенные коды результатов вместо основных кодов результатов.</target>
        </trans-unit>
        <trans-unit id="17b53a99ea41c50893270b0043884f065027650e" translate="yes" xml:space="preserve">
          <source>For historical reasons, and for efficiency, all sorting is currently done in memory.</source>
          <target state="translated">По историческим причинам,а также в целях эффективности,вся сортировка в настоящее время производится в памяти.</target>
        </trans-unit>
        <trans-unit id="eeed22fa30af9d54901acfbf4c1ce1f017feb462" translate="yes" xml:space="preserve">
          <source>For integer substitutions (%d, %i, %x, %X, %o, and %p) the precision specifies minimum number of digits to display. Leading zeros are added if necessary, to expand the output to the minimum number of digits.</source>
          <target state="translated">Для целых чисел (%d,%i,%x,%X,%o и %p)точность задает минимальное количество отображаемых цифр.При необходимости добавляются ведущие нули,чтобы расширить вывод до минимального количества цифр.</target>
        </trans-unit>
        <trans-unit id="6f753dacad85542947673dd8fa7db3bccc0a7592" translate="yes" xml:space="preserve">
          <source>For maximum reliability and for robustness against database corruption, SQLite should always be run with its default synchronous setting of FULL.</source>
          <target state="translated">Для максимальной надежности и устойчивости к повреждениям базы данных,SQLite всегда должен быть запущен с синхронной установкой по умолчанию FULL.</target>
        </trans-unit>
        <trans-unit id="489e54409f8b7e0829c336efb96f4282b5ccf13a" translate="yes" xml:space="preserve">
          <source>For more details, refer to the comments in &lt;a href=&quot;http://sqlite.org/src/doc/trunk/ext/rbu/sqlite3rbu.h&quot;&gt;header file sqlite3rbu.h&lt;/a&gt;.</source>
          <target state="translated">Дополнительные сведения см. В комментариях в &lt;a href=&quot;http://sqlite.org/src/doc/trunk/ext/rbu/sqlite3rbu.h&quot;&gt;заголовочном файле sqlite3rbu.h&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4e6f70ecf49e4210656602d693e569fcb03d8193" translate="yes" xml:space="preserve">
          <source>For most applications, the recommended method for building SQLite is to use &lt;a href=&quot;amalgamation&quot;&gt;the amalgamation&lt;/a&gt; code file, &lt;b&gt;sqlite3.c&lt;/b&gt;, and its corresponding header file &lt;b&gt;sqlite3.h&lt;/b&gt;. The sqlite3.c code file should compile and run on any unix, Windows system without any changes or special compiler options. Most applications can simply include the sqlite3.c file together with the other C code files that make up the application, compile them all together, and have working and well configured version of SQLite.</source>
          <target state="translated">Для большинства приложений рекомендуемый метод построения SQLite - использовать файл кода &lt;a href=&quot;amalgamation&quot;&gt;объединения &lt;/a&gt;&lt;b&gt;sqlite3.c&lt;/b&gt; и соответствующий ему файл заголовка &lt;b&gt;sqlite3.h&lt;/b&gt; . Файл кода sqlite3.c должен компилироваться и запускаться в любой системе UNIX или Windows без каких-либо изменений или специальных параметров компилятора. Большинство приложений могут просто включать файл sqlite3.c вместе с другими файлами кода C, составляющими приложение, компилировать их все вместе и иметь работающую и хорошо настроенную версию SQLite.</target>
        </trans-unit>
        <trans-unit id="99e3c9a88b32764d83bb0da10699b12fcd9a531f" translate="yes" xml:space="preserve">
          <source>For most applications, upgrading from the legacy query planner to the NGQP requires little thought or effort. Simply replace the older SQLite version with the newer version of SQLite and recompile and the application will run faster. There are no API changes nor modifications to compilation procedures.</source>
          <target state="translated">Для большинства приложений переход с устаревшего планировщика запросов на NGQP не требует особых размышлений и усилий.Просто замените старую версию SQLite на более новую и перекомпилируйте,и приложение будет работать быстрее.Никаких изменений API или модификаций процедур компиляции не происходит.</target>
        </trans-unit>
        <trans-unit id="0efe87a820fa8cd327d2f74d3e3f1deb32107fb9" translate="yes" xml:space="preserve">
          <source>For most cases, it is true that potential attackers have no way of injecting arbitrary SQL, and so most uses of SQLite are immune to the attack above. But there are some notable exceptions. To wit:</source>
          <target state="translated">В большинстве случаев потенциальные злоумышленники не имеют возможности внедрить произвольный SQL,поэтому большинство способов использования SQLite невосприимчивы к вышеописанной атаке.Но есть некоторые примечательные исключения.В частности:</target>
        </trans-unit>
        <trans-unit id="c86754da6df36988096aed27dea948d5f58eceba" translate="yes" xml:space="preserve">
          <source>For most non-trivial SQL databases, the key to performance is creating the right SQL indexes. In this context &quot;the right SQL indexes&quot; means those that cause the queries that an application needs to optimize run fast. The &quot;.expert&quot; command can assist with this by proposing indexes that might assist with specific queries, were they present in the database.</source>
          <target state="translated">Для большинства нетривиальных баз данных SQL ключом к производительности является создание правильных индексов SQL.В данном контексте &quot;правильные SQL-индексы&quot; означают те,которые вызывают запросы,которые необходимо оптимизировать для быстрой работы приложения.Команда &quot;.эксперт&quot; может помочь в этом,предлагая индексы,которые могли бы помочь с конкретными запросами,если бы они присутствовали в БД.</target>
        </trans-unit>
        <trans-unit id="e0fd582fdc761484a0a0ca3bb5f583aafab7cdf5" translate="yes" xml:space="preserve">
          <source>For most purposes, SQLite can be built just fine using the default compilation options. However, if required, the compile-time options documented below can be used to &lt;a href=&quot;#omitfeatures&quot;&gt;omit SQLite features&lt;/a&gt; (resulting in a &lt;a href=&quot;footprint&quot;&gt;smaller compiled library size&lt;/a&gt;) or to change the &lt;a href=&quot;#defaults&quot;&gt;default values&lt;/a&gt; of some parameters.</source>
          <target state="translated">В большинстве случаев SQLite может быть легко собран с использованием параметров компиляции по умолчанию. Однако, при необходимости, параметры времени компиляции, описанные ниже, можно использовать для &lt;a href=&quot;#omitfeatures&quot;&gt;исключения функций SQLite&lt;/a&gt; (что приводит к &lt;a href=&quot;footprint&quot;&gt;уменьшению размера скомпилированной библиотеки&lt;/a&gt; ) или для изменения &lt;a href=&quot;#defaults&quot;&gt;значений&lt;/a&gt; некоторых параметров по умолчанию .</target>
        </trans-unit>
        <trans-unit id="932b2392df531ace28cd032a80948aba14e668af" translate="yes" xml:space="preserve">
          <source>For much of its history SQLite has been focused on 100% MC/DC testing. Resistance to fuzzing attacks only became a concern with the introduction of AFL in 2014. For a while there, fuzzers were finding many problems in SQLite. In more recent years, the testing strategy of SQLite has evolved to place more emphasis on fuzz testing. We still maintain 100% MC/DC of the core SQLite code, but most testing CPU cycles are now devoted to fuzzing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be3d8fa3ad8b3f16b5f81b3d35db241bab90e030" translate="yes" xml:space="preserve">
          <source>For multi-threaded applications that are careful about how they manage threads, SQLite supports an alternative run-time configuration that is half way between not using any mutexes and the default situation of mutexing everything in sight. This in-the-middle mutex alignment can be established as follows:</source>
          <target state="translated">Для многопоточных приложений,которые заботятся о том,как они управляют потоками,SQLite поддерживает альтернативную конфигурацию времени выполнения,которая находится на полпути между неиспользованием каких-либо мьютексов и ситуацией,когда по умолчанию мьютексные приложения используют все,что попадается на глаза.Такое выравнивание мьютексов в среднем может быть установлено следующим образом:</target>
        </trans-unit>
        <trans-unit id="5bfaf72720042391e9725050a2097ea765a5277e" translate="yes" xml:space="preserve">
          <source>For newer applications, FTS4 is recommended; though if compatibility with older versions of SQLite is important, then FTS3 will usually serve just as well.</source>
          <target state="translated">Для новых приложений рекомендуется FTS4,хотя если важна совместимость со старыми версиями SQLite,то FTS3,как правило,будет служить также хорошо.</target>
        </trans-unit>
        <trans-unit id="74f1cec569d928f5163be03c8f3a97d88c4bb5d9" translate="yes" xml:space="preserve">
          <source>For non-TEMP triggers, the table to be modified or queried must exist in the same database as the table or view to which the trigger is attached. TEMP triggers are not subject to the same-database rule. A TEMP trigger is allowed to query or modify any table in any &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt;-ed database.</source>
          <target state="translated">Для триггеров, не относящихся к TEMP, таблица, которую нужно изменить или запросить, должна существовать в той же базе данных, что и таблица или представление, к которым привязан триггер. Триггеры TEMP не подчиняются правилу одной и той же базы данных. Триггеру TEMP разрешено запрашивать или изменять любую таблицу в любой базе данных с &lt;a href=&quot;lang_attach&quot;&gt;функцией ATTACH&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="eaf4afda655b698c5089cf162bb3637b1ddce067" translate="yes" xml:space="preserve">
          <source>For numeric data, this situation is more complex. If both inputs look like well-formed numbers, then they are converted into floating point values using &lt;b&gt;atof()&lt;/b&gt; and compared numerically. If one input is not a well-formed number but the other is, then the number is considered to be less than the non-number. If neither inputs is a well-formed number, then &lt;b&gt;strcmp()&lt;/b&gt; is used to do the comparison.</source>
          <target state="translated">Для числовых данных ситуация более сложная. Если оба ввода выглядят как правильно сформированные числа, то они преобразуются в значения с плавающей запятой с помощью &lt;b&gt;atof ()&lt;/b&gt; и сравниваются численно. Если одно входное число не является правильно сформированным числом, а другое - числом, то считается, что число меньше числа, не являющегося числом. Если ни один из входных данных не является правильным числом, для сравнения используется &lt;b&gt;strcmp ()&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="11d66790f63457992337a522f75d0ba8c19d49c3" translate="yes" xml:space="preserve">
          <source>For ordinary FTS3/FTS4 queries, the search tree depth is approximately the base-2 logarithm of the number of terms in the right-hand side of the MATCH operator. However, for &lt;a href=&quot;fts3#phrase&quot;&gt;phrase queries&lt;/a&gt; and &lt;a href=&quot;fts3#near&quot;&gt;NEAR queries&lt;/a&gt; the search tree depth is linear in the number of right-hand side terms. So the default depth limit of 12 is sufficient for up to 4095 ordinary terms on a MATCH, it is only sufficient for 11 or 12 phrase or NEAR terms. Even so, the default is more than enough for most application.</source>
          <target state="translated">Для обычных запросов FTS3 / FTS4 глубина дерева поиска приблизительно равна логарифму по основанию 2 числа терминов в правой части оператора MATCH. Однако для &lt;a href=&quot;fts3#phrase&quot;&gt;фразовых запросов&lt;/a&gt; и запросов &lt;a href=&quot;fts3#near&quot;&gt;NEAR&lt;/a&gt; глубина дерева поиска линейна в зависимости от количества элементов в правой части. Таким образом, предела глубины по умолчанию 12 достаточно для 4095 обычных терминов в MATCH, этого достаточно только для 11 или 12 фраз или NEAR терминов. Даже в этом случае значения по умолчанию более чем достаточно для большинства приложений.</target>
        </trans-unit>
        <trans-unit id="87e6be4eb608f1997fb25355e4537ee88db28dd4" translate="yes" xml:space="preserve">
          <source>For performance measurement, SQLite is compiled in approximately the same way as it would be for use in production systems. The compile-time configuration is &quot;approximate&quot; in the sense that every production use of SQLite is different. Compile-time options used by one system are not necessarily the same as those used by others. The key point is that options that significantly impact the generated machine code are avoided. For example, the -DSQLITE_DEBUG option is omitted because that option inserts thousands of assert() statements in the middle of performance critical sections of the SQLite library. The -pg option (on GCC) is omitted because it causes the compiler to emit extra probabilistic performance measuring code which interferes with actual performance measurements.</source>
          <target state="translated">Для измерения производительности SQLite компилируется примерно так же,как и для использования в производственных системах.Конфигурация времени компиляции является &quot;приблизительной&quot; в том смысле,что каждое производственное использование SQLite отличается.Варианты времени компиляции,используемые в одной системе,не обязательно совпадают с вариантами,используемыми в других системах.Ключевым моментом является то,что опции,которые существенно влияют на генерируемый машинный код,избегаются.Например,опция -DSQLITE_DEBUG опущена,потому что она вставляет тысячи выражений assert()в середине критических секций производительности библиотеки SQLite.Опция -pg (на GCC)опущена,так как она заставляет компилятор выдавать дополнительный вероятностный код измерения производительности,который мешает фактическим измерениям производительности.</target>
        </trans-unit>
        <trans-unit id="f448cd989ab34ec0bc46f3d775e49bf2cb96fd96" translate="yes" xml:space="preserve">
          <source>For performance measurements, the -Os option is used (optimize for size) rather than -O2 because the -O2 option creates so much code movement that it is difficult to associate specific CPU instructions to C source code lines.</source>
          <target state="translated">Для измерения производительности используется опция -OO (оптимизация под размер),а не -O2,потому что опция -O2 создает столько движения кода,что трудно связать конкретные инструкции процессора со строками исходного кода на C.</target>
        </trans-unit>
        <trans-unit id="5c184bd0f5295912e4ff3123f4057a4db6895161" translate="yes" xml:space="preserve">
          <source>For performance reasons, it is advantageous to &lt;b&gt;minimize the quantity of data read and written&lt;/b&gt; to and from the file-system.</source>
          <target state="translated">По соображениям производительности выгодно &lt;b&gt;минимизировать количество данных, считываемых и записываемых&lt;/b&gt; в файловую систему и из нее .</target>
        </trans-unit>
        <trans-unit id="07b863ed3fe569c9ef5b6a594040618449a6d03c" translate="yes" xml:space="preserve">
          <source>For programs that have a lot of data that must be sifted and sorted in diverse ways, it is often easier and quicker to load the data into an in-memory SQLite database and use queries with joins and ORDER BY clauses to extract the data in the form and order needed rather than to try to code the same operations manually. Using an SQL database internally in this way also gives the program greater flexibility since new columns and indices can be added without having to recode every query.</source>
          <target state="translated">Для программ с большим количеством данных,которые необходимо просеивать и сортировать различными способами,часто проще и быстрее загрузить данные в базу данных SQLite в памяти и использовать запросы с соединениями и пунктами ORDER BY для извлечения данных в нужном виде и порядке,а не пытаться кодировать одни и те же операции вручную.Внутреннее использование базы данных SQL также дает программе большую гибкость,так как можно добавлять новые столбцы и индексы без необходимости перекодировать каждый запрос.</target>
        </trans-unit>
        <trans-unit id="9dd6714e0fb0a2d212f83820882b4bc1eae38324" translate="yes" xml:space="preserve">
          <source>For queries that use OR expressions, or those that use LIMIT or return many rows, the 'y' matchinfo option may be faster than 'x'.</source>
          <target state="translated">Для запросов,использующих выражения ИЛИ,или тех,которые используют LIMIT или возвращают много строк,опция 'y' matchinfo может быть быстрее,чем 'x'.</target>
        </trans-unit>
        <trans-unit id="0c9ccc0a52d5200b9388c921b60acbab7d6fb34e" translate="yes" xml:space="preserve">
          <source>For queries, extract results by calling &lt;a href=&quot;c3ref/column_blob&quot;&gt;sqlite3_column()&lt;/a&gt; in between two calls to &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt;.</source>
          <target state="translated">Для запросов извлекайте результаты, вызывая &lt;a href=&quot;c3ref/column_blob&quot;&gt;sqlite3_column ()&lt;/a&gt; между двумя вызовами &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c5bf18084dc0d97ae369c3088b48ef4a87de7f25" translate="yes" xml:space="preserve">
          <source>For reading database files that are unusually high-risk, such as database files that are received from remote machines, and possibly from anonymous contributors, the following extra precautions might be justified. These added defenses come with performance costs, however, and so may not be appropriate in every situation:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85d9929e5f003ec622c68d9ac564cf73c6c4c155" translate="yes" xml:space="preserve">
          <source>For reading existing zip archives, the Zipfile module provides a &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued function&lt;/a&gt; that accepts a single argument. If the argument is a text value, then it is a path to a zip archive to read from the file-system. Or, if the argument is an SQL blob, then it is the zip archive data itself.</source>
          <target state="translated">Для чтения существующих zip-архивов модуль Zipfile предоставляет возвращающую &lt;a href=&quot;vtab#tabfunc2&quot;&gt;табличное значение функцию,&lt;/a&gt; которая принимает единственный аргумент. Если аргумент - текстовое значение, то это путь к zip-архиву для чтения из файловой системы. Или, если аргумент - это большой двоичный объект SQL, то это сами данные zip-архива.</target>
        </trans-unit>
        <trans-unit id="9867027f324defd1a582c5a9d9007cb8936fd6ce" translate="yes" xml:space="preserve">
          <source>For reasons of backwards compatibility, the &quot;automerge=1&quot; command sets the automerge parameter to 8, not 1 (a value of 1 would make no sense anyway, as merging data from a single segment is a no-op).</source>
          <target state="translated">Из соображений обратной совместимости команда &quot;automerge=1&quot; устанавливает параметр automerge равным 8,а не 1 (значение 1 все равно не имеет смысла,так как объединение данных из одного сегмента не имеет смысла).</target>
        </trans-unit>
        <trans-unit id="a23d1c74ece13b6a1e6d02aa92a4e6d015b8a626" translate="yes" xml:space="preserve">
          <source>For regular functions, the &lt;b&gt;xFunc&lt;/b&gt; callback is invoked once for each function call. The implementation of xFunc should call one of the &lt;b&gt;sqlite_set_result_...&lt;/b&gt; interfaces to return its result. The &lt;b&gt;sqlite_user_data()&lt;/b&gt; routine can be used to retrieve the &lt;b&gt;pUserData&lt;/b&gt; pointer that was passed in when the function was registered.</source>
          <target state="translated">Для обычных функций &lt;b&gt;обратный&lt;/b&gt; вызов &lt;b&gt;xFunc&lt;/b&gt; вызывается один раз для каждого вызова функции. Реализация xFunc должна вызывать один из интерфейсов &lt;b&gt;sqlite_set_result _...&lt;/b&gt; для возврата результата. &lt;b&gt;Sqlite_user_data ()&lt;/b&gt; процедура может быть использована для получения &lt;b&gt;pUserData&lt;/b&gt; указателя , который был принят в том, когда функция была зарегистрирована.</target>
        </trans-unit>
        <trans-unit id="d0ed67ff8b79adf22c16c2b1f3556a389aea4a01" translate="yes" xml:space="preserve">
          <source>For resilience when confronted with historical SQL statements, SQLite will sometimes bend the quoting rules above:</source>
          <target state="translated">Для обеспечения устойчивости при столкновении с историческими SQL-запросами,SQLite иногда будет изгибать правила цитирования,приведенные выше:</target>
        </trans-unit>
        <trans-unit id="e7eae9c3102a4115cf6fa58568800e787b48e7a4" translate="yes" xml:space="preserve">
          <source>For security reasons, extension loaded is turned off by default and must be enabled by a prior call to &lt;a href=&quot;c3ref/enable_load_extension&quot;&gt;sqlite3_enable_load_extension()&lt;/a&gt;.</source>
          <target state="translated">По соображениям безопасности загруженное расширение по умолчанию отключено и должно быть включено предварительным вызовом &lt;a href=&quot;c3ref/enable_load_extension&quot;&gt;sqlite3_enable_load_extension ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c4880044a5796d62d55405bede28ef5f4f52805b" translate="yes" xml:space="preserve">
          <source>For security reasons, extension loading is turned off by default. In order to use either the C-language or SQL extension loading functions, one must first enable extension loading using the &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigenableloadextension&quot;&gt;SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION&lt;/a&gt;,1,NULL) C-language API in your application.</source>
          <target state="translated">По соображениям безопасности загрузка расширений по умолчанию отключена. Чтобы использовать функции загрузки расширения на языке C или SQL, необходимо сначала включить загрузку расширения с помощью API-интерфейса языка C &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config&lt;/a&gt; (db, &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigenableloadextension&quot;&gt;SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION&lt;/a&gt; , 1, NULL) в вашем приложении.</target>
        </trans-unit>
        <trans-unit id="90f079fcf7344dc268fa3af2372e90f48b6aca40" translate="yes" xml:space="preserve">
          <source>For security reasons, it is recommended that applications first set &lt;a href=&quot;pragma#pragma_trusted_schema&quot;&gt;PRAGMA trusted_schema=OFF&lt;/a&gt; or run the &quot;&lt;a href=&quot;#config&quot;&gt;db config trusted_schema 0&lt;/a&gt;&quot; method before using this method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92cbc8f2d6b97260523c5a56f27aa3c653ce65fe" translate="yes" xml:space="preserve">
          <source>For signed numeric substitutions, include a &quot;+&quot; sign before positive numbers. A &quot;-&quot; sign always appears before negative numbers regardless of flag settings.</source>
          <target state="translated">Для подписанных числовых подстановок перед положительными числами необходимо включить знак &quot;+&quot;.Знак &quot;-&quot; всегда появляется перед отрицательными числами независимо от установки флагов.</target>
        </trans-unit>
        <trans-unit id="0a389ef1f84e1f5ea12705422f16f304415d7e84" translate="yes" xml:space="preserve">
          <source>For signed numeric substitutions, prepend a single space before positive numbers.</source>
          <target state="translated">Для подписанных числовых замен представьте один пробел перед положительными числами.</target>
        </trans-unit>
        <trans-unit id="8361cfb2d567750344a1d16c228e8f02d706a6ad" translate="yes" xml:space="preserve">
          <source>For simple queries against a single table with few indexes, there is usually an obvious choice for the best algorithm. But for larger and more complex queries, such as multi-way joins with many indexes and subqueries, there can be hundreds, thousands, or millions of reasonable algorithms for computing the result. The job of the query planner is to choose the single &quot;best&quot; query plan from this multitude of possibilities.</source>
          <target state="translated">Для простых запросов к одной таблице с несколькими индексами,как правило,существует очевидный выбор лучшего алгоритма.Но для более крупных и сложных запросов,таких как многопутевые соединения со многими индексами и подзапросами,могут существовать сотни,тысячи или миллионы разумных алгоритмов для вычисления результата.Задача планировщика запросов состоит в том,чтобы из этого множества возможностей выбрать единственный &quot;лучший&quot; план запроса.</target>
        </trans-unit>
        <trans-unit id="a9d77b186d3d3bf7ae8219371bcb8b76fedae519" translate="yes" xml:space="preserve">
          <source>For small databases and modern CPUs, there is usually no reason not to pass &quot;--sample 100&quot;. However, gathering data distribution statistics can be expensive for large database tables. If the operation is too slow, try passing a smaller value for the --sample option.</source>
          <target state="translated">Для небольших баз данных и современных процессоров,как правило,нет причин не сдавать &quot;-образец 100&quot;.Однако сбор статистики распределения данных может быть дорогостоящим для больших таблиц баз данных.Если операция слишком медленная,попробуйте передать меньшее значение для опции &quot;-образца&quot;.</target>
        </trans-unit>
        <trans-unit id="a4a24ddee4d5daf8ddd5ba8dfd7d48787ebb03b7" translate="yes" xml:space="preserve">
          <source>For string substitutions (%s, %z, %q, %Q, or %w) the precision is the number of byte or character used from the argument. The number is bytes by default but is characters if the &quot;!&quot; flag is present. If there is no precision, then the entire string is substituted. Examples: &quot;%.3s&quot; substitutes the first 3 bytes of the argument string. &quot;%!.3s&quot; substitutes the first three characters of the argument string.</source>
          <target state="translated">Для подстановок строк (%s,%z,%q,%Q или %w)точность-это количество байтов или символов,используемых в аргументе.По умолчанию это количество байт,но это символы,если присутствует флаг &quot;!&quot;.Если нет точности,то подставляется вся строка.Примеры:&quot;%.3s&quot; заменяет первые 3 байта строки аргумента.&quot;%!.3s&quot; заменяет первые три символа строки аргумента.</target>
        </trans-unit>
        <trans-unit id="e7573ff9c5daeb6537cacfee96e59061a43495a3" translate="yes" xml:space="preserve">
          <source>For subprograms, there is a bitmask in the VdbeFrame that determines whether or not the jump should be taken. The bitmask is necessary because the self-altering code trick does not work for recursive triggers.</source>
          <target state="translated">Для подпрограмм в VdbeFrame есть битовая маска,которая определяет,следует ли выполнять прыжок или нет.Битовая маска необходима,так как трюк с самоизменяющимся кодом не работает для рекурсивных триггеров.</target>
        </trans-unit>
        <trans-unit id="1ef6b92612835372e131287be2c793df5805bcf9" translate="yes" xml:space="preserve">
          <source>For table columns, the datatype is determined by the type declaration of the CREATE TABLE statement. The datatype is text if and only if the type declaration contains one or more of the following strings:</source>
          <target state="translated">Для столбцов таблицы тип данных определяется объявлением типа оператора CREATE TABLE.Типом данных является текст,если и только если объявление типа содержит одну или более из следующих строк:</target>
        </trans-unit>
        <trans-unit id="7117d5cbbb5730360ccac5d30c1470b52beef293" translate="yes" xml:space="preserve">
          <source>For testing on embedded systems, the mkth3.tcl script and the compiler steps shown above are performed on an ordinary workstation using a cross-compiler, then the resulting test program is transferred onto the device to be run.</source>
          <target state="translated">Для тестирования на встраиваемых системах скрипт mkth3.tcl и показанные выше шаги компилятора выполняются на обычной рабочей станции с помощью кросс-компилятора,после чего результирующая тестовая программа переносится на запускаемое устройство.</target>
        </trans-unit>
        <trans-unit id="d2eb4ede923268e657583d146fd6fd411d8b52aa" translate="yes" xml:space="preserve">
          <source>For the --insert command, all files listed are inserted into the archive. For the --update command, files are only inserted if they do not previously exist in the archive, or if their &quot;mtime&quot; or &quot;mode&quot; is different from what is currently in the archive.</source>
          <target state="translated">Для команды --insert все перечисленные файлы вставляются в архив.Для команды --update файлы вставляются только в том случае,если они ранее не существовали в архиве,или если их &quot;mtime&quot; или &quot;mode&quot; отличается от того,что находится в архиве в данный момент.</target>
        </trans-unit>
        <trans-unit id="0d9d2265812b12b9762e700ccc4ceb3931ebf930" translate="yes" xml:space="preserve">
          <source>For the C-language interfaces, the argument is an integer which is interpreted as a character. For the &lt;a href=&quot;lang_corefunc#printf&quot;&gt;printf() SQL function&lt;/a&gt; the argument is a string from which the first character is extracted and displayed.</source>
          <target state="translated">Для интерфейсов на языке C аргументом является целое число, которое интерпретируется как символ. Для &lt;a href=&quot;lang_corefunc#printf&quot;&gt;функции SQL printf ()&lt;/a&gt; аргументом является строка, из которой извлекается и отображается первый символ.</target>
        </trans-unit>
        <trans-unit id="c95ceb997c597a8e6a21b33cbd1c20d5ac14d94b" translate="yes" xml:space="preserve">
          <source>For the GLOB operator, the column must be indexed using the built-in BINARY collating sequence.</source>
          <target state="translated">Для GLOB-оператора столбец должен быть проиндексирован с помощью встроенной BINARY-колларирующей последовательности.</target>
        </trans-unit>
        <trans-unit id="8b7943406433a1489b27536ff1cedb40c6a83fc4" translate="yes" xml:space="preserve">
          <source>For the LIKE operator, if &lt;a href=&quot;pragma#pragma_case_sensitive_like&quot;&gt;case_sensitive_like&lt;/a&gt; mode is enabled then the column must indexed using BINARY collating sequence, or if &lt;a href=&quot;pragma#pragma_case_sensitive_like&quot;&gt;case_sensitive_like&lt;/a&gt; mode is disabled then the column must indexed using built-in NOCASE collating sequence.</source>
          <target state="translated">Для оператора LIKE, если &lt;a href=&quot;pragma#pragma_case_sensitive_like&quot;&gt;включен&lt;/a&gt; режим case_sensitive_like, столбец должен индексироваться с использованием последовательности сортировки BINARY, или если режим &lt;a href=&quot;pragma#pragma_case_sensitive_like&quot;&gt;case_sensitive_like&lt;/a&gt; отключен, столбец должен индексироваться с использованием встроенной последовательности сортировки NOCASE.</target>
        </trans-unit>
        <trans-unit id="394b73aae0d0953d9f85a4d75a67f00c2d16e226" translate="yes" xml:space="preserve">
          <source>For the SELECT statement above, the optimizer can use the ex2i1 index to lookup rows of ex2 that contain x=5 and then test each row against the y=6 term. Or it can use the ex2i2 index to lookup rows of ex2 that contain y=6 then test each of those rows against the x=5 term.</source>
          <target state="translated">Для приведенного выше утверждения SELECT оптимизатор может использовать индекс ex2i1 для поиска строк ex2,которые содержат x=5,а затем проверить каждую строку на предмет y=6.Или же он может использовать индекс ex2i2 для поиска строк ex2,которые содержат y=6,а затем проверить каждую из этих строк на соответствие термину x=5.</target>
        </trans-unit>
        <trans-unit id="6880a2956aa62196c20844c37991ebf1c9cc0265" translate="yes" xml:space="preserve">
          <source>For the character substitution (%c) a precision N greater than 1 causes the character to be repeated N times. This is a non-standard extension found only in SQLite.</source>
          <target state="translated">Для подстановки символов (%c)точность N больше 1 приводит к повторению символа N раз.Это нестандартное расширение встречается только в SQLite.</target>
        </trans-unit>
        <trans-unit id="cbfa8c438ab75aa5b53746b3a61a2493fdc0fcad" translate="yes" xml:space="preserve">
          <source>For the common case where we want the busy callback to sleep, the SQLite library provides a convenience routine &lt;b&gt;sqlite_busy_timeout&lt;/b&gt;. The first argument to &lt;b&gt;sqlite_busy_timeout&lt;/b&gt; is a pointer to an open SQLite database and the second argument is a number of milliseconds. After &lt;b&gt;sqlite_busy_timeout&lt;/b&gt; has been executed, the SQLite library will wait for the lock to clear for at least the number of milliseconds specified before it returns SQLITE_BUSY. Specifying zero milliseconds for the timeout restores the default behavior.</source>
          <target state="translated">Для общего случая, когда мы хотим, чтобы обратный вызов занятости переходил в спящий режим, библиотека SQLite предоставляет удобную процедуру &lt;b&gt;sqlite_busy_timeout&lt;/b&gt; . Первый аргумент &lt;b&gt;sqlite_busy_timeout&lt;/b&gt; - это указатель на открытую базу данных SQLite, а второй аргумент - количество миллисекунд. После выполнения &lt;b&gt;sqlite_busy_timeout&lt;/b&gt; библиотека SQLite будет ждать &lt;b&gt;снятия&lt;/b&gt; блокировки в течение по крайней мере указанного количества миллисекунд, прежде чем она вернет SQLITE_BUSY. Указание нулевых миллисекунд для тайм-аута восстанавливает поведение по умолчанию.</target>
        </trans-unit>
        <trans-unit id="77995af2794868d5e3e1a545ee53f68c9abf9c9a" translate="yes" xml:space="preserve">
          <source>For the index above and WHERE clause like this:</source>
          <target state="translated">Для вышеприведенного индекса и пункта ГДЕ,подобного этому:</target>
        </trans-unit>
        <trans-unit id="bb541928f8f21ef53252b3fcd58c0333fdfa446f" translate="yes" xml:space="preserve">
          <source>For the most part, ordinary rowid tables and WITHOUT ROWID tables are interchangeable. But there are some additional restrictions on WITHOUT ROWID tables that do not apply to ordinary rowid tables:</source>
          <target state="translated">По большей части обычные таблицы rowid и таблицы WITHOUT ROWID являются взаимозаменяемыми.Но есть некоторые дополнительные ограничения для таблиц БЕЗ ROWID,которые не применимы к обычным rowid таблицам:</target>
        </trans-unit>
        <trans-unit id="bee902327ddee3eaa34014db30d1eb9d18663957" translate="yes" xml:space="preserve">
          <source>For the purpose of computing window functions, the result set of a query is divided into one or more &quot;partitions&quot;. A partition consists of all rows that have the same value for all terms of the PARTITION BY clause in the window-defn. If there is no PARTITION BY clause, then the entire result set of the query is a single partition. Window-function processing is performed separately for each partition.</source>
          <target state="translated">Для вычисления оконных функций результирующий набор запроса делится на один или несколько &quot;простенков&quot;.Раздел состоит из всех строк,которые имеют одинаковое значение для всех условий пункта PARTITION BY в окне-defn.Если пункт PARTITION BY отсутствует,то весь результирующий набор запроса представляет собой один простенок.Обработка функции окна выполняется отдельно для каждого раздела.</target>
        </trans-unit>
        <trans-unit id="b3fd877f7b6778afbc1e68eb5017d97a2b27eeb2" translate="yes" xml:space="preserve">
          <source>For the purpose of the &lt;b&gt;sqlite_complete&lt;/b&gt; function, an SQL statement is complete if it ends in a semicolon.</source>
          <target state="translated">Для функции &lt;b&gt;sqlite_complete&lt;/b&gt; оператор SQL считается завершенным, если он заканчивается точкой с запятой.</target>
        </trans-unit>
        <trans-unit id="3bdae1911eb2b3c855db66c9e8e796a26c988410" translate="yes" xml:space="preserve">
          <source>For the purposes of determining duplicate rows for the results of compound SELECT operators, NULL values are considered equal to other NULL values and distinct from all non-NULL values. The collation sequence used to compare two text values is determined as if the columns of the left and right-hand SELECT statements were the left and right-hand operands of the equals (=) operator, except that greater precedence is not assigned to a collation sequence specified with the postfix COLLATE operator. No affinity transformations are applied to any values when comparing rows as part of a compound SELECT.</source>
          <target state="translated">Для целей определения дублирующих строк по результатам сложных операторов SELECT значения NULL считаются равными другим значениям NULL и отличными от всех не нулевых значений.Последовательность столбцов,используемая для сравнения двух текстовых значений,определяется так,как если бы столбцы левого и правого операторов SELECT были левым и правым операторами оператора equals (=),за исключением того,что больший приоритет не присваивается последовательности столбцов,заданной с помощью постфиксного оператора COLLATE.При сравнении строк в составе составного SELECT к каким-либо значениям не применяются аффинные преобразования.</target>
        </trans-unit>
        <trans-unit id="593804fd692754b9bd9050d15e0853bf78663ff7" translate="yes" xml:space="preserve">
          <source>For the purposes of determining validity, leading and trailing whitespace on JSON inputs is ignored. Interior whitespace is also ignored, in accordance with the JSON spec. These routines accept exactly the &lt;a href=&quot;http://www.rfc-editor.org/rfc/rfc7159.txt&quot;&gt;rfc-7159 JSON syntax&lt;/a&gt; &amp;mdash; no more and no less.</source>
          <target state="translated">В целях определения действительности начальные и конечные пробелы во входных данных JSON игнорируются. Внутренние пробелы также игнорируются в соответствии со спецификацией JSON. Эти процедуры принимают в точности &lt;a href=&quot;http://www.rfc-editor.org/rfc/rfc7159.txt&quot;&gt;синтаксис JSON rfc-7159&lt;/a&gt; - не больше и не меньше.</target>
        </trans-unit>
        <trans-unit id="4f71629a5f8d309dcb7934e2a9e496e90193e44f" translate="yes" xml:space="preserve">
          <source>For the purposes of sorting rows, values are compared in the same way as for &lt;a href=&quot;datatype3#comparisons&quot;&gt;comparison expressions&lt;/a&gt;. The collation sequence used to compare two text values is determined as follows:</source>
          <target state="translated">В целях сортировки строк значения сравниваются так же, как и для &lt;a href=&quot;datatype3#comparisons&quot;&gt;выражений сравнения&lt;/a&gt; . Последовательность сопоставления, используемая для сравнения двух текстовых значений, определяется следующим образом:</target>
        </trans-unit>
        <trans-unit id="15ea441aee0df5dfef81b948679ce855bde68d24" translate="yes" xml:space="preserve">
          <source>For the purposes of the previous four items, two database connections that use the same &lt;a href=&quot;sharedcache&quot;&gt;shared cache&lt;/a&gt; and which enable &lt;a href=&quot;pragma#pragma_read_uncommitted&quot;&gt;PRAGMA read_uncommitted&lt;/a&gt; are considered to be the same database connection, not separate database connections.</source>
          <target state="translated">Для целей предыдущих четырех пунктов два соединения с базой данных, которые используют один и тот же &lt;a href=&quot;sharedcache&quot;&gt;общий кеш&lt;/a&gt; и включают &lt;a href=&quot;pragma#pragma_read_uncommitted&quot;&gt;PRAGMA read_uncommitted&lt;/a&gt; , считаются одним и тем же соединением с базой данных, а не отдельными соединениями с базой данных.</target>
        </trans-unit>
        <trans-unit id="206270d8fd15072121eb3d0a56144d865640f2b5" translate="yes" xml:space="preserve">
          <source>For the purposes of the previous two paragraphs, two database connections that have the same &lt;a href=&quot;sharedcache&quot;&gt;shared cache&lt;/a&gt; and which have enabled &lt;a href=&quot;pragma#pragma_read_uncommitted&quot;&gt;PRAGMA read_uncommitted&lt;/a&gt; are considered to be the same database connection.</source>
          <target state="translated">Для целей предыдущих двух параграфов два соединения с базой данных с одним и тем же &lt;a href=&quot;sharedcache&quot;&gt;общим кешем&lt;/a&gt; и с включенной &lt;a href=&quot;pragma#pragma_read_uncommitted&quot;&gt;функцией PRAGMA read_uncommitted&lt;/a&gt; считаются одним и тем же соединением с базой данных.</target>
        </trans-unit>
        <trans-unit id="a17e59e38b9d3bf2b2df3849089638f1437b4d1e" translate="yes" xml:space="preserve">
          <source>For the purposes of this API, a transaction is said to have been rolled back if an explicit &quot;ROLLBACK&quot; statement is executed, or an error or constraint causes an implicit rollback to occur. The rollback callback is not invoked if a transaction is automatically rolled back because the database connection is closed.</source>
          <target state="translated">Для целей этого API считается,что транзакция откатилась,если выполняется явное заявление &quot;ROLLBACK&quot;,или ошибка или ограничение приводит к неявному откату.Обратный откат не вызывается,если транзакция автоматически откатывается,потому что соединение с БД закрыто.</target>
        </trans-unit>
        <trans-unit id="57f69f1f3e95239c1d08d8e626c461a431a40ba6" translate="yes" xml:space="preserve">
          <source>For the purposes of this pragma, the &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; command is considered a schema change, since &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; will usual alter the &quot;rootpage&quot; values for entries in the &lt;a href=&quot;fileformat2#sqlite_master&quot;&gt;sqlite_master table&lt;/a&gt;.</source>
          <target state="translated">Для целей этой прагмы команда &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; считается изменением схемы, поскольку &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; обычно изменяет значения &amp;laquo;корневой страницы&amp;raquo; для записей в &lt;a href=&quot;fileformat2#sqlite_master&quot;&gt;таблице sqlite_master&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a9b750853d344854f9aa1e24acbcd47fcdfc4ad1" translate="yes" xml:space="preserve">
          <source>For the purposes of this pragma, the &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; command is considered a schema change, since &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; will usual alter the &quot;rootpage&quot; values for entries in the &lt;a href=&quot;schematab&quot;&gt;sqlite_schema table&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e03b6c7391fbf0bc56188a8c09cd4a7c0b4cdfb" translate="yes" xml:space="preserve">
          <source>For the purposes of this routine, an &lt;a href=&quot;../lang_insert&quot;&gt;INSERT&lt;/a&gt; is considered to be successful even if it is subsequently rolled back.</source>
          <target state="translated">Для целей этой процедуры &lt;a href=&quot;../lang_insert&quot;&gt;INSERT&lt;/a&gt; считается успешным, даже если он впоследствии откатывается.</target>
        </trans-unit>
        <trans-unit id="4c58e719af76025bd3937a17763f87efc5e13c1f" translate="yes" xml:space="preserve">
          <source>For the purposes of this routine, an &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; is considered to be successful even if it is subsequently rolled back.</source>
          <target state="translated">Для целей этой процедуры &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; считается успешным, даже если он впоследствии откатывается.</target>
        </trans-unit>
        <trans-unit id="105a62f9f913b7c3c03726a4a42a2b6ed86624fa" translate="yes" xml:space="preserve">
          <source>For the purposes of unique indices, all NULL values are considered different from all other NULL values and are thus unique. This is one of the two possible interpretations of the SQL-92 standard (the language in the standard is ambiguous). The interpretation used by SQLite is the same and is the interpretation followed by PostgreSQL, MySQL, Firebird, and Oracle. Informix and Microsoft SQL Server follow the other interpretation of the standard, which is that all NULL values are equal to one another.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="713e891998daa01c37d2616d81cfb2bf2962ac1e" translate="yes" xml:space="preserve">
          <source>For the right-hand table of a LEFT JOIN, compute the values of expressions directly rather than loading precomputed values out of an &lt;a href=&quot;expridx&quot;&gt;expression index&lt;/a&gt; as the expression index might not contain the correct value. Ticket &lt;a href=&quot;https://sqlite.org/src/info/7fa8049685b50b5aeb0c2&quot;&gt;7fa8049685b50b5aeb0c2&lt;/a&gt;</source>
          <target state="translated">Для правой таблицы LEFT JOIN вычисляйте значения выражений напрямую, а не загружайте предварительно вычисленные значения из &lt;a href=&quot;expridx&quot;&gt;индекса выражения,&lt;/a&gt; поскольку индекс выражения может не содержать правильного значения. Билет &lt;a href=&quot;https://sqlite.org/src/info/7fa8049685b50b5aeb0c2&quot;&gt;7fa8049685b50b5aeb0c2&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5c9ca201b99a3489f4b36f53a1d0536e05b123a3" translate="yes" xml:space="preserve">
          <source>For the second case, when the table already exists, every row of the CSV file, including the first row, is assumed to be actual content. If the CSV file contains an initial row of column labels, that row will be read as data and inserted into the table. To avoid this, make sure that table does not previously exist.</source>
          <target state="translated">Во втором случае,когда таблица уже существует,каждая строка CSV-файла,включая первую строку,считается фактическим содержимым.Если CSV-файл содержит начальную строку с метками столбцов,то эта строка будет прочитана как данные и вставлена в таблицу.Чтобы избежать этого,убедитесь,что таблица ранее не существовала.</target>
        </trans-unit>
        <trans-unit id="7bf6df3d98c9980bb0d46166ad84f0bd8834c9ba" translate="yes" xml:space="preserve">
          <source>For the second case, when the table already exists, every row of the CSV file, including the first row, is assumed to be actual content. If the CSV file contains an initial row of column labels, you can cause the .import command to skip that initial row using the &quot;--skip 1&quot; option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d66c18babb7715bc31a6fed2788e6b8d32bfce2" translate="yes" xml:space="preserve">
          <source>For the sqlite3_result_text16(), sqlite3_result_text16le(), and sqlite3_result_text16be() routines, and for sqlite3_result_text64() when the encoding is not UTF8, if the input UTF16 begins with a byte-order mark (BOM, U+FEFF) then the BOM is removed from the string and the rest of the string is interpreted according to the byte-order specified by the BOM. The byte-order specified by the BOM at the beginning of the text overrides the byte-order specified by the interface procedure. So, for example, if sqlite3_result_text16le() is invoked with text that begins with bytes 0xfe, 0xff (a big-endian byte-order mark) then the first two bytes of input are skipped and the remaining input is interpreted as UTF16BE text.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="814f69ac0546d66f0db75207e5064bf283a12829" translate="yes" xml:space="preserve">
          <source>For these reasons, many complex queries may use less memory and run faster using FTS5.</source>
          <target state="translated">По этим причинам многие сложные запросы могут потреблять меньше памяти и быстрее выполняться с помощью FTS5.</target>
        </trans-unit>
        <trans-unit id="7fe943bac7177b3cc26bc016acdb488812414486" translate="yes" xml:space="preserve">
          <source>For these substitutions, the precision is the number of bytes or characters taken from the argument, not the number of bytes or characters that are written into the output.</source>
          <target state="translated">Для таких подстановок точностью является количество байтов или символов,взятых из аргумента,а не количество байтов или символов,которые записываются в выходной файл.</target>
        </trans-unit>
        <trans-unit id="ddecb7fc6ac9ebf678a969f318e2c93050dc15ef" translate="yes" xml:space="preserve">
          <source>For this first experiment, nothing else about the file format is changed. The OpenDocument is still a pile-of-files, only now each file is a row in an SQLite database rather than an entry in a ZIP archive. This simple change does not use the power of a relational database. Even so, this simple change shows some improvements.</source>
          <target state="translated">Для этого первого эксперимента больше ничего не меняется в формате файла.OpenDocument по-прежнему является кучей файлов,только теперь каждый файл является строкой в базе данных SQLite,а не записью в ZIP-архиве.Это простое изменение не использует возможности реляционной базы данных.Тем не менее,это простое изменение показывает некоторые улучшения.</target>
        </trans-unit>
        <trans-unit id="fbfd34ac3082b66cb73eae2395605bfffd9afee2" translate="yes" xml:space="preserve">
          <source>For this form, the &amp;lt;expr&amp;gt; does not have to be an integer. It can evaluate to a real number as long as it is constant and non-negative.</source>
          <target state="translated">Для этой формы &amp;lt;expr&amp;gt; не обязательно должно быть целым числом. Он может быть действительным числом, если он постоянен и неотрицателен.</target>
        </trans-unit>
        <trans-unit id="752d2cd19688f392b69d1efc9ea4707b6423ad4e" translate="yes" xml:space="preserve">
          <source>For this particular UPDATE test, MySQL is consistently five or ten times slower than PostgreSQL and SQLite. I do not know why. MySQL is normally a very fast engine. Perhaps this problem has been addressed in later versions of MySQL.</source>
          <target state="translated">Для данного теста UPDATE,MySQL последовательно в пять или десять раз медленнее,чем PostgreSQL и SQLite.Я не знаю почему.MySQL обычно очень быстрый движок.Возможно,эта проблема была решена в более поздних версиях MySQL.</target>
        </trans-unit>
        <trans-unit id="9db0e6302461b7556c4838a4a6492fc335414fcc" translate="yes" xml:space="preserve">
          <source>For usage hints and a summary of all options, simply give the &lt;a href=&quot;cli&quot;&gt;CLI&lt;/a&gt; the -A option with no additional arguments:</source>
          <target state="translated">Для подсказок по использованию и сводки всех параметров просто дайте &lt;a href=&quot;cli&quot;&gt;CLI&lt;/a&gt; опцию -A без дополнительных аргументов:</target>
        </trans-unit>
        <trans-unit id="c9239816897eb996f78a6efe04536d4eaf0b8d55" translate="yes" xml:space="preserve">
          <source>Force the value in register P1 to be an integer. If the value in P1 is not an integer and cannot be converted into an integer without data loss, then jump immediately to P2, or if P2==0 raise an SQLITE_MISMATCH exception.</source>
          <target state="translated">Заставить значение в регистре P1 быть целым числом.Если значение в P1 не является целым числом и не может быть преобразовано в целое без потери данных,то сразу переходите к P2,или если P2==0 вызывает исключение SQLITE_MISMATCH.</target>
        </trans-unit>
        <trans-unit id="e1652af1b46a8724b09c6398e58d043cf684e88e" translate="yes" xml:space="preserve">
          <source>Force the value in register P1 to be the type defined by P2.</source>
          <target state="translated">Принудите значение в регистре P1 к типу,определенному P2.</target>
        </trans-unit>
        <trans-unit id="c3788028d350f50070224e2ffa767d1574a8ab2d" translate="yes" xml:space="preserve">
          <source>Foreign Key Constraints</source>
          <target state="translated">Ограничения по внешнему ключу</target>
        </trans-unit>
        <trans-unit id="8ea9876246ba7c653355a0ce27076bc76b4c8469" translate="yes" xml:space="preserve">
          <source>Foreign key ON DELETE and ON UPDATE clauses are used to configure actions that take place when deleting rows from the parent table (ON DELETE), or modifying the parent key values of existing rows (ON UPDATE). A single foreign key constraint may have different actions configured for ON DELETE and ON UPDATE. Foreign key actions are similar to triggers in many ways.</source>
          <target state="translated">Иностранный ключ ON DELETE и пункты ON UPDATE используются для настройки действий,которые происходят при удалении строк из родительской таблицы (ON DELETE),или изменении значений родительского ключа существующих строк (ON UPDATE).Одно ограничение по внешнему ключу может иметь различные настройки действий,которые выполняются при удалении строк из родительской таблицы (ON DELETE и ON UPDATE).Действия внешнего ключа похожи на триггеры по многим параметрам.</target>
        </trans-unit>
        <trans-unit id="474365badbb1f3b57e5eb366037b4f712db8f5d1" translate="yes" xml:space="preserve">
          <source>Foreign key actions</source>
          <target state="translated">Зарубежные ключевые действия</target>
        </trans-unit>
        <trans-unit id="d3465e4f63b19b36c358f39673e35fd218b96287" translate="yes" xml:space="preserve">
          <source>Foreign key constraints are disabled by default (for backwards compatibility), so must be enabled separately for each &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt;. (Note, however, that future releases of SQLite might change so that foreign key constraints enabled by default. Careful developers will not make any assumptions about whether or not foreign keys are enabled by default but will instead enable or disable them as necessary.) The application can also use a &lt;a href=&quot;pragma#pragma_foreign_keys&quot;&gt;PRAGMA foreign_keys&lt;/a&gt; statement to determine if foreign keys are currently enabled. The following command-line session demonstrates this:</source>
          <target state="translated">По умолчанию ограничения внешнего ключа отключены (для обратной совместимости), поэтому их необходимо включать отдельно для каждого &lt;a href=&quot;c3ref/sqlite3&quot;&gt;подключения&lt;/a&gt; к базе данных . (Обратите внимание, однако, что будущие выпуски SQLite могут измениться, так что ограничения внешнего ключа будут включены по умолчанию. Внимательные разработчики не будут делать никаких предположений о том, включены ли внешние ключи по умолчанию, а вместо этого будут включать или отключать их по мере необходимости.) приложение также может использовать оператор &lt;a href=&quot;pragma#pragma_foreign_keys&quot;&gt;PRAGMA foreign_keys,&lt;/a&gt; чтобы определить, включены ли в данный момент внешние ключи. Следующий сеанс командной строки демонстрирует это:</target>
        </trans-unit>
        <trans-unit id="fadb49ecb31870fa195b79a63507d69332246c87" translate="yes" xml:space="preserve">
          <source>Foreign key constraints are enabled</source>
          <target state="translated">Введены внешние ключевые ограничения</target>
        </trans-unit>
        <trans-unit id="ce28942b103c42389428127f519c6795e562c011" translate="yes" xml:space="preserve">
          <source>Format 1 is understood by all versions of SQLite back to &lt;a href=&quot;https://sqlite.org/releaselog/3_0_0.html&quot;&gt;version 3.0.0&lt;/a&gt; (2004-06-18).</source>
          <target state="translated">Формат 1 понимается всеми версиями SQLite до &lt;a href=&quot;https://sqlite.org/releaselog/3_0_0.html&quot;&gt;версии 3.0.0&lt;/a&gt; (18.06.2004).</target>
        </trans-unit>
        <trans-unit id="bb846b850c6fa3ff33f8d13f455d688d28aa22d8" translate="yes" xml:space="preserve">
          <source>Format 2 adds the ability of rows within the same table to have a varying number of columns, in order to support the &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE ... ADD COLUMN&lt;/a&gt; functionality. Support for reading and writing format 2 was added in SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_1_3.html&quot;&gt;version 3.1.3&lt;/a&gt; on 2005-02-20.</source>
          <target state="translated">Формат 2 добавляет возможность строк в одной таблице иметь различное количество столбцов, чтобы поддерживать функциональность &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE ... ADD COLUMN&lt;/a&gt; . Поддержка чтения и записи формата 2 была добавлена ​​в SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_1_3.html&quot;&gt;версии 3.1.3&lt;/a&gt; 20 февраля 2005 г.</target>
        </trans-unit>
        <trans-unit id="e74a0202e30c00da07d8e3f647ad619d797750ee" translate="yes" xml:space="preserve">
          <source>Format 3 adds the ability of extra columns added by &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE ... ADD COLUMN&lt;/a&gt; to have non-NULL default values. This capability was added in SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_1_4.html&quot;&gt;version 3.1.4&lt;/a&gt; on 2005-03-11.</source>
          <target state="translated">Формат 3 добавляет возможность дополнительных столбцов, добавленных &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE ... ADD COLUMN,&lt;/a&gt; чтобы иметь значения по умолчанию, отличные от NULL. Эта возможность была добавлена ​​в SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_1_4.html&quot;&gt;версии 3.1.4&lt;/a&gt; 11 марта 2005 г.</target>
        </trans-unit>
        <trans-unit id="6f87214a5c89d4a264dcabc8b3ff76d0ecb7e6ab" translate="yes" xml:space="preserve">
          <source>Format 4 causes SQLite to respect the &lt;a href=&quot;lang_createindex#descidx&quot;&gt;DESC keyword&lt;/a&gt; on index declarations. (The DESC keyword is ignored in indexes for formats 1, 2, and 3.) Format 4 also adds two new boolean record type values (&lt;a href=&quot;fileformat2#serialtype&quot;&gt;serial types&lt;/a&gt; 8 and 9). Support for format 4 was added in SQLite 3.3.0 on 2006-01-10.</source>
          <target state="translated">Формат 4 заставляет SQLite &lt;a href=&quot;lang_createindex#descidx&quot;&gt;учитывать ключевое слово DESC&lt;/a&gt; в объявлениях индекса. (Ключевое слово DESC игнорируется в индексах для форматов 1, 2 и 3.) Формат 4 также добавляет два новых значения типа логической записи ( &lt;a href=&quot;fileformat2#serialtype&quot;&gt;последовательные типы&lt;/a&gt; 8 и 9). Поддержка формата 4 была добавлена ​​в SQLite 3.3.0 10 января 2006 г.</target>
        </trans-unit>
        <trans-unit id="d2e4ea8f983e7648b4500b3c2517f1581f43edb0" translate="yes" xml:space="preserve">
          <source>Formats 2 through 10 may be optionally followed by a timezone indicator of the form &quot;</source>
          <target state="translated">Форматы со 2 по 10 могут по желанию сопровождаться индикатором часового пояса формы&quot;.</target>
        </trans-unit>
        <trans-unit id="ff2a0eb4d03de61d70053787eab6804fcec445da" translate="yes" xml:space="preserve">
          <source>Formatted String Printing Functions</source>
          <target state="translated">Функции форматированной строковой печати</target>
        </trans-unit>
        <trans-unit id="73cdbab7825af4beabbe4e8fccce8b346886e89f" translate="yes" xml:space="preserve">
          <source>Fossil gives me peace of mind that I have everything ... synced to the server with a single command.... I never get this peace of mind with git.</source>
          <target state="translated">Ископание дает мне душевное спокойствие,что у меня есть все...синхронизированное с сервером одной командой....Я никогда не получаю этого спокойствия с гитом.</target>
        </trans-unit>
        <trans-unit id="968f45bf8ccf7ca67b780b2bdd22df3354350003" translate="yes" xml:space="preserve">
          <source>Fossil is a completely stand-alone program, so install it simply by putting the &quot;fossil&quot; or &quot;fossil.exe&quot; executable someplace on your $PATH or %PATH%. After you have Fossil installed, do this:</source>
          <target state="translated">Fossil-это полностью автономная программа,поэтому установите ее,просто поместив исполняемый файл &quot;fossil&quot; или &quot;fossil.exe&quot; куда-нибудь на вашем $PATH или %PATH%.После того,как вы установите &quot;Fossil&quot;,сделайте это:</target>
        </trans-unit>
        <trans-unit id="94257cd970f113fc11ecc5cc6011f7bfff67e319" translate="yes" xml:space="preserve">
          <source>Fossil is easy to install and use. Here are the steps for unix. (Windows is similar.)</source>
          <target state="translated">Ископаемые материалы просты в установке и использовании.Вот шаги для unix.(Окна похожи.)</target>
        </trans-unit>
        <trans-unit id="233904fc6b6c8ee70d33af66e4cb04bfc0af5c1f" translate="yes" xml:space="preserve">
          <source>Fossil vs. Git</source>
          <target state="translated">Ископаемые против Гита</target>
        </trans-unit>
        <trans-unit id="bbba84135de6b052c2210e74e0cc5b2a9d359ddb" translate="yes" xml:space="preserve">
          <source>Found</source>
          <target state="translated">Found</target>
        </trans-unit>
        <trans-unit id="71c33b1cffd26b04e4533bd5c542bd8028125150" translate="yes" xml:space="preserve">
          <source>Four independently developed test harnesses</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9521a3d73988a064707ebf1e7a52b3d8155b49c" translate="yes" xml:space="preserve">
          <source>Frame boundary</source>
          <target state="translated">Граница кадра</target>
        </trans-unit>
        <trans-unit id="77433082b8e51b0f02140d5bb2ad80c6960db0b1" translate="yes" xml:space="preserve">
          <source>Frame type</source>
          <target state="translated">Тип кадра</target>
        </trans-unit>
        <trans-unit id="6e84d556b35797f261b67f9c140d77ba6a16046e" translate="yes" xml:space="preserve">
          <source>Free Memory Used By A Database Connection</source>
          <target state="translated">Бесплатная память,используемая при подключении к базе данных</target>
        </trans-unit>
        <trans-unit id="c3f00513ee103316a9c102f8d540f97f3d93a05d" translate="yes" xml:space="preserve">
          <source>Freelist leaf pages contain no information. SQLite avoids reading or writing freelist leaf pages in order to reduce disk I/O.</source>
          <target state="translated">Страницы фрилиста не содержат никакой информации.SQLite избегает чтения или записи страниц листа фрилиста,чтобы уменьшить объем ввода/вывода диска.</target>
        </trans-unit>
        <trans-unit id="71c292b702c9c6ddbea2af4ccdda270456dc5dd4" translate="yes" xml:space="preserve">
          <source>Frequent inserts, updates, and deletes can cause the database file to become fragmented - where data for a single table or index is scattered around the database file. Running VACUUM ensures that each table and index is largely stored contiguously within the database file. In some cases, VACUUM may also reduce the number of partially filled pages in the database, reducing the size of the database file further.</source>
          <target state="translated">Частые вставки,обновления и удаления могут привести к фрагментации файла базы данных-когда данные для одной таблицы или индекса разбросаны по файлу базы данных.Запуск VACUUM гарантирует,что каждая таблица и индекс в основном хранятся в файле базы данных.В некоторых случаях VACUUM может также уменьшить количество частично заполненных страниц в БД,еще больше уменьшив размер файла БД.</target>
        </trans-unit>
        <trans-unit id="d790b402d79ac1a723c790313bcd679999474630" translate="yes" xml:space="preserve">
          <source>Frequently Asked Questions</source>
          <target state="translated">Часто задаваемые вопросы</target>
        </trans-unit>
        <trans-unit id="4dca8789d725335eabc320e5fd334c48abe46050" translate="yes" xml:space="preserve">
          <source>From the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt;, extensions can be loaded using the &quot;.load&quot; dot-command. For example:</source>
          <target state="translated">Из &lt;a href=&quot;cli&quot;&gt;оболочки командной строки&lt;/a&gt; расширения можно загрузить с помощью точечной команды &quot;.load&quot;. Например:</target>
        </trans-unit>
        <trans-unit id="9622d74f0a066cde3991b933210f9d9f6547b468" translate="yes" xml:space="preserve">
          <source>From the point of view of a single process, a database file can be in one of five locking states:</source>
          <target state="translated">С точки зрения одного процесса,файл базы данных может находиться в одном из пяти состояний блокировки:</target>
        </trans-unit>
        <trans-unit id="f2bf6ce9c451768f240ac82fe10e69d266839161" translate="yes" xml:space="preserve">
          <source>From the point of view of the uppers layers of the SQLite stack, each open database file uses exactly one VFS. But in practice, a particular VFS might just be a thin wrapper around another VFS that does the real work. We call a wrapper VFS a &quot;shim&quot;.</source>
          <target state="translated">С точки зрения верхних слоев стека SQLite,каждый открытый файл базы данных использует ровно один VFS.Но на практике,конкретная VFS может быть просто тонкой оберткой вокруг другой VFS,которая выполняет реальную работу.Мы называем обертку VFS &quot;shim&quot;.</target>
        </trans-unit>
        <trans-unit id="b51b364d89abfa3baa92bcc31eb6e45de7419ef6" translate="yes" xml:space="preserve">
          <source>From the users point of view, FTS tables are similar to ordinary SQLite tables in many ways. Data may be added to, modified within and removed from FTS tables using the INSERT, UPDATE and DELETE commands just as it may be with ordinary tables. Similarly, the SELECT command may be used to query data. The following list summarizes the differences between FTS and ordinary tables:</source>
          <target state="translated">С точки зрения пользователей таблицы FTS во многом схожи с обычными таблицами SQLite.Данные могут добавляться в таблицы FTS,изменяться внутри них и удаляться из них с помощью команд INSERT,UPDATE и DELETE точно так же,как это может быть с обычными таблицами.Аналогичным образом,для запроса данных может использоваться команда SELECT.В следующем списке приведены различия между FTS и обычными таблицами:</target>
        </trans-unit>
        <trans-unit id="27c4a8e9b8642a933f67723d0e4be1b9a0f44d80" translate="yes" xml:space="preserve">
          <source>From this we get the following output</source>
          <target state="translated">Из этого мы получаем следующий вывод</target>
        </trans-unit>
        <trans-unit id="2180268f2a9a9fda782b57bf8e01a18a029a7a96" translate="yes" xml:space="preserve">
          <source>Fulfill God's commandments daily in your deeds.</source>
          <target state="translated">Ежедневно исполняйте Божьи заповеди в своих делах.</target>
        </trans-unit>
        <trans-unit id="b471a096b84cc0494684e033a051e31af5d4baaa" translate="yes" xml:space="preserve">
          <source>Fulfill not the desires of the flesh; hate your own will.</source>
          <target state="translated">Не исполняй желаний плоти;ненавидь свою собственную волю.</target>
        </trans-unit>
        <trans-unit id="c55154da9bee9185f44dff21df8abc2c3aabdcae" translate="yes" xml:space="preserve">
          <source>Full unicode case folding is supported in SQLite if it is compiled with the &lt;a href=&quot;compile#enable_icu&quot;&gt;-DSQLITE_ENABLE_ICU&lt;/a&gt; option and linked against the &lt;a href=&quot;http://site.icu-project.org/&quot;&gt;International Components for Unicode&lt;/a&gt; library.</source>
          <target state="translated">Полное сворачивание регистра Unicode поддерживается в SQLite, если он скомпилирован с параметром &lt;a href=&quot;compile#enable_icu&quot;&gt;-DSQLITE_ENABLE_ICU&lt;/a&gt; и связан с библиотекой &lt;a href=&quot;http://site.icu-project.org/&quot;&gt;International Components for Unicode&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="90b0c8025a15a6f38263adcf72861e6ab67a9305" translate="yes" xml:space="preserve">
          <source>Full-Featured SQL</source>
          <target state="translated">Полнофункциональный SQL</target>
        </trans-unit>
        <trans-unit id="9e0f1c37b71547a59fac0e69533c4df840ff38fe" translate="yes" xml:space="preserve">
          <source>Full-Text Search</source>
          <target state="translated">Полнотекстовый поиск</target>
        </trans-unit>
        <trans-unit id="369603a7ebe96771eca2b1d07435e9996bd963f3" translate="yes" xml:space="preserve">
          <source>Full-text search</source>
          <target state="translated">Полнотекстовый поиск</target>
        </trans-unit>
        <trans-unit id="f1e410ad1472b42cb42cc98962428637290b6706" translate="yes" xml:space="preserve">
          <source>Function</source>
          <target state="translated">Function</target>
        </trans-unit>
        <trans-unit id="9365da4d7427ae049cd7228599ffdbf56ca765df" translate="yes" xml:space="preserve">
          <source>Function &lt;a href=&quot;c3ref/backup_finish#sqlite3backupfinish&quot;&gt;sqlite3_backup_finish()&lt;/a&gt; is called to clean up resources allocated by &lt;a href=&quot;c3ref/backup_finish#sqlite3backupinit&quot;&gt;sqlite3_backup_init()&lt;/a&gt;.</source>
          <target state="translated">Функция &lt;a href=&quot;c3ref/backup_finish#sqlite3backupfinish&quot;&gt;sqlite3_backup_finish ()&lt;/a&gt; вызывается для очистки ресурсов, выделенных &lt;a href=&quot;c3ref/backup_finish#sqlite3backupinit&quot;&gt;sqlite3_backup_init ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6ee739a58d0601e439d67d32ce677eb6f284f6f0" translate="yes" xml:space="preserve">
          <source>Function &lt;a href=&quot;c3ref/backup_finish#sqlite3backupinit&quot;&gt;sqlite3_backup_init()&lt;/a&gt; is called to create an &lt;a href=&quot;c3ref/backup&quot;&gt;sqlite3_backup&lt;/a&gt; object to copy data between the two databases (either from a file and into the in-memory database, or vice-versa).</source>
          <target state="translated">Функция &lt;a href=&quot;c3ref/backup_finish#sqlite3backupinit&quot;&gt;sqlite3_backup_init ()&lt;/a&gt; вызывается для создания объекта &lt;a href=&quot;c3ref/backup&quot;&gt;sqlite3_backup&lt;/a&gt; для копирования данных между двумя базами данных (либо из файла в базу данных в памяти, либо наоборот).</target>
        </trans-unit>
        <trans-unit id="3518bc62cbd77290edb8df852902f3d26b669db7" translate="yes" xml:space="preserve">
          <source>Function &lt;a href=&quot;c3ref/backup_finish#sqlite3backupinit&quot;&gt;sqlite3_backup_init()&lt;/a&gt; is called to create an &lt;a href=&quot;c3ref/backup&quot;&gt;sqlite3_backup&lt;/a&gt; object to copy data from database pDb to the backup database file identified by zFilename.</source>
          <target state="translated">Функция &lt;a href=&quot;c3ref/backup_finish#sqlite3backupinit&quot;&gt;sqlite3_backup_init ()&lt;/a&gt; вызывается для создания объекта &lt;a href=&quot;c3ref/backup&quot;&gt;sqlite3_backup&lt;/a&gt; для копирования данных из базы данных pDb в файл резервной копии базы данных, идентифицированный zFilename.</target>
        </trans-unit>
        <trans-unit id="391bd2c3bef8e5815ac8dc9e143dc5e9f29edc4b" translate="yes" xml:space="preserve">
          <source>Function &lt;a href=&quot;c3ref/backup_finish#sqlite3backupstep&quot;&gt;sqlite3_backup_step()&lt;/a&gt; is called with a parameter of 5 to copy 5 pages of database pDb to the backup database (file zFilename).</source>
          <target state="translated">Функция &lt;a href=&quot;c3ref/backup_finish#sqlite3backupstep&quot;&gt;sqlite3_backup_step ()&lt;/a&gt; вызывается с параметром 5 для копирования 5 страниц базы данных pDb в резервную базу данных (файл zFilename).</target>
        </trans-unit>
        <trans-unit id="38d0016fe914d4211802e56c1b039ba739bf3a21" translate="yes" xml:space="preserve">
          <source>Function &lt;a href=&quot;c3ref/backup_finish#sqlite3backupstep&quot;&gt;sqlite3_backup_step()&lt;/a&gt; is called with a parameter of &lt;code&gt;-1&lt;/code&gt; to copy the entire source database to the destination.</source>
          <target state="translated">Функция &lt;a href=&quot;c3ref/backup_finish#sqlite3backupstep&quot;&gt;sqlite3_backup_step ()&lt;/a&gt; вызывается с параметром &lt;code&gt;-1&lt;/code&gt; для копирования всей исходной базы данных в место назначения.</target>
        </trans-unit>
        <trans-unit id="a019467e942226e7593baeafe04451d52208ddbd" translate="yes" xml:space="preserve">
          <source>Function Auxiliary Data</source>
          <target state="translated">Вспомогательные данные функции</target>
        </trans-unit>
        <trans-unit id="95b0294dd891e754097881615649b65fc6ba31c5" translate="yes" xml:space="preserve">
          <source>Function Flags</source>
          <target state="translated">Функциональные флаги</target>
        </trans-unit>
        <trans-unit id="17555700d9f22f47c91cbb0e6dcdac3a03a90e07" translate="yes" xml:space="preserve">
          <source>Function implementations use the following APIs to acquire context and to report results:</source>
          <target state="translated">Реализации функций используют следующие API для получения контекста и отчетов о результатах:</target>
        </trans-unit>
        <trans-unit id="7db899803172ac5c12cb30190a927b06044d501c" translate="yes" xml:space="preserve">
          <source>Function sqlite3_backup_step(B,N) will copy up to N pages between the source and destination databases specified by &lt;a href=&quot;#sqlite3_backup&quot;&gt;sqlite3_backup&lt;/a&gt; object B. If N is negative, all remaining source pages are copied. If sqlite3_backup_step(B,N) successfully copies N pages and there are still more pages to be copied, then the function returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt;. If sqlite3_backup_step(B,N) successfully finishes copying all pages from source to destination, then it returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_DONE&lt;/a&gt;. If an error occurs while running sqlite3_backup_step(B,N), then an &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; is returned. As well as &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; and &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_DONE&lt;/a&gt;, a call to sqlite3_backup_step() may return &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_READONLY&lt;/a&gt;, &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOMEM&lt;/a&gt;, &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY&lt;/a&gt;, &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_LOCKED&lt;/a&gt;, or an &lt;a href=&quot;#SQLITE_ABORT_ROLLBACK&quot;&gt;SQLITE_IOERR_XXX&lt;/a&gt; extended error code.</source>
          <target state="translated">Функция sqlite3_backup_step (B, N) скопирует до N страниц между исходной и целевой базами данных, указанными в объекте &lt;a href=&quot;#sqlite3_backup&quot;&gt;sqlite3_backup&lt;/a&gt; B. Если N отрицательное, копируются все оставшиеся исходные страницы. Если sqlite3_backup_step (B, N) успешно копирует N страниц и есть еще страницы, которые нужно скопировать, функция возвращает &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; . Если sqlite3_backup_step (B, N) успешно завершает копирование всех страниц из источника в место назначения, он возвращает &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_DONE&lt;/a&gt; . Если ошибка возникает при выполнении sqlite3_backup_step (B, N), возвращается &lt;a href=&quot;rescode&quot;&gt;код ошибки&lt;/a&gt; . Так же, как &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; и &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_DONE&lt;/a&gt; , вызов sqlite3_backup_step () может вернуть &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_READONLY&lt;/a&gt; ,&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOMEM&lt;/a&gt; , &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY&lt;/a&gt; , &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_LOCKED&lt;/a&gt; или расширенный код ошибки &lt;a href=&quot;#SQLITE_ABORT_ROLLBACK&quot;&gt;SQLITE_IOERR_XXX&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9255837a8368562d39b56b025c25a117e386acd6" translate="yes" xml:space="preserve">
          <source>Function sqlite3_backup_step(B,N) will copy up to N pages between the source and destination databases specified by &lt;a href=&quot;backup&quot;&gt;sqlite3_backup&lt;/a&gt; object B. If N is negative, all remaining source pages are copied. If sqlite3_backup_step(B,N) successfully copies N pages and there are still more pages to be copied, then the function returns &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;. If sqlite3_backup_step(B,N) successfully finishes copying all pages from source to destination, then it returns &lt;a href=&quot;../rescode#done&quot;&gt;SQLITE_DONE&lt;/a&gt;. If an error occurs while running sqlite3_backup_step(B,N), then an &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; is returned. As well as &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; and &lt;a href=&quot;../rescode#done&quot;&gt;SQLITE_DONE&lt;/a&gt;, a call to sqlite3_backup_step() may return &lt;a href=&quot;../rescode#readonly&quot;&gt;SQLITE_READONLY&lt;/a&gt;, &lt;a href=&quot;../rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt;, &lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;, &lt;a href=&quot;../rescode#locked&quot;&gt;SQLITE_LOCKED&lt;/a&gt;, or an &lt;a href=&quot;../rescode#ioerr_access&quot;&gt;SQLITE_IOERR_XXX&lt;/a&gt; extended error code.</source>
          <target state="translated">Функция sqlite3_backup_step (B, N) скопирует до N страниц между исходной и целевой базами данных, указанными в объекте &lt;a href=&quot;backup&quot;&gt;sqlite3_backup&lt;/a&gt; B. Если N отрицательное, копируются все оставшиеся исходные страницы. Если sqlite3_backup_step (B, N) успешно копирует N страниц и есть еще страницы, которые нужно скопировать, функция возвращает &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; . Если sqlite3_backup_step (B, N) успешно завершает копирование всех страниц из источника в место назначения, он возвращает &lt;a href=&quot;../rescode#done&quot;&gt;SQLITE_DONE&lt;/a&gt; . Если ошибка возникает при выполнении sqlite3_backup_step (B, N), возвращается &lt;a href=&quot;../rescode&quot;&gt;код ошибки&lt;/a&gt; . Так же, как &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; и &lt;a href=&quot;../rescode#done&quot;&gt;SQLITE_DONE&lt;/a&gt; , вызов sqlite3_backup_step () может вернуть &lt;a href=&quot;../rescode#readonly&quot;&gt;SQLITE_READONLY&lt;/a&gt; ,&lt;a href=&quot;../rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt; , &lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; , &lt;a href=&quot;../rescode#locked&quot;&gt;SQLITE_LOCKED&lt;/a&gt; или расширенный код ошибки &lt;a href=&quot;../rescode#ioerr_access&quot;&gt;SQLITE_IOERR_XXX&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="02506e4ca51a17167d74a2f8b901e6d46a621915" translate="yes" xml:space="preserve">
          <source>Function sqlite3rbu_step() is called on the RBU handle until either the RBU vacuum is finished, an error occurs or the application wishes to suspend the RBU vacuum.</source>
          <target state="translated">Функция sqlite3rbu_step()вызывается на ручке RBU до тех пор,пока не закончится вакуум RBU,не произойдет ошибка или приложение не захочет приостановить вакуум RBU.</target>
        </trans-unit>
        <trans-unit id="c29dbde42f9e09b5fa1fe9e874978bd60461ca23" translate="yes" xml:space="preserve">
          <source>Function0</source>
          <target state="translated">Function0</target>
        </trans-unit>
        <trans-unit id="885fce7082ac7fe77b80dbde8d190b12ddbee6ea" translate="yes" xml:space="preserve">
          <source>Functionality Testing</source>
          <target state="translated">Тестирование функциональности</target>
        </trans-unit>
        <trans-unit id="2b961dea1dc0c60ddf9a2c8e9d090f6f7d082483" translate="yes" xml:space="preserve">
          <source>Functions</source>
          <target state="translated">Functions</target>
        </trans-unit>
        <trans-unit id="5a1198fbca49df3b9353761343f6ab00ba7526e3" translate="yes" xml:space="preserve">
          <source>Functions:</source>
          <target state="translated">Functions:</target>
        </trans-unit>
        <trans-unit id="1ddc4309220e5ca80653bda487622cf643ea376d" translate="yes" xml:space="preserve">
          <source>Fundamental Datatypes</source>
          <target state="translated">Фундаментальные Датипы</target>
        </trans-unit>
        <trans-unit id="f728c83ebd508ddfa64fa9b670d3c24c116a1c08" translate="yes" xml:space="preserve">
          <source>Further performance improves can be made by using the &lt;a href=&quot;mmap&quot;&gt;memory-mapped I/O&lt;/a&gt; feature of SQLite. In the next chart, the entire 1GB database file is memory mapped and blobs are read (in random order) using the &lt;a href=&quot;c3ref/blob_read&quot;&gt;sqlite3_blob_read()&lt;/a&gt; interface. With these optimizations, SQLite is twice as fast as Android or MacOS-X and over 10 times faster than Windows.</source>
          <target state="translated">Дальнейшее улучшение производительности может быть достигнуто за счет использования функции &lt;a href=&quot;mmap&quot;&gt;ввода-вывода с отображением памяти&lt;/a&gt; в SQLite. На следующей диаграмме весь файл базы данных размером 1 ГБ отображается в памяти, и большие двоичные объекты считываются (в случайном порядке) с использованием интерфейса &lt;a href=&quot;c3ref/blob_read&quot;&gt;sqlite3_blob_read ()&lt;/a&gt; . Благодаря этой оптимизации SQLite в два раза быстрее Android или MacOS-X и более чем в 10 раз быстрее, чем Windows.</target>
        </trans-unit>
        <trans-unit id="215d209e37d2a11fed7e914dfee16f71ee55be90" translate="yes" xml:space="preserve">
          <source>Further suppose that column x contains values spread out between 0 and 1,000,000 and column y contains values that span between 0 and 1,000. In that scenario, the range constraint on column x should reduce the search space by a factor of 10,000 whereas the range constraint on column y should reduce the search space by a factor of only 10. So the ex2i1 index should be preferred.</source>
          <target state="translated">Далее предположим,что столбец x содержит значения,распределенные между 0 и 1,000,000,а столбец y содержит значения,распределенные между 0 и 1,000.В этом сценарии ограничение диапазона в столбце x должно уменьшить поисковое пространство в 10,000 раз,в то время как ограничение диапазона в столбце y должно уменьшить поисковое пространство только в 10 раз.Поэтому следует отдавать предпочтение индексу ex2i1.</target>
        </trans-unit>
        <trans-unit id="09aabcfb38f7cb10806136de02a602b19c076fd6" translate="yes" xml:space="preserve">
          <source>Further to keeping &lt;b&gt;n&lt;/b&gt; small, one desires to keep the size of the largest memory allocations under control. Large requests to the general-purpose memory allocator might come from several sources:</source>
          <target state="translated">Помимо того, что &lt;b&gt;n остается&lt;/b&gt; небольшим, желательно держать под контролем размер самых больших распределений памяти. Большие запросы к распределителю памяти общего назначения могут поступать из нескольких источников:</target>
        </trans-unit>
        <trans-unit id="4a74f247651044b2313a36316a7929616b6d570a" translate="yes" xml:space="preserve">
          <source>Furthermore, a single SQLite database holding 10-kilobyte blobs uses about 20% less disk space than storing the blobs in individual files.</source>
          <target state="translated">Кроме того,одна база данных SQLite,содержащая 10-килобайтные блоки,использует примерно на 20% меньше дискового пространства,чем хранение блоков в отдельных файлах.</target>
        </trans-unit>
        <trans-unit id="8bd50359d3a17558a2d398e2f44b82ca134e4e80" translate="yes" xml:space="preserve">
          <source>Future releases may add new output columns and may change the order of legacy columns. Further detail about the meaning of each column in the SQLITE_STMT virtual table is provided below:</source>
          <target state="translated">В будущих релизах могут добавляться новые столбцы вывода и может меняться порядок следования старых столбцов.Более подробная информация о значении каждой колонки в виртуальной таблице SQLITE_STMT приведена ниже:</target>
        </trans-unit>
        <trans-unit id="6831b46470717c86c7d25cb9cedff9f9bee20302" translate="yes" xml:space="preserve">
          <source>Future releases of SQLite might enable those interfaces by default and instead offer an SQLITE_OMIT_DESERIALIZE option to leave them out.</source>
          <target state="translated">В будущих релизах SQLite можно было бы включить эти интерфейсы по умолчанию и вместо этого предложить опцию SQLITE_OMIT_DESERIALIZE,чтобы пропустить их.</target>
        </trans-unit>
        <trans-unit id="69eed414fd6ede90f6e232a4b640df2129c7213e" translate="yes" xml:space="preserve">
          <source>Future versions of SQLite may extend the list of errors which might cause automatic transaction rollback. Future versions of SQLite might change the error response. In particular, we may choose to simplify the interface in future versions of SQLite by causing the errors above to force an unconditional rollback.</source>
          <target state="translated">Будущие версии SQLite могут расширить список ошибок,которые могут привести к автоматическому откату транзакций.Будущие версии SQLite могут изменить реакцию на ошибки.В частности,в будущих версиях SQLite можно будет упростить интерфейс,вызвав приведенные выше ошибки,которые могут привести к безусловному откату транзакций.</target>
        </trans-unit>
        <trans-unit id="b0b58ce3a5e420ed148b6052399ca3a065dfe3cb" translate="yes" xml:space="preserve">
          <source>Future versions of SQLite might enable the batch-atomic-write capability by default, at which point this compile-time option will become superfluous.</source>
          <target state="translated">В будущих версиях SQLite по умолчанию может быть включена возможность пакетной автоматической записи,и с этого момента данная опция времени компиляции станет излишней.</target>
        </trans-unit>
        <trans-unit id="75a65696cc2dd88673f048a8e620acbe3511d286" translate="yes" xml:space="preserve">
          <source>Fuzz testing and &lt;a href=&quot;testing#mcdc&quot;&gt;100% MC/DC testing&lt;/a&gt; are in tension with one another. That is to say, code tested to 100% MC/DC will tend to be more vulnerable to problems found by fuzzing and code that performs well during fuzz testing will tend to have (much) less than 100% MC/DC. This is because MC/DC testing discourages &lt;a href=&quot;testing#defcode&quot;&gt;defensive code&lt;/a&gt; with unreachable branches, but without defensive code, a fuzzer is more likely to find a path that causes problems. MC/DC testing seems to work well for building code that is robust during typical normal use, whereas fuzz testing is good for building code that is robust against malicious attack.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7aac4860a695a884103c23bef4fe10cea8ac21a0" translate="yes" xml:space="preserve">
          <source>Fuzz tests</source>
          <target state="translated">тесты Fuzz</target>
        </trans-unit>
        <trans-unit id="cbf13864eb622e042fd70afc25b332a98febed1d" translate="yes" xml:space="preserve">
          <source>GCC-7 generates binaries that are smaller and faster than GCC-5, though the difference is not that great.</source>
          <target state="translated">GCC-7 генерирует двоичные файлы,которые меньше и быстрее,чем GCC-5,хотя разница не так уж велика.</target>
        </trans-unit>
        <trans-unit id="82cb2940a14f458fe56d211dffdcd12595e8b940" translate="yes" xml:space="preserve">
          <source>GENERATED</source>
          <target state="translated">GENERATED</target>
        </trans-unit>
        <trans-unit id="3c1c8852a41864ea17cea1296e10f38e7d36f590" translate="yes" xml:space="preserve">
          <source>GIT - Git source code repository</source>
          <target state="translated">GIT-Git-репозиторий исходного кода</target>
        </trans-unit>
        <trans-unit id="801660e770a91f34fb13ac91a9b5cbd2d98c6d3a" translate="yes" xml:space="preserve">
          <source>GLOB</source>
          <target state="translated">GLOB</target>
        </trans-unit>
        <trans-unit id="ea5a383494f81c4f464965d03bf916c41d68ced5" translate="yes" xml:space="preserve">
          <source>GROUP</source>
          <target state="translated">GROUP</target>
        </trans-unit>
        <trans-unit id="992f3cd91fffb522eba0b5e27b68c643f2967283" translate="yes" xml:space="preserve">
          <source>GROUP BY now considers NULLs to be equal again, as it should</source>
          <target state="translated">ГРУППА теперь снова считает НУЛЬШИЕ равными,как и должно быть.</target>
        </trans-unit>
        <trans-unit id="1f8969d436579977f5b13e27e290ffdb25736672" translate="yes" xml:space="preserve">
          <source>GROUPS</source>
          <target state="translated">GROUPS</target>
        </trans-unit>
        <trans-unit id="47abf252888b506642430a87f17ad2e364853ea7" translate="yes" xml:space="preserve">
          <source>GROUPS frames</source>
          <target state="translated">Каркасы ГРУППЫ</target>
        </trans-unit>
        <trans-unit id="5023fde21a93efcc45f3ef1278a03020db274d7f" translate="yes" xml:space="preserve">
          <source>Ge</source>
          <target state="translated">Ge</target>
        </trans-unit>
        <trans-unit id="5f5383c13d2f60a6733afafdeaf91505cfcc253b" translate="yes" xml:space="preserve">
          <source>Generalized ALTER TABLE procedure</source>
          <target state="translated">Обобщенная процедура АЛЬТЕР-ТАБЛИЦЫ</target>
        </trans-unit>
        <trans-unit id="200f1a824c74356136271be8f5cec761b8361890" translate="yes" xml:space="preserve">
          <source>Generalized the IS and IS NOT operators to take arbitrary expressions on their right-hand side.</source>
          <target state="translated">Обобщил операторы ИСПРАВЛЕНИЯ и НЕ ИСПРАВЛЕНИЯ,чтобы принимать произвольные выражения с правой стороны.</target>
        </trans-unit>
        <trans-unit id="b3419155244f27d32ab3d7f4be3add6bd08da9d5" translate="yes" xml:space="preserve">
          <source>Generally speaking, there are three separate subsystems within SQLite that can be modified or overridden at compile-time. The mutex subsystem is used to serialize access to SQLite resources that are shared among threads. The memory allocation subsystem is used to allocate memory required by SQLite objects and for the database cache. Finally, the &lt;a href=&quot;c3ref/vfs&quot;&gt;Virtual File System&lt;/a&gt; subsystem is used to provide a portable interface between SQLite and the underlying operating system and especially the file system. We call these three subsystems the &quot;interface&quot; subsystems of SQLite.</source>
          <target state="translated">Вообще говоря, в SQLite есть три отдельные подсистемы, которые можно изменить или переопределить во время компиляции. Подсистема мьютексов используется для сериализации доступа к ресурсам SQLite, которые совместно используются потоками. Подсистема выделения памяти используется для выделения памяти, необходимой объектам SQLite, и для кэша базы данных. Наконец, подсистема &lt;a href=&quot;c3ref/vfs&quot;&gt;виртуальной файловой системы&lt;/a&gt; используется для обеспечения переносимого интерфейса между SQLite и базовой операционной системой, особенно файловой системой. Мы называем эти три подсистемы &amp;laquo;интерфейсными&amp;raquo; подсистемами SQLite.</target>
        </trans-unit>
        <trans-unit id="03b11aad395b9bb3b854450c1f0acff0112439bd" translate="yes" xml:space="preserve">
          <source>Generate A Changeset From A Session Object</source>
          <target state="translated">Сгенерировать измененный набор из объекта сеанса</target>
        </trans-unit>
        <trans-unit id="771f6c81129288bd0dca35edc653f4896b8a38b9" translate="yes" xml:space="preserve">
          <source>Generate A Patchset From A Session Object</source>
          <target state="translated">Сгенерировать патчсет A из объекта сеанса</target>
        </trans-unit>
        <trans-unit id="c543fcc61a656cc087657032229c13b299493cc4" translate="yes" xml:space="preserve">
          <source>Generate all multiples of 5 less than or equal to 100:</source>
          <target state="translated">Сгенерируйте все кратные числа на 5 меньше или равные 100:</target>
        </trans-unit>
        <trans-unit id="79e208b13cb09ea92286261229fb60357b5683cd" translate="yes" xml:space="preserve">
          <source>Generate the 20 random integer values:</source>
          <target state="translated">Генерируйте 20 случайных целых значений:</target>
        </trans-unit>
        <trans-unit id="46614740c9601066a8714b11664b1eb75a5a0bb4" translate="yes" xml:space="preserve">
          <source>Generating the results of a simple SELECT statement is presented as a four step process in the description below:</source>
          <target state="translated">Генерирование результатов простого SELECT-оператора представлено в виде четырехступенчатого процесса в описании ниже:</target>
        </trans-unit>
        <trans-unit id="0060bdc4470d529ca18bce37edc0d7a0701d9b10" translate="yes" xml:space="preserve">
          <source>Geopoly</source>
          <target state="translated">Geopoly</target>
        </trans-unit>
        <trans-unit id="c4340d254981277ce14859ec23653c0dac4e3963" translate="yes" xml:space="preserve">
          <source>Geopoly operates on &quot;simple&quot; polygons - that is, polygons for which the boundary does not intersect itself. Geopoly thus extends the capabilities of the &lt;a href=&quot;rtree&quot;&gt;R-Tree extension&lt;/a&gt; which can only deal with rectangular areas. On the other hand, the &lt;a href=&quot;rtree&quot;&gt;R-Tree extension&lt;/a&gt; is able to handle between 1 and 5 coordinate dimensions, whereas Geopoly is restricted to 2-dimensional shapes only.</source>
          <target state="translated">Геополия работает с &amp;laquo;простыми&amp;raquo; полигонами, то есть с полигонами, граница которых не пересекает сама себя. Таким образом, Geopoly расширяет возможности &lt;a href=&quot;rtree&quot;&gt;расширения R-Tree,&lt;/a&gt; которое может работать только с прямоугольными областями. С другой стороны, &lt;a href=&quot;rtree&quot;&gt;расширение R-Tree&lt;/a&gt; может обрабатывать от 1 до 5 координатных измерений, тогда как Geopoly ограничивается только 2-мерными формами.</target>
        </trans-unit>
        <trans-unit id="6dd9a0429b5e12a110f96aed0989c67466586ea1" translate="yes" xml:space="preserve">
          <source>Geopoly stores all polygons internally using a binary format. A binary polygon consists of a 4-byte header following by an array of coordinate pairs in which each dimension of each coordinate is a 32-bit floating point number.</source>
          <target state="translated">В геополитическом магазине все полигоны хранятся внутренне с использованием бинарного формата.Двоичный полигон состоит из 4-х байтового заголовка,за которым следует массив пар координат,в которых каждое измерение каждой координаты является 32-битным числом с плавающей точкой.</target>
        </trans-unit>
        <trans-unit id="230fd79e9ac234b116998f305ec36a626773a0c1" translate="yes" xml:space="preserve">
          <source>Get a copy of the prebuilt binaries for your machine, or get a copy of the sources and compile them yourself. Visit the &lt;a href=&quot;https://sqlite.org/download.html&quot;&gt;download&lt;/a&gt; page for more information.</source>
          <target state="translated">Получите копию предварительно скомпилированных двоичных файлов для своей машины или получите копию исходных текстов и скомпилируйте их самостоятельно. Посетите страницу &lt;a href=&quot;https://sqlite.org/download.html&quot;&gt;загрузки&lt;/a&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="f22b4172b2caeb752e5b6845137b0e1c3132162f" translate="yes" xml:space="preserve">
          <source>Get a new integer record number (a.k.a &quot;rowid&quot;) used as the key to a table. The record number is not previously used as a key in the database table that cursor P1 points to. The new record number is written written to register P2.</source>
          <target state="translated">Получить новый целочисленный номер записи (так называемый &quot;rowid&quot;),используемый в качестве ключа к таблице.Номер записи ранее не использовался в качестве ключа в таблице БД,на который указывает курсор P1.Новый номер записи записывается в регистр P2.</target>
        </trans-unit>
        <trans-unit id="2c8ad3eda2ae8758b9937a69c2cdf3d37bc6a82b" translate="yes" xml:space="preserve">
          <source>Get extension loading working on Cygwin.</source>
          <target state="translated">Получить нагрузку расширения работает на Cygwin.</target>
        </trans-unit>
        <trans-unit id="70d300a9221d054ecf73f3a432c241cce5538fb1" translate="yes" xml:space="preserve">
          <source>Get the SQLITE_ENABLE_LOCKING_STYLE macro working again on Mac OS X.</source>
          <target state="translated">Восстановите работу макроса SQLITE_ENABLE_LOCKING_STYLE на Mac OS X.</target>
        </trans-unit>
        <trans-unit id="191ab3ffcff8c3d125f02fa19cf1b4772a774563" translate="yes" xml:space="preserve">
          <source>Get the library working correctly when compiled with GCC option &quot;-fstrict-aliasing&quot;.</source>
          <target state="translated">Заставить библиотеку работать корректно при компиляции с помощью опции GCC &quot;-fstrict-aliasing&quot;.</target>
        </trans-unit>
        <trans-unit id="e33fe52a421a08f566920837d8eaa9b7577c26cc" translate="yes" xml:space="preserve">
          <source>Git allows you to go backwards in time easily. Given the latest check-in on a branch, Git lets you see all the ancestors of that check-in. But Git makes it difficult to move in the other direction. Given some historical check-in, it is quite challenging in Git to find out what came next. It can be done, but it is sufficiently difficult that people rarely do it. Common interfaces for Git, such as GitHub, do not support the ability.</source>
          <target state="translated">Git позволяет легко вернуться назад во времени.Учитывая последнюю регистрацию на ветке,Git позволяет вам увидеть всех предков этой регистрации.Но Git затрудняет движение в другом направлении.С учётом некоторых исторических моментов регистрации,в Git'е довольно сложно узнать,что было дальше.Это можно сделать,но достаточно сложно,чтобы люди редко это делали.Общие интерфейсы для Git'а,такие как GitHub,не поддерживают эту возможность.</target>
        </trans-unit>
        <trans-unit id="b6fbc2ab6d8b00135f72a297ae81133b9c538d92" translate="yes" xml:space="preserve">
          <source>Git commands (and/or options on commands) for moving and comparing content between all of these locations.</source>
          <target state="translated">Git-команды (и/или опции на командах)для перемещения и сравнения содержимого между всеми этими местами.</target>
        </trans-unit>
        <trans-unit id="913e20aa0e82cacccbed30743753b5fea41f9dd9" translate="yes" xml:space="preserve">
          <source>Git is complex software. One needs an installer of some kind to put Git on a developer workstation, or to upgrade to a newer version of Git. Setting up a Git server is non-trivial, and so most users have to use a third-party service such as GitHub or GitLab, and thus introduce additional (unnecessary) dependencies into the project.</source>
          <target state="translated">Git-это сложное программное обеспечение.Для установки Git'а на рабочую станцию разработчика или для перехода на более новую версию Git'а нужен какой-нибудь инсталлятор.Настройка Git-сервера нетривиальна,поэтому большинству пользователей приходится пользоваться сторонними сервисами,такими как GitHub или GitLab,и таким образом вводить в проект дополнительные (ненужные)зависимости.</target>
        </trans-unit>
        <trans-unit id="ee613d9b4f6dfc0f80be0bd2cfff2ea77808bbb6" translate="yes" xml:space="preserve">
          <source>Git keeps the complete DAG of the check-in sequence. But branch tags are local information that is not synced and not retained once a branch closes. This makes review of historical branches tedious.</source>
          <target state="translated">Git сохраняет полную DAG последовательности регистрации.Но теги ветки-это локальная информация,которая не синхронизируется и не сохраняется после закрытия ветки.Это делает просмотр исторических веток утомительным.</target>
        </trans-unit>
        <trans-unit id="48b3160f0b763f1616179debce43562e664f02d9" translate="yes" xml:space="preserve">
          <source>GitHub and GitLab offer nothing comparable. The closest I have found is the &lt;a href=&quot;https://github.com/sqlite/sqlite/network&quot;&gt;network&lt;/a&gt;, which is slow to render (unless it is already cached), does not offer nearly as much details, and scarcely works on mobile. The &lt;a href=&quot;https://github.com/sqlite/sqlite/commits/master&quot;&gt;commits&lt;/a&gt; view of GitHub provides more detail, renders quickly, and works on mobile, but only shows a single branch at a time, so I cannot easily know if I've seen all of the recent changes. And even if GitHub/GitLab did offer better interfaces, both are third-party services. They are not a core part of Git. Hence, using them introduces yet another dependency into the project.</source>
          <target state="translated">GitHub и GitLab не предлагают ничего сопоставимого. Ближайшее, что я нашел, - это &lt;a href=&quot;https://github.com/sqlite/sqlite/network&quot;&gt;сеть&lt;/a&gt; , которая медленно обрабатывается (если она уже не кеширована), не предлагает столько деталей и почти не работает на мобильных устройствах. Представление &lt;a href=&quot;https://github.com/sqlite/sqlite/commits/master&quot;&gt;коммитов&lt;/a&gt; на GitHub предоставляет более подробную информацию, быстро отрисовывается и работает на мобильных устройствах, но показывает только одну ветвь за раз, поэтому я не могу легко узнать, все ли последние изменения я видел. И даже если GitHub / GitLab действительно предлагают лучшие интерфейсы, оба являются сторонними сервисами. Они не являются основной частью Git. Следовательно, их использование вводит в проект еще одну зависимость.</target>
        </trans-unit>
        <trans-unit id="ba7606fea498a9e876c11c77be2a94dc96cb33f9" translate="yes" xml:space="preserve">
          <source>Given a page number P and a maximum WAL frame index M, return the largest WAL frame index for page P that does not exceed M, or return NULL if there are no frames for page P that do not exceed M.</source>
          <target state="translated">Учитывая номер страницы P и максимальный индекс кадра WAL M,верните самый большой индекс кадра WAL для страницы P,который не превышает M,или верните NULL,если нет кадров для страницы P,которые не превышают M.</target>
        </trans-unit>
        <trans-unit id="d4a9375f517c74831802a20b14cf1be5743c9399" translate="yes" xml:space="preserve">
          <source>Given a single SQL statement, there might be dozens, hundreds, or even thousands of ways to implement that statement, depending on the complexity of the statement itself and of the underlying database schema. The task of the query planner is to select an algorithm from among the many choices that provides the answer with a minimum of disk I/O and CPU overhead.</source>
          <target state="translated">При наличии одного SQL-оператора могут существовать десятки,сотни или даже тысячи способов реализации этого оператора,в зависимости от сложности самого оператора и лежащей в его основе схемы базы данных.Задача планировщика запросов состоит в выборе алгоритма из множества вариантов,который обеспечивает ответ с минимальными затратами дискового ввода/вывода и центрального процессора.</target>
        </trans-unit>
        <trans-unit id="f6bcca46f0f74a9ae01ce42d9f7404d2419d51ad" translate="yes" xml:space="preserve">
          <source>Given all of the information above, the job of the xBestIndex method it to figure out the best way to search the virtual table.</source>
          <target state="translated">Учитывая всю вышеперечисленную информацию,задача метода xBestIndex заключается в том,чтобы найти наилучший способ поиска по виртуальной таблице.</target>
        </trans-unit>
        <trans-unit id="3214b13dd0b542c059230864a7a5bcd2b12ab804" translate="yes" xml:space="preserve">
          <source>Given an input string X, this routine attempts to determine the dominant script of that input and returns the ISO-15924 numeric code for that script. The current implementation understands the following scripts:</source>
          <target state="translated">Учитывая входную строку X,эта рутина пытается определить доминирующий скрипт этого входа и возвращает цифровой код ISO-15924 для этого скрипта.Текущая реализация понимает следующие скрипты:</target>
        </trans-unit>
        <trans-unit id="c57b59e0dd1b427eb5c7b60fabfb8b9d76033a70" translate="yes" xml:space="preserve">
          <source>Given the definition of X1 above, the following expressions have historically evaluated to FALSE in SQLite, though the correct answer is actually NULL:</source>
          <target state="translated">Учитывая определение X1,приведенное выше,следующие выражения исторически оценивались для FALSE в SQLite,хотя правильным ответом на самом деле является NULL:</target>
        </trans-unit>
        <trans-unit id="bd2ada8cc33bdc4785b371a48d725c0e9ca58446" translate="yes" xml:space="preserve">
          <source>Given the new multi-column Idx3 index, it is now possible for SQLite to find the price of California oranges using only 2 binary searches:</source>
          <target state="translated">Учитывая новый многоколоночный индекс Idx3,теперь SQLite может найти цену калифорнийских апельсинов,используя только 2 бинарных поиска:</target>
        </trans-unit>
        <trans-unit id="7427cf697be16a4ec1d916910128a59d920125e7" translate="yes" xml:space="preserve">
          <source>Glossary</source>
          <target state="translated">Glossary</target>
        </trans-unit>
        <trans-unit id="617490ec40d56766edf8aff111990bee9834d1c1" translate="yes" xml:space="preserve">
          <source>Gosub</source>
          <target state="translated">Gosub</target>
        </trans-unit>
        <trans-unit id="0a9ffc4a328e6d21b11f3b8312d08e5b413aec49" translate="yes" xml:space="preserve">
          <source>Goto</source>
          <target state="translated">Goto</target>
        </trans-unit>
        <trans-unit id="1dee13ac09a18c736a85fb7212501ca3f0535655" translate="yes" xml:space="preserve">
          <source>Gt</source>
          <target state="translated">Gt</target>
        </trans-unit>
        <trans-unit id="60f4e65b35154fc853b0c67ac464ba87691c1af9" translate="yes" xml:space="preserve">
          <source>Guard your tongue against evil and depraved speech.</source>
          <target state="translated">Охраняй свой язык от злых и развратных речей.</target>
        </trans-unit>
        <trans-unit id="3472b7100ee6c34d2c985ec6e738e904962356df" translate="yes" xml:space="preserve">
          <source>HAVING</source>
          <target state="translated">HAVING</target>
        </trans-unit>
        <trans-unit id="a4c7ee9ba5c961273e153da9b6004699add74ac0" translate="yes" xml:space="preserve">
          <source>HH:MM</source>
          <target state="translated">HH:MM</target>
        </trans-unit>
        <trans-unit id="4a05a9c514dbbe7b13aeee7ffbbac9804dba7f74" translate="yes" xml:space="preserve">
          <source>HH:MM:SS</source>
          <target state="translated">HH:MM:SS</target>
        </trans-unit>
        <trans-unit id="4fe76e489c6dd906a0f1a9c53aab6e472da095e8" translate="yes" xml:space="preserve">
          <source>HH:MM:SS.SSS</source>
          <target state="translated">HH:MM:SS.SSS</target>
        </trans-unit>
        <trans-unit id="65f5a5cdef2d1220d932d3711961b5f933bef00b" translate="yes" xml:space="preserve">
          <source>HHHHHHHH</source>
          <target state="translated">HHHHHHHH</target>
        </trans-unit>
        <trans-unit id="cbc6ab8d850f8cff446447123804da23a703c293" translate="yes" xml:space="preserve">
          <source>Halt</source>
          <target state="translated">Halt</target>
        </trans-unit>
        <trans-unit id="c9efb4e35e5411aedaf0542890d4f34de7fdc553" translate="yes" xml:space="preserve">
          <source>HaltIfNull</source>
          <target state="translated">HaltIfNull</target>
        </trans-unit>
        <trans-unit id="eda901a16a2ed9d0d0e178d305fa51f41c885dd9" translate="yes" xml:space="preserve">
          <source>Has the same PRIMARY KEY definition.</source>
          <target state="translated">Имеет то же самое определение PRIMARY KEY.</target>
        </trans-unit>
        <trans-unit id="7b3c15bec716c58e30bb9a01cc52d490760b69bf" translate="yes" xml:space="preserve">
          <source>Has the same name,</source>
          <target state="translated">У него такое же имя,</target>
        </trans-unit>
        <trans-unit id="96ee9d0e4b354db6f1aac2ad6a31abd4bc3e74ca" translate="yes" xml:space="preserve">
          <source>Has the same set of columns declared in the same order, and</source>
          <target state="translated">Имеет тот же набор колонок,объявленных в том же порядке,и</target>
        </trans-unit>
        <trans-unit id="71024d7461751155928cb62c4bbb4edb8155f4cb" translate="yes" xml:space="preserve">
          <source>Hate no one.</source>
          <target state="translated">Ненавижу никого.</target>
        </trans-unit>
        <trans-unit id="f5e9b1bebb569eb2b57a7ab4d85d0681e37d4262" translate="yes" xml:space="preserve">
          <source>Having SQLite take ownership of the type strings would impose a performance cost on all applications, even applications that do not use the pointer-passing interfaces. SQLite passes values around as instances of the &lt;a href=&quot;c3ref/value&quot;&gt;sqlite3_value&lt;/a&gt; object. That object has a destructor, which because of the fact that sqlite3_value objects are used for nearly everything, is invoked frequently. If the destructor needs to check to see if there is a pointer type string that needs to be freed, that is a few extra CPU cycles that need to be burned on each call to the destructor. Those cycles add up. We would be willing to bear the cost of the extra CPU cycles if pointer-passing was a commonly used programming paradigm, but pointer-passing is rare, and so it seems unwise to impose a run-time cost on billions and billions of applications that do not use pointer passing just for convenience of a few applications that do.</source>
          <target state="translated">Если SQLite возьмет на себя ответственность за строки типа, это приведет к снижению производительности для всех приложений, даже для приложений, которые не используют интерфейсы передачи указателей. SQLite передает значения как экземпляры &lt;a href=&quot;c3ref/value&quot;&gt;sqlite3_value&lt;/a&gt;объект. Этот объект имеет деструктор, который из-за того, что объекты sqlite3_value используются почти для всего, часто вызывается. Если деструктору нужно проверить, есть ли строка типа указателя, которую нужно освободить, это несколько дополнительных циклов ЦП, которые необходимо сжигать при каждом вызове деструктора. Эти циклы складываются. Мы были бы готовы нести расходы на дополнительные циклы ЦП, если бы передача указателя была широко используемой парадигмой программирования, но передача указателя является редкостью, и поэтому кажется неразумным налагать затраты времени выполнения на миллиарды и миллиарды приложений, которые не используйте передачу указателя только для удобства некоторых приложений, которые это делают.</target>
        </trans-unit>
        <trans-unit id="3880fcd08d24da661937a86693cfca26882a3b4e" translate="yes" xml:space="preserve">
          <source>Hazards of upgrading to the NGQP</source>
          <target state="translated">Опасности модернизации до NGQP</target>
        </trans-unit>
        <trans-unit id="5050e4d38d7df11eb3b253f0629fcc46c260dc76" translate="yes" xml:space="preserve">
          <source>Header string: 0xd9, 0xd5, 0x05, 0xf9, 0x20, 0xa1, 0x63, 0xd7</source>
          <target state="translated">Строка заголовка:0xd9,0xd5,0x05,0xf9,0x20,0xa1,0x63,0xd7</target>
        </trans-unit>
        <trans-unit id="4bc19fb4af9f917cd00992c6391f45202ff0d0ec" translate="yes" xml:space="preserve">
          <source>Hence, a good rule of thumb is that your database schema should never contain two indices where one index is a prefix of the other. Drop the index with fewer columns. SQLite will still be able to do efficient lookups with the longer index.</source>
          <target state="translated">Следовательно,хорошее эмпирическое правило заключается в том,что схема вашей базы данных никогда не должна содержать двух индексов,где один индекс является префиксом другого.Бросайте индекс с меньшим количеством столбцов.SQLite все равно сможет выполнять эффективный поиск с более длинным индексом.</target>
        </trans-unit>
        <trans-unit id="e3f076946ec3be55b66dffc59ab395c4e63eeb8f" translate="yes" xml:space="preserve">
          <source>Hence, by adding extra &quot;output&quot; columns onto the end of an index, one can avoid having to reference the original table and thereby cut the number of binary searches for a query in half. This is a constant-factor improvement in performance (roughly a doubling of the speed). But on the other hand, it is also just a refinement; A two-fold performance increase is not nearly as dramatic as the one-million-fold increase seen when the table was first indexed. And for most queries, the difference between 1 microsecond and 2 microseconds is unlikely to be noticed.</source>
          <target state="translated">Таким образом,добавляя дополнительные &quot;выходные&quot; столбцы в конец индекса,можно избежать необходимости ссылаться на исходную таблицу и тем самым сократить количество двоичных поисков по запросу пополам.Это постоянное улучшение производительности (примерно удвоение скорости).Но,с другой стороны,это также просто уточнение;двукратное увеличение производительности не так драматично,как миллионный рост,наблюдаемый при первом индексировании таблицы.А по большинству запросов разница между 1 микросекундой и 2 микросекундами вряд ли будет замечена.</target>
        </trans-unit>
        <trans-unit id="b665f7a53251e88b80c18ae95a6e2a7570ff2c9e" translate="yes" xml:space="preserve">
          <source>Hence, in comparison to other approaches, the use of an SQLite database as an application file format has compelling advantages. Here are a few of these advantages, enumerated and expounded:</source>
          <target state="translated">Таким образом,по сравнению с другими подходами,использование базы данных SQLite в качестве формата файла приложения имеет неоспоримые преимущества.Вот некоторые из этих преимуществ,перечисленные и описанные:</target>
        </trans-unit>
        <trans-unit id="39e8db1d33a3457396e45de0c0793052727a641e" translate="yes" xml:space="preserve">
          <source>Hence, the content encoding for a WITHOUT ROWID table is the same as the content encoding for an ordinary rowid table, except that the order of the columns is rearranged so that PRIMARY KEY columns come first, and the content is used as the key in an index b-tree rather than as the data in a table b-tree. The special encoding rules for columns with REAL affinity apply to WITHOUT ROWID tables the same as they do with rowid tables.</source>
          <target state="translated">Следовательно,кодировка содержимого для БЕЗ РАЗРЕШЕНИЯ таблицы такая же,как и кодировка содержимого для обычной таблицы rowid,за исключением того,что порядок столбцов изменен таким образом,что столбцы PRIMARY KEY стоят на первом месте,а содержимое используется в качестве ключа в b-дереве индекса,а не в качестве данных в b-дереве таблицы.Специальные правила кодирования для столбцов с REAL сродством применяются к БЕЗ ROWID таблицам так же,как и к таблицам с rowid.</target>
        </trans-unit>
        <trans-unit id="999cfa83416c7b736dc3f3dfa6e7f25b9ba6e98f" translate="yes" xml:space="preserve">
          <source>Here again, version 2.7.0 of SQLite used to run at about the same speed as MySQL. But now version 2.7.6 is over two times faster than MySQL and over twenty times faster than PostgreSQL.</source>
          <target state="translated">Здесь опять же,версия 2.7.0 SQLite работала примерно с той же скоростью,что и MySQL.Но теперь версия 2.7.6 более чем в два раза быстрее MySQL и более чем в двадцать раз быстрее PostgreSQL.</target>
        </trans-unit>
        <trans-unit id="c79a9d1055558ef2d9992c6424392d62b259c2a6" translate="yes" xml:space="preserve">
          <source>Here are some existing and postulated uses for virtual tables:</source>
          <target state="translated">Вот некоторые существующие и постулируемые варианты использования виртуальных таблиц:</target>
        </trans-unit>
        <trans-unit id="f0580ad7def68334eac7c2c033faae47fa33aa31" translate="yes" xml:space="preserve">
          <source>Here are the syntax details:</source>
          <target state="translated">Вот подробности синтаксиса:</target>
        </trans-unit>
        <trans-unit id="c84ee5f5403083ecda923ec1470b2d4f31fd0f00" translate="yes" xml:space="preserve">
          <source>Here is a complete template extension that you can copy/paste to get started:</source>
          <target state="translated">Вот полное расширение шаблона,которое вы можете скопировать/вставить,чтобы начать:</target>
        </trans-unit>
        <trans-unit id="537d394cf0d1eecb92a9cbe8efc7e1a703bdd18e" translate="yes" xml:space="preserve">
          <source>Here is a query that computes the average height over everyone in Alice's organization, including Alice:</source>
          <target state="translated">Вот запрос,который вычисляет среднюю высоту над всеми в организации Алисы,в том числе и над Алисой:</target>
        </trans-unit>
        <trans-unit id="dd42feed9698b376dcb10e9aa54e385c734b65a6" translate="yes" xml:space="preserve">
          <source>Here is a query to show the tree structure in a breadth-first pattern:</source>
          <target state="translated">Вот запрос на отображение древовидной структуры в первом шаблоне ширины:</target>
        </trans-unit>
        <trans-unit id="b68ea20ab0a8004dffe949b080033114856a05ba" translate="yes" xml:space="preserve">
          <source>Here is a simple example of omitting a LEFT JOIN:</source>
          <target state="translated">Вот простой пример опускания ЛЕВОГО СОВЕТА:</target>
        </trans-unit>
        <trans-unit id="22d888f42ada11de3c14b5860a924536cf19b222" translate="yes" xml:space="preserve">
          <source>Here is a slightly different way to describe the aPgno values: If you think of all aPgno values as a contiguous array, then the database page number stored in the i-th frame of the WAL file is stored in aPgno[i]. Of course, aPgno is not a contiguous array. The first 4062 entries are on the first 32768-byte unit of the shm file and subsequent values are in 4096 entry chunks in later units of the shm file.</source>
          <target state="translated">Вот несколько другой способ описания значений aPgno:Если рассматривать все значения aPgno как смежный массив,то номер страницы базы данных,хранящейся в i-ом фрейме файла WAL,хранится в aPgno[i].Конечно,aPgno не является смежным массивом.Первые 4062 записи находятся в первой 32768-байтовой единице файла shm,а последующие значения-в 4096 кусках в более поздних единицах файла shm.</target>
        </trans-unit>
        <trans-unit id="eeed83aeb26a72a7167e0caa92d0a130551072b7" translate="yes" xml:space="preserve">
          <source>Here is a summary of what the core interfaces do:</source>
          <target state="translated">Вот краткое описание того,что делают основные интерфейсы:</target>
        </trans-unit>
        <trans-unit id="8a2373a91d98c2486bbd1ed6e2138a7e77394ed5" translate="yes" xml:space="preserve">
          <source>Here is a variation on the previous example:</source>
          <target state="translated">Вот вариация на предыдущем примере:</target>
        </trans-unit>
        <trans-unit id="1319ba3fc57ef36ac27efdbc47123bdd4cb7f431" translate="yes" xml:space="preserve">
          <source>Here is an alternative description of the same computation:</source>
          <target state="translated">Вот альтернативное описание этого же вычисления:</target>
        </trans-unit>
        <trans-unit id="44eacff0724c9f996876f69099ca0b2726a97ade" translate="yes" xml:space="preserve">
          <source>Here is an alternative way of describing the hash look-up algorithm: Start with h = (P * 383)%8192 and look at aHash[h] and subsequent entries, wrapping around to zero when h reaches 8192, until finding an entry with aHash[h]==0. All aPgno entries having a page number of P will have an index that is one of the aHash[h] values thusly computed. But not all the computed aHash[h] values will meet the matching criteria, so you must check them independently. The speed advantage comes about because normally this set of h values is very small.</source>
          <target state="translated">Вот альтернативный способ описания алгоритма поиска хэша:Начните с h=(P*383)%8192 и посмотрите на aHash[h]и последующие записи,обернутые до нуля при достижении h 8192,пока не найдете запись с aHash[h]==0.Все записи aPgno,имеющие номер страницы P,будут иметь индекс,который является одним из значений aHash[h],вычисленных таким образом.Но не все вычисленные значения aHash[h]будут соответствовать критериям соответствия,поэтому необходимо проверять их независимо.Преимущество в скорости достигается за счет того,что обычно этот набор значений h очень мал.</target>
        </trans-unit>
        <trans-unit id="1a49c4bb8c6fe24c99e1160edbe5f45003dd833d" translate="yes" xml:space="preserve">
          <source>Here is an example using the built-in row_number() window function:</source>
          <target state="translated">Приведем пример использования встроенной оконной функции row_number():</target>
        </trans-unit>
        <trans-unit id="1ed2d64e0577782df2f1f708b1c461ee5ebea46a" translate="yes" xml:space="preserve">
          <source>Here is what is going to happen: The first SELECT statement will construct rows of the result and save each row as the key of an entry in the transient table. The data for each entry in the transient table is a never used so we fill it in with an empty string. The second SELECT statement also constructs rows, but the rows constructed by the second SELECT are removed from the transient table. That is why we want the rows to be stored in the key of the SQLite file instead of in the data -- so they can be easily located and deleted.</source>
          <target state="translated">Вот что произойдет:Первый оператор SELECT построит строки результата и сохранит каждую строку как ключ записи в переходной таблице.Данные для каждой записи в переходной таблице никогда не используются,поэтому мы заполняем ее пустой строкой.Второй оператор SELECT также построит строки,но строки,построенные вторым SELECT,удаляются из переходной таблицы.Поэтому мы хотим,чтобы строки хранились в ключе SQLite-файла,а не в данных,чтобы их можно было легко найти и удалить.</target>
        </trans-unit>
        <trans-unit id="7a844050eead2e7f9a21cd042c8a0efba1c399bc" translate="yes" xml:space="preserve">
          <source>Here is what the program must do. First it has to locate all of the records in the table &quot;examp&quot; that are to be deleted. This is done using a loop very much like the loop used in the SELECT examples above. Once all records have been located, then we can go back through and delete them one by one. Note that we cannot delete each record as soon as we find it. We have to locate all records first, then go back and delete them. This is because the SQLite database backend might change the scan order after a delete operation. And if the scan order changes in the middle of the scan, some records might be visited more than once and other records might not be visited at all.</source>
          <target state="translated">Вот что должна сделать программа.Сначала она должна найти все записи в таблице &quot;экзамен&quot;,которые должны быть удалены.Это делается с помощью цикла,очень похожего на цикл,используемый в примерах SELECT выше.После того,как все записи найдены,мы можем вернуться назад и удалить их по одной.Обратите внимание,что мы не можем удалить каждую запись,как только найдем ее.Сначала мы должны найти все записи,затем вернуться назад и удалить их.Это связано с тем,что бэкэнд базы данных SQLite может изменить порядок сканирования после операции удаления.И если порядок сканирования изменится в середине сканирования,некоторые записи могут быть посещены более одного раза,а другие вообще не будут посещены.</target>
        </trans-unit>
        <trans-unit id="6ed0e64b4172a16a9716e7e75ddd35007c4f6e5a" translate="yes" xml:space="preserve">
          <source>Here is what you do to start experimenting with SQLite without having to do a lot of tedious reading and configuration:</source>
          <target state="translated">Вот что нужно сделать,чтобы начать экспериментировать с SQLite без утомительного чтения и настройки:</target>
        </trans-unit>
        <trans-unit id="c11a956fd1daf361e07b9a2963b5331668a6cb09" translate="yes" xml:space="preserve">
          <source>Here the apostrophe has been escaped and the SQL statement is well-formed. When generating SQL on-the-fly from data that might contain a single-quote character ('), it is always a good idea to use the SQLite printf routines and the %q formatting option instead of &lt;b&gt;sprintf&lt;/b&gt;.</source>
          <target state="translated">Здесь апостроф был экранирован, а оператор SQL сформирован правильно. При генерации SQL на лету из данных, которые могут содержать символ одинарной кавычки ('), всегда рекомендуется использовать подпрограммы SQLite printf и параметр форматирования% q вместо &lt;b&gt;sprintf&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="53844b42e0f15c4e9c92f326da701e5edff51b64" translate="yes" xml:space="preserve">
          <source>Here the inequalities are on columns x and y which are not the left-most index columns. Hence, the histogram data which is collected no left-most column of indices is useless in helping to choose between the range constraints on columns x and y.</source>
          <target state="translated">Здесь неравенства находятся на столбцах x и y,которые не являются самыми левыми столбцами индекса.Следовательно,данные гистограммы,которые не собираются в крайнем левом столбце индексов,бесполезны для выбора между ограничениями диапазона на столбцах x и y.</target>
        </trans-unit>
        <trans-unit id="54b1a90f72334cf67c79da3608b8cff7cc194a79" translate="yes" xml:space="preserve">
          <source>Hexadecimal</source>
          <target state="translated">Hexadecimal</target>
        </trans-unit>
        <trans-unit id="f3f781093bc605abee81ccbeb636a20f530bbe5d" translate="yes" xml:space="preserve">
          <source>Hexadecimal integer literals</source>
          <target state="translated">целочисленные шестнадцатеричные литералы</target>
        </trans-unit>
        <trans-unit id="35e13960711ca47c62471d92f2b4029ee7852496" translate="yes" xml:space="preserve">
          <source>Hexadecimal integer literals follow the C-language notation of &quot;0x&quot; or &quot;0X&quot; followed by hexadecimal digits. For example, 0x1234 means the same as 4660 and 0x8000000000000000 means the same as -9223372036854775808. Hexadecimal integer literals are interpreted as 64-bit two's-complement integers and are thus limited to sixteen significant digits of precision. Support for hexadecimal integers was added to SQLite version 3.8.6 (2014-08-15). For backwards compatibility, the &quot;0x&quot; hexadecimal integer notation is only understood by the SQL language parser, not by the type conversions routines. String variables that contain text formatted like hexadecimal integers are not interpreted as hexadecimal integers when coercing the string value into an integer due to a &lt;a href=&quot;lang_expr#castexpr&quot;&gt;CAST expression&lt;/a&gt; or for a &lt;a href=&quot;datatype3#affinity&quot;&gt;column affinity&lt;/a&gt; transformation or prior to performing a numeric operation or for any other run-time conversions. When coercing a string value in the format of a hexadecimal integer into an integer value, the conversion process stops when the 'x' character is seen so the resulting integer value is always zero. SQLite only understands the hexadecimal integer notation when it appears in the SQL statement text, not when it appears as part of the content of the database.</source>
          <target state="translated">Шестнадцатеричные целочисленные литералы следуют нотации языка C &quot;0x&quot; или &quot;0X&quot;, за которой следуют шестнадцатеричные цифры. Например, 0x1234 означает то же, что и 4660, а 0x8000000000000000 означает то же самое, что и -9223372036854775808. Шестнадцатеричные целочисленные литералы интерпретируются как 64-битные целые числа с дополнением до двух и, таким образом, ограничены шестнадцатью значащими цифрами точности. Поддержка шестнадцатеричных целых чисел была добавлена ​​в SQLite версии 3.8.6 (2014-08-15). Для обратной совместимости шестнадцатеричное целочисленное представление &amp;laquo;0x&amp;raquo; понимается только синтаксическим анализатором языка SQL, а не процедурами преобразования типов.Строковые переменные, содержащие текст, отформатированный как шестнадцатеричные целые числа, не интерпретируются как шестнадцатеричные целые числа при преобразовании строкового значения в целое число из-за &lt;a href=&quot;lang_expr#castexpr&quot;&gt;выражения CAST&lt;/a&gt; или &lt;a href=&quot;datatype3#affinity&quot;&gt;сходства столбца&lt;/a&gt;преобразование или перед выполнением числовой операции или для любых других преобразований времени выполнения. При преобразовании строкового значения в формате шестнадцатеричного целого числа в целочисленное, процесс преобразования останавливается, когда отображается символ &amp;laquo;x&amp;raquo;, поэтому результирующее целочисленное значение всегда равно нулю. SQLite понимает шестнадцатеричную целочисленную нотацию только тогда, когда она появляется в тексте оператора SQL, а не когда она появляется как часть содержимого базы данных.</target>
        </trans-unit>
        <trans-unit id="4413e5afdd76b08f7a57f3501dcd353af75c6909" translate="yes" xml:space="preserve">
          <source>Hexadecimal integers</source>
          <target state="translated">шестнадцатеричные числа</target>
        </trans-unit>
        <trans-unit id="34ad49fd08b5d8ebfe6309e8a94dbdda68560346" translate="yes" xml:space="preserve">
          <source>Hidden column</source>
          <target state="translated">Скрытая колонка</target>
        </trans-unit>
        <trans-unit id="47adea5ce487ea3890476b37d1c95b4a2f866391" translate="yes" xml:space="preserve">
          <source>Hidden columns are not included in the expansion of a &quot;*&quot; expression in the result set of a &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt;, and</source>
          <target state="translated">Скрытые столбцы не включаются в раскрытие выражения &quot;*&quot; в результирующем наборе &lt;a href=&quot;lang_select&quot;&gt;оператора SELECT&lt;/a&gt; , и</target>
        </trans-unit>
        <trans-unit id="20096dd8d3b8c2cfd4d3a69c38df377eed777771" translate="yes" xml:space="preserve">
          <source>Hidden columns are not included in the implicit column-list used by an &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; statement that lacks an explicit column-list.</source>
          <target state="translated">Скрытые столбцы не включаются в неявный список столбцов, используемый оператором &lt;a href=&quot;lang_insert&quot;&gt;INSERT, в&lt;/a&gt; котором отсутствует явный список столбцов.</target>
        </trans-unit>
        <trans-unit id="b7668a93e533ae2c015270865d5e714d07d437f1" translate="yes" xml:space="preserve">
          <source>Hidden columns are not listed in the dataset returned by &quot;&lt;a href=&quot;pragma#pragma_table_info&quot;&gt;PRAGMA table_info&lt;/a&gt;&quot;,</source>
          <target state="translated">Скрытые столбцы не перечислены в наборе данных, возвращаемом &lt;a href=&quot;pragma#pragma_table_info&quot;&gt;PRAGMA table_info&lt;/a&gt; ,</target>
        </trans-unit>
        <trans-unit id="c4cf7b97c327f9d39106315e4a050c0b0f137cef" translate="yes" xml:space="preserve">
          <source>Hierarchical Query Examples</source>
          <target state="translated">Примеры иерархических запросов</target>
        </trans-unit>
        <trans-unit id="62ae978c372dd625e1ad5bee3c09efecd27ef87c" translate="yes" xml:space="preserve">
          <source>High Reliability</source>
          <target state="translated">Высокая надежность</target>
        </trans-unit>
        <trans-unit id="5b43fa59ed80a4a74e2345ca9a7be4d00498a5de" translate="yes" xml:space="preserve">
          <source>High-Level Query Language</source>
          <target state="translated">Язык запросов высокого уровня</target>
        </trans-unit>
        <trans-unit id="f0be6eee61b3f35036173bb461da267d072410b3" translate="yes" xml:space="preserve">
          <source>High-security Value</source>
          <target state="translated">Высокая безопасность Ценность</target>
        </trans-unit>
        <trans-unit id="d4e0f8e3d3d0dc08399c35d69b24eda9dfffeab6" translate="yes" xml:space="preserve">
          <source>Higher level logic within SQLite will normally intercept the error code and create a temporary in-memory shared memory region so that the current process can at least read the content of the database. This result code should not reach the application interface layer.</source>
          <target state="translated">Логика более высокого уровня внутри SQLite,как правило,перехватывает код ошибки и создает временную область общей памяти in-memory,так что текущий процесс может,по крайней мере,читать содержимое базы данных.Этот код результата не должен доходить до уровня интерфейса приложения.</target>
        </trans-unit>
        <trans-unit id="8ec8e6f8b27cff894766ae4e4215e6f333126ae8" translate="yes" xml:space="preserve">
          <source>Highest precedence (tightest grouping).</source>
          <target state="translated">Высший приоритет (самая плотная группировка).</target>
        </trans-unit>
        <trans-unit id="9d8bc8b9f1a6b46c231d4505eec0f99894497892" translate="yes" xml:space="preserve">
          <source>Hint: applications can generate globally unique identifiers using this function together with &lt;a href=&quot;lang_corefunc#hex&quot;&gt;hex()&lt;/a&gt; and/or &lt;a href=&quot;lang_corefunc#lower&quot;&gt;lower()&lt;/a&gt; like this:</source>
          <target state="translated">Подсказка: приложения могут генерировать глобальные уникальные идентификаторы, используя эту функцию вместе с &lt;a href=&quot;lang_corefunc#hex&quot;&gt;hex ()&lt;/a&gt; и / или &lt;a href=&quot;lang_corefunc#lower&quot;&gt;lower ()&lt;/a&gt; следующим образом:</target>
        </trans-unit>
        <trans-unit id="13895cc550db90756c2c44f981469cdd85261a1d" translate="yes" xml:space="preserve">
          <source>Hints for Debugging SQLite</source>
          <target state="translated">Подсказки по отладке SQLite</target>
        </trans-unit>
        <trans-unit id="6b205a779ffaeec5fb12feda7165de7c06e54bbe" translate="yes" xml:space="preserve">
          <source>Historical test cases from &lt;a href=&quot;testing#aflfuzz&quot;&gt;AFL&lt;/a&gt;, &lt;a href=&quot;testing#ossfuzz&quot;&gt;OSS Fuzz&lt;/a&gt;, and &lt;a href=&quot;testing#dbsqlfuzz&quot;&gt;dbsqlfuzz&lt;/a&gt; are collected in a set of database files in the main SQLite source tree and then rerun by the &quot;fuzzcheck&quot; utility program whenever one runs &quot;make test&quot;. Fuzzcheck only runs a few thousand &quot;interesting&quot; cases out of the hundreds of millions of cases that the various fuzzers have examined over the years. &quot;Interesting&quot; cases are cases that exhibit previously unseen behavior. Actual bugs found by fuzzers are always included among the interesting test cases, but most of the cases run by fuzzcheck were never actual bugs.</source>
          <target state="translated">Исторические тестовые примеры из &lt;a href=&quot;testing#aflfuzz&quot;&gt;AFL&lt;/a&gt; , &lt;a href=&quot;testing#ossfuzz&quot;&gt;OSS Fuzz&lt;/a&gt; и &lt;a href=&quot;testing#dbsqlfuzz&quot;&gt;dbsqlfuzz&lt;/a&gt; собираются в набор файлов базы данных в основном дереве исходных текстов SQLite, а затем повторно запускаются служебной программой &amp;laquo;fuzzcheck&amp;raquo; при каждом запуске &amp;laquo;make test&amp;raquo;. Fuzzcheck запускает лишь несколько тысяч &amp;laquo;интересных&amp;raquo; случаев из сотен миллионов случаев, которые различные фаззеры исследовали за эти годы. &amp;laquo;Интересные&amp;raquo; случаи - это случаи, демонстрирующие ранее невидимое поведение. Фактические ошибки, обнаруженные фаззерами, всегда включаются в число интересных тестовых примеров, но большинство случаев, запускаемых fuzzcheck, никогда не были настоящими ошибками.</target>
        </trans-unit>
        <trans-unit id="67fec9a6d19b7573beec194f9c1e57c883f7bff1" translate="yes" xml:space="preserve">
          <source>Historically, backups (copies) of SQLite databases have been created using the following method:</source>
          <target state="translated">Исторически резервные копии баз данных SQLite создавались следующим способом:</target>
        </trans-unit>
        <trans-unit id="a7796946d81b3e384b117135d383fc5e5877941f" translate="yes" xml:space="preserve">
          <source>Historically, the bytecode engine in SQLite is called the &quot;Virtual DataBase Engine&quot; or &quot;VDBE&quot;. This website uses the terms &quot;bytecode engine&quot;, &quot;VDBE&quot;, &quot;virtual machine&quot;, and &quot;bytecode virtual machine&quot; interchangeably, as they all mean the same thing.</source>
          <target state="translated">Исторически сложилось так,что движок байткода в SQLite называется &quot;Virtual DataBase Engine&quot; или &quot;VDBE&quot;.На этом сайте термины &quot;движок байткода&quot;,&quot;VDBE&quot;,&quot;виртуальная машина&quot; и &quot;виртуальная машина байткода&quot; взаимозаменяемы,так как все они означают одно и то же.</target>
        </trans-unit>
        <trans-unit id="186352c9ed4b1d5538fac7c967930c7dfb52b78f" translate="yes" xml:space="preserve">
          <source>Historically, the return value from xFindFunction() was either zero or one. Zero means that the function is not overloaded and one means that it is overload. The ability to return values of &lt;a href=&quot;c3ref/c_index_constraint_eq&quot;&gt;SQLITE_INDEX_CONSTRAINT_FUNCTION&lt;/a&gt; or greater was added in version 3.25.0 (2018-09-15). If xFindFunction returns &lt;a href=&quot;c3ref/c_index_constraint_eq&quot;&gt;SQLITE_INDEX_CONSTRAINT_FUNCTION&lt;/a&gt; or greater, than means that the function takes two arguments and the function can be used as a boolean in the WHERE clause of a query and that the virtual table is able to exploit that function to speed up the query result. When xFindFunction returns &lt;a href=&quot;c3ref/c_index_constraint_eq&quot;&gt;SQLITE_INDEX_CONSTRAINT_FUNCTION&lt;/a&gt; or larger, the value returned becomes the sqlite3_index_info.aConstraint.op value for one of the constraints passed into &lt;a href=&quot;vtab#xbestindex&quot;&gt;xBestIndex()&lt;/a&gt; and the second argument becomes the value corresponding to that constraint that is passed to &lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter()&lt;/a&gt;. This enables the xBestIndex()/xFilter implementations to use the function to speed its search.</source>
          <target state="translated">Исторически возвращаемое значение xFindFunction () было либо нулем, либо единицей. Ноль означает, что функция не перегружена, а единица означает, что она перегружена. Возможность возвращать значения &lt;a href=&quot;c3ref/c_index_constraint_eq&quot;&gt;SQLITE_INDEX_CONSTRAINT_FUNCTION&lt;/a&gt; или выше была добавлена ​​в версии 3.25.0 (2018-09-15). Если xFindFunction возвращает &lt;a href=&quot;c3ref/c_index_constraint_eq&quot;&gt;SQLITE_INDEX_CONSTRAINT_FUNCTION&lt;/a&gt; или больше, это означает, что функция принимает два аргумента, и функция может использоваться как логическое значение в предложении WHERE запроса, и что виртуальная таблица может использовать эту функцию для ускорения результата запроса. Когда xFindFunction возвращает &lt;a href=&quot;c3ref/c_index_constraint_eq&quot;&gt;SQLITE_INDEX_CONSTRAINT_FUNCTION&lt;/a&gt; или больше, возвращаемое значение становится значением sqlite3_index_info.aConstraint.op для одного из ограничений, переданных в &lt;a href=&quot;vtab#xbestindex&quot;&gt;xBestIndex ()&lt;/a&gt;а второй аргумент становится значением, соответствующим тому ограничению, которое передается в &lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter ()&lt;/a&gt; . Это позволяет реализациям xBestIndex () / xFilter использовать функцию для ускорения поиска.</target>
        </trans-unit>
        <trans-unit id="48f87256a37f996b34f071b6b4ef5f1805966dbd" translate="yes" xml:space="preserve">
          <source>Historically, this was not considered a threat. The argument was that if a hostile agent is able to inject arbitrary SQL text into the application, then that agent is already in full control of the application, so letting the hostile agent forge a pointer does not give the agent any new capability.</source>
          <target state="translated">Исторически это не считалось угрозой.Аргументом было то,что если враждебный агент способен внедрить произвольный SQL текст в приложение,то этот агент уже полностью контролирует приложение,поэтому позволить враждебному агенту подделать указатель не дает агенту никаких новых возможностей.</target>
        </trans-unit>
        <trans-unit id="bfbddd574d4f950742d8e5d7a49607c23d347f95" translate="yes" xml:space="preserve">
          <source>Honor all.</source>
          <target state="translated">Честь всем.</target>
        </trans-unit>
        <trans-unit id="645a5172c51f2105b78cb24101222af4c2581b31" translate="yes" xml:space="preserve">
          <source>Honor the &lt;a href=&quot;c3ref/c_deserialize_freeonclose&quot;&gt;SQLITE_DESERIALIZE_READONLY&lt;/a&gt; flag, which was previously described in the documentation, but was previously a no-op.</source>
          <target state="translated">Чти &lt;a href=&quot;c3ref/c_deserialize_freeonclose&quot;&gt;SQLITE_DESERIALIZE_READONLY&lt;/a&gt; флаг, который ранее был описан в документации, но не был ранее не оп.</target>
        </trans-unit>
        <trans-unit id="2fff26aa56e0db9e63e42ae6a74896b210340408" translate="yes" xml:space="preserve">
          <source>Honor the ORDER BY and LIMIT clause of a SELECT even if the result set is used for an INSERT.</source>
          <target state="translated">УЧИТЫВАЙТЕ ЗАЯВЛЕНИЕ и ОГРАНИЧЕНИЕ,даже если для ИНСЕРТА используется результирующий набор.</target>
        </trans-unit>
        <trans-unit id="972205ef02943c809b85189066f29ea5a922b1d8" translate="yes" xml:space="preserve">
          <source>Host parameter names can begin with '@' for compatibility with SQL Server.</source>
          <target state="translated">Имена параметров хоста могут начинаться с '@' для совместимости с SQL Server.</target>
        </trans-unit>
        <trans-unit id="2107ab6c47208816e9f85a68b6f666b821dd323b" translate="yes" xml:space="preserve">
          <source>Hot Journal Detection</source>
          <target state="translated">Обнаружение горячих журналов</target>
        </trans-unit>
        <trans-unit id="387adc1437f284bb8f7d821272256c3791f7c532" translate="yes" xml:space="preserve">
          <source>Hot Journal Rollback</source>
          <target state="translated">Горячий перемотка журнала</target>
        </trans-unit>
        <trans-unit id="51a2396551270d6b1b9b0daa06c843f02294bf7a" translate="yes" xml:space="preserve">
          <source>Hot journal files</source>
          <target state="translated">Горячие журнальные файлы</target>
        </trans-unit>
        <trans-unit id="33f85488d44d0b31b265f227edf83b283232673c" translate="yes" xml:space="preserve">
          <source>Hot journal rollback</source>
          <target state="translated">Горячий откат журнала</target>
        </trans-unit>
        <trans-unit id="72b9d3b59a2cd3c6b5726c2ec8f20f5cbd8fc2c8" translate="yes" xml:space="preserve">
          <source>How &lt;a href=&quot;queryplanner&quot;&gt;indexing&lt;/a&gt; works.</source>
          <target state="translated">Как работает &lt;a href=&quot;queryplanner&quot;&gt;индексация&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="de544e283cfebc5d70d3d7b590e023e13a9bf879" translate="yes" xml:space="preserve">
          <source>How Memory-Mapped I/O Works</source>
          <target state="translated">Как работает карта памяти ввода/вывода</target>
        </trans-unit>
        <trans-unit id="56b803311ab7e3e616ef538b11ad7fad3dcd0741" translate="yes" xml:space="preserve">
          <source>How SQLite Is Tested</source>
          <target state="translated">Как тестируется SQLite</target>
        </trans-unit>
        <trans-unit id="f0b874a1265664f2f8c8240dcb0a141334e57668" translate="yes" xml:space="preserve">
          <source>How To Compile SQLite</source>
          <target state="translated">Как скомпилировать SQLite</target>
        </trans-unit>
        <trans-unit id="bac0366a300ac4acaffdcf4c3d4ee83a4619271d" translate="yes" xml:space="preserve">
          <source>How To Corrupt</source>
          <target state="translated">Как коррумпировать</target>
        </trans-unit>
        <trans-unit id="07961a03bdae1448ec20af2c6389f109c109cecd" translate="yes" xml:space="preserve">
          <source>How To Corrupt An SQLite Database File</source>
          <target state="translated">Как повредить файл базы данных SQLite</target>
        </trans-unit>
        <trans-unit id="ac75035a65466ee12d9ad12dabe0ea72bf4078bd" translate="yes" xml:space="preserve">
          <source>How To Corrupt Your Database Files</source>
          <target state="translated">Как повредить файлы базы данных</target>
        </trans-unit>
        <trans-unit id="6c4dc04d73e3b62534455f3b1b128df4687ca99e" translate="yes" xml:space="preserve">
          <source>How To Download Canonical SQLite Source Code</source>
          <target state="translated">Как загрузить канонический исходный код SQLite</target>
        </trans-unit>
        <trans-unit id="023a32566bba30a34815129fd5e3cc90c1e899ca" translate="yes" xml:space="preserve">
          <source>How VACUUM works</source>
          <target state="translated">Как работает VACUUM</target>
        </trans-unit>
        <trans-unit id="996ef93cbabdf3a445d79226e8fa6d9c24a881f0" translate="yes" xml:space="preserve">
          <source>How are the syntax diagrams (a.k.a. &quot;railroad&quot; diagrams) for SQLite generated?</source>
          <target state="translated">Как генерируются диаграммы синтаксиса (так же известные как диаграммы &quot;железной дороги&quot;)для SQLite?</target>
        </trans-unit>
        <trans-unit id="fc0899650d804dfcac8dc2104606bf9268efcf1e" translate="yes" xml:space="preserve">
          <source>How collation is determined</source>
          <target state="translated">Как определяется сравнение</target>
        </trans-unit>
        <trans-unit id="9a3218133ebd28240c94b4e7364a4f7e2e221ee5" translate="yes" xml:space="preserve">
          <source>How do I add or delete columns from an existing table in SQLite.</source>
          <target state="translated">Как добавить или удалить столбцы из существующей таблицы в SQLite.</target>
        </trans-unit>
        <trans-unit id="30aeec19cd6396142e3416e018900e8041d11cdb" translate="yes" xml:space="preserve">
          <source>How do I create an AUTOINCREMENT field?</source>
          <target state="translated">Как создать поле АВТОИНКРЕМЕНТА?</target>
        </trans-unit>
        <trans-unit id="a6cedc80b4e8057201d930bd24da72e7284f5f18" translate="yes" xml:space="preserve">
          <source>How do I list all tables/indices contained in an SQLite database</source>
          <target state="translated">Как перечислить все таблицы/индексы,содержащиеся в базе данных SQLite?</target>
        </trans-unit>
        <trans-unit id="94a002c7d3ab3f319a7a958c2ffad735eae889c1" translate="yes" xml:space="preserve">
          <source>How do I use a string literal that contains an embedded single-quote (') character?</source>
          <target state="translated">Как использовать строковый литерал,содержащий встроенный символ одиночной кавычки (')?</target>
        </trans-unit>
        <trans-unit id="df2742c7cfd9e0aab79b47f5b91d0027a0daa0fc" translate="yes" xml:space="preserve">
          <source>How many executable files are in the archive?</source>
          <target state="translated">Сколько исполняемых файлов в архиве?</target>
        </trans-unit>
        <trans-unit id="463cdf2e00bc03ffb0a58ce75a36b28173bad1d1" translate="yes" xml:space="preserve">
          <source>How vacuum works</source>
          <target state="translated">Как работает вакуум</target>
        </trans-unit>
        <trans-unit id="c2ebee163b547a5e69c6b8f18b3ce7ade428f296" translate="yes" xml:space="preserve">
          <source>However, client/server database engines (such as PostgreSQL, MySQL, or Oracle) usually support a higher level of concurrency and allow multiple processes to be writing to the same database at the same time. This is possible in a client/server database because there is always a single well-controlled server process available to coordinate access. If your application has a need for a lot of concurrency, then you should consider using a client/server database. But experience suggests that most applications need much less concurrency than their designers imagine.</source>
          <target state="translated">Однако движки клиентских/серверных баз данных (такие как PostgreSQL,MySQL или Oracle)обычно поддерживают более высокий уровень параллельности и позволяют записывать несколько процессов в одну и ту же базу данных одновременно.Это возможно в базе данных клиент/сервер,потому что всегда есть один хорошо управляемый серверный процесс,доступный для координации доступа.Если ваше приложение нуждается в большом количестве параллелизма,то вам следует подумать об использовании базы данных клиент/сервер.Но опыт подсказывает,что большинство приложений нуждаются в гораздо меньшем количестве параллелизма,чем это представляют себе их разработчики.</target>
        </trans-unit>
        <trans-unit id="a6ddbe53650906819e58dd27910958633c3e2cfa" translate="yes" xml:space="preserve">
          <source>However, for a &quot;contained-within&quot; style query, rounding the bounding boxes outward might cause some entries to be excluded from the result set if the edge of the entry bounding box corresponds to the edge of the query bounding box. To guard against this, applications should expand their contained-within query boxes slightly (by 0.000012%) by rounding down the lower coordinates and rounding up the top coordinates, in each dimension.</source>
          <target state="translated">Однако для запроса в стиле &quot;Содержимое-внутри&quot; округление ограничивающих полей наружу может привести к исключению некоторых записей из набора результатов,если край ограничивающего полей соответствует краю ограничивающего полей запроса.Чтобы защититься от этого,приложения должны немного (на 0.000012%)округлять нижние координаты и верхние-в каждом измерении.</target>
        </trans-unit>
        <trans-unit id="036059da8b4b48b5c802bde550324a35ba2a35da" translate="yes" xml:space="preserve">
          <source>However, highly tuned and specialized applications may want or need to replace some of SQLite's built-in system interfaces with alternative implementations more suitable for the needs of the application. SQLite is designed to be easily reconfigured at compile-time to meet the specific needs of individual projects. Among the compile-time configuration options for SQLite are these:</source>
          <target state="translated">Однако высоконастроенные и специализированные приложения могут захотеть или потребовать замены некоторых встроенных системных интерфейсов SQLite альтернативными реализациями,более подходящими для нужд приложения.SQLite разработан таким образом,что его можно легко перенастроить во время компиляции для удовлетворения специфических потребностей отдельных проектов.Среди опций конфигурации во время компиляции для SQLite можно выделить следующие:</target>
        </trans-unit>
        <trans-unit id="9070a26476fc8018912ec09ceeee6b8f4a55c4f3" translate="yes" xml:space="preserve">
          <source>However, if a</source>
          <target state="translated">Однако,если</target>
        </trans-unit>
        <trans-unit id="96aad563dbeff373bd60c0d93a4ac2c049bba808" translate="yes" xml:space="preserve">
          <source>However, if a &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; implementation creates real tables (sometimes referred to as &quot;shadow&quot; tables) within the database to store its data in, then sqldiff.exe does calculate the difference between these. This can have surprising effects if the resulting SQL script is then run on a database that is not</source>
          <target state="translated">Однако, если реализация &lt;a href=&quot;vtab&quot;&gt;виртуальной таблицы&lt;/a&gt; создает в базе данных реальные таблицы (иногда называемые &amp;laquo;теневыми&amp;raquo;) для хранения данных, то sqldiff.exe вычисляет разницу между ними. Это может иметь неожиданные последствия, если полученный сценарий SQL затем запускается в базе данных, которая не</target>
        </trans-unit>
        <trans-unit id="90ac212208b638040cc57dde761531e1857cf547" translate="yes" xml:space="preserve">
          <source>However, if a database has many concurrent overlapping readers and there is always at least one active reader, then no checkpoints will be able to complete and hence the WAL file will grow without bound.</source>
          <target state="translated">Однако,если в базе данных есть много одновременных перекрывающихся считывателей и всегда есть хотя бы один активный считыватель,то ни одна контрольная точка не сможет завершить работу и,следовательно,файл WAL будет расти без привязки.</target>
        </trans-unit>
        <trans-unit id="908b33a654e5b5eaa50e924611f16debc0d52007" translate="yes" xml:space="preserve">
          <source>However, if in-memory database pInMemory has just been opened (and is therefore completely empty) before being passed to function loadOrSaveDb(), then it is still possible to change its page size using an SQLite &quot;PRAGMA page_size&quot; command. Function loadOrSaveDb() could detect this case, and attempt to set the page-size of the in-memory database to the page-size of database zFilename before invoking the online backup API functions.</source>
          <target state="translated">Однако,если перед передачей в функцию loadOrSaveDb()pInMemory только что была открыта (а значит,полностью пуста)база данных in-memory,то размер ее страницы все равно можно изменить с помощью команды SQLite &quot;PRAGMA page_size&quot;.Функция loadOrSaveDb()могла обнаружить этот случай и попытаться установить размер страницы БД в памяти на размер страницы БД zFilename перед вызовом функций online backup API.</target>
        </trans-unit>
        <trans-unit id="9282d84ef089a46651581dc23d9984a0b853a197" translate="yes" xml:space="preserve">
          <source>However, the application must guarantee that the destination &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; is not passed to any other API (by any thread) after sqlite3_backup_init() is called and before the corresponding call to sqlite3_backup_finish(). SQLite does not currently check to see if the application incorrectly accesses the destination &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; and so no error code is reported, but the operations may malfunction nevertheless. Use of the destination database connection while a backup is in progress might also also cause a mutex deadlock.</source>
          <target state="translated">Однако приложение должно гарантировать, что соединение с целевой &lt;a href=&quot;#sqlite3&quot;&gt;базой данных&lt;/a&gt; не передается ни в какой другой API (каким-либо потоком) после вызова sqlite3_backup_init () и до соответствующего вызова sqlite3_backup_finish (). SQLite в настоящее время не проверяет, неправильно ли приложение обращается к &lt;a href=&quot;#sqlite3&quot;&gt;соединению&lt;/a&gt; с целевой базой данных, поэтому код ошибки не отображается, но, тем не менее, операции могут работать некорректно . Использование соединения с целевой базой данных во время резервного копирования также может вызвать взаимоблокировку мьютекса.</target>
        </trans-unit>
        <trans-unit id="6bd67d83c5ac9c5a6146085621d60822aa5f256c" translate="yes" xml:space="preserve">
          <source>However, the application must guarantee that the destination &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; is not passed to any other API (by any thread) after sqlite3_backup_init() is called and before the corresponding call to sqlite3_backup_finish(). SQLite does not currently check to see if the application incorrectly accesses the destination &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; and so no error code is reported, but the operations may malfunction nevertheless. Use of the destination database connection while a backup is in progress might also also cause a mutex deadlock.</source>
          <target state="translated">Однако приложение должно гарантировать, что соединение с целевой &lt;a href=&quot;sqlite3&quot;&gt;базой данных&lt;/a&gt; не передается ни в какой другой API (каким-либо потоком) после вызова sqlite3_backup_init () и до соответствующего вызова sqlite3_backup_finish (). SQLite в настоящее время не проверяет, неправильно ли приложение обращается к &lt;a href=&quot;sqlite3&quot;&gt;соединению&lt;/a&gt; с целевой базой данных, поэтому код ошибки не отображается, но, тем не менее, операции могут работать некорректно . Использование соединения с целевой базой данных во время резервного копирования также может вызвать взаимоблокировку мьютекса.</target>
        </trans-unit>
        <trans-unit id="2051ec90af96c4dbbb12c8a2bb3921b04fb0a7f2" translate="yes" xml:space="preserve">
          <source>However, the b-tree for a &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; table is in the same format as an index b-tree. Thus, an index b-tree can be accessed as if it were a WITHOUT ROWID table.</source>
          <target state="translated">Однако b-дерево для таблицы &lt;a href=&quot;withoutrowid&quot;&gt;БЕЗ ROWID&lt;/a&gt; имеет тот же формат, что и b-дерево индекса. Таким образом, к индексному b-дереву можно получить доступ, как если бы это была таблица БЕЗ ROWID.</target>
        </trans-unit>
        <trans-unit id="bdab598cbadf7cd7b2bb8bc0bda2ecbe3c4ceb3a" translate="yes" xml:space="preserve">
          <source>Hundreds of virtual tables that publish various aspects of the host computer, such as the process table, user lists, active network connections, and so forth. OsQuery is a separate project, started by Facebook, hosted on &lt;a href=&quot;https://github.com/facebook/osquery&quot;&gt;GitHub&lt;/a&gt;, and intended for security analysis and intrusion detection OsQuery is not a part of the SQLite project, but is included in this list because it demonstrates how the SQL language and the SQLite virtual table mechanism can be leveraged to provide elegant solutions to important real-world problems.</source>
          <target state="translated">Сотни виртуальных таблиц, которые публикуют различные аспекты главного компьютера, такие как таблица процессов, списки пользователей, активные сетевые соединения и т. Д. OsQuery - это отдельный проект, запущенный Facebook, размещенный на &lt;a href=&quot;https://github.com/facebook/osquery&quot;&gt;GitHub&lt;/a&gt; и предназначенный для анализа безопасности и обнаружения вторжений. OsQuery не является частью проекта SQLite, но включен в этот список, поскольку демонстрирует, как язык SQL и виртуальная таблица SQLite Механизм может быть использован для элегантного решения важных реальных проблем.</target>
        </trans-unit>
        <trans-unit id="6d245e7140689124e74b20cb072465076d95b006" translate="yes" xml:space="preserve">
          <source>I accidentally deleted some important information from my SQLite database. How can I recover it?</source>
          <target state="translated">Я случайно удалил важную информацию из базы данных SQLite.Как я могу ее восстановить?</target>
        </trans-unit>
        <trans-unit id="dc9c3207dff5659b4c310cd90f15260ed36f68c7" translate="yes" xml:space="preserve">
          <source>I am told that Git users commonly install third-party graphical viewers for Git, many of which do a better job of showing recent activity on the project. That is great, but these are still more third-party applications that must be installed and managed separately. Many are platform-specific. (One of the better ones, &lt;a href=&quot;https://gitup.co/&quot;&gt;GitUp&lt;/a&gt;, only works on Mac, for example.) All require that you first sync your local repository then bring up their graphical interface on your desktop. And even with all that, I still cannot see what I typically want to see without multiple clicks. Checking on project status from a phone while away from the office is not an option.</source>
          <target state="translated">Мне сказали, что пользователи Git обычно устанавливают сторонние графические программы просмотра для Git, многие из которых лучше отображают недавнюю активность в проекте. Это здорово, но это все же сторонние приложения, которые нужно устанавливать и управлять ими отдельно. Многие из них зависят от платформы. (Один из лучших, &lt;a href=&quot;https://gitup.co/&quot;&gt;GitUp&lt;/a&gt; , работает, например, только на Mac.) Все требуют, чтобы вы сначала синхронизировали локальный репозиторий, а затем вывели его графический интерфейс на рабочий стол. И даже несмотря на это, я все еще не могу видеть то, что обычно хочу видеть, без нескольких щелчков мышью. Проверить статус проекта по телефону, находясь вне офиса, нельзя.</target>
        </trans-unit>
        <trans-unit id="a5d8bfaba744d8865014e1b5776daef69b8ba64a" translate="yes" xml:space="preserve">
          <source>I am told that the default PostgreSQL configuration in RedHat 7.3 is unnecessarily conservative (it is designed to work on a machine with 8MB of RAM) and that PostgreSQL could be made to run a lot faster with some knowledgeable configuration tuning. Matt Sergeant reports that he has tuned his PostgreSQL installation and rerun the tests shown below. His results show that PostgreSQL and MySQL run at about the same speed. For Matt's results, visit</source>
          <target state="translated">Мне сказали,что стандартная конфигурация PostgreSQL в RedHat 7.3 неоправданно консервативна (она предназначена для работы на машине с 8 МБ оперативной памяти),и что PostgreSQL можно было бы заставить работать намного быстрее при грамотной настройке конфигурации.Мэтт Сержант сообщает,что он настроил свою установку PostgreSQL и повторно запустил тесты,показанные ниже.Его результаты показывают,что PostgreSQL и MySQL работают примерно с одинаковой скоростью.Для ознакомления с результатами Мэтта посетите</target>
        </trans-unit>
        <trans-unit id="c4b4aed72c495e6b69cc90a12c1002093ba09a73" translate="yes" xml:space="preserve">
          <source>I deleted a lot of data but the database file did not get any smaller. Is this a bug?</source>
          <target state="translated">Я удалил много данных,но файл базы данных не стал меньше.Это ошибка?</target>
        </trans-unit>
        <trans-unit id="30c131b4d60b85b44b7c7e76894246c9eeed47f8" translate="yes" xml:space="preserve">
          <source>I get a compiler error if I use the SQLITE_OMIT_... compile-time options when building SQLite.</source>
          <target state="translated">Я получаю ошибку компилятора,если использую опции SQLITE_OMIT_...при сборке SQLite.</target>
        </trans-unit>
        <trans-unit id="96380689d1c266e443557fac220e162eb248fe7f" translate="yes" xml:space="preserve">
          <source>I get some compiler warnings when I compile SQLite. Isn't this a problem? Doesn't it indicate poor code quality?</source>
          <target state="translated">При компиляции SQLite я получаю предупреждения компилятора.Разве это не проблема? Разве это не говорит о низком качестве кода?</target>
        </trans-unit>
        <trans-unit id="b0631d514fcfd330a2105540a0b813b7c7b65c3f" translate="yes" xml:space="preserve">
          <source>I/O error testing is similar in concept to OOM testing; I/O errors are simulated and checks are made to verify that SQLite responds correctly to the simulated errors. I/O errors are simulated in both the TCL and TH3 test harnesses by inserting a new &lt;a href=&quot;c3ref/vfs&quot;&gt;Virtual File System object&lt;/a&gt; that is specially rigged to simulate an I/O error after a set number of I/O operations. As with OOM error testing, the I/O error simulators can be set to fail just once, or to fail continuously after the first failure. Tests are run in a loop, slowly increasing the point of failure until the test case runs to completion without error. The loop is run twice, once with the I/O error simulator set to simulate only a single failure and a second time with it set to fail all I/O operations after the first failure.</source>
          <target state="translated">Тестирование ошибок ввода-вывода аналогично тестированию OOM; Моделируются ошибки ввода-вывода и выполняются проверки, чтобы убедиться, что SQLite правильно реагирует на смоделированные ошибки. Ошибки ввода-вывода моделируются как в тестовых жгутах TCL, так и в TH3 путем вставки нового &lt;a href=&quot;c3ref/vfs&quot;&gt;объекта виртуальной файловой системы,&lt;/a&gt; который специально настроен для имитации ошибки ввода-вывода после заданного количества операций ввода-вывода. Как и при тестировании ошибок OOM, имитаторы ошибок ввода-вывода могут быть настроены на сбой только один раз или на постоянный сбой после первого сбоя. Тесты выполняются в цикле, постепенно увеличивая точку отказа, пока тестовый пример не завершится без ошибок. Цикл запускается дважды: один раз с имитатором ошибок ввода-вывода, настроенным на имитацию только одного отказа, и второй раз, когда он настроен на сбой всех операций ввода-вывода после первого сбоя.</target>
        </trans-unit>
        <trans-unit id="7e39c1a666c2fd143f11a87457de9e9888317484" translate="yes" xml:space="preserve">
          <source>I/O error testing seeks to verify that SQLite responds sanely to failed I/O operations. I/O errors might result from a full disk drive, malfunctioning disk hardware, network outages when using a network file system, system configuration or permission changes that occur in the middle of an SQL operation, or other hardware or operating system malfunctions. Whatever the cause, it is important that SQLite be able to respond correctly to these errors and I/O error testing seeks to verify that it does.</source>
          <target state="translated">Тестирование ошибок ввода/вывода направлено на проверку того,что SQLite адекватно реагирует на неудачные операции ввода/вывода.Ошибки ввода/вывода могут быть вызваны полным дисковым накопителем,неисправностью дискового оборудования,перебоями в работе сети при использовании сетевой файловой системы,изменениями в конфигурации системы или разрешениях,которые происходят в середине операции SQL,или другими сбоями в работе оборудования или операционной системы.Какой бы ни была причина,важно,чтобы SQLite смог правильно отреагировать на эти ошибки,и тестирование ошибок ввода/вывода стремится проверить,что это так.</target>
        </trans-unit>
        <trans-unit id="8d8651647c9490ad914b1a9a6e6d44929ce46c04" translate="yes" xml:space="preserve">
          <source>I/O error tests</source>
          <target state="translated">тесты ошибок ввода/вывода</target>
        </trans-unit>
        <trans-unit id="35d92e9f60aece05bafa666d5e6093c27b070d38" translate="yes" xml:space="preserve">
          <source>I/O errors in the OS-interface generate error logging events. The message to these events gives the line number in the source code where the error originated and the filename associated with the event when there is a corresponding file.</source>
          <target state="translated">Ошибки ввода/вывода в интерфейсе операционной системы генерируют события регистрации ошибок.В сообщении к этим событиям указывается номер строки в исходном коде,где возникла ошибка,и имя файла,связанного с событием при наличии соответствующего файла.</target>
        </trans-unit>
        <trans-unit id="d998ed8c49ae368254ded62fce1c76a6c0d44f30" translate="yes" xml:space="preserve">
          <source>I/O performance is measured using the &lt;a href=&quot;https://www.sqlite.org/src/file/test/kvtest.c&quot;&gt;kvtest.c&lt;/a&gt; program from the SQLite source tree. To compile this test program, first gather the kvtest.c source file into a directory with the &lt;a href=&quot;amalgamation&quot;&gt;SQLite amalgamation&lt;/a&gt; source files &quot;sqlite3.c&quot; and &quot;sqlite3.h&quot;. Then on unix, run a command like the following:</source>
          <target state="translated">Производительность ввода-вывода измеряется с помощью программы &lt;a href=&quot;https://www.sqlite.org/src/file/test/kvtest.c&quot;&gt;kvtest.c&lt;/a&gt; из дерева исходных текстов SQLite. Чтобы скомпилировать эту тестовую программу, сначала соберите исходный файл kvtest.c в каталог с исходными файлами &lt;a href=&quot;amalgamation&quot;&gt;объединения SQLite&lt;/a&gt; &amp;laquo;sqlite3.c&amp;raquo; и &amp;laquo;sqlite3.h&amp;raquo;. Затем в unix выполните следующую команду:</target>
        </trans-unit>
        <trans-unit id="e779dca751c9ced361a0eadbe7916be59d02dc09" translate="yes" xml:space="preserve">
          <source>I/O performance varies widely depending on operating system and hardware. Make your own measurements before drawing conclusions.</source>
          <target state="translated">Производительность входов/выходов варьируется в широких пределах в зависимости от операционной системы и аппаратного обеспечения.Сделайте свои собственные измерения,прежде чем делать выводы.</target>
        </trans-unit>
        <trans-unit id="267e452e4d048aacef682e30a9d368c22e7501e4" translate="yes" xml:space="preserve">
          <source>IDF(q&lt;sub&gt;i&lt;/sub&gt;)</source>
          <target state="translated">IDF(q&lt;sub&gt;i&lt;/sub&gt;)</target>
        </trans-unit>
        <trans-unit id="7be63e2881f7da8faa393bfe0ce4667f10916b66" translate="yes" xml:space="preserve">
          <source>IF</source>
          <target state="translated">IF</target>
        </trans-unit>
        <trans-unit id="235cae5b9c97fbc3364fb92af44d64b71392dbb2" translate="yes" xml:space="preserve">
          <source>IF EXISTS and IF NOT EXISTS clauses on CREATE/DROP TABLE/INDEX.</source>
          <target state="translated">ЕСЛИ ВЫХОДЫ и ЕСЛИ НЕ ВЫХОДЫ положения о таблице/индексе CREATE/DROP.</target>
        </trans-unit>
        <trans-unit id="c9226f99dd645a71848cf0585c15059d7de868f4" translate="yes" xml:space="preserve">
          <source>IGNORE</source>
          <target state="translated">IGNORE</target>
        </trans-unit>
        <trans-unit id="8ae3e8381a64e36db57a5344790db89d7de90954" translate="yes" xml:space="preserve">
          <source>IMMEDIATE</source>
          <target state="translated">IMMEDIATE</target>
        </trans-unit>
        <trans-unit id="3b63a4da1415c242da17f132d0e00d086153fa66" translate="yes" xml:space="preserve">
          <source>IMMEDIATE cause the database connection to start a new write immediately, without waiting for a write statement. The BEGIN IMMEDIATE might fail with &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; if another write transaction is already active on another database connection.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f94ea3de1605903ae5123660f5457eb8bd32e9f" translate="yes" xml:space="preserve">
          <source>IMMEDIATE cause the database connection to start a new write immediately, without waiting for a writes statement. The BEGIN IMMEDIATE might fail with &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; if another write transaction is already active on another database connection.</source>
          <target state="translated">IMMEDIATE заставляет соединение с базой данных немедленно начать новую запись, не дожидаясь оператора записи. BEGIN IMMEDIATE может завершиться ошибкой с &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY,&lt;/a&gt; если другая транзакция записи уже активна в другом соединении с базой данных.</target>
        </trans-unit>
        <trans-unit id="a4db76ad8831e1ebbbc52031b1ae484c99975878" translate="yes" xml:space="preserve">
          <source>IMPORTANT: The estimatedRows field was added to the sqlite3_index_info structure for SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_2.html&quot;&gt;version 3.8.2&lt;/a&gt; (2013-12-06). If a virtual table extension is used with an SQLite version earlier than 3.8.2, the results of attempting to read or write the estimatedRows field are undefined (but are likely to include crashing the application). The estimatedRows field should therefore only be used if &lt;a href=&quot;#sqlite3_libversion&quot;&gt;sqlite3_libversion_number()&lt;/a&gt; returns a value greater than or equal to 3008002. Similarly, the idxFlags field was added for &lt;a href=&quot;https://sqlite.org/releaselog/3_9_0.html&quot;&gt;version 3.9.0&lt;/a&gt; (2015-10-14). It may therefore only be used if sqlite3_libversion_number() returns a value greater than or equal to 3009000.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f10a7701656ba82f20f9690db33f263b9944c35" translate="yes" xml:space="preserve">
          <source>IMPORTANT: The estimatedRows field was added to the sqlite3_index_info structure for SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_2.html&quot;&gt;version 3.8.2&lt;/a&gt; (2013-12-06). If a virtual table extension is used with an SQLite version earlier than 3.8.2, the results of attempting to read or write the estimatedRows field are undefined (but are likely to include crashing the application). The estimatedRows field should therefore only be used if &lt;a href=&quot;libversion&quot;&gt;sqlite3_libversion_number()&lt;/a&gt; returns a value greater than or equal to 3008002. Similarly, the idxFlags field was added for &lt;a href=&quot;https://sqlite.org/releaselog/3_9_0.html&quot;&gt;version 3.9.0&lt;/a&gt; (2015-10-14). It may therefore only be used if sqlite3_libversion_number() returns a value greater than or equal to 3009000.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac8fb933cd53d38ff3f25855409c3725df641570" translate="yes" xml:space="preserve">
          <source>IMPORTANT: The estimatedRows field was added to the sqlite3_index_info structure for SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_2.html&quot;&gt;version 3.8.2&lt;/a&gt; (2013-12-06). If a virtual table extension is used with an SQLite version earlier than 3.8.2, the results of attempting to read or write the estimatedRows field are undefined (but are likely to included crashing the application). The estimatedRows field should therefore only be used if &lt;a href=&quot;#sqlite3_libversion&quot;&gt;sqlite3_libversion_number()&lt;/a&gt; returns a value greater than or equal to 3008002. Similarly, the idxFlags field was added for &lt;a href=&quot;https://sqlite.org/releaselog/3_9_0.html&quot;&gt;version 3.9.0&lt;/a&gt; (2015-10-14). It may therefore only be used if sqlite3_libversion_number() returns a value greater than or equal to 3009000.</source>
          <target state="translated">ВАЖНО: поле EstimatedRows было добавлено в структуру sqlite3_index_info для SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_2.html&quot;&gt;версии 3.8.2&lt;/a&gt; (2013-12-06). Если расширение виртуальной таблицы используется с версией SQLite более ранней, чем 3.8.2, результаты попытки чтения или записи поля оцениваемых строк не определены (но, скорее всего, это приведет к сбою приложения). Поэтому поле EstimatedRows следует использовать только в том случае, если &lt;a href=&quot;#sqlite3_libversion&quot;&gt;sqlite3_libversion_number ()&lt;/a&gt; возвращает значение, большее или равное 3008002. Аналогичным образом поле idxFlags было добавлено для &lt;a href=&quot;https://sqlite.org/releaselog/3_9_0.html&quot;&gt;версии 3.9.0&lt;/a&gt; (2015-10-14). Поэтому его можно использовать, только если sqlite3_libversion_number () возвращает значение, большее или равное 3009000.</target>
        </trans-unit>
        <trans-unit id="f7788b148a07ca2844906ea43293afae622f959f" translate="yes" xml:space="preserve">
          <source>IMPORTANT: The estimatedRows field was added to the sqlite3_index_info structure for SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_2.html&quot;&gt;version 3.8.2&lt;/a&gt; (2013-12-06). If a virtual table extension is used with an SQLite version earlier than 3.8.2, the results of attempting to read or write the estimatedRows field are undefined (but are likely to included crashing the application). The estimatedRows field should therefore only be used if &lt;a href=&quot;libversion&quot;&gt;sqlite3_libversion_number()&lt;/a&gt; returns a value greater than or equal to 3008002. Similarly, the idxFlags field was added for &lt;a href=&quot;https://sqlite.org/releaselog/3_9_0.html&quot;&gt;version 3.9.0&lt;/a&gt; (2015-10-14). It may therefore only be used if sqlite3_libversion_number() returns a value greater than or equal to 3009000.</source>
          <target state="translated">ВАЖНО: поле EstimatedRows было добавлено в структуру sqlite3_index_info для SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_2.html&quot;&gt;версии 3.8.2&lt;/a&gt; (2013-12-06). Если расширение виртуальной таблицы используется с версией SQLite более ранней, чем 3.8.2, результаты попытки чтения или записи поля оцениваемых строк не определены (но, скорее всего, это приведет к сбою приложения). Поэтому поле EstimatedRows следует использовать только в том случае, если &lt;a href=&quot;libversion&quot;&gt;sqlite3_libversion_number ()&lt;/a&gt; возвращает значение, большее или равное 3008002. Аналогичным образом поле idxFlags было добавлено для &lt;a href=&quot;https://sqlite.org/releaselog/3_9_0.html&quot;&gt;версии 3.9.0&lt;/a&gt; (2015-10-14). Поэтому его можно использовать, только если sqlite3_libversion_number () возвращает значение, большее или равное 3009000.</target>
        </trans-unit>
        <trans-unit id="6fca55ca3c828a46bfe96a10e69f572b61ce540c" translate="yes" xml:space="preserve">
          <source>IN</source>
          <target state="translated">IN</target>
        </trans-unit>
        <trans-unit id="9e93d8e547641024337c9f88c37aeeb56b09cfd4" translate="yes" xml:space="preserve">
          <source>IN operator</source>
          <target state="translated">оператор ввода</target>
        </trans-unit>
        <trans-unit id="2704c1d8c3fc215c38ee176f6cc30e434a22b7d7" translate="yes" xml:space="preserve">
          <source>INDEX</source>
          <target state="translated">INDEX</target>
        </trans-unit>
        <trans-unit id="d34941b7cef935d2b4b0705a24e87fad9ef16cef" translate="yes" xml:space="preserve">
          <source>INDEXED</source>
          <target state="translated">INDEXED</target>
        </trans-unit>
        <trans-unit id="0a477a77f065212096e980b210eda0227cabf37c" translate="yes" xml:space="preserve">
          <source>INDEXED BY</source>
          <target state="translated">ЗАКРЫТО</target>
        </trans-unit>
        <trans-unit id="fd4d2f0d5aa850e30c0830c19e27d0fa4c65c7a7" translate="yes" xml:space="preserve">
          <source>INITIALLY</source>
          <target state="translated">INITIALLY</target>
        </trans-unit>
        <trans-unit id="88d86d54436967d4b4599d22d53c2a3db38390e6" translate="yes" xml:space="preserve">
          <source>INNER</source>
          <target state="translated">INNER</target>
        </trans-unit>
        <trans-unit id="c20ea07e32d25c072a65368c234d6f5a88f4521a" translate="yes" xml:space="preserve">
          <source>INSERT</source>
          <target state="translated">INSERT</target>
        </trans-unit>
        <trans-unit id="06c4e866c3ade62ba74b04b1ef54dce90603c067" translate="yes" xml:space="preserve">
          <source>INSERT Changes</source>
          <target state="translated">Изменения</target>
        </trans-unit>
        <trans-unit id="4e7c6a59e9c103dd735d95fe84726b20fe104acf" translate="yes" xml:space="preserve">
          <source>INSERT INTO demo2(command) VALUES(&quot;reset&quot;);</source>
          <target state="translated">INSERT INTO demo2(команда)VALUES(&quot;сброс&quot;);</target>
        </trans-unit>
        <trans-unit id="ed9844477a7bb01e976b863376804eb769331989" translate="yes" xml:space="preserve">
          <source>INSERT INTO t1 SELECT b,a,c FROM t2;</source>
          <target state="translated">ИНСЕРТ В Т1 ВЫБЕРИТЕ b,a,c ОТ Т2;</target>
        </trans-unit>
        <trans-unit id="767dcfed1e7a66d267a3220fbe439232373351ee" translate="yes" xml:space="preserve">
          <source>INSERT INTO t1 VALUES(1,10719,'ten thousand seven hundred nineteen');</source>
          <target state="translated">ИНСЕРТ ИНФОРМАЦИОННАЯ ЦЕННОСТЬ (10719,десять тысяч семьсот девятнадцать);</target>
        </trans-unit>
        <trans-unit id="a30ee5b0b970fc276bf5d3453cfa994508fd0177" translate="yes" xml:space="preserve">
          <source>INSERT INTO t1 VALUES(1,13153,'thirteen thousand one hundred fifty three');</source>
          <target state="translated">ИНСЕРТ ИНФОРМАЦИОННАЯ ЦЕНА (1 13153,'тринадцать тысяч сто пятьдесят три');</target>
        </trans-unit>
        <trans-unit id="4bc6de27aceadc240c8dd43059a82f9a9561379b" translate="yes" xml:space="preserve">
          <source>INSERT INTO t1 VALUES(1000,94142,'ninety four thousand one hundred forty two');</source>
          <target state="translated">INSERT INTO t1 VALUES(1000 94142,'девяносто четыре тысячи сто сорок два');</target>
        </trans-unit>
        <trans-unit id="62d9636f68aa675dabacb22b938d9f2be06b55e0" translate="yes" xml:space="preserve">
          <source>INSERT INTO t1 VALUES(11999,72836,'seventy two thousand eight hundred thirty six');</source>
          <target state="translated">ИНСЕРТ ИНФОРМАЦИОННАЯ ЦЕННОСТЬ(11999 72836,'семьдесят две тысячи восемьсот тридцать шесть');</target>
        </trans-unit>
        <trans-unit id="f0fbe2df8c33450eafb90fd96d71291641e02aa4" translate="yes" xml:space="preserve">
          <source>INSERT INTO t1 VALUES(12000,64231,'sixty four thousand two hundred thirty one');</source>
          <target state="translated">ИНСЕРТ ИНФОРМАЦИОННЫХ ЦЕННОСТЕЙ (12000 64231,шестьдесят четыре тысячи двести тридцать один);</target>
        </trans-unit>
        <trans-unit id="31a76630ad88d2e05dde2c415d8576db8ec6caf9" translate="yes" xml:space="preserve">
          <source>INSERT INTO t1 VALUES(2,75560,'seventy five thousand five hundred sixty');</source>
          <target state="translated">ИНСЕРТ ИНФОРМАЦИОННАЯ ЦЕННОСТЬ(2 75560,'семьдесят пять тысяч пятьсот шестьдесят');</target>
        </trans-unit>
        <trans-unit id="215d5732ce27fd223582c712aaa4660a83a173d4" translate="yes" xml:space="preserve">
          <source>INSERT INTO t1 VALUES(998,66289,'sixty six thousand two hundred eighty nine');</source>
          <target state="translated">ИНСЕРТ ИНФОРМАЦИОННАЯ ЦЕНА (998 66289,шестьдесят шесть тысяч двести восемьдесят девять);</target>
        </trans-unit>
        <trans-unit id="4b533e1d2a14d2013c249801c64abee1873ad0e7" translate="yes" xml:space="preserve">
          <source>INSERT INTO t1 VALUES(999,24322,'twenty four thousand three hundred twenty two');</source>
          <target state="translated">ИНСЕРТ ИНФОРМАЦИОННАЯ ЦЕННОСТЬ(999 24322,'двадцать четыре тысячи триста двадцать два');</target>
        </trans-unit>
        <trans-unit id="c97d31d96ba9608129ccb018853e9ea9cb6076d1" translate="yes" xml:space="preserve">
          <source>INSERT INTO t2 SELECT * FROM t1;</source>
          <target state="translated">ИНСЕРТ ИНФОРМАЦИОННАЯ ИНФОРМАЦИОННАЯ ИНФОРМАЦИЯ*ОТ Т1;</target>
        </trans-unit>
        <trans-unit id="18573be7d634b7266c9f3fabe6799c0e9de399b2" translate="yes" xml:space="preserve">
          <source>INSERT INTO t2 SELECT b,a,c FROM t1;</source>
          <target state="translated">ИНСЕРТ В Т2 ВЫБЕРИТЕ b,a,c ОТ Т1;</target>
        </trans-unit>
        <trans-unit id="6654bc4310d1eef443b5f0f2c1641262634e1e66" translate="yes" xml:space="preserve">
          <source>INSERT INTO t2 VALUES(1,59672,'fifty nine thousand six hundred seventy two');</source>
          <target state="translated">INSERT INTO t2 VALUES(1 59672,'пятьдесят девять тысяч шестьсот семьдесят два');</target>
        </trans-unit>
        <trans-unit id="94d1d27ed943c864c7cfd96715bf162e7beab100" translate="yes" xml:space="preserve">
          <source>INSERT INTO t2 VALUES(24999,89569,'eighty nine thousand five hundred sixty nine');</source>
          <target state="translated">ИНСЕРТ ИНТОНСТРУМЕНТАЦИИ 2 ЦЕННОСТИ(24999 89569,'восемьдесят девять тысяч пятьсот шестьдесят девять');</target>
        </trans-unit>
        <trans-unit id="253860cdd49bceb80fa941fa6a7a8aa222a2af3e" translate="yes" xml:space="preserve">
          <source>INSERT INTO t2 VALUES(25000,94666,'ninety four thousand six hundred sixty six');</source>
          <target state="translated">INSERT INTO t2 VALUES(25000 94666,'девяносто четыре тысячи шестьсот шестьдесят шесть');</target>
        </trans-unit>
        <trans-unit id="0e8f253b1b555988f2df4dcb60865d19307f1b0c" translate="yes" xml:space="preserve">
          <source>INSERT INTO t3 VALUES(24999,88509,'eighty eight thousand five hundred nine');</source>
          <target state="translated">ИНСЕРТ ИНТОНСТРУМЕНТАЦИИ 3 ЦЕННОСТИ(24999 88509,'восемьдесят восемь тысяч пятьсот девять');</target>
        </trans-unit>
        <trans-unit id="00be643bf7f738dedf700c9b2a35f10694c7941a" translate="yes" xml:space="preserve">
          <source>INSERT INTO t3 VALUES(25000,84791,'eighty four thousand seven hundred ninety one');</source>
          <target state="translated">ИНСЕРТ В 3 ЦЕНЫ (25000 84791,&quot;восемьдесят четыре тысячи семьсот девяносто один&quot;);</target>
        </trans-unit>
        <trans-unit id="eb2365c71aa4f9cd4a1bfec486fd83fcbdda7977" translate="yes" xml:space="preserve">
          <source>INSERT INTO tab1 VALUES(?,?,?);</source>
          <target state="translated">INSERT INTO tab1 VALUES(?,?,?);</target>
        </trans-unit>
        <trans-unit id="0666a7f2affc6b3653a4c2bdf54c9b4bb98361ed" translate="yes" xml:space="preserve">
          <source>INSERT INTO xyz(xyz) VALUES('automerge=N');</source>
          <target state="translated">INSERT INTO xyz(xyz)VALUES('automerge=N');</target>
        </trans-unit>
        <trans-unit id="4e8b9a8e297bede64cc05b119a6cea847e694a59" translate="yes" xml:space="preserve">
          <source>INSERT INTO xyz(xyz) VALUES('integrity-check');</source>
          <target state="translated">INSERT INTO xyz(xyz)VALUES('integrity-check');</target>
        </trans-unit>
        <trans-unit id="f5e0d229ccc9b20df140de91fa55ac169f3840fe" translate="yes" xml:space="preserve">
          <source>INSERT INTO xyz(xyz) VALUES('merge=X,Y');</source>
          <target state="translated">INSERT INTO xyz(xyz)VALUES('merge=X,Y');</target>
        </trans-unit>
        <trans-unit id="5af88d4a59ba50ff893198ed67ae451d74a117e2" translate="yes" xml:space="preserve">
          <source>INSERT INTO xyz(xyz) VALUES('optimize');</source>
          <target state="translated">INSERT INTO xyz(xyz)VALUES('optim');</target>
        </trans-unit>
        <trans-unit id="13f47444da210de43c60aab402a316dfe2becb56" translate="yes" xml:space="preserve">
          <source>INSERT INTO xyz(xyz) VALUES('rebuild');</source>
          <target state="translated">INSERT INTO xyz(xyz)VALUES('rebuild');</target>
        </trans-unit>
        <trans-unit id="631e931c19e40aa3da1ce6f0902d43d9a508af25" translate="yes" xml:space="preserve">
          <source>INSERT and UPDATE statements now always apply &lt;a href=&quot;datatype3#affinity&quot;&gt;column affinity&lt;/a&gt; before computing &lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK constraints&lt;/a&gt;. This bug fix could, in theory, cause problems for legacy databases with unorthodox CHECK constraints the require the input type for an INSERT is different from the declared column type. See ticket &lt;a href=&quot;https://sqlite.org/src/info/86ba67afafded936&quot;&gt;86ba67afafded936&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f103f7920401a2a0647c3f2159a7c89eabff571" translate="yes" xml:space="preserve">
          <source>INSERT is really slow - I can only do few dozen INSERTs per second</source>
          <target state="translated">INSERT очень медленный-я могу делать только несколько десятков INSERT в секунду.</target>
        </trans-unit>
        <trans-unit id="62d1399645f66158b7511abeddf89f395dea5fde" translate="yes" xml:space="preserve">
          <source>INSERT runs a little faster when the source is a SELECT statement.</source>
          <target state="translated">INSERT работает немного быстрее,когда источником является утверждение SELECT.</target>
        </trans-unit>
        <trans-unit id="aeb597e62b4ad26deac5b62c60062c710ea90371" translate="yes" xml:space="preserve">
          <source>INSTEAD</source>
          <target state="translated">INSTEAD</target>
        </trans-unit>
        <trans-unit id="2300ac39d09a99728ae682403c03797ee8da658b" translate="yes" xml:space="preserve">
          <source>INSTEAD OF trigger</source>
          <target state="translated">спусковой крючок</target>
        </trans-unit>
        <trans-unit id="d8374d53c837e126cb6abc0132fba2a1f9a3a9c8" translate="yes" xml:space="preserve">
          <source>INSTEAD OF triggers</source>
          <target state="translated">ВНИМАНИЕ триггеров</target>
        </trans-unit>
        <trans-unit id="793985cddb68d46ef51b688aecf85864c9e06813" translate="yes" xml:space="preserve">
          <source>INT</source>
          <target state="translated">INT</target>
        </trans-unit>
        <trans-unit id="a3a0ec55e3e26ee54417c786dfad5d709ecb7c40" translate="yes" xml:space="preserve">
          <source>INT2</source>
          <target state="translated">INT2</target>
        </trans-unit>
        <trans-unit id="021a30ffe1ce8750cb57ce941d7fb3d04090b37c" translate="yes" xml:space="preserve">
          <source>INT8</source>
          <target state="translated">INT8</target>
        </trans-unit>
        <trans-unit id="0fe37e40e5dab3ac411c2ddca6d21991e811acfa" translate="yes" xml:space="preserve">
          <source>INTEGER</source>
          <target state="translated">INTEGER</target>
        </trans-unit>
        <trans-unit id="e3752510d6a9d0fb8f3974168ca6bea1a562a9ac" translate="yes" xml:space="preserve">
          <source>INTEGER PRIMARY KEY columns can be used to implement the equivalent of AUTOINCREMENT. If you try to insert a NULL into an INTEGER PRIMARY KEY column, the column will actually be filled with an integer that is one greater than the largest key already in the table. Or if the largest key is 2147483647, then the column will be filled with a random integer. Either way, the INTEGER PRIMARY KEY column will be assigned a unique integer. You can retrieve this integer using the &lt;b&gt;sqlite_last_insert_rowid()&lt;/b&gt; API function or using the &lt;b&gt;last_insert_rowid()&lt;/b&gt; SQL function in a subsequent SELECT statement.</source>
          <target state="translated">Столбцы INTEGER PRIMARY KEY могут использоваться для реализации эквивалента AUTOINCREMENT. Если вы попытаетесь вставить NULL в столбец INTEGER PRIMARY KEY, этот столбец будет фактически заполнен целым числом, которое на единицу больше, чем самый большой ключ в таблице. Или, если самый большой ключ - 2147483647, тогда столбец будет заполнен случайным целым числом. В любом случае столбцу INTEGER PRIMARY KEY будет присвоено уникальное целое число. Вы можете получить это целое число с помощью функции API &lt;b&gt;sqlite_last_insert_rowid ()&lt;/b&gt; или с помощью функции SQL &lt;b&gt;last_insert_rowid ()&lt;/b&gt; в последующем операторе SELECT.</target>
        </trans-unit>
        <trans-unit id="6f436e25f27f33e27c6053472309a17baa61d133" translate="yes" xml:space="preserve">
          <source>INTERFACE</source>
          <target state="translated">INTERFACE</target>
        </trans-unit>
        <trans-unit id="3230de938114213aa9c2d1e95f291cad51ede171" translate="yes" xml:space="preserve">
          <source>INTERSECT</source>
          <target state="translated">INTERSECT</target>
        </trans-unit>
        <trans-unit id="ce45b16212fe00c28d1a00de9cdfe954aa5bdc83" translate="yes" xml:space="preserve">
          <source>INTO</source>
          <target state="translated">INTO</target>
        </trans-unit>
        <trans-unit id="ec4a2a5056d72d8e03345caaebf4607d163e6dd7" translate="yes" xml:space="preserve">
          <source>IS</source>
          <target state="translated">IS</target>
        </trans-unit>
        <trans-unit id="819809f7649d3da66fd65a40dff83509ed2b98d0" translate="yes" xml:space="preserve">
          <source>IS NOT</source>
          <target state="translated">НЕ ЯВЛЯЕТСЯ</target>
        </trans-unit>
        <trans-unit id="437390c0773d23a0b0e272480ef7204b356f23ad" translate="yes" xml:space="preserve">
          <source>IS operator</source>
          <target state="translated">оператор операционной системы</target>
        </trans-unit>
        <trans-unit id="4e93120a53b25e7642cc15924ececcc7c79ac693" translate="yes" xml:space="preserve">
          <source>ISNULL</source>
          <target state="translated">ISNULL</target>
        </trans-unit>
        <trans-unit id="c8c6b6fe3176986c9e57f2648e139dfd273d0908" translate="yes" xml:space="preserve">
          <source>Ideally, all changes for an entire write transaction are buffered in the page cache until the end of the transaction. When the user commits the transaction, all changes are applied to the database file in the most efficient way possible, taking into account the assumptions enumerated in section</source>
          <target state="translated">В идеале,все изменения для всей транзакции записи буферизируются в кэше страниц до конца транзакции.Когда пользователь фиксирует транзакцию,все изменения применяются к файлу базы данных наиболее эффективным способом,с учетом предположений,перечисленных в разделе</target>
        </trans-unit>
        <trans-unit id="3aa28748de853653631eccc0d256aed420f0eed1" translate="yes" xml:space="preserve">
          <source>Ideally, applications should &lt;a href=&quot;#sqlite3_finalize&quot;&gt;finalize&lt;/a&gt; all &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statements&lt;/a&gt;, &lt;a href=&quot;#sqlite3_blob_close&quot;&gt;close&lt;/a&gt; all &lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB handles&lt;/a&gt;, and &lt;a href=&quot;#sqlite3backupfinish&quot;&gt;finish&lt;/a&gt; all &lt;a href=&quot;#sqlite3_backup&quot;&gt;sqlite3_backup&lt;/a&gt; objects associated with the &lt;a href=&quot;#sqlite3&quot;&gt;sqlite3&lt;/a&gt; object prior to attempting to close the object. If the database connection is associated with unfinalized prepared statements, BLOB handlers, and/or unfinished sqlite3_backup objects then sqlite3_close() will leave the database connection open and return &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY&lt;/a&gt;. If sqlite3_close_v2() is called with unfinalized prepared statements, unclosed BLOB handlers, and/or unfinished sqlite3_backups, it returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; regardless, but instead of deallocating the database connection immediately, it marks the database connection as an unusable &quot;zombie&quot; and makes arrangements to automatically deallocate the database connection after all prepared statements are finalized, all BLOB handles are closed, and all backups have finished. The sqlite3_close_v2() interface is intended for use with host languages that are garbage collected, and where the order in which destructors are called is arbitrary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6a04cc62fe27e532be18f141495602f090fc2e2" translate="yes" xml:space="preserve">
          <source>Ideally, applications should &lt;a href=&quot;finalize&quot;&gt;finalize&lt;/a&gt; all &lt;a href=&quot;stmt&quot;&gt;prepared statements&lt;/a&gt;, &lt;a href=&quot;blob_close&quot;&gt;close&lt;/a&gt; all &lt;a href=&quot;blob&quot;&gt;BLOB handles&lt;/a&gt;, and &lt;a href=&quot;backup_finish#sqlite3backupfinish&quot;&gt;finish&lt;/a&gt; all &lt;a href=&quot;backup&quot;&gt;sqlite3_backup&lt;/a&gt; objects associated with the &lt;a href=&quot;sqlite3&quot;&gt;sqlite3&lt;/a&gt; object prior to attempting to close the object. If the database connection is associated with unfinalized prepared statements, BLOB handlers, and/or unfinished sqlite3_backup objects then sqlite3_close() will leave the database connection open and return &lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;. If sqlite3_close_v2() is called with unfinalized prepared statements, unclosed BLOB handlers, and/or unfinished sqlite3_backups, it returns &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; regardless, but instead of deallocating the database connection immediately, it marks the database connection as an unusable &quot;zombie&quot; and makes arrangements to automatically deallocate the database connection after all prepared statements are finalized, all BLOB handles are closed, and all backups have finished. The sqlite3_close_v2() interface is intended for use with host languages that are garbage collected, and where the order in which destructors are called is arbitrary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6acc0ba610f36525f417357719583f041f6f89df" translate="yes" xml:space="preserve">
          <source>Identify all methods for important objects in the interface documentation. (&lt;a href=&quot;c3ref/context&quot;&gt;example&lt;/a&gt;)</source>
          <target state="translated">Определите все методы для важных объектов в документации по интерфейсу. ( &lt;a href=&quot;c3ref/context&quot;&gt;пример&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="b22904746b6da6e6da1cdf65a007a3a92ddeb189" translate="yes" xml:space="preserve">
          <source>IdxDelete</source>
          <target state="translated">IdxDelete</target>
        </trans-unit>
        <trans-unit id="366f895979adef772b50f0a751ee770dc166bab5" translate="yes" xml:space="preserve">
          <source>IdxGE</source>
          <target state="translated">IdxGE</target>
        </trans-unit>
        <trans-unit id="267d8b7b66c2e63c7420b46c7edd1ef118e13442" translate="yes" xml:space="preserve">
          <source>IdxGT</source>
          <target state="translated">IdxGT</target>
        </trans-unit>
        <trans-unit id="bdc0a8ea07737acbd00822ec9e49840776244c14" translate="yes" xml:space="preserve">
          <source>IdxInsert</source>
          <target state="translated">IdxInsert</target>
        </trans-unit>
        <trans-unit id="ba9bc003fbf28927e55ed674e6312a7b981c1435" translate="yes" xml:space="preserve">
          <source>IdxLE</source>
          <target state="translated">IdxLE</target>
        </trans-unit>
        <trans-unit id="11ede54300baae62726a3150e6c2f825098c4577" translate="yes" xml:space="preserve">
          <source>IdxLT</source>
          <target state="translated">IdxLT</target>
        </trans-unit>
        <trans-unit id="c82f35a450e8e6ba85d6a5ba639866e8424ba8d9" translate="yes" xml:space="preserve">
          <source>IdxRowid</source>
          <target state="translated">IdxRowid</target>
        </trans-unit>
        <trans-unit id="751c68a3471b1c791efaee0a8e7c24ea0c266efd" translate="yes" xml:space="preserve">
          <source>If</source>
          <target state="translated">If</target>
        </trans-unit>
        <trans-unit id="7194c23292e4ec0e7bfbbaa15bc21cc90107f2f5" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt; object V was initialized using &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;sqlite3_bind_pointer(S,I,P,X,D)&lt;/a&gt; or &lt;a href=&quot;#sqlite3_result_blob&quot;&gt;sqlite3_result_pointer(C,P,X,D)&lt;/a&gt; and if X and Y are strings that compare equal according to strcmp(X,Y), then sqlite3_value_pointer(V,Y) will return the pointer P. Otherwise, sqlite3_value_pointer(V,Y) returns a NULL. The sqlite3_bind_pointer() routine is part of the &lt;a href=&quot;bindptr&quot;&gt;pointer passing interface&lt;/a&gt; added for SQLite 3.20.0.</source>
          <target state="translated">Если объект &lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt; V был инициализирован с использованием &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;sqlite3_bind_pointer (S, I, P, X, D)&lt;/a&gt; или &lt;a href=&quot;#sqlite3_result_blob&quot;&gt;sqlite3_result_pointer (C, P, X, D)&lt;/a&gt; и если X и Y - строки, которые сравниваются равными согласно strcmp (X, Y), то sqlite3_value_pointer (V, Y) вернет указатель P. В противном случае sqlite3_value_pointer (V, Y) вернет NULL. Подпрограмма sqlite3_bind_pointer () является частью &lt;a href=&quot;bindptr&quot;&gt;интерфейса передачи указателя,&lt;/a&gt; добавленного для SQLite 3.20.0.</target>
        </trans-unit>
        <trans-unit id="6f26b5b5b34df807b99862702ef8a28042e009ca" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;../uri&quot;&gt;URI filename&lt;/a&gt; interpretation is enabled, and the filename argument begins with &quot;file:&quot;, then the filename is interpreted as a URI. URI filename interpretation is enabled if the &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_URI&lt;/a&gt; flag is set in the third argument to sqlite3_open_v2(), or if it has been enabled globally using the &lt;a href=&quot;c_config_covering_index_scan#sqliteconfiguri&quot;&gt;SQLITE_CONFIG_URI&lt;/a&gt; option with the &lt;a href=&quot;config&quot;&gt;sqlite3_config()&lt;/a&gt; method or by the &lt;a href=&quot;../compile#use_uri&quot;&gt;SQLITE_USE_URI&lt;/a&gt; compile-time option. URI filename interpretation is turned off by default, but future releases of SQLite might enable URI filename interpretation by default. See &quot;&lt;a href=&quot;../uri&quot;&gt;URI filenames&lt;/a&gt;&quot; for additional information.</source>
          <target state="translated">Если интерпретация &lt;a href=&quot;../uri&quot;&gt;имени файла URI&lt;/a&gt; включена и аргумент имени файла начинается с &amp;laquo;file:&amp;raquo;, тогда имя файла интерпретируется как URI. Интерпретация имени файла URI включена, если флаг &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_URI&lt;/a&gt; установлен в третьем аргументе sqlite3_open_v2 () или если он был включен глобально с помощью параметра &lt;a href=&quot;c_config_covering_index_scan#sqliteconfiguri&quot;&gt;SQLITE_CONFIG_URI&lt;/a&gt; с методом &lt;a href=&quot;config&quot;&gt;sqlite3_config ()&lt;/a&gt; или параметром &lt;a href=&quot;../compile#use_uri&quot;&gt;времени&lt;/a&gt; компиляции SQLITE_USE_URI . Интерпретация имени файла URI по умолчанию отключена, но в будущих версиях SQLite может быть включена интерпретация имени файла URI по умолчанию. См. &amp;laquo; &lt;a href=&quot;../uri&quot;&gt;Имена файлов URI&lt;/a&gt; &amp;raquo; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="05071756ec11a7890791b184fe1e16795132ff77" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;foreignkeys&quot;&gt;foreign key constraints&lt;/a&gt; are &lt;a href=&quot;pragma#pragma_foreign_keys&quot;&gt;enabled&lt;/a&gt; and a column with a &lt;a href=&quot;syntax/foreign-key-clause&quot;&gt;REFERENCES clause&lt;/a&gt; is added, the column must have a default value of NULL.</source>
          <target state="translated">Если &lt;a href=&quot;foreignkeys&quot;&gt;ограничения внешнего ключа&lt;/a&gt; являются &lt;a href=&quot;pragma#pragma_foreign_keys&quot;&gt;включены&lt;/a&gt; и столбцом с &lt;a href=&quot;syntax/foreign-key-clause&quot;&gt;пунктом ЛИТЕРАТУРЫ&lt;/a&gt; добавляются столбец должен иметь значение по умолчанию NULL.</target>
        </trans-unit>
        <trans-unit id="4f1ff78b03ab38bd9d7bc0c0b70bf71a047d9c7f" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;foreignkeys&quot;&gt;foreign key constraints&lt;/a&gt; are enabled, a DROP TABLE command performs an implicit &lt;a href=&quot;lang_delete&quot;&gt;DELETE FROM&lt;/a&gt; command before removing the table from the database schema. Any triggers attached to the table are dropped from the database schema before the implicit DELETE FROM is executed, so this cannot cause any triggers to fire. By contrast, an implicit DELETE FROM does cause any configured &lt;a href=&quot;foreignkeys#fk_actions&quot;&gt;foreign key actions&lt;/a&gt; to take place. If the implicit DELETE FROM executed as part of a DROP TABLE command violates any immediate foreign key constraints, an error is returned and the table is not dropped. If the implicit DELETE FROM causes any deferred foreign key constraints to be violated, and the violations still exist when the transaction is committed, an error is returned at the time of commit.</source>
          <target state="translated">Если включены &lt;a href=&quot;foreignkeys&quot;&gt;ограничения внешнего ключа&lt;/a&gt; , команда DROP TABLE выполняет неявную команду &lt;a href=&quot;lang_delete&quot;&gt;DELETE FROM&lt;/a&gt; перед удалением таблицы из схемы базы данных. Любые триггеры, прикрепленные к таблице, удаляются из схемы базы данных до выполнения неявного DELETE FROM, поэтому это не может вызвать срабатывание триггеров. Напротив, неявное DELETE FROM вызывает любые настроенные &lt;a href=&quot;foreignkeys#fk_actions&quot;&gt;действия внешнего ключа.&lt;/a&gt;иметь место. Если неявное DELETE FROM, выполняемое как часть команды DROP TABLE, нарушает любые непосредственные ограничения внешнего ключа, возвращается ошибка, и таблица не удаляется. Если неявное DELETE FROM приводит к нарушению каких-либо отложенных ограничений внешнего ключа, и нарушения все еще существуют, когда транзакция фиксируется, во время фиксации возвращается ошибка.</target>
        </trans-unit>
        <trans-unit id="5f1e27999e2bb2ba42de86bd45d31998c0603f29" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode&lt;/a&gt; is set to OFF (thus disabling the rollback journal file) then the behavior of the ROLLBACK command is undefined.</source>
          <target state="translated">Если для &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode&lt;/a&gt; установлено значение OFF (отключение файла журнала отката), то поведение команды ROLLBACK не определено.</target>
        </trans-unit>
        <trans-unit id="ff29cd60491f93076673fb75bedc0744960c9309" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;EXCLUSIVE locking mode&lt;/a&gt; is set prior to the first WAL-mode database access, then SQLite never attempts to call any of the shared-memory methods and hence no shared-memory wal-index is ever created. In that case, the database connection remains in EXCLUSIVE mode as long as the journal mode is WAL; attempts to change the locking mode using &quot;&lt;code&gt;PRAGMA locking_mode=NORMAL;&lt;/code&gt;&quot; are no-ops. The only way to change out of EXCLUSIVE locking mode is to first change out of WAL journal mode.</source>
          <target state="translated">Если &lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;режим блокировки EXCLUSIVE&lt;/a&gt; установлен до первого доступа к базе данных в режиме WAL, то SQLite никогда не пытается вызвать какие-либо методы с общей памятью, и, следовательно, wal-index с общей памятью никогда не создается. В этом случае соединение с базой данных остается в ЭКСКЛЮЗИВНОМ режиме, пока режим журнала - WAL; попытки изменить режим блокировки с помощью &amp;laquo; &lt;code&gt;PRAGMA locking_mode=NORMAL;&lt;/code&gt; &amp;raquo; не выполняются. Единственный способ выйти из ЭКСКЛЮЗИВНОГО режима блокировки - это сначала выйти из режима журнала WAL.</target>
        </trans-unit>
        <trans-unit id="53ecc95d367e022d4f668ded862caf4b37a61a3f" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;uri&quot;&gt;URI filename&lt;/a&gt; interpretation is enabled, and the filename argument begins with &quot;file:&quot;, then the filename is interpreted as a URI. URI filename interpretation is enabled if the &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_URI&lt;/a&gt; flag is set in the third argument to sqlite3_open_v2(), or if it has been enabled globally using the &lt;a href=&quot;#sqliteconfiguri&quot;&gt;SQLITE_CONFIG_URI&lt;/a&gt; option with the &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config()&lt;/a&gt; method or by the &lt;a href=&quot;compile#use_uri&quot;&gt;SQLITE_USE_URI&lt;/a&gt; compile-time option. URI filename interpretation is turned off by default, but future releases of SQLite might enable URI filename interpretation by default. See &quot;&lt;a href=&quot;uri&quot;&gt;URI filenames&lt;/a&gt;&quot; for additional information.</source>
          <target state="translated">Если интерпретация &lt;a href=&quot;uri&quot;&gt;имени файла URI&lt;/a&gt; включена и аргумент имени файла начинается с &amp;laquo;file:&amp;raquo;, тогда имя файла интерпретируется как URI. Интерпретация имени файла URI включена, если флаг &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_URI&lt;/a&gt; установлен в третьем аргументе sqlite3_open_v2 () или если он был включен глобально с помощью параметра &lt;a href=&quot;#sqliteconfiguri&quot;&gt;SQLITE_CONFIG_URI&lt;/a&gt; с методом &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config ()&lt;/a&gt; или параметром &lt;a href=&quot;compile#use_uri&quot;&gt;времени&lt;/a&gt; компиляции SQLITE_USE_URI . Интерпретация имени файла URI по умолчанию отключена, но в будущих версиях SQLite может быть включена интерпретация имени файла URI по умолчанию. См. &amp;laquo; &lt;a href=&quot;uri&quot;&gt;Имена файлов URI&lt;/a&gt; &amp;raquo; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="0b1cbecea1bfc84769a23d468c11c6578d2f04c8" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;value&quot;&gt;sqlite3_value&lt;/a&gt; object V was initialized using &lt;a href=&quot;bind_blob&quot;&gt;sqlite3_bind_pointer(S,I,P,X,D)&lt;/a&gt; or &lt;a href=&quot;result_blob&quot;&gt;sqlite3_result_pointer(C,P,X,D)&lt;/a&gt; and if X and Y are strings that compare equal according to strcmp(X,Y), then sqlite3_value_pointer(V,Y) will return the pointer P. Otherwise, sqlite3_value_pointer(V,Y) returns a NULL. The sqlite3_bind_pointer() routine is part of the &lt;a href=&quot;../bindptr&quot;&gt;pointer passing interface&lt;/a&gt; added for SQLite 3.20.0.</source>
          <target state="translated">Если объект &lt;a href=&quot;value&quot;&gt;sqlite3_value&lt;/a&gt; V был инициализирован с использованием &lt;a href=&quot;bind_blob&quot;&gt;sqlite3_bind_pointer (S, I, P, X, D)&lt;/a&gt; или &lt;a href=&quot;result_blob&quot;&gt;sqlite3_result_pointer (C, P, X, D)&lt;/a&gt; и если X и Y - строки, которые сравниваются равными согласно strcmp (X, Y), то sqlite3_value_pointer (V, Y) вернет указатель P. В противном случае sqlite3_value_pointer (V, Y) вернет NULL. Подпрограмма sqlite3_bind_pointer () является частью &lt;a href=&quot;../bindptr&quot;&gt;интерфейса передачи указателя,&lt;/a&gt; добавленного для SQLite 3.20.0.</target>
        </trans-unit>
        <trans-unit id="efa51497a7f80ea6cb0e82aee000934c754a4257" translate="yes" xml:space="preserve">
          <source>If A&amp;lt;B THEN B&amp;gt;A.</source>
          <target state="translated">Если A &amp;lt;B THEN B&amp;gt; A.</target>
        </trans-unit>
        <trans-unit id="af85ab5198e03592c9a1e93f75055ff7f7b4d432" translate="yes" xml:space="preserve">
          <source>If A&amp;lt;B and B&amp;lt;C then A&amp;lt;C.</source>
          <target state="translated">Если A &amp;lt;B и B &amp;lt;C, то A &amp;lt;C.</target>
        </trans-unit>
        <trans-unit id="ee7bb0a19c51474ba2d6ea010cd538d977b0b7a6" translate="yes" xml:space="preserve">
          <source>If A==B and B==C then A==C.</source>
          <target state="translated">Если A==B и B==C,то A==C.</target>
        </trans-unit>
        <trans-unit id="ad62f244096def890ab26a681e8f0120126f5af5" translate="yes" xml:space="preserve">
          <source>If A==B then B==A.</source>
          <target state="translated">Если A==B,то B==A.</target>
        </trans-unit>
        <trans-unit id="215c914a1a9a516e367b5ac91682005ac659922c" translate="yes" xml:space="preserve">
          <source>If AUTOVACUUM is enabled then it is possible that another root page might be moved into the newly deleted root page in order to keep all root pages contiguous at the beginning of the database. The former value of the root page that moved - its value before the move occurred - is stored in register P2. If no page movement was required (because the table being dropped was already the last one in the database) then a zero is stored in register P2. If AUTOVACUUM is disabled then a zero is stored in register P2.</source>
          <target state="translated">Если включена функция AUTOVACUUM,то возможно,что во вновь удаленную корневую страницу может быть перемещена другая корневая страница,чтобы все корневые страницы оставались смежными в начале БД.Прежнее значение корневой страницы,которая была перемещена-ее значение до того,как произошло перемещение,-хранится в регистре P2.Если перемещение страницы не требовалось (т.к.опускаемая таблица уже была последней в БД),то в регистре P2 сохраняется ноль.Если АВТОВАКУМ отключен,то ноль хранится в регистре P2.</target>
        </trans-unit>
        <trans-unit id="ed950ba22e4eb6cfb3232df6ec7b67b59a4df463" translate="yes" xml:space="preserve">
          <source>If CHANGESET_REPLACE is returned by an SQLITE_CHANGESET_CONFLICT conflict handler, then the conflicting row is removed from the database and a second attempt to apply the change is made. If this second attempt fails, the original row is restored to the database before continuing.</source>
          <target state="translated">Если CHANGESET_REPLACE возвращается обработчиком конфликта SQLITE_CHANGESET_CONFLICT,то конфликтующая строка удаляется из базы данных и предпринимается вторая попытка применения изменения.Если эта вторая попытка не увенчалась успехом,исходная строка восстанавливается в БД перед продолжением.</target>
        </trans-unit>
        <trans-unit id="30467096b4dd78c0d45cf667e992ae71e7009c64" translate="yes" xml:space="preserve">
          <source>If CHANGESET_REPLACE is returned by an SQLITE_CHANGESET_DATA conflict handler, then the conflicting row is either updated or deleted, depending on the type of change.</source>
          <target state="translated">Если CHANGESET_REPLACE возвращается обработчиком конфликтов SQLITE_CHANGESET_DATA,то конфликтная строка либо обновляется,либо удаляется,в зависимости от типа изменения.</target>
        </trans-unit>
        <trans-unit id="1a6c0fd79d5064239e68ae7d0df720319dab8e2b" translate="yes" xml:space="preserve">
          <source>If F is a NULL pointer, then sqlite3_uri_parameter(F,P) returns NULL and sqlite3_uri_boolean(F,P,B) returns B. If F is not a NULL pointer and is not a database file pathname pointer that SQLite passed into the xOpen VFS method, then the behavior of this routine is undefined and probably undesirable.</source>
          <target state="translated">Если F-указатель NULL,то sqlite3_uri_parameter(F,P)возвращает NULL,а sqlite3_uri_boolean(F,P,B)возвращает B.Если F-не указатель NULL и не указатель на файл базы данных,который SQLite передал в метод xOpen VFS,то поведение этой рутины неопределенное и,вероятно,нежелательное.</target>
        </trans-unit>
        <trans-unit id="7f60624c5c0f9adef9d93c9ed8179bc298264376" translate="yes" xml:space="preserve">
          <source>If F is a NULL pointer, then sqlite3_uri_parameter(F,P) returns NULL and sqlite3_uri_boolean(F,P,B) returns B. If F is not a NULL pointer and is not a database file pathname pointer that the SQLite core passed into the xOpen VFS method, then the behavior of this routine is undefined and probably undesirable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4646f7a7f8236532256725ec4112b997f511c7d6" translate="yes" xml:space="preserve">
          <source>If F is a suitable filename (as described in the previous paragraph) and if P is the name of the query parameter, then sqlite3_uri_parameter(F,P) returns the value of the P parameter if it exists or a NULL pointer if P does not appear as a query parameter on F. If P is a query parameter of F and it has no explicit value, then sqlite3_uri_parameter(F,P) returns a pointer to an empty string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9276605b0b0a889bb4c7aa5fcec85c6fc6240625" translate="yes" xml:space="preserve">
          <source>If F is the database filename pointer passed into the xOpen() method of a VFS implementation when the flags parameter to xOpen() has one or more of the &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_URI&lt;/a&gt; or &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_MAIN_DB&lt;/a&gt; bits set and P is the name of the query parameter, then sqlite3_uri_parameter(F,P) returns the value of the P parameter if it exists or a NULL pointer if P does not appear as a query parameter on F. If P is a query parameter of F has no explicit value, then sqlite3_uri_parameter(F,P) returns a pointer to an empty string.</source>
          <target state="translated">Если F - указатель имени файла базы данных, переданный в метод xOpen () реализации VFS, когда параметр flags функции xOpen () имеет один или несколько битов &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_URI&lt;/a&gt; или &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_MAIN_DB,&lt;/a&gt; а P - имя параметра запроса, тогда sqlite3_uri_parameter ( F, P) возвращает значение параметра P, если он существует, или указатель NULL, если P не отображается как параметр запроса на F. Если P является параметром запроса F, не имеет явного значения, тогда sqlite3_uri_parameter (F, P) возвращает указатель на пустую строку.</target>
        </trans-unit>
        <trans-unit id="8ba138ee3e59443a69735dbcd87f0f8269dd9564" translate="yes" xml:space="preserve">
          <source>If F is the database filename pointer passed into the xOpen() method of a VFS implementation when the flags parameter to xOpen() has one or more of the &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_URI&lt;/a&gt; or &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_MAIN_DB&lt;/a&gt; bits set and P is the name of the query parameter, then sqlite3_uri_parameter(F,P) returns the value of the P parameter if it exists or a NULL pointer if P does not appear as a query parameter on F. If P is a query parameter of F has no explicit value, then sqlite3_uri_parameter(F,P) returns a pointer to an empty string.</source>
          <target state="translated">Если F - указатель имени файла базы данных, переданный в метод xOpen () реализации VFS, когда параметр flags функции xOpen () имеет один или несколько битов &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_URI&lt;/a&gt; или &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_MAIN_DB,&lt;/a&gt; а P - имя параметра запроса, тогда sqlite3_uri_parameter ( F, P) возвращает значение параметра P, если он существует, или указатель NULL, если P не отображается как параметр запроса на F. Если P является параметром запроса F, не имеет явного значения, тогда sqlite3_uri_parameter (F, P) возвращает указатель на пустую строку.</target>
        </trans-unit>
        <trans-unit id="96db4246a2920821a0342bd0eb3ee7ac297124f4" translate="yes" xml:space="preserve">
          <source>If F is the name of an sqlite database file, journal file, or WAL file passed by the SQLite core into the VFS, or if F is a database filename obtained from &lt;a href=&quot;#sqlite3_db_filename&quot;&gt;sqlite3_db_filename()&lt;/a&gt;, then sqlite3_filename_journal(F) returns the name of the corresponding rollback journal file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5222d2f3de406b301b9d249247c656c5b47394f" translate="yes" xml:space="preserve">
          <source>If F is the name of an sqlite database file, journal file, or WAL file passed by the SQLite core into the VFS, then sqlite3_filename_database(F) returns the name of the corresponding database file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbbd8f58db83b28c968f4a1fd0df5ad504ea9fa0" translate="yes" xml:space="preserve">
          <source>If F is the name of an sqlite database file, journal file, or WAL file that was passed by the SQLite core into the VFS, or if F is a database filename obtained from &lt;a href=&quot;#sqlite3_db_filename&quot;&gt;sqlite3_db_filename()&lt;/a&gt;, then sqlite3_filename_wal(F) returns the name of the corresponding WAL file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="298246b211caead4a1410b71d74279a5d314bec4" translate="yes" xml:space="preserve">
          <source>If FILE is a ZIP archive rather than an SQLite Archive, the &quot;.archive&quot; command and the &quot;-A&quot; command-line option still work. This is accomplished using of the &lt;a href=&quot;zipfile&quot;&gt;zipfile&lt;/a&gt; extension. Hence, the following commands are roughly equivalent, differing only in output formatting:</source>
          <target state="translated">Если ФАЙЛ является ZIP-архивом, а не архивом SQLite, команда &amp;laquo;.archive&amp;raquo; и параметр командной строки &amp;laquo;-A&amp;raquo; по-прежнему работают. Это достигается с &lt;a href=&quot;zipfile&quot;&gt;помощью&lt;/a&gt; расширения zipfile . Следовательно, следующие команды примерно эквивалентны, различаются только форматированием вывода:</target>
        </trans-unit>
        <trans-unit id="d860543f88997bfbcee9b4b76e89b05bba6e3e47" translate="yes" xml:space="preserve">
          <source>If M is -1 in the initial journal header, then the number of page records that follow is computed by computing how many page records will fit in the available space of the remainder of the journal file.</source>
          <target state="translated">Если M -1 в начальном заголовке журнала,то количество последующих записей страницы вычисляется путем вычисления,сколько записей страницы поместится в доступное пространство оставшегося файла журнала.</target>
        </trans-unit>
        <trans-unit id="9d3a57a4870ed12272e250deed6ea841c224df1b" translate="yes" xml:space="preserve">
          <source>If NORMAL locking mode is in effect for the first WAL-mode database access, then the shared-memory wal-index is created. This means that the underlying VFS must support the &quot;version 2&quot; shared-memory. If the VFS does not support shared-memory methods, then the attempt to open a database that is already in WAL mode, or the attempt convert a database into WAL mode, will fail. As long as exactly one connection is using a shared-memory wal-index, the locking mode can be changed freely between NORMAL and EXCLUSIVE. It is only when the shared-memory wal-index is omitted, when the locking mode is EXCLUSIVE prior to the first WAL-mode database access, that the locking mode is stuck in EXCLUSIVE.</source>
          <target state="translated">Если для первого доступа к БД в WAL-режиме действует НОРМАЛЬНЫЙ режим блокировки,то создается wal-index разделяемой памяти.Это означает,что базовая VFS должна поддерживать разделяемую память &quot;версии 2&quot;.Если VFS не поддерживает методы общей памяти,то попытка открыть базу данных,которая уже находится в режиме WAL,или попытка преобразовать базу данных в режим WAL,будет безуспешной.До тех пор,пока ровно одно соединение использует wal-index общей памяти,режим блокировки может быть свободно изменен между NORMAL и EXCLUSIVE.Только в том случае,если wal-index общей памяти опущен,когда режим блокировки является ЭКСКЛЮЗИВНЫМ до первого доступа к базе данных в режиме WAL,режим блокировки застрял в ЭКСКЛЮЗИВНОМ режиме.</target>
        </trans-unit>
        <trans-unit id="084a98d24eb789b16e0f410999491d6ca6f68655" translate="yes" xml:space="preserve">
          <source>If NULL is inserted into the mode column, then the mode of the new archive entry is automatically set to either 33188 (-rw-r--r--) or 16877 (drwxr-xr-x), depending on whether or not the values specified for columns &quot;sz&quot;, &quot;data&quot; and &quot;rawdata&quot; indicate that the new entry is a directory.</source>
          <target state="translated">Если в столбец режима вставлен NULL,то режим новой записи архива автоматически устанавливается либо 33188 (-rw-r--r--),либо 16877 (drwxr-xr-x),в зависимости от того,указывают ли значения,указанные для столбцов &quot;sz&quot;,&quot;data&quot; и &quot;rawdata&quot; на то,что новая запись является директорией.</target>
        </trans-unit>
        <trans-unit id="4101f8cb88698edd15d7c951de1289b2d8eaa71c" translate="yes" xml:space="preserve">
          <source>If NULL is inserted into the mtime column, then the timestamp of the new entry is set to the current time. Otherwise, the specified value is interpreted as an integer and used as is.</source>
          <target state="translated">Если NULL вставлен в столбец mtime,то временная метка новой записи устанавливается на текущее время.В противном случае указанное значение интерпретируется как целое число и используется как есть.</target>
        </trans-unit>
        <trans-unit id="43806989f629698fba47d7f7a7bc8a167120b2e8" translate="yes" xml:space="preserve">
          <source>If P is a polygon, then geopoly_area(P) returns the area enclosed by that polygon. If P is not a polygon, geopoly_area(P) returns NULL.</source>
          <target state="translated">Если P-полигон,то geopoly_area(P)возвращает область,окруженную этим полигоном.Если P не полигон,то geopoly_area(P)возвращает NULL.</target>
        </trans-unit>
        <trans-unit id="7923fadf3f55cd9b6d47a16ad18e97575f464043" translate="yes" xml:space="preserve">
          <source>If P is a polygon, then geopoly_bbox(P) returns a new polygon that is the smallest (axis-aligned) rectangle completely enclosing P. If P is not a polygon, geopoly_bbox(P) returns NULL.</source>
          <target state="translated">Если P-полигон,то geopoly_bbox(P)возвращает новый полигон,который является наименьшим (выровненным по оси)прямоугольником,полностью окружающим P.Если P-не полигон,то geopoly_bbox(P)возвращает NULL.</target>
        </trans-unit>
        <trans-unit id="231cf86fd88561789cf32053e3b5a58ac30a1c90" translate="yes" xml:space="preserve">
          <source>If P is a polygon, then geopoly_blob(P) returns the binary encoding of that polygon as a BLOB. If P is not a polygon, geopoly_blob(P) returns NULL.</source>
          <target state="translated">Если P-полигон,то geopoly_blob(P)возвращает двоичную кодировку этого полигона в виде BLOB.Если P не полигон,то geopoly_blob(P)возвращает NULL.</target>
        </trans-unit>
        <trans-unit id="85466629c4fd74bf6816a1cb264ff5557384a47f" translate="yes" xml:space="preserve">
          <source>If P is a polygon, then geopoly_contains_point(P,X,Y) returns a non-zero integer if and only if the coordinate X,Y is inside or on the boundary of the polygon P. If P is not a polygon, geopoly_contains_point(P,X,Y) returns NULL.</source>
          <target state="translated">Если P-полигон,то geopoly_contains_point(P,X,Y)возвращает ненулевое целое число,если и только если координата X,Y находится внутри или на границе полигона P.Если P-не полигон,то geopoly_contains_point(P,X,Y)возвращает NULL.</target>
        </trans-unit>
        <trans-unit id="01d01cedd541548c033da5a76ae2b943d566e364" translate="yes" xml:space="preserve">
          <source>If P is a polygon, then geopoly_json(P) returns the GeoJSON representation of that polygon as a TEXT string. If P is not a polygon, geopoly_json(P) returns NULL.</source>
          <target state="translated">Если P-полигон,то geopoly_json(P)возвращает GeoJSON представление этого полигона как строку TEXT.Если P не полигон,то geopoly_json(P)возвращает NULL.</target>
        </trans-unit>
        <trans-unit id="4d96f5fac84b02e3eed71829015c2301166a1102" translate="yes" xml:space="preserve">
          <source>If P is a polygon, then geopoly_svg(P,...) returns a text string which is a &lt;a href=&quot;https://en.wikipedia.org/wiki/Scalable_Vector_Graphics&quot;&gt;Scalable Vector Graphics (SVG)&lt;/a&gt; representation of that polygon. If there is more one argument, then second and subsequent arguments are added as attributes to each SVG glyph. For example:</source>
          <target state="translated">Если P - многоугольник, то geopoly_svg (P, ...) возвращает текстовую строку, которая представляет собой представление этого многоугольника в формате &lt;a href=&quot;https://en.wikipedia.org/wiki/Scalable_Vector_Graphics&quot;&gt;масштабируемой векторной графики (SVG)&lt;/a&gt; . Если есть несколько аргументов, то второй и последующие аргументы добавляются как атрибуты к каждому глифу SVG. Например:</target>
        </trans-unit>
        <trans-unit id="8bf89c8791c7886430f52d199af4522be0892c2c" translate="yes" xml:space="preserve">
          <source>If P is not a polygon, geopoly_svg(P,...) returns NULL.</source>
          <target state="translated">Если P не является полигоном,то geopoly_svg(P,...)возвращает NULL.</target>
        </trans-unit>
        <trans-unit id="8d6c1d000f406140de377a0a6166c3f4f4ee6ecf" translate="yes" xml:space="preserve">
          <source>If P&amp;gt;X and K&amp;gt;X then the first M bytes of P are stored on the btree page and the remaining P-M bytes are stored on overflow pages.</source>
          <target state="translated">Если P&amp;gt; X и K&amp;gt; X, то первые M байтов P сохраняются на странице btree, а оставшиеся байты PM хранятся на страницах переполнения.</target>
        </trans-unit>
        <trans-unit id="40c35ab59089c6d8a3b822955c4be859755a9e2b" translate="yes" xml:space="preserve">
          <source>If P&amp;gt;X and K&amp;lt;=X then the first K bytes of P are stored on the btree page and the remaining P-K bytes are stored on overflow pages.</source>
          <target state="translated">Если P&amp;gt; X и K &amp;lt;= X, то первые K байтов P сохраняются на странице btree, а оставшиеся байты PK хранятся на страницах переполнения.</target>
        </trans-unit>
        <trans-unit id="fa33ffa92f81891eff9dffa21d7e8d38e3faa786" translate="yes" xml:space="preserve">
          <source>If P&amp;lt;=X then all P bytes of payload are stored directly on the btree page without overflow.</source>
          <target state="translated">Если P &amp;lt;= X, то все P байтов полезной нагрузки сохраняются непосредственно на странице btree без переполнения.</target>
        </trans-unit>
        <trans-unit id="a69350651a4faef3f95c007babd7352f8f77d85e" translate="yes" xml:space="preserve">
          <source>If P1 and P2 are both polygons, then the geopoly_overlap(P1,P2) function returns a non-zero integer if there is any overlap between P1 and P2, or it returns zero if P1 and P2 completely disjoint. If either P1 or P2 is not a polygon, this routine returns NULL.</source>
          <target state="translated">Если P1 и P2 являются полигонами,то функция geopoly_overlap(P1,P2)возвращает ненулевое целое число,если есть какое-либо перекрытие между P1 и P2,или возвращает ноль,если P1 и P2 полностью разобщены.Если P1 или P2 не является полигоном,эта рутина возвращает NULL.</target>
        </trans-unit>
        <trans-unit id="3222b98590b837273b0d4239ca32f6bb0d30ac83" translate="yes" xml:space="preserve">
          <source>If P1 and P2 are both polygons, then the geopoly_within(P1,P2) function returns a non-zero integer if P1 is completely contained within P2, or it returns zero if any part of P1 is outside of P2. If P1 and P2 are the same polygon, this routine returns non-zero. If either P1 or P2 is not a polygon, this routine returns NULL.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd9f5db9ef38463d2501fa9dc6b70e3f4750a4f2" translate="yes" xml:space="preserve">
          <source>If P1 and P2 are both polygons, then the geopoly_within(P1,P2) function returns a non-zero integer if P2 is completely contained within P1, or it returns zero if any part of P2 is outside of P1. If P1 and P2 are the same polygon, this routine returns non-zero. If either P1 or P2 is not a polygon, this routine returns NULL.</source>
          <target state="translated">Если P1 и P2 являются полигонами,то функция geopoly_within(P1,P2)возвращает ненулевое целое число,если P2 полностью содержится в P1,или возвращает ноль,если какая-либо часть P2 находится вне P1.Если P1 и P2-один и тот же полигон,то эта рутина возвращает ненулевое число.Если P1 или P2 не являются полигонами,эта рутина возвращает NULL.</target>
        </trans-unit>
        <trans-unit id="4157b5ffd90247cfe9008c1ae67666efa84d2bdb" translate="yes" xml:space="preserve">
          <source>If P1 is 0, then all SQL statements become expired. If P1 is non-zero, then only the currently executing statement is expired.</source>
          <target state="translated">Если P1 равен 0,то все SQL-операторы становятся недействительными.Если P1 ненулевой,то истекает только исполняемый в данный момент оператор.</target>
        </trans-unit>
        <trans-unit id="7196e8103cc1b57f49e64f9cffafd04bf56cea94" translate="yes" xml:space="preserve">
          <source>If P1 is non-zero, then the jump is taken if the database constraint-counter is zero (the one that counts deferred constraint violations). If P1 is zero, the jump is taken if the statement constraint-counter is zero (immediate foreign key constraint violations).</source>
          <target state="translated">Если P1 ненулевой,то прыжок выполняется,если счетчик ограничений БД равен нулю (тот,который считает нарушения отложенных ограничений).Если P1 равен нулю,то скачок выполняется,если счетчик ограничений оператора равен нулю (немедленные нарушения ограничений по внешнему ключу).</target>
        </trans-unit>
        <trans-unit id="e76da0aa98d442426a710c17ffdd5c83f500e5de" translate="yes" xml:space="preserve">
          <source>If P1 is not zero, then it is a register that a subsequent min() or max() aggregate will set to 1 if the current row is not the minimum or maximum. The P1 register is initialized to 0 by this instruction.</source>
          <target state="translated">Если P1 не равен нулю,то это регистр,который последующий агрегат min()или max()установит в 1,если текущая строка не является минимальной или максимальной.Регистр P1 инициализируется этой инструкцией до 0.</target>
        </trans-unit>
        <trans-unit id="12e05de4c2b1f6e3dffb8fed2e435034a63c1753" translate="yes" xml:space="preserve">
          <source>If P2 is 0, then SQL statements are expired immediately. If P2 is 1, then running SQL statements are allowed to continue to run to completion. The P2==1 case occurs when a CREATE INDEX or similar schema change happens that might help the statement run faster but which does not affect the correctness of operation.</source>
          <target state="translated">Если P2 равен 0,то SQL-операторы истекают немедленно.Если P2 равен 1,то запущенные SQL-операторы можно продолжать выполнять до конца.Случай P2==1 происходит,когда происходит изменение CREATE INDEX или аналогичной схемы,что может помочь оператору работать быстрее,но это не влияет на корректность работы.</target>
        </trans-unit>
        <trans-unit id="b95c82eece8cdb232cd3c969e9f714560a3483ed" translate="yes" xml:space="preserve">
          <source>If P2 is not zero, jump to instruction P2.</source>
          <target state="translated">Если P2 не равен нулю,перейдите к инструкции P2.</target>
        </trans-unit>
        <trans-unit id="624ae34f34a46b97a6ede8c6928e2854d808cc50" translate="yes" xml:space="preserve">
          <source>If P2 is not zero, then it is a register holding a string which is the file into which the result of vacuum should be written. When P2 is zero, the vacuum overwrites the original database.</source>
          <target state="translated">Если P2 не равен нулю,то это регистр,содержащий строку,которая является файлом,в который должен быть записан результат вакуума.Когда P2 равен нулю,вакуум перезаписывает исходную базу данных.</target>
        </trans-unit>
        <trans-unit id="7f685a86b5e506b77efdf72c9ec8070a39f8b40d" translate="yes" xml:space="preserve">
          <source>If P2 is the SCHEMA_VERSION cookie (cookie number 1) then the internal schema version is set to P3-P5. The &quot;PRAGMA schema_version=N&quot; statement has P5 set to 1, so that the internal schema version will be different from the database schema version, resulting in a schema reset.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4101c4124c3fe6e483990efc85814b11a364af14" translate="yes" xml:space="preserve">
          <source>If P2!=0 then the coroutine implementation immediately follows this opcode. So jump over the coroutine implementation to address P2.</source>
          <target state="translated">Если P2!=0,то реализация корутины немедленно следует за этим опкодом.Поэтому перескакивайте через реализацию корутины для обращения к P2.</target>
        </trans-unit>
        <trans-unit id="95acd6cd81e68312a7b3f200adb71394407e2187" translate="yes" xml:space="preserve">
          <source>If P2==1 then no insert is performed. argv[0] is the rowid of a row to delete.</source>
          <target state="translated">Если P2==1,то вставка не производится.argv[0]-это rowid строки для удаления.</target>
        </trans-unit>
        <trans-unit id="4b3305a3179f27393cd2b3c6dff28468fd2e27f2" translate="yes" xml:space="preserve">
          <source>If P3 is not zero and the content of register P3 is equal to P5, then the datatype of the register P2 is converted to BLOB. The content is the same sequence of bytes, it is merely interpreted as a BLOB instead of a string, as if it had been CAST. In other words:</source>
          <target state="translated">Если P3 не равен нулю,а содержимое регистра P3 равно P5,то тип данных регистра P2 преобразуется в BLOB.Содержимое является той же самой последовательностью байтов,оно просто интерпретируется как BLOB,а не как строка,как если бы это было CAST.Другими словами:</target>
        </trans-unit>
        <trans-unit id="7b12a88585bcaf8799451da77eaddd8eae80e136" translate="yes" xml:space="preserve">
          <source>If P3 is not zero, then it is an address to jump to if an SQLITE_CORRUPT error is encountered.</source>
          <target state="translated">Если P3 не равен нулю,то это адрес,на который нужно перейти при возникновении ошибки SQLITE_CORRUPT.</target>
        </trans-unit>
        <trans-unit id="c8b8a297f15c969bf51cec7bd085ee38d68f8af2" translate="yes" xml:space="preserve">
          <source>If P3!=0 then the content of the P2 register is unsuitable for use in OP_Result and any OP_Result will invalidate the P2 register content. The P2 register content is invalidated by opcodes like &lt;a href=&quot;opcode#Function&quot;&gt;Function&lt;/a&gt; or by any use of another cursor pointing to the same table.</source>
          <target state="translated">Если P3! = 0, то содержимое регистра P2 не подходит для использования в OP_Result, и любой OP_Result сделает недействительным содержимое регистра P2. Содержимое регистра P2 становится недействительным из-за кодов операций, таких как &lt;a href=&quot;opcode#Function&quot;&gt;Function,&lt;/a&gt; или любого использования другого курсора, указывающего на ту же таблицу.</target>
        </trans-unit>
        <trans-unit id="f0e377e900f9f81e14b13484040277f239153040" translate="yes" xml:space="preserve">
          <source>If P3!=0 then this opcode is allowed to make an ephemeral pointer into the database page. That means that the content of the output register will be invalidated as soon as the cursor moves - including moves caused by other cursors that &quot;save&quot; the current cursors position in order that they can write to the same table. If P3==0 then a copy of the data is made into memory. P3!=0 is faster, but P3==0 is safer.</source>
          <target state="translated">Если P3!=0,то данный опкод позволяет сделать эфемерный указатель на страницу базы данных.Это означает,что содержимое выходного регистра будет признано недействительным,как только курсор переместится-включая перемещения,вызванные другими курсорами,которые &quot;сохраняют&quot; текущую позицию курсора для того,чтобы они могли записать в ту же самую таблицу.Если P3==0,то происходит копирование данных в память.P3!=0 быстрее,но P3==0 безопаснее.</target>
        </trans-unit>
        <trans-unit id="261dff5d4c60a753fca80ceb7a30b1ccde835d53" translate="yes" xml:space="preserve">
          <source>If P3&amp;gt;0 then P3 is a register in the root frame of this VDBE that holds the largest previously generated record number. No new record numbers are allowed to be less than this value. When this value reaches its maximum, an SQLITE_FULL error is generated. The P3 register is updated with the ' generated record number. This P3 mechanism is used to help implement the AUTOINCREMENT feature.</source>
          <target state="translated">Если P3&amp;gt; 0, то P3 - это регистр в корневом кадре этого VDBE, который содержит наибольший номер ранее созданной записи. Номера новых записей не могут быть меньше этого значения. Когда это значение достигает своего максимума, генерируется ошибка SQLITE_FULL. Регистр P3 обновляется сгенерированным номером записи. Этот механизм P3 используется для помощи в реализации функции AUTOINCREMENT.</target>
        </trans-unit>
        <trans-unit id="b537aafa079e151774c7dbac498d69a9800ce496" translate="yes" xml:space="preserve">
          <source>If P3==0 and P4==0 then r[P2] := r[P1] IS TRUE</source>
          <target state="translated">Если P3==0 и P4==0,то r[P2]:=r[P1]IS TRUE</target>
        </trans-unit>
        <trans-unit id="4abb01d048e9054de1718b2c97d7bca8f72ca3fd" translate="yes" xml:space="preserve">
          <source>If P3==0 and P4==1 then r[P2] := r[P1] IS NOT TRUE</source>
          <target state="translated">Если P3==0 и P4==1,то r[P2]:=r[P1]НЕ ТРУДИТСЯ</target>
        </trans-unit>
        <trans-unit id="dffd9f3f7dcda52e1f25f401261075e7728503f3" translate="yes" xml:space="preserve">
          <source>If P3==0, then an exact count is obtained, which involves visiting every btree page of the table. But if P3 is non-zero, an estimate is returned based on the current cursor position.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0f5592c3dfac53b5b17bcf906b1b3d9b28a160a" translate="yes" xml:space="preserve">
          <source>If P3==1 and P4==0 then r[P2] := r[P1] IS NOT FALSE</source>
          <target state="translated">Если P3==1 и P4==0,то r[P2]:=r[P1]НЕ ЛОЖИТСЯ</target>
        </trans-unit>
        <trans-unit id="ec92d66dd345ec321132b256dce88d1a72413c5f" translate="yes" xml:space="preserve">
          <source>If P3==1 and P4==1 then r[P2] := r[P1] IS FALSE</source>
          <target state="translated">Если P3==1 и P4==1,то r[P2]:=r[P1]IS FALSE</target>
        </trans-unit>
        <trans-unit id="ec8063043e0a9cad56cc57c55e1e58a5f2b9e719" translate="yes" xml:space="preserve">
          <source>If P4 is NULL then all index fields have the affinity BLOB.</source>
          <target state="translated">Если P4 равен NULL,то все поля индекса имеют сродство BLOB.</target>
        </trans-unit>
        <trans-unit id="0409d4d0ae010acb4eb82b5c67e7d26a4e78a377" translate="yes" xml:space="preserve">
          <source>If P4 is not NULL then it points to a Table object. In this case either the update or pre-update hook, or both, may be invoked. The P1 cursor must have been positioned using &lt;a href=&quot;opcode#NotFound&quot;&gt;NotFound&lt;/a&gt; prior to invoking this opcode in this case. Specifically, if one is configured, the pre-update hook is invoked if P4 is not NULL. The update-hook is invoked if one is configured, P4 is not NULL, and the OPFLAG_NCHANGE flag is set in P2.</source>
          <target state="translated">Если P4 не равен NULL, он указывает на объект Table. В этом случае может быть вызвана ловушка обновления или предварительного обновления, либо и то, и другое. В этом случае курсор P1 должен быть размещен с помощью &lt;a href=&quot;opcode#NotFound&quot;&gt;NotFound&lt;/a&gt; до вызова этого кода операции. В частности, если он настроен, ловушка предварительного обновления вызывается, если P4 не равен NULL. Ловушка обновления вызывается, если она настроена, P4 не равен NULL и флаг OPFLAG_NCHANGE установлен в P2.</target>
        </trans-unit>
        <trans-unit id="833039fcfc9ba1341a8bac648d6011bebc9ef640" translate="yes" xml:space="preserve">
          <source>If P4 is not null then it is an error message string.</source>
          <target state="translated">Если P4 не равен нулю,то это строка сообщения об ошибке.</target>
        </trans-unit>
        <trans-unit id="323b07c0a29678efca20be714e85be9034012831" translate="yes" xml:space="preserve">
          <source>If P4 is not zero, then it is the number of values in the unpacked key of reg(P2). In that case, P3 is the index of the first register for the unpacked key. The availability of the unpacked key can sometimes be an optimization.</source>
          <target state="translated">Если P4 не равен нулю,то это количество значений в распакованном ключе reg(P2).В этом случае P3-это индекс первого регистра для распакованного ключа.Наличие распакованного ключа иногда может быть оптимизацией.</target>
        </trans-unit>
        <trans-unit id="7f6b94d7be2c05fd8f0bc6b7de40e344824f8d5b" translate="yes" xml:space="preserve">
          <source>If P4==0 then register P3 holds a blob constructed by &lt;a href=&quot;opcode#MakeRecord&quot;&gt;MakeRecord&lt;/a&gt;. If P4&amp;gt;0 then register P3 is the first of P4 registers that form an unpacked record.</source>
          <target state="translated">Если P4 == 0, то регистр P3 содержит большой двоичный &lt;a href=&quot;opcode#MakeRecord&quot;&gt;объект,&lt;/a&gt; созданный MakeRecord . Если P4&amp;gt; 0, то регистр P3 является первым из регистров P4, которые формируют распакованную запись.</target>
        </trans-unit>
        <trans-unit id="ea0d786e8193b3191b8e71dcd7cd40efa9daf92e" translate="yes" xml:space="preserve">
          <source>If P5 has the OPFLAG_APPEND bit set, that is a hint to the b-tree layer that this insert is likely to be an append.</source>
          <target state="translated">Если P5 имеет набор битов OPFLAG_APPEND,то это намек на слой b-дерева,что эта вставка,скорее всего,будет приложением.</target>
        </trans-unit>
        <trans-unit id="b63e95392a3322ead1cda4df48bfef1df78fcfb5" translate="yes" xml:space="preserve">
          <source>If P5 has the OPFLAG_NCHANGE bit set, then the change counter is incremented by this instruction. If the OPFLAG_NCHANGE bit is clear, then the change counter is unchanged.</source>
          <target state="translated">Если в P5 установлен бит OPFLAG_NCHANGE,то счетчик изменений инкрементируется данной инструкцией.Если бит OPFLAG_NCHANGE чист,то счетчик изменений не изменяется.</target>
        </trans-unit>
        <trans-unit id="1ea732c0486f9121ffc851f241dea7753a429516" translate="yes" xml:space="preserve">
          <source>If P5 has the OPFLAG_PERMUTE bit set, then the order of comparison is determined by the most recent &lt;a href=&quot;opcode#Permutation&quot;&gt;Permutation&lt;/a&gt; operator. If the OPFLAG_PERMUTE bit is clear, then register are compared in sequential order.</source>
          <target state="translated">Если в P5 установлен бит OPFLAG_PERMUTE, то порядок сравнения определяется последним оператором &lt;a href=&quot;opcode#Permutation&quot;&gt;перестановки&lt;/a&gt; . Если бит OPFLAG_PERMUTE сброшен, регистры сравниваются в последовательном порядке.</target>
        </trans-unit>
        <trans-unit id="d566e20d0304652ba9b826870e3331951b73f1a1" translate="yes" xml:space="preserve">
          <source>If P5 is non-zero, then recursive program invocation is enabled.</source>
          <target state="translated">Если P5 ненулевой,то включается рекурсивный вызов программы.</target>
        </trans-unit>
        <trans-unit id="8cc4989073012226802ebb0b0b0287d0ebbc4c24" translate="yes" xml:space="preserve">
          <source>If P5 is not zero and P4 is NULL, then everything after the &quot;:&quot; is omitted.</source>
          <target state="translated">Если P5 не равен нулю,а P4-NULL,то все после &quot;:&quot; опускается.</target>
        </trans-unit>
        <trans-unit id="6140b6bc786ef6328163c583ea74afbbf1b0203f" translate="yes" xml:space="preserve">
          <source>If P5 is not zero, the check is done on the auxiliary database file, not the main database file.</source>
          <target state="translated">Если P5 не равен нулю,проверка производится на вспомогательном файле БД,а не на основном файле БД.</target>
        </trans-unit>
        <trans-unit id="4031180a3fa926570f402abdb205aa9088ecbac2" translate="yes" xml:space="preserve">
          <source>If P5 is not zero, then raise an SQLITE_CORRUPT_INDEX error if no matching index entry is found. This happens when running an UPDATE or DELETE statement and the index entry to be updated or deleted is not found. For some uses of &lt;a href=&quot;opcode#IdxDelete&quot;&gt;IdxDelete&lt;/a&gt; (example: the EXCEPT operator) it does not matter that no matching entry is found. For those cases, P5 is zero.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f3d5e8ef0f60d316b59356518575a2f176eb4d7" translate="yes" xml:space="preserve">
          <source>If P5 is positive and the jump is taken, then event counter number P5-1 in the prepared statement is incremented.</source>
          <target state="translated">Если P5 положительный и прыжок сделан,то номер счетчика событий P5-1 в подготовленном отчете увеличивается.</target>
        </trans-unit>
        <trans-unit id="e77300f272721b16413737d1f5909b28a7b7a6ee" translate="yes" xml:space="preserve">
          <source>If P5 is set, then all released registers have their type set to MEM_Undefined so that any subsequent attempt to read the released register (before it is reinitialized) will generate an assertion fault.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d64a234f707179617701bb23c32b6ab90539344" translate="yes" xml:space="preserve">
          <source>If P5!=0 then this opcode also checks the schema cookie against P3 and the schema generation counter against P4. The cookie changes its value whenever the database schema changes. This operation is used to detect when that the cookie has changed and that the current process needs to reread the schema. If the schema cookie in P3 differs from the schema cookie in the database header or if the schema generation counter in P4 differs from the current generation counter, then an SQLITE_SCHEMA error is raised and execution halts. The sqlite3_step() wrapper function might then reprepare the statement and rerun it from the beginning.</source>
          <target state="translated">Если P5!=0,то этот опкод также проверяет куки-схемы против P3,а счетчик генерации схемы против P4.Файл cookie меняет свое значение всякий раз,когда изменяется схема базы данных.Эта операция используется для определения того,когда файл cookie изменился и что текущему процессу необходимо перечитать схему.Если куки-схемы в P3 отличаются от куки-схемы в заголовке базы данных или если счетчик генерации схемы в P4 отличается от счетчика генерации текущей,то возникает ошибка SQLITE_SCHEMA и выполнение останавливается.Функция обертки sqlite3_step()может затем перезапустить оператор и выполнить его заново с самого начала.</target>
        </trans-unit>
        <trans-unit id="79b8df381ad1ae2bdf21bac462376aead762296f" translate="yes" xml:space="preserve">
          <source>If RBU is used to update a large BLOB value within a target database, it may be more efficient to store a patch or delta that can be used to modify the existing BLOB instead of an entirely new value within the RBU database. RBU allows deltas to be specified in two ways:</source>
          <target state="translated">Если RBU используется для обновления большого BLOB-значения в целевой базе данных,то,возможно,более эффективным будет хранение патча или дельты,которые могут быть использованы для модификации существующего BLOB вместо совершенно нового значения в базе данных RBU.RBU позволяет задавать дельты двумя способами:</target>
        </trans-unit>
        <trans-unit id="f32404d913415ab312a2d32bca5267050dc55433" translate="yes" xml:space="preserve">
          <source>If SQLITE_DEFAULT_WAL_SYNCHRONOUS differs from SQLITE_DEFAULT_SYNCHRONOUS, and if the application has not modified the synchronous setting for the database file using the &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous&lt;/a&gt; statement, then the synchronous setting is changed to value defined by SQLITE_DEFAULT_WAL_SYNCHRONOUS when the database connection switches into WAL mode for the first time. If the SQLITE_DEFAULT_WAL_SYNCHRONOUS value is not overridden at compile-time, then it will always be the same as &lt;a href=&quot;compile#default_synchronous&quot;&gt;SQLITE_DEFAULT_SYNCHRONOUS&lt;/a&gt; and so no automatic synchronous setting changes will ever occur.</source>
          <target state="translated">Если SQLITE_DEFAULT_WAL_SYNCHRONOUS отличается от SQLITE_DEFAULT_SYNCHRONOUS, и если приложение не изменило синхронную настройку для файла базы данных с &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;помощью синхронного&lt;/a&gt; оператора PRAGMA , то синхронная настройка изменяется на значение, определенное SQLITE_DEFAULT_WAL_WAL_SYNCHRONOUS, когда первое соединение с базой данных переключается в режим WAL_SYNCHRONOUS, когда первое соединение с базой данных переключается в режим WAL. Если значение SQLITE_DEFAULT_WAL_SYNCHRONOUS не переопределено во время компиляции, оно всегда будет таким же, как &lt;a href=&quot;compile#default_synchronous&quot;&gt;SQLITE_DEFAULT_SYNCHRONOUS,&lt;/a&gt; и поэтому никаких автоматических изменений синхронных настроек никогда не произойдет.</target>
        </trans-unit>
        <trans-unit id="35daf76480440bed2a0456819e4a2256b8e77c1e" translate="yes" xml:space="preserve">
          <source>If SQLITE_NULLEQ is set in P5 then the result of comparison is always either true or false and is never NULL. If both operands are NULL then the result of comparison is true. If either operand is NULL then the result is false. If neither operand is NULL the result is the same as it would be if the SQLITE_NULLEQ flag were omitted from P5.</source>
          <target state="translated">Если SQLITE_NULLEQ выставлен в P5,то результат сравнения всегда будет либо истинным,либо ложным и никогда не будет NULL.Если оба операнда NULL,то результат сравнения будет true.Если любой из операндов имеет значение NULL,то результат равен false.Если ни один из операндов не равен NULL,то результат будет таким же,как если бы из P5 был опущен флаг SQLITE_NULLEQ.</target>
        </trans-unit>
        <trans-unit id="b5e1e68a469214facd1d655d6dbff18739ace55a" translate="yes" xml:space="preserve">
          <source>If SQLite discovers that the sqlite_sequence table has any other format, it returns the SQLITE_CORRUPT_SEQUENCE error.</source>
          <target state="translated">Если SQLite обнаруживает,что таблица sqlite_sequence имеет другой формат,он возвращает ошибку SQLITE_CORRUPT_SEQUENCE.</target>
        </trans-unit>
        <trans-unit id="015569a0e55d69ecf2d3dec3d6ece8f0bde61846" translate="yes" xml:space="preserve">
          <source>If SQLite ever returns SQLITE_MISUSE from any interface, that means that the application is incorrectly coded and needs to be fixed. Do not ship an application that sometimes returns SQLITE_MISUSE from a standard SQLite interface because that application contains potentially serious bugs.</source>
          <target state="translated">Если SQLite когда-либо возвращал SQLITE_MISUSE из любого интерфейса,это означает,что приложение некорректно закодировано и нуждается в исправлении.Не поставляйте приложение,которое иногда возвращает SQLITE_MISUSE из стандартного интерфейса SQLite,потому что это приложение содержит потенциально серьезные ошибки.</target>
        </trans-unit>
        <trans-unit id="60b69a270887c8a40e3999f62767f4e29079be3d" translate="yes" xml:space="preserve">
          <source>If SQLite has been compiled with the &lt;a href=&quot;compile#debug&quot;&gt;SQLITE_DEBUG&lt;/a&gt; compile-time option, then the parser_trace pragma can be used to turn on tracing for the SQL parser used internally by SQLite. This feature is used for debugging SQLite itself.</source>
          <target state="translated">Если SQLite был скомпилирован с параметром &lt;a href=&quot;compile#debug&quot;&gt;времени&lt;/a&gt; компиляции SQLITE_DEBUG , то прагма parser_trace может использоваться для включения трассировки для синтаксического анализатора SQL, используемого внутри SQLite. Эта функция используется для отладки самого SQLite.</target>
        </trans-unit>
        <trans-unit id="3e93855bd0fdb13d2772a4cf88fefeb516093bf0" translate="yes" xml:space="preserve">
          <source>If SQLite has been compiled with the &lt;a href=&quot;compile#debug&quot;&gt;SQLITE_DEBUG&lt;/a&gt; compile-time option, then the vdbe_addoptrace pragma can be used to cause a complete VDBE opcodes to be displayed as they are created during code generation. This feature is used for debugging SQLite itself. See the &lt;a href=&quot;vdbe#trace&quot;&gt;VDBE documentation&lt;/a&gt; for more information.</source>
          <target state="translated">Если SQLite был скомпилирован с параметром &lt;a href=&quot;compile#debug&quot;&gt;времени&lt;/a&gt; компиляции SQLITE_DEBUG , то прагма vdbe_addoptrace может использоваться для отображения полных кодов операций VDBE, созданных во время генерации кода. Эта функция используется для отладки самого SQLite. См. &lt;a href=&quot;vdbe#trace&quot;&gt;Документацию VDBE&lt;/a&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="ed1cfc408ef29e4c5084ed94c91a1453ae1e7d68" translate="yes" xml:space="preserve">
          <source>If SQLite has been compiled with the &lt;a href=&quot;compile#debug&quot;&gt;SQLITE_DEBUG&lt;/a&gt; compile-time option, then the vdbe_debug pragma is a shorthand for three other debug-only pragmas: vdbe_addoptrace, vdbe_listing, and vdbe_trace. This feature is used for debugging SQLite itself. See the &lt;a href=&quot;vdbe#trace&quot;&gt;VDBE documentation&lt;/a&gt; for more information.</source>
          <target state="translated">Если SQLite был скомпилирован с параметром &lt;a href=&quot;compile#debug&quot;&gt;времени&lt;/a&gt; компиляции SQLITE_DEBUG , то прагма vdbe_debug является сокращением для трех других прагм, предназначенных только для отладки: vdbe_addoptrace, vdbe_listing и vdbe_trace. Эта функция используется для отладки самого SQLite. См. &lt;a href=&quot;vdbe#trace&quot;&gt;Документацию VDBE&lt;/a&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="1e32eb3dd2a790d29e0b70974d295922571079df" translate="yes" xml:space="preserve">
          <source>If SQLite has been compiled with the &lt;a href=&quot;compile#debug&quot;&gt;SQLITE_DEBUG&lt;/a&gt; compile-time option, then the vdbe_listing pragma can be used to cause a complete listing of the virtual machine opcodes to appear on standard output as each statement is evaluated. With listing is on, the entire content of a program is printed just prior to beginning execution. The statement executes normally after the listing is printed. This feature is used for debugging SQLite itself. See the &lt;a href=&quot;vdbe#trace&quot;&gt;VDBE documentation&lt;/a&gt; for more information.</source>
          <target state="translated">Если SQLite был скомпилирован с параметром &lt;a href=&quot;compile#debug&quot;&gt;времени&lt;/a&gt; компиляции SQLITE_DEBUG , то можно использовать прагму vdbe_listing, чтобы полный список кодов операций виртуальной машины появлялся в стандартном выводе при оценке каждого оператора. Если листинг включен, все содержимое программы распечатывается непосредственно перед началом выполнения. Оператор выполняется нормально после печати листинга. Эта функция используется для отладки самого SQLite. См. &lt;a href=&quot;vdbe#trace&quot;&gt;Документацию VDBE&lt;/a&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="cefc8fedb890f68ef15ff1358f045bdc3b72901b" translate="yes" xml:space="preserve">
          <source>If SQLite has been compiled with the &lt;a href=&quot;compile#debug&quot;&gt;SQLITE_DEBUG&lt;/a&gt; compile-time option, then the vdbe_trace pragma can be used to cause virtual machine opcodes to be printed on standard output as they are evaluated. This feature is used for debugging SQLite. See the &lt;a href=&quot;vdbe#trace&quot;&gt;VDBE documentation&lt;/a&gt; for more information.</source>
          <target state="translated">Если SQLite был скомпилирован с &lt;a href=&quot;compile#debug&quot;&gt;опцией времени&lt;/a&gt; компиляции SQLITE_DEBUG , то можно использовать прагму vdbe_trace, чтобы коды операций виртуальной машины выводились на стандартный вывод по мере их оценки. Эта функция используется для отладки SQLite. См. &lt;a href=&quot;vdbe#trace&quot;&gt;Документацию VDBE&lt;/a&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="5153e53873f4aff61d1f8d367f68545fed69c0e7" translate="yes" xml:space="preserve">
          <source>If SQLite has not been initialized using &lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_initialize()&lt;/a&gt; prior to invoking sqlite3_complete16() then sqlite3_initialize() is invoked automatically by sqlite3_complete16(). If that initialization fails, then the return value from sqlite3_complete16() will be non-zero regardless of whether or not the input SQL is complete.</source>
          <target state="translated">Если SQLite не был инициализирован с помощью &lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_initialize ()&lt;/a&gt; до вызова sqlite3_complete16 (), то sqlite3_initialize () автоматически вызывается sqlite3_complete16 (). Если эта инициализация завершится неудачно, то возвращаемое значение sqlite3_complete16 () будет отличным от нуля, независимо от того, завершен ли входной SQL.</target>
        </trans-unit>
        <trans-unit id="3c965f677e7c54456f9a69dea9325df1caaec3d9" translate="yes" xml:space="preserve">
          <source>If SQLite has not been initialized using &lt;a href=&quot;initialize&quot;&gt;sqlite3_initialize()&lt;/a&gt; prior to invoking sqlite3_complete16() then sqlite3_initialize() is invoked automatically by sqlite3_complete16(). If that initialization fails, then the return value from sqlite3_complete16() will be non-zero regardless of whether or not the input SQL is complete.</source>
          <target state="translated">Если SQLite не был инициализирован с помощью &lt;a href=&quot;initialize&quot;&gt;sqlite3_initialize ()&lt;/a&gt; до вызова sqlite3_complete16 (), то sqlite3_initialize () автоматически вызывается sqlite3_complete16 (). Если эта инициализация завершится неудачно, то возвращаемое значение sqlite3_complete16 () будет отличным от нуля, независимо от того, завершен ли входной SQL.</target>
        </trans-unit>
        <trans-unit id="6d6bbb3059e334920732ba9450708b663008dcc7" translate="yes" xml:space="preserve">
          <source>If SQLite is built with the &lt;a href=&quot;compile#enable_update_delete_limit&quot;&gt;SQLITE_ENABLE_UPDATE_DELETE_LIMIT&lt;/a&gt; compile-time option then the syntax of the UPDATE statement is extended with optional ORDER BY and LIMIT clauses as follows:</source>
          <target state="translated">Если SQLite построен с параметром &lt;a href=&quot;compile#enable_update_delete_limit&quot;&gt;времени&lt;/a&gt; компиляции SQLITE_ENABLE_UPDATE_DELETE_LIMIT, то синтаксис оператора UPDATE расширяется дополнительными предложениями ORDER BY и LIMIT следующим образом:</target>
        </trans-unit>
        <trans-unit id="44ff2e47de1d4a52252bdf0898ff4b68826c3d7a" translate="yes" xml:space="preserve">
          <source>If SQLite is compiled for Windows with the &lt;a href=&quot;compile#win32_malloc&quot;&gt;SQLITE_WIN32_MALLOC&lt;/a&gt; compile-time option, then a different, thin wrapper is used around HeapAlloc(), HeapReAlloc(), and HeapFree(). The thin wrapper uses the configured SQLite heap, which will be different from the default process heap if the &lt;a href=&quot;compile#win32_heap_create&quot;&gt;SQLITE_WIN32_HEAP_CREATE&lt;/a&gt; compile-time option is used. In addition, when an allocation is made or freed, HeapValidate() will be called if SQLite is compiled with assert() enabled and the &lt;a href=&quot;compile#win32_malloc_validate&quot;&gt;SQLITE_WIN32_MALLOC_VALIDATE&lt;/a&gt; compile-time option.</source>
          <target state="translated">Если SQLite скомпилирован для Windows с параметром &lt;a href=&quot;compile#win32_malloc&quot;&gt;времени&lt;/a&gt; компиляции SQLITE_WIN32_MALLOC , то для HeapAlloc (), HeapReAlloc () и HeapFree () используется другая тонкая оболочка. Тонкая оболочка использует настроенную кучу SQLite, которая будет отличаться от кучи процесса по умолчанию, если используется &lt;a href=&quot;compile#win32_heap_create&quot;&gt;параметр времени&lt;/a&gt; компиляции SQLITE_WIN32_HEAP_CREATE . Кроме того, при выделении или освобождении памяти будет вызвана функция HeapValidate (), если SQLite скомпилирован с включенным assert () и параметром &lt;a href=&quot;compile#win32_malloc_validate&quot;&gt;времени&lt;/a&gt; компиляции SQLITE_WIN32_MALLOC_VALIDATE .</target>
        </trans-unit>
        <trans-unit id="517e1af932491e30c32e06c4fd9e534300edd652" translate="yes" xml:space="preserve">
          <source>If SQLite is compiled with &lt;a href=&quot;compile#enable_memsys3&quot;&gt;SQLITE_ENABLE_MEMSYS3&lt;/a&gt; then another zero-malloc memory allocator, similar to memsys5, is included in the source tree. The memsys3 allocator, like memsys5, must be activated by a call to &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigheap&quot;&gt;SQLITE_CONFIG_HEAP&lt;/a&gt;,...). Memsys3 uses the memory buffer supplied as its source for all memory allocations. The difference between memsys3 and memsys5 is that memsys3 uses a different memory allocation algorithm that seems to work well in practice, but which does not provide mathematical guarantees against memory fragmentation and breakdown. Memsys3 was a predecessor to memsys5. The SQLite developers now believe that memsys5 is superior to memsys3 and that all applications that need a zero-malloc memory allocator should use memsys5 in preference to memsys3. Memsys3 is considered both experimental and deprecated and will likely be removed from the source tree in a future release of SQLite.</source>
          <target state="translated">Если SQLite скомпилирован с &lt;a href=&quot;compile#enable_memsys3&quot;&gt;SQLITE_ENABLE_MEMSYS3,&lt;/a&gt; то в дерево исходных текстов включается другой распределитель памяти с нулевым распределением памяти, аналогичный memsys5. Распределитель memsys3, как и memsys5, должен быть активирован вызовом &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt; ( &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigheap&quot;&gt;SQLITE_CONFIG_HEAP&lt;/a&gt;, ...). Memsys3 использует буфер памяти в качестве источника для всех выделений памяти. Разница между memsys3 и memsys5 заключается в том, что memsys3 использует другой алгоритм распределения памяти, который, кажется, хорошо работает на практике, но не дает математических гарантий от фрагментации и сбоя памяти. Memsys3 был предшественником memsys5. Разработчики SQLite теперь считают, что memsys5 превосходит memsys3 и что все приложения, которым требуется распределитель памяти с нулевым распределением памяти, должны использовать memsys5 вместо memsys3. Memsys3 считается экспериментальным и устаревшим и, вероятно, будет удален из дерева исходных текстов в будущих версиях SQLite.</target>
        </trans-unit>
        <trans-unit id="a20ff9c15584045a4ca98d16d24d41c5ba218767" translate="yes" xml:space="preserve">
          <source>If SQLite is compiled with the &lt;a href=&quot;compile#enable_update_delete_limit&quot;&gt;SQLITE_ENABLE_UPDATE_DELETE_LIMIT&lt;/a&gt; compile-time option, then the syntax of the DELETE statement is extended by the addition of optional ORDER BY and LIMIT clauses:</source>
          <target state="translated">Если SQLite скомпилирован с параметром &lt;a href=&quot;compile#enable_update_delete_limit&quot;&gt;времени&lt;/a&gt; компиляции SQLITE_ENABLE_UPDATE_DELETE_LIMIT , то синтаксис оператора DELETE расширяется путем добавления дополнительных предложений ORDER BY и LIMIT:</target>
        </trans-unit>
        <trans-unit id="0e66b56024c7560826b0783e73206c696c2fa3db" translate="yes" xml:space="preserve">
          <source>If SQLite is compiled with the &lt;a href=&quot;compile#memdebug&quot;&gt;SQLITE_MEMDEBUG&lt;/a&gt; compile-time option, then a different, heavy wrapper is used around system malloc(), realloc(), and free(). The heavy wrapper allocates around 100 bytes of extra space with each allocation. The extra space is used to place sentinel values at both ends of the allocation returned to the SQLite core. When an allocation is freed, these sentinels are checked to make sure the SQLite core did not overrun the buffer in either direction. When the system library is GLIBC, the heavy wrapper also makes use of the GNU backtrace() function to examine the stack and record the ancestor functions of the malloc() call. When running the SQLite test suite, the heavy wrapper also records the name of the current test case. These latter two features are useful for tracking down the source of memory leaks detected by the test suite.</source>
          <target state="translated">Если SQLite скомпилирован с &lt;a href=&quot;compile#memdebug&quot;&gt;SQLITE_MEMDEBUG&lt;/a&gt;во время компиляции, то для системных malloc (), realloc () и free () используется другая тяжелая оболочка. Тяжелая оболочка выделяет около 100 байт дополнительного пространства при каждом выделении. Дополнительное пространство используется для размещения контрольных значений на обоих концах выделения, возвращаемого ядру SQLite. Когда выделение освобождается, эти контрольные точки проверяются, чтобы убедиться, что ядро ​​SQLite не переполнило буфер в любом направлении. Когда системной библиотекой является GLIBC, тяжелая оболочка также использует функцию GNU backtrace () для проверки стека и записи функций-предков вызова malloc (). При запуске набора тестов SQLite тяжелая оболочка также записывает имя текущего тестового примера. Эти две последние функции полезны для отслеживания источника утечек памяти, обнаруженных набором тестов.</target>
        </trans-unit>
        <trans-unit id="bdb5f255b340a7c8ea5f9ec1a27271eaa4afef49" translate="yes" xml:space="preserve">
          <source>If SQLite is compiled with the &lt;a href=&quot;compile#zero_malloc&quot;&gt;SQLITE_ZERO_MALLOC&lt;/a&gt; option, then the &lt;a href=&quot;malloc#defaultalloc&quot;&gt;default memory allocator&lt;/a&gt; is omitted and replaced by a stub memory allocator that never allocates any memory. Any calls to the stub memory allocator will report back that no memory is available.</source>
          <target state="translated">Если SQLite скомпилирован с параметром &lt;a href=&quot;compile#zero_malloc&quot;&gt;SQLITE_ZERO_MALLOC&lt;/a&gt; , тогда &lt;a href=&quot;malloc#defaultalloc&quot;&gt;распределитель памяти&lt;/a&gt; по умолчанию опускается и заменяется распределителем памяти-заглушкой, который никогда не выделяет память. Любые вызовы распределителя памяти заглушек сообщат, что памяти нет.</target>
        </trans-unit>
        <trans-unit id="a81969949fdea82f85b5652d9dfeed54c87f7d37" translate="yes" xml:space="preserve">
          <source>If SQLite is compiled with the SQLITE_MUTEX_APPDEF preprocessor macro defined (with &quot;-DSQLITE_MUTEX_APPDEF=1&quot;), then no mutex implementation is included with the library. In this case the application must supply a custom mutex implementation using the &lt;a href=&quot;#sqliteconfigmutex&quot;&gt;SQLITE_CONFIG_MUTEX&lt;/a&gt; option of the sqlite3_config() function before calling sqlite3_initialize() or any other public sqlite3_ function that calls sqlite3_initialize().</source>
          <target state="translated">Если SQLite скомпилирован с определенным макросом препроцессора SQLITE_MUTEX_APPDEF (с &amp;laquo;-DSQLITE_MUTEX_APPDEF = 1&amp;raquo;), то в библиотеку не включается реализация мьютекса. В этом случае приложение должно предоставить настраиваемую реализацию мьютекса с использованием параметра &lt;a href=&quot;#sqliteconfigmutex&quot;&gt;SQLITE_CONFIG_MUTEX&lt;/a&gt; функции sqlite3_config () перед вызовом sqlite3_initialize () или любой другой общедоступной функции sqlite3_, которая вызывает sqlite3_initialize ().</target>
        </trans-unit>
        <trans-unit id="3612fbeb4e5912d3519c058afb830d2ca96819e8" translate="yes" xml:space="preserve">
          <source>If SQLite is compiled with the SQLITE_MUTEX_APPDEF preprocessor macro defined (with &quot;-DSQLITE_MUTEX_APPDEF=1&quot;), then no mutex implementation is included with the library. In this case the application must supply a custom mutex implementation using the &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigmutex&quot;&gt;SQLITE_CONFIG_MUTEX&lt;/a&gt; option of the sqlite3_config() function before calling sqlite3_initialize() or any other public sqlite3_ function that calls sqlite3_initialize().</source>
          <target state="translated">Если SQLite скомпилирован с определенным макросом препроцессора SQLITE_MUTEX_APPDEF (с &amp;laquo;-DSQLITE_MUTEX_APPDEF = 1&amp;raquo;), то в библиотеку не включается реализация мьютекса. В этом случае приложение должно предоставить настраиваемую реализацию мьютекса с использованием параметра &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigmutex&quot;&gt;SQLITE_CONFIG_MUTEX&lt;/a&gt; функции sqlite3_config () перед вызовом sqlite3_initialize () или любой другой общедоступной функции sqlite3_, которая вызывает sqlite3_initialize ().</target>
        </trans-unit>
        <trans-unit id="3e4d7ea4d24bcad6503f112a75cb8cf3b594762c" translate="yes" xml:space="preserve">
          <source>If SQLite is compiled with the THREADSAFE preprocessor macro set to 1, then it is safe to use SQLite from two or more threads of the same process at the same time. But each thread should have its own &lt;b&gt;sqlite*&lt;/b&gt; pointer returned from &lt;b&gt;sqlite_open&lt;/b&gt;. It is never safe for two or more threads to access the same &lt;b&gt;sqlite*&lt;/b&gt; pointer at the same time.</source>
          <target state="translated">Если SQLite скомпилирован с макросом препроцессора THREADSAFE, установленным на 1, тогда безопасно использовать SQLite из двух или более потоков одного и того же процесса одновременно. Но каждый поток должен иметь свой собственный указатель &lt;b&gt;sqlite *,&lt;/b&gt; возвращаемый из &lt;b&gt;sqlite_open&lt;/b&gt; . Никогда не безопасно для двух или более потоков обращаться к одному и тому же указателю &lt;b&gt;sqlite *&lt;/b&gt; одновременно.</target>
        </trans-unit>
        <trans-unit id="710dfc358000c04c6f29b5a8b9d1e58f09170c01" translate="yes" xml:space="preserve">
          <source>If SQLite is working with multiple databases at the same time (using the &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; command) then each database has its own rollback journal. But there is also a separate aggregate journal called the &lt;em&gt;master journal&lt;/em&gt;. The master journal does not contain page data used for rolling back changes. Instead the master journal contains the names of the individual database rollback journals for each of the ATTACHed databases. Each of the individual database rollback journals also contain the name of the master journal. If there are no ATTACHed databases (or if none of the ATTACHed database is participating in the current transaction) no master journal is created and the normal rollback journal contains an empty string in the place normally reserved for recording the name of the master journal.</source>
          <target state="translated">Если SQLite работает с несколькими базами данных одновременно (с помощью команды &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; ), каждая база данных имеет свой собственный журнал отката. Но есть также отдельный сводный журнал, называемый &lt;em&gt;главным журналом&lt;/em&gt; . Главный журнал не содержит данных страниц, используемых для отката изменений. Вместо этого главный журнал содержит имена отдельных журналов отката базы данных для каждой из подключенных баз данных. Каждый из отдельных журналов отката базы данных также содержит имя главного журнала. Если нет подключенных баз данных (или если ни одна из подключенных баз данных не участвует в текущей транзакции), главный журнал не создается, а обычный журнал отката содержит пустую строку в месте, обычно зарезервированном для записи имени главного журнала.</target>
        </trans-unit>
        <trans-unit id="e3d682297850435cbed4a4f23333530d1946cfd2" translate="yes" xml:space="preserve">
          <source>If SQLite is working with multiple databases at the same time (using the &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; command) then each database has its own rollback journal. But there is also a separate aggregate journal called the &lt;em&gt;super-journal&lt;/em&gt;. The super-journal does not contain page data used for rolling back changes. Instead the super-journal contains the names of the individual database rollback journals for each of the ATTACHed databases. Each of the individual database rollback journals also contain the name of the super-journal. If there are no ATTACHed databases (or if none of the ATTACHed database is participating in the current transaction) no super-journal is created and the normal rollback journal contains an empty string in the place normally reserved for recording the name of the super-journal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5896c61835dd6f9792c99d8e8f334dcf5e7f29e5" translate="yes" xml:space="preserve">
          <source>If SQLite needs a page-cache entry that is larger than &quot;sz&quot; bytes or if it needs more than N entries, it falls back to using the general-purpose memory allocator.</source>
          <target state="translated">Если SQLite нужен элемент страничного кэша размером больше &quot;sz&quot; байт или если ему нужно больше N элементов,то он возвращается к использованию аллокатора памяти общего назначения.</target>
        </trans-unit>
        <trans-unit id="4aa68767277ee1001967243f3227f1d8f761e4eb" translate="yes" xml:space="preserve">
          <source>If SQLite recognizes a table as a shadow table, and if the &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigdefensive&quot;&gt;SQLITE_DBCONFIG_DEFENSIVE&lt;/a&gt; flag is set, then the shadow table is read-only for ordinary SQL statements. The shadow table can still be written, but only by SQL that is invoked from within one of the methods of some virtual table implementation.</source>
          <target state="translated">Если SQLite распознает таблицу как теневую и &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigdefensive&quot;&gt;установлен&lt;/a&gt; флаг SQLITE_DBCONFIG_DEFENSIVE , то теневая таблица доступна только для чтения для обычных операторов SQL. Теневая таблица все еще может быть записана, но только с помощью SQL, который вызывается из одного из методов реализации некоторой виртуальной таблицы.</target>
        </trans-unit>
        <trans-unit id="c334cbe953204cf334f3f0300d4576308ac4cfdc" translate="yes" xml:space="preserve">
          <source>If URI filenames are recognized when the database connection is originally opened, then URI filenames will also be recognized on &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; statements. Similarly, if URI filenames are not recognized when the database connection is first opened, they will not be recognized by &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt;.</source>
          <target state="translated">Если имена файлов URI распознаются при первоначальном открытии соединения с базой данных, то имена файлов URI также будут распознаваться в операторах &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; . Точно так же, если имена файлов URI не распознаются при первом открытии соединения с базой данных, они не будут распознаны &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="20f2ccdd4e7b5b66dd50ba0f757be7113d0c9526" translate="yes" xml:space="preserve">
          <source>If W is AND-connected terms and X is OR-connected terms and if any term of W appears as a term of X, then the partial index is usable.</source>
          <target state="translated">Если W является И-связанным термином,а X-ИЛИ-связанным термином,и если какой-либо из терминов W появляется как термин X,то частичный индекс может быть использован.</target>
        </trans-unit>
        <trans-unit id="5ee5624c5ac84e77c145fe142470f12976a4d91a" translate="yes" xml:space="preserve">
          <source>If X is a memory allocation previously obtained from sqlite3_malloc(), sqlite3_malloc64(), sqlite3_realloc(), or sqlite3_realloc64(), then sqlite3_msize(X) returns the size of that memory allocation in bytes. The value returned by sqlite3_msize(X) might be larger than the number of bytes requested when X was allocated. If X is a NULL pointer then sqlite3_msize(X) returns zero. If X points to something that is not the beginning of memory allocation, or if it points to a formerly valid memory allocation that has now been freed, then the behavior of sqlite3_msize(X) is undefined and possibly harmful.</source>
          <target state="translated">Если X-это выделение памяти,ранее полученное с помощью sqlite3_malloc(),sqlite3_malloc64(),sqlite3_realloc()или sqlite3_realloc64(),то sqlite3_msize(X)возвращает размер этого выделения памяти в байтах.Значение,возвращаемое функцией sqlite3_msize(X),может быть больше,чем количество байт,запрашиваемых при выделении X.Если X-указатель NULL,то sqlite3_msize(X)возвращает ноль.Если X указывает на то,что не является началом выделения памяти,или если он указывает на то,что ранее выделенная память была освобождена,то поведение sqlite3_msize(X)является неопределенным и,возможно,вредным.</target>
        </trans-unit>
        <trans-unit id="b1b66964d31ddb28c71bf027a0d38468bda02bb0" translate="yes" xml:space="preserve">
          <source>If X is greater than or equal to zero, go back to step 3.</source>
          <target state="translated">Если Х больше или равно нулю,вернитесь к шагу 3.</target>
        </trans-unit>
        <trans-unit id="b3fb68847c867d6e5aec8b5513dabb7e57278079" translate="yes" xml:space="preserve">
          <source>If X is non-zero, then the virtual table implementation guarantees that if &lt;a href=&quot;../vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; returns &lt;a href=&quot;../rescode#constraint&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt;, it will do so before any modifications to internal or persistent data structures have been made. If the &lt;a href=&quot;../lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt; mode is ABORT, FAIL, IGNORE or ROLLBACK, SQLite is able to roll back a statement or database transaction, and abandon or continue processing the current SQL statement as appropriate. If the ON CONFLICT mode is REPLACE and the &lt;a href=&quot;../vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; method returns &lt;a href=&quot;../rescode#constraint&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt;, SQLite handles this as if the ON CONFLICT mode had been ABORT.</source>
          <target state="translated">Если X не равно нулю, то реализация виртуальной таблицы гарантирует, что если &lt;a href=&quot;../vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; вернет &lt;a href=&quot;../rescode#constraint&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt; , он сделает это до того , как будут внесены какие-либо изменения во внутренние или постоянные структуры данных. Если режим &lt;a href=&quot;../lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt; - ABORT, FAIL, IGNORE или ROLLBACK, SQLite может откатить инструкцию или транзакцию базы данных, а также отказаться или продолжить обработку текущего оператора SQL, если это необходимо. Если режим ON CONFLICT имеет значение REPLACE, а метод &lt;a href=&quot;../vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; возвращает &lt;a href=&quot;../rescode#constraint&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt; , SQLite обрабатывает это, как если бы режим ON CONFLICT был ABORT.</target>
        </trans-unit>
        <trans-unit id="c0b29678a870c29e379cb0f8c76e93d5c6f694fd" translate="yes" xml:space="preserve">
          <source>If X is non-zero, then the virtual table implementation guarantees that if &lt;a href=&quot;vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt;, it will do so before any modifications to internal or persistent data structures have been made. If the &lt;a href=&quot;lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt; mode is ABORT, FAIL, IGNORE or ROLLBACK, SQLite is able to roll back a statement or database transaction, and abandon or continue processing the current SQL statement as appropriate. If the ON CONFLICT mode is REPLACE and the &lt;a href=&quot;vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; method returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt;, SQLite handles this as if the ON CONFLICT mode had been ABORT.</source>
          <target state="translated">Если X не равно нулю, то реализация виртуальной таблицы гарантирует, что если &lt;a href=&quot;vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; вернет &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt; , он сделает это до того , как будут внесены какие-либо изменения во внутренние или постоянные структуры данных. Если режим &lt;a href=&quot;lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt; - ABORT, FAIL, IGNORE или ROLLBACK, SQLite может откатить инструкцию или транзакцию базы данных, а также отказаться или продолжить обработку текущего оператора SQL, если это необходимо. Если режим ON CONFLICT имеет значение REPLACE, а метод &lt;a href=&quot;vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; возвращает &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt; , SQLite обрабатывает это, как если бы режим ON CONFLICT был ABORT.</target>
        </trans-unit>
        <trans-unit id="30772a96ac944f5d807fde7afed09facbb4c72a3" translate="yes" xml:space="preserve">
          <source>If X is the name of a rollback or WAL-mode journal file that is passed into the xOpen method of &lt;a href=&quot;#sqlite3_vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;, then sqlite3_database_file_object(X) returns a pointer to the &lt;a href=&quot;#sqlite3_file&quot;&gt;sqlite3_file&lt;/a&gt; object that represents the main database file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90405f680f9fd6c0b9fd6e8fd54aba076154778a" translate="yes" xml:space="preserve">
          <source>If X starts a transaction that will initially only read but X knows it will eventually want to write and does not want to be troubled with possible SQLITE_BUSY_SNAPSHOT errors that arise because another connection jumped ahead of it in line, then X can issue &lt;a href=&quot;lang_transaction#immediate&quot;&gt;BEGIN IMMEDIATE&lt;/a&gt; to start its transaction instead of just an ordinary BEGIN. The &lt;a href=&quot;lang_transaction#immediate&quot;&gt;BEGIN IMMEDIATE&lt;/a&gt; command goes ahead and starts a write transaction, and thus blocks all other writers. If the &lt;a href=&quot;lang_transaction#immediate&quot;&gt;BEGIN IMMEDIATE&lt;/a&gt; operation succeeds, then no subsequent operations in that transaction will ever fail with an &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; error.</source>
          <target state="translated">Если X запускает транзакцию, которая первоначально будет только читать, но X знает, что она в конечном итоге захочет писать, и не хочет, чтобы его беспокоили возможные ошибки SQLITE_BUSY_SNAPSHOT, которые возникают из-за того, что другое соединение прыгнуло впереди него в строке, тогда X может выдать &lt;a href=&quot;lang_transaction#immediate&quot;&gt;BEGIN IMMEDIATE&lt;/a&gt; для запуска транзакцию вместо обычного BEGIN. Команда &lt;a href=&quot;lang_transaction#immediate&quot;&gt;BEGIN IMMEDIATE&lt;/a&gt; запускает транзакцию записи и, таким образом, блокирует все другие средства записи. Если операция &lt;a href=&quot;lang_transaction#immediate&quot;&gt;BEGIN IMMEDIATE&lt;/a&gt; завершается успешно, то никакие последующие операции в этой транзакции никогда не &lt;a href=&quot;rescode#busy&quot;&gt;завершатся&lt;/a&gt; ошибкой SQLITE_BUSY .</target>
        </trans-unit>
        <trans-unit id="0eea241e4d0bdc37c50e93c325fbb23bd791a257" translate="yes" xml:space="preserve">
          <source>If a &quot;*&quot; character follows a string within an FTS expression, then the final token extracted from the string is marked as a &lt;b&gt;prefix token&lt;/b&gt;. As you might expect, a prefix token matches any document token of which it is a prefix. For example, the first two queries in the following block will match any document that contains the token &quot;one&quot; immediately followed by the token &quot;two&quot; and then any token that begins with &quot;thr&quot;.</source>
          <target state="translated">Если за строкой в ​​выражении FTS следует символ &amp;laquo;*&amp;raquo;, то последний токен, извлеченный из строки, помечается как &lt;b&gt;префиксный токен&lt;/b&gt; . Как и следовало ожидать, токен префикса соответствует любому токену документа, префиксом которого он является. Например, первые два запроса в следующем блоке будут соответствовать любому документу, который содержит токен &amp;laquo;один&amp;raquo;, сразу за которым следует токен &amp;laquo;два&amp;raquo;, а затем любой токен, который начинается с &amp;laquo;thr&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="3fc71a5654e7dbcda099553445308929a409041e" translate="yes" xml:space="preserve">
          <source>If a &quot;DROP TABLE&quot; or &quot;DROP INDEX&quot; SQL command is executed, and the same database connection currently has one or more actively executing SELECT statements, then SQLITE_LOCKED is returned. If &lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify()&lt;/a&gt; is called in this case, then the specified callback will be invoked immediately. Re-attempting the &quot;DROP TABLE&quot; or &quot;DROP INDEX&quot; statement will return another SQLITE_LOCKED error. In the implementation of sqlite3_blocking_step() shown to the left, this could cause an infinite loop.</source>
          <target state="translated">Если выполняется команда SQL &amp;laquo;DROP TABLE&amp;raquo; или &amp;laquo;DROP INDEX&amp;raquo;, и то же соединение с базой данных в настоящее время имеет один или несколько активно выполняющихся операторов SELECT, то возвращается SQLITE_LOCKED. Если в этом случае вызывается &lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify ()&lt;/a&gt; , то указанный обратный вызов будет вызван немедленно. Повторная попытка выполнения оператора &amp;laquo;DROP TABLE&amp;raquo; или &amp;laquo;DROP INDEX&amp;raquo; вернет еще одну ошибку SQLITE_LOCKED. В реализации sqlite3_blocking_step (), показанной слева, это могло вызвать бесконечный цикл.</target>
        </trans-unit>
        <trans-unit id="12bc34a5236123febe1cd1188da174890c26f97b" translate="yes" xml:space="preserve">
          <source>If a &quot;^&quot; character appears immediately before a phrase that is not part of a NEAR query, then that phrase only matches a document only if it starts at the first token in a column. The &quot;^&quot; syntax may be combined with a &lt;a href=&quot;fts5#fts5_column_filters&quot;&gt;column filter&lt;/a&gt;, but may not be inserted into the middle of a phrase.</source>
          <target state="translated">Если символ &amp;laquo;^&amp;raquo; появляется непосредственно перед фразой, которая не является частью запроса NEAR, то эта фраза соответствует документу только в том случае, если она начинается с первого токена в столбце. Синтаксис &amp;laquo;^&amp;raquo; можно комбинировать с &lt;a href=&quot;fts5#fts5_column_filters&quot;&gt;фильтром столбца&lt;/a&gt; , но нельзя вставлять в середину фразы.</target>
        </trans-unit>
        <trans-unit id="73147d85cef7d3f5b1649d52c7fae3bdc6d30054" translate="yes" xml:space="preserve">
          <source>If a &quot;create file&quot; operation is executed by SQLite, and then the created file</source>
          <target state="translated">Если операция &quot;создать файл&quot; выполняется SQLite,то созданный файл</target>
        </trans-unit>
        <trans-unit id="84d99b586ac4808874504752037c1f68b1dc681c" translate="yes" xml:space="preserve">
          <source>If a &quot;truncate file&quot; operation is executed by SQLite, and then the truncated file</source>
          <target state="translated">Если операция &quot;Усеченный файл&quot; выполняется SQLite,а затем усеченный файл</target>
        </trans-unit>
        <trans-unit id="a177cd3b97251df1bda061d91a729d6e25be393e" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;../wal#walfile&quot;&gt;WAL file&lt;/a&gt; remains on disk after all database connections close (either through the use of the &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlpersistwal&quot;&gt;SQLITE_FCNTL_PERSIST_WAL&lt;/a&gt;&lt;a href=&quot;file_control&quot;&gt;file control&lt;/a&gt; or because the last process to have the database opened exited without calling &lt;a href=&quot;close&quot;&gt;sqlite3_close()&lt;/a&gt;) and a new connection is subsequently opened on that database and &lt;a href=&quot;../wal#walfile&quot;&gt;WAL file&lt;/a&gt;, the &lt;a href=&quot;snapshot_open&quot;&gt;sqlite3_snapshot_open()&lt;/a&gt; interface will only be able to open the last transaction added to the WAL file even though the WAL file contains other valid transactions.</source>
          <target state="translated">Если &lt;a href=&quot;../wal#walfile&quot;&gt;файл WAL&lt;/a&gt; остается на диске после закрытия всех подключений к базе данных (либо с помощью &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlpersistwal&quot;&gt;файлового элемента &lt;/a&gt;&lt;a href=&quot;file_control&quot;&gt;управления &lt;/a&gt;SQLITE_FCNTL_PERSIST_WAL, либо из-за того, что последний процесс, открывший базу данных, завершился без вызова &lt;a href=&quot;close&quot;&gt;sqlite3_close ()&lt;/a&gt; ), а затем с этой базой данных открывается новое соединение и &lt;a href=&quot;../wal#walfile&quot;&gt;WAL&lt;/a&gt; , интерфейс &lt;a href=&quot;snapshot_open&quot;&gt;sqlite3_snapshot_open ()&lt;/a&gt; сможет открыть только последнюю транзакцию, добавленную в файл WAL, даже если файл WAL содержит другие допустимые транзакции.</target>
        </trans-unit>
        <trans-unit id="ce5e78d94d5947b9e328c1516e3f265b0f48637a" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; is generated from &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; then the statement is automatically re-prepared if the schema changes, up to &lt;a href=&quot;compile#max_schema_retry&quot;&gt;SQLITE_MAX_SCHEMA_RETRY&lt;/a&gt; times (default: 50). The &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; interface will only return SQLITE_SCHEMA back to the application if the failure persists after these many retries.</source>
          <target state="translated">Если &lt;a href=&quot;c3ref/stmt&quot;&gt;подготовленный оператор&lt;/a&gt; генерируется из &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2 (),&lt;/a&gt; тогда оператор автоматически повторно готовится, если схема изменяется, до &lt;a href=&quot;compile#max_schema_retry&quot;&gt;SQLITE_MAX_SCHEMA_RETRY&lt;/a&gt; раз (по умолчанию: 50). Интерфейс &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step ()&lt;/a&gt; вернет SQLITE_SCHEMA обратно приложению только в том случае, если сбой сохраняется после этих многочисленных попыток.</target>
        </trans-unit>
        <trans-unit id="3249186023e31b2ef81a917670edb42184c4e1e6" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt; operation occurs on the same &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; as a pending read or write, then the pending read or write may fail with an SQLITE_ABORT or &lt;a href=&quot;rescode#abort_rollback&quot;&gt;SQLITE_ABORT_ROLLBACK&lt;/a&gt; error.</source>
          <target state="translated">Если операция &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt; происходит в том же &lt;a href=&quot;c3ref/sqlite3&quot;&gt;соединении с базой данных,&lt;/a&gt; что и ожидающее чтение или запись, то ожидающее чтение или запись может завершиться ошибкой SQLITE_ABORT или &lt;a href=&quot;rescode#abort_rollback&quot;&gt;SQLITE_ABORT_ROLLBACK&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a092e1c1463db0502720c4f04f6df73156ddbd46" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;wal#walfile&quot;&gt;WAL file&lt;/a&gt; remains on disk after all database connections close (either through the use of the &lt;a href=&quot;#sqlitefcntlpersistwal&quot;&gt;SQLITE_FCNTL_PERSIST_WAL&lt;/a&gt;&lt;a href=&quot;#sqlite3_file_control&quot;&gt;file control&lt;/a&gt; or because the last process to have the database opened exited without calling &lt;a href=&quot;#sqlite3_close&quot;&gt;sqlite3_close()&lt;/a&gt;) and a new connection is subsequently opened on that database and &lt;a href=&quot;wal#walfile&quot;&gt;WAL file&lt;/a&gt;, the &lt;a href=&quot;#sqlite3_snapshot_open&quot;&gt;sqlite3_snapshot_open()&lt;/a&gt; interface will only be able to open the last transaction added to the WAL file even though the WAL file contains other valid transactions.</source>
          <target state="translated">Если &lt;a href=&quot;wal#walfile&quot;&gt;файл WAL&lt;/a&gt; остается на диске после закрытия всех подключений к базе данных (либо с помощью &lt;a href=&quot;#sqlitefcntlpersistwal&quot;&gt;файлового элемента &lt;/a&gt;&lt;a href=&quot;#sqlite3_file_control&quot;&gt;управления &lt;/a&gt;SQLITE_FCNTL_PERSIST_WAL, либо из-за того, что последний процесс, открывший базу данных, завершился без вызова &lt;a href=&quot;#sqlite3_close&quot;&gt;sqlite3_close ()&lt;/a&gt; ), а затем с этой базой данных открывается новое соединение и &lt;a href=&quot;wal#walfile&quot;&gt;WAL&lt;/a&gt; , интерфейс &lt;a href=&quot;#sqlite3_snapshot_open&quot;&gt;sqlite3_snapshot_open ()&lt;/a&gt; сможет открыть только последнюю транзакцию, добавленную в файл WAL, даже если файл WAL содержит другие допустимые транзакции.</target>
        </trans-unit>
        <trans-unit id="fa0658f406309a7c36c783a199e98aa7bfe2c3be" translate="yes" xml:space="preserve">
          <source>If a BEFORE UPDATE or BEFORE DELETE trigger modifies or deletes a row that was to have been updated or deleted, then the result of the subsequent update or delete operation is undefined. Furthermore, if a BEFORE trigger modifies or deletes a row, then it is undefined whether or not AFTER triggers that would have otherwise run on those rows will in fact run.</source>
          <target state="translated">Если триггер BEFORE UPDATE или BEFORE DELETE изменяет или удаляет строку,которая должна была быть обновлена или удалена,то результат последующей операции обновления или удаления не определяется.Более того,если триггер BEFORE изменяет или удаляет строку,то не определено,будут ли на самом деле выполняться триггеры,которые в противном случае должны были бы выполняться на этих строках.</target>
        </trans-unit>
        <trans-unit id="a3ab52a71f2c1fab71f9f4f7d4dd870ab7b02c55" translate="yes" xml:space="preserve">
          <source>If a COMMIT statement (or the RELEASE of a transaction SAVEPOINT) fails because the database is currently in a state that violates a deferred foreign key constraint and there are currently &lt;a href=&quot;lang_savepoint&quot;&gt;nested savepoints&lt;/a&gt;, the nested savepoints remain open.</source>
          <target state="translated">Если оператор COMMIT (или RELEASE транзакции SAVEPOINT) завершается неудачно, потому что база данных в настоящее время находится в состоянии, которое нарушает ограничение отложенного внешнего ключа, и в настоящее время существуют &lt;a href=&quot;lang_savepoint&quot;&gt;вложенные точки сохранения&lt;/a&gt; , вложенные точки сохранения остаются открытыми.</target>
        </trans-unit>
        <trans-unit id="4862567128635ae0bf91b3eee8827f7e081e0187" translate="yes" xml:space="preserve">
          <source>If a DELETE statement has a LIMIT clause, the maximum number of rows that will be deleted is found by evaluating the accompanying expression and casting it to an integer value. If the result of the evaluating the LIMIT clause cannot be losslessly converted to an integer value, it is an error. A negative LIMIT value is interpreted as &quot;no limit&quot;. If the DELETE statement also has an OFFSET clause, then it is similarly evaluated and cast to an integer value. Again, it is an error if the value cannot be losslessly converted to an integer. If there is no OFFSET clause, or the calculated integer value is negative, the effective OFFSET value is zero.</source>
          <target state="translated">Если оператор DELETE имеет выражение LIMIT,максимальное количество строк,которые будут удалены,будет найдено путем вычисления сопровождающего выражения и приведения его к целому значению.Если результат вычисления выражения LIMIT не может быть без потерь преобразован в целое значение,это является ошибкой.Отрицательное значение LIMIT интерпретируется как &quot;нет предела&quot;.Если оператор DELETE также имеет условие OFFSET,то он вычисляется аналогичным образом и приводится к целому значению.Опять же,это ошибка,если значение не может быть без потерь преобразовано в целое число.Если отсутствует выражение OFFSET или вычисленное целое значение имеет отрицательное значение,то эффективное значение OFFSET равно нулю.</target>
        </trans-unit>
        <trans-unit id="a8ebe41fb4265f7abee56db5ee7b5c4f78f4ea2f" translate="yes" xml:space="preserve">
          <source>If a FILTER clause is provided, then only rows for which the</source>
          <target state="translated">Если предусмотрено условие FILTER,то только те строки,для которых</target>
        </trans-unit>
        <trans-unit id="94816fac33b04eac89bfe331f82f9493ef356c93" translate="yes" xml:space="preserve">
          <source>If a FROM clause is specified, the data on which a simple SELECT query operates comes from the one or more tables or subqueries (SELECT statements in parentheses) specified following the FROM keyword. A subquery specified in the table-or-subquery following the FROM clause in a simple SELECT statement is handled as if it was a table containing the data returned by executing the subquery statement. Each column of the subquery has the &lt;a href=&quot;datatype3#collation&quot;&gt;collation sequence&lt;/a&gt; and &lt;a href=&quot;datatype3#affinity&quot;&gt;affinity&lt;/a&gt; of the corresponding expression in the subquery statement.</source>
          <target state="translated">Если указано предложение FROM, данные, с которыми работает простой запрос SELECT, берутся из одной или нескольких таблиц или подзапросов (операторы SELECT в скобках), указанных после ключевого слова FROM. Подзапрос, указанный в таблице или подзапросе, следующей за предложением FROM в простом операторе SELECT, обрабатывается так, как если бы это была таблица, содержащая данные, возвращенные при выполнении оператора подзапроса. Каждый столбец подзапроса имеет &lt;a href=&quot;datatype3#collation&quot;&gt;последовательность сортировки&lt;/a&gt; и &lt;a href=&quot;datatype3#affinity&quot;&gt;сродство&lt;/a&gt; соответствующего выражения в операторе подзапросов.</target>
        </trans-unit>
        <trans-unit id="257e2a863a3526135a72b7350cb70ec4620d0ce5" translate="yes" xml:space="preserve">
          <source>If a HAVING clause is specified, it is evaluated once for each group of rows as a &lt;a href=&quot;lang_expr#booleanexpr&quot;&gt;boolean expression&lt;/a&gt;. If the result of evaluating the HAVING clause is false, the group is discarded. If the HAVING clause is an aggregate expression, it is evaluated across all rows in the group. If a HAVING clause is a non-aggregate expression, it is evaluated with respect to an arbitrarily selected row from the group. The HAVING expression may refer to values, even aggregate functions, that are not in the result.</source>
          <target state="translated">Если указано предложение HAVING, оно оценивается один раз для каждой группы строк как &lt;a href=&quot;lang_expr#booleanexpr&quot;&gt;логическое выражение&lt;/a&gt; . Если результат оценки предложения HAVING ложный, группа отбрасывается. Если предложение HAVING является агрегатным выражением, оно оценивается по всем строкам в группе. Если предложение HAVING является неагрегатным выражением, оно оценивается относительно произвольно выбранной строки из группы. Выражение HAVING может относиться к значениям, даже агрегатным функциям, которых нет в результате.</target>
        </trans-unit>
        <trans-unit id="30445e74b001ab802719baf4ad36071ade7519f0" translate="yes" xml:space="preserve">
          <source>If a LIMIT clause is present, it might be possible to avoid scanning the entire table.</source>
          <target state="translated">При наличии пункта LIMIT,возможно,удастся избежать сканирования всей таблицы.</target>
        </trans-unit>
        <trans-unit id="948b4ac14d2baa3362d0ca28f059b73564c6f3e7" translate="yes" xml:space="preserve">
          <source>If a Linux &lt;a href=&quot;http://en.wikipedia.org/wiki/Ext3&quot;&gt;ext3&lt;/a&gt; filesystem is mounted without the &quot;barrier=1&quot; option in the &lt;a href=&quot;http://en.wikipedia.org/wiki/fstab&quot;&gt;/etc/fstab&lt;/a&gt; and the disk drive write cache is enabled then filesystem corruption can occur following a power loss or OS crash. Whether or not corruption can occur depends on the details of the disk control hardware; corruption is more likely with inexpensive consumer-grade disks and less of a problem for enterprise-class storage devices with advanced features such as non-volatile write caches. Various ext3 experts &lt;a href=&quot;http://www.redhat.com/archives/ext3-users/2010-July/msg00001.html&quot;&gt; confirm this behavior&lt;/a&gt;. We are told that most Linux distributions do not use barrier=1 and do not disable the write cache so most Linux distributions are vulnerable to this problem. Note that this is an operating system and hardware issue and that there is nothing that SQLite can do to work around it. &lt;a href=&quot;http://ozlabs.org/~rusty/index.cgi/tech/2009-10-20.html&quot;&gt; Other database engines&lt;/a&gt; have also run into this same problem.</source>
          <target state="translated">Если файловая система Linux &lt;a href=&quot;http://en.wikipedia.org/wiki/Ext3&quot;&gt;ext3&lt;/a&gt; смонтирована без параметра &quot;барьер = 1&quot; в &lt;a href=&quot;http://en.wikipedia.org/wiki/fstab&quot;&gt;файле / etc / fstab&lt;/a&gt; и включен кэш записи на диск, то повреждение файловой системы может произойти после потери питания или сбоя ОС. Может ли произойти повреждение, зависит от деталей оборудования управления диском; повреждение более вероятно с недорогими дисками потребительского уровня и меньше проблем для устройств хранения корпоративного класса с расширенными функциями, такими как энергонезависимые кэши записи. Различные эксперты ext3 &lt;a href=&quot;http://www.redhat.com/archives/ext3-users/2010-July/msg00001.html&quot;&gt;подтверждают такое поведение&lt;/a&gt;. Нам говорят, что в большинстве дистрибутивов Linux не используется ограничение = 1 и не отключается кэш записи, поэтому большинство дистрибутивов Linux уязвимы для этой проблемы. Обратите внимание, что это проблема операционной системы и оборудования, и SQLite ничего не может сделать для ее решения. &lt;a href=&quot;http://ozlabs.org/~rusty/index.cgi/tech/2009-10-20.html&quot;&gt;Другие движки баз данных&lt;/a&gt; также столкнулись с той же проблемой.</target>
        </trans-unit>
        <trans-unit id="99b0a8e8602a0a06983153315092cfd9796ad41e" translate="yes" xml:space="preserve">
          <source>If a NOT NULL constraint is specified, then the column must have a default value other than NULL.</source>
          <target state="translated">Если указано ограничение NOT NULL,то столбец должен иметь значение по умолчанию,отличное от NULL.</target>
        </trans-unit>
        <trans-unit id="55be5a331b8cf28f9f746d3f7eb6341aa17eff02" translate="yes" xml:space="preserve">
          <source>If a SELECT query contains an ORDER BY, GROUP BY or DISTINCT clause, SQLite may need to use a temporary b-tree structure to sort the output rows. Or, it might &lt;a href=&quot;queryplanner#sorting&quot;&gt;use an index&lt;/a&gt;. Using an index is almost always much more efficient than performing a sort. If a temporary b-tree is required, a record is added to the EXPLAIN QUERY PLAN output with the &quot;detail&quot; field set to a string value of the form &quot;USE TEMP B-TREE FOR xxx&quot;, where xxx is one of &quot;ORDER BY&quot;, &quot;GROUP BY&quot; or &quot;DISTINCT&quot;. For example:</source>
          <target state="translated">Если запрос SELECT содержит предложение ORDER BY, GROUP BY или DISTINCT, SQLite может потребоваться использовать временную структуру b-дерева для сортировки выходных строк. Или он может &lt;a href=&quot;queryplanner#sorting&quot;&gt;использовать index&lt;/a&gt; . Использование индекса почти всегда намного эффективнее, чем выполнение сортировки. Если требуется временное b-дерево, к выходным данным EXPLAIN QUERY PLAN добавляется запись с полем &quot;detail&quot;, установленным на строковое значение формы &quot;USE TEMP B-TREE FOR xxx&quot;, где xxx - одно из &quot;ORDER&quot; ПО &quot;,&quot; ГРУППА ПО &quot;или&quot; ОТЛИЧИТЕЛЬНО &quot;. Например:</target>
        </trans-unit>
        <trans-unit id="5b44dbe4fb9e1c6ef0606b8af702048ca0e438cc" translate="yes" xml:space="preserve">
          <source>If a SELECT statement that returns more than one row does not have an ORDER BY clause, the order in which the rows are returned is undefined. Or, if a SELECT statement does have an ORDER BY clause, then the list of expressions attached to the ORDER BY determine the order in which rows are returned to the user.</source>
          <target state="translated">Если оператор SELECT,возвращающий более одной строки,не имеет пункта ORDER BY,порядок,в котором возвращаются строки,не определен.Или,если оператор SELECT имеет пункт ORDER BY,то список выражений,приложенный к оператору ORDER BY,определяет порядок,в котором строки возвращаются пользователю.</target>
        </trans-unit>
        <trans-unit id="1b3cef981ef6c33ad4faa712cdaf3b903f15861f" translate="yes" xml:space="preserve">
          <source>If a UNION operator connects the initial-select with the recursive-select, then only add rows to the queue if no identical row has been previously added to the queue. Repeated rows are discarded before being added to the queue even if the repeated rows have already been extracted from the queue by the recursion step. If the operator is UNION ALL, then all rows generated by both the initial-select and the recursive-select are always added to the queue even if they are repeats. When determining if a row is repeated, NULL values compare equal to one another and not equal to any other value.</source>
          <target state="translated">Если оператор UNION соединяет начальный выбор с рекурсивным,то добавлять строки в очередь можно только в том случае,если ранее в очередь не было добавлено ни одной идентичной строки.Повторяющиеся строки отбрасываются перед добавлением в очередь,даже если повторяющиеся строки уже были извлечены из очереди по шагу рекурсии.Если оператор UNION ALL,то все строки,сгенерированные как начальным выбором,так и рекурсивным,всегда добавляются в очередь,даже если они повторяются.При определении,повторяется ли строка,NULL-значения сравниваются,равные друг другу и не равные никакому другому значению.</target>
        </trans-unit>
        <trans-unit id="56d92b47e4081e5a6e548ebb6f898e186d052899" translate="yes" xml:space="preserve">
          <source>If a WHEN clause is supplied, the SQL statements specified are only executed if the WHEN clause is true. If no WHEN clause is supplied, the SQL statements are executed every time the trigger fires.</source>
          <target state="translated">Если поставляется условие WHEN,то указанные SQL-операторы выполняются только в том случае,если условие WHEN верно.Если же условие WHEN отсутствует,то SQL-операторы выполняются каждый раз при срабатывании триггера.</target>
        </trans-unit>
        <trans-unit id="85a070271019d9b24039a7b30649256cb4c49fd9" translate="yes" xml:space="preserve">
          <source>If a WHERE clause is specified, the WHERE expression is evaluated for each row in the input data as a &lt;a href=&quot;lang_expr#booleanexpr&quot;&gt;boolean expression&lt;/a&gt;. Only rows for which the WHERE clause expression evaluates to true are included from the dataset before continuing. Rows are excluded from the result if the WHERE clause evaluates to either false or NULL.</source>
          <target state="translated">Если указано предложение WHERE, выражение WHERE оценивается для каждой строки входных данных как &lt;a href=&quot;lang_expr#booleanexpr&quot;&gt;логическое выражение&lt;/a&gt; . Перед продолжением из набора данных включаются только строки, для которых выражение предложения WHERE имеет значение true. Строки исключаются из результата, если предложение WHERE принимает значение false или NULL.</target>
        </trans-unit>
        <trans-unit id="99314068471e46954e8f897765afda682981e6bc" translate="yes" xml:space="preserve">
          <source>If a build of SQLite does not include the FTS modules, then any attempt to prepare an SQL statement to create an FTS3 or FTS4 table or to drop or access an existing FTS table in any way will fail. The error message returned will be similar to &quot;no such module: ftsN&quot; (where N is either 3 or 4).</source>
          <target state="translated">Если сборка SQLite не включает в себя модули FTS,то любая попытка подготовить SQL-оператор для создания таблицы FTS3 или FTS4 или бросить существующую таблицу FTS или получить к ней доступ каким-либо образом будет безуспешной.Возвращаемое сообщение об ошибке будет похоже на &quot;нет такого модуля:ftsN&quot; (где N-3 или 4).</target>
        </trans-unit>
        <trans-unit id="c07dc39ee71e6a6e8537165278b706aabd6e81bd" translate="yes" xml:space="preserve">
          <source>If a call to sqlite3_step() that attempts to write to a database table returns SQLITE_LOCKED, then more than one other connection may be holding a read-lock on the database table in question. In this case SQLite simply selects one of those other connections arbitrarily and issues the unlock-notify callback when that connection's transaction is finished. Whether the call to sqlite3_step() was blocked by one or many connections, when the corresponding unlock-notify callback is issued it is not guaranteed that the required lock is available, only that it may be.</source>
          <target state="translated">Если при вызове sqlite3_step(),который пытается записать в таблицу БД,возвращается SQLITE_LOCKED,то в рассматриваемой таблице БД может находиться несколько других соединений,которые удерживают блокировку на чтение.В этом случае SQLite просто произвольно выбирает одно из этих других соединений и по завершении транзакции этого соединения выдает обратный вызов с уведомлением о разблокировке.Был ли вызов sqlite3_step()заблокирован одним или несколькими соединениями,при соответствующем обратном вызове unlock-notify не гарантируется,что требуемая блокировка доступна,а только то,что она может быть.</target>
        </trans-unit>
        <trans-unit id="12e866adc40a794d5a50cd7647771628a0fe472b" translate="yes" xml:space="preserve">
          <source>If a character specified as part of the argument to &quot;tokenchars=&quot; is considered to be a token character by default, it is ignored. This is true even if it has been marked as a separator by an earlier &quot;separators=&quot; option. Similarly, if a character specified as part of a &quot;separators=&quot; option is treated as a separator character by default, it is ignored. If multiple &quot;tokenchars=&quot; or &quot;separators=&quot; options are specified, all are processed. For example:</source>
          <target state="translated">Если символ,указанный в аргументе &quot;tokenchars=&quot;,по умолчанию считается символом токена,то он игнорируется.Это справедливо,даже если он был помечен как разделитель более ранней опцией &quot;separators=&quot;.Аналогично,если символ,указанный как часть опции &quot;separators=&quot;,по умолчанию рассматривается как символ-разделитель,то он игнорируется.Если указано несколько опций &quot;tokenchars=&quot; или &quot;separators=&quot;,то все они будут обработаны.Например:</target>
        </trans-unit>
        <trans-unit id="4047a69992390b90bb1e651abb363899dad3ce20" translate="yes" xml:space="preserve">
          <source>If a collating function fails any of the above constraints and that collating function is registered and used, then the behavior of SQLite is undefined.</source>
          <target state="translated">Если функция коллатинга не справляется с любым из вышеперечисленных ограничений и эта функция коллатинга регистрируется и используется,то поведение SQLite не определено.</target>
        </trans-unit>
        <trans-unit id="4a25d30fe6f01a94e32b9a3c4b8ab96f2806f18f" translate="yes" xml:space="preserve">
          <source>If a column datatype contains the special keyword &quot;HIDDEN&quot; (in any combination of upper and lower case letters) then that keyword it is omitted from the column datatype name and the column is marked as a hidden column internally. A hidden column differs from a normal column in three respects:</source>
          <target state="translated">Если тип данных столбца содержит специальное ключевое слово &quot;HIDDEN&quot; (в любой комбинации заглавных и строчных букв),то это ключевое слово опускается из названия типа данных столбца и столбец помечается как скрытый внутри него.Скрытый столбец отличается от обычного в трех отношениях:</target>
        </trans-unit>
        <trans-unit id="4a3060f5f06633a8fd81221c196cda03a0efe5c5" translate="yes" xml:space="preserve">
          <source>If a column filter specification is preceded by a &quot;-&quot; character, then it is interpreted as a list of column not to match against. For example:</source>
          <target state="translated">Если спецификации фильтра по столбцам предшествует символ &quot;-&quot;,то он интерпретируется как список столбцов,которым не соответствует.Например:</target>
        </trans-unit>
        <trans-unit id="4784be250e1d29a9c62d93440a67186e8f2d433e" translate="yes" xml:space="preserve">
          <source>If a column has the type INTEGER PRIMARY KEY AUTOINCREMENT then a slightly different ROWID selection algorithm is used. The ROWID chosen for the new row is at least one larger than the largest ROWID that has ever before existed in that same table. If the table has never before contained any data, then a ROWID of 1 is used. If the largest possible ROWID has previously been inserted, then new INSERTs are not allowed and any attempt to insert a new row will fail with an SQLITE_FULL error. Only ROWID values from previous transactions that were committed are considered. ROWID values that were rolled back are ignored and can be reused.</source>
          <target state="translated">Если колонка имеет тип INTEGER PRIMARY KEY AUTOINCREMENT,то используется немного другой алгоритм выбора ROWID.ROWID,выбранный для новой строки,по крайней мере,на один больше,чем самый большой ROWID,который когда-либо существовал в той же самой таблице.Если таблица никогда раньше не содержала данных,то используется ROWID равный 1.Если ранее был вставлен самый большой ROWID,то новые INSERT не разрешены и любая попытка вставить новую строку будет неудачной с ошибкой SQLITE_FULL.Учитываются только значения ROWID из предыдущих транзакций,которые были зафиксированы.Значения ROWID,которые были откачены,игнорируются и могут быть использованы повторно.</target>
        </trans-unit>
        <trans-unit id="85779fa11fd249fc0a9433b1c9e912b143d1abd7" translate="yes" xml:space="preserve">
          <source>If a column-name list follows the view-name, then that list determines the names of the columns for the view. If the column-name list is omitted, then the names of the columns in the view are derived from the names of the result-set columns in the &lt;a href=&quot;syntax/select-stmt&quot;&gt;select-stmt&lt;/a&gt;. The use of column-name list is recommended. Or, if column-name list is omitted, then the result columns in the &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statement that defines the view should have well-defined names using the &quot;&lt;a href=&quot;syntax/result-column&quot;&gt;AS column-alias&lt;/a&gt;&quot; syntax. SQLite allows you to create views that depend on automatically generated column names, but you should avoid using them since the rules used to generate column names are not a defined part of the interface and might change in future releases of SQLite.</source>
          <target state="translated">Если список имен столбцов следует за именем представления, то этот список определяет имена столбцов для представления. Если список имен столбцов опущен, тогда имена столбцов в представлении являются производными от имен столбцов набора результатов в &lt;a href=&quot;syntax/select-stmt&quot;&gt;select-stmt&lt;/a&gt; . Рекомендуется использовать список имен столбцов. Или, если список имен столбцов опущен, тогда столбцы результатов в &lt;a href=&quot;lang_select&quot;&gt;операторе SELECT&lt;/a&gt; , определяющем представление, должны иметь четко определенные имена с использованием синтаксиса &amp;laquo; &lt;a href=&quot;syntax/result-column&quot;&gt;псевдоним столбца AS&lt;/a&gt; &amp;raquo;. SQLite позволяет создавать представления, которые зависят от автоматически сгенерированных имен столбцов, но вам следует избегать их использования, поскольку правила, используемые для генерации имен столбцов, не являются определенной частью интерфейса и могут измениться в будущих выпусках SQLite.</target>
        </trans-unit>
        <trans-unit id="7f7aaafed42977493a2413f4303512821df4e3b2" translate="yes" xml:space="preserve">
          <source>If a conflict handler returns this value no special action is taken. The change that caused the conflict is not applied. The session module continues to the next change in the changeset.</source>
          <target state="translated">Если обработчик конфликта возвращает это значение,никаких специальных действий не предпринимается.Изменение,которое вызвало конфликт,не применяется.Сеансовый модуль переходит к следующему изменению в changeset.</target>
        </trans-unit>
        <trans-unit id="a40b2d39f56dad1b134a26af2fe2ae696281adc1" translate="yes" xml:space="preserve">
          <source>If a covering index can be used for a query, then the multiple rowid lookups can be avoided and the cost of the query drops dramatically.</source>
          <target state="translated">Если для запроса можно использовать индекс покрытия,то можно избежать многократного поиска и стоимость запроса резко падает.</target>
        </trans-unit>
        <trans-unit id="653b4381ff1ad3607fbc3061d7b4f5d80ed74deb" translate="yes" xml:space="preserve">
          <source>If a crash or power failure occurs and results in a hot journal but that journal is deleted, the next process to open the database will not know that it contains changes that need to be rolled back. The rollback will not occur and the database will be left in an inconsistent state. Rollback journals might be deleted for any number of reasons:</source>
          <target state="translated">Если произойдет авария или сбой электропитания и в результате будет создан &quot;горячий&quot; журнал,но этот журнал будет удален,то следующий процесс открытия базы данных не будет знать о том,что в ней содержатся изменения,которые необходимо откатить.Откат не произойдет,и база данных останется в непоследовательном состоянии.Откатные журналы могут быть удалены по любой причине:</target>
        </trans-unit>
        <trans-unit id="dbc53ced19579b45a05b723b3063167292a44232" translate="yes" xml:space="preserve">
          <source>If a crash or power loss does occur and a hot journal is left on the disk, it is essential that the original database file and the hot journal remain on disk with their original names until the database file is opened by another SQLite process and rolled back. During recovery at &lt;a href=&quot;#section_4_2&quot;&gt;step 4.2&lt;/a&gt; SQLite locates the hot journal by looking for a file in the same directory as the database being opened and whose name is derived from the name of the file being opened. If either the original database file or the hot journal have been moved or renamed, then the hot journal will not be seen and the database will not be rolled back.</source>
          <target state="translated">Если происходит сбой или отключение питания и на диске остается горячий журнал, важно, чтобы исходный файл базы данных и горячий журнал оставались на диске с их исходными именами до тех пор, пока файл базы данных не будет открыт другим процессом SQLite и откат . Во время восстановления на &lt;a href=&quot;#section_4_2&quot;&gt;шаге 4.2&lt;/a&gt; SQLite находит &amp;laquo;горячий журнал&amp;raquo;, ища файл в том же каталоге, что и открываемая база данных, имя которого происходит от имени открываемого файла. Если исходный файл базы данных или горячий журнал были перемещены или переименованы, то горячий журнал не будет виден, и база данных не будет откатана.</target>
        </trans-unit>
        <trans-unit id="fb8183919d1fc07417b2707b8092ba7a7a08090d" translate="yes" xml:space="preserve">
          <source>If a crash or power loss occurs in the middle of a transaction, then the rollback journal file is left on disk. The next time another application attempts to open the database file, it notices the presence of the abandoned rollback journal (we call it a &quot;hot journal&quot; in this circumstance) and uses the information in the journal to restore the database to its state prior to the start of the incomplete transaction. This is how SQLite implements atomic commit.</source>
          <target state="translated">Если в середине транзакции происходит сбой или отключение питания,то файл журнала отката остается на диске.При следующей попытке открытия файла базы данных другое приложение замечает наличие заброшенного журнала отката (в данном случае мы называем его &quot;горячим журналом&quot;)и использует содержащуюся в нем информацию для восстановления базы данных до ее состояния до начала незавершенной транзакции.Именно так SQLite реализует атомарный коммит.</target>
        </trans-unit>
        <trans-unit id="ac9f0e2592a2df4c51e939a4b5d49b41b7d7ebcb" translate="yes" xml:space="preserve">
          <source>If a database connection is opened with the &quot;-uri 1&quot; option, then &lt;a href=&quot;uri&quot;&gt;URI filenames&lt;/a&gt; are honored by the &quot;backup&quot; and &quot;restore&quot; commands.</source>
          <target state="translated">Если соединение с базой данных открывается с параметром &amp;laquo;-uri 1&amp;raquo;, то &lt;a href=&quot;uri&quot;&gt;имена файлов URI&lt;/a&gt; учитываются командами &amp;laquo;backup&amp;raquo; и &amp;laquo;restore&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="d5923feff2a2aef8fc7abf4f600aff34fc785066" translate="yes" xml:space="preserve">
          <source>If a database connection is operating in &lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;exclusive locking mode&lt;/a&gt; or in &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;persistent journal mode&lt;/a&gt; (PRAGMA journal_mode=persist) then after committing a transaction the &lt;a href=&quot;lockingv3#rollback&quot;&gt;rollback journal&lt;/a&gt; file may remain in the file-system. This increases performance for subsequent transactions since overwriting an existing file is faster than append to a file, but it also consumes file-system space. After a large transaction (e.g. a &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt;), the rollback journal file may consume a very large amount of space.</source>
          <target state="translated">Если соединение с базой данных работает в &lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;режиме эксклюзивной блокировки&lt;/a&gt; или в режиме &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;постоянного журнала&lt;/a&gt; (PRAGMA journal_mode = persist), то после фиксации транзакции файл &lt;a href=&quot;lockingv3#rollback&quot;&gt;журнала отката&lt;/a&gt; может остаться в файловой системе. Это увеличивает производительность для последующих транзакций, поскольку перезапись существующего файла выполняется быстрее, чем добавление в файл, но при этом также расходуется пространство файловой системы. После большой транзакции (например, &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; ) файл журнала отката может занимать очень много места.</target>
        </trans-unit>
        <trans-unit id="5f55f04439258c2d344a35f29269aa9db3e5202b" translate="yes" xml:space="preserve">
          <source>If a database file is accessed using 8+3 naming rather than the default long filename, then it must be consistently accessed using 8+3 naming by every database connection every time it is opened, or else there is a risk of database corruption. The auxiliary &lt;a href=&quot;lockingv3#rollback&quot;&gt;rollback journal&lt;/a&gt; and &lt;a href=&quot;wal&quot;&gt;write-ahead log&lt;/a&gt; files are essential to SQLite for being about to recover from a crash. If an application is using 8+3 names and crashes, then the information needed to safely recover from the crash is stored in files with the &quot;&lt;code&gt;.nal&lt;/code&gt;&quot; or &quot;&lt;code&gt;.wal&lt;/code&gt;&quot; extension. If the next application to open the database does not specify the &quot;&lt;code&gt;8_3_names=1&lt;/code&gt;&quot; URI parameter, then SQLite will use the long filenames to try to locate the rollback journal or write-ahead log files. It will not find them, since they were saved using 8+3 names by the application that crashed, and hence the database will not be properly recovered and will likely go corrupt.</source>
          <target state="translated">Если доступ к файлу базы данных осуществляется с использованием именования 8 + 3, а не с использованием длинного имени файла по умолчанию, тогда к нему необходимо последовательно обращаться с использованием именования 8 + 3 при каждом подключении к базе данных при каждом его открытии, иначе существует риск повреждения базы данных. Вспомогательный &lt;a href=&quot;lockingv3#rollback&quot;&gt;журнал отката&lt;/a&gt; и файлы &lt;a href=&quot;wal&quot;&gt;журнала упреждающей записи&lt;/a&gt; необходимы SQLite для восстановления после сбоя. Если приложение использует имена 8 + 3 и дает сбой, то информация, необходимая для безопасного восстановления после сбоя, сохраняется в файлах с &lt;code&gt;.nal&lt;/code&gt; &amp;laquo; .nal &amp;raquo; или &amp;laquo; &lt;code&gt;.wal&lt;/code&gt; &amp;raquo;. Если следующее приложение для открытия базы данных не указывает &amp;laquo; &lt;code&gt;8_3_names=1&lt;/code&gt; &quot;Параметр URI, тогда SQLite будет использовать длинные имена файлов, чтобы попытаться найти журнал отката или файлы журнала упреждающей записи. Он не найдет их, поскольку они были сохранены с использованием 8 + 3 имен приложением, в котором произошел сбой, и, следовательно, база данных не будут восстановлены должным образом и, скорее всего, будут повреждены.</target>
        </trans-unit>
        <trans-unit id="bd70a20b8f5f47bbbe011a3bee3a583fecc50caa" translate="yes" xml:space="preserve">
          <source>If a database is written by SQLite version 3.7.0 or later and then written again by SQLite version 3.6.23 or earlier in such a way as to make the size of the database file decrease, then the next time that SQLite version 3.7.0 access the database file, it might report that the database file is corrupt. The database file is not really corrupt, however. Version 3.7.0 was simply being overly zealous in its corruption detection.</source>
          <target state="translated">Если БД написана SQLite версии 3.7.0 или более поздней,а затем снова написана SQLite версии 3.6.23 или более ранней таким образом,что размер файла БД уменьшается,то при следующем обращении SQLite версии 3.7.0 к файлу БД может появиться сообщение о том,что файл БД поврежден.Однако файл базы данных на самом деле не поврежден.Версия 3.7.0 была просто слишком усердной в обнаружении ее повреждений.</target>
        </trans-unit>
        <trans-unit id="c0e8b12ff7ad15986137c5d5f01f4e0ef949a4a6" translate="yes" xml:space="preserve">
          <source>If a database were originally created using SQLite version 3.7.0, then written by SQLite version 3.6.23.1 such that the size of the database file increased, then written again by SQLite version 3.7.0, the database file could go corrupt.</source>
          <target state="translated">Если БД изначально создавалась с использованием SQLite версии 3.7.0,а затем была написана SQLite версии 3.6.23.1 таким образом,что размер файла БД увеличивался,а затем снова написана SQLite версии 3.7.0,то файл БД может выйти из строя.</target>
        </trans-unit>
        <trans-unit id="f7f861f58b781638426cc97ad65bbe6addfa6a62" translate="yes" xml:space="preserve">
          <source>If a keyword in double quotes (ex: &lt;b&gt;&quot;key&quot;&lt;/b&gt; or &lt;b&gt;&quot;glob&quot;&lt;/b&gt;) is used in a context where it cannot be resolved to an identifier but where a string literal is allowed, then the token is understood to be a string literal instead of an identifier.</source>
          <target state="translated">Если ключевое слово в двойных кавычках (например, &lt;b&gt;&amp;laquo;ключ&amp;raquo;&lt;/b&gt; или &lt;b&gt;&amp;laquo;глобус&amp;raquo;&lt;/b&gt; ) используется в контексте, где оно не может быть преобразовано в идентификатор, но где разрешен строковый литерал, тогда токен считается строковым литералом, а не идентификатор.</target>
        </trans-unit>
        <trans-unit id="ff734731d1dd61e745b8c19a93e379fd051ea7fb" translate="yes" xml:space="preserve">
          <source>If a keyword in single quotes (ex: &lt;b&gt;'key'&lt;/b&gt; or &lt;b&gt;'glob'&lt;/b&gt;) is used in a context where an identifier is allowed but where a string literal is not allowed, then the token is understood to be an identifier instead of a string literal.</source>
          <target state="translated">Если ключевое слово в одинарных кавычках (например, &lt;b&gt;'key'&lt;/b&gt; или &lt;b&gt;'glob'&lt;/b&gt; ) используется в контексте, где идентификатор разрешен, но где строковый литерал не разрешен, тогда токен считается идентификатором, а не строковым литералом. .</target>
        </trans-unit>
        <trans-unit id="fd8582b07f28c43cf6305e6462fb4a6db23b8ea7" translate="yes" xml:space="preserve">
          <source>If a matchable phrase is part of a series of phrases connected by NEAR operators in the FTS query expression, then each phrase match must be sufficiently close to other phrase matches of the relevant types to satisfy the NEAR condition.</source>
          <target state="translated">Если совпадающая фраза является частью серии фраз,соединенных операторами NEAR в выражении запроса FTS,то каждое совпадение фраз должно быть достаточно близко к другим совпадениям фраз соответствующих типов для выполнения условия NEAR.</target>
        </trans-unit>
        <trans-unit id="a2a6d03cae632eedbf962d2919113c9e0642d81c" translate="yes" xml:space="preserve">
          <source>If a memory allocation error occurs, sqlite3_create_filename() might return a NULL pointer. The memory obtained from sqlite3_create_filename(X) must be released by a corresponding call to sqlite3_free_filename(Y).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16ba62507a795aad87688bd7a66b598560ff99c0" translate="yes" xml:space="preserve">
          <source>If a named virtual table that uses the dbstat module is desired, then the recommended way to create an instance of the dbstat virtual table is as follows:</source>
          <target state="translated">Если требуется именованная виртуальная таблица,использующая модуль dbstat,то рекомендуемый способ создания экземпляра виртуальной таблицы dbstat следующий:</target>
        </trans-unit>
        <trans-unit id="f0a2ba4a4cc7d08c018b4dbe8137dc10439214b7" translate="yes" xml:space="preserve">
          <source>If a numeric literal has a decimal point or an exponentiation clause or if its magnitude is less than -9223372036854775808 or greater than 9223372036854775807, then it is a floating point literal. Otherwise is it is an integer literal. The &quot;E&quot; character that begins the exponentiation clause of a floating point literal can be either upper or lower case. The &quot;.&quot; character is always used as the decimal point even if the locale setting specifies &quot;,&quot; for this role - the use of &quot;,&quot; for the decimal point would result in syntactic ambiguity.</source>
          <target state="translated">Если числовой литерал имеет десятичную точку или выражение экспоненции,или его величина меньше -9223372036854775808 или больше 9223372036854775807,то он является литералом с плавающей точкой.Иначе это целочисленный литерал.Символ &quot;E&quot;,который начинает выражение выражения литерала с плавающей точкой,может быть как верхним,так и нижним регистром.Символ &quot;...&quot; всегда используется в качестве десятичной точки,даже если в настройках локали указано &quot;,&quot; для этой роли-использование &quot;,&quot; для десятичной точки приведет к синтаксической неоднозначности.</target>
        </trans-unit>
        <trans-unit id="8cf3813aebca15b6b5e1583aeffa06f6925412e6" translate="yes" xml:space="preserve">
          <source>If a page contains no cells (which is only possible for a root page of a table that contains no rows) then the offset to the cell content area will equal the page size minus the bytes of reserved space. If the database uses a 65536-byte page size and the reserved space is zero (the usual value for reserved space) then the cell content offset of an empty page wants to be 65536. However, that integer is too large to be stored in a 2-byte unsigned integer, so a value of 0 is used in its place.</source>
          <target state="translated">Если страница не содержит ячеек (что возможно только для корневой страницы таблицы,не содержащей строк),то смещение к области содержимого ячейки будет равно размеру страницы минус байты зарезервированного пространства.Если в БД используется размер страницы 65536 байт,а зарезервированное пространство равно нулю (обычное значение для зарезервированного пространства),то смещение к ячейке содержимого пустой страницы будет равно 65536.Однако это целое число слишком велико,чтобы храниться в 2-байтовом беззнаковом числе,поэтому вместо него используется значение 0.</target>
        </trans-unit>
        <trans-unit id="c99e07bc95c7e7eeb5ce8d8ce056128a45cab0ab" translate="yes" xml:space="preserve">
          <source>If a parameter name begins with a &quot;:&quot;, then it is assumed to be a value to bind to the SQL statement before executing it. The value is always bound as text. It is an error if the specified SQL parameter does not exist. For example:</source>
          <target state="translated">Если имя параметра начинается с &quot;:&quot;,то предполагается,что это значение привязывается к SQL-оператору перед его выполнением.Значение всегда привязывается в виде текста.Это ошибка,если указанный параметр SQL не существует.Например:</target>
        </trans-unit>
        <trans-unit id="a3a6677c34d1c31ace005a4fa6f3930c2040066e" translate="yes" xml:space="preserve">
          <source>If a power failure or operating system crash occurs at this point, the transaction will not rollback when the system reboots even though there are rollback journals present. The difference is the master journal pathname in the header of the rollback journal. Upon restart, SQLite only considers a journal to be hot and will only playback the journal if there is no master journal filename in the header (which is the case for a single-file commit) or if the master journal file still exists on disk.</source>
          <target state="translated">Если в этот момент произойдет сбой питания или сбой операционной системы,транзакция не откатится при перезагрузке системы,даже несмотря на наличие журналов отката.Разница заключается в том,что в заголовке журнала отката есть главный журнал.При перезагрузке SQLite считает журнал горячим и будет проигрывать его только в том случае,если в заголовке нет имени файла главного журнала (в случае однофайловой фиксации)или если главный файл журнала все еще существует на диске.</target>
        </trans-unit>
        <trans-unit id="df0966ae095afce680bcbe564721893f2e27c89b" translate="yes" xml:space="preserve">
          <source>If a power failure or operating system crash occurs at this point, the transaction will not rollback when the system reboots even though there are rollback journals present. The difference is the super-journal pathname in the header of the rollback journal. Upon restart, SQLite only considers a journal to be hot and will only playback the journal if there is no super-journal filename in the header (which is the case for a single-file commit) or if the super-journal file still exists on disk.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f031e4113363c1780559d56fb503c736f7031cb4" translate="yes" xml:space="preserve">
          <source>If a power failure or operating system failure occurs while copying the database file the backup database may be corrupted following system recovery.</source>
          <target state="translated">Если во время копирования файла базы данных произойдет сбой электропитания или сбой операционной системы,то после восстановления системы резервная база данных может быть повреждена.</target>
        </trans-unit>
        <trans-unit id="d63fd60747c59caf947d214389cf965d0e528d08" translate="yes" xml:space="preserve">
          <source>If a query contains an ORDER BY clause with multiple terms, it might be that SQLite can use indices to cause rows to come out in the order of some prefix of the terms in the ORDER BY but that later terms in the ORDER BY are not satisfied. In that case, SQLite does block sorting. Suppose the ORDER BY clause has four terms and the natural order of the query results in rows appearing in order of the first two terms. As each row is output by the query engine and enters the sorter, the outputs in the current row corresponding to the first two terms of the ORDER BY are compared against the previous row. If they have changed, the current sort is finished and output and a new sort is started. This results in a slightly faster sort. But the bigger advantages are that many fewer rows need to be held in memory, reducing memory requirements, and outputs can begin to appear before the core query has run to completion.</source>
          <target state="translated">Если запрос содержит пункт &quot;ЗАКАЗАТЬ ПО&quot; с несколькими терминами,возможно,SQLite может использовать индексы для вызова строк в порядке некоторого префикса терминов в пункте &quot;ЗАКАЗАТЬ ПО&quot;,но более поздние термины в пункте &quot;ЗАКАЗАТЬ ПО&quot; не удовлетворяются.В этом случае SQLite действительно блокирует сортировку.Предположим,что в пункте &quot;ЗАКАЗЫВАТЬ ПО&quot; имеется четыре термина,и естественный порядок запроса приводит к тому,что строки появляются в порядке первых двух терминов.Поскольку каждая строка выводится механизмом запроса и попадает в сортировщик,результаты в текущей строке,соответствующие первым двум слагаемым пункта &quot;ЗАКАЗАТЬ ВЫБОР&quot;,сравниваются с предыдущей строкой.Если они изменились,то текущий сорт завершается и выводится и начинается новый сорт.В результате сортировка получается немного быстрее.Но большие преимущества заключаются в том,что меньше строк нужно хранить в памяти,что снижает требования к памяти,и результаты могут начать появляться еще до того,как основной запрос будет выполнен.</target>
        </trans-unit>
        <trans-unit id="ec318f6e2d2904b05a3f02946f0559cc8fefaa28" translate="yes" xml:space="preserve">
          <source>If a query contains no aggregate functions at all, then a GROUP BY clause can be added as a substitute for the DISTINCT ON clause. In other words, output rows are filtered so that only one row is shown for each distinct set of values in the GROUP BY clause. If two or more output rows would have otherwise had the same set of values for the GROUP BY columns, then one of the rows is chosen arbitrarily. (SQLite supports DISTINCT but not DISTINCT ON, whose functionality is provided instead by GROUP BY.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdf63c23188158127b26cd2c4807de45ccf6dea6" translate="yes" xml:space="preserve">
          <source>If a query contains no aggregate functions at all, then a GROUP BY clause can be added as a substitute of DISTINCT ON clause. In other words, output rows are filtered so that only one row is shows for each distinct set of values in the GROUP BY clause. If two or more output rows would have otherwise had the same set of values for the GROUP BY columns, then one of the rows is chosen arbitrarily.</source>
          <target state="translated">Если запрос вообще не содержит агрегатных функций,то в качестве замены пункта DISTINCT ON можно добавить пункт GROUP BY.Другими словами,выходные строки фильтруются таким образом,что для каждого отдельного набора значений в пункте GROUP BY отображается только одна строка.Если две или более выходных строк в противном случае имели бы один и тот же набор значений для столбцов GROUP BY,то одна из строк выбирается произвольно.</target>
        </trans-unit>
        <trans-unit id="cab66c0bca9a377eb02b4b0ac5090404c2d874c0" translate="yes" xml:space="preserve">
          <source>If a read/write client invokes &lt;a href=&quot;c3ref/file_control&quot;&gt;sqlite3_file_control&lt;/a&gt;(&lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlpersistwal&quot;&gt;SQLITE_FCNTL_PERSIST_WAL&lt;/a&gt;) prior to shutdown, then at shutdown a checkpoint is still run, but the shm file and wal file are not deleted. This allows subsequent read-only clients to connect to and read the database.</source>
          <target state="translated">Если клиент чтения / записи вызывает &lt;a href=&quot;c3ref/file_control&quot;&gt;sqlite3_file_control&lt;/a&gt; ( &lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlpersistwal&quot;&gt;SQLITE_FCNTL_PERSIST_WAL&lt;/a&gt; ) до завершения работы, то при завершении работы контрольная точка все еще выполняется, но файл shm и файл wal не удаляются. Это позволяет последующим клиентам, доступным только для чтения, подключаться к базе данных и читать ее.</target>
        </trans-unit>
        <trans-unit id="337133b7d09a387cf87665a4c7d79ff39c533386" translate="yes" xml:space="preserve">
          <source>If a row with matching primary key values is found, but one or more of the modified non-primary key fields contains a value different from an original row value stored in the changeset, the conflict-handler function is invoked with &lt;a href=&quot;#SQLITE_CHANGESET_CONFLICT&quot;&gt;SQLITE_CHANGESET_DATA&lt;/a&gt; as the second argument. Since UPDATE changes only contain values for non-primary key fields that are to be modified, only those fields need to match the original values to avoid the SQLITE_CHANGESET_DATA conflict-handler callback.</source>
          <target state="translated">Если строка с совпадающими значениями первичного ключа найдена, но одно или несколько измененных полей непервичного ключа содержат значение, отличное от значения исходной строки, сохраненного в наборе изменений, вызывается функция обработчика конфликтов с &lt;a href=&quot;#SQLITE_CHANGESET_CONFLICT&quot;&gt;SQLITE_CHANGESET_DATA&lt;/a&gt; в качестве второго аргумента . Поскольку изменения UPDATE содержат только значения для полей непервичного ключа, которые должны быть изменены, только эти поля должны соответствовать исходным значениям, чтобы избежать обратного вызова обработчика конфликтов SQLITE_CHANGESET_DATA.</target>
        </trans-unit>
        <trans-unit id="35c7138a2b7260bc49d6f60cf430df710c00202b" translate="yes" xml:space="preserve">
          <source>If a row with matching primary key values is found, but one or more of the modified non-primary key fields contains a value different from an original row value stored in the changeset, the conflict-handler function is invoked with &lt;a href=&quot;c_changeset_conflict&quot;&gt;SQLITE_CHANGESET_DATA&lt;/a&gt; as the second argument. Since UPDATE changes only contain values for non-primary key fields that are to be modified, only those fields need to match the original values to avoid the SQLITE_CHANGESET_DATA conflict-handler callback.</source>
          <target state="translated">Если строка с совпадающими значениями первичного ключа найдена, но одно или несколько измененных полей непервичного ключа содержат значение, отличное от значения исходной строки, сохраненного в наборе изменений, вызывается функция обработчика конфликтов с &lt;a href=&quot;c_changeset_conflict&quot;&gt;SQLITE_CHANGESET_DATA&lt;/a&gt; в качестве второго аргумента . Поскольку изменения UPDATE содержат только значения для полей непервичного ключа, которые должны быть изменены, только эти поля должны соответствовать исходным значениям, чтобы избежать обратного вызова обработчика конфликтов SQLITE_CHANGESET_DATA.</target>
        </trans-unit>
        <trans-unit id="1b234b4b89cfdd9943a23340845cb2723771c58a" translate="yes" xml:space="preserve">
          <source>If a row with matching primary key values is found, but one or more of the non-primary key fields contains a value different from the original row value stored in the changeset, the conflict-handler function is invoked with &lt;a href=&quot;#SQLITE_CHANGESET_CONFLICT&quot;&gt;SQLITE_CHANGESET_DATA&lt;/a&gt; as the second argument. If the database table has more columns than are recorded in the changeset, only the values of those non-primary key fields are compared against the current database contents - any trailing database table columns are ignored.</source>
          <target state="translated">Если найдена строка с совпадающими значениями первичного ключа, но одно или несколько полей непервичного ключа содержат значение, отличное от значения исходной строки, хранящегося в наборе изменений, вызывается функция обработчика конфликтов с &lt;a href=&quot;#SQLITE_CHANGESET_CONFLICT&quot;&gt;SQLITE_CHANGESET_DATA&lt;/a&gt; в качестве второго аргумента. Если в таблице базы данных больше столбцов, чем записано в наборе изменений, только значения этих полей непервичного ключа сравниваются с текущим содержимым базы данных - любые конечные столбцы таблицы базы данных игнорируются.</target>
        </trans-unit>
        <trans-unit id="ca3b8d6b7470e9a00b63341bcac487b0076109fe" translate="yes" xml:space="preserve">
          <source>If a row with matching primary key values is found, but one or more of the non-primary key fields contains a value different from the original row value stored in the changeset, the conflict-handler function is invoked with &lt;a href=&quot;c_changeset_conflict&quot;&gt;SQLITE_CHANGESET_DATA&lt;/a&gt; as the second argument. If the database table has more columns than are recorded in the changeset, only the values of those non-primary key fields are compared against the current database contents - any trailing database table columns are ignored.</source>
          <target state="translated">Если найдена строка с совпадающими значениями первичного ключа, но одно или несколько полей непервичного ключа содержат значение, отличное от значения исходной строки, хранящегося в наборе изменений, вызывается функция обработчика конфликтов с &lt;a href=&quot;c_changeset_conflict&quot;&gt;SQLITE_CHANGESET_DATA&lt;/a&gt; в качестве второго аргумента. Если в таблице базы данных больше столбцов, чем записано в наборе изменений, только значения этих полей непервичного ключа сравниваются с текущим содержимым базы данных - любые конечные столбцы таблицы базы данных игнорируются.</target>
        </trans-unit>
        <trans-unit id="e400ae567f256dbdcc0abe528516e66e2c791942" translate="yes" xml:space="preserve">
          <source>If a schema name is specified as part of an object reference, it must be either &quot;main&quot;, or &quot;temp&quot; or the schema-name of an attached database. Like other SQL identifiers, schema names are case-insensitive. If a schema name is specified, then only that one schema is searched for the named object.</source>
          <target state="translated">Если имя схемы указано как часть ссылки на объект,то оно должно быть либо &quot;основным&quot;,либо &quot;временным&quot;,либо схемным именем подключенной БД.Как и другие SQL-идентификаторы,имена схем не чувствительны к регистру.Если указано имя схемы,то для именованного объекта ищется только одна схема.</target>
        </trans-unit>
        <trans-unit id="a287d9b64545db85e7dfa26422162809454f183b" translate="yes" xml:space="preserve">
          <source>If a schema-name is specified, it must be either &quot;main&quot;, &quot;temp&quot;, or the name of an &lt;a href=&quot;lang_attach&quot;&gt;attached database&lt;/a&gt;. In this case the new table is created in the named database. If the &quot;TEMP&quot; or &quot;TEMPORARY&quot; keyword occurs between the &quot;CREATE&quot; and &quot;TABLE&quot; then the new table is created in the temp database. It is an error to specify both a schema-name and the TEMP or TEMPORARY keyword, unless the schema-name is &quot;temp&quot;. If no schema name is specified and the TEMP keyword is not present then the table is created in the main database.</source>
          <target state="translated">Если указано имя схемы, оно должно быть либо &amp;laquo;main&amp;raquo;, &amp;laquo;temp&amp;raquo;, либо именем &lt;a href=&quot;lang_attach&quot;&gt;присоединенной базы данных&lt;/a&gt; . В этом случае новая таблица создается в названной базе данных. Если ключевое слово &amp;laquo;TEMP&amp;raquo; или &amp;laquo;TEMPORARY&amp;raquo; встречается между &amp;laquo;CREATE&amp;raquo; и &amp;laquo;TABLE&amp;raquo;, то новая таблица создается во временной базе данных. Ошибкой является указание и имени схемы, и ключевого слова TEMP или TEMPORARY, если имя схемы не равно &amp;laquo;temp&amp;raquo;. Если имя схемы не указано и ключевое слово TEMP отсутствует, таблица создается в основной базе данных.</target>
        </trans-unit>
        <trans-unit id="d186fac3c43b0ebe9fb52f2e0bcd9b8dc9321942" translate="yes" xml:space="preserve">
          <source>If a schema-name is specified, then the view is created in the specified database. It is an error to specify both a schema-name and the TEMP keyword on a VIEW, unless the schema-name is &quot;temp&quot;. If no schema name is specified, and the TEMP keyword is not present, the VIEW is created in the main database.</source>
          <target state="translated">Если указано имя схемы,то представление создается в указанной БД.Ошибкой является указание как имени схемы,так и ключевого слова TEMP на VIEW,если только имя схемы не &quot;temp&quot;.Если имя схемы не указано,а ключевое слово TEMP отсутствует,то VIEW создается в основной базе данных.</target>
        </trans-unit>
        <trans-unit id="5a3b25f9ef77a5c2a55ede994e4212a6c3bae634" translate="yes" xml:space="preserve">
          <source>If a search token (on the right-hand side of the MATCH operator) in &lt;a href=&quot;fts3#fts4&quot;&gt;FTS4&lt;/a&gt; begins with &quot;^&quot; then that token must be the first in its field of the document. &lt;b&gt;** Potentially Incompatible Change **&lt;/b&gt;</source>
          <target state="translated">Если маркер поиска (справа от оператора MATCH) в &lt;a href=&quot;fts3#fts4&quot;&gt;FTS4&lt;/a&gt; начинается с &amp;laquo;^&amp;raquo;, то этот маркер должен быть первым в соответствующем поле документа. &lt;b&gt;** Потенциально несовместимое изменение **&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="e0b0e745b5660b6e63d47617f06b59c6fe2aec60" translate="yes" xml:space="preserve">
          <source>If a separate thread makes changes on the same database connection while &lt;a href=&quot;#sqlite3_changes&quot;&gt;sqlite3_changes()&lt;/a&gt; is running then the value returned is unpredictable and not meaningful.</source>
          <target state="translated">Если отдельный поток вносит изменения в одно и то же соединение с базой данных во время работы &lt;a href=&quot;#sqlite3_changes&quot;&gt;sqlite3_changes (),&lt;/a&gt; то возвращаемое значение непредсказуемо и не имеет смысла.</target>
        </trans-unit>
        <trans-unit id="e161385bf705ff3ca3325998e8904218252e0a24" translate="yes" xml:space="preserve">
          <source>If a separate thread makes changes on the same database connection while &lt;a href=&quot;#sqlite3_total_changes&quot;&gt;sqlite3_total_changes()&lt;/a&gt; is running then the value returned is unpredictable and not meaningful.</source>
          <target state="translated">Если отдельный поток вносит изменения в одно и то же соединение с базой данных во время работы &lt;a href=&quot;#sqlite3_total_changes&quot;&gt;sqlite3_total_changes (),&lt;/a&gt; то возвращаемое значение непредсказуемо и не имеет смысла.</target>
        </trans-unit>
        <trans-unit id="48949b30f7cc8dfe518df452770028dcf8268e04" translate="yes" xml:space="preserve">
          <source>If a separate thread makes changes on the same database connection while &lt;a href=&quot;changes&quot;&gt;sqlite3_changes()&lt;/a&gt; is running then the value returned is unpredictable and not meaningful.</source>
          <target state="translated">Если отдельный поток вносит изменения в одно и то же соединение с базой данных во время работы &lt;a href=&quot;changes&quot;&gt;sqlite3_changes (),&lt;/a&gt; то возвращаемое значение непредсказуемо и не имеет смысла.</target>
        </trans-unit>
        <trans-unit id="e69017ebf8db42f4c918537142f058b4e1e4b99c" translate="yes" xml:space="preserve">
          <source>If a separate thread makes changes on the same database connection while &lt;a href=&quot;total_changes&quot;&gt;sqlite3_total_changes()&lt;/a&gt; is running then the value returned is unpredictable and not meaningful.</source>
          <target state="translated">Если отдельный поток вносит изменения в одно и то же соединение с базой данных во время работы &lt;a href=&quot;total_changes&quot;&gt;sqlite3_total_changes (),&lt;/a&gt; то возвращаемое значение непредсказуемо и не имеет смысла.</target>
        </trans-unit>
        <trans-unit id="67e0dff317f2ea719a9272889d4afc4730b1b5fc" translate="yes" xml:space="preserve">
          <source>If a separate thread performs a new &lt;a href=&quot;../lang_insert&quot;&gt;INSERT&lt;/a&gt; on the same database connection while the &lt;a href=&quot;last_insert_rowid&quot;&gt;sqlite3_last_insert_rowid()&lt;/a&gt; function is running and thus changes the last insert &lt;a href=&quot;../lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;, then the value returned by &lt;a href=&quot;last_insert_rowid&quot;&gt;sqlite3_last_insert_rowid()&lt;/a&gt; is unpredictable and might not equal either the old or the new last insert &lt;a href=&quot;../lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;.</source>
          <target state="translated">Если отдельный поток выполняет новую &lt;a href=&quot;../lang_insert&quot;&gt;операцию INSERT&lt;/a&gt; для того же подключения к базе данных во время работы &lt;a href=&quot;last_insert_rowid&quot;&gt;функции sqlite3_last_insert_rowid ()&lt;/a&gt; и, таким образом, изменяет последний &lt;a href=&quot;../lang_createtable#rowid&quot;&gt;идентификатор строки&lt;/a&gt; вставки , тогда значение, возвращаемое &lt;a href=&quot;last_insert_rowid&quot;&gt;sqlite3_last_insert_rowid (),&lt;/a&gt; является непредсказуемым и может не совпадать ни со старым, ни с новым последним. вставить &lt;a href=&quot;../lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f8a05ae1d1d14adcdf537d4865ddc934cf60a0a4" translate="yes" xml:space="preserve">
          <source>If a separate thread performs a new &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; on the same database connection while the &lt;a href=&quot;#sqlite3_last_insert_rowid&quot;&gt;sqlite3_last_insert_rowid()&lt;/a&gt; function is running and thus changes the last insert &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;, then the value returned by &lt;a href=&quot;#sqlite3_last_insert_rowid&quot;&gt;sqlite3_last_insert_rowid()&lt;/a&gt; is unpredictable and might not equal either the old or the new last insert &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;.</source>
          <target state="translated">Если отдельный поток выполняет новую &lt;a href=&quot;lang_insert&quot;&gt;операцию INSERT&lt;/a&gt; для того же подключения к базе данных во время работы &lt;a href=&quot;#sqlite3_last_insert_rowid&quot;&gt;функции sqlite3_last_insert_rowid ()&lt;/a&gt; и, таким образом, изменяет последний &lt;a href=&quot;lang_createtable#rowid&quot;&gt;идентификатор строки&lt;/a&gt; вставки , тогда значение, возвращаемое &lt;a href=&quot;#sqlite3_last_insert_rowid&quot;&gt;sqlite3_last_insert_rowid (),&lt;/a&gt; является непредсказуемым и может не совпадать ни со старым, ни с новым последним. вставить &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9c0a40f4902327b395568a304aa57a5c4039b9e5" translate="yes" xml:space="preserve">
          <source>If a single database file has multiple links (either hard or soft links) then that is just another way of saying that the file has multiple names. If two or more processes open the database using different names, then they will use different rollback journals and WAL files. That means that if one process crashes, the other process will be unable to recover the transaction in progress because it will be looking in the wrong place for the appropriate journal.</source>
          <target state="translated">Если один файл базы данных имеет несколько ссылок (жесткие или мягкие),то это просто еще один способ сказать,что файл имеет несколько имён.Если два или более процессов открывают базу данных под разными именами,то они будут использовать разные журналы отката и файлы WAL.Это означает,что если один процесс выйдет из строя,другой процесс не сможет восстановить текущую транзакцию,потому что будет искать не в том месте,где находится соответствующий журнал.</target>
        </trans-unit>
        <trans-unit id="54992194ecdfbf1a36948d0111a0401fc51b1ec9" translate="yes" xml:space="preserve">
          <source>If a single row is affected by more than one operation within a session, then the change is considered indirect if all operations meet the criteria for an indirect change above, or direct otherwise.</source>
          <target state="translated">Если на один ряд влияет несколько операций в течение сессии,то изменение считается косвенным,если все операции соответствуют критериям косвенного изменения,указанным выше,или прямым иным образом.</target>
        </trans-unit>
        <trans-unit id="8aed35bc8fc658c89e5539bc9b828e9558656314" translate="yes" xml:space="preserve">
          <source>If a statement modifies the contents of the database so that an immediate foreign key constraint is in violation at the conclusion the statement, an exception is thrown and the effects of the statement are reverted. By contrast, if a statement modifies the contents of the database such that a deferred foreign key constraint is violated, the violation is not reported immediately. Deferred foreign key constraints are not checked until the transaction tries to &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt;. For as long as the user has an open transaction, the database is allowed to exist in a state that violates any number of deferred foreign key constraints. However, &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; will fail as long as foreign key constraints remain in violation.</source>
          <target state="translated">Если оператор изменяет содержимое базы данных таким образом, что при заключении оператора нарушается непосредственное ограничение внешнего ключа, генерируется исключение и действие оператора отменяется. Напротив, если оператор изменяет содержимое базы данных таким образом, что нарушается ограничение отложенного внешнего ключа, о нарушении не сообщается немедленно. Отложенные ограничения внешнего ключа не проверяются, пока транзакция не попытается выполнить &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; . Пока у пользователя есть открытая транзакция, базе данных разрешено существовать в состоянии, которое нарушает любое количество ограничений отложенного внешнего ключа. Однако &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; завершится ошибкой, пока не будут соблюдены ограничения внешнего ключа.</target>
        </trans-unit>
        <trans-unit id="4a9fe68ac2f3c48ea32a43f2c5cf9be89d342ee4" translate="yes" xml:space="preserve">
          <source>If a subquery cannot be &lt;a href=&quot;optoverview#flattening&quot;&gt;flattened&lt;/a&gt; into the outer query, it might still be possible to enhance performance by &quot;pushing down&quot; WHERE clause terms from the outer query into the subquery. Consider an example:</source>
          <target state="translated">Если подзапрос не может быть &lt;a href=&quot;optoverview#flattening&quot;&gt;уплощен&lt;/a&gt; во внешний запрос, он все еще может быть возможность повысить производительность за счет &amp;laquo;надавив&amp;raquo; ИНЕКЕ термины из внешнего запроса в подзапрос. Рассмотрим пример:</target>
        </trans-unit>
        <trans-unit id="cfbdc72faddc3dd92eaf2d66d72d9166e0ce65e3" translate="yes" xml:space="preserve">
          <source>If a system failure occurs at any time after a &quot;delete file&quot; operation (call to the VFS xDelete() method) returns successfully, it is assumed that the file-system will not contain the deleted file following system recovery.</source>
          <target state="translated">Если после успешного возвращения операции &quot;удалить файл&quot; (обращение к методу VFS xDelete())в любой момент произойдет системный сбой,то предполагается,что после восстановления системы файловая система не будет содержать удаленный файл.</target>
        </trans-unit>
        <trans-unit id="c32e1e0b557aefde59c28d931cf3e5d6733099fd" translate="yes" xml:space="preserve">
          <source>If a system failure occurs during a &quot;delete file&quot; operation, it is assumed that following system recovery the file-system will either contain the file being deleted in the state it was in before the operation was attempted, or not contain the file at all. It is assumed that it is not possible for the file to have become corrupted purely as a result of a failure occurring during a &quot;delete file&quot; operation.</source>
          <target state="translated">Если во время операции &quot;удалить файл&quot; происходит системный сбой,то предполагается,что после восстановления системы файловая система будет либо содержать удаляемый файл в том состоянии,в котором он находился до попытки операции,либо не содержать файл вообще.Предполагается,что файл не может быть поврежден только в результате сбоя при выполнении операции &quot;удалить файл&quot;.</target>
        </trans-unit>
        <trans-unit id="91f96ef24748138cdd82c09ceabe7f648ae9cf43" translate="yes" xml:space="preserve">
          <source>If a system failure occurs during or after a &quot;create file&quot; operation, but before the created file has been</source>
          <target state="translated">Если системный сбой происходит во время или после операции &quot;создать файл&quot;,но до того как созданный файл был</target>
        </trans-unit>
        <trans-unit id="1fcfee495c57582bc4c6e63019680717056464ec" translate="yes" xml:space="preserve">
          <source>If a system failure occurs during or after a &quot;truncate file&quot; operation, but before the truncated file has been</source>
          <target state="translated">Если системный сбой происходит во время или после операции &quot;усеченный файл&quot;,но до того,как усеченный файл был</target>
        </trans-unit>
        <trans-unit id="e3c60bc044d7ebf2be0e926e292ed7263d6ed54a" translate="yes" xml:space="preserve">
          <source>If a system failure occurs during or after a &quot;write file&quot; operation that causes the file to grow, but before the corresponding file has been</source>
          <target state="translated">Если системный сбой происходит во время или после операции &quot;запись файла&quot;,которая приводит к росту файла,но до того,как соответствующий файл был</target>
        </trans-unit>
        <trans-unit id="0de8e98595413448f2b535870f8da207b8048237" translate="yes" xml:space="preserve">
          <source>If a system failure occurs during or after a &quot;write file&quot; operation, but before the corresponding file has been</source>
          <target state="translated">Если системный сбой произошел во время или после операции &quot;запись файла&quot;,но до того,как соответствующий файл стал</target>
        </trans-unit>
        <trans-unit id="12d84c274c03171c71b26275c99f75f3392362a6" translate="yes" xml:space="preserve">
          <source>If a system failure occurs on a system that supports the</source>
          <target state="translated">Если системный сбой происходит в системе,которая поддерживает</target>
        </trans-unit>
        <trans-unit id="70f739b455c168080412690c97f5940222b8f766" translate="yes" xml:space="preserve">
          <source>If a system supports</source>
          <target state="translated">Если система поддерживает</target>
        </trans-unit>
        <trans-unit id="ec9800aa0fd4fbf6e94d5e57566c8304e2f2782b" translate="yes" xml:space="preserve">
          <source>If a system supports the</source>
          <target state="translated">Если система поддерживает</target>
        </trans-unit>
        <trans-unit id="16f55a3959edd0a92c0395b9cf4c3468da074f4f" translate="yes" xml:space="preserve">
          <source>If a table contains a column of type &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;, then that column becomes an alias for the ROWID. You can then access the ROWID using any of four different names, the original three names described above or the name given to the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; column. All these names are aliases for one another and work equally well in any context.</source>
          <target state="translated">Если таблица содержит столбец типа &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; , то этот столбец становится псевдонимом для ROWID. Затем вы можете получить доступ к ROWID, используя любое из четырех разных имен, исходных трех имен, описанных выше, или имени, присвоенного столбцу &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; . Все эти имена являются псевдонимами друг для друга и одинаково хорошо работают в любом контексте.</target>
        </trans-unit>
        <trans-unit id="a73b6736040e74c7d625fd213eca9757c75eee19" translate="yes" xml:space="preserve">
          <source>If a table has a single column primary key and the declared type of that column is &quot;INTEGER&quot; and the table is not a &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; table, then the column is known as an &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;. See &lt;a href=&quot;lang_createtable#rowid&quot;&gt;below&lt;/a&gt; for a description of the special properties and behaviors associated with an &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;.</source>
          <target state="translated">Если таблица имеет первичный ключ с одним столбцом, и объявленный тип этого столбца - &quot;INTEGER&quot;, а таблица не является таблицей &lt;a href=&quot;withoutrowid&quot;&gt;БЕЗ ROWID&lt;/a&gt; , то этот столбец известен как &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; . См. &lt;a href=&quot;lang_createtable#rowid&quot;&gt;Ниже&lt;/a&gt; описание специальных свойств и поведения, связанных с &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5e353db8a7a970978b864076f23349bbe29b3cd1" translate="yes" xml:space="preserve">
          <source>If a term in X is of the form &quot;z IS NOT NULL&quot; and if a term in W is a comparison operator on &quot;z&quot; other than &quot;IS&quot;, then those terms match.</source>
          <target state="translated">Если термин в X имеет форму &quot;z НЕ НУЛЬШЕ&quot; и если термин в W является оператором сравнения на &quot;z&quot;,отличным от &quot;IS&quot;,то эти термины совпадают.</target>
        </trans-unit>
        <trans-unit id="d7704041f8ff8a11a4c662eef3d671025a3e5ebe" translate="yes" xml:space="preserve">
          <source>If a term of the WHERE clause is of the following form:</source>
          <target state="translated">Если условие &quot;ГДЕ&quot; имеет следующую форму:</target>
        </trans-unit>
        <trans-unit id="e5d671a1040d0448cbcd3997833359da102571a4" translate="yes" xml:space="preserve">
          <source>If a transaction involves multiple databases, then a more complex commit sequence is used, as follows:</source>
          <target state="translated">Если транзакция включает в себя несколько баз данных,то используется более сложная последовательность коммитов,как показано ниже:</target>
        </trans-unit>
        <trans-unit id="1b08d45fd51c4591fce14d3b424e9dccc579bef5" translate="yes" xml:space="preserve">
          <source>If a transaction is aborted due to an application crash, an operating system crash, or a hardware power failure or crash, then the database may be left in an inconsistent state. The next time SQLite attempts to open the database file, the presence of the rollback journal file will be detected and the journal will be automatically played back to restore the database to its state at the start of the incomplete transaction.</source>
          <target state="translated">Если транзакция прерывается в связи с отказом приложения,сбоем операционной системы,сбоем или отказом аппаратного обеспечения электропитания,то база данных может остаться в непоследовательном состоянии.При следующей попытке SQLite открыть файл БД будет обнаружено наличие файла журнала отката,который будет автоматически проигрываться для восстановления БД до ее состояния при запуске незавершенной транзакции.</target>
        </trans-unit>
        <trans-unit id="b139c7ece8944c0ce3ad448cfb0c14ea14a36c67" translate="yes" xml:space="preserve">
          <source>If a write-transaction is open on &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; D when the &lt;a href=&quot;#sqlite3_db_cacheflush&quot;&gt;sqlite3_db_cacheflush(D)&lt;/a&gt; interface invoked, any dirty pages in the pager-cache that are not currently in use are written out to disk. A dirty page may be in use if a database cursor created by an active SQL statement is reading from it, or if it is page 1 of a database file (page 1 is always &quot;in use&quot;). The &lt;a href=&quot;#sqlite3_db_cacheflush&quot;&gt;sqlite3_db_cacheflush(D)&lt;/a&gt; interface flushes caches for all schemas - &quot;main&quot;, &quot;temp&quot;, and any &lt;a href=&quot;lang_attach&quot;&gt;attached&lt;/a&gt; databases.</source>
          <target state="translated">Если транзакция записи открыта в &lt;a href=&quot;#sqlite3&quot;&gt;соединении с базой данных&lt;/a&gt; D при вызове интерфейса &lt;a href=&quot;#sqlite3_db_cacheflush&quot;&gt;sqlite3_db_cacheflush (D)&lt;/a&gt; , все неиспользуемые грязные страницы в кэше пейджера записываются на диск. Грязная страница может использоваться, если курсор базы данных, созданный активным оператором SQL, читает из нее, или если это страница 1 файла базы данных (страница 1 всегда &amp;laquo;используется&amp;raquo;). Интерфейс &lt;a href=&quot;#sqlite3_db_cacheflush&quot;&gt;sqlite3_db_cacheflush (D)&lt;/a&gt; очищает кеши для всех схем - &amp;laquo;main&amp;raquo;, &amp;laquo;temp&amp;raquo; и любых &lt;a href=&quot;lang_attach&quot;&gt;подключенных&lt;/a&gt; баз данных.</target>
        </trans-unit>
        <trans-unit id="94598ac271e5cdca4a0d9c950ece2e2fde3c85ae" translate="yes" xml:space="preserve">
          <source>If a write-transaction is open on &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; D when the &lt;a href=&quot;db_cacheflush&quot;&gt;sqlite3_db_cacheflush(D)&lt;/a&gt; interface invoked, any dirty pages in the pager-cache that are not currently in use are written out to disk. A dirty page may be in use if a database cursor created by an active SQL statement is reading from it, or if it is page 1 of a database file (page 1 is always &quot;in use&quot;). The &lt;a href=&quot;db_cacheflush&quot;&gt;sqlite3_db_cacheflush(D)&lt;/a&gt; interface flushes caches for all schemas - &quot;main&quot;, &quot;temp&quot;, and any &lt;a href=&quot;../lang_attach&quot;&gt;attached&lt;/a&gt; databases.</source>
          <target state="translated">Если транзакция записи открыта в &lt;a href=&quot;sqlite3&quot;&gt;соединении с базой данных&lt;/a&gt; D при вызове интерфейса &lt;a href=&quot;db_cacheflush&quot;&gt;sqlite3_db_cacheflush (D)&lt;/a&gt; , все неиспользуемые грязные страницы в кэше пейджера записываются на диск. Грязная страница может использоваться, если курсор базы данных, созданный активным оператором SQL, читает из нее, или если это страница 1 файла базы данных (страница 1 всегда &amp;laquo;используется&amp;raquo;). Интерфейс &lt;a href=&quot;db_cacheflush&quot;&gt;sqlite3_db_cacheflush (D)&lt;/a&gt; очищает кеши для всех схем - &amp;laquo;main&amp;raquo;, &amp;laquo;temp&amp;raquo; и любых &lt;a href=&quot;../lang_attach&quot;&gt;подключенных&lt;/a&gt; баз данных.</target>
        </trans-unit>
        <trans-unit id="9d687ea67d2673f11d5b429c0195a169c2caa77a" translate="yes" xml:space="preserve">
          <source>If a write-transaction is started and the Vdbe.usesStmtJournal flag is true (this flag is set if the Vdbe may modify more than one row and may throw an ABORT exception), a statement transaction may also be opened. More specifically, a statement transaction is opened iff the database connection is currently not in autocommit mode, or if there are other active statements. A statement transaction allows the changes made by this VDBE to be rolled back after an error without having to roll back the entire transaction. If no error is encountered, the statement transaction will automatically commit when the VDBE halts.</source>
          <target state="translated">Если транзакция записи начинается и флаг Vdbe.useStmtJournal истинен (этот флаг устанавливается,если Vdbe может модифицировать более чем одну строку и может бросить исключение ABORT),транзакция оператора также может быть открыта.Точнее,транзакция оператора открывается,если соединение с базой данных в настоящее время не находится в режиме автокомитации,или если есть другие активные операторы.Транзакция оператора позволяет откатить изменения,сделанные этим VDBE после ошибки,без необходимости отката всей транзакции.Если ошибка не обнаружена,транзакция оператора будет автоматически зафиксирована,когда VDBE остановится.</target>
        </trans-unit>
        <trans-unit id="7e874d6b40d57619d9fa5fb8dd75a92de53ed059" translate="yes" xml:space="preserve">
          <source>If all three of the steps enumerated above are executed successfully, then it is safe to modify the content of the</source>
          <target state="translated">Если все три перечисленные выше шага будут успешно выполнены,то можно безопасно модифицировать содержание</target>
        </trans-unit>
        <trans-unit id="8a9cfb8256efd43eaa74ef64ff226cfbf427865f" translate="yes" xml:space="preserve">
          <source>If an &quot;ALTER TABLE ... RENAME TO&quot; command is used to rename a table that is the parent table of one or more foreign key constraints, the definitions of the foreign key constraints are modified to refer to the parent table by its new name. The text of the child CREATE TABLE statement or statements stored in the &lt;a href=&quot;schematab&quot;&gt;sqlite_schema table&lt;/a&gt; are modified to reflect the new parent table name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76124bb023821e31ac6f5cbf1f8b54083a3ec643" translate="yes" xml:space="preserve">
          <source>If an &quot;ALTER TABLE ... RENAME TO&quot; command is used to rename a table that is the parent table of one or more foreign key constraints, the definitions of the foreign key constraints are modified to refer to the parent table by its new name. The text of the child CREATE TABLE statement or statements stored in the sqlite_master table are modified to reflect the new parent table name.</source>
          <target state="translated">Если &quot;АЛЬТЕР-ТАБЛИЦА&quot; ...RENAME TO&quot; используется для переименования таблицы,являющейся родительской таблицей одного или нескольких ограничений внешнего ключа,определения ограничений внешнего ключа изменяются для обращения к родительской таблице по ее новому имени.Текст оператора дочерней CREATE TABLE или операторов,хранящихся в таблице sqlite_master,изменяется для отражения нового имени родительской таблицы.</target>
        </trans-unit>
        <trans-unit id="7603e9a69b7a72c62bbc679327133633953ff9aa" translate="yes" xml:space="preserve">
          <source>If an &lt;a href=&quot;#sqlite3&quot;&gt;sqlite3&lt;/a&gt; object is destroyed while a transaction is open, the transaction is automatically rolled back.</source>
          <target state="translated">Если объект &lt;a href=&quot;#sqlite3&quot;&gt;sqlite3&lt;/a&gt; уничтожается во время открытия транзакции, транзакция автоматически откатывается.</target>
        </trans-unit>
        <trans-unit id="53a3481d0fa9e30b2f0d27a6044ee94e1a62bb9b" translate="yes" xml:space="preserve">
          <source>If an &lt;a href=&quot;../lang_insert&quot;&gt;INSERT&lt;/a&gt; occurs within a trigger then this routine will return the &lt;a href=&quot;../lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; of the inserted row as long as the trigger is running. Once the trigger program ends, the value returned by this routine reverts to what it was before the trigger was fired.</source>
          <target state="translated">Если &lt;a href=&quot;../lang_insert&quot;&gt;INSERT&lt;/a&gt; происходит в триггере, эта процедура будет возвращать &lt;a href=&quot;../lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; вставленной строки, пока триггер работает. После завершения программы триггера значение, возвращаемое этой подпрограммой, возвращается к тому, что было до срабатывания триггера.</target>
        </trans-unit>
        <trans-unit id="877e1b4a7430ba11b48b32c5598ad0c65dc34442" translate="yes" xml:space="preserve">
          <source>If an &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; occurs within a trigger then this routine will return the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; of the inserted row as long as the trigger is running. Once the trigger program ends, the value returned by this routine reverts to what it was before the trigger was fired.</source>
          <target state="translated">Если &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; происходит в триггере, эта процедура будет возвращать &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; вставленной строки, пока триггер работает. После завершения программы триггера значение, возвращаемое этой подпрограммой, возвращается к тому, что было до срабатывания триггера.</target>
        </trans-unit>
        <trans-unit id="b95cb40fc8352b696796b3bff79e2f006b1ce07a" translate="yes" xml:space="preserve">
          <source>If an &lt;a href=&quot;sqlite3&quot;&gt;sqlite3&lt;/a&gt; object is destroyed while a transaction is open, the transaction is automatically rolled back.</source>
          <target state="translated">Если объект &lt;a href=&quot;sqlite3&quot;&gt;sqlite3&lt;/a&gt; уничтожается во время открытия транзакции, транзакция автоматически откатывается.</target>
        </trans-unit>
        <trans-unit id="9f62d9384e44621989efc3c00f1a3ba721b2e39d" translate="yes" xml:space="preserve">
          <source>If an FTS5 table is configured with columnsize=0 but is not a &lt;a href=&quot;fts5#contentless_tables&quot;&gt;contentless table&lt;/a&gt;, the xColumnSize API function still works, but runs much more slowly. In this case, instead of reading the value to return directly from the database, it reads the text value itself and count the tokens within it on demand.</source>
          <target state="translated">Если таблица FTS5 настроена со значением columnsize = 0, но не является &lt;a href=&quot;fts5#contentless_tables&quot;&gt;таблицей без&lt;/a&gt; содержимого, функция API xColumnSize по-прежнему работает, но работает намного медленнее. В этом случае вместо чтения возвращаемого значения непосредственно из базы данных он считывает само текстовое значение и по требованию подсчитывает токены в нем.</target>
        </trans-unit>
        <trans-unit id="a593df8166351f80d07eb58cb262614d9dbc8634" translate="yes" xml:space="preserve">
          <source>If an INSERT statement attempts to insert a NULL value into a rowid or integer primary key column, the system chooses an integer value to use as the rowid automatically. A detailed description of how this is done is provided &lt;a href=&quot;autoinc&quot;&gt;separately&lt;/a&gt;.</source>
          <target state="translated">Если оператор INSERT пытается вставить значение NULL в столбец первичного ключа rowid или integer, система автоматически выбирает целочисленное значение для использования в качестве rowid. Подробное описание того, как это делается, предоставляется &lt;a href=&quot;autoinc&quot;&gt;отдельно&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ba4158b1467dce3a1f2ceab9abb8de00b0fe4463" translate="yes" xml:space="preserve">
          <source>If an ORDER BY clause is present, it determines the order in which rows are extracted from the queue in step 2a. If there is no ORDER BY clause, then the order in which rows are extracted is undefined. (In the current implementation, the queue becomes a FIFO if the ORDER BY clause is omitted, but applications should not depend on that fact since it might change.)</source>
          <target state="translated">Если присутствует пункт ORDER BY,то он определяет порядок извлечения строк из очереди на шаге 2a.Если пункта &quot;ORDER BY&quot; нет,то порядок извлечения строк из очереди не определен.(В текущей реализации очередь становится FIFO,если опущено условие ORDER BY,но приложения не должны зависеть от этого факта,так как он может измениться).</target>
        </trans-unit>
        <trans-unit id="22141c686821647d4155d6b151a8d8fa154cd1a8" translate="yes" xml:space="preserve">
          <source>If an SQL operation is very nearly finished at the time when sqlite3_interrupt() is called, then it might not have an opportunity to be interrupted and might continue to completion.</source>
          <target state="translated">Если на момент вызова sqlite3_interrupt()SQL-операция почти завершена,то она может не иметь возможности быть прервана и продолжить выполнение.</target>
        </trans-unit>
        <trans-unit id="923eabd2cf996c975383b0dccd3e5fb8dc063dde" translate="yes" xml:space="preserve">
          <source>If an SQL statement is limited to be a million bytes in length, then obviously you will not be able to insert multi-million byte strings by embedding them as literals inside of INSERT statements. But you should not do that anyway. Use host &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameters&lt;/a&gt; for your data. Prepare short SQL statements like this:</source>
          <target state="translated">Если длина оператора SQL ограничена миллионом байтов, очевидно, что вы не сможете вставлять многомиллионные строки байтов, вставляя их как литералы внутри операторов INSERT. Но все равно этого делать не стоит. Используйте &lt;a href=&quot;lang_expr#varparam&quot;&gt;параметры&lt;/a&gt; хоста для ваших данных. Подготовьте короткие операторы SQL, подобные этому:</target>
        </trans-unit>
        <trans-unit id="a519000750401db43c985f6fefc862d71c74bede" translate="yes" xml:space="preserve">
          <source>If an SQL table is created using the &quot;WITHOUT ROWID&quot; clause at the end of its CREATE TABLE statement, then that table is a &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; table and uses a different on-disk representation. A WITHOUT ROWID table uses an index b-tree rather than a table b-tree for storage. The key for each entry in the WITHOUT ROWID b-tree is a record composed of the columns of the PRIMARY KEY followed by all remaining columns of the table. The primary key columns appear in the order they they were declared in the PRIMARY KEY clause and the remaining columns appear in the order they occur in the CREATE TABLE statement.</source>
          <target state="translated">Если таблица SQL создается с использованием предложения WITHOUT ROWID в конце оператора CREATE TABLE, то эта таблица является таблицей &lt;a href=&quot;withoutrowid&quot;&gt;БЕЗ ROWID&lt;/a&gt; и использует другое представление на диске. Таблица БЕЗ ROWID использует для хранения b-дерево индекса, а не b-дерево таблицы. Ключ для каждой записи в b-дереве БЕЗ ROWID - это запись, состоящая из столбцов ПЕРВИЧНОГО КЛЮЧА, за которыми следуют все оставшиеся столбцы таблицы. Столбцы первичного ключа появляются в том порядке, в котором они были объявлены в предложении PRIMARY KEY, а остальные столбцы появляются в том порядке, в котором они встречаются в операторе CREATE TABLE.</target>
        </trans-unit>
        <trans-unit id="7a1f15ef308e23ec2fc80a29e25882265ebf0786" translate="yes" xml:space="preserve">
          <source>If an UPDATE statement attempts to set an integer primary key or rowid column to a NULL or blob value, or to a string or real value that cannot be losslessly converted to an integer, a &quot;datatype mismatch&quot; error occurs and the statement is aborted. If an INSERT statement attempts to insert a blob value, or a string or real value that cannot be losslessly converted to an integer into an integer primary key or rowid column, a &quot;datatype mismatch&quot; error occurs and the statement is aborted.</source>
          <target state="translated">Если оператор UPDATE пытается установить целочисленный первичный ключ или рядный столбец в значение NULL или blob,или в строку или вещественное значение,которое не может быть без потерь преобразовано в целое число,возникает ошибка &quot;несоответствия типа данных&quot;,и оператор прерывается.Если оператор INSERT пытается вставить блочное или строковое или вещественное значение,которое не может быть без потерь преобразовано в целое число,в целочисленный первичный ключ или рядный столбец,возникает ошибка несоответствия типа данных,и оператор прерывается.</target>
        </trans-unit>
        <trans-unit id="284b34da69fbf9cd89926df318af7634184253b9" translate="yes" xml:space="preserve">
          <source>If an UPDATE statement has a LIMIT clause, the maximum number of rows that will be updated is found by evaluating the accompanying expression and casting it to an integer value. A negative value is interpreted as &quot;no limit&quot;.</source>
          <target state="translated">Если оператор UPDATE имеет выражение LIMIT,максимальное количество строк,которые будут обновлены,будет найдено путем вычисления сопровождающего выражения и приведения его к целому значению.Отрицательное значение интерпретируется как &quot;нет предела&quot;.</target>
        </trans-unit>
        <trans-unit id="35654cca0e06875d8f71c06cdb825a502007ac27" translate="yes" xml:space="preserve">
          <source>If an application issues a SELECT statement on a single table like &quot;</source>
          <target state="translated">Если приложение выпускает заявление SELECT на одной таблице,например,&quot;</target>
        </trans-unit>
        <trans-unit id="3c9847a3fc8345f21ef2aae877b6da29936db6dc" translate="yes" xml:space="preserve">
          <source>If an application puts SQLite in &lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;exclusive locking mode&lt;/a&gt; using the pragma:</source>
          <target state="translated">Если приложение переводит SQLite в &lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;режим монопольной блокировки,&lt;/a&gt; используя прагму:</target>
        </trans-unit>
        <trans-unit id="16930c87a89e5aa4dacec21b97a534c286412312" translate="yes" xml:space="preserve">
          <source>If an application using asynchronous IO executes transactions in quick succession, other database users may be effectively locked out of the database. This is because when a &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt; is executed, a database lock is established immediately. But when the corresponding COMMIT or ROLLBACK occurs, the lock is not released until the relevant part of the write-queue has been flushed through. As a result, if a COMMIT is followed by a BEGIN before the write-queue is flushed through, the database is never unlocked,preventing other processes from accessing the database.</source>
          <target state="translated">Если приложение, использующее асинхронный ввод-вывод, выполняет транзакции в быстрой последовательности, другие пользователи базы данных могут быть фактически заблокированы из базы данных. Это связано с тем, что при выполнении &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt; блокировка базы данных устанавливается немедленно. Но когда происходит соответствующий COMMIT или ROLLBACK, блокировка не снимается, пока соответствующая часть очереди записи не будет очищена. В результате, если за COMMIT следует BEGIN до того, как очередь записи будет очищена, база данных никогда не будет разблокирована, что предотвратит доступ других процессов к базе данных.</target>
        </trans-unit>
        <trans-unit id="dec67a679cc10b4fb4ca0df679f1b42a8a809bf0" translate="yes" xml:space="preserve">
          <source>If an attempt to acquire a</source>
          <target state="translated">При попытке приобретения</target>
        </trans-unit>
        <trans-unit id="ae2dad7a2ac6f9639d4f707a82a9b585c9a56bd8" translate="yes" xml:space="preserve">
          <source>If an attempt to upgrade to an</source>
          <target state="translated">При попытке перейти на</target>
        </trans-unit>
        <trans-unit id="0f4ee50fd2b5b886cf93345554e2cb331273f09d" translate="yes" xml:space="preserve">
          <source>If an error (e.g. an OOM condition) occurs within this function, the auxiliary data is set to NULL and an error code returned. If the xDelete parameter was not NULL, it is invoked on the auxiliary data pointer before returning.</source>
          <target state="translated">Если в рамках этой функции возникает ошибка (например,состояние OOM),то вспомогательные данные устанавливаются на NULL и возвращается код ошибки.Если параметр xDelete не был NULL,то перед возвратом он вызывается на вспомогательном указателе данных.</target>
        </trans-unit>
        <trans-unit id="8045cc0ef3fd13ca44d5e4369a94674b9f7300cd" translate="yes" xml:space="preserve">
          <source>If an error occurs in any of the three main backup API routines then the &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; and &lt;a href=&quot;c3ref/errcode&quot;&gt;message&lt;/a&gt; are attached to the destination &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt;. Additionally, if &lt;a href=&quot;c3ref/backup_finish#sqlite3backupstep&quot;&gt;sqlite3_backup_step()&lt;/a&gt; encounters an error, then the &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; is returned by both the &lt;a href=&quot;c3ref/backup_finish#sqlite3backupstep&quot;&gt;sqlite3_backup_step()&lt;/a&gt; call itself, and by the subsequent call to &lt;a href=&quot;c3ref/backup_finish#sqlite3backupfinish&quot;&gt;sqlite3_backup_finish()&lt;/a&gt;. So a call to &lt;a href=&quot;c3ref/backup_finish#sqlite3backupfinish&quot;&gt;sqlite3_backup_finish()&lt;/a&gt; does not overwrite an &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; stored in the destination &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; by &lt;a href=&quot;c3ref/backup_finish#sqlite3backupstep&quot;&gt;sqlite3_backup_step()&lt;/a&gt;. This feature is used in the example code to reduce amount of error handling required. The return values of the &lt;a href=&quot;c3ref/backup_finish#sqlite3backupstep&quot;&gt;sqlite3_backup_step()&lt;/a&gt; and &lt;a href=&quot;c3ref/backup_finish#sqlite3backupfinish&quot;&gt;sqlite3_backup_finish()&lt;/a&gt; calls are ignored and the error code indicating the success or failure of the copy operation collected from the destination &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; afterward.</source>
          <target state="translated">Если ошибка возникает в любой из трех основных подпрограмм API резервного копирования, &lt;a href=&quot;rescode&quot;&gt;код ошибки&lt;/a&gt; и &lt;a href=&quot;c3ref/errcode&quot;&gt;сообщение&lt;/a&gt; прикрепляются к целевому &lt;a href=&quot;c3ref/sqlite3&quot;&gt;соединению с базой данных&lt;/a&gt; . Кроме того, если &lt;a href=&quot;c3ref/backup_finish#sqlite3backupstep&quot;&gt;sqlite3_backup_step ()&lt;/a&gt; обнаруживает ошибку, &lt;a href=&quot;rescode&quot;&gt;код ошибки&lt;/a&gt; возвращается как самим вызовом &lt;a href=&quot;c3ref/backup_finish#sqlite3backupstep&quot;&gt;sqlite3_backup_step ()&lt;/a&gt; , так и последующим вызовом &lt;a href=&quot;c3ref/backup_finish#sqlite3backupfinish&quot;&gt;sqlite3_backup_finish ()&lt;/a&gt; . Таким образом, вызов &lt;a href=&quot;c3ref/backup_finish#sqlite3backupfinish&quot;&gt;sqlite3_backup_finish ()&lt;/a&gt; не перезаписывает &lt;a href=&quot;rescode&quot;&gt;код ошибки,&lt;/a&gt; хранящийся в соединении с целевой &lt;a href=&quot;c3ref/sqlite3&quot;&gt;базой данных с&lt;/a&gt; помощью &lt;a href=&quot;c3ref/backup_finish#sqlite3backupstep&quot;&gt;sqlite3_backup_step ()&lt;/a&gt;. Эта функция используется в примере кода, чтобы уменьшить объем необходимой обработки ошибок. Возвращаемые значения вызовов &lt;a href=&quot;c3ref/backup_finish#sqlite3backupstep&quot;&gt;sqlite3_backup_step ()&lt;/a&gt; и &lt;a href=&quot;c3ref/backup_finish#sqlite3backupfinish&quot;&gt;sqlite3_backup_finish ()&lt;/a&gt; игнорируются, а код ошибки, указывающий на успех или неудачу операции копирования, впоследствии собирается из соединения с целевой &lt;a href=&quot;c3ref/sqlite3&quot;&gt;базой данных&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e8416d9f169797cd1d1df3d689a0f3981d1e1914" translate="yes" xml:space="preserve">
          <source>If an error occurs while evaluating the SQL statements passed into sqlite3_exec(), then execution of the current statement stops and subsequent statements are skipped. If the 5th parameter to sqlite3_exec() is not NULL then any error message is written into memory obtained from &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc()&lt;/a&gt; and passed back through the 5th parameter. To avoid memory leaks, the application should invoke &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free()&lt;/a&gt; on error message strings returned through the 5th parameter of sqlite3_exec() after the error message string is no longer needed. If the 5th parameter to sqlite3_exec() is not NULL and no errors occur, then sqlite3_exec() sets the pointer in its 5th parameter to NULL before returning.</source>
          <target state="translated">Если ошибка возникает при оценке операторов SQL, переданных в sqlite3_exec (), выполнение текущего оператора останавливается, а последующие операторы пропускаются. Если 5-й параметр sqlite3_exec () не равен NULL, то любое сообщение об ошибке записывается в память, полученная из &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc (),&lt;/a&gt; и передается обратно через 5-й параметр. Чтобы избежать утечек памяти, приложение должно вызывать &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free ()&lt;/a&gt; для строк сообщений об ошибках, возвращаемых через 5-й параметр sqlite3_exec () после того, как строка сообщения об ошибке больше не нужна. Если 5-й параметр sqlite3_exec () не равен NULL и ошибок не возникает, то sqlite3_exec () устанавливает указатель в своем 5-м параметре в NULL перед возвратом.</target>
        </trans-unit>
        <trans-unit id="67c739deca1fc659fe9011cffdf430f71e9a737b" translate="yes" xml:space="preserve">
          <source>If an error occurs while evaluating the SQL statements passed into sqlite3_exec(), then execution of the current statement stops and subsequent statements are skipped. If the 5th parameter to sqlite3_exec() is not NULL then any error message is written into memory obtained from &lt;a href=&quot;free&quot;&gt;sqlite3_malloc()&lt;/a&gt; and passed back through the 5th parameter. To avoid memory leaks, the application should invoke &lt;a href=&quot;free&quot;&gt;sqlite3_free()&lt;/a&gt; on error message strings returned through the 5th parameter of sqlite3_exec() after the error message string is no longer needed. If the 5th parameter to sqlite3_exec() is not NULL and no errors occur, then sqlite3_exec() sets the pointer in its 5th parameter to NULL before returning.</source>
          <target state="translated">Если ошибка возникает при оценке операторов SQL, переданных в sqlite3_exec (), выполнение текущего оператора останавливается, а последующие операторы пропускаются. Если 5-й параметр sqlite3_exec () не равен NULL, то любое сообщение об ошибке записывается в память, полученная из &lt;a href=&quot;free&quot;&gt;sqlite3_malloc (),&lt;/a&gt; и передается обратно через 5-й параметр. Чтобы избежать утечек памяти, приложение должно вызывать &lt;a href=&quot;free&quot;&gt;sqlite3_free ()&lt;/a&gt; для строк сообщений об ошибках, возвращаемых через 5-й параметр sqlite3_exec () после того, как строка сообщения об ошибке больше не нужна. Если 5-й параметр sqlite3_exec () не равен NULL и ошибок не возникает, то sqlite3_exec () устанавливает указатель в своем 5-м параметре в NULL перед возвратом.</target>
        </trans-unit>
        <trans-unit id="194a0b44e46a56e474b265407cd79a961ab1ee3b" translate="yes" xml:space="preserve">
          <source>If an error occurs within sqlite3_backup_init(D,N,S,M), then NULL is returned and an error code and error message are stored in the destination &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; D. The error code and message for the failed call to sqlite3_backup_init() can be retrieved using the &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errcode()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errmsg()&lt;/a&gt;, and/or &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errmsg16()&lt;/a&gt; functions. A successful call to sqlite3_backup_init() returns a pointer to an &lt;a href=&quot;#sqlite3_backup&quot;&gt;sqlite3_backup&lt;/a&gt; object. The &lt;a href=&quot;#sqlite3_backup&quot;&gt;sqlite3_backup&lt;/a&gt; object may be used with the sqlite3_backup_step() and sqlite3_backup_finish() functions to perform the specified backup operation.</source>
          <target state="translated">Если ошибка возникает в sqlite3_backup_init (D, N, S, M), то возвращается NULL, а код ошибки и сообщение об ошибке сохраняются в целевом &lt;a href=&quot;#sqlite3&quot;&gt;соединении с базой данных&lt;/a&gt; D. Код ошибки и сообщение для неудачного вызова sqlite3_backup_init () могут можно получить с помощью функций &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errcode ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errmsg ()&lt;/a&gt; и / или &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errmsg16 ()&lt;/a&gt; . Успешный вызов sqlite3_backup_init () возвращает указатель на объект &lt;a href=&quot;#sqlite3_backup&quot;&gt;sqlite3_backup&lt;/a&gt; . Объект &lt;a href=&quot;#sqlite3_backup&quot;&gt;sqlite3_backup&lt;/a&gt; можно использовать с функциями sqlite3_backup_step () и sqlite3_backup_finish () для выполнения указанной операции резервного копирования.</target>
        </trans-unit>
        <trans-unit id="1200818faf5a8fe2f6854c6a6851d33b2f623b3d" translate="yes" xml:space="preserve">
          <source>If an error occurs within sqlite3_backup_init(D,N,S,M), then NULL is returned and an error code and error message are stored in the destination &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; D. The error code and message for the failed call to sqlite3_backup_init() can be retrieved using the &lt;a href=&quot;errcode&quot;&gt;sqlite3_errcode()&lt;/a&gt;, &lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg()&lt;/a&gt;, and/or &lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg16()&lt;/a&gt; functions. A successful call to sqlite3_backup_init() returns a pointer to an &lt;a href=&quot;backup&quot;&gt;sqlite3_backup&lt;/a&gt; object. The &lt;a href=&quot;backup&quot;&gt;sqlite3_backup&lt;/a&gt; object may be used with the sqlite3_backup_step() and sqlite3_backup_finish() functions to perform the specified backup operation.</source>
          <target state="translated">Если ошибка возникает в sqlite3_backup_init (D, N, S, M), то возвращается NULL, а код ошибки и сообщение об ошибке сохраняются в целевом &lt;a href=&quot;sqlite3&quot;&gt;соединении с базой данных&lt;/a&gt; D. Код ошибки и сообщение для неудачного вызова sqlite3_backup_init () могут можно получить с помощью функций &lt;a href=&quot;errcode&quot;&gt;sqlite3_errcode ()&lt;/a&gt; , &lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg ()&lt;/a&gt; и / или &lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg16 ()&lt;/a&gt; . Успешный вызов sqlite3_backup_init () возвращает указатель на объект &lt;a href=&quot;backup&quot;&gt;sqlite3_backup&lt;/a&gt; . Объект &lt;a href=&quot;backup&quot;&gt;sqlite3_backup&lt;/a&gt; можно использовать с функциями sqlite3_backup_step () и sqlite3_backup_finish () для выполнения указанной операции резервного копирования.</target>
        </trans-unit>
        <trans-unit id="100ded69e0a780b44961df68d1032c0e7c075797" translate="yes" xml:space="preserve">
          <source>If an error occurs, an SQLite error code is returned and the output variables (*pnData) and (*ppData) are set to 0. Otherwise, SQLITE_OK is returned and the output variables are set to the size of and a pointer to the output buffer, respectively. In this case it is the responsibility of the caller to eventually free the buffer using a call to sqlite3_free().</source>
          <target state="translated">При возникновении ошибки возвращается код ошибки SQLite и выходные переменные (*pnData)и (*ppData)устанавливаются в 0,в противном случае возвращается SQLITE_OK и выходные переменные устанавливаются в размер выходного буфера и указатель на него соответственно.В этом случае ответственность за окончательное освобождение буфера возлагается на вызывающего абонента с помощью вызова sqlite3_free().</target>
        </trans-unit>
        <trans-unit id="622e26e115262f02ac7f60da2462323cdc540b9f" translate="yes" xml:space="preserve">
          <source>If an error occurs, an SQLite error code is returned. Possible error codes include SQLITE_CORRUPT (if the changeset buffer is corrupt) or SQLITE_NOMEM.</source>
          <target state="translated">При возникновении ошибки возвращается код ошибки SQLite.Возможные коды ошибок включают в себя SQLITE_CORRUPT (если буфер changeset поврежден)или SQLITE_NOMEM.</target>
        </trans-unit>
        <trans-unit id="e455ebdd54ae8a16893e6de74ee6f1db7c5e35d7" translate="yes" xml:space="preserve">
          <source>If an error was encountered within a call to an sqlite3changeset_xxx() function (for example an &lt;a href=&quot;../rescode#corrupt&quot;&gt;SQLITE_CORRUPT&lt;/a&gt; in &lt;a href=&quot;sqlite3changeset_next&quot;&gt;sqlite3changeset_next()&lt;/a&gt; or an &lt;a href=&quot;../rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt; in &lt;a href=&quot;sqlite3changeset_new&quot;&gt;sqlite3changeset_new()&lt;/a&gt;) then an error code corresponding to that error is returned by this function. Otherwise, SQLITE_OK is returned. This is to allow the following pattern (pseudo-code):</source>
          <target state="translated">Если при вызове функции sqlite3changeset_xxx () возникла ошибка (например, &lt;a href=&quot;../rescode#corrupt&quot;&gt;SQLITE_CORRUPT&lt;/a&gt; в &lt;a href=&quot;sqlite3changeset_next&quot;&gt;sqlite3changeset_next ()&lt;/a&gt; или &lt;a href=&quot;../rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt; в &lt;a href=&quot;sqlite3changeset_new&quot;&gt;sqlite3changeset_new ()&lt;/a&gt; ), то эта функция возвращает код ошибки, соответствующий этой ошибке. В противном случае возвращается SQLITE_OK. Это позволяет использовать следующий шаблон (псевдокод):</target>
        </trans-unit>
        <trans-unit id="1bc5bca387ff960fe9687401573a47507a4fa49f" translate="yes" xml:space="preserve">
          <source>If an error was encountered within a call to an sqlite3changeset_xxx() function (for example an &lt;a href=&quot;rescode#corrupt&quot;&gt;SQLITE_CORRUPT&lt;/a&gt; in &lt;a href=&quot;#sqlite3changeset_next&quot;&gt;sqlite3changeset_next()&lt;/a&gt; or an &lt;a href=&quot;rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt; in &lt;a href=&quot;#sqlite3changeset_new&quot;&gt;sqlite3changeset_new()&lt;/a&gt;) then an error code corresponding to that error is returned by this function. Otherwise, SQLITE_OK is returned. This is to allow the following pattern (pseudo-code):</source>
          <target state="translated">Если при вызове функции sqlite3changeset_xxx () возникла ошибка (например, &lt;a href=&quot;rescode#corrupt&quot;&gt;SQLITE_CORRUPT&lt;/a&gt; в &lt;a href=&quot;#sqlite3changeset_next&quot;&gt;sqlite3changeset_next ()&lt;/a&gt; или &lt;a href=&quot;rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt; в &lt;a href=&quot;#sqlite3changeset_new&quot;&gt;sqlite3changeset_new ()&lt;/a&gt; ), то эта функция возвращает код ошибки, соответствующий этой ошибке. В противном случае возвращается SQLITE_OK. Это позволяет использовать следующий шаблон (псевдокод):</target>
        </trans-unit>
        <trans-unit id="1b680ceb7d64040ce2b6564485c5ca5b1c9689a0" translate="yes" xml:space="preserve">
          <source>If an fts5vocab table is created in the temp database, it may be associated with an FTS5 table in any attached database. In order to attach the fts5vocab table to an FTS5 table located in a database other than &quot;temp&quot;, the name of the database is inserted before the FTS5 table name in the CREATE VIRTUAL TABLE arguments. For example:</source>
          <target state="translated">Если таблица fts5vocab создана в базе данных temp,то она может быть связана с таблицей FTS5 в любой подключенной базе данных.Для того чтобы присоединить таблицу fts5vocab к таблице FTS5,находящейся в БД,отличной от &quot;temp&quot;,имя БД вставляется перед именем таблицы FTS5 в аргументах CREATE VIRTUAL TABLE.Например:</target>
        </trans-unit>
        <trans-unit id="3334fd5a8f49d3b3b23387e0ded39340f08eab83" translate="yes" xml:space="preserve">
          <source>If an index is available on the ORDER BY column, that index can be used for sorting. Consider the request for all items sorted by &quot;fruit&quot;:</source>
          <target state="translated">Если индекс доступен в столбце ORDER BY,то этот индекс может быть использован для сортировки.Рассмотрим запрос на все элементы,отсортированные по &quot;фруктам&quot;:</target>
        </trans-unit>
        <trans-unit id="7ff3ecb138d9749f1bf1bb734a03098e601b851c" translate="yes" xml:space="preserve">
          <source>If an index is created using a statement like this:</source>
          <target state="translated">Если индекс создается с помощью такого оператора:</target>
        </trans-unit>
        <trans-unit id="19ed5776fff64746115879da20e80724a2114442" translate="yes" xml:space="preserve">
          <source>If an instance-list grows so large that it exceeds the &lt;a href=&quot;limits#max_length&quot;&gt;SQLITE_MAX_LENGTH&lt;/a&gt; limit, FTS3/4 is unable to handle it. FTS5 does not have this problem.</source>
          <target state="translated">Если экземпляр-список растет настолько велик , что превышает &lt;a href=&quot;limits#max_length&quot;&gt;SQLITE_MAX_LENGTH&lt;/a&gt; предела, FTS3 / 4 не в состоянии справиться с этим. FTS5 не имеет этой проблемы.</target>
        </trans-unit>
        <trans-unit id="e669868d5fcfe552cb1dbbc9c2998f5505f629e6" translate="yes" xml:space="preserve">
          <source>If an interface fails with SQLITE_MISUSE, that means the interface was invoked incorrectly by the application. In that case, the error code and message may or may not be set.</source>
          <target state="translated">Если интерфейс не работает с SQLITE_MISUSE,это означает,что интерфейс был вызван приложением некорректно.В этом случае код ошибки и сообщение могут быть установлены,а могут и не установлены.</target>
        </trans-unit>
        <trans-unit id="582fb0780f4838faf9f9c1524bd108b2fc64370c" translate="yes" xml:space="preserve">
          <source>If an out-of-memory error occurs, then the return value from these routines is the same as if the column had contained an SQL NULL value. Valid SQL NULL returns can be distinguished from out-of-memory errors by invoking the &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errcode()&lt;/a&gt; immediately after the suspect return value is obtained and before any other SQLite interface is called on the same &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt;.</source>
          <target state="translated">Если возникает ошибка нехватки памяти, то возвращаемое значение из этих подпрограмм такое же, как если бы столбец содержал значение SQL NULL. Верные возвращаемые значения SQL NULL можно отличить от ошибок нехватки памяти, вызвав &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errcode ()&lt;/a&gt; сразу после получения подозрительного возвращаемого значения и перед вызовом любого другого интерфейса SQLite в том же &lt;a href=&quot;#sqlite3&quot;&gt;соединении с базой данных&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5851016a3fb15ec26147b80722e832005884d3e4" translate="yes" xml:space="preserve">
          <source>If an out-of-memory error occurs, then the return value from these routines is the same as if the column had contained an SQL NULL value. Valid SQL NULL returns can be distinguished from out-of-memory errors by invoking the &lt;a href=&quot;errcode&quot;&gt;sqlite3_errcode()&lt;/a&gt; immediately after the suspect return value is obtained and before any other SQLite interface is called on the same &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt;.</source>
          <target state="translated">Если возникает ошибка нехватки памяти, то возвращаемое значение из этих подпрограмм такое же, как если бы столбец содержал значение SQL NULL. Верные возвращаемые значения SQL NULL можно отличить от ошибок нехватки памяти, вызвав &lt;a href=&quot;errcode&quot;&gt;sqlite3_errcode ()&lt;/a&gt; сразу после получения подозрительного возвращаемого значения и перед вызовом любого другого интерфейса SQLite в том же &lt;a href=&quot;sqlite3&quot;&gt;соединении с базой данных&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="53a860ff4ceaa780f514879a263f3e2bd7a64b45" translate="yes" xml:space="preserve">
          <source>If an sqlite3_exec() callback returns non-zero, the sqlite3_exec() routine returns SQLITE_ABORT without invoking the callback again and without running any subsequent SQL statements.</source>
          <target state="translated">Если sqlite3_exec()возвращает ненулевое значение,рутина sqlite3_exec()возвращает SQLITE_ABORT без повторного вызова и без выполнения последующих SQL-запросов.</target>
        </trans-unit>
        <trans-unit id="86f2a1856f49f287cef6815b989e3bcfc9f7c019" translate="yes" xml:space="preserve">
          <source>If an update is only partially applied to the target database by the time sqlite3rbu_close() is called, state information is saved within the state database if it exists, or otherwise in the RBU database. This allows subsequent processes to automatically resume the RBU update from where it left off. If state information is stored in the RBU database, it can be removed by dropping all tables whose names begin with &quot;rbu_&quot;.</source>
          <target state="translated">Если к моменту вызова sqlite3rbu_close()обновление только частично применяется к целевой базе данных,то информация о состоянии сохраняется в базе данных состояния,если она существует,или в базе данных RBU.Это позволяет последующим процессам автоматически возобновить обновление RBU с того места,на котором оно было остановлено.Если информация о состоянии хранится в базе данных RBU,то ее можно удалить,опустив все таблицы,имена которых начинаются с &quot;rbu_&quot;.</target>
        </trans-unit>
        <trans-unit id="bd175412c5f187514ee87168844f1bedfa975635" translate="yes" xml:space="preserve">
          <source>If an xToken() callback returns any value other than SQLITE_OK, then the tokenization should be abandoned and the xTokenize() method should immediately return a copy of the xToken() return value. Or, if the input buffer is exhausted, xTokenize() should return SQLITE_OK. Finally, if an error occurs with the xTokenize() implementation itself, it may abandon the tokenization and return any error code other than SQLITE_OK or SQLITE_DONE.</source>
          <target state="translated">Если обратный вызов xToken()возвращает любое значение,отличное от SQLITE_OK,то следует отказаться от токенирования и метод xTokenize()должен немедленно вернуть копию возвращаемого значения xToken().Или,если входной буфер исчерпан,xTokenize()должна вернуть SQLITE_OK.Наконец,если возникает ошибка с самой реализацией xTokenize(),то она может отказаться от токенирования и вернуть любой код ошибки,отличный от SQLITE_OK или SQLITE_DONE.</target>
        </trans-unit>
        <trans-unit id="0be452758cf5838f411f1a08b26770962254070e" translate="yes" xml:space="preserve">
          <source>If and only if the previously described conversion of OR to an IN operator does not work, the second OR-clause optimization is attempted. Suppose the OR clause consists of multiple subterms as follows:</source>
          <target state="translated">Если и только если описанное ранее преобразование &quot;ИЛИ&quot; в оператор IN не работает,то предпринимается попытка второй оптимизации &quot;ИЛИ&quot;.Предположим,что условие &quot;ИЛИ&quot; состоит из нескольких подзаголовков следующим образом:</target>
        </trans-unit>
        <trans-unit id="1d92fd7f31be8d1f3061a17050b41ab1479f4bcd" translate="yes" xml:space="preserve">
          <source>If another database connection has the database mode open in &lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;exclusive locking mode&lt;/a&gt; then all queries against the database will return &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;. Both Chrome and Firefox open their database files in exclusive locking mode, so attempts to read Chrome or Firefox databases while the applications are running will run into this problem, for example.</source>
          <target state="translated">Если для другого соединения с базой данных открыт режим базы данных в режиме &lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;монопольной блокировки,&lt;/a&gt; то все запросы к базе данных будут возвращать &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; . И Chrome, и Firefox открывают свои файлы баз данных в режиме монопольной блокировки, поэтому, например, попытки читать базы данных Chrome или Firefox во время работы приложений могут столкнуться с этой проблемой.</target>
        </trans-unit>
        <trans-unit id="52c07a908a81f106b3dd1bc1b1492081c7a35d47" translate="yes" xml:space="preserve">
          <source>If another thread changes the autocommit status of the database connection while this routine is running, then the return value is undefined.</source>
          <target state="translated">Если во время выполнения данной рутины другой поток изменит статус автокомммиссии соединения с БД,то возвращаемое значение будет неопределенным.</target>
        </trans-unit>
        <trans-unit id="8503a498072091f7cabc2db6a10e976de9bc12b1" translate="yes" xml:space="preserve">
          <source>If another thread or process writes to the source database while this function is sleeping, then SQLite detects this and usually restarts the backup process when sqlite3_backup_step() is next called. There is one exception to this rule: If the source database is not an in-memory database, and the write is performed from within the same process as the backup operation and uses the same database handle (pDb), then the destination database (the one opened using connection pFile) is automatically updated along with the source. The backup process may then be continued after the sqlite3_sleep() call returns as if nothing had happened.</source>
          <target state="translated">Если другой поток или процесс записывает в исходную базу данных,пока эта функция находится в спящем режиме,то SQLite обнаруживает это и обычно перезапускает процесс резервного копирования при следующем вызове sqlite3_backup_step().Есть одно исключение из этого правила:если исходная база данных не является базой данных в памяти,а запись выполняется из того же процесса,что и операция резервного копирования,и при этом используется тот же самый хэндл базы данных (pDb),то база данных получателя (открытая с помощью функции соединения pFile)автоматически обновляется вместе с исходной.Затем процесс резервного копирования может быть продолжен после того,как вызов sqlite3_sleep()вернется как ни в чем не бывало.</target>
        </trans-unit>
        <trans-unit id="b9f8be087686590dab771595e5bd54b7d246dba5" translate="yes" xml:space="preserve">
          <source>If any errors are encountered during compilation, an error message is written into memory obtained from &lt;b&gt;malloc&lt;/b&gt; and the 5th parameter is made to point to that memory. If the 5th parameter is NULL, then no error message is generated. If the 5th parameter is not NULL, then the calling function should dispose of the memory containing the error message by calling &lt;b&gt;sqlite_freemem&lt;/b&gt;.</source>
          <target state="translated">Если во время компиляции обнаруживаются какие-либо ошибки, сообщение об ошибке записывается в память, полученную из &lt;b&gt;malloc,&lt;/b&gt; и 5-й параметр указывается на эту память. Если 5-й параметр - ПУСТО (NULL), сообщение об ошибке не создается. Если 5-й параметр не равен NULL, вызывающая функция должна избавиться от памяти, содержащей сообщение об ошибке, путем вызова &lt;b&gt;sqlite_freemem&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="83125f64332cc16259858298cfafac27aca598bf" translate="yes" xml:space="preserve">
          <source>If any of the special-case entries shows above are omitted, then the value of 100 is used for insertion and deletion and 150 is used for substitution. To disable the default insertion, deletion, and/or substitution set their respective cost to 10000 or more.</source>
          <target state="translated">Если какая-либо из записей специального случая,показанных выше,опущена,то для вставки и удаления используется значение 100,а для подстановки-150.Чтобы отключить вставку,удаление и/или замену по умолчанию,установите их соответствующую стоимость равной 10000 или более.</target>
        </trans-unit>
        <trans-unit id="8b09289d91105f4036d96455156f97ad8f84efdf" translate="yes" xml:space="preserve">
          <source>If any of the sqlite3_bind_*() routines are called with a NULL pointer for the &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; or with a prepared statement for which &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; has been called more recently than &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset()&lt;/a&gt;, then the call will return &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_MISUSE&lt;/a&gt;. If any sqlite3_bind_() routine is passed a &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; that has been finalized, the result is undefined and probably harmful.</source>
          <target state="translated">Если какая-либо из подпрограмм sqlite3_bind _ * () вызывается с указателем NULL для &lt;a href=&quot;#sqlite3_stmt&quot;&gt;подготовленного оператора&lt;/a&gt; или с подготовленным оператором, для которого &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step ()&lt;/a&gt; был вызван позже, чем &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset ()&lt;/a&gt; , то вызов вернет &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_MISUSE&lt;/a&gt; . Если какой-либо подпрограмме sqlite3_bind_ () передается &lt;a href=&quot;#sqlite3_stmt&quot;&gt;подготовленный оператор&lt;/a&gt; , который был завершен, результат не определен и, вероятно, опасен.</target>
        </trans-unit>
        <trans-unit id="4d6ffdf1dd2e882d0d92b18297a217958bf3b943" translate="yes" xml:space="preserve">
          <source>If any of the sqlite3_bind_*() routines are called with a NULL pointer for the &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; or with a prepared statement for which &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; has been called more recently than &lt;a href=&quot;reset&quot;&gt;sqlite3_reset()&lt;/a&gt;, then the call will return &lt;a href=&quot;../rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt;. If any sqlite3_bind_() routine is passed a &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; that has been finalized, the result is undefined and probably harmful.</source>
          <target state="translated">Если какая-либо из подпрограмм sqlite3_bind _ * () вызывается с указателем NULL для &lt;a href=&quot;stmt&quot;&gt;подготовленного оператора&lt;/a&gt; или с подготовленным оператором, для которого &lt;a href=&quot;step&quot;&gt;sqlite3_step ()&lt;/a&gt; был вызван позже, чем &lt;a href=&quot;reset&quot;&gt;sqlite3_reset ()&lt;/a&gt; , то вызов вернет &lt;a href=&quot;../rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt; . Если какой-либо подпрограмме sqlite3_bind_ () передается &lt;a href=&quot;stmt&quot;&gt;подготовленный оператор&lt;/a&gt; , который был завершен, результат не определен и, вероятно, опасен.</target>
        </trans-unit>
        <trans-unit id="ecc451199e804c2d9bbaab7eeb8ae7260c861c03" translate="yes" xml:space="preserve">
          <source>If any of these options are defined, then the same set of SQLITE_OMIT_* options must also be defined when using the &lt;a href=&quot;lemon&quot;&gt;Lemon parser generator&lt;/a&gt; tool to generate the parse.c file and when compiling the 'mkkeywordhash' tool which generates the keywordhash.h file. Because of this, these options may only be used when the library is built from canonical source, not from the &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt;. Some SQLITE_OMIT_* options might work, or appear to work, when used with the &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt;. But this is not guaranteed. In general, always compile from canonical sources in order to take advantage of SQLITE_OMIT_* options.</source>
          <target state="translated">Если какой-либо из этих параметров определен, то такой же набор параметров SQLITE_OMIT_ * также должен быть определен при использовании инструмента &lt;a href=&quot;lemon&quot;&gt;генератора синтаксического анализатора Lemon&lt;/a&gt; для создания файла parse.c и при компиляции инструмента mkkeywordhash, который генерирует файл keywordhash.h. По этой причине эти параметры могут использоваться только в том случае, если библиотека построена из канонического источника, а не из &lt;a href=&quot;amalgamation&quot;&gt;объединения&lt;/a&gt; . Некоторые параметры SQLITE_OMIT_ * могут работать или казаться работающими при использовании с &lt;a href=&quot;amalgamation&quot;&gt;объединением&lt;/a&gt; . Но это не гарантируется. В общем, всегда компилируйте из канонических источников, чтобы воспользоваться опциями SQLITE_OMIT_ *.</target>
        </trans-unit>
        <trans-unit id="066af8ac5653f5f78e3e77b86a9535152f8106eb" translate="yes" xml:space="preserve">
          <source>If any other constraint violation occurs while applying a change (i.e. a UNIQUE, CHECK or NOT NULL constraint), the conflict handler is invoked with CHANGESET_CONSTRAINT as the second argument.</source>
          <target state="translated">Если при применении изменения происходит какое-либо другое нарушение ограничения (т.е.ограничение UNIQUE,CHECK или NOT NULL),то обработчик конфликта вызывается со вторым аргументом CHANGESET_CONSTRAINT.</target>
        </trans-unit>
        <trans-unit id="c1ffcbd8edc1e59c920bc1e42ef8ae6a08f1c489" translate="yes" xml:space="preserve">
          <source>If any other error occurs while flushing dirty pages to disk (for example an IO error or out-of-memory condition), then processing is abandoned and an SQLite &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; is returned to the caller immediately.</source>
          <target state="translated">Если при сбросе грязных страниц на диск возникает какая-либо другая ошибка (например, ошибка ввода-вывода или нехватка памяти), обработка прекращается, и вызывающей стороне немедленно возвращается &lt;a href=&quot;../rescode&quot;&gt;код ошибки&lt;/a&gt; SQLite .</target>
        </trans-unit>
        <trans-unit id="547159ba42f3dd194cd2ac6c73df9dfb51226b89" translate="yes" xml:space="preserve">
          <source>If any other error occurs while flushing dirty pages to disk (for example an IO error or out-of-memory condition), then processing is abandoned and an SQLite &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; is returned to the caller immediately.</source>
          <target state="translated">Если при сбросе грязных страниц на диск возникает какая-либо другая ошибка (например, ошибка ввода-вывода или нехватка памяти), обработка прекращается, и вызывающей стороне немедленно возвращается &lt;a href=&quot;rescode&quot;&gt;код ошибки&lt;/a&gt; SQLite .</target>
        </trans-unit>
        <trans-unit id="ed9a42f661215804821abb386ff5f31ffa1294e2" translate="yes" xml:space="preserve">
          <source>If any prior errors have occurred while constructing the dynamic string in sqlite3_str X, then the &lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_errcode(X)&lt;/a&gt; method will return an appropriate error code. The &lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_errcode(X)&lt;/a&gt; method returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOMEM&lt;/a&gt; following any out-of-memory error, or &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_TOOBIG&lt;/a&gt; if the size of the dynamic string exceeds &lt;a href=&quot;limits#max_length&quot;&gt;SQLITE_MAX_LENGTH&lt;/a&gt;, or &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; if there have been no errors.</source>
          <target state="translated">Если при построении динамической строки в sqlite3_str X произошли какие-либо предыдущие ошибки, то метод &lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_errcode (X)&lt;/a&gt; вернет соответствующий код ошибки. Метод &lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_errcode (X)&lt;/a&gt; возвращает &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOMEM&lt;/a&gt; после любой ошибки &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;нехватки&lt;/a&gt; памяти или SQLITE_TOOBIG, если размер динамической строки превышает &lt;a href=&quot;limits#max_length&quot;&gt;SQLITE_MAX_LENGTH&lt;/a&gt; , или &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK,&lt;/a&gt; если ошибок не было.</target>
        </trans-unit>
        <trans-unit id="2797997123bd9f48d4b03d213989316f5ee2db3a" translate="yes" xml:space="preserve">
          <source>If any prior errors have occurred while constructing the dynamic string in sqlite3_str X, then the &lt;a href=&quot;str_errcode&quot;&gt;sqlite3_str_errcode(X)&lt;/a&gt; method will return an appropriate error code. The &lt;a href=&quot;str_errcode&quot;&gt;sqlite3_str_errcode(X)&lt;/a&gt; method returns &lt;a href=&quot;../rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt; following any out-of-memory error, or &lt;a href=&quot;../rescode#toobig&quot;&gt;SQLITE_TOOBIG&lt;/a&gt; if the size of the dynamic string exceeds &lt;a href=&quot;../limits#max_length&quot;&gt;SQLITE_MAX_LENGTH&lt;/a&gt;, or &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; if there have been no errors.</source>
          <target state="translated">Если при построении динамической строки в sqlite3_str X произошли какие-либо предыдущие ошибки, то метод &lt;a href=&quot;str_errcode&quot;&gt;sqlite3_str_errcode (X)&lt;/a&gt; вернет соответствующий код ошибки. Метод &lt;a href=&quot;str_errcode&quot;&gt;sqlite3_str_errcode (X)&lt;/a&gt; возвращает &lt;a href=&quot;../rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt; после любой ошибки &lt;a href=&quot;../rescode#toobig&quot;&gt;нехватки&lt;/a&gt; памяти или SQLITE_TOOBIG, если размер динамической строки превышает &lt;a href=&quot;../limits#max_length&quot;&gt;SQLITE_MAX_LENGTH&lt;/a&gt; , или &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK,&lt;/a&gt; если ошибок не было.</target>
        </trans-unit>
        <trans-unit id="8cf62e1e5822970ab1a0772544bba1f6a9886bdb" translate="yes" xml:space="preserve">
          <source>If any views refer to table X in a way that is affected by the schema change, then drop those views using &lt;a href=&quot;lang_dropview&quot;&gt;DROP VIEW&lt;/a&gt; and recreate them with whatever changes are necessary to accommodate the schema change using &lt;a href=&quot;lang_createview&quot;&gt;CREATE VIEW&lt;/a&gt;.</source>
          <target state="translated">Если какие-либо представления ссылаются на таблицу X способом, на который влияет изменение схемы, отбросьте эти представления с помощью &lt;a href=&quot;lang_dropview&quot;&gt;DROP VIEW&lt;/a&gt; и воссоздайте их с любыми изменениями, необходимыми для адаптации к изменению схемы с помощью &lt;a href=&quot;lang_createview&quot;&gt;CREATE VIEW&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f4bcba20e82a98be0954f7a995f190f8be3b9e76" translate="yes" xml:space="preserve">
          <source>If argument P3 is non-zero, then it indicates that the sorter may assume that a stable sort considering the first P3 fields of each key is sufficient to produce the required results.</source>
          <target state="translated">Если аргумент P3 ненулевой,то это указывает на то,что сортировщик может предположить,что стабильный сорт,учитывающий первые поля P3 каждого ключа,достаточен для получения требуемого результата.</target>
        </trans-unit>
        <trans-unit id="35693c95846989c47eb6a922b6389598e5e5c2ef" translate="yes" xml:space="preserve">
          <source>If argument pnCol is not NULL, then *pnCol is set to the number of columns in the table.</source>
          <target state="translated">Если аргумент pnCol не NULL,то *pnCol задается количеством колонок в таблице.</target>
        </trans-unit>
        <trans-unit id="6eebf7ee5a909998cdac6e1af93d8bf0c4b9e6a9" translate="yes" xml:space="preserve">
          <source>If argument pzTab is not NULL, then *pzTab is set to point to a nul-terminated utf-8 encoded string containing the name of the table affected by the current change. The buffer remains valid until either sqlite3changeset_next() is called on the iterator or until the conflict-handler function returns. If pnCol is not NULL, then *pnCol is set to the number of columns in the table affected by the change. If pbIndirect is not NULL, then *pbIndirect is set to true (1) if the change is an indirect change, or false (0) otherwise. See the documentation for &lt;a href=&quot;#sqlite3session_indirect&quot;&gt;sqlite3session_indirect()&lt;/a&gt; for a description of direct and indirect changes. Finally, if pOp is not NULL, then *pOp is set to one of &lt;a href=&quot;c3ref/c_alter_table&quot;&gt;SQLITE_INSERT&lt;/a&gt;, &lt;a href=&quot;c3ref/c_alter_table&quot;&gt;SQLITE_DELETE&lt;/a&gt; or &lt;a href=&quot;c3ref/c_alter_table&quot;&gt;SQLITE_UPDATE&lt;/a&gt;, depending on the type of change that the iterator currently points to.</source>
          <target state="translated">Если аргумент pzTab не равен NULL, тогда * pzTab устанавливается так, чтобы указывать на закодированную строку utf-8 с завершающим нулем, содержащую имя таблицы, затронутой текущим изменением. Буфер остается действительным до тех пор, пока на итераторе не будет вызвана функция sqlite3changeset_next () или пока не вернется функция обработчика конфликтов. Если pnCol не равен NULL, тогда * pnCol устанавливается равным количеству столбцов в таблице, затронутых изменением. Если pbIndirect не NULL, тогда * pbIndirect устанавливается в значение true (1), если изменение является косвенным, или false (0) в противном случае. См. Документацию по &lt;a href=&quot;#sqlite3session_indirect&quot;&gt;sqlite3session_indirect ()&lt;/a&gt; для описания прямых и косвенных изменений. Наконец, если pOp не равен NULL, тогда * pOp устанавливается в одно из &lt;a href=&quot;c3ref/c_alter_table&quot;&gt;значений SQLITE_INSERT&lt;/a&gt; , &lt;a href=&quot;c3ref/c_alter_table&quot;&gt;SQLITE_DELETE&lt;/a&gt; или &lt;a href=&quot;c3ref/c_alter_table&quot;&gt;SQLITE_UPDATE.&lt;/a&gt;, в зависимости от типа изменения, на которое в настоящий момент указывает итератор.</target>
        </trans-unit>
        <trans-unit id="eeb423ada7e3f3af8ece536280a90cde13ccf0f0" translate="yes" xml:space="preserve">
          <source>If argument pzTab is not NULL, then *pzTab is set to point to a nul-terminated utf-8 encoded string containing the name of the table affected by the current change. The buffer remains valid until either sqlite3changeset_next() is called on the iterator or until the conflict-handler function returns. If pnCol is not NULL, then *pnCol is set to the number of columns in the table affected by the change. If pbIndirect is not NULL, then *pbIndirect is set to true (1) if the change is an indirect change, or false (0) otherwise. See the documentation for &lt;a href=&quot;sqlite3session_indirect&quot;&gt;sqlite3session_indirect()&lt;/a&gt; for a description of direct and indirect changes. Finally, if pOp is not NULL, then *pOp is set to one of &lt;a href=&quot;../c3ref/c_alter_table&quot;&gt;SQLITE_INSERT&lt;/a&gt;, &lt;a href=&quot;../c3ref/c_alter_table&quot;&gt;SQLITE_DELETE&lt;/a&gt; or &lt;a href=&quot;../c3ref/c_alter_table&quot;&gt;SQLITE_UPDATE&lt;/a&gt;, depending on the type of change that the iterator currently points to.</source>
          <target state="translated">Если аргумент pzTab не равен NULL, тогда * pzTab устанавливается так, чтобы указывать на закодированную строку utf-8 с завершающим нулем, содержащую имя таблицы, затронутой текущим изменением. Буфер остается действительным до тех пор, пока на итераторе не будет вызвана функция sqlite3changeset_next () или пока не вернется функция обработчика конфликтов. Если pnCol не равен NULL, тогда * pnCol устанавливается равным количеству столбцов в таблице, затронутых изменением. Если pbIndirect не NULL, тогда * pbIndirect устанавливается в значение true (1), если изменение является косвенным, или false (0) в противном случае. См. Документацию по &lt;a href=&quot;sqlite3session_indirect&quot;&gt;sqlite3session_indirect ()&lt;/a&gt; для описания прямых и косвенных изменений. Наконец, если pOp не равен NULL, тогда * pOp устанавливается в одно из &lt;a href=&quot;../c3ref/c_alter_table&quot;&gt;значений SQLITE_INSERT&lt;/a&gt; , &lt;a href=&quot;../c3ref/c_alter_table&quot;&gt;SQLITE_DELETE&lt;/a&gt; или &lt;a href=&quot;../c3ref/c_alter_table&quot;&gt;SQLITE_UPDATE.&lt;/a&gt;, в зависимости от типа изменения, на которое в настоящий момент указывает итератор.</target>
        </trans-unit>
        <trans-unit id="012db9d404feeb7b242a5f104e807e9ebcf5e6cc" translate="yes" xml:space="preserve">
          <source>If argument zTab is not NULL, then it is the name of a table to attach to the session object passed as the first argument. All subsequent changes made to the table while the session object is enabled will be recorded. See documentation for &lt;a href=&quot;#sqlite3session_changeset&quot;&gt;sqlite3session_changeset()&lt;/a&gt; for further details.</source>
          <target state="translated">Если аргумент zTab не равен NULL, то это имя таблицы, которую нужно присоединить к объекту сеанса, переданному в качестве первого аргумента. Все последующие изменения, внесенные в таблицу, пока объект сеанса включен, будут записаны. Дополнительную информацию см. В документации по &lt;a href=&quot;#sqlite3session_changeset&quot;&gt;sqlite3session_changeset ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1874355cfa55a648a95d55d6cc4ad4d5d5a5435f" translate="yes" xml:space="preserve">
          <source>If argument zTab is not NULL, then it is the name of a table to attach to the session object passed as the first argument. All subsequent changes made to the table while the session object is enabled will be recorded. See documentation for &lt;a href=&quot;sqlite3session_changeset&quot;&gt;sqlite3session_changeset()&lt;/a&gt; for further details.</source>
          <target state="translated">Если аргумент zTab не равен NULL, то это имя таблицы, которую нужно присоединить к объекту сеанса, переданному в качестве первого аргумента. Все последующие изменения, внесенные в таблицу, пока объект сеанса включен, будут записаны. Дополнительную информацию см. В документации по &lt;a href=&quot;sqlite3session_changeset&quot;&gt;sqlite3session_changeset ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="21fcaf7a804fb18a6bdf460073dabd9a55d816ad" translate="yes" xml:space="preserve">
          <source>If both SQLITE_STOREP2 and SQLITE_KEEPNULL flags are set then the content of r[P2] is only changed if the new value is NULL or 0 (false). In other words, a prior r[P2] value will not be overwritten by 1 (true).</source>
          <target state="translated">Если установлены оба флага SQLITE_STOREP2 и SQLITE_KEEPNULL,то содержимое r[P2]изменяется только в том случае,если новое значение NULL или 0 (false).Другими словами,предыдущее значение r[P2]не будет перезаписано значением 1 (true).</target>
        </trans-unit>
        <trans-unit id="f091230c98fc9fb42f84687fff668e2e8782487e" translate="yes" xml:space="preserve">
          <source>If both SQLITE_STOREP2 and SQLITE_KEEPNULL flags are set then the content of r[P2] is only changed if the new value is NULL or 1 (true). In other words, a prior r[P2] value will not be overwritten by 0 (false).</source>
          <target state="translated">Если установлены оба флага SQLITE_STOREP2 и SQLITE_KEEPNULL,то содержимое r[P2]изменяется только в том случае,если новое значение NULL или 1 (true).Другими словами,предыдущее значение r[P2]не будет перезаписано на 0 (false).</target>
        </trans-unit>
        <trans-unit id="b35b42f8226135f60e30979149548acecdb3cd9a" translate="yes" xml:space="preserve">
          <source>If both pragmas &lt;a href=&quot;pragma#pragma_short_column_names&quot;&gt;short_column_names&lt;/a&gt; and &lt;a href=&quot;pragma#pragma_full_column_names&quot;&gt;full_column_names&lt;/a&gt; are OFF then case (2) applies.</source>
          <target state="translated">Если обе &lt;a href=&quot;pragma#pragma_short_column_names&quot;&gt;прагмы short_column_names&lt;/a&gt; и &lt;a href=&quot;pragma#pragma_full_column_names&quot;&gt;full_column_names&lt;/a&gt; выключены, применяется case (2).</target>
        </trans-unit>
        <trans-unit id="c1ea5de7bdcea197233ed39232910d2d33159cd2" translate="yes" xml:space="preserve">
          <source>If certain kinds of errors occur on a statement within a multi-statement transaction (errors including &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_FULL&lt;/a&gt;, &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_IOERR&lt;/a&gt;, &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOMEM&lt;/a&gt;, &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY&lt;/a&gt;, and &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_INTERRUPT&lt;/a&gt;) then the transaction might be rolled back automatically. The only way to find out whether SQLite automatically rolled back the transaction after an error is to use this function.</source>
          <target state="translated">Если определенные виды ошибок возникают в инструкции в рамках транзакции с несколькими операторами (ошибки, включая &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_FULL&lt;/a&gt; , &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_IOERR&lt;/a&gt; , &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOMEM&lt;/a&gt; , &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY&lt;/a&gt; и &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_INTERRUPT&lt;/a&gt; ), транзакция может быть автоматически отменена . Единственный способ узнать, откатывает ли SQLite транзакцию автоматически после ошибки, - это использовать эту функцию.</target>
        </trans-unit>
        <trans-unit id="063cf3d6b1f8d89a285c8317271a90d08b9bd66c" translate="yes" xml:space="preserve">
          <source>If certain kinds of errors occur on a statement within a multi-statement transaction (errors including &lt;a href=&quot;../rescode#full&quot;&gt;SQLITE_FULL&lt;/a&gt;, &lt;a href=&quot;../rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt;, &lt;a href=&quot;../rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt;, &lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;, and &lt;a href=&quot;../rescode#interrupt&quot;&gt;SQLITE_INTERRUPT&lt;/a&gt;) then the transaction might be rolled back automatically. The only way to find out whether SQLite automatically rolled back the transaction after an error is to use this function.</source>
          <target state="translated">Если определенные виды ошибок возникают в инструкции в рамках транзакции с несколькими операторами (ошибки, включая &lt;a href=&quot;../rescode#full&quot;&gt;SQLITE_FULL&lt;/a&gt; , &lt;a href=&quot;../rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt; , &lt;a href=&quot;../rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt; , &lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; и &lt;a href=&quot;../rescode#interrupt&quot;&gt;SQLITE_INTERRUPT&lt;/a&gt; ), транзакция может быть автоматически отменена . Единственный способ узнать, откатывает ли SQLite транзакцию автоматически после ошибки, - это использовать эту функцию.</target>
        </trans-unit>
        <trans-unit id="65b57925e204e3ebe11c23e15127d898a0e33ca6" translate="yes" xml:space="preserve">
          <source>If certain kinds of errors occur within a transaction, the transaction may or may not be rolled back automatically. The errors that can cause an automatic rollback include:</source>
          <target state="translated">Если в рамках транзакции возникают определенные виды ошибок,то транзакция может автоматически откатываться,а может и не откатываться.К ошибкам,которые могут привести к автоматическому откату,относятся:</target>
        </trans-unit>
        <trans-unit id="debbf4ee0f449f15f2b2fad59057f8a4eccd847a" translate="yes" xml:space="preserve">
          <source>If changes occur on the same database connection after a query starts running but before the query completes, then it is undefined whether or not the query will see those changes.</source>
          <target state="translated">Если изменения происходят при одном и том же подключении к БД после начала выполнения запроса,но до его завершения,то неизвестно,будет ли запрос видеть эти изменения.</target>
        </trans-unit>
        <trans-unit id="92abf58210ebaa6ec510b645429d6e91e6ca04d8" translate="yes" xml:space="preserve">
          <source>If changes occur on the same database connection after a query starts running but before the query completes, then the query might return a changed row more than once, or it might return a row that was previously deleted.</source>
          <target state="translated">Если изменения происходят при одном и том же подключении к БД после начала выполнения запроса,но до его завершения,то запрос может вернуть измененную строку несколько раз,либо может вернуть ранее удаленную строку.</target>
        </trans-unit>
        <trans-unit id="437112dad4bafb7626f6351c41b7b34b2abfaca6" translate="yes" xml:space="preserve">
          <source>If changing into or out of WAL mode the procedure is more complicated.</source>
          <target state="translated">При переходе в режим WAL или из него процедура становится более сложной.</target>
        </trans-unit>
        <trans-unit id="f754396c33d700ad2fd9dbdfe823fd9ae27672f4" translate="yes" xml:space="preserve">
          <source>If column names are explicitly provided for the FTS table as part of the CREATE VIRTUAL TABLE statement, then a datatype name may be optionally specified for each column. This is pure syntactic sugar, the supplied typenames are not used by FTS or the SQLite core for any purpose. The same applies to any constraints specified along with an FTS column name - they are parsed but not used or recorded by the system in any way.</source>
          <target state="translated">Если имена столбцов явно предоставляются для таблицы FTS как часть оператора CREATE VIRTUAL TABLE,то для каждого столбца может быть опционально указано имя типа данных.Это чистый синтаксический сахар,поставляемые имена типов не используются FTS или ядром SQLite ни для каких целей.То же самое относится и к любым ограничениям,указанным вместе с именем столбца FTS-они анализируются,но не используются или не записываются системой каким-либо образом.</target>
        </trans-unit>
        <trans-unit id="4ec154d4b803f19da5aae8c26059349f5ffc0b8b" translate="yes" xml:space="preserve">
          <source>If conflict is with a remote UPDATE and the resolution is OMIT, then the old.* values are rebased using the new.* values in the remote change. Or, if the resolution is REPLACE, then the change is copied into the rebased changeset with updates to columns also updated by the conflicting remote UPDATE removed. If this means no columns would be updated, the change is omitted.</source>
          <target state="translated">Если конфликт произошел с удаленной UPDATE,а разрешение-OMIT,то старые.*значения пересчитываются,используя новые.*значения в удаленном изменении.Или,если разрешение REPLACE,то изменение копируется в rebased changeset с обновлениями в столбцы,которые также обновляются удаленным конфликтом UPDATE.Если это означает,что никакие колонки не будут обновлены,изменение опускается.</target>
        </trans-unit>
        <trans-unit id="eacad9fb0a3ce1ea1edfa735ab3f942dbf9e8cd8" translate="yes" xml:space="preserve">
          <source>If cursor P1 is an index, then the content is the key of the row. If cursor P2 is a table, then the content extracted is the data.</source>
          <target state="translated">Если курсор P1-это индекс,то его содержимое-это ключ строки.Если курсор P2-таблица,то извлекаемое содержимое-данные.</target>
        </trans-unit>
        <trans-unit id="ecd4bc0795e5315c7b840830ae1ae10db7944fd7" translate="yes" xml:space="preserve">
          <source>If cursor P1 is not open, jump to instruction P2. Otherwise, fall through.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0e0c624719d0c72631b398ea85cd293212feef6" translate="yes" xml:space="preserve">
          <source>If cursor P1 refers to an SQL table (B-Tree that uses integer keys), use the value in register P3 as a key. If cursor P1 refers to an SQL index, then P3 is the first in an array of P4 registers that are used as an unpacked index key.</source>
          <target state="translated">Если курсор P1 ссылается на таблицу SQL (B-дерево,использующее целочисленные ключи),используйте в качестве ключа значение в регистре P3.Если курсор P1 ссылается на индекс SQL,то P3 является первым в массиве регистров P4,которые используются в качестве распакованного индексного ключа.</target>
        </trans-unit>
        <trans-unit id="eed3ade81291c8b1e43812aa13b2f866776f9f36" translate="yes" xml:space="preserve">
          <source>If cursor P1 refers to an SQL table (B-Tree that uses integer keys), use the value in register P3 as the key. If cursor P1 refers to an SQL index, then P3 is the first in an array of P4 registers that are used as an unpacked index key.</source>
          <target state="translated">Если курсор P1 ссылается на таблицу SQL (B-дерево,использующее целочисленные ключи),используйте в качестве ключа значение в регистре P3.Если курсор P1 ссылается на индекс SQL,то P3 является первым в массиве регистров P4,которые используются в качестве распакованного индексного ключа.</target>
        </trans-unit>
        <trans-unit id="bde1d5766ee802e72c51189e7fb68596781976ad" translate="yes" xml:space="preserve">
          <source>If cursor P1 was previously moved via &lt;a href=&quot;opcode#DeferredSeek&quot;&gt;DeferredSeek&lt;/a&gt;, complete that seek operation now, without further delay. If the cursor seek has already occurred, this instruction is a no-op.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9a382b280888652763d650554446d773be05c07" translate="yes" xml:space="preserve">
          <source>If data is of type &lt;b&gt;text&lt;/b&gt; then the comparison is determined by the standard C data comparison functions &lt;b&gt;memcmp()&lt;/b&gt; or &lt;b&gt;strcmp()&lt;/b&gt;. The comparison looks at bytes from two inputs one by one and returns the first non-zero difference. Strings are '\000' terminated so shorter strings sort before longer strings, as you would expect.</source>
          <target state="translated">Если данные имеют &lt;b&gt;текстовый&lt;/b&gt; тип, то сравнение определяется стандартными функциями сравнения данных C &lt;b&gt;memcmp ()&lt;/b&gt; или &lt;b&gt;strcmp ()&lt;/b&gt; . Сравнение просматривает байты из двух входов один за другим и возвращает первую ненулевую разницу. Строки заканчиваются символом '\ 000', поэтому более короткие строки сортируются перед более длинными, как и следовало ожидать.</target>
        </trans-unit>
        <trans-unit id="0120d2592940874456695d5517c48510978290bc" translate="yes" xml:space="preserve">
          <source>If database zDb is the name of an attached database that is not in WAL mode, SQLITE_OK is returned and both *pnLog and *pnCkpt set to -1. If zDb is not NULL (or a zero length string) and is not the name of any attached database, SQLITE_ERROR is returned to the caller.</source>
          <target state="translated">Если база данных zDb-это имя подключенной базы данных,которая не находится в режиме WAL,то возвращается SQLITE_OK и оба *pnLog и *pnCkpt устанавливаются в -1.Если zDb не является NULL (или строкой нулевой длины)и не является именем ни одной из подключенных баз данных,то вызывающему абоненту возвращается SQLITE_ERROR.</target>
        </trans-unit>
        <trans-unit id="ed9f3d01c8cb63f65cf1f8cb1ada863d801c5821" translate="yes" xml:space="preserve">
          <source>If defined, support for sub-selects and the IN() operator are omitted.</source>
          <target state="translated">Если определено,то поддержка подвыборов и оператора IN()опускается.</target>
        </trans-unit>
        <trans-unit id="5f4710e921e7c9706b1a7d0affff80c102083b4a" translate="yes" xml:space="preserve">
          <source>If desired, you can verify the new database by running this command:</source>
          <target state="translated">При желании вы можете проверить новую БД,выполнив данную команду:</target>
        </trans-unit>
        <trans-unit id="d0b0b6a44b8709f88072f86b2bad9194c580b896" translate="yes" xml:space="preserve">
          <source>If either P1 or P2 is 0 (false) then the result is 0 even if the other input is NULL. A NULL and true or two NULLs give a NULL output.</source>
          <target state="translated">Если P1 или P2 равен 0 (ложь),то результат равен 0,даже если на другом входе NULL.NULL и true или два NULL дают результат NULL.</target>
        </trans-unit>
        <trans-unit id="0c5f4e14888f22c44de9608417d3500cbb09c876" translate="yes" xml:space="preserve">
          <source>If either P1 or P2 is nonzero (true) then the result is 1 (true) even if the other input is NULL. A NULL and false or two NULLs give a NULL output.</source>
          <target state="translated">Если P1 или P2 ненулевой (истина),то результат равен 1 (истина),даже если на другом входе NULL.NULL и false или два NULL дают результат NULL.</target>
        </trans-unit>
        <trans-unit id="f718f36fc0872a36f2f90015ef098011701953fd" translate="yes" xml:space="preserve">
          <source>If either P3 or the sorter contains a NULL in one of their significant fields (not counting the P4 fields at the end which are ignored) then the comparison is assumed to be equal.</source>
          <target state="translated">Если либо P3,либо сортировщик содержит NULL в одном из своих значимых полей (не считая P4 полей в конце,которые игнорируются),то сравнение считается равным.</target>
        </trans-unit>
        <trans-unit id="cb70cc2d7081446ae1bd92c809ed77dcb6489c40" translate="yes" xml:space="preserve">
          <source>If either X&lt;sub&gt;&lt;small&gt;i&lt;/small&gt;&lt;/sub&gt; or X&lt;sub&gt;&lt;small&gt;c&lt;/small&gt;&lt;/sub&gt; are non-numeric, then the boundary is the first row for which the expression &quot;X&lt;sub&gt;&lt;small&gt;i&lt;/small&gt;&lt;/sub&gt; IS X&lt;sub&gt;&lt;small&gt;c&lt;/small&gt;&lt;/sub&gt;&quot; is true.</source>
          <target state="translated">Если X &lt;sub&gt;&lt;small&gt;i&lt;/small&gt;&lt;/sub&gt; или X &lt;sub&gt;&lt;small&gt;c&lt;/small&gt;&lt;/sub&gt; нечисловые, то граница - это первая строка, для которой верно выражение &amp;laquo;X &lt;sub&gt;&lt;small&gt;i&lt;/small&gt;&lt;/sub&gt; IS X &lt;sub&gt;&lt;small&gt;c&lt;/small&gt;&lt;/sub&gt; &amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="40afda50342c1866ef5c9245fe131f4faa8b196a" translate="yes" xml:space="preserve">
          <source>If either operand has an explicit collating function assignment using the postfix &lt;a href=&quot;lang_expr#collateop&quot;&gt;COLLATE operator&lt;/a&gt;, then the explicit collating function is used for comparison, with precedence to the collating function of the left operand.</source>
          <target state="translated">Если какой-либо из операндов имеет явное назначение функции сортировки с использованием постфиксного &lt;a href=&quot;lang_expr#collateop&quot;&gt;оператора COLLATE&lt;/a&gt; , то для сравнения используется явная функция сортировки с приоритетом перед функцией сортировки левого операнда.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
