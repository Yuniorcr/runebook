<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="sqlite">
    <body>
      <group id="sqlite">
        <trans-unit id="4fe1d3a13dd63ed4836e434d893dc270763cfe84" translate="yes" xml:space="preserve">
          <source>The release checklist is continuously evolving. As new problems or potential problems are discovered, new checklist items are added to make sure those problems do not appear in subsequent releases. The release checklist has proven to be an invaluable tool in helping to ensure that nothing is overlooked during the release process.</source>
          <target state="translated">Контрольный список выпусков постоянно развивается.По мере обнаружения новых проблем или потенциальных проблем,добавляются новые пункты контрольного списка,чтобы убедиться,что эти проблемы не появятся в последующих релизах.Контрольный список выпусков оказался неоценимым инструментом,помогающим убедиться в том,что ничто не будет упущено из виду в процессе выпуска.</target>
        </trans-unit>
        <trans-unit id="54fb9bcb3273ff541df78c3b4ae7a5c1d95caf43" translate="yes" xml:space="preserve">
          <source>The release checklist is not automated: developers run each item on the checklist manually. We find that it is important to keep a human in the loop. Sometimes problems are found while running a checklist item even though the test itself passed. It is important to have a human reviewing the test output at the highest level, and constantly asking &quot;Is this really right?&quot;</source>
          <target state="translated">Контрольный список выпуска не автоматизирован:разработчики запускают каждый пункт контрольного списка вручную.Мы считаем,что важно держать человека в курсе дела.Иногда проблемы обнаруживаются при запуске элемента контрольного списка,несмотря на то,что сам тест прошел.Важно,чтобы человек просматривал результат теста на самом высоком уровне и постоянно спрашивал:&quot;Это правда?&quot;.</target>
        </trans-unit>
        <trans-unit id="2c9d643524e4e559789769fa0d9c05fd5ba6364a" translate="yes" xml:space="preserve">
          <source>The relevancy of a document may depend on something other than just the data available in the return value of matchinfo. For example each document in the database may be assigned a static weight based on factors unrelated to its content (origin, author, age, number of references etc.). These values can be stored by the application in a separate table that can be joined against the documents table in the sub-query so that the rank function may access them.</source>
          <target state="translated">Актуальность документа может зависеть не только от данных,доступных в возвращаемом значении совпадения.Например,каждому документу в базе данных может быть присвоен статический вес,основанный на факторах,не связанных с его содержанием (происхождение,автор,возраст,количество ссылок и т.д.).Эти значения могут быть сохранены приложением в отдельной таблице,которая может быть объединена с таблицей документов в подзапросе,чтобы к ним мог получить доступ ранговый функционал.</target>
        </trans-unit>
        <trans-unit id="d03714ee4fa95f4e8679f472e2f3c59cc9a47883" translate="yes" xml:space="preserve">
          <source>The reliability and robustness of SQLite is achieved in part by thorough and careful testing.</source>
          <target state="translated">Надежность и надежность SQLite достигается отчасти благодаря тщательному и тщательному тестированию.</target>
        </trans-unit>
        <trans-unit id="7a3157bd64ab9a637ba9a36bada2711bd2147294" translate="yes" xml:space="preserve">
          <source>The remainder of this document will guide the reader through the steps needed to maintain a private branch. The general idea is the same as outlined above. This section merely provides more detail.</source>
          <target state="translated">Остальная часть этого документа поможет читателю разобраться в шагах,необходимых для поддержания частного филиала.Общая идея аналогична изложенной выше.Этот раздел содержит лишь более подробную информацию.</target>
        </trans-unit>
        <trans-unit id="30a538553e382aa8cfb9498b6fd827480cf2d80b" translate="yes" xml:space="preserve">
          <source>The remaining fields of the &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object all store pointers to functions that implement primitive operations. We call these &quot;methods&quot;. The first method, xOpen, is used to open files on the underlying storage media. The result is an &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; object. There are additional methods, defined by the &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; object itself that are used to read and write and close the file. The additional methods are detailed below. The filename is in UTF-8. SQLite will guarantee that the zFilename string passed to xOpen() is a full pathname as generated by xFullPathname() and that the string will be valid and unchanged until xClose() is called. So the &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; can store a pointer to the filename if it needs to remember the filename for some reason. The flags argument to xOpen() is a copy of the flags argument to sqlite3_open_v2(). If sqlite3_open() or sqlite3_open16() is used, then flags is &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_READWRITE&lt;/a&gt; | &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_CREATE&lt;/a&gt;. If xOpen() opens a file read-only then it sets *pOutFlags to include &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_READONLY&lt;/a&gt;. Other bits in *pOutFlags may be set. SQLite will also add one of the following flags to the xOpen() call, depending on the object being opened:</source>
          <target state="translated">Все остальные поля объекта &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; хранят указатели на функции, реализующие примитивные операции. Мы называем это &amp;laquo;методами&amp;raquo;. Первый метод, xOpen, используется для открытия файлов на нижележащем носителе. Результатом является объект &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; . Существуют дополнительные методы, определяемые самим объектом &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; , которые используются для чтения, записи и закрытия файла. Дополнительные методы подробно описаны ниже. Имя файла в кодировке UTF-8. SQLite гарантирует, что строка zFilename, переданная в xOpen (), является полным путем, сгенерированным xFullPathname (), и что строка будет действительной и неизменной до вызова xClose (). Итак, &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt;может хранить указатель на имя файла, если ему по какой-то причине необходимо запомнить имя файла. Аргумент flags функции xOpen () является копией аргумента flags функции sqlite3_open_v2 (). Если используется sqlite3_open () или sqlite3_open16 (), тогда flags - &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_READWRITE&lt;/a&gt; | &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_CREATE&lt;/a&gt; . Если xOpen () открывает файл только для чтения, он устанавливает * pOutFlags для включения &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_READONLY&lt;/a&gt; . Другие биты в * pOutFlags могут быть установлены. SQLite также добавит один из следующих флагов к вызову xOpen (), в зависимости от открываемого объекта:</target>
        </trans-unit>
        <trans-unit id="75ee3ed9cd8aa1cdca7e660d366395ab9cdd104b" translate="yes" xml:space="preserve">
          <source>The remaining seven methods defined by this structure (xMutexAlloc, xMutexFree, xMutexEnter, xMutexTry, xMutexLeave, xMutexHeld and xMutexNotheld) implement the following interfaces (respectively):</source>
          <target state="translated">Остальные семь методов,определяемые этой структурой (xMutexAlloc,xMutexFree,xMutexEnter,xMutexTry,xMutexLeave,xMutexHeld и xMutexNotheld)реализуют следующие интерфейсы (соответственно):</target>
        </trans-unit>
        <trans-unit id="01d5ccb02fb58f9483b8bb4a6c89788e5e99328d" translate="yes" xml:space="preserve">
          <source>The remove_diacritics option is not supported.</source>
          <target state="translated">Опция remove_diacritics не поддерживается.</target>
        </trans-unit>
        <trans-unit id="5dc3bfc4e2330eb1c8eb7d47b9e9b34b4b7effb1" translate="yes" xml:space="preserve">
          <source>The remove_diacritics option may be set to &quot;0&quot;, &quot;1&quot; or &quot;2&quot;. The default value is &quot;1&quot;. If it is set to &quot;1&quot; or &quot;2&quot;, then diacritics are removed from Latin script characters as described above. However, if it is set to &quot;1&quot;, then diacritics are not removed in the fairly uncommon case where a single unicode codepoint is used to represent a character with more that one diacritic. For example, diacritics are not removed from codepoint 0x1ED9 (&quot;LATIN SMALL LETTER O WITH CIRCUMFLEX AND DOT BELOW&quot;). This is technically a bug, but cannot be fixed without creating backwards compatibility problems. If this option is set to &quot;2&quot;, then diacritics are correctly removed from all Latin characters.</source>
          <target state="translated">Опция remove_diacritics может быть установлена на &quot;0&quot;,&quot;1&quot; или &quot;2&quot;.Значение по умолчанию-&quot;1&quot;.Если установлено &quot;1&quot; или &quot;2&quot;,то диакритические знаки удаляются из символов латинского алфавита,как описано выше.Однако,если установлено значение &quot;1&quot;,то диакритические знаки не удаляются в достаточно редком случае,когда для представления символа с более чем одним диакритическим знаком используется одна юникодная кодовая точка.Например,диакритические знаки не удаляются из кодовой точки 0x1ED9 (&quot;LATIN SMALL LETTER O WITH CIRCUMFLEX AND DOT BELOW&quot;).Технически это ошибка,но она не может быть исправлена без создания проблем с обратной совместимостью.Если эта опция установлена в &quot;2&quot;,то диакритические знаки правильно удаляются из всех латинских символов.</target>
        </trans-unit>
        <trans-unit id="e878b1555960f1149f69c44e721edf9e3c3726dd" translate="yes" xml:space="preserve">
          <source>The replace(X,Y,Z) function returns a string formed by substituting string Z for every occurrence of string Y in string X. The &lt;a href=&quot;datatype3#collation&quot;&gt;BINARY&lt;/a&gt; collating sequence is used for comparisons. If Y is an empty string then return X unchanged. If Z is not initially a string, it is cast to a UTF-8 string prior to processing.</source>
          <target state="translated">Функция replace (X, Y, Z) возвращает строку, образованную заменой строки Z на каждое вхождение строки Y в строке X. &lt;a href=&quot;datatype3#collation&quot;&gt;Двоичная&lt;/a&gt; последовательность сортировки используется для сравнений. Если Y - пустая строка, вернуть X без изменений. Если Z изначально не является строкой, перед обработкой он преобразуется в строку UTF-8.</target>
        </trans-unit>
        <trans-unit id="7d84cb3d97dd720ff83b043f47169f048a42ed9d" translate="yes" xml:space="preserve">
          <source>The repository created in the previous step is initially empty. The next step is to load the baseline SQLite release - circle (1) in the diagram above.</source>
          <target state="translated">Репозиторий,созданный на предыдущем этапе,изначально пуст.На следующем этапе необходимо загрузить базовый релиз SQLite-круг (1)на диаграмме выше.</target>
        </trans-unit>
        <trans-unit id="10c2d611bbd1154503c3d2f589b7893620f36217" translate="yes" xml:space="preserve">
          <source>The reserved region is an area of unused space at the end of every page (except the locking page) that extensions can use to hold per-page information. The size of the reserved region is determined by the one-byte unsigned integer found at an offset of 20 into the database file header. The size of the reserved region is usually zero.</source>
          <target state="translated">Зарезервированная область-это область неиспользованного пространства в конце каждой страницы (за исключением зарезервированной страницы),которую расширения могут использовать для хранения информации на каждую страницу.Размер зарезервированной области определяется однобайтовым беззнаковым целым числом,находящимся со смещением 20 в заголовке файла БД.Размер зарезервированного региона обычно равен нулю.</target>
        </trans-unit>
        <trans-unit id="5406b5dfde9f00d0738ba2c75a1507fa33caf617" translate="yes" xml:space="preserve">
          <source>The reserved region.</source>
          <target state="translated">Зарезервированный регион.</target>
        </trans-unit>
        <trans-unit id="aad9068a01cab0c1ed6f0408e5a3ca43105c9476" translate="yes" xml:space="preserve">
          <source>The response of SQLite to out-of-memory (OOM) errors is tested using a specialized memory allocator overlay that can simulate memory failures. The overlay is a layer that is inserted in between the memory allocator and the rest of SQLite. The overlay passes most memory allocation requests straight through to the underlying allocator and passes the results back up to the requester. But the overlay can be set to cause the Nth memory allocation to fail. To run an OOM test, the overlay is first set to fail on the first allocation attempt. Then some test script is run and verification that the allocation was correctly caught and handled is made. Then the overlay is set to fail on the second allocation and the test repeats. The failure point continues to advance one allocation at a time until the entire test procedure runs to completion without hitting a memory allocation error. This whole test sequence run twice. On the first pass, the overlay is set to fail only the Nth allocation. On the second pass, the overlay is set to fail the Nth and all subsequent allocations.</source>
          <target state="translated">Реакция SQLite на ошибки вне памяти (OOM)проверяется с помощью специализированного оверлея аллокатора памяти,который может имитировать сбои в памяти.Оверлей-это слой,который вставляется между аллокатором памяти и остальной частью SQLite.Оверлей передает большинство запросов на выделение памяти прямо к соответствующему аллокатору и передает результаты обратно запросчику.Но оверлей можно настроить так,чтобы N-ый аллокатор памяти не справился с выделением памяти.Для запуска теста OOM оверлей сначала устанавливается на неудачу при первой попытке выделения памяти.Затем выполняется какой-то тестовый скрипт и производится проверка,что выделение было корректно поймано и обработано.Затем оверлей устанавливается как неудачный при второй попытке выделения памяти,и тест повторяется.Точка отказа продолжает продвигаться по одному распределению за раз до тех пор,пока вся процедура теста не завершится без ошибки выделения памяти.Вся эта тестовая последовательность выполняется дважды.При первом проходе оверлей устанавливается на неудачное N-е распределение.При втором проходе оверлей устанавливается на неудачное N-е и все последующие выделения.</target>
        </trans-unit>
        <trans-unit id="12691a5bbec67aa65e24fe31d2477402bd3c4199" translate="yes" xml:space="preserve">
          <source>The rest of the module structure consists of methods used to implement various features of the virtual table. Details on what each of these methods do are provided in the sequel.</source>
          <target state="translated">Остальная часть модульной структуры состоит из методов,используемых для реализации различных возможностей виртуальной таблицы.Подробная информация о том,что каждый из этих методов делает,приведена в сиквеле.</target>
        </trans-unit>
        <trans-unit id="4c062c28bf53cd1153a7f659fc941fb25e4394ee" translate="yes" xml:space="preserve">
          <source>The result column names generated for compound subqueries have been simplified to show only the name of the column of the original table and omit the table name. This makes SQLite operate more like other SQL database engines.</source>
          <target state="translated">Имена столбцов результата,сгенерированные для составных подзапросов,были упрощены,чтобы показать только имя столбца исходной таблицы и опустить имя таблицы.Это делает SQLite более похожим на другие движки баз данных SQL.</target>
        </trans-unit>
        <trans-unit id="8fba3a08c8f1c5c3b4c188d84f260675274f7bae" translate="yes" xml:space="preserve">
          <source>The result of &quot;(1,2,3)=(1,NULL,3)&quot; is NULL because the result might be true if we replaced NULL&amp;rarr;2 or false if we replaced NULL&amp;rarr;9. The result of &quot;(1,2,3)=(1,NULL,4)&quot; is not NULL because there is no substitutions of the constituent NULL that will make the expression true, since 3 will never equal 4 in the third column.</source>
          <target state="translated">Результатом &amp;laquo;(1,2,3) = (1, NULL, 3)&amp;raquo; является NULL, потому что результат может быть истинным, если мы заменим NULL &amp;rarr; 2, или false, если мы заменим NULL &amp;rarr; 9. Результат &amp;laquo;(1,2,3) = (1, NULL, 4)&amp;raquo; не является NULL, потому что нет никаких замен составляющих NULL, которые сделают выражение истинным, поскольку 3 никогда не будет равно 4 в третьем столбце.</target>
        </trans-unit>
        <trans-unit id="8f8beef2187bafe894f67b36f4b351c6bf0083c2" translate="yes" xml:space="preserve">
          <source>The result of an IN or NOT IN operator is determined by the following matrix:</source>
          <target state="translated">Результат работы оператора IN или NOT IN определяется следующей матрицей:</target>
        </trans-unit>
        <trans-unit id="61365ffa3c163a280c658c5edf1eb2a5c12ca346" translate="yes" xml:space="preserve">
          <source>The result of any binary operator is either a numeric value or NULL, except for the</source>
          <target state="translated">Результатом любого двоичного оператора является либо числовое значение,либо NULL,кроме</target>
        </trans-unit>
        <trans-unit id="efe84f22635d66f10495dd8d63c09814ab5f5a9a" translate="yes" xml:space="preserve">
          <source>The result of combining all input changesets together is obtained by the application via a call to sqlite3changegroup_output().</source>
          <target state="translated">Результат объединения всех входных изменяемых параметров вместе получается приложением с помощью вызова sqlite3changegroup_output().</target>
        </trans-unit>
        <trans-unit id="bf374835b6b23f4254068862fbe80fd36859e25a" translate="yes" xml:space="preserve">
          <source>The result of opening a file is an instance of an &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; object. The &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; object is an abstract base class defined as follows:</source>
          <target state="translated">Результатом открытия файла является экземпляр объекта &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; . Объект &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; - это абстрактный базовый класс, определенный следующим образом:</target>
        </trans-unit>
        <trans-unit id="8384d1099fcb8eaa40cfc52c9ccfbf281fc795df" translate="yes" xml:space="preserve">
          <source>The result of the compound select is sent to the callback routine by the loop at instructions 22 through 25. There is nothing new or remarkable about this loop, except for the fact that the Column instruction at 23 will be extracting a column out of the record key rather than the record data.</source>
          <target state="translated">Результат выбора соединения посылается в программу обратного вызова петлей в соответствии с инструкциями с 22 по 25.В этом цикле нет ничего нового и примечательного,кроме того,что команда &quot;Столбец на 23&quot; будет извлекать столбец из ключа записи,а не данные записи.</target>
        </trans-unit>
        <trans-unit id="a2285b0635d880f7a2485fe902caef319bce2b4f" translate="yes" xml:space="preserve">
          <source>The result of this last example should be every unique value of the &quot;two&quot; column in the examp table, except any value that is in the &quot;four&quot; column of examp2 is removed. The code to implement this query is as follows:</source>
          <target state="translated">Результатом этого последнего примера должно быть каждое уникальное значение столбца &quot;два&quot; в экзаменационной таблице,за исключением любого значения,которое находится в столбце &quot;четыре&quot; экзамена2.Код для реализации данного запроса выглядит следующим образом:</target>
        </trans-unit>
        <trans-unit id="ccf7a73ae578c847fadf3966512c178de5c0acda" translate="yes" xml:space="preserve">
          <source>The result of total() is always a floating point value. The result of sum() is an integer value if all non-NULL inputs are integers. If any input to sum() is neither an integer or a NULL then sum() returns a floating point value which might be an approximation to the true sum.</source>
          <target state="translated">Результатом функции total()всегда является значение с плавающей точкой.Результат функции sum()является целочисленным значением,если все не нулевые входы являются целыми числами.Если любой вход sum()не является ни целым числом,ни NULL,то sum()возвращает значение с плавающей точкой,которое может быть аппроксимацией к истинной сумме.</target>
        </trans-unit>
        <trans-unit id="3501cb60eee256e312e1519991e5a4a97f468bc9" translate="yes" xml:space="preserve">
          <source>The result shown above (0.0000011126) is the correct answer. But if you do this computation using binary64 floating-point, the answer you get is 0.00000095367431640625 - an error of about 14%. If you do many similar computations as part of your program, the errors add up so that your final result might be completely meaningless.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a6fa042949920d8ab9a65592e82f3922c405d35" translate="yes" xml:space="preserve">
          <source>The resulting &quot;sqlite3.c&quot; amalgamation code file (and its associated header file &quot;sqlite3.h&quot;) can then be moved to a non-unix platform for final compilation using a native compiler.</source>
          <target state="translated">Полученный в результате слияния файл с кодом &quot;sqlite3.c&quot; (и связанный с ним заголовочный файл &quot;sqlite3.h&quot;)можно переместить на нефиксированную платформу для окончательной компиляции с помощью родного компилятора.</target>
        </trans-unit>
        <trans-unit id="e2d2e1926aa6ddaac2f60d9749f53fb11268ec2a" translate="yes" xml:space="preserve">
          <source>The results of a comparison depend on the storage classes of the operands, according to the following rules:</source>
          <target state="translated">Результаты сравнения зависят от классов хранения операндов,по следующим правилам:</target>
        </trans-unit>
        <trans-unit id="32d9d0342a63956078e67d37802198109f0decfd" translate="yes" xml:space="preserve">
          <source>The results presented here come with the following caveats:</source>
          <target state="translated">Представленные здесь результаты содержат следующие предостережения:</target>
        </trans-unit>
        <trans-unit id="0aa6d6ab54b80d454b7163f11aaed1a126d7a246" translate="yes" xml:space="preserve">
          <source>The return value from both sqlite3_soft_heap_limit64() and sqlite3_hard_heap_limit64() is the size of the heap limit prior to the call, or negative in the case of an error. If the argument N is negative then no change is made to the heap limit. Hence, the current size of heap limits can be determined by invoking sqlite3_soft_heap_limit64(-1) or sqlite3_hard_heap_limit(-1).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9310ef8309cce9fab8d7528f6f21efe5cbb34c7" translate="yes" xml:space="preserve">
          <source>The return value from sqlite3_soft_heap_limit64() is the size of the soft heap limit prior to the call, or negative in the case of an error. If the argument N is negative then no change is made to the soft heap limit. Hence, the current size of the soft heap limit can be determined by invoking sqlite3_soft_heap_limit64() with a negative argument.</source>
          <target state="translated">Возвращаемое из sqlite3_soft_heap_limit64()значение-это размер лимита мягкой кучи до вызова,или отрицательное в случае ошибки.Если аргумент N отрицательный,то лимит мягкой кучи не изменяется.Следовательно,текущий размер лимита мягкой кучи можно определить,вызвав sqlite3_soft_heap_limit64()с отрицательным аргументом.</target>
        </trans-unit>
        <trans-unit id="b9ca53c6554299d5eae8ef584802645a6046ae33" translate="yes" xml:space="preserve">
          <source>The return value indicates the final state of the indirect flag: 0 if it is clear, or 1 if it is set.</source>
          <target state="translated">Возвращаемое значение указывает на конечное состояние опосредованного флага:0,если он чист,или 1,если он установлен.</target>
        </trans-unit>
        <trans-unit id="7ce2179f1a4d84a59cb420b693cc86ea07338afc" translate="yes" xml:space="preserve">
          <source>The return value indicates the final state of the session object: 0 if the session is disabled, or 1 if it is enabled.</source>
          <target state="translated">Возвращаемое значение указывает на конечное состояние объекта сеанса:0,если сеанс выключен,или 1,если он включен.</target>
        </trans-unit>
        <trans-unit id="cae4bd57ed056db33a88f07df4b39cc7f3ccb51d" translate="yes" xml:space="preserve">
          <source>The return value of the &lt;a href=&quot;c3ref/threadsafe&quot;&gt;sqlite3_threadsafe()&lt;/a&gt; interface is determined by the compile-time threading mode selection. If single-thread mode is selected at compile-time, then &lt;a href=&quot;c3ref/threadsafe&quot;&gt;sqlite3_threadsafe()&lt;/a&gt; returns false. If either the multi-thread or serialized modes are selected, then &lt;a href=&quot;c3ref/threadsafe&quot;&gt;sqlite3_threadsafe()&lt;/a&gt; returns true. The &lt;a href=&quot;c3ref/threadsafe&quot;&gt;sqlite3_threadsafe()&lt;/a&gt; interface predates the multi-thread mode and start-time and run-time mode selection and so is unable to distinguish between multi-thread and serialized mode nor is it able to report start-time or run-time mode changes.</source>
          <target state="translated">Возвращаемое значение интерфейса &lt;a href=&quot;c3ref/threadsafe&quot;&gt;sqlite3_threadsafe ()&lt;/a&gt; определяется выбором режима многопоточности во время компиляции. Если во время компиляции выбран однопоточный режим, &lt;a href=&quot;c3ref/threadsafe&quot;&gt;sqlite3_threadsafe ()&lt;/a&gt; возвращает false. Если выбран многопоточный или сериализованный режимы, &lt;a href=&quot;c3ref/threadsafe&quot;&gt;sqlite3_threadsafe ()&lt;/a&gt; возвращает true. Интерфейс &lt;a href=&quot;c3ref/threadsafe&quot;&gt;sqlite3_threadsafe ()&lt;/a&gt; предшествует многопоточному режиму и выбору режима времени запуска и времени выполнения и поэтому не может различать многопоточный и сериализованный режим, а также не может сообщать об изменениях режима запуска или времени выполнения.</target>
        </trans-unit>
        <trans-unit id="39d80cd93bcac1fdb374e9a2b5c0dd95b400a1d6" translate="yes" xml:space="preserve">
          <source>The return value of the &lt;b&gt;sqlite_open&lt;/b&gt; function is a pointer to an opaque &lt;b&gt;sqlite&lt;/b&gt; structure. This pointer will be the first argument to all subsequent SQLite function calls that deal with the same database. NULL is returned if the open fails for any reason.</source>
          <target state="translated">Возвращаемое значение функции &lt;b&gt;sqlite_open&lt;/b&gt; - указатель на непрозрачную структуру &lt;b&gt;sqlite&lt;/b&gt; . Этот указатель будет первым аргументом для всех последующих вызовов функций SQLite, имеющих дело с той же базой данных. NULL возвращается, если открытие не удалось по какой-либо причине.</target>
        </trans-unit>
        <trans-unit id="6ab6c5924ac478fb10f4cbca37723d1a21ffdbb3" translate="yes" xml:space="preserve">
          <source>The returned string pointer is valid until either the &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; is destroyed by &lt;a href=&quot;#sqlite3_finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt; or until the statement is automatically reprepared by the first call to &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; for a particular run or until the next call to sqlite3_column_name() or sqlite3_column_name16() on the same column.</source>
          <target state="translated">Возвращенный строковый указатель действителен до тех пор, пока &lt;a href=&quot;#sqlite3_stmt&quot;&gt;подготовленный оператор не&lt;/a&gt; будет уничтожен &lt;a href=&quot;#sqlite3_finalize&quot;&gt;sqlite3_finalize (),&lt;/a&gt; или пока оператор не будет автоматически представлен первым вызовом &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step ()&lt;/a&gt; для определенного запуска, или до следующего вызова sqlite3_column_name () или sqlite3_column_name16 () на тот же столбец.</target>
        </trans-unit>
        <trans-unit id="b378f46326a64f9ce7b892670372ed936b24e5cc" translate="yes" xml:space="preserve">
          <source>The returned string pointer is valid until either the &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; is destroyed by &lt;a href=&quot;finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt; or until the statement is automatically reprepared by the first call to &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; for a particular run or until the next call to sqlite3_column_name() or sqlite3_column_name16() on the same column.</source>
          <target state="translated">Возвращенный строковый указатель действителен до тех пор, пока &lt;a href=&quot;stmt&quot;&gt;подготовленный оператор не&lt;/a&gt; будет уничтожен &lt;a href=&quot;finalize&quot;&gt;sqlite3_finalize (),&lt;/a&gt; или пока оператор не будет автоматически представлен первым вызовом &lt;a href=&quot;step&quot;&gt;sqlite3_step ()&lt;/a&gt; для определенного запуска, или до следующего вызова sqlite3_column_name () или sqlite3_column_name16 () на тот же столбец.</target>
        </trans-unit>
        <trans-unit id="bee83cce7953088554432a61ef6e85ee98f1b384" translate="yes" xml:space="preserve">
          <source>The rewritten expression above is conceptual; WHERE clauses containing OR are not really rewritten this way. The actual implementation of the OR clause uses a mechanism that is more efficient and that works even for &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables or tables in which the &quot;rowid&quot; is inaccessible. But the essence of the implementation is captured by the statement above: Separate indices are used to find candidate result rows from each OR clause term and the final result is the union of those rows.</source>
          <target state="translated">Переписанное выше выражение является концептуальным; Предложения WHERE, содержащие OR, на самом деле не переписываются таким образом. Фактическая реализация предложения OR использует механизм, который более эффективен и работает даже для таблиц &lt;a href=&quot;withoutrowid&quot;&gt;БЕЗ ROWID&lt;/a&gt; или таблиц, в которых &quot;rowid&quot; недоступен. Но суть реализации отражена в приведенном выше утверждении: отдельные индексы используются для поиска строк результатов-кандидатов из каждого члена предложения OR, а конечный результат - это объединение этих строк.</target>
        </trans-unit>
        <trans-unit id="1bd2a272126ae7fe0bcc8e6d37c8017e55bcc2f1" translate="yes" xml:space="preserve">
          <source>The rewritten term then might go on to constrain an index using the normal rules for *IN* operators. Note that</source>
          <target state="translated">Затем переписанный термин может быть использован для ограничения индекса,используя обычные правила для операторов *IN*.Обратите внимание,что</target>
        </trans-unit>
        <trans-unit id="d0930df338a07de9990756603662657ba4f08d89" translate="yes" xml:space="preserve">
          <source>The right-hand operand of an IN or NOT IN operator has no affinity if the operand is a list and has the same affinity as the affinity of the result set expression if the operand is a SELECT.</source>
          <target state="translated">Правый операнд оператора IN или NOT IN не имеет сродства,если операнд является списком и имеет такое же сродство,как и сродство выражения результирующего множества,если операнд является ВЫБОРНЫМ (SELECT).</target>
        </trans-unit>
        <trans-unit id="066626c86d12ae463e5bc63db194f29a635a8420" translate="yes" xml:space="preserve">
          <source>The right-hand side of the IN operator can now be a list of expressions instead of just a list of constants</source>
          <target state="translated">Справа от оператора IN теперь может быть список выражений,а не просто список констант</target>
        </trans-unit>
        <trans-unit id="5c40f29b907e12e70ce95f7046453c736453580d" translate="yes" xml:space="preserve">
          <source>The right-hand side of the LIKE or GLOB must be either a string literal or a &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameter&lt;/a&gt; bound to a string literal that does not begin with a wildcard character.</source>
          <target state="translated">Правая часть LIKE или GLOB должна быть либо строковым литералом, либо &lt;a href=&quot;lang_expr#varparam&quot;&gt;параметром,&lt;/a&gt; привязанным к строковому литералу, который не начинается с символа подстановки.</target>
        </trans-unit>
        <trans-unit id="b4246dd614eb68d70df4434b2497d819d23353bb" translate="yes" xml:space="preserve">
          <source>The right-hand table of the LEFT JOIN is not be used anywhere in the query outside of its own USING or ON clause.</source>
          <target state="translated">Правая таблица ЛЕВОГО СОВЕТА не используется нигде в запросе вне его собственного пункта USING или ON.</target>
        </trans-unit>
        <trans-unit id="fc3dd2572b5bfa090299b30f5d81e58803cff0cb" translate="yes" xml:space="preserve">
          <source>The right-hand-side of the MATCH or = operator must be a constant expression that evaluates to a string consisting of the auxiliary function to invoke, followed by zero or more comma separated arguments within parenthesis. Arguments must be SQL literals. For example:</source>
          <target state="translated">Правая часть оператора MATCH или=должна быть константным выражением,которое вычисляет к строке,состоящей из вспомогательной функции для вызова,за которой следует аргумент,разделенный нулем или более запятыми в круглых скобках.Аргументами должны быть SQL-литералы.Например:</target>
        </trans-unit>
        <trans-unit id="60bf6a0aa9c141c91d3c15f81e63af1fbe6058ec" translate="yes" xml:space="preserve">
          <source>The right-most SELECT of the compound select must not make use of &lt;a href=&quot;lang_aggfunc&quot;&gt;aggregate&lt;/a&gt; or &lt;a href=&quot;windowfunctions&quot;&gt;window functions&lt;/a&gt;.</source>
          <target state="translated">Крайний правый SELECT в составном select не должен использовать &lt;a href=&quot;lang_aggfunc&quot;&gt;агрегатные&lt;/a&gt; или &lt;a href=&quot;windowfunctions&quot;&gt;оконные функции&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7b1ae3c5986255800fb2859410b2b4acb04d2122" translate="yes" xml:space="preserve">
          <source>The rollback journal contains a small header (shown in green in the diagram) that records the original size of the database file. So if a change causes the database file to grow, we will still know the original size of the database. The page number is stored together with each database page that is written into the rollback journal.</source>
          <target state="translated">Журнал отката содержит небольшой заголовок (показан на диаграмме зеленым цветом),в котором записывается исходный размер файла базы данных.Таким образом,если изменение приводит к росту файла базы данных,мы все равно будем знать исходный размер базы данных.Номер страницы хранится вместе с каждой страницей БД,которая записывается в журнал отката.</target>
        </trans-unit>
        <trans-unit id="1c053ab6c700ac534ac79f62078cfd2e255f73f2" translate="yes" xml:space="preserve">
          <source>The rollback journal does not contain the name of a master journal file (see &lt;a href=&quot;#section_5_5&quot;&gt;section 5.5&lt;/a&gt; below) or if does contain the name of a master journal, then that master journal file exists.</source>
          <target state="translated">Журнал отката не содержит имени главного файла журнала (см. &lt;a href=&quot;#section_5_5&quot;&gt;Раздел 5.5&lt;/a&gt; ниже) или, если он содержит имя главного журнала, то этот главный файл журнала существует.</target>
        </trans-unit>
        <trans-unit id="070c8fccacf99462797ddd5845e4bd8960ffcf17" translate="yes" xml:space="preserve">
          <source>The rollback journal does not contain the name of a super-journal file (see &lt;a href=&quot;#section_5_5&quot;&gt;section 5.5&lt;/a&gt; below) or if does contain the name of a super-journal, then that super-journal file exists.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e312e9592f38c1d0abcf1823ca656ae6dc24729" translate="yes" xml:space="preserve">
          <source>The rollback journal exists.</source>
          <target state="translated">Журнал отката существует.</target>
        </trans-unit>
        <trans-unit id="a6a9ff12c8273f443fb56b2bd7d0ab6853333cef" translate="yes" xml:space="preserve">
          <source>The rollback journal file can be deleted,</source>
          <target state="translated">Файл журнала отката может быть удален,</target>
        </trans-unit>
        <trans-unit id="841baedc01f54f9ab6f694a5b23bcc695e5f21f1" translate="yes" xml:space="preserve">
          <source>The rollback journal file can be truncated to zero length, or</source>
          <target state="translated">Файл журнала отката может быть усечен до нулевой длины,или</target>
        </trans-unit>
        <trans-unit id="31415ebe9f384149b021a50dd2fb2ee645763262" translate="yes" xml:space="preserve">
          <source>The rollback journal is</source>
          <target state="translated">Журнал отката</target>
        </trans-unit>
        <trans-unit id="08afad671df0d2c575466e5f9fe1a518b69a6c6b" translate="yes" xml:space="preserve">
          <source>The rollback journal is a file associated with each SQLite database file that holds information used to restore the database file to its initial state during the course of a transaction. The rollback journal file is always located in the same directory as the database file and has the same name as the database file but with the string &quot;&lt;code&gt;-journal&lt;/code&gt;&quot; appended. There can only be a single rollback journal associated with a give database and hence there can only be one write transaction open against a single database at one time.</source>
          <target state="translated">Журнал отката - это файл, связанный с каждым файлом базы данных SQLite, который содержит информацию, используемую для восстановления файла базы данных в исходное состояние в ходе транзакции. Файл журнала отката всегда находится в том же каталоге, что и файл базы данных, и имеет то же имя, что и файл базы данных, но с добавленной строкой &amp;laquo; &lt;code&gt;-journal&lt;/code&gt; &amp;raquo;. Может быть только один журнал отката, связанный с данной базой данных, и, следовательно, может быть только одна транзакция записи, открытая для одной базы данных одновременно.</target>
        </trans-unit>
        <trans-unit id="8a29cd2d15ece2c4c624bfe95a88741dea324ccf" translate="yes" xml:space="preserve">
          <source>The rollback journal is complete and intact on disk when the power is restored. This is a key point. The reason for the flush operation in &lt;a href=&quot;#section_3_7&quot;&gt;step 3.7&lt;/a&gt; is to make absolutely sure that all of the rollback journal is safely on nonvolatile storage prior to making any changes to the database file itself.</source>
          <target state="translated">Журнал отката будет полным и сохранится на диске после восстановления питания. Это ключевой момент. Причина операции сброса на &lt;a href=&quot;#section_3_7&quot;&gt;шаге 3.7&lt;/a&gt; состоит в том, чтобы до внесения каких-либо изменений в сам файл базы данных убедиться, что весь журнал отката безопасно находится в энергонезависимой памяти.</target>
        </trans-unit>
        <trans-unit id="5d1b7832cc643f77f52a69083206bb3b5fc3e74c" translate="yes" xml:space="preserve">
          <source>The rollback journal is not an empty file.</source>
          <target state="translated">Журнал отката не является пустым файлом.</target>
        </trans-unit>
        <trans-unit id="194c559058723739212e12d7c3749019f8df5f55" translate="yes" xml:space="preserve">
          <source>The root page numbers of all tables in the database are integers stored in P4_INTARRAY argument.</source>
          <target state="translated">Номера корневых страниц всех таблиц в БД-это целые числа,которые хранятся в аргументе P4_INTARRAY.</target>
        </trans-unit>
        <trans-unit id="a973ad8403210b9b222fd26c2aef5b8f2808389c" translate="yes" xml:space="preserve">
          <source>The round(X,Y) function returns a floating-point value X rounded to Y digits to the right of the decimal point. If the Y argument is omitted, it is assumed to be 0.</source>
          <target state="translated">Функция round(X,Y)возвращает значение с плавающей точкой X,округленное до Y цифр справа от десятичной запятой.Если аргумент Y опущен,то предполагается,что он равен 0.</target>
        </trans-unit>
        <trans-unit id="5fa12ab6f93c055083bc1a95b917e71f9cff725b" translate="yes" xml:space="preserve">
          <source>The routines &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt;, &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt;, &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare16()&lt;/a&gt;, &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare16_v2()&lt;/a&gt;, &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec()&lt;/a&gt;, and &lt;a href=&quot;c3ref/free_table&quot;&gt;sqlite3_get_table()&lt;/a&gt; accept an SQL statement list (sql-stmt-list) which is a semicolon-separated list of statements.</source>
          <target state="translated">Подпрограммы &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; , &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare ()&lt;/a&gt; , &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare16 ()&lt;/a&gt; , &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare16_v2 ()&lt;/a&gt; , &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec ()&lt;/a&gt; и &lt;a href=&quot;c3ref/free_table&quot;&gt;sqlite3_get_table ()&lt;/a&gt; принимают список операторов SQL (sql-stmt-list), который представляет собой список операторов, разделенных точкой с запятой.</target>
        </trans-unit>
        <trans-unit id="94230b7f00353328063595629d48ef7be9fce389" translate="yes" xml:space="preserve">
          <source>The row-value notation is useful for updating two or more columns of a table from the result of a single query. An example of this is in the full-text search feature of the &lt;a href=&quot;https://www.fossil-scm.org/&quot;&gt;Fossil version control system&lt;/a&gt;.</source>
          <target state="translated">Обозначение значения строки полезно для обновления двух или более столбцов таблицы из результата одного запроса. Примером этого является функция полнотекстового поиска в системе &lt;a href=&quot;https://www.fossil-scm.org/&quot;&gt;контроля версий Fossil&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="12b6af8126e4e3b962d71bf35b72e9a66ab6fcba" translate="yes" xml:space="preserve">
          <source>The row_number() of the first peer in each group - the rank of the current row with gaps. If there is no ORDER BY clause, then all rows are considered peers and this function always returns 1.</source>
          <target state="translated">Функция row_number()первого ровесника в каждой группе-ранг текущей строки с пробелами.Если нет пункта ORDER BY,то все строки считаются равными и эта функция всегда возвращает 1.</target>
        </trans-unit>
        <trans-unit id="d3978e13ae998834400769bcf87213e9a57acdbe" translate="yes" xml:space="preserve">
          <source>The row_number() window function assigns consecutive integers to each row in order of the &quot;ORDER BY&quot; clause within the window-defn (in this case &quot;ORDER BY y&quot;). Note that this does not affect the order in which results are returned from the overall query. The order of the final output is still governed by the ORDER BY clause attached to the SELECT statement (in this case &quot;ORDER BY x&quot;).</source>
          <target state="translated">Функция окна row_number()присваивает каждой строке последовательные целые числа в порядке пункта &quot;ORDER BY&quot; внутри окна-defn (в данном случае &quot;ORDER BY y&quot;).Обратите внимание,что это не влияет на порядок,в котором результаты возвращаются из общего запроса.Порядок конечного результата по-прежнему регулируется пунктом &quot;ЗАКАЗАТЬ ПО&quot;,приложенным к заявлению SELECT (в данном случае &quot;ЗАКАЗАТЬ ПО x&quot;).</target>
        </trans-unit>
        <trans-unit id="97fcd9de22c4efb0eb648cf609eba1ee3fdf411d" translate="yes" xml:space="preserve">
          <source>The rowid (and &quot;oid&quot; and &quot;_rowid_&quot;) is omitted in &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables. WITHOUT ROWID tables are only available in SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_2.html&quot;&gt;version 3.8.2&lt;/a&gt; (2013-12-06) and later. A table that lacks the WITHOUT ROWID clause is called a &quot;rowid table&quot;.</source>
          <target state="translated">Идентификатор строки (а также &amp;laquo;oid&amp;raquo; и &amp;laquo;_rowid_&amp;raquo;) опускается в таблицах &lt;a href=&quot;withoutrowid&quot;&gt;БЕЗ ROWID&lt;/a&gt; . Таблицы БЕЗ ROWID доступны только в &lt;a href=&quot;https://sqlite.org/releaselog/3_8_2.html&quot;&gt;версии&lt;/a&gt; SQLite 3.8.2 (2013-12-06) и новее. Таблица, в которой отсутствует предложение WITHOUT ROWID, называется &quot;таблицей rowid&quot;.</target>
        </trans-unit>
        <trans-unit id="a4a453c67097537d0d10c4b81190fd5d03a4b9dd" translate="yes" xml:space="preserve">
          <source>The rowid column is not accessible on a WITHOUT ROWID virtual table (of course).</source>
          <target state="translated">Столбец rowid недоступен на виртуальной таблице БЕЗ СТРАНИЦ (конечно же).</target>
        </trans-unit>
        <trans-unit id="101d05f0746854eb07065f446e80313cdc7692a7" translate="yes" xml:space="preserve">
          <source>The rowid of the document that contains the term instance.</source>
          <target state="translated">Строка документа,содержащая экземпляр термина.</target>
        </trans-unit>
        <trans-unit id="21037157130833680d029f7ec56534a7a85bda67" translate="yes" xml:space="preserve">
          <source>The rowid of the row in the table being changed</source>
          <target state="translated">Изменение рядовой части строки в таблице</target>
        </trans-unit>
        <trans-unit id="4967842a66478a8da76fb91a725d0ca4385c40a8" translate="yes" xml:space="preserve">
          <source>The rtreecheck() function performs the following checks:</source>
          <target state="translated">Функция rtreecheck()выполняет следующие проверки:</target>
        </trans-unit>
        <trans-unit id="93e10cfe1c883491ee9016750849300312683ba1" translate="yes" xml:space="preserve">
          <source>The rtrim(X,Y) function returns a string formed by removing any and all characters that appear in Y from the right side of X. If the Y argument is omitted, rtrim(X) removes spaces from the right side of X.</source>
          <target state="translated">Функция rtrim(X,Y)возвращает строку,образованную удалением всех символов,которые появляются в Y с правой стороны X.Если аргумент Y опущен,rtrim(X)удаляет пробелы с правой стороны X.</target>
        </trans-unit>
        <trans-unit id="46ff031bad92aa35bcef2484317fc2661aa2d589" translate="yes" xml:space="preserve">
          <source>The rule above says that the letter &quot;a&quot; in user input can be matched against the letter &quot;&amp;auml;&quot; in the dictionary with a penalty of 5.</source>
          <target state="translated">Приведенное выше правило гласит, что буква &amp;laquo;а&amp;raquo; в пользовательском вводе может быть сопоставлена ​​с буквой &amp;laquo;&amp;auml;&amp;raquo; в словаре со штрафом 5.</target>
        </trans-unit>
        <trans-unit id="ed3a2c883d263a1e9abd7d6661fda464d09422b3" translate="yes" xml:space="preserve">
          <source>The rules for determining which collating function to use for a binary comparison operator (=, &amp;lt;, &amp;gt;, &amp;lt;=, &amp;gt;=, !=, IS, and IS NOT) are as follows:</source>
          <target state="translated">Правила определения того, какую функцию сопоставления использовать для оператора двоичного сравнения (=, &amp;lt;,&amp;gt;, &amp;lt;=,&amp;gt; =,! =, IS и IS NOT), следующие:</target>
        </trans-unit>
        <trans-unit id="27705c6545cd7b92f01b98bd6ebfb1aa891406e9" translate="yes" xml:space="preserve">
          <source>The rules for when tables are analyzed are likely to change in future releases.</source>
          <target state="translated">Правила проведения анализа таблиц,скорее всего,изменятся в будущих релизах.</target>
        </trans-unit>
        <trans-unit id="819c15849a2758e415f2520702095eeff7ea13a5" translate="yes" xml:space="preserve">
          <source>The safest and easiest to remember policy is this: assume that any result from</source>
          <target state="translated">Самая безопасная и легкая для запоминания политика заключается в следующем:предположим,что любой результат от</target>
        </trans-unit>
        <trans-unit id="9bfc94ce3f6dbf06df6c899612d318253dda6014" translate="yes" xml:space="preserve">
          <source>The safest policy is to invoke these routines in one of the following ways:</source>
          <target state="translated">Самая безопасная политика заключается в том,чтобы использовать эти процедуры одним из следующих способов:</target>
        </trans-unit>
        <trans-unit id="376b573ee029dd7d9463b27b130e605260069a93" translate="yes" xml:space="preserve">
          <source>The salt-1 and salt-2 values in the frame-header match salt values in the wal-header</source>
          <target state="translated">Значения соли-1 и соли-2 в заголовке кадра совпадают со значениями соли в заголовке стены.</target>
        </trans-unit>
        <trans-unit id="b0647dc001e4e971c816ce4a73a18b5c698aa62d" translate="yes" xml:space="preserve">
          <source>The same SQL statement will fail on every other SQL implementation that we know of due to the use of keywords &quot;union&quot;, &quot;true&quot;, and &quot;with&quot; as identifiers.</source>
          <target state="translated">Один и тот же SQL-оператор не будет работать на всех других известных нам SQL реализациях из-за использования в качестве идентификаторов ключевых слов &quot;union&quot;,&quot;true&quot; и &quot;with&quot;.</target>
        </trans-unit>
        <trans-unit id="67d39480596a16c7c11f0309e84be58f71d89746" translate="yes" xml:space="preserve">
          <source>The same basic B-Tree format is used but the details of the index keys were changed in order to provide better query optimization opportunities. Some of the headers were also changed in order to increase the maximum size of a row from 64KB to 24MB.</source>
          <target state="translated">Используется тот же базовый формат B-Tree,но детали индексных ключей были изменены,чтобы обеспечить лучшие возможности оптимизации запросов.Также были изменены некоторые заголовки,чтобы увеличить максимальный размер строки с 64KB до 24MB.</target>
        </trans-unit>
        <trans-unit id="8827fbb3b64d8c27595464e7777bbb4e772df118" translate="yes" xml:space="preserve">
          <source>The same basic algorithm is followed, except this time the matching rows of the index are scanned from bottom to top instead of from top to bottom, so that the states will appear in descending order.</source>
          <target state="translated">Используется тот же базовый алгоритм,за исключением того,что в этот раз соответствующие строки индекса сканируются снизу вверх,а не сверху вниз,так что состояния будут отображаться в порядке убывания.</target>
        </trans-unit>
        <trans-unit id="8ef4bb6f50ee96f372f99fa9088d7b9c16950c07" translate="yes" xml:space="preserve">
          <source>The same core string formatter is also used internally by SQLite.</source>
          <target state="translated">Тот же самый формирователь строк ядра также используется внутри SQLite.</target>
        </trans-unit>
        <trans-unit id="c76359de67616f16a26e96d68504c135072ade53" translate="yes" xml:space="preserve">
          <source>The same database connection may now be used simultaneously by separate threads.</source>
          <target state="translated">Одно и то же подключение к БД теперь может использоваться одновременно отдельными потоками.</target>
        </trans-unit>
        <trans-unit id="3bfa6cdc7cb80687d83044e6ab3337ab8d5595b5" translate="yes" xml:space="preserve">
          <source>The same indices are used to speed up every loop in both implementation options. The only difference in these two query plans is the order in which the loops are nested.</source>
          <target state="translated">Одни и те же индексы используются для ускорения каждого цикла в обоих вариантах реализации.Единственное отличие этих двух планов запросов-порядок вложения циклов.</target>
        </trans-unit>
        <trans-unit id="d1cd4608c87b02b3bc5ed6c81e7bb9ae9c4b8e13" translate="yes" xml:space="preserve">
          <source>The same technique ensures that an SQLite database file cannot be corrupted by a system failure that occurs at an inopportune moment. If a system failure does occur before SQLite has had a chance to execute sufficient</source>
          <target state="translated">Эта же техника гарантирует,что файл базы данных SQLite не может быть поврежден системным сбоем,который происходит в неподходящий момент.Если сбой системы все же произойдет до того,как SQLite получит возможность выполнить достаточное количество операций.</target>
        </trans-unit>
        <trans-unit id="40cbe38c06ce85b1c49ad0c8414f8f89ac5525ac" translate="yes" xml:space="preserve">
          <source>The same thing can be done with an enterprise client/server database, of course. The advantage of SQLite is that it is easier to install and use and the resulting database is a single file that can be written to a USB memory stick or emailed to a colleague.</source>
          <target state="translated">То же самое,конечно,можно сделать и с базой данных корпоративных клиентов/серверов.Преимущество SQLite заключается в том,что его проще установить и использовать,а результирующая база данных представляет собой единый файл,который можно записать на USB-накопитель или отправить коллеге по электронной почте.</target>
        </trans-unit>
        <trans-unit id="d9e7d4c0bf312ba2ed4d788d1d81806125454441" translate="yes" xml:space="preserve">
          <source>The scalar SQL function rtreecheck(R) or rtreecheck(S,R) runs an integrity check on the rtree table named R contained within database S. The function returns a human-language description of any problems found, or the string 'ok' if everything is ok. Running rtreecheck() on an R*Tree virtual table is similar to running &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt; on a database.</source>
          <target state="translated">Скалярная функция SQL rtreecheck (R) или rtreecheck (S, R) запускает проверку целостности таблицы rtree с именем R, содержащейся в базе данных S. Функция возвращает описание любых обнаруженных проблем на человеческом языке или строку 'ok', если все в порядке. Запуск rtreecheck () в виртуальной таблице R * Tree аналогичен запуску &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA Integrity_check&lt;/a&gt; в базе данных.</target>
        </trans-unit>
        <trans-unit id="181bcf0e796a132dd22a68144a4e494726dfbf32" translate="yes" xml:space="preserve">
          <source>The scenario above sounds far-fetched. But the SQLite developers are aware of at least one commercial product that was released with exactly this bug. The vendor came to the SQLite developers seeking help in tracking down some infrequent database corruption issues they were seeing on Linux and Mac. The problem was eventually traced to the fact that the application was linking against two separate copies of SQLite. The solution was to change the application build procedures to link against just one copy of SQLite instead of two.</source>
          <target state="translated">Сценарий выше звучит надуманно.Но разработчики SQLite знают хотя бы об одном коммерческом продукте,который был выпущен именно с этой ошибкой.Продавец обратился к разработчикам SQLite за помощью в отслеживании некоторых редких проблем с повреждением баз данных,которые они видят на Linux и Mac.В конце концов,проблема была связана с тем,что приложение было связано с двумя отдельными копиями SQLite.Решение состояло в том,чтобы изменить процедуры сборки приложения и привязать его к одной копии SQLite,а не к двум.</target>
        </trans-unit>
        <trans-unit id="7cf33abd12fd2e97d31a441b54d245ec800fc490" translate="yes" xml:space="preserve">
          <source>The schema above defines a directed graph with the ability to store a name at each node. Now consider a query against this schema:</source>
          <target state="translated">Приведенная выше схема определяет направленный график с возможностью хранения имени в каждом узле.Теперь рассмотрим запрос к этой схеме:</target>
        </trans-unit>
        <trans-unit id="d37b6e6570fc572ab09d9f50bc38138c9b41b0ec" translate="yes" xml:space="preserve">
          <source>The schema cookie is a 4-byte big-endian integer at offset 40 that is incremented whenever the database schema changes. A prepared statement is compiled against a specific version of the database schema. When the database schema changes, the statement must be reprepared. When a prepared statement runs, it first checks the schema cookie to ensure the value is the same as when the statement was prepared and if the schema cookie has changed, the statement either automatically reprepares and reruns or it aborts with an &lt;a href=&quot;rescode#schema&quot;&gt;SQLITE_SCHEMA&lt;/a&gt; error.</source>
          <target state="translated">Файл cookie схемы представляет собой 4-байтовое целое число с прямым порядком байтов со смещением 40, которое увеличивается при каждом изменении схемы базы данных. Подготовленный оператор компилируется в соответствии с конкретной версией схемы базы данных. При изменении схемы базы данных оператор должен быть воспроизведен. Когда подготовленный оператор запускается, он сначала проверяет файл cookie схемы, чтобы убедиться, что значение такое же, как и при подготовке оператора, и если файл cookie схемы изменился, оператор либо автоматически выполняет повторное сравнение и запускается повторно, либо прерывается с ошибкой &lt;a href=&quot;rescode#schema&quot;&gt;SQLITE_SCHEMA&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1ab0e540f94c93f90585f3869aa649d5881cec37" translate="yes" xml:space="preserve">
          <source>The schema cookie.</source>
          <target state="translated">Печенье-схема.</target>
        </trans-unit>
        <trans-unit id="4488aa59b7580b3c4da5952eb56f99b2cde228a2" translate="yes" xml:space="preserve">
          <source>The schema depicted above is not designed to store the full-text index directly. Instead, it is used to store one or more b-tree structures. There is one b-tree for each row in the %_segdir table. The %_segdir table row contains the root node and various meta-data associated with the b-tree structure, and the %_segments table contains all other (non-root) b-tree nodes. Each b-tree is referred to as a &quot;segment&quot;. Once it has been created, a segment b-tree is never updated (although it may be deleted altogether).</source>
          <target state="translated">Схема,изображенная выше,не предназначена для непосредственного хранения полнотекстового индекса.Вместо этого она используется для хранения одной или нескольких b-деревянных структур.В таблице %_segdir для каждой строки имеется по одному b-дереву.Строка таблицы %_segdir содержит корневой узел и различные мета-данные,связанные с b-деревянной структурой,а таблица %_segments содержит все остальные (не корневые)b-деревянные узлы.Каждое b-дерево называется &quot;сегментом&quot;.После его создания b-дерево сегмента никогда не обновляется (хотя может быть удалено вообще).</target>
        </trans-unit>
        <trans-unit id="2b92ee620ed7f83eb29e5266f914917afed4620a" translate="yes" xml:space="preserve">
          <source>The schema for the DBSTAT virtual table looks like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fd02dc53052cb07a4282595789654910705302c" translate="yes" xml:space="preserve">
          <source>The schema for the dbstat virtual table is this:</source>
          <target state="translated">Схема для виртуальной таблицы dbstat такая:</target>
        </trans-unit>
        <trans-unit id="2252a25e95423355b1edc92e550e314acf60ad89" translate="yes" xml:space="preserve">
          <source>The schema for the table returned by json_each() and json_tree() is as follows:</source>
          <target state="translated">Схема для таблицы,возвращаемой функциями json_each()и json_tree(),выглядит следующим образом:</target>
        </trans-unit>
        <trans-unit id="c3619e8cc0e29548b78032aaa5130408e5391fbe" translate="yes" xml:space="preserve">
          <source>The schema for the tables_used table is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f20e4cd592c03cab97adad3d2182916294f862d" translate="yes" xml:space="preserve">
          <source>The schema format number for a new database can be set at runtime using the &lt;a href=&quot;pragma#pragma_legacy_file_format&quot;&gt;PRAGMA legacy_file_format&lt;/a&gt; command.</source>
          <target state="translated">Номер формата схемы для новой базы данных может быть установлен во время выполнения с помощью команды &lt;a href=&quot;pragma#pragma_legacy_file_format&quot;&gt;PRAGMA legacy_file_format&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="933a80ece41d7c4fe3169e373964e2826ef1d8f7" translate="yes" xml:space="preserve">
          <source>The schema format number is a 4-byte big-endian integer at offset 44. The schema format number is similar to the file format read and write version numbers at offsets 18 and 19 except that the schema format number refers to the high-level SQL formatting rather than the low-level b-tree formatting. Four schema format numbers are currently defined:</source>
          <target state="translated">Номер формата схемы представляет собой 4-байтовое биг-ендианское целое число со смещением 44.Номер формата схемы аналогичен формату файла считывания и записи номеров версий со смещением 18 и 19,за исключением того,что номер формата схемы относится к высокоуровневому форматированию SQL,а не к низкоуровневому форматированию b-дерева.В настоящее время определены четыре номера формата схемы:</target>
        </trans-unit>
        <trans-unit id="62a7a887a20a821d1b69e9b449caf90b4200d958" translate="yes" xml:space="preserve">
          <source>The schema format number. Supported schema formats are 1, 2, 3, and 4.</source>
          <target state="translated">Номер формата схемы.Поддерживаются форматы схем 1,2,3 и 4.</target>
        </trans-unit>
        <trans-unit id="c07d56a869023707575ade10738a217ecfcee4af" translate="yes" xml:space="preserve">
          <source>The schema of an SQL database is able to represent information more directly and succinctly than a key/value database such as a ZIP archive. This makes the document content more accessible to third-party applications and scripts and facilitates advanced features such as built-in document versioning, and incremental saving of work in progress for recovery after a crash.</source>
          <target state="translated">Схема базы данных SQL способна представлять информацию более непосредственно и лаконично,чем база данных ключей/значений,такая как ZIP-архив.Это делает содержимое документов более доступным для сторонних приложений и скриптов,а также облегчает использование таких расширенных функций,как встроенная версионность документов и инкрементальное сохранение текущей работы для восстановления после сбоя.</target>
        </trans-unit>
        <trans-unit id="4828e232778c36009f5d78cd72861a810e476bb6" translate="yes" xml:space="preserve">
          <source>The schema of the bytecode table is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a339d84c3beee1eeb93694c936d75161789ed451" translate="yes" xml:space="preserve">
          <source>The schema table can always be referenced using the name &quot;sqlite_schema&quot;, especially if qualifed by the schema name like &quot;main.sqlite_schema&quot; or &quot;temp.sqlite_schema&quot;. But for historical compatibility, some alternative names are also recognized, including:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70d31e0ed54ade1f01f5803b76d2ee1ab0a7fa16" translate="yes" xml:space="preserve">
          <source>The schema_version pragma will get or set the value of the schema-version integer at offset 40 in the &lt;a href=&quot;fileformat2#database_header&quot;&gt;database header&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87cc88d5b4a5e95bb023c0790cc28378b9e2bd05" translate="yes" xml:space="preserve">
          <source>The schema_version pragma will to get or set the value of the schema-version integer at offset 40 in the &lt;a href=&quot;fileformat2#database_header&quot;&gt;database header&lt;/a&gt;.</source>
          <target state="translated">Прагма schema_version будет получать или устанавливать значение целого числа версии схемы со смещением 40 в &lt;a href=&quot;fileformat2#database_header&quot;&gt;заголовке базы данных&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="077341a10c528ac1588a1408b9034c9f8021b705" translate="yes" xml:space="preserve">
          <source>The scheme of the URI must be &quot;&lt;code&gt;file:&lt;/code&gt;&quot;. Any other scheme results in the input being treated as an ordinary filename.</source>
          <target state="translated">Схема URI должна быть &amp;laquo; &lt;code&gt;file:&lt;/code&gt; &amp;raquo;. Любая другая схема приводит к тому, что ввод обрабатывается как обычное имя файла.</target>
        </trans-unit>
        <trans-unit id="08d91918dffee8fc87a94df6946790f6caab8817" translate="yes" xml:space="preserve">
          <source>The score is a combination of rank and distance. The idea is that a lower score is better. The virtual table attempts to find words with the lowest score and by default (unless overridden by ORDER BY) returns results in order of increasing score.</source>
          <target state="translated">Счет представляет собой комбинацию ранга и расстояния.Идея заключается в том,что меньший балл лучше.Виртуальная таблица пытается найти слова с наименьшим количеством баллов и по умолчанию (если только они не переопределены ORDER BY)возвращает результаты в порядке возрастания баллов.</target>
        </trans-unit>
        <trans-unit id="61fd3b441b127465c680d5c3514e6d464720698f" translate="yes" xml:space="preserve">
          <source>The script compiles the TH3 test harness into machine code (&quot;th3.o&quot;) if necessary.</source>
          <target state="translated">При необходимости скрипт компилирует тестовый жгут TH3 в машинный код (&quot;th3.o&quot;).</target>
        </trans-unit>
        <trans-unit id="9f405708716b43bff0ad67cd4c7d9fb92e6afc28" translate="yes" xml:space="preserve">
          <source>The script compiles the sqlite3.c source file into assembly language (&quot;sqlite3.s&quot;) if necessary.</source>
          <target state="translated">При необходимости скрипт компилирует исходный файл sqlite3.c на ассемблере (&quot;sqlite3.s&quot;).</target>
        </trans-unit>
        <trans-unit id="9bf1fc92f793f60b433b7ebac87847be7a48eb60" translate="yes" xml:space="preserve">
          <source>The script loops through instructions in the assembly language file to locate branch operations.</source>
          <target state="translated">Скрипт проходит через инструкции в файле на языке ассемблера,чтобы найти операции с ветвями.</target>
        </trans-unit>
        <trans-unit id="576c62795ba33247bec0c331da3dd87f14e7a748" translate="yes" xml:space="preserve">
          <source>The script makes a copy of the original sqlite3.s file.</source>
          <target state="translated">Скрипт делает копию оригинального файла sqlite3.s.</target>
        </trans-unit>
        <trans-unit id="fbefc60f4848710280b3f195980be93ae6fb0731" translate="yes" xml:space="preserve">
          <source>The script shows progress for each cycle of the previous step then displays a summary of &quot;survivors&quot; at the end. A &quot;survivor&quot; is a mutation that was not detected by TH3.</source>
          <target state="translated">Сценарий показывает прогресс для каждого цикла предыдущего шага,а затем в конце отображает сводку &quot;выживших&quot;.Выживший&quot;-это мутация,которая не была обнаружена TH3.</target>
        </trans-unit>
        <trans-unit id="4a731425cd1bb86844c78ad068a724419eca7459" translate="yes" xml:space="preserve">
          <source>The search for these strings in the type declaration is case insensitive, of course. If any of the above strings occur anywhere in the type declaration, then the datatype of the column is text. Notice that the type &quot;VARCHAR&quot; contains &quot;CHAR&quot; as a substring so it is considered text.</source>
          <target state="translated">Поиск этих строк в объявлении типа,конечно,не чувствителен к регистру.Если какая-либо из вышеперечисленных строк встречается где-либо в объявлении типа,то типом данных столбца является текст.Обратите внимание,что тип &quot;VARCHAR&quot; содержит &quot;CHAR&quot; в качестве подстроки,поэтому он считается текстом.</target>
        </trans-unit>
        <trans-unit id="201735a6137bd8c721345300624cc86e3645ba64" translate="yes" xml:space="preserve">
          <source>The second &lt;a href=&quot;opcode#Transaction&quot;&gt;Transaction&lt;/a&gt; instruction begins a transaction and starts a rollback journal for database 1, the database used for temporary tables.</source>
          <target state="translated">Вторая инструкция &lt;a href=&quot;opcode#Transaction&quot;&gt;Transaction&lt;/a&gt; начинает транзакцию и запускает журнал отката для базы данных 1, базы данных, используемой для временных таблиц.</target>
        </trans-unit>
        <trans-unit id="541464126fdf47682a89498dd2c1f59037e5c50b" translate="yes" xml:space="preserve">
          <source>The second SELECT is implemented by instructions 14 through 19. Instruction 14 initializes the loop by rewinding its cursor. A new result row is created from the &quot;four&quot; column of table &quot;examp2&quot; by instructions 15 and 16. But instead of using PutStrKey to write this new row into the temporary table, we instead call Delete to remove it from the temporary table if it exists.</source>
          <target state="translated">Второй ВЫБОР осуществляется с помощью инструкций с 14 по 19.Инструкция 14 инициализирует петлю,перематывая курсор.Новая строка результата создается из столбца &quot;четыре&quot; таблицы &quot;экзамен2&quot; инструкциями 15 и 16.Но вместо того,чтобы использовать PutStrKey для записи этой новой строки во временную таблицу,мы вызываем команду Delete,чтобы удалить ее из временной таблицы,если она существует.</target>
        </trans-unit>
        <trans-unit id="b382925f3a88c50c566963d5ae8b2f2a69bce488" translate="yes" xml:space="preserve">
          <source>The second advantage the SQLite printf routines have over &lt;b&gt;sprintf&lt;/b&gt; are two new formatting options specifically designed to support string literals in SQL. Within the format string, the %q formatting option works very much like %s in that it reads a null-terminated string from the argument list and inserts it into the result. But %q translates the inserted string by making two copies of every single-quote (') character in the substituted string. This has the effect of escaping the end-of-string meaning of single-quote within a string literal. The %Q formatting option works similar; it translates the single-quotes like %q and additionally encloses the resulting string in single-quotes. If the argument for the %Q formatting options is a NULL pointer, the resulting string is NULL without single quotes.</source>
          <target state="translated">Второе преимущество подпрограмм SQLite printf перед &lt;b&gt;sprintf&lt;/b&gt; - это две новые опции форматирования, специально разработанные для поддержки строковых литералов в SQL. В строке формата параметр форматирования% q работает очень похоже на% s, поскольку он считывает строку с завершающим нулем из списка аргументов и вставляет ее в результат. Но% q переводит вставленную строку, создавая две копии каждого символа одинарной кавычки (') в подставляемой строке. Это имеет эффект экранирования значения одинарной кавычки в конце строки внутри строкового литерала. Параметр форматирования% Q работает аналогично; он переводит одинарные кавычки, например% q, и дополнительно заключает полученную строку в одинарные кавычки. Если аргумент для параметров форматирования% Q является указателем NULL, результирующая строка будет NULL без одинарных кавычек.</target>
        </trans-unit>
        <trans-unit id="24bd2add8c4054117cbe09f659537f282404edb5" translate="yes" xml:space="preserve">
          <source>The second and all subsequent 32768-byte units of the shm file are like this:</source>
          <target state="translated">Второй и все последующие 32768-байтовые единицы файла shm такие:</target>
        </trans-unit>
        <trans-unit id="2f88dda8423c5371c7ad74eb85809481a6d1addf" translate="yes" xml:space="preserve">
          <source>The second and third forms return the computed edit distance between strings 'string1' and &quot;string2'. In the second form, a language id of 0 is used. The language id is specified in the third form.</source>
          <target state="translated">Вторая и третья формы возвращают вычисленное расстояние редактирования между строками 'string1' и 'string2'.Во второй форме используется идентификатор языка 0.Идентификатор языка указывается в третьей форме.</target>
        </trans-unit>
        <trans-unit id="bab5b375ff048a5d63f1a3b4cc3d343effcaa9c1" translate="yes" xml:space="preserve">
          <source>The second argument (xFilter) is the &quot;filter callback&quot;. For changes to rows in tables that are not attached to the Session object, the filter is called to determine whether changes to the table's rows should be tracked or not. If xFilter returns 0, changes are not tracked. Note that once a table is attached, xFilter will not be called again.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3a47f0193da66fdda72484a51d350d2076b5681" translate="yes" xml:space="preserve">
          <source>The second argument (xFilter) is the &quot;filter callback&quot;. For changes to rows in tables that are not attached to the Session object, the filter is called to determine whether changes to the table's rows should be tracked or not. If xFilter returns 0, changes is not tracked. Note that once a table is attached, xFilter will not be called again.</source>
          <target state="translated">Второй аргумент (xFilter)-&quot;обратный вызов фильтра&quot;.При изменениях строк в таблицах,которые не привязаны к объекту сеанса,фильтр вызывается для определения того,должны ли быть отслежены изменения в строках таблицы.Если xFilter возвращает 0,изменения не отслеживаются.Обратите внимание,что после прикрепления таблицы xFilter больше не будет вызываться.</target>
        </trans-unit>
        <trans-unit id="718f90fed591046439ad14f60ea06810377e7e83" translate="yes" xml:space="preserve">
          <source>The second argument indicates the reason that FTS5 is requesting tokenization of the supplied text. This is always one of the following four values:</source>
          <target state="translated">Второй аргумент указывает на причину,по которой FTS5 запрашивает токенирование поставляемого текста.Это всегда одно из следующих четырех значений:</target>
        </trans-unit>
        <trans-unit id="1b37e9b1846948d626696aade4d54493fddd03d8" translate="yes" xml:space="preserve">
          <source>The second argument is a pointer to the function to invoke when a row is updated, inserted or deleted in a rowid table. The first argument to the callback is a copy of the third argument to sqlite3_update_hook(). The second callback argument is one of &lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;SQLITE_INSERT&lt;/a&gt;, &lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;SQLITE_DELETE&lt;/a&gt;, or &lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;SQLITE_UPDATE&lt;/a&gt;, depending on the operation that caused the callback to be invoked. The third and fourth arguments to the callback contain pointers to the database and table name containing the affected row. The final callback parameter is the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; of the row. In the case of an update, this is the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; after the update takes place.</source>
          <target state="translated">Второй аргумент - это указатель на функцию, вызываемую при обновлении, вставке или удалении строки в таблице rowid. Первый аргумент обратного вызова - это копия третьего аргумента sqlite3_update_hook (). Второй аргумент обратного вызова - это &lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;SQLITE_INSERT&lt;/a&gt; , &lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;SQLITE_DELETE&lt;/a&gt; или &lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;SQLITE_UPDATE&lt;/a&gt; , в зависимости от операции, которая вызвала вызов обратного вызова. Третий и четвертый аргументы обратного вызова содержат указатели на базу данных и имя таблицы, содержащей затронутую строку. Последний параметр обратного вызова - это &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; строки. В случае обновления это &lt;a href=&quot;lang_createtable#rowid&quot;&gt;идентификатор строки&lt;/a&gt; после обновления.</target>
        </trans-unit>
        <trans-unit id="f6eef977cb1db09c38e32ceda39f74ec952be8d2" translate="yes" xml:space="preserve">
          <source>The second argument is a pointer to the function to invoke when a row is updated, inserted or deleted in a rowid table. The first argument to the callback is a copy of the third argument to sqlite3_update_hook(). The second callback argument is one of &lt;a href=&quot;c_alter_table&quot;&gt;SQLITE_INSERT&lt;/a&gt;, &lt;a href=&quot;c_alter_table&quot;&gt;SQLITE_DELETE&lt;/a&gt;, or &lt;a href=&quot;c_alter_table&quot;&gt;SQLITE_UPDATE&lt;/a&gt;, depending on the operation that caused the callback to be invoked. The third and fourth arguments to the callback contain pointers to the database and table name containing the affected row. The final callback parameter is the &lt;a href=&quot;../lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; of the row. In the case of an update, this is the &lt;a href=&quot;../lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; after the update takes place.</source>
          <target state="translated">Второй аргумент - это указатель на функцию, вызываемую при обновлении, вставке или удалении строки в таблице rowid. Первый аргумент обратного вызова - это копия третьего аргумента sqlite3_update_hook (). Второй аргумент обратного вызова - это &lt;a href=&quot;c_alter_table&quot;&gt;SQLITE_INSERT&lt;/a&gt; , &lt;a href=&quot;c_alter_table&quot;&gt;SQLITE_DELETE&lt;/a&gt; или &lt;a href=&quot;c_alter_table&quot;&gt;SQLITE_UPDATE&lt;/a&gt; , в зависимости от операции, которая вызвала вызов обратного вызова. Третий и четвертый аргументы обратного вызова содержат указатели на базу данных и имя таблицы, содержащей затронутую строку. Последний параметр обратного вызова - это &lt;a href=&quot;../lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; строки. В случае обновления это &lt;a href=&quot;../lang_createtable#rowid&quot;&gt;идентификатор строки&lt;/a&gt; после обновления.</target>
        </trans-unit>
        <trans-unit id="724bd11ad92d936922e1ead7d8425d39851a3038" translate="yes" xml:space="preserve">
          <source>The second argument is the index of the SQL parameter to be set. The leftmost SQL parameter has an index of 1. When the same named SQL parameter is used more than once, second and subsequent occurrences have the same index as the first occurrence. The index for named parameters can be looked up using the &lt;a href=&quot;#sqlite3_bind_parameter_index&quot;&gt;sqlite3_bind_parameter_index()&lt;/a&gt; API if desired. The index for &quot;?NNN&quot; parameters is the value of NNN. The NNN value must be between 1 and the &lt;a href=&quot;#sqlite3_limit&quot;&gt;sqlite3_limit()&lt;/a&gt; parameter &lt;a href=&quot;#sqlitelimitvariablenumber&quot;&gt;SQLITE_LIMIT_VARIABLE_NUMBER&lt;/a&gt; (default value: 32766).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4e308f3aa98b17590b5e994747b662ab58b2433" translate="yes" xml:space="preserve">
          <source>The second argument is the index of the SQL parameter to be set. The leftmost SQL parameter has an index of 1. When the same named SQL parameter is used more than once, second and subsequent occurrences have the same index as the first occurrence. The index for named parameters can be looked up using the &lt;a href=&quot;#sqlite3_bind_parameter_index&quot;&gt;sqlite3_bind_parameter_index()&lt;/a&gt; API if desired. The index for &quot;?NNN&quot; parameters is the value of NNN. The NNN value must be between 1 and the &lt;a href=&quot;#sqlite3_limit&quot;&gt;sqlite3_limit()&lt;/a&gt; parameter &lt;a href=&quot;#sqlitelimitvariablenumber&quot;&gt;SQLITE_LIMIT_VARIABLE_NUMBER&lt;/a&gt; (default value: 999).</source>
          <target state="translated">Второй аргумент - это индекс устанавливаемого параметра SQL. Самый левый параметр SQL имеет индекс 1. Когда один и тот же именованный параметр SQL используется более одного раза, второе и последующие вхождения имеют тот же индекс, что и первое вхождение. При необходимости индекс для именованных параметров можно найти с помощью API &lt;a href=&quot;#sqlite3_bind_parameter_index&quot;&gt;sqlite3_bind_parameter_index ()&lt;/a&gt; . Индекс для параметров &amp;laquo;? NNN&amp;raquo; - это значение NNN. Значение NNN должно быть между 1 и &lt;a href=&quot;#sqlite3_limit&quot;&gt;sqlite3_limit ()&lt;/a&gt; параметр &lt;a href=&quot;#sqlitelimitvariablenumber&quot;&gt;SQLITE_LIMIT_VARIABLE_NUMBER&lt;/a&gt; (значение по умолчанию: 999).</target>
        </trans-unit>
        <trans-unit id="ff965dc4a3884d50d8419508e30018f226ac3b0d" translate="yes" xml:space="preserve">
          <source>The second argument is the index of the SQL parameter to be set. The leftmost SQL parameter has an index of 1. When the same named SQL parameter is used more than once, second and subsequent occurrences have the same index as the first occurrence. The index for named parameters can be looked up using the &lt;a href=&quot;bind_parameter_index&quot;&gt;sqlite3_bind_parameter_index()&lt;/a&gt; API if desired. The index for &quot;?NNN&quot; parameters is the value of NNN. The NNN value must be between 1 and the &lt;a href=&quot;limit&quot;&gt;sqlite3_limit()&lt;/a&gt; parameter &lt;a href=&quot;c_limit_attached#sqlitelimitvariablenumber&quot;&gt;SQLITE_LIMIT_VARIABLE_NUMBER&lt;/a&gt; (default value: 32766).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3f014790ea15d84ae5efd1a40e8d6440e64de4e" translate="yes" xml:space="preserve">
          <source>The second argument is the index of the SQL parameter to be set. The leftmost SQL parameter has an index of 1. When the same named SQL parameter is used more than once, second and subsequent occurrences have the same index as the first occurrence. The index for named parameters can be looked up using the &lt;a href=&quot;bind_parameter_index&quot;&gt;sqlite3_bind_parameter_index()&lt;/a&gt; API if desired. The index for &quot;?NNN&quot; parameters is the value of NNN. The NNN value must be between 1 and the &lt;a href=&quot;limit&quot;&gt;sqlite3_limit()&lt;/a&gt; parameter &lt;a href=&quot;c_limit_attached#sqlitelimitvariablenumber&quot;&gt;SQLITE_LIMIT_VARIABLE_NUMBER&lt;/a&gt; (default value: 999).</source>
          <target state="translated">Второй аргумент - это индекс устанавливаемого параметра SQL. Самый левый параметр SQL имеет индекс 1. Когда один и тот же именованный параметр SQL используется более одного раза, второе и последующие вхождения имеют тот же индекс, что и первое вхождение. При необходимости индекс для именованных параметров можно найти с помощью API &lt;a href=&quot;bind_parameter_index&quot;&gt;sqlite3_bind_parameter_index ()&lt;/a&gt; . Индекс для параметров &amp;laquo;? NNN&amp;raquo; - это значение NNN. Значение NNN должно быть между 1 и &lt;a href=&quot;limit&quot;&gt;sqlite3_limit ()&lt;/a&gt; параметр &lt;a href=&quot;c_limit_attached#sqlitelimitvariablenumber&quot;&gt;SQLITE_LIMIT_VARIABLE_NUMBER&lt;/a&gt; (значение по умолчанию: 999).</target>
        </trans-unit>
        <trans-unit id="2fb1bff691f79072fe4cf1aa2d31d1bd3832725a" translate="yes" xml:space="preserve">
          <source>The second argument passed to the xToken() callback (&quot;tflags&quot;) should normally be set to 0. The exception is if the tokenizer supports synonyms. In this case see the discussion below for details.</source>
          <target state="translated">Второй аргумент,передаваемый в функцию обратного вызова xToken()(&quot;tflags&quot;),обычно должен быть равен 0.Исключение составляют случаи,когда токенайзер поддерживает синонимы.В этом случае смотрите подробности ниже.</target>
        </trans-unit>
        <trans-unit id="ca943db57529952ad5f76d4c9a47b52221a6d6e3" translate="yes" xml:space="preserve">
          <source>The second argument to sqlite3_db_config(D,V,...) is the &lt;a href=&quot;#sqlitedbconfiglookaside&quot;&gt;configuration verb&lt;/a&gt; - an integer code that indicates what aspect of the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; is being configured. Subsequent arguments vary depending on the configuration verb.</source>
          <target state="translated">Второй аргумент sqlite3_db_config (D, V, ...) - это команда &lt;a href=&quot;#sqlitedbconfiglookaside&quot;&gt;настройки&lt;/a&gt; - целочисленный код, указывающий, какой аспект &lt;a href=&quot;#sqlite3&quot;&gt;подключения&lt;/a&gt; к базе данных настраивается. Последующие аргументы меняются в зависимости от глагола конфигурации.</target>
        </trans-unit>
        <trans-unit id="a7845e3bb7f88361055af36d05adde4b952592f9" translate="yes" xml:space="preserve">
          <source>The second argument to sqlite3_db_config(D,V,...) is the &lt;a href=&quot;c_dbconfig_defensive#sqlitedbconfiglookaside&quot;&gt;configuration verb&lt;/a&gt; - an integer code that indicates what aspect of the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; is being configured. Subsequent arguments vary depending on the configuration verb.</source>
          <target state="translated">Второй аргумент sqlite3_db_config (D, V, ...) - это команда &lt;a href=&quot;c_dbconfig_defensive#sqlitedbconfiglookaside&quot;&gt;настройки&lt;/a&gt; - целочисленный код, указывающий, какой аспект &lt;a href=&quot;sqlite3&quot;&gt;подключения&lt;/a&gt; к базе данных настраивается. Последующие аргументы меняются в зависимости от глагола конфигурации.</target>
        </trans-unit>
        <trans-unit id="7ca88f23336b34513d2d790b7c87ef9c5d8d0e67" translate="yes" xml:space="preserve">
          <source>The second argument to the error logger callback is an integer &lt;a href=&quot;rescode#extrc&quot;&gt;extended error code&lt;/a&gt;. The third argument to the error logger is the text of the error message. The error message text is stored in a fixed-length stack buffer in the calling function and so will only be valid for the duration of the error logger callback function. The error logger should make a copy of this message into persistent storage if retention of the message is needed.</source>
          <target state="translated">Второй аргумент обратного вызова регистратора ошибок - это &lt;a href=&quot;rescode#extrc&quot;&gt;расширенный&lt;/a&gt; целочисленный код ошибки . Третий аргумент регистратора ошибок - это текст сообщения об ошибке. Текст сообщения об ошибке хранится в буфере стека фиксированной длины в вызывающей функции и поэтому будет действителен только на время выполнения функции обратного вызова регистратора ошибок. Регистратор ошибок должен сделать копию этого сообщения в постоянном хранилище, если необходимо сохранить сообщение.</target>
        </trans-unit>
        <trans-unit id="a2a47b21d6064e4d10a2f6d6161c0f1dce1664a1" translate="yes" xml:space="preserve">
          <source>The second argument, &quot;zSql&quot;, is the statement to be compiled, encoded as either UTF-8 or UTF-16. The sqlite3_prepare(), sqlite3_prepare_v2(), and sqlite3_prepare_v3() interfaces use UTF-8, and sqlite3_prepare16(), sqlite3_prepare16_v2(), and sqlite3_prepare16_v3() use UTF-16.</source>
          <target state="translated">Второй аргумент,&quot;zSql&quot;,это оператор,который должен быть скомпилирован,закодированный либо как UTF-8,либо как UTF-16.Интерфейсы sqlite3_prepare(),sqlite3_prepare_v2()и sqlite3_prepare_v3()используют UTF-8,а sqlite3_prepare16(),sqlite3_prepare16_v2()и sqlite3_prepare16_v3()используют UTF-16.</target>
        </trans-unit>
        <trans-unit id="f2e250c2ef383dec7dc31067a07b23d0da95c91b" translate="yes" xml:space="preserve">
          <source>The second beta release for SQLite 3.0.</source>
          <target state="translated">Второй бета-релиз для SQLite 3.0.</target>
        </trans-unit>
        <trans-unit id="771287a1de97a728b2134cd9c420c1c39a0f52c6" translate="yes" xml:space="preserve">
          <source>The second column is the name of the table.</source>
          <target state="translated">Вторая колонка-это название таблицы.</target>
        </trans-unit>
        <trans-unit id="68511a08109abd7af5a81fce815eeb4f023584c9" translate="yes" xml:space="preserve">
          <source>The second form changes the journaling mode for &quot;</source>
          <target state="translated">Вторая форма меняет режим протоколирования на &quot;</target>
        </trans-unit>
        <trans-unit id="2f272c30ebac8ce92b2f903964b40a07bad463d7" translate="yes" xml:space="preserve">
          <source>The second form of the INSERT statement contains a &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statement instead of a VALUES clause. A new entry is inserted into the table for each row of data returned by executing the SELECT statement. If a column-list is specified, the number of columns in the result of the SELECT must be the same as the number of items in the column-list. Otherwise, if no column-list is specified, the number of columns in the result of the SELECT must be the same as the number of columns in the table. Any SELECT statement, including &lt;a href=&quot;lang_select#compound&quot;&gt;compound SELECTs&lt;/a&gt; and SELECT statements with &lt;a href=&quot;lang_select#orderby&quot;&gt;ORDER BY&lt;/a&gt; and/or &lt;a href=&quot;lang_select#limitoffset&quot;&gt;LIMIT&lt;/a&gt; clauses, may be used in an INSERT statement of this form.</source>
          <target state="translated">Вторая форма оператора INSERT содержит &lt;a href=&quot;lang_select&quot;&gt;оператор SELECT&lt;/a&gt; вместо предложения VALUES. В таблицу добавляется новая запись для каждой строки данных, возвращаемых при выполнении оператора SELECT. Если указан список столбцов, количество столбцов в результате SELECT должно быть таким же, как количество элементов в списке столбцов. В противном случае, если список столбцов не указан, количество столбцов в результате SELECT должно быть таким же, как количество столбцов в таблице. Любой оператор SELECT, включая &lt;a href=&quot;lang_select#compound&quot;&gt;составные операторы&lt;/a&gt; SELECT и SELECT с предложениями &lt;a href=&quot;lang_select#orderby&quot;&gt;ORDER BY&lt;/a&gt; и / или &lt;a href=&quot;lang_select#limitoffset&quot;&gt;LIMIT&lt;/a&gt; , может использоваться в операторе INSERT этой формы.</target>
        </trans-unit>
        <trans-unit id="ec9aa9593798c759bbdf9a6cf2b73541eab87efe" translate="yes" xml:space="preserve">
          <source>The second form of the command is this:</source>
          <target state="translated">Вторая форма команды такая:</target>
        </trans-unit>
        <trans-unit id="fa9b557c755fe5c619c7e5fc0af0adff81ce48ad" translate="yes" xml:space="preserve">
          <source>The second form of the pragma listed above is used to set a new limit in bytes for the specified database. A negative number implies no limit. To always truncate rollback journals and WAL files to their minimum size, set the journal_size_limit to zero. Both the first and second forms of the pragma listed above return a single result row containing a single integer column - the value of the journal size limit in bytes. The default journal size limit is -1 (no limit). The &lt;a href=&quot;compile#default_journal_size_limit&quot;&gt;SQLITE_DEFAULT_JOURNAL_SIZE_LIMIT&lt;/a&gt; preprocessor macro can be used to change the default journal size limit at compile-time.</source>
          <target state="translated">Вторая форма прагмы, указанная выше, используется для установки нового ограничения в байтах для указанной базы данных. Отрицательное число означает отсутствие ограничений. Чтобы всегда обрезать журналы отката и файлы WAL до минимального размера, установите для параметра journal_size_limit значение ноль. И первая, и вторая формы прагмы, перечисленные выше, возвращают одну строку результата, содержащую один целочисленный столбец - значение ограничения размера журнала в байтах. Ограничение размера журнала по умолчанию - -1 (без ограничений). &lt;a href=&quot;compile#default_journal_size_limit&quot;&gt;SQLITE_DEFAULT_JOURNAL_SIZE_LIMIT&lt;/a&gt; препроцессор макрос может быть использован для изменения журнала предельного размера по умолчанию во время компиляции.</target>
        </trans-unit>
        <trans-unit id="4008980ca9a9274111928748bc06de4b907efa68" translate="yes" xml:space="preserve">
          <source>The second integer, if it is present, is the aggregate size of all data stored on leaf pages in bytes. If the value is negative, then the segment is the output of an unfinished incremental-merge operation, and the absolute value is current size in bytes.</source>
          <target state="translated">Второе целое число,если оно присутствует,является совокупным размером всех данных,хранящихся на страницах листа в байтах.Если значение отрицательное,то сегмент является выводом незавершенной операции инкременталь-мергера,а абсолютное значение-текущий размер в байтах.</target>
        </trans-unit>
        <trans-unit id="211c21970b7cdeb91101e574bc29708c2cdfae64" translate="yes" xml:space="preserve">
          <source>The second line above creates a virtual table named &quot;t1&quot; that reads the content of the file named in the argument. The number and names of the columns is determined automatically by reading the first line of content. Other options to the CSV virtual table provide the ability to take the CSV content from a string rather than a separate file, and give the programmer more control over the number and names of the columns. The options are detailed below. The CSV virtual table is usually created as a TEMP table so that it exists only for the current database connection and does not become a permanent part of the database schema. Note that there is no &quot;CREATE TEMP VIRTUAL TABLE&quot; command in SQLite. Instead, prepend the &quot;temp.&quot; schema prefix to the name of the virtual table.</source>
          <target state="translated">Во второй строке выше создается виртуальная таблица с именем &quot;t1&quot;,которая читает содержимое файла с именем в аргументе.Номер и имена столбцов определяются автоматически при прочтении первой строки содержимого.Другие опции виртуальной таблицы CSV предоставляют возможность взять содержимое CSV из строки,а не из отдельного файла,и дать программисту больше контроля над количеством и именами столбцов.Опции подробно описаны ниже.Виртуальная таблица CSV обычно создается как таблица TEMP,так что она существует только для текущего соединения с БД и не становится постоянной частью схемы БД.Обратите внимание,что в SQLite отсутствует команда &quot;CREATE TEMP VIRTUAL TABLE&quot;.Вместо этого представьте префикс схемы &quot;temp.&quot; к имени виртуальной таблицы.</target>
        </trans-unit>
        <trans-unit id="c3933495d9788c26f88ba69fbabb317f1e83064e" translate="yes" xml:space="preserve">
          <source>The second line of the file contains 211792 characters of impenetrable XML. Yes, 211792 characters all on one line. This file is a good stress-test for a text editor. Thankfully, the file is not some obscure binary format, but in terms of accessibility, it might as well be written in Klingon.</source>
          <target state="translated">Вторая строка файла содержит 211792 символа непроницаемого XML.Да,211792 символа все в одной строке.Этот файл является хорошим стресс-тестом для текстового редактора.К счастью,этот файл не является каким-то непонятным бинарным форматом,но с точки зрения доступности он может быть написан и на клингонском языке.</target>
        </trans-unit>
        <trans-unit id="5c1d27adf7a874de9fb599be39fb1d27d63c3092" translate="yes" xml:space="preserve">
          <source>The second number Y is incremented for any change that breaks forward compatibility by adding new features. Most future SQLite releases are expected to increment the second number Y. The Z is reset to zero whenever Y is increased.</source>
          <target state="translated">Второе число Y увеличивается для любого изменения,которое нарушает прямую совместимость путем добавления новых функций.Ожидается,что большинство будущих релизов SQLite будут увеличивать второе число Y.Z сбрасывается на ноль всякий раз,когда число Y увеличивается.</target>
        </trans-unit>
        <trans-unit id="50b9dd44fd65466aa651f4fce7056da00ed7e13a" translate="yes" xml:space="preserve">
          <source>The second parameter (argc) and the fourth parameter (columnNames) are still valid and can be used to determine the number and names of the result columns if there had been a result. The default behavior is not to invoke the callback at all if the result set is empty.</source>
          <target state="translated">Второй параметр (argc)и четвертый параметр (columnNames)все еще действительны и могут быть использованы для определения количества и названий столбцов результата,если бы был получен результат.Поведение по умолчанию заключается в том,чтобы вообще не вызывать обратный вызов,если результирующий набор пуст.</target>
        </trans-unit>
        <trans-unit id="682054ab4ce2cb4dfe2528dcad7556d5d406ca5f" translate="yes" xml:space="preserve">
          <source>The second parameter is the name of the SQL function to be created or redefined. The length of the name is limited to 255 bytes in a UTF-8 representation, exclusive of the zero-terminator. Note that the name length limit is in UTF-8 bytes, not characters nor UTF-16 bytes. Any attempt to create a function with a longer name will result in &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_MISUSE&lt;/a&gt; being returned.</source>
          <target state="translated">Второй параметр - это имя функции SQL, которую нужно создать или переопределить. Длина имени ограничена 255 байтами в представлении UTF-8, исключая нулевой терминатор. Обратите внимание, что максимальная длина имени указана в байтах UTF-8, а не в символах или байтах UTF-16. Любая попытка создать функцию с более длинным именем приведет к &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;возврату SQLITE_MISUSE&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="266b83f6439ab5e88dcd3928741ef542cdbb6626" translate="yes" xml:space="preserve">
          <source>The second parameter is the name of the SQL function to be created or redefined. The length of the name is limited to 255 bytes in a UTF-8 representation, exclusive of the zero-terminator. Note that the name length limit is in UTF-8 bytes, not characters nor UTF-16 bytes. Any attempt to create a function with a longer name will result in &lt;a href=&quot;../rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt; being returned.</source>
          <target state="translated">Второй параметр - это имя функции SQL, которую нужно создать или переопределить. Длина имени ограничена 255 байтами в представлении UTF-8, исключая нулевой терминатор. Обратите внимание, что максимальная длина имени указана в байтах UTF-8, а не в символах или байтах UTF-16. Любая попытка создать функцию с более длинным именем приведет к &lt;a href=&quot;../rescode#misuse&quot;&gt;возврату SQLITE_MISUSE&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="560b989b803d6b51bde79f3db2c1500c44cc5751" translate="yes" xml:space="preserve">
          <source>The second parameter to the preupdate callback is a pointer to the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; that registered the preupdate hook. The third parameter to the preupdate callback is one of the constants &lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;SQLITE_INSERT&lt;/a&gt;, &lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;SQLITE_DELETE&lt;/a&gt;, or &lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;SQLITE_UPDATE&lt;/a&gt; to identify the kind of update operation that is about to occur. The fourth parameter to the preupdate callback is the name of the database within the database connection that is being modified. This will be &quot;main&quot; for the main database or &quot;temp&quot; for TEMP tables or the name given after the AS keyword in the &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; statement for attached databases. The fifth parameter to the preupdate callback is the name of the table that is being modified.</source>
          <target state="translated">Второй параметр обратного вызова preupdate - это указатель на &lt;a href=&quot;#sqlite3&quot;&gt;соединение&lt;/a&gt; с базой данных, которое зарегистрировало обработчик preupdate. Третий параметр обратного вызова перед обновлением - это одна из констант &lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;SQLITE_INSERT&lt;/a&gt; , &lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;SQLITE_DELETE&lt;/a&gt; или &lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;SQLITE_UPDATE&lt;/a&gt; для определения типа операции обновления, которая должна произойти. Четвертым параметром обратного вызова перед обновлением является имя базы данных в изменяемом соединении с базой данных. Это будет &amp;laquo;main&amp;raquo; для основной базы данных или &amp;laquo;temp&amp;raquo; для таблиц TEMP или имя, указанное после ключевого слова AS в операторе &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; для присоединенных баз данных. Пятый параметр обратного вызова перед обновлением - это имя изменяемой таблицы.</target>
        </trans-unit>
        <trans-unit id="097d5db1a651bbf810ec3be53362ed0414cfc3f9" translate="yes" xml:space="preserve">
          <source>The second parameter to the preupdate callback is a pointer to the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; that registered the preupdate hook. The third parameter to the preupdate callback is one of the constants &lt;a href=&quot;c_alter_table&quot;&gt;SQLITE_INSERT&lt;/a&gt;, &lt;a href=&quot;c_alter_table&quot;&gt;SQLITE_DELETE&lt;/a&gt;, or &lt;a href=&quot;c_alter_table&quot;&gt;SQLITE_UPDATE&lt;/a&gt; to identify the kind of update operation that is about to occur. The fourth parameter to the preupdate callback is the name of the database within the database connection that is being modified. This will be &quot;main&quot; for the main database or &quot;temp&quot; for TEMP tables or the name given after the AS keyword in the &lt;a href=&quot;../lang_attach&quot;&gt;ATTACH&lt;/a&gt; statement for attached databases. The fifth parameter to the preupdate callback is the name of the table that is being modified.</source>
          <target state="translated">Второй параметр обратного вызова preupdate - это указатель на &lt;a href=&quot;sqlite3&quot;&gt;соединение&lt;/a&gt; с базой данных, которое зарегистрировало обработчик preupdate. Третий параметр обратного вызова перед обновлением - это одна из констант &lt;a href=&quot;c_alter_table&quot;&gt;SQLITE_INSERT&lt;/a&gt; , &lt;a href=&quot;c_alter_table&quot;&gt;SQLITE_DELETE&lt;/a&gt; или &lt;a href=&quot;c_alter_table&quot;&gt;SQLITE_UPDATE&lt;/a&gt; для определения типа операции обновления, которая должна произойти. Четвертым параметром обратного вызова перед обновлением является имя базы данных в изменяемом соединении с базой данных. Это будет &amp;laquo;main&amp;raquo; для основной базы данных или &amp;laquo;temp&amp;raquo; для таблиц TEMP или имя, указанное после ключевого слова AS в операторе &lt;a href=&quot;../lang_attach&quot;&gt;ATTACH&lt;/a&gt; для присоединенных баз данных. Пятый параметр обратного вызова перед обновлением - это имя изменяемой таблицы.</target>
        </trans-unit>
        <trans-unit id="f5ad56c8e6b709d2294efc15c0b9ac27fea8d776" translate="yes" xml:space="preserve">
          <source>The second step finds the four shortest paths to visit two nodes beginning with one of the four paths from the previous step. In the case where two or more paths are equivalent (they have the same set of visited nodes, though possibly in a different order) only the first and lowest-cost path is retained. We have:</source>
          <target state="translated">На втором этапе находятся четыре кратчайших пути для посещения двух узлов,начинающихся с одного из четырех путей,указанных на предыдущем этапе.В случае,когда два или более путей эквивалентны (они имеют один и тот же набор посещенных узлов,хотя,возможно,и в другом порядке),сохраняется только первый и самый дешевый путь.У нас есть:</target>
        </trans-unit>
        <trans-unit id="73fbb8fcf9b3b6fa8277785714e82cfa142507c2" translate="yes" xml:space="preserve">
          <source>The second through fifth forms of this pragma set the encoding that the main database will be created with if it is created by this session. The string 'UTF-16' is interpreted as &quot;UTF-16 encoding using native machine byte-ordering&quot;. It is not possible to change the text encoding of a database after it has been created and any attempt to do so will be silently ignored.</source>
          <target state="translated">Вторая-пятая формы этой прагмы задают кодировку,с помощью которой будет создана основная база данных,если она будет создана к этому сеансу.Строка 'UTF-16' интерпретируется как &quot;кодировка UTF-16 с использованием байт-заказа на родной машине&quot;.Изменить текстовую кодировку БД после ее создания невозможно,и любая попытка сделать это будет молча игнорироваться.</target>
        </trans-unit>
        <trans-unit id="5882943850506b5e4c2358f26a0aca06e4d009ac" translate="yes" xml:space="preserve">
          <source>The secure_delete setting causes deleted content to be overwritten with zeros. There is a small performance penalty since additional I/O must occur. On the other hand, secure_delete can prevent fragments of sensitive information from lingering in unused parts of the database file after it has been deleted. See the documentation on the &lt;a href=&quot;pragma#pragma_secure_delete&quot;&gt;secure_delete pragma&lt;/a&gt; for additional information.</source>
          <target state="translated">Параметр secure_delete вызывает перезапись удаленного содержимого нулями. Существует небольшое снижение производительности, поскольку должен происходить дополнительный ввод-вывод. С другой стороны, secure_delete может предотвратить сохранение фрагментов конфиденциальной информации в неиспользуемых частях файла базы данных после его удаления. Дополнительную информацию см. В документации по &lt;a href=&quot;pragma#pragma_secure_delete&quot;&gt;прагме secure_delete&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5b04afcfc3f7fd09080833015b31410c518c0339" translate="yes" xml:space="preserve">
          <source>The separate &lt;a href=&quot;fileformat2&quot;&gt;file format&lt;/a&gt; description provides details on the structure of a database file and of the write-head log file used in &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt;. But details of the locking protocol and of the format of the WAL-index are deliberately omitted since those details are left to discretion of individual &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; implementations. This document fills in those missing details for the unix and windows &lt;a href=&quot;vfs&quot;&gt;VFSes&lt;/a&gt;.</source>
          <target state="translated">В отдельном описании &lt;a href=&quot;fileformat2&quot;&gt;формата файла&lt;/a&gt; содержится подробная информация о структуре файла базы данных и файла журнала головки записи, используемого в &lt;a href=&quot;wal&quot;&gt;режиме WAL&lt;/a&gt; . Но детали протокола блокировки и формата WAL-индекса намеренно опускаются, поскольку эти детали оставлены на усмотрение отдельных реализаций &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; . Этот документ заполняет недостающие детали для &lt;a href=&quot;vfs&quot;&gt;VFS для UNIX&lt;/a&gt; и Windows .</target>
        </trans-unit>
        <trans-unit id="92103d1dd017d8e08e89604f71cfaaa913bec164" translate="yes" xml:space="preserve">
          <source>The session extension facilitates this by recording all changes to both Alice's and Bob's databases and writing those changes into changeset or patchset files. At the end of the day, Alice can send her changeset to Bob and Bob can &quot;apply&quot; it to his database. The result (assuming there are no conflicts) is that Bob's database then contains both his changes and Alice's changes. Likewise, Bob can send a changeset of his work over to Alice and she can apply his changes to her database.</source>
          <target state="translated">Расширение сеанса облегчает это,записывая все изменения в базы данных как Алисы,так и Боба,и записывая эти изменения в changeset или patchset файлы.В конце концов,Элис может отправить свой changeset Бобу,а Боб может &quot;применить&quot; его к своей базе данных.В результате (при условии отсутствия конфликтов)база данных Боба будет содержать как его изменения,так и изменения Элис.Аналогичным образом,Боб может отправить набор изменений своей работы Элис,а она может &quot;применить&quot; его изменения к своей базе данных.</target>
        </trans-unit>
        <trans-unit id="1c8659fbbef014d7697d1ea170e739bed552acd5" translate="yes" xml:space="preserve">
          <source>The session extension only works with tables that have a declared PRIMARY KEY. The PRIMARY KEY of a table may be an INTEGER PRIMARY KEY (rowid alias) or an external PRIMARY KEY.</source>
          <target state="translated">Расширение сессии работает только с таблицами,которые имеют объявленный PRIMARY KEY.PRIMARY KEY таблицы может быть INTEGER PRIMARY KEY (псевдоним rowid)или внешним PRIMARY KEY.</target>
        </trans-unit>
        <trans-unit id="8619b8eb0bb510e39b3c8622337b2bb7b6549aba" translate="yes" xml:space="preserve">
          <source>The session extension provide a mechanism for recording changes to some or all of the &lt;a href=&quot;rowidtable&quot;&gt;rowid tables&lt;/a&gt; in an SQLite database, and packaging those changes into a &quot;changeset&quot; or &quot;patchset&quot; file that can later be used to apply the same set of changes to another database with the same schema and compatible starting data. A &quot;changeset&quot; may also be inverted and used to &quot;undo&quot; a session.</source>
          <target state="translated">Расширение сеанса обеспечивает механизм для записи изменений в некоторые или все &lt;a href=&quot;rowidtable&quot;&gt;таблицы идентификаторов строк&lt;/a&gt; в базе данных SQLite и упаковки этих изменений в файл &amp;laquo;набора изменений&amp;raquo; или &amp;laquo;набора исправлений&amp;raquo;, который впоследствии можно использовать для применения того же набора изменений к другому. база данных с той же схемой и совместимыми стартовыми данными. &amp;laquo;Набор изменений&amp;raquo; также может быть инвертирован и использован для &amp;laquo;отмены&amp;raquo; сеанса.</target>
        </trans-unit>
        <trans-unit id="0b97f5ba300285bc33992abb7779519b897b7aa7" translate="yes" xml:space="preserve">
          <source>The session object &quot;indirect&quot; flag is set when the change is made, or</source>
          <target state="translated">Флаг объекта сеанса &quot;непрямой&quot; устанавливается при изменении,или</target>
        </trans-unit>
        <trans-unit id="ffcb76dee8dc3b4cb20fe29908bbbe2ff2230909" translate="yes" xml:space="preserve">
          <source>The session object is configured with a set of tables to monitor changes on.</source>
          <target state="translated">Объект сеанса настраивается с набором таблиц для отслеживания изменений.</target>
        </trans-unit>
        <trans-unit id="0c67ff7ccfd533851dea34da8187939bbeae8841" translate="yes" xml:space="preserve">
          <source>The session object is deleted using a call to the &lt;a href=&quot;session/sqlite3session_delete&quot;&gt;sqlite3session_delete()&lt;/a&gt; API function.</source>
          <target state="translated">Объект сеанса удаляется с помощью вызова функции API &lt;a href=&quot;session/sqlite3session_delete&quot;&gt;sqlite3session_delete ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b41c2d1dd25f0b9daf0304c7870c3eb7ae78b919" translate="yes" xml:space="preserve">
          <source>The session object therefore accumulates two types of records - those that consist of primary key values only (created when the user inserts a new record) and those that consist of the primary key values and the original values of other table columns (created when the users deletes or updates a record).</source>
          <target state="translated">Следовательно,объект сеанса аккумулирует два типа записей-те,которые состоят только из значений первичного ключа (создаются,когда пользователь вставляет новую запись)и те,которые состоят из значений первичного ключа и исходных значений других столбцов таблицы (создаются,когда пользователь удаляет или обновляет запись).</target>
        </trans-unit>
        <trans-unit id="67b4d05a6aa852ba851b95d39158470c33cead0c" translate="yes" xml:space="preserve">
          <source>The session object will be used to create changesets for tables in database zDb, where zDb is either &quot;main&quot;, or &quot;temp&quot;, or the name of an attached database. It is not an error if database zDb is not attached to the database when the session object is created.</source>
          <target state="translated">Объект сессии будет использоваться для создания таблиц изменений в БД zDb,где zDb-это либо &quot;главная&quot;,либо &quot;временная&quot;,либо имя подключенной БД.Это не является ошибкой,если при создании объекта сессии БД zDb не подключена к БД.</target>
        </trans-unit>
        <trans-unit id="45a8679117c7936fefc29c4e8b252b099d09917b" translate="yes" xml:space="preserve">
          <source>The sessions module never invokes an xOutput callback with the third parameter set to a value less than or equal to zero. Other than this, no guarantees are made as to the size of the chunks of data returned.</source>
          <target state="translated">Модуль сеансов никогда не вызывает обратного вызова xOutput с третьим параметром,установленным в значение меньше или равным нулю.Кроме этого,не даётся никаких гарантий относительно размера возвращаемых кусков данных.</target>
        </trans-unit>
        <trans-unit id="a218d47a709906affb4f3ae717da9de3077b519d" translate="yes" xml:space="preserve">
          <source>The sessions module revolves around creating and manipulating changesets. A changeset is a blob of data that encodes a series of changes to a database. Each change in a changeset is one of the following:</source>
          <target state="translated">Модуль сеансов вращается вокруг создания и манипулирования модификациями.Изменения-это блок данных,который кодирует серию изменений в базу данных.Каждое изменение в changesetе является одним из следующих:</target>
        </trans-unit>
        <trans-unit id="d639d6bbcd88a2f2cd5339240f5d5c5de8f80432" translate="yes" xml:space="preserve">
          <source>The set X contains the index in aPgno of every entry in the current 32768-byte unit of the shm file that might possible be a solution to the FindFrame(P,M) function. Each of these entries must be checked separately to ensure that the aPgno value is P and that the frame number does not exceed M. The largest frame number that passes those two tests is the answer.</source>
          <target state="translated">Набор X содержит индекс в aPgno каждой записи в текущей 32768-байтовой единице файла shm,что может быть решением для функции FindFrame(P,M).Каждая из этих записей должна быть проверена отдельно,чтобы убедиться,что значение aPgno равно P и что номер кадра не превышает M.Самый большой номер кадра,который проходит эти два теста,является ответом.</target>
        </trans-unit>
        <trans-unit id="daeab809359987c0f17f57c78f38704f62041f7b" translate="yes" xml:space="preserve">
          <source>The set of</source>
          <target state="translated">Набор</target>
        </trans-unit>
        <trans-unit id="df619f50e7143055665ccf4d69e938c1340f4737" translate="yes" xml:space="preserve">
          <source>The set of built-in auxiliary functions provided by FTS5 may be improved upon in the future.</source>
          <target state="translated">Набор встроенных вспомогательных функций,предоставляемых FTS5,может быть улучшен в будущем.</target>
        </trans-unit>
        <trans-unit id="a49341beec33b485301f8bafe6ae6c61c6f39915" translate="yes" xml:space="preserve">
          <source>The set of checklist items for release checklist is potentially updated for each release. The content and complete history of each release checklist are retained for the historical record.</source>
          <target state="translated">Набор элементов контрольного списка для каждого релиза потенциально обновляется для каждого релиза.Содержание и полная история каждого релиза сохраняются для исторической записи.</target>
        </trans-unit>
        <trans-unit id="0f5a66644e1d1f4b0f41c960d4f2f7a794b20868" translate="yes" xml:space="preserve">
          <source>The set of static mutexes may change from one SQLite release to the next. Applications that override the built-in mutex logic must be prepared to accommodate additional static mutexes.</source>
          <target state="translated">Набор статических мьютексов может меняться от одного релиза SQLite к другому.Приложения,переопределяющие встроенную логику мьютекса,должны быть готовы к размещению дополнительных статических мьютексов.</target>
        </trans-unit>
        <trans-unit id="9b60f1982b5c4164ca917a617479f0aacfe46294" translate="yes" xml:space="preserve">
          <source>The shadow tables are ordinary SQLite data tables. You can query them directly if you like, though this unlikely to reveal anything particularly useful. And you can &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;, &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt;, &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; or even &lt;a href=&quot;lang_droptable&quot;&gt;DROP&lt;/a&gt; the shadow tables, though doing so will corrupt your R*Tree index. So it is best to simply ignore the shadow tables. Recognize that they hold your R*Tree index information and let it go as that.</source>
          <target state="translated">Теневые таблицы - это обычные таблицы данных SQLite. Вы можете запросить их напрямую, если хотите, хотя это вряд ли даст вам что-нибудь особенно полезное. И вы можете &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; , &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; , &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; или даже &lt;a href=&quot;lang_droptable&quot;&gt;DROP&lt;/a&gt; теневых таблиц, хотя это приведет к коррумпированному индексу R * Tree. Так что лучше просто игнорировать теневые таблицы. Осознайте, что они хранят информацию о вашем индексе R * Tree, и оставьте ее как есть.</target>
        </trans-unit>
        <trans-unit id="7b89e4e1261efca1d668789aecafeceb06cf0045" translate="yes" xml:space="preserve">
          <source>The shared library filename passed to &lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension()&lt;/a&gt; may omit the filename suffix, and an appropriate architecture-dependent suffix (&quot;.so&quot;, &quot;.dylib&quot;, or &quot;.dll&quot;) will be added automatically.</source>
          <target state="translated">Имя файла общей библиотеки, переданное в &lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension (),&lt;/a&gt; может опускать суффикс имени файла, и соответствующий архитектурно-зависимый суффикс (&amp;laquo;.so&amp;raquo;, &amp;laquo;.dylib&amp;raquo; или &amp;laquo;.dll&amp;raquo;) будет добавлен автоматически.</target>
        </trans-unit>
        <trans-unit id="683712ddb2de169a205df89a5ffe29d5c006c2b5" translate="yes" xml:space="preserve">
          <source>The shared-memory file contains no persistent content. The only purpose of the shared-memory file is to provide a block of shared memory for use by multiple processes all accessing the same database in WAL mode. If the &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; is able to provide an alternative method for accessing shared memory, then that alternative method might be used rather than the shared-memory file. For example, if &lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;PRAGMA locking_mode&lt;/a&gt; is set to EXCLUSIVE (meaning that only one process is able to access the database file) then the shared memory will be allocated from heap rather than out of the shared-memory file, and the shared-memory file will never be created.</source>
          <target state="translated">Файл с общей памятью не содержит постоянного содержимого. Единственная цель файла с общей памятью - предоставить блок общей памяти для использования несколькими процессами, обращающимися к одной и той же базе данных в режиме WAL. Если &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; может предоставить альтернативный метод доступа к разделяемой памяти, то этот альтернативный метод может использоваться вместо файла с разделяемой памятью. Например, если &lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;PRAGMA lock_mode&lt;/a&gt; установлен в EXCLUSIVE (это означает, что только один процесс может получить доступ к файлу базы данных), то общая память будет выделяться из кучи, а не из файла с общей памятью, и файл с общей памятью будет никогда не создаваться.</target>
        </trans-unit>
        <trans-unit id="d84d71db4e9c7a1a18a467e4bbe2be0320c053f2" translate="yes" xml:space="preserve">
          <source>The shared-memory file has the same lifetime as its associated WAL file. The shared-memory file is created when the WAL file is created and is deleted when the WAL file is deleted. During WAL file recovery, the shared memory file is recreated from scratch based on the contents of the WAL file being recovered.</source>
          <target state="translated">Файл общей памяти имеет то же время жизни,что и связанный с ним файл WAL.Файл общей памяти создается при создании файла WAL и удаляется при удалении файла WAL.Во время восстановления файла WAL файл общей памяти воссоздается с нуля на основе содержимого восстанавливаемого файла WAL.</target>
        </trans-unit>
        <trans-unit id="c6175d074e784d9fffd662056186d3e1dc1f4cc9" translate="yes" xml:space="preserve">
          <source>The shm does not contain any database content and is not required to recover the database following a crash. For that reason, the first client to connect to a quiescent database will normally truncate the shm file if it exists. Since the content of the shm file does not need to be preserved across a crash, the shm file is never fsync()-ed to disk. In fact, if there were a mechanism by which SQLite could tell the operating system to never persist the shm file to disk but always hold it in cache memory, SQLite would use that mechanism to avoid any unnecessary disk I/O associated with the shm file. However, no such mechanism exists in standard posix.</source>
          <target state="translated">ШМ не содержит содержимого базы данных и не требуется для восстановления базы данных после аварии.По этой причине первый клиент,подключившийся к базе данных в состоянии покоя,обычно усекает shm-файл,если он существует.Поскольку содержимое файла shm не нужно сохранять во время аварии,файл shm никогда не помещается на диск с помощью функции fsync()-ed.На самом деле,если бы существовал механизм,с помощью которого SQLite мог бы сказать операционной системе никогда не сохранять файл shm на диск,но всегда хранить его в кэш-памяти,SQLite бы использовал этот механизм,чтобы избежать лишних дисковых операций ввода/вывода,связанных с файлом shm.Однако в стандартном исполнении такого механизма не существует.</target>
        </trans-unit>
        <trans-unit id="2ce5842569cd9ae6cb873fe122d925e98dfd9e57" translate="yes" xml:space="preserve">
          <source>The shm file consists of one or more hash tables, where each hash table is 32768 bytes in size. Except, a 136-byte header is carved out of the front of the very first hash table, so the first hash table is only 32632 bytes in size. The total size of the shm file is always a multiple of 32768. In most cases, the total size of the shm file is exactly 32768 bytes. The shm file only needs to grow beyond a single hash table if when the wal file grows very large (more than 4079 frames). Since the default &lt;a href=&quot;c3ref/wal_autocheckpoint&quot;&gt;automatic checkpoint threshold&lt;/a&gt; is 1000, WAL files rare reach the 4079 threshold needed to make the shm file grow.</source>
          <target state="translated">Файл shm состоит из одной или нескольких хеш-таблиц, каждая из которых имеет размер 32768 байт. За исключением того, что 136-байтовый заголовок вырезан из передней части самой первой хеш-таблицы, поэтому размер первой хеш-таблицы составляет всего 32632 байта. Общий размер файла shm всегда кратен 32768. В большинстве случаев общий размер файла shm составляет ровно 32768 байт. Файл shm должен вырасти за пределы одной хеш-таблицы только в том случае, если файл wal становится очень большим (более 4079 кадров). Поскольку &lt;a href=&quot;c3ref/wal_autocheckpoint&quot;&gt;порог автоматической контрольной точки&lt;/a&gt; по умолчанию равен 1000, файлы WAL редко достигают порога 4079, необходимого для увеличения размера файла shm.</target>
        </trans-unit>
        <trans-unit id="0d8774149ef596e36906cd1fe56afff10a697841" translate="yes" xml:space="preserve">
          <source>The signature of the xAccess method has been modified to return an &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; and to store its output into an integer pointed to by a parameter, rather than returning the output directly. This change allows the xAccess() method to report failures. In association with this signature change, a new extended error code &lt;a href=&quot;rescode#ioerr_access&quot;&gt;SQLITE_IOERR_ACCESS&lt;/a&gt; has been added.</source>
          <target state="translated">Сигнатура метода xAccess была изменена для возврата &lt;a href=&quot;rescode&quot;&gt;кода ошибки&lt;/a&gt; и сохранения ее вывода в виде целого числа, на которое указывает параметр, вместо того, чтобы возвращать вывод напрямую. Это изменение позволяет методу xAccess () сообщать об ошибках. В связи с этим изменением подписи был добавлен новый расширенный код ошибки &lt;a href=&quot;rescode#ioerr_access&quot;&gt;SQLITE_IOERR_ACCESS&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="73da15d1378e7e4cecf6c05a9921a5f1b3117f3b" translate="yes" xml:space="preserve">
          <source>The signature of the xCheckReservedLock method on &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; has been modified so that it returns an &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; and stores its boolean result into an integer pointed to by a parameter. In association with this change, a new extended error code &lt;a href=&quot;rescode#ioerr_checkreservedlock&quot;&gt;SQLITE_IOERR_CHECKRESERVEDLOCK&lt;/a&gt; has been added.</source>
          <target state="translated">Сигнатура метода xCheckReservedLock в &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; была изменена так, что он возвращает &lt;a href=&quot;rescode&quot;&gt;код ошибки&lt;/a&gt; и сохраняет свой логический результат в целое число, на которое указывает параметр. В связи с этим изменением был добавлен новый расширенный код ошибки &lt;a href=&quot;rescode#ioerr_checkreservedlock&quot;&gt;SQLITE_IOERR_CHECKRESERVEDLOCK&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="23da313c5318bbaf1e11638c6787139e74ceff62" translate="yes" xml:space="preserve">
          <source>The simple, modular design of SQLite makes it a good platform for prototyping new, experimental database language features or ideas.</source>
          <target state="translated">Простой модульный дизайн SQLite делает его хорошей платформой для прототипирования новых,экспериментальных возможностей языка баз данных или идей.</target>
        </trans-unit>
        <trans-unit id="2d0de7ad7a0838db1beb185b37e3f4659d20a947" translate="yes" xml:space="preserve">
          <source>The single row of result-set data created by evaluating the aggregate and non-aggregate expressions in the result-set forms the result of an aggregate query without a GROUP BY clause. An aggregate query without a GROUP BY clause always returns exactly one row of data, even if there are zero rows of input data.</source>
          <target state="translated">Единая строка данных результирующей выборки,созданная путем вычисления агрегированных и не агрегированных выражений в результирующей выборке,формирует результат агрегированного запроса без пункта GROUP BY.Агрегированный запрос без пункта GROUP BY всегда возвращает ровно одну строку данных,даже если есть нулевые строки входных данных.</target>
        </trans-unit>
        <trans-unit id="fee8fe6df1809775fcd62fdf9f110bcf759d94a6" translate="yes" xml:space="preserve">
          <source>The six streaming API xxx_strm() functions serve similar purposes to the corresponding non-streaming API functions:</source>
          <target state="translated">Шесть потоковых функций API xxx_strm()служат аналогично соответствующим не потоковым функциям API:</target>
        </trans-unit>
        <trans-unit id="af903c0dcc364c9d11abbe191c3960a1c5d014f5" translate="yes" xml:space="preserve">
          <source>The sixth argument to sqlite3_bind_text64() must be one of &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF8&lt;/a&gt;, &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16&lt;/a&gt;, &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16BE&lt;/a&gt;, or &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16LE&lt;/a&gt; to specify the encoding of the text in the third parameter. If the sixth argument to sqlite3_bind_text64() is not one of the allowed values shown above, or if the text encoding is different from the encoding specified by the sixth parameter, then the behavior is undefined.</source>
          <target state="translated">Шестой аргумент sqlite3_bind_text64 () должен быть одним из &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF8&lt;/a&gt; , &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16&lt;/a&gt; , &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16BE&lt;/a&gt; или &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16LE,&lt;/a&gt; чтобы указать кодировку текста в третьем параметре. Если шестой аргумент sqlite3_bind_text64 () не является одним из допустимых значений, показанных выше, или если кодировка текста отличается от кодировки, указанной шестым параметром, то поведение не определено.</target>
        </trans-unit>
        <trans-unit id="3a920902ff183846916ffe84129516653c512659" translate="yes" xml:space="preserve">
          <source>The sixth argument to sqlite3_bind_text64() must be one of &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF8&lt;/a&gt;, &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16&lt;/a&gt;, &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16BE&lt;/a&gt;, or &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16LE&lt;/a&gt; to specify the encoding of the text in the third parameter. If the sixth argument to sqlite3_bind_text64() is not one of the allowed values shown above, or if the text encoding is different from the encoding specified by the sixth parameter, then the behavior is undefined.</source>
          <target state="translated">Шестой аргумент sqlite3_bind_text64 () должен быть одним из &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF8&lt;/a&gt; , &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16&lt;/a&gt; , &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16BE&lt;/a&gt; или &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16LE,&lt;/a&gt; чтобы указать кодировку текста в третьем параметре. Если шестой аргумент sqlite3_bind_text64 () не является одним из допустимых значений, показанных выше, или если кодировка текста отличается от кодировки, указанной шестым параметром, то поведение не определено.</target>
        </trans-unit>
        <trans-unit id="e8b06ccbdc8c379a9a470f7c185a0247a80f8e2b" translate="yes" xml:space="preserve">
          <source>The sixth, seventh and eighth parameters passed to the three &quot;sqlite3_create_function*&quot; functions, xFunc, xStep and xFinal, are pointers to C-language functions that implement the SQL function or aggregate. A scalar SQL function requires an implementation of the xFunc callback only; NULL pointers must be passed as the xStep and xFinal parameters. An aggregate SQL function requires an implementation of xStep and xFinal and NULL pointer must be passed for xFunc. To delete an existing SQL function or aggregate, pass NULL pointers for all three function callbacks.</source>
          <target state="translated">Шестой,седьмой и восьмой параметры,переданные трем функциям &quot;sqlite3_create_function*&quot;,xFunc,xStep и xFinal,являются указателями на функции языка C,реализующие функцию SQL или агрегат.Скалярная SQL-функция требует только реализации обратного вызова xFunc;в качестве параметров xStep и xFinal должны передаваться указатели NULL.Функция агрегированного SQL требует реализации указателя xStep,а указатели xFinal и NULL должны передаваться для xFunc.Чтобы удалить существующую SQL-функцию или агрегат,необходимо передать NULL указатели для всех трех обратных вызовов функций.</target>
        </trans-unit>
        <trans-unit id="5a1e0ca7d22b49ccdf57dfbe9e13e610f7e7488a" translate="yes" xml:space="preserve">
          <source>The sixth, seventh, eighth and ninth parameters (xStep, xFinal, xValue and xInverse) passed to sqlite3_create_window_function are pointers to C-language callbacks that implement the new function. xStep and xFinal must both be non-NULL. xValue and xInverse may either both be NULL, in which case a regular aggregate function is created, or must both be non-NULL, in which case the new function may be used as either an aggregate or aggregate window function. More details regarding the implementation of aggregate window functions are &lt;a href=&quot;../windowfunctions#udfwinfunc&quot;&gt;available here&lt;/a&gt;.</source>
          <target state="translated">Шестой, седьмой, восьмой и девятый параметры (xStep, xFinal, xValue и xInverse), переданные в sqlite3_create_window_function, являются указателями на обратные вызовы языка C, реализующие новую функцию. Оба xStep и xFinal не должны быть NULL. xValue и xInverse могут быть либо NULL, и в этом случае создается обычная агрегатная функция, либо оба должны быть не NULL, и в этом случае новая функция может использоваться либо как агрегатная, либо как агрегатная оконная функция. Более подробная информация о реализации агрегированных оконных функций &lt;a href=&quot;../windowfunctions#udfwinfunc&quot;&gt;доступна здесь&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9f70d86715eabcca8a7d61d2f6e68b2fc4d6a57e" translate="yes" xml:space="preserve">
          <source>The sixth, seventh, eighth and ninth parameters (xStep, xFinal, xValue and xInverse) passed to sqlite3_create_window_function are pointers to C-language callbacks that implement the new function. xStep and xFinal must both be non-NULL. xValue and xInverse may either both be NULL, in which case a regular aggregate function is created, or must both be non-NULL, in which case the new function may be used as either an aggregate or aggregate window function. More details regarding the implementation of aggregate window functions are &lt;a href=&quot;windowfunctions#udfwinfunc&quot;&gt;available here&lt;/a&gt;.</source>
          <target state="translated">Шестой, седьмой, восьмой и девятый параметры (xStep, xFinal, xValue и xInverse), переданные в sqlite3_create_window_function, являются указателями на обратные вызовы языка C, реализующие новую функцию. Оба xStep и xFinal не должны быть NULL. xValue и xInverse могут быть либо NULL, и в этом случае создается обычная агрегатная функция, либо оба должны быть не NULL, и в этом случае новая функция может использоваться либо как агрегатная, либо как агрегатная оконная функция. Более подробная информация о реализации агрегированных оконных функций &lt;a href=&quot;windowfunctions#udfwinfunc&quot;&gt;доступна здесь&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="650196bb22cf5bf05d1563df9b31bf781c3e9a6d" translate="yes" xml:space="preserve">
          <source>The size of the blobs in the test data affects performance. The filesystem will generally be faster for larger blobs, since the overhead of open() and close() is amortized over more bytes of I/O, whereas the database will be more efficient in both speed and space as the average blob size decreases.</source>
          <target state="translated">Размер капель в тестовых данных влияет на производительность.Файловая система,как правило,будет быстрее для больших блоков,так как накладные расходы open()и close()амортизируются за большее количество байт ввода/вывода,в то время как база данных будет более эффективной как по скорости,так и по объему,так как средний размер блока уменьшается.</target>
        </trans-unit>
        <trans-unit id="71ba6b5b378d657456a5945d2ff20a780b1b14d4" translate="yes" xml:space="preserve">
          <source>The size of the lookaside memory pool has a global default value but can also be configured on a connection-by-connection basis. To change the default size of the lookaside memory pool at compile-time, use the &lt;a href=&quot;compile#default_lookaside&quot;&gt;-DSQLITE_DEFAULT_LOOKASIDE=&lt;i&gt;SZ,N&lt;/i&gt;&lt;/a&gt; option. To change the default size of the lookaside memory pool at start-time, use the &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config()&lt;/a&gt; interface:</source>
          <target state="translated">Размер резервного пула памяти имеет глобальное значение по умолчанию, но его также можно настроить для каждого соединения. Чтобы изменить размер по умолчанию пула памяти ассоциативного во время компиляции, используйте &lt;a href=&quot;compile#default_lookaside&quot;&gt;-DSQLITE_DEFAULT_LOOKASIDE = &lt;i&gt;SZ, N&lt;/i&gt;&lt;/a&gt; вариант. Чтобы изменить размер резервного пула памяти по умолчанию во время запуска, используйте интерфейс &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config ()&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="7032e0044fe8cbf0ccd0392512f38ee2b17ffc25" translate="yes" xml:space="preserve">
          <source>The size of the matching term in bytes.</source>
          <target state="translated">Размер совпадающего термина в байтах.</target>
        </trans-unit>
        <trans-unit id="481f99d28cac0daa50062e9ad3a05601840366c0" translate="yes" xml:space="preserve">
          <source>The size of the memory-mapped I/O region cannot be changed while the memory-mapped I/O region is in active use, to avoid unmapping memory out from under running SQL statements. For this reason, the mmap_size pragma may be a no-op if the prior mmap_size is non-zero and there are other SQL statements running concurrently on the same &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt;.</source>
          <target state="translated">Размер области ввода-вывода с отображением памяти не может быть изменен, пока область ввода-вывода с отображением памяти находится в активном использовании, чтобы избежать отмены отображения памяти из-за выполнения операторов SQL. По этой причине прагма mmap_size может не работать, если предыдущий mmap_size не равен нулю и есть другие операторы SQL, выполняющиеся одновременно с тем же &lt;a href=&quot;c3ref/sqlite3&quot;&gt;соединением с базой данных&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="19c67c781984d7843a725bf421c45281605af01e" translate="yes" xml:space="preserve">
          <source>The snippet function first attempts to find a fragment of text consisting of</source>
          <target state="translated">Функция сниппета сначала пытается найти фрагмент текста,состоящего из</target>
        </trans-unit>
        <trans-unit id="54b3f9fdd628ef57cd97424e1a01116d0ba15ccd" translate="yes" xml:space="preserve">
          <source>The snippet function is used to create formatted fragments of document text for display as part of a full-text query results report. The snippet function may be passed between one and six arguments, as follows:</source>
          <target state="translated">Функция фрагментации используется для создания форматированных фрагментов текста документа для отображения в рамках полнотекстового отчета о результатах запроса.Функция сниппета может быть передана между одним и шестью аргументами следующим образом:</target>
        </trans-unit>
        <trans-unit id="25ab90403f978d997e2573cced370b12d71d602c" translate="yes" xml:space="preserve">
          <source>The snippet() function is similar to highlight(), except that instead of returning entire column values, it automatically selects and extracts a short fragment of document text to process and return. The snippet() function must be passed five parameters following the table name argument:</source>
          <target state="translated">Функция snippet()аналогична функции highlight(),за исключением того,что вместо возврата значений всей колонки она автоматически выбирает и извлекает короткий фрагмент текста документа для обработки и возврата.Функция snippet()должна передавать пять параметров,следующих за аргументом имени таблицы:</target>
        </trans-unit>
        <trans-unit id="650db23255aac8aa4103c6f6d9992ba8c2854051" translate="yes" xml:space="preserve">
          <source>The soft heap limit is &quot;soft&quot; in this sense: If SQLite is not able to free up enough auxiliary memory to stay below the limit, it goes ahead and allocates the extra memory and exceeds its limit. This occurs under the theory that it is better to use additional memory than to fail outright.</source>
          <target state="translated">Лимит &quot;мягкой кучи&quot; в этом смысле &quot;мягкий&quot;:если SQLite не в состоянии освободить достаточно вспомогательной памяти,чтобы остаться ниже лимита,то он выделяет дополнительную память и превышает ее лимит.Это происходит в соответствии с теорией,что лучше использовать дополнительную память,чем выходить из строя.</target>
        </trans-unit>
        <trans-unit id="f259c7b18142819d8b2454c94e82cad365d3cfbd" translate="yes" xml:space="preserve">
          <source>The soft heap limit is not enforced in the current implementation if one or more of following conditions are true:</source>
          <target state="translated">Мягкое ограничение кучности не применяется в текущей реализации,если одно или несколько из следующих условий являются верными:</target>
        </trans-unit>
        <trans-unit id="62f643dbe59889b37bb6ee27203ce861b75e4df1" translate="yes" xml:space="preserve">
          <source>The soft heap limit is set to zero.</source>
          <target state="translated">Предел мягкой кучи установлен на ноль.</target>
        </trans-unit>
        <trans-unit id="1e9f9417ca080fbcc56641af6510e79f88f545c2" translate="yes" xml:space="preserve">
          <source>The soft heap limit may not be greater than the hard heap limit. If the hard heap limit is enabled and if sqlite3_soft_heap_limit(N) is invoked with a value of N that is greater than the hard heap limit, the the soft heap limit is set to the value of the hard heap limit. The soft heap limit is automatically enabled whenever the hard heap limit is enabled. When sqlite3_hard_heap_limit64(N) is invoked and the soft heap limit is outside the range of 1..N, then the soft heap limit is set to N. Invoking sqlite3_soft_heap_limit64(0) when the hard heap limit is enabled makes the soft heap limit equal to the hard heap limit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84963983acb45095ae249428915953ba1875b5f1" translate="yes" xml:space="preserve">
          <source>The solution was computed in less than 300 milliseconds on a modern workstation.</source>
          <target state="translated">Решение было рассчитано менее чем за 300 миллисекунд на современном рабочем месте.</target>
        </trans-unit>
        <trans-unit id="d8fc439428a4b57b8a635dfdc3bc6c9e9458a598" translate="yes" xml:space="preserve">
          <source>The solver works by adding new entries to the &quot;x&quot; recursive table. Given prior entries, the recursive-select tries to fill in a single new position with all values between 1 and 9 that actually work in that position. The complicated &quot;NOT EXISTS&quot; subquery is the magic that figures out whether or not each candidate &quot;s&quot; string is a valid sudoku puzzle or not.</source>
          <target state="translated">Решение работает путем добавления новых записей в рекурсивной таблице &quot;x&quot;.Учитывая предыдущие записи,рекурсивный выбор пытается заполнить одну новую позицию со всеми значениями от 1 до 9,которые на самом деле работают в этой позиции.Сложный подзапрос &quot;NOT EXISTS&quot;-это волшебство,которое определяет,является ли каждая строка кандидата &quot;s&quot; действительной головоломкой судоку или нет.</target>
        </trans-unit>
        <trans-unit id="a81e5007b5735cbaaaf41fe92b085a6bb28859ca" translate="yes" xml:space="preserve">
          <source>The sorter can use auxiliary helper threads to increase real-time response. This feature is off by default and may be enabled using the &lt;a href=&quot;pragma#pragma_threads&quot;&gt;PRAGMA threads&lt;/a&gt; command or the &lt;a href=&quot;compile#default_worker_threads&quot;&gt;SQLITE_DEFAULT_WORKER_THREADS&lt;/a&gt; compile-time option.</source>
          <target state="translated">Сортировщик может использовать вспомогательные вспомогательные потоки для увеличения отклика в реальном времени. Эта функция по умолчанию отключена и может быть включена с помощью команды &lt;a href=&quot;pragma#pragma_threads&quot;&gt;PRAGMA threads&lt;/a&gt; или параметра &lt;a href=&quot;compile#default_worker_threads&quot;&gt;времени&lt;/a&gt; компиляции SQLITE_DEFAULT_WORKER_THREADS .</target>
        </trans-unit>
        <trans-unit id="f3082f533e58c712999cbf940673f567d8a29017" translate="yes" xml:space="preserve">
          <source>The soundex(X) function returns a string that is the soundex encoding of the string X. The string &quot;?000&quot; is returned if the argument is NULL or contains no ASCII alphabetic characters. This function is omitted from SQLite by default. It is only available if the &lt;a href=&quot;compile#soundex&quot;&gt;SQLITE_SOUNDEX&lt;/a&gt; compile-time option is used when SQLite is built.</source>
          <target state="translated">Функция soundex (X) возвращает строку, которая является кодировкой soundex строки X. Строка &amp;laquo;? 000&amp;raquo; возвращается, если аргумент равен NULL или не содержит буквенных символов ASCII. По умолчанию эта функция отсутствует в SQLite. Он доступен, только если используется &lt;a href=&quot;compile#soundex&quot;&gt;параметр времени&lt;/a&gt; компиляции SQLITE_SOUNDEX при сборке SQLite.</target>
        </trans-unit>
        <trans-unit id="9611e60fec986c004f40bb3986af444fd02497aa" translate="yes" xml:space="preserve">
          <source>The source &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; may be used by the application for other purposes while a backup operation is underway or being initialized. If SQLite is compiled and configured to support threadsafe database connections, then the source database connection may be used concurrently from within other threads.</source>
          <target state="translated">Соединение с исходной &lt;a href=&quot;#sqlite3&quot;&gt;базой данных&lt;/a&gt; может использоваться приложением для других целей, пока выполняется или инициализируется операция резервного копирования. Если SQLite скомпилирован и настроен для поддержки поточно-безопасных соединений с базой данных, то соединение с исходной базой данных может использоваться одновременно из других потоков.</target>
        </trans-unit>
        <trans-unit id="d46770cf519d64fb4869e93bb4ebad2a0d214ebb" translate="yes" xml:space="preserve">
          <source>The source &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; may be used by the application for other purposes while a backup operation is underway or being initialized. If SQLite is compiled and configured to support threadsafe database connections, then the source database connection may be used concurrently from within other threads.</source>
          <target state="translated">Соединение с исходной &lt;a href=&quot;sqlite3&quot;&gt;базой данных&lt;/a&gt; может использоваться приложением для других целей, пока выполняется или инициализируется операция резервного копирования. Если SQLite скомпилирован и настроен для поддержки поточно-безопасных соединений с базой данных, то соединение с исходной базой данных может использоваться одновременно из других потоков.</target>
        </trans-unit>
        <trans-unit id="cb98bce78cf336a453aacfd68f1f2a70ccf1bb9e" translate="yes" xml:space="preserve">
          <source>The source code files for other SQL database engines typically begin with a comment describing your legal rights to view and copy that file. The SQLite source code contains no license since it is not governed by copyright. Instead of a license, the SQLite source code offers a blessing:</source>
          <target state="translated">Файлы исходного кода для других движков баз данных SQL обычно начинаются с комментария,описывающего ваши законные права на просмотр и копирование этого файла.Исходный код SQLite не содержит лицензии,так как он не регулируется авторским правом.Вместо лицензии исходный код SQLite предлагает благословение:</target>
        </trans-unit>
        <trans-unit id="b230daf41ab11e7921fa2a959263c09c6fe7e609" translate="yes" xml:space="preserve">
          <source>The source code for Geopoly is included in the &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt; but is not included in the library unless the &lt;a href=&quot;compile#enable_geopoly&quot;&gt;-DSQLITE_ENABLE_GEOPOLY&lt;/a&gt; compile-time option is used.</source>
          <target state="translated">Исходный код для Geopoly включен в &lt;a href=&quot;amalgamation&quot;&gt;объединение,&lt;/a&gt; но не включен в библиотеку, если не используется параметр &lt;a href=&quot;compile#enable_geopoly&quot;&gt;-DSQLITE_ENABLE_GEOPOLY&lt;/a&gt; во время компиляции.</target>
        </trans-unit>
        <trans-unit id="9ce563d47e369284dcc9eb90d209f5fe50c9d87d" translate="yes" xml:space="preserve">
          <source>The source code for SQLite is in the public domain. No claim of copyright is made on any part of the core source code. (The documentation and test code is a different matter - some sections of documentation and test logic are governed by open-source licenses.) All contributors to the SQLite core software have signed affidavits specifically disavowing any copyright interest in the code. This means that anybody is able to legally do anything they want with the SQLite source code.</source>
          <target state="translated">Исходный код SQLite находится в открытом доступе.Никакие авторские права не распространяются на любую часть основного исходного кода.(Документация и тестовый код-это другой вопрос-некоторые разделы документации и тестовая логика регулируются лицензиями с открытым исходным кодом).Все разработчики основного программного обеспечения SQLite подписали аффидевиты,в которых конкретно отказываются от любых авторских прав на код.Это означает,что любой человек может на законных основаниях делать с исходным кодом SQLite все,что угодно.</target>
        </trans-unit>
        <trans-unit id="1cfec4458134c689073b56a3f124a05cfee319a4" translate="yes" xml:space="preserve">
          <source>The source code in public SQLite releases uses unix line endings (ASCII code 10: &quot;newline&quot; only, NL) and spaces instead of tabs. If you will be changing the line ending to windows-style line endings (ASCII codes 13, 10: &quot;carriage-return&quot; and &quot;newline&quot;; CR-NL) or if you will be changing space indents into tab indents, &lt;b&gt;make that change now&lt;/b&gt; before you check in the baseline. The merging process will only work well if the differences between the public and the private branches are minimal. If every single line of the source file is changed in the private branch because you changed from NL to CR-NL line endings, then the merge steps will not work correctly.</source>
          <target state="translated">В исходном коде общедоступных выпусков SQLite используются окончания строк unix (код ASCII 10: только &amp;laquo;новая строка&amp;raquo;, NL) и пробелы вместо табуляции. Если вы измените окончание строки на окончание строки в стиле Windows (коды ASCII 13, 10: &amp;laquo;возврат каретки&amp;raquo; и &amp;laquo;новая строка&amp;raquo;; CR-NL) или если вы собираетесь заменять отступы пробелов на отступы табуляции, &lt;b&gt;внесите это изменение теперь,&lt;/b&gt; прежде чем вы проверяете базовый уровень. Процесс слияния будет успешным только в том случае, если различия между государственной и частной ветвями минимальны. Если каждая отдельная строка исходного файла изменена в частной ветви, потому что вы изменили окончание строки с NL на CR-NL, то шаги слияния не будут работать правильно.</target>
        </trans-unit>
        <trans-unit id="c71fe30151d8d1ffe822e83fe610e421f8822069" translate="yes" xml:space="preserve">
          <source>The source code module that implements the spellfix1 virtual table also implements several SQL functions that might be useful to applications that employ spellfix1 or for testing or diagnostic work while developing applications that use spellfix1. The following auxiliary functions are available:</source>
          <target state="translated">Модуль исходного кода,реализующий виртуальную таблицу spellfix1,также реализует несколько SQL-функций,которые могут быть полезны приложениям,использующим spellfix1,а также для тестирования или диагностики при разработке приложений,использующих spellfix1.Доступны следующие вспомогательные функции:</target>
        </trans-unit>
        <trans-unit id="06e0d7a5506cbf178b35ec85914ad01a3f38017c" translate="yes" xml:space="preserve">
          <source>The source code to SQLite is designed to be readable and accessible to the average programmer. All procedures and data structures and many automatic variables are carefully commented with useful information about what they do. Boilerplate commenting is omitted.</source>
          <target state="translated">Исходный код SQLite разработан таким образом,чтобы быть удобочитаемым и доступным среднестатистическому программисту.Все процедуры и структуры данных,а также многие автоматические переменные тщательно прокомментированы с полезной информацией о том,что они делают.Комментарий к Boilerplate опущен.</target>
        </trans-unit>
        <trans-unit id="042c70a1cba19758906aae3ec84cad7dc8c53383" translate="yes" xml:space="preserve">
          <source>The source code to the SQLite R*Tree module is included as part of the &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt; but is disabled by default. To enable the R*Tree module, simply compile with the &lt;a href=&quot;compile#enable_rtree&quot;&gt;SQLITE_ENABLE_RTREE&lt;/a&gt; C-preprocessor macro defined. With many compilers, this is accomplished by adding the option &quot;-DSQLITE_ENABLE_RTREE=1&quot; to the compiler command-line.</source>
          <target state="translated">Исходный код модуля SQLite R * Tree включен как часть &lt;a href=&quot;amalgamation&quot;&gt;объединения,&lt;/a&gt; но по умолчанию отключен. Чтобы включить модуль R * Tree, просто скомпилируйте с определенным &lt;a href=&quot;compile#enable_rtree&quot;&gt;макросом SQLITE_ENABLE_RTREE&lt;/a&gt; C-препроцессора. Во многих компиляторах это достигается путем добавления опции &quot;-DSQLITE_ENABLE_RTREE = 1&quot; в командную строку компилятора.</target>
        </trans-unit>
        <trans-unit id="a40cbeb8ac52569bca99e948856ab4db846ed02b" translate="yes" xml:space="preserve">
          <source>The source code to the bytecode engine is in the &lt;a href=&quot;http://www.sqlite.org/src/file/src/vdbe.c&quot;&gt;vdbe.c&lt;/a&gt; source file. The &lt;a href=&quot;opcode#codes&quot;&gt;opcode definitions&lt;/a&gt; in this document are derived from comments in that source file. The source code comments are the canonical source of information about the bytecode engine. When in doubt, refer to the source code.</source>
          <target state="translated">Исходный код механизма байт-кода находится в исходном файле &lt;a href=&quot;http://www.sqlite.org/src/file/src/vdbe.c&quot;&gt;vdbe.c. &lt;/a&gt;Определения &lt;a href=&quot;opcode#codes&quot;&gt;кодов операций&lt;/a&gt; в этом документе основаны на комментариях в этом исходном файле. Комментарии к исходному коду являются каноническим источником информации о механизме байт-кода. В случае сомнений обратитесь к исходному коду.</target>
        </trans-unit>
        <trans-unit id="013177e363c21284dd8426d7c41bb413bf325a0a" translate="yes" xml:space="preserve">
          <source>The source code to the software that runs the checklists is stored in its own Fossil repository at &lt;a href=&quot;https://www.sqlite.org/checklistapp&quot;&gt;https://www.sqlite.org/checklistapp&lt;/a&gt;.</source>
          <target state="translated">Исходный код программного обеспечения, запускающего контрольные списки, хранится в собственном репозитории Fossil по адресу &lt;a href=&quot;https://www.sqlite.org/checklistapp&quot;&gt;https://www.sqlite.org/checklistapp&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="79b8e8d26e2fd4c36bb8b15bd366cedd02031771" translate="yes" xml:space="preserve">
          <source>The source code to the sqlite3 command line interface is in a single file named &quot;shell.c&quot;. The shell.c source file is generated from other sources, but most of the code for shell.c can be found in &lt;a href=&quot;https://sqlite.org/src/file/src/shell.c.in&quot;&gt;src/shell.c.in&lt;/a&gt;. (Regenerate shell.c by typing &quot;make shell.c&quot; from the canonical source tree.) &lt;a href=&quot;howtocompile&quot;&gt;Compile&lt;/a&gt; the shell.c file (together with the &lt;a href=&quot;amalgamation&quot;&gt;sqlite3 library source code&lt;/a&gt;) to generate the executable. For example:</source>
          <target state="translated">Исходный код интерфейса командной строки sqlite3 находится в одном файле с именем &amp;laquo;shell.c&amp;raquo;. Исходный файл shell.c создается из других источников, но большую часть кода для shell.c можно найти в &lt;a href=&quot;https://sqlite.org/src/file/src/shell.c.in&quot;&gt;src / shell.c.in&lt;/a&gt; . (Восстановите shell.c, набрав &amp;laquo;make shell.c&amp;raquo; из канонического исходного дерева.) &lt;a href=&quot;howtocompile&quot;&gt;Скомпилируйте&lt;/a&gt; файл shell.c (вместе с &lt;a href=&quot;amalgamation&quot;&gt;исходным кодом библиотеки&lt;/a&gt; sqlite3 ), чтобы сгенерировать исполняемый файл. Например:</target>
        </trans-unit>
        <trans-unit id="3baebed042eebfba10dcbc501e7f4785bd1f6d07" translate="yes" xml:space="preserve">
          <source>The source file and entry point are named for &quot;unionvtab&quot; instead of &quot;swarmvtab&quot;. Unionvtab is a &lt;a href=&quot;unionvtab&quot;&gt;separately documented&lt;/a&gt; virtual table that is bundled with swarmvtab.</source>
          <target state="translated">Исходный файл и точка входа названы по имени unionvtab вместо swarmvtab. Unionvtab - это &lt;a href=&quot;unionvtab&quot;&gt;отдельно документированная&lt;/a&gt; виртуальная таблица, которая входит в комплект swarmvtab.</target>
        </trans-unit>
        <trans-unit id="f3fba365763538ecbddb6c57bd7009fd058f9084" translate="yes" xml:space="preserve">
          <source>The special &quot;:memory:&quot; filename also works when using &lt;a href=&quot;uri&quot;&gt;URI filenames&lt;/a&gt;. For example:</source>
          <target state="translated">Специальное имя файла &quot;: memory:&quot; также работает при использовании &lt;a href=&quot;uri&quot;&gt;имен файлов URI&lt;/a&gt; . Например:</target>
        </trans-unit>
        <trans-unit id="e94ff833d41c9d30c15767ac9e7aeb85daf442aa" translate="yes" xml:space="preserve">
          <source>The special UPSERT processing happens only for uniqueness constraint on the table that is receiving the INSERT. A &quot;uniqueness constraint&quot; is an explicit UNIQUE or PRIMARY KEY constraint within the CREATE TABLE statement, or a &lt;a href=&quot;lang_createindex#uniqueidx&quot;&gt;unique index&lt;/a&gt;. UPSERT does not intervene for failed NOT NULL or foreign key constraints or for constraints that are implemented using triggers.</source>
          <target state="translated">Специальная обработка UPSERT происходит только для ограничения уникальности таблицы, которая получает INSERT. &amp;laquo;Ограничение уникальности&amp;raquo; - это явное ограничение UNIQUE или PRIMARY KEY в операторе CREATE TABLE или &lt;a href=&quot;lang_createindex#uniqueidx&quot;&gt;уникальный индекс&lt;/a&gt; . UPSERT не вмешивается в случае неудачных ограничений NOT NULL или внешнего ключа или ограничений, которые реализованы с помощью триггеров.</target>
        </trans-unit>
        <trans-unit id="2e94e3f68bdf7fc07fc0dcd878c089797a3fe9a2" translate="yes" xml:space="preserve">
          <source>The special filename &quot;:memory:&quot; can be used anywhere that a database filename is permitted. For example, it can be used as the</source>
          <target state="translated">Специальное имя файла &quot;:memory:&quot; может быть использовано везде,где разрешено использование имени файла базы данных.Например,оно может быть использовано как</target>
        </trans-unit>
        <trans-unit id="dff68709141a31a267598fa549dc38cfbd61c946" translate="yes" xml:space="preserve">
          <source>The special processing for opening ZIP archives is a trick of the command-line shell, not the core SQLite library. So if you want to open a ZIP archive as a database in your application, you will need to activate the &lt;a href=&quot;zipfile&quot;&gt;Zipfile virtual table&lt;/a&gt; module then run an appropriate &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; statement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29bca994e11cb6f841a93aac5cdb8471376e38df" translate="yes" xml:space="preserve">
          <source>The specified column of row iRow contains a value that is not a TEXT or BLOB value,</source>
          <target state="translated">Указанный столбец строки iRow содержит значение,которое не является значением TEXT или BLOB,</target>
        </trans-unit>
        <trans-unit id="06e48e6df6f51c35512fa45acc8a0e8a634c95f8" translate="yes" xml:space="preserve">
          <source>The speedtest1.c program is updated from time to time as the SQLite developers' understanding of what constitutes &quot;typical&quot; usage evolves.</source>
          <target state="translated">Программа speedtest1.c время от времени обновляется по мере развития понимания разработчиками SQLite,что такое &quot;типичное&quot; использование.</target>
        </trans-unit>
        <trans-unit id="5446f248e6916745d646dc3f5e88e893b3ad00cc" translate="yes" xml:space="preserve">
          <source>The speedtest1.c workload that is being measured tries to be representative of a wide range of typical uses of SQLite. But every application is different. The speedtest1.c workload might not be a good proxy for the kinds of activities performed by some applications. The SQLite developers are constantly working to improve the speedtest1.c program, to make it a better proxy for actual SQLite usage. Community feedback is welcomed.</source>
          <target state="translated">Измеряемая рабочая нагрузка speedtest1.c пытается быть репрезентативной для широкого диапазона типичного использования SQLite.Но каждое приложение отличается от других.Рабочая нагрузка speedtest1.c может не быть хорошим прокси-сервером для видов деятельности,выполняемых некоторыми приложениями.Разработчики SQLite постоянно работают над улучшением программы speedtest1.c,чтобы сделать ее лучшим прокси для фактического использования SQLite.Обратная связь с сообществом приветствуется.</target>
        </trans-unit>
        <trans-unit id="92167de554e681259504f6e2f3edf942b7026bd6" translate="yes" xml:space="preserve">
          <source>The spellfix1 virtual table creates a single shadow table named &quot;%_vocab&quot; (where the % is replaced by the name of the virtual table; Ex: &quot;demo_vocab&quot; for the &quot;demo&quot; virtual table). the shadow table contains the following columns:</source>
          <target state="translated">Виртуальная таблица spellfix1 создает единственную теневую таблицу с именем &quot;%_vocab&quot; (где % заменяется именем виртуальной таблицы;Ex:&quot;demo_vocab&quot; для виртуальной таблицы &quot;demo&quot;).теневая таблица содержит следующие столбцы:</target>
        </trans-unit>
        <trans-unit id="f9097157fe13f14b48b89617ee87aed62da83c73" translate="yes" xml:space="preserve">
          <source>The spellfix1 virtual table uses editdist3 if the &quot;edit_cost_table=TABLE&quot; option is specified as an argument when the spellfix1 virtual table is created. But editdist3 can also be tested directly using the built-in &quot;editdist3()&quot; SQL function. The editdist3() SQL function has 3 forms:</source>
          <target state="translated">Виртуальная таблица spellfix1 использует editdist3,если в качестве аргумента при создании виртуальной таблицы spellfix1 указана опция &quot;edit_cost_table=TABLE&quot;.Но editdist3 также может быть протестирован непосредственно с помощью встроенной SQL-функции &quot;editdist3()&quot;.SQL-функция editdist3()имеет 3 формы:</target>
        </trans-unit>
        <trans-unit id="e416e23f51996e4d87d84d45407db4bd482280e4" translate="yes" xml:space="preserve">
          <source>The sqlar_compress(X) function attempts to compress a copy of the string or blob X using the &lt;a href=&quot;https://zlib.net/&quot;&gt;Default&lt;/a&gt; algorithm and returns the result as a blob. If the input X is incompressible, then a copy of X is returned. This routine is used when inserting content into an SQLite Archive.</source>
          <target state="translated">Функция sqlar_compress (X) пытается сжать копию строки или большого двоичного объекта X, используя алгоритм по &lt;a href=&quot;https://zlib.net/&quot;&gt;умолчанию&lt;/a&gt; , и возвращает результат в виде большого двоичного объекта . Если вход X несжимаемый, то возвращается копия X. Эта процедура используется при вставке содержимого в архив SQLite.</target>
        </trans-unit>
        <trans-unit id="0c132e268d7082089985d58b1716bee78c9b6c72" translate="yes" xml:space="preserve">
          <source>The sqlar_uncompress(Y,SZ) function will undo the compression accomplished by sqlar_compress(X). The Y parameter is the compressed content (the output from a prior call to sqlar_compress()) and SZ is the original uncompressed size of the input X that generated Y. If SZ is less than or equal to the size of Y, that indicates that no compression occurred, and so sqlar_uncompress(Y,SZ) returns a copy of Y. Otherwise, sqlar_uncompress(Y,SZ) runs the Inflate algorithm on Y to uncompress it and restore it to its original form and returns the uncompressed content. This routine is used when extracting content from an SQLite Archive.</source>
          <target state="translated">Функция sqlar_uncompress(Y,SZ)отменит компрессию,выполненную sqlar_compress(X).Параметр Y-это сжатое содержимое (вывод из предыдущего вызова sqlar_compress()),а SZ-исходный несжатый размер входа X,который генерировал Y.Если SZ меньше или равна размеру Y,это означает,что сжатия не произошло,и поэтому sqlar_uncompress(Y,SZ)возвращает копию Y.В противном случае,sqlar_uncompress(Y,SZ)запускает алгоритм Inflate по Y,чтобы распаковать его и восстановить в исходном виде,а затем возвращает несжатое содержимое.Эта рутина используется при извлечении содержимого из архива SQLite.</target>
        </trans-unit>
        <trans-unit id="9894bd2027e1ec7fe1defc073eb794af8cfcddba" translate="yes" xml:space="preserve">
          <source>The sqldiff.exe utility does not (currently) display differences in &lt;a href=&quot;lang_createtrigger&quot;&gt;TRIGGERs&lt;/a&gt; or &lt;a href=&quot;lang_createview&quot;&gt;VIEWs&lt;/a&gt;.</source>
          <target state="translated">Утилита sqldiff.exe (в настоящее время) не отображает различия в &lt;a href=&quot;lang_createtrigger&quot;&gt;TRIGGER&lt;/a&gt; или &lt;a href=&quot;lang_createview&quot;&gt;VIEW&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1eec35831f2ddb18882fbe495fb78b6e88f27f70" translate="yes" xml:space="preserve">
          <source>The sqldiff.exe utility is unable to compute differences for rowid tables for which the rowid is inaccessible. An example of a table with an inaccessible rowid is:</source>
          <target state="translated">Утилита sqldiff.exe не может вычислить различия для таблиц rowid,для которых rowid недоступен.Пример таблицы с недоступным rowid:</target>
        </trans-unit>
        <trans-unit id="199f0fae6d132ab01eeef495a83df7f5456338b1" translate="yes" xml:space="preserve">
          <source>The sqldiff.exe utility works by finding rows in the source and destination that are logical &quot;pairs&quot;. The default behavior is to treat two rows as pairs if they are in tables with the same name and they have the same &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;, or in the case of a &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; table if they have the same &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt;. Any differences in the content of paired rows are output as UPDATEs. Rows in the source database that could not be paired are output as DELETEs. Rows in the destination database that could not be paired are output as INSERTs.</source>
          <target state="translated">Утилита sqldiff.exe работает, находя строки в источнике и месте назначения, которые являются логическими &amp;laquo;парами&amp;raquo;. По умолчанию две строки рассматриваются как пары, если они находятся в таблицах с одинаковыми именами и имеют одинаковый &lt;a href=&quot;lang_createtable#rowid&quot;&gt;идентификатор строки&lt;/a&gt; , или в случае таблицы &lt;a href=&quot;withoutrowid&quot;&gt;БЕЗ ROWID,&lt;/a&gt; если у них одинаковый &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;ПЕРВИЧНЫЙ КЛЮЧ&lt;/a&gt; . Любые различия в содержимом парных строк выводятся как ОБНОВЛЕНИЯ. Строки в исходной базе данных, которые не удалось объединить в пары, выводятся как DELETE. Строки в целевой базе данных, которые не могут быть объединены в пары, выводятся как INSERT.</target>
        </trans-unit>
        <trans-unit id="5a94a70315a765a01576195e900e88922987242a" translate="yes" xml:space="preserve">
          <source>The sqlite3 program is able to show the results of a query in 14 different formats:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a33930cce71afaf2bac4391a7d92f2102fe6799" translate="yes" xml:space="preserve">
          <source>The sqlite3 program is able to show the results of a query in eight different formats: &quot;csv&quot;, &quot;column&quot;, &quot;html&quot;, &quot;insert&quot;, &quot;line&quot;, &quot;list&quot;, &quot;quote&quot;, &quot;tabs&quot;, and &quot;tcl&quot;. You can use the &quot;.mode&quot; dot command to switch between these output formats.</source>
          <target state="translated">Программа sqlite3 способна показывать результаты запроса в восьми различных форматах:&quot;csv&quot;,&quot;столбец&quot;,&quot;html&quot;,&quot;вставить&quot;,&quot;строка&quot;,&quot;список&quot;,&quot;кавычки&quot;,&quot;вкладки&quot; и &quot;tcl&quot;.Вы можете использовать точечную команду &quot;.mode&quot; для переключения между этими форматами вывода.</target>
        </trans-unit>
        <trans-unit id="c934dde95758c5fad9d43c84ef7f4c41bf3fe114" translate="yes" xml:space="preserve">
          <source>The sqlite3 program provides several convenience commands that are useful for looking at the schema of the database. There is nothing that these commands do that cannot be done by some other means. These commands are provided purely as a shortcut.</source>
          <target state="translated">Программа sqlite3 предоставляет несколько удобных команд,которые полезны для просмотра схемы БД.В этих командах нет ничего такого,что нельзя было бы сделать какими-либо другими способами.Эти команды предоставляются исключительно в виде ярлыка.</target>
        </trans-unit>
        <trans-unit id="d730ebfc68ed44661fe9aaa4784f842bff23a6ec" translate="yes" xml:space="preserve">
          <source>The sqlite3_aggregate_context(C,N) routine returns a NULL pointer when first called if N is less than or equal to zero or if a memory allocate error occurs.</source>
          <target state="translated">Рутина sqlite3_aggregate_context(C,N)возвращает указатель NULL при первом вызове,если N меньше или равно нулю,или если произошла ошибка выделения памяти.</target>
        </trans-unit>
        <trans-unit id="a781b80076608933fb39f35323ee417edf53e9fb" translate="yes" xml:space="preserve">
          <source>The sqlite3_analyzer utility program is updated to provide better descriptions and to compute a more accurate estimate for &quot;Non-sequential pages&quot;</source>
          <target state="translated">Утилита-анализатор sqlite3_Analyzer обновлена для получения более точных описаний и вычисления более точной оценки для &quot;Непоследовательных страниц&quot;.</target>
        </trans-unit>
        <trans-unit id="cea6cec9b3cecf3cdb8b21b8c439ffacaf7e4757" translate="yes" xml:space="preserve">
          <source>The sqlite3_analyzer.exe Utility Program</source>
          <target state="translated">Коммунальная программа sqlite3_nalyzer.exe</target>
        </trans-unit>
        <trans-unit id="08064e181ad262ed7b2155684ee88c71ec311b40" translate="yes" xml:space="preserve">
          <source>The sqlite3_analyzer.exe utility is updated to report the depth of each btree and to show the average fanout for indexes and WITHOUT ROWID tables.</source>
          <target state="translated">Обновлена утилита sqlite3_nalyzer.exe,которая сообщает глубину каждого дерева и показывает средний размах для индексов и таблиц БЕЗ ROWID.</target>
        </trans-unit>
        <trans-unit id="69ea749b99043a4585c42b36d581974b4510bba7" translate="yes" xml:space="preserve">
          <source>The sqlite3_backup object records state information about an ongoing online backup operation. The sqlite3_backup object is created by a call to &lt;a href=&quot;#sqlite3backupinit&quot;&gt;sqlite3_backup_init()&lt;/a&gt; and is destroyed by a call to &lt;a href=&quot;#sqlite3backupfinish&quot;&gt;sqlite3_backup_finish()&lt;/a&gt;.</source>
          <target state="translated">Объект sqlite3_backup записывает информацию о состоянии текущей операции резервного копирования в оперативном режиме. Объект sqlite3_backup создается вызовом &lt;a href=&quot;#sqlite3backupinit&quot;&gt;sqlite3_backup_init ()&lt;/a&gt; и уничтожается вызовом &lt;a href=&quot;#sqlite3backupfinish&quot;&gt;sqlite3_backup_finish ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ff5c92c4105199925092609d2d9f802d1fa55672" translate="yes" xml:space="preserve">
          <source>The sqlite3_backup object records state information about an ongoing online backup operation. The sqlite3_backup object is created by a call to &lt;a href=&quot;backup_finish#sqlite3backupinit&quot;&gt;sqlite3_backup_init()&lt;/a&gt; and is destroyed by a call to &lt;a href=&quot;backup_finish#sqlite3backupfinish&quot;&gt;sqlite3_backup_finish()&lt;/a&gt;.</source>
          <target state="translated">Объект sqlite3_backup записывает информацию о состоянии текущей операции резервного копирования в оперативном режиме. Объект sqlite3_backup создается вызовом &lt;a href=&quot;backup_finish#sqlite3backupinit&quot;&gt;sqlite3_backup_init ()&lt;/a&gt; и уничтожается вызовом &lt;a href=&quot;backup_finish#sqlite3backupfinish&quot;&gt;sqlite3_backup_finish ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="db586a6cde9f4397b1aba32074e60460ba79310a" translate="yes" xml:space="preserve">
          <source>The sqlite3_backup_remaining() and sqlite3_backup_pagecount() APIs report values stored by the previous call to sqlite3_backup_step(), they do not actually inspect the source database file. This means that if the source database is written to by another thread or process after the call to sqlite3_backup_step() returns but before the values returned by sqlite3_backup_remaining() and sqlite3_backup_pagecount() are used, the values may be technically incorrect. This is not usually a problem.</source>
          <target state="translated">API sqlite3_backup_remaining()и sqlite3_backup_pagecount()сообщают в sqlite3_backup_step()значения,сохраненные при предыдущем вызове,фактически не проверяют файл исходной базы данных.Это означает,что если исходная база данных записывается другим потоком или процессом после вызова sqlite3_backup_step(),но до использования значений,возвращенных функциями sqlite3_backup_remaining()и sqlite3_backup_pagecount(),эти значения могут быть технически некорректными.Обычно это не является проблемой.</target>
        </trans-unit>
        <trans-unit id="ab13e83a5eec05a800456f808bd2ed14f96ad7d8" translate="yes" xml:space="preserve">
          <source>The sqlite3_backup_remaining() routine returns the number of pages still to be backed up at the conclusion of the most recent sqlite3_backup_step(). The sqlite3_backup_pagecount() routine returns the total number of pages in the source database at the conclusion of the most recent sqlite3_backup_step(). The values returned by these functions are only updated by sqlite3_backup_step(). If the source database is modified in a way that changes the size of the source database or the number of pages remaining, those changes are not reflected in the output of sqlite3_backup_pagecount() and sqlite3_backup_remaining() until after the next sqlite3_backup_step().</source>
          <target state="translated">Рутина sqlite3_backup_remaining()возвращает количество страниц,которые еще нужно зарезервировать по завершению последней функции sqlite3_backup_step().Рутина sqlite3_backup_pagecount()возвращает общее количество страниц в исходной базе данных по завершению последней функции sqlite3_backup_step().Значения,возвращаемые этими функциями,обновляются только функцией sqlite3_backup_step().Если исходная база данных изменяется таким образом,что изменяется размер исходной базы данных или количество оставшихся страниц,то эти изменения не отражаются в выводе sqlite3_backup_pagecount()и sqlite3_backup_remaining()до следующего sqlite3_backup_step().</target>
        </trans-unit>
        <trans-unit id="027c7809f8a158ea3a080d548eaba037441f7cc5" translate="yes" xml:space="preserve">
          <source>The sqlite3_backup_step() might return &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_READONLY&lt;/a&gt; if</source>
          <target state="translated">Sqlite3_backup_step () может вернуть &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_READONLY,&lt;/a&gt; если</target>
        </trans-unit>
        <trans-unit id="44bfd22dba6c2a0335c1b72cfe8865a0ed15325c" translate="yes" xml:space="preserve">
          <source>The sqlite3_backup_step() might return &lt;a href=&quot;../rescode#readonly&quot;&gt;SQLITE_READONLY&lt;/a&gt; if</source>
          <target state="translated">Sqlite3_backup_step () может вернуть &lt;a href=&quot;../rescode#readonly&quot;&gt;SQLITE_READONLY,&lt;/a&gt; если</target>
        </trans-unit>
        <trans-unit id="a2f8db9336dd78e8265a2d46cc59a9e446011dc7" translate="yes" xml:space="preserve">
          <source>The sqlite3_bind_* routines return &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; on success or an &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; if anything goes wrong. &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_TOOBIG&lt;/a&gt; might be returned if the size of a string or BLOB exceeds limits imposed by &lt;a href=&quot;#sqlite3_limit&quot;&gt;sqlite3_limit&lt;/a&gt;(&lt;a href=&quot;#sqlitelimitlength&quot;&gt;SQLITE_LIMIT_LENGTH&lt;/a&gt;) or &lt;a href=&quot;limits#max_length&quot;&gt;SQLITE_MAX_LENGTH&lt;/a&gt;. &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_RANGE&lt;/a&gt; is returned if the parameter index is out of range. &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOMEM&lt;/a&gt; is returned if malloc() fails.</source>
          <target state="translated">Подпрограммы sqlite3_bind_ * возвращают &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; в случае успеха или &lt;a href=&quot;rescode&quot;&gt;код ошибки,&lt;/a&gt; если что-то пойдет не так. &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_TOOBIG&lt;/a&gt; может быть возвращен, если размер строки или BLOB превышает ограничения, налагаемые &lt;a href=&quot;#sqlite3_limit&quot;&gt;sqlite3_limit&lt;/a&gt; ( &lt;a href=&quot;#sqlitelimitlength&quot;&gt;SQLITE_LIMIT_LENGTH&lt;/a&gt; ) или &lt;a href=&quot;limits#max_length&quot;&gt;SQLITE_MAX_LENGTH&lt;/a&gt; . &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_RANGE&lt;/a&gt; возвращается, если индекс параметра выходит за пределы допустимого диапазона. &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOMEM&lt;/a&gt; возвращается, если malloc () не работает.</target>
        </trans-unit>
        <trans-unit id="eb0da7fe06be85118ba3dab99ff46185b6777bbe" translate="yes" xml:space="preserve">
          <source>The sqlite3_bind_* routines return &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; on success or an &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; if anything goes wrong. &lt;a href=&quot;../rescode#toobig&quot;&gt;SQLITE_TOOBIG&lt;/a&gt; might be returned if the size of a string or BLOB exceeds limits imposed by &lt;a href=&quot;limit&quot;&gt;sqlite3_limit&lt;/a&gt;(&lt;a href=&quot;c_limit_attached#sqlitelimitlength&quot;&gt;SQLITE_LIMIT_LENGTH&lt;/a&gt;) or &lt;a href=&quot;../limits#max_length&quot;&gt;SQLITE_MAX_LENGTH&lt;/a&gt;. &lt;a href=&quot;../rescode#range&quot;&gt;SQLITE_RANGE&lt;/a&gt; is returned if the parameter index is out of range. &lt;a href=&quot;../rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt; is returned if malloc() fails.</source>
          <target state="translated">Подпрограммы sqlite3_bind_ * возвращают &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; в случае успеха или &lt;a href=&quot;../rescode&quot;&gt;код ошибки,&lt;/a&gt; если что-то пойдет не так. &lt;a href=&quot;../rescode#toobig&quot;&gt;SQLITE_TOOBIG&lt;/a&gt; может быть возвращен, если размер строки или BLOB превышает ограничения, налагаемые &lt;a href=&quot;limit&quot;&gt;sqlite3_limit&lt;/a&gt; ( &lt;a href=&quot;c_limit_attached#sqlitelimitlength&quot;&gt;SQLITE_LIMIT_LENGTH&lt;/a&gt; ) или &lt;a href=&quot;../limits#max_length&quot;&gt;SQLITE_MAX_LENGTH&lt;/a&gt; . &lt;a href=&quot;../rescode#range&quot;&gt;SQLITE_RANGE&lt;/a&gt; возвращается, если индекс параметра выходит за пределы допустимого диапазона. &lt;a href=&quot;../rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt; возвращается, если malloc () не работает.</target>
        </trans-unit>
        <trans-unit id="6f71713542739e9593b1adb467245384ef671786" translate="yes" xml:space="preserve">
          <source>The sqlite3_bind_parameter_name(P,N) interface returns the name of the N-th &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;SQL parameter&lt;/a&gt; in the &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; P. SQL parameters of the form &quot;?NNN&quot; or &quot;:AAA&quot; or &quot;@AAA&quot; or &quot;$AAA&quot; have a name which is the string &quot;?NNN&quot; or &quot;:AAA&quot; or &quot;@AAA&quot; or &quot;$AAA&quot; respectively. In other words, the initial &quot;:&quot; or &quot;$&quot; or &quot;@&quot; or &quot;?&quot; is included as part of the name. Parameters of the form &quot;?&quot; without a following integer have no name and are referred to as &quot;nameless&quot; or &quot;anonymous parameters&quot;.</source>
          <target state="translated">Интерфейс sqlite3_bind_parameter_name (P, N) возвращает имя N-го &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;параметра SQL&lt;/a&gt; в &lt;a href=&quot;#sqlite3_stmt&quot;&gt;подготовленном операторе&lt;/a&gt; P. Параметры SQL в форме &amp;laquo;? NNN&amp;raquo; или &amp;laquo;: AAA&amp;raquo; или &amp;laquo;@AAA&amp;raquo; или &amp;laquo;$ AAA&amp;raquo; имеют имя, которое является строкой &amp;laquo;? NNN&amp;raquo; или &amp;laquo;: AAA&amp;raquo;, &amp;laquo;@AAA&amp;raquo; или &amp;laquo;$ AAA&amp;raquo; соответственно. Другими словами, начальные символы &amp;laquo;:&amp;raquo;, &amp;laquo;$&amp;raquo;, &amp;laquo;@&amp;raquo; или &amp;laquo;?&amp;raquo; входит как часть имени. Параметры формы &quot;?&quot; без следующего целого числа не имеют имени и называются &amp;laquo;безымянными&amp;raquo; или &amp;laquo;анонимными параметрами&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="8f7478b82c93544aa582bd52cdb8be854dddfaed" translate="yes" xml:space="preserve">
          <source>The sqlite3_bind_parameter_name(P,N) interface returns the name of the N-th &lt;a href=&quot;bind_blob&quot;&gt;SQL parameter&lt;/a&gt; in the &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; P. SQL parameters of the form &quot;?NNN&quot; or &quot;:AAA&quot; or &quot;@AAA&quot; or &quot;$AAA&quot; have a name which is the string &quot;?NNN&quot; or &quot;:AAA&quot; or &quot;@AAA&quot; or &quot;$AAA&quot; respectively. In other words, the initial &quot;:&quot; or &quot;$&quot; or &quot;@&quot; or &quot;?&quot; is included as part of the name. Parameters of the form &quot;?&quot; without a following integer have no name and are referred to as &quot;nameless&quot; or &quot;anonymous parameters&quot;.</source>
          <target state="translated">Интерфейс sqlite3_bind_parameter_name (P, N) возвращает имя N-го &lt;a href=&quot;bind_blob&quot;&gt;параметра SQL&lt;/a&gt; в &lt;a href=&quot;stmt&quot;&gt;подготовленном операторе&lt;/a&gt; P. Параметры SQL в форме &amp;laquo;? NNN&amp;raquo; или &amp;laquo;: AAA&amp;raquo; или &amp;laquo;@AAA&amp;raquo; или &amp;laquo;$ AAA&amp;raquo; имеют имя, которое является строкой &amp;laquo;? NNN&amp;raquo; или &amp;laquo;: AAA&amp;raquo;, &amp;laquo;@AAA&amp;raquo; или &amp;laquo;$ AAA&amp;raquo; соответственно. Другими словами, начальные символы &amp;laquo;:&amp;raquo;, &amp;laquo;$&amp;raquo;, &amp;laquo;@&amp;raquo; или &amp;laquo;?&amp;raquo; входит как часть имени. Параметры формы &quot;?&quot; без следующего целого числа не имеют имени и называются &amp;laquo;безымянными&amp;raquo; или &amp;laquo;анонимными параметрами&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="2f7ba9ace88be98840180479bfcb11ff0ebe16ce" translate="yes" xml:space="preserve">
          <source>The sqlite3_bind_pointer(S,I,P,T,D) routine causes the I-th parameter in &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; S to have an SQL value of NULL, but to also be associated with the pointer P of type T. D is either a NULL pointer or a pointer to a destructor function for P. SQLite will invoke the destructor D with a single argument of P when it is finished using P. The T parameter should be a static string, preferably a string literal. The sqlite3_bind_pointer() routine is part of the &lt;a href=&quot;bindptr&quot;&gt;pointer passing interface&lt;/a&gt; added for SQLite 3.20.0.</source>
          <target state="translated">Подпрограмма sqlite3_bind_pointer (S, I, P, T, D) заставляет I-й параметр в &lt;a href=&quot;#sqlite3_stmt&quot;&gt;подготовленном операторе&lt;/a&gt; S иметь значение SQL NULL, но также быть связанным с указателем P типа T. D является либо NULL указатель или указатель на функцию деструктора для P. SQLite вызовет деструктор D с одним аргументом P, когда он завершится с использованием P. Параметр T должен быть статической строкой, предпочтительно строковым литералом. Подпрограмма sqlite3_bind_pointer () является частью &lt;a href=&quot;bindptr&quot;&gt;интерфейса передачи указателя,&lt;/a&gt; добавленного для SQLite 3.20.0.</target>
        </trans-unit>
        <trans-unit id="658c91c6c69fa0e297b2600c0a7ae1e8d41b306a" translate="yes" xml:space="preserve">
          <source>The sqlite3_bind_pointer(S,I,P,T,D) routine causes the I-th parameter in &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; S to have an SQL value of NULL, but to also be associated with the pointer P of type T. D is either a NULL pointer or a pointer to a destructor function for P. SQLite will invoke the destructor D with a single argument of P when it is finished using P. The T parameter should be a static string, preferably a string literal. The sqlite3_bind_pointer() routine is part of the &lt;a href=&quot;../bindptr&quot;&gt;pointer passing interface&lt;/a&gt; added for SQLite 3.20.0.</source>
          <target state="translated">Подпрограмма sqlite3_bind_pointer (S, I, P, T, D) заставляет I-й параметр в &lt;a href=&quot;stmt&quot;&gt;подготовленном операторе&lt;/a&gt; S иметь значение SQL NULL, но также быть связанным с указателем P типа T. D является либо NULL указатель или указатель на функцию деструктора для P. SQLite вызовет деструктор D с одним аргументом P, когда он завершится с использованием P. Параметр T должен быть статической строкой, предпочтительно строковым литералом. Подпрограмма sqlite3_bind_pointer () является частью &lt;a href=&quot;../bindptr&quot;&gt;интерфейса передачи указателя,&lt;/a&gt; добавленного для SQLite 3.20.0.</target>
        </trans-unit>
        <trans-unit id="6397a7b2569f0831356316d22abee5d260da2f56" translate="yes" xml:space="preserve">
          <source>The sqlite3_bind_zeroblob() routine binds a BLOB of length N that is filled with zeroes. A zeroblob uses a fixed amount of memory (just an integer to hold its size) while it is being processed. Zeroblobs are intended to serve as placeholders for BLOBs whose content is later written using &lt;a href=&quot;#sqlite3_blob_open&quot;&gt;incremental BLOB I/O&lt;/a&gt; routines. A negative value for the zeroblob results in a zero-length BLOB.</source>
          <target state="translated">Подпрограмма sqlite3_bind_zeroblob () связывает большой двоичный объект длины N, заполненный нулями. Zeroblob использует фиксированный объем памяти (просто целое число для хранения его размера) во время обработки. Нулевые двоичные объекты предназначены для использования в качестве заполнителей для больших двоичных объектов, содержимое которых позже записывается с использованием процедур &lt;a href=&quot;#sqlite3_blob_open&quot;&gt;инкрементного ввода-вывода&lt;/a&gt; больших двоичных объектов . Отрицательное значение для zeroblob приводит к BLOB нулевой длины.</target>
        </trans-unit>
        <trans-unit id="c43ef2df76e0304e4b4beb3c8e7c5dbefc82b96b" translate="yes" xml:space="preserve">
          <source>The sqlite3_bind_zeroblob() routine binds a BLOB of length N that is filled with zeroes. A zeroblob uses a fixed amount of memory (just an integer to hold its size) while it is being processed. Zeroblobs are intended to serve as placeholders for BLOBs whose content is later written using &lt;a href=&quot;blob_open&quot;&gt;incremental BLOB I/O&lt;/a&gt; routines. A negative value for the zeroblob results in a zero-length BLOB.</source>
          <target state="translated">Подпрограмма sqlite3_bind_zeroblob () связывает большой двоичный объект длины N, заполненный нулями. Zeroblob использует фиксированный объем памяти (просто целое число для хранения его размера) во время обработки. Нулевые двоичные объекты предназначены для использования в качестве заполнителей для больших двоичных объектов, содержимое которых позже записывается с использованием процедур &lt;a href=&quot;blob_open&quot;&gt;инкрементного ввода-вывода&lt;/a&gt; больших двоичных объектов . Отрицательное значение для zeroblob приводит к BLOB нулевой длины.</target>
        </trans-unit>
        <trans-unit id="3d2cce49ac08682bc109d88559efafcb5bc906c9" translate="yes" xml:space="preserve">
          <source>The sqlite3_busy_handler(D,X,P) routine sets a callback function X that might be invoked with argument P whenever an attempt is made to access a database table associated with &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; D when another thread or process has the table locked. The sqlite3_busy_handler() interface is used to implement &lt;a href=&quot;#sqlite3_busy_timeout&quot;&gt;sqlite3_busy_timeout()&lt;/a&gt; and &lt;a href=&quot;pragma#pragma_busy_timeout&quot;&gt;PRAGMA busy_timeout&lt;/a&gt;.</source>
          <target state="translated">Подпрограмма sqlite3_busy_handler (D, X, P) устанавливает функцию обратного вызова X, которая может быть вызвана с аргументом P всякий раз, когда делается попытка доступа к таблице базы данных, связанной с &lt;a href=&quot;#sqlite3&quot;&gt;подключением к базе данных&lt;/a&gt; D, когда другой поток или процесс заблокировали таблицу. Интерфейс sqlite3_busy_handler () используется для реализации &lt;a href=&quot;#sqlite3_busy_timeout&quot;&gt;sqlite3_busy_timeout ()&lt;/a&gt; и &lt;a href=&quot;pragma#pragma_busy_timeout&quot;&gt;PRAGMA busy_timeout&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d3363e5f93709d191e40f4d06f477acdab0e375e" translate="yes" xml:space="preserve">
          <source>The sqlite3_busy_handler(D,X,P) routine sets a callback function X that might be invoked with argument P whenever an attempt is made to access a database table associated with &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; D when another thread or process has the table locked. The sqlite3_busy_handler() interface is used to implement &lt;a href=&quot;busy_timeout&quot;&gt;sqlite3_busy_timeout()&lt;/a&gt; and &lt;a href=&quot;../pragma#pragma_busy_timeout&quot;&gt;PRAGMA busy_timeout&lt;/a&gt;.</source>
          <target state="translated">Подпрограмма sqlite3_busy_handler (D, X, P) устанавливает функцию обратного вызова X, которая может быть вызвана с аргументом P всякий раз, когда делается попытка доступа к таблице базы данных, связанной с &lt;a href=&quot;sqlite3&quot;&gt;подключением к базе данных&lt;/a&gt; D, когда другой поток или процесс заблокировали таблицу. Интерфейс sqlite3_busy_handler () используется для реализации &lt;a href=&quot;busy_timeout&quot;&gt;sqlite3_busy_timeout ()&lt;/a&gt; и &lt;a href=&quot;../pragma#pragma_busy_timeout&quot;&gt;PRAGMA busy_timeout&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e8d93853c1f8ff5d06942fd5a08d82650ba96772" translate="yes" xml:space="preserve">
          <source>The sqlite3_close() and sqlite3_close_v2() routines are destructors for the &lt;a href=&quot;#sqlite3&quot;&gt;sqlite3&lt;/a&gt; object. Calls to sqlite3_close() and sqlite3_close_v2() return &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; if the &lt;a href=&quot;#sqlite3&quot;&gt;sqlite3&lt;/a&gt; object is successfully destroyed and all associated resources are deallocated.</source>
          <target state="translated">Подпрограммы sqlite3_close () и sqlite3_close_v2 () являются деструкторами для объекта &lt;a href=&quot;#sqlite3&quot;&gt;sqlite3&lt;/a&gt; . Звонки на sqlite3_close () и sqlite3_close_v2 () возвращает &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; если &lt;a href=&quot;#sqlite3&quot;&gt;sqlite3&lt;/a&gt; объект успешно разрушен , и все связанные с ним ресурсы высвобождены.</target>
        </trans-unit>
        <trans-unit id="c3b661e4a47ed928f3b7e88dd929f7831fe5385b" translate="yes" xml:space="preserve">
          <source>The sqlite3_close() and sqlite3_close_v2() routines are destructors for the &lt;a href=&quot;sqlite3&quot;&gt;sqlite3&lt;/a&gt; object. Calls to sqlite3_close() and sqlite3_close_v2() return &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; if the &lt;a href=&quot;sqlite3&quot;&gt;sqlite3&lt;/a&gt; object is successfully destroyed and all associated resources are deallocated.</source>
          <target state="translated">Подпрограммы sqlite3_close () и sqlite3_close_v2 () являются деструкторами для объекта &lt;a href=&quot;sqlite3&quot;&gt;sqlite3&lt;/a&gt; . Звонки на sqlite3_close () и sqlite3_close_v2 () возвращает &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; если &lt;a href=&quot;sqlite3&quot;&gt;sqlite3&lt;/a&gt; объект успешно разрушен , и все связанные с ним ресурсы высвобождены.</target>
        </trans-unit>
        <trans-unit id="2e35c3e04c8fe7269b95a0494cefdd5cde7acf02" translate="yes" xml:space="preserve">
          <source>The sqlite3_collation_needed() routine registers a callback which the database engine will invoke if it encounters an unknown collating sequence. The callback can lookup an appropriate comparison function and invoke sqlite_3_create_collation() as needed. The fourth parameter to the callback is the name of the collating sequence in UTF-8. For sqlite3_collation_need16() the callback sends the collating sequence name in UTF-16 host byte order.</source>
          <target state="translated">Рутина sqlite3_collation_need()регистрирует обратный вызов,который будет вызван движком БД,если он столкнется с неизвестной коллекционной последовательностью.Обратный вызов может найти соответствующую функцию сравнения и вызвать sqlite_3_create_collation()по мере необходимости.Четвертым параметром обратного вызова является имя коллекционной последовательности в UTF-8.Для sqlite3_collation_need16()обратный вызов посылает имя коллекционной последовательности в порядке байт хоста UTF-16.</target>
        </trans-unit>
        <trans-unit id="289668a545984e8fa7c4b426fa20f850363028a3" translate="yes" xml:space="preserve">
          <source>The sqlite3_column_decltype() routine returns text which is the declared type of the column in the CREATE TABLE statement. For an expression, the return type is an empty string. sqlite3_column_name() returns the name of the Nth column. sqlite3_column_bytes() returns the number of bytes in a column that has type BLOB or the number of bytes in a TEXT string with UTF-8 encoding. sqlite3_column_bytes16() returns the same value for BLOBs but for TEXT strings returns the number of bytes in a UTF-16 encoding. sqlite3_column_blob() return BLOB data. sqlite3_column_text() return TEXT data as UTF-8. sqlite3_column_text16() return TEXT data as UTF-16. sqlite3_column_int() return INTEGER data in the host machines native integer format. sqlite3_column_int64() returns 64-bit INTEGER data. Finally, sqlite3_column_double() return floating point data.</source>
          <target state="translated">Рутина sqlite3_column_decltype()возвращает текст,который является объявленным типом столбца в операторе CREATE TABLE.Для выражения тип возвращаемого текста-пустая строка.sqlite3_column_name()возвращает имя N-ой колонки.sqlite3_column_bytes()возвращает количество байт в колонке,имеющей тип BLOB или количество байт в TEXT-строке в кодировке UTF-8.sqlite3_column_bytes16()возвращает то же самое значение для BLOB-строк,но для TEXT-строк возвращает количество байт в кодировке UTF-16.sqlite3_column_blob()возвращает BLOB-данные.sqlite3_column_text()возвращает данные TEXT в кодировке UTF-8.sqlite3_column_text16()возвращает данные TEXT в кодировке UTF-16.sqlite3_column_int()возвращает данные INTEGER в родном целочисленном формате для хост-машин.sqlite3_column_int64()возвращает 64-битные данные INTEGER.Наконец,функция sqlite3_column_double()возвращает данные с плавающей точкой.</target>
        </trans-unit>
        <trans-unit id="a9b38d21f857b4d104b01ccf828564edcab9302b" translate="yes" xml:space="preserve">
          <source>The sqlite3_column_type() routine returns the &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;datatype code&lt;/a&gt; for the initial data type of the result column. The returned value is one of &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_INTEGER&lt;/a&gt;, &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_FLOAT&lt;/a&gt;, &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_TEXT&lt;/a&gt;, &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_BLOB&lt;/a&gt;, or &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_NULL&lt;/a&gt;. The return value of sqlite3_column_type() can be used to decide which of the first six interface should be used to extract the column value. The value returned by sqlite3_column_type() is only meaningful if no automatic type conversions have occurred for the value in question. After a type conversion, the result of calling sqlite3_column_type() is undefined, though harmless. Future versions of SQLite may change the behavior of sqlite3_column_type() following a type conversion.</source>
          <target state="translated">Подпрограмма sqlite3_column_type () возвращает &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;код типа данных&lt;/a&gt; для исходного типа данных столбца результата. Возвращаемое значение - одно из &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_INTEGER&lt;/a&gt; , &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_FLOAT&lt;/a&gt; , &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_TEXT&lt;/a&gt; , &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_BLOB&lt;/a&gt; или &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_NULL&lt;/a&gt; . Возвращаемое значение sqlite3_column_type () может использоваться, чтобы решить, какой из первых шести интерфейсов следует использовать для извлечения значения столбца. Значение, возвращаемое функцией sqlite3_column_type (), имеет смысл только в том случае, если для рассматриваемого значения не было выполнено автоматическое преобразование типов. После преобразования типа результат вызова sqlite3_column_type () не определен, но безвреден. В будущих версиях SQLite может измениться поведение sqlite3_column_type () после преобразования типа.</target>
        </trans-unit>
        <trans-unit id="d87c623fe2ec1f08f5218d69ec07d1b6f1fe406e" translate="yes" xml:space="preserve">
          <source>The sqlite3_column_type() routine returns the &lt;a href=&quot;c_blob&quot;&gt;datatype code&lt;/a&gt; for the initial data type of the result column. The returned value is one of &lt;a href=&quot;c_blob&quot;&gt;SQLITE_INTEGER&lt;/a&gt;, &lt;a href=&quot;c_blob&quot;&gt;SQLITE_FLOAT&lt;/a&gt;, &lt;a href=&quot;c_blob&quot;&gt;SQLITE_TEXT&lt;/a&gt;, &lt;a href=&quot;c_blob&quot;&gt;SQLITE_BLOB&lt;/a&gt;, or &lt;a href=&quot;c_blob&quot;&gt;SQLITE_NULL&lt;/a&gt;. The return value of sqlite3_column_type() can be used to decide which of the first six interface should be used to extract the column value. The value returned by sqlite3_column_type() is only meaningful if no automatic type conversions have occurred for the value in question. After a type conversion, the result of calling sqlite3_column_type() is undefined, though harmless. Future versions of SQLite may change the behavior of sqlite3_column_type() following a type conversion.</source>
          <target state="translated">Подпрограмма sqlite3_column_type () возвращает &lt;a href=&quot;c_blob&quot;&gt;код типа данных&lt;/a&gt; для исходного типа данных столбца результата. Возвращаемое значение - одно из &lt;a href=&quot;c_blob&quot;&gt;SQLITE_INTEGER&lt;/a&gt; , &lt;a href=&quot;c_blob&quot;&gt;SQLITE_FLOAT&lt;/a&gt; , &lt;a href=&quot;c_blob&quot;&gt;SQLITE_TEXT&lt;/a&gt; , &lt;a href=&quot;c_blob&quot;&gt;SQLITE_BLOB&lt;/a&gt; или &lt;a href=&quot;c_blob&quot;&gt;SQLITE_NULL&lt;/a&gt; . Возвращаемое значение sqlite3_column_type () может использоваться, чтобы решить, какой из первых шести интерфейсов следует использовать для извлечения значения столбца. Значение, возвращаемое функцией sqlite3_column_type (), имеет смысл только в том случае, если для рассматриваемого значения не было выполнено автоматическое преобразование типов. После преобразования типа результат вызова sqlite3_column_type () не определен, но безвреден. В будущих версиях SQLite может измениться поведение sqlite3_column_type () после преобразования типа.</target>
        </trans-unit>
        <trans-unit id="80c9429e83e0f6600057106ffc072b05d6e8df14" translate="yes" xml:space="preserve">
          <source>The sqlite3_commit_hook() interface registers a callback function to be invoked whenever a transaction is &lt;a href=&quot;../lang_transaction&quot;&gt;committed&lt;/a&gt;. Any callback set by a previous call to sqlite3_commit_hook() for the same database connection is overridden. The sqlite3_rollback_hook() interface registers a callback function to be invoked whenever a transaction is &lt;a href=&quot;../lang_transaction&quot;&gt;rolled back&lt;/a&gt;. Any callback set by a previous call to sqlite3_rollback_hook() for the same database connection is overridden. The pArg argument is passed through to the callback. If the callback on a commit hook function returns non-zero, then the commit is converted into a rollback.</source>
          <target state="translated">Интерфейс sqlite3_commit_hook () регистрирует функцию обратного вызова, которая будет вызываться всякий раз, когда транзакция &lt;a href=&quot;../lang_transaction&quot;&gt;фиксируется&lt;/a&gt; . Любой обратный вызов, установленный предыдущим вызовом sqlite3_commit_hook () для того же подключения к базе данных, отменяется. Интерфейс sqlite3_rollback_hook () регистрирует функцию обратного вызова, которая будет вызываться всякий раз, когда транзакция &lt;a href=&quot;../lang_transaction&quot;&gt;откатывается&lt;/a&gt; . Любой обратный вызов, установленный предыдущим вызовом sqlite3_rollback_hook () для того же подключения к базе данных, отменяется. Аргумент pArg передается функции обратного вызова. Если обратный вызов функции обработчика фиксации возвращает ненулевое значение, фиксация преобразуется в откат.</target>
        </trans-unit>
        <trans-unit id="c831f98581f1e28276e947cc54e55e8093cff2bf" translate="yes" xml:space="preserve">
          <source>The sqlite3_commit_hook() interface registers a callback function to be invoked whenever a transaction is &lt;a href=&quot;lang_transaction&quot;&gt;committed&lt;/a&gt;. Any callback set by a previous call to sqlite3_commit_hook() for the same database connection is overridden. The sqlite3_rollback_hook() interface registers a callback function to be invoked whenever a transaction is &lt;a href=&quot;lang_transaction&quot;&gt;rolled back&lt;/a&gt;. Any callback set by a previous call to sqlite3_rollback_hook() for the same database connection is overridden. The pArg argument is passed through to the callback. If the callback on a commit hook function returns non-zero, then the commit is converted into a rollback.</source>
          <target state="translated">Интерфейс sqlite3_commit_hook () регистрирует функцию обратного вызова, которая будет вызываться всякий раз, когда транзакция &lt;a href=&quot;lang_transaction&quot;&gt;фиксируется&lt;/a&gt; . Любой обратный вызов, установленный предыдущим вызовом sqlite3_commit_hook () для того же подключения к базе данных, отменяется. Интерфейс sqlite3_rollback_hook () регистрирует функцию обратного вызова, которая будет вызываться всякий раз, когда транзакция &lt;a href=&quot;lang_transaction&quot;&gt;откатывается&lt;/a&gt; . Любой обратный вызов, установленный предыдущим вызовом sqlite3_rollback_hook () для того же подключения к базе данных, отменяется. Аргумент pArg передается функции обратного вызова. Если обратный вызов функции обработчика фиксации возвращает ненулевое значение, фиксация преобразуется в откат.</target>
        </trans-unit>
        <trans-unit id="8ed0ff1b29d3e198ebfc7c54c6d04128fb45e5b9" translate="yes" xml:space="preserve">
          <source>The sqlite3_commit_hook(D,C,P) and sqlite3_rollback_hook(D,C,P) functions return the P argument from the previous call of the same function on the same &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; D, or NULL for the first call for each function on D.</source>
          <target state="translated">Функции sqlite3_commit_hook (D, C, P) и sqlite3_rollback_hook (D, C, P) возвращают аргумент P из предыдущего вызова той же функции в том же &lt;a href=&quot;#sqlite3&quot;&gt;соединении с базой данных&lt;/a&gt; D или NULL для первого вызова каждой функции на D.</target>
        </trans-unit>
        <trans-unit id="5c814d040fa0b2376c6a44e987d8d06f8d405641" translate="yes" xml:space="preserve">
          <source>The sqlite3_commit_hook(D,C,P) and sqlite3_rollback_hook(D,C,P) functions return the P argument from the previous call of the same function on the same &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; D, or NULL for the first call for each function on D.</source>
          <target state="translated">Функции sqlite3_commit_hook (D, C, P) и sqlite3_rollback_hook (D, C, P) возвращают аргумент P из предыдущего вызова той же функции в том же &lt;a href=&quot;sqlite3&quot;&gt;соединении с базой данных&lt;/a&gt; D или NULL для первого вызова каждой функции на D.</target>
        </trans-unit>
        <trans-unit id="a783ef29506da5187d0b6a8b529c5db8a199c982" translate="yes" xml:space="preserve">
          <source>The sqlite3_compileoption_get() function allows iterating over the list of options that were defined at compile time by returning the N-th compile time option string. If N is out of range, sqlite3_compileoption_get() returns a NULL pointer. The SQLITE_ prefix is omitted from any strings returned by sqlite3_compileoption_get().</source>
          <target state="translated">Функция sqlite3_compileoption_get()позволяет проводить итерации над списком опций,которые были определены при компиляции,возвращая строку N-ой опции времени компиляции.Если N находится вне диапазона,sqlite3_compileoption_get()возвращает указатель NULL.Префикс SQLITE_опускается из любых строк,возвращаемых функцией sqlite3_compileoption_get().</target>
        </trans-unit>
        <trans-unit id="39c27e864f7c32b9ceed46ceee3feba79ed9e6fc" translate="yes" xml:space="preserve">
          <source>The sqlite3_compileoption_used() function returns 0 or 1 indicating whether the specified option was defined at compile time. The SQLITE_ prefix may be omitted from the option name passed to sqlite3_compileoption_used().</source>
          <target state="translated">Функция sqlite3_compileoption_used()возвращает 0 или 1,указывая,была ли указанная опция определена во время компиляции.Префикс SQLITE_может быть опущен из названия опции,переданного в функцию sqlite3_compileoption_used().</target>
        </trans-unit>
        <trans-unit id="c2f7b71d769d28cabe75800e2f0fc786a0e3ca05" translate="yes" xml:space="preserve">
          <source>The sqlite3_config() interface is used to make global configuration changes to SQLite in order to tune SQLite to the specific needs of the application. The default configuration is recommended for most applications and so this routine is usually not necessary. It is provided to support rare applications with unusual needs.</source>
          <target state="translated">Интерфейс sqlite3_config()используется для внесения глобальных конфигурационных изменений в SQLite с целью настройки SQLite под конкретные потребности приложения.Конфигурация по умолчанию рекомендуется для большинства приложений,поэтому такая рутина обычно не требуется.Она предусмотрена для поддержки редких приложений с необычными потребностями.</target>
        </trans-unit>
        <trans-unit id="2a43551c13014713b84ff3176d603e20a0bb2d0e" translate="yes" xml:space="preserve">
          <source>The sqlite3_config() interface may only be invoked prior to library initialization using &lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_initialize()&lt;/a&gt; or after shutdown by &lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_shutdown()&lt;/a&gt;. If sqlite3_config() is called after &lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_initialize()&lt;/a&gt; and before &lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_shutdown()&lt;/a&gt; then it will return SQLITE_MISUSE. Note, however, that sqlite3_config() can be called as part of the implementation of an application-defined &lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_os_init()&lt;/a&gt;.</source>
          <target state="translated">Интерфейс sqlite3_config () можно вызывать только до инициализации библиотеки с помощью &lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_initialize ()&lt;/a&gt; или после завершения работы с помощью &lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_shutdown ()&lt;/a&gt; . Если sqlite3_config () вызывается после &lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_initialize ()&lt;/a&gt; и перед &lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_shutdown (),&lt;/a&gt; тогда он вернет SQLITE_MISUSE. Обратите внимание, однако, что sqlite3_config () может вызываться как часть реализации определяемой приложением &lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_os_init ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="950f596cd61399b38213d68d8e3371f1294cd97c" translate="yes" xml:space="preserve">
          <source>The sqlite3_config() interface may only be invoked prior to library initialization using &lt;a href=&quot;initialize&quot;&gt;sqlite3_initialize()&lt;/a&gt; or after shutdown by &lt;a href=&quot;initialize&quot;&gt;sqlite3_shutdown()&lt;/a&gt;. If sqlite3_config() is called after &lt;a href=&quot;initialize&quot;&gt;sqlite3_initialize()&lt;/a&gt; and before &lt;a href=&quot;initialize&quot;&gt;sqlite3_shutdown()&lt;/a&gt; then it will return SQLITE_MISUSE. Note, however, that sqlite3_config() can be called as part of the implementation of an application-defined &lt;a href=&quot;initialize&quot;&gt;sqlite3_os_init()&lt;/a&gt;.</source>
          <target state="translated">Интерфейс sqlite3_config () можно вызывать только до инициализации библиотеки с помощью &lt;a href=&quot;initialize&quot;&gt;sqlite3_initialize ()&lt;/a&gt; или после завершения работы с помощью &lt;a href=&quot;initialize&quot;&gt;sqlite3_shutdown ()&lt;/a&gt; . Если sqlite3_config () вызывается после &lt;a href=&quot;initialize&quot;&gt;sqlite3_initialize ()&lt;/a&gt; и перед &lt;a href=&quot;initialize&quot;&gt;sqlite3_shutdown (),&lt;/a&gt; тогда он вернет SQLITE_MISUSE. Обратите внимание, однако, что sqlite3_config () может вызываться как часть реализации определяемой приложением &lt;a href=&quot;initialize&quot;&gt;sqlite3_os_init ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f36e7397009cd60c7259be5a8cbdeb80264ff811" translate="yes" xml:space="preserve">
          <source>The sqlite3_context_db_handle() interface returns a copy of the pointer to the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; (the 1st parameter) of the &lt;a href=&quot;#sqlite3_create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_create_function&quot;&gt;sqlite3_create_function16()&lt;/a&gt; routines that originally registered the application defined function.</source>
          <target state="translated">Интерфейс sqlite3_context_db_handle () возвращает копию указателя на &lt;a href=&quot;#sqlite3&quot;&gt;соединение&lt;/a&gt; с базой данных (1-й параметр &lt;a href=&quot;#sqlite3_create_function&quot;&gt;)&lt;/a&gt; подпрограмм &lt;a href=&quot;#sqlite3_create_function&quot;&gt;sqlite3_create_function ()&lt;/a&gt; и sqlite3_create_function16 () , которые первоначально зарегистрировали функцию, определенную приложением.</target>
        </trans-unit>
        <trans-unit id="04b3afa93b5033ef2c02acd3a1ef18374b3a066e" translate="yes" xml:space="preserve">
          <source>The sqlite3_context_db_handle() interface returns a copy of the pointer to the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; (the 1st parameter) of the &lt;a href=&quot;create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt; and &lt;a href=&quot;create_function&quot;&gt;sqlite3_create_function16()&lt;/a&gt; routines that originally registered the application defined function.</source>
          <target state="translated">Интерфейс sqlite3_context_db_handle () возвращает копию указателя на &lt;a href=&quot;sqlite3&quot;&gt;соединение&lt;/a&gt; с базой данных (1-й параметр &lt;a href=&quot;create_function&quot;&gt;)&lt;/a&gt; подпрограмм &lt;a href=&quot;create_function&quot;&gt;sqlite3_create_function ()&lt;/a&gt; и sqlite3_create_function16 () , которые первоначально зарегистрировали функцию, определенную приложением.</target>
        </trans-unit>
        <trans-unit id="0b0f49ec423453d8567eeff6ab2f843591a04245" translate="yes" xml:space="preserve">
          <source>The sqlite3_create_collation() function honors the SQLITE_UTF16_ALIGNED flag.</source>
          <target state="translated">Функция sqlite3_create_collation()помечает флаг SQLITE_UTF16_ALIGNED.</target>
        </trans-unit>
        <trans-unit id="0e46987511170cbb4e8e90d14cfd9fe052087146" translate="yes" xml:space="preserve">
          <source>The sqlite3_create_collation() function specifies a collating sequence name and a comparison function to implement that collating sequence. The comparison function is only used for comparing text values. The eTextRep parameter is one of SQLITE_UTF8, SQLITE_UTF16LE, SQLITE_UTF16BE, or SQLITE_ANY to specify which text representation the comparison function works with. Separate comparison functions can exist for the same collating sequence for each of the UTF-8, UTF-16LE and UTF-16BE text representations. The sqlite3_create_collation16() works like sqlite3_create_collation() except that the collation name is specified in UTF-16 host byte order instead of in UTF-8.</source>
          <target state="translated">Функция sqlite3_create_collation()задает имя коллекционной последовательности и функцию сравнения для реализации этой коллекционной последовательности.Функция сравнения используется только для сравнения текстовых значений.Параметр eTextRep является одним из параметров SQLITE_UTF8,SQLITE_UTF16LE,SQLITE_UTF16BE или SQLITE_ANY для указания,с каким текстовым представлением работает функция сравнения.Отдельные функции сравнения могут существовать для одной и той же последовательности сравнения для каждого из текстовых представлений UTF-8,UTF-16LE и UTF-16BE.Функция sqlite3_create_collation16()работает как sqlite3_create_collation()за исключением того,что имя коллирования указывается в порядке байт хоста UTF-16,а не в UTF-8.</target>
        </trans-unit>
        <trans-unit id="3bb1bc030c0ecaf171e6e7837d4fc5ad509b9304" translate="yes" xml:space="preserve">
          <source>The sqlite3_create_collation_v2() works like sqlite3_create_collation() with the addition that the xDestroy callback is invoked on pArg when the collating function is deleted. Collating functions are deleted when they are overridden by later calls to the collation creation functions or when the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; is closed using &lt;a href=&quot;#sqlite3_close&quot;&gt;sqlite3_close()&lt;/a&gt;.</source>
          <target state="translated">Sqlite3_create_collation_v2 () работает аналогично sqlite3_create_collation () с добавлением того, что обратный вызов xDestroy вызывается в pArg при удалении функции сортировки. Функции сортировки удаляются, когда они переопределяются последующими вызовами функций создания сопоставления или когда &lt;a href=&quot;#sqlite3&quot;&gt;соединение&lt;/a&gt; с базой данных закрывается с помощью &lt;a href=&quot;#sqlite3_close&quot;&gt;sqlite3_close ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cce8a06023084f98541458166466b478b68c97fc" translate="yes" xml:space="preserve">
          <source>The sqlite3_create_collation_v2() works like sqlite3_create_collation() with the addition that the xDestroy callback is invoked on pArg when the collating function is deleted. Collating functions are deleted when they are overridden by later calls to the collation creation functions or when the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; is closed using &lt;a href=&quot;close&quot;&gt;sqlite3_close()&lt;/a&gt;.</source>
          <target state="translated">Sqlite3_create_collation_v2 () работает аналогично sqlite3_create_collation () с добавлением того, что обратный вызов xDestroy вызывается в pArg при удалении функции сортировки. Функции сортировки удаляются, когда они переопределяются последующими вызовами функций создания сопоставления или когда &lt;a href=&quot;sqlite3&quot;&gt;соединение&lt;/a&gt; с базой данных закрывается с помощью &lt;a href=&quot;close&quot;&gt;sqlite3_close ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="35eaa1fdb7403d0bf2c872e0985b90cb08324f23" translate="yes" xml:space="preserve">
          <source>The sqlite3_create_filename(D,J,W,N,P) allocates memory to hold a version of database filename D with corresponding journal file J and WAL file W and with N URI parameters key/values pairs in the array P. The result from sqlite3_create_filename(D,J,W,N,P) is a pointer to a database filename that is safe to pass to routines like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2321a78d45e7f791f5be9bd5eeeecdd73b61cbff" translate="yes" xml:space="preserve">
          <source>The sqlite3_create_module_v2() interface has a fifth parameter which is a pointer to a destructor for the pClientData. SQLite will invoke the destructor function (if it is not NULL) when SQLite no longer needs the pClientData pointer. The destructor will also be invoked if the call to sqlite3_create_module_v2() fails. The sqlite3_create_module() interface is equivalent to sqlite3_create_module_v2() with a NULL destructor.</source>
          <target state="translated">Интерфейс sqlite3_create_module_v2()имеет пятый параметр-указатель на деструктор для pClientData.SQLite вызовет функцию деструктора (если она не NULL),когда SQLite больше не будет нужен указатель на pClientData.Деструктор также будет вызван,если вызов sqlite3_create_module_v2()не удастся.Интерфейс sqlite3_create_module()эквивалентен sqlite3_create_module_v2()с деструктором NULL.</target>
        </trans-unit>
        <trans-unit id="ce43917c89192dc7d4a31aeaa86afac14bcedebc" translate="yes" xml:space="preserve">
          <source>The sqlite3_data_count(P) interface returns the number of columns in the current row of the result set of &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; P. If prepared statement P does not have results ready to return (via calls to the &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column()&lt;/a&gt; family of interfaces) then sqlite3_data_count(P) returns 0. The sqlite3_data_count(P) routine also returns 0 if P is a NULL pointer. The sqlite3_data_count(P) routine returns 0 if the previous call to &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step&lt;/a&gt;(P) returned &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_DONE&lt;/a&gt;. The sqlite3_data_count(P) will return non-zero if previous call to &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step&lt;/a&gt;(P) returned &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ROW&lt;/a&gt;, except in the case of the &lt;a href=&quot;pragma#pragma_incremental_vacuum&quot;&gt;PRAGMA incremental_vacuum&lt;/a&gt; where it always returns zero since each step of that multi-step pragma returns 0 columns of data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b23578428cca6b0b7cc9f351266849d54d3f4ac7" translate="yes" xml:space="preserve">
          <source>The sqlite3_data_count(P) interface returns the number of columns in the current row of the result set of &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; P. If prepared statement P does not have results ready to return (via calls to the &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_*()&lt;/a&gt; of interfaces) then sqlite3_data_count(P) returns 0. The sqlite3_data_count(P) routine also returns 0 if P is a NULL pointer. The sqlite3_data_count(P) routine returns 0 if the previous call to &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step&lt;/a&gt;(P) returned &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_DONE&lt;/a&gt;. The sqlite3_data_count(P) will return non-zero if previous call to &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step&lt;/a&gt;(P) returned &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ROW&lt;/a&gt;, except in the case of the &lt;a href=&quot;pragma#pragma_incremental_vacuum&quot;&gt;PRAGMA incremental_vacuum&lt;/a&gt; where it always returns zero since each step of that multi-step pragma returns 0 columns of data.</source>
          <target state="translated">Интерфейс sqlite3_data_count (P) возвращает количество столбцов в текущей строке набора результатов &lt;a href=&quot;#sqlite3_stmt&quot;&gt;подготовленного оператора&lt;/a&gt; P. Если подготовленный оператор P не имеет результатов, готовых к возврату (через вызовы &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column _ * ()&lt;/a&gt; интерфейсов), тогда sqlite3_data_count ( P) возвращает 0. Подпрограмма sqlite3_data_count (P) также возвращает 0, если P является указателем NULL. Подпрограмма sqlite3_data_count (P) возвращает 0, если предыдущий вызов &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step&lt;/a&gt; (P) вернул &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_DONE&lt;/a&gt; . Sqlite3_data_count (P) вернет ненулевое значение, если предыдущий вызов &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step&lt;/a&gt; (P) вернул &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ROW&lt;/a&gt; , за исключением случая &lt;a href=&quot;pragma#pragma_incremental_vacuum&quot;&gt;PRAGMA incremental_vacuum&lt;/a&gt;где он всегда возвращает ноль, поскольку каждый шаг этой многошаговой прагмы возвращает 0 столбцов данных.</target>
        </trans-unit>
        <trans-unit id="f5791b68b76b19a4a15dafbc0a31b6f189b8fc89" translate="yes" xml:space="preserve">
          <source>The sqlite3_data_count(P) interface returns the number of columns in the current row of the result set of &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; P. If prepared statement P does not have results ready to return (via calls to the &lt;a href=&quot;column_blob&quot;&gt;sqlite3_column()&lt;/a&gt; family of interfaces) then sqlite3_data_count(P) returns 0. The sqlite3_data_count(P) routine also returns 0 if P is a NULL pointer. The sqlite3_data_count(P) routine returns 0 if the previous call to &lt;a href=&quot;step&quot;&gt;sqlite3_step&lt;/a&gt;(P) returned &lt;a href=&quot;../rescode#done&quot;&gt;SQLITE_DONE&lt;/a&gt;. The sqlite3_data_count(P) will return non-zero if previous call to &lt;a href=&quot;step&quot;&gt;sqlite3_step&lt;/a&gt;(P) returned &lt;a href=&quot;../rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt;, except in the case of the &lt;a href=&quot;../pragma#pragma_incremental_vacuum&quot;&gt;PRAGMA incremental_vacuum&lt;/a&gt; where it always returns zero since each step of that multi-step pragma returns 0 columns of data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0331c5159620074031eabe2d2fffeb3879925815" translate="yes" xml:space="preserve">
          <source>The sqlite3_data_count(P) interface returns the number of columns in the current row of the result set of &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; P. If prepared statement P does not have results ready to return (via calls to the &lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_*()&lt;/a&gt; of interfaces) then sqlite3_data_count(P) returns 0. The sqlite3_data_count(P) routine also returns 0 if P is a NULL pointer. The sqlite3_data_count(P) routine returns 0 if the previous call to &lt;a href=&quot;step&quot;&gt;sqlite3_step&lt;/a&gt;(P) returned &lt;a href=&quot;../rescode#done&quot;&gt;SQLITE_DONE&lt;/a&gt;. The sqlite3_data_count(P) will return non-zero if previous call to &lt;a href=&quot;step&quot;&gt;sqlite3_step&lt;/a&gt;(P) returned &lt;a href=&quot;../rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt;, except in the case of the &lt;a href=&quot;../pragma#pragma_incremental_vacuum&quot;&gt;PRAGMA incremental_vacuum&lt;/a&gt; where it always returns zero since each step of that multi-step pragma returns 0 columns of data.</source>
          <target state="translated">Интерфейс sqlite3_data_count (P) возвращает количество столбцов в текущей строке набора результатов &lt;a href=&quot;stmt&quot;&gt;подготовленного оператора&lt;/a&gt; P. Если подготовленный оператор P не имеет результатов, готовых к возврату (через вызовы &lt;a href=&quot;column_blob&quot;&gt;sqlite3_column _ * ()&lt;/a&gt; интерфейсов), тогда sqlite3_data_count ( P) возвращает 0. Подпрограмма sqlite3_data_count (P) также возвращает 0, если P является указателем NULL. Подпрограмма sqlite3_data_count (P) возвращает 0, если предыдущий вызов &lt;a href=&quot;step&quot;&gt;sqlite3_step&lt;/a&gt; (P) вернул &lt;a href=&quot;../rescode#done&quot;&gt;SQLITE_DONE&lt;/a&gt; . Sqlite3_data_count (P) вернет ненулевое значение, если предыдущий вызов &lt;a href=&quot;step&quot;&gt;sqlite3_step&lt;/a&gt; (P) вернул &lt;a href=&quot;../rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt; , за исключением случая &lt;a href=&quot;../pragma#pragma_incremental_vacuum&quot;&gt;PRAGMA incremental_vacuum&lt;/a&gt;где он всегда возвращает ноль, поскольку каждый шаг этой многошаговой прагмы возвращает 0 столбцов данных.</target>
        </trans-unit>
        <trans-unit id="043836a9d52018cfd95036ef1de8601c0dd65b27" translate="yes" xml:space="preserve">
          <source>The sqlite3_db_config() interface is used to make configuration changes to a &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt;. The interface is similar to &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config()&lt;/a&gt; except that the changes apply to a single &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; (specified in the first argument).</source>
          <target state="translated">Интерфейс sqlite3_db_config () используется для внесения изменений в конфигурацию &lt;a href=&quot;#sqlite3&quot;&gt;соединения&lt;/a&gt; с базой данных . Интерфейс похож на &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config (),&lt;/a&gt; за исключением того, что изменения применяются к одному &lt;a href=&quot;#sqlite3&quot;&gt;соединению с базой данных&lt;/a&gt; (указанному в первом аргументе).</target>
        </trans-unit>
        <trans-unit id="cb382b8043f6bd41fb4e955562ae2dd8de8821a6" translate="yes" xml:space="preserve">
          <source>The sqlite3_db_config() interface is used to make configuration changes to a &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt;. The interface is similar to &lt;a href=&quot;config&quot;&gt;sqlite3_config()&lt;/a&gt; except that the changes apply to a single &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; (specified in the first argument).</source>
          <target state="translated">Интерфейс sqlite3_db_config () используется для внесения изменений в конфигурацию &lt;a href=&quot;sqlite3&quot;&gt;соединения&lt;/a&gt; с базой данных . Интерфейс похож на &lt;a href=&quot;config&quot;&gt;sqlite3_config (),&lt;/a&gt; за исключением того, что изменения применяются к одному &lt;a href=&quot;sqlite3&quot;&gt;соединению с базой данных&lt;/a&gt; (указанному в первом аргументе).</target>
        </trans-unit>
        <trans-unit id="d9890e9099b39efa9f23ed1209f98fc2abd695d1" translate="yes" xml:space="preserve">
          <source>The sqlite3_db_filename(D,N) interface returns a pointer to a filename associated with database N of connection D. The main database file has the name &quot;main&quot;. If there is no attached database N on the database connection D, or if database N is a temporary or in-memory database, then this function will return either a NULL pointer or an empty string.</source>
          <target state="translated">Интерфейс sqlite3_db_filename(D,N)возвращает указатель на имя файла,связанного с БД N соединения D.Основной файл БД имеет имя &quot;main&quot;.Если к БД с подключением D не подключена БД N,или БД N является временной или внутрипамятной БД,то данная функция вернет либо указатель NULL,либо пустую строку.</target>
        </trans-unit>
        <trans-unit id="6ce559d2134cd8f80b32424d9cafa088f3f1de6d" translate="yes" xml:space="preserve">
          <source>The sqlite3_db_filename(D,N) interface returns a pointer to the filename associated with database N of connection D. If there is no attached database N on the database connection D, or if database N is a temporary or in-memory database, then this function will return either a NULL pointer or an empty string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a0142f7765d452e556a6d1ade538189bbf023a1" translate="yes" xml:space="preserve">
          <source>The sqlite3_db_handle interface returns the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; handle to which a &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; belongs. The &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; returned by sqlite3_db_handle is the same &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; that was the first argument to the &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; call (or its variants) that was used to create the statement in the first place.</source>
          <target state="translated">Интерфейс sqlite3_db_handle возвращает дескриптор &lt;a href=&quot;#sqlite3&quot;&gt;соединения&lt;/a&gt; с базой данных, которому принадлежит &lt;a href=&quot;#sqlite3_stmt&quot;&gt;подготовленный оператор&lt;/a&gt; . Соединение с &lt;a href=&quot;#sqlite3&quot;&gt;базой данных,&lt;/a&gt; возвращаемое sqlite3_db_handle, является тем же &lt;a href=&quot;#sqlite3&quot;&gt;соединением с базой данных,&lt;/a&gt; которое было первым аргументом вызова &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; (или его вариантов), который изначально использовался для создания оператора.</target>
        </trans-unit>
        <trans-unit id="0ed4944069eec7d7c0e7904b6909ffc71d6a37af" translate="yes" xml:space="preserve">
          <source>The sqlite3_db_handle interface returns the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; handle to which a &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; belongs. The &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; returned by sqlite3_db_handle is the same &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; that was the first argument to the &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; call (or its variants) that was used to create the statement in the first place.</source>
          <target state="translated">Интерфейс sqlite3_db_handle возвращает дескриптор &lt;a href=&quot;sqlite3&quot;&gt;соединения&lt;/a&gt; с базой данных, которому принадлежит &lt;a href=&quot;stmt&quot;&gt;подготовленный оператор&lt;/a&gt; . Соединение с &lt;a href=&quot;sqlite3&quot;&gt;базой данных,&lt;/a&gt; возвращаемое sqlite3_db_handle, является тем же &lt;a href=&quot;sqlite3&quot;&gt;соединением с базой данных,&lt;/a&gt; которое было первым аргументом вызова &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; (или его вариантов), который изначально использовался для создания оператора.</target>
        </trans-unit>
        <trans-unit id="f13e3d008759351c9d014a67b0c7d66c909c38ed" translate="yes" xml:space="preserve">
          <source>The sqlite3_db_readonly(D,N) interface returns 1 if the database N of connection D is read-only, 0 if it is read/write, or -1 if N is not the name of a database on connection D.</source>
          <target state="translated">Интерфейс sqlite3_db_readonly(D,N)возвращает 1,если БД N соединения D доступна только для чтения,0,если оно доступно для чтения/записи или -1,если N не является именем БД по соединению D.</target>
        </trans-unit>
        <trans-unit id="7c54e0312a49676acc8e0fa5a98fa6c3ca389049" translate="yes" xml:space="preserve">
          <source>The sqlite3_db_release_memory(D) interface attempts to free as much heap memory as possible from database connection D. Unlike the &lt;a href=&quot;#sqlite3_release_memory&quot;&gt;sqlite3_release_memory()&lt;/a&gt; interface, this interface is in effect even when the &lt;a href=&quot;compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt; compile-time option is omitted.</source>
          <target state="translated">Интерфейс sqlite3_db_release_memory (D) пытается освободить как можно больше памяти кучи из соединения с базой данных D. В отличие от интерфейса &lt;a href=&quot;#sqlite3_release_memory&quot;&gt;sqlite3_release_memory ()&lt;/a&gt; , этот интерфейс действует даже в том случае, если параметр &lt;a href=&quot;compile#enable_memory_management&quot;&gt;времени&lt;/a&gt; компиляции SQLITE_ENABLE_MEMORY_MANAGEMENT опущен.</target>
        </trans-unit>
        <trans-unit id="a4505b330dae36966abd878a7a5251bb10a809a6" translate="yes" xml:space="preserve">
          <source>The sqlite3_db_release_memory(D) interface attempts to free as much heap memory as possible from database connection D. Unlike the &lt;a href=&quot;release_memory&quot;&gt;sqlite3_release_memory()&lt;/a&gt; interface, this interface is in effect even when the &lt;a href=&quot;../compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt; compile-time option is omitted.</source>
          <target state="translated">Интерфейс sqlite3_db_release_memory (D) пытается освободить как можно больше памяти кучи из соединения с базой данных D. В отличие от интерфейса &lt;a href=&quot;release_memory&quot;&gt;sqlite3_release_memory ()&lt;/a&gt; , этот интерфейс действует даже в том случае, если параметр &lt;a href=&quot;../compile#enable_memory_management&quot;&gt;времени&lt;/a&gt; компиляции SQLITE_ENABLE_MEMORY_MANAGEMENT опущен.</target>
        </trans-unit>
        <trans-unit id="83634ce6a2d174966fca0f07d2eb6e5e52439e9f" translate="yes" xml:space="preserve">
          <source>The sqlite3_db_status() routine returns SQLITE_OK on success and a non-zero &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; on failure.</source>
          <target state="translated">Подпрограмма sqlite3_db_status () возвращает SQLITE_OK в случае успеха и ненулевой &lt;a href=&quot;../rescode&quot;&gt;код ошибки&lt;/a&gt; в случае ошибки.</target>
        </trans-unit>
        <trans-unit id="7babdc84886f95b16b07a064461180aa8e231247" translate="yes" xml:space="preserve">
          <source>The sqlite3_db_status() routine returns SQLITE_OK on success and a non-zero &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; on failure.</source>
          <target state="translated">Подпрограмма sqlite3_db_status () возвращает SQLITE_OK в случае успеха и ненулевой &lt;a href=&quot;rescode&quot;&gt;код ошибки&lt;/a&gt; в случае ошибки.</target>
        </trans-unit>
        <trans-unit id="18d47ae58f8b29dbac7701bb014dc19e22eadf62" translate="yes" xml:space="preserve">
          <source>The sqlite3_deserialize() interface will fail with SQLITE_BUSY if the database is currently in a read transaction or is involved in a backup operation.</source>
          <target state="translated">Интерфейс sqlite3_deserialize()не будет работать с SQLITE_BUSY,если база данных в данный момент находится в транзакции чтения или участвует в операции резервного копирования.</target>
        </trans-unit>
        <trans-unit id="12340c8333dc6a82eca44a1f4c8bbf0434fac375" translate="yes" xml:space="preserve">
          <source>The sqlite3_deserialize(D,S,P,N,M,F) interface causes the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; D to disconnect from database S and then reopen S as an in-memory database based on the serialization contained in P. The serialized database P is N bytes in size. M is the size of the buffer P, which might be larger than N. If M is larger than N, and the SQLITE_DESERIALIZE_READONLY bit is not set in F, then SQLite is permitted to add content to the in-memory database as long as the total size does not exceed M bytes.</source>
          <target state="translated">Интерфейс sqlite3_deserialize (D, S, P, N, M, F) заставляет &lt;a href=&quot;#sqlite3&quot;&gt;соединение&lt;/a&gt; D с базой данных отключиться от базы данных S, а затем повторно открыть S как базу данных в памяти на основе сериализации, содержащейся в P. Сериализованная база данных P равна N байтов размером. M - это размер буфера P, который может быть больше N. Если M больше N, а бит SQLITE_DESERIALIZE_READONLY не установлен в F, то SQLite разрешено добавлять контент в базу данных в памяти, пока общий размер не превышает M байтов.</target>
        </trans-unit>
        <trans-unit id="afac5ec67e0561a540471ae51b94788f3734ed79" translate="yes" xml:space="preserve">
          <source>The sqlite3_deserialize(D,S,P,N,M,F) interface causes the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; D to disconnect from database S and then reopen S as an in-memory database based on the serialization contained in P. The serialized database P is N bytes in size. M is the size of the buffer P, which might be larger than N. If M is larger than N, and the SQLITE_DESERIALIZE_READONLY bit is not set in F, then SQLite is permitted to add content to the in-memory database as long as the total size does not exceed M bytes.</source>
          <target state="translated">Интерфейс sqlite3_deserialize (D, S, P, N, M, F) заставляет &lt;a href=&quot;sqlite3&quot;&gt;соединение&lt;/a&gt; D с базой данных отключиться от базы данных S, а затем повторно открыть S как базу данных в памяти на основе сериализации, содержащейся в P. Сериализованная база данных P равна N байтов размером. M - это размер буфера P, который может быть больше N. Если M больше N, а бит SQLITE_DESERIALIZE_READONLY не установлен в F, то SQLite разрешено добавлять контент в базу данных в памяти, пока общий размер не превышает M байтов.</target>
        </trans-unit>
        <trans-unit id="6ae05681a8b59259daa468a1d8590729337a135a" translate="yes" xml:space="preserve">
          <source>The sqlite3_drop_modules(D,L) interface removes all virtual table modules from database connection D except those named on list L. The L parameter must be either NULL or a pointer to an array of pointers to strings where the array is terminated by a single NULL pointer. If the L parameter is NULL, then all virtual table modules are removed.</source>
          <target state="translated">Интерфейс sqlite3_drop_modules(D,L)удаляет из соединения с БД D все модули виртуальных таблиц,кроме модулей,указанных в списке L.Параметр L должен быть либо NULL,либо указателем на массив указателей на строки,где массив завершается одним NULL указателем.Если параметр L равен NULL,то удаляются все виртуальные модули таблиц.</target>
        </trans-unit>
        <trans-unit id="cb17fe8b042f1bd6f76a39ed23dd1524edfc2345" translate="yes" xml:space="preserve">
          <source>The sqlite3_errcode() routine returns a result code for the most recent major API call. sqlite3_errmsg() returns an English-language text error message for the most recent error. The error message is represented in UTF-8 and will be ephemeral - it could disappear on the next call to any SQLite API function. sqlite3_errmsg16() works like sqlite3_errmsg() except that it returns the error message represented as UTF-16 in host native byte order.</source>
          <target state="translated">Рутина sqlite3_errcode()возвращает код результата последнего основного вызова API.sqlite3_errmsg()возвращает англоязычное текстовое сообщение об ошибке последнего вызова API.Сообщение об ошибке представлено в UTF-8 и будет эфемерным-оно может исчезнуть при следующем вызове любой функции API SQLite.sqlite3_errmsg16()работает как sqlite3_errmsg()за исключением того,что возвращает сообщение об ошибке,представленное в виде UTF-16 в родном для хоста порядке байт.</target>
        </trans-unit>
        <trans-unit id="5e0d9cf7c1277961ee0db98705525eacc5bb425f" translate="yes" xml:space="preserve">
          <source>The sqlite3_errmsg() and sqlite3_errmsg16() return English-language text that describes the error, as either UTF-8 or UTF-16 respectively. Memory to hold the error message string is managed internally. The application does not need to worry about freeing the result. However, the error string might be overwritten or deallocated by subsequent calls to other SQLite interface functions.</source>
          <target state="translated">Функции sqlite3_errmsg()и sqlite3_errmsg16()возвращают англоязычный текст,который описывает ошибку как UTF-8 или UTF-16 соответственно.Память для хранения строки сообщения об ошибке управляется внутренне.Приложению не нужно беспокоиться об освобождении результата.Однако строка сообщения об ошибке может быть перезаписана или удалена последующими вызовами других функций интерфейса SQLite.</target>
        </trans-unit>
        <trans-unit id="a3b2d05546afbeecb20b8fe87e3f3189bfedb642" translate="yes" xml:space="preserve">
          <source>The sqlite3_errstr() interface returns the English-language text that describes the &lt;a href=&quot;../rescode&quot;&gt;result code&lt;/a&gt;, as UTF-8. Memory to hold the error message string is managed internally and must not be freed by the application.</source>
          <target state="translated">Интерфейс sqlite3_errstr () возвращает текст на английском языке, который описывает &lt;a href=&quot;../rescode&quot;&gt;код результата&lt;/a&gt; , как UTF-8. Память для хранения строки сообщения об ошибке управляется внутренне и не должна освобождаться приложением.</target>
        </trans-unit>
        <trans-unit id="3185f0fefecbff2d0db8b69bac9298083b70809e" translate="yes" xml:space="preserve">
          <source>The sqlite3_errstr() interface returns the English-language text that describes the &lt;a href=&quot;rescode&quot;&gt;result code&lt;/a&gt;, as UTF-8. Memory to hold the error message string is managed internally and must not be freed by the application.</source>
          <target state="translated">Интерфейс sqlite3_errstr () возвращает текст на английском языке, который описывает &lt;a href=&quot;rescode&quot;&gt;код результата&lt;/a&gt; , как UTF-8. Память для хранения строки сообщения об ошибке управляется внутренне и не должна освобождаться приложением.</target>
        </trans-unit>
        <trans-unit id="eec19de3d00e4cd6319cb02ddf72d5b612e30300" translate="yes" xml:space="preserve">
          <source>The sqlite3_exec() interface is a convenience wrapper around &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt;, and &lt;a href=&quot;#sqlite3_finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt;, that allows an application to run multiple statements of SQL without having to use a lot of C code.</source>
          <target state="translated">Интерфейс sqlite3_exec () - это удобная оболочка для &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step ()&lt;/a&gt; и &lt;a href=&quot;#sqlite3_finalize&quot;&gt;sqlite3_finalize ()&lt;/a&gt; , которая позволяет приложению запускать несколько операторов SQL без необходимости использования большого количества кода C.</target>
        </trans-unit>
        <trans-unit id="9a4e88bd32574fff7b2361feb6cf37710d7194a2" translate="yes" xml:space="preserve">
          <source>The sqlite3_exec() interface is a convenience wrapper around &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt;, &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt;, and &lt;a href=&quot;finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt;, that allows an application to run multiple statements of SQL without having to use a lot of C code.</source>
          <target state="translated">Интерфейс sqlite3_exec () - это удобная оболочка для &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; , &lt;a href=&quot;step&quot;&gt;sqlite3_step ()&lt;/a&gt; и &lt;a href=&quot;finalize&quot;&gt;sqlite3_finalize ()&lt;/a&gt; , которая позволяет приложению запускать несколько операторов SQL без необходимости использования большого количества кода C.</target>
        </trans-unit>
        <trans-unit id="5f6ecb5327784e2b3ab3076a060e42400e8e6e49" translate="yes" xml:space="preserve">
          <source>The sqlite3_exec() interface runs zero or more UTF-8 encoded, semicolon-separate SQL statements passed into its 2nd argument, in the context of the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; passed in as its 1st argument. If the callback function of the 3rd argument to sqlite3_exec() is not NULL, then it is invoked for each result row coming out of the evaluated SQL statements. The 4th argument to sqlite3_exec() is relayed through to the 1st argument of each callback invocation. If the callback pointer to sqlite3_exec() is NULL, then no callback is ever invoked and result rows are ignored.</source>
          <target state="translated">Интерфейс sqlite3_exec () выполняет ноль или более операторов SQL в кодировке UTF-8, разделенных точкой с запятой, переданных во второй аргумент в контексте соединения с &lt;a href=&quot;#sqlite3&quot;&gt;базой данных,&lt;/a&gt; переданного в качестве первого аргумента. Если функция обратного вызова третьего аргумента sqlite3_exec () не имеет значения NULL, то она вызывается для каждой строки результата, полученной из оцененных операторов SQL. 4-й аргумент sqlite3_exec () передается 1-му аргументу каждого вызова обратного вызова. Если указатель обратного вызова на sqlite3_exec () равен NULL, то обратный вызов никогда не вызывается, а строки результатов игнорируются.</target>
        </trans-unit>
        <trans-unit id="7f2bf987e70ab4f6565417a4f7295b79e8706b9e" translate="yes" xml:space="preserve">
          <source>The sqlite3_exec() interface runs zero or more UTF-8 encoded, semicolon-separate SQL statements passed into its 2nd argument, in the context of the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; passed in as its 1st argument. If the callback function of the 3rd argument to sqlite3_exec() is not NULL, then it is invoked for each result row coming out of the evaluated SQL statements. The 4th argument to sqlite3_exec() is relayed through to the 1st argument of each callback invocation. If the callback pointer to sqlite3_exec() is NULL, then no callback is ever invoked and result rows are ignored.</source>
          <target state="translated">Интерфейс sqlite3_exec () выполняет ноль или более операторов SQL в кодировке UTF-8, разделенных точкой с запятой, переданных во второй аргумент в контексте соединения с &lt;a href=&quot;sqlite3&quot;&gt;базой данных,&lt;/a&gt; переданного в качестве первого аргумента. Если функция обратного вызова третьего аргумента sqlite3_exec () не имеет значения NULL, то она вызывается для каждой строки результата, полученной из оцененных операторов SQL. 4-й аргумент sqlite3_exec () передается 1-му аргументу каждого вызова обратного вызова. Если указатель обратного вызова на sqlite3_exec () равен NULL, то обратный вызов никогда не вызывается, а строки результатов игнорируются.</target>
        </trans-unit>
        <trans-unit id="fdc80de144729ab29ec768dc45f521935b24167a" translate="yes" xml:space="preserve">
          <source>The sqlite3_expanded_sql() interface returns NULL if insufficient memory is available to hold the result, or if the result would exceed the the maximum string length determined by the &lt;a href=&quot;#sqlitelimitlength&quot;&gt;SQLITE_LIMIT_LENGTH&lt;/a&gt;.</source>
          <target state="translated">Интерфейс sqlite3_expanded_sql () возвращает NULL, если недостаточно памяти для хранения результата или если результат превысит максимальную длину строки, определяемую параметром &lt;a href=&quot;#sqlitelimitlength&quot;&gt;SQLITE_LIMIT_LENGTH&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="253eafa1da6e36def799917e15566e8c664899fe" translate="yes" xml:space="preserve">
          <source>The sqlite3_expanded_sql() interface returns NULL if insufficient memory is available to hold the result, or if the result would exceed the the maximum string length determined by the &lt;a href=&quot;c_limit_attached#sqlitelimitlength&quot;&gt;SQLITE_LIMIT_LENGTH&lt;/a&gt;.</source>
          <target state="translated">Интерфейс sqlite3_expanded_sql () возвращает NULL, если недостаточно памяти для хранения результата или если результат превысит максимальную длину строки, определяемую параметром &lt;a href=&quot;c_limit_attached#sqlitelimitlength&quot;&gt;SQLITE_LIMIT_LENGTH&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1d1fd4c0ad3995d89a0ef41f1f46affc2269eba4" translate="yes" xml:space="preserve">
          <source>The sqlite3_extended_result_codes() routine enables or disables the &lt;a href=&quot;../rescode#extrc&quot;&gt;extended result codes&lt;/a&gt; feature of SQLite. The extended result codes are disabled by default for historical compatibility.</source>
          <target state="translated">Подпрограмма sqlite3_extended_result_codes () включает или отключает функцию &lt;a href=&quot;../rescode#extrc&quot;&gt;расширенных кодов результатов&lt;/a&gt; SQLite. Расширенные коды результатов по умолчанию отключены для исторической совместимости.</target>
        </trans-unit>
        <trans-unit id="904ab00e0ae19fa09117889888e1162471d32017" translate="yes" xml:space="preserve">
          <source>The sqlite3_extended_result_codes() routine enables or disables the &lt;a href=&quot;rescode#extrc&quot;&gt;extended result codes&lt;/a&gt; feature of SQLite. The extended result codes are disabled by default for historical compatibility.</source>
          <target state="translated">Подпрограмма sqlite3_extended_result_codes () включает или отключает функцию &lt;a href=&quot;rescode#extrc&quot;&gt;расширенных кодов результатов&lt;/a&gt; SQLite. Расширенные коды результатов по умолчанию отключены для исторической совместимости.</target>
        </trans-unit>
        <trans-unit id="5daeea1eac71cd621bf8b80af259a724f2e831b8" translate="yes" xml:space="preserve">
          <source>The sqlite3_finalize() function is called to delete a &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt;. If the most recent evaluation of the statement encountered no errors or if the statement is never been evaluated, then sqlite3_finalize() returns SQLITE_OK. If the most recent evaluation of statement S failed, then sqlite3_finalize(S) returns the appropriate &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; or &lt;a href=&quot;rescode#extrc&quot;&gt;extended error code&lt;/a&gt;.</source>
          <target state="translated">Функция sqlite3_finalize () вызывается для удаления &lt;a href=&quot;#sqlite3_stmt&quot;&gt;подготовленного оператора&lt;/a&gt; . Если последняя оценка оператора не обнаружила ошибок или если оператор никогда не оценивался, то sqlite3_finalize () возвращает SQLITE_OK. Если последняя оценка оператора S завершилась неудачно, sqlite3_finalize (S) возвращает соответствующий &lt;a href=&quot;rescode&quot;&gt;код ошибки&lt;/a&gt; или &lt;a href=&quot;rescode#extrc&quot;&gt;расширенный код ошибки&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="74837217c620c1e41ee1e321a9ad17968e0d6486" translate="yes" xml:space="preserve">
          <source>The sqlite3_finalize() function is called to delete a &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt;. If the most recent evaluation of the statement encountered no errors or if the statement is never been evaluated, then sqlite3_finalize() returns SQLITE_OK. If the most recent evaluation of statement S failed, then sqlite3_finalize(S) returns the appropriate &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; or &lt;a href=&quot;../rescode#extrc&quot;&gt;extended error code&lt;/a&gt;.</source>
          <target state="translated">Функция sqlite3_finalize () вызывается для удаления &lt;a href=&quot;stmt&quot;&gt;подготовленного оператора&lt;/a&gt; . Если последняя оценка оператора не обнаружила ошибок или если оператор никогда не оценивался, то sqlite3_finalize () возвращает SQLITE_OK. Если последняя оценка оператора S завершилась неудачно, sqlite3_finalize (S) возвращает соответствующий &lt;a href=&quot;../rescode&quot;&gt;код ошибки&lt;/a&gt; или &lt;a href=&quot;../rescode#extrc&quot;&gt;расширенный код ошибки&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cfdc64000a1f68dd938d60f9bb70e02c947748fd" translate="yes" xml:space="preserve">
          <source>The sqlite3_finalize(S) routine can be called at any point during the life cycle of &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; S: before statement S is ever evaluated, after one or more calls to &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset()&lt;/a&gt;, or after any call to &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; regardless of whether or not the statement has completed execution.</source>
          <target state="translated">Подпрограмму sqlite3_finalize (S) можно вызвать в любой момент в течение жизненного цикла &lt;a href=&quot;#sqlite3_stmt&quot;&gt;подготовленного оператора&lt;/a&gt; S: до того, как оператор S будет когда-либо оценен, после одного или нескольких вызовов &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset ()&lt;/a&gt; или после любого вызова &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step ()&lt;/a&gt; независимо от того, используется ли не выполнение инструкции завершено.</target>
        </trans-unit>
        <trans-unit id="1dec5478469a2333006cfdfd3bbed8c6613161e2" translate="yes" xml:space="preserve">
          <source>The sqlite3_finalize(S) routine can be called at any point during the life cycle of &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; S: before statement S is ever evaluated, after one or more calls to &lt;a href=&quot;reset&quot;&gt;sqlite3_reset()&lt;/a&gt;, or after any call to &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; regardless of whether or not the statement has completed execution.</source>
          <target state="translated">Подпрограмму sqlite3_finalize (S) можно вызвать в любой момент в течение жизненного цикла &lt;a href=&quot;stmt&quot;&gt;подготовленного оператора&lt;/a&gt; S: до того, как оператор S будет когда-либо оценен, после одного или нескольких вызовов &lt;a href=&quot;reset&quot;&gt;sqlite3_reset ()&lt;/a&gt; или после любого вызова &lt;a href=&quot;step&quot;&gt;sqlite3_step ()&lt;/a&gt; независимо от того, используется ли не выполнение инструкции завершено.</target>
        </trans-unit>
        <trans-unit id="408796a34b26a6721118a4ab1b7c1f9baef90909" translate="yes" xml:space="preserve">
          <source>The sqlite3_free_filename(Y) routine releases a memory allocation previously obtained from sqlite3_create_filename(). Invoking sqlite3_free_filename(Y) where Y is a NULL pointer is a harmless no-op.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a8a4dfedb4d5de550dae28093210eb5e1165c50" translate="yes" xml:space="preserve">
          <source>The sqlite3_get_autocommit() interface returns non-zero or zero if the given database connection is or is not in autocommit mode, respectively. Autocommit mode is on by default. Autocommit mode is disabled by a &lt;a href=&quot;../lang_transaction&quot;&gt;BEGIN&lt;/a&gt; statement. Autocommit mode is re-enabled by a &lt;a href=&quot;../lang_transaction&quot;&gt;COMMIT&lt;/a&gt; or &lt;a href=&quot;../lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt;.</source>
          <target state="translated">Интерфейс sqlite3_get_autocommit () возвращает ненулевое или нулевое значение, если данное соединение с базой данных находится или не находится в режиме автоматической фиксации, соответственно. По умолчанию режим автоматической фиксации включен. Режим автоматической фиксации отключен оператором &lt;a href=&quot;../lang_transaction&quot;&gt;BEGIN&lt;/a&gt; . Режим автоматической фиксации снова включается посредством &lt;a href=&quot;../lang_transaction&quot;&gt;COMMIT&lt;/a&gt; или &lt;a href=&quot;../lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c6407bbe024eecae19905f3987328770ebef955e" translate="yes" xml:space="preserve">
          <source>The sqlite3_get_autocommit() interface returns non-zero or zero if the given database connection is or is not in autocommit mode, respectively. Autocommit mode is on by default. Autocommit mode is disabled by a &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt; statement. Autocommit mode is re-enabled by a &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; or &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt;.</source>
          <target state="translated">Интерфейс sqlite3_get_autocommit () возвращает ненулевое или нулевое значение, если данное соединение с базой данных находится или не находится в режиме автоматической фиксации, соответственно. По умолчанию режим автоматической фиксации включен. Режим автоматической фиксации отключен оператором &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt; . Режим автоматической фиксации снова включается посредством &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; или &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c54753db8fb054877250927a699aaaed04734d2b" translate="yes" xml:space="preserve">
          <source>The sqlite3_get_auxdata(C,N) interface returns a pointer to the metadata associated by the sqlite3_set_auxdata(C,N,P,X) function with the Nth argument value to the application-defined function. N is zero for the left-most function argument. If there is no metadata associated with the function argument, the sqlite3_get_auxdata(C,N) interface returns a NULL pointer.</source>
          <target state="translated">Интерфейс sqlite3_get_auxdata(C,N)возвращает указатель на метаданные,ассоциированные функцией sqlite3_set_auxdata(C,N,P,X)со значением N-го аргумента на функцию,определяемую приложением.N равен нулю для самого левого аргумента функции.Если метаданные,связанные с аргументом функции,отсутствуют,то интерфейс sqlite3_get_auxdata(C,N)возвращает указатель NULL.</target>
        </trans-unit>
        <trans-unit id="35597daf57a6a6a4650eb220c2a29fa2c91a59d0" translate="yes" xml:space="preserve">
          <source>The sqlite3_get_table() function evaluates one or more semicolon-separated SQL statements in the zero-terminated UTF-8 string of its 2nd parameter and returns a result table to the pointer given in its 3rd parameter.</source>
          <target state="translated">Функция sqlite3_get_table()вычисляет один или несколько SQL-операторов,разделенных точкой с запятой,в строке с нулевой точкой UTF-8 своего 2-го параметра и возвращает итоговую таблицу указателю,заданному в 3-м параметре.</target>
        </trans-unit>
        <trans-unit id="acdf7ebaf34cc7cf8bdf020e8dc45c52df0d628c" translate="yes" xml:space="preserve">
          <source>The sqlite3_get_table() interface is implemented as a wrapper around &lt;a href=&quot;#sqlite3_exec&quot;&gt;sqlite3_exec()&lt;/a&gt;. The sqlite3_get_table() routine does not have access to any internal data structures of SQLite. It uses only the public interface defined here. As a consequence, errors that occur in the wrapper layer outside of the internal &lt;a href=&quot;#sqlite3_exec&quot;&gt;sqlite3_exec()&lt;/a&gt; call are not reflected in subsequent calls to &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errcode()&lt;/a&gt; or &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errmsg()&lt;/a&gt;.</source>
          <target state="translated">Интерфейс sqlite3_get_table () реализован как оболочка вокруг &lt;a href=&quot;#sqlite3_exec&quot;&gt;sqlite3_exec ()&lt;/a&gt; . Подпрограмма sqlite3_get_table () не имеет доступа ни к каким внутренним структурам данных SQLite. Он использует только определенный здесь публичный интерфейс. Как следствие, ошибки, возникающие на уровне оболочки вне внутреннего вызова &lt;a href=&quot;#sqlite3_exec&quot;&gt;sqlite3_exec ()&lt;/a&gt; , не отражаются в последующих вызовах &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errcode ()&lt;/a&gt; или &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errmsg ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="566ec671a5bf78f09b92642b451438dd26c86350" translate="yes" xml:space="preserve">
          <source>The sqlite3_get_table() interface is implemented as a wrapper around &lt;a href=&quot;exec&quot;&gt;sqlite3_exec()&lt;/a&gt;. The sqlite3_get_table() routine does not have access to any internal data structures of SQLite. It uses only the public interface defined here. As a consequence, errors that occur in the wrapper layer outside of the internal &lt;a href=&quot;exec&quot;&gt;sqlite3_exec()&lt;/a&gt; call are not reflected in subsequent calls to &lt;a href=&quot;errcode&quot;&gt;sqlite3_errcode()&lt;/a&gt; or &lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg()&lt;/a&gt;.</source>
          <target state="translated">Интерфейс sqlite3_get_table () реализован как оболочка вокруг &lt;a href=&quot;exec&quot;&gt;sqlite3_exec ()&lt;/a&gt; . Подпрограмма sqlite3_get_table () не имеет доступа ни к каким внутренним структурам данных SQLite. Он использует только определенный здесь публичный интерфейс. Как следствие, ошибки, возникающие на уровне оболочки вне внутреннего вызова &lt;a href=&quot;exec&quot;&gt;sqlite3_exec ()&lt;/a&gt; , не отражаются в последующих вызовах &lt;a href=&quot;errcode&quot;&gt;sqlite3_errcode ()&lt;/a&gt; или &lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b9b992cc0be7235d15c4a18cbb125e283656622e" translate="yes" xml:space="preserve">
          <source>The sqlite3_hard_heap_limit64(N) interface sets a hard upper bound of N bytes on the amount of memory that will be allocated. The sqlite3_hard_heap_limit64(N) interface is similar to sqlite3_soft_heap_limit64(N) except that memory allocations will fail when the hard heap limit is reached.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a1053b2bb267ced2e3415b8b71b02dc7bb0d976" translate="yes" xml:space="preserve">
          <source>The sqlite3_index_info structure and its substructures is used as part of the &lt;a href=&quot;../vtab&quot;&gt;virtual table&lt;/a&gt; interface to pass information into and receive the reply from the &lt;a href=&quot;../vtab#xbestindex&quot;&gt;xBestIndex&lt;/a&gt; method of a &lt;a href=&quot;module&quot;&gt;virtual table module&lt;/a&gt;. The fields under **Inputs** are the inputs to xBestIndex and are read-only. xBestIndex inserts its results into the **Outputs** fields.</source>
          <target state="translated">Структура sqlite3_index_info и ее подструктуры используются как часть интерфейса &lt;a href=&quot;../vtab&quot;&gt;виртуальной таблицы&lt;/a&gt; для передачи информации и получения ответа от метода &lt;a href=&quot;../vtab#xbestindex&quot;&gt;xBestIndex &lt;/a&gt;&lt;a href=&quot;module&quot;&gt;модуля виртуальной таблицы&lt;/a&gt; . Поля под ** Inputs ** являются входными данными для xBestIndex и доступны только для чтения. xBestIndex вставляет свои результаты в поля ** Outputs **.</target>
        </trans-unit>
        <trans-unit id="779db7516101e2733ab83d988869d6422e837e26" translate="yes" xml:space="preserve">
          <source>The sqlite3_index_info structure and its substructures is used as part of the &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; interface to pass information into and receive the reply from the &lt;a href=&quot;vtab#xbestindex&quot;&gt;xBestIndex&lt;/a&gt; method of a &lt;a href=&quot;#sqlite3_module&quot;&gt;virtual table module&lt;/a&gt;. The fields under **Inputs** are the inputs to xBestIndex and are read-only. xBestIndex inserts its results into the **Outputs** fields.</source>
          <target state="translated">Структура sqlite3_index_info и ее подструктуры используются как часть интерфейса &lt;a href=&quot;vtab&quot;&gt;виртуальной таблицы&lt;/a&gt; для передачи информации и получения ответа от метода &lt;a href=&quot;vtab#xbestindex&quot;&gt;xBestIndex &lt;/a&gt;&lt;a href=&quot;#sqlite3_module&quot;&gt;модуля виртуальной таблицы&lt;/a&gt; . Поля под ** Inputs ** являются входными данными для xBestIndex и доступны только для чтения. xBestIndex вставляет свои результаты в поля ** Outputs **.</target>
        </trans-unit>
        <trans-unit id="f7b3a693ac538b125172c62d75cc7d377f31b955" translate="yes" xml:space="preserve">
          <source>The sqlite3_initialize() interface is threadsafe, but sqlite3_shutdown() is not. The sqlite3_shutdown() interface must only be called from a single thread. All open &lt;a href=&quot;#sqlite3&quot;&gt;database connections&lt;/a&gt; must be closed and all other SQLite resources must be deallocated prior to invoking sqlite3_shutdown().</source>
          <target state="translated">Интерфейс sqlite3_initialize () потокобезопасен, а sqlite3_shutdown () - нет. Интерфейс sqlite3_shutdown () должен вызываться только из одного потока. Все открытые &lt;a href=&quot;#sqlite3&quot;&gt;соединения с базой данных&lt;/a&gt; должны быть закрыты, а все другие ресурсы SQLite должны быть освобождены до вызова sqlite3_shutdown ().</target>
        </trans-unit>
        <trans-unit id="88e442978d61726b76c4c6bd7b1f8a87808c119b" translate="yes" xml:space="preserve">
          <source>The sqlite3_initialize() interface is threadsafe, but sqlite3_shutdown() is not. The sqlite3_shutdown() interface must only be called from a single thread. All open &lt;a href=&quot;sqlite3&quot;&gt;database connections&lt;/a&gt; must be closed and all other SQLite resources must be deallocated prior to invoking sqlite3_shutdown().</source>
          <target state="translated">Интерфейс sqlite3_initialize () потокобезопасен, а sqlite3_shutdown () - нет. Интерфейс sqlite3_shutdown () должен вызываться только из одного потока. Все открытые &lt;a href=&quot;sqlite3&quot;&gt;соединения с базой данных&lt;/a&gt; должны быть закрыты, а все другие ресурсы SQLite должны быть освобождены до вызова sqlite3_shutdown ().</target>
        </trans-unit>
        <trans-unit id="0e2957684efb0782443d87103a368a9305c21dfe" translate="yes" xml:space="preserve">
          <source>The sqlite3_initialize() routine initializes the SQLite library. The sqlite3_shutdown() routine deallocates any resources that were allocated by sqlite3_initialize(). These routines are designed to aid in process initialization and shutdown on embedded systems. Workstation applications using SQLite normally do not need to invoke either of these routines.</source>
          <target state="translated">Рутина sqlite3_initialize()инициализирует библиотеку SQLite.Рутина sqlite3_shutdown()выполняет удаление любых ресурсов,которые были выделены функцией sqlite3_initialize().Эти подпрограммы предназначены для облегчения инициализации и завершения процесса на встраиваемых системах.Приложениям,использующим SQLite на рабочих станциях,как правило,не требуется выполнять ни одну из этих процедур.</target>
        </trans-unit>
        <trans-unit id="6344d658101e62a854952f62047632e568cb77e6" translate="yes" xml:space="preserve">
          <source>The sqlite3_initialize() routine is called internally by many other SQLite interfaces so that an application usually does not need to invoke sqlite3_initialize() directly. For example, &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open()&lt;/a&gt; calls sqlite3_initialize() so the SQLite library will be automatically initialized when &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open()&lt;/a&gt; is called if it has not be initialized already. However, if SQLite is compiled with the &lt;a href=&quot;compile#omit_autoinit&quot;&gt;SQLITE_OMIT_AUTOINIT&lt;/a&gt; compile-time option, then the automatic calls to sqlite3_initialize() are omitted and the application must call sqlite3_initialize() directly prior to using any other SQLite interface. For maximum portability, it is recommended that applications always invoke sqlite3_initialize() directly prior to using any other SQLite interface. Future releases of SQLite may require this. In other words, the behavior exhibited when SQLite is compiled with &lt;a href=&quot;compile#omit_autoinit&quot;&gt;SQLITE_OMIT_AUTOINIT&lt;/a&gt; might become the default behavior in some future release of SQLite.</source>
          <target state="translated">Подпрограмма sqlite3_initialize () вызывается изнутри многими другими интерфейсами SQLite, поэтому приложению обычно не требуется напрямую вызывать sqlite3_initialize (). Например, &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open ()&lt;/a&gt; вызывает sqlite3_initialize (), поэтому библиотека SQLite будет автоматически инициализирована при &lt;a href=&quot;#sqlite3_open&quot;&gt;вызове sqlite3_open (),&lt;/a&gt; если она еще не была инициализирована. Однако, если SQLite скомпилирован с &lt;a href=&quot;compile#omit_autoinit&quot;&gt;SQLITE_OMIT_AUTOINIT&lt;/a&gt;во время компиляции, то автоматические вызовы sqlite3_initialize () опускаются, и приложение должно вызывать sqlite3_initialize () непосредственно перед использованием любого другого интерфейса SQLite. Для максимальной переносимости рекомендуется, чтобы приложения всегда вызывали sqlite3_initialize () непосредственно перед использованием любого другого интерфейса SQLite. Это может потребоваться в будущих выпусках SQLite. Другими словами, поведение, проявляющееся при компиляции SQLite с &lt;a href=&quot;compile#omit_autoinit&quot;&gt;SQLITE_OMIT_AUTOINIT,&lt;/a&gt; может стать поведением по умолчанию в некоторых будущих выпусках SQLite.</target>
        </trans-unit>
        <trans-unit id="fcebb10283d6873f839e3d670ae393ff5c1368df" translate="yes" xml:space="preserve">
          <source>The sqlite3_initialize() routine is called internally by many other SQLite interfaces so that an application usually does not need to invoke sqlite3_initialize() directly. For example, &lt;a href=&quot;open&quot;&gt;sqlite3_open()&lt;/a&gt; calls sqlite3_initialize() so the SQLite library will be automatically initialized when &lt;a href=&quot;open&quot;&gt;sqlite3_open()&lt;/a&gt; is called if it has not be initialized already. However, if SQLite is compiled with the &lt;a href=&quot;../compile#omit_autoinit&quot;&gt;SQLITE_OMIT_AUTOINIT&lt;/a&gt; compile-time option, then the automatic calls to sqlite3_initialize() are omitted and the application must call sqlite3_initialize() directly prior to using any other SQLite interface. For maximum portability, it is recommended that applications always invoke sqlite3_initialize() directly prior to using any other SQLite interface. Future releases of SQLite may require this. In other words, the behavior exhibited when SQLite is compiled with &lt;a href=&quot;../compile#omit_autoinit&quot;&gt;SQLITE_OMIT_AUTOINIT&lt;/a&gt; might become the default behavior in some future release of SQLite.</source>
          <target state="translated">Подпрограмма sqlite3_initialize () вызывается изнутри многими другими интерфейсами SQLite, поэтому приложению обычно не требуется напрямую вызывать sqlite3_initialize (). Например, &lt;a href=&quot;open&quot;&gt;sqlite3_open ()&lt;/a&gt; вызывает sqlite3_initialize (), поэтому библиотека SQLite будет автоматически инициализирована при &lt;a href=&quot;open&quot;&gt;вызове sqlite3_open (),&lt;/a&gt; если она еще не была инициализирована. Однако, если SQLite скомпилирован с &lt;a href=&quot;../compile#omit_autoinit&quot;&gt;SQLITE_OMIT_AUTOINIT&lt;/a&gt;во время компиляции, то автоматические вызовы sqlite3_initialize () опускаются, и приложение должно вызывать sqlite3_initialize () непосредственно перед использованием любого другого интерфейса SQLite. Для максимальной переносимости рекомендуется, чтобы приложения всегда вызывали sqlite3_initialize () непосредственно перед использованием любого другого интерфейса SQLite. Это может потребоваться в будущих выпусках SQLite. Другими словами, поведение, проявляющееся при компиляции SQLite с &lt;a href=&quot;../compile#omit_autoinit&quot;&gt;SQLITE_OMIT_AUTOINIT,&lt;/a&gt; может стать поведением по умолчанию в некоторых будущих выпусках SQLite.</target>
        </trans-unit>
        <trans-unit id="ce2e2f5e58c3c92f466c0d1a9cbb3782ccb3ca7e" translate="yes" xml:space="preserve">
          <source>The sqlite3_initialize() routine returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; on success. If for some reason, sqlite3_initialize() is unable to initialize the library (perhaps it is unable to allocate a needed resource such as a mutex) it returns an &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; other than &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt;.</source>
          <target state="translated">Процедура sqlite3_initialize () в &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;случае&lt;/a&gt; успеха возвращает SQLITE_OK . Если по какой-то причине sqlite3_initialize () не может инициализировать библиотеку (возможно, она не может выделить необходимый ресурс, такой как мьютекс), она возвращает &lt;a href=&quot;rescode&quot;&gt;код ошибки,&lt;/a&gt; отличный от &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7cfd6fb2b2f9b6bef5dc2729044b616aa2e46340" translate="yes" xml:space="preserve">
          <source>The sqlite3_initialize() routine returns &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; on success. If for some reason, sqlite3_initialize() is unable to initialize the library (perhaps it is unable to allocate a needed resource such as a mutex) it returns an &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; other than &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;.</source>
          <target state="translated">Процедура sqlite3_initialize () в &lt;a href=&quot;../rescode#ok&quot;&gt;случае&lt;/a&gt; успеха возвращает SQLITE_OK . Если по какой-то причине sqlite3_initialize () не может инициализировать библиотеку (возможно, она не может выделить необходимый ресурс, такой как мьютекс), она возвращает &lt;a href=&quot;../rescode&quot;&gt;код ошибки,&lt;/a&gt; отличный от &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="004164880e4716eb9f6522ffa56490d8e1026730" translate="yes" xml:space="preserve">
          <source>The sqlite3_int64 and sqlite3_uint64 are the preferred type definitions. The sqlite_int64 and sqlite_uint64 types are supported for backwards compatibility only.</source>
          <target state="translated">Предпочтительными определениями типов являются sqlite3_int64 и sqlite3_uint64.Типы sqlite_int64 и sqlite_uint64 поддерживаются только для обратной совместимости.</target>
        </trans-unit>
        <trans-unit id="7d87f3d7209e128d2babe00e667401d22d9cc8a5" translate="yes" xml:space="preserve">
          <source>The sqlite3_int64 and sqlite_int64 types can store integer values between -9223372036854775808 and +9223372036854775807 inclusive. The sqlite3_uint64 and sqlite_uint64 types can store integer values between 0 and +18446744073709551615 inclusive.</source>
          <target state="translated">Типы sqlite3_int64 и sqlite_int64 могут хранить целочисленные значения между -9223372036854775808 и +9223372036854775807 включительно.Типы sqlite3_uint64 и sqlite_uint64 могут хранить целочисленные значения от 0 до +18446744073709551615 включительно.</target>
        </trans-unit>
        <trans-unit id="d1945cfc4228bc66b1032ca0f61bc88893782d0c" translate="yes" xml:space="preserve">
          <source>The sqlite3_interrupt(D) call is in effect until all currently running SQL statements on &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; D complete. Any new SQL statements that are started after the sqlite3_interrupt() call and before the running statement count reaches zero are interrupted as if they had been running prior to the sqlite3_interrupt() call. New SQL statements that are started after the running statement count reaches zero are not effected by the sqlite3_interrupt(). A call to sqlite3_interrupt(D) that occurs when there are no running SQL statements is a no-op and has no effect on SQL statements that are started after the sqlite3_interrupt() call returns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7eba8c8e6f99b81a907173174c705f9ed98298ab" translate="yes" xml:space="preserve">
          <source>The sqlite3_interrupt(D) call is in effect until all currently running SQL statements on &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; D complete. Any new SQL statements that are started after the sqlite3_interrupt() call and before the running statements reaches zero are interrupted as if they had been running prior to the sqlite3_interrupt() call. New SQL statements that are started after the running statement count reaches zero are not effected by the sqlite3_interrupt(). A call to sqlite3_interrupt(D) that occurs when there are no running SQL statements is a no-op and has no effect on SQL statements that are started after the sqlite3_interrupt() call returns.</source>
          <target state="translated">Вызов sqlite3_interrupt (D) действует до тех пор, пока не завершатся все выполняющиеся в данный момент операторы SQL для &lt;a href=&quot;#sqlite3&quot;&gt;соединения&lt;/a&gt; D с базой данных . Любые новые операторы SQL, которые запускаются после вызова sqlite3_interrupt () и до того, как текущие операторы достигают нуля, прерываются, как если бы они выполнялись до вызова sqlite3_interrupt (). Новые операторы SQL, которые запускаются после того, как счетчик запущенных операторов достигает нуля, не обрабатываются sqlite3_interrupt (). Вызов sqlite3_interrupt (D), который происходит, когда нет запущенных операторов SQL, является бездействующим и не влияет на операторы SQL, которые запускаются после возврата из вызова sqlite3_interrupt ().</target>
        </trans-unit>
        <trans-unit id="397354330de52f0df08035b92ede80f0eda59fd9" translate="yes" xml:space="preserve">
          <source>The sqlite3_interrupt(D) call is in effect until all currently running SQL statements on &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; D complete. Any new SQL statements that are started after the sqlite3_interrupt() call and before the running statement count reaches zero are interrupted as if they had been running prior to the sqlite3_interrupt() call. New SQL statements that are started after the running statement count reaches zero are not effected by the sqlite3_interrupt(). A call to sqlite3_interrupt(D) that occurs when there are no running SQL statements is a no-op and has no effect on SQL statements that are started after the sqlite3_interrupt() call returns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6b86af3fa8ce3c883af892e74e82bdad0554e41" translate="yes" xml:space="preserve">
          <source>The sqlite3_interrupt(D) call is in effect until all currently running SQL statements on &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; D complete. Any new SQL statements that are started after the sqlite3_interrupt() call and before the running statements reaches zero are interrupted as if they had been running prior to the sqlite3_interrupt() call. New SQL statements that are started after the running statement count reaches zero are not effected by the sqlite3_interrupt(). A call to sqlite3_interrupt(D) that occurs when there are no running SQL statements is a no-op and has no effect on SQL statements that are started after the sqlite3_interrupt() call returns.</source>
          <target state="translated">Вызов sqlite3_interrupt (D) действует до тех пор, пока не завершатся все выполняющиеся в данный момент операторы SQL для &lt;a href=&quot;sqlite3&quot;&gt;соединения&lt;/a&gt; D с базой данных . Любые новые операторы SQL, которые запускаются после вызова sqlite3_interrupt () и до того, как текущие операторы достигают нуля, прерываются, как если бы они выполнялись до вызова sqlite3_interrupt (). Новые операторы SQL, которые запускаются после того, как счетчик запущенных операторов достигает нуля, не обрабатываются sqlite3_interrupt (). Вызов sqlite3_interrupt (D), который происходит, когда нет запущенных операторов SQL, является бездействующим и не влияет на операторы SQL, которые запускаются после возврата из вызова sqlite3_interrupt ().</target>
        </trans-unit>
        <trans-unit id="3bfe2e62ea9486a964b648fd6403e7edfa3b65f8" translate="yes" xml:space="preserve">
          <source>The sqlite3_keyword_check(Z,L) interface checks to see whether or not the L-byte UTF8 identifier that Z points to is a keyword, returning non-zero if it is and zero if not.</source>
          <target state="translated">Интерфейс sqlite3_keyword_check(Z,L)проверяет,является ли L-байтовый идентификатор UTF8,на который указывает Z,ключевым словом,возвращая ненулевое,если да,и нулевое,если нет.</target>
        </trans-unit>
        <trans-unit id="d4d8092bdf6d249db5e6e39b2ccbee0c913272c1" translate="yes" xml:space="preserve">
          <source>The sqlite3_keyword_count() interface returns the number of distinct keywords understood by SQLite.</source>
          <target state="translated">Интерфейс sqlite3_keyword_count()возвращает количество различных ключевых слов,понятных SQLite.</target>
        </trans-unit>
        <trans-unit id="dc0acf41ffb529d44b2ebca13529ac325b17bad2" translate="yes" xml:space="preserve">
          <source>The sqlite3_keyword_name(N,Z,L) interface finds the N-th keyword and makes *Z point to that keyword expressed as UTF8 and writes the number of bytes in the keyword into *L. The string that *Z points to is not zero-terminated. The sqlite3_keyword_name(N,Z,L) routine returns SQLITE_OK if N is within bounds and SQLITE_ERROR if not. If either Z or L are NULL or invalid pointers then calls to sqlite3_keyword_name(N,Z,L) result in undefined behavior.</source>
          <target state="translated">Интерфейс sqlite3_keyword_name(N,Z,L)находит N-е ключевое слово и записывает количество байт в *L.Строка,на которую указывает *Z,не является нулевой.Рутина sqlite3_keyword_name(N,Z,L)возвращает SQLITE_OK,если N находится в границах,и SQLITE_ERROR,если нет.Если Z или L-NULL или недействительные указатели,то обращение к sqlite3_keyword_name(N,Z,L)приводит к неопределенному поведению.</target>
        </trans-unit>
        <trans-unit id="0a1d77fc76c131dee5ee5dd030d6d5133cee00d1" translate="yes" xml:space="preserve">
          <source>The sqlite3_last_insert_rowid(D) interface usually returns the &lt;a href=&quot;../lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; of the most recent successful &lt;a href=&quot;../lang_insert&quot;&gt;INSERT&lt;/a&gt; into a rowid table or &lt;a href=&quot;../vtab&quot;&gt;virtual table&lt;/a&gt; on database connection D. Inserts into &lt;a href=&quot;../withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables are not recorded. If no successful &lt;a href=&quot;../lang_insert&quot;&gt;INSERT&lt;/a&gt;s into rowid tables have ever occurred on the database connection D, then sqlite3_last_insert_rowid(D) returns zero.</source>
          <target state="translated">Интерфейс sqlite3_last_insert_rowid (D) обычно возвращает &lt;a href=&quot;../lang_createtable#rowid&quot;&gt;идентификатор&lt;/a&gt; строки самого последнего успешного &lt;a href=&quot;../lang_insert&quot;&gt;INSERT&lt;/a&gt; в таблицу идентификаторов строк или &lt;a href=&quot;../vtab&quot;&gt;виртуальную таблицу&lt;/a&gt; при подключении к базе данных D. Вставки в таблицы &lt;a href=&quot;../withoutrowid&quot;&gt;БЕЗ ROWID&lt;/a&gt; не записываются. Если в соединении D с базой данных никогда не происходило успешных &lt;a href=&quot;../lang_insert&quot;&gt;операций INSERT&lt;/a&gt; в таблицы rowid, тогда sqlite3_last_insert_rowid (D) возвращает ноль.</target>
        </trans-unit>
        <trans-unit id="96cc17a506c60ac9000086a1e0105e51d535d45e" translate="yes" xml:space="preserve">
          <source>The sqlite3_last_insert_rowid(D) interface usually returns the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; of the most recent successful &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; into a rowid table or &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; on database connection D. Inserts into &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables are not recorded. If no successful &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;s into rowid tables have ever occurred on the database connection D, then sqlite3_last_insert_rowid(D) returns zero.</source>
          <target state="translated">Интерфейс sqlite3_last_insert_rowid (D) обычно возвращает &lt;a href=&quot;lang_createtable#rowid&quot;&gt;идентификатор&lt;/a&gt; строки самого последнего успешного &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; в таблицу идентификаторов строк или &lt;a href=&quot;vtab&quot;&gt;виртуальную таблицу&lt;/a&gt; при подключении к базе данных D. Вставки в таблицы &lt;a href=&quot;withoutrowid&quot;&gt;БЕЗ ROWID&lt;/a&gt; не записываются. Если в соединении D с базой данных никогда не происходило успешных &lt;a href=&quot;lang_insert&quot;&gt;операций INSERT&lt;/a&gt; в таблицы rowid, тогда sqlite3_last_insert_rowid (D) возвращает ноль.</target>
        </trans-unit>
        <trans-unit id="97d28d93a8572fd39455b44f97795fb1531500e9" translate="yes" xml:space="preserve">
          <source>The sqlite3_load_extension() interface attempts to load an &lt;a href=&quot;../loadext&quot;&gt;SQLite extension&lt;/a&gt; library contained in the file zFile. If the file cannot be loaded directly, attempts are made to load with various operating-system specific extensions added. So for example, if &quot;samplelib&quot; cannot be loaded, then names like &quot;samplelib.so&quot; or &quot;samplelib.dylib&quot; or &quot;samplelib.dll&quot; might be tried also.</source>
          <target state="translated">Интерфейс sqlite3_load_extension () пытается загрузить библиотеку &lt;a href=&quot;../loadext&quot;&gt;расширений SQLite,&lt;/a&gt; содержащуюся в файле zFile. Если файл не может быть загружен напрямую, предпринимаются попытки загрузки с добавлением различных расширений для конкретной операционной системы. Так, например, если &quot;samplelib&quot; не может быть загружен, можно также попробовать такие имена, как &quot;samplelib.so&quot;, &quot;samplelib.dylib&quot; или &quot;samplelib.dll&quot;.</target>
        </trans-unit>
        <trans-unit id="29a1d12e678745f57cc139b953c6116a8408aff6" translate="yes" xml:space="preserve">
          <source>The sqlite3_load_extension() interface attempts to load an &lt;a href=&quot;loadext&quot;&gt;SQLite extension&lt;/a&gt; library contained in the file zFile. If the file cannot be loaded directly, attempts are made to load with various operating-system specific extensions added. So for example, if &quot;samplelib&quot; cannot be loaded, then names like &quot;samplelib.so&quot; or &quot;samplelib.dylib&quot; or &quot;samplelib.dll&quot; might be tried also.</source>
          <target state="translated">Интерфейс sqlite3_load_extension () пытается загрузить библиотеку &lt;a href=&quot;loadext&quot;&gt;расширений SQLite,&lt;/a&gt; содержащуюся в файле zFile. Если файл не может быть загружен напрямую, предпринимаются попытки загрузки с добавлением различных расширений для конкретной операционной системы. Так, например, если &quot;samplelib&quot; не может быть загружен, можно также попробовать такие имена, как &quot;samplelib.so&quot;, &quot;samplelib.dylib&quot; или &quot;samplelib.dll&quot;.</target>
        </trans-unit>
        <trans-unit id="653b87892cb27376af041bf3731e3304fd208799" translate="yes" xml:space="preserve">
          <source>The sqlite3_log() interface is intended for use by extensions such as virtual tables, collating functions, and SQL functions. While there is nothing to prevent an application from calling sqlite3_log(), doing so is considered bad form.</source>
          <target state="translated">Интерфейс sqlite3_log()предназначен для использования такими расширениями,как виртуальные таблицы,коллекционные функции и функции SQL.Хотя ничто не мешает приложению вызывать sqlite3_log(),это считается плохой формой.</target>
        </trans-unit>
        <trans-unit id="c4ad2aeb0d9be1f2327ef6d534ab004f6a2b8dc6" translate="yes" xml:space="preserve">
          <source>The sqlite3_malloc() routine returns a pointer to a block of memory at least N bytes in length, where N is the parameter. If sqlite3_malloc() is unable to obtain sufficient free memory, it returns a NULL pointer. If the parameter N to sqlite3_malloc() is zero or negative then sqlite3_malloc() returns a NULL pointer.</source>
          <target state="translated">Рутина sqlite3_malloc()возвращает указатель на блок памяти длиной не менее N байт,где N-параметр.Если sqlite3_malloc()не может получить достаточное количество свободной памяти,то возвращается указатель NULL.Если параметр N sqlite3_malloc()равен нулю или отрицателен,то sqlite3_malloc()возвращает указатель NULL.</target>
        </trans-unit>
        <trans-unit id="a4e65f99f4accbf5db989c9154cb81e75b9ee8ed" translate="yes" xml:space="preserve">
          <source>The sqlite3_malloc64(N) routine works just like sqlite3_malloc(N) except that N is an unsigned 64-bit integer instead of a signed 32-bit integer.</source>
          <target state="translated">Рутина sqlite3_malloc64(N)работает так же,как sqlite3_malloc(N),за исключением того,что N является беззнаковым 64-битным целым числом,а не знаковым 32-битным целым.</target>
        </trans-unit>
        <trans-unit id="6aa420d40670b164a1cce9b427bd49e7d1c5fd88" translate="yes" xml:space="preserve">
          <source>The sqlite3_mprintf() and sqlite3_vmprintf() routines write their results into memory obtained from &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc64()&lt;/a&gt;. The strings returned by these two routines should be released by &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free()&lt;/a&gt;. Both routines return a NULL pointer if &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc64()&lt;/a&gt; is unable to allocate enough memory to hold the resulting string.</source>
          <target state="translated">Подпрограммы sqlite3_mprintf () и sqlite3_vmprintf () записывают свои результаты в память, полученную из &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc64 ()&lt;/a&gt; . Строки, возвращаемые этими двумя подпрограммами, должны быть освобождены &lt;a href=&quot;#sqlite3_free&quot;&gt;функцией sqlite3_free ()&lt;/a&gt; . Обе подпрограммы возвращают указатель NULL, если &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc64 ()&lt;/a&gt; не может выделить достаточно памяти для хранения результирующей строки.</target>
        </trans-unit>
        <trans-unit id="aeca10a8c44ac57eac0c9c7f71ba952063b68cc0" translate="yes" xml:space="preserve">
          <source>The sqlite3_mprintf() and sqlite3_vmprintf() routines write their results into memory obtained from &lt;a href=&quot;free&quot;&gt;sqlite3_malloc64()&lt;/a&gt;. The strings returned by these two routines should be released by &lt;a href=&quot;free&quot;&gt;sqlite3_free()&lt;/a&gt;. Both routines return a NULL pointer if &lt;a href=&quot;free&quot;&gt;sqlite3_malloc64()&lt;/a&gt; is unable to allocate enough memory to hold the resulting string.</source>
          <target state="translated">Подпрограммы sqlite3_mprintf () и sqlite3_vmprintf () записывают свои результаты в память, полученную из &lt;a href=&quot;free&quot;&gt;sqlite3_malloc64 ()&lt;/a&gt; . Строки, возвращаемые этими двумя подпрограммами, должны быть освобождены &lt;a href=&quot;free&quot;&gt;функцией sqlite3_free ()&lt;/a&gt; . Обе подпрограммы возвращают указатель NULL, если &lt;a href=&quot;free&quot;&gt;sqlite3_malloc64 ()&lt;/a&gt; не может выделить достаточно памяти для хранения результирующей строки.</target>
        </trans-unit>
        <trans-unit id="f0bcf6e7726b974822789eb5eaa08500974adb52" translate="yes" xml:space="preserve">
          <source>The sqlite3_mutex_alloc() routine allocates a new mutex and returns a pointer to it. The sqlite3_mutex_alloc() routine returns NULL if it is unable to allocate the requested mutex. The argument to sqlite3_mutex_alloc() must one of these integer constants:</source>
          <target state="translated">Рутина sqlite3_mutex_alloc()выделяет новый мьютекс и возвращает на него указатель.Программа sqlite3_mutex_alloc()возвращает NULL,если не может выделить запрашиваемый мьютекс.Аргумент sqlite3_mutex_alloc()должен содержать одну из этих целочисленных констант:</target>
        </trans-unit>
        <trans-unit id="2d81df454ad810426381d8f39e8b57e0d9de3e46" translate="yes" xml:space="preserve">
          <source>The sqlite3_mutex_enter() and sqlite3_mutex_try() routines attempt to enter a mutex. If another thread is already within the mutex, sqlite3_mutex_enter() will block and sqlite3_mutex_try() will return SQLITE_BUSY. The sqlite3_mutex_try() interface returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; upon successful entry. Mutexes created using SQLITE_MUTEX_RECURSIVE can be entered multiple times by the same thread. In such cases, the mutex must be exited an equal number of times before another thread can enter. If the same thread tries to enter any mutex other than an SQLITE_MUTEX_RECURSIVE more than once, the behavior is undefined.</source>
          <target state="translated">Подпрограммы sqlite3_mutex_enter () и sqlite3_mutex_try () пытаются ввести мьютекс. Если другой поток уже находится в мьютексе, sqlite3_mutex_enter () заблокируется, а sqlite3_mutex_try () вернет SQLITE_BUSY. Интерфейс sqlite3_mutex_try () возвращает &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; при успешном входе. Мьютексы, созданные с использованием SQLITE_MUTEX_RECURSIVE, можно вводить несколько раз одним и тем же потоком. В таких случаях из мьютекса необходимо выйти равное количество раз, прежде чем другой поток сможет войти. Если один и тот же поток пытается ввести любой мьютекс, отличный от SQLITE_MUTEX_RECURSIVE, более одного раза, поведение не определено.</target>
        </trans-unit>
        <trans-unit id="3b45ebc24527ab0f89738f7016be66d43d5251ac" translate="yes" xml:space="preserve">
          <source>The sqlite3_mutex_enter() and sqlite3_mutex_try() routines attempt to enter a mutex. If another thread is already within the mutex, sqlite3_mutex_enter() will block and sqlite3_mutex_try() will return SQLITE_BUSY. The sqlite3_mutex_try() interface returns &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; upon successful entry. Mutexes created using SQLITE_MUTEX_RECURSIVE can be entered multiple times by the same thread. In such cases, the mutex must be exited an equal number of times before another thread can enter. If the same thread tries to enter any mutex other than an SQLITE_MUTEX_RECURSIVE more than once, the behavior is undefined.</source>
          <target state="translated">Подпрограммы sqlite3_mutex_enter () и sqlite3_mutex_try () пытаются ввести мьютекс. Если другой поток уже находится в мьютексе, sqlite3_mutex_enter () заблокируется, а sqlite3_mutex_try () вернет SQLITE_BUSY. Интерфейс sqlite3_mutex_try () возвращает &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; при успешном входе. Мьютексы, созданные с использованием SQLITE_MUTEX_RECURSIVE, можно вводить несколько раз одним и тем же потоком. В таких случаях из мьютекса необходимо выйти равное количество раз, прежде чем другой поток сможет войти. Если один и тот же поток пытается ввести любой мьютекс, отличный от SQLITE_MUTEX_RECURSIVE, более одного раза, поведение не определено.</target>
        </trans-unit>
        <trans-unit id="a9c3683cf3483b6e604960673d2e4ca248bc41dc" translate="yes" xml:space="preserve">
          <source>The sqlite3_mutex_free() routine deallocates a previously allocated dynamic mutex. Attempting to deallocate a static mutex results in undefined behavior.</source>
          <target state="translated">Обычная функция sqlite3_mutex_free()выполняет раздачу ранее выделенного динамического мьютекса.Попытка разобрать статический мьютекс приводит к неопределенному поведению.</target>
        </trans-unit>
        <trans-unit id="c54fa9a704452135b01172d66edadf344257a173" translate="yes" xml:space="preserve">
          <source>The sqlite3_mutex_held() and sqlite3_mutex_notheld() routines are intended for use inside assert() statements. The SQLite core never uses these routines except inside an assert() and applications are advised to follow the lead of the core. The SQLite core only provides implementations for these routines when it is compiled with the SQLITE_DEBUG flag. External mutex implementations are only required to provide these routines if SQLITE_DEBUG is defined and if NDEBUG is not defined.</source>
          <target state="translated">Рутины sqlite3_mutex_held()и sqlite3_mutex_notheld()предназначены для использования внутри операторов assert().Ядро SQLite никогда не использует эти подпрограммы,кроме как внутри функции assert(),и приложениям рекомендуется следовать указаниям ядра.Ядро SQLite предоставляет реализации для этих процедур только тогда,когда оно скомпилировано с флагом SQLITE_DEBUG.Внешние реализации мьютекса необходимы для обеспечения этих подпрограмм только в том случае,если определен флаг SQLITE_DEBUG и не определен NDEBUG.</target>
        </trans-unit>
        <trans-unit id="93534cd54fb671abd29d988fdeee0858c44767d1" translate="yes" xml:space="preserve">
          <source>The sqlite3_mutex_leave() routine exits a mutex that was previously entered by the same thread. The behavior is undefined if the mutex is not currently entered by the calling thread or is not currently allocated.</source>
          <target state="translated">Рутина sqlite3_mutex_leave()выходит из мьютекса,который ранее был введен тем же самым потоком.Поведение мьютекса не определено,если мьютекс в данный момент не введен вызывающим потоком или не выделен.</target>
        </trans-unit>
        <trans-unit id="fb745ae4bf7930e6464af0ad23559d80e7f2b3bc" translate="yes" xml:space="preserve">
          <source>The sqlite3_open() routine returns an integer error code rather than a pointer to the sqlite3 structure as the version 2 interface did. The difference between sqlite3_open() and sqlite3_open16() is that sqlite3_open16() takes UTF-16 (in host native byte order) for the name of the database file. If a new database file needs to be created, then sqlite3_open16() sets the internal text representation to UTF-16 whereas sqlite3_open() sets the text representation to UTF-8.</source>
          <target state="translated">Рутина sqlite3_open()возвращает целочисленный код ошибки,а не указатель на структуру sqlite3,как это делал интерфейс версии 2.Разница между функциями sqlite3_open()и sqlite3_open16()заключается в том,что sqlite3_open16()принимает UTF-16 (в родном для хоста порядке байт)за имя файла базы данных.Если необходимо создать новый файл базы данных,то sqlite3_open16()устанавливает внутреннее текстовое представление в UTF-16,а sqlite3_open()устанавливает текстовое представление в UTF-8.</target>
        </trans-unit>
        <trans-unit id="49cca3441049c31bbff034c5494130978bd29358" translate="yes" xml:space="preserve">
          <source>The sqlite3_open_v2() interface works like sqlite3_open() except that it accepts two additional parameters for additional control over the new database connection. The flags parameter to sqlite3_open_v2() can take one of the following three values, optionally combined with the &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_NOMUTEX&lt;/a&gt;, &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_FULLMUTEX&lt;/a&gt;, &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_SHAREDCACHE&lt;/a&gt;, &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_PRIVATECACHE&lt;/a&gt;, and/or &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_URI&lt;/a&gt; flags:</source>
          <target state="translated">Интерфейс sqlite3_open_v2 () работает так же, как sqlite3_open (), за исключением того, что он принимает два дополнительных параметра для дополнительного контроля над новым подключением к базе данных. Параметр flags для sqlite3_open_v2 () может принимать одно из следующих трех значений, необязательно в сочетании с &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;флагами SQLITE_OPEN_NOMUTEX&lt;/a&gt; , &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_FULLMUTEX&lt;/a&gt; , &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_SHAREDCACHE&lt;/a&gt; , &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_PRIVATECACHE&lt;/a&gt; и / или &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_URI&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="e598ece82e5f2beb42f8604c9b91c3f1054b0c31" translate="yes" xml:space="preserve">
          <source>The sqlite3_open_v2() interface works like sqlite3_open() except that it accepts two additional parameters for additional control over the new database connection. The flags parameter to sqlite3_open_v2() can take one of the following three values, optionally combined with the &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_NOMUTEX&lt;/a&gt;, &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_FULLMUTEX&lt;/a&gt;, &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_SHAREDCACHE&lt;/a&gt;, &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_PRIVATECACHE&lt;/a&gt;, and/or &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_URI&lt;/a&gt; flags:</source>
          <target state="translated">Интерфейс sqlite3_open_v2 () работает так же, как sqlite3_open (), за исключением того, что он принимает два дополнительных параметра для дополнительного контроля над новым подключением к базе данных. Параметр flags для sqlite3_open_v2 () может принимать одно из следующих трех значений, необязательно в сочетании с &lt;a href=&quot;c_open_autoproxy&quot;&gt;флагами SQLITE_OPEN_NOMUTEX&lt;/a&gt; , &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_FULLMUTEX&lt;/a&gt; , &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_SHAREDCACHE&lt;/a&gt; , &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_PRIVATECACHE&lt;/a&gt; и / или &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_URI&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="5a0142d09a66478c971c322bbffc0dda8bf83c4b" translate="yes" xml:space="preserve">
          <source>The sqlite3_open_v2() interface works like sqlite3_open() except that it accepts two additional parameters for additional control over the new database connection. The flags parameter to sqlite3_open_v2() must include, at a minimum, one of the following three flag combinations:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e55b10d2fb69bf6bea01941ab944f29f8bde45c" translate="yes" xml:space="preserve">
          <source>The sqlite3_os_init() routine does operating-system specific initialization of the SQLite library. The sqlite3_os_end() routine undoes the effect of sqlite3_os_init(). Typical tasks performed by these routines include allocation or deallocation of static resources, initialization of global variables, setting up a default &lt;a href=&quot;#sqlite3_vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; module, or setting up a default configuration using &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config()&lt;/a&gt;.</source>
          <target state="translated">Подпрограмма sqlite3_os_init () выполняет инициализацию библиотеки SQLite в зависимости от операционной системы. Подпрограмма sqlite3_os_end () отменяет эффект sqlite3_os_init (). Типичные задачи, выполняемые этими подпрограммами, включают выделение или освобождение статических ресурсов, инициализацию глобальных переменных, установку модуля &lt;a href=&quot;#sqlite3_vfs&quot;&gt;sqlite3_vfs по&lt;/a&gt; умолчанию или установку конфигурации по умолчанию с помощью &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ea78da5df45c282e78d4b89a318af0ce437587df" translate="yes" xml:space="preserve">
          <source>The sqlite3_os_init() routine does operating-system specific initialization of the SQLite library. The sqlite3_os_end() routine undoes the effect of sqlite3_os_init(). Typical tasks performed by these routines include allocation or deallocation of static resources, initialization of global variables, setting up a default &lt;a href=&quot;vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; module, or setting up a default configuration using &lt;a href=&quot;config&quot;&gt;sqlite3_config()&lt;/a&gt;.</source>
          <target state="translated">Подпрограмма sqlite3_os_init () выполняет инициализацию библиотеки SQLite в зависимости от операционной системы. Подпрограмма sqlite3_os_end () отменяет эффект sqlite3_os_init (). Типичные задачи, выполняемые этими подпрограммами, включают выделение или освобождение статических ресурсов, инициализацию глобальных переменных, установку модуля &lt;a href=&quot;vfs&quot;&gt;sqlite3_vfs по&lt;/a&gt; умолчанию или установку конфигурации по умолчанию с помощью &lt;a href=&quot;config&quot;&gt;sqlite3_config ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3bd4022600e005736b49c1c51ead1422ec8da9c9" translate="yes" xml:space="preserve">
          <source>The sqlite3_pcache type is opaque. It is implemented by the pluggable module. The SQLite core has no knowledge of its size or internal structure and never deals with the sqlite3_pcache object except by holding and passing pointers to the object.</source>
          <target state="translated">Тип sqlite3_pcache непрозрачен.Реализуется подключаемым модулем.Ядро SQLite не знает ни его размера,ни внутренней структуры и никогда не работает с объектом sqlite3_pcache,кроме как удерживая и передавая указатели на объект.</target>
        </trans-unit>
        <trans-unit id="07293c189451b8c181f77d9379a0238420ee3f47" translate="yes" xml:space="preserve">
          <source>The sqlite3_pcache_methods structure and the &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigpcache&quot;&gt;SQLITE_CONFIG_PCACHE&lt;/a&gt; and &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfiggetpcache&quot;&gt;SQLITE_CONFIG_GETPCACHE&lt;/a&gt; configuration parameters are deprecated. They are replaced by a new &lt;a href=&quot;c3ref/pcache_methods2&quot;&gt;sqlite3_pcache_methods2&lt;/a&gt; structure and &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigpcache2&quot;&gt;SQLITE_CONFIG_PCACHE2&lt;/a&gt; and &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfiggetpcache2&quot;&gt;SQLITE_CONFIG_GETPCACHE2&lt;/a&gt; configuration parameters.</source>
          <target state="translated">Структура sqlite3_pcache_methods и параметры конфигурации &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigpcache&quot;&gt;SQLITE_CONFIG_PCACHE&lt;/a&gt; и &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfiggetpcache&quot;&gt;SQLITE_CONFIG_GETPCACHE&lt;/a&gt; устарели. Они заменены новой структурой &lt;a href=&quot;c3ref/pcache_methods2&quot;&gt;sqlite3_pcache_methods2&lt;/a&gt; и параметрами конфигурации &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigpcache2&quot;&gt;SQLITE_CONFIG_PCACHE2&lt;/a&gt; и &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfiggetpcache2&quot;&gt;SQLITE_CONFIG_GETPCACHE2&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="445aa02fd749c19bfbd930e14dfefb0c0e11a4d3" translate="yes" xml:space="preserve">
          <source>The sqlite3_pcache_page object represents a single page in the page cache. The page cache will allocate instances of this object. Various methods of the page cache use pointers to instances of this object as parameters or as their return value.</source>
          <target state="translated">Объект sqlite3_pcache_page представляет собой одну страницу в кэше страниц.В кэше страниц будут выделяться экземпляры этого объекта.Различные методы кэширования страниц используют указатели на экземпляры данного объекта в качестве параметров или их возвращаемого значения.</target>
        </trans-unit>
        <trans-unit id="7bf15591143e8308e465ab8ab773665acb5da577" translate="yes" xml:space="preserve">
          <source>The sqlite3_prepare interface compiles a single SQL statement into byte code for later execution. This interface is now the preferred way of accessing the database.</source>
          <target state="translated">Интерфейс sqlite3_prepare компилирует один SQL-оператор в байтовый код для последующего выполнения.Этот интерфейс теперь является предпочтительным способом доступа к БД.</target>
        </trans-unit>
        <trans-unit id="63425e76fcf41641f3bb3043a50f94b90abaff47" translate="yes" xml:space="preserve">
          <source>The sqlite3_prepare_v2(), sqlite3_prepare_v3(), sqlite3_prepare16_v2(), and sqlite3_prepare16_v3() interfaces are recommended for all new programs. The older interfaces (sqlite3_prepare() and sqlite3_prepare16()) are retained for backwards compatibility, but their use is discouraged. In the &quot;vX&quot; interfaces, the prepared statement that is returned (the &lt;a href=&quot;#sqlite3_stmt&quot;&gt;sqlite3_stmt&lt;/a&gt; object) contains a copy of the original SQL text. This causes the &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; interface to behave differently in three ways:</source>
          <target state="translated">Интерфейсы sqlite3_prepare_v2 (), sqlite3_prepare_v3 (), sqlite3_prepare16_v2 () и sqlite3_prepare16_v3 () рекомендуются для всех новых программ. Старые интерфейсы (sqlite3_prepare () и sqlite3_prepare16 ()) сохранены для обратной совместимости, но их использование не рекомендуется. В интерфейсах &amp;laquo;vX&amp;raquo; возвращаемый подготовленный оператор ( объект &lt;a href=&quot;#sqlite3_stmt&quot;&gt;sqlite3_stmt&lt;/a&gt; ) содержит копию исходного текста SQL. Это приводит к тому, что интерфейс &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step ()&lt;/a&gt; ведет себя по-разному тремя способами:</target>
        </trans-unit>
        <trans-unit id="31c4a31d37db839c6c488798a5abc3fd1e42192d" translate="yes" xml:space="preserve">
          <source>The sqlite3_prepare_v2(), sqlite3_prepare_v3(), sqlite3_prepare16_v2(), and sqlite3_prepare16_v3() interfaces are recommended for all new programs. The older interfaces (sqlite3_prepare() and sqlite3_prepare16()) are retained for backwards compatibility, but their use is discouraged. In the &quot;vX&quot; interfaces, the prepared statement that is returned (the &lt;a href=&quot;stmt&quot;&gt;sqlite3_stmt&lt;/a&gt; object) contains a copy of the original SQL text. This causes the &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; interface to behave differently in three ways:</source>
          <target state="translated">Интерфейсы sqlite3_prepare_v2 (), sqlite3_prepare_v3 (), sqlite3_prepare16_v2 () и sqlite3_prepare16_v3 () рекомендуются для всех новых программ. Старые интерфейсы (sqlite3_prepare () и sqlite3_prepare16 ()) сохранены для обратной совместимости, но их использование не рекомендуется. В интерфейсах &amp;laquo;vX&amp;raquo; возвращаемый подготовленный оператор ( объект &lt;a href=&quot;stmt&quot;&gt;sqlite3_stmt&lt;/a&gt; ) содержит копию исходного текста SQL. Это приводит к тому, что интерфейс &lt;a href=&quot;step&quot;&gt;sqlite3_step ()&lt;/a&gt; ведет себя по-разному тремя способами:</target>
        </trans-unit>
        <trans-unit id="1133258b4a9a31b0c0513ddc50dd402acde6047e" translate="yes" xml:space="preserve">
          <source>The sqlite3_progress_handler(D,N,X,P) interface causes the callback function X to be invoked periodically during long running calls to &lt;a href=&quot;#sqlite3_exec&quot;&gt;sqlite3_exec()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_free_table&quot;&gt;sqlite3_get_table()&lt;/a&gt; for database connection D. An example use for this interface is to keep a GUI updated during a large query.</source>
          <target state="translated">Интерфейс sqlite3_progress_handler (D, N, X, P) вызывает периодический вызов функции обратного вызова X во время длительных вызовов &lt;a href=&quot;#sqlite3_exec&quot;&gt;sqlite3_exec ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step ()&lt;/a&gt; и &lt;a href=&quot;#sqlite3_free_table&quot;&gt;sqlite3_get_table ()&lt;/a&gt; для подключения к базе данных D. Пример использования этого интерфейса: обновлять графический интерфейс во время большого запроса.</target>
        </trans-unit>
        <trans-unit id="6ede9775015331a2dade498d028dbb0b1a89b661" translate="yes" xml:space="preserve">
          <source>The sqlite3_progress_handler(D,N,X,P) interface causes the callback function X to be invoked periodically during long running calls to &lt;a href=&quot;exec&quot;&gt;sqlite3_exec()&lt;/a&gt;, &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; and &lt;a href=&quot;free_table&quot;&gt;sqlite3_get_table()&lt;/a&gt; for database connection D. An example use for this interface is to keep a GUI updated during a large query.</source>
          <target state="translated">Интерфейс sqlite3_progress_handler (D, N, X, P) вызывает периодический вызов функции обратного вызова X во время длительных вызовов &lt;a href=&quot;exec&quot;&gt;sqlite3_exec ()&lt;/a&gt; , &lt;a href=&quot;step&quot;&gt;sqlite3_step ()&lt;/a&gt; и &lt;a href=&quot;free_table&quot;&gt;sqlite3_get_table ()&lt;/a&gt; для подключения к базе данных D. Пример использования этого интерфейса: обновлять графический интерфейс во время большого запроса.</target>
        </trans-unit>
        <trans-unit id="92b3414b60e6ff01e63206d0ac8d5d46b8bec0e5" translate="yes" xml:space="preserve">
          <source>The sqlite3_realloc(X,N) interface attempts to resize a prior memory allocation X to be at least N bytes. If the X parameter to sqlite3_realloc(X,N) is a NULL pointer then its behavior is identical to calling sqlite3_malloc(N). If the N parameter to sqlite3_realloc(X,N) is zero or negative then the behavior is exactly the same as calling sqlite3_free(X). sqlite3_realloc(X,N) returns a pointer to a memory allocation of at least N bytes in size or NULL if insufficient memory is available. If M is the size of the prior allocation, then min(N,M) bytes of the prior allocation are copied into the beginning of buffer returned by sqlite3_realloc(X,N) and the prior allocation is freed. If sqlite3_realloc(X,N) returns NULL and N is positive, then the prior allocation is not freed.</source>
          <target state="translated">Интерфейс sqlite3_realloc(X,N)пытается изменить размер ранее выделенной памяти X как минимум на N байт.Если параметр X sqlite3_realloc(X,N)является указателем NULL,то его поведение идентично вызову sqlite3_malloc(N).Если параметр N sqlite3_realloc(X,N)равен нулю или отрицателен,то его поведение аналогично вызову sqlite3_free(X).sqlite3_realloc(X,N)возвращает указатель на выделение памяти размером не менее N байт или NULL,если памяти недостаточно.Если M-размер предыдущего выделения,то min(N,M)байт предыдущего выделения копируется в начало буфера,возвращаемого sqlite3_realloc(X,N),и предыдущее выделение освобождается.Если sqlite3_realloc(X,N)возвращает NULL,а N положительное,то предыдущее выделение не освобождается.</target>
        </trans-unit>
        <trans-unit id="e95adede07a7a66375653b101c394b5d26a89fcd" translate="yes" xml:space="preserve">
          <source>The sqlite3_realloc64(X,N) interfaces works the same as sqlite3_realloc(X,N) except that N is a 64-bit unsigned integer instead of a 32-bit signed integer.</source>
          <target state="translated">Интерфейсы sqlite3_realloc64(X,N)работают так же,как и sqlite3_realloc(X,N),за исключением того,что N является 64-битным беззнаковым целым числом вместо 32-битного знакового.</target>
        </trans-unit>
        <trans-unit id="c45df4cf90bd7042631d9142c52fed7adb90361e" translate="yes" xml:space="preserve">
          <source>The sqlite3_rebaser object is deleted by calling sqlite3rebaser_delete().</source>
          <target state="translated">Удаление объекта sqlite3_rebaser производится вызовом sqlite3rebaser_delete().</target>
        </trans-unit>
        <trans-unit id="4a286ff8214a968ca30b48466d6f539d2ffd723c" translate="yes" xml:space="preserve">
          <source>The sqlite3_release_memory() interface attempts to free N bytes of heap memory by deallocating non-essential memory allocations held by the database library. Memory used to cache database pages to improve performance is an example of non-essential memory. sqlite3_release_memory() returns the number of bytes actually freed, which might be more or less than the amount requested. The sqlite3_release_memory() routine is a no-op returning zero if SQLite is not compiled with &lt;a href=&quot;../compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt;.</source>
          <target state="translated">Интерфейс sqlite3_release_memory () пытается освободить N байтов кучи, освобождая несущественные выделения памяти, хранящиеся в библиотеке базы данных. Память, используемая для кэширования страниц базы данных с целью повышения производительности, является примером несущественной памяти. sqlite3_release_memory () возвращает количество фактически освобожденных байтов, которое может быть больше или меньше запрошенного количества. Процедура sqlite3_release_memory () - это не &lt;a href=&quot;../compile#enable_memory_management&quot;&gt;операция,&lt;/a&gt; возвращающая ноль, если SQLite не скомпилирован с SQLITE_ENABLE_MEMORY_MANAGEMENT .</target>
        </trans-unit>
        <trans-unit id="e641eb92f089a94b694e1eb10428491e684eab1f" translate="yes" xml:space="preserve">
          <source>The sqlite3_release_memory() interface attempts to free N bytes of heap memory by deallocating non-essential memory allocations held by the database library. Memory used to cache database pages to improve performance is an example of non-essential memory. sqlite3_release_memory() returns the number of bytes actually freed, which might be more or less than the amount requested. The sqlite3_release_memory() routine is a no-op returning zero if SQLite is not compiled with &lt;a href=&quot;compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt;.</source>
          <target state="translated">Интерфейс sqlite3_release_memory () пытается освободить N байтов кучи, освобождая несущественные выделения памяти, хранящиеся в библиотеке базы данных. Память, используемая для кэширования страниц базы данных с целью повышения производительности, является примером несущественной памяти. sqlite3_release_memory () возвращает количество фактически освобожденных байтов, которое может быть больше или меньше запрошенного количества. Процедура sqlite3_release_memory () - это не &lt;a href=&quot;compile#enable_memory_management&quot;&gt;операция,&lt;/a&gt; возвращающая ноль, если SQLite не скомпилирован с SQLITE_ENABLE_MEMORY_MANAGEMENT .</target>
        </trans-unit>
        <trans-unit id="54ae89d5ac2183e89297de25b936056b80fa288f" translate="yes" xml:space="preserve">
          <source>The sqlite3_reset() function is called to reset a &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; object back to its initial state, ready to be re-executed. Any SQL statement variables that had values bound to them using the &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;sqlite3_bind_*() API&lt;/a&gt; retain their values. Use &lt;a href=&quot;#sqlite3_clear_bindings&quot;&gt;sqlite3_clear_bindings()&lt;/a&gt; to reset the bindings.</source>
          <target state="translated">Функция sqlite3_reset () вызывается для сброса &lt;a href=&quot;#sqlite3_stmt&quot;&gt;подготовленного&lt;/a&gt; объекта оператора обратно в его начальное состояние, готового к повторному выполнению. Все переменные инструкции SQL, значения которых были привязаны к ним с помощью &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;API sqlite3_bind _ * (),&lt;/a&gt; сохраняют свои значения. Используйте &lt;a href=&quot;#sqlite3_clear_bindings&quot;&gt;sqlite3_clear_bindings ()&lt;/a&gt; для сброса привязок.</target>
        </trans-unit>
        <trans-unit id="55cabea2592a4db5b69eb055b74aa3254a909a13" translate="yes" xml:space="preserve">
          <source>The sqlite3_reset() function is called to reset a &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; object back to its initial state, ready to be re-executed. Any SQL statement variables that had values bound to them using the &lt;a href=&quot;bind_blob&quot;&gt;sqlite3_bind_*() API&lt;/a&gt; retain their values. Use &lt;a href=&quot;clear_bindings&quot;&gt;sqlite3_clear_bindings()&lt;/a&gt; to reset the bindings.</source>
          <target state="translated">Функция sqlite3_reset () вызывается для сброса &lt;a href=&quot;stmt&quot;&gt;подготовленного&lt;/a&gt; объекта оператора обратно в его начальное состояние, готового к повторному выполнению. Все переменные инструкции SQL, значения которых были привязаны к ним с помощью &lt;a href=&quot;bind_blob&quot;&gt;API sqlite3_bind _ * (),&lt;/a&gt; сохраняют свои значения. Используйте &lt;a href=&quot;clear_bindings&quot;&gt;sqlite3_clear_bindings ()&lt;/a&gt; для сброса привязок.</target>
        </trans-unit>
        <trans-unit id="ee8a502aaf09ac296b4bb201f29d8a4e68054a04" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_blob() interface sets the result from an application-defined function to be the BLOB whose content is pointed to by the second parameter and which is N bytes long where N is the third parameter.</source>
          <target state="translated">Интерфейс sqlite3_result_blob()устанавливает результат от функции,определяемой приложением,в BLOB,на содержимое которой указывает второй параметр,а длина N байт,где N-третий параметр.</target>
        </trans-unit>
        <trans-unit id="b7904572bea3279794f2bcc9179991e08e12d408" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_double() interface sets the result from an application-defined function to be a floating point value specified by its 2nd argument.</source>
          <target state="translated">Интерфейс sqlite3_result_double()устанавливает в качестве результата работы функции,определяемой приложением,значение с плавающей точкой,заданное ее 2-м аргументом.</target>
        </trans-unit>
        <trans-unit id="ea6209b4564a5f3773fd6febf3293c65522a4bc0" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_error() and sqlite3_result_error16() functions cause the implemented SQL function to throw an exception. SQLite uses the string pointed to by the 2nd parameter of sqlite3_result_error() or sqlite3_result_error16() as the text of an error message. SQLite interprets the error message string from sqlite3_result_error() as UTF-8. SQLite interprets the string from sqlite3_result_error16() as UTF-16 in native byte order. If the third parameter to sqlite3_result_error() or sqlite3_result_error16() is negative then SQLite takes as the error message all text up through the first zero character. If the third parameter to sqlite3_result_error() or sqlite3_result_error16() is non-negative then SQLite takes that many bytes (not characters) from the 2nd parameter as the error message. The sqlite3_result_error() and sqlite3_result_error16() routines make a private copy of the error message text before they return. Hence, the calling function can deallocate or modify the text after they return without harm. The sqlite3_result_error_code() function changes the error code returned by SQLite as a result of an error in a function. By default, the error code is SQLITE_ERROR. A subsequent call to sqlite3_result_error() or sqlite3_result_error16() resets the error code to SQLITE_ERROR.</source>
          <target state="translated">Функции sqlite3_result_error()и sqlite3_result_error16()приводят к тому,что реализованная SQL-функция бросает исключение.В качестве текста сообщения об ошибке SQLite использует строку,на которую указывает 2-й параметр sqlite3_result_error()или sqlite3_result_error16().SQLite интерпретирует строку сообщения об ошибке из sqlite3_result_error()как UTF-8.SQLite интерпретирует строку из sqlite3_result_error16()как UTF-16 в родном порядке байт.Если третий параметр sqlite3_result_error()или sqlite3_result_error16()отрицательный,то SQLite принимает за сообщение об ошибке весь текст вверх через первый нулевой символ.Если третий параметр sqlite3_result_error()или sqlite3_result_error16()не имеет отрицательного значения,то SQLite принимает в качестве сообщения об ошибке столько байт (не символов)от 2-го параметра.Рутины sqlite3_result_error()и sqlite3_result_error16()делают приватную копию текста сообщения об ошибке перед возвращением.Следовательно,вызывающая функция может разблокировать или модифицировать текст после их возврата без ущерба.Функция sqlite3_result_error_code()изменяет код ошибки,возвращаемый SQLite в результате ошибки в функции.По умолчанию код ошибки SQLITE_ERROR.Последующий вызов sqlite3_result_error()или sqlite3_result_error16()сбрасывает код ошибки на SQLITE_ERROR.</target>
        </trans-unit>
        <trans-unit id="29f28f42596987edc9ab24a265ebb7acbdeb19a7" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_error() and sqlite3_result_error16() functions cause the implemented SQL function to throw an exception. SQLite uses the string pointed to by the 2nd parameter of sqlite3_result_error() or sqlite3_result_error16() as the text of an error message. SQLite interprets the error message string from sqlite3_result_error() as UTF-8. SQLite interprets the string from sqlite3_result_error16() as UTF-16 using the same &lt;a href=&quot;#byteorderdeterminationrules&quot;&gt;byte-order determination rules&lt;/a&gt; as &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;sqlite3_bind_text16()&lt;/a&gt;. If the third parameter to sqlite3_result_error() or sqlite3_result_error16() is negative then SQLite takes as the error message all text up through the first zero character. If the third parameter to sqlite3_result_error() or sqlite3_result_error16() is non-negative then SQLite takes that many bytes (not characters) from the 2nd parameter as the error message. The sqlite3_result_error() and sqlite3_result_error16() routines make a private copy of the error message text before they return. Hence, the calling function can deallocate or modify the text after they return without harm. The sqlite3_result_error_code() function changes the error code returned by SQLite as a result of an error in a function. By default, the error code is SQLITE_ERROR. A subsequent call to sqlite3_result_error() or sqlite3_result_error16() resets the error code to SQLITE_ERROR.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5a0bd3f253d68fda2502decfe5e0f0d13527f91" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_error() and sqlite3_result_error16() functions cause the implemented SQL function to throw an exception. SQLite uses the string pointed to by the 2nd parameter of sqlite3_result_error() or sqlite3_result_error16() as the text of an error message. SQLite interprets the error message string from sqlite3_result_error() as UTF-8. SQLite interprets the string from sqlite3_result_error16() as UTF-16 using the same &lt;a href=&quot;bind_blob#byteorderdeterminationrules&quot;&gt;byte-order determination rules&lt;/a&gt; as &lt;a href=&quot;bind_blob&quot;&gt;sqlite3_bind_text16()&lt;/a&gt;. If the third parameter to sqlite3_result_error() or sqlite3_result_error16() is negative then SQLite takes as the error message all text up through the first zero character. If the third parameter to sqlite3_result_error() or sqlite3_result_error16() is non-negative then SQLite takes that many bytes (not characters) from the 2nd parameter as the error message. The sqlite3_result_error() and sqlite3_result_error16() routines make a private copy of the error message text before they return. Hence, the calling function can deallocate or modify the text after they return without harm. The sqlite3_result_error_code() function changes the error code returned by SQLite as a result of an error in a function. By default, the error code is SQLITE_ERROR. A subsequent call to sqlite3_result_error() or sqlite3_result_error16() resets the error code to SQLITE_ERROR.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9161e1bf262f2df329446fa1f6bc65f20e7794e5" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_error_nomem() interface causes SQLite to throw an error indicating that a memory allocation failed.</source>
          <target state="translated">Интерфейс sqlite3_result_error_nomem()приводит к тому,что SQLite выдает ошибку,указывающую на неудачное выделение памяти.</target>
        </trans-unit>
        <trans-unit id="9e5d46d0dedea736182a8b4b5fc9e97d872ed801" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_error_toobig() interface causes SQLite to throw an error indicating that a string or BLOB is too long to represent.</source>
          <target state="translated">Интерфейс sqlite3_result_error_toobig()заставляет SQLite выдавать ошибку,указывающую на то,что строка или BLOB слишком длинная для представления.</target>
        </trans-unit>
        <trans-unit id="f6cfb870f85ac1c6d72052f09d1c9de9769820e3" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_int() interface sets the return value of the application-defined function to be the 32-bit signed integer value given in the 2nd argument. The sqlite3_result_int64() interface sets the return value of the application-defined function to be the 64-bit signed integer value given in the 2nd argument.</source>
          <target state="translated">Интерфейс sqlite3_result_int()устанавливает возвращаемое значение функции,определяемой приложением,в качестве 32-битного знакового целого значения,заданного во 2-м аргументе.Интерфейс sqlite3_result_int64()устанавливает возвращаемое значение функции,определяемой приложением,в качестве 64-битного знакового целого значения,заданного во 2-м аргументе.</target>
        </trans-unit>
        <trans-unit id="6279fe7ee925bdc0e3f640e0b50cfa7f6bf20e52" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_null() interface sets the return value of the application-defined function to be NULL.</source>
          <target state="translated">Интерфейс sqlite3_result_null()устанавливает возвращаемое значение функции,определяемой приложением,в NULL.</target>
        </trans-unit>
        <trans-unit id="16d6bb7320a3240a335aa7ac5ed9b9a1d6945bef" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_pointer(C,P,T,D) interface sets the result to an SQL NULL value, just like &lt;a href=&quot;#sqlite3_result_blob&quot;&gt;sqlite3_result_null(C)&lt;/a&gt;, except that it also associates the host-language pointer P or type T with that NULL value such that the pointer can be retrieved within an &lt;a href=&quot;#sqlite3_create_function&quot;&gt;application-defined SQL function&lt;/a&gt; using &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_pointer()&lt;/a&gt;. If the D parameter is not NULL, then it is a pointer to a destructor for the P parameter. SQLite invokes D with P as its only argument when SQLite is finished with P. The T parameter should be a static string and preferably a string literal. The sqlite3_result_pointer() routine is part of the &lt;a href=&quot;bindptr&quot;&gt;pointer passing interface&lt;/a&gt; added for SQLite 3.20.0.</source>
          <target state="translated">Интерфейс sqlite3_result_pointer (C, P, T, D) устанавливает результат равным значению SQL NULL, так же, как &lt;a href=&quot;#sqlite3_result_blob&quot;&gt;sqlite3_result_null (C)&lt;/a&gt; , за исключением того, что он также связывает указатель языка хоста P или тип T с этим значением NULL, так что указатель могут быть получены в рамках определяемой &lt;a href=&quot;#sqlite3_create_function&quot;&gt;приложением функции SQL&lt;/a&gt; с помощью &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_pointer ()&lt;/a&gt; . Если параметр D не равен NULL, то это указатель на деструктор для параметра P. SQLite вызывает D с P в качестве единственного аргумента, когда SQLite завершает работу с P. Параметр T должен быть статической строкой и предпочтительно строковым литералом. Подпрограмма sqlite3_result_pointer () является частью &lt;a href=&quot;bindptr&quot;&gt;интерфейса передачи указателя,&lt;/a&gt; добавленного для SQLite 3.20.0.</target>
        </trans-unit>
        <trans-unit id="2141ed898fc1d1e35a1c686aae779faa61d104a5" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_pointer(C,P,T,D) interface sets the result to an SQL NULL value, just like &lt;a href=&quot;#sqlite3_result_blob&quot;&gt;sqlite3_result_null(C)&lt;/a&gt;, except that it also associates the host-language pointer P or type T with that NULL value such that the pointer can be retrieved within an &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL function&lt;/a&gt; using &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_pointer()&lt;/a&gt;. If the D parameter is not NULL, then it is a pointer to a destructor for the P parameter. SQLite invokes D with P as its only argument when SQLite is finished with P. The T parameter should be a static string and preferably a string literal. The sqlite3_result_pointer() routine is part of the &lt;a href=&quot;bindptr&quot;&gt;pointer passing interface&lt;/a&gt; added for SQLite 3.20.0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abeb9a4e536ac73c7793be889cbe18ade4a8329e" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_pointer(C,P,T,D) interface sets the result to an SQL NULL value, just like &lt;a href=&quot;result_blob&quot;&gt;sqlite3_result_null(C)&lt;/a&gt;, except that it also associates the host-language pointer P or type T with that NULL value such that the pointer can be retrieved within an &lt;a href=&quot;../appfunc&quot;&gt;application-defined SQL function&lt;/a&gt; using &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_pointer()&lt;/a&gt;. If the D parameter is not NULL, then it is a pointer to a destructor for the P parameter. SQLite invokes D with P as its only argument when SQLite is finished with P. The T parameter should be a static string and preferably a string literal. The sqlite3_result_pointer() routine is part of the &lt;a href=&quot;../bindptr&quot;&gt;pointer passing interface&lt;/a&gt; added for SQLite 3.20.0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="870667722e41d2c1c37c185e96c88c88778eea77" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_pointer(C,P,T,D) interface sets the result to an SQL NULL value, just like &lt;a href=&quot;result_blob&quot;&gt;sqlite3_result_null(C)&lt;/a&gt;, except that it also associates the host-language pointer P or type T with that NULL value such that the pointer can be retrieved within an &lt;a href=&quot;create_function&quot;&gt;application-defined SQL function&lt;/a&gt; using &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_pointer()&lt;/a&gt;. If the D parameter is not NULL, then it is a pointer to a destructor for the P parameter. SQLite invokes D with P as its only argument when SQLite is finished with P. The T parameter should be a static string and preferably a string literal. The sqlite3_result_pointer() routine is part of the &lt;a href=&quot;../bindptr&quot;&gt;pointer passing interface&lt;/a&gt; added for SQLite 3.20.0.</source>
          <target state="translated">Интерфейс sqlite3_result_pointer (C, P, T, D) устанавливает результат равным значению SQL NULL, так же, как &lt;a href=&quot;result_blob&quot;&gt;sqlite3_result_null (C)&lt;/a&gt; , за исключением того, что он также связывает указатель языка хоста P или тип T с этим значением NULL, так что указатель могут быть получены в рамках определяемой &lt;a href=&quot;create_function&quot;&gt;приложением функции SQL&lt;/a&gt; с помощью &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_pointer ()&lt;/a&gt; . Если параметр D не равен NULL, то это указатель на деструктор для параметра P. SQLite вызывает D с P в качестве единственного аргумента, когда SQLite завершает работу с P. Параметр T должен быть статической строкой и предпочтительно строковым литералом. Подпрограмма sqlite3_result_pointer () является частью &lt;a href=&quot;../bindptr&quot;&gt;интерфейса передачи указателя,&lt;/a&gt; добавленного для SQLite 3.20.0.</target>
        </trans-unit>
        <trans-unit id="a4e926904c44e1c10338c3ed629ffd93dee056e2" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_subtype(C,T) function causes the subtype of the result from the &lt;a href=&quot;#sqlite3_create_function&quot;&gt;application-defined SQL function&lt;/a&gt; with &lt;a href=&quot;#sqlite3_context&quot;&gt;sqlite3_context&lt;/a&gt; C to be the value T. Only the lower 8 bits of the subtype T are preserved in current versions of SQLite; higher order bits are discarded. The number of subtype bytes preserved by SQLite might increase in future releases of SQLite.</source>
          <target state="translated">Функция sqlite3_result_subtype (C, T) заставляет подтип результата от определяемой &lt;a href=&quot;#sqlite3_create_function&quot;&gt;приложением функции SQL&lt;/a&gt; с &lt;a href=&quot;#sqlite3_context&quot;&gt;sqlite3_context&lt;/a&gt; C быть значением T. В текущих версиях SQLite сохраняются только младшие 8 битов подтипа T; биты более высокого порядка отбрасываются. Количество байтов подтипа, сохраняемых SQLite, может увеличиться в будущих выпусках SQLite.</target>
        </trans-unit>
        <trans-unit id="14b620485a8968d2bc78129bd173a352a06dd552" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_subtype(C,T) function causes the subtype of the result from the &lt;a href=&quot;../appfunc&quot;&gt;application-defined SQL function&lt;/a&gt; with &lt;a href=&quot;context&quot;&gt;sqlite3_context&lt;/a&gt; C to be the value T. Only the lower 8 bits of the subtype T are preserved in current versions of SQLite; higher order bits are discarded. The number of subtype bytes preserved by SQLite might increase in future releases of SQLite.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b466179681aeddfbf231a03d679d2648006d92dc" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_subtype(C,T) function causes the subtype of the result from the &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL function&lt;/a&gt; with &lt;a href=&quot;#sqlite3_context&quot;&gt;sqlite3_context&lt;/a&gt; C to be the value T. Only the lower 8 bits of the subtype T are preserved in current versions of SQLite; higher order bits are discarded. The number of subtype bytes preserved by SQLite might increase in future releases of SQLite.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d462f96f6d4a97e8d351d18ac7f1c494815765c7" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_subtype(C,T) function causes the subtype of the result from the &lt;a href=&quot;create_function&quot;&gt;application-defined SQL function&lt;/a&gt; with &lt;a href=&quot;context&quot;&gt;sqlite3_context&lt;/a&gt; C to be the value T. Only the lower 8 bits of the subtype T are preserved in current versions of SQLite; higher order bits are discarded. The number of subtype bytes preserved by SQLite might increase in future releases of SQLite.</source>
          <target state="translated">Функция sqlite3_result_subtype (C, T) заставляет подтип результата от определяемой &lt;a href=&quot;create_function&quot;&gt;приложением функции SQL&lt;/a&gt; с &lt;a href=&quot;context&quot;&gt;sqlite3_context&lt;/a&gt; C быть значением T. В текущих версиях SQLite сохраняются только младшие 8 битов подтипа T; биты более высокого порядка отбрасываются. Количество байтов подтипа, сохраняемых SQLite, может увеличиться в будущих выпусках SQLite.</target>
        </trans-unit>
        <trans-unit id="8fc6882e24d42f347f5ab25fb2f2b1c639f2f020" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_text(), sqlite3_result_text16(), sqlite3_result_text16le(), and sqlite3_result_text16be() interfaces set the return value of the application-defined function to be a text string which is represented as UTF-8, UTF-16 native byte order, UTF-16 little endian, or UTF-16 big endian, respectively. The sqlite3_result_text64() interface sets the return value of an application-defined function to be a text string in an encoding specified by the fifth (and last) parameter, which must be one of &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF8&lt;/a&gt;, &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16&lt;/a&gt;, &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16BE&lt;/a&gt;, or &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16LE&lt;/a&gt;. SQLite takes the text result from the application from the 2nd parameter of the sqlite3_result_text* interfaces. If the 3rd parameter to the sqlite3_result_text* interfaces is negative, then SQLite takes result text from the 2nd parameter through the first zero character. If the 3rd parameter to the sqlite3_result_text* interfaces is non-negative, then as many bytes (not characters) of the text pointed to by the 2nd parameter are taken as the application-defined function result. If the 3rd parameter is non-negative, then it must be the byte offset into the string where the NUL terminator would appear if the string where NUL terminated. If any NUL characters occur in the string at a byte offset that is less than the value of the 3rd parameter, then the resulting string will contain embedded NULs and the result of expressions operating on strings with embedded NULs is undefined. If the 4th parameter to the sqlite3_result_text* interfaces or sqlite3_result_blob is a non-NULL pointer, then SQLite calls that function as the destructor on the text or BLOB result when it has finished using that result. If the 4th parameter to the sqlite3_result_text* interfaces or to sqlite3_result_blob is the special constant SQLITE_STATIC, then SQLite assumes that the text or BLOB result is in constant space and does not copy the content of the parameter nor call a destructor on the content when it has finished using that result. If the 4th parameter to the sqlite3_result_text* interfaces or sqlite3_result_blob is the special constant SQLITE_TRANSIENT then SQLite makes a copy of the result into space obtained from &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc()&lt;/a&gt; before it returns.</source>
          <target state="translated">Интерфейсы sqlite3_result_text (), sqlite3_result_text16 (), sqlite3_result_text16le () и sqlite3_result_text16be () устанавливают возвращаемое значение функции, определяемой приложением, как текстовую строку, которая представлена ​​как UTF-8, собственный порядок байтов UTF-16, UTF- 16 с прямым порядком байтов или UTF-16 с прямым порядком байтов соответственно. Интерфейс sqlite3_result_text64 () устанавливает возвращаемое значение функции, определяемой приложением, как текстовую строку в кодировке, заданной пятым (и последним) параметром, который должен быть одним из &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF8&lt;/a&gt; , &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16&lt;/a&gt; , &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16BE&lt;/a&gt; или &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16LE.&lt;/a&gt;. SQLite берет текстовый результат из приложения из 2-го параметра интерфейсов sqlite3_result_text *. Если 3-й параметр интерфейсов sqlite3_result_text * отрицательный, то SQLite принимает текст результата от 2-го параметра до первого нулевого символа. Если 3-й параметр интерфейсов sqlite3_result_text * неотрицателен, то в качестве результата функции, определяемой приложением, принимается столько же байтов (не символов) текста, на которое указывает 2-й параметр. Если 3-й параметр неотрицателен, то это должно быть байтовое смещение в строке, где появится терминатор NUL, если строка, в которой завершается NUL. Если какие-либо символы NUL встречаются в строке со смещением байта, меньшим, чем значение 3-го параметра,тогда результирующая строка будет содержать встроенные NUL, а результат выражений, работающих со строками со встроенными NUL, не определен. Если 4-й параметр для интерфейсов sqlite3_result_text * или sqlite3_result_blob является указателем, отличным от NULL, то SQLite вызывает эту функцию как деструктор для текста или результата BLOB, когда он закончил использовать этот результат. Если 4-й параметр для интерфейсов sqlite3_result_text * или sqlite3_result_blob является специальной константой SQLITE_STATIC, то SQLite предполагает, что текст или результат BLOB находится в постоянном пространстве и не копирует содержимое параметра и не вызывает деструктор для содержимого, когда он имеет закончил использовать этот результат.Если 4-й параметр для интерфейсов sqlite3_result_text * или sqlite3_result_blob - это специальная константа SQLITE_TRANSIENT, тогда SQLite копирует результат в пространство, полученное из&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc ()&lt;/a&gt; перед возвратом.</target>
        </trans-unit>
        <trans-unit id="ffc0515c64350de79930cdbbfae27bfbd23133bf" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_text(), sqlite3_result_text16(), sqlite3_result_text16le(), and sqlite3_result_text16be() interfaces set the return value of the application-defined function to be a text string which is represented as UTF-8, UTF-16 native byte order, UTF-16 little endian, or UTF-16 big endian, respectively. The sqlite3_result_text64() interface sets the return value of an application-defined function to be a text string in an encoding specified by the fifth (and last) parameter, which must be one of &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF8&lt;/a&gt;, &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16&lt;/a&gt;, &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16BE&lt;/a&gt;, or &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16LE&lt;/a&gt;. SQLite takes the text result from the application from the 2nd parameter of the sqlite3_result_text* interfaces. If the 3rd parameter to the sqlite3_result_text* interfaces is negative, then SQLite takes result text from the 2nd parameter through the first zero character. If the 3rd parameter to the sqlite3_result_text* interfaces is non-negative, then as many bytes (not characters) of the text pointed to by the 2nd parameter are taken as the application-defined function result. If the 3rd parameter is non-negative, then it must be the byte offset into the string where the NUL terminator would appear if the string where NUL terminated. If any NUL characters occur in the string at a byte offset that is less than the value of the 3rd parameter, then the resulting string will contain embedded NULs and the result of expressions operating on strings with embedded NULs is undefined. If the 4th parameter to the sqlite3_result_text* interfaces or sqlite3_result_blob is a non-NULL pointer, then SQLite calls that function as the destructor on the text or BLOB result when it has finished using that result. If the 4th parameter to the sqlite3_result_text* interfaces or to sqlite3_result_blob is the special constant SQLITE_STATIC, then SQLite assumes that the text or BLOB result is in constant space and does not copy the content of the parameter nor call a destructor on the content when it has finished using that result. If the 4th parameter to the sqlite3_result_text* interfaces or sqlite3_result_blob is the special constant SQLITE_TRANSIENT then SQLite makes a copy of the result into space obtained from &lt;a href=&quot;free&quot;&gt;sqlite3_malloc()&lt;/a&gt; before it returns.</source>
          <target state="translated">Интерфейсы sqlite3_result_text (), sqlite3_result_text16 (), sqlite3_result_text16le () и sqlite3_result_text16be () устанавливают возвращаемое значение функции, определяемой приложением, как текстовую строку, которая представлена ​​как UTF-8, собственный порядок байтов UTF-16, UTF- 16 с прямым порядком байтов или UTF-16 с прямым порядком байтов соответственно. Интерфейс sqlite3_result_text64 () устанавливает возвращаемое значение функции, определяемой приложением, как текстовую строку в кодировке, заданной пятым (и последним) параметром, который должен быть одним из &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF8&lt;/a&gt; , &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16&lt;/a&gt; , &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16BE&lt;/a&gt; или &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16LE.&lt;/a&gt;. SQLite берет текстовый результат из приложения из 2-го параметра интерфейсов sqlite3_result_text *. Если 3-й параметр интерфейсов sqlite3_result_text * отрицательный, то SQLite принимает текст результата от 2-го параметра до первого нулевого символа. Если 3-й параметр интерфейсов sqlite3_result_text * неотрицателен, то в качестве результата функции, определяемой приложением, принимается столько же байтов (не символов) текста, на которое указывает 2-й параметр. Если 3-й параметр неотрицателен, то это должно быть байтовое смещение в строке, где появится терминатор NUL, если строка, в которой завершается NUL. Если какие-либо символы NUL встречаются в строке со смещением байта, меньшим, чем значение 3-го параметра,тогда результирующая строка будет содержать встроенные NUL, а результат выражений, работающих со строками со встроенными NUL, не определен. Если 4-й параметр для интерфейсов sqlite3_result_text * или sqlite3_result_blob является указателем, отличным от NULL, то SQLite вызывает эту функцию как деструктор для текста или результата BLOB, когда он закончил использовать этот результат. Если 4-й параметр для интерфейсов sqlite3_result_text * или sqlite3_result_blob является специальной константой SQLITE_STATIC, то SQLite предполагает, что текст или результат BLOB находится в постоянном пространстве и не копирует содержимое параметра и не вызывает деструктор для содержимого, когда он имеет закончил использовать этот результат.Если 4-й параметр для интерфейсов sqlite3_result_text * или sqlite3_result_blob - это специальная константа SQLITE_TRANSIENT, тогда SQLite копирует результат в пространство, полученное из&lt;a href=&quot;free&quot;&gt;sqlite3_malloc ()&lt;/a&gt; перед возвратом.</target>
        </trans-unit>
        <trans-unit id="66d19148a84e04f07a639f83744f212454fd9d54" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_value() interface sets the result of the application-defined function to be a copy of the &lt;a href=&quot;#sqlite3_value&quot;&gt;unprotected sqlite3_value&lt;/a&gt; object specified by the 2nd parameter. The sqlite3_result_value() interface makes a copy of the &lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt; so that the &lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt; specified in the parameter may change or be deallocated after sqlite3_result_value() returns without harm. A &lt;a href=&quot;#sqlite3_value&quot;&gt;protected sqlite3_value&lt;/a&gt; object may always be used where an &lt;a href=&quot;#sqlite3_value&quot;&gt;unprotected sqlite3_value&lt;/a&gt; object is required, so either kind of &lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt; object can be used with this interface.</source>
          <target state="translated">Интерфейс sqlite3_result_value () устанавливает результат функции, определяемой приложением, как копию &lt;a href=&quot;#sqlite3_value&quot;&gt;незащищенного&lt;/a&gt; объекта sqlite3_value, указанного вторым параметром. Интерфейс sqlite3_result_value () делает копию &lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value,&lt;/a&gt; так что &lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value,&lt;/a&gt; указанное в параметре, может измениться или быть освобождено после того, как sqlite3_result_value () вернется без вреда. &lt;a href=&quot;#sqlite3_value&quot;&gt;Защищенный sqlite3_value&lt;/a&gt; объект всегда может быть использован , где &lt;a href=&quot;#sqlite3_value&quot;&gt;незащищенный sqlite3_value&lt;/a&gt; требуется объект, так как вид &lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt; объекта может быть использован с этим интерфейсом.</target>
        </trans-unit>
        <trans-unit id="9c611bb0b94d5204b93fd73ea02598841b3b449f" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_value() interface sets the result of the application-defined function to be a copy of the &lt;a href=&quot;value&quot;&gt;unprotected sqlite3_value&lt;/a&gt; object specified by the 2nd parameter. The sqlite3_result_value() interface makes a copy of the &lt;a href=&quot;value&quot;&gt;sqlite3_value&lt;/a&gt; so that the &lt;a href=&quot;value&quot;&gt;sqlite3_value&lt;/a&gt; specified in the parameter may change or be deallocated after sqlite3_result_value() returns without harm. A &lt;a href=&quot;value&quot;&gt;protected sqlite3_value&lt;/a&gt; object may always be used where an &lt;a href=&quot;value&quot;&gt;unprotected sqlite3_value&lt;/a&gt; object is required, so either kind of &lt;a href=&quot;value&quot;&gt;sqlite3_value&lt;/a&gt; object can be used with this interface.</source>
          <target state="translated">Интерфейс sqlite3_result_value () устанавливает результат функции, определяемой приложением, как копию &lt;a href=&quot;value&quot;&gt;незащищенного&lt;/a&gt; объекта sqlite3_value, указанного вторым параметром. Интерфейс sqlite3_result_value () делает копию &lt;a href=&quot;value&quot;&gt;sqlite3_value,&lt;/a&gt; так что &lt;a href=&quot;value&quot;&gt;sqlite3_value,&lt;/a&gt; указанное в параметре, может измениться или быть освобождено после того, как sqlite3_result_value () вернется без вреда. &lt;a href=&quot;value&quot;&gt;Защищенный sqlite3_value&lt;/a&gt; объект всегда может быть использован , где &lt;a href=&quot;value&quot;&gt;незащищенный sqlite3_value&lt;/a&gt; требуется объект, так как вид &lt;a href=&quot;value&quot;&gt;sqlite3_value&lt;/a&gt; объекта может быть использован с этим интерфейсом.</target>
        </trans-unit>
        <trans-unit id="3b2bde2ed5663531d681bf21defe3755de5aa926" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_zeroblob(C,N) and sqlite3_result_zeroblob64(C,N) interfaces set the result of the application-defined function to be a BLOB containing all zero bytes and N bytes in size.</source>
          <target state="translated">Интерфейсы sqlite3_result_zeroblob(C,N)и sqlite3_result_zeroblob64(C,N)устанавливают результат определяемой приложением функции в BLOB,содержащий все нулевые байты и N байт в размере.</target>
        </trans-unit>
        <trans-unit id="38bbbf7ab9a0945b32615ce5c77fecc3dda2b8bb" translate="yes" xml:space="preserve">
          <source>The sqlite3_rtree_geometry structure that the first argument to the xGeom callback points to has a structure shown below. The exact same sqlite3_rtree_geometry structure is used for every callback for same MATCH operator in the same query. The contents of the sqlite3_rtree_geometry structure are initialized by SQLite but are not subsequently modified. The callback is free to make changes to the pUser and xDelUser elements of the structure if desired.</source>
          <target state="translated">Структура sqlite3_rtree_geometry,на которую указывает первый аргумент обратного вызова xGeom,имеет структуру,показанную ниже.Точно такая же структура sqlite3_rtree_geometry используется для каждого обратного вызова для одного и того же MATCH-оператора в одном и том же запросе.Содержимое структуры sqlite3_rtree_geometry инициализируется SQLite,но в дальнейшем не изменяется.Обратный вызов свободен для внесения изменений в элементы структуры pUser и xDelUser при желании.</target>
        </trans-unit>
        <trans-unit id="23ca7c4bc54ebb3192ebcd695698caa11c607135" translate="yes" xml:space="preserve">
          <source>The sqlite3_rtree_query_callback() became available with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_5.html&quot;&gt;version 3.8.5&lt;/a&gt; (2014-06-04) and is the preferred interface. The sqlite3_rtree_geometry_callback() is an older and less flexible interface that is supported for backwards compatibility.</source>
          <target state="translated">Sqlite3_rtree_query_callback () стал доступен с &lt;a href=&quot;https://sqlite.org/releaselog/3_8_5.html&quot;&gt;версией&lt;/a&gt; SQLite 3.8.5 (2014-06-04) и является предпочтительным интерфейсом. Sqlite3_rtree_geometry_callback () - это более старый и менее гибкий интерфейс, который поддерживается для обратной совместимости.</target>
        </trans-unit>
        <trans-unit id="a4141688a761802a4dde7063e989412b5ba08576" translate="yes" xml:space="preserve">
          <source>The sqlite3_serialize(D,S,P,F) interface returns a pointer to memory that is a serialization of the S database on &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; D. If P is not a NULL pointer, then the size of the database in bytes is written into *P.</source>
          <target state="translated">Интерфейс sqlite3_serialize (D, S, P, F) возвращает указатель на память, который является сериализацией базы &lt;a href=&quot;#sqlite3&quot;&gt;данных&lt;/a&gt; S при подключении к базе данных D. Если P не является указателем NULL, то размер базы данных в байтах записывается в * П.</target>
        </trans-unit>
        <trans-unit id="fd8828a508df0b7bef3d1d62a2ae33a5520d58f6" translate="yes" xml:space="preserve">
          <source>The sqlite3_serialize(D,S,P,F) interface returns a pointer to memory that is a serialization of the S database on &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; D. If P is not a NULL pointer, then the size of the database in bytes is written into *P.</source>
          <target state="translated">Интерфейс sqlite3_serialize (D, S, P, F) возвращает указатель на память, который является сериализацией базы &lt;a href=&quot;sqlite3&quot;&gt;данных&lt;/a&gt; S при подключении к базе данных D. Если P не является указателем NULL, то размер базы данных в байтах записывается в * П.</target>
        </trans-unit>
        <trans-unit id="d9311ad5ed8e88f0e0e396fbe1a059c5d4e870f6" translate="yes" xml:space="preserve">
          <source>The sqlite3_set_auxdata(C,N,P,X) interface saves P as metadata for the N-th argument of the application-defined function. Subsequent calls to sqlite3_get_auxdata(C,N) return P from the most recent sqlite3_set_auxdata(C,N,P,X) call if the metadata is still valid or NULL if the metadata has been discarded. After each call to sqlite3_set_auxdata(C,N,P,X) where X is not NULL, SQLite will invoke the destructor function X with parameter P exactly once, when the metadata is discarded. SQLite is free to discard the metadata at any time, including:</source>
          <target state="translated">Интерфейс sqlite3_set_auxdata(C,N,P,X)сохраняет P в качестве метаданных для N-ого аргумента функции,определяемой приложением.Последующие вызовы sqlite3_get_auxdata(C,N)возвращают P из последнего вызова sqlite3_set_auxdata(C,N,P,X),если метаданные все еще действительны,или NULL,если метаданные были отброшены.После каждого вызова sqlite3_set_auxdata(C,N,P,X),где X не NULL,SQLite будет вызывать функцию деструктора X с параметром P ровно один раз,когда метаданные будут отброшены.SQLite свободен отбрасывать метаданные в любое время,в том числе:</target>
        </trans-unit>
        <trans-unit id="ce7e4094de25df6c5d0672255fe4f34354822777" translate="yes" xml:space="preserve">
          <source>The sqlite3_set_last_insert_rowid(D, R) method allows the application to set the value returned by calling sqlite3_last_insert_rowid(D) to R without inserting a row into the database.</source>
          <target state="translated">Метод sqlite3_set_last_insert_rowid(D,R)позволяет программе устанавливать значение,возвращаемое вызовом sqlite3_last_insert_rowid(D)в R без вставки строки в БД.</target>
        </trans-unit>
        <trans-unit id="e1bb92256471e00d9337dbe91acedaceec62010e" translate="yes" xml:space="preserve">
          <source>The sqlite3_sleep() function causes the current thread to suspend execution for at least a number of milliseconds specified in its parameter.</source>
          <target state="translated">Функция sqlite3_sleep()заставляет текущий поток приостановить выполнение не менее чем на несколько миллисекунд,указанных в его параметре.</target>
        </trans-unit>
        <trans-unit id="932dc970d1649bf3cbe1cd6e521c5a774af59735" translate="yes" xml:space="preserve">
          <source>The sqlite3_snapshot object records state information about an historical version of the database file so that it is possible to later open a new read transaction that sees that historical version of the database rather than the most recent version.</source>
          <target state="translated">Записи объекта sqlite3_snapshot содержат информацию об исторической версии файла базы данных,так что позже можно открыть новую прочитанную транзакцию,которая видит эту историческую версию базы данных,а не самую последнюю версию.</target>
        </trans-unit>
        <trans-unit id="242ec5992913a3f34748a4cb2f4099b50b723004" translate="yes" xml:space="preserve">
          <source>The sqlite3_snapshot_cmp(P1, P2) interface is used to compare the ages of two valid snapshot handles.</source>
          <target state="translated">Интерфейс sqlite3_snapshot_cmp(P1,P2)используется для сравнения возраста двух корректных обработчиков снимков.</target>
        </trans-unit>
        <trans-unit id="01e7a2ddf509d560437f8041b7f083cd66113cd5" translate="yes" xml:space="preserve">
          <source>The sqlite3_snprintf() routine is similar to &quot;snprintf()&quot; from the standard C library. The result is written into the buffer supplied as the second parameter whose size is given by the first parameter. Note that the order of the first two parameters is reversed from snprintf(). This is an historical accident that cannot be fixed without breaking backwards compatibility. Note also that sqlite3_snprintf() returns a pointer to its buffer instead of the number of characters actually written into the buffer. We admit that the number of characters written would be a more useful return value but we cannot change the implementation of sqlite3_snprintf() now without breaking compatibility.</source>
          <target state="translated">Рутина sqlite3_snprintf()аналогична &quot;snprintf()&quot; из стандартной библиотеки Си.Результат записывается в буфер,поставляемый в качестве второго параметра,размер которого задается первым параметром.Обратите внимание,что порядок следования первых двух параметров обратный от snprintf().Это исторический случай,который не может быть исправлен без нарушения обратной совместимости.Обратите также внимание,что sqlite3_snprintf()возвращает указатель на свой буфер вместо количества символов,фактически записанных в буфер.Мы признаем,что количество записанных символов было бы более полезным возвращаемым значением,но теперь мы не можем изменить реализацию sqlite3_snprintf()без нарушения совместимости.</target>
        </trans-unit>
        <trans-unit id="a1e7c63d0192b11455ed615eabf6f8b339d7c44c" translate="yes" xml:space="preserve">
          <source>The sqlite3_soft_heap_limit64() interface sets and/or queries the soft limit on the amount of heap memory that may be allocated by SQLite. SQLite strives to keep heap memory utilization below the soft heap limit by reducing the number of pages held in the page cache as heap memory usages approaches the limit. The soft heap limit is &quot;soft&quot; because even though SQLite strives to stay below the limit, it will exceed the limit rather than generate an &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOMEM&lt;/a&gt; error. In other words, the soft heap limit is advisory only.</source>
          <target state="translated">Интерфейс sqlite3_soft_heap_limit64 () устанавливает и / или запрашивает мягкий предел объема памяти кучи, который может быть выделен SQLite. SQLite стремится поддерживать использование памяти кучи ниже предела мягкой кучи, уменьшая количество страниц, хранящихся в кеше страниц, по мере приближения использования памяти кучи к пределу. Предел мягкой кучи является &amp;laquo;мягким&amp;raquo;, потому что даже если SQLite стремится оставаться ниже лимита, он превысит лимит, а не сгенерирует ошибку &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOMEM&lt;/a&gt; . Другими словами, ограничение мягкой кучи носит рекомендательный характер.</target>
        </trans-unit>
        <trans-unit id="d5aefe7f58cf6098f950ef6aaad46d0524e32f68" translate="yes" xml:space="preserve">
          <source>The sqlite3_soft_heap_limit64() interface sets and/or queries the soft limit on the amount of heap memory that may be allocated by SQLite. SQLite strives to keep heap memory utilization below the soft heap limit by reducing the number of pages held in the page cache as heap memory usages approaches the limit. The soft heap limit is &quot;soft&quot; because even though SQLite strives to stay below the limit, it will exceed the limit rather than generate an &lt;a href=&quot;../rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt; error. In other words, the soft heap limit is advisory only.</source>
          <target state="translated">Интерфейс sqlite3_soft_heap_limit64 () устанавливает и / или запрашивает мягкий предел объема памяти кучи, который может быть выделен SQLite. SQLite стремится поддерживать использование памяти кучи ниже предела мягкой кучи, уменьшая количество страниц, хранящихся в кеше страниц, по мере приближения использования памяти кучи к пределу. Предел мягкой кучи является &amp;laquo;мягким&amp;raquo;, потому что даже если SQLite стремится оставаться ниже лимита, он превысит лимит, а не сгенерирует ошибку &lt;a href=&quot;../rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt; . Другими словами, ограничение мягкой кучи носит рекомендательный характер.</target>
        </trans-unit>
        <trans-unit id="b94ad72c9e1e61f387a8b9571668f6ee1d93f6d1" translate="yes" xml:space="preserve">
          <source>The sqlite3_sql(P) interface returns a pointer to a copy of the UTF-8 SQL text used to create &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; P if P was created by &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v3()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16_v2()&lt;/a&gt;, or &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16_v3()&lt;/a&gt;. The sqlite3_expanded_sql(P) interface returns a pointer to a UTF-8 string containing the SQL text of prepared statement P with &lt;a href=&quot;lang_expr#varparam&quot;&gt;bound parameters&lt;/a&gt; expanded. The sqlite3_normalized_sql(P) interface returns a pointer to a UTF-8 string containing the normalized SQL text of prepared statement P. The semantics used to normalize a SQL statement are unspecified and subject to change. At a minimum, literal values will be replaced with suitable placeholders.</source>
          <target state="translated">Интерфейс sqlite3_sql (P) возвращает указатель на копию текста SQL UTF-8, используемого для создания &lt;a href=&quot;#sqlite3_stmt&quot;&gt;подготовленного оператора&lt;/a&gt; P, если P был создан с помощью &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v3 ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16_v2 ()&lt;/a&gt; или &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16_v3 ()&lt;/a&gt; . Интерфейс sqlite3_expanded_sql (P) возвращает указатель на строку UTF-8, содержащую текст SQL подготовленного оператора P с расширенными &lt;a href=&quot;lang_expr#varparam&quot;&gt;связанными параметрами&lt;/a&gt; . Интерфейс sqlite3_normalized_sql (P) возвращает указатель на строку UTF-8, содержащую нормализованный текст SQL подготовленного оператора P. Семантика, используемая для нормализации оператора SQL, не указана и может быть изменена. Как минимум, буквальные значения будут заменены подходящими заполнителями.</target>
        </trans-unit>
        <trans-unit id="45ba0cce80e217739aee37fc8f257b9f4497c286" translate="yes" xml:space="preserve">
          <source>The sqlite3_sql(P) interface returns a pointer to a copy of the UTF-8 SQL text used to create &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; P if P was created by &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt;, &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v3()&lt;/a&gt;, &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16_v2()&lt;/a&gt;, or &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16_v3()&lt;/a&gt;. The sqlite3_expanded_sql(P) interface returns a pointer to a UTF-8 string containing the SQL text of prepared statement P with &lt;a href=&quot;../lang_expr#varparam&quot;&gt;bound parameters&lt;/a&gt; expanded. The sqlite3_normalized_sql(P) interface returns a pointer to a UTF-8 string containing the normalized SQL text of prepared statement P. The semantics used to normalize a SQL statement are unspecified and subject to change. At a minimum, literal values will be replaced with suitable placeholders.</source>
          <target state="translated">Интерфейс sqlite3_sql (P) возвращает указатель на копию текста SQL UTF-8, используемого для создания &lt;a href=&quot;stmt&quot;&gt;подготовленного оператора&lt;/a&gt; P, если P был создан с помощью &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; , &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v3 ()&lt;/a&gt; , &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16_v2 ()&lt;/a&gt; или &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16_v3 ()&lt;/a&gt; . Интерфейс sqlite3_expanded_sql (P) возвращает указатель на строку UTF-8, содержащую текст SQL подготовленного оператора P с расширенными &lt;a href=&quot;../lang_expr#varparam&quot;&gt;связанными параметрами&lt;/a&gt; . Интерфейс sqlite3_normalized_sql (P) возвращает указатель на строку UTF-8, содержащую нормализованный текст SQL подготовленного оператора P. Семантика, используемая для нормализации оператора SQL, не указана и может быть изменена. Как минимум, буквальные значения будут заменены подходящими заполнителями.</target>
        </trans-unit>
        <trans-unit id="e775091a2d75ef8eec628ca58240bb3a4c44f41a" translate="yes" xml:space="preserve">
          <source>The sqlite3_status() and sqlite3_status64() routines return SQLITE_OK on success and a non-zero &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; on failure.</source>
          <target state="translated">Подпрограммы sqlite3_status () и sqlite3_status64 () возвращают SQLITE_OK в случае успеха и ненулевой &lt;a href=&quot;../rescode&quot;&gt;код ошибки&lt;/a&gt; в случае ошибки.</target>
        </trans-unit>
        <trans-unit id="08017cba5dea56fb38bd261f36812b68e5da595b" translate="yes" xml:space="preserve">
          <source>The sqlite3_status() and sqlite3_status64() routines return SQLITE_OK on success and a non-zero &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; on failure.</source>
          <target state="translated">Подпрограммы sqlite3_status () и sqlite3_status64 () возвращают SQLITE_OK в случае успеха и ненулевой &lt;a href=&quot;rescode&quot;&gt;код ошибки&lt;/a&gt; в случае ошибки.</target>
        </trans-unit>
        <trans-unit id="8844a5c0b1eb32242054752c1e25f36f36feae1a" translate="yes" xml:space="preserve">
          <source>The sqlite3_step() interface returns SQLITE_BUSY if it is unable to commit a change because of a lock</source>
          <target state="translated">Интерфейс sqlite3_step()возвращает SQLITE_BUSY,если он не может зафиксировать изменение из-за блокировки</target>
        </trans-unit>
        <trans-unit id="aadfbac7c6cbfe9d27468ec7c9a622af76c3660e" translate="yes" xml:space="preserve">
          <source>The sqlite3_step() routine return SQLITE_ROW if it is returning a single row of the result set, or SQLITE_DONE if execution has completed, either normally or due to an error. It might also return SQLITE_BUSY if it is unable to open the database file. If the return value is SQLITE_ROW, then the following routines can be used to extract information about that row of the result set:</source>
          <target state="translated">Рутина sqlite3_step()возвращает SQLITE_ROW,если она возвращает одну строку результирующего множества,или SQLITE_DONE,если выполнение завершилось,либо нормально,либо из-за ошибки.Она также может вернуть SQLITE_BUSY,если не может открыть файл базы данных.Если возвращаемое значение-SQLITE_ROW,то для извлечения информации об этой строке результирующего множества можно воспользоваться следующими подпрограммами:</target>
        </trans-unit>
        <trans-unit id="68ecf4c95ec171ac99c79d0f7b7218a0a2a7996e" translate="yes" xml:space="preserve">
          <source>The sqlite3_stmt_busy(S) interface returns true (non-zero) if the &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; S has been stepped at least once using &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step(S)&lt;/a&gt; but has neither run to completion (returned &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_DONE&lt;/a&gt; from &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step(S)&lt;/a&gt;) nor been reset using &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset(S)&lt;/a&gt;. The sqlite3_stmt_busy(S) interface returns false if S is a NULL pointer. If S is not a NULL pointer and is not a pointer to a valid &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; object, then the behavior is undefined and probably undesirable.</source>
          <target state="translated">Интерфейс sqlite3_stmt_busy (S) возвращает истину (ненулевое значение), если &lt;a href=&quot;#sqlite3_stmt&quot;&gt;подготовленный оператор&lt;/a&gt; S был выполнен по крайней мере один раз с использованием &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step (S),&lt;/a&gt; но не был выполнен до завершения (возвращен &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_DONE&lt;/a&gt; из &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step (S)&lt;/a&gt; ) и не был сброшен с помощью &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset ( S)&lt;/a&gt; . Интерфейс sqlite3_stmt_busy (S) возвращает false, если S является указателем NULL. Если S не является указателем NULL и не является указателем на действительный &lt;a href=&quot;#sqlite3_stmt&quot;&gt;подготовленный&lt;/a&gt; объект оператора , то поведение не определено и, вероятно, нежелательно.</target>
        </trans-unit>
        <trans-unit id="30e9a2351b8f1f389c8c1f5ed3bb5643292d6719" translate="yes" xml:space="preserve">
          <source>The sqlite3_stmt_busy(S) interface returns true (non-zero) if the &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; S has been stepped at least once using &lt;a href=&quot;step&quot;&gt;sqlite3_step(S)&lt;/a&gt; but has neither run to completion (returned &lt;a href=&quot;../rescode#done&quot;&gt;SQLITE_DONE&lt;/a&gt; from &lt;a href=&quot;step&quot;&gt;sqlite3_step(S)&lt;/a&gt;) nor been reset using &lt;a href=&quot;reset&quot;&gt;sqlite3_reset(S)&lt;/a&gt;. The sqlite3_stmt_busy(S) interface returns false if S is a NULL pointer. If S is not a NULL pointer and is not a pointer to a valid &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; object, then the behavior is undefined and probably undesirable.</source>
          <target state="translated">Интерфейс sqlite3_stmt_busy (S) возвращает истину (ненулевое значение), если &lt;a href=&quot;stmt&quot;&gt;подготовленный оператор&lt;/a&gt; S был выполнен по крайней мере один раз с использованием &lt;a href=&quot;step&quot;&gt;sqlite3_step (S),&lt;/a&gt; но не был выполнен до завершения (возвращен &lt;a href=&quot;../rescode#done&quot;&gt;SQLITE_DONE&lt;/a&gt; из &lt;a href=&quot;step&quot;&gt;sqlite3_step (S)&lt;/a&gt; ) и не был сброшен с помощью &lt;a href=&quot;reset&quot;&gt;sqlite3_reset ( S)&lt;/a&gt; . Интерфейс sqlite3_stmt_busy (S) возвращает false, если S является указателем NULL. Если S не является указателем NULL и не является указателем на действительный &lt;a href=&quot;stmt&quot;&gt;подготовленный&lt;/a&gt; объект оператора , то поведение не определено и, вероятно, нежелательно.</target>
        </trans-unit>
        <trans-unit id="90793b88a180a777be3c4f2d53caba9bba6af112" translate="yes" xml:space="preserve">
          <source>The sqlite3_stmt_isexplain(S) interface returns 1 if the prepared statement S is an EXPLAIN statement, or 2 if the statement S is an EXPLAIN QUERY PLAN. The sqlite3_stmt_isexplain(S) interface returns 0 if S is an ordinary statement or a NULL pointer.</source>
          <target state="translated">Интерфейс sqlite3_stmt_isexplain(S)возвращает 1,если подготовленный оператор S является оператором EXPLAIN,или 2,если оператор S является оператором EXPLAIN QUERY PLAN.Интерфейс sqlite3_stmt_isexplain(S)возвращает 0,если оператор S является обычным оператором или указателем NULL.</target>
        </trans-unit>
        <trans-unit id="959c0941832b79e09f96d36c140b66399c0579af" translate="yes" xml:space="preserve">
          <source>The sqlite3_stmt_readonly(X) interface returns true (non-zero) if and only if the &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; X makes no direct changes to the content of the database file.</source>
          <target state="translated">Интерфейс sqlite3_stmt_readonly (X) возвращает истину (ненулевое значение) тогда и только тогда, когда &lt;a href=&quot;#sqlite3_stmt&quot;&gt;подготовленный оператор&lt;/a&gt; X не вносит прямых изменений в содержимое файла базы данных.</target>
        </trans-unit>
        <trans-unit id="ac5964bf97c9886f6e336072767ae1979506a3cb" translate="yes" xml:space="preserve">
          <source>The sqlite3_stmt_readonly(X) interface returns true (non-zero) if and only if the &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; X makes no direct changes to the content of the database file.</source>
          <target state="translated">Интерфейс sqlite3_stmt_readonly (X) возвращает истину (ненулевое значение) тогда и только тогда, когда &lt;a href=&quot;stmt&quot;&gt;подготовленный оператор&lt;/a&gt; X не вносит прямых изменений в содержимое файла базы данных.</target>
        </trans-unit>
        <trans-unit id="46d5fb0793437180a07e66953d44f2fda8b50c88" translate="yes" xml:space="preserve">
          <source>The sqlite3_str object is created using &lt;a href=&quot;#sqlite3_str_new&quot;&gt;sqlite3_str_new()&lt;/a&gt;.</source>
          <target state="translated">Объект sqlite3_str создается с помощью &lt;a href=&quot;#sqlite3_str_new&quot;&gt;sqlite3_str_new ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="58bd138876e3ab72759402d62d6773f8d1b76c11" translate="yes" xml:space="preserve">
          <source>The sqlite3_str object is created using &lt;a href=&quot;str_new&quot;&gt;sqlite3_str_new()&lt;/a&gt;.</source>
          <target state="translated">Объект sqlite3_str создается с помощью &lt;a href=&quot;str_new&quot;&gt;sqlite3_str_new ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="709d2526ae98679c1dec5db36348e5bd59a7a2cf" translate="yes" xml:space="preserve">
          <source>The sqlite3_str object is destroyed and the string it created is returned using the &lt;a href=&quot;#sqlite3_str_finish&quot;&gt;sqlite3_str_finish()&lt;/a&gt; interface.</source>
          <target state="translated">Объект sqlite3_str уничтожается, а созданная им строка возвращается с использованием интерфейса &lt;a href=&quot;#sqlite3_str_finish&quot;&gt;sqlite3_str_finish ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="17671bb4cfc45e29421b502c0583cd6458abaa8b" translate="yes" xml:space="preserve">
          <source>The sqlite3_str object is destroyed and the string it created is returned using the &lt;a href=&quot;str_finish&quot;&gt;sqlite3_str_finish()&lt;/a&gt; interface.</source>
          <target state="translated">Объект sqlite3_str уничтожается, а созданная им строка возвращается с использованием интерфейса &lt;a href=&quot;str_finish&quot;&gt;sqlite3_str_finish ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9c1806bb938001e1be73835ffc5a99f71985fc2b" translate="yes" xml:space="preserve">
          <source>The sqlite3_table_column_metadata(X,D,T,C,....) routine returns information about column C of table T in database D on &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; X. The sqlite3_table_column_metadata() interface returns SQLITE_OK and fills in the non-NULL pointers in the final five arguments with appropriate values if the specified column exists. The sqlite3_table_column_metadata() interface returns SQLITE_ERROR and if the specified column does not exist. If the column-name parameter to sqlite3_table_column_metadata() is a NULL pointer, then this routine simply checks for the existence of the table and returns SQLITE_OK if the table exists and SQLITE_ERROR if it does not. If the table name parameter T in a call to sqlite3_table_column_metadata(X,D,T,C,...) is NULL then the result is undefined behavior.</source>
          <target state="translated">Подпрограмма sqlite3_table_column_metadata (X, D, T, C, ....) возвращает информацию о столбце C таблицы T в базе данных D при &lt;a href=&quot;#sqlite3&quot;&gt;подключении к базе данных&lt;/a&gt; X. Интерфейс sqlite3_table_column_metadata () возвращает SQLITE_OK и заполняет указатели, отличные от NULL в последние пять аргументов с соответствующими значениями, если указанный столбец существует. Интерфейс sqlite3_table_column_metadata () возвращает SQLITE_ERROR и, если указанный столбец не существует. Если параметр имени столбца для sqlite3_table_column_metadata () является указателем NULL, то эта процедура просто проверяет наличие таблицы и возвращает SQLITE_OK, если таблица существует, и SQLITE_ERROR, если нет. Если параметр имени таблицы T в вызове sqlite3_table_column_metadata (X, D, T, C, ...) равен NULL, то результатом будет неопределенное поведение.</target>
        </trans-unit>
        <trans-unit id="1a9220a600a9fb3a4c23d26f17dc0f839445989b" translate="yes" xml:space="preserve">
          <source>The sqlite3_table_column_metadata(X,D,T,C,....) routine returns information about column C of table T in database D on &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; X. The sqlite3_table_column_metadata() interface returns SQLITE_OK and fills in the non-NULL pointers in the final five arguments with appropriate values if the specified column exists. The sqlite3_table_column_metadata() interface returns SQLITE_ERROR if the specified column does not exist. If the column-name parameter to sqlite3_table_column_metadata() is a NULL pointer, then this routine simply checks for the existence of the table and returns SQLITE_OK if the table exists and SQLITE_ERROR if it does not. If the table name parameter T in a call to sqlite3_table_column_metadata(X,D,T,C,...) is NULL then the result is undefined behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14811f3f6309b7a46fb7b07e8c86e4e522dd9f2d" translate="yes" xml:space="preserve">
          <source>The sqlite3_table_column_metadata(X,D,T,C,....) routine returns information about column C of table T in database D on &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; X. The sqlite3_table_column_metadata() interface returns SQLITE_OK and fills in the non-NULL pointers in the final five arguments with appropriate values if the specified column exists. The sqlite3_table_column_metadata() interface returns SQLITE_ERROR and if the specified column does not exist. If the column-name parameter to sqlite3_table_column_metadata() is a NULL pointer, then this routine simply checks for the existence of the table and returns SQLITE_OK if the table exists and SQLITE_ERROR if it does not. If the table name parameter T in a call to sqlite3_table_column_metadata(X,D,T,C,...) is NULL then the result is undefined behavior.</source>
          <target state="translated">Подпрограмма sqlite3_table_column_metadata (X, D, T, C, ....) возвращает информацию о столбце C таблицы T в базе данных D при &lt;a href=&quot;sqlite3&quot;&gt;подключении к базе данных&lt;/a&gt; X. Интерфейс sqlite3_table_column_metadata () возвращает SQLITE_OK и заполняет указатели, отличные от NULL в последние пять аргументов с соответствующими значениями, если указанный столбец существует. Интерфейс sqlite3_table_column_metadata () возвращает SQLITE_ERROR и, если указанный столбец не существует. Если параметр имени столбца для sqlite3_table_column_metadata () является указателем NULL, то эта процедура просто проверяет наличие таблицы и возвращает SQLITE_OK, если таблица существует, и SQLITE_ERROR, если нет. Если параметр имени таблицы T в вызове sqlite3_table_column_metadata (X, D, T, C, ...) равен NULL, то результатом будет неопределенное поведение.</target>
        </trans-unit>
        <trans-unit id="1c11863e106d03a5d69e9f5e41b5782d50d0ba8d" translate="yes" xml:space="preserve">
          <source>The sqlite3_table_column_metadata(X,D,T,C,....) routine returns information about column C of table T in database D on &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; X. The sqlite3_table_column_metadata() interface returns SQLITE_OK and fills in the non-NULL pointers in the final five arguments with appropriate values if the specified column exists. The sqlite3_table_column_metadata() interface returns SQLITE_ERROR if the specified column does not exist. If the column-name parameter to sqlite3_table_column_metadata() is a NULL pointer, then this routine simply checks for the existence of the table and returns SQLITE_OK if the table exists and SQLITE_ERROR if it does not. If the table name parameter T in a call to sqlite3_table_column_metadata(X,D,T,C,...) is NULL then the result is undefined behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6f71c56bc991c72ab07825bab1be2b2926a3b41" translate="yes" xml:space="preserve">
          <source>The sqlite3_test_control() interface is used to read out internal state of SQLite and to inject faults into SQLite for testing purposes. The first parameter is an operation code that determines the number, meaning, and operation of all subsequent parameters.</source>
          <target state="translated">Интерфейс sqlite3_test_control()используется для считывания внутреннего состояния SQLite и внесения ошибок в SQLite для тестирования.Первый параметр-это код операции,определяющий количество,значение и работу всех последующих параметров.</target>
        </trans-unit>
        <trans-unit id="5082c0760e0921243970779b3672c52191342376" translate="yes" xml:space="preserve">
          <source>The sqlite3_threadsafe() function returns zero if and only if SQLite was compiled with mutexing code omitted due to the &lt;a href=&quot;../compile#threadsafe&quot;&gt;SQLITE_THREADSAFE&lt;/a&gt; compile-time option being set to 0.</source>
          <target state="translated">Функция sqlite3_threadsafe () возвращает ноль тогда и только тогда, когда SQLite был скомпилирован с опущенным кодом мьютекса из-за того, что для параметра &lt;a href=&quot;../compile#threadsafe&quot;&gt;времени&lt;/a&gt; компиляции SQLITE_THREADSAFE установлено значение 0.</target>
        </trans-unit>
        <trans-unit id="a21f6ed50c99e2696e83c890474c76bf238b4d0d" translate="yes" xml:space="preserve">
          <source>The sqlite3_threadsafe() function returns zero if and only if SQLite was compiled with mutexing code omitted due to the &lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE&lt;/a&gt; compile-time option being set to 0.</source>
          <target state="translated">Функция sqlite3_threadsafe () возвращает ноль тогда и только тогда, когда SQLite был скомпилирован с опущенным кодом мьютекса из-за того, что для параметра &lt;a href=&quot;compile#threadsafe&quot;&gt;времени&lt;/a&gt; компиляции SQLITE_THREADSAFE установлено значение 0.</target>
        </trans-unit>
        <trans-unit id="bda43267162a3774849f8ead3ae62d9dfab76a35" translate="yes" xml:space="preserve">
          <source>The sqlite3_trace() callbacks occur before each statement is executed, not when the statement is compiled.</source>
          <target state="translated">Обратные вызовы sqlite3_trace()происходят перед выполнением каждого оператора,а не при компиляции оператора.</target>
        </trans-unit>
        <trans-unit id="1ffc76f2d02a8dff2313298df0260161ca209b9b" translate="yes" xml:space="preserve">
          <source>The sqlite3_trace_v2() interface is intended to replace the legacy interfaces &lt;a href=&quot;#sqlite3_profile&quot;&gt;sqlite3_trace()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_profile&quot;&gt;sqlite3_profile()&lt;/a&gt;, both of which are deprecated.</source>
          <target state="translated">Интерфейс sqlite3_trace_v2 () предназначен для замены устаревших интерфейсов &lt;a href=&quot;#sqlite3_profile&quot;&gt;sqlite3_trace ()&lt;/a&gt; и &lt;a href=&quot;#sqlite3_profile&quot;&gt;sqlite3_profile ()&lt;/a&gt; , оба из которых устарели.</target>
        </trans-unit>
        <trans-unit id="377ad2a0a4bd528d9de5514af64376270faee9cf" translate="yes" xml:space="preserve">
          <source>The sqlite3_trace_v2() interface is intended to replace the legacy interfaces &lt;a href=&quot;profile&quot;&gt;sqlite3_trace()&lt;/a&gt; and &lt;a href=&quot;profile&quot;&gt;sqlite3_profile()&lt;/a&gt;, both of which are deprecated.</source>
          <target state="translated">Интерфейс sqlite3_trace_v2 () предназначен для замены устаревших интерфейсов &lt;a href=&quot;profile&quot;&gt;sqlite3_trace ()&lt;/a&gt; и &lt;a href=&quot;profile&quot;&gt;sqlite3_profile ()&lt;/a&gt; , оба из которых устарели.</target>
        </trans-unit>
        <trans-unit id="423d6e23fa8d1a2ce23d8999f3685bde80941a45" translate="yes" xml:space="preserve">
          <source>The sqlite3_trace_v2(D,M,X,P) interface registers a trace callback function X against &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; D, using property mask M and context pointer P. If the X callback is NULL or if the M mask is zero, then tracing is disabled. The M argument should be the bitwise OR-ed combination of zero or more &lt;a href=&quot;#SQLITE_TRACE&quot;&gt;SQLITE_TRACE&lt;/a&gt; constants.</source>
          <target state="translated">Интерфейс sqlite3_trace_v2 (D, M, X, P) регистрирует функцию обратного вызова трассировки X для &lt;a href=&quot;#sqlite3&quot;&gt;соединения&lt;/a&gt; с базой данных D, используя маску свойств M и указатель контекста P. Если обратный вызов X равен NULL или если маска M равна нулю, трассировка отключена. . Аргумент M должен быть комбинацией нуля или более констант &lt;a href=&quot;#SQLITE_TRACE&quot;&gt;SQLITE_TRACE, созданной методом&lt;/a&gt; побитового ИЛИ .</target>
        </trans-unit>
        <trans-unit id="c43af05001b13bd414732905f7825bbbb97dce0a" translate="yes" xml:space="preserve">
          <source>The sqlite3_trace_v2(D,M,X,P) interface registers a trace callback function X against &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; D, using property mask M and context pointer P. If the X callback is NULL or if the M mask is zero, then tracing is disabled. The M argument should be the bitwise OR-ed combination of zero or more &lt;a href=&quot;c_trace&quot;&gt;SQLITE_TRACE&lt;/a&gt; constants.</source>
          <target state="translated">Интерфейс sqlite3_trace_v2 (D, M, X, P) регистрирует функцию обратного вызова трассировки X для &lt;a href=&quot;sqlite3&quot;&gt;соединения&lt;/a&gt; с базой данных D, используя маску свойств M и указатель контекста P. Если обратный вызов X равен NULL или если маска M равна нулю, трассировка отключена. . Аргумент M должен быть комбинацией нуля или более констант &lt;a href=&quot;c_trace&quot;&gt;SQLITE_TRACE, созданной методом&lt;/a&gt; побитового ИЛИ .</target>
        </trans-unit>
        <trans-unit id="99807c4e04d2f72ca0bf7cd79e0b0ccb8d1cdec6" translate="yes" xml:space="preserve">
          <source>The sqlite3_update_hook() interface registers a callback function with the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; identified by the first argument to be invoked whenever a row is updated, inserted or deleted in a &lt;a href=&quot;rowidtable&quot;&gt;rowid table&lt;/a&gt;. Any callback set by a previous call to this function for the same database connection is overridden.</source>
          <target state="translated">Интерфейс sqlite3_update_hook () регистрирует функцию обратного вызова с &lt;a href=&quot;#sqlite3&quot;&gt;подключением&lt;/a&gt; к базе данных, идентифицированным первым аргументом, которая будет вызываться всякий раз, когда строка обновляется, вставляется или удаляется в &lt;a href=&quot;rowidtable&quot;&gt;таблице rowid&lt;/a&gt; . Любой обратный вызов, установленный предыдущим вызовом этой функции для того же подключения к базе данных, отменяется.</target>
        </trans-unit>
        <trans-unit id="f13c4b8c3d5b462597549f85fa26ca8898f02c2a" translate="yes" xml:space="preserve">
          <source>The sqlite3_update_hook() interface registers a callback function with the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; identified by the first argument to be invoked whenever a row is updated, inserted or deleted in a &lt;a href=&quot;../rowidtable&quot;&gt;rowid table&lt;/a&gt;. Any callback set by a previous call to this function for the same database connection is overridden.</source>
          <target state="translated">Интерфейс sqlite3_update_hook () регистрирует функцию обратного вызова с &lt;a href=&quot;sqlite3&quot;&gt;подключением&lt;/a&gt; к базе данных, идентифицированным первым аргументом, которая будет вызываться всякий раз, когда строка обновляется, вставляется или удаляется в &lt;a href=&quot;../rowidtable&quot;&gt;таблице rowid&lt;/a&gt; . Любой обратный вызов, установленный предыдущим вызовом этой функции для того же подключения к базе данных, отменяется.</target>
        </trans-unit>
        <trans-unit id="299c5d8dbf8312233913ebdfb7abe735c08c4d12" translate="yes" xml:space="preserve">
          <source>The sqlite3_update_hook(D,C,P) function returns the P argument from the previous call on the same &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; D, or NULL for the first call on D.</source>
          <target state="translated">Функция sqlite3_update_hook (D, C, P) возвращает аргумент P из предыдущего вызова в том же &lt;a href=&quot;#sqlite3&quot;&gt;соединении с базой данных&lt;/a&gt; D или NULL для первого вызова D.</target>
        </trans-unit>
        <trans-unit id="b7813b4170b9b916299f8d86a0cb2ffbf096aaa5" translate="yes" xml:space="preserve">
          <source>The sqlite3_update_hook(D,C,P) function returns the P argument from the previous call on the same &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; D, or NULL for the first call on D.</source>
          <target state="translated">Функция sqlite3_update_hook (D, C, P) возвращает аргумент P из предыдущего вызова в том же &lt;a href=&quot;sqlite3&quot;&gt;соединении с базой данных&lt;/a&gt; D или NULL для первого вызова D.</target>
        </trans-unit>
        <trans-unit id="9e5c2049439d88f4f1e900d8863f9c93f3ca0ab3" translate="yes" xml:space="preserve">
          <source>The sqlite3_uri_boolean(F,P,B) routine assumes that P is a boolean parameter and returns true (1) or false (0) according to the value of P. The sqlite3_uri_boolean(F,P,B) routine returns true (1) if the value of query parameter P is one of &quot;yes&quot;, &quot;true&quot;, or &quot;on&quot; in any case or if the value begins with a non-zero number. The sqlite3_uri_boolean(F,P,B) routines returns false (0) if the value of query parameter P is one of &quot;no&quot;, &quot;false&quot;, or &quot;off&quot; in any case or if the value begins with a numeric zero. If P is not a query parameter on F or if the value of P does not match any of the above, then sqlite3_uri_boolean(F,P,B) returns (B!=0).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07d5885fa75b35071ed61bef7a0d72dc8a43c3b7" translate="yes" xml:space="preserve">
          <source>The sqlite3_uri_boolean(F,P,B) routine assumes that P is a boolean parameter and returns true (1) or false (0) according to the value of P. The sqlite3_uri_boolean(F,P,B) routine returns true (1) if the value of query parameter P is one of &quot;yes&quot;, &quot;true&quot;, or &quot;on&quot; in any case or if the value begins with a non-zero number. The sqlite3_uri_boolean(F,P,B) routines returns false (0) if the value of query parameter P is one of &quot;no&quot;, &quot;false&quot;, or &quot;off&quot; in any case or if the value begins with a numeric zero. If P is not a query parameter on F or if the value of P is does not match any of the above, then sqlite3_uri_boolean(F,P,B) returns (B!=0).</source>
          <target state="translated">Рутина sqlite3_uri_boolean(F,P,B)предполагает,что P является булевым параметром,и возвращает true (1)или false (0)в соответствии со значением P.Рутина sqlite3_uri_boolean(F,P,B)возвращает true (1),если значение параметра запроса P в любом случае одно из &quot;yes&quot;,&quot;true&quot; или &quot;on&quot;,или если значение начинается с ненулевого числа.Рутина sqlite3_uri_boolean(F,P,B)возвращает false (0),если значение параметра запроса P в любом случае одно из &quot;no&quot;,&quot;false&quot; или &quot;off&quot;,или если значение начинается с числового нуля.Если P не является параметром запроса на F или если значение P не совпадает ни с одним из вышеперечисленных,то sqlite3_uri_boolean(F,P,B)возвращает (B!=0).</target>
        </trans-unit>
        <trans-unit id="d8465d3a607ae26cbee19418630adba78c7f16b3" translate="yes" xml:space="preserve">
          <source>The sqlite3_uri_int64(F,P,D) routine converts the value of P into a 64-bit signed integer and returns that integer, or D if P does not exist. If the value of P is something other than an integer, then zero is returned.</source>
          <target state="translated">Рутина sqlite3_uri_int64(F,P,D)преобразует значение P в 64-битное целое число со знаком и возвращает это число,или D,если P не существует.Если значение P не является целым числом,то возвращается ноль.</target>
        </trans-unit>
        <trans-unit id="00f6b921b58342af7827ee6740ce3bd7da1204bf" translate="yes" xml:space="preserve">
          <source>The sqlite3_uri_key(F,N) returns a pointer to the name (not the value) of the N-th query parameter for filename F, or a NULL pointer if N is less than zero or greater than the number of query parameters minus 1. The N value is zero-based so N should be 0 to obtain the name of the first query parameter, 1 for the second parameter, and so forth.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4924027328fd6dc74b1360ec20381b3f6724812a" translate="yes" xml:space="preserve">
          <source>The sqlite3_user_data() interface returns a copy of the pointer that was the pUserData parameter (the 5th parameter) of the &lt;a href=&quot;#sqlite3_create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_create_function&quot;&gt;sqlite3_create_function16()&lt;/a&gt; routines that originally registered the application defined function.</source>
          <target state="translated">Интерфейс sqlite3_user_data () возвращает копию указателя, который был параметром pUserData (5-й параметр &lt;a href=&quot;#sqlite3_create_function&quot;&gt;)&lt;/a&gt; подпрограмм &lt;a href=&quot;#sqlite3_create_function&quot;&gt;sqlite3_create_function ()&lt;/a&gt; и sqlite3_create_function16 () , которые первоначально регистрировали функцию, определенную приложением.</target>
        </trans-unit>
        <trans-unit id="bf548778e52386bbdaeeb7ac3a4e8320cb6164f6" translate="yes" xml:space="preserve">
          <source>The sqlite3_user_data() interface returns a copy of the pointer that was the pUserData parameter (the 5th parameter) of the &lt;a href=&quot;create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt; and &lt;a href=&quot;create_function&quot;&gt;sqlite3_create_function16()&lt;/a&gt; routines that originally registered the application defined function.</source>
          <target state="translated">Интерфейс sqlite3_user_data () возвращает копию указателя, который был параметром pUserData (5-й параметр &lt;a href=&quot;create_function&quot;&gt;)&lt;/a&gt; подпрограмм &lt;a href=&quot;create_function&quot;&gt;sqlite3_create_function ()&lt;/a&gt; и sqlite3_create_function16 () , которые первоначально регистрировали функцию, определенную приложением.</target>
        </trans-unit>
        <trans-unit id="ea63e7ca04dfc54c7a9a4dfd28964eb4fb6446f1" translate="yes" xml:space="preserve">
          <source>The sqlite3_value objects that are passed as parameters into the implementation of &lt;a href=&quot;#sqlite3_create_function&quot;&gt;application-defined SQL functions&lt;/a&gt; are protected. The sqlite3_value object returned by &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_value()&lt;/a&gt; is unprotected. Unprotected sqlite3_value objects may only be used as arguments to &lt;a href=&quot;#sqlite3_result_blob&quot;&gt;sqlite3_result_value()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;sqlite3_bind_value()&lt;/a&gt;, and &lt;a href=&quot;#sqlite3_value_dup&quot;&gt;sqlite3_value_dup()&lt;/a&gt;. The &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_type()&lt;/a&gt; family of interfaces require protected sqlite3_value objects.</source>
          <target state="translated">Объекты sqlite3_value, которые передаются в качестве параметров в реализацию &lt;a href=&quot;#sqlite3_create_function&quot;&gt;определяемых приложением функций SQL&lt;/a&gt; , защищены. Объект sqlite3_value, возвращаемый &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;функцией sqlite3_column_value (),&lt;/a&gt; не защищен. Незащищенные объекты sqlite3_value могут использоваться только в качестве аргументов для &lt;a href=&quot;#sqlite3_result_blob&quot;&gt;sqlite3_result_value ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;sqlite3_bind_value ()&lt;/a&gt; и &lt;a href=&quot;#sqlite3_value_dup&quot;&gt;sqlite3_value_dup ()&lt;/a&gt; . Для семейства интерфейсов &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_type ()&lt;/a&gt; требуются защищенные объекты sqlite3_value.</target>
        </trans-unit>
        <trans-unit id="878c26369032034cf1577de94a30701d2b72bfbf" translate="yes" xml:space="preserve">
          <source>The sqlite3_value objects that are passed as parameters into the implementation of &lt;a href=&quot;../appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt; are protected. The sqlite3_value object returned by &lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_value()&lt;/a&gt; is unprotected. Unprotected sqlite3_value objects may only be used as arguments to &lt;a href=&quot;result_blob&quot;&gt;sqlite3_result_value()&lt;/a&gt;, &lt;a href=&quot;bind_blob&quot;&gt;sqlite3_bind_value()&lt;/a&gt;, and &lt;a href=&quot;value_dup&quot;&gt;sqlite3_value_dup()&lt;/a&gt;. The &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_type()&lt;/a&gt; family of interfaces require protected sqlite3_value objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d8545cde1bbfc4f37da956f6919362a532aef6b" translate="yes" xml:space="preserve">
          <source>The sqlite3_value objects that are passed as parameters into the implementation of &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt; are protected. The sqlite3_value object returned by &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_value()&lt;/a&gt; is unprotected. Unprotected sqlite3_value objects may only be used as arguments to &lt;a href=&quot;#sqlite3_result_blob&quot;&gt;sqlite3_result_value()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;sqlite3_bind_value()&lt;/a&gt;, and &lt;a href=&quot;#sqlite3_value_dup&quot;&gt;sqlite3_value_dup()&lt;/a&gt;. The &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_type()&lt;/a&gt; family of interfaces require protected sqlite3_value objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d38041b5ccb2d09a369551e816f131ddba2abad9" translate="yes" xml:space="preserve">
          <source>The sqlite3_value objects that are passed as parameters into the implementation of &lt;a href=&quot;create_function&quot;&gt;application-defined SQL functions&lt;/a&gt; are protected. The sqlite3_value object returned by &lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_value()&lt;/a&gt; is unprotected. Unprotected sqlite3_value objects may only be used as arguments to &lt;a href=&quot;result_blob&quot;&gt;sqlite3_result_value()&lt;/a&gt;, &lt;a href=&quot;bind_blob&quot;&gt;sqlite3_bind_value()&lt;/a&gt;, and &lt;a href=&quot;value_dup&quot;&gt;sqlite3_value_dup()&lt;/a&gt;. The &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_type()&lt;/a&gt; family of interfaces require protected sqlite3_value objects.</source>
          <target state="translated">Объекты sqlite3_value, которые передаются в качестве параметров в реализацию &lt;a href=&quot;create_function&quot;&gt;определяемых приложением функций SQL&lt;/a&gt; , защищены. Объект sqlite3_value, возвращаемый &lt;a href=&quot;column_blob&quot;&gt;функцией sqlite3_column_value (),&lt;/a&gt; не защищен. Незащищенные объекты sqlite3_value могут использоваться только в качестве аргументов для &lt;a href=&quot;result_blob&quot;&gt;sqlite3_result_value ()&lt;/a&gt; , &lt;a href=&quot;bind_blob&quot;&gt;sqlite3_bind_value ()&lt;/a&gt; и &lt;a href=&quot;value_dup&quot;&gt;sqlite3_value_dup ()&lt;/a&gt; . Для семейства интерфейсов &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_type ()&lt;/a&gt; требуются защищенные объекты sqlite3_value.</target>
        </trans-unit>
        <trans-unit id="a0129b60c59e08fad26659c0f3fdb0270cff463d" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_dup(V) interface makes a copy of the &lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt; object D and returns a pointer to that copy. The &lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt; returned is a &lt;a href=&quot;#sqlite3_value&quot;&gt;protected sqlite3_value&lt;/a&gt; object even if the input is not. The sqlite3_value_dup(V) interface returns NULL if V is NULL or if a memory allocation fails.</source>
          <target state="translated">Интерфейс sqlite3_value_dup (V) создает копию объекта &lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt; D и возвращает указатель на эту копию. &lt;a href=&quot;#sqlite3_value&quot;&gt;Sqlite3_value&lt;/a&gt; вернулся является &lt;a href=&quot;#sqlite3_value&quot;&gt;защищенным sqlite3_value&lt;/a&gt; объекта , даже если на входе нет. Интерфейс sqlite3_value_dup (V) возвращает NULL, если V равен NULL или при сбое выделения памяти.</target>
        </trans-unit>
        <trans-unit id="0aa98b18c314b7d86c75837f6de77eb6d3e0637d" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_dup(V) interface makes a copy of the &lt;a href=&quot;value&quot;&gt;sqlite3_value&lt;/a&gt; object D and returns a pointer to that copy. The &lt;a href=&quot;value&quot;&gt;sqlite3_value&lt;/a&gt; returned is a &lt;a href=&quot;value&quot;&gt;protected sqlite3_value&lt;/a&gt; object even if the input is not. The sqlite3_value_dup(V) interface returns NULL if V is NULL or if a memory allocation fails.</source>
          <target state="translated">Интерфейс sqlite3_value_dup (V) создает копию объекта &lt;a href=&quot;value&quot;&gt;sqlite3_value&lt;/a&gt; D и возвращает указатель на эту копию. &lt;a href=&quot;value&quot;&gt;Sqlite3_value&lt;/a&gt; вернулся является &lt;a href=&quot;value&quot;&gt;защищенным sqlite3_value&lt;/a&gt; объекта , даже если на входе нет. Интерфейс sqlite3_value_dup (V) возвращает NULL, если V равен NULL или при сбое выделения памяти.</target>
        </trans-unit>
        <trans-unit id="e0414ddee749e340e753046c8b57c08bdec5a9dc" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_free(V) interface frees an &lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt; object previously obtained from &lt;a href=&quot;#sqlite3_value_dup&quot;&gt;sqlite3_value_dup()&lt;/a&gt;. If V is a NULL pointer then sqlite3_value_free(V) is a harmless no-op.</source>
          <target state="translated">Интерфейс sqlite3_value_free (V) освобождает объект &lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value,&lt;/a&gt; ранее полученный из &lt;a href=&quot;#sqlite3_value_dup&quot;&gt;sqlite3_value_dup ()&lt;/a&gt; . Если V является указателем NULL, тогда sqlite3_value_free (V) - безобидный запрет.</target>
        </trans-unit>
        <trans-unit id="e1cbff52a059b27e36ab50ec612e0a1c2d7433c2" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_free(V) interface frees an &lt;a href=&quot;value&quot;&gt;sqlite3_value&lt;/a&gt; object previously obtained from &lt;a href=&quot;value_dup&quot;&gt;sqlite3_value_dup()&lt;/a&gt;. If V is a NULL pointer then sqlite3_value_free(V) is a harmless no-op.</source>
          <target state="translated">Интерфейс sqlite3_value_free (V) освобождает объект &lt;a href=&quot;value&quot;&gt;sqlite3_value,&lt;/a&gt; ранее полученный из &lt;a href=&quot;value_dup&quot;&gt;sqlite3_value_dup ()&lt;/a&gt; . Если V является указателем NULL, тогда sqlite3_value_free (V) - безобидный запрет.</target>
        </trans-unit>
        <trans-unit id="7d48e35fde2b5031a0a61511df13116d92432d3c" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_frombind(X) interface returns non-zero if the value X originated from one of the &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;sqlite3_bind()&lt;/a&gt; interfaces. If X comes from an SQL literal value, or a table column, and expression, then sqlite3_value_frombind(X) returns zero.</source>
          <target state="translated">Интерфейс sqlite3_value_frombind (X) возвращает ненулевое значение, если значение X получено из одного из интерфейсов &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;sqlite3_bind ()&lt;/a&gt; . Если X происходит из литерального значения SQL или столбца таблицы и выражения, тогда sqlite3_value_frombind (X) возвращает ноль.</target>
        </trans-unit>
        <trans-unit id="80d4668ad9e2d92c3db76ff20be74213c969d9ff" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_frombind(X) interface returns non-zero if the value X originated from one of the &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;sqlite3_bind()&lt;/a&gt; interfaces. If X comes from an SQL literal value, or a table column, or an expression, then sqlite3_value_frombind(X) returns zero.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4099e909bffc50f671788cefdd0e00a496608c5a" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_frombind(X) interface returns non-zero if the value X originated from one of the &lt;a href=&quot;bind_blob&quot;&gt;sqlite3_bind()&lt;/a&gt; interfaces. If X comes from an SQL literal value, or a table column, and expression, then sqlite3_value_frombind(X) returns zero.</source>
          <target state="translated">Интерфейс sqlite3_value_frombind (X) возвращает ненулевое значение, если значение X получено из одного из интерфейсов &lt;a href=&quot;bind_blob&quot;&gt;sqlite3_bind ()&lt;/a&gt; . Если X происходит из литерального значения SQL или столбца таблицы и выражения, тогда sqlite3_value_frombind (X) возвращает ноль.</target>
        </trans-unit>
        <trans-unit id="d098066d168e6b39abb688284c2a26c07f3bcf76" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_frombind(X) interface returns non-zero if the value X originated from one of the &lt;a href=&quot;bind_blob&quot;&gt;sqlite3_bind()&lt;/a&gt; interfaces. If X comes from an SQL literal value, or a table column, or an expression, then sqlite3_value_frombind(X) returns zero.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4ba714b8f0c8b8a0a85eade6cc85a5f85674f5b" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_numeric_type() interface attempts to apply numeric affinity to the value. This means that an attempt is made to convert the value to an integer or floating point. If such a conversion is possible without loss of information (in other words, if the value is a string that looks like a number) then the conversion is performed. Otherwise no conversion occurs. The &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;datatype&lt;/a&gt; after conversion is returned.</source>
          <target state="translated">Интерфейс sqlite3_value_numeric_type () пытается применить числовое сродство к значению. Это означает, что делается попытка преобразовать значение в целое число или с плавающей запятой. Если такое преобразование возможно без потери информации (другими словами, если значение представляет собой строку, которая выглядит как число), то преобразование выполняется. В противном случае преобразование не происходит. Тип &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;данных&lt;/a&gt; после преобразования возвращается.</target>
        </trans-unit>
        <trans-unit id="d57e13a61eeb32fc6ccab4def9ab890b09fb83b8" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_numeric_type() interface attempts to apply numeric affinity to the value. This means that an attempt is made to convert the value to an integer or floating point. If such a conversion is possible without loss of information (in other words, if the value is a string that looks like a number) then the conversion is performed. Otherwise no conversion occurs. The &lt;a href=&quot;c_blob&quot;&gt;datatype&lt;/a&gt; after conversion is returned.</source>
          <target state="translated">Интерфейс sqlite3_value_numeric_type () пытается применить числовое сродство к значению. Это означает, что делается попытка преобразовать значение в целое число или с плавающей запятой. Если такое преобразование возможно без потери информации (другими словами, если значение представляет собой строку, которая выглядит как число), то преобразование выполняется. В противном случае преобразование не происходит. Тип &lt;a href=&quot;c_blob&quot;&gt;данных&lt;/a&gt; после преобразования возвращается.</target>
        </trans-unit>
        <trans-unit id="4ec72e1543814b021a25a90d5cb860b5227da9f5" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_subtype(V) function returns the subtype for an &lt;a href=&quot;#sqlite3_create_function&quot;&gt;application-defined SQL function&lt;/a&gt; argument V. The subtype information can be used to pass a limited amount of context from one SQL function to another. Use the &lt;a href=&quot;#sqlite3_result_subtype&quot;&gt;sqlite3_result_subtype()&lt;/a&gt; routine to set the subtype for the return value of an SQL function.</source>
          <target state="translated">Функция sqlite3_value_subtype (V) возвращает подтип для аргумента V &lt;a href=&quot;#sqlite3_create_function&quot;&gt;функции SQL, определяемого приложением.&lt;/a&gt; Информация о подтипе может использоваться для передачи ограниченного объема контекста от одной функции SQL к другой. Используйте процедуру &lt;a href=&quot;#sqlite3_result_subtype&quot;&gt;sqlite3_result_subtype (),&lt;/a&gt; чтобы установить подтип для возвращаемого значения функции SQL.</target>
        </trans-unit>
        <trans-unit id="ac784313e8a1c8814ecb1722aed4c17998bb6a84" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_subtype(V) function returns the subtype for an &lt;a href=&quot;../appfunc&quot;&gt;application-defined SQL function&lt;/a&gt; argument V. The subtype information can be used to pass a limited amount of context from one SQL function to another. Use the &lt;a href=&quot;result_subtype&quot;&gt;sqlite3_result_subtype()&lt;/a&gt; routine to set the subtype for the return value of an SQL function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9482d5c89729cab0c852ef903cf3adcd7fd134d" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_subtype(V) function returns the subtype for an &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL function&lt;/a&gt; argument V. The subtype information can be used to pass a limited amount of context from one SQL function to another. Use the &lt;a href=&quot;#sqlite3_result_subtype&quot;&gt;sqlite3_result_subtype()&lt;/a&gt; routine to set the subtype for the return value of an SQL function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff11a55e63d67f21f428483b7880706f081aadf2" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_subtype(V) function returns the subtype for an &lt;a href=&quot;create_function&quot;&gt;application-defined SQL function&lt;/a&gt; argument V. The subtype information can be used to pass a limited amount of context from one SQL function to another. Use the &lt;a href=&quot;result_subtype&quot;&gt;sqlite3_result_subtype()&lt;/a&gt; routine to set the subtype for the return value of an SQL function.</source>
          <target state="translated">Функция sqlite3_value_subtype (V) возвращает подтип для аргумента V &lt;a href=&quot;create_function&quot;&gt;функции SQL, определяемого приложением.&lt;/a&gt; Информация о подтипе может использоваться для передачи ограниченного объема контекста от одной функции SQL к другой. Используйте процедуру &lt;a href=&quot;result_subtype&quot;&gt;sqlite3_result_subtype (),&lt;/a&gt; чтобы установить подтип для возвращаемого значения функции SQL.</target>
        </trans-unit>
        <trans-unit id="b0e636524c92f0e1651fb00be6db5e8d57af0255" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_text16() interface extracts a UTF-16 string in the native byte-order of the host machine. The sqlite3_value_text16be() and sqlite3_value_text16le() interfaces extract UTF-16 strings as big-endian and little-endian respectively.</source>
          <target state="translated">Интерфейс sqlite3_value_text16()извлекает строку UTF-16 в родном порядке байт хост-машины.Интерфейсы sqlite3_value_text16be()и sqlite3_value_text16le()извлекают строки UTF-16 в виде big-endian и little-endian соответственно.</target>
        </trans-unit>
        <trans-unit id="abd8dcf49d86f46dedd1a279c57c33b107030fa7" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_type(V) interface returns the &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;datatype code&lt;/a&gt; for the initial datatype of the &lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt; object V. The returned value is one of &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_INTEGER&lt;/a&gt;, &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_FLOAT&lt;/a&gt;, &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_TEXT&lt;/a&gt;, &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_BLOB&lt;/a&gt;, or &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_NULL&lt;/a&gt;. Other interfaces might change the datatype for an sqlite3_value object. For example, if the datatype is initially SQLITE_INTEGER and sqlite3_value_text(V) is called to extract a text value for that integer, then subsequent calls to sqlite3_value_type(V) might return SQLITE_TEXT. Whether or not a persistent internal datatype conversion occurs is undefined and may change from one release of SQLite to the next.</source>
          <target state="translated">Интерфейс sqlite3_value_type (V) возвращает &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;код типа данных&lt;/a&gt; для начального типа данных объекта &lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt; V. Возвращаемое значение - одно из &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_INTEGER&lt;/a&gt; , &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_FLOAT&lt;/a&gt; , &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_TEXT&lt;/a&gt; , &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_BLOB&lt;/a&gt; или &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_NULL&lt;/a&gt; . Другие интерфейсы могут изменить тип данных для объекта sqlite3_value. Например, если типом данных изначально является SQLITE_INTEGER и вызывается sqlite3_value_text (V) для извлечения текстового значения для этого целого числа, то последующие вызовы sqlite3_value_type (V) могут вернуть SQLITE_TEXT. Не определено, происходит ли постоянное внутреннее преобразование типа данных, и оно может изменяться от одного выпуска SQLite к другому.</target>
        </trans-unit>
        <trans-unit id="9cdf3c345651dd059fa86a01b992ffdfc67b3546" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_type(V) interface returns the &lt;a href=&quot;c_blob&quot;&gt;datatype code&lt;/a&gt; for the initial datatype of the &lt;a href=&quot;value&quot;&gt;sqlite3_value&lt;/a&gt; object V. The returned value is one of &lt;a href=&quot;c_blob&quot;&gt;SQLITE_INTEGER&lt;/a&gt;, &lt;a href=&quot;c_blob&quot;&gt;SQLITE_FLOAT&lt;/a&gt;, &lt;a href=&quot;c_blob&quot;&gt;SQLITE_TEXT&lt;/a&gt;, &lt;a href=&quot;c_blob&quot;&gt;SQLITE_BLOB&lt;/a&gt;, or &lt;a href=&quot;c_blob&quot;&gt;SQLITE_NULL&lt;/a&gt;. Other interfaces might change the datatype for an sqlite3_value object. For example, if the datatype is initially SQLITE_INTEGER and sqlite3_value_text(V) is called to extract a text value for that integer, then subsequent calls to sqlite3_value_type(V) might return SQLITE_TEXT. Whether or not a persistent internal datatype conversion occurs is undefined and may change from one release of SQLite to the next.</source>
          <target state="translated">Интерфейс sqlite3_value_type (V) возвращает &lt;a href=&quot;c_blob&quot;&gt;код типа данных&lt;/a&gt; для начального типа данных объекта &lt;a href=&quot;value&quot;&gt;sqlite3_value&lt;/a&gt; V. Возвращаемое значение - одно из &lt;a href=&quot;c_blob&quot;&gt;SQLITE_INTEGER&lt;/a&gt; , &lt;a href=&quot;c_blob&quot;&gt;SQLITE_FLOAT&lt;/a&gt; , &lt;a href=&quot;c_blob&quot;&gt;SQLITE_TEXT&lt;/a&gt; , &lt;a href=&quot;c_blob&quot;&gt;SQLITE_BLOB&lt;/a&gt; или &lt;a href=&quot;c_blob&quot;&gt;SQLITE_NULL&lt;/a&gt; . Другие интерфейсы могут изменить тип данных для объекта sqlite3_value. Например, если типом данных изначально является SQLITE_INTEGER и вызывается sqlite3_value_text (V) для извлечения текстового значения для этого целого числа, то последующие вызовы sqlite3_value_type (V) могут вернуть SQLITE_TEXT. Не определено, происходит ли постоянное внутреннее преобразование типа данных, и оно может изменяться от одного выпуска SQLite к другому.</target>
        </trans-unit>
        <trans-unit id="9fd8993db96d6be0a53b95ff8fe5c5a06191a2c2" translate="yes" xml:space="preserve">
          <source>The sqlite3_version[] string constant contains the text of &lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_VERSION&lt;/a&gt; macro. The sqlite3_libversion() function returns a pointer to the to the sqlite3_version[] string constant. The sqlite3_libversion() function is provided for use in DLLs since DLL users usually do not have direct access to string constants within the DLL. The sqlite3_libversion_number() function returns an integer equal to &lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_VERSION_NUMBER&lt;/a&gt;. The sqlite3_sourceid() function returns a pointer to a string constant whose value is the same as the &lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_SOURCE_ID&lt;/a&gt; C preprocessor macro. Except if SQLite is built using an edited copy of &lt;a href=&quot;amalgamation&quot;&gt;the amalgamation&lt;/a&gt;, then the last four characters of the hash might be different from &lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_SOURCE_ID&lt;/a&gt;.</source>
          <target state="translated">Строковая константа sqlite3_version [] содержит текст макроса &lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_VERSION&lt;/a&gt; . Функция sqlite3_libversion () возвращает указатель на строковую константу sqlite3_version []. Функция sqlite3_libversion () предназначена для использования в библиотеках DLL, поскольку пользователи DLL обычно не имеют прямого доступа к строковым константам внутри библиотеки DLL. Функция sqlite3_libversion_number () возвращает целое число, равное &lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_VERSION_NUMBER&lt;/a&gt; . Функция sqlite3_sourceid () возвращает указатель на &lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;строковую&lt;/a&gt; константу, значение которой совпадает со значением макроса препроцессора C SQLITE_SOURCE_ID . За исключением случаев, когда SQLite создается с использованием отредактированной копии &lt;a href=&quot;amalgamation&quot;&gt;объединения&lt;/a&gt; , последние четыре символа хеш- &lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;кода&lt;/a&gt; могут отличаться от SQLITE_SOURCE_ID .</target>
        </trans-unit>
        <trans-unit id="a807d081504ff9864c4a0f322dee10127ba34ee0" translate="yes" xml:space="preserve">
          <source>The sqlite3_version[] string constant contains the text of &lt;a href=&quot;c_source_id&quot;&gt;SQLITE_VERSION&lt;/a&gt; macro. The sqlite3_libversion() function returns a pointer to the to the sqlite3_version[] string constant. The sqlite3_libversion() function is provided for use in DLLs since DLL users usually do not have direct access to string constants within the DLL. The sqlite3_libversion_number() function returns an integer equal to &lt;a href=&quot;c_source_id&quot;&gt;SQLITE_VERSION_NUMBER&lt;/a&gt;. The sqlite3_sourceid() function returns a pointer to a string constant whose value is the same as the &lt;a href=&quot;c_source_id&quot;&gt;SQLITE_SOURCE_ID&lt;/a&gt; C preprocessor macro. Except if SQLite is built using an edited copy of &lt;a href=&quot;../amalgamation&quot;&gt;the amalgamation&lt;/a&gt;, then the last four characters of the hash might be different from &lt;a href=&quot;c_source_id&quot;&gt;SQLITE_SOURCE_ID&lt;/a&gt;.</source>
          <target state="translated">Строковая константа sqlite3_version [] содержит текст макроса &lt;a href=&quot;c_source_id&quot;&gt;SQLITE_VERSION&lt;/a&gt; . Функция sqlite3_libversion () возвращает указатель на строковую константу sqlite3_version []. Функция sqlite3_libversion () предназначена для использования в библиотеках DLL, поскольку пользователи DLL обычно не имеют прямого доступа к строковым константам внутри библиотеки DLL. Функция sqlite3_libversion_number () возвращает целое число, равное &lt;a href=&quot;c_source_id&quot;&gt;SQLITE_VERSION_NUMBER&lt;/a&gt; . Функция sqlite3_sourceid () возвращает указатель на &lt;a href=&quot;c_source_id&quot;&gt;строковую&lt;/a&gt; константу, значение которой совпадает со значением макроса препроцессора C SQLITE_SOURCE_ID . За исключением случаев, когда SQLite создается с использованием отредактированной копии &lt;a href=&quot;../amalgamation&quot;&gt;объединения&lt;/a&gt; , последние четыре символа хеш- &lt;a href=&quot;c_source_id&quot;&gt;кода&lt;/a&gt; могут отличаться от SQLITE_SOURCE_ID .</target>
        </trans-unit>
        <trans-unit id="b7f0635e95ae6f97edbc2a13b7ebfc89ee7bf9a3" translate="yes" xml:space="preserve">
          <source>The sqlite3_vfs_find() interface returns a pointer to a VFS given its name. Names are case sensitive. Names are zero-terminated UTF-8 strings. If there is no match, a NULL pointer is returned. If zVfsName is NULL then the default VFS is returned.</source>
          <target state="translated">Интерфейс sqlite3_vfs_find()возвращает указатель на VFS с его именем.Имена чувствительны к регистру.Имена-ноль-терминированные UTF-8 строки.Если совпадение отсутствует,возвращается указатель NULL.Если zVfsName равно NULL,возвращается VFS по умолчанию.</target>
        </trans-unit>
        <trans-unit id="88892501427d74185f6b1bff1e11e202173ae158" translate="yes" xml:space="preserve">
          <source>The sqlite3_vsnprintf() routine is a varargs version of sqlite3_snprintf().</source>
          <target state="translated">Рутина sqlite3_vsnprintf()является varargs версией sqlite3_snprintf().</target>
        </trans-unit>
        <trans-unit id="bfe11fb394a04090848d426f27d7f821bd426298" translate="yes" xml:space="preserve">
          <source>The sqlite3_wal_checkpoint(D,X) is equivalent to &lt;a href=&quot;#sqlite3_wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2&lt;/a&gt;(D,X,&lt;a href=&quot;#SQLITE_CHECKPOINT_FULL&quot;&gt;SQLITE_CHECKPOINT_PASSIVE&lt;/a&gt;,0,0).</source>
          <target state="translated">Sqlite3_wal_checkpoint (D, X) эквивалентен &lt;a href=&quot;#sqlite3_wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2&lt;/a&gt; (D, X, &lt;a href=&quot;#SQLITE_CHECKPOINT_FULL&quot;&gt;SQLITE_CHECKPOINT_PASSIVE&lt;/a&gt; , 0,0).</target>
        </trans-unit>
        <trans-unit id="a5b2980a50de42ca24a7d3c803dbeadfa7a488ca" translate="yes" xml:space="preserve">
          <source>The sqlite3_wal_checkpoint(D,X) is equivalent to &lt;a href=&quot;wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2&lt;/a&gt;(D,X,&lt;a href=&quot;c_checkpoint_full&quot;&gt;SQLITE_CHECKPOINT_PASSIVE&lt;/a&gt;,0,0).</source>
          <target state="translated">Sqlite3_wal_checkpoint (D, X) эквивалентен &lt;a href=&quot;wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2&lt;/a&gt; (D, X, &lt;a href=&quot;c_checkpoint_full&quot;&gt;SQLITE_CHECKPOINT_PASSIVE&lt;/a&gt; , 0,0).</target>
        </trans-unit>
        <trans-unit id="7f281b26d80df2d4297decb3bb5684de63641309" translate="yes" xml:space="preserve">
          <source>The sqlite3_wal_checkpoint_v2(D,X,M,L,C) interface runs a checkpoint operation on database X of &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; D in mode M. Status information is written back into integers pointed to by L and C. The M parameter must be a valid &lt;a href=&quot;#SQLITE_CHECKPOINT_FULL&quot;&gt;checkpoint mode&lt;/a&gt;:</source>
          <target state="translated">Интерфейс sqlite3_wal_checkpoint_v2 (D, X, M, L, C) запускает операцию контрольной точки в базе данных X соединения с &lt;a href=&quot;#sqlite3&quot;&gt;базой данных&lt;/a&gt; D в режиме M. Информация о состоянии записывается обратно в целые числа, на которые указывают L и C. Параметр M должен быть допустимым. &lt;a href=&quot;#SQLITE_CHECKPOINT_FULL&quot;&gt;режим контрольной точки&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="4f16d84b1dffbf24b61871d0a39f458136f5ce78" translate="yes" xml:space="preserve">
          <source>The sqlite3_wal_checkpoint_v2(D,X,M,L,C) interface runs a checkpoint operation on database X of &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; D in mode M. Status information is written back into integers pointed to by L and C. The M parameter must be a valid &lt;a href=&quot;c_checkpoint_full&quot;&gt;checkpoint mode&lt;/a&gt;:</source>
          <target state="translated">Интерфейс sqlite3_wal_checkpoint_v2 (D, X, M, L, C) запускает операцию контрольной точки в базе данных X соединения с &lt;a href=&quot;sqlite3&quot;&gt;базой данных&lt;/a&gt; D в режиме M. Информация о состоянии записывается обратно в целые числа, на которые указывают L и C. Параметр M должен быть допустимым. &lt;a href=&quot;c_checkpoint_full&quot;&gt;режим контрольной точки&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="121e4ad510585a0237e3a007626cc2d427159cf6" translate="yes" xml:space="preserve">
          <source>The sqlite3changeset_apply() function automatically converts the zero-length blob back to a NULL value when updating the sqlite_stat1 table. However, if the application calls sqlite3changeset_new(), sqlite3changeset_old() or sqlite3changeset_conflict on a changeset iterator directly (including on a changeset iterator passed to a conflict-handler callback) then the X'' value is returned. The application must translate X'' to NULL itself if required.</source>
          <target state="translated">Функция sqlite3changeset_apply()при обновлении таблицы sqlite_stat1 автоматически преобразует блок нулевой длины обратно в значение NULL.Однако,если приложение вызывает sqlite3changeset_new(),sqlite3changeset_old()или sqlite3changeset_conflict на итераторе changeset непосредственно (в том числе и на итераторе changeset,переданном обратному конфликтообладателю),то возвращается значение X''.При необходимости приложение должно самостоятельно перевести X'' в NULL.</target>
        </trans-unit>
        <trans-unit id="ab7530db4d4c9fc320d8eb6c02294cea75207425" translate="yes" xml:space="preserve">
          <source>The sqlite3rbu_open(T,A,S) function returns a pointer to an &quot;sqlite3rbu&quot; object, which is then passed into the subsequent interfaces.</source>
          <target state="translated">Функция sqlite3rbu_open(T,A,S)возвращает указатель на объект &quot;sqlite3rbu&quot;,который затем передаётся в последующие интерфейсы.</target>
        </trans-unit>
        <trans-unit id="bcc8971708ade277f3f9ba38012f5db2060092ea" translate="yes" xml:space="preserve">
          <source>The sqlite3session_config() interface is not threadsafe. If it is invoked while any other thread is inside any other sessions method then the results are undefined. Furthermore, if it is invoked after any sessions related objects have been created, the results are also undefined.</source>
          <target state="translated">Интерфейс sqlite3session_config()не является потокобезопасным.Если он вызывается в то время,как любой другой поток находится внутри любого другого метода сеанса,то результаты не определяются.Более того,если он вызывается после создания объектов,связанных с сессиями,результаты также не определяются.</target>
        </trans-unit>
        <trans-unit id="ed3502dd7610ba7f06fbfad0a9a6bcb2eec2c983" translate="yes" xml:space="preserve">
          <source>The sqlite3session_config() interface is used to make global configuration changes to the sessions module in order to tune it to the specific needs of the application.</source>
          <target state="translated">Интерфейс sqlite3session_config()используется для внесения глобальных конфигурационных изменений в модуль сеансов с целью его настройки под конкретные нужды приложения.</target>
        </trans-unit>
        <trans-unit id="517ed7f5443765d182eb47f3b8b955f48af65e6e" translate="yes" xml:space="preserve">
          <source>The sqlite_compileoption_get() SQL function is a wrapper around the &lt;a href=&quot;c3ref/compileoption_get&quot;&gt;sqlite3_compileoption_get()&lt;/a&gt; C/C++ function. This routine returns the N-th compile-time option used to build SQLite or NULL if N is out of range. See also the &lt;a href=&quot;pragma#pragma_compile_options&quot;&gt;compile_options pragma&lt;/a&gt;.</source>
          <target state="translated">SQL-функция sqlite_compileoption_get () представляет собой оболочку для &lt;a href=&quot;c3ref/compileoption_get&quot;&gt;функции sqlite3_compileoption_get ()&lt;/a&gt; C / C ++. Эта процедура возвращает N-й параметр времени компиляции, используемый для построения SQLite, или NULL, если N выходит за пределы допустимого диапазона. См. Также &lt;a href=&quot;pragma#pragma_compile_options&quot;&gt;прагму compile_options&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="62942f05e5a1956f6b33c8235e025eeea5e49332" translate="yes" xml:space="preserve">
          <source>The sqlite_compileoption_used() SQL function is a wrapper around the &lt;a href=&quot;c3ref/compileoption_get&quot;&gt;sqlite3_compileoption_used()&lt;/a&gt; C/C++ function. When the argument X to sqlite_compileoption_used(X) is a string which is the name of a compile-time option, this routine returns true (1) or false (0) depending on whether or not that option was used during the build.</source>
          <target state="translated">SQL-функция sqlite_compileoption_used () является оболочкой для &lt;a href=&quot;c3ref/compileoption_get&quot;&gt;функции sqlite3_compileoption_used ()&lt;/a&gt; C / C ++. Когда аргумент X для sqlite_compileoption_used (X) является строкой, которая является именем параметра времени компиляции, эта процедура возвращает истину (1) или ложь (0) в зависимости от того, использовалась ли эта опция во время сборки.</target>
        </trans-unit>
        <trans-unit id="029c047f81979126902e66d7c2206be9ceebe6ff" translate="yes" xml:space="preserve">
          <source>The sqlite_master table contains one row for each table, index, view, and trigger (collectively &quot;objects&quot;) in the database schema, except there is no entry for the sqlite_master table itself. The sqlite_master table contains entries for &lt;a href=&quot;fileformat2#intschema&quot;&gt;internal schema objects&lt;/a&gt; in addition to application- and programmer-defined objects.</source>
          <target state="translated">Таблица sqlite_master содержит по одной строке для каждой таблицы, индекса, представления и триггера (в совокупности &amp;laquo;объекты&amp;raquo;) в схеме базы данных, за исключением того, что для самой таблицы sqlite_master нет записи. Таблица sqlite_master содержит записи для &lt;a href=&quot;fileformat2#intschema&quot;&gt;объектов внутренней схемы&lt;/a&gt; в дополнение к объектам, определяемым приложением и программистом.</target>
        </trans-unit>
        <trans-unit id="9e701356a8021b4fb9727300fa9f7200eddb250b" translate="yes" xml:space="preserve">
          <source>The sqlite_master.name column will hold the name of the object. &lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE&lt;/a&gt; and &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt; constraints on tables cause SQLite to create &lt;a href=&quot;fileformat2#intschema&quot;&gt;internal indexes&lt;/a&gt; with names of the form &quot;sqlite_autoindex_TABLE_N&quot; where TABLE is replaced by the name of the table that contains the constraint and N is an integer beginning with 1 and increasing by one with each constraint seen in the table definition. In a &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; table, there is no sqlite_master entry for the PRIMARY KEY, but the &quot;sqlite_autoindex_TABLE_N&quot; name is set aside for the PRIMARY KEY as if the sqlite_master entry did exist. This will affect the numbering of subsequent UNIQUE constraints. The &quot;sqlite_autoindex_TABLE_N&quot; name is never allocated for an &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;, either in rowid tables or WITHOUT ROWID tables.</source>
          <target state="translated">Столбец sqlite_master.name будет содержать имя объекта. Ограничения &lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE&lt;/a&gt; и &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt; для таблиц заставляют SQLite создавать &lt;a href=&quot;fileformat2#intschema&quot;&gt;внутренние индексы&lt;/a&gt; с именами в форме &amp;laquo;sqlite_autoindex_TABLE_N&amp;raquo;, где TABLE заменяется именем таблицы, содержащей ограничение, а N - целое число, начинающееся с 1 и увеличивающееся на единицу с каждым ограничением. видно в определении таблицы. В таблице &lt;a href=&quot;withoutrowid&quot;&gt;БЕЗ ROWID&lt;/a&gt; отсутствует запись sqlite_master для ПЕРВИЧНОГО КЛЮЧА, но имя &amp;laquo;sqlite_autoindex_TABLE_N&amp;raquo; для ПЕРВИЧНОГО КЛЮЧА отложено, как если бы запись sqlite_master действительно существовала. Это повлияет на нумерацию последующих ограничений UNIQUE. &quot;Sqlite_autoindex_TABLE_N&quot;имя никогда не выделяется для &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;, либо в таблицах rowid, либо в таблицах БЕЗ ROWID.</target>
        </trans-unit>
        <trans-unit id="3bae42f70521e9e8cd4db2168d1d1babca7ff5fa" translate="yes" xml:space="preserve">
          <source>The sqlite_master.rootpage column stores the page number of the root b-tree page for tables and indexes. For rows that define views, triggers, and virtual tables, the rootpage column is 0 or NULL.</source>
          <target state="translated">В колонке sqlite_master.rootpage хранится номер страницы корневой b-деревянной страницы для таблиц и индексов.Для строк,определяющих представления,триггеры и виртуальные таблицы,столбец корневой страницы равен 0 или NULL.</target>
        </trans-unit>
        <trans-unit id="ccb922e59255362de7628494ea2946015486eb28" translate="yes" xml:space="preserve">
          <source>The sqlite_master.sql column stores SQL text that describes the object. This SQL text is a &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt;, &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt;, &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt;, &lt;a href=&quot;lang_createview&quot;&gt;CREATE VIEW&lt;/a&gt;, or &lt;a href=&quot;lang_createtrigger&quot;&gt;CREATE TRIGGER&lt;/a&gt; statement that if evaluated against the database file when it is the main database of a &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; would recreate the object. The text is usually a copy of the original statement used to create the object but with normalizations applied so that the text conforms to the following rules:</source>
          <target state="translated">В столбце sqlite_master.sql хранится текст SQL, описывающий объект. Этот текст SQL представляет собой оператор &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; , &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; , &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt; , &lt;a href=&quot;lang_createview&quot;&gt;CREATE VIEW&lt;/a&gt; или &lt;a href=&quot;lang_createtrigger&quot;&gt;CREATE TRIGGER,&lt;/a&gt; который при вычислении по файлу базы данных, когда он является основной базой &lt;a href=&quot;c3ref/sqlite3&quot;&gt;данных соединения&lt;/a&gt; с базой данных , воссоздает объект. Текст обычно является копией исходного оператора, использованного для создания объекта, но с нормализацией, применяемой так, чтобы текст соответствовал следующим правилам:</target>
        </trans-unit>
        <trans-unit id="8ef76cce54ac5ead8c9ecfb2e98b71a272278d61" translate="yes" xml:space="preserve">
          <source>The sqlite_master.tbl_name column holds the name of a table or view that the object is associated with. For a table or view, the tbl_name column is a copy of the name column. For an index, the tbl_name is the name of the table that is indexed. For a trigger, the tbl_name column stores the name of the table or view that causes the trigger to fire.</source>
          <target state="translated">В столбце sqlite_master.tbl_name хранится имя таблицы или представления,с которым ассоциируется объект.Для таблицы или представления столбец tbl_name является копией столбца имени.Для индекса столбец tbl_name-это имя таблицы,которая индексируется.Для триггера столбец tbl_name хранит имя таблицы или представления,которое вызывает срабатывание триггера.</target>
        </trans-unit>
        <trans-unit id="1161ce8b03e8867e67c57e405c9c72a8e7f39824" translate="yes" xml:space="preserve">
          <source>The sqlite_master.type column will be one of the following text strings: 'table', 'index', 'view', or 'trigger' according to the type of object defined. The 'table' string is used for both ordinary and &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt;.</source>
          <target state="translated">Столбец sqlite_master.type будет представлять собой одну из следующих текстовых строк: &amp;laquo;таблица&amp;raquo;, &amp;laquo;индекс&amp;raquo;, &amp;laquo;представление&amp;raquo; или &amp;laquo;триггер&amp;raquo; в соответствии с типом определенного объекта. Строка table используется как для обычных, так и для &lt;a href=&quot;vtab&quot;&gt;виртуальных таблиц&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8a4ecb6a492d4b0952a80c0d2b263ba43418de02" translate="yes" xml:space="preserve">
          <source>The sqlite_offset(X) SQL function is only available if SQLite is built using the &lt;a href=&quot;compile#enable_offset_sql_func&quot;&gt;-DSQLITE_ENABLE_OFFSET_SQL_FUNC&lt;/a&gt; compile-time option.</source>
          <target state="translated">Функция SQL sqlite_offset (X) доступна только в том случае, если SQLite построен с использованием параметра &lt;a href=&quot;compile#enable_offset_sql_func&quot;&gt;времени&lt;/a&gt; компиляции -DSQLITE_ENABLE_OFFSET_SQL_FUNC .</target>
        </trans-unit>
        <trans-unit id="f36120db3cfab77bf49cfde55bfe4a03928e953b" translate="yes" xml:space="preserve">
          <source>The sqlite_offset(X) function returns the byte offset in the database file for the beginning of the record from which value would be read. If X is not a column in an ordinary table, then sqlite_offset(X) returns NULL. The value returned by sqlite_offset(X) might reference either the original table or an index, depending on the query. If the value X would normally be extracted from an index, the sqlite_offset(X) returns the offset to the corresponding index record. If the value X would be extracted from the original table, then sqlite_offset(X) returns the offset to the table record.</source>
          <target state="translated">Функция sqlite_offset(X)возвращает смещение байта в файле базы данных для начала записи,из которой будет считываться значение.Если X не является столбцом в обычной таблице,то sqlite_offset(X)возвращает NULL.Значение,возвращаемое sqlite_offset(X),может содержать ссылку либо на исходную таблицу,либо на индекс,в зависимости от запроса.Если значение X обычно извлекается из индекса,sqlite_offset(X)возвращает смещение к соответствующей записи индекса.Если значение X будет извлечено из исходной таблицы,то sqlite_offset(X)возвращает смещение в запись таблицы.</target>
        </trans-unit>
        <trans-unit id="7edde881cc83be6805465c505116db44a7c10317" translate="yes" xml:space="preserve">
          <source>The sqlite_schema table contains one row for each table, index, view, and trigger (collectively &quot;objects&quot;) in the database schema, except there is no entry for the sqlite_schema table itself. The sqlite_schema table contains entries for &lt;a href=&quot;fileformat2#intschema&quot;&gt;internal schema objects&lt;/a&gt; in addition to application- and programmer-defined objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8cd91bb0f299cfe62ef641ec65f9fe2bb5de142" translate="yes" xml:space="preserve">
          <source>The sqlite_schema table contains one row for each table, index, view, and trigger (collectively &quot;objects&quot;) in the schema, except there is no entry for the sqlite_schema table itself. See the &lt;a href=&quot;fileformat2#ffschema&quot;&gt;schema storage&lt;/a&gt; subsection of the &lt;a href=&quot;fileformat2&quot;&gt;file format&lt;/a&gt; documentation for additional information on how SQLite uses the sqlite_schema table internally.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01b38e5a9d3444c64ea7992a244995da2b49b851" translate="yes" xml:space="preserve">
          <source>The sqlite_schema.name column will hold the name of the object. (&lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE&lt;/a&gt; and &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt; constraints on tables cause SQLite to create &lt;a href=&quot;fileformat2#intschema&quot;&gt;internal indexes&lt;/a&gt; with names of the form &quot;sqlite_autoindex_TABLE_N&quot; where TABLE is replaced by the name of the table that contains the constraint and N is an integer beginning with 1 and increasing by one with each constraint seen in the table definition. In a &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; table, there is no sqlite_schema entry for the PRIMARY KEY, but the &quot;sqlite_autoindex_TABLE_N&quot; name is set aside for the PRIMARY KEY as if the sqlite_schema entry did exist. This will affect the numbering of subsequent UNIQUE constraints. The &quot;sqlite_autoindex_TABLE_N&quot; name is never allocated for an &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;, either in rowid tables or WITHOUT ROWID tables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e02071e2d759314e2fb363a98ec697450c31c3a5" translate="yes" xml:space="preserve">
          <source>The sqlite_schema.name column will hold the name of the object. &lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE&lt;/a&gt; and &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt; constraints on tables cause SQLite to create &lt;a href=&quot;fileformat2#intschema&quot;&gt;internal indexes&lt;/a&gt; with names of the form &quot;sqlite_autoindex_TABLE_N&quot; where TABLE is replaced by the name of the table that contains the constraint and N is an integer beginning with 1 and increasing by one with each constraint seen in the table definition. In a &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; table, there is no sqlite_schema entry for the PRIMARY KEY, but the &quot;sqlite_autoindex_TABLE_N&quot; name is set aside for the PRIMARY KEY as if the sqlite_schema entry did exist. This will affect the numbering of subsequent UNIQUE constraints. The &quot;sqlite_autoindex_TABLE_N&quot; name is never allocated for an &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;, either in rowid tables or WITHOUT ROWID tables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b54e4469dd50abde5034fd8f801a4d0306037ed0" translate="yes" xml:space="preserve">
          <source>The sqlite_schema.rootpage column stores the page number of the root b-tree page for tables and indexes. For rows that define views, triggers, and virtual tables, the rootpage column is 0 or NULL.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee6bcf89a71c75b0fa182495e5015131f7df248c" translate="yes" xml:space="preserve">
          <source>The sqlite_schema.sql column stores SQL text that describes the object. This SQL text is a &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt;, &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt;, &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt;, &lt;a href=&quot;lang_createview&quot;&gt;CREATE VIEW&lt;/a&gt;, or &lt;a href=&quot;lang_createtrigger&quot;&gt;CREATE TRIGGER&lt;/a&gt; statement that if evaluated against the database file when it is the main database of a &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; would recreate the object. The text is usually a copy of the original statement used to create the object but with normalizations applied so that the text conforms to the following rules:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d911ebef016f1f15b28a4875cf26c113309d9fa3" translate="yes" xml:space="preserve">
          <source>The sqlite_schema.tbl_name column holds the name of a table or view that the object is associated with. For a table or view, the tbl_name column is a copy of the name column. For an index, the tbl_name is the name of the table that is indexed. For a trigger, the tbl_name column stores the name of the table or view that causes the trigger to fire.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02a28099cf1bad8380c62abb7ce56059bbeb63ba" translate="yes" xml:space="preserve">
          <source>The sqlite_schema.type column will be one of the following text strings: 'table', 'index', 'view', or 'trigger' according to the type of object defined. The 'table' string is used for both ordinary and &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f99e581aad3bfe8af33ed6ae438c6f190e18bdd" translate="yes" xml:space="preserve">
          <source>The sqlite_sequence table is an internal table used to help implement &lt;a href=&quot;autoinc&quot;&gt;AUTOINCREMENT&lt;/a&gt;. The sqlite_sequence table is created automatically whenever any ordinary table with an AUTOINCREMENT integer primary key is created. Once created, the sqlite_sequence table exists in the sqlite_master table forever; it cannot be dropped. The schema for the sqlite_sequence table is:</source>
          <target state="translated">Таблица sqlite_sequence - это внутренняя таблица, которая помогает реализовать &lt;a href=&quot;autoinc&quot;&gt;AUTOINCREMENT&lt;/a&gt; . Таблица sqlite_sequence создается автоматически при создании любой обычной таблицы с целочисленным первичным ключом AUTOINCREMENT. После создания таблица sqlite_sequence существует в таблице sqlite_master навсегда; его нельзя отбросить. Схема для таблицы sqlite_sequence:</target>
        </trans-unit>
        <trans-unit id="45d57d826d6c576b74670b2e5b7c281dbdfadbab" translate="yes" xml:space="preserve">
          <source>The sqlite_sequence table is an internal table used to help implement &lt;a href=&quot;autoinc&quot;&gt;AUTOINCREMENT&lt;/a&gt;. The sqlite_sequence table is created automatically whenever any ordinary table with an AUTOINCREMENT integer primary key is created. Once created, the sqlite_sequence table exists in the sqlite_schema table forever; it cannot be dropped. The schema for the sqlite_sequence table is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2336dfb15c81a1bc2e023f4a5ddff1cb80eb4aa" translate="yes" xml:space="preserve">
          <source>The sqlite_source_id() function returns a string that identifies the specific version of the source code that was used to build the SQLite library. The string returned by sqlite_source_id() is the date and time that the source code was checked in followed by the SHA1 hash for that check-in. This function is an SQL wrapper around the &lt;a href=&quot;c3ref/libversion&quot;&gt;sqlite3_sourceid()&lt;/a&gt; C interface.</source>
          <target state="translated">Функция sqlite_source_id () возвращает строку, которая определяет конкретную версию исходного кода, которая использовалась для создания библиотеки SQLite. Строка, возвращаемая sqlite_source_id (), представляет собой дату и время, когда исходный код был проверен, за которым следует хеш SHA1 для этой регистрации. Эта функция является оболочкой SQL для интерфейса C. &lt;a href=&quot;c3ref/libversion&quot;&gt;sqlite3_sourceid ()&lt;/a&gt; C.</target>
        </trans-unit>
        <trans-unit id="7f3f3c25482d0c81576dfc7ce696a273cc1dcba3" translate="yes" xml:space="preserve">
          <source>The sqlite_stat1 is an internal table created by the &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; command and used to hold supplemental information about tables and indexes that the query planner can use to help it find better ways of performing queries. Applications can update, delete from, insert into or drop the sqlite_stat1 table, but may not create or alter the sqlite_stat1 table. The schema of the sqlite_stat1 table is as follows:</source>
          <target state="translated">Sqlite_stat1 - это внутренняя таблица, созданная командой &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; и используемая для хранения дополнительной информации о таблицах и индексах, которую планировщик запросов может использовать для поиска лучших способов выполнения запросов. Приложения могут обновлять, удалять, вставлять или удалять таблицу sqlite_stat1, но не могут создавать или изменять таблицу sqlite_stat1. Схема таблицы sqlite_stat1 выглядит следующим образом:</target>
        </trans-unit>
        <trans-unit id="eac5f10d8bfa6fc7cd030e9acfc883c862434c99" translate="yes" xml:space="preserve">
          <source>The sqlite_stat2 entries for an index that have sqlite_stat2.sampleno between 0 and 9 inclusive are samples of the left-most key value in the index taken at evenly spaced points along the index. Let C be the number of rows in the index. Then the sampled rows are given by</source>
          <target state="translated">Записи sqlite_stat2 для индекса,имеющего sqlite_stat2.sampleno между 0 и 9 включительно,являются выборками крайнего левого значения ключа в индексе,взятого в равномерно распределенных точках вдоль индекса.Пусть C будет числом строк в индексе.Затем выборочные строки задаются</target>
        </trans-unit>
        <trans-unit id="db07f0500ccc51725e75c485f7f2868bee244cc2" translate="yes" xml:space="preserve">
          <source>The sqlite_stat2 is only created and is only used if SQLite is compiled with SQLITE_ENABLE_STAT2 and if the SQLite version number is between 3.6.18 (2009-09-11) and 3.7.8 (2011-09-19). The sqlite_stat2 table is neither read nor written by any version of SQLite before 3.6.18 nor after 3.7.8. The sqlite_stat2 table contains additional information about the distribution of keys within an index. The schema of the sqlite_stat2 table is as follows:</source>
          <target state="translated">sqlite_stat2 создается и используется только в том случае,если SQLite скомпилирован с SQLITE_ENABLE_STAT2 и номер версии SQLite находится между 3.6.18 (2009-09-11)и 3.7.8 (2011-09-19).Таблица sqlite_stat2 не читается и не записывается ни одной из версий SQLite до 3.6.18,ни после 3.7.8.Таблица sqlite_stat2 содержит дополнительную информацию о распределении ключей внутри индекса.Схема таблицы sqlite_stat2 выглядит следующим образом:</target>
        </trans-unit>
        <trans-unit id="5e0f4c3583a4ba1380f140be5cb19d805481ba5e" translate="yes" xml:space="preserve">
          <source>The sqlite_stat2.idx column and the sqlite_stat2.tbl column in each row of the sqlite_stat2 table identify an index described by that row. There are usually 10 rows in the sqlite_stat2 table for each index.</source>
          <target state="translated">Столбец sqlite_stat2.idx и столбец sqlite_stat2.tbl в каждой строке таблицы sqlite_stat2 определяют индекс,описанный этой строкой.Обычно для каждого индекса в таблице sqlite_stat2 имеется 10 строк.</target>
        </trans-unit>
        <trans-unit id="2f0561169a2bdda1f406d666ccb3f34136d53934" translate="yes" xml:space="preserve">
          <source>The sqlite_stat3 is only used if SQLite is compiled with &lt;a href=&quot;compile#enable_stat3&quot;&gt;SQLITE_ENABLE_STAT3&lt;/a&gt; or &lt;a href=&quot;compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt; and if the SQLite version number is 3.7.9 (2011-11-01) or greater. The sqlite_stat3 table is neither read nor written by any version of SQLite before 3.7.9. If the &lt;a href=&quot;compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt; compile-time option is used and the SQLite version number is 3.8.1 (2013-10-17) or greater, then sqlite_stat3 might be read but not written. The sqlite_stat3 table contains additional information about the distribution of keys within an index, information that the query planner can use to devise better and faster query algorithms. The schema of the sqlite_stat3 table is as follows:</source>
          <target state="translated">Sqlite_stat3 используется только в том случае, если SQLite скомпилирован с &lt;a href=&quot;compile#enable_stat3&quot;&gt;SQLITE_ENABLE_STAT3&lt;/a&gt; или &lt;a href=&quot;compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt; и если номер версии SQLite равен 3.7.9 (2011-11-01) или выше. Таблица sqlite_stat3 не читается и не записывается ни одной версией SQLite до 3.7.9. Если используется &lt;a href=&quot;compile#enable_stat4&quot;&gt;параметр времени&lt;/a&gt; компиляции SQLITE_ENABLE_STAT4 и номер версии SQLite равен 3.8.1 (2013-10-17) или выше, тогда sqlite_stat3 может быть прочитан, но не записан. Таблица sqlite_stat3 содержит дополнительную информацию о распределении ключей в индексе, информацию, которую планировщик запросов может использовать для разработки более эффективных и быстрых алгоритмов запросов. Схема таблицы sqlite_stat3 выглядит следующим образом:</target>
        </trans-unit>
        <trans-unit id="00890c07b6c2c2c2cdb8874e2a1b39eb7801c048" translate="yes" xml:space="preserve">
          <source>The sqlite_stat4 is a generalization of the sqlite_stat3 table. The sqlite_stat3 table provides information about the left-most column of an index whereas the sqlite_stat4 table provides information about all columns of the index.</source>
          <target state="translated">Таблица sqlite_stat4 является обобщением таблицы sqlite_stat3.Таблица sqlite_stat3 предоставляет информацию о самом левом столбце индекса,в то время как таблица sqlite_stat4 предоставляет информацию обо всех столбцах индекса.</target>
        </trans-unit>
        <trans-unit id="17be4a34aae6ba200b1b6b315d0554ec130a710a" translate="yes" xml:space="preserve">
          <source>The sqlite_stat4 is only created and is only used if SQLite is compiled with &lt;a href=&quot;compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt; and if the SQLite version number is 3.8.1 (2013-10-17) or greater. The sqlite_stat4 table is neither read nor written by any version of SQLite before 3.8.1. The sqlite_stat4 table contains additional information about the distribution of keys within an index or the distribution of keys in the primary key of a &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; table. The query planner can sometimes use the additional information in the sqlite_stat4 table to devise better and faster query algorithms. The schema of the sqlite_stat4 table is as follows:</source>
          <target state="translated">Sqlite_stat4 создается только и используется только в том случае, если SQLite скомпилирован с &lt;a href=&quot;compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt; и если номер версии SQLite равен 3.8.1 (2013-10-17) или выше. Таблица sqlite_stat4 не читается и не записывается ни одной версией SQLite до 3.8.1. Таблица sqlite_stat4 содержит дополнительную информацию о распределении ключей в индексе или распределении ключей в первичном ключе таблицы &lt;a href=&quot;withoutrowid&quot;&gt;БЕЗ ROWID&lt;/a&gt; . Планировщик запросов иногда может использовать дополнительную информацию в таблице sqlite_stat4 для разработки более эффективных и быстрых алгоритмов запросов. Схема таблицы sqlite_stat4 выглядит следующим образом:</target>
        </trans-unit>
        <trans-unit id="dc1ec4b833f86cdac2f0f4646210820d900eb53f" translate="yes" xml:space="preserve">
          <source>The sqlite_stat4.idx column holds name of the index that the row describes, or in the case of an sqlite_stat4 entry for a &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; table, the name of the table itself.</source>
          <target state="translated">Столбец sqlite_stat4.idx содержит имя индекса, который описывает строка, или, в случае записи sqlite_stat4 для таблицы &lt;a href=&quot;withoutrowid&quot;&gt;БЕЗ ROWID&lt;/a&gt; , имя самой таблицы.</target>
        </trans-unit>
        <trans-unit id="1916f53e908a81ccd0bcf17da67632c5df8295de" translate="yes" xml:space="preserve">
          <source>The sqlite_stat4.nDLt column holds a list of N integers where the K-th integer is the approximate number of entries in the index that are distinct in the first K columns and where the left-most K columns are collectively less than the left-most K columns of the sample.</source>
          <target state="translated">Столбец sqlite_stat4.nDLt содержит список N целых чисел,где K-ое целое число-это приблизительное количество записей в индексе,которые отличаются в первых K столбцах,и где крайние левые K столбцы вместе меньше крайних левых K столбцов выборки.</target>
        </trans-unit>
        <trans-unit id="dc87c0d99b695b0cfc2da2e070670a4e3020def1" translate="yes" xml:space="preserve">
          <source>The sqlite_stat4.nEq column holds a list of N integers where the K-th integer is the approximate number of entries in the index whose left-most K columns exactly match the K left-most columns of the sample.</source>
          <target state="translated">В столбце sqlite_stat4.nEq находится список N целых чисел,где K-ое число-это приблизительное количество записей в индексе,чьи крайние левые K столбцы точно совпадают с крайними левыми K столбцами выборки.</target>
        </trans-unit>
        <trans-unit id="9c81743d3d82af763c76e0a7b4201b09b9bf99f3" translate="yes" xml:space="preserve">
          <source>The sqlite_stat4.nLt column holds a list of N integers where the K-th integer is the approximate number of entries in the index whose K left-most columns are collectively less than the K left-most columns of the sample.</source>
          <target state="translated">В столбце sqlite_stat4.nLt находится список из N целых чисел,где K-е число-это приблизительное количество записей в индексе,чьи K крайних левых столбцов вместе меньше,чем K крайних левых столбцов выборки.</target>
        </trans-unit>
        <trans-unit id="d2e1c17126c7777e5bb111d59ea8156e8e7627c8" translate="yes" xml:space="preserve">
          <source>The sqlite_stat4.sample column holds a BLOB in the &lt;a href=&quot;fileformat2#record_format&quot;&gt;record format&lt;/a&gt; that encodes the indexed columns followed by the rowid for a rowid table or by the columns of the primary key for a WITHOUT ROWID table. The sqlite_stat4.sample BLOB for the WITHOUT ROWID table itself contains just the columns of the primary key. Let the number of columns encoded by the sqlite_stat4.sample blob be N. For indexes on an ordinary rowid table, N will be one more than the number of columns indexed. For indexes on WITHOUT ROWID tables, N will be the number of columns indexed plus the number of columns in the primary key. For a WITHOUT ROWID table, N will be the number of columns in the primary key.</source>
          <target state="translated">Столбец sqlite_stat4.sample содержит большой двоичный объект в &lt;a href=&quot;fileformat2#record_format&quot;&gt;формате записи,&lt;/a&gt; который кодирует индексированные столбцы, за которыми следует идентификатор строки для таблицы идентификаторов строк или столбцы первичного ключа для таблицы БЕЗ ROWID. Большой двоичный объект sqlite_stat4.sample для самой таблицы БЕЗ ROWID содержит только столбцы первичного ключа. Пусть количество столбцов, закодированных с помощью большого двоичного объекта sqlite_stat4.sample, равно N. Для индексов в обычной таблице rowid N будет на единицу больше, чем количество проиндексированных столбцов. Для индексов в таблицах БЕЗ ROWID N будет числом проиндексированных столбцов плюс количество столбцов в первичном ключе. Для таблицы БЕЗ ROWID N будет числом столбцов в первичном ключе.</target>
        </trans-unit>
        <trans-unit id="d3368a66552678e4208326d2b99cb82cd670c435" translate="yes" xml:space="preserve">
          <source>The sqlite_stat4.tbl column holds name of the table that owns the index that the row describes</source>
          <target state="translated">В столбце sqlite_stat4.tbl хранится имя таблицы,которой принадлежит индекс,описываемый в строке</target>
        </trans-unit>
        <trans-unit id="b005c74909d1b6008d9a724163e0fb64f6a832fd" translate="yes" xml:space="preserve">
          <source>The sqlite_version() function returns the version string for the SQLite library that is running. This function is an SQL wrapper around the &lt;a href=&quot;c3ref/libversion&quot;&gt;sqlite3_libversion()&lt;/a&gt; C-interface.</source>
          <target state="translated">Функция sqlite_version () возвращает строку версии для запущенной библиотеки SQLite. Эта функция является оболочкой SQL вокруг C-интерфейса &lt;a href=&quot;c3ref/libversion&quot;&gt;sqlite3_libversion ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="eeb9bf4120a8b3a5d3dfa457114e73704c247a52" translate="yes" xml:space="preserve">
          <source>The stability of the SQLite database file format and the fact that the file format is cross-platform combine to make SQLite database files an excellent choice as an &lt;a href=&quot;appfileformat&quot;&gt;Application File Format&lt;/a&gt;. The US Library Of Congress acknowledges this by listing SQLite as a &lt;a href=&quot;locrsf&quot;&gt;recommended storage format&lt;/a&gt; for long-term preservation of digital content.</source>
          <target state="translated">Стабильность формата файла базы данных SQLite и тот факт, что формат файла является кросс-платформенным, в совокупности делают файлы базы данных SQLite отличным выбором в качестве &lt;a href=&quot;appfileformat&quot;&gt;формата файла приложения&lt;/a&gt; . Библиотека Конгресса США признает это, перечисляя SQLite в качестве &lt;a href=&quot;locrsf&quot;&gt;рекомендуемого формата хранения&lt;/a&gt; для долгосрочного хранения цифрового контента.</target>
        </trans-unit>
        <trans-unit id="edcbc0ddf3b476ae82b56edb901d58f590378e61" translate="yes" xml:space="preserve">
          <source>The standard SQLite source tree contains built-in VFSes for unix and windows. Alternative VFSes can be added at start-time or run-time using the &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register()&lt;/a&gt; interface.</source>
          <target state="translated">Стандартное дерево исходного кода SQLite содержит встроенные файловые системы VFS для unix и windows. Альтернативные VFS могут быть добавлены во время запуска или выполнения с помощью интерфейса &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3afa9cfa18cab2a00e2e2667b20527102ceccaa0" translate="yes" xml:space="preserve">
          <source>The state of the computer when a database connection is first opened is shown conceptually by the diagram at the right. The area of the diagram on the extreme right (labeled &quot;Disk&quot;) represents information stored on the mass storage device. Each rectangle is a sector. The blue color represents that the sectors contain original data. The middle area is the operating systems disk cache. At the onset of our example, the cache is cold and this is represented by leaving the rectangles of the disk cache empty. The left area of the diagram shows the content of memory for the process that is using SQLite. The database connection has just been opened and no information has been read yet, so the user space is empty.</source>
          <target state="translated">Состояние компьютера при первом открытии подключения к БД концептуально показано диаграммой справа.Область диаграммы справа в крайнем углу (помеченная &quot;Диск&quot;)представляет информацию,хранящуюся на запоминающем устройстве.Каждый прямоугольник представляет собой сектор.Синим цветом показано,что сектора содержат исходные данные.Средняя область-дисковый кэш операционной системы.В начале нашего примера,кэш холодный,и это выражается в том,что прямоугольники дисковой кэш-памяти остаются пустыми.Левая область диаграммы показывает содержимое памяти для процесса,использующего SQLite.Соединение с базой данных только что было открыто и никакой информации пока не прочитано,поэтому пользовательское пространство пустое.</target>
        </trans-unit>
        <trans-unit id="c2357c705a667a06ce3b401fc40060cc2044167c" translate="yes" xml:space="preserve">
          <source>The statement above creates a new geopoly table named &quot;newtab&quot;. Every geopoly table contains a built-in integer &quot;rowid&quot; column and a &quot;_shape&quot; column that contains the polygon associated with that row of the table. The example above also defines three auxiliary data columns named &quot;a&quot;, &quot;b&quot;, and &quot;c&quot; that can store whatever additional information the application needs to associate with each polygon. If there is no need to store auxiliary information, the list of auxiliary columns can be omitted.</source>
          <target state="translated">Вышеупомянутое утверждение создает новую геополитическую таблицу под названием &quot;newtab&quot;.Каждая геополитическая таблица содержит встроенный целочисленный столбец &quot;rowid&quot; и столбец &quot;_shape&quot;,содержащий полигон,связанный с этой строкой таблицы.Пример выше также определяет три вспомогательных столбца данных с именами &quot;a&quot;,&quot;b&quot; и &quot;c&quot;,которые могут хранить любую дополнительную информацию,необходимую приложению для связи с каждым полигоном.Если нет необходимости хранить вспомогательную информацию,список вспомогательных столбцов можно опустить.</target>
        </trans-unit>
        <trans-unit id="d3ed1fe19431b8dcc87a89320be8ef338ed550ea" translate="yes" xml:space="preserve">
          <source>The statement above has three ordinary columns, &quot;a&quot; (the PRIMARY KEY), &quot;b&quot;, and &quot;c&quot;, and two generated columns &quot;d&quot; and &quot;e&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ab1aefcd821f7c6a31149043d5432c19acbdf4f" translate="yes" xml:space="preserve">
          <source>The statement above may appear syntactically incorrect to some. Refer to the section describing the &lt;a href=&quot;fts3#simple_fts_queries&quot;&gt;simple fts queries&lt;/a&gt; for an explanation.</source>
          <target state="translated">Приведенное выше утверждение может кому-то показаться синтаксически неверным. Обратитесь к разделу, описывающему &lt;a href=&quot;fts3#simple_fts_queries&quot;&gt;простые запросы fts&lt;/a&gt; для объяснения.</target>
        </trans-unit>
        <trans-unit id="ecd0da773db50485ad79c3fe0dd58ba001f98f02" translate="yes" xml:space="preserve">
          <source>The statement journal is given a randomized name, not necessarily in the same directory as the main database, and is automatically deleted at the conclusion of the transaction. The size of the statement journal is proportional to the size of the change implemented by the UPDATE or INSERT statement that caused the statement journal to be created.</source>
          <target state="translated">Журналу оператора присваивается рандомизированное имя,не обязательно в том же каталоге,что и основной БД,и автоматически удаляется при заключении сделки.Размер журнала операторов пропорционален размеру изменения,реализованного оператором UPDATE или INSERT,вызвавшего создание журнала операторов.</target>
        </trans-unit>
        <trans-unit id="abce2a89006a756ad8f25f400ff4bbb7de7fef61" translate="yes" xml:space="preserve">
          <source>The status method is basically a wrapper on the &lt;a href=&quot;c3ref/stmt_status&quot;&gt;sqlite3_stmt_status()&lt;/a&gt; C-language interface.</source>
          <target state="translated">Метод status - это, по сути, оболочка интерфейса языка C. &lt;a href=&quot;c3ref/stmt_status&quot;&gt;sqlite3_stmt_status ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c5cf163b4b04538a4fb65ca4f4e01be3e19142a2" translate="yes" xml:space="preserve">
          <source>The step function for an aggregate should always begin with a call to the &lt;a href=&quot;c3ref/aggregate_context&quot;&gt;sqlite3_aggregate_context()&lt;/a&gt; routine to fetch the persistent state of the aggregate function. On the first invocation of the step() function, the aggregate context is initialized to a block of memory that is N bytes in size, where N is the second parameter to sqlite3_aggregate_context() and that memory is zeroed. On all subsequent calls to the step() function, the same block of memory is returned. Except, sqlite3_aggregate_context() might return NULL in the case of an out-of-memory error, so aggregate functions should be prepared to deal with that case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2957b92cef7bca913b9349499bded01bd701447b" translate="yes" xml:space="preserve">
          <source>The strategy is to compile a single SQL statement using &lt;b&gt;sqlite_compile&lt;/b&gt; then invoke &lt;b&gt;sqlite_step&lt;/b&gt; multiple times, once for each row of output, and finally call &lt;b&gt;sqlite_finalize&lt;/b&gt; to clean up after the SQL has finished execution.</source>
          <target state="translated">Стратегия состоит в том, чтобы скомпилировать один оператор SQL с помощью &lt;b&gt;sqlite_compile,&lt;/b&gt; затем вызвать &lt;b&gt;sqlite_step&lt;/b&gt; несколько раз, по одному разу для каждой строки вывода и, наконец, вызвать &lt;b&gt;sqlite_finalize&lt;/b&gt; для очистки после завершения выполнения SQL.</target>
        </trans-unit>
        <trans-unit id="7809402bc982c32307d88a8090b6d47f604ca513" translate="yes" xml:space="preserve">
          <source>The string value P4 of length P1 (bytes) is stored in register P2.</source>
          <target state="translated">Строковое значение P4 длины P1 (байт)хранится в регистре P2.</target>
        </trans-unit>
        <trans-unit id="9a7f87028156aaa8a8bf754d55b553e046a12fec" translate="yes" xml:space="preserve">
          <source>The string value returned by this routine is owned and managed by the database connection. The value will be valid until the database N is &lt;a href=&quot;../lang_detach&quot;&gt;DETACH&lt;/a&gt;-ed or until the database connection closes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb38b0feb448edc668a127b1d9c6a6f2f876060a" translate="yes" xml:space="preserve">
          <source>The string value returned by this routine is owned and managed by the database connection. The value will be valid until the database N is &lt;a href=&quot;lang_detach&quot;&gt;DETACH&lt;/a&gt;-ed or until the database connection closes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="995f4878031e82187c641f145afc9d059e07a6dd" translate="yes" xml:space="preserve">
          <source>The strings returned by sqlite3_sql(P) and sqlite3_normalized_sql(P) are managed by SQLite and are automatically freed when the prepared statement is finalized. The string returned by sqlite3_expanded_sql(P), on the other hand, is obtained from &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc()&lt;/a&gt; and must be free by the application by passing it to &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free()&lt;/a&gt;.</source>
          <target state="translated">Строки, возвращаемые sqlite3_sql (P) и sqlite3_normalized_sql (P), управляются SQLite и автоматически освобождаются, когда подготовленный оператор завершается. Строка, возвращаемая sqlite3_expanded_sql (P), с другой стороны, получается из &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc ()&lt;/a&gt; и должна быть освобождена приложением, передав ее в &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6988de3a51ce0d23769efda8a1dd27ed60344374" translate="yes" xml:space="preserve">
          <source>The strings returned by sqlite3_sql(P) and sqlite3_normalized_sql(P) are managed by SQLite and are automatically freed when the prepared statement is finalized. The string returned by sqlite3_expanded_sql(P), on the other hand, is obtained from &lt;a href=&quot;free&quot;&gt;sqlite3_malloc()&lt;/a&gt; and must be free by the application by passing it to &lt;a href=&quot;free&quot;&gt;sqlite3_free()&lt;/a&gt;.</source>
          <target state="translated">Строки, возвращаемые sqlite3_sql (P) и sqlite3_normalized_sql (P), управляются SQLite и автоматически освобождаются, когда подготовленный оператор завершается. Строка, возвращаемая sqlite3_expanded_sql (P), с другой стороны, получается из &lt;a href=&quot;free&quot;&gt;sqlite3_malloc ()&lt;/a&gt; и должна быть освобождена приложением, передав ее в &lt;a href=&quot;free&quot;&gt;sqlite3_free ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3deeab5872c796defa91ce886ebd57387fbb18a8" translate="yes" xml:space="preserve">
          <source>The subquery and outer query do not both use LIMIT.</source>
          <target state="translated">В подзапросе и внешнем запросе не используется LIMIT.</target>
        </trans-unit>
        <trans-unit id="77e0e5365d2489d6a42fa705340d96f457af3864" translate="yes" xml:space="preserve">
          <source>The subquery and the outer query do not both have ORDER BY clauses.</source>
          <target state="translated">Подзапрос и внешний запрос не имеют пунктов ORDER BY.</target>
        </trans-unit>
        <trans-unit id="c18b6359aac0e334ed733af3b59f97a0357158e6" translate="yes" xml:space="preserve">
          <source>The subquery does not use LIMIT or the outer query does not use aggregates.</source>
          <target state="translated">В подзапросе не используется LIMIT или во внешнем запросе не используются агрегаты.</target>
        </trans-unit>
        <trans-unit id="b5bd1b6abc2be3885b869265a72b70231dcb2d09" translate="yes" xml:space="preserve">
          <source>The subquery does not use LIMIT or the outer query is not a join.</source>
          <target state="translated">Подзапрос не использует LIMIT или внешний запрос не является соединением.</target>
        </trans-unit>
        <trans-unit id="9a0c8ea79566123f0e4ecc1c9a70135357fff910" translate="yes" xml:space="preserve">
          <source>The subquery does not use OFFSET.</source>
          <target state="translated">В подзапросе не используется OFFSET.</target>
        </trans-unit>
        <trans-unit id="8e09a48cd0d988ee9dac8cadad6cdbfcea3b74f2" translate="yes" xml:space="preserve">
          <source>The subquery has a FROM clause.</source>
          <target state="translated">В подзапросе есть пункт FROM.</target>
        </trans-unit>
        <trans-unit id="36f95cae80ab7a78b4e298e8fc4b136f62be389f" translate="yes" xml:space="preserve">
          <source>The subquery in the FROM clause computes the amount by which the inventory should be reduced for each itemId. That subquery is joined against the inventory table and the quantity of each affected inventory row is reduced by the appropriate amount.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14960c81162a6f569b4caa226a699f43010d4c7e" translate="yes" xml:space="preserve">
          <source>The subquery is not DISTINCT.</source>
          <target state="translated">Подзапрос не DISTINCT.</target>
        </trans-unit>
        <trans-unit id="560b14fd5f0c196e23d6c05b79eac72d5d601e25" translate="yes" xml:space="preserve">
          <source>The subquery may not be a recursive CTE.</source>
          <target state="translated">Подзапрос может не быть рекурсивным CTE.</target>
        </trans-unit>
        <trans-unit id="7577bd701d8770ad9fc4050124549876822aa978" translate="yes" xml:space="preserve">
          <source>The substitute character (unicode codepoint 26).</source>
          <target state="translated">Символ подстановки (кодовый юникод 26).</target>
        </trans-unit>
        <trans-unit id="1b25cfaa2f051cde5a374dd5fbd3d25bcae8f82b" translate="yes" xml:space="preserve">
          <source>The substr() function in the SQL view above returns the text of the rbu_control argument with the first character (the one corresponding to column &quot;i&quot;, which is not required by the FTS table) removed.</source>
          <target state="translated">Функция substr()в SQL-виде выше возвращает текст аргумента rbu_control с удаленным первым символом (символ,соответствующий столбцу &quot;i&quot;,который не требуется таблицей FTS).</target>
        </trans-unit>
        <trans-unit id="1eb749257ff54f4f9f61b55605ad1eef34135ccf" translate="yes" xml:space="preserve">
          <source>The substr(X,Y,Z) function returns a substring of input string X that begins with the Y-th character and which is Z characters long. If Z is omitted then substr(X,Y) returns all characters through the end of the string X beginning with the Y-th. The left-most character of X is number 1. If Y is negative then the first character of the substring is found by counting from the right rather than the left. If Z is negative then the abs(Z) characters preceding the Y-th character are returned. If X is a string then characters indices refer to actual UTF-8 characters. If X is a BLOB then the indices refer to bytes.</source>
          <target state="translated">Функция подстроки(X,Y,Z)возвращает подстроку входной строки X,которая начинается с Y-символа и имеет длину Z символов.Если Z опущена,то функция substr(X,Y,Y)возвращает все символы через конец строки X,начинающийся с Y-ого символа.Самый левый символ X-номер 1.Если Y отрицательный,то первый символ подстроки будет найден путем подсчета справа,а не слева.Если Z отрицательный,то возвращаются абс(Z)символы,предшествующие Y-му символу.Если X-строка,то символьные индексы относятся к действительным символам UTF-8.Если X-BLOB,то индексы относятся к байтам.</target>
        </trans-unit>
        <trans-unit id="8f8f72577e48839e2c6e724a5bcfafdf7566b512" translate="yes" xml:space="preserve">
          <source>The sum of all &quot;four&quot; values. This is used to compute &quot;avg(four)&quot;.</source>
          <target state="translated">Сумма всех &quot;четырех&quot; значений.Это используется для вычисления &quot;avg(четыре)&quot;.</target>
        </trans-unit>
        <trans-unit id="4a5f1cfa6e3d0c304a8016c9b0a8f3f6f7afd998" translate="yes" xml:space="preserve">
          <source>The sum() and total() aggregate functions return sum of all non-NULL values in the group. If there are no non-NULL input rows then sum() returns NULL but total() returns 0.0. NULL is not normally a helpful result for the sum of no rows but the SQL standard requires it and most other SQL database engines implement sum() that way so SQLite does it in the same way in order to be compatible. The non-standard total() function is provided as a convenient way to work around this design problem in the SQL language.</source>
          <target state="translated">Функции sum()и total()агрегата возвращают сумму всех не нулевых значений в группе.Если нет не нулевых входных строк,то функция sum()возвращает NULL,но total()возвращает 0.0.Обычно NULL не является полезным результатом для суммы без строк,но стандарт SQL требует этого,и большинство других движков баз данных SQL реализуют sum()таким образом,чтобы SQLite делал это таким же образом,чтобы быть совместимым.Нестандартная функция total()предусмотрена в качестве удобного способа обойти эту проблему проектирования на языке SQL.</target>
        </trans-unit>
        <trans-unit id="c8cc59294c9d81aba99fd5de24fb6dc6b41b0132" translate="yes" xml:space="preserve">
          <source>The super-journal file is only created for &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; operations that involve multiple database files where at least two of the databases meet all of the following requirements:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ee67fa1e83c36dfa202c1d70aacf19927252737" translate="yes" xml:space="preserve">
          <source>The super-journal file is used as part of the atomic commit process when a single transaction makes changes to multiple databases that have been added to a single &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; using the &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; statement. The super-journal file is always located in the same directory as the main database file (the main database file is the database that is identified in the original &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open16()&lt;/a&gt;, or &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; call that created the &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt;) with a randomized suffix. The super-journal file contains the names of all of the various attached auxiliary databases that were changed during the transaction. The multi-database transaction commits when the super-journal file is deleted. See the documentation titled &lt;a href=&quot;atomiccommit&quot;&gt;Atomic Commit In SQLite&lt;/a&gt; for additional detail.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b11b2e43da7a9faed114feb7f008a51dec0a5a77" translate="yes" xml:space="preserve">
          <source>The suppression of redundant columns in the key suffix of an index entry only occurs in WITHOUT ROWID tables. In an ordinary rowid table, the index entry always ends with the rowid even if the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; column is one of the columns being indexed.</source>
          <target state="translated">Подавление избыточных столбцов в ключевом суффиксе записи индекса происходит только в таблицах БЕЗ ROWID. В обычной таблице rowid запись индекса всегда заканчивается rowid, даже если столбец &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; является одним из индексируемых столбцов.</target>
        </trans-unit>
        <trans-unit id="2572ed867faedb74714d50c5898bcb75f0754e78" translate="yes" xml:space="preserve">
          <source>The swarmvtab implementation may open or close databases at any point. By default, it attempts to limit the maximum number of simultaneously open database files to nine. This is not a hard limit - it is possible to construct a scenario that will cause swarmvtab to exceed it.</source>
          <target state="translated">Реализация swarmvtab может открыть или закрыть базы данных в любой момент.По умолчанию она пытается ограничить максимальное количество одновременно открытых файлов БД девятью.Это не жесткое ограничение-можно построить сценарий,при котором swarmvtab превысит его.</target>
        </trans-unit>
        <trans-unit id="9f9e99aa51f888cdf6630598d938ef39ae15f9a3" translate="yes" xml:space="preserve">
          <source>The sync operations that SQLite performs to help ensure integrity can be disabled at run-time using the &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;synchronous pragma&lt;/a&gt;. By setting PRAGMA synchronous=OFF, all sync operations are omitted. This makes SQLite seem to run faster, but it also allows the operating system to freely reorder writes, which could result in database corruption if a power failure or hard reset occurs prior to all content reaching persistent storage.</source>
          <target state="translated">Операции синхронизации, выполняемые SQLite для обеспечения целостности, можно отключить во время выполнения с помощью &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;прагмы synchronous&lt;/a&gt; . При установке PRAGMA synchronous = OFF все операции синхронизации опускаются. Это заставляет SQLite работать быстрее, но также позволяет операционной системе свободно переупорядочивать записи, что может привести к повреждению базы данных, если сбой питания или полный сброс произойдет до того, как весь контент попадет в постоянное хранилище.</target>
        </trans-unit>
        <trans-unit id="8ed0f1cf6ef82d0d97320ed63cceee25b526aa88" translate="yes" xml:space="preserve">
          <source>The synchronous version of SQLite is the slowest of the group in this test, but the asynchronous version is the fastest. The difference is the extra time needed to execute fsync().</source>
          <target state="translated">Синхронная версия SQLite-самая медленная из группы в данном тесте,но асинхронная-самая быстрая.Разница заключается в дополнительном времени,необходимом для выполнения fsync().</target>
        </trans-unit>
        <trans-unit id="88535ccaca4588c188d3dec59b74e5b6c648c437" translate="yes" xml:space="preserve">
          <source>The syntax for a window function is like this:</source>
          <target state="translated">Синтаксис для оконной функции такой:</target>
        </trans-unit>
        <trans-unit id="e97f2e6030323368e9626fb51e9e8ff6dc7c7f0a" translate="yes" xml:space="preserve">
          <source>The syntax for integer and floating point literals (collectively &quot;numeric literals&quot;) is shown by the following diagram:</source>
          <target state="translated">Синтаксис целых и плавающих литералов (вместе &quot;числовые литералы&quot;)показан на следующей диаграмме:</target>
        </trans-unit>
        <trans-unit id="c1140f24a0825da092ba683013464dc50c75b952" translate="yes" xml:space="preserve">
          <source>The syntax for row values and the circumstances in which row values can be used are illustrated in examples below.</source>
          <target state="translated">Синтаксис значений рядов и обстоятельства,при которых значения рядов могут быть использованы,проиллюстрированы в примерах ниже.</target>
        </trans-unit>
        <trans-unit id="0601104dedcf396efbb0c30203a6d31fd40a4a67" translate="yes" xml:space="preserve">
          <source>The syntax for the ON CONFLICT clause is as shown above for the CREATE TABLE command. For the INSERT and UPDATE commands, the keywords &quot;ON CONFLICT&quot; are replaced by &quot;OR&quot; so that the syntax reads more naturally. For example, instead of &quot;INSERT ON CONFLICT IGNORE&quot; we have &quot;INSERT OR IGNORE&quot;. The keywords change but the meaning of the clause is the same either way.</source>
          <target state="translated">Синтаксис пункта ON CONFLICT выглядит так,как показано выше для команды CREATE TABLE.Для команд INSERT и UPDATE ключевые слова &quot;ON CONFLICT&quot; заменены на &quot;OR&quot;,чтобы синтаксис читался более естественно.Например,вместо &quot;INSERT ON CONFLICT IGNORE&quot; мы имеем &quot;INSERT OR IGNORE&quot;.Ключевые слова меняются,но значение пункта в любом случае одинаково.</target>
        </trans-unit>
        <trans-unit id="f067d61a53dcb338fdf63bf3df528ef6a0487e73" translate="yes" xml:space="preserve">
          <source>The syntax looks like this:</source>
          <target state="translated">Синтаксис выглядит так:</target>
        </trans-unit>
        <trans-unit id="a61a22c417283e11aa14f2ba9ecd8cd0c90ce62d" translate="yes" xml:space="preserve">
          <source>The syntax of the &lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt;, &lt;a href=&quot;lang_dropindex&quot;&gt;DROP INDEX&lt;/a&gt;, &lt;a href=&quot;lang_dropview&quot;&gt;DROP VIEW&lt;/a&gt;, &lt;a href=&quot;lang_droptrigger&quot;&gt;DROP TRIGGER&lt;/a&gt;, &lt;a href=&quot;lang_reindex&quot;&gt;REINDEX&lt;/a&gt;, &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE&lt;/a&gt; and many other commands all permit the user to specify a database object either by its name alone, or by a combination of its name and the name of its database. If no database is specified as part of the object reference, then SQLite searches the main, temp and all attached databases for an object with a matching name. The temp database is searched first, followed by the main database, followed all attached databases in the order that they were attached. The reference resolves to the first match found. For example:</source>
          <target state="translated">Синтаксис команд &lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt; , &lt;a href=&quot;lang_dropindex&quot;&gt;DROP INDEX&lt;/a&gt; , &lt;a href=&quot;lang_dropview&quot;&gt;DROP VIEW&lt;/a&gt; , &lt;a href=&quot;lang_droptrigger&quot;&gt;DROP TRIGGER&lt;/a&gt; , &lt;a href=&quot;lang_reindex&quot;&gt;REINDEX&lt;/a&gt; , &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE&lt;/a&gt; и многих других команд позволяет пользователю указать объект базы данных либо только по его имени, либо по комбинации его имени и имени свою базу данных. Если база данных не указана как часть ссылки на объект, SQLite ищет в основной, временной и всех подключенных базах данных объект с совпадающим именем. Сначала ищется временная база данных, затем основная база данных, а затем все присоединенные базы данных в том порядке, в котором они были присоединены. Ссылка преобразуется в первое найденное совпадение. Например:</target>
        </trans-unit>
        <trans-unit id="070a4a12a4cd8479f973f088343e30dee884b914" translate="yes" xml:space="preserve">
          <source>The syntax that occurs in between the &quot;ON CONFLICT&quot; and &quot;DO&quot; keywords is called the &quot;conflict target&quot;. The conflict target specifies a specific uniqueness constraint that will trigger the upsert. The conflict target is required for DO UPDATE upserts, but is optional for DO NOTHING. When the conflict target is omitted, the upsert behavior is triggered by a violation of any uniqueness constraint on the table of the INSERT.</source>
          <target state="translated">Синтаксис,возникающий между ключевыми словами &quot;ON CONFLICT&quot; и &quot;DO&quot;,называется &quot;конфликтной целью&quot;.Конфликтная цель задает специфическое ограничение уникальности,которое спровоцирует взлет.Конфликтная цель необходима для поднятия DO UPDATE,но необязательна для DO NOTHING.Когда конфликтная цель опущена,поведение выпадения вызывается нарушением любого ограничения уникальности на таблице INSERT.</target>
        </trans-unit>
        <trans-unit id="6578fb33b7ba1ef0fa58c80688a069c9340aa258" translate="yes" xml:space="preserve">
          <source>The szOsFile field is the size in bytes of the structure that defines an open file: the &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; object. This object will be described more fully below. The point here is that each VFS implementation can define its own &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; object containing whatever information the VFS implementation needs to store about an open file. SQLite needs to know how big this object is, however, in order to preallocate enough space to hold it.</source>
          <target state="translated">Поле szOsFile - это размер в байтах структуры, которая определяет открытый файл: объект &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; . Более подробно этот объект будет описан ниже. Дело в том, что каждая реализация VFS может определять свой собственный объект &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file,&lt;/a&gt; содержащий любую информацию, которую реализация VFS должна хранить об открытом файле. Однако SQLite необходимо знать, насколько велик этот объект, чтобы предварительно выделить достаточно места для его хранения.</target>
        </trans-unit>
        <trans-unit id="4160b3968588675d955230ce2bf92a9066be0932" translate="yes" xml:space="preserve">
          <source>The szOsFile field is the size of the subclassed &lt;a href=&quot;#sqlite3_file&quot;&gt;sqlite3_file&lt;/a&gt; structure used by this VFS. mxPathname is the maximum length of a pathname in this VFS.</source>
          <target state="translated">Поле szOsFile - это размер подклассовой структуры &lt;a href=&quot;#sqlite3_file&quot;&gt;sqlite3_file,&lt;/a&gt; используемой этой VFS. mxPathname - максимальная длина пути в этой VFS.</target>
        </trans-unit>
        <trans-unit id="0c08ad2486a604361da59adedd8095e01f05af8a" translate="yes" xml:space="preserve">
          <source>The szOsFile field is the size of the subclassed &lt;a href=&quot;file&quot;&gt;sqlite3_file&lt;/a&gt; structure used by this VFS. mxPathname is the maximum length of a pathname in this VFS.</source>
          <target state="translated">Поле szOsFile - это размер подклассовой структуры &lt;a href=&quot;file&quot;&gt;sqlite3_file,&lt;/a&gt; используемой этой VFS. mxPathname - максимальная длина пути в этой VFS.</target>
        </trans-unit>
        <trans-unit id="34b2e05f8be89f8919f89034a92c2255013098b0" translate="yes" xml:space="preserve">
          <source>The t2 table is completely unused in the query above, and so the query planner is able to implement the query as if it were written:</source>
          <target state="translated">Таблица t2 полностью не используется в вышеуказанном запросе,поэтому планировщик запросов может реализовать запрос так,как если бы он был записан:</target>
        </trans-unit>
        <trans-unit id="4238f21507c2ee050a84b88e1b8452b278b7cbd3" translate="yes" xml:space="preserve">
          <source>The table &quot;t1&quot; has four columns &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, and &quot;d&quot; that have no particular datatype assigned. You can store anything you want in any of those columns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69666453d6f0a7ffe136a772a15ed97e78f29762" translate="yes" xml:space="preserve">
          <source>The table being clear is in the main database file if P2==0. If P2==1 then the table to be clear is in the auxiliary database file that is used to store tables create using CREATE TEMPORARY TABLE.</source>
          <target state="translated">Очищаемая таблица находится в основном файле БД,если P2==0.Если P2==1,то очищаемая таблица находится во вспомогательном файле БД,который используется для хранения таблиц,создаваемых с помощью CREATE TEMPORARY TABLE.</target>
        </trans-unit>
        <trans-unit id="b84cc68d91e3409f1edcdf58fc339f372294c1e2" translate="yes" xml:space="preserve">
          <source>The table being destroyed is in the main database file if P3==0. If P3==1 then the table to be clear is in the auxiliary database file that is used to store tables create using CREATE TEMPORARY TABLE.</source>
          <target state="translated">Уничтожаемая таблица находится в основном файле БД,если P3==0.Если P3==1,то очищаемая таблица находится во вспомогательном файле БД,который используется для хранения таблиц,создаваемых с помощью CREATE TEMPORARY TABLE.</target>
        </trans-unit>
        <trans-unit id="41f345ab868d88acd8992e4784839c2d5c1e8639" translate="yes" xml:space="preserve">
          <source>The table below lists a few of the virtual tables implementations available for SQLite. Developers can deploy these virtual tables in their own applications, or use the implementations shown below as templates for writing their own virtual tables.</source>
          <target state="translated">В таблице ниже перечислены некоторые из реализаций виртуальных таблиц,доступных для SQLite.Разработчики могут развернуть эти виртуальные таблицы в своих приложениях или использовать реализации,показанные ниже,в качестве шаблонов для написания собственных виртуальных таблиц.</target>
        </trans-unit>
        <trans-unit id="0d5035ee89279b64afd0eeb8d11272d1a3924472" translate="yes" xml:space="preserve">
          <source>The table conceptually has a number of rows and columns. But these numbers are not part of the result table itself. These numbers are obtained separately. Let N be the number of rows and M be the number of columns.</source>
          <target state="translated">Таблица концептуально имеет ряд строк и столбцов.Но эти числа не являются частью самой таблицы результатов.Эти номера получены отдельно.Пусть N будет числом строк,а M-числом столбцов.</target>
        </trans-unit>
        <trans-unit id="dcf57858fad384bb52da74fd124071a651012ac9" translate="yes" xml:space="preserve">
          <source>The table has at least as many columns as recorded in the changeset, and</source>
          <target state="translated">В таблице есть как минимум столько же столбцов,сколько было записано в changeset,и</target>
        </trans-unit>
        <trans-unit id="c59c86844961ecda887187879536aa8941add7f6" translate="yes" xml:space="preserve">
          <source>The table has primary key columns in the same position as recorded in the changeset.</source>
          <target state="translated">Таблица имеет колонки с первичными ключами в той же позиции,что и записанная в changeset.</target>
        </trans-unit>
        <trans-unit id="80f1ee5eb53df523cde7e4859fa53a41bb0e9f57" translate="yes" xml:space="preserve">
          <source>The table has the same name as the name recorded in the changeset, and</source>
          <target state="translated">Таблица имеет то же имя,что и имя,записанное в changeset,и</target>
        </trans-unit>
        <trans-unit id="7d27b581c3631a8cd2d37de114b2996daa06d034" translate="yes" xml:space="preserve">
          <source>The table named in the table_info pragma can also be a view.</source>
          <target state="translated">Таблица,названная в прагме table_info,также может быть представлением.</target>
        </trans-unit>
        <trans-unit id="79bd6ebb5ebe8eca1811d6164c483996ae2dbb59" translate="yes" xml:space="preserve">
          <source>The table named on the left-hand side of the AS keyword must appear exactly once in the FROM clause of the right-most SELECT statement of the compound select, and nowhere else.</source>
          <target state="translated">Таблица,названная с левой стороны ключевого слова AS,должна появиться ровно один раз в пункте FROM крайнего правого оператора SELECT составного селекции,и больше нигде.</target>
        </trans-unit>
        <trans-unit id="747fb24ebf8caf800f314099b86fad330ec2bb21" translate="yes" xml:space="preserve">
          <source>The table that is being changed</source>
          <target state="translated">Таблица,которая меняется</target>
        </trans-unit>
        <trans-unit id="e089550b926c62bbc2dcb5b20ca60a982f76e723" translate="yes" xml:space="preserve">
          <source>The table-name specified as part of a DELETE statement within a trigger body must be unqualified. In other words, the</source>
          <target state="translated">Название таблицы,указанное как часть заявления об УДАЛЕНИИ внутри тела триггера,должно быть безоговорочным.Другими словами,</target>
        </trans-unit>
        <trans-unit id="f34e54cb0abeaba37df0e01490317583d5a035fb" translate="yes" xml:space="preserve">
          <source>The table-name specified as part of an UPDATE statement within a trigger body must be unqualified. In other words, the</source>
          <target state="translated">Название таблицы,указанное как часть заявления UPDATE в теле триггера,должно быть безоговорочным.Другими словами</target>
        </trans-unit>
        <trans-unit id="234e68825ade4fb4c6a3d0e2fe2ac2487e1f2eea" translate="yes" xml:space="preserve">
          <source>The table-valued function returns one row for each record (file, directory or symbolic link) in the zip archive. Each row has the following columns:</source>
          <target state="translated">Функция табличного значения возвращает по одной строке для каждой записи (файла,каталога или символической ссылки)в zip-архиве.Каждая строка имеет следующие столбцы:</target>
        </trans-unit>
        <trans-unit id="d7dc1f7c6b1a5d93554b66158b8eab41e9fa0f02" translate="yes" xml:space="preserve">
          <source>The table-valued function syntax may also be used to specify an alternative ranking function. In this case the text describing the ranking function should be specified as the second table-valued function argument. The following three queries are equivalent:</source>
          <target state="translated">Синтаксис функции табличных значений может также использоваться для указания альтернативной функции ранжирования.В этом случае текст,описывающий рейтинговую функцию,должен быть указан в качестве второго аргумента таблично-значимой функции.Следующие три запроса эквивалентны:</target>
        </trans-unit>
        <trans-unit id="194c5b8001842ee44aaaa2c4539d9e178d7c37bd" translate="yes" xml:space="preserve">
          <source>The table-valued functions for PRAGMA feature was added in SQLite version 3.16.0 (2017-01-02). Prior versions of SQLite cannot use this feature.</source>
          <target state="translated">В SQLite версии 3.16.0 (2017-01-02)добавлены табличные функции для функции PRAGMA.Предыдущие версии SQLite не могли использовать эту функцию.</target>
        </trans-unit>
        <trans-unit id="273bdbb137f334009fcac2c6deba9c8d09edc07d" translate="yes" xml:space="preserve">
          <source>The tableZ table has a single column named &quot;INTEGER&quot;. That column has no datatype specified, but it is the PRIMARY KEY. The column is &lt;em&gt;not&lt;/em&gt; the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; for the table because it has no datatype. The &quot;INTEGER&quot; token is used as an identifier for the column name, not as a datatype keyword.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1296ca23d366e0c8b6ad53b34a86a007a9e6fcba" translate="yes" xml:space="preserve">
          <source>The tables necessary to do full and proper unicode case folding are larger than the whole SQLite library.</source>
          <target state="translated">Таблицы,необходимые для полного и правильного юникодного сгибания корпуса,больше,чем вся библиотека SQLite.</target>
        </trans-unit>
        <trans-unit id="1fa68f636ed5379e184e8d386d825c36877f4a63" translate="yes" xml:space="preserve">
          <source>The tables that participate in a union-vtab can be in the same database file, or they can be in separate databases files that are &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt;-ed to the same database connection.</source>
          <target state="translated">Таблицы, участвующие в union-vtab, могут находиться в одном файле базы данных или в отдельных файлах базы данных, которые &lt;a href=&quot;lang_attach&quot;&gt;прикреплены&lt;/a&gt; к одному и тому же соединению с базой данных.</target>
        </trans-unit>
        <trans-unit id="0d9a0645c34c7b267a5cc6a578129314b8359efc" translate="yes" xml:space="preserve">
          <source>The tables_used table is intended to show which btrees of the database file are read or written by a prepared statement, both by the main statement itself but also by related triggers and foreign key actions. The columns are as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30590c6f42ddca035bfcfa04a6fd54a5c5428cad" translate="yes" xml:space="preserve">
          <source>The target database may already contain a row with the same PRIMARY KEY values as specified by the INSERT change.</source>
          <target state="translated">Целевая база данных может уже содержать строку с теми же значениями PRIMARY KEY,которые указаны изменением INSERT.</target>
        </trans-unit>
        <trans-unit id="ddffb3a24b55dea30b114ff8f89840fe90c8c752" translate="yes" xml:space="preserve">
          <source>The target database may contain a row with the specified PRIMARY KEY values, but the current values of the fields that will be modified by the change may not match the original values stored within the changeset. This type of conflict is not detected when using a patchset.</source>
          <target state="translated">Целевая база данных может содержать строку с указанными значениями PRIMARY KEY,однако текущие значения полей,которые будут изменены в результате изменения,могут не совпадать с исходными значениями,сохраненными в changeset.Этот тип конфликта не обнаруживается при использовании патчсета.</target>
        </trans-unit>
        <trans-unit id="9637f3da3aa12d5bcfe7a6adc7e68c320df396f3" translate="yes" xml:space="preserve">
          <source>The target database may contain a row with the specified PRIMARY KEY values, but the other fields may contain values that do not match those stored as part of the changeset. This type of conflict is not detected when using a patchset.</source>
          <target state="translated">Целевая база данных может содержать строку с указанными значениями PRIMARY KEY,но другие поля могут содержать значения,не совпадающие со значениями,сохраненными в changeset.Этот тип конфликта не обнаруживается при использовании набора патчей.</target>
        </trans-unit>
        <trans-unit id="11c37f0367cfc6691a61d3fba7a936ab62a7d348" translate="yes" xml:space="preserve">
          <source>The target database may contain no row with the specified PRIMARY KEY values to delete.</source>
          <target state="translated">Целевая база данных может не содержать строк с указанными для удаления значениями PRIMARY KEY.</target>
        </trans-unit>
        <trans-unit id="e2b06a833985a4c35aa0208799ae843a7b65a575" translate="yes" xml:space="preserve">
          <source>The target database may contain no row with the specified PRIMARY KEY values to modify.</source>
          <target state="translated">Целевая база данных может не содержать строк с заданными значениями PRIMARY KEY для изменения.</target>
        </trans-unit>
        <trans-unit id="6f87cac991eff302d9976172f7bdf73e926bb9c2" translate="yes" xml:space="preserve">
          <source>The target database may not be in &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt;.</source>
          <target state="translated">Целевая база данных может быть не в &lt;a href=&quot;wal&quot;&gt;режиме WAL&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e79db16e64c18b69803344025e269d729d3745a5" translate="yes" xml:space="preserve">
          <source>The target table is not included in the FROM clause, unless the intent is to do a self-join against the target table. In the event of a self-join, the table in the FROM clause must be aliased to a different name than the target table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="711e958f26b3fdef5ca444454f4ee0f963fc86d6" translate="yes" xml:space="preserve">
          <source>The task of the &quot;query planner&quot; is to figure out the best algorithm or &quot;query plan&quot; to accomplish an SQL statement. Beginning with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_0.html&quot;&gt;version 3.8.0&lt;/a&gt; (2013-08-26), the query planner component has been rewritten so that it runs faster and generates better plans. The rewrite is called the &quot;next generation query planner&quot; or &quot;NGQP&quot;.</source>
          <target state="translated">Задача &amp;laquo;планировщика запросов&amp;raquo; - выяснить лучший алгоритм или &amp;laquo;план запроса&amp;raquo; для выполнения оператора SQL. Начиная с &lt;a href=&quot;https://sqlite.org/releaselog/3_8_0.html&quot;&gt;версии&lt;/a&gt; SQLite 3.8.0 (2013-08-26), компонент планировщика запросов был переписан, чтобы он работал быстрее и генерировал лучшие планы. Перезапись называется &amp;laquo;планировщик запросов следующего поколения&amp;raquo; или &amp;laquo;NGQP&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="42a7ae31a25e761d6c699099d742c17f30af41a6" translate="yes" xml:space="preserve">
          <source>The team_id field cannot be unique because there usually multiple people on the same team. One cannot make the combination of team_id and is_team_leader unique since there are usually multiple non-leaders on each team. The solution to enforcing one leader per team is to create a unique index on team_id but restricted to those entries for which is_team_leader is true:</source>
          <target state="translated">Поле team_id не может быть уникальным,потому что обычно в одной команде несколько человек.Нельзя сделать уникальной комбинацию team_id и is_team_leader,так как в каждой команде обычно несколько нелидеров.Решение по введению в действие одного лидера в каждой команде заключается в создании уникального индекса на идентификаторе_команды,но только для тех записей,для которых значение_team_leader равно true:</target>
        </trans-unit>
        <trans-unit id="0785e2dbbfabdba0d3916b209d305b3e5683f44f" translate="yes" xml:space="preserve">
          <source>The technique of having xFindFunction() return values of &lt;a href=&quot;c3ref/c_index_constraint_eq&quot;&gt;SQLITE_INDEX_CONSTRAINT_FUNCTION&lt;/a&gt; was initially used in the implementation of the &lt;a href=&quot;geopoly&quot;&gt;Geopoly module&lt;/a&gt;. The xFindFunction() method of that module returns SQLITE_INDEX_CONSTRAINT_FUNCTION for the &lt;a href=&quot;geopoly#goverlap&quot;&gt;geopoly_overlap()&lt;/a&gt; SQL function and it returns SQLITE_INDEX_CONSTRAINT_FUNCTION+1 for the &lt;a href=&quot;geopoly#gwithin&quot;&gt;geopoly_within()&lt;/a&gt; SQL function. This permits search optimizations for queries such as:</source>
          <target state="translated">Методика возврата xFindFunction () значений &lt;a href=&quot;c3ref/c_index_constraint_eq&quot;&gt;SQLITE_INDEX_CONSTRAINT_FUNCTION&lt;/a&gt; изначально использовалась при реализации &lt;a href=&quot;geopoly&quot;&gt;модуля Geopoly&lt;/a&gt; . Метод xFindFunction () этого модуля возвращает SQLITE_INDEX_CONSTRAINT_FUNCTION для функции SQL &lt;a href=&quot;geopoly#goverlap&quot;&gt;geopoly_overlap ()&lt;/a&gt; и возвращает SQLITE_INDEX_CONSTRAINT_FUNCTION + 1 для функции SQL &lt;a href=&quot;geopoly#gwithin&quot;&gt;geopoly_within ()&lt;/a&gt; . Это позволяет оптимизировать поиск по таким запросам, как:</target>
        </trans-unit>
        <trans-unit id="2710792de033b547bac6e441ea1f9b9d8e9fc431" translate="yes" xml:space="preserve">
          <source>The temp.sqlite_parameters table only provides values for parameters in the command-line shell. The temp.sqlite_parameter table has no effect on queries that are run directly using the SQLite C-language API. Individual applications are expected to implement their own parameter binding. You can search for &quot;sqlite_parameters&quot; in the &lt;a href=&quot;https://sqlite.org/src/file/src/shell.c.in&quot;&gt;command-line shell source code&lt;/a&gt; to see how the command-line shell does parameter binding, and use that as a hint for how to implement it yourself.</source>
          <target state="translated">Таблица temp.sqlite_parameters предоставляет значения только для параметров в оболочке командной строки. Таблица temp.sqlite_parameter не влияет на запросы, которые выполняются напрямую с помощью SQLite C-language API. Ожидается, что отдельные приложения будут реализовывать свои собственные привязки параметров. Вы можете найти &amp;laquo;sqlite_parameters&amp;raquo; в &lt;a href=&quot;https://sqlite.org/src/file/src/shell.c.in&quot;&gt;исходном коде оболочки командной строки,&lt;/a&gt; чтобы увидеть, как оболочка командной строки выполняет привязку параметров, и использовать это как подсказку о том, как реализовать это самостоятельно.</target>
        </trans-unit>
        <trans-unit id="e0243e43a9e092811e1870e88e873ed47024b50d" translate="yes" xml:space="preserve">
          <source>The temporary file created by the &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; command exists only for the duration of the command itself. The size of the temporary file will be no larger than the original database.</source>
          <target state="translated">Временный файл, созданный командой &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM,&lt;/a&gt; существует только на время действия самой команды. Размер временного файла не будет больше размера исходной базы данных.</target>
        </trans-unit>
        <trans-unit id="2f2df5fab6b729ca7d2c3e78798e53760ca0b74f" translate="yes" xml:space="preserve">
          <source>The temporary files associated with the TEMP database and its rollback journal are only created if the application makes use of the &quot;CREATE TEMP TABLE&quot; statement.</source>
          <target state="translated">Временные файлы,связанные с базой данных TEMP и ее журналом отката,создаются только в том случае,если приложение использует оператор &quot;CREATE TEMP TABLE&quot;.</target>
        </trans-unit>
        <trans-unit id="f07c39bdad21f0453b3d046fa930925221ebb2c1" translate="yes" xml:space="preserve">
          <source>The temporary files associated with transaction control, namely the rollback journal, master journal, write-ahead log (WAL) files, and shared-memory files, are always written to disk. But the other kinds of temporary files might be stored in memory only and never written to disk. Whether or not temporary files other than the rollback, master, and statement journals are written to disk or stored only in memory depends on the &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; compile-time parameter, the &lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;temp_store pragma&lt;/a&gt;, and on the size of the temporary file.</source>
          <target state="translated">Временные файлы, связанные с управлением транзакциями, а именно журнал отката, главный журнал, файлы журнала упреждающей записи (WAL) и файлы совместно используемой памяти, всегда записываются на диск. Но другие типы временных файлов могут храниться только в памяти и никогда не записываться на диск. Записываются ли временные файлы, отличные от журналов отката, главного журнала и операторов, на диск или хранятся только в памяти, зависит от параметра &lt;a href=&quot;compile#temp_store&quot;&gt;времени&lt;/a&gt; компиляции SQLITE_TEMP_STORE , &lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;прагмы temp_store&lt;/a&gt; и от размера временного файла.</target>
        </trans-unit>
        <trans-unit id="408ca6d25d3ec064e51ba766d2fa74811ccbfcc3" translate="yes" xml:space="preserve">
          <source>The temporary files associated with transaction control, namely the rollback journal, super-journal, write-ahead log (WAL) files, and shared-memory files, are always written to disk. But the other kinds of temporary files might be stored in memory only and never written to disk. Whether or not temporary files other than the rollback, super, and statement journals are written to disk or stored only in memory depends on the &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; compile-time parameter, the &lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;temp_store pragma&lt;/a&gt;, and on the size of the temporary file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42ee5d948678f086d276ab61d7dad5de2797f6e5" translate="yes" xml:space="preserve">
          <source>The term number of the matching term within the full-text query expression. Terms within a query expression are numbered starting from 0 in the order that they occur.</source>
          <target state="translated">Номер совпадающего члена в выражении полнотекстового запроса.Термины в выражении запроса нумеруются,начиная с 0,в порядке их появления.</target>
        </trans-unit>
        <trans-unit id="2146ad4958dfdca7b01896ef7e97e3c556f6bfc0" translate="yes" xml:space="preserve">
          <source>The term, as stored in the FTS5 index.</source>
          <target state="translated">Термин,хранящийся в индексе FTS5.</target>
        </trans-unit>
        <trans-unit id="efaf8ed4fd273fae5234c31a87ca20e1f921ce05" translate="yes" xml:space="preserve">
          <source>The terms &quot;protected&quot; and &quot;unprotected&quot; refer to whether or not a mutex is held. An internal mutex is held for a protected sqlite3_value object but no mutex is held for an unprotected sqlite3_value object. If SQLite is compiled to be single-threaded (with &lt;a href=&quot;../compile#threadsafe&quot;&gt;SQLITE_THREADSAFE=0&lt;/a&gt; and with &lt;a href=&quot;threadsafe&quot;&gt;sqlite3_threadsafe()&lt;/a&gt; returning 0) or if SQLite is run in one of reduced mutex modes &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigsinglethread&quot;&gt;SQLITE_CONFIG_SINGLETHREAD&lt;/a&gt; or &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigmultithread&quot;&gt;SQLITE_CONFIG_MULTITHREAD&lt;/a&gt; then there is no distinction between protected and unprotected sqlite3_value objects and they can be used interchangeably. However, for maximum code portability it is recommended that applications still make the distinction between protected and unprotected sqlite3_value objects even when not strictly required.</source>
          <target state="translated">Термины &amp;laquo;защищенный&amp;raquo; и &amp;laquo;незащищенный&amp;raquo; относятся к тому, удерживается ли мьютекс. Внутренний мьютекс сохраняется для защищенного объекта sqlite3_value, но не сохраняется мьютекс для незащищенного объекта sqlite3_value. Если SQLite скомпилирован как однопоточный (с &lt;a href=&quot;../compile#threadsafe&quot;&gt;SQLITE_THREADSAFE = 0&lt;/a&gt; и &lt;a href=&quot;threadsafe&quot;&gt;sqlite3_threadsafe (),&lt;/a&gt; возвращающим 0) или если SQLite запущен в одном из сокращенных режимов мьютекса, &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigsinglethread&quot;&gt;SQLITE_CONFIG_SINGLETHREAD&lt;/a&gt; или &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigmultithread&quot;&gt;SQLITE_CONFIG_MULTITHREAD,&lt;/a&gt; тогда нет различий между защищенными и незащищенными объектами sq3. использоваться как взаимозаменяемые. Однако для максимальной переносимости кода рекомендуется, чтобы приложения по-прежнему делали различие между защищенными и незащищенными объектами sqlite3_value, даже если это не требуется строго.</target>
        </trans-unit>
        <trans-unit id="9b59119835d0c98638847083b9be8651dcfed7b3" translate="yes" xml:space="preserve">
          <source>The terms &quot;protected&quot; and &quot;unprotected&quot; refer to whether or not a mutex is held. An internal mutex is held for a protected sqlite3_value object but no mutex is held for an unprotected sqlite3_value object. If SQLite is compiled to be single-threaded (with &lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE=0&lt;/a&gt; and with &lt;a href=&quot;#sqlite3_threadsafe&quot;&gt;sqlite3_threadsafe()&lt;/a&gt; returning 0) or if SQLite is run in one of reduced mutex modes &lt;a href=&quot;#sqliteconfigsinglethread&quot;&gt;SQLITE_CONFIG_SINGLETHREAD&lt;/a&gt; or &lt;a href=&quot;#sqliteconfigmultithread&quot;&gt;SQLITE_CONFIG_MULTITHREAD&lt;/a&gt; then there is no distinction between protected and unprotected sqlite3_value objects and they can be used interchangeably. However, for maximum code portability it is recommended that applications still make the distinction between protected and unprotected sqlite3_value objects even when not strictly required.</source>
          <target state="translated">Термины &amp;laquo;защищенный&amp;raquo; и &amp;laquo;незащищенный&amp;raquo; относятся к тому, удерживается ли мьютекс. Внутренний мьютекс сохраняется для защищенного объекта sqlite3_value, но не сохраняется мьютекс для незащищенного объекта sqlite3_value. Если SQLite скомпилирован как однопоточный (с &lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE = 0&lt;/a&gt; и &lt;a href=&quot;#sqlite3_threadsafe&quot;&gt;sqlite3_threadsafe (),&lt;/a&gt; возвращающим 0) или если SQLite запущен в одном из сокращенных режимов мьютекса, &lt;a href=&quot;#sqliteconfigsinglethread&quot;&gt;SQLITE_CONFIG_SINGLETHREAD&lt;/a&gt; или &lt;a href=&quot;#sqliteconfigmultithread&quot;&gt;SQLITE_CONFIG_MULTITHREAD,&lt;/a&gt; тогда нет различий между защищенными и незащищенными объектами sq3. использоваться как взаимозаменяемые. Однако для максимальной переносимости кода рекомендуется, чтобы приложения по-прежнему делали различие между защищенными и незащищенными объектами sqlite3_value, даже если это не требуется строго.</target>
        </trans-unit>
        <trans-unit id="d0d8bb329a3e29ad5aa4a494be22dcdfc57447c5" translate="yes" xml:space="preserve">
          <source>The terms in W and X must match exactly. SQLite does not do algebra to try to get them to look the same. The term &quot;b=6&quot; does not match &quot;b=3+3&quot; or &quot;b-6=0&quot; or &quot;b BETWEEN 6 AND 6&quot;. &quot;b=6&quot; will match to &quot;6=b&quot; as long as &quot;b=6&quot; is on the index and &quot;6=b&quot; is in the query. If a term of the form &quot;6=b&quot; appears in the index, it will never match anything.</source>
          <target state="translated">Условия в W и X должны точно совпадать.SQLite не делает алгебру,чтобы заставить их выглядеть одинаково.Термин &quot;b=6&quot; не совпадает с &quot;b=3+3&quot; или &quot;b-6=0&quot; или &quot;b BETWEEN 6 AND 6&quot;.&quot;b=6&quot; будет совпадать с &quot;6=b&quot; до тех пор,пока &quot;b=6&quot; находится в индексе,а &quot;6=b&quot;-в запросе.Если в индексе появится выражение вида &quot;6=b&quot;,то оно никогда ничему не будет соответствовать.</target>
        </trans-unit>
        <trans-unit id="1a91aabb1ee8a98e3573519dc568a9cdcf09f371" translate="yes" xml:space="preserve">
          <source>The test infrastructure verifies that SQLite does not misuse dynamically allocated memory by using a specially instrumented memory allocator. The instrumented memory allocator is enabled at compile-time using the &lt;a href=&quot;compile#memdebug&quot;&gt;SQLITE_MEMDEBUG&lt;/a&gt; option. The instrumented memory allocator is much slower than the default memory allocator and so its use is not recommended in production. But when enabled during testing, the instrumented memory allocator performs the following checks:</source>
          <target state="translated">Инфраструктура тестирования проверяет, что SQLite не злоупотребляет динамически выделяемой памятью, используя специально оборудованный распределитель памяти. Инструментальный распределитель памяти включается во время компиляции с &lt;a href=&quot;compile#memdebug&quot;&gt;помощью&lt;/a&gt; опции SQLITE_MEMDEBUG . Инструментальный распределитель памяти намного медленнее, чем распределитель памяти по умолчанию, поэтому его использование не рекомендуется в производственной среде. Но при включении во время тестирования инструментальный распределитель памяти выполняет следующие проверки:</target>
        </trans-unit>
        <trans-unit id="23d89111adcbe2ab0ff1f685425a6f5892695526" translate="yes" xml:space="preserve">
          <source>The test suite is designed to be run three times, once for each of the ALWAYS() and NEVER() definitions shown above. All three test runs should yield exactly the same result. There is a run-time test using the &lt;a href=&quot;c3ref/test_control&quot;&gt;sqlite3_test_control&lt;/a&gt;(&lt;a href=&quot;c3ref/c_testctrl_always&quot;&gt;SQLITE_TESTCTRL_ALWAYS&lt;/a&gt;, ...) interface that can be used to verify that the macros are correctly set to the first form (the pass-through form) for deployment.</source>
          <target state="translated">Набор тестов разработан для трехкратного выполнения, по одному для каждого из определений ALWAYS () и NEVER (), показанных выше. Все три тестовых прогона должны дать точно такой же результат. Существует тест во время выполнения с использованием интерфейса &lt;a href=&quot;c3ref/test_control&quot;&gt;sqlite3_test_control&lt;/a&gt; ( &lt;a href=&quot;c3ref/c_testctrl_always&quot;&gt;SQLITE_TESTCTRL_ALWAYS&lt;/a&gt; , ...), который можно использовать для проверки правильности установки макросов для первой формы (сквозной формы) для развертывания.</target>
        </trans-unit>
        <trans-unit id="77fbf4494f9eeac6c3dd3e8030fecebddc25654d" translate="yes" xml:space="preserve">
          <source>The test suites for SQLite also explore the result of stacking multiple failures. For example, tests are run to ensure correct behavior when an I/O error or OOM fault occurs while trying to recover from a prior crash.</source>
          <target state="translated">Тестовые наборы для SQLite также исследуют результат стекирования множественных сбоев.Например,тесты выполняются для обеспечения правильного поведения при ошибке ввода/вывода или ошибке OOM при попытке восстановления после предыдущего сбоя.</target>
        </trans-unit>
        <trans-unit id="a7eb514323fac72f4df40162cf2fb7ca6826d6f1" translate="yes" xml:space="preserve">
          <source>The test1.dir directory will contain 100,000 files with names like &quot;000000&quot;, &quot;000001&quot;, &quot;000002&quot; and so forth but the test1.tree directory will contain the same files in subdirectories like &quot;00/00/00&quot;, &quot;00/00/01&quot;, and so on. The test1.dir and test1.test directories take up approximately the same amount of space, though test1.test is very slightly larger due to the extra directory entries.</source>
          <target state="translated">Каталог test1.dir будет содержать 100,000 файлов с именами типа &quot;000000&quot;,&quot;000001&quot;,&quot;000002&quot; и так далее,но каталог test1.tree будет содержать те же файлы в подкаталогах типа &quot;00/00/00&quot;,&quot;00/00/01&quot; и так далее.Каталоги test1.dir и test1.test занимают примерно одинаковое количество места,хотя test1.test из-за дополнительных записей в каталоге очень большой.</target>
        </trans-unit>
        <trans-unit id="833841004a13aff638c7a47f3f35a8f25f41ac0a" translate="yes" xml:space="preserve">
          <source>The test_async.c drive now does full file locking and works correctly when used simultaneously by multiple processes on the same database.</source>
          <target state="translated">Диск test_async.c теперь выполняет полную блокировку файлов и корректно работает при одновременном использовании несколькими процессами в одной и той же БД.</target>
        </trans-unit>
        <trans-unit id="eb420a5e9808216cc66d2c072d0472129ab690a9" translate="yes" xml:space="preserve">
          <source>The testcase() macro is often used to verify that boundary cases of an inequality comparison are checked. For example, at &lt;a href=&quot;https://sqlite.org/src/artifact/18a53540aa3?ln=5766&quot;&gt;https://sqlite.org/src/artifact/18a53540aa3?ln=5766&lt;/a&gt;. These kind of checks help to prevent off-by-one errors.</source>
          <target state="translated">Макрос testcase () часто используется для проверки того, что проверяются граничные случаи сравнения неравенств. Например, на &lt;a href=&quot;https://sqlite.org/src/artifact/18a53540aa3?ln=5766&quot;&gt;https://sqlite.org/src/artifact/18a53540aa3?ln=5766&lt;/a&gt; . Такие проверки помогают предотвратить случайные ошибки.</target>
        </trans-unit>
        <trans-unit id="bfd50a8b5d17dc1d197a2f0aeffde22600cc3d5e" translate="yes" xml:space="preserve">
          <source>The testcase(X) macro is normally a no-op, but for a coverage test build it does generate a small amount of extra code that includes at least one branch, in order to verify that test cases exist for which X is both true and false.</source>
          <target state="translated">Макрос testtcase(X)обычно не работает,но для сборки теста покрытия он генерирует небольшое количество дополнительного кода,включающего хотя бы одну ветку,чтобы проверить,что существуют тестовые случаи,для которых X и правда,и ложь.</target>
        </trans-unit>
        <trans-unit id="198025ed4b90dd540b423fcfb30efac73a9076a6" translate="yes" xml:space="preserve">
          <source>The testing process for SQLite is described in the &lt;a href=&quot;testing&quot;&gt;testing&lt;/a&gt; document. Testing objectives include:</source>
          <target state="translated">Процесс тестирования SQLite описан в &lt;a href=&quot;testing&quot;&gt;тестовом&lt;/a&gt; документе. Цели тестирования включают:</target>
        </trans-unit>
        <trans-unit id="7f341b9da6892f9f513eb1e23029aaad7d1945bb" translate="yes" xml:space="preserve">
          <source>The testing process is controlled by the &lt;a href=&quot;testing#cklist&quot;&gt;release testing checklists&lt;/a&gt;. The checklists succinctly summary all steps necessary to fully validate SQLite, and they record when and by whom each validation step was performed.</source>
          <target state="translated">Процесс тестирования контролируется &lt;a href=&quot;testing#cklist&quot;&gt;контрольными списками тестирования релизов&lt;/a&gt; . В контрольных списках кратко перечислены все шаги, необходимые для полной проверки SQLite, и в них записывается, когда и кем был выполнен каждый шаг проверки.</target>
        </trans-unit>
        <trans-unit id="b10a0b7612e25fb69c97ba29101b2f64b4a7581b" translate="yes" xml:space="preserve">
          <source>The text format is pure SQL so you can also use the .dump command to export an SQLite database into other popular SQL database engines. Like this:</source>
          <target state="translated">Текстовый формат является чистым SQL,поэтому вы также можете использовать команду .dump для экспорта базы данных SQLite в другие популярные движки баз данных SQL.Вот так:</target>
        </trans-unit>
        <trans-unit id="002ca6dfea0de9e1d73a68077f123004fa9755de" translate="yes" xml:space="preserve">
          <source>The text in the sqlite_master.sql column is a copy of the original CREATE statement text that created the object, except normalized as described above and as modified by subsequent &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE&lt;/a&gt; statements. The sqlite_master.sql is NULL for the &lt;a href=&quot;fileformat2#intschema&quot;&gt;internal indexes&lt;/a&gt; that are automatically created by &lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE&lt;/a&gt; or &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt; constraints.</source>
          <target state="translated">Текст в столбце sqlite_master.sql является копией исходного текста оператора CREATE, создавшего объект, за исключением нормализованного, как описано выше, и измененного последующими операторами &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE&lt;/a&gt; . Sqlite_master.sql имеет значение NULL для &lt;a href=&quot;fileformat2#intschema&quot;&gt;внутренних индексов&lt;/a&gt; , которые автоматически создаются ограничениями &lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE&lt;/a&gt; или &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="df540746bab5e3cce21edce12d96e726e4a223e9" translate="yes" xml:space="preserve">
          <source>The text in the sqlite_schema.sql column is a copy of the original CREATE statement text that created the object, except normalized as described above and as modified by subsequent &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE&lt;/a&gt; statements. The sqlite_schema.sql is NULL for the &lt;a href=&quot;fileformat2#intschema&quot;&gt;internal indexes&lt;/a&gt; that are automatically created by &lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE&lt;/a&gt; or &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt; constraints.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3362b59e42a116b494bb787cf561f00b28111a39" translate="yes" xml:space="preserve">
          <source>The text of query parameters is appended to the filename argument of the xOpen method of the &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;. Any %HH escape sequences in the query parameters are resolved prior to being appended to the xOpen filename. A single zero-byte separates the xOpen filename argument from the key of the first query parameters, each key and value, and each subsequent key from the prior value. The list of query parameters appended to the xOpen filename is terminated by a single zero-length key. Note that the value of a query parameter can be an empty string.</source>
          <target state="translated">Текст параметров запроса добавляется к аргументу имени файла метода xOpen &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; . Любые escape-последовательности% HH в параметрах запроса разрешаются перед добавлением к имени файла xOpen. Один нулевой байт отделяет аргумент имени файла xOpen от ключа первых параметров запроса, каждого ключа и значения и каждого последующего ключа от предыдущего значения. Список параметров запроса, добавленный к имени файла xOpen, завершается одним ключом нулевой длины. Обратите внимание, что значение параметра запроса может быть пустой строкой.</target>
        </trans-unit>
        <trans-unit id="f010a4aeda05a6fff949d6b23c4d99edd507a5b9" translate="yes" xml:space="preserve">
          <source>The text of the word that matches the pattern. Both word and pattern can contain unicode characters and can be mixed case.</source>
          <target state="translated">Текст слова,совпадающий с образцом.Как слово,так и образец могут содержать символы в кодировке Unicode и могут иметь смешанный регистр.</target>
        </trans-unit>
        <trans-unit id="7af9ff5f020628933bb8ed136e797234a16f70b6" translate="yes" xml:space="preserve">
          <source>The text output of the one-argument form of ieee754() is great for human readability, but it awkward to use as part of a larger expression. Hence The ieee754_mantissa() and ieee754_exponent() routines were added to return the M and E values corresponding to their single argument F value. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34ac3915c6fa697bff1880701cc84fcf41ef0614" translate="yes" xml:space="preserve">
          <source>The text to add to the start or end of the selected text to indicate that the returned text does not occur at the start or end of its column, respectively.</source>
          <target state="translated">Текст,который необходимо добавить в начало или конец выделенного текста,чтобы указать,что возвращаемый текст не встречается в начале или в конце его столбца соответственно.</target>
        </trans-unit>
        <trans-unit id="5d227441e585adc9dccb7fd5119a447b09eeb780" translate="yes" xml:space="preserve">
          <source>The text to insert after each phrase match within the returned text.</source>
          <target state="translated">Текст,который необходимо вставить после каждого совпадения фраз в возвращаемом тексте.</target>
        </trans-unit>
        <trans-unit id="c372789c27ae2ac063bb79f99aab7639b81bdf47" translate="yes" xml:space="preserve">
          <source>The text to insert after each phrase match.</source>
          <target state="translated">Текст для вставки после каждого совпадения фраз.</target>
        </trans-unit>
        <trans-unit id="98deed99ebb119a4eabb19891d9d80c8f6d99766" translate="yes" xml:space="preserve">
          <source>The text to insert before each phrase match within the returned text.</source>
          <target state="translated">Текст,который необходимо вставить перед каждой фразой,совпадает с возвращенным текстом.</target>
        </trans-unit>
        <trans-unit id="011020fd80da1d64051ffd57ff7d4f9db6949595" translate="yes" xml:space="preserve">
          <source>The text to insert before each phrase match.</source>
          <target state="translated">Текст,который необходимо вставить перед каждым словосочетанием.</target>
        </trans-unit>
        <trans-unit id="41db7390257d3e1c83cfe7262fbe75efa4098374" translate="yes" xml:space="preserve">
          <source>The theoretical maximum number of rows in a table is 2&lt;sup&gt;&lt;small&gt;64&lt;/small&gt;&lt;/sup&gt; (18446744073709551616 or about 1.8e+19). This limit is unreachable since the maximum database size of 140 terabytes will be reached first. A 140 terabytes database can hold no more than approximately 1e+13 rows, and then only if there are no indices and if each row contains very little data.</source>
          <target state="translated">Теоретическое максимальное количество строк в таблице - 2 &lt;sup&gt;&lt;small&gt;64&lt;/small&gt;&lt;/sup&gt; (18446744073709551616 или около 1,8e + 19). Этот предел недостижим, так как сначала будет достигнут максимальный размер базы данных в 140 терабайт. База данных размером 140 терабайт может содержать не более примерно 1e + 13 строк, и то только при отсутствии индексов и если каждая строка содержит очень мало данных.</target>
        </trans-unit>
        <trans-unit id="9c469d0a6dd7814f8f536d83dd0c0d4f9236b847" translate="yes" xml:space="preserve">
          <source>The theoretical maximum number of rows in a table is 2&lt;sup&gt;&lt;small&gt;64&lt;/small&gt;&lt;/sup&gt; (18446744073709551616 or about 1.8e+19). This limit is unreachable since the maximum database size of 281 terabytes will be reached first. A 281 terabytes database can hold no more than approximately 2e+13 rows, and then only if there are no indices and if each row contains very little data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e681320a770693ff8880c2fe787c3d46c58d6fe" translate="yes" xml:space="preserve">
          <source>The these routines may attempt to convert the datatype of the result. For example, if the internal representation is FLOAT and a text result is requested, &lt;a href=&quot;#sqlite3_mprintf&quot;&gt;sqlite3_snprintf()&lt;/a&gt; is used internally to perform the conversion automatically. The following table details the conversions that are applied:</source>
          <target state="translated">Эти подпрограммы могут пытаться преобразовать тип данных результата. Например, если внутреннее представление - FLOAT и запрашивается текстовый результат, &lt;a href=&quot;#sqlite3_mprintf&quot;&gt;sqlite3_snprintf ()&lt;/a&gt; используется внутренне для автоматического выполнения преобразования. В следующей таблице подробно описаны применяемые преобразования:</target>
        </trans-unit>
        <trans-unit id="d45ababe332de0d6a9b7d204a8229a091726f141" translate="yes" xml:space="preserve">
          <source>The these routines may attempt to convert the datatype of the result. For example, if the internal representation is FLOAT and a text result is requested, &lt;a href=&quot;mprintf&quot;&gt;sqlite3_snprintf()&lt;/a&gt; is used internally to perform the conversion automatically. The following table details the conversions that are applied:</source>
          <target state="translated">Эти подпрограммы могут пытаться преобразовать тип данных результата. Например, если внутреннее представление - FLOAT и запрашивается текстовый результат, &lt;a href=&quot;mprintf&quot;&gt;sqlite3_snprintf ()&lt;/a&gt; используется внутренне для автоматического выполнения преобразования. В следующей таблице подробно описаны применяемые преобразования:</target>
        </trans-unit>
        <trans-unit id="f29b8fd84fbcfd59fccde21c2067cc383b5612cf" translate="yes" xml:space="preserve">
          <source>The third and fourth parameters to this function are the table and column name of the desired column, respectively.</source>
          <target state="translated">Третий и четвертый параметры этой функции-это название таблицы и столбца нужного столбца соответственно.</target>
        </trans-unit>
        <trans-unit id="5dad7ccfb7adf02e60a4718cd1bfaf6cc7ad8094" translate="yes" xml:space="preserve">
          <source>The third argument (eTextRep) must be one of the constants:</source>
          <target state="translated">Третий аргумент (eTextRep)должен быть одной из констант:</target>
        </trans-unit>
        <trans-unit id="a12fbbce4ea7f98c6f3257e48e8cfdd9d6a7f402" translate="yes" xml:space="preserve">
          <source>The third argument is the value to bind to the parameter. If the third parameter to sqlite3_bind_text() or sqlite3_bind_text16() or sqlite3_bind_blob() is a NULL pointer then the fourth parameter is ignored and the end result is the same as sqlite3_bind_null().</source>
          <target state="translated">Третий аргумент-значение для привязки к параметру.Если третий параметр sqlite3_bind_text()или sqlite3_bind_text16()или sqlite3_bind_blob()является указателем NULL,то четвертый параметр игнорируется и конечный результат равен sqlite3_bind_null().</target>
        </trans-unit>
        <trans-unit id="cfd2994dc5175da09229d952b2be33f11c05e0da" translate="yes" xml:space="preserve">
          <source>The third argument is the value to bind to the parameter. If the third parameter to sqlite3_bind_text() or sqlite3_bind_text16() or sqlite3_bind_blob() is a NULL pointer then the fourth parameter is ignored and the end result is the same as sqlite3_bind_null(). If the third parameter to sqlite3_bind_text() is not NULL, then it should be a pointer to well-formed UTF8 text. If the third parameter to sqlite3_bind_text16() is not NULL, then it should be a pointer to well-formed UTF16 text. If the third parameter to sqlite3_bind_text64() is not NULL, then it should be a pointer to a well-formed unicode string that is either UTF8 if the sixth parameter is SQLITE_UTF8, or UTF16 otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8896799f29c2adcd495a7004a3dfd8ef2c595b55" translate="yes" xml:space="preserve">
          <source>The third argument to the &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfiglog&quot;&gt;SQLITE_CONFIG_LOG&lt;/a&gt;,...) interface (the &quot;pData&quot; argument in the example above) is a pointer to arbitrary data. SQLite passes this pointer through to the first argument of the error logger callback. The pointer can be used to pass application-specific setup or state information, if desired. Or it can simply be a NULL pointer which is ignored by the callback.</source>
          <target state="translated">Третий аргумент интерфейса &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt; ( &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfiglog&quot;&gt;SQLITE_CONFIG_LOG&lt;/a&gt; , ...) (аргумент &amp;laquo;pData&amp;raquo; в приведенном выше примере) - это указатель на произвольные данные. SQLite передает этот указатель на первый аргумент обратного вызова регистратора ошибок. При желании указатель может использоваться для передачи информации о настройке или состоянии конкретного приложения. Или это может быть просто указатель NULL, который игнорируется обратным вызовом.</target>
        </trans-unit>
        <trans-unit id="8e80d3a19f53ad5c94b48f6b4deace1bd8cd6a01" translate="yes" xml:space="preserve">
          <source>The third chart shows that reading blob content out of SQLite can be twice as fast as reading from individual files on disk for Mac and Android, and an amazing ten times faster for Windows.</source>
          <target state="translated">Третий график показывает,что чтение блоков из SQLite может быть в два раза быстрее,чем чтение отдельных файлов на диске для Mac и Android,и в десять раз быстрее для Windows.</target>
        </trans-unit>
        <trans-unit id="ce81cfaf801aa960a0d4e258e6f72c47aaf642db" translate="yes" xml:space="preserve">
          <source>The third column is the minimum value for any rowid in the table.</source>
          <target state="translated">Третий столбец-это минимальное значение для любой строки таблицы.</target>
        </trans-unit>
        <trans-unit id="66b245a2c0333e9c6e002eaadabc21caae3f20aa" translate="yes" xml:space="preserve">
          <source>The third form of an INSERT statement is with DEFAULT VALUES. The INSERT ... DEFAULT VALUES statement inserts a single new row into the named table. Each column of the new row is populated with its &lt;a href=&quot;lang_createtable#dfltval&quot;&gt;default value&lt;/a&gt;, or with a NULL if no default value is specified as part of the column definition in the &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; statement. The &lt;a href=&quot;syntax/upsert-clause&quot;&gt;upsert-clause&lt;/a&gt; is not supported after DEFAULT VALUES.</source>
          <target state="translated">Третья форма оператора INSERT - со ЗНАЧЕНИЯМИ ПО УМОЛЧАНИЮ. Оператор INSERT ... DEFAULT VALUES вставляет одну новую строку в указанную таблицу. Каждый столбец новой строки заполняется &lt;a href=&quot;lang_createtable#dfltval&quot;&gt;значением по умолчанию&lt;/a&gt; или NULL, если значение по умолчанию не указано как часть определения столбца в операторе &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; . Предложение &lt;a href=&quot;syntax/upsert-clause&quot;&gt;upsert&lt;/a&gt; не поддерживается после DEFAULT VALUES.</target>
        </trans-unit>
        <trans-unit id="80211bcbcab262c368d4da63de6e8f61d55d7f66" translate="yes" xml:space="preserve">
          <source>The third line of the example shows the virtual table being used, to read all content of the CSV file. This is perhaps the simplest possible use of the virtual table. The CSV virtual table can be used anywhere an ordinary virtual table can be used. One can use the CSV virtual table inside subqueries, or &lt;a href=&quot;lang_with&quot;&gt;common table expressions&lt;/a&gt; or add WHERE, GROUP BY, HAVING, ORDER BY, and LIMIT clauses as required.</source>
          <target state="translated">Третья строка примера показывает используемую виртуальную таблицу для чтения всего содержимого файла CSV. Это, пожалуй, самое простое возможное использование виртуальной таблицы. Виртуальную таблицу CSV можно использовать везде, где можно использовать обычную виртуальную таблицу. Можно использовать виртуальную таблицу CSV внутри подзапросов или &lt;a href=&quot;lang_with&quot;&gt;общих табличных выражений&lt;/a&gt; или добавить при необходимости предложения WHERE, GROUP BY, HAVING, ORDER BY и LIMIT.</target>
        </trans-unit>
        <trans-unit id="37d0f732f75ffbc9298be10c6e109dfc37fa5d4b" translate="yes" xml:space="preserve">
          <source>The third number Z is incremented for releases consisting of only small changes that implement performance enhancements and/or bug fixes.</source>
          <target state="translated">Третье число Z увеличивается для релизов,состоящих только из небольших изменений,в которых реализованы улучшения производительности и/или исправления ошибок.</target>
        </trans-unit>
        <trans-unit id="d43fa02ec7a69fa0b5cb4656ab69a4413a6918c8" translate="yes" xml:space="preserve">
          <source>The third optimization, zeroing the journal file header rather than deleting the rollback journal file, does not depend on holding an exclusive lock at all times. This optimization can be set independently of exclusive lock mode using the &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;journal_mode pragma&lt;/a&gt; as described in &lt;a href=&quot;#section_7_6&quot;&gt;section 7.6&lt;/a&gt; below.</source>
          <target state="translated">Третья оптимизация, обнуление заголовка файла журнала вместо удаления файла журнала отката, не зависит от постоянного удержания монопольной блокировки. Эта оптимизация может быть установлена ​​независимо от режима монопольной блокировки с помощью &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;прагмы journal_mode,&lt;/a&gt; как описано в &lt;a href=&quot;#section_7_6&quot;&gt;разделе 7.6&lt;/a&gt; ниже.</target>
        </trans-unit>
        <trans-unit id="226219f131eebb1bb82e3a9e80c20160ef9e49d4" translate="yes" xml:space="preserve">
          <source>The third parameter (nArg) is the number of arguments that the SQL function or aggregate takes. If this parameter is -1, then the SQL function or aggregate may take any number of arguments between 0 and the limit set by &lt;a href=&quot;#sqlite3_limit&quot;&gt;sqlite3_limit&lt;/a&gt;(&lt;a href=&quot;#sqlitelimitfunctionarg&quot;&gt;SQLITE_LIMIT_FUNCTION_ARG&lt;/a&gt;). If the third parameter is less than -1 or greater than 127 then the behavior is undefined.</source>
          <target state="translated">Третий параметр (nArg) - это количество аргументов, которые принимает функция или агрегат SQL. Если этот параметр равен -1, тогда функция или агрегат SQL может принимать любое количество аргументов от 0 до предела, установленного &lt;a href=&quot;#sqlite3_limit&quot;&gt;sqlite3_limit&lt;/a&gt; ( &lt;a href=&quot;#sqlitelimitfunctionarg&quot;&gt;SQLITE_LIMIT_FUNCTION_ARG&lt;/a&gt; ). Если третий параметр меньше -1 или больше 127, поведение не определено.</target>
        </trans-unit>
        <trans-unit id="11f56952c8e04a9269627afb8274637d6b360ea2" translate="yes" xml:space="preserve">
          <source>The third parameter (nArg) is the number of arguments that the SQL function or aggregate takes. If this parameter is -1, then the SQL function or aggregate may take any number of arguments between 0 and the limit set by &lt;a href=&quot;limit&quot;&gt;sqlite3_limit&lt;/a&gt;(&lt;a href=&quot;c_limit_attached#sqlitelimitfunctionarg&quot;&gt;SQLITE_LIMIT_FUNCTION_ARG&lt;/a&gt;). If the third parameter is less than -1 or greater than 127 then the behavior is undefined.</source>
          <target state="translated">Третий параметр (nArg) - это количество аргументов, которые принимает функция или агрегат SQL. Если этот параметр равен -1, тогда функция или агрегат SQL может принимать любое количество аргументов от 0 до предела, установленного &lt;a href=&quot;limit&quot;&gt;sqlite3_limit&lt;/a&gt; ( &lt;a href=&quot;c_limit_attached#sqlitelimitfunctionarg&quot;&gt;SQLITE_LIMIT_FUNCTION_ARG&lt;/a&gt; ). Если третий параметр меньше -1 или больше 127, поведение не определено.</target>
        </trans-unit>
        <trans-unit id="7effa7c199d796ec9c7957d5b06f69295ac44ef2" translate="yes" xml:space="preserve">
          <source>The third step starts with the four shortest two-node paths and finds the four shortest three-node paths:</source>
          <target state="translated">Третий шаг начинается с четырех кратчайших двух-узловых путей и находит четыре кратчайших трех-узловых пути:</target>
        </trans-unit>
        <trans-unit id="97390ca779620e87876318d53cdbb5c0eb4c1782" translate="yes" xml:space="preserve">
          <source>The threading mode can be selected at compile-time (when the SQLite library is being compiled from source code) or at start-time (when the application that intends to use SQLite is initializing) or at run-time (when a new SQLite database connection is being created). Generally speaking, run-time overrides start-time and start-time overrides compile-time. Except, single-thread mode cannot be overridden once selected.</source>
          <target state="translated">Режим нити может быть выбран во время компиляции (когда библиотека SQLite компилируется из исходного кода),во время запуска (когда приложение,которое намерено использовать SQLite,инициализируется)или во время выполнения (когда создается новое подключение к базе данных SQLite).Вообще говоря,время выполнения переопределяет время запуска и время запуска переопределяет время компиляции.Кроме того,однопоточный режим не может быть переопределен один раз.</target>
        </trans-unit>
        <trans-unit id="7a0e198fd0423256115863d78eac9cac1343e176" translate="yes" xml:space="preserve">
          <source>The threading mode for an individual database connection is determined by flags given as the third argument to &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;. The &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_NOMUTEX&lt;/a&gt; flag causes the database connection to be in the multi-thread mode and the &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_FULLMUTEX&lt;/a&gt; flag causes the connection to be in serialized mode. If neither flag is specified or if &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt; or &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open16()&lt;/a&gt; are used instead of &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;, then the default mode determined by the compile-time and start-time settings is used.</source>
          <target state="translated">Режим потоковой передачи для отдельного соединения с базой данных определяется флагами, заданными в качестве третьего аргумента &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2 ()&lt;/a&gt; . &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_NOMUTEX&lt;/a&gt; флаг вызывает соединение с базой данных , чтобы быть в режиме многопоточного и &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_FULLMUTEX&lt;/a&gt; флаг вызывает соединение находиться в последовательном режиме. Если ни один флаг указан или если &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open ()&lt;/a&gt; или &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open16 ()&lt;/a&gt; используется вместо &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2 ()&lt;/a&gt; , то режим по умолчанию определяется во время компиляции и запуска времени используются настройка.</target>
        </trans-unit>
        <trans-unit id="a70f1f8b6fb5520108a2b27f649a3322d3c256dc" translate="yes" xml:space="preserve">
          <source>The three auxiliary functions are only useful within a SELECT statement that uses the FTS table's full-text index. If used within a SELECT that uses the &quot;query by rowid&quot; or &quot;linear scan&quot; strategies, then the snippet and offsets both return an empty string, and the matchinfo function returns a blob value zero bytes in size.</source>
          <target state="translated">Три вспомогательные функции полезны только в операторе SELECT,использующем полнотекстовый индекс таблицы FTS.Если она используется внутри SELECT,использующего стратегии &quot;запрос по rowid&quot; или &quot;линейное сканирование&quot;,то фрагмент и смещение возвращают пустую строку,а функция matchinfo возвращает блочное значение нулевого байта в размере.</target>
        </trans-unit>
        <trans-unit id="6eb0a1f7b89a823f8bdbde0d13568a18262e614a" translate="yes" xml:space="preserve">
          <source>The three basic query types described above may be used to query the full-text index for the set of documents that match the specified criteria. Using the FTS query expression language it is possible to perform various set operations on the results of basic queries. There are currently three supported operations:</source>
          <target state="translated">Три основных типа запросов,описанных выше,могут быть использованы для запроса полнотекстового индекса для набора документов,соответствующих указанным критериям.Используя язык выражения запросов FTS,можно выполнять различные наборы операций над результатами базовых запросов.В настоящее время поддерживаются три операции:</target>
        </trans-unit>
        <trans-unit id="7097964beca5dc252968954049e7c0946f78e4a9" translate="yes" xml:space="preserve">
          <source>The three leftmost columns of a zipfile virtual table, &quot;name&quot;, &quot;mode&quot; and &quot;mtime&quot;, may each be set to any value that may be inserted into the same column (see above). If either &quot;mode&quot; or &quot;mtime&quot; is set to NULL, the final value is determined as described for an INSERT of a NULL value - the current time for &quot;mtime&quot; and either 33188 or 16877 for &quot;mode&quot;, depending on whether or not the values specified for the next four columns of the zipfile table indicate that the entry is a directory or a file.</source>
          <target state="translated">Три крайние левые колонки виртуальной таблицы zip-файла-&quot;имя&quot;,&quot;режим&quot; и &quot;время&quot;-могут быть установлены на любое значение,которое может быть вставлено в одну и ту же колонку (см.выше).Если для &quot;режима&quot; или &quot;mtime&quot; установлено значение NULL,то конечное значение определяется,как описано для ИНСЕРТА значения NULL-текущее время для &quot;mtime&quot; и либо 33188,либо 16877 для &quot;режима&quot;,в зависимости от того,указывают ли значения,указанные для следующих четырех столбцов zip-таблицы,на то,что запись является каталогом или файлом.</target>
        </trans-unit>
        <trans-unit id="3411dedba6408ea6c13a17f75aea9b87b7d91fad" translate="yes" xml:space="preserve">
          <source>The time string can be followed by zero or more modifiers that alter date and/or time. Each modifier is a transformation that is applied to the time value to its left. Modifiers are applied from left to right; order is important. The available modifiers are as follows.</source>
          <target state="translated">За строкой времени могут следовать нулевые или более модификаторы,изменяющие дату и/или время.Каждый модификатор представляет собой преобразование,которое применяется к значению времени слева от него.Модификаторы применяются слева направо;порядок важен.Доступные модификаторы следующие.</target>
        </trans-unit>
        <trans-unit id="30024a74e5aefa6cc166b0948a8f34eea1be4641" translate="yes" xml:space="preserve">
          <source>The time taken to execute each virtual machine operation can vary based on many factors. A typical value for a 1 GHz PC is between half and three million per second but may be much higher or lower, depending on the query. As such it is difficult to schedule background operations based on virtual machine operations. Instead, it is recommended that a callback be scheduled relatively frequently (say every 1000 instructions) and external timer routines used to determine whether or not background jobs need to be run.</source>
          <target state="translated">Время,затрачиваемое на выполнение каждой операции виртуальной машины,может варьироваться в зависимости от многих факторов.Типичное значение для ПК с частотой 1 ГГц составляет от полутора до трех миллионов в секунду,но может быть значительно больше или меньше в зависимости от запроса.В связи с этим сложно запланировать фоновые операции на основе операций виртуальной машины.Вместо этого рекомендуется относительно часто планировать обратный вызов (скажем,каждые 1000 инструкций)и использовать внешние подпрограммы таймера для определения необходимости выполнения фоновых заданий.</target>
        </trans-unit>
        <trans-unit id="d31d23c9c6ce92ba1161f4e9fe89ef4c4bc1cceb" translate="yes" xml:space="preserve">
          <source>The times reported on all tests represent wall-clock time in seconds. Two separate time values are reported for SQLite. The first value is for SQLite in its default configuration with full disk synchronization turned on. With synchronization turned on, SQLite executes an &lt;b&gt;fsync()&lt;/b&gt; system call (or the equivalent) at key points to make certain that critical data has actually been written to the disk drive surface. Synchronization is necessary to guarantee the integrity of the database if the operating system crashes or the computer powers down unexpectedly in the middle of a database update. The second time reported for SQLite is when synchronization is turned off. With synchronization off, SQLite is sometimes much faster, but there is a risk that an operating system crash or an unexpected power failure could damage the database. Generally speaking, the synchronous SQLite times are for comparison against PostgreSQL (which is also synchronous) and the asynchronous SQLite times are for comparison against the asynchronous MySQL engine.</source>
          <target state="translated">Время, указанное во всех тестах, представляет собой время настенных часов в секундах. Для SQLite представлены два отдельных значения времени. Первое значение предназначено для SQLite в его конфигурации по умолчанию с включенной полной синхронизацией диска. При включенной синхронизации SQLite выполняет &lt;b&gt;fsync ()&lt;/b&gt;системный вызов (или его эквивалент) в ключевых точках, чтобы убедиться, что критически важные данные действительно записаны на поверхность диска. Синхронизация необходима для гарантии целостности базы данных в случае сбоя операционной системы или непредвиденного отключения компьютера во время обновления базы данных. Второй раз для SQLite сообщается, что синхронизация отключена. Если синхронизация отключена, SQLite иногда работает намного быстрее, но существует риск того, что сбой операционной системы или неожиданный сбой питания могут повредить базу данных. Вообще говоря, синхронное время SQLite предназначено для сравнения с PostgreSQL (который также является синхронным), а время асинхронного SQLite - для сравнения с асинхронным механизмом MySQL.</target>
        </trans-unit>
        <trans-unit id="0fc05e4c39e5e71215073020483f372e45a3d893" translate="yes" xml:space="preserve">
          <source>The total amount of free space on a b-tree page consists of the size of the unallocated region plus the total size of all freeblocks plus the number of fragmented free bytes. SQLite may from time to time reorganize a b-tree page so that there are no freeblocks or fragment bytes, all unused bytes are contained in the unallocated space region, and all cells are packed tightly at the end of the page. This is called &quot;defragmenting&quot; the b-tree page.</source>
          <target state="translated">Общее количество свободного места на b-деревянной странице складывается из размера нераспределенной области плюс суммарный размер всех фриблок плюс количество фрагментированных свободных байтов.SQLite может время от времени реорганизовывать b-деревневую страницу таким образом,чтобы на ней не было ни фрагментарных,ни свободных байтов,все неиспользованные байты находились в нераспределенном пространстве,а все ячейки были плотно упакованы в конце страницы.Это называется &quot;дефрагментацией&quot; b-деревянной страницы.</target>
        </trans-unit>
        <trans-unit id="460e85c11483674a3089f1a062d5d6ad1f387294" translate="yes" xml:space="preserve">
          <source>The total number of instances of the term in the entire FTS5 table.</source>
          <target state="translated">Общее количество экземпляров срока во всей таблице FTS5.</target>
        </trans-unit>
        <trans-unit id="8456fd817ff013feb889e3e84d49e1da8d0b8117" translate="yes" xml:space="preserve">
          <source>The total number of instances of the term that appear in column $col of the FTS5 table (considering all rows).</source>
          <target state="translated">Общее количество экземпляров термина,указанных в столбце $col таблицы FTS5 (с учетом всех строк).</target>
        </trans-unit>
        <trans-unit id="8b23a01c6d0371374c2abef2c4b0a82ba4134902" translate="yes" xml:space="preserve">
          <source>The total number of pages in the btree for the current row</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e6d24f273b69a04a7a37a510d51811f2500b867" translate="yes" xml:space="preserve">
          <source>The total number of rows in the FTS table for which the column contains at least one instance of the phrase.</source>
          <target state="translated">Общее количество строк в таблице FTS,для которых столбец содержит хотя бы один экземпляр фразы.</target>
        </trans-unit>
        <trans-unit id="36827e0806ceb5dc326cee16a98d2a59022e566e" translate="yes" xml:space="preserve">
          <source>The total number of times the phrase appears in the column in all rows in the FTS table.</source>
          <target state="translated">Общее количество раз,когда фраза появляется в столбце во всех строках таблицы FTS.</target>
        </trans-unit>
        <trans-unit id="cf5b068f292efb4fb2def2e783aac8fbf8f0464d" translate="yes" xml:space="preserve">
          <source>The total_changes() function returns the number of row changes caused by INSERT, UPDATE or DELETE statements since the current database connection was opened. This function is a wrapper around the &lt;a href=&quot;c3ref/total_changes&quot;&gt;sqlite3_total_changes()&lt;/a&gt; C/C++ interface.</source>
          <target state="translated">Функция total_changes () возвращает количество изменений строки, вызванных операторами INSERT, UPDATE или DELETE с момента открытия текущего соединения с базой данных. Эта функция является оболочкой для интерфейса &lt;a href=&quot;c3ref/total_changes&quot;&gt;sqlite3_total_changes ()&lt;/a&gt; C / C ++.</target>
        </trans-unit>
        <trans-unit id="e56b60d01d475c54e2abcd03a315a64862d2471f" translate="yes" xml:space="preserve">
          <source>The traditional rollback journal works by writing a copy of the original unchanged database content into a separate rollback journal file and then writing changes directly into the database file. In the event of a crash or &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt;, the original content contained in the rollback journal is played back into the database file to revert the database file to its original state. The &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; occurs when the rollback journal is deleted.</source>
          <target state="translated">Традиционный журнал отката работает путем записи копии исходного неизмененного содержимого базы данных в отдельный файл журнала отката, а затем записи изменений непосредственно в файл базы данных. В случае сбоя или &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt; исходное содержимое, содержащееся в журнале отката, воспроизводится в файле базы данных, чтобы вернуть файл базы данных в исходное состояние. &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; происходит , когда журнал отката удаляется.</target>
        </trans-unit>
        <trans-unit id="fa45945065730186850cef64d952ee165c9cc090" translate="yes" xml:space="preserve">
          <source>The traditional way of communicating this information was to transform a C-language pointer into a BLOB or a 64-bit integer, then move that BLOB or integer through SQLite using the usual interfaces like &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_blob()&lt;/a&gt;, &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_blob()&lt;/a&gt;, &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_blob()&lt;/a&gt; or the integer equivalents.</source>
          <target state="translated">Традиционным способом передачи этой информации было преобразование указателя на языке C в BLOB или 64-битное целое число, а затем перемещение этого BLOB или целого числа через SQLite с использованием обычных интерфейсов, таких как &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_blob ()&lt;/a&gt; , &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_blob ()&lt;/a&gt; , &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_blob ()&lt;/a&gt; или целочисленные эквиваленты.</target>
        </trans-unit>
        <trans-unit id="c2d0f49e1ec0a4672583f25736f97bcbd3e6ba07" translate="yes" xml:space="preserve">
          <source>The transaction command can be used to group together several SQLite commands in a safe way. You can always start transactions manually using BEGIN, of course. But if an error occurs so that the COMMIT or ROLLBACK are never run, then the database will remain locked indefinitely. Also, BEGIN does not nest, so you have to make sure no other transactions are active before starting a new one. The &quot;transaction&quot; method takes care of all of these details automatically.</source>
          <target state="translated">Команда транзакции может быть использована для безопасной группировки нескольких команд SQLite.Разумеется,вы всегда можете запускать транзакции вручную с помощью BEGIN.Но если произойдет ошибка,в результате которой COMMIT или ROLLBACK никогда не будут запущены,то БД останется заблокированной на неопределенный срок.Кроме того,BEGIN не гнездится,поэтому вы должны убедиться,что никакие другие транзакции не активны,прежде чем запускать новую.Метод &quot;транзакции&quot; заботится обо всех этих деталях автоматически.</target>
        </trans-unit>
        <trans-unit id="66431b524eb3e3d97e40f460537f3aa544382bf9" translate="yes" xml:space="preserve">
          <source>The transaction has already committed at this point so timing is not critical in the deletion of the rollback journals. The current implementation deletes a single rollback journal then unlocks the corresponding database file before proceeding to the next rollback journal. But in the future we might change this so that all rollback journals are deleted before any database files are unlocked. As long as the rollback journal is deleted before its corresponding database file is unlocked it does not matter in what order the rollback journals are deleted or the database files are unlocked.</source>
          <target state="translated">Сделка уже совершена на данный момент,поэтому сроки не являются критичными при удалении откатных журналов.Текущая реализация удаляет один журнал отката,затем разблокирует соответствующий файл базы данных,прежде чем перейти к следующему журналу отката.Но в будущем мы можем изменить это так,что все откатные журналы будут удалены до того,как будут разблокированы какие-либо файлы БД.До тех пор,пока откатный журнал удаляется до разблокировки соответствующего файла БД,не имеет значения,в каком порядке удаляются откатные журналы или разблокируются файлы БД.</target>
        </trans-unit>
        <trans-unit id="439b3c25010ac483338852bbf167e17f82acaecb" translate="yes" xml:space="preserve">
          <source>The transformation converts each vertex of the polygon according to the following formula:</source>
          <target state="translated">Преобразование преобразует каждую вершину многоугольника по следующей формуле:</target>
        </trans-unit>
        <trans-unit id="970a22ffd83744a201d5b074bf5b2eed9b68c352" translate="yes" xml:space="preserve">
          <source>The transient table in which the result is built is created by instruction 0. Three loops then follow. The loop at instructions 5 through 10 implements the first SELECT statement. The second SELECT statement is implemented by the loop at instructions 14 through 19. Finally, a loop at instructions 22 through 25 reads the transient table and invokes the callback once for each row in the result.</source>
          <target state="translated">Таблица переходных процессов,в которой строится результат,создается командой 0.Затем следуют три цикла.Цикл на инструкциях 5-10 реализует первый оператор SELECT.Второй оператор SELECT реализуется циклом на инструкциях 14-19.Наконец,цикл на инструкциях с 22 по 25 читает таблицу переходных процессов и вызывает обратный вызов один раз для каждой строки результата.</target>
        </trans-unit>
        <trans-unit id="952fc2249e617c46359543a66e348109d3087d3d" translate="yes" xml:space="preserve">
          <source>The transient table in which the results of the inner SELECT are stored is created by the &lt;a href=&quot;opcode#OpenTemp&quot;&gt;OpenTemp&lt;/a&gt; instruction at 0. This opcode is used for tables that exist for the duration of a single SQL statement only. The transient cursor is always opened read/write even if the main database is read-only. The transient table is deleted automatically when the cursor is closed. The P2 value of 1 means the cursor points to a BTree index, which has no data but can have an arbitrary key.</source>
          <target state="translated">Временная таблица, в которой хранятся результаты внутреннего SELECT, создается инструкцией &lt;a href=&quot;opcode#OpenTemp&quot;&gt;OpenTemp&lt;/a&gt; в 0. Этот код операции используется для таблиц, которые существуют только в течение одного оператора SQL. Временный курсор всегда открывается для чтения / записи, даже если основная база данных доступна только для чтения. Таблица переходных процессов автоматически удаляется при закрытии курсора. Значение P2, равное 1, означает, что курсор указывает на индекс BTree, который не имеет данных, но может иметь произвольный ключ.</target>
        </trans-unit>
        <trans-unit id="592350be0cb11625e2bd092767c6171c56d03c65" translate="yes" xml:space="preserve">
          <source>The transition from SQLite version 3.4.2 to 3.5.0 is a major change. Every source code file in the SQLite core had to be modified, some extensively. And the change introduced some minor incompatibilities in the C interface. But we feel that the benefits of the transition from 3.4.2 to 3.5.0 far outweigh the pain of porting. The new VFS layer is now well-defined and stable and should simplify future customizations. The VFS layer, and the separable memory allocator and mutex subsystems allow a standard SQLite source code amalgamation to be used in an embedded project without change, greatly simplifying configuration management. And the resulting system is much more tolerant of highly threaded designs.</source>
          <target state="translated">Переход с версии SQLite 3.4.2 на 3.5.0 является существенным изменением.Каждый файл исходного кода в ядре SQLite требовал значительных изменений.И это изменение ввело некоторые незначительные несовместимости в C-интерфейсе.Но мы считаем,что преимущества перехода с 3.4.2 на 3.5.0 намного перевешивают боль переноса.Новый слой VFS теперь четко определен и стабилен и должен упростить будущие настройки.Уровень VFS,а также разделяемые подсистемы выделения памяти и мьютекса позволяют без изменений использовать стандартное слияние исходного кода SQLite во встроенном проекте,значительно упрощая управление конфигурацией.А получившаяся система гораздо более терпима к высокопоточным конструкциям.</target>
        </trans-unit>
        <trans-unit id="b0ecdf62ac64721b60f0c811bc6ae15d2a3d1b27" translate="yes" xml:space="preserve">
          <source>The trick here is the -DTCLSH=1 option. The TCL interface module for SQLite includes a &lt;b&gt;main()&lt;/b&gt; procedure that initializes a TCL interpreter and enters a command-line loop when it is compiled with -DTCLSH=1. The command above works on both Linux and Mac OS X, though one may need to adjust the library options depending on the platform and which version of TCL one is linking against.</source>
          <target state="translated">Уловка здесь - опция -DTCLSH = 1. Модуль интерфейса TCL для SQLite включает процедуру &lt;b&gt;main ()&lt;/b&gt; , которая инициализирует интерпретатор TCL и входит в цикл командной строки, когда он компилируется с -DTCLSH = 1. Приведенная выше команда работает как в Linux, так и в Mac OS X, хотя может потребоваться настроить параметры библиотеки в зависимости от платформы и версии TCL, с которой выполняется компоновка.</target>
        </trans-unit>
        <trans-unit id="fc5d00c95debe18bbcee9e720337d19dcab11f5a" translate="yes" xml:space="preserve">
          <source>The trigger created by the previous statement is named &quot;AFTER&quot; and it is a &quot;BEFORE&quot; trigger. The &quot;AFTER&quot; token is used as an identifier instead of as a keyword, as that is the only way to parse the statement. Another example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b9b7cf0a7967eed621bbbad3863190e29c44d61" translate="yes" xml:space="preserve">
          <source>The trim(X,Y) function returns a string formed by removing any and all characters that appear in Y from both ends of X. If the Y argument is omitted, trim(X) removes spaces from both ends of X.</source>
          <target state="translated">Функция trim(X,Y)возвращает строку,образованную удалением всех символов,которые появляются в Y,из обоих концов X.Если аргумент Y опущен,trim(X)удаляет пробелы из обоих концов X.</target>
        </trans-unit>
        <trans-unit id="02041028dd7a37adeacbb35b1200b0b1a6b27a53" translate="yes" xml:space="preserve">
          <source>The true primary key for a rowid table (the value that is used as the key to look up rows in the underlying &lt;a href=&quot;fileformat2#btree&quot;&gt;B-tree&lt;/a&gt; storage engine) is the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;.</source>
          <target state="translated">Истинный первичный ключ для таблицы rowid (значение, которое используется в качестве ключа для поиска строк в базовом механизме хранения &lt;a href=&quot;fileformat2#btree&quot;&gt;B-дерева&lt;/a&gt; ) - это &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3f9dae6c570b0f408d716bb105a5e25850cccf9f" translate="yes" xml:space="preserve">
          <source>The truncate optimization can also be disabled at runtime using the &lt;a href=&quot;c3ref/set_authorizer&quot;&gt;sqlite3_set_authorizer()&lt;/a&gt; interface. If an authorizer callback returns &lt;a href=&quot;c3ref/c_deny&quot;&gt;SQLITE_IGNORE&lt;/a&gt; for an &lt;a href=&quot;c3ref/c_alter_table&quot;&gt;SQLITE_DELETE&lt;/a&gt; action code, then the DELETE operation will proceed but the truncate optimization will be bypassed and rows will be deleted one by one.</source>
          <target state="translated">Оптимизацию усечения также можно отключить во время выполнения с помощью интерфейса &lt;a href=&quot;c3ref/set_authorizer&quot;&gt;sqlite3_set_authorizer ()&lt;/a&gt; . Если обратный вызов авторизатора возвращает &lt;a href=&quot;c3ref/c_deny&quot;&gt;SQLITE_IGNORE&lt;/a&gt; для &lt;a href=&quot;c3ref/c_alter_table&quot;&gt;кода&lt;/a&gt; действия SQLITE_DELETE , тогда операция DELETE будет продолжена, но оптимизация усечения будет пропущена, и строки будут удалены одна за другой.</target>
        </trans-unit>
        <trans-unit id="7489f83785acf46d79dbedce76141d020e3a30b4" translate="yes" xml:space="preserve">
          <source>The truncate optimization can be permanently disabled for all queries by recompiling SQLite with the &lt;a href=&quot;compile#omit_truncate_optimization&quot;&gt;SQLITE_OMIT_TRUNCATE_OPTIMIZATION&lt;/a&gt; compile-time switch.</source>
          <target state="translated">Оптимизацию усечения можно навсегда отключить для всех запросов, перекомпилировав SQLite с переключателем времени компиляции &lt;a href=&quot;compile#omit_truncate_optimization&quot;&gt;SQLITE_OMIT_TRUNCATE_OPTIMIZATION&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="30f49567fa43c7d2e5e26ee8efe4338c93c45898" translate="yes" xml:space="preserve">
          <source>The trusted_schema setting is a per-connection boolean that determines whether or not SQL functions and virtual tables that have not been security audited are allowed to be run by views, triggers, or in expressions of the schema such as &lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK constraints&lt;/a&gt;, &lt;a href=&quot;lang_createtable#dfltval&quot;&gt;DEFAULT clauses&lt;/a&gt;, &lt;a href=&quot;gencol&quot;&gt;generated columns&lt;/a&gt;, &lt;a href=&quot;expridx&quot;&gt;expression indexes&lt;/a&gt;, and/or &lt;a href=&quot;partialindex&quot;&gt;partial indexes&lt;/a&gt;. This setting can also be controlled using the &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigtrustedschema&quot;&gt;SQLITE_DBCONFIG_TRUSTED_SCHEMA&lt;/a&gt;,...) C-language interface.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e242c8734781e20213900394ec30db10b58ee560" translate="yes" xml:space="preserve">
          <source>The two &quot;0&quot; parameters do server a purpose in some contexts, but for using these routine to print a parse tree as ASCII-art on the terminal, they should both be &quot;0&quot;.</source>
          <target state="translated">Оба параметра &quot;0&quot; в некоторых контекстах выполняют функцию сервера,но для использования этих рутинных действий для печати дерева разбора в виде ASCII-арта на терминале,оба они должны быть &quot;0&quot;.</target>
        </trans-unit>
        <trans-unit id="46623d6b4b79b06cc3078e791041446a91edf407" translate="yes" xml:space="preserve">
          <source>The two 4-byte big-endian integers at offsets 52 and 64 are used to manage the &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum&lt;/a&gt; and &lt;a href=&quot;pragma#pragma_incremental_vacuum&quot;&gt;incremental_vacuum&lt;/a&gt; modes. If the integer at offset 52 is zero then pointer-map (ptrmap) pages are omitted from the database file and neither auto_vacuum nor incremental_vacuum are supported. If the integer at offset 52 is non-zero then it is the page number of the largest root page in the database file, the database file will contain ptrmap pages, and the mode must be either auto_vacuum or incremental_vacuum. In this latter case, the integer at offset 64 is true for incremental_vacuum and false for auto_vacuum. If the integer at offset 52 is zero then the integer at offset 64 must also be zero.</source>
          <target state="translated">Два 4-байтовых целых числа с &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;прямым порядком&lt;/a&gt; байтов в смещениях 52 и 64 используются для управления режимами auto_vacuum и &lt;a href=&quot;pragma#pragma_incremental_vacuum&quot;&gt;incremental_vacuum&lt;/a&gt; . Если целое число по смещению 52 равно нулю, то страницы указателя-карты (ptrmap) исключаются из файла базы данных, и ни auto_vacuum, ни incremental_vacuum не поддерживаются. Если целое число по смещению 52 не равно нулю, то это номер страницы самой большой корневой страницы в файле базы данных, файл базы данных будет содержать страницы ptrmap, и режим должен быть либо auto_vacuum, либо incremental_vacuum. В этом последнем случае целое число по смещению 64 истинно для incremental_vacuum и ложно для auto_vacuum. Если целое число по смещению 52 равно нулю, то целое число по смещению 64 также должно быть нулевым.</target>
        </trans-unit>
        <trans-unit id="5d5cec8b4b21ae2b9d4802acdeb66477068dae88" translate="yes" xml:space="preserve">
          <source>The two &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued functions&lt;/a&gt; are:</source>
          <target state="translated">Две возвращающие &lt;a href=&quot;vtab#tabfunc2&quot;&gt;табличное значение функции&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="60d1d8fda3bbd4cfca022cc996f0d5a823d5b6ed" translate="yes" xml:space="preserve">
          <source>The two exceptions are:</source>
          <target state="translated">Два исключения:</target>
        </trans-unit>
        <trans-unit id="e1f0bf58781420b540ac606f0e7579a8a2be4378" translate="yes" xml:space="preserve">
          <source>The two fragments of SQL below are similar, but not entirely equivalent, as the latter will fail if the definition of window &quot;win&quot; contains a frame specification.</source>
          <target state="translated">Два фрагмента SQL ниже схожи,но не полностью эквивалентны,так как последний провалится,если определение окна &quot;win&quot; будет содержать спецификацию кадра.</target>
        </trans-unit>
        <trans-unit id="f9a92735a6c1a485477340ad1399f41bdfef6983" translate="yes" xml:space="preserve">
          <source>The two remaining tables, %_segments and %_segdir, are used to store the full-text index. Conceptually, this index is a lookup table that maps each term (word) to the set of docid values corresponding to records in the %_content table that contain one or more occurrences of the term. To retrieve all documents that contain a specified term, the FTS module queries this index to determine the set of docid values for records that contain the term, then retrieves the required documents from the %_content table. Regardless of the schema of the FTS virtual table, the %_segments and %_segdir tables are always created as follows:</source>
          <target state="translated">Остальные две таблицы,%_сегменты и %_сегдир,используются для хранения полнотекстового индекса.Концептуально этот индекс представляет собой поисковую таблицу,которая сопоставляет каждый термин (слово)с набором документальных значений,соответствующих записям в таблице %_content,содержащим одно или несколько вхождений этого термина.Для получения всех документов,которые содержат заданный термин,модуль FTS запрашивает этот индекс для определения набора документальных значений для записей,которые содержат термин,а затем извлекает необходимые документы из таблицы %_content.Независимо от схемы виртуальной таблицы FTS,таблицы %_segments и %_segdir всегда создаются следующим образом:</target>
        </trans-unit>
        <trans-unit id="57eb59a7de5c1f2eacd1a8c2e2793991396d4104" translate="yes" xml:space="preserve">
          <source>The two salt value copied from the WAL file header. These values are in the byte-order of the WAL file, which might be different from the native byte-order of the machine.</source>
          <target state="translated">Два значения соли скопированы из заголовка файла WAL.Эти значения находятся в байтовом порядке файла WAL,который может отличаться от родного байтового порядка машины.</target>
        </trans-unit>
        <trans-unit id="ccc9e431ebc7fabfa6726082e51ef8838fff247f" translate="yes" xml:space="preserve">
          <source>The two-argument version of &lt;a href=&quot;fts3#f3tknzr&quot;&gt;fts3_tokenizer()&lt;/a&gt; accepts a pointer to the tokenizer method object even without the &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config&lt;/a&gt;(&lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigenablefts3tokenizer&quot;&gt;SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER&lt;/a&gt;) setting if the second argument is a &lt;a href=&quot;lang_expr#varparam&quot;&gt;bound parameter&lt;/a&gt;</source>
          <target state="translated">Версия &lt;a href=&quot;fts3#f3tknzr&quot;&gt;fts3_tokenizer () с&lt;/a&gt; двумя аргументами принимает указатель на объект метода токенизатора даже без настройки &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config&lt;/a&gt; ( &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigenablefts3tokenizer&quot;&gt;SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER&lt;/a&gt; ), если второй аргумент является &lt;a href=&quot;lang_expr#varparam&quot;&gt;связанным параметром&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6b8d35e3a824a79bc7ce101b6a6ae7997418f4f7" translate="yes" xml:space="preserve">
          <source>The two-byte integer at offset 1 gives the start of the first freeblock on the page, or is zero if there are no freeblocks.</source>
          <target state="translated">Двухбайтовое целое число со смещением 1 дает начало первого свободного блока на странице,или равно нулю,если свободных блоков нет.</target>
        </trans-unit>
        <trans-unit id="c4473928239ae1bda74a9fb4bb8276860fc5ffb5" translate="yes" xml:space="preserve">
          <source>The two-byte integer at offset 3 gives the number of cells on the page.</source>
          <target state="translated">Двухбайтовое целое число со смещением 3 дает количество ячеек на странице.</target>
        </trans-unit>
        <trans-unit id="a06521372b9101f2c70d6a3c29239fdaf5cbc5a7" translate="yes" xml:space="preserve">
          <source>The two-byte integer at offset 5 designates the start of the cell content area. A zero value for this integer is interpreted as 65536.</source>
          <target state="translated">Двухбайтовое целое число со смещением 5 обозначает начало области содержимого ячейки.Нулевое значение для этого целого числа интерпретируется как 65536.</target>
        </trans-unit>
        <trans-unit id="85da2eb104aa5ac23b3d2218d186677a6dbc8b7e" translate="yes" xml:space="preserve">
          <source>The two-byte value beginning at offset 16 determines the page size of the database. For SQLite versions 3.7.0.1 (2010-08-04) and earlier, this value is interpreted as a big-endian integer and must be a power of two between 512 and 32768, inclusive. Beginning with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_1.html&quot;&gt;version 3.7.1&lt;/a&gt; (2010-08-23), a page size of 65536 bytes is supported. The value 65536 will not fit in a two-byte integer, so to specify a 65536-byte page size, the value at offset 16 is 0x00 0x01. This value can be interpreted as a big-endian 1 and thought of as a magic number to represent the 65536 page size. Or one can view the two-byte field as a little endian number and say that it represents the page size divided by 256. These two interpretations of the page-size field are equivalent.</source>
          <target state="translated">Двухбайтовое значение, начинающееся со смещения 16, определяет размер страницы базы данных. Для версий SQLite 3.7.0.1 (2010-08-04) и более ранних это значение интерпретируется как целое число с прямым порядком байтов и должно быть степенью двойки от 512 до 32768 включительно. Начиная с &lt;a href=&quot;https://sqlite.org/releaselog/3_7_1.html&quot;&gt;версии&lt;/a&gt; SQLite 3.7.1 (2010-08-23), поддерживается размер страницы 65536 байт. Значение 65536 не помещается в двухбайтовое целое число, поэтому, чтобы указать размер страницы 65536 байт, значение по смещению 16 равно 0x00 0x01. Это значение можно интерпретировать как 1 с прямым порядком байтов и рассматривать как магическое число, представляющее размер страницы 65536. Или можно рассматривать двухбайтовое поле как число с прямым порядком байтов и сказать, что оно представляет размер страницы, деленный на 256. Эти две интерпретации поля размера страницы эквивалентны.</target>
        </trans-unit>
        <trans-unit id="d620a0d4c1327669927184e30780adb142926606" translate="yes" xml:space="preserve">
          <source>The typedef is necessary to work around problems in certain C++ compilers.</source>
          <target state="translated">Типef необходим для работы над проблемами в некоторых Си++компиляторах.</target>
        </trans-unit>
        <trans-unit id="2acee6be58c92d0d4d1c18a3c705f7ce6eca583d" translate="yes" xml:space="preserve">
          <source>The typeof(X) function returns a string that indicates the &lt;a href=&quot;datatype3&quot;&gt;datatype&lt;/a&gt; of the expression X: &quot;null&quot;, &quot;integer&quot;, &quot;real&quot;, &quot;text&quot;, or &quot;blob&quot;.</source>
          <target state="translated">Функция typeof (X) возвращает строку, которая указывает &lt;a href=&quot;datatype3&quot;&gt;тип данных&lt;/a&gt; выражения X: &amp;laquo;null&amp;raquo;, &amp;laquo;integer&amp;raquo;, &amp;laquo;real&amp;raquo;, &amp;laquo;text&amp;raquo; или &amp;laquo;blob&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="7de0eb427df1bd72e4d6981f084f01d2fd7b104b" translate="yes" xml:space="preserve">
          <source>The types and default collation sequences attached to each column must be the same for all component tables.</source>
          <target state="translated">Типы и последовательности сверки по умолчанию,прикрепленные к каждому столбцу,должны быть одинаковыми для всех таблиц компонентов.</target>
        </trans-unit>
        <trans-unit id="7a193d6baad5e9eae89c634a076cd20d9e39a2d0" translate="yes" xml:space="preserve">
          <source>The unary operator</source>
          <target state="translated">Унарный оператор</target>
        </trans-unit>
        <trans-unit id="5de3e6de824f9a3c28afdefed054e3e170c8e0d8" translate="yes" xml:space="preserve">
          <source>The uncompress function should uncompress data previously compressed by the compress function. In other words, for all SQLite values X, it should be true that uncompress(compress(X)) equals X. When data that has been compressed by the compress function is read from the database by FTS4, it is passed to the uncompress function before it is used.</source>
          <target state="translated">Функция распаковки должна распаковать данные,ранее сжатые функцией компрессии.Другими словами,для всех значений X в SQLite должно быть верно,что unompress(compress(X))равно X.Когда данные,которые были сжаты функцией компрессии,считываются из базы данных по FTS4,они передаются в функцию распаковки перед использованием.</target>
        </trans-unit>
        <trans-unit id="04cb6e28b7a92f43a8ce66195a1ea7614bfeaae5" translate="yes" xml:space="preserve">
          <source>The underlying implementation can support some subset of these locking levels as long as it meets the other requirements of this paragraph. The locking level is specified as the second argument to both xLock and xUnlock. The xLock method increases the locking level to the specified locking level or higher. The xUnlock method decreases the locking level to no lower than the level specified. &lt;a href=&quot;c3ref/c_lock_exclusive&quot;&gt;SQLITE_LOCK_NONE&lt;/a&gt; means that the file is unlocked. &lt;a href=&quot;c3ref/c_lock_exclusive&quot;&gt;SQLITE_LOCK_SHARED&lt;/a&gt; gives permission to read the file. Multiple database connections can hold &lt;a href=&quot;c3ref/c_lock_exclusive&quot;&gt;SQLITE_LOCK_SHARED&lt;/a&gt; at the same time. &lt;a href=&quot;c3ref/c_lock_exclusive&quot;&gt;SQLITE_LOCK_RESERVED&lt;/a&gt; is like &lt;a href=&quot;c3ref/c_lock_exclusive&quot;&gt;SQLITE_LOCK_SHARED&lt;/a&gt; in that it is permission to read the file. But only a single connection can hold a reserved lock at any point in time. The &lt;a href=&quot;c3ref/c_lock_exclusive&quot;&gt;SQLITE_LOCK_PENDING&lt;/a&gt; is also permission to read the file. Other connections can continue to read the file as well, but no other connection is allowed to escalate a lock from none to shared. &lt;a href=&quot;c3ref/c_lock_exclusive&quot;&gt;SQLITE_LOCK_EXCLUSIVE&lt;/a&gt; is permission to write on the file. Only a single connection can hold an exclusive lock and no other connection can hold any lock (other than &quot;none&quot;) while one connection holds an exclusive lock. The xLock returns &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; on success, &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; if it is unable to obtain the lock, or &lt;a href=&quot;rescode#ioerr_rdlock&quot;&gt;SQLITE_IOERR_RDLOCK&lt;/a&gt; if something else goes wrong. The xUnlock method returns &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; on success and &lt;a href=&quot;rescode#ioerr_unlock&quot;&gt;SQLITE_IOERR_UNLOCK&lt;/a&gt; for problems.</source>
          <target state="translated">Базовая реализация может поддерживать некоторое подмножество этих уровней блокировки, если она соответствует другим требованиям этого параграфа. Уровень блокировки указывается вторым аргументом как для xLock, так и для xUnlock. Метод xLock увеличивает уровень блокировки до указанного уровня блокировки или выше. Метод xUnlock снижает уровень блокировки не ниже указанного. &lt;a href=&quot;c3ref/c_lock_exclusive&quot;&gt;SQLITE_LOCK_NONE&lt;/a&gt; означает, что файл разблокирован. &lt;a href=&quot;c3ref/c_lock_exclusive&quot;&gt;SQLITE_LOCK_SHARED&lt;/a&gt; дает разрешение на чтение файла. &lt;a href=&quot;c3ref/c_lock_exclusive&quot;&gt;SQLITE_LOCK_SHARED&lt;/a&gt; может одновременно содержать несколько соединений с базой данных . &lt;a href=&quot;c3ref/c_lock_exclusive&quot;&gt;SQLITE_LOCK_RESERVED&lt;/a&gt; похож на &lt;a href=&quot;c3ref/c_lock_exclusive&quot;&gt;SQLITE_LOCK_SHARED&lt;/a&gt;в том, что это разрешение на чтение файла. Но только одно соединение может удерживать зарезервированную блокировку в любой момент времени. &lt;a href=&quot;c3ref/c_lock_exclusive&quot;&gt;SQLITE_LOCK_PENDING&lt;/a&gt; также разрешение на чтение файла. Другие соединения также могут продолжать читать файл, но никакому другому соединению не разрешено повышать блокировку с нулевой до общей.&lt;a href=&quot;c3ref/c_lock_exclusive&quot;&gt;SQLITE_LOCK_EXCLUSIVE&lt;/a&gt; - это разрешение на запись в файл. Только одно соединение может удерживать исключительную блокировку, и никакое другое соединение не может удерживать какую-либо блокировку (кроме &quot;none&quot;), в то время как одно соединение имеет исключительную блокировку. XLock возвращает &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; в случае успеха, &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY,&lt;/a&gt; если он не может получить блокировку, или &lt;a href=&quot;rescode#ioerr_rdlock&quot;&gt;SQLITE_IOERR_RDLOCK,&lt;/a&gt; если что-то еще пойдет не так. Метод xUnlock возвращает&lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; при успехе и &lt;a href=&quot;rescode#ioerr_unlock&quot;&gt;SQLITE_IOERR_UNLOCK&lt;/a&gt; при проблемах.</target>
        </trans-unit>
        <trans-unit id="0269000c82eb39065f294879a620aecf2c6e833d" translate="yes" xml:space="preserve">
          <source>The underscore character (unicode codepoint 96).</source>
          <target state="translated">Символ подчёркивания (кодовый знак юникода 96).</target>
        </trans-unit>
        <trans-unit id="94b1d236b1b1bdea969b9f218085fccfc7fb6de3" translate="yes" xml:space="preserve">
          <source>The undo::activate command creates temporary triggers in the database that record all changes made to the tables named in the arguments.</source>
          <target state="translated">Команда undo::activate создает в БД временные триггеры,которые записывают все изменения,внесенные в таблицы с именами в аргументах.</target>
        </trans-unit>
        <trans-unit id="9d719f9a44e55c933ab5b5fa11156ee426d1545d" translate="yes" xml:space="preserve">
          <source>The undocumented &lt;b&gt;sqlite3_os_switch()&lt;/b&gt; interface has been removed.</source>
          <target state="translated">Недокументированный интерфейс &lt;b&gt;sqlite3_os_switch ()&lt;/b&gt; был удален.</target>
        </trans-unit>
        <trans-unit id="93cdbdaae25242141056e83b2feecd9f656881a8" translate="yes" xml:space="preserve">
          <source>The unicode tokenizer classifies all unicode characters as either &quot;separator&quot; or &quot;token&quot; characters. By default all space and punctuation characters, as defined by Unicode 6.1, are considered separators, and all other characters as token characters. More specifically, all unicode characters assigned to a &lt;a href=&quot;https://en.wikipedia.org/wiki/Unicode_character_property#General_Category&quot;&gt; general category&lt;/a&gt; beginning with &quot;L&quot; or &quot;N&quot; (letters and numbers, specifically) or to category &quot;Co&quot; (&quot;other, private use&quot;) are considered tokens. All other characters are separators.</source>
          <target state="translated">Токенизатор Юникода классифицирует все символы Юникода как символы-разделители или символы-токены. По умолчанию все пробелы и знаки препинания, как определено в Unicode 6.1, считаются разделителями, а все остальные символы - символами-маркерами. Более конкретно, все символы Юникода, присвоенные &lt;a href=&quot;https://en.wikipedia.org/wiki/Unicode_character_property#General_Category&quot;&gt;общей категории,&lt;/a&gt; начинающейся с &amp;laquo;L&amp;raquo; или &amp;laquo;N&amp;raquo; (буквы и цифры, в частности) или категории &amp;laquo;Со&amp;raquo; (&amp;laquo;другое, личное использование&amp;raquo;), считаются токенами. Все остальные символы являются разделителями.</target>
        </trans-unit>
        <trans-unit id="8359d1281537e2db390ccb27a011cf0c1e07387b" translate="yes" xml:space="preserve">
          <source>The unicode(X) function returns the numeric unicode code point corresponding to the first character of the string X. If the argument to unicode(X) is not a string then the result is undefined.</source>
          <target state="translated">Функция unicode(X)возвращает числовую точку кода юникода,соответствующую первому символу строки X.Если аргумент к unicode(X)не является строкой,то результат является неопределенным.</target>
        </trans-unit>
        <trans-unit id="b06912261f5bb2d984a2ea7d12c5ea40ed3062a1" translate="yes" xml:space="preserve">
          <source>The union-vtab is not built into SQLite. Union-vtab is a &lt;a href=&quot;loadext&quot;&gt;loadable extension&lt;/a&gt;. The source code for union-vtab is contained in a single file located at &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/unionvtab.c&quot;&gt;ext/misc/unionvtab.c&lt;/a&gt; in the SQLite source tree.</source>
          <target state="translated">Union-vtab не встроен в SQLite. Union-vtab - это&lt;a href=&quot;loadext&quot;&gt; загружаемое расширение&lt;/a&gt; . Исходный код union-vtab содержится в одном файле, расположенном по адресу &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/unionvtab.c&quot;&gt;ext / misc / unionvtab.c&lt;/a&gt; в дереве исходных текстов SQLite.</target>
        </trans-unit>
        <trans-unit id="70f606d5ad9373cd7360030770268b87dc04b4a8" translate="yes" xml:space="preserve">
          <source>The union-vtab is read-only. Support for writing may be added at a later time, but writing is not a part of the initial implementation.</source>
          <target state="translated">Юнион-втаб доступен только для чтения.Поддержка написания может быть добавлена позже,но написание не является частью первоначальной реализации.</target>
        </trans-unit>
        <trans-unit id="217c127b8d7dc9166357c6c852e4edb92e8bd2cc" translate="yes" xml:space="preserve">
          <source>The union-vtab shall optimize access to the underlying real tables when the constraints on the query are among forms shown below. Other kinds of constraints may be optimized in the future, but only these constraints are optimized in the initial implementation.</source>
          <target state="translated">Union-vtab должен оптимизировать доступ к основным реальным таблицам,когда ограничения на запрос входят в число форм,показанных ниже.Другие виды ограничений могут быть оптимизированы в будущем,но только эти ограничения оптимизируются в начальной реализации.</target>
        </trans-unit>
        <trans-unit id="5ad25f83f6534911bf90077b4a8c2d24284bf894" translate="yes" xml:space="preserve">
          <source>The unique id (INTEGER PRIMARY KEY)</source>
          <target state="translated">Уникальный идентификатор (INTEGER PRIMARY KEY).</target>
        </trans-unit>
        <trans-unit id="37c73afc15f55751239631e696091c5fb7a86756" translate="yes" xml:space="preserve">
          <source>The unix &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; will never use a file descriptor less than</source>
          <target state="translated">Unix &lt;a href=&quot;vfs&quot;&gt; VFS&lt;/a&gt; никогда не будет использовать дескриптор файла меньше, чем</target>
        </trans-unit>
        <trans-unit id="ae8287e8b161fa1549dd3442fa8607f53d8dfe62" translate="yes" xml:space="preserve">
          <source>The unlikely(X) function returns the argument X unchanged. The unlikely(X) function is a no-op that the code generator optimizes away so that it consumes no CPU cycles at run-time (that is, during calls to &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt;). The purpose of the unlikely(X) function is to provide a hint to the query planner that the argument X is a boolean value that is usually not true. The unlikely(X) function is equivalent to &lt;a href=&quot;lang_corefunc#likelihood&quot;&gt;likelihood&lt;/a&gt;(X, 0.0625).</source>
          <target state="translated">Функция маловероятно (X) возвращает аргумент X без изменений. Маловероятная (X) функция - это запретная операция, которую генератор кода оптимизирует, чтобы не потреблять циклы ЦП во время выполнения (то есть во время вызовов &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step ()&lt;/a&gt; ). Назначение маловероятной (X) функции - указать планировщику запросов, что аргумент X является логическим значением, которое обычно не соответствует действительности. Функция маловероятной (X) эквивалентна &lt;a href=&quot;lang_corefunc#likelihood&quot;&gt;правдоподобию&lt;/a&gt; (X, 0,0625).</target>
        </trans-unit>
        <trans-unit id="f74bf3865d4b8d380ed09cdf9682ebd8ba365f80" translate="yes" xml:space="preserve">
          <source>The unlock-notify callback is not reentrant. If an application invokes any sqlite3_xxx API functions from within an unlock-notify callback, a crash or deadlock may be the result.</source>
          <target state="translated">Обратный звонок по разблокировке не возвращается.Если приложение вызывает какие-либо функции sqlite3_xxx API в рамках обратного вызова уведомления о разблокировке,может произойти аварийное завершение работы или тупик.</target>
        </trans-unit>
        <trans-unit id="9f10c2e623337226e56371f152fe9704c596a75e" translate="yes" xml:space="preserve">
          <source>The unlock_notify method is used access the &lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify()&lt;/a&gt; interface to the SQLite core library for testing purposes. The use of this method by applications is discouraged.</source>
          <target state="translated">Метод unlock_notify используется для доступа к &lt;a href=&quot;c3ref/unlock_notify&quot;&gt;&lt;/a&gt; интерфейсу sqlite3_unlock_notify () к основной библиотеке SQLite в целях тестирования. Использование этого метода приложениями не рекомендуется.</target>
        </trans-unit>
        <trans-unit id="c0db7fcedecb648c350c1b6f11ba954f23165737" translate="yes" xml:space="preserve">
          <source>The update hook implementation must not do anything that will modify the database connection that invoked the update hook. Any actions to modify the database connection must be deferred until after the completion of the &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; call that triggered the update hook. Note that &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; both modify their database connections for the meaning of &quot;modify&quot; in this paragraph.</source>
          <target state="translated">Реализация ловушки обновления не должна делать ничего, что изменило бы соединение с базой данных, вызвавшее ловушку обновления. Любые действия по изменению подключения к базе данных должны быть отложены до завершения вызова &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step (),&lt;/a&gt; который запустил ловушку обновления. Обратите внимание, что &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; и &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step ()&lt;/a&gt; оба изменяют свои соединения с базой данных для значения слова &amp;laquo;изменить&amp;raquo; в этом абзаце.</target>
        </trans-unit>
        <trans-unit id="09532968164962481e11046837aaa8bacbe59ea0" translate="yes" xml:space="preserve">
          <source>The update hook implementation must not do anything that will modify the database connection that invoked the update hook. Any actions to modify the database connection must be deferred until after the completion of the &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; call that triggered the update hook. Note that &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; and &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; both modify their database connections for the meaning of &quot;modify&quot; in this paragraph.</source>
          <target state="translated">Реализация ловушки обновления не должна делать ничего, что изменило бы соединение с базой данных, вызвавшее ловушку обновления. Любые действия по изменению подключения к базе данных должны быть отложены до завершения вызова &lt;a href=&quot;step&quot;&gt;sqlite3_step (),&lt;/a&gt; который запустил ловушку обновления. Обратите внимание, что &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; и &lt;a href=&quot;step&quot;&gt;sqlite3_step ()&lt;/a&gt; оба изменяют свои соединения с базой данных для значения слова &amp;laquo;изменить&amp;raquo; в этом абзаце.</target>
        </trans-unit>
        <trans-unit id="f188e349260d6d862bd1151de1aa0b41c96135c8" translate="yes" xml:space="preserve">
          <source>The update hook is not invoked when internal system tables are modified (i.e. sqlite_master and sqlite_sequence). The update hook is not invoked when &lt;a href=&quot;../withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables are modified.</source>
          <target state="translated">Ловушка обновления не вызывается при изменении внутренних системных таблиц (например, sqlite_master и sqlite_sequence). &lt;a href=&quot;../withoutrowid&quot;&gt;Ловушка&lt;/a&gt; обновления не вызывается при изменении таблиц БЕЗ ROWID .</target>
        </trans-unit>
        <trans-unit id="d4c3b215f10d00c42f1094ebb70e270136be0ef6" translate="yes" xml:space="preserve">
          <source>The update hook is not invoked when internal system tables are modified (i.e. sqlite_master and sqlite_sequence). The update hook is not invoked when &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables are modified.</source>
          <target state="translated">Ловушка обновления не вызывается при изменении внутренних системных таблиц (например, sqlite_master и sqlite_sequence). &lt;a href=&quot;withoutrowid&quot;&gt;Ловушка&lt;/a&gt; обновления не вызывается при изменении таблиц БЕЗ ROWID .</target>
        </trans-unit>
        <trans-unit id="f04fa9936d514fac1b991da703764bce23461785" translate="yes" xml:space="preserve">
          <source>The update hook is not invoked when internal system tables are modified (i.e. sqlite_sequence). The update hook is not invoked when &lt;a href=&quot;../withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables are modified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b14dc5637688b2512ff9a25b9caa046cb0c8fc2" translate="yes" xml:space="preserve">
          <source>The update hook is not invoked when internal system tables are modified (i.e. sqlite_sequence). The update hook is not invoked when &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables are modified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b3d709a5bf6d8d9c48b677160252ac4da74295a" translate="yes" xml:space="preserve">
          <source>The upper bound on the database &lt;a href=&quot;pragma#pragma_cache_size&quot;&gt;cache size&lt;/a&gt; has traditionally defaulted to 2000 pages. SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_12_0.html&quot;&gt;version 3.12.0&lt;/a&gt; also changes this default setting to be &quot;-2000&quot; which means 2000*1024 bytes, regardless of page size. So, the upper bound on the amount of memory used for the page cache is unchanged.</source>
          <target state="translated">Верхняя граница &lt;a href=&quot;pragma#pragma_cache_size&quot;&gt;размера кэша&lt;/a&gt; базы данных по умолчанию составляет 2000 страниц. SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_12_0.html&quot;&gt;версии 3.12.0&lt;/a&gt; также изменяет этот параметр по умолчанию на &amp;laquo;-2000&amp;raquo;, что означает 2000 * 1024 байта, независимо от размера страницы. Таким образом, верхняя граница объема памяти, используемой для кеширования страниц, не изменилась.</target>
        </trans-unit>
        <trans-unit id="55e210be964a43ed3f79f81acfb0252d2ec508a2" translate="yes" xml:space="preserve">
          <source>The upper(X) function returns a copy of input string X in which all lower-case ASCII characters are converted to their upper-case equivalent.</source>
          <target state="translated">Функция upper(X)возвращает копию входной строки X,в которой все строчные ASCII-символы преобразуются в их прописной эквивалент.</target>
        </trans-unit>
        <trans-unit id="2ff3bb49a7df2e57465c506adbfbac36859c676c" translate="yes" xml:space="preserve">
          <source>The upsert above inserts the new vocabulary word &quot;jovial&quot; if that word is not already in the dictionary, or if it is already in the dictionary, it increments the counter. The &quot;count+1&quot; expression could also be written as &quot;vocabulary.count&quot;. PostgreSQL requires the second form, but SQLite accepts either.</source>
          <target state="translated">Вверху вставляется новое словосочетание &quot;йовиальный&quot;,если этого слова еще нет в словаре,или если оно уже есть в словаре,оно увеличивает счетчик.Выражение &quot;счет+1&quot; также может быть записано как &quot;vocabulary.count&quot;.PostgreSQL требует второй формы,но SQLite принимает и то,и другое.</target>
        </trans-unit>
        <trans-unit id="f98914d65daf1eee948f9cf4215d1bc155ef41fa" translate="yes" xml:space="preserve">
          <source>The usage of pagecache memory is somewhat harder to control in SQLite version 3.6.1, though mechanisms are planned for subsequent releases that will make controlling pagecache memory much easier. Prior to the introduction of these new mechanisms, the only way to control pagecache memory is using the &lt;a href=&quot;pragma#pragma_cache_size&quot;&gt;cache_size pragma&lt;/a&gt;.</source>
          <target state="translated">Использование памяти pagecache несколько сложнее контролировать в SQLite версии 3.6.1, хотя в последующих выпусках запланированы механизмы, которые значительно упростят управление памятью pagecache. До введения этих новых механизмов единственным способом управления памятью кэша страниц было использование &lt;a href=&quot;pragma#pragma_cache_size&quot;&gt;прагмы cache_size&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="83c37f6e9e518d22e126d6f49713b321c1f31d9b" translate="yes" xml:space="preserve">
          <source>The use of &quot;:&quot; instead of &quot;$&quot; before the name of a variable can sometimes be useful if the SQL text is enclosed in double-quotes &quot;...&quot; instead of curly-braces {...}. When the SQL is contained within double-quotes &quot;...&quot; then TCL will do the substitution of $-variables, which can lead to SQL injection if extreme care is not used. But TCL will never substitute a :-variable regardless of whether double-quotes &quot;...&quot; or curly-braces {...} are used to enclose the SQL, so the use of :-variables adds an extra measure of defense against SQL injection.</source>
          <target state="translated">Использование &quot;:&quot; вместо &quot;$&quot; перед именем переменной иногда может быть полезно,если SQL текст заключен в двойные кавычки &quot;...&quot; вместо фигурных скобок {...}.Когда SQL заключен в двойные кавычки &quot;...&quot;,то TCL сделает замену $-переменных,что может привести к SQL инъекции,если не использовать крайние меры предосторожности.Но TCL никогда не заменит :-переменную независимо от того,используются ли двойные кавычки &quot;...&quot; или фигурные скобки {...}для вложения SQL,поэтому использование :-переменных добавляет дополнительную меру защиты от SQL инъекции.</target>
        </trans-unit>
        <trans-unit id="c10b4d5006af0e657932026cc02e7f4a31cf3940" translate="yes" xml:space="preserve">
          <source>The use of NUL characters in SQL text strings is not recommended.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53ba0fe6640d81c27b2028a34ac03622ddcd61d3" translate="yes" xml:space="preserve">
          <source>The use of a ZIP archive to encapsulate XML files plus resources is an elegant approach to an application file format. It is clearly superior to a custom binary file format. But using an SQLite database as the container, instead of ZIP, would be more elegant still.</source>
          <target state="translated">Использование ZIP-архива для инкапсуляции XML-файлов плюс ресурсов является элегантным подходом к формату файла приложения.Он явно превосходит пользовательский двоичный формат файла.Но использование базы данных SQLite в качестве контейнера вместо ZIP было бы еще более элегантным.</target>
        </trans-unit>
        <trans-unit id="62a1d7ca77be3f3b5567800401dc0bf052c2aaae" translate="yes" xml:space="preserve">
          <source>The use of a virtual machine in SQLite has been a great benefit to the library's development. The virtual machine provides a crisp, well-defined junction between the front-end of SQLite (the part that parses SQL statements and generates virtual machine code) and the back-end (the part that executes the virtual machine code and computes a result.) The virtual machine allows the developers to see clearly and in an easily readable form what SQLite is trying to do with each statement it compiles, which is a tremendous help in debugging. Depending on how it is compiled, SQLite also has the capability of tracing the execution of the virtual machine - printing each virtual machine instruction and its result as it executes.</source>
          <target state="translated">Использование виртуальной машины в SQLite было большим преимуществом при разработке библиотеки.Виртуальная машина обеспечивает четкий,четко определенный переход между внешним интерфейсом SQLite (часть,которая разбирает SQL-операторы и генерирует код виртуальной машины)и внутренним интерфейсом (часть,которая выполняет код виртуальной машины и вычисляет результат).Виртуальная машина позволяет разработчикам четко и в легко читаемом виде видеть,что SQLite пытается сделать с каждым оператором,который он компилирует,что является огромным подспорьем в отладке.В зависимости от того,как она компилируется,SQLite также имеет возможность отслеживать выполнение виртуальной машины-распечатывать каждую инструкцию виртуальной машины и ее результат по мере выполнения.</target>
        </trans-unit>
        <trans-unit id="9d27ce1c6f5449fceeec41db3a7baef374e89122" translate="yes" xml:space="preserve">
          <source>The use of each of these methods will be explained in the sequel, though not in the order shown above.</source>
          <target state="translated">Использование каждого из этих методов будет объяснено в сиквеле,хотя и не в порядке,показанном выше.</target>
        </trans-unit>
        <trans-unit id="ac3e9e4d3a0d1a6a51dbf276370664c84cd0bc3c" translate="yes" xml:space="preserve">
          <source>The use of persistent journal mode provides a noticeable performance improvement on many systems. Of course, the drawback is that the journal files remain on the disk, using disk space and cluttering directories, long after the transaction commits. The only safe way to delete a persistent journal file is to commit a transaction with journaling mode set to DELETE:</source>
          <target state="translated">Использование режима постоянного журнала обеспечивает заметное повышение производительности многих систем.Конечно,недостатком является то,что файлы журнала остаются на диске,используя дисковое пространство и загромождающие каталоги,долгое время после фиксации транзакции.Единственный безопасный способ удалить файл постоянного журнала-это зафиксировать транзакцию в режиме записи,установленном в DELETE:</target>
        </trans-unit>
        <trans-unit id="ac2e1cc15280219a058aa01cbdd9d14acc3c174c" translate="yes" xml:space="preserve">
          <source>The use of pointer-passing is an advanced technique that should be used infrequently and cautiously. Pointer-passing should not be used haphazardly or carelessly. Pointer-passing is a sharp tool that can leave deep scars if misused.</source>
          <target state="translated">Использование обхода указателя-это продвинутая техника,которую следует использовать нечасто и с осторожностью.Указка-обход не должна использоваться бессистемно или небрежно.Указка-обход является острым инструментом,который может оставить глубокие шрамы при неправильном использовании.</target>
        </trans-unit>
        <trans-unit id="716439e76a7ceab1c8c91b09a2f76c73c53bf8c1" translate="yes" xml:space="preserve">
          <source>The use of subtypes on pointers prevented pointer forgery using pure SQL. But subtypes do nothing to prevent an attacker from reading the values of pointers. In other words, subtypes on pointer values prevent attacks using SQL statements like this:</source>
          <target state="translated">Использование подтипов на указателях предотвратило подделку указателей с использованием чистого SQL.Но подтипы ничего не делают для того,чтобы помешать злоумышленнику читать значения указателей.Другими словами,подтипы на значениях указателей предотвращают атаки с использованием подобных SQL выражений:</target>
        </trans-unit>
        <trans-unit id="d8ed607375ddfb8582a61f0a5132f51fb52c53b0" translate="yes" xml:space="preserve">
          <source>The use of the &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt; is recommended for all applications.</source>
          <target state="translated">Использование &lt;a href=&quot;amalgamation&quot;&gt;амальгамации&lt;/a&gt; рекомендуется для всех приложений.</target>
        </trans-unit>
        <trans-unit id="789c46abbb3fc4976d476150773395da4c1e0a98" translate="yes" xml:space="preserve">
          <source>The use of the UTF-8 interfaces is preferred, as SQLite currently does all parsing using UTF-8. The UTF-16 interfaces are provided as a convenience. The UTF-16 interfaces work by converting the input text into UTF-8, then invoking the corresponding UTF-8 interface.</source>
          <target state="translated">Предпочтительно использовать интерфейсы UTF-8,так как SQLite в настоящее время выполняет весь парсинг с использованием UTF-8.Интерфейсы UTF-16 предоставляются для удобства.Интерфейсы UTF-16 работают путем преобразования входного текста в UTF-8,а затем вызова соответствующего интерфейса UTF-8.</target>
        </trans-unit>
        <trans-unit id="7ed5c8c8570cfb3a0d0049b76c3fa5c381dc896c" translate="yes" xml:space="preserve">
          <source>The use of the error logger callback is highly recommended. The debugging information that the error logger provides has proven very useful in tracking down obscure problems that occurs with applications after they get into the field. The error logger callback has also proven useful in catching errors occasional errors that the application misses because of inconsistent checking of API return codes. Developers are encouraged to implement an error logger callback early in the development cycle in order to spot unexpected behavior quickly, and to leave the error logger callback turned on through deployment. If the error logger never finds a problem, then no harm is done. But failure to set up an appropriate error logger might compromise diagnostic capabilities later on.</source>
          <target state="translated">Настоятельно рекомендуется использовать обратный вызов регистратора ошибок.Отладочная информация,предоставляемая регистратором ошибок,оказалась очень полезной для отслеживания неясных проблем,которые возникают с приложениями после того,как они попадают в поле.Обратный вызов регистратора ошибок также оказался полезным для отлова случайных ошибок,которые приложение пропускает из-за непоследовательной проверки кодов возврата API.Разработчикам рекомендуется реализовать обратный вызов регистратора ошибок на ранней стадии цикла разработки,чтобы быстро обнаружить неожиданное поведение и оставить включенным обратный вызов регистратора ошибок во время развертывания.Если регистратор ошибок никогда не найдет проблему,то вреда от этого не будет.Но неустановка соответствующего регистратора ошибок может впоследствии поставить под угрозу диагностические возможности.</target>
        </trans-unit>
        <trans-unit id="a848d528e6bb7ea17daf03362baa03e736e192f7" translate="yes" xml:space="preserve">
          <source>The use of the standardized speedtest1.c workload and cachegrind has enabled significant performance improvement. However, it is important to recognize the limitations of this approach:</source>
          <target state="translated">Использование стандартизированной рабочей нагрузки speedtest1.c и кэшфренда позволило значительно повысить производительность.Однако важно признать ограничения этого подхода:</target>
        </trans-unit>
        <trans-unit id="fbf470196dd9e32d7a6c5961b17698cfadfdbb60" translate="yes" xml:space="preserve">
          <source>The use of variable-length records by SQLite has a number of advantages. It results in smaller database files, obviously. It also makes the database run faster, since there is less information to move to and from disk. And, the use of variable-length records makes it possible for SQLite to employ manifest typing instead of static typing.</source>
          <target state="translated">Использование SQLite записей переменной длины имеет ряд преимуществ.Очевидно,что это приводит к меньшему размеру файлов базы данных.Кроме того,это ускоряет работу базы данных,т.к.меньше информации нужно перемещать на диск и с диска.Кроме того,использование записей переменной длины позволяет SQLite использовать манифестный набор текста вместо статического.</target>
        </trans-unit>
        <trans-unit id="f495ec4a4bf3743c12d1f50425c742888001cad3" translate="yes" xml:space="preserve">
          <source>The user_version pragma will to get or set the value of the user-version integer at offset 60 in the &lt;a href=&quot;fileformat2#database_header&quot;&gt;database header&lt;/a&gt;. The user-version is an integer that is available to applications to use however they want. SQLite makes no use of the user-version itself.</source>
          <target state="translated">Прагма user_version будет получать или устанавливать значение целого числа версии пользователя по смещению 60 в &lt;a href=&quot;fileformat2#database_header&quot;&gt;заголовке базы данных&lt;/a&gt; . Версия пользователя - это целое число, которое доступно приложениям для использования по своему усмотрению. SQLite не использует саму пользовательскую версию.</target>
        </trans-unit>
        <trans-unit id="81fbf2e7b21c5d201e92f96deae7ccf53bbeeddc" translate="yes" xml:space="preserve">
          <source>The usermerge option is similar to the automerge and crisismerge options. It is the minimum number of b-tree segments that will be merged together by a 'merge' command with a positive parameter. For example:</source>
          <target state="translated">Опция usermerge похожа на опции automerge и crisismerge.Это минимальное количество сегментов b-дерева,которые будут объединены командой 'слияние' с положительным параметром.Например:</target>
        </trans-unit>
        <trans-unit id="7380a4170d0b89318a355604d7dab9b3376f5f00" translate="yes" xml:space="preserve">
          <source>The usual &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;, &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;, and &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; commands work on an R*Tree index just like on regular tables. So to insert some data into our sample R*Tree index, we can do something like this:</source>
          <target state="translated">Обычные команды &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; , &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; и &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; работают с индексом R * Tree так же, как и с обычными таблицами. Итак, чтобы вставить некоторые данные в наш пример индекса R * Tree, мы можем сделать что-то вроде этого:</target>
        </trans-unit>
        <trans-unit id="7245ad2ccb3652b74420857f1f81436b120932a2" translate="yes" xml:space="preserve">
          <source>The usual case is that sqlite3_serialize() copies the serialization of the database into memory obtained from &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc64()&lt;/a&gt; and returns a pointer to that memory. The caller is responsible for freeing the returned value to avoid a memory leak. However, if the F argument contains the SQLITE_SERIALIZE_NOCOPY bit, then no memory allocations are made, and the sqlite3_serialize() function will return a pointer to the contiguous memory representation of the database that SQLite is currently using for that database, or NULL if the no such contiguous memory representation of the database exists. A contiguous memory representation of the database will usually only exist if there has been a prior call to &lt;a href=&quot;#sqlite3_deserialize&quot;&gt;sqlite3_deserialize(D,S,...)&lt;/a&gt; with the same values of D and S. The size of the database is written into *P even if the SQLITE_SERIALIZE_NOCOPY bit is set but no contiguous copy of the database exists.</source>
          <target state="translated">Обычно sqlite3_serialize () копирует сериализацию базы данных в память, полученную из &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc64 (),&lt;/a&gt; и возвращает указатель на эту память. Вызывающий отвечает за освобождение возвращаемого значения во избежание утечки памяти. Однако, если аргумент F содержит бит SQLITE_SERIALIZE_NOCOPY, то выделение памяти не производится, и функция sqlite3_serialize () вернет указатель на непрерывное представление памяти базы данных, которую SQLite в настоящее время использует для этой базы данных, или NULL, если нет такое непрерывное представление базы данных в памяти существует. Непрерывное представление базы данных в памяти обычно существует только в том случае, если был предыдущий вызов &lt;a href=&quot;#sqlite3_deserialize&quot;&gt;sqlite3_deserialize (D, S, ...)&lt;/a&gt; с теми же значениями D и S. Размер базы данных записывается в * P, даже если бит SQLITE_SERIALIZE_NOCOPY установлен, но непрерывной копии базы данных не существует.</target>
        </trans-unit>
        <trans-unit id="69659aa2e08fcc19f80f4fa144bcabaf8c7b3ed8" translate="yes" xml:space="preserve">
          <source>The usual case is that sqlite3_serialize() copies the serialization of the database into memory obtained from &lt;a href=&quot;free&quot;&gt;sqlite3_malloc64()&lt;/a&gt; and returns a pointer to that memory. The caller is responsible for freeing the returned value to avoid a memory leak. However, if the F argument contains the SQLITE_SERIALIZE_NOCOPY bit, then no memory allocations are made, and the sqlite3_serialize() function will return a pointer to the contiguous memory representation of the database that SQLite is currently using for that database, or NULL if the no such contiguous memory representation of the database exists. A contiguous memory representation of the database will usually only exist if there has been a prior call to &lt;a href=&quot;deserialize&quot;&gt;sqlite3_deserialize(D,S,...)&lt;/a&gt; with the same values of D and S. The size of the database is written into *P even if the SQLITE_SERIALIZE_NOCOPY bit is set but no contiguous copy of the database exists.</source>
          <target state="translated">Обычно sqlite3_serialize () копирует сериализацию базы данных в память, полученную из &lt;a href=&quot;free&quot;&gt;sqlite3_malloc64 (),&lt;/a&gt; и возвращает указатель на эту память. Вызывающий отвечает за освобождение возвращаемого значения во избежание утечки памяти. Однако, если аргумент F содержит бит SQLITE_SERIALIZE_NOCOPY, то выделение памяти не производится, и функция sqlite3_serialize () вернет указатель на непрерывное представление памяти базы данных, которую SQLite в настоящее время использует для этой базы данных, или NULL, если нет такое непрерывное представление базы данных в памяти существует. Непрерывное представление базы данных в памяти обычно существует только в том случае, если был предыдущий вызов &lt;a href=&quot;deserialize&quot;&gt;sqlite3_deserialize (D, S, ...)&lt;/a&gt; с теми же значениями D и S. Размер базы данных записывается в * P, даже если бит SQLITE_SERIALIZE_NOCOPY установлен, но непрерывной копии базы данных не существует.</target>
        </trans-unit>
        <trans-unit id="2878cf43bc017da229299a9eeb8ee3b6c95340de" translate="yes" xml:space="preserve">
          <source>The usual case is that the entire database file is checked. However, if the argument is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fc6512389ff21ec6ba0d889f8647d34fa1771be" translate="yes" xml:space="preserve">
          <source>The usual output is an SQL script that will transform database1.sqlite (the &quot;source&quot; database) into database2.sqlite (the &quot;destination&quot; database). This behavior can be altered using command-line switches:</source>
          <target state="translated">Обычный вывод-это SQL скрипт,который преобразует database1.sqlite (&quot;исходную&quot; БД)в database2.sqlite (&quot;целевую&quot; БД).Это поведение может быть изменено с помощью переключателей командной строки:</target>
        </trans-unit>
        <trans-unit id="ebe7d136ea02a608354f8bf5123226386a80e2bf" translate="yes" xml:space="preserve">
          <source>The usual usage pattern for an sqlite3_changegroup object is as follows:</source>
          <target state="translated">Обычный шаблон использования объекта sqlite3_changegroup следующий:</target>
        </trans-unit>
        <trans-unit id="f006b61943f366c81b0414ad0d7a764b14620096" translate="yes" xml:space="preserve">
          <source>The usual way of storing a date in a database table is as a single field, as either a unix timestamp, a julian day number, or an ISO-8601 dates string. But some application store dates as three separate fields for the year, month, and day.</source>
          <target state="translated">Обычный способ хранения даты в таблице базы данных-в виде одного поля,в виде одноименной метки времени,юлианского номера дня или строки с датами в формате ISO-8601.Но некоторые приложения хранят даты в виде трех отдельных полей для года,месяца и дня.</target>
        </trans-unit>
        <trans-unit id="e446494ebae458b5aea2681dfd535005a9fb5001" translate="yes" xml:space="preserve">
          <source>The value</source>
          <target state="translated">Значение</target>
        </trans-unit>
        <trans-unit id="1493e5c49d89b37715d26870b14178bb98eff899" translate="yes" xml:space="preserve">
          <source>The value extracted is stored in register P3.</source>
          <target state="translated">Извлеченное значение сохраняется в регистре P3.</target>
        </trans-unit>
        <trans-unit id="b67d4fe7f5972a61b5da20c2ef9a98c84328f043" translate="yes" xml:space="preserve">
          <source>The value of NEW.rowid is undefined in a BEFORE INSERT trigger in which the rowid is not explicitly set to an integer.</source>
          <target state="translated">Значение NEW.rowid не определено в триггере BEFORE INSERT,в котором rowid явно не установлен в целое число.</target>
        </trans-unit>
        <trans-unit id="6ccbeb6aa89a69300ffd6eb190f7535f8bc566cf" translate="yes" xml:space="preserve">
          <source>The value of SQLITE_THREADSAFE can be determined at run-time using the &lt;a href=&quot;c3ref/threadsafe&quot;&gt;sqlite3_threadsafe()&lt;/a&gt; interface.</source>
          <target state="translated">Значение SQLITE_THREADSAFE можно определить во время выполнения с помощью интерфейса &lt;a href=&quot;c3ref/threadsafe&quot;&gt;sqlite3_threadsafe ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d5ab5daf4c7771df3bc76b4527132dffd8bea934" translate="yes" xml:space="preserve">
          <source>The value of an &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; column must always be a non-NULL integer. The PRIMARY KEY columns of a &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; table are also required to be non-NULL.</source>
          <target state="translated">Значение столбца &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; всегда должно быть целым числом, отличным от NULL. Столбцы PRIMARY KEY таблицы &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; также должны быть не NULL.</target>
        </trans-unit>
        <trans-unit id="94d5eebfcf21e24cf605bf00db4a0642798783cd" translate="yes" xml:space="preserve">
          <source>The value of the N parameter to these interfaces should be non-negative. Future enhancements may make use of negative N values to define new kinds of function caching behavior.</source>
          <target state="translated">Значение параметра N для этих интерфейсов должно быть неотрицательным.Будущие усовершенствования могут использовать отрицательные значения N для определения новых типов поведения кэширования функций.</target>
        </trans-unit>
        <trans-unit id="cc7bdc3b5bd50bd43536e1eeee3d4c188a48e335" translate="yes" xml:space="preserve">
          <source>The value of the change counter is copied to the database handle change counter (returned by subsequent calls to sqlite3_changes()). Then the VMs internal change counter resets to 0. This is used by trigger programs.</source>
          <target state="translated">Значение счетчика изменений копируется в счетчик изменений хэндла (возвращается последующими вызовами sqlite3_changes()).Затем внутренний счетчик изменений ВМ сбрасывается на 0,что используется триггерными программами.</target>
        </trans-unit>
        <trans-unit id="4a5b194cd44f85aade16e1c37ccac8a115177304" translate="yes" xml:space="preserve">
          <source>The value returned by sqlite3_backup_finish is &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; if no sqlite3_backup_step() errors occurred, regardless or whether or not sqlite3_backup_step() completed. If an out-of-memory condition or IO error occurred during any prior sqlite3_backup_step() call on the same &lt;a href=&quot;#sqlite3_backup&quot;&gt;sqlite3_backup&lt;/a&gt; object, then sqlite3_backup_finish() returns the corresponding &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt;.</source>
          <target state="translated">Значение, возвращаемое sqlite3_backup_finish, равно &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK,&lt;/a&gt; если ошибок sqlite3_backup_step () не возникло, независимо от того, завершилась ли sqlite3_backup_step () или нет. Если во время любого предыдущего вызова sqlite3_backup_step () того же объекта sqlite3_backup возникла проблема &lt;a href=&quot;#sqlite3_backup&quot;&gt;нехватки&lt;/a&gt; памяти или ошибка ввода-вывода , то sqlite3_backup_finish () вернет соответствующий &lt;a href=&quot;rescode&quot;&gt;код ошибки&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a8b2a631496d509ee2b275504f995fbe8e4ff87c" translate="yes" xml:space="preserve">
          <source>The value returned by sqlite3_backup_finish is &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; if no sqlite3_backup_step() errors occurred, regardless or whether or not sqlite3_backup_step() completed. If an out-of-memory condition or IO error occurred during any prior sqlite3_backup_step() call on the same &lt;a href=&quot;backup&quot;&gt;sqlite3_backup&lt;/a&gt; object, then sqlite3_backup_finish() returns the corresponding &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt;.</source>
          <target state="translated">Значение, возвращаемое sqlite3_backup_finish, равно &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK,&lt;/a&gt; если ошибок sqlite3_backup_step () не возникло, независимо от того, завершилась ли sqlite3_backup_step () или нет. Если во время любого предыдущего вызова sqlite3_backup_step () того же объекта sqlite3_backup возникла проблема &lt;a href=&quot;backup&quot;&gt;нехватки&lt;/a&gt; памяти или ошибка ввода-вывода , то sqlite3_backup_finish () вернет соответствующий &lt;a href=&quot;../rescode&quot;&gt;код ошибки&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bc51fa501b0d744e2b8200daac75839a3f391d4e" translate="yes" xml:space="preserve">
          <source>The values &lt;b&gt;M&lt;/b&gt; and &lt;b&gt;n&lt;/b&gt; are properties of the application. If an application is constructed in such a way that both &lt;b&gt;M&lt;/b&gt; and &lt;b&gt;n&lt;/b&gt; are known, or at least have known upper bounds, and if the application uses the &lt;a href=&quot;malloc#memsys5&quot;&gt;memsys5&lt;/a&gt; memory allocator and is provided with &lt;b&gt;N&lt;/b&gt; bytes of available memory space using &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigheap&quot;&gt;SQLITE_CONFIG_HEAP&lt;/a&gt; then Robson proves that no memory allocation request will ever fail within the application. To put this another way, the application developer can select a value for &lt;b&gt;N&lt;/b&gt; that will guarantee that no call to any SQLite interface will ever return &lt;a href=&quot;rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt;. The memory pool will never become so fragmented that a new memory allocation request cannot be satisfied. This is an important property for applications where a software fault could cause injury, physical harm, or loss of irreplaceable data.</source>
          <target state="translated">Значения &lt;b&gt;M&lt;/b&gt; и &lt;b&gt;n&lt;/b&gt; являются свойствами приложения. Если приложение построено таким образом, что известны как &lt;b&gt;M, так&lt;/b&gt; и &lt;b&gt;n&lt;/b&gt; , или, по крайней мере, известны верхние границы, и если приложение использует &lt;a href=&quot;malloc#memsys5&quot;&gt;распределитель&lt;/a&gt; памяти memsys5 и ему предоставляется &lt;b&gt;N&lt;/b&gt; байтов доступного пространства памяти с помощью &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigheap&quot;&gt;SQLITE_CONFIG_HEAP,&lt;/a&gt; то Робсон доказывает, что ни один запрос на выделение памяти никогда не завершится ошибкой в ​​приложении. &lt;a href=&quot;rescode#nomem&quot;&gt;Другими&lt;/a&gt; словами, разработчик приложения может выбрать значение для &lt;b&gt;N,&lt;/b&gt; которое будет гарантировать, что ни один вызов любого интерфейса SQLite никогда не вернет SQLITE_NOMEM.. Пул памяти никогда не станет настолько фрагментированным, чтобы новый запрос на выделение памяти не мог быть удовлетворен. Это важное свойство для приложений, в которых программный сбой может привести к травмам, физическому ущербу или потере незаменимых данных.</target>
        </trans-unit>
        <trans-unit id="22f534f2da25c6b7c05e8783b8e5bfbbc59c87e8" translate="yes" xml:space="preserve">
          <source>The values for each column in the record immediately follow the header. For serial types 0, 8, 9, 12, and 13, the value is zero bytes in length. If all columns are of these types then the body section of the record is empty.</source>
          <target state="translated">Значения для каждого столбца записи сразу же следуют за заголовком.Для последовательных типов 0,8,9,12 и 13 значение равно нулю байт.Если все столбцы относятся к этим типам,то участок тела записи пуст.</target>
        </trans-unit>
        <trans-unit id="d128efd1de498da70d20d12d2513201d5001c97a" translate="yes" xml:space="preserve">
          <source>The values for each column of the row are stored in these columns. The &quot;.recover&quot; command creates the lost_and_found table with as many columns as required by the longest orphaned row.</source>
          <target state="translated">В этих столбцах хранятся значения для каждого столбца строки.Команда &quot;.восстановить&quot; создает таблицу lost_and_found с таким количеством столбцов,которое требуется для самой длинной осиротевшей строки.</target>
        </trans-unit>
        <trans-unit id="fd6b2ec514a48d20f0372d7449abd69ec8081347" translate="yes" xml:space="preserve">
          <source>The values placed in the sqlite_stat1 table by an approximate ANALYZE are not exactly the same as what would be computed by an unrestricted analysis. But they are usually close enough. The index statistics in the sqlite_stat1 table are approximations in any case, so the fact that the results of an approximate ANALYZE are slightly different from a traditional full scan ANALYZE has little practical impact. It is possible to construct a pathological case where an approximate ANALYZE is noticeably inferior to a full-scan ANALYZE, but such cases rare in real-world problems.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61332fb4ed04580474ae395b4c8e0cfc53138b43" translate="yes" xml:space="preserve">
          <source>The values returned by &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_bytes()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_bytes16()&lt;/a&gt; do not include the zero terminators at the end of the string. For clarity: the values returned by &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_bytes()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_bytes16()&lt;/a&gt; are the number of bytes in the string, not the number of characters.</source>
          <target state="translated">Значения, возвращаемые &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_bytes ()&lt;/a&gt; и &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_bytes16 ()&lt;/a&gt; , не включают нулевые терминаторы в конце строки. Для ясности: значения, возвращаемые &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_bytes ()&lt;/a&gt; и &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_bytes16 (),&lt;/a&gt; представляют собой количество байтов в строке, а не количество символов.</target>
        </trans-unit>
        <trans-unit id="56d75a71d4310cb50689d453693c130f5e211175" translate="yes" xml:space="preserve">
          <source>The values returned by &lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_bytes()&lt;/a&gt; and &lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_bytes16()&lt;/a&gt; do not include the zero terminators at the end of the string. For clarity: the values returned by &lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_bytes()&lt;/a&gt; and &lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_bytes16()&lt;/a&gt; are the number of bytes in the string, not the number of characters.</source>
          <target state="translated">Значения, возвращаемые &lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_bytes ()&lt;/a&gt; и &lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_bytes16 ()&lt;/a&gt; , не включают нулевые терминаторы в конце строки. Для ясности: значения, возвращаемые &lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_bytes ()&lt;/a&gt; и &lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_bytes16 (),&lt;/a&gt; представляют собой количество байтов в строке, а не количество символов.</target>
        </trans-unit>
        <trans-unit id="9a34a413d802292386ca8ed35bad50613a2e40f9" translate="yes" xml:space="preserve">
          <source>The values returned by sqlite3_errcode() and/or sqlite3_extended_errcode() might change with each API call. Except, there are some interfaces that are guaranteed to never change the value of the error code. The error-code preserving interfaces are:</source>
          <target state="translated">Значения,возвращаемые функциями sqlite3_errcode()и/или sqlite3_extended_errcode(),могут меняться при каждом вызове API.Кроме того,существуют некоторые интерфейсы,которые гарантированно никогда не изменят значение кода ошибки.Интерфейсы,сохраняющие код ошибки:</target>
        </trans-unit>
        <trans-unit id="af0883b91a2c32edd6bb6e8adf9674294de318ba" translate="yes" xml:space="preserve">
          <source>The variable &lt;b&gt;$x&lt;/b&gt; is set by the above code to</source>
          <target state="translated">Переменная &lt;b&gt;$ x&lt;/b&gt; устанавливается приведенным выше кодом как</target>
        </trans-unit>
        <trans-unit id="e81b821adc588b80803661eb9435ef7daf5e77e6" translate="yes" xml:space="preserve">
          <source>The variable i in the previous expression varies between 0 and 9. Conceptually, the index space is divided into 10 uniform buckets and the samples are the middle row from each bucket.</source>
          <target state="translated">Переменная i в предыдущем выражении варьируется от 0 до 9.Концептуально,индексное пространство разделено на 10 однородных ведер,а образцы-это средняя строка от каждого ведра.</target>
        </trans-unit>
        <trans-unit id="e46969b4d5144ef5a3ecc1c7c5e86080c0dd5e34" translate="yes" xml:space="preserve">
          <source>The various &lt;b&gt;sqlite_stat&lt;/b&gt;</source>
          <target state="translated">Различные &lt;b&gt;sqlite_stat&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="4ea0a2ad541e7dfd246d5e09a98161b66d983211" translate="yes" xml:space="preserve">
          <source>The various SQLite Archive Archive commands are implemented using SQL statements. Application developers can easily add SQLite Archive Archive reading and writing support to their own projects by running the appropriate SQL.</source>
          <target state="translated">Различные команды SQLite Archive Archive реализуются с помощью операторов SQL.Разработчики приложения могут легко добавить поддержку чтения и записи SQLite Archive Archive в свои собственные проекты,запустив соответствующий SQL.</target>
        </trans-unit>
        <trans-unit id="22f8ca9c7ec1168dbb45b57fd3ebfbf3e9d60926" translate="yes" xml:space="preserve">
          <source>The various assert()-like macros behave differently according to how SQLite is built.</source>
          <target state="translated">Различные макросы assert()-like ведут себя по-разному в зависимости от того,как построен SQLite.</target>
        </trans-unit>
        <trans-unit id="8789a3da4f75d5b0392ef189d216e2c9312d1546" translate="yes" xml:space="preserve">
          <source>The various unix VFSes differ only in the way they handle file locking - they share most of their implementation in common with one another and are all located in the same SQLite source file: &lt;a href=&quot;http://www.sqlite.org/src/doc/trunk/src/os_unix.c&quot;&gt;os_unix.c&lt;/a&gt;. Note that except for &quot;unix&quot; and &quot;unix-excl&quot;, the various unix VFSes all use incompatible locking implementations. If two processes are accessing the same SQLite database using different unix VFSes, they may not see each others locks and may end up interfering with one another, resulting in database corruption. The &quot;unix-none&quot; VFS in particular does no locking at all and will easily result in database corruption if used by two or more database connections at the same time. Programmers are encouraged to use only &quot;unix&quot; or &quot;unix-excl&quot; unless there is a compelling reason to do otherwise.</source>
          <target state="translated">Различные виртуальные файловые системы UNIX различаются только способом обработки блокировок файлов - они имеют большую часть своей общей реализации, и все они расположены в одном исходном файле SQLite: &lt;a href=&quot;http://www.sqlite.org/src/doc/trunk/src/os_unix.c&quot;&gt;os_unix.c&lt;/a&gt; . Обратите внимание, что, за исключением unix и unix-excl, все VFS для unix используют несовместимые реализации блокировки. Если два процесса обращаются к одной и той же базе данных SQLite с использованием разных VFS Unix, они могут не видеть блокировки друг друга и могут в конечном итоге мешать друг другу, что приведет к повреждению базы данных. В частности, VFS &quot;unix-none&quot; вообще не блокирует и может легко привести к повреждению базы данных, если используется двумя или более соединениями с базой данных одновременно. Программистам рекомендуется использовать только &amp;laquo;unix&amp;raquo; или &amp;laquo;unix-excl&amp;raquo;.если нет веских причин поступить иначе.</target>
        </trans-unit>
        <trans-unit id="c5ffe5eea46cbcd5a1594ce73f72bf62a68d39e3" translate="yes" xml:space="preserve">
          <source>The versions of SQLite that come preinstalled on Apple Mac OS X computers contain a version of SQLite that has been extended to use alternative locking strategies that work on all network filesystems that Apple supports. These extensions used by Apple work great as long as all processes are accessing the database file in the same way. Unfortunately, the locking mechanisms do not exclude one another, so if one process is accessing a file using (for example) AFP locking and another process (perhaps on a different machine) is using dot-file locks, the two processes might collide because AFP locks do not exclude dot-file locks or vice versa.</source>
          <target state="translated">Версии SQLite,которые поставляются предустановленными на компьютерах Apple Mac OS X,содержат версию SQLite,которая была расширена для использования альтернативных стратегий блокировки,работающих на всех сетевых файловых системах,поддерживаемых Apple.Эти расширения,используемые Apple,отлично работают до тех пор,пока все процессы одинаково обращаются к файлу базы данных.К сожалению,механизмы блокировки не исключают друг друга,поэтому если один процесс получает доступ к файлу,используя (например)блокировку AFP,а другой процесс (возможно,на другой машине)использует блокировку dot-файлов,эти два процесса могут столкнуться,поскольку блокировки AFP не исключают блокировку dot-файлов,или наоборот.</target>
        </trans-unit>
        <trans-unit id="27a68965a58736f6647ab050fea465e20bf8ddef" translate="yes" xml:space="preserve">
          <source>The versions of the SQLite amalgamation that are supplied on the &lt;a href=&quot;https://sqlite.org/download.html&quot;&gt;download page&lt;/a&gt; are normally adequate for most users. However, some projects may want or need to build their own amalgamations. A common reason for building a custom amalgamation is in order to use certain &lt;a href=&quot;compile&quot;&gt;compile-time options&lt;/a&gt; to customize the SQLite library. Recall that the SQLite amalgamation contains a lot of C-code that is generated by auxiliary programs and scripts. Many of the compile-time options effect this generated code and must be supplied to the code generators before the amalgamation is assembled. The set of compile-time options that must be passed into the code generators can vary from one release of SQLite to the next, but at the time of this writing (circa SQLite 3.6.20, 2009-11-04) the set of options that must be known by the code generators includes:</source>
          <target state="translated">Версии объединения SQLite, представленные на &lt;a href=&quot;https://sqlite.org/download.html&quot;&gt;странице загрузки&lt;/a&gt; , обычно подходят для большинства пользователей. Однако некоторым проектам может потребоваться или необходимо создать собственные объединения. Распространенная причина создания настраиваемого объединения - использование определенных &lt;a href=&quot;compile&quot;&gt;параметров времени компиляции&lt;/a&gt;для настройки библиотеки SQLite. Напомним, что объединение SQLite содержит много C-кода, который генерируется вспомогательными программами и скриптами. Многие из параметров времени компиляции влияют на этот сгенерированный код и должны быть переданы генераторам кода перед сборкой объединения. Набор параметров времени компиляции, которые необходимо передать генераторам кода, может варьироваться от одного выпуска SQLite к другому, но на момент написания этой статьи (около SQLite 3.6.20, 2009-11-04) набор параметров которые должны быть известны генераторам кода, включают:</target>
        </trans-unit>
        <trans-unit id="d08eefb01c3e7948c8ed07ad520422cff4b9225d" translate="yes" xml:space="preserve">
          <source>The very name &quot;Structured Query Language&quot; tells us that SQL should support nested queries. And, in fact, two different kinds of nesting are supported. Any SELECT statement that returns a single-row, single-column result can be used as a term in an expression of another SELECT statement. And, a SELECT statement that returns a single-column, multi-row result can be used as the right-hand operand of the IN and NOT IN operators. We will begin this section with an example of the first kind of nesting, where a single-row, single-column SELECT is used as a term in an expression of another SELECT. Here is our example:</source>
          <target state="translated">Само название &quot;Язык структурированных запросов&quot; говорит о том,что SQL должен поддерживать вложенные запросы.И,фактически,поддерживаются два различных вида вложенности.Любой оператор SELECT,возвращающий результат,состоящий из одной строки и одной колонки,может быть использован в качестве термина в выражении другого оператора SELECT.А оператор SELECT,возвращающий многострочный результат в один столбец,может использоваться в качестве правого оператора операторов IN и NOT IN.Мы начнем этот раздел с примера первого вида вложенности,когда однорядный,многострочный результат SELECT используется в качестве термина в выражении другого оператора SELECT.Вот наш пример:</target>
        </trans-unit>
        <trans-unit id="20c4a011c8e3b37249d4469eb52a0ff7a1d9c48e" translate="yes" xml:space="preserve">
          <source>The vfs query parameter causes the database connection to be opened using the &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; called</source>
          <target state="translated">Параметр запроса vfs вызывает открытие соединения с базой данных с помощью &lt;a href=&quot;vfs&quot;&gt;VFS,&lt;/a&gt; называемой</target>
        </trans-unit>
        <trans-unit id="7fc9c565eeb1c6123557989180ff5a163d06934e" translate="yes" xml:space="preserve">
          <source>The view to drop is identified by the view-name and optional schema-name specified as part of the DROP VIEW statement. This reference is resolved using the standard procedure for &lt;a href=&quot;lang_naming&quot;&gt;object resolution&lt;/a&gt;.</source>
          <target state="translated">Отбрасываемое представление идентифицируется именем представления и необязательным именем схемы, указанным как часть оператора DROP VIEW. Эта ссылка разрешается с использованием стандартной процедуры &lt;a href=&quot;lang_naming&quot;&gt;разрешения объекта&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3b2c6960eedc019bcf13fce258370b16a245ba89" translate="yes" xml:space="preserve">
          <source>The view v1 cannot be &lt;a href=&quot;optoverview#flattening&quot;&gt;flattened&lt;/a&gt; because it is DISTINCT. It must instead be run as a subquery with the results being stored in a transient table, then the join is performed between t2 and the transient table. The push-down optimization pushes down the &quot;b BETWEEN 10 AND 20&quot; term into the view. This makes the transient table smaller, and helps the subquery to run faster if there is an index on t1.b. The resulting evaluation is like this:</source>
          <target state="translated">Представление v1 не может быть &lt;a href=&quot;optoverview#flattening&quot;&gt;сведено,&lt;/a&gt; потому что оно ОТЛИЧИТЕЛЬНО. Вместо этого он должен выполняться как подзапрос с сохранением результатов в таблице переходных процессов, после чего выполняется соединение между t2 и таблицей переходных процессов. Оптимизация &quot;вниз&quot; выталкивает элемент &quot;b МЕЖДУ 10 И 20&quot; в представление. Это делает таблицу переходных процессов меньше и помогает подзапросу работать быстрее, если на t1.b есть индекс. Итоговая оценка выглядит так:</target>
        </trans-unit>
        <trans-unit id="ce6b93653a867ff824a137b275a2d8a4b5929427" translate="yes" xml:space="preserve">
          <source>The virtual machine itself is entirely contained in a single source file &lt;a href=&quot;https://sqlite.org/src/file/src/vdbe.c&quot;&gt;vdbe.c&lt;/a&gt;. The &lt;a href=&quot;https://sqlite.org/src/file/src/vdbe.h&quot;&gt;vdbe.h&lt;/a&gt; header file defines an interface between the virtual machine and the rest of the SQLite library and &lt;a href=&quot;https://sqlite.org/src/file/src/vdbeInt.h&quot;&gt;vdbeInt.h&lt;/a&gt; which defines structures and interfaces that are private the virtual machine itself. Various other &lt;b&gt;vdbe*.c&lt;/b&gt; files are helpers to the virtual machine. The &lt;a href=&quot;https://sqlite.org/src/file/src/vdbeaux.c&quot;&gt;vdbeaux.c&lt;/a&gt; file contains utilities used by the virtual machine and interface modules used by the rest of the library to construct VM programs. The &lt;a href=&quot;https://sqlite.org/src/file/src/vdbeapi.c&quot;&gt;vdbeapi.c&lt;/a&gt; file contains external interfaces to the virtual machine such as the &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_int()&lt;/a&gt; and &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt;. Individual values (strings, integer, floating point numbers, and BLOBs) are stored in an internal object named &quot;Mem&quot; which is implemented by &lt;a href=&quot;https://sqlite.org/src/file/src/vdbemem.c&quot;&gt;vdbemem.c&lt;/a&gt;.</source>
          <target state="translated">Сама виртуальная машина целиком содержится в одном исходном файле &lt;a href=&quot;https://sqlite.org/src/file/src/vdbe.c&quot;&gt;vdbe.c&lt;/a&gt; . &lt;a href=&quot;https://sqlite.org/src/file/src/vdbe.h&quot;&gt;Vdbe.h&lt;/a&gt; заголовочного файл определяет интерфейс между виртуальной машиной и остальной частью библиотеки SQLite и &lt;a href=&quot;https://sqlite.org/src/file/src/vdbeInt.h&quot;&gt;vdbeInt.h&lt;/a&gt; , который определяет структуру и интерфейсы , которые являются закрытыми самим виртуальной машиной. Различные другие &lt;b&gt;файлы vdbe * .c&lt;/b&gt; являются помощниками для виртуальной машины. &lt;a href=&quot;https://sqlite.org/src/file/src/vdbeaux.c&quot;&gt;Vdbeaux.c&lt;/a&gt; файл содержит утилиты , используемые в виртуальных машин и интерфейсных модулей , используемых в остальной части библиотеки для построения программ VM. &lt;a href=&quot;https://sqlite.org/src/file/src/vdbeapi.c&quot;&gt;Vdbeapi.c&lt;/a&gt; файл содержит внешние интерфейсы для виртуальной машины , такие как &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_int ()&lt;/a&gt; и &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step ()&lt;/a&gt;. Отдельные значения (строки, целые числа, числа с плавающей запятой и &lt;a href=&quot;https://sqlite.org/src/file/src/vdbemem.c&quot;&gt;большие двоичные объекты&lt;/a&gt; ) хранятся во внутреннем объекте с именем &amp;laquo;Mem&amp;raquo;, который реализуется vdbemem.c .</target>
        </trans-unit>
        <trans-unit id="00bcd77d6dec3bc1a5f96c0e0f3985aefbea69f9" translate="yes" xml:space="preserve">
          <source>The virtual table contains an xShadowName method.</source>
          <target state="translated">Виртуальная таблица содержит метод xShadowName.</target>
        </trans-unit>
        <trans-unit id="aba94b8d1e25fe7120c464dc013b1d34868edb66" translate="yes" xml:space="preserve">
          <source>The virtual table mechanism allows an application to publish interfaces that are accessible from SQL statements as if they were tables. SQL statements can do almost anything to a virtual table that they can do to a real table, with the following exceptions:</source>
          <target state="translated">Механизм виртуальных таблиц позволяет приложению публиковать интерфейсы,доступные из SQL-операторов,как если бы они были таблицами.SQL-операторы могут сделать с виртуальной таблицей практически все,что они могут сделать с реальной таблицей,со следующими исключениями:</target>
        </trans-unit>
        <trans-unit id="7616eb3efb8cfc2b544466ae9f36f2a81289f276" translate="yes" xml:space="preserve">
          <source>The virtual table will return one row of output for each token in the input string. The &quot;token&quot; column is the text of the token. The &quot;start&quot; and &quot;end&quot; columns are the byte offset to the beginning and end of the token in the original input string. The &quot;position&quot; column is the sequence number of the token in the original input string. There is also an &quot;input&quot; column which is simply a copy of the input string that is specified in the WHERE clause. Note that a constraint of the form &quot;input=?&quot; must appear in the WHERE clause or else the virtual table will have no input to tokenize and will return no rows. The example above generates the following output:</source>
          <target state="translated">Виртуальная таблица вернет по одной строке вывода для каждой лексемы во входной строке.Столбец &quot;токен&quot;-это текст токена.Столбцы &quot;начало&quot; и &quot;конец&quot;-это смещение байта к началу и концу токена в исходной строке ввода.Столбец &quot;позиция&quot;-это порядковый номер токена в исходной строке ввода.Существует также столбец &quot;input&quot;,который является просто копией входной строки,указанной в пункте WHERE.Обратите внимание,что ограничение формы &quot;input=?&quot; должно появиться в выражении WHERE,иначе виртуальная таблица не будет иметь входных данных для токенов и не вернет строк.В примере,приведенном выше,будет выдан следующий вывод:</target>
        </trans-unit>
        <trans-unit id="e7d6d48d0123dd78c2ece991b5f7661cea292174" translate="yes" xml:space="preserve">
          <source>The wal-index file or &quot;shm&quot; file is not actually used as a file. Rather, individual database clients mmap the shm file and use it as shared memory for coordinating access to the database and as a cache for quickly locating frame within the wal file. The name of the shm file is the main database file name with the four characters &quot;-shm&quot; appended. Or, for 8+3 filesystems, the shm file is the main database file with the suffix changed to &quot;.SHM&quot;.</source>
          <target state="translated">Файл wal-index или файл &quot;shm&quot; на самом деле не используется в качестве файла.Скорее,отдельные клиенты базы данных mmap-файл shm и используют его в качестве общей памяти для координации доступа к базе данных и в качестве кэша для быстрого определения местоположения фрейма в файле wal.Имя файла shm является основным именем файла базы данных с четырьмя символами &quot;-шм&quot;.Или,для 8+3 файловых систем,файл shm является основным файлом БД с суффиксом,измененным на &quot;.SHM&quot;.</target>
        </trans-unit>
        <trans-unit id="2705cff44fec902d1ca3ce2af3b554cabc339fb3" translate="yes" xml:space="preserve">
          <source>The wal-index file, usually named &quot;X-shm&quot;.</source>
          <target state="translated">Файл wal-index,обычно называемый &quot;X-shm&quot;.</target>
        </trans-unit>
        <trans-unit id="3164ee82328b180dbc8289eddc9db733f9109901" translate="yes" xml:space="preserve">
          <source>The wal-index is transient. After a crash, the wal-index is reconstructed from the original WAL file. The VFS is required to either truncate or zero the header of the wal-index when the last connection to it closes. Because the wal-index is transient, it can use an architecture-specific format; it does not have to be cross-platform. Hence, unlike the database and WAL file formats which store all values as big endian, the wal-index stores multi-byte values in the native byte order of the host computer.</source>
          <target state="translated">Уолл-индекс преходящий.После сбоя,wal-index восстанавливается из оригинального файла WAL.VFS требуется либо усечь,либо обнулить заголовок wal-index при закрытии последнего соединения с ним.Поскольку wal-index является переходным,он может использовать формат,специфичный для архитектуры;он не обязательно должен быть кроссплатформенным.Следовательно,в отличие от форматов баз данных и файлов WAL,в которых все значения хранятся как большие эндианы,wal-index хранит многобайтовые значения в родном порядке байт на хост-компьютере.</target>
        </trans-unit>
        <trans-unit id="f37728360280f92c82e5f63eda2235cd3fe649d8" translate="yes" xml:space="preserve">
          <source>The wal_checkpoint pragma returns a single row with three integer columns. The first column is usually 0 but will be 1 if a RESTART or FULL or TRUNCATE checkpoint was blocked from completing, for example because another thread or process was actively using the database. In other words, the first column is 0 if the equivalent call to &lt;a href=&quot;c3ref/wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2()&lt;/a&gt; would have returned &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; or 1 if the equivalent call would have returned &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;. The second column is the number of modified pages that have been written to the write-ahead log file. The third column is the number of pages in the write-ahead log file that have been successfully moved back into the database file at the conclusion of the checkpoint. The second and third column are -1 if there is no write-ahead log, for example if this pragma is invoked on a database connection that is not in &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt;.</source>
          <target state="translated">Прагма wal_checkpoint возвращает одну строку с тремя целочисленными столбцами. Первый столбец обычно равен 0, но будет равен 1, если выполнение контрольной точки RESTART, FULL или TRUNCATE было заблокировано, например, из-за того, что другой поток или процесс активно использовали базу данных. Другими словами, первый столбец равен 0, если эквивалентный вызов &lt;a href=&quot;c3ref/wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2 ()&lt;/a&gt; вернул бы &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; или 1, если бы эквивалентный вызов вернул бы &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;. Во втором столбце указано количество измененных страниц, которые были записаны в файл журнала упреждающей записи. Третий столбец - это количество страниц в файле журнала упреждающей записи, которые были успешно перемещены обратно в файл базы данных по завершении контрольной точки. Второй и третий столбцы имеют значение -1, если журнал упреждающей записи отсутствует, например, если эта прагма вызывается для соединения с базой данных, которое не находится в &lt;a href=&quot;wal&quot;&gt;режиме WAL&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7abca67d3b2f6649a3ed46e41721882b254d1af5" translate="yes" xml:space="preserve">
          <source>The way SQLite deals with this is to first run the inner SELECT (the one against examp2) and store its result in a private memory cell. SQLite then substitutes the value of this private memory cell for the inner SELECT when it evaluates the outer SELECT. The code looks like this:</source>
          <target state="translated">Способ,которым SQLite справляется с этим,заключается в том,чтобы сначала запустить внутренний SELECT (тот,который против examp2)и сохранить его результат в частной ячейке памяти.Затем SQLite подставляет значение этой частной ячейки памяти во внутреннюю SELECT при оценке внешнего SELECT.Код выглядит следующим образом:</target>
        </trans-unit>
        <trans-unit id="d9f0711eae8ce05c73449f6cd3513a09a5b0c229" translate="yes" xml:space="preserve">
          <source>The way in which the IN and NOT IN operators handle NULL values in their right-hand expressions has been brought into compliance with the SQL standard and with other SQL database engines.</source>
          <target state="translated">То,как операторы IN и NOT IN обрабатывают NULL-значения в своих правосторонних выражениях,было приведено в соответствие со стандартом SQL и другими движками баз данных SQL.</target>
        </trans-unit>
        <trans-unit id="1bcbf2e1391b1aa7e3ebafdb83d7f3bc20c48ce0" translate="yes" xml:space="preserve">
          <source>The whole point of the xShadowName method is to protect the content of shadow tables from being corrupted by hostile SQL. Every virtual table implementation that uses shadow tables should be able to detect and cope with corrupted shadow table content. However, bugs in particular virtual table implementation might allow a deliberately corrupted shadow table to cause a crash or other malfunction. The xShadowName mechanism seeks to avoid zero-day exploits by preventing ordinary SQL statements from deliberately corrupting shadow tables.</source>
          <target state="translated">Весь смысл метода xShadowName заключается в защите содержимого теневых таблиц от повреждения враждебным SQL.Каждая реализация виртуальной таблицы,использующая теневые таблицы,должна быть способна обнаруживать поврежденное содержимое теневых таблиц и справляться с ним.Однако ошибки,в частности,в реализации виртуальных таблиц,могут позволить намеренно поврежденной теневой таблице вызвать сбой или другие неполадки.Механизм xShadowName стремится избежать эксплойтов нулевого дня,предотвращая намеренное повреждение теневых таблиц обычными SQL операторами.</target>
        </trans-unit>
        <trans-unit id="7ba3625dd3002c676817bb5d0641f1c309f9b35c" translate="yes" xml:space="preserve">
          <source>The width field specifies the minimum width of the substituted value in the output. If the string or number that is written into the output is shorter than the width, then the value is padded. Padding is on the left (the value is right-justified) by default. If the &quot;-&quot; flag is used, then the padding is on the right and the value is left-justified.</source>
          <target state="translated">Поле width (Ширина)задает минимальную ширину замещаемого значения на выходе.Если строка или число,записанное в вывод,меньше ширины,то значение подставляется.По умолчанию подставка находится слева (значение обосновано справа).Если используется флаг &quot;-&quot;,то подкладка находится справа,а значение-слева (значение обосновано справа).</target>
        </trans-unit>
        <trans-unit id="a12aad5ee5dbe2d3fff555e1c8b3c9090a69eb38" translate="yes" xml:space="preserve">
          <source>The width is measured in bytes by default. However, if the &quot;!&quot; flag is present then the width is in characters. This only makes a difference for multi-byte utf-8 characters, and those only occur on string substitutions.</source>
          <target state="translated">По умолчанию ширина измеряется в байтах.Однако,если присутствует флаг &quot;!&quot;,то ширина измеряется в символах.Это имеет значение только для многобайтовых символов utf-8,а такие символы встречаются только при замене строк.</target>
        </trans-unit>
        <trans-unit id="bb37fe25186c24e9c2d6b18924cc12e6bf999427" translate="yes" xml:space="preserve">
          <source>The word transliterated into lower-case ASCII. There is a standard table of mappings from non-ASCII characters into ASCII. Examples: &quot;&amp;aelig;&quot; -&amp;gt; &quot;ae&quot;, &quot;&amp;thorn;&quot; -&amp;gt; &quot;th&quot;, &quot;&amp;szlig;&quot; -&amp;gt; &quot;ss&quot;, &quot;&amp;aacute;&quot; -&amp;gt; &quot;a&quot;, ... The accessory function spellfix1_translit(X) will do the non-ASCII to ASCII mapping. The built-in lower(X) function will convert to lower-case. Thus: k1 = lower(spellfix1_translit(word)). If the word is already all lower-case ASCII, then the k1 column will contain a NULL. This reduces the storage requirements for the %_vocab table and helps spellfix to run a little faster. Therefore, it is advantageous to populate as much of the spellfix table as possible using lower-case ASCII vocabulary.</source>
          <target state="translated">Слово транслитерируется в нижний регистр ASCII. Существует стандартная таблица сопоставлений символов, отличных от ASCII, в ASCII. Примеры: &amp;laquo;&amp;aelig;&amp;raquo; -&amp;gt; &amp;laquo;ae&amp;raquo;, &amp;laquo;&amp;thorn;&amp;raquo; -&amp;gt; &amp;laquo;th&amp;raquo;, &amp;laquo;&amp;szlig;&amp;raquo; -&amp;gt; &amp;laquo;ss&amp;raquo;, &amp;laquo;&amp;aacute;&amp;raquo; -&amp;gt; &amp;laquo;a&amp;raquo;, ... Дополнительная функция spellfix1_translit (X) выполнит отображение не-ASCII в ASCII. Встроенная функция lower (X) будет преобразовывать в нижний регистр. Таким образом: k1 = нижний (spellfix1_translit (слово)). Если слово уже состоит из ASCII нижнего регистра, тогда столбец k1 будет содержать NULL. Это снижает требования к хранилищу для таблицы% _vocab и помогает программе spellfix работать немного быстрее. Следовательно, выгодно заполнить как можно большую часть таблицы исправлений орфографии, используя словарь ASCII нижнего регистра.</target>
        </trans-unit>
        <trans-unit id="2aea0dad5536afb073da7952899f42822308cf24" translate="yes" xml:space="preserve">
          <source>The working directory</source>
          <target state="translated">Рабочая директория</target>
        </trans-unit>
        <trans-unit id="1191da9cfb737ab513b0974862b6931c34d468a3" translate="yes" xml:space="preserve">
          <source>The write-ahead log file, usually named &quot;X-wal&quot;.</source>
          <target state="translated">Файл журнала с записями наперед,обычно называемый &quot;X-wal&quot;.</target>
        </trans-unit>
        <trans-unit id="aa76cd0207c05b41731ac87f189a853ae60f3634" translate="yes" xml:space="preserve">
          <source>The write-ahead log or &quot;wal&quot; file is a roll-forward journal that records transactions that have been committed but not yet applied to the main database. Details on the format of the wal file are describe in the &lt;a href=&quot;fileformat2#walformat&quot;&gt;WAL format&lt;/a&gt; subsection of the main &lt;a href=&quot;fileformat2&quot;&gt;file format&lt;/a&gt; document. The wal file is named by appending the four characters &quot;-wal&quot; to the end of the name of the main database file. Except on 8+3 filesystems, such names are not allowed, and in that case the file suffix is changed to &quot;.WAL&quot;. But as 8+3 filesystems are increasingly rare, that exceptional case can usually be ignored.</source>
          <target state="translated">Журнал упреждающей записи или файл wal - это журнал с повтором транзакций, в котором записываются транзакции, которые были зафиксированы, но еще не применены к основной базе данных. Подробности о формате файла wal описаны в подразделе &lt;a href=&quot;fileformat2#walformat&quot;&gt;формата WAL&lt;/a&gt; основного документа &lt;a href=&quot;fileformat2&quot;&gt;формата файла&lt;/a&gt; . Файл wal именуется добавлением четырех символов &amp;laquo;-wal&amp;raquo; в конец имени основного файла базы данных. За исключением файловых систем 8 + 3, такие имена не допускаются, и в этом случае суффикс файла изменяется на &amp;laquo;.WAL&amp;raquo;. Но поскольку файловые системы 8 + 3 встречаются все реже, этот исключительный случай обычно можно игнорировать.</target>
        </trans-unit>
        <trans-unit id="9fcf91986e20f3838e989f19567544d31cd8c593" translate="yes" xml:space="preserve">
          <source>The writefile(X,Y) SQL function write the blob Y into the file named X and returns the number of bytes written. Use this function to extract the content of a single table column into a file. For example:</source>
          <target state="translated">SQL функция writeefile(X,Y)записывает блок Y в файл с именем X и возвращает количество записанных байт.Используйте эту функцию для извлечения содержимого одного столбца таблицы в файл.Например:</target>
        </trans-unit>
        <trans-unit id="35efa113638256d189c7bffd527a8b95982adee0" translate="yes" xml:space="preserve">
          <source>The writing test above is not completely fair, since SQLite is doing &lt;a href=&quot;transactional&quot;&gt;power-safe transactions&lt;/a&gt; whereas the direct-to-disk writing is not. To put the tests on a more equal footing, add either the --nosync option to the SQLite writes to disable calling fsync() or FlushFileBuffers() to force content to disk, or using the --fsync option for the direct-to-disk tests to force them to invoke fsync() or FlushFileBuffers() when updating disk files.</source>
          <target state="translated">Приведенный выше тест записи не совсем честен, поскольку SQLite выполняет &lt;a href=&quot;transactional&quot;&gt;безопасные транзакции,&lt;/a&gt; тогда как прямая запись на диск - нет. Чтобы поставить тесты на более равные условия, добавьте либо параметр --nosync для записи SQLite, чтобы отключить вызов fsync (), либо FlushFileBuffers () для принудительного размещения содержимого на диске, или используйте параметр --fsync для прямого доступа к тесты диска, чтобы заставить их вызывать fsync () или FlushFileBuffers () при обновлении файлов на диске.</target>
        </trans-unit>
        <trans-unit id="3500eedb790da60f6c7c2c2fe42347161ad2dc7e" translate="yes" xml:space="preserve">
          <source>The xAccess method is used to check for access permissions on a file. The filename will be UTF-8 encoded. The flags argument will be &lt;a href=&quot;c3ref/c_access_exists&quot;&gt;SQLITE_ACCESS_EXISTS&lt;/a&gt; to check for the existence of the file, &lt;a href=&quot;c3ref/c_access_exists&quot;&gt;SQLITE_ACCESS_READWRITE&lt;/a&gt; to check to see if the file is both readable and writable, or &lt;a href=&quot;c3ref/c_access_exists&quot;&gt;SQLITE_ACCESS_READ&lt;/a&gt; to check to see if the file is at least readable. The &quot;file&quot; named by the second parameter might be a directory or folder name.</source>
          <target state="translated">Метод xAccess используется для проверки прав доступа к файлу. Имя файла будет в кодировке UTF-8. Аргументом flags будет &lt;a href=&quot;c3ref/c_access_exists&quot;&gt;SQLITE_ACCESS_EXISTS&lt;/a&gt; для проверки существования файла, &lt;a href=&quot;c3ref/c_access_exists&quot;&gt;SQLITE_ACCESS_READWRITE,&lt;/a&gt; чтобы проверить , доступен ли файл как для чтения, так и для записи, или &lt;a href=&quot;c3ref/c_access_exists&quot;&gt;SQLITE_ACCESS_READ,&lt;/a&gt; чтобы проверить, является ли файл хотя бы читаемым. &amp;laquo;Файл&amp;raquo;, названный вторым параметром, может быть именем каталога или папки.</target>
        </trans-unit>
        <trans-unit id="7e3dceb3a3d82f8b52bd7f5b2f951ed3b0619691" translate="yes" xml:space="preserve">
          <source>The xAccess() method is invoked again to detect if the journal file is still in the file system. If it is, then it is a hot-journal file and SQLite tries to roll it back (see section</source>
          <target state="translated">Метод xAccess()снова вызывается для того,чтобы определить,находится ли файл журнала в файловой системе.Если это так,то это горячий файл журнала,и SQLite пытается откатить его обратно (см.раздел</target>
        </trans-unit>
        <trans-unit id="be1521ac61f6da801d0f89ccb40ef26362bd2aea" translate="yes" xml:space="preserve">
          <source>The xAccess() method of the VFS is allowed to return -1 to signal a memory allocation error.</source>
          <target state="translated">Метод xAccess()VFS позволяет вернуть -1 для сигнала об ошибке выделения памяти.</target>
        </trans-unit>
        <trans-unit id="dbb116d3015d148d9aef4ab4eaf91f8dc7699911" translate="yes" xml:space="preserve">
          <source>The xBestIndex function may have requested the values of certain expressions using the aConstraintUsage[].argvIndex values of the &lt;a href=&quot;c3ref/index_info&quot;&gt;sqlite3_index_info&lt;/a&gt; structure. Those values are passed to xFilter using the argc and argv parameters.</source>
          <target state="translated">Функция xBestIndex могла запросить значения определенных выражений, используя значения aConstraintUsage [] .argvIndex структуры &lt;a href=&quot;c3ref/index_info&quot;&gt;sqlite3_index_info&lt;/a&gt; . Эти значения передаются в xFilter с использованием параметров argc и argv.</target>
        </trans-unit>
        <trans-unit id="e673068c08d7f626c7139b66b363abe588afdbfb" translate="yes" xml:space="preserve">
          <source>The xBestIndex method fills the idxNum and idxStr fields with information that communicates an indexing strategy to the &lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter&lt;/a&gt; method. The information in idxNum and idxStr is arbitrary as far as the SQLite core is concerned. The SQLite core just copies the information through to the &lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter&lt;/a&gt; method. Any desired meaning can be assigned to idxNum and idxStr as long as xBestIndex and xFilter agree on what that meaning is.</source>
          <target state="translated">Метод xBestIndex заполняет поля idxNum и idxStr информацией, которая передает стратегию &lt;a href=&quot;vtab#xfilter&quot;&gt;индексации&lt;/a&gt; методу xFilter . Информация в idxNum и idxStr является произвольной для ядра SQLite. Ядро SQLite просто копирует информацию в метод &lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter&lt;/a&gt; . Любое желаемое значение может быть присвоено idxNum и idxStr, если xBestIndex и xFilter согласны с тем, что это за значение.</target>
        </trans-unit>
        <trans-unit id="7549b2c421b13b6947674708c7a5360fc1373a57" translate="yes" xml:space="preserve">
          <source>The xBestIndex method is required for every virtual table implementation.</source>
          <target state="translated">Метод xBestIndex требуется для каждой реализации виртуальной таблицы.</target>
        </trans-unit>
        <trans-unit id="6671b4241ef5e4b25933598f6cbd513b0faa9c69" translate="yes" xml:space="preserve">
          <source>The xBestIndex method may optionally populate the idxFlags field with a mask of SQLITE_INDEX_SCAN_* flags. Currently there is only one such flag - SQLITE_INDEX_SCAN_UNIQUE. If the xBestIndex method sets this flag, SQLite assumes that the strategy may visit at most one row.</source>
          <target state="translated">Метод xBestIndex может опционально заполнять поле idxFlags маской флагов SQLITE_INDEX_SCAN_*.На данный момент существует только один такой флаг-SQLITE_INDEX_SCAN_UNIQUE.Если метод xBestIndex устанавливает этот флаг,то SQLite предполагает,что стратегия может посещать не более одной строки.</target>
        </trans-unit>
        <trans-unit id="60dc1bff84d7b24ecf260c549a70a2e550acd608" translate="yes" xml:space="preserve">
          <source>The xBestIndex method may set aConstraintUsage[].argvIndex entries to values greater than zero. Exactly one entry should be set to 1, another to 2, another to 3, and so forth up to as many or as few as the xBestIndex method wants. The EXPR of the corresponding constraints will then be passed in as the argv[] parameters to xFilter.</source>
          <target state="translated">Метод xBestIndex может устанавливать для записей aConstraintUsage[].argvIndex значения больше нуля.Точно одна запись должна быть установлена в 1,другая в 2,третья и т.д.до тех пор,пока метод xBestIndex не захочет.Затем EXPR соответствующих ограничений будет передан в качестве параметров argv[]в xFilter.</target>
        </trans-unit>
        <trans-unit id="b0c67bb7b3ba635b9cd74ad89d5155e843f934eb" translate="yes" xml:space="preserve">
          <source>The xBestIndex method should return SQLITE_OK on success. If any kind of fatal error occurs, an appropriate error code (ex: &lt;a href=&quot;rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt;) should be returned instead.</source>
          <target state="translated">Метод xBestIndex должен вернуть SQLITE_OK в случае успеха. Если происходит какая-либо фатальная ошибка, вместо &lt;a href=&quot;rescode#nomem&quot;&gt;нее&lt;/a&gt; должен быть возвращен соответствующий код ошибки (например: SQLITE_NOMEM ).</target>
        </trans-unit>
        <trans-unit id="6e2147722085d4c968213130f4ef993a32c73b66" translate="yes" xml:space="preserve">
          <source>The xBestIndex method will be invoked once for each of the potential plans above. For plan 1, the aConstraint[].usable flag for for the SQLITE_CONSTRAINT_EQ constraint on the param1 column will be true because the right-hand side value for the &quot;param1 = ?&quot; constraint will be known, since it is determined by the outer realtab loop. But for plan 2, the aConstraint[].usable flag for &quot;param1 = ?&quot; will be false because the right-hand side value is determined by an inner loop and is thus an unknown quantity. Because param1 is a required input to the table-valued functions, the xBestIndex method should return SQLITE_CONSTRAINT when presented with plan 2, indicating that a required input is missing. This forces the query planner to select plan 1.</source>
          <target state="translated">Метод xBestIndex будет вызван один раз для каждого из потенциальных планов,описанных выше.Для плана 1 флаг aConstraint[].usable для ограничения SQLITE_CONSTRAINT_EQ в столбце param1 будет истинен,так как будет известно значение правой стороны для ограничения &quot;param1=?&quot;,так как оно определяется внешним циклом realtab.Но для плана 2 флаг aConstraint[].usable для &quot;param1=?&quot; будет ложным,так как значение правой стороны определяется внутренним циклом и,таким образом,является неизвестной величиной.Так как param1 является обязательным входом для функций с табличными значениями,метод xBestIndex должен возвращать SQLITE_CONSTRAINT при представлении плана 2,что указывает на отсутствие нужного входа.Это заставляет планировщика запроса выбрать план 1.</target>
        </trans-unit>
        <trans-unit id="c5e6a28d9d92d2bf9deb3f28a367d165a9d141f6" translate="yes" xml:space="preserve">
          <source>The xCachesize() method may be called at any time by SQLite to set the suggested maximum cache-size (number of pages stored by) the cache instance passed as the first argument. This is the value configured using the SQLite &quot;&lt;a href=&quot;../pragma#pragma_cache_size&quot; id=&quot;thexcachesizepagecachemethod&quot;&gt;PRAGMA cache_size&lt;/a&gt;&quot; command. As with the bPurgeable parameter, the implementation is not required to do anything with this value; it is advisory only.</source>
          <target state="translated">Метод xCachesize () может быть вызван SQLite в любое время, чтобы установить предлагаемый максимальный размер кэша (количество страниц, сохраняемых) экземпляром кэша, переданным в качестве первого аргумента. Это значение, настроенное с помощью команды SQLite &quot; &lt;a href=&quot;../pragma#pragma_cache_size&quot; id=&quot;thexcachesizepagecachemethod&quot;&gt;PRAGMA cache_size&lt;/a&gt; &quot;. Как и в случае с параметром bPurgeable, реализации не требуется ничего делать с этим значением; это только рекомендательный характер.</target>
        </trans-unit>
        <trans-unit id="64860c154593114b929547aef1bfe359a445dd93" translate="yes" xml:space="preserve">
          <source>The xCachesize() method may be called at any time by SQLite to set the suggested maximum cache-size (number of pages stored by) the cache instance passed as the first argument. This is the value configured using the SQLite &quot;&lt;a href=&quot;pragma#pragma_cache_size&quot; id=&quot;thexcachesizepagecachemethod&quot;&gt;PRAGMA cache_size&lt;/a&gt;&quot; command. As with the bPurgeable parameter, the implementation is not required to do anything with this value; it is advisory only.</source>
          <target state="translated">Метод xCachesize () может быть вызван SQLite в любое время, чтобы установить предлагаемый максимальный размер кэша (количество страниц, сохраняемых) экземпляром кэша, переданным в качестве первого аргумента. Это значение, настроенное с помощью команды SQLite &quot; &lt;a href=&quot;pragma#pragma_cache_size&quot; id=&quot;thexcachesizepagecachemethod&quot;&gt;PRAGMA cache_size&lt;/a&gt; &quot;. Как и в случае с параметром bPurgeable, реализации не требуется ничего делать с этим значением; это только рекомендательный характер.</target>
        </trans-unit>
        <trans-unit id="76bfcc9d387b84934d7209d1ccf2568a52cae2ff" translate="yes" xml:space="preserve">
          <source>The xCheckReservedLock() method checks to see if another connection or another process is currently holding a reserved, pending, or exclusive lock on the file. It returns true or false.</source>
          <target state="translated">Метод xCheckReservedLock()проверяет,не содержит ли другое соединение или другой процесс в настоящее время зарезервированную,ожидающую или эксклюзивную блокировку файла.Он возвращает true или false.</target>
        </trans-unit>
        <trans-unit id="5108534fb3c98c994a35c533b42cb72d472a86d4" translate="yes" xml:space="preserve">
          <source>The xClose method closes a cursor previously opened by &lt;a href=&quot;vtab#xopen&quot;&gt;xOpen&lt;/a&gt;. The SQLite core will always call xClose once for each cursor opened using xOpen.</source>
          <target state="translated">Метод xClose закрывает курсор, ранее открытый &lt;a href=&quot;vtab#xopen&quot;&gt;xOpen&lt;/a&gt; . Ядро SQLite всегда будет вызывать xClose один раз для каждого курсора, открытого с помощью xOpen.</target>
        </trans-unit>
        <trans-unit id="a1fcaec496244ffb2502893506be9bff99222ddb" translate="yes" xml:space="preserve">
          <source>The xClose method closes the file. The space for the &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; structure is deallocated by the caller. But if the &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; contains pointers to other allocated memory or resources, those allocations should be released by the xClose method.</source>
          <target state="translated">Метод xClose закрывает файл. Пространство для структуры &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; освобождается вызывающей стороной. Но если &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; содержит указатели на другую выделенную память или ресурсы, эти выделения должны быть освобождены методом xClose.</target>
        </trans-unit>
        <trans-unit id="2af5d67c2c34fed358127148fe670412a17ae024" translate="yes" xml:space="preserve">
          <source>The xClose method is required for every virtual table implementation.</source>
          <target state="translated">Метод xClose требуется для каждой реализации виртуальной таблицы.</target>
        </trans-unit>
        <trans-unit id="57537332c9edcb104197db5e7bb9793f5df28547" translate="yes" xml:space="preserve">
          <source>The xColumn method is required for every virtual table implementation.</source>
          <target state="translated">Метод xColumn необходим для каждой реализации виртуальной таблицы.</target>
        </trans-unit>
        <trans-unit id="ef93eeb561a6057de6700b4a7eda4c4170148438" translate="yes" xml:space="preserve">
          <source>The xColumnSize API always returns -1. There is no way to determine the number of tokens in a value stored within a contentless FTS5 table configured with columnsize=0.</source>
          <target state="translated">API xColumnSize всегда возвращает -1.Нет способа определить количество токенов в значении,хранящемся в бесконтактной таблице FTS5,сконфигурированной с размером столбца=0.</target>
        </trans-unit>
        <trans-unit id="9e2d00478c87bed4be4b97709f42f53211a90ec1" translate="yes" xml:space="preserve">
          <source>The xConnect method is required for every virtual table implementation, though the &lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; and xConnect pointers of the &lt;a href=&quot;c3ref/module&quot;&gt;sqlite3_module&lt;/a&gt; object may point to the same function if the virtual table does not need to initialize backing store.</source>
          <target state="translated">Метод xConnect требуется для каждой реализации виртуальной таблицы, хотя указатели &lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; и xConnect объекта &lt;a href=&quot;c3ref/module&quot;&gt;sqlite3_module&lt;/a&gt; могут указывать на ту же функцию, если виртуальной таблице не требуется инициализировать резервное хранилище.</target>
        </trans-unit>
        <trans-unit id="3a84b2667247b1e27fdcdd3d4cc56221f573c090" translate="yes" xml:space="preserve">
          <source>The xConnect method is very similar to &lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt;. It has the same parameters and constructs a new &lt;a href=&quot;c3ref/vtab&quot;&gt;sqlite3_vtab&lt;/a&gt; structure just like xCreate. And it must also call &lt;a href=&quot;c3ref/declare_vtab&quot;&gt;sqlite3_declare_vtab()&lt;/a&gt; like xCreate.</source>
          <target state="translated">Метод xConnect очень похож на &lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; . Он имеет те же параметры и создает новую структуру &lt;a href=&quot;c3ref/vtab&quot;&gt;sqlite3_vtab,&lt;/a&gt; как и xCreate. И он также должен вызывать &lt;a href=&quot;c3ref/declare_vtab&quot;&gt;sqlite3_declare_vtab (),&lt;/a&gt; как xCreate.</target>
        </trans-unit>
        <trans-unit id="9ec50befd1d20d9f6756f231c4255cc685afba32" translate="yes" xml:space="preserve">
          <source>The xConnect method must return &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; if it is successful in creating the new virtual table, or &lt;a href=&quot;rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt; if it is not successful. If not successful, the &lt;a href=&quot;c3ref/vtab&quot;&gt;sqlite3_vtab&lt;/a&gt; structure must not be allocated. An error message may optionally be returned in *pzErr if unsuccessful. Space to hold the error message string must be allocated using an SQLite memory allocation function like &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc()&lt;/a&gt; or &lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_mprintf()&lt;/a&gt; as the SQLite core will attempt to free the space using &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_free()&lt;/a&gt; after the error has been reported up to the application.</source>
          <target state="translated">Метод xConnect должен возвращать &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK,&lt;/a&gt; если он успешно создает новую виртуальную таблицу, или &lt;a href=&quot;rescode#error&quot;&gt;SQLITE_ERROR,&lt;/a&gt; если это не удается. В случае &lt;a href=&quot;c3ref/vtab&quot;&gt;неудачи&lt;/a&gt; нельзя выделять структуру sqlite3_vtab . В случае неудачи сообщение об ошибке может быть возвращено в * pzErr. Пространство для хранения строки сообщения об ошибке должно быть выделено с помощью функции выделения памяти SQLite, такой как &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc ()&lt;/a&gt; или &lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_mprintf (),&lt;/a&gt; поскольку ядро ​​SQLite попытается освободить пространство с помощью &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_free ()&lt;/a&gt; после того, как об ошибке было сообщено приложению.</target>
        </trans-unit>
        <trans-unit id="6920f3a6545664c297cabaad1f1d797cb28640a2" translate="yes" xml:space="preserve">
          <source>The xCreate and xConnect methods are only different when the virtual table has some kind of backing store that must be initialized the first time the virtual table is created. The xCreate method creates and initializes the backing store. The xConnect method just connects to an existing backing store. When xCreate and xConnect are the same, the table is an &lt;a href=&quot;vtab#epovtab&quot;&gt;eponymous virtual table&lt;/a&gt;.</source>
          <target state="translated">Методы xCreate и xConnect различаются только в том случае, если виртуальная таблица имеет какое-то резервное хранилище, которое необходимо инициализировать при первом создании виртуальной таблицы. Метод xCreate создает и инициализирует резервное хранилище. Метод xConnect просто подключается к существующему хранилищу резервных копий. Когда xCreate и xConnect совпадают, таблица является &lt;a href=&quot;vtab#epovtab&quot;&gt;одноименной виртуальной таблицей&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="dcf39a347f064ec02d2e007cec689340fd805ffc" translate="yes" xml:space="preserve">
          <source>The xCreate method is called to create a new instance of a virtual table in response to a &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; statement. If the xCreate method is the same pointer as the &lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; method, then the virtual table is an &lt;a href=&quot;vtab#epovtab&quot;&gt;eponymous virtual table&lt;/a&gt;. If the xCreate method is omitted (if it is a NULL pointer) then the virtual table is an &lt;a href=&quot;vtab#epoonlyvtab&quot;&gt;eponymous-only virtual table&lt;/a&gt;.</source>
          <target state="translated">Метод xCreate вызывается для создания нового экземпляра виртуальной таблицы в ответ на оператор &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; . Если метод xCreate является тем же указателем, что и метод &lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; , тогда виртуальная таблица является &lt;a href=&quot;vtab#epovtab&quot;&gt;одноименной виртуальной таблицей&lt;/a&gt; . Если метод xCreate опущен (если это указатель NULL), тогда виртуальная таблица является &lt;a href=&quot;vtab#epoonlyvtab&quot;&gt;одноименной виртуальной таблицей&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7fa820ae673d5a152c6735ecfbe5a6902d1afc09" translate="yes" xml:space="preserve">
          <source>The xCreate method need not initialize the pModule, nRef, and zErrMsg fields of the &lt;a href=&quot;c3ref/vtab&quot;&gt;sqlite3_vtab&lt;/a&gt; object. The SQLite core will take care of that chore.</source>
          <target state="translated">Метод xCreate не требует инициализации полей pModule, nRef и zErrMsg объекта &lt;a href=&quot;c3ref/vtab&quot;&gt;sqlite3_vtab&lt;/a&gt; . Об этом позаботится ядро ​​SQLite.</target>
        </trans-unit>
        <trans-unit id="06c7e419a8719bf400eb11e6ddbab813f843fcfc" translate="yes" xml:space="preserve">
          <source>The xCreate should return &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; if it is successful in creating the new virtual table, or &lt;a href=&quot;rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt; if it is not successful. If not successful, the &lt;a href=&quot;c3ref/vtab&quot;&gt;sqlite3_vtab&lt;/a&gt; structure must not be allocated. An error message may optionally be returned in *pzErr if unsuccessful. Space to hold the error message string must be allocated using an SQLite memory allocation function like &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc()&lt;/a&gt; or &lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_mprintf()&lt;/a&gt; as the SQLite core will attempt to free the space using &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_free()&lt;/a&gt; after the error has been reported up to the application.</source>
          <target state="translated">XCreate должен вернуть &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK,&lt;/a&gt; если он успешно создает новую виртуальную таблицу, или &lt;a href=&quot;rescode#error&quot;&gt;SQLITE_ERROR,&lt;/a&gt; если это не удалось. В случае &lt;a href=&quot;c3ref/vtab&quot;&gt;неудачи&lt;/a&gt; нельзя выделять структуру sqlite3_vtab . В случае неудачи сообщение об ошибке может быть возвращено в * pzErr. Пространство для хранения строки сообщения об ошибке должно быть выделено с помощью функции выделения памяти SQLite, такой как &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc ()&lt;/a&gt; или &lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_mprintf (),&lt;/a&gt; поскольку ядро ​​SQLite попытается освободить пространство с помощью &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_free ()&lt;/a&gt; после того, как об ошибке было сообщено приложению.</target>
        </trans-unit>
        <trans-unit id="f958ace0be88d27965e6fd7b0b417f1f44eb7a29" translate="yes" xml:space="preserve">
          <source>The xCurrentTime method finds the current time and date and writes the result as a double-precision floating point value into pointer provided by the second parameter. The time and date is in coordinated universal time (UTC) and is a fractional Julian day number.</source>
          <target state="translated">Метод xCurrentTime находит текущее время и дату и записывает результат в виде значения с плавающей точкой двойной точности в указатель,предоставленный вторым параметром.Время и дата находятся в координированном универсальном времени (UTC)и представляют собой дробное число юлианских суток.</target>
        </trans-unit>
        <trans-unit id="6df2a95b2c02a08ca9301c1af593f076dcec3de1" translate="yes" xml:space="preserve">
          <source>The xDelete callback, if one is specified, is also invoked on the auxiliary data pointer after the FTS5 query has finished.</source>
          <target state="translated">Обратный вызов xDelete,если он указан,также вызывается на вспомогательный указатель данных после завершения FTS5-запроса.</target>
        </trans-unit>
        <trans-unit id="684db9583b8006f9c3587ed123a3291e36233a15" translate="yes" xml:space="preserve">
          <source>The xDelete method in the built-in &lt;a href=&quot;vfs&quot;&gt;VFSes&lt;/a&gt; now return SQLITE_IOERR_DELETE_NOENT if the file to be deleted does not exist.</source>
          <target state="translated">Метод xDelete во встроенных &lt;a href=&quot;vfs&quot;&gt;виртуальных файловых системах&lt;/a&gt; теперь возвращает SQLITE_IOERR_DELETE_NOENT, если удаляемый файл не существует.</target>
        </trans-unit>
        <trans-unit id="8acbdfc184b8627360b75ab194ff6c7691155e56" translate="yes" xml:space="preserve">
          <source>The xDelete method is used to delete a file. The name of the file is given in the second parameter. The filename will be in UTF-8. The VFS must convert the filename into whatever character representation the underlying operating system expects. If the syncDir parameter is true, then the xDelete method should not return until the change to the directory contents for the directory containing the deleted file have been synced to disk in order to ensure that the file does not &quot;reappear&quot; if a power failure occurs soon after.</source>
          <target state="translated">Метод xDelete используется для удаления файла.Имя файла указывается во втором параметре.Имя файла будет в кодировке UTF-8.VFS должна преобразовать имя файла в любое символьное представление,которое ожидает операционная система.Если параметр syncDir верен,то метод xDelete не должен возвращаться до тех пор,пока изменение содержимого каталога,содержащего удаленный файл,не будет синхронизировано на диск,чтобы файл не &quot;появился&quot; в случае отключения питания вскоре после этого.</target>
        </trans-unit>
        <trans-unit id="11b2a4e02961f3a81754bcacd1c2618edac811a1" translate="yes" xml:space="preserve">
          <source>The xDestroy callback is &lt;u&gt;not&lt;/u&gt; called if the sqlite3_create_collation_v2() function fails. Applications that invoke sqlite3_create_collation_v2() with a non-NULL xDestroy argument should check the return code and dispose of the application data pointer themselves rather than expecting SQLite to deal with it for them. This is different from every other SQLite interface. The inconsistency is unfortunate but cannot be changed without breaking backwards compatibility.</source>
          <target state="translated">Обратный вызов xDestroy &lt;u&gt;не&lt;/u&gt; вызывается, если функция sqlite3_create_collation_v2 () не работает. Приложения, которые вызывают sqlite3_create_collation_v2 () с аргументом xDestroy, отличным от NULL, должны сами проверять код возврата и удалять указатель данных приложения, а не ожидать, что SQLite обработает это за них. Это отличается от любого другого интерфейса SQLite. Несогласованность вызывает сожаление, но ее нельзя изменить без нарушения обратной совместимости.</target>
        </trans-unit>
        <trans-unit id="82fcb2416a6d15ad9c7eed2868bb3c1083659be9" translate="yes" xml:space="preserve">
          <source>The xDestroy method is required for every virtual table implementation, though it is acceptable for the &lt;a href=&quot;vtab#xdisconnect&quot;&gt;xDisconnect&lt;/a&gt; and xDestroy methods to be the same function if that makes sense for the particular virtual table.</source>
          <target state="translated">Метод xDestroy требуется для каждой реализации виртуальной таблицы, хотя допустимо, чтобы методы &lt;a href=&quot;vtab#xdisconnect&quot;&gt;xDisconnect&lt;/a&gt; и xDestroy были одной и той же функцией, если это имеет смысл для конкретной виртуальной таблицы.</target>
        </trans-unit>
        <trans-unit id="433eafbb64ee6df6fcf2cd0863165758dd2318f2" translate="yes" xml:space="preserve">
          <source>The xDestroy() method is used to delete a cache allocated by xCreate(). All resources associated with the specified cache should be freed. After calling the xDestroy() method, SQLite considers the &lt;a href=&quot;#sqlite3_pcache&quot; id=&quot;thexdestroypagecachemethod&quot;&gt;sqlite3_pcache*&lt;/a&gt; handle invalid, and will not use it with any other sqlite3_pcache_methods2 functions.</source>
          <target state="translated">Метод xDestroy () используется для удаления кеша, выделенного xCreate (). Все ресурсы, связанные с указанным кешем, должны быть освобождены. После вызова метода xDestroy () SQLite считает дескриптор &lt;a href=&quot;#sqlite3_pcache&quot; id=&quot;thexdestroypagecachemethod&quot;&gt;sqlite3_pcache *&lt;/a&gt; недействительным и не будет использовать его с другими функциями sqlite3_pcache_methods2.</target>
        </trans-unit>
        <trans-unit id="8baf35611bcad0c5db55f35fee163e2aa0c149e9" translate="yes" xml:space="preserve">
          <source>The xDestroy() method is used to delete a cache allocated by xCreate(). All resources associated with the specified cache should be freed. After calling the xDestroy() method, SQLite considers the &lt;a href=&quot;pcache&quot; id=&quot;thexdestroypagecachemethod&quot;&gt;sqlite3_pcache*&lt;/a&gt; handle invalid, and will not use it with any other sqlite3_pcache_methods2 functions.</source>
          <target state="translated">Метод xDestroy () используется для удаления кеша, выделенного xCreate (). Все ресурсы, связанные с указанным кешем, должны быть освобождены. После вызова метода xDestroy () SQLite считает дескриптор &lt;a href=&quot;pcache&quot; id=&quot;thexdestroypagecachemethod&quot;&gt;sqlite3_pcache *&lt;/a&gt; недействительным и не будет использовать его с другими функциями sqlite3_pcache_methods2.</target>
        </trans-unit>
        <trans-unit id="604385447aab898766cb3896d8016d04ab97fc0d" translate="yes" xml:space="preserve">
          <source>The xDeviceCharacteristics method of the &lt;a href=&quot;#sqlite3_io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object returns an integer which is a vector of these bit values expressing I/O characteristics of the mass storage device that holds the file that the &lt;a href=&quot;#sqlite3_io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; refers to.</source>
          <target state="translated">Метод xDeviceCharacteristics объекта &lt;a href=&quot;#sqlite3_io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; возвращает целое число, которое является вектором этих битовых значений, выражающих характеристики ввода-вывода запоминающего устройства большой емкости, содержащего файл, на который ссылается &lt;a href=&quot;#sqlite3_io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b98ec973b9735d7dd446dd0f56fe3b7eb0a27d7c" translate="yes" xml:space="preserve">
          <source>The xDeviceCharacteristics method of the &lt;a href=&quot;io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object returns an integer which is a vector of these bit values expressing I/O characteristics of the mass storage device that holds the file that the &lt;a href=&quot;io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; refers to.</source>
          <target state="translated">Метод xDeviceCharacteristics объекта &lt;a href=&quot;io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; возвращает целое число, которое является вектором этих битовых значений, выражающих характеристики ввода-вывода запоминающего устройства большой емкости, содержащего файл, на который ссылается &lt;a href=&quot;io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c2e8466b1e208836960d6bb4f90ed3ea7832fd67" translate="yes" xml:space="preserve">
          <source>The xDeviceCharacteristics method returns an integer bit vector that defines any special properties that the underlying storage medium might have that SQLite can use to increase performance. The allowed return is the bit-wise OR of the following values:</source>
          <target state="translated">Метод xDeviceCharacteristics возвращает целочисленный битовый вектор,который определяет любые специальные свойства,которые может иметь базовый носитель данных,который SQLite может использовать для повышения производительности.Допустимым возвратом является битовое ИЛИ следующих значений:</target>
        </trans-unit>
        <trans-unit id="1262b3501d52f25dbe2da92b37772cb17c293d40" translate="yes" xml:space="preserve">
          <source>The xDisconnect method is required for every virtual table implementation, though it is acceptable for the xDisconnect and &lt;a href=&quot;vtab#sqlite3_module.xDestroy&quot;&gt;xDestroy&lt;/a&gt; methods to be the same function if that makes sense for the particular virtual table.</source>
          <target state="translated">Метод xDisconnect требуется для каждой реализации виртуальной таблицы, хотя допустимо, чтобы методы xDisconnect и &lt;a href=&quot;vtab#sqlite3_module.xDestroy&quot;&gt;xDestroy&lt;/a&gt; были одной и той же функцией, если это имеет смысл для конкретной виртуальной таблицы.</target>
        </trans-unit>
        <trans-unit id="80202d349ad4d59a55548ad8afd689feeefba61b" translate="yes" xml:space="preserve">
          <source>The xDlOpen, xDlError, xDlSym, and xDlClose methods are all used for accessing shared libraries at run-time. These methods may be omitted (and their pointers set to zero) if the library is compiled with &lt;a href=&quot;compile#omit_load_extension&quot;&gt;SQLITE_OMIT_LOAD_EXTENSION&lt;/a&gt; or if the &lt;a href=&quot;c3ref/enable_load_extension&quot;&gt;sqlite3_enable_load_extension()&lt;/a&gt; interface is never used to enable dynamic extension loading. The xDlOpen method opens a shared library or DLL and returns a pointer to a handle. NULL is returned if the open fails. If the open fails, the xDlError method can be used to obtain a text error message. The message is written into the zErrMsg buffer of the third parameter which is at least nByte bytes in length. The xDlSym returns a pointer to a symbol in the shared library. The name of the symbol is given by the second parameter. UTF-8 encoding is assumed. If the symbol is not found a NULL pointer is returned. The xDlClose routine closes the shared library.</source>
          <target state="translated">Все методы xDlOpen, xDlError, xDlSym и xDlClose используются для доступа к разделяемым библиотекам во время выполнения. Эти методы могут быть опущены (и их указатели установлены в ноль), если библиотека скомпилирована с &lt;a href=&quot;compile#omit_load_extension&quot;&gt;SQLITE_OMIT_LOAD_EXTENSION&lt;/a&gt; или если &lt;a href=&quot;c3ref/enable_load_extension&quot;&gt;sqlite3_enable_load_extension ()&lt;/a&gt;интерфейс никогда не используется для включения динамической загрузки расширений. Метод xDlOpen открывает общую библиотеку или DLL и возвращает указатель на дескриптор. NULL возвращается, если открытие не удалось. В случае сбоя открытия можно использовать метод xDlError для получения текстового сообщения об ошибке. Сообщение записывается в буфер zErrMsg третьего параметра, который имеет длину не менее nByte байт. XDlSym возвращает указатель на символ в общей библиотеке. Имя символа задается вторым параметром. Предполагается кодировка UTF-8. Если символ не найден, возвращается NULL указатель. Подпрограмма xDlClose закрывает общую библиотеку.</target>
        </trans-unit>
        <trans-unit id="2a328c23f376e27049c3463e790fd30ea24be07c" translate="yes" xml:space="preserve">
          <source>The xEof method is required for every virtual table implementation.</source>
          <target state="translated">Метод xEof необходим для каждой реализации виртуальной таблицы.</target>
        </trans-unit>
        <trans-unit id="2f524de9f6418ba3f20971cbbb6e678439f267fb" translate="yes" xml:space="preserve">
          <source>The xEof method must return false (zero) if the specified cursor currently points to a valid row of data, or true (non-zero) otherwise. This method is called by the SQL engine immediately after each &lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter&lt;/a&gt; and &lt;a href=&quot;vtab#xnext&quot;&gt;xNext&lt;/a&gt; invocation.</source>
          <target state="translated">Метод xEof должен возвращать false (ноль), если указанный курсор в настоящий момент указывает на допустимую строку данных, или true (ненулевое значение) в противном случае. Этот метод вызывается механизмом SQL сразу после каждого &lt;a href=&quot;vtab#xfilter&quot;&gt;вызова xFilter&lt;/a&gt; и &lt;a href=&quot;vtab#xnext&quot;&gt;xNext&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="31055a962a7bb13c9dfa534ee5cb14dc7402ab08" translate="yes" xml:space="preserve">
          <source>The xFetch() method locates a page in the cache and returns a pointer to an sqlite3_pcache_page object associated with that page, or a NULL pointer. The pBuf element of the returned sqlite3_pcache_page object will be a pointer to a buffer of szPage bytes used to store the content of a single database page. The pExtra element of sqlite3_pcache_page will be a pointer to the szExtra bytes of extra storage that SQLite has requested for each entry in the page cache.</source>
          <target state="translated">Метод xFetch()находит страницу в кэше и возвращает указатель на объект sqlite3_pcache_page,связанный с этой страницей,или указатель NULL.Элемент pBuf возвращаемого объекта sqlite3_pcache_page будет указателем на буфер байт szPage,используемый для хранения содержимого одной страницы БД.Элемент pExtra sqlite3_pcache_page будет указателем на байты szExtra дополнительного хранилища,которые SQLite запрашивал для каждого элемента в кэше страниц.</target>
        </trans-unit>
        <trans-unit id="eec30896c07568e6756a1fd11de9a9be38006b51" translate="yes" xml:space="preserve">
          <source>The xFileControl() method is a generic interface that allows custom VFS implementations to directly control an open file using the (new and experimental) &lt;a href=&quot;c3ref/file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; interface. The second &quot;op&quot; argument is an integer opcode. The third argument is a generic pointer which is intended to be a pointer to a structure that may contain arguments or space in which to write return values. Potential uses for xFileControl() might be functions to enable blocking locks with timeouts, to change the locking strategy (for example to use dot-file locks), to inquire about the status of a lock, or to break stale locks. The SQLite core reserves opcodes less than 100 for its own use. A &lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntllockstate&quot;&gt;list of opcodes&lt;/a&gt; less than 100 is available. Applications that define a custom xFileControl method should use opcodes greater than 100 to avoid conflicts.</source>
          <target state="translated">Метод xFileControl () - это общий интерфейс, который позволяет настраиваемым реализациям VFS напрямую управлять открытым файлом с помощью (нового и экспериментального &lt;a href=&quot;c3ref/file_control&quot;&gt;)&lt;/a&gt; интерфейса sqlite3_file_control () . Второй аргумент op - это целочисленный код операции. Третий аргумент - это общий указатель, который предназначен для использования в качестве указателя на структуру, которая может содержать аргументы или пространство для записи возвращаемых значений. Возможным использованием xFileControl () могут быть функции для включения блокирующих блокировок с тайм-аутом, для изменения стратегии блокировки (например, для использования блокировок точечных файлов), для запроса состояния блокировки или для снятия устаревших блокировок. Ядро SQLite резервирует коды операций менее 100 для собственного использования. &lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntllockstate&quot;&gt;Список опкодов&lt;/a&gt;доступно менее 100. Приложения, которые определяют собственный метод xFileControl, должны использовать коды операций больше 100, чтобы избежать конфликтов.</target>
        </trans-unit>
        <trans-unit id="dddf7acfafd6d3f8269f8f981d3bcbe57970b96a" translate="yes" xml:space="preserve">
          <source>The xFileControl() method is a generic interface that allows custom VFS implementations to directly control an open file using the &lt;a href=&quot;#sqlite3_file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; interface. The second &quot;op&quot; argument is an integer opcode. The third argument is a generic pointer intended to point to a structure that may contain arguments or space in which to write return values. Potential uses for xFileControl() might be functions to enable blocking locks with timeouts, to change the locking strategy (for example to use dot-file locks), to inquire about the status of a lock, or to break stale locks. The SQLite core reserves all opcodes less than 100 for its own use. A &lt;a href=&quot;#SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&quot;&gt;list of opcodes&lt;/a&gt; less than 100 is available. Applications that define a custom xFileControl method should use opcodes greater than 100 to avoid conflicts. VFS implementations should return &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOTFOUND&lt;/a&gt; for file control opcodes that they do not recognize.</source>
          <target state="translated">Метод xFileControl () - это общий интерфейс, который позволяет настраиваемым реализациям VFS напрямую управлять открытым файлом с помощью интерфейса &lt;a href=&quot;#sqlite3_file_control&quot;&gt;sqlite3_file_control ()&lt;/a&gt; . Второй аргумент op - это целочисленный код операции. Третий аргумент - это общий указатель, предназначенный для указания на структуру, которая может содержать аргументы или пространство для записи возвращаемых значений. Возможным использованием xFileControl () могут быть функции для включения блокирующих блокировок с тайм-аутом, для изменения стратегии блокировки (например, для использования блокировок точечных файлов), для запроса состояния блокировки или для снятия устаревших блокировок. Ядро SQLite резервирует все коды операций менее 100 для собственного использования. &lt;a href=&quot;#SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&quot;&gt;Список опкодов&lt;/a&gt;доступно менее 100. Приложения, которые определяют собственный метод xFileControl, должны использовать коды операций больше 100, чтобы избежать конфликтов. Реализации VFS должны возвращать &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOTFOUND&lt;/a&gt; для кодов операций управления файлами, которые они не распознают.</target>
        </trans-unit>
        <trans-unit id="0cff0bc514819c033ff2d05910e11b13ceab5fce" translate="yes" xml:space="preserve">
          <source>The xFileControl() method is a generic interface that allows custom VFS implementations to directly control an open file using the &lt;a href=&quot;file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; interface. The second &quot;op&quot; argument is an integer opcode. The third argument is a generic pointer intended to point to a structure that may contain arguments or space in which to write return values. Potential uses for xFileControl() might be functions to enable blocking locks with timeouts, to change the locking strategy (for example to use dot-file locks), to inquire about the status of a lock, or to break stale locks. The SQLite core reserves all opcodes less than 100 for its own use. A &lt;a href=&quot;c_fcntl_begin_atomic_write&quot;&gt;list of opcodes&lt;/a&gt; less than 100 is available. Applications that define a custom xFileControl method should use opcodes greater than 100 to avoid conflicts. VFS implementations should return &lt;a href=&quot;../rescode#notfound&quot;&gt;SQLITE_NOTFOUND&lt;/a&gt; for file control opcodes that they do not recognize.</source>
          <target state="translated">Метод xFileControl () - это общий интерфейс, который позволяет настраиваемым реализациям VFS напрямую управлять открытым файлом с помощью интерфейса &lt;a href=&quot;file_control&quot;&gt;sqlite3_file_control ()&lt;/a&gt; . Второй аргумент op - это целочисленный код операции. Третий аргумент - это общий указатель, предназначенный для указания на структуру, которая может содержать аргументы или пространство для записи возвращаемых значений. Возможным использованием xFileControl () могут быть функции для включения блокирующих блокировок с тайм-аутом, для изменения стратегии блокировки (например, для использования блокировок точечных файлов), для запроса состояния блокировки или для снятия устаревших блокировок. Ядро SQLite резервирует все коды операций менее 100 для собственного использования. &lt;a href=&quot;c_fcntl_begin_atomic_write&quot;&gt;Список опкодов&lt;/a&gt;доступно менее 100. Приложения, которые определяют собственный метод xFileControl, должны использовать коды операций больше 100, чтобы избежать конфликтов. Реализации VFS должны возвращать &lt;a href=&quot;../rescode#notfound&quot;&gt;SQLITE_NOTFOUND&lt;/a&gt; для кодов операций управления файлами, которые они не распознают.</target>
        </trans-unit>
        <trans-unit id="3203c926180842d31c782d904c037633ddf2f91f" translate="yes" xml:space="preserve">
          <source>The xFileSize() method determines the current size of the file in bytes and writes that value into *pSize. It returns &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; on success and &lt;a href=&quot;rescode#ioerr_fstat&quot;&gt;SQLITE_IOERR_FSTAT&lt;/a&gt; if something goes wrong.</source>
          <target state="translated">Метод xFileSize () определяет текущий размер файла в байтах и ​​записывает это значение в * pSize. Он возвращает &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; в случае успеха и &lt;a href=&quot;rescode#ioerr_fstat&quot;&gt;SQLITE_IOERR_FSTAT,&lt;/a&gt; если что-то пойдет не так.</target>
        </trans-unit>
        <trans-unit id="96653ab4bb654a8e871b1a8c14aa48716aadb8ae" translate="yes" xml:space="preserve">
          <source>The xFilter method is required for every virtual table implementation.</source>
          <target state="translated">Метод xFilter требуется для каждой реализации виртуальной таблицы.</target>
        </trans-unit>
        <trans-unit id="4479f4bd625e3440b28fa60e755d9671817cfbcf" translate="yes" xml:space="preserve">
          <source>The xFullPathname method is used to convert a relative pathname into a full pathname. The resulting full pathname is written into the buffer provided by the third parameter. SQLite will size the output buffer to at least mxPathname bytes. Both the input and output names should be in UTF-8.</source>
          <target state="translated">Метод xFullPathname используется для преобразования относительного имени в полное.Полученный полный путь записывается в буфер,предоставляемый третьим параметром.SQLite будет размер выходного буфера не менее mxPathname в байтах.Имена как входного,так и выходного должны быть в кодировке UTF-8.</target>
        </trans-unit>
        <trans-unit id="5dbd41bd881211c13a1dbbcb8c736851e1bf5d97" translate="yes" xml:space="preserve">
          <source>The xGeom callback always does a depth-first search of the r-tree.</source>
          <target state="translated">Обратный вызов xGeom всегда выполняет глубинный поиск r-дерева.</target>
        </trans-unit>
        <trans-unit id="454e11b15802805175a3b539debe13d361beb72d" translate="yes" xml:space="preserve">
          <source>The xGetTempName method computes the name of a temporary file that SQLite can use. The name should be written into the buffer given by the second parameter. SQLite will size that buffer to hold at least mxPathname bytes. The generated filename should be in UTF-8. To avoid security problems, the generated temporary filename should contain enough randomness to prevent an attacker from guessing the temporary filename in advance.</source>
          <target state="translated">Метод xGetTempName вычисляет имя временного файла,который SQLite может использовать.Имя должно быть записано в буфер,заданный вторым параметром.SQLite будет размер этого буфера не менее mxPathname байт.Генерируемое имя файла должно быть в UTF-8.Чтобы избежать проблем с безопасностью,сгенерированное временное имя файла должно содержать достаточное количество случайностей,чтобы злоумышленник не смог заранее угадать временное имя файла.</target>
        </trans-unit>
        <trans-unit id="5d25f32f0f944f020730e420a59b761837d6fa20" translate="yes" xml:space="preserve">
          <source>The xGetTempname method has been removed from &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;. In its place, the xOpen method is enhanced to open a temporary file of its own invention when the filename parameter is NULL.</source>
          <target state="translated">Метод xGetTempname был удален из &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; . Вместо этого метод xOpen расширен и позволяет открывать временный файл собственного изобретения, когда параметр filename равен NULL.</target>
        </trans-unit>
        <trans-unit id="e9de98bc73bd358a33146535bc6a4c0838edf0ac" translate="yes" xml:space="preserve">
          <source>The xInit method initializes the memory allocator. For example, it might allocate any require mutexes or initialize internal data structures. The xShutdown method is invoked (indirectly) by &lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_shutdown()&lt;/a&gt; and should deallocate any resources acquired by xInit. The pAppData pointer is used as the only parameter to xInit and xShutdown.</source>
          <target state="translated">Метод xInit инициализирует распределитель памяти. Например, он может выделить любые требуемые мьютексы или инициализировать внутренние структуры данных. Метод xShutdown вызывается (косвенно) &lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_shutdown ()&lt;/a&gt; и должен освободить все ресурсы, полученные xInit. Указатель pAppData используется как единственный параметр для xInit и xShutdown.</target>
        </trans-unit>
        <trans-unit id="3fa9fa67f04b6378191cf480be2d31d4ea4b3e4c" translate="yes" xml:space="preserve">
          <source>The xInit method initializes the memory allocator. For example, it might allocate any require mutexes or initialize internal data structures. The xShutdown method is invoked (indirectly) by &lt;a href=&quot;initialize&quot;&gt;sqlite3_shutdown()&lt;/a&gt; and should deallocate any resources acquired by xInit. The pAppData pointer is used as the only parameter to xInit and xShutdown.</source>
          <target state="translated">Метод xInit инициализирует распределитель памяти. Например, он может выделить любые требуемые мьютексы или инициализировать внутренние структуры данных. Метод xShutdown вызывается (косвенно) &lt;a href=&quot;initialize&quot;&gt;sqlite3_shutdown ()&lt;/a&gt; и должен освободить все ресурсы, полученные xInit. Указатель pAppData используется как единственный параметр для xInit и xShutdown.</target>
        </trans-unit>
        <trans-unit id="b5977e9a51901888e399d44616a096c8dd4ad36a" translate="yes" xml:space="preserve">
          <source>The xInit method initializes the memory allocator. For example, it might allocate any required mutexes or initialize internal data structures. The xShutdown method is invoked (indirectly) by &lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_shutdown()&lt;/a&gt; and should deallocate any resources acquired by xInit. The pAppData pointer is used as the only parameter to xInit and xShutdown.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9b210b9a34cdea6b00c84f118c3818052de5137" translate="yes" xml:space="preserve">
          <source>The xInit method initializes the memory allocator. For example, it might allocate any required mutexes or initialize internal data structures. The xShutdown method is invoked (indirectly) by &lt;a href=&quot;initialize&quot;&gt;sqlite3_shutdown()&lt;/a&gt; and should deallocate any resources acquired by xInit. The pAppData pointer is used as the only parameter to xInit and xShutdown.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="928f04710edbd4aadd8a60154ed8a2e307eed0ef" translate="yes" xml:space="preserve">
          <source>The xInit() method is called once for each effective call to &lt;a href=&quot;#sqlite3_initialize&quot; id=&quot;thexinitpagecachemethod&quot;&gt;sqlite3_initialize()&lt;/a&gt; (usually only once during the lifetime of the process). The xInit() method is passed a copy of the sqlite3_pcache_methods2.pArg value. The intent of the xInit() method is to set up global data structures required by the custom page cache implementation. If the xInit() method is NULL, then the built-in default page cache is used instead of the application defined page cache.</source>
          <target state="translated">Метод xInit () вызывается один раз для каждого эффективного вызова &lt;a href=&quot;#sqlite3_initialize&quot; id=&quot;thexinitpagecachemethod&quot;&gt;sqlite3_initialize ()&lt;/a&gt; (обычно только один раз за время существования процесса). В метод xInit () передается копия значения sqlite3_pcache_methods2.pArg. Назначение метода xInit () - настроить глобальные структуры данных, необходимые для реализации пользовательского кэша страниц. Если метод xInit () имеет значение ПУСТО (NULL), то используется встроенный по умолчанию кеш страниц вместо кеша страниц, определяемого приложением.</target>
        </trans-unit>
        <trans-unit id="6ba32c8d759124102ccc057ecbe6a0c1c85fb3b5" translate="yes" xml:space="preserve">
          <source>The xInit() method is called once for each effective call to &lt;a href=&quot;initialize&quot; id=&quot;thexinitpagecachemethod&quot;&gt;sqlite3_initialize()&lt;/a&gt; (usually only once during the lifetime of the process). The xInit() method is passed a copy of the sqlite3_pcache_methods2.pArg value. The intent of the xInit() method is to set up global data structures required by the custom page cache implementation. If the xInit() method is NULL, then the built-in default page cache is used instead of the application defined page cache.</source>
          <target state="translated">Метод xInit () вызывается один раз для каждого эффективного вызова &lt;a href=&quot;initialize&quot; id=&quot;thexinitpagecachemethod&quot;&gt;sqlite3_initialize ()&lt;/a&gt; (обычно только один раз за время существования процесса). В метод xInit () передается копия значения sqlite3_pcache_methods2.pArg. Назначение метода xInit () - настроить глобальные структуры данных, необходимые для реализации пользовательского кэша страниц. Если метод xInit () имеет значение ПУСТО (NULL), то используется встроенный по умолчанию кеш страниц вместо кеша страниц, определяемого приложением.</target>
        </trans-unit>
        <trans-unit id="8a32ff6fcc7d9e120e222fe6ef8bbf8b9661df8a" translate="yes" xml:space="preserve">
          <source>The xLock and xUnlock methods are used to set and clear file locks. SQLite supports five levels of file locks, in order:</source>
          <target state="translated">Методы xLock и xUnlock используются для установки и очистки файловых замков.SQLite поддерживает пять уровней блокировки файлов по порядку:</target>
        </trans-unit>
        <trans-unit id="8a5c74b276f4ba001214e303873304b1cefc6f0e" translate="yes" xml:space="preserve">
          <source>The xMalloc, xRealloc, and xFree methods must work like the malloc(), realloc() and free() functions from the standard C library. SQLite guarantees that the second argument to xRealloc is always a value returned by a prior call to xRoundup.</source>
          <target state="translated">Методы xMalloc,xRealloc и xFree должны работать как функции malloc(),realloc()и free()из стандартной библиотеки Си.SQLite гарантирует,что вторым аргументом в xRealloc всегда будет значение,возвращенное предыдущим вызовом в xRoundup.</target>
        </trans-unit>
        <trans-unit id="f3c67d901eafc4b8170f137f64b1ed5325131c31" translate="yes" xml:space="preserve">
          <source>The xMutexEnd method defined by this structure is invoked as part of system shutdown by the sqlite3_shutdown() function. The implementation of this method is expected to release all outstanding resources obtained by the mutex methods implementation, especially those obtained by the xMutexInit method. The xMutexEnd() interface is invoked exactly once for each call to &lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_shutdown()&lt;/a&gt;.</source>
          <target state="translated">Метод xMutexEnd, определенный этой структурой, вызывается как часть завершения работы системы функцией sqlite3_shutdown (). Ожидается, что реализация этого метода освободит все невыполненные ресурсы, полученные с помощью реализации методов мьютекса, особенно те, которые получены с помощью метода xMutexInit. Интерфейс xMutexEnd () вызывается ровно один раз для каждого вызова &lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_shutdown ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="29460abd69ce976afdb57bd86f856a912e6b2129" translate="yes" xml:space="preserve">
          <source>The xMutexEnd method defined by this structure is invoked as part of system shutdown by the sqlite3_shutdown() function. The implementation of this method is expected to release all outstanding resources obtained by the mutex methods implementation, especially those obtained by the xMutexInit method. The xMutexEnd() interface is invoked exactly once for each call to &lt;a href=&quot;initialize&quot;&gt;sqlite3_shutdown()&lt;/a&gt;.</source>
          <target state="translated">Метод xMutexEnd, определенный этой структурой, вызывается как часть завершения работы системы функцией sqlite3_shutdown (). Ожидается, что реализация этого метода освободит все невыполненные ресурсы, полученные с помощью реализации методов мьютекса, особенно те, которые получены с помощью метода xMutexInit. Интерфейс xMutexEnd () вызывается ровно один раз для каждого вызова &lt;a href=&quot;initialize&quot;&gt;sqlite3_shutdown ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cd4f06c8938e3564cfbf224eac3d8cf5b5b06a0d" translate="yes" xml:space="preserve">
          <source>The xMutexInit method defined by this structure is invoked as part of system initialization by the sqlite3_initialize() function. The xMutexInit routine is called by SQLite exactly once for each effective call to &lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_initialize()&lt;/a&gt;.</source>
          <target state="translated">Метод xMutexInit, определенный этой структурой, вызывается как часть инициализации системы функцией sqlite3_initialize (). Подпрограмма xMutexInit вызывается SQLite ровно один раз для каждого эффективного вызова &lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_initialize ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="dab4cb79a586f29424445d440e5fffbfe8ba4495" translate="yes" xml:space="preserve">
          <source>The xMutexInit method defined by this structure is invoked as part of system initialization by the sqlite3_initialize() function. The xMutexInit routine is called by SQLite exactly once for each effective call to &lt;a href=&quot;initialize&quot;&gt;sqlite3_initialize()&lt;/a&gt;.</source>
          <target state="translated">Метод xMutexInit, определенный этой структурой, вызывается как часть инициализации системы функцией sqlite3_initialize (). Подпрограмма xMutexInit вызывается SQLite ровно один раз для каждого эффективного вызова &lt;a href=&quot;initialize&quot;&gt;sqlite3_initialize ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="89ac720acef7b2cd1f40cadc5a9b4008a6051773" translate="yes" xml:space="preserve">
          <source>The xMutexInit() method must be threadsafe. It must be harmless to invoke xMutexInit() multiple times within the same process and without intervening calls to xMutexEnd(). Second and subsequent calls to xMutexInit() must be no-ops.</source>
          <target state="translated">Метод xMutexInit()должен быть потокобезопасен.Должно быть безопасно вызывать xMutexInit()несколько раз в рамках одного и того же процесса и без вмешательства вызова xMutexEnd().Второй и последующие вызовы xMutexInit()должны быть безостановочными.</target>
        </trans-unit>
        <trans-unit id="35cc67c51c972e7defc85a2cd19b646cf64aa418" translate="yes" xml:space="preserve">
          <source>The xNext method advances a &lt;a href=&quot;c3ref/vtab_cursor&quot;&gt;virtual table cursor&lt;/a&gt; to the next row of a result set initiated by &lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter&lt;/a&gt;. If the cursor is already pointing at the last row when this routine is called, then the cursor no longer points to valid data and a subsequent call to the &lt;a href=&quot;vtab#xeof&quot;&gt;xEof&lt;/a&gt; method must return true (non-zero). If the cursor is successfully advanced to another row of content, then subsequent calls to &lt;a href=&quot;vtab#xeof&quot;&gt;xEof&lt;/a&gt; must return false (zero).</source>
          <target state="translated">Метод xNext &lt;a href=&quot;c3ref/vtab_cursor&quot;&gt;перемещает курсор виртуальной таблицы&lt;/a&gt; к следующей строке набора результатов, инициированного &lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter&lt;/a&gt; . Если курсор уже указывает на последнюю строку при вызове этой подпрограммы, то курсор больше не указывает на действительные данные, и последующий вызов метода &lt;a href=&quot;vtab#xeof&quot;&gt;xEof&lt;/a&gt; должен возвращать истину (ненулевое значение). Если курсор успешно перемещается на другую строку содержимого, последующие вызовы &lt;a href=&quot;vtab#xeof&quot;&gt;xEof&lt;/a&gt; должны возвращать false (ноль).</target>
        </trans-unit>
        <trans-unit id="c07bbf2e5005e8108d2f1c166d0b989d5b0ef5de" translate="yes" xml:space="preserve">
          <source>The xNext method is required for every virtual table implementation.</source>
          <target state="translated">Метод xNext требуется для каждой реализации виртуальной таблицы.</target>
        </trans-unit>
        <trans-unit id="eee0d952c4251db31a384eceabf2a26d2118eb4d" translate="yes" xml:space="preserve">
          <source>The xOpen method creates a new cursor used for accessing (read and/or writing) a virtual table. A successful invocation of this method will allocate the memory for the &lt;a href=&quot;c3ref/vtab_cursor&quot;&gt;sqlite3_vtab_cursor&lt;/a&gt; (or a subclass), initialize the new object, and make *ppCursor point to the new object. The successful call then returns &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;.</source>
          <target state="translated">Метод xOpen создает новый курсор, используемый для доступа (чтения и / или записи) к виртуальной таблице. Успешный вызов этого метода выделит память для &lt;a href=&quot;c3ref/vtab_cursor&quot;&gt;sqlite3_vtab_cursor&lt;/a&gt; (или подкласса), инициализирует новый объект и заставит * ppCursor указывать на новый объект. Затем успешный вызов возвращает &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="00b35252e3240b77ad5fc35ac862013d23c8ea89" translate="yes" xml:space="preserve">
          <source>The xOpen method is required for every virtual table implementation.</source>
          <target state="translated">Метод xOpen требуется для каждой реализации виртуальной таблицы.</target>
        </trans-unit>
        <trans-unit id="fe219d8e760e2d5872424a8a4fa6980f7d9bd820" translate="yes" xml:space="preserve">
          <source>The xOpen method need not initialize the pVtab field of the &lt;a href=&quot;c3ref/vtab_cursor&quot;&gt;sqlite3_vtab_cursor&lt;/a&gt; structure. The SQLite core will take care of that chore automatically.</source>
          <target state="translated">Метод xOpen не требует инициализации поля pVtab структуры &lt;a href=&quot;c3ref/vtab_cursor&quot;&gt;sqlite3_vtab_cursor&lt;/a&gt; . Ядро SQLite автоматически выполнит эту работу.</target>
        </trans-unit>
        <trans-unit id="5883a2e08ea426f3d0e98ebbcc84b207e43eeb5d" translate="yes" xml:space="preserve">
          <source>The xOutput callback is invoked zero or more times to return data to the application. The first parameter passed to each call is a copy of the pOut pointer supplied by the application. The second parameter, pData, points to a buffer nData bytes in size containing the chunk of output data being returned. If the xOutput callback successfully processes the supplied data, it should return SQLITE_OK to indicate success. Otherwise, it should return some other SQLite error code. In this case processing is immediately abandoned and the streaming API function returns a copy of the xOutput error code to the application.</source>
          <target state="translated">Обратный вызов xOutput вызывается нулевым или более раз для возврата данных в приложение.Первый параметр,передаваемый каждому вызову,является копией указателя pOut,поставляемого приложением.Второй параметр,pData,указывает на буфер nData байт размером с кусок возвращаемых выходных данных.Если xOutput callback успешно обрабатывает предоставленные данные,он должен вернуть SQLITE_OK,чтобы указать на успех.В противном случае,он должен вернуть другой код ошибки SQLite.В этом случае обработка немедленно прекращается и потоковая API-функция возвращает приложению копию кода ошибки xOutput.</target>
        </trans-unit>
        <trans-unit id="4fdec734fe0825d4b45223206e7ef21a40dca7d6" translate="yes" xml:space="preserve">
          <source>The xPagecount() method must return the number of pages currently stored in the cache, both pinned and unpinned.</source>
          <target state="translated">Метод xPagecount()должен возвращать количество страниц,хранящихся в кэше в данный момент,как пиннированных,так и не пиннированных.</target>
        </trans-unit>
        <trans-unit id="f7670800549df532ce782308a5027526fc2bbf4f" translate="yes" xml:space="preserve">
          <source>The xQueryFunc must set the eWithin field of sqlite3_rtree_query_info to one of the values NOT_WITHIN, PARTLY_WITHIN, or FULLY_WITHIN depending on whether or not the bounding box defined by aCoord[] is completely outside the region, overlaps the region, or is completely inside the region, respectively. In addition, the xQueryFunc must set the rScore field to a non-negative value that indicates the order in which subtrees and entries of the query should be analyzed and returned. Smaller scores are processed first.</source>
          <target state="translated">xQueryFunc должен установить поле eWithin sqlite3_rtree_query_info в одно из значений NOT_WITHIN,PARTLY_WITHIN или FULLY_WITHIN в зависимости от того,находится ли ограничительное поле,определенное aCoord[]полностью вне региона,перекрывает регион или полностью внутри региона,соответственно.Кроме того,xQueryFunc должен установить для поля rScore неотрицательное значение,указывающее порядок анализа и возврата поддеревьев и записей запроса.Сначала обрабатываются меньшие оценки.</target>
        </trans-unit>
        <trans-unit id="243e65d787818469363333eb640b0b44f38c6ec4" translate="yes" xml:space="preserve">
          <source>The xRandomness method is used exactly once to initialize the pseudo-random number generator (PRNG) inside of SQLite. Only the xRandomness method on the default VFS is used. The xRandomness methods on other VFSes are never accessed by SQLite. The xRandomness routine requests that nByte bytes of randomness be written into zOut. The routine returns the actual number of bytes of randomness obtained. The quality of the randomness so obtained will determine the quality of the randomness generated by built-in SQLite functions such as random() and randomblob(). SQLite also uses its PRNG to generate temporary file names. On some platforms (ex: Windows) SQLite assumes that temporary file names are unique without actually testing for collisions, so it is important to have good-quality randomness even if the random() and randomblob() functions are never used.</source>
          <target state="translated">Метод xRandomness используется ровно один раз для инициализации генератора псевдослучайных чисел (PRNG)внутри SQLite.Используется только метод xRandomness на VFS по умолчанию.Доступ к методам xRandomness на других VFS никогда не осуществляется SQLite.Метод xRandomness требует,чтобы в zOut были записаны nByte байты случайности.Рутина возвращает реальное количество полученных байт случайности.Качество полученной таким образом случайности определяет качество случайности,генерируемой встроенными функциями SQLite,такими как random()и randomblob().SQLite также использует свой PRNG для генерации имен временных файлов.На некоторых платформах (например,Windows)SQLite предполагает,что имена временных файлов уникальны без фактической проверки на коллизии,поэтому важно иметь хорошее качество случайности,даже если функции random()и randomblob()никогда не используются.</target>
        </trans-unit>
        <trans-unit id="2203fe5d9da94fc2d593e73757d6951b646a5aac" translate="yes" xml:space="preserve">
          <source>The xRandomness(), xSleep(), xCurrentTime(), and xCurrentTimeInt64() interfaces are not strictly a part of the filesystem, but they are included in the VFS structure for completeness. The xRandomness() function attempts to return nBytes bytes of good-quality randomness into zOut. The return value is the actual number of bytes of randomness obtained. The xSleep() method causes the calling thread to sleep for at least the number of microseconds given. The xCurrentTime() method returns a Julian Day Number for the current date and time as a floating point value. The xCurrentTimeInt64() method returns, as an integer, the Julian Day Number multiplied by 86400000 (the number of milliseconds in a 24-hour day). SQLite will use the xCurrentTimeInt64() method to get the current date and time if that method is available (if iVersion is 2 or greater and the function pointer is not NULL) and will fall back to xCurrentTime() if xCurrentTimeInt64() is unavailable.</source>
          <target state="translated">Интерфейсы xRandomness(),xSleep(),xCurrentTime()и xCurrentTimeInt64()не являются строго частью файловой системы,но для полноты они включены в структуру VFS.Функция xRandomness()пытается вернуть nBytes байт хорошего качества в zOut.Возвращаемое значение представляет собой фактическое количество полученных байт случайности.Метод xSleep()заставляет вызывающий поток спать,по крайней мере,в течение заданного количества микросекунд.Метод xCurrentTime()возвращает в качестве значения с плавающей точкой Julian Day Number для текущей даты и времени.Метод xCurrentTimeInt64()возвращает в виде целого числа номер юлианского дня,умноженного на 86400000 (количество миллисекунд за 24-часовой день).SQLite будет использовать метод xCurrentTimeInt64()для получения текущей даты и времени,если этот метод доступен (если iVersion равна 2 или больше и указатель функции не NULL)и вернется к xCurrentTime(),если xCurrentTimeInt64()недоступен.</target>
        </trans-unit>
        <trans-unit id="9578c347ea12c88b2a68bb1b8891cc899dd6f688" translate="yes" xml:space="preserve">
          <source>The xRead method reads iAmt bytes from the file beginning at a byte offset to iOfst. The data read is stored in the pointer of the second parameter. xRead returns the &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; on success, &lt;a href=&quot;rescode#ioerr_short_read&quot;&gt;SQLITE_IOERR_SHORT_READ&lt;/a&gt; if it was not able to read the full number of bytes because it reached end-of-file, or &lt;a href=&quot;rescode#ioerr_read&quot;&gt;SQLITE_IOERR_READ&lt;/a&gt; for any other error.</source>
          <target state="translated">Метод xRead считывает байты iAmt из файла, начиная с байтового смещения до iOfst. Считанные данные сохраняются в указателе второго параметра. xRead возвращает &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; в случае успеха, &lt;a href=&quot;rescode#ioerr_short_read&quot;&gt;SQLITE_IOERR_SHORT_READ,&lt;/a&gt; если он не смог прочитать полное количество байтов, потому что он достиг конца файла, или &lt;a href=&quot;rescode#ioerr_read&quot;&gt;SQLITE_IOERR_READ&lt;/a&gt; для любой другой ошибки.</target>
        </trans-unit>
        <trans-unit id="179305437ddf972de11f25d6c031548629b7dbeb" translate="yes" xml:space="preserve">
          <source>The xRekey() method is used to change the key value associated with the page passed as the second argument. If the cache previously contains an entry associated with newKey, it must be discarded. Any prior cache entry associated with newKey is guaranteed not to be pinned.</source>
          <target state="translated">Метод xRekey()используется для изменения значения ключа,связанного со страницей,переданной в качестве второго аргумента.Если в кэше ранее содержалась запись,связанная с newKey,то она должна быть отброшена.Любой предыдущий элемент кэша,связанный с newKey,гарантированно не будет пин-кодом.</target>
        </trans-unit>
        <trans-unit id="ee97077a16637439ff4f073f89fa74d3ae66efba" translate="yes" xml:space="preserve">
          <source>The xRename method is optional. If omitted, then the virtual table may not be renamed using the ALTER TABLE RENAME command.</source>
          <target state="translated">Метод xRename не является обязательным.Если его опустить,виртуальная таблица не может быть переименована с помощью команды ALTER TABLE RENAME.</target>
        </trans-unit>
        <trans-unit id="ac1529fc1db9096e5e7532c56994cf7e11a7e7d4" translate="yes" xml:space="preserve">
          <source>The xRoundup method returns what would be the allocated size of a memory allocation given a particular requested size. Most memory allocators round up memory allocations at least to the next multiple of 8. Some allocators round up to a larger multiple or to a power of 2. Every memory allocation request coming in through &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc()&lt;/a&gt; or &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_realloc()&lt;/a&gt; first calls xRoundup. If xRoundup returns 0, that causes the corresponding memory allocation to fail.</source>
          <target state="translated">Метод xRoundup возвращает размер выделенной памяти для конкретного запрошенного размера. Большинство распределителей памяти округляют распределение памяти по крайней мере до следующего кратного 8. Некоторые распределители округляют до большего кратного или до степени 2. Каждый запрос на выделение памяти, поступающий через &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc ()&lt;/a&gt; или &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_realloc (),&lt;/a&gt; сначала вызывает xRoundup. Если xRoundup возвращает 0, это приводит к сбою соответствующего выделения памяти.</target>
        </trans-unit>
        <trans-unit id="5558ee9f292501795b089dc2d3175bf349258bae" translate="yes" xml:space="preserve">
          <source>The xRoundup method returns what would be the allocated size of a memory allocation given a particular requested size. Most memory allocators round up memory allocations at least to the next multiple of 8. Some allocators round up to a larger multiple or to a power of 2. Every memory allocation request coming in through &lt;a href=&quot;free&quot;&gt;sqlite3_malloc()&lt;/a&gt; or &lt;a href=&quot;free&quot;&gt;sqlite3_realloc()&lt;/a&gt; first calls xRoundup. If xRoundup returns 0, that causes the corresponding memory allocation to fail.</source>
          <target state="translated">Метод xRoundup возвращает размер выделенной памяти для конкретного запрошенного размера. Большинство распределителей памяти округляют распределение памяти по крайней мере до следующего кратного 8. Некоторые распределители округляют до большего кратного или до степени 2. Каждый запрос на выделение памяти, поступающий через &lt;a href=&quot;free&quot;&gt;sqlite3_malloc ()&lt;/a&gt; или &lt;a href=&quot;free&quot;&gt;sqlite3_realloc (),&lt;/a&gt; сначала вызывает xRoundup. Если xRoundup возвращает 0, это приводит к сбою соответствующего выделения памяти.</target>
        </trans-unit>
        <trans-unit id="ac776ca96c027496fe8cb024585d72e01e0bde03" translate="yes" xml:space="preserve">
          <source>The xRowid method is required for every virtual table implementation.</source>
          <target state="translated">Метод xRowid требуется для каждой реализации виртуальной таблицы.</target>
        </trans-unit>
        <trans-unit id="f91951a49d3cd2a19053a4c5034726651d8bcc0a" translate="yes" xml:space="preserve">
          <source>The xSectorSize returns the &quot;sector size&quot; of the underlying non-volatile media. A &quot;sector&quot; is defined as the smallest unit of storage that can be written without disturbing adjacent storage. On a disk drive the &quot;sector size&quot; has until recently been 512 bytes, though there is a push to increase this value to 4KiB. SQLite needs to know the sector size so that it can write a full sector at a time, and thus avoid corrupting adjacent storage space if a power loss occurs in the middle of a write.</source>
          <target state="translated">xSectorSize возвращает &quot;размер сектора&quot; подстилающей энергонезависимой среды.Сектор&quot; определяется как наименьшая единица хранения,которая может быть записана без нарушения соседнего хранения.На дисковом накопителе &quot;размер сектора&quot; до недавнего времени составлял 512 байт,хотя существует толчок для увеличения этого значения до 4 КБ.SQLite необходимо знать размер сектора,чтобы иметь возможность записывать полный сектор за раз,и таким образом не повредить соседнее пространство хранения,если в середине записи произойдет отключение питания.</target>
        </trans-unit>
        <trans-unit id="7905596593f9a3650933e2dff7d4278590e16d18" translate="yes" xml:space="preserve">
          <source>The xSectorSize() method returns the sector size of the device that underlies the file. The sector size is the minimum write that can be performed without disturbing other bytes in the file. The xDeviceCharacteristics() method returns a bit vector describing behaviors of the underlying device:</source>
          <target state="translated">Метод xSectorSize()возвращает размер сектора устройства,лежащего в основе файла.Размер сектора-это минимальный размер записи,которую можно выполнить,не мешая другим байтам в файле.Метод xDeviceCharacteristics()возвращает битовый вектор,описывающий поведение лежащего в основе устройства:</target>
        </trans-unit>
        <trans-unit id="c28ec934424705226c30dba3dc7fb3bbb1c98c66" translate="yes" xml:space="preserve">
          <source>The xSetSystemCall(), xGetSystemCall(), and xNestSystemCall() interfaces are not used by the SQLite core. These optional interfaces are provided by some VFSes to facilitate testing of the VFS code. By overriding system calls with functions under its control, a test program can simulate faults and error conditions that would otherwise be difficult or impossible to induce. The set of system calls that can be overridden varies from one VFS to another, and from one version of the same VFS to the next. Applications that use these interfaces must be prepared for any or all of these interfaces to be NULL or for their behavior to change from one release to the next. Applications must not attempt to access any of these methods if the iVersion of the VFS is less than 3.</source>
          <target state="translated">Интерфейсы xSetSystemCall(),xGetSystemCall()и xNestSystemCall()не используются ядром SQLite.Эти дополнительные интерфейсы предоставляются некоторыми VFS для облегчения тестирования кода VFS.Переопределяя системные вызовы с функциями,находящимися под его контролем,тестовая программа может имитировать ошибки и условия возникновения ошибок,которые в противном случае было бы трудно или невозможно вызвать.Набор системных вызовов,которые могут быть переопределены,варьируется от одной VFS к другой,и от одной версии той же VFS к другой.Приложения,использующие эти интерфейсы,должны быть готовы к тому,что любой или все эти интерфейсы будут NULL,или к тому,что их поведение будет меняться от одного выпуска к другому.Приложения не должны пытаться получить доступ к любому из этих методов,если iVersion VFS меньше 3.</target>
        </trans-unit>
        <trans-unit id="5423cabb179d0301d2f1838406af9e345543b685" translate="yes" xml:space="preserve">
          <source>The xShadowName method exists to allow SQLite to determine whether a certain real table is in fact a shadow table for a virtual table.</source>
          <target state="translated">Метод xShadowName существует для того,чтобы SQLite мог определить,является ли на самом деле определенная реальная таблица теневой таблицей для виртуальной.</target>
        </trans-unit>
        <trans-unit id="947c2bf35d5cbfd4ce5579dacd8c602d7123b2d2" translate="yes" xml:space="preserve">
          <source>The xShadowName method returns true when its input is the part of the table name past the last &quot;_&quot; character.</source>
          <target state="translated">Метод xShadowName возвращает true,когда его ввод является частью имени таблицы после последнего символа &quot;_&quot;.</target>
        </trans-unit>
        <trans-unit id="bb9ed2671c0267a52c772896119a40dfbdf41d3e" translate="yes" xml:space="preserve">
          <source>The xShmLock method can transition between unlocked and SHARED or between unlocked and EXCLUSIVE. It cannot transition between SHARED and EXCLUSIVE.</source>
          <target state="translated">Метод xShmLock может переключаться между разблокированным и SHARED или между разблокированным и EXCLUSIVE.Он не может переключаться между SHARED и EXCLUSIVE.</target>
        </trans-unit>
        <trans-unit id="3b138a7b2ca75c6da01e38d919aae9bc4beaeeca" translate="yes" xml:space="preserve">
          <source>The xShmLock method on &lt;a href=&quot;#sqlite3_io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; may use values between 0 and this upper bound as its &quot;offset&quot; argument. The SQLite core will never attempt to acquire or release a lock outside of this range</source>
          <target state="translated">Метод xShmLock в &lt;a href=&quot;#sqlite3_io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; может использовать значения от 0 до этой верхней границы в качестве аргумента &amp;laquo;смещения&amp;raquo;. Ядро SQLite никогда не будет пытаться установить или снять блокировку за пределами этого диапазона.</target>
        </trans-unit>
        <trans-unit id="99e14d7c5dc9f436dda83c4868de4dcfa29aa8e2" translate="yes" xml:space="preserve">
          <source>The xShmLock method on &lt;a href=&quot;io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; may use values between 0 and this upper bound as its &quot;offset&quot; argument. The SQLite core will never attempt to acquire or release a lock outside of this range</source>
          <target state="translated">Метод xShmLock в &lt;a href=&quot;io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; может использовать значения от 0 до этой верхней границы в качестве аргумента &amp;laquo;смещения&amp;raquo;. Ядро SQLite никогда не будет пытаться установить или снять блокировку за пределами этого диапазона.</target>
        </trans-unit>
        <trans-unit id="c9d6171767cbe080777a834fc404f8313c3bd7a0" translate="yes" xml:space="preserve">
          <source>The xShutdown() method is called by &lt;a href=&quot;#sqlite3_initialize&quot; id=&quot;thexshutdownpagecachemethod&quot;&gt;sqlite3_shutdown()&lt;/a&gt;. It can be used to clean up any outstanding resources before process shutdown, if required. The xShutdown() method may be NULL.</source>
          <target state="translated">Метод xShutdown () вызывается &lt;a href=&quot;#sqlite3_initialize&quot; id=&quot;thexshutdownpagecachemethod&quot;&gt;sqlite3_shutdown ()&lt;/a&gt; . При необходимости его можно использовать для очистки любых невыполненных ресурсов перед остановкой процесса. Метод xShutdown () может иметь значение NULL.</target>
        </trans-unit>
        <trans-unit id="89b517d093efdb5642222dcbac94dd78a355996a" translate="yes" xml:space="preserve">
          <source>The xShutdown() method is called by &lt;a href=&quot;initialize&quot; id=&quot;thexshutdownpagecachemethod&quot;&gt;sqlite3_shutdown()&lt;/a&gt;. It can be used to clean up any outstanding resources before process shutdown, if required. The xShutdown() method may be NULL.</source>
          <target state="translated">Метод xShutdown () вызывается &lt;a href=&quot;initialize&quot; id=&quot;thexshutdownpagecachemethod&quot;&gt;sqlite3_shutdown ()&lt;/a&gt; . При необходимости его можно использовать для очистки любых невыполненных ресурсов перед остановкой процесса. Метод xShutdown () может иметь значение NULL.</target>
        </trans-unit>
        <trans-unit id="809b6a168241db65edee19e686edd4e9bd3b2bfa" translate="yes" xml:space="preserve">
          <source>The xSleep method is used to suspend the calling thread for at least the number of microseconds given. This method is used to implement the &lt;a href=&quot;c3ref/sleep&quot;&gt;sqlite3_sleep()&lt;/a&gt; and &lt;a href=&quot;c3ref/busy_timeout&quot;&gt;sqlite3_busy_timeout()&lt;/a&gt; APIs. In the case of &lt;a href=&quot;c3ref/sleep&quot;&gt;sqlite3_sleep()&lt;/a&gt; the xSleep method of the default VFS is always used. If the underlying system does not have a microsecond resolution sleep capability, then the sleep time should be rounded up. xSleep returns this rounded-up value.</source>
          <target state="translated">Метод xSleep используется для приостановки вызывающего потока по крайней мере на указанное количество микросекунд. Этот метод используется для реализации API &lt;a href=&quot;c3ref/sleep&quot;&gt;sqlite3_sleep ()&lt;/a&gt; и &lt;a href=&quot;c3ref/busy_timeout&quot;&gt;sqlite3_busy_timeout ()&lt;/a&gt; . В случае &lt;a href=&quot;c3ref/sleep&quot;&gt;sqlite3_sleep ()&lt;/a&gt; всегда используется метод xSleep VFS по умолчанию. Если базовая система не имеет возможности сна с разрешением в микросекунды, время сна следует округлить в большую сторону. xSleep возвращает это округленное значение.</target>
        </trans-unit>
        <trans-unit id="097b3f659c15f2c222834063189d1813c9097500" translate="yes" xml:space="preserve">
          <source>The xSync method is called again, to ensure that the update to the</source>
          <target state="translated">Метод xSync вызывается снова,чтобы убедиться в том,что обновление для</target>
        </trans-unit>
        <trans-unit id="c43866c10fb70246bff455fcc260272ec7695054" translate="yes" xml:space="preserve">
          <source>The xSync method is used to force previously written data out of operating system cache and into non-volatile memory. The second parameter is usually &lt;a href=&quot;c3ref/c_sync_dataonly&quot;&gt;SQLITE_SYNC_NORMAL&lt;/a&gt;. If the second parameter is &lt;a href=&quot;c3ref/c_sync_dataonly&quot;&gt;SQLITE_SYNC_FULL&lt;/a&gt; then the xSync method should make sure that data has also been flushed through the disk controllers cache. The &lt;a href=&quot;c3ref/c_sync_dataonly&quot;&gt;SQLITE_SYNC_FULL&lt;/a&gt; parameter is the equivalent of the F_FULLSYNC ioctl() on Mac OS X. The xSync method returns &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; on success and &lt;a href=&quot;rescode#ioerr_fsync&quot;&gt;SQLITE_IOERR_FSYNC&lt;/a&gt; if anything goes wrong.</source>
          <target state="translated">Метод xSync используется для принудительного удаления ранее записанных данных из кеша операционной системы в энергонезависимую память. Второй параметр обычно - &lt;a href=&quot;c3ref/c_sync_dataonly&quot;&gt;SQLITE_SYNC_NORMAL&lt;/a&gt; . Если вторым параметром является &lt;a href=&quot;c3ref/c_sync_dataonly&quot;&gt;SQLITE_SYNC_FULL,&lt;/a&gt; тогда метод xSync должен убедиться, что данные также были сброшены через кеш дисковых контроллеров. Параметр &lt;a href=&quot;c3ref/c_sync_dataonly&quot;&gt;SQLITE_SYNC_FULL&lt;/a&gt; является эквивалентом F_FULLSYNC ioctl () в Mac OS X. Метод xSync возвращает &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; в случае успеха и &lt;a href=&quot;rescode#ioerr_fsync&quot;&gt;SQLITE_IOERR_FSYNC,&lt;/a&gt; если что-то пойдет не так.</target>
        </trans-unit>
        <trans-unit id="d363e92ec2dbc091f6f79c8b02f677c3bfbb4dc4" translate="yes" xml:space="preserve">
          <source>The xSync method of the file-handle opened on the journal file is called. This operation ensures that all</source>
          <target state="translated">Вызывается метод xSync файл-ручка,открытая на файле журнала.Эта операция гарантирует,что все</target>
        </trans-unit>
        <trans-unit id="2abc7e1d2661195eacab3734a083049181c96938" translate="yes" xml:space="preserve">
          <source>The xTruncate method truncates a file to be nByte bytes in length. If the file is already nByte bytes or less in length then this method is a no-op. The xTruncate method returns &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; on success and &lt;a href=&quot;rescode#ioerr_truncate&quot;&gt;SQLITE_IOERR_TRUNCATE&lt;/a&gt; if anything goes wrong.</source>
          <target state="translated">Метод xTruncate обрезает файл до размера nByte байтов. Если размер файла уже равен nByte или меньше байтов, то этот метод не работает. Метод xTruncate возвращает &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; в случае успеха и &lt;a href=&quot;rescode#ioerr_truncate&quot;&gt;SQLITE_IOERR_TRUNCATE,&lt;/a&gt; если что-то пойдет не так.</target>
        </trans-unit>
        <trans-unit id="264cd9fc05e84b4a4186bdf81ed3b9dddd14f364" translate="yes" xml:space="preserve">
          <source>The xUpdate method is optional. If the xUpdate pointer in the &lt;a href=&quot;c3ref/module&quot;&gt;sqlite3_module&lt;/a&gt; for a virtual table is a NULL pointer, then the virtual table is read-only.</source>
          <target state="translated">Метод xUpdate не является обязательным. Если указатель xUpdate в модуле &lt;a href=&quot;c3ref/module&quot;&gt;sqlite3_module&lt;/a&gt; для виртуальной таблицы является указателем NULL, тогда виртуальная таблица доступна только для чтения.</target>
        </trans-unit>
        <trans-unit id="e7991b9300a6d5d1e9dd517f980e91bd729b810d" translate="yes" xml:space="preserve">
          <source>The xUpdate method must return &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; if and only if it is successful. If a failure occurs, the xUpdate must return an appropriate &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt;. On a failure, the pVTab-&amp;gt;zErrMsg element may optionally be replaced with error message text stored in memory allocated from SQLite using functions such as &lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_mprintf()&lt;/a&gt; or &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc()&lt;/a&gt;.</source>
          <target state="translated">Метод xUpdate должен возвращать &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; тогда и только тогда, когда он успешен. В случае сбоя xUpdate должен вернуть соответствующий &lt;a href=&quot;rescode&quot;&gt;код ошибки&lt;/a&gt; . В случае сбоя элемент pVTab-&amp;gt; zErrMsg можно дополнительно заменить текстом сообщения об ошибке, хранящимся в памяти, выделенной из SQLite, с использованием таких функций, как &lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_mprintf ()&lt;/a&gt; или &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4f4c20f5295bf2671dba3e7fbec564fd71238ee3" translate="yes" xml:space="preserve">
          <source>The xUpdate method will do a DELETE or an INSERT or both. The argv[0] element (which corresponds to memory cell P3) is the rowid of a row to delete. If argv[0] is NULL then no deletion occurs. The argv[1] element is the rowid of the new row. This can be NULL to have the virtual table select the new rowid for itself. The subsequent elements in the array are the values of columns in the new row.</source>
          <target state="translated">Метод xUpdate сделает УДАЛЕНИЕ или ИНСЕРТ,или и то,и другое.Элемент argv[0](который соответствует ячейке памяти P3)является rowid строки для удаления.Если argv[0]равен NULL,то удаление не происходит.Элемент argv[1]является штрихкодом новой строки.Это может быть NULL,чтобы виртуальная таблица сама выбирала новый rowid.Последующие элементы в массиве являются значениями столбцов в новой строке.</target>
        </trans-unit>
        <trans-unit id="dce6593181b88387e0232c4fe3315ea114b78c31" translate="yes" xml:space="preserve">
          <source>The xWrite method writes iAmt bytes of data from the second parameter into the file beginning at an offset of iOfst bytes. If the size of the file is less than iOfst bytes prior to the write, then xWrite should ensure that the file is extended with zeros up to iOfst bytes prior to beginning its write. xWrite continues to extends the file as necessary so that the size of the file is at least iAmt+iOfst bytes at the conclusion of the xWrite call. The xWrite method returns &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; on success. If the write cannot complete because the underlying storage medium is full, then &lt;a href=&quot;rescode#full&quot;&gt;SQLITE_FULL&lt;/a&gt; is returned. &lt;a href=&quot;rescode#ioerr_write&quot;&gt;SQLITE_IOERR_WRITE&lt;/a&gt; should be returned for any other error.</source>
          <target state="translated">Метод xWrite записывает байты iAmt данных из второго параметра в файл, начиная со смещения iOfst байтов. Если размер файла меньше iOfst байтов до записи, то xWrite должен гарантировать, что файл расширен нулями до iOfst байтов до начала записи. xWrite продолжает расширять файл по мере необходимости, так что размер файла составляет не менее iAmt + iOfst байт в конце вызова xWrite. В случае успеха метод xWrite возвращает &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; . Если запись не может быть завершена из-за того, что нижележащий носитель данных заполнен, возвращается &lt;a href=&quot;rescode#full&quot;&gt;SQLITE_FULL&lt;/a&gt; . &lt;a href=&quot;rescode#ioerr_write&quot;&gt;SQLITE_IOERR_WRITE&lt;/a&gt; должен быть возвращен для любой другой ошибки.</target>
        </trans-unit>
        <trans-unit id="d58a45ae0f446bdb86db23efea40a4365e8b2411" translate="yes" xml:space="preserve">
          <source>The zFormat string must not be NULL.</source>
          <target state="translated">Строка zFormat не должна быть NULL.</target>
        </trans-unit>
        <trans-unit id="4f80fc797d2d3e861743d9ee1212caa09c71f3bc" translate="yes" xml:space="preserve">
          <source>The zName field holds the name of the VFS module. The name must be unique across all VFS modules.</source>
          <target state="translated">В поле zName содержится имя модуля VFS.Имя должно быть уникальным для всех модулей VFS.</target>
        </trans-unit>
        <trans-unit id="2e8507d62c194c1ae3ea2e8955ca09d80822bd5b" translate="yes" xml:space="preserve">
          <source>The zName field is the symbolic name of the VFS. This is the name that the &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_find()&lt;/a&gt; compares against when it is looking for a VFS.</source>
          <target state="translated">Поле zName - это символическое имя VFS. Это имя, с которым &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_find ()&lt;/a&gt; сравнивает, когда ищет VFS.</target>
        </trans-unit>
        <trans-unit id="159171a13f5482b6256b050c73e581c3c1ed7fde" translate="yes" xml:space="preserve">
          <source>The zeroblob(N) function returns a BLOB consisting of N bytes of 0x00. SQLite manages these zeroblobs very efficiently. Zeroblobs can be used to reserve space for a BLOB that is later written using &lt;a href=&quot;c3ref/blob_open&quot;&gt;incremental BLOB I/O&lt;/a&gt;. This SQL function is implemented using the &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_zeroblob()&lt;/a&gt; routine from the C/C++ interface.</source>
          <target state="translated">Функция zeroblob (N) возвращает большой двоичный объект, состоящий из N байтов размером 0x00. SQLite очень эффективно управляет этими нулевыми шарами. Нулевые двоичные объекты можно использовать для резервирования места для больших двоичных объектов, которые позже записываются с использованием &lt;a href=&quot;c3ref/blob_open&quot;&gt;инкрементного ввода-вывода&lt;/a&gt; больших двоичных объектов . Эта функция SQL реализована с помощью процедуры &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_zeroblob ()&lt;/a&gt; из интерфейса C / C ++.</target>
        </trans-unit>
        <trans-unit id="211680c2a7f3cd39edd65730ba2dc5798231d4d2" translate="yes" xml:space="preserve">
          <source>The zipfile module provides read/write access to simple &lt;a href=&quot;https://en.wikipedia.org/wiki/Zip_%28file_format%29&quot;&gt;ZIP archives&lt;/a&gt;. The current implementation has the following restrictions:</source>
          <target state="translated">Модуль zipfile обеспечивает доступ для чтения / записи к простым &lt;a href=&quot;https://en.wikipedia.org/wiki/Zip_%28file_format%29&quot;&gt;архивам ZIP&lt;/a&gt; . Текущая реализация имеет следующие ограничения:</target>
        </trans-unit>
        <trans-unit id="1b7b70776cb9a79f5d42a047fb481e44592ef0cc" translate="yes" xml:space="preserve">
          <source>The zipfile module provides three similar interfaces for accessing, updating and creating zip file archives:</source>
          <target state="translated">Модуль zip-файлов предоставляет три похожих интерфейса для доступа,обновления и создания zip-архивов:</target>
        </trans-unit>
        <trans-unit id="a3bf102cd7b1098b918321543923b0fbcf9afd25" translate="yes" xml:space="preserve">
          <source>The zipfile module provides two similar interfaces for accessing zip archives. A table-valued function, which provides read-only access to existing archives, and a virtual table interface, which provides both read and write access.</source>
          <target state="translated">Модуль zip-архивов предоставляет два одинаковых интерфейса для доступа к zip-архивам.Функция табличной оценки,обеспечивающая доступ только на чтение к существующим архивам,и виртуальный табличный интерфейс,обеспечивающий доступ как на чтение,так и на запись.</target>
        </trans-unit>
        <trans-unit id="7f26831f509249abeae6c04bd252c7253425a19e" translate="yes" xml:space="preserve">
          <source>The zipfile() aggregate function may be called with 2, 4 or 5 arguments. If it is called with 5 arguments, then the entry added to the archive is equivalent to inserting the same values into the &quot;name&quot;, &quot;mode&quot;, &quot;mtime&quot;, &quot;data&quot; and &quot;method&quot; columns of a zipfile virtual table.</source>
          <target state="translated">Функция агрегата zipfile()может быть вызвана с 2,4 или 5 аргументами.Если она вызывается с 5 аргументами,то добавляемая в архив запись эквивалентна вставке тех же значений в столбцы &quot;имя&quot;,&quot;режим&quot;,&quot;mtime&quot;,&quot;данные&quot; и &quot;метод&quot; виртуальной zip-таблицы.</target>
        </trans-unit>
        <trans-unit id="fda3c54068d6592ac94595a28e9ae2b5a7631d94" translate="yes" xml:space="preserve">
          <source>Then any query that uses operators =, &amp;lt;, &amp;gt;, &amp;lt;=, &amp;gt;=, &amp;lt;&amp;gt;, IN, LIKE, or GLOB on column &quot;c&quot; would be usable with the partial index because those comparison operators are only true if &quot;c&quot; is not NULL. So the following query could use the partial index:</source>
          <target state="translated">Тогда любой запрос, в котором используются операторы =, &amp;lt;,&amp;gt;, &amp;lt;=,&amp;gt; =, &amp;lt;&amp;gt;, IN, LIKE или GLOB в столбце &amp;laquo;c&amp;raquo;, можно будет использовать с частичным индексом, поскольку эти операторы сравнения верны только в том случае, если &amp;laquo;c&amp;raquo; не NULL. Таким образом, следующий запрос может использовать частичный индекс:</target>
        </trans-unit>
        <trans-unit id="d38e46789e87cb85236cff516beec8a98a69642c" translate="yes" xml:space="preserve">
          <source>Then continue to merge the changes in &quot;trunk&quot; with your &quot;private&quot; changes as described in section 3.7.</source>
          <target state="translated">Затем продолжайте объединять изменения в &quot;багажнике&quot; со своими &quot;личными&quot; изменениями,как описано в разделе 3.7.</target>
        </trans-unit>
        <trans-unit id="4221ef1a5952683847cd93186bb995482d485923" translate="yes" xml:space="preserve">
          <source>Then creating &lt;a href=&quot;lang_createview&quot;&gt;VIEWs&lt;/a&gt; in that schema that implement the official information schema tables using table-valued PRAGMA functions.</source>
          <target state="translated">Затем создание &lt;a href=&quot;lang_createview&quot;&gt;представлений&lt;/a&gt; в этой схеме, которые реализуют таблицы схемы официальной информации с использованием возвращающих табличное значение функций PRAGMA.</target>
        </trans-unit>
        <trans-unit id="24143dcd35d1fb5f0ef327aba489cfb57e18e5f5" translate="yes" xml:space="preserve">
          <source>Then download the new version of the SQLite sources and overwrite the files that are in the checkout.</source>
          <target state="translated">Затем загрузите новую версию исходников SQLite и перезапишите файлы,которые находятся на кассе.</target>
        </trans-unit>
        <trans-unit id="350d0a66ff74448747b37fd69238737bb7294306" translate="yes" xml:space="preserve">
          <source>Then either of the two queries below may be executed to find the number of documents in the database that contain the word &quot;linux&quot; (351). Using one desktop PC hardware configuration, the query on the FTS3 table returns in approximately 0.03 seconds, versus 22.5 for querying the ordinary table.</source>
          <target state="translated">Затем можно выполнить любой из двух нижеперечисленных запросов,чтобы найти в базе данных количество документов,содержащих слово &quot;linux&quot; (351).При использовании конфигурации аппаратного обеспечения одного настольного ПК запрос к таблице FTS3 возвращается примерно за 0.03 секунды по сравнению с 22.5 для запроса к обычной таблице.</target>
        </trans-unit>
        <trans-unit id="dec93deaca5432fc2b3655d16d3eb7b184d40788" translate="yes" xml:space="preserve">
          <source>Then for each &quot;id&quot; value returned, suppose the application creates an UPDATE statement like the following and binds the &quot;id&quot; value returned against the &quot;?1&quot; parameter:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b72f2d807bd1572c917e30647dff75353e7ffc89" translate="yes" xml:space="preserve">
          <source>Then let the application maintain a separate pool of larger lookaside memory buffers that it can distribute to &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt; as they are created. In the common case, the application will only have a single &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; and so the lookaside memory pool can consist of a single large buffer.</source>
          <target state="translated">Затем позвольте приложению поддерживать отдельный пул более крупных буферов внешней памяти, которые оно может распределять по &lt;a href=&quot;c3ref/sqlite3&quot;&gt;соединениям&lt;/a&gt; с базой данных по мере их создания. В общем случае приложение будет иметь только одно &lt;a href=&quot;c3ref/sqlite3&quot;&gt;соединение с базой данных,&lt;/a&gt; поэтому резервный пул памяти может состоять из одного большого буфера.</target>
        </trans-unit>
        <trans-unit id="e376e98c10da73b25d2ab9a479ff86c1a4e0ab3c" translate="yes" xml:space="preserve">
          <source>Then no rows are returned. SQLite knows that the t1.b column actually holds a 7-character string, and the 7-character string 'abc'||char(0)||'xyz' is not equal to the 3-character string 'abc', and so no rows are returned. But a user might be easily confused by this because the &lt;a href=&quot;cli&quot;&gt;CLI&lt;/a&gt; output seems to show that the string has only 3 characters. This seems like a bug. But it is how SQLite works.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13bc76c23a2d1597cb4fa248a96e4ed2a6339b15" translate="yes" xml:space="preserve">
          <source>Then one of the constraints would be on the &quot;a&quot; column with operator &quot;=&quot; and an expression of &quot;5&quot;. Constraints need not have a literal representation of the WHERE clause. The query optimizer might make transformations to the WHERE clause in order to extract as many constraints as it can. So, for example, if the WHERE clause contained something like this:</source>
          <target state="translated">Тогда одно из ограничений будет на столбце &quot;a&quot; с оператором &quot;=&quot; и выражением &quot;5&quot;.Ограничения не обязательно должны иметь буквальное представление пункта WHERE.Оптимизатор запроса может выполнить преобразования к выражению WHERE,чтобы извлечь как можно больше ограничений.Так,например,если выражение WHERE содержало нечто подобное:</target>
        </trans-unit>
        <trans-unit id="a6d85a4cee37097aa0048aa17c7e903390d7845d" translate="yes" xml:space="preserve">
          <source>Then run &quot;sh speed-check.sh trunk&quot;.</source>
          <target state="translated">Затем запустите &quot;sh speed-check.sh trunk&quot;.</target>
        </trans-unit>
        <trans-unit id="5af7ca0994a03bba6845a3d09f85ba03527c6bbf" translate="yes" xml:space="preserve">
          <source>Then that term is rewritten as follows:</source>
          <target state="translated">Затем этот термин переписывается следующим образом:</target>
        </trans-unit>
        <trans-unit id="89cb6c0dfe329a7ee49493775fd34d7651a1097e" translate="yes" xml:space="preserve">
          <source>Then the LIKE operator pays attention to case and the example above would evaluate to false. Note that case insensitivity only applies to latin1 characters - basically the upper and lower case letters of English in the lower 127 byte codes of ASCII. International character sets are case sensitive in SQLite unless an application-defined &lt;a href=&quot;datatype3#collation&quot;&gt;collating sequence&lt;/a&gt; and &lt;a href=&quot;lang_corefunc#like&quot;&gt;like() SQL function&lt;/a&gt; are provided that take non-ASCII characters into account. But if an application-defined collating sequence and/or like() SQL function are provided, the LIKE optimization described here will never be taken.</source>
          <target state="translated">Затем оператор LIKE обращает внимание на регистр, и приведенный выше пример оценивается как false. Обратите внимание, что нечувствительность к регистру применяется только к символам latin1 - в основном к верхним и нижним буквам английского языка в нижних 127-байтовых кодах ASCII. Международные наборы символов чувствительны к регистру в SQLite, если не предусмотрена определяемая приложением &lt;a href=&quot;datatype3#collation&quot;&gt;последовательность сортировки&lt;/a&gt; и &lt;a href=&quot;lang_corefunc#like&quot;&gt;функция SQL like ()&lt;/a&gt; , которая учитывает символы, отличные от ASCII. Но если предоставляется определяемая приложением последовательность сортировки и / или функция SQL like (), описанная здесь оптимизация LIKE никогда не будет выполняться.</target>
        </trans-unit>
        <trans-unit id="be60a7454a5a8c066c86b3ca9b68995e4f6f1ddf" translate="yes" xml:space="preserve">
          <source>Then the RBU database should contain:</source>
          <target state="translated">Тогда база данных RBU должна содержать:</target>
        </trans-unit>
        <trans-unit id="afb35789040d9830a99208d5f4ddcf476245eb59" translate="yes" xml:space="preserve">
          <source>Then the UPDATE might fail with an SQLITE_LOCKED error. The reason is that the initial query has not run to completion. It is remembering its place in the middle of a scan of the R-Tree. So an update to the R-Tree cannot be tolerated as this would disrupt the scan.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="996a8ef99f82edf5bb93411418cadd30d4e95347" translate="yes" xml:space="preserve">
          <source>Then the generated SQL will look like the following:</source>
          <target state="translated">Тогда сгенерированный SQL будет выглядеть следующим образом:</target>
        </trans-unit>
        <trans-unit id="0e329a491713b53943766e19e0cd3bc2370d4353" translate="yes" xml:space="preserve">
          <source>Then the index is usable by the query because the &quot;b=6&quot; term appears in both the index definition and in the query. Remember: terms in the index should be OR-connected and terms in the query should be AND-connected.</source>
          <target state="translated">Тогда индекс можно использовать по запросу,потому что термин &quot;b=6&quot; появляется и в определении индекса,и в запросе.Помните:термины в индексе должны быть ИЛИ связаны,а термины в запросе должны быть ИЛИ связаны.</target>
        </trans-unit>
        <trans-unit id="2efe4248a37f7b9e147bfa69326ac21ae4833059" translate="yes" xml:space="preserve">
          <source>Then the index might be used if the initial columns of the index (columns a, b, and so forth) appear in WHERE clause terms. The initial columns of the index must be used with the *=* or *IN* or *IS* operators. The right-most column that is used can employ inequalities. For the right-most column of an index that is used, there can be up to two inequalities that must sandwich the allowed values of the column between two extremes.</source>
          <target state="translated">Тогда индекс может быть использован,если начальные столбцы индекса (столбцы a,b и т.д.)появляются в условиях пункта ГДЕ.Начальные колонки индекса должны использоваться с операторами *=*или *IN*или *IS*.В самом правом столбце могут использоваться неравенства.Для самого правого столбца используемого индекса может быть до двух неравенств,которые должны смешивать допустимые значения столбца между двумя крайними точками.</target>
        </trans-unit>
        <trans-unit id="f563dfd5bcb7f2cd99d04f3adadee6fc2e0e90d8" translate="yes" xml:space="preserve">
          <source>Then the index will &lt;u&gt;not&lt;/u&gt; be used because the expression on the CREATE INDEX statement (x+y) is not the same as the expression as it appears in the query (y+x). The two expressions might be mathematically equivalent, but the SQLite query planner insists that they be the same, not merely equivalent. Consider rewriting the query thusly:</source>
          <target state="translated">Тогда индекс &lt;u&gt;не&lt;/u&gt; будет использоваться, потому что выражение в операторе CREATE INDEX (x + y) не совпадает с выражением, указанным в запросе (y + x). Эти два выражения могут быть математически эквивалентными, но планировщик запросов SQLite настаивает на том, чтобы они были одинаковыми, а не просто эквивалентными. Попробуйте переписать запрос следующим образом:</target>
        </trans-unit>
        <trans-unit id="faa0b455785c0547f03cc054aee1b96482863f25" translate="yes" xml:space="preserve">
          <source>Then the locking mode applies only to the named database. If no database name qualifier precedes the &quot;locking_mode&quot; keyword then the locking mode is applied to all databases, including any new databases added by subsequent &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; commands.</source>
          <target state="translated">Тогда режим блокировки применяется только к указанной базе данных. Если квалификатор имени базы данных не предшествует ключевому слову &amp;laquo;lock_mode&amp;raquo;, то режим блокировки применяется ко всем базам данных, включая любые новые базы данных, добавленные последующими командами &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2ace62cf521cfc04b47d7dad558287516162d423" translate="yes" xml:space="preserve">
          <source>Then the virtual table would be created with two hidden columns, and with datatypes of &quot;VARCHAR(12)&quot; and &quot;INTEGER&quot;.</source>
          <target state="translated">Затем будет создана виртуальная таблица с двумя скрытыми столбцами,а также с типами данных &quot;VARCHAR(12)&quot; и &quot;INTEGER&quot;.</target>
        </trans-unit>
        <trans-unit id="b398879a2efe1c2e2e8691470971432fd8ac7954" translate="yes" xml:space="preserve">
          <source>Then to read the first page of that database file, one merely runs:</source>
          <target state="translated">Затем,чтобы прочитать первую страницу этого файла базы данных,достаточно просто запустить его:</target>
        </trans-unit>
        <trans-unit id="9a0f2cc8cc7905afb88e588449e50b02e607b774" translate="yes" xml:space="preserve">
          <source>Then two &quot;virtual&quot; terms are added as follows:</source>
          <target state="translated">Затем добавляются два &quot;виртуальных&quot; термина следующим образом:</target>
        </trans-unit>
        <trans-unit id="ca7fe30da623ecbcc16dc68b6763c7b9a4af11d0" translate="yes" xml:space="preserve">
          <source>Then use the &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_XXXX()&lt;/a&gt; functions to bind your large string values to the SQL statement. The use of binding obviates the need to escape quote characters in the string, reducing the risk of SQL injection attacks. It also runs faster since the large string does not need to be parsed or copied as much.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d3ddffeb2cfef8ef81678864135303a52c1015f" translate="yes" xml:space="preserve">
          <source>Then use the &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_XXXX()&lt;/a&gt; functions to bind your large string values to the SQL statement. The use of binding obviates the need to escape quote characters in the string, reducing the risk of SQL injection attacks. It is also runs faster since the large string does not need to be parsed or copied as much.</source>
          <target state="translated">Затем используйте функции &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_XXXX (),&lt;/a&gt; чтобы привязать большие строковые значения к оператору SQL. Использование привязки устраняет необходимость экранирования кавычек в строке, снижая риск атак с использованием SQL-инъекций. Кроме того, он работает быстрее, поскольку большую строку не нужно так много анализировать или копировать.</target>
        </trans-unit>
        <trans-unit id="265606c9637ac4024a4237e1919b8d5a2a194605" translate="yes" xml:space="preserve">
          <source>Then, love your neighbor as yourself.</source>
          <target state="translated">Тогда люби ближнего,как самого себя.</target>
        </trans-unit>
        <trans-unit id="aaba5b69e34e258d19f535d62804a66ddc861cc0" translate="yes" xml:space="preserve">
          <source>Then, when the application attempts to open the database, register the system() function, then run an innocent query against the &quot;tab1&quot; table, it instead deletes all the files in its working directory. Yikes!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cfbc622cd136a62d323c5b8bab5c8bc5876d69e" translate="yes" xml:space="preserve">
          <source>There are &lt;a href=&quot;vtablist&quot;&gt;many other virtual table implementations&lt;/a&gt; in the SQLite source tree that can be used as examples. Locate these other virtual table implementations by searching for &quot;sqlite3_create_module&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf0cc9442c93b87173641af3ce48fe6ba6a56819" translate="yes" xml:space="preserve">
          <source>There are U or more such b-trees on a single level (see the documentation for the &lt;a href=&quot;fts5#the_automerge_configuration_option&quot;&gt;FTS5 automerge option&lt;/a&gt; for an explanation of b-tree levels), where U is the value assigned to the &lt;a href=&quot;fts5#the_usermerge_configuration_option&quot;&gt;FTS5 usermerge option&lt;/a&gt; option.</source>
          <target state="translated">На одном уровне существует U или более таких b-деревьев (см. Документацию по &lt;a href=&quot;fts5#the_automerge_configuration_option&quot;&gt;опции автоматического слияния FTS5&lt;/a&gt; для объяснения уровней b-дерева), где U - значение, присвоенное &lt;a href=&quot;fts5#the_usermerge_configuration_option&quot;&gt;опции&lt;/a&gt; опции FTS5 usermerge .</target>
        </trans-unit>
        <trans-unit id="fd10b08d9cff8fbc86ae03afd572ce0a4529a480" translate="yes" xml:space="preserve">
          <source>There are advantages and disadvantages to being serverless. The main advantage is that there is no separate server process to install, setup, configure, initialize, manage, and troubleshoot. This is one reason why SQLite is a &quot;&lt;a href=&quot;zeroconf&quot;&gt;zero-configuration&lt;/a&gt;&quot; database engine. Programs that use SQLite require no administrative support for setting up the database engine before they are run. Any program that is able to access the disk is able to use an SQLite database.</source>
          <target state="translated">У бессерверного режима есть свои преимущества и недостатки. Главное преимущество заключается в том, что нет отдельного серверного процесса для установки, настройки, настройки, инициализации, управления и устранения неполадок. Это одна из причин, почему SQLite является ядром базы данных с &lt;a href=&quot;zeroconf&quot;&gt;нулевой конфигурацией&lt;/a&gt; . Программы, использующие SQLite, не требуют административной поддержки для настройки ядра базы данных перед запуском. Любая программа, имеющая доступ к диску, может использовать базу данных SQLite.</target>
        </trans-unit>
        <trans-unit id="9e47d4a7ae3779b3ce3872907368c2ebe6ca93d1" translate="yes" xml:space="preserve">
          <source>There are advantages and disadvantages to being serverless. The main advantage is that there is no separate server process to install, setup, configure, initialize, manage, and troubleshoot. This is one reason why SQLite is a &quot;zero-configuration&quot; database engine. Programs that use SQLite require no administrative support for setting up the database engine before they are run. Any program that is able to access the disk is able to use an SQLite database.</source>
          <target state="translated">Есть преимущества и недостатки безсерверной работы.Основным преимуществом является отсутствие отдельного серверного процесса для установки,настройки,конфигурирования,инициализации,управления и поиска неисправностей.Это одна из причин,по которой SQLite является движком баз данных &quot;нулевой конфигурации&quot;.Программы,использующие SQLite,не требуют никакой административной поддержки для настройки движка баз данных перед их запуском.Любая программа,имеющая доступ к диску,может использовать базу данных SQLite.</target>
        </trans-unit>
        <trans-unit id="a00099ff32dd16c72c3ea081a513584d8f3c38e0" translate="yes" xml:space="preserve">
          <source>There are advantages and disadvantages to using WAL instead of a rollback journal. Advantages include:</source>
          <target state="translated">Существуют преимущества и недостатки использования WAL вместо журнала отката.Преимущества включают в себя:</target>
        </trans-unit>
        <trans-unit id="3093b427039bbfacae2cf7cc0c20cdff14795a5c" translate="yes" xml:space="preserve">
          <source>There are advantages and disadvantages to using memory-mapped I/O. Advantages include:</source>
          <target state="translated">Существуют преимущества и недостатки использования ввода/вывода с отображением на карте памяти.Преимущества включают в себя:</target>
        </trans-unit>
        <trans-unit id="79bd071128837bce919057f74da96b8e84ac063f" translate="yes" xml:space="preserve">
          <source>There are certain reasonable restrictions on expressions that appear in CREATE INDEX statements:</source>
          <target state="translated">Существуют определенные разумные ограничения на выражения,которые появляются в утверждениях CREATE INDEX:</target>
        </trans-unit>
        <trans-unit id="0440cacf20ea4b02e6a0db0e8999f07d0748bd04" translate="yes" xml:space="preserve">
          <source>There are compile-time options that will set upper bounds on the sizes of various structures in SQLite. The compile-time options normally set a hard upper bound that can be changed at run-time on individual &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt; using the &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit()&lt;/a&gt; interface.</source>
          <target state="translated">Существуют параметры времени компиляции, которые устанавливают верхние границы размеров различных структур в SQLite. Параметры времени компиляции обычно устанавливают жесткую верхнюю границу, которая может быть изменена во время выполнения для отдельных &lt;a href=&quot;c3ref/sqlite3&quot;&gt;подключений к базе данных&lt;/a&gt; с помощью интерфейса &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5db06d3cdfac9a23d2859adb4baf70db2e25be47" translate="yes" xml:space="preserve">
          <source>There are currently 170 opcodes defined by the virtual machine. All currently defined opcodes are described in the table below. This table was generated automatically by scanning the source code from the file &lt;a href=&quot;http://www.sqlite.org/src/artifact/da4030a71acf42be18001b9b7067d6d34ffb76610603ce6fafa52854b9e52936&quot;&gt;vdbe.c&lt;/a&gt;.</source>
          <target state="translated">В настоящее время виртуальная машина определяет 170 кодов операций. Все определенные в настоящее время коды операций описаны в таблице ниже. Эта таблица была сгенерирована автоматически путем сканирования исходного кода из файла &lt;a href=&quot;http://www.sqlite.org/src/artifact/da4030a71acf42be18001b9b7067d6d34ffb76610603ce6fafa52854b9e52936&quot;&gt;vdbe.c&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3d151e494351273cc5176bb466ee794220518dba" translate="yes" xml:space="preserve">
          <source>There are currently 175 opcodes defined by the virtual machine. All currently defined opcodes are described in the table below. This table was generated automatically by scanning the source code from the file &lt;a href=&quot;http://www.sqlite.org/src/artifact/e9f7f818f128c8600058c0eabb6b3975974c95153a104d340f419adabbc15b9f&quot;&gt;vdbe.c&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f94a164918f438c0d1173d53f7a4f94c08b35d7" translate="yes" xml:space="preserve">
          <source>There are currently the following configuration options:</source>
          <target state="translated">В настоящее время существуют следующие варианты конфигурации:</target>
        </trans-unit>
        <trans-unit id="3c95acf82c00de5d5751bda48036e2a0038274e3" translate="yes" xml:space="preserve">
          <source>There are details to fill in here. Perhaps a screen can be provided that displays a history changes (perhaps with a graph) allowing the user to select which version they want to view or edit. Perhaps some facility can be provided to merge forks that might occur in the version history. And perhaps the application should provide a means to purge old and unwanted versions. The key point is that using an SQLite database to store the content, rather than a ZIP archive, makes all of these features much, much easier to implement, which increases the possibility that they will eventually get implemented.</source>
          <target state="translated">Здесь есть подробности,которые нужно заполнить.Возможно,можно предусмотреть экран,на котором будет отображаться история изменений (возможно,с графиком),позволяющий пользователю выбрать,какую версию он хочет просмотреть или отредактировать.Возможно,будет предоставлена возможность объединить вилки,которые могут встречаться в истории версий.И,возможно,приложение должно предоставлять средства для очистки старых и нежелательных версий.Ключевым моментом является то,что использование базы данных SQLite для хранения контента,а не ZIP-архива,делает все эти возможности намного,намного проще в реализации,что увеличивает вероятность того,что они в конечном итоге будут реализованы.</target>
        </trans-unit>
        <trans-unit id="97fa5e0129d965dcc6b70eeae4ab75a90f4ae6ee" translate="yes" xml:space="preserve">
          <source>There are dozens and dozens of SQL function implementations scattered throughout the SQLite source code that can be used as example applications. The built-in SQL functions use the same interface as application-defined SQL functions, so built-in functions can be used as examples too. Search for &quot;sqlite3_context&quot; in the SQLite source code to find examples.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98cb1601f44f3fee5a33f8d40abfeb82b5e7251a" translate="yes" xml:space="preserve">
          <source>There are five separate read locks, numbers 0 through 4. Read locks may be either SHARED or EXCLUSIVE. Connections obtain a shared lock on one of the read locks bytes while they are within a transaction. Connections also obtain an exclusive lock on read locks, one at a time, for the brief moment while they are updating the values of the corresponding read-marks. Read locks 1 through 4 are held exclusively when running &lt;a href=&quot;walformat#recovery&quot;&gt;recovery&lt;/a&gt;.</source>
          <target state="translated">Существует пять отдельных блокировок чтения, номера от 0 до 4. Блокировки чтения могут быть ОБЩИМИ или ИСКЛЮЧИТЕЛЬНЫМИ. Соединения получают разделяемую блокировку на один из байтов блокировки чтения, пока они находятся в транзакции. Соединения также получают эксклюзивную блокировку блокировок чтения, по одной за раз, на короткий момент, пока они обновляют значения соответствующих меток чтения. Блокировки чтения с 1 по 4 удерживаются только при запуске &lt;a href=&quot;walformat#recovery&quot;&gt;восстановления&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c457ee41ba8d1b7387ba8e7edc9a0ac19be4f375" translate="yes" xml:space="preserve">
          <source>There are five ways to describe starting and ending frame boundaries:</source>
          <target state="translated">Существует пять способов описания границ начального и конечного кадров:</target>
        </trans-unit>
        <trans-unit id="c2ce0d23c5814413e2c1fb5364c7eef30a6e31f7" translate="yes" xml:space="preserve">
          <source>There are four independent test harnesses used for testing the core SQLite library. Each test harness is designed, maintained, and managed separately from the others.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="253fb3b554421e91657bed4f34f13690b219d88b" translate="yes" xml:space="preserve">
          <source>There are many SQL-based database management systems available, besides SQLite. Common options include MySQL, PostgreSQL, and SQL-Server. All these systems use the SQL langauge to communicate with the application, just like SQLite. But these other systems different from SQLite in important respects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4083c54b42aa73500fa86d4b0409e55690866a09" translate="yes" xml:space="preserve">
          <source>There are many advantages to using SQLite as an application file format, including:</source>
          <target state="translated">Использование SQLite в качестве формата файла приложения имеет много преимуществ,в том числе:</target>
        </trans-unit>
        <trans-unit id="7e1c62962db715e611550a655ba502415a8c24f6" translate="yes" xml:space="preserve">
          <source>There are many benefits to this approach, including improved performance, reduced cost and complexity, and improved reliability. See technical notes &lt;a href=&quot;aff_short&quot;&gt;&quot;aff_short.html&quot;&lt;/a&gt; and &lt;a href=&quot;appfileformat&quot;&gt;&quot;appfileformat.html&quot;&lt;/a&gt; and &lt;a href=&quot;fasterthanfs&quot;&gt;&quot;fasterthanfs.html&quot;&lt;/a&gt; for more information. This use case is closely related to the &lt;a href=&quot;#wireproto&quot;&gt;data transfer format&lt;/a&gt; and &lt;a href=&quot;#container&quot;&gt;data container&lt;/a&gt; use cases below.</source>
          <target state="translated">У этого подхода много преимуществ, включая повышенную производительность, снижение стоимости и сложности, а также повышенную надежность. См технических примечаний &lt;a href=&quot;aff_short&quot;&gt;&amp;laquo;aff_short.html&amp;raquo;&lt;/a&gt; и &lt;a href=&quot;appfileformat&quot;&gt;&amp;laquo;appfileformat.html&amp;raquo;&lt;/a&gt; и &lt;a href=&quot;fasterthanfs&quot;&gt;&amp;laquo;fasterthanfs.html&amp;raquo;&lt;/a&gt; для получения дополнительной информации. Этот вариант использования тесно связан с &lt;a href=&quot;#wireproto&quot;&gt;форматом передачи данных&lt;/a&gt; и &lt;a href=&quot;#container&quot;&gt;контейнер данных&lt;/a&gt; случаев использования ниже.</target>
        </trans-unit>
        <trans-unit id="a6dd1c1ec54122d1cd8a41e77d633d60c4de1054" translate="yes" xml:space="preserve">
          <source>There are many different extended result codes for I/O errors that identify the specific I/O operation that failed.</source>
          <target state="translated">Существует много различных расширенных кодов результатов для ошибок ввода/вывода,которые идентифицируют конкретную операцию ввода/вывода,которая не удалась.</target>
        </trans-unit>
        <trans-unit id="f265782324871b5641aee92d51fefe1edfb475af" translate="yes" xml:space="preserve">
          <source>There are many fraudulent USB sticks in circulation that report to have a high capacity (ex: 8GB) but are really only capable of storing a much smaller amount (ex: 1GB). Attempts to write on these devices will often result in unrelated files being overwritten. Any use of a fraudulent flash memory device can easily lead to database corruption, therefore. Internet searches such as &quot;fake capacity usb&quot; will turn up lots of disturbing information about this problem.</source>
          <target state="translated">В обращении есть много фальшивых USB-накопителей,которые,как сообщается,имеют большую емкость (например,8 Гб),но на самом деле способны хранить только гораздо меньшее количество (например,1 Гб).Попытки записи на таких устройствах часто приводят к перезаписи несвязанных файлов.Поэтому любое использование мошеннического устройства флэш-памяти может легко привести к повреждению базы данных.Поиски в Интернете,такие как &quot;фальшивые емкости USB&quot; найдут много тревожной информации об этой проблеме.</target>
        </trans-unit>
        <trans-unit id="a53dc58a565490cefd808a058bfaad47e191a084" translate="yes" xml:space="preserve">
          <source>There are many more features not listed above. SQLite may be small in size and have &quot;Lite&quot; in its name, but it is not lacking in capability.</source>
          <target state="translated">Есть много других функций,не перечисленных выше.SQLite может быть небольшого размера и иметь в названии &quot;Lite&quot;,но в его названии нет недостатка в возможностях.</target>
        </trans-unit>
        <trans-unit id="60f662540321a06d796e68831dc73409bf49f397" translate="yes" xml:space="preserve">
          <source>There are many other dot-commands available in the command-line shell. See the &quot;.help&quot; command for a complete list for any particular version and build of SQLite.</source>
          <target state="translated">В оболочке командной строки доступно множество других точечных команд.Полный список для любой конкретной версии и сборки SQLite см.в команде &quot;.help&quot;.</target>
        </trans-unit>
        <trans-unit id="53f739b37a172fddf027f7c8afb4029bf933f8fe" translate="yes" xml:space="preserve">
          <source>There are many other testing options, which can be seen by running the command:</source>
          <target state="translated">Существует множество других опций тестирования,которые можно увидеть,запустив команду:</target>
        </trans-unit>
        <trans-unit id="461c7676d827031f4cd64d05f3d67e68ce256daf" translate="yes" xml:space="preserve">
          <source>There are many ways to measure test coverage. The most popular metric is &quot;statement coverage&quot;. When you hear someone say that their program as &quot;XX% test coverage&quot; without further explanation, they usually mean statement coverage. Statement coverage measures what percentage of lines of code are executed at least once by the test suite.</source>
          <target state="translated">Существует множество способов измерить покрытие теста.Наиболее популярной метрикой является &quot;покрытие теста&quot;.Когда Вы слышите,как кто-то говорит,что его программа,как &quot;XX% тестовое покрытие&quot;,без дальнейших объяснений,как правило,означает покрытие утверждения.Покрытие операторов измеряет,какой процент строк кода хотя бы один раз выполняется тестовым набором.</target>
        </trans-unit>
        <trans-unit id="15784824361af8c293ec21cb8076051131fb442d" translate="yes" xml:space="preserve">
          <source>There are no arbitrary limits in TH3. One could generate a single test program that contained all test modules and all configuration files. However, such a test program might be too large to deploy on embedded platforms. (As of 2018-05-19, a full-up TH3 test is over 850,000 lines and 58MB of C code.) TH3 provides the ability to break the library of test modules up into smaller, more easily digested pieces.</source>
          <target state="translated">В ТН3 нет произвольных ограничений.Можно создать единую тестовую программу,содержащую все тестовые модули и все конфигурационные файлы.Однако такая тестовая программа может быть слишком большой для развертывания на встраиваемых платформах.(По состоянию на 2018-05-19 годы,полный тест TH3 составляет более 850 000 строк и 58MB кода на языке C).TH3 дает возможность разбить библиотеку тестовых модулей на более мелкие,легко усваиваемые части.</target>
        </trans-unit>
        <trans-unit id="67165e227e06a66e9e2a7c9a359bffd814ca48a8" translate="yes" xml:space="preserve">
          <source>There are no arbitrary limits on the number of indices that can be attached to a single table. The number of columns in an index is limited to the value set by &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;(&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitcolumn&quot;&gt;SQLITE_LIMIT_COLUMN&lt;/a&gt;,...).</source>
          <target state="translated">Не существует произвольных ограничений на количество индексов, которые могут быть прикреплены к одной таблице. Количество столбцов в индексе ограничено значением, установленным &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt; ( &lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitcolumn&quot;&gt;SQLITE_LIMIT_COLUMN&lt;/a&gt; , ...).</target>
        </trans-unit>
        <trans-unit id="75e5745eabbe1f0d9742be6d3047103706a06632" translate="yes" xml:space="preserve">
          <source>There are no arguments to this option. This option sets the &lt;a href=&quot;../threadsafe&quot;&gt;threading mode&lt;/a&gt; to Multi-thread. In other words, it disables mutexing on &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; and &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; objects. The application is responsible for serializing access to &lt;a href=&quot;sqlite3&quot;&gt;database connections&lt;/a&gt; and &lt;a href=&quot;stmt&quot;&gt;prepared statements&lt;/a&gt;. But other mutexes are enabled so that SQLite will be safe to use in a multi-threaded environment as long as no two threads attempt to use the same &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; at the same time. If SQLite is compiled with the &lt;a href=&quot;../compile#threadsafe&quot;&gt;SQLITE_THREADSAFE=0&lt;/a&gt; compile-time option then it is not possible to set the Multi-thread &lt;a href=&quot;../threadsafe&quot;&gt;threading mode&lt;/a&gt; and &lt;a href=&quot;config&quot;&gt;sqlite3_config()&lt;/a&gt; will return &lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt; if called with the SQLITE_CONFIG_MULTITHREAD configuration option.</source>
          <target state="translated">У этого варианта нет аргументов. Этот параметр устанавливает &lt;a href=&quot;../threadsafe&quot;&gt;режим&lt;/a&gt; многопоточности. Другими словами, он отключает мьютекс для &lt;a href=&quot;sqlite3&quot;&gt;подключения к базе данных&lt;/a&gt; и &lt;a href=&quot;stmt&quot;&gt;подготовленных&lt;/a&gt; объектов операторов . Приложение отвечает за сериализацию доступа к &lt;a href=&quot;sqlite3&quot;&gt;соединениям&lt;/a&gt; с базой данных и &lt;a href=&quot;stmt&quot;&gt;подготовленным операторам&lt;/a&gt; . Но другие мьютексы включены, поэтому SQLite можно будет безопасно использовать в многопоточной среде, если ни один из двух потоков не пытается использовать одно и то же &lt;a href=&quot;sqlite3&quot;&gt;соединение с базой данных&lt;/a&gt; одновременно. Если SQLite скомпилирован с параметром &lt;a href=&quot;../compile#threadsafe&quot;&gt;времени&lt;/a&gt; компиляции SQLITE_THREADSAFE = 0, тогда невозможно установить &lt;a href=&quot;../threadsafe&quot;&gt;режим многопоточности&lt;/a&gt; и &lt;a href=&quot;config&quot;&gt;sqlite3_config ()&lt;/a&gt;вернет &lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt; при вызове с параметром конфигурации SQLITE_CONFIG_MULTITHREAD.</target>
        </trans-unit>
        <trans-unit id="438fea25e22862b67e0b2e195af310125649fa4d" translate="yes" xml:space="preserve">
          <source>There are no arguments to this option. This option sets the &lt;a href=&quot;../threadsafe&quot;&gt;threading mode&lt;/a&gt; to Serialized. In other words, this option enables all mutexes including the recursive mutexes on &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; and &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; objects. In this mode (which is the default when SQLite is compiled with &lt;a href=&quot;../compile#threadsafe&quot;&gt;SQLITE_THREADSAFE=1&lt;/a&gt;) the SQLite library will itself serialize access to &lt;a href=&quot;sqlite3&quot;&gt;database connections&lt;/a&gt; and &lt;a href=&quot;stmt&quot;&gt;prepared statements&lt;/a&gt; so that the application is free to use the same &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; or the same &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; in different threads at the same time. If SQLite is compiled with the &lt;a href=&quot;../compile#threadsafe&quot;&gt;SQLITE_THREADSAFE=0&lt;/a&gt; compile-time option then it is not possible to set the Serialized &lt;a href=&quot;../threadsafe&quot;&gt;threading mode&lt;/a&gt; and &lt;a href=&quot;config&quot;&gt;sqlite3_config()&lt;/a&gt; will return &lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt; if called with the SQLITE_CONFIG_SERIALIZED configuration option.</source>
          <target state="translated">У этого варианта нет аргументов. Эта опция устанавливает &lt;a href=&quot;../threadsafe&quot;&gt;режим потоковой передачи&lt;/a&gt; на Serialized. Другими словами, этот параметр включает все мьютексы, включая рекурсивные мьютексы при &lt;a href=&quot;sqlite3&quot;&gt;подключении к базе данных&lt;/a&gt; и &lt;a href=&quot;stmt&quot;&gt;подготовленные&lt;/a&gt; объекты операторов . В этом режиме (который используется по умолчанию, когда SQLite скомпилирован с &lt;a href=&quot;../compile#threadsafe&quot;&gt;SQLITE_THREADSAFE = 1&lt;/a&gt; ) библиотека SQLite сама сериализует доступ к &lt;a href=&quot;sqlite3&quot;&gt;соединениям&lt;/a&gt; с базой данных и &lt;a href=&quot;stmt&quot;&gt;подготовленным операторам,&lt;/a&gt; чтобы приложение могло свободно использовать одно и то же &lt;a href=&quot;sqlite3&quot;&gt;соединение с базой данных&lt;/a&gt; или один и тот же &lt;a href=&quot;stmt&quot;&gt;подготовленный оператор&lt;/a&gt; в разных потоках. в то же время. Если SQLite скомпилирован с &lt;a href=&quot;../compile#threadsafe&quot;&gt;SQLITE_THREADSAFE = 0&lt;/a&gt;параметр времени компиляции, то невозможно установить режим сериализованной &lt;a href=&quot;../threadsafe&quot;&gt;потоковой передачи,&lt;/a&gt; и &lt;a href=&quot;config&quot;&gt;sqlite3_config ()&lt;/a&gt; вернет &lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR,&lt;/a&gt; если вызывается с параметром конфигурации SQLITE_CONFIG_SERIALIZED.</target>
        </trans-unit>
        <trans-unit id="4b86fd3dbc8c8ae83073b70ec3ca59694912ef28" translate="yes" xml:space="preserve">
          <source>There are no arguments to this option. This option sets the &lt;a href=&quot;../threadsafe&quot;&gt;threading mode&lt;/a&gt; to Single-thread. In other words, it disables all mutexing and puts SQLite into a mode where it can only be used by a single thread. If SQLite is compiled with the &lt;a href=&quot;../compile#threadsafe&quot;&gt;SQLITE_THREADSAFE=0&lt;/a&gt; compile-time option then it is not possible to change the &lt;a href=&quot;../threadsafe&quot;&gt;threading mode&lt;/a&gt; from its default value of Single-thread and so &lt;a href=&quot;config&quot;&gt;sqlite3_config()&lt;/a&gt; will return &lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt; if called with the SQLITE_CONFIG_SINGLETHREAD configuration option.</source>
          <target state="translated">У этого варианта нет аргументов. Этот параметр устанавливает &lt;a href=&quot;../threadsafe&quot;&gt;однопоточный режим&lt;/a&gt; . Другими словами, он отключает все мьютексы и переводит SQLite в режим, в котором он может использоваться только одним потоком. Если SQLite скомпилирован с параметром &lt;a href=&quot;../compile#threadsafe&quot;&gt;времени&lt;/a&gt; компиляции SQLITE_THREADSAFE = 0, тогда невозможно изменить &lt;a href=&quot;../threadsafe&quot;&gt;режим потоковой передачи&lt;/a&gt; со значения по умолчанию Однопоточный, и поэтому &lt;a href=&quot;config&quot;&gt;sqlite3_config ()&lt;/a&gt; вернет &lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR,&lt;/a&gt; если вызывается с параметром конфигурации SQLITE_CONFIG_SINGLETHREAD.</target>
        </trans-unit>
        <trans-unit id="e6b294707b24261f0f532c64902934c051eedbd1" translate="yes" xml:space="preserve">
          <source>There are no arguments to this option. This option sets the &lt;a href=&quot;threadsafe&quot;&gt;threading mode&lt;/a&gt; to Multi-thread. In other words, it disables mutexing on &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; and &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; objects. The application is responsible for serializing access to &lt;a href=&quot;#sqlite3&quot;&gt;database connections&lt;/a&gt; and &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statements&lt;/a&gt;. But other mutexes are enabled so that SQLite will be safe to use in a multi-threaded environment as long as no two threads attempt to use the same &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; at the same time. If SQLite is compiled with the &lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE=0&lt;/a&gt; compile-time option then it is not possible to set the Multi-thread &lt;a href=&quot;threadsafe&quot;&gt;threading mode&lt;/a&gt; and &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config()&lt;/a&gt; will return &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt; if called with the SQLITE_CONFIG_MULTITHREAD configuration option.</source>
          <target state="translated">У этого варианта нет аргументов. Этот параметр устанавливает &lt;a href=&quot;threadsafe&quot;&gt;режим&lt;/a&gt; многопоточности. Другими словами, он отключает мьютекс для &lt;a href=&quot;#sqlite3&quot;&gt;подключения к базе данных&lt;/a&gt; и &lt;a href=&quot;#sqlite3_stmt&quot;&gt;подготовленных&lt;/a&gt; объектов операторов . Приложение отвечает за сериализацию доступа к &lt;a href=&quot;#sqlite3&quot;&gt;соединениям&lt;/a&gt; с базой данных и &lt;a href=&quot;#sqlite3_stmt&quot;&gt;подготовленным операторам&lt;/a&gt; . Но другие мьютексы включены, поэтому SQLite можно будет безопасно использовать в многопоточной среде, если ни один из двух потоков не пытается использовать одно и то же &lt;a href=&quot;#sqlite3&quot;&gt;соединение с базой данных&lt;/a&gt; одновременно. Если SQLite скомпилирован с параметром &lt;a href=&quot;compile#threadsafe&quot;&gt;времени&lt;/a&gt; компиляции SQLITE_THREADSAFE = 0, тогда невозможно установить &lt;a href=&quot;threadsafe&quot;&gt;режим многопоточности&lt;/a&gt; и &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config ()&lt;/a&gt;вернет &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt; при вызове с параметром конфигурации SQLITE_CONFIG_MULTITHREAD.</target>
        </trans-unit>
        <trans-unit id="955a610f066915f2766fca467b944718d1ee6aea" translate="yes" xml:space="preserve">
          <source>There are no arguments to this option. This option sets the &lt;a href=&quot;threadsafe&quot;&gt;threading mode&lt;/a&gt; to Serialized. In other words, this option enables all mutexes including the recursive mutexes on &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; and &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; objects. In this mode (which is the default when SQLite is compiled with &lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE=1&lt;/a&gt;) the SQLite library will itself serialize access to &lt;a href=&quot;#sqlite3&quot;&gt;database connections&lt;/a&gt; and &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statements&lt;/a&gt; so that the application is free to use the same &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; or the same &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; in different threads at the same time. If SQLite is compiled with the &lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE=0&lt;/a&gt; compile-time option then it is not possible to set the Serialized &lt;a href=&quot;threadsafe&quot;&gt;threading mode&lt;/a&gt; and &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config()&lt;/a&gt; will return &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt; if called with the SQLITE_CONFIG_SERIALIZED configuration option.</source>
          <target state="translated">У этого варианта нет аргументов. Эта опция устанавливает &lt;a href=&quot;threadsafe&quot;&gt;режим потоковой передачи&lt;/a&gt; на Serialized. Другими словами, этот параметр включает все мьютексы, включая рекурсивные мьютексы при &lt;a href=&quot;#sqlite3&quot;&gt;подключении к базе данных&lt;/a&gt; и &lt;a href=&quot;#sqlite3_stmt&quot;&gt;подготовленные&lt;/a&gt; объекты операторов . В этом режиме (который используется по умолчанию, когда SQLite скомпилирован с &lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE = 1&lt;/a&gt; ) библиотека SQLite сама сериализует доступ к &lt;a href=&quot;#sqlite3&quot;&gt;соединениям&lt;/a&gt; с базой данных и &lt;a href=&quot;#sqlite3_stmt&quot;&gt;подготовленным операторам,&lt;/a&gt; чтобы приложение могло свободно использовать одно и то же &lt;a href=&quot;#sqlite3&quot;&gt;соединение с базой данных&lt;/a&gt; или один и тот же &lt;a href=&quot;#sqlite3_stmt&quot;&gt;подготовленный оператор&lt;/a&gt; в разных потоках. в то же время. Если SQLite скомпилирован с &lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE = 0&lt;/a&gt;параметр времени компиляции, то невозможно установить режим сериализованной &lt;a href=&quot;threadsafe&quot;&gt;потоковой передачи,&lt;/a&gt; и &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config ()&lt;/a&gt; вернет &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR,&lt;/a&gt; если вызывается с параметром конфигурации SQLITE_CONFIG_SERIALIZED.</target>
        </trans-unit>
        <trans-unit id="1bc66a3a72545b16257e521a7b7467b7b7fb116b" translate="yes" xml:space="preserve">
          <source>There are no arguments to this option. This option sets the &lt;a href=&quot;threadsafe&quot;&gt;threading mode&lt;/a&gt; to Single-thread. In other words, it disables all mutexing and puts SQLite into a mode where it can only be used by a single thread. If SQLite is compiled with the &lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE=0&lt;/a&gt; compile-time option then it is not possible to change the &lt;a href=&quot;threadsafe&quot;&gt;threading mode&lt;/a&gt; from its default value of Single-thread and so &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config()&lt;/a&gt; will return &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt; if called with the SQLITE_CONFIG_SINGLETHREAD configuration option.</source>
          <target state="translated">У этого варианта нет аргументов. Этот параметр устанавливает &lt;a href=&quot;threadsafe&quot;&gt;однопоточный режим&lt;/a&gt; . Другими словами, он отключает все мьютексы и переводит SQLite в режим, в котором он может использоваться только одним потоком. Если SQLite скомпилирован с параметром &lt;a href=&quot;compile#threadsafe&quot;&gt;времени&lt;/a&gt; компиляции SQLITE_THREADSAFE = 0, тогда невозможно изменить &lt;a href=&quot;threadsafe&quot;&gt;режим потоковой передачи&lt;/a&gt; со значения по умолчанию Однопоточный, и поэтому &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config ()&lt;/a&gt; вернет &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR,&lt;/a&gt; если вызывается с параметром конфигурации SQLITE_CONFIG_SINGLETHREAD.</target>
        </trans-unit>
        <trans-unit id="33e0331165757b835edb3c42bfc1d34942851312" translate="yes" xml:space="preserve">
          <source>There are numerous test cases that verify that SQLite is able to deal with malformed database files. These tests first build a well-formed database file, then add corruption by changing one or more bytes in the file by some means other than SQLite. Then SQLite is used to read the database. In some cases, the bytes changes are in the middle of data. This causes the content of the database to change while keeping the database well-formed. In other cases, unused bytes of the file are modified, which has no effect on the integrity of the database. The interesting cases are when bytes of the file that define database structure get changed. The malformed database tests verify that SQLite finds the file format errors and reports them using the &lt;a href=&quot;rescode#corrupt&quot;&gt;SQLITE_CORRUPT&lt;/a&gt; return code without overflowing buffers, dereferencing NULL pointers, or performing other unwholesome actions.</source>
          <target state="translated">Существует множество тестовых примеров, которые подтверждают, что SQLite может работать с искаженными файлами базы данных. Эти тесты сначала создают правильно сформированный файл базы данных, а затем добавляют повреждение, изменяя один или несколько байтов в файле другими способами, кроме SQLite. Затем SQLite используется для чтения базы данных. В некоторых случаях изменения байтов происходят в середине данных. Это приводит к изменению содержимого базы данных при сохранении ее правильного формата. В других случаях изменяются неиспользуемые байты файла, что не влияет на целостность базы данных. Интересны случаи, когда изменяются байты файла, определяющие структуру базы данных. Тесты неверно сформированной базы данных подтверждают, что SQLite находит ошибки формата файла и сообщает о них с помощью &lt;a href=&quot;rescode#corrupt&quot;&gt;SQLITE_CORRUPT&lt;/a&gt; код возврата без переполнения буферов, разыменования указателей NULL или выполнения других нежелательных действий.</target>
        </trans-unit>
        <trans-unit id="f9afe2547739122b5f898fca4cf352f033d81b8f" translate="yes" xml:space="preserve">
          <source>There are only two reasonable ways to implement this query. (There are many other possible algorithms, but none of the others are contenders for being the &quot;best&quot; algorithm.)</source>
          <target state="translated">Есть только два разумных способа реализовать этот запрос.(Существует множество других возможных алгоритмов,но ни один из них не претендует на то,чтобы быть &quot;лучшим&quot; алгоритмом).</target>
        </trans-unit>
        <trans-unit id="35c4953b7b40ec225a59ad1651360c7dbd0086b0" translate="yes" xml:space="preserve">
          <source>There are other SQL database engines with liberal licenses that allow the code to be broadly and freely used. But those other engines are still governed by copyright law. SQLite is different in that copyright law simply does not apply.</source>
          <target state="translated">Существуют и другие движки баз данных SQL с либеральными лицензиями,которые позволяют широко и свободно использовать код.Но эти другие движки все равно регулируются авторским правом.SQLite отличается тем,что авторское право просто не применяется.</target>
        </trans-unit>
        <trans-unit id="00840e534b3409464615b9e5469c1789e0356b07" translate="yes" xml:space="preserve">
          <source>There are other VFS implementations both in the core SQLite source code library and in available extensions. The list above is not meant to be exhaustive but merely representative of the kinds of features that can be realized using the VFS interface.</source>
          <target state="translated">Существуют и другие реализации VFS,как в основной библиотеке исходных кодов SQLite,так и в доступных расширениях.Приведенный выше список не претендует на полноту,а лишь представляет те возможности,которые могут быть реализованы с помощью интерфейса VFS.</target>
        </trans-unit>
        <trans-unit id="fe657852dc4212647e79b2906ecbf326edcfcb96" translate="yes" xml:space="preserve">
          <source>There are several other ways to add an equivalent foreign key declaration to a &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; statement. Refer to the &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE documentation&lt;/a&gt; for details.</source>
          <target state="translated">Есть несколько других способов добавить эквивалентное объявление внешнего ключа к оператору &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; . Обратитесь к &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE документации&lt;/a&gt; для деталей.</target>
        </trans-unit>
        <trans-unit id="14687afe7afa4066d985b4f03845594063586e18" translate="yes" xml:space="preserve">
          <source>There are several ways of thinking about the RELEASE command:</source>
          <target state="translated">Существует несколько способов мышления о команде RELEASE:</target>
        </trans-unit>
        <trans-unit id="22c57ea3a56c1a621fcb33ba044a6de73ca1f510" translate="yes" xml:space="preserve">
          <source>There are several ways to approach this in FTS5:</source>
          <target state="translated">В FTS5 есть несколько способов к этому подойти:</target>
        </trans-unit>
        <trans-unit id="de40b756c06e57b21f4c7c518f428b201082172b" translate="yes" xml:space="preserve">
          <source>There are some contexts in SQLite that do not allow the use of non-deterministic functions:</source>
          <target state="translated">В SQLite есть некоторые контексты,которые не позволяют использовать недетерминированные функции:</target>
        </trans-unit>
        <trans-unit id="ffb257ce26a3636acdb1a9134b8ec418a490f506" translate="yes" xml:space="preserve">
          <source>There are some restrictions on the use of a VALUES clause that are not shown on the syntax diagrams:</source>
          <target state="translated">Существуют некоторые ограничения на использование выражения VALUES,которые не отображаются на синтаксических схемах:</target>
        </trans-unit>
        <trans-unit id="4fc9c795ba02424df295c5bd8e19a42a3240738c" translate="yes" xml:space="preserve">
          <source>There are three frame types: ROWS, GROUPS, and RANGE. The frame type determines how the starting and ending boundaries of the frame are measured.</source>
          <target state="translated">Есть три типа рам:ROWS,GROUPS и RANGE.Тип кадра определяет,как измеряются начальная и конечная границы кадра.</target>
        </trans-unit>
        <trans-unit id="b1e7d89744d05b6a27dde7db2836b2617aa1bbd6" translate="yes" xml:space="preserve">
          <source>There are three independent test harnesses used for testing the core SQLite library. Each test harness is designed, maintained, and managed separately from the others.</source>
          <target state="translated">Для тестирования основной библиотеки SQLite используются три независимые тестовые жгуты.Каждая тестовая жгутка проектируется,поддерживается и управляется отдельно от других.</target>
        </trans-unit>
        <trans-unit id="045c3584370eb289c548f60cb3b6ecaf401b3ed3" translate="yes" xml:space="preserve">
          <source>There are three levels to the shared-cache locking model, transaction level locking, table level locking and schema level locking. They are described in the following three sub-sections.</source>
          <target state="translated">Существует три уровня для модели блокировки общего кэша,блокировка на уровне транзакций,блокировка на уровне таблиц и блокировка на уровне схемы.Они описаны в следующих трех подразделах.</target>
        </trans-unit>
        <trans-unit id="e99c034a6b8af219b7e8f49f9f3d601cff4065a7" translate="yes" xml:space="preserve">
          <source>There are three math functions available:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1eaabb690f2c43b66d0713f1063a91097f30c63b" translate="yes" xml:space="preserve">
          <source>There are three possible outputs from the verify_checksum() function: 1, 0, and NULL. 1 is returned if the checksum is correct. 0 is returned if the checksum is incorrect. NULL is returned if the page is unreadable. If checksumming is enabled, the read will fail if the checksum is wrong, so the usual result from verify_checksum() on a bad checksum is NULL.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="944bcf56eaccf2f8d8f73507f47a4f5f610aa075" translate="yes" xml:space="preserve">
          <source>There are three reasons to set the locking-mode to EXCLUSIVE.</source>
          <target state="translated">Существует три причины для установки режима блокировки на EXCLUSIVE.</target>
        </trans-unit>
        <trans-unit id="e889a4b513747e6b54c292e814d5a011df18d8e5" translate="yes" xml:space="preserve">
          <source>There are three special-case entries in the cost table:</source>
          <target state="translated">В таблице расходов есть три специальные записи:</target>
        </trans-unit>
        <trans-unit id="3e8f3752e4f9aab9d7f5e605906342c5eeca4178" translate="yes" xml:space="preserve">
          <source>There are two advantages to using the SQLite printf functions instead of &lt;b&gt;sprintf&lt;/b&gt;. First of all, with the SQLite printf routines, there is never a danger of overflowing a static buffer as there is with &lt;b&gt;sprintf&lt;/b&gt;. The SQLite printf routines automatically allocate (and later frees) as much memory as is necessary to hold the SQL statements generated.</source>
          <target state="translated">У использования функций SQLite printf вместо &lt;b&gt;sprintf&lt;/b&gt; есть два преимущества . Прежде всего, с подпрограммами printf SQLite никогда не возникает опасности переполнения статического буфера, как в случае с &lt;b&gt;sprintf&lt;/b&gt; . Подпрограммы SQLite printf автоматически выделяют (а позже освобождают) столько памяти, сколько необходимо для хранения сгенерированных операторов SQL.</target>
        </trans-unit>
        <trans-unit id="391950a505dd77c6d9de2b0a8bf9dd26b935ed51" translate="yes" xml:space="preserve">
          <source>There are two aggregate SQL functions:</source>
          <target state="translated">Существует две совокупные функции SQL:</target>
        </trans-unit>
        <trans-unit id="631b7dfac93f3d53c23db92b1bef743005732dff" translate="yes" xml:space="preserve">
          <source>There are two cases to consider: (1) Table &quot;tab1&quot; does not previously exist and (2) table &quot;tab1&quot; does already exist.</source>
          <target state="translated">Есть два дела,которые нужно рассмотреть:(1)Таблицы &quot;tab1&quot; ранее не существовало и (2)таблица &quot;tab1&quot; уже существует.</target>
        </trans-unit>
        <trans-unit id="b8b8531dc422d3e33d42cc7bdad0abd37870f1fe" translate="yes" xml:space="preserve">
          <source>There are two column (M==2) and three rows (N==3). Thus the result table has 8 entries. Suppose the result table is stored in an array names azResult. Then azResult holds this content:</source>
          <target state="translated">Здесь две колонки (M==2)и три строки (N==3).Таким образом,таблица результатов имеет 8 записей.Предположим,таблица результата хранится в имени массива azResult.Затем azResult хранит это содержимое:</target>
        </trans-unit>
        <trans-unit id="e8adb25d367ffc51207827de29ffc66a0b34c609" translate="yes" xml:space="preserve">
          <source>There are two columns (M==2) and three rows (N==3). Thus the result table has 8 entries. Suppose the result table is stored in an array named azResult. Then azResult holds this content:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="928a963ad2407ff0d2d21e12347ddb23d756bb64" translate="yes" xml:space="preserve">
          <source>There are two differences in this variation. The initial-select is &quot;SELECT 1&quot; instead of &quot;VALUES(1)&quot;. But those are just different syntaxes for saying exactly the same thing. The other change is that the recursion is stopped by a LIMIT rather than a WHERE clause. The use of LIMIT means that when the one-millionth row is added to the &quot;cnt&quot; table (and returned by the main SELECT, thanks to the query optimizer) then the recursion stops immediately regardless of how many rows might be left in the queue. On more complex queries, it can sometimes be difficult to ensure that the WHERE clause will eventually cause the queue to drain and the recursion to terminate. But the LIMIT clause will always stop the recursion. So it is good practice to always include a LIMIT clause as a safety if an upper bound on the size of the recursion is known.</source>
          <target state="translated">В этом варианте есть два отличия.Первоначальный выбор-&quot;ВЫБОР 1&quot; вместо &quot;ЦЕНЫ(1)&quot;.Но это просто разные синтаксисы,чтобы сказать одно и то же.Другое изменение заключается в том,что рекурсия останавливается пунктом LIMIT,а не WHERE.Использование LIMIT означает,что когда миллионная строка добавляется в таблицу &quot;cnt&quot; (и возвращается основным SELECT,благодаря оптимизатору запросов),рекурсия останавливается немедленно,независимо от того,сколько строк может остаться в очереди.На более сложных запросах иногда бывает сложно гарантировать,что выражение WHERE в конце концов приведет к сливу очереди,а рекурсия завершится.Но выражение LIMIT всегда остановит рекурсию.Поэтому хорошая практика-всегда включать в качестве безопасности пункт LIMIT,если известна верхняя граница размера рекурсии.</target>
        </trans-unit>
        <trans-unit id="bb5962b52c02f4df27314354c0118e64e476f288" translate="yes" xml:space="preserve">
          <source>There are two separate configuration changes here which can be used either togethr or separately. The &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmultithread&quot;&gt;SQLITE_CONFIG_MULTITHREAD&lt;/a&gt; setting disables the mutexes that serialize access to &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; objects and &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; objects. With this setting, the application is free to use SQLite from multiple threads, but it must make sure than no two threads try to access the same &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; or any &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statements&lt;/a&gt; associated with the same &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; at the same time. Two threads can use SQLite at the same time, but they must use separate &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt;. The second &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmemstatus&quot;&gt;SQLITE_CONFIG_MEMSTATUS&lt;/a&gt; setting disables the mechanism in SQLite that tracks the total size of all outstanding memory allocation requests. This omits the need to mutex each call to &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc()&lt;/a&gt; and &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_free()&lt;/a&gt;, which saves a huge number of mutex operations. But a consequence of disabling the memory statistics mechanism is that the &lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_used()&lt;/a&gt;, &lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_highwater()&lt;/a&gt;, and &lt;a href=&quot;c3ref/hard_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64()&lt;/a&gt; interfaces cease to work.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10f943413bc9e88ca64edb6cc154e6b7583f6c77" translate="yes" xml:space="preserve">
          <source>There are two separate configuration changes here which can be used either togethr or separately. The &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmultithread&quot;&gt;SQLITE_CONFIG_MULTITHREAD&lt;/a&gt; setting disables the mutexes that serialize access to &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; objects and &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; objects. With this setting, the application is free to use SQLite from multiple threads, but it must make sure than no two threads try to access the same &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; or any &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statements&lt;/a&gt; associated with the same &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; at the same time. Two threads can use SQLite at the same time, but they must use separate &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt;. The second &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmemstatus&quot;&gt;SQLITE_CONFIG_MEMSTATUS&lt;/a&gt; setting disables the mechanism in SQLite that tracks the total size of all outstanding memory allocation requests. This omits the need to mutex each call to &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc()&lt;/a&gt; and &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_free()&lt;/a&gt;, which saves a huge number of mutex operations. But a consequence of disabling the memory statistics mechanism is that the &lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_used()&lt;/a&gt;, &lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_highwater()&lt;/a&gt;, and &lt;a href=&quot;c3ref/soft_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64()&lt;/a&gt; interfaces cease to work.</source>
          <target state="translated">Здесь есть два отдельных изменения конфигурации, которые можно использовать вместе или по отдельности. Параметр &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmultithread&quot;&gt;SQLITE_CONFIG_MULTITHREAD&lt;/a&gt; отключает мьютексы, которые сериализуют доступ к объектам &lt;a href=&quot;c3ref/sqlite3&quot;&gt;подключения&lt;/a&gt; к базе данных и &lt;a href=&quot;c3ref/stmt&quot;&gt;подготовленным&lt;/a&gt; объектам операторов . С этим параметром приложение может использовать SQLite из нескольких потоков, но оно должно быть уверено, что никакие два потока не попытаются получить доступ к одному и тому же &lt;a href=&quot;c3ref/sqlite3&quot;&gt;соединению с базой данных&lt;/a&gt; или любым &lt;a href=&quot;c3ref/stmt&quot;&gt;подготовленным операторам,&lt;/a&gt; связанным с одним и тем же &lt;a href=&quot;c3ref/sqlite3&quot;&gt;соединением&lt;/a&gt; с базой данных одновременно. Два потока могут использовать SQLite одновременно, но они должны использовать отдельные &lt;a href=&quot;c3ref/sqlite3&quot;&gt;соединения с базой данных&lt;/a&gt; . Второй &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmemstatus&quot;&gt;SQLITE_CONFIG_MEMSTATUS&lt;/a&gt;настройка отключает механизм в SQLite, который отслеживает общий размер всех невыполненных запросов на выделение памяти. Это избавляет от необходимости мьютексировать каждый вызов &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc ()&lt;/a&gt; и &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_free ()&lt;/a&gt; , что экономит огромное количество операций мьютекса. Но следствием отключения механизма статистики памяти является то, что интерфейсы &lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_used ()&lt;/a&gt; , &lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_highwater ()&lt;/a&gt; и &lt;a href=&quot;c3ref/soft_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64 ()&lt;/a&gt; перестают работать.</target>
        </trans-unit>
        <trans-unit id="03b9684a8e7902c26ab2183576e54dd70242a272" translate="yes" xml:space="preserve">
          <source>There are two types of simple SELECT statement - aggregate and non-aggregate queries. A simple SELECT statement is an aggregate query if it contains either a GROUP BY clause or one or more aggregate functions in the result-set. Otherwise, if a simple SELECT contains no aggregate functions or a GROUP BY clause, it is a non-aggregate query.</source>
          <target state="translated">Существует два типа простых SELECT-запросов-агрегированные и не агрегированные.Простой оператор SELECT-это агрегированный запрос,если он содержит либо пункт GROUP BY,либо одну или несколько агрегированных функций в результирующем множестве.Иначе,если простой SELECT не содержит агрегатных функций или пункта GROUP BY,это неагрегированный запрос.</target>
        </trans-unit>
        <trans-unit id="265655ffc7236582ade45c905963724f97d22dc0" translate="yes" xml:space="preserve">
          <source>There are two ways to use the &quot;content&quot; option:</source>
          <target state="translated">Существует два способа использования опции &quot;контент&quot;:</target>
        </trans-unit>
        <trans-unit id="6c855557ba4350c988043164f7d90199d18c9af0" translate="yes" xml:space="preserve">
          <source>There are typically between 10 to 40 entries in the sqlite_stat4 table for each index for which statistics are available, however these limits are not hard bounds. The meanings of the columns in the sqlite_stat4 table are as follows:</source>
          <target state="translated">Обычно в таблице sqlite_stat4 для каждого индекса,по которому доступна статистика,имеется от 10 до 40 записей,однако эти границы не являются жесткими.Значения столбцов в таблице sqlite_stat4 следующие:</target>
        </trans-unit>
        <trans-unit id="7cc2860dd2126e117e20cc785f2f36fc98950f36" translate="yes" xml:space="preserve">
          <source>There are usually multiple entries in the sqlite_stat3 table for each index. The sqlite_stat3.sample column holds the value of the left-most field of an index identified by sqlite_stat3.idx and sqlite_stat3.tbl. The sqlite_stat3.nEq column holds the approximate number of entries in the index whose left-most column exactly matches the sample. The sqlite_stat3.nLt holds the approximate number of entries in the index whose left-most column is less than the sample. The sqlite_stat3.nDLt column holds the approximate number of distinct left-most entries in the index that are less than the sample.</source>
          <target state="translated">Для каждого индекса в таблице sqlite_stat3 обычно имеется несколько записей.В столбце sqlite_stat3.sample хранится значение самого левого поля индекса,идентифицируемого sqlite_stat3.idx и sqlite_stat3.tbl.В столбце sqlite_stat3.nEq хранится примерное количество записей в индексе,крайний левый столбец которого точно совпадает с выборкой.В столбце sqlite_stat3.nLt хранится примерное количество записей в индексе,крайний левый столбец которого меньше,чем в выборке.В столбце sqlite_stat3.nDLt указано примерное количество отдельных крайних левых записей в индексе,которое меньше,чем в выборке.</target>
        </trans-unit>
        <trans-unit id="3bc8ca2faf5f82d403479bc810eea0e330c59fbe" translate="yes" xml:space="preserve">
          <source>There can be an arbitrary number of sqlite_stat3 entries per index. The &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; command will typically generate sqlite_stat3 tables that contain between 10 and 40 samples that are distributed across the key space and with large nEq values.</source>
          <target state="translated">В каждом индексе может быть произвольное количество записей sqlite_stat3. Команда &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; обычно создает таблицы sqlite_stat3, содержащие от 10 до 40 выборок, которые распределены по ключевому пространству и имеют большие значения nEq.</target>
        </trans-unit>
        <trans-unit id="76781503806bdc9ca573d5796b00968614643484" translate="yes" xml:space="preserve">
          <source>There can be an arbitrary number of sqlite_stat4 entries per index. The &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; command will typically generate sqlite_stat4 tables that contain between 10 and 40 samples that are distributed across the key space and with large nEq values.</source>
          <target state="translated">В каждом индексе может быть произвольное количество записей sqlite_stat4. Команда &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; обычно создает таблицы sqlite_stat4, содержащие от 10 до 40 выборок, распределенных по ключевому пространству и с большими значениями nEq.</target>
        </trans-unit>
        <trans-unit id="4935a4962bbd49a87bfec8ba26bcb0ee96e2bc65" translate="yes" xml:space="preserve">
          <source>There can only be a single busy handler defined for each &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt;. Setting a new busy handler clears any previously set handler. Note that calling &lt;a href=&quot;#sqlite3_busy_timeout&quot;&gt;sqlite3_busy_timeout()&lt;/a&gt; or evaluating &lt;a href=&quot;pragma#pragma_busy_timeout&quot;&gt;PRAGMA busy_timeout=N&lt;/a&gt; will change the busy handler and thus clear any previously set busy handler.</source>
          <target state="translated">Для каждого &lt;a href=&quot;#sqlite3&quot;&gt;подключения&lt;/a&gt; к базе данных может быть определен только один обработчик занятости . Установка нового обработчика занятости очищает любой ранее установленный обработчик. Обратите внимание, что вызов &lt;a href=&quot;#sqlite3_busy_timeout&quot;&gt;sqlite3_busy_timeout ()&lt;/a&gt; или оценка &lt;a href=&quot;pragma#pragma_busy_timeout&quot;&gt;PRAGMA busy_timeout = N&lt;/a&gt; изменит обработчик занятости и, таким образом, очистит любой ранее установленный обработчик занятости.</target>
        </trans-unit>
        <trans-unit id="595614b4fea7d83eeee9eca9b82c7f15a616950a" translate="yes" xml:space="preserve">
          <source>There can only be a single busy handler defined for each &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt;. Setting a new busy handler clears any previously set handler. Note that calling &lt;a href=&quot;busy_timeout&quot;&gt;sqlite3_busy_timeout()&lt;/a&gt; or evaluating &lt;a href=&quot;../pragma#pragma_busy_timeout&quot;&gt;PRAGMA busy_timeout=N&lt;/a&gt; will change the busy handler and thus clear any previously set busy handler.</source>
          <target state="translated">Для каждого &lt;a href=&quot;sqlite3&quot;&gt;подключения&lt;/a&gt; к базе данных может быть определен только один обработчик занятости . Установка нового обработчика занятости очищает любой ранее установленный обработчик. Обратите внимание, что вызов &lt;a href=&quot;busy_timeout&quot;&gt;sqlite3_busy_timeout ()&lt;/a&gt; или оценка &lt;a href=&quot;../pragma#pragma_busy_timeout&quot;&gt;PRAGMA busy_timeout = N&lt;/a&gt; изменит обработчик занятости и, таким образом, очистит любой ранее установленный обработчик занятости.</target>
        </trans-unit>
        <trans-unit id="4557f81c54cd198ad30dafda03e1a7688c37ee6a" translate="yes" xml:space="preserve">
          <source>There can only be a single busy handler for a particular &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; at any given moment. If another busy handler was defined (using &lt;a href=&quot;#sqlite3_busy_handler&quot;&gt;sqlite3_busy_handler()&lt;/a&gt;) prior to calling this routine, that other busy handler is cleared.</source>
          <target state="translated">Для конкретного &lt;a href=&quot;#sqlite3&quot;&gt;соединения с базой данных&lt;/a&gt; в любой момент может быть только один обработчик занятости . Если перед вызовом этой процедуры был определен другой обработчик занятости (с использованием &lt;a href=&quot;#sqlite3_busy_handler&quot;&gt;sqlite3_busy_handler ()&lt;/a&gt; ), этот другой обработчик занятости очищается.</target>
        </trans-unit>
        <trans-unit id="6c5612f166f3c19adb75f5b9420223d984d062bf" translate="yes" xml:space="preserve">
          <source>There can only be a single busy handler for a particular &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; at any given moment. If another busy handler was defined (using &lt;a href=&quot;busy_handler&quot;&gt;sqlite3_busy_handler()&lt;/a&gt;) prior to calling this routine, that other busy handler is cleared.</source>
          <target state="translated">Для конкретного &lt;a href=&quot;sqlite3&quot;&gt;соединения с базой данных&lt;/a&gt; в любой момент может быть только один обработчик занятости . Если перед вызовом этой процедуры был определен другой обработчик занятости (с использованием &lt;a href=&quot;busy_handler&quot;&gt;sqlite3_busy_handler ()&lt;/a&gt; ), этот другой обработчик занятости очищается.</target>
        </trans-unit>
        <trans-unit id="da947c700e89a2839d81ef99abfdba549201cf04" translate="yes" xml:space="preserve">
          <source>There can only be a single error logging callback per process. The error logging callback is registered at start-time using C-code similar to the following:</source>
          <target state="translated">На каждый процесс может быть только один обратный вызов журнала ошибок.Обратный вызов регистрации ошибок регистрируется при запуске с помощью C-кода,как показано ниже:</target>
        </trans-unit>
        <trans-unit id="297da7a4ca1508d9a0851c1993606776e3a61cd5" translate="yes" xml:space="preserve">
          <source>There can only be a single trace callback registered on a database connection. Each use of &quot;trace&quot; or &quot;trace_v2&quot; cancels all prior trace callback.</source>
          <target state="translated">При подключении к базе данных может быть зарегистрирован только один обратный вызов трассы.Каждое использование &quot;trace&quot; или &quot;trace_v2&quot; отменяет все предыдущие обратные вызовы трассы.</target>
        </trans-unit>
        <trans-unit id="13fe35de43729e33636f83c267efada945c04a07" translate="yes" xml:space="preserve">
          <source>There exists some subtle problem with mmap() on QNX such that making a second mmap() call against a single file descriptor can cause the memory obtained from the first mmap() call to be zeroed. SQLite on unix uses mmap() to create a shared memory region for transaction coordination in &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt;, and it will call mmap() multiple times for large transactions. The QNX mmap() has been demonstrated to corrupt database file under that scenario. QNX engineers are aware of this problem and are working on a solution; the problem may have already been fixed by the time you read this.</source>
          <target state="translated">Существует некоторая тонкая проблема с mmap () в QNX: второй вызов mmap () для одного файлового дескриптора может привести к обнулению памяти, полученной в результате первого вызова mmap (). SQLite в unix использует mmap () для создания области разделяемой памяти для координации транзакций в &lt;a href=&quot;wal&quot;&gt;режиме WAL&lt;/a&gt; , и он будет вызывать mmap () несколько раз для больших транзакций. Было продемонстрировано, что QNX mmap () повреждает файл базы данных в этом сценарии. Инженеры QNX знают об этой проблеме и работают над ее решением; к тому времени, когда вы это прочтете, проблема могла быть уже решена.</target>
        </trans-unit>
        <trans-unit id="d56d459074bf9b196b2551c494a4c7bec9d94df2" translate="yes" xml:space="preserve">
          <source>There has lately been a lot of interest in &quot;safe&quot; programming languages like Rust or Go in which it is impossible, or is at least difficult, to make common programming errors like memory leaks or array overruns. So the question often arises as to why SQLite is not coded in a &quot;safe&quot; language.</source>
          <target state="translated">В последнее время наблюдается большой интерес к &quot;безопасным&quot; языкам программирования,таким как Rust или Go,в которых невозможно или,по крайней мере,сложно допустить распространенные ошибки программирования,такие как утечка памяти или выход за границы массивов.Поэтому часто возникает вопрос,почему SQLite не кодируется на &quot;безопасном&quot; языке.</target>
        </trans-unit>
        <trans-unit id="52072b3d340cc958b2ff6cebc4a70e99aba7da9e" translate="yes" xml:space="preserve">
          <source>There have been three historical file formats for SQLite. SQLite 1.0 through 1.0.32 used the &lt;a href=&quot;https://www.gnu.org/software/gdbm/gdbm.html&quot;&gt;gdbm&lt;/a&gt; library as its storage engine. SQLite 2.0.0 through 2.8.17 used a custom b-tree storage engine that supported only text keys and data. All modern versions of SQLite (3.0.0 to present) use a b-tree storage engine that has full support for binary data and Unicode.</source>
          <target state="translated">Для SQLite существует три исторических формата файлов. В SQLite 1.0&amp;ndash;1.0.32 в качестве механизма хранения используется библиотека &lt;a href=&quot;https://www.gnu.org/software/gdbm/gdbm.html&quot;&gt;gdbm&lt;/a&gt; . SQLite 2.0.0&amp;ndash;2.8.17 использовал специальный механизм хранения b-tree, который поддерживал только текстовые ключи и данные. Все современные версии SQLite (от 3.0.0 до настоящего момента) используют механизм хранения b-tree, который полностью поддерживает двоичные данные и Unicode.</target>
        </trans-unit>
        <trans-unit id="3be8d2f16b71e4444f7f725739b5254eb08f103c" translate="yes" xml:space="preserve">
          <source>There is a function named &lt;a href=&quot;c3ref/last_insert_rowid&quot;&gt;sqlite3_last_insert_rowid()&lt;/a&gt; which will return the integer key for the most recent insert operation.</source>
          <target state="translated">Существует функция &lt;a href=&quot;c3ref/last_insert_rowid&quot;&gt;sqlite3_last_insert_rowid (),&lt;/a&gt; которая возвращает целочисленный ключ для последней операции вставки.</target>
        </trans-unit>
        <trans-unit id="2c4047eace270e4351576190943319e0de00174c" translate="yes" xml:space="preserve">
          <source>There is a limit, set using &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit()&lt;/a&gt; and &lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitattached&quot;&gt;SQLITE_LIMIT_ATTACHED&lt;/a&gt;, to the number of databases that can be simultaneously attached to a single database connection.</source>
          <target state="translated">Существует ограничение, устанавливаемое с помощью &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit ()&lt;/a&gt; и &lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitattached&quot;&gt;SQLITE_LIMIT_ATTACHED&lt;/a&gt; , на количество баз данных, которые могут быть одновременно подключены к одному соединению с базой данных.</target>
        </trans-unit>
        <trans-unit id="d03b97c401c9a348f14fea8d291ce117238dc810" translate="yes" xml:space="preserve">
          <source>There is a long list of conditions that must all be met in order for query flattening to occur. Some of the constraints are marked as obsolete by italic text. These extra constraints are retained in the documentation to preserve the numbering of the other constraints.</source>
          <target state="translated">Существует длинный список условий,которые должны быть выполнены для того,чтобы запрос сглаживался.Некоторые из ограничений помечены курсивом как устаревшие.Эти дополнительные ограничения сохраняются в документации для сохранения нумерации других ограничений.</target>
        </trans-unit>
        <trans-unit id="098b1868e66c13228c4371a548aa26b3bfac10d5" translate="yes" xml:space="preserve">
          <source>There is a new TypeOf() function used to determine if an expression is numeric or text.</source>
          <target state="translated">Появилась новая функция TypeOf(),используемая для определения,является ли выражение числовым или текстовым.</target>
        </trans-unit>
        <trans-unit id="e6da2fbcc052924976fcf688d82595c343604804" translate="yes" xml:space="preserve">
          <source>There is a single row in the sqlite_sequence table for each ordinary table that uses AUTOINCREMENT. The name of the table (as it appears in sqlite_master.name) is in the sqlite_sequence.main field and the largest &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; ever inserted into that table is in the sqlite_sequence.seq field. New automatically generated integer primary keys for AUTOINCREMENT tables are guaranteed to be larger than the sqlite_sequence.seq field for that table. If the sqlite_sequence.seq field of an AUTOINCREMENT table is already at the largest integer value (9223372036854775807) then attempts to add new rows to that table with an automatically generated integer primary will fail with an &lt;a href=&quot;rescode#full&quot;&gt;SQLITE_FULL&lt;/a&gt; error. The sqlite_sequence.seq field is automatically updated if required when new entries are inserted to an AUTOINCREMENT table. The sqlite_sequence row for an AUTOINCREMENT table is automatically deleted when the table is dropped. If the sqlite_sequence row for an AUTOINCREMENT table does not exist when the AUTOINCREMENT table is updated, then a new sqlite_sequence row is created. If the sqlite_sequence.seq value for an AUTOINCREMENT table is manually set to something other than an integer and there is a subsequent attempt to insert the or update the AUTOINCREMENT table, then the behavior is undefined.</source>
          <target state="translated">В таблице sqlite_sequence есть одна строка для каждой обычной таблицы, в которой используется AUTOINCREMENT. Имя таблицы (как оно отображается в sqlite_master.name) находится в поле sqlite_sequence.main, а самый большой &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY,&lt;/a&gt; когда-либо вставленный в эту таблицу, находится в поле sqlite_sequence.seq. Новые автоматически сгенерированные целочисленные первичные ключи для таблиц AUTOINCREMENT гарантированно будут больше, чем поле sqlite_sequence.seq для этой таблицы. Если поле sqlite_sequence.seq таблицы AUTOINCREMENT уже имеет наибольшее целочисленное значение (9223372036854775807), тогда попытки добавить новые строки в эту таблицу с автоматически сгенерированным целочисленным первичным числом завершатся ошибкой с &lt;a href=&quot;rescode#full&quot;&gt;SQLITE_FULL&lt;/a&gt;ошибка. Поле sqlite_sequence.seq автоматически обновляется при необходимости, когда новые записи вставляются в таблицу AUTOINCREMENT. Строка sqlite_sequence для таблицы AUTOINCREMENT автоматически удаляется при удалении таблицы. Если строка sqlite_sequence для таблицы AUTOINCREMENT не существует при обновлении таблицы AUTOINCREMENT, то создается новая строка sqlite_sequence. Если значение sqlite_sequence.seq для таблицы AUTOINCREMENT вручную установлено на значение, отличное от целого числа, и последующая попытка вставить или обновить таблицу AUTOINCREMENT, то поведение не определено.</target>
        </trans-unit>
        <trans-unit id="873101a14a572759e5a45b0dc79cf0cd42bbd9dd" translate="yes" xml:space="preserve">
          <source>There is a single row in the sqlite_sequence table for each ordinary table that uses AUTOINCREMENT. The name of the table (as it appears in sqlite_schema.name) is in the sqlite_sequence.main field and the largest &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; ever inserted into that table is in the sqlite_sequence.seq field. New automatically generated integer primary keys for AUTOINCREMENT tables are guaranteed to be larger than the sqlite_sequence.seq field for that table. If the sqlite_sequence.seq field of an AUTOINCREMENT table is already at the largest integer value (9223372036854775807) then attempts to add new rows to that table with an automatically generated integer primary will fail with an &lt;a href=&quot;rescode#full&quot;&gt;SQLITE_FULL&lt;/a&gt; error. The sqlite_sequence.seq field is automatically updated if required when new entries are inserted to an AUTOINCREMENT table. The sqlite_sequence row for an AUTOINCREMENT table is automatically deleted when the table is dropped. If the sqlite_sequence row for an AUTOINCREMENT table does not exist when the AUTOINCREMENT table is updated, then a new sqlite_sequence row is created. If the sqlite_sequence.seq value for an AUTOINCREMENT table is manually set to something other than an integer and there is a subsequent attempt to insert the or update the AUTOINCREMENT table, then the behavior is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f02c79b70988445eed051dee5ef879c5abc0fcef" translate="yes" xml:space="preserve">
          <source>There is a single row of the dbstat table for each page in the database file. Freelist pages, the lock page, and pointer-map pages of the database file do not appear in the dbstat virtual table.</source>
          <target state="translated">Для каждой страницы в файле базы данных есть одна строка таблицы dbstat.В виртуальной таблице dbstat не отображаются страницы фрилиста,страницы блокировки и страницы отображения указателя в файле базы данных.</target>
        </trans-unit>
        <trans-unit id="aad819f0714ba351410884e15d9171da8c02d268" translate="yes" xml:space="preserve">
          <source>There is also a &quot;.once -e&quot; command which works similarly, except that it names the temporary file with a &quot;.txt&quot; suffix so that the default text editor for the system will be invoked, instead of the default spreadsheet.</source>
          <target state="translated">Также существует команда &quot;.once -e&quot;,которая работает аналогичным образом,за исключением того,что она называет временный файл суффиксом &quot;.txt&quot; таким образом,что вместо стандартной электронной таблицы будет вызван текстовый редактор по умолчанию для системы.</target>
        </trans-unit>
        <trans-unit id="d689365d69d51f44124dabea5ed23d15cbc239dd" translate="yes" xml:space="preserve">
          <source>There is also a function for computing the Wagner edit distance or the Levenshtein distance between a pattern and a word. This function is exposed as spellfix1_editdist(X,Y). The edit distance function returns the &quot;cost&quot; of converting X into Y. Some transformations cost more than others. Changing one vowel into a different vowel, for example is relatively cheap, as is doubling a constant, or omitting the second character of a double-constant. Other transformations or more expensive. The idea is that the edit distance function returns a low cost for words that are similar and a higher cost for words that are further apart. In this implementation, the maximum cost of any single-character edit (delete, insert, or substitute) is 100, with lower costs for some edits (such as transforming vowels).</source>
          <target state="translated">Существует также функция для вычисления расстояния редактирования Вагнера или расстояния Левенштейна между деталью и словом.Эта функция выставляется как spellfix1_editdist(X,Y).Функция расстояния редактирования возвращает &quot;стоимость&quot; преобразования X в Y.Некоторые преобразования стоят дороже других.Изменение одной гласной на другую,например,относительно дешево,как и удвоение константы,или опускание второго символа двойной константы.Другие преобразования или стоят дороже.Идея заключается в том,что функция расстояния редактирования возвращает низкую стоимость для слов,которые похожи,и более высокую стоимость для слов,которые находятся на большем расстоянии друг от друга.В этой реализации максимальная стоимость любого односимвольного редактирования (удаление,вставка или замена)составляет 100,с более низкими затратами на некоторые редактирования (например,преобразование гласных).</target>
        </trans-unit>
        <trans-unit id="8f729e8ad1be217b3b85bb1dbd08e4580826f423" translate="yes" xml:space="preserve">
          <source>There is also a new &lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlpowersafeoverwrite&quot;&gt;SQLITE_FCNTL_POWERSAFE_OVERWRITE&lt;/a&gt; opcode for the &lt;a href=&quot;c3ref/file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; that allows an application to query the powersafe overwrite property for a database file.</source>
          <target state="translated">Также существует новый код операции &lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlpowersafeoverwrite&quot;&gt;SQLITE_FCNTL_POWERSAFE_OVERWRITE&lt;/a&gt; для &lt;a href=&quot;c3ref/file_control&quot;&gt;sqlite3_file_control (),&lt;/a&gt; который позволяет приложению запрашивать свойство перезаписи в режиме энергосбережения для файла базы данных.</target>
        </trans-unit>
        <trans-unit id="d5d98dc46e0aff9a749813616cdf742a9f8913ea" translate="yes" xml:space="preserve">
          <source>There is also an SQL function that can be used to load extensions: &lt;a href=&quot;lang_corefunc#load_extension&quot;&gt;load_extension(X,Y)&lt;/a&gt;. It works just like the &lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension()&lt;/a&gt; C interface.</source>
          <target state="translated">Также существует функция SQL, которую можно использовать для загрузки расширений: &lt;a href=&quot;lang_corefunc#load_extension&quot;&gt;load_extension (X, Y)&lt;/a&gt; . Он работает так же, как интерфейс C. &lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension ()&lt;/a&gt; C.</target>
        </trans-unit>
        <trans-unit id="043cd14b86c980f673cef92a152d79c2c6e3cf2c" translate="yes" xml:space="preserve">
          <source>There is always a default VFS. The legacy interfaces &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt; and &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open16()&lt;/a&gt; always use the default VFS. The new interface for creating database connections, &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;, allows you to specify which VFS you want to use by name.</source>
          <target state="translated">Всегда есть VFS по умолчанию. &lt;a href=&quot;c3ref/open&quot;&gt;Устаревшие&lt;/a&gt; интерфейсы sqlite3_open () и &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open16 ()&lt;/a&gt; всегда используют VFS по умолчанию. Новый интерфейс для создания подключений к базе данных &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2 ()&lt;/a&gt; позволяет вам указать, какую VFS вы хотите использовать по имени.</target>
        </trans-unit>
        <trans-unit id="a75d63f61cb222d77eadc6074711ab25e460df12" translate="yes" xml:space="preserve">
          <source>There is always one VFS which is the default VFS. On unix systems, the &quot;unix&quot; VFS comes up as the default and on windows it is &quot;win32&quot;. If no other actions are taken, new database connections will make use of the default VFS.</source>
          <target state="translated">Всегда есть одна VFS,которая является VFS по умолчанию.На unix-системах по умолчанию появляется &quot;unix&quot; VFS,а в окнах-&quot;win32&quot;.Если другие действия не предпринимаются,новые подключения к базе данных будут использовать VFS по умолчанию.</target>
        </trans-unit>
        <trans-unit id="a07e87b2dfc85be098248de6c63083968b9cc2a5" translate="yes" xml:space="preserve">
          <source>There is an additional quasi-persistent &quot;&lt;code&gt;-wal&lt;/code&gt;&quot; file and &quot;&lt;code&gt;-shm&lt;/code&gt;&quot; shared memory file associated with each database, which can make SQLite less appealing for use as an &lt;a href=&quot;appfileformat&quot;&gt;application file-format&lt;/a&gt;.</source>
          <target state="translated">Существует дополнительный квази-стойкий &amp;laquo; &lt;code&gt;-wal&lt;/code&gt; &amp;raquo; файл и &amp;laquo; &lt;code&gt;-shm&lt;/code&gt; &amp;raquo; совместно используемый файл память , связанный с каждой базой данных, которая может сделать SQLite менее привлекательным для использования в качестве &lt;a href=&quot;appfileformat&quot;&gt;файла формата приложение&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6c15ef6d2dec509f5afb1c6ad236607cae0e66e0" translate="yes" xml:space="preserve">
          <source>There is an assortment of sqlite3_bind routines used to assign values to wildcards in a prepared SQL statement. Unbound wildcards are interpreted as NULLs. Bindings are not reset by sqlite3_reset(). But wildcards can be rebound to new values after an sqlite3_reset().</source>
          <target state="translated">Существует ассортимент процедур sqlite3_bind,используемых для присвоения значений подстановочным знакам в подготовленном SQL операторе.Несвязанные подстановочные знаки интерпретируются как NULL.Привязки не сбрасываются функцией sqlite3_reset().Но после функции sqlite3_reset()подстановочные знаки могут быть возвращены к новым значениям.</target>
        </trans-unit>
        <trans-unit id="1cba197f7f4cf87333685b6d55dd8ea7d285abdf" translate="yes" xml:space="preserve">
          <source>There is an implied &quot;&lt;a href=&quot;opcode#Halt&quot;&gt;Halt&lt;/a&gt; 0 0 0&quot; instruction inserted at the very end of every program. So a jump past the last instruction of the program is the same as executing &lt;a href=&quot;opcode#Halt&quot;&gt;Halt&lt;/a&gt;.</source>
          <target state="translated">Подразумевается, что в самом конце каждой программы вставляется инструкция &amp;laquo; &lt;a href=&quot;opcode#Halt&quot;&gt;Halt&lt;/a&gt; 0 0 0&amp;raquo;. Таким образом, переход за последнюю инструкцию программы аналогичен выполнению &lt;a href=&quot;opcode#Halt&quot;&gt;Halt&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="16ef4ec82cf13cdae86f5bf01316c19576909f0f" translate="yes" xml:space="preserve">
          <source>There is an unofficial and unsanctioned Git clone of this repository at &lt;a href=&quot;https://github.com/mackyle/sqlite&quot;&gt;https://github.com/mackyle/sqlite&lt;/a&gt;.</source>
          <target state="translated">Существует неофициальный и несанкционированный клон Git этого репозитория по адресу &lt;a href=&quot;https://github.com/mackyle/sqlite&quot;&gt;https://github.com/mackyle/sqlite&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bea5c372cd0bf0b6a49c619c32079d5921e4aed3" translate="yes" xml:space="preserve">
          <source>There is another, deprecated, method for invoking the optimize operation using a SELECT statement. New code should use statements similar to the INSERT above to optimize FTS structures.</source>
          <target state="translated">Существует еще один,устаревший метод вызова операции оптимизации с помощью оператора SELECT.В новом коде для оптимизации структур FTS должны использоваться утверждения,аналогичные приведенному выше INSERT.</target>
        </trans-unit>
        <trans-unit id="b085a1ad6ab5d12c0b0eb9f325abf631b21418bf" translate="yes" xml:space="preserve">
          <source>There is no &quot;CREATE TEMP VIRTUAL TABLE&quot; statement. To create a temporary virtual table, add the &quot;temp&quot; schema before the virtual table name.</source>
          <target state="translated">Заявления &quot;CREATE TEMP VIRTUAL TABLE&quot; не существует.Чтобы создать временную виртуальную таблицу,добавьте схему &quot;temp&quot; перед именем виртуальной таблицы.</target>
        </trans-unit>
        <trans-unit id="f17db4bcecd606fe4d51c30c972432fc774cef49" translate="yes" xml:space="preserve">
          <source>There is no RESERVED lock on the corresponding database file.</source>
          <target state="translated">В соответствующем файле базы данных нет RESERVED-блокировки.</target>
        </trans-unit>
        <trans-unit id="e99ed00de2d6f07769da563a3ed2aa8bf01a7e2e" translate="yes" xml:space="preserve">
          <source>There is no agreement on what the C datatype for a UTF-16 string should be. Therefore, SQLite uses a generic type of void* to refer to UTF-16 strings. Client software can cast the void* to whatever datatype is appropriate for their system.</source>
          <target state="translated">Нет согласия по поводу того,каким должен быть тип данных C для строки UTF-16.Поэтому SQLite использует общий тип void*для ссылки на строки UTF-16.Клиентское программное обеспечение может приводить void*к любому типу данных,подходящему для его системы.</target>
        </trans-unit>
        <trans-unit id="c505515229e6ccfbb2128baeaa4350ad9e337f7c" translate="yes" xml:space="preserve">
          <source>There is no conflicting row in this case. The results of invoking the sqlite3changeset_conflict() API are undefined.</source>
          <target state="translated">В этом случае нет противоречивых строк.Результаты вызова sqlite3changeset_conflict()API неопределенны.</target>
        </trans-unit>
        <trans-unit id="a04b936246a75ee50e5104c87c5e5c3bc05ae139" translate="yes" xml:space="preserve">
          <source>There is no pre-defined release cycle. Releases occur when there is a critical mass of feature enhancements and/or bug fixes. Historically, releases have occurred about 5 or 6 times per year. Users of SQLite pick up new releases from the website on an as-needed basis.</source>
          <target state="translated">Предварительного цикла выпуска нет.Релизы происходят при наличии критической массы улучшений и/или исправлений.Исторически релизы происходили примерно 5-6 раз в год.Пользователи SQLite получают новые релизы с сайта по мере необходимости.</target>
        </trans-unit>
        <trans-unit id="dd71d330015524aacf28e91f9c23458da952387d" translate="yes" xml:space="preserve">
          <source>There is no reserved lock on the main database file.</source>
          <target state="translated">В главном файле БД нет зарезервированной блокировки.</target>
        </trans-unit>
        <trans-unit id="7df732794b7961185fb08c11a413b1539639964a" translate="yes" xml:space="preserve">
          <source>There is no support for &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt;. Changes to virtual tables are not captured.</source>
          <target state="translated">Нет поддержки &lt;a href=&quot;vtab&quot;&gt;виртуальных таблиц&lt;/a&gt; . Изменения виртуальных таблиц не фиксируются.</target>
        </trans-unit>
        <trans-unit id="11d7bfeb25e84c6d1e9766a1abf1f94079350c5e" translate="yes" xml:space="preserve">
          <source>There is normally one row per index, with the index identified by the name in the sqlite_stat1.idx column. The sqlite_stat1.tbl column is the name of the table to which the index belongs. In each such row, the sqlite_stat.stat column will be a string consisting of a list of integers followed by zero or more arguments. The first integer in this list is the approximate number of rows in the index. (The number of rows in the index is the same as the number of rows in the table, except for &lt;a href=&quot;partialindex&quot;&gt;partial indexes&lt;/a&gt;.) The second integer is the approximate number of rows in the index that have the same value in the first column of the index. The third integer is the number number of rows in the index that have the same value for the first two columns. The N-th integer (for N&amp;gt;1) is the estimated average number of rows in the index which have the same value for the first N-1 columns. For a K-column index, there will be K+1 integers in the stat column. If the index is unique, then the last integer will be 1.</source>
          <target state="translated">Обычно на каждый индекс приходится одна строка, причем индекс определяется именем в столбце sqlite_stat1.idx. Столбец sqlite_stat1.tbl - это имя таблицы, к которой принадлежит индекс. В каждой такой строке столбец sqlite_stat.stat будет строкой, состоящей из списка целых чисел, за которым следует ноль или более аргументов. Первое целое число в этом списке - приблизительное количество строк в индексе. (Количество строк в индексе такое же, как количество строк в таблице, за исключением &lt;a href=&quot;partialindex&quot;&gt;частичных индексов&lt;/a&gt;.) Второе целое число - это приблизительное количество строк в индексе, которые имеют такое же значение в первом столбце индекса. Третье целое число - это количество строк в индексе, которые имеют одинаковое значение для первых двух столбцов. N-е целое число (для N&amp;gt; 1) - это оценочное среднее количество строк в индексе, которые имеют одинаковое значение для первых N-1 столбцов. Для индекса K-столбца в столбце stat будет K + 1 целых чисел. Если индекс уникален, то последнее целое число будет равно 1.</target>
        </trans-unit>
        <trans-unit id="c9c3e6d9120e8e4bfa41b1d6a3111f7343cb6f19" translate="yes" xml:space="preserve">
          <source>There is now a compile-time option that allows an application to define alternative malloc()/free() implementations without having to modify any core SQLite code.</source>
          <target state="translated">Теперь существует возможность компиляции,которая позволяет приложению определять альтернативные реализации malloc()/free()без необходимости модификации основного кода SQLite.</target>
        </trans-unit>
        <trans-unit id="f62ae2b58bd448bf76ec1b9c9d9ded56906eaff1" translate="yes" xml:space="preserve">
          <source>There is now a compile-time option that allows an application to define alternative mutex implementations without having to modify any core SQLite code.</source>
          <target state="translated">Теперь существует возможность компиляции,которая позволяет приложению определять альтернативные реализации мьютекса без необходимости модификации основного кода SQLite.</target>
        </trans-unit>
        <trans-unit id="b1cb6058c59ace1351641df9e565cb12b51e73fe" translate="yes" xml:space="preserve">
          <source>There is one entry in the %_node table for each R*Tree node. An R*Tree node consists of one or more entries that are proximate to one another. The nodes of an R*Tree for a tree. All nodes other than the root have an entry in the %_parent shadow table that identifies the parent node. Each entry in an R*Tree has a rowid. The %_rowid shadow table maps entry rowids to the node that contains that entry.</source>
          <target state="translated">Для каждого узла R*Tree в таблице %_node есть одна запись.Узел R*Tree состоит из одной или нескольких записей,которые находятся в непосредственной близости друг от друга.Узлы R*Tree для дерева.Все узлы,кроме корня,имеют запись в таблице тени %_parent,которая идентифицирует родительский узел.Каждая запись в R*Tree имеет ряд.Таблица тени %_rowsid сопоставляет рядки записей узлу,который содержит эту запись.</target>
        </trans-unit>
        <trans-unit id="91aa566670abb0466fc190ee57ffd69271a7af7c" translate="yes" xml:space="preserve">
          <source>There is one exception to the previous paragraph: when a row is inserted, updated or deleted, if one or more of its primary key columns contain a NULL value, no record of the change is made.</source>
          <target state="translated">Есть одно исключение из предыдущего параграфа:когда строка вставляется,обновляется или удаляется,если один или несколько столбцов первичного ключа содержат NULL-значение,запись об изменении не производится.</target>
        </trans-unit>
        <trans-unit id="545885bb104866881571615fd910604fef6b0f44" translate="yes" xml:space="preserve">
          <source>There is one important difference between ON UPDATE foreign key actions and SQL triggers. An ON UPDATE action is only taken if the values of the parent key are modified so that the new parent key values are not equal to the old. For example:</source>
          <target state="translated">Существует одно важное отличие между действием постороннего ключа ON UPDATE и триггерами SQL.Действие ON UPDATE выполняется только в том случае,если значения родительского ключа изменены таким образом,что новые значения родительского ключа не совпадают со старыми.Например:</target>
        </trans-unit>
        <trans-unit id="67f4030e1b4840bae9054c024eff72bf5cb42560" translate="yes" xml:space="preserve">
          <source>There is one other subtle difference between &quot;docid&quot; and the normal SQLite aliases for the rowid column. Normally, if an INSERT or UPDATE statement assigns discrete values to two or more aliases of the rowid column, SQLite writes the rightmost of such values specified in the INSERT or UPDATE statement to the database. However, assigning a non-NULL value to both the &quot;docid&quot; and one or more of the SQLite rowid aliases when inserting or updating an FTS table is considered an error. See below for an example.</source>
          <target state="translated">Есть еще одно тонкое различие между &quot;docid&quot; и обычными псевдонимами SQLite для столбца rowid.Обычно,если оператор INSERT или UPDATE присваивает дискретные значения двум или более псевдонимам столбца rowid,SQLite записывает в БД самую правую часть таких значений,указанных в операторе INSERT или UPDATE.Однако присвоение значения,отличного от NULL,как &quot;docid&quot;,так и одного или более псевдонимов рядковых столбцов SQLite при вставке или обновлении таблицы FTS считается ошибкой.См.пример ниже.</target>
        </trans-unit>
        <trans-unit id="f856aedc1ad69cfc42357d4bdb200682208f50ab" translate="yes" xml:space="preserve">
          <source>There is only one sorter object, so there are no instructions to open or close it. It is opened automatically when needed, and it is closed when the VDBE program halts.</source>
          <target state="translated">Существует только один объект сортировщика,поэтому нет инструкций по его открытию или закрытию.Он открывается автоматически при необходимости,и закрывается,когда программа VDBE останавливается.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
