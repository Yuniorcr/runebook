<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="sqlite">
    <body>
      <group id="sqlite">
        <trans-unit id="99bed95a8c8918c9ad675486624a0ec50cca0b55" translate="yes" xml:space="preserve">
          <source>The maximum amount of general-purpose memory needed by the application is determined by such factors as how many simultaneous open &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; and &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; objects the application uses, and on the complexity of the &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statements&lt;/a&gt;. For any given application, these factors are normally fixed and can be determined experimentally using &lt;a href=&quot;c3ref/c_status_malloc_count#sqlitestatusmemoryused&quot;&gt;SQLITE_STATUS_MEMORY_USED&lt;/a&gt;. A typical application might only use about 40KB of general-purpose memory. This gives a value of &lt;b&gt;N&lt;/b&gt; of around 100KB.</source>
          <target state="translated">Максимальный объем памяти общего назначения, необходимый приложению, определяется такими факторами, как количество одновременных открытых &lt;a href=&quot;c3ref/sqlite3&quot;&gt;соединений с базой данных&lt;/a&gt; и &lt;a href=&quot;c3ref/stmt&quot;&gt;подготовленных&lt;/a&gt; объектов операторов, которые использует приложение, а также сложность &lt;a href=&quot;c3ref/stmt&quot;&gt;подготовленных операторов&lt;/a&gt; . Для любого конкретного приложения эти факторы обычно фиксированы и могут быть определены экспериментально с помощью &lt;a href=&quot;c3ref/c_status_malloc_count#sqlitestatusmemoryused&quot;&gt;SQLITE_STATUS_MEMORY_USED&lt;/a&gt; . Типичное приложение может использовать только около 40 КБ памяти общего назначения. Это дает значение &lt;b&gt;N&lt;/b&gt; около 100 КБ.</target>
        </trans-unit>
        <trans-unit id="a9b767b87a835989935611d9f91af0a49ef22427" translate="yes" xml:space="preserve">
          <source>The maximum and minimum embedded payload fractions and the leaf payload fraction values must be 64, 32, and 32. These values were originally intended to be tunable parameters that could be used to modify the storage format of the b-tree algorithm. However, that functionality is not supported and there are no current plans to add support in the future. Hence, these three bytes are fixed at the values specified.</source>
          <target state="translated">Максимальные и минимальные значения дроби полезной нагрузки и дроби полезной нагрузки листа должны быть 64,32 и 32.Эти значения изначально задумывались как настраиваемые параметры,которые можно было бы использовать для изменения формата хранения алгоритма b-дерева.Однако эта функциональность не поддерживается,и в настоящее время нет планов по добавлению поддержки в будущем.Следовательно,эти три байта фиксируются на заданных значениях.</target>
        </trans-unit>
        <trans-unit id="3b75dd01c336dd48a91229fb4fe465cfca0656d8" translate="yes" xml:space="preserve">
          <source>The maximum depth of an expression tree can be lowered at run-time using the &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitexprdepth&quot;&gt;SQLITE_LIMIT_EXPR_DEPTH&lt;/a&gt;,size) interface if the SQLITE_MAX_EXPR_DEPTH is initially positive. In other words, the maximum expression depth can be lowered at run-time if there is already a compile-time limit on the expression depth. If SQLITE_MAX_EXPR_DEPTH is set to 0 at compile time (if the depth of expressions is unlimited) then the &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitexprdepth&quot;&gt;SQLITE_LIMIT_EXPR_DEPTH&lt;/a&gt;,size) is a no-op.</source>
          <target state="translated">Максимальную глубину дерева выражения можно уменьшить во время выполнения с помощью интерфейса &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt; (db, &lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitexprdepth&quot;&gt;SQLITE_LIMIT_EXPR_DEPTH&lt;/a&gt; , size), если значение SQLITE_MAX_EXPR_DEPTH изначально положительное. Другими словами, максимальная глубина выражения может быть снижена во время выполнения, если уже существует ограничение времени компиляции на глубину выражения. Если SQLITE_MAX_EXPR_DEPTH установлен в 0 во время компиляции (если глубина выражений не ограничена), тогда &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt; (db, &lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitexprdepth&quot;&gt;SQLITE_LIMIT_EXPR_DEPTH&lt;/a&gt; , size) не работает.</target>
        </trans-unit>
        <trans-unit id="7601f568790af4a666771d9637268d8679fb90bb" translate="yes" xml:space="preserve">
          <source>The maximum depth of recursion for triggers.</source>
          <target state="translated">Максимальная глубина рекурсии для триггеров.</target>
        </trans-unit>
        <trans-unit id="f7ca88d6870cff0eca30922b0b5339bd065f10ca" translate="yes" xml:space="preserve">
          <source>The maximum depth of the parse tree on any expression.</source>
          <target state="translated">Максимальная глубина дерева разбора по любому выражению.</target>
        </trans-unit>
        <trans-unit id="2e6bbb757edd69dcf67031bc6d4f260f516ed8d0" translate="yes" xml:space="preserve">
          <source>The maximum host parameter number can be lowered at run-time using the &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitvariablenumber&quot;&gt;SQLITE_LIMIT_VARIABLE_NUMBER&lt;/a&gt;,size) interface.</source>
          <target state="translated">Максимальное количество параметров хоста можно уменьшить во время выполнения с помощью интерфейса &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt; (db, &lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitvariablenumber&quot;&gt;SQLITE_LIMIT_VARIABLE_NUMBER&lt;/a&gt; , size).</target>
        </trans-unit>
        <trans-unit id="b3e774d908522cebf9bd7f7f3469b3fb31276410" translate="yes" xml:space="preserve">
          <source>The maximum index number of any &lt;a href=&quot;../lang_expr#varparam&quot;&gt;parameter&lt;/a&gt; in an SQL statement.</source>
          <target state="translated">Максимальный порядковый номер любого &lt;a href=&quot;../lang_expr#varparam&quot;&gt;параметра&lt;/a&gt; в инструкции SQL.</target>
        </trans-unit>
        <trans-unit id="32a6d72e37d636464c2192cbf409c3425887feb6" translate="yes" xml:space="preserve">
          <source>The maximum index number of any &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameter&lt;/a&gt; in an SQL statement.</source>
          <target state="translated">Максимальный порядковый номер любого &lt;a href=&quot;lang_expr#varparam&quot;&gt;параметра&lt;/a&gt; в инструкции SQL.</target>
        </trans-unit>
        <trans-unit id="ab2a11cb65d0770d55a8b43b094028bd3c341a46" translate="yes" xml:space="preserve">
          <source>The maximum length of a LIKE or GLOB pattern can be lowered at run-time using the &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitlikepatternlength&quot;&gt;SQLITE_LIMIT_LIKE_PATTERN_LENGTH&lt;/a&gt;,size) interface.</source>
          <target state="translated">Максимальную длину шаблона LIKE или GLOB можно уменьшить во время выполнения с помощью интерфейса &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt; (db, &lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitlikepatternlength&quot;&gt;SQLITE_LIMIT_LIKE_PATTERN_LENGTH&lt;/a&gt; , size).</target>
        </trans-unit>
        <trans-unit id="295e913f367222db2770c86b223d1cb94f3eaca7" translate="yes" xml:space="preserve">
          <source>The maximum length of a SQL function name is 255 bytes of UTF8. Any attempt to create a function with a longer name will result in an &lt;a href=&quot;rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt; error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d765036961e5dc86e0ba5117af47c297fab27c55" translate="yes" xml:space="preserve">
          <source>The maximum length of an SQL statement can be lowered at run-time using the &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitsqllength&quot;&gt;SQLITE_LIMIT_SQL_LENGTH&lt;/a&gt;,size) interface.</source>
          <target state="translated">Максимальную длину оператора SQL можно уменьшить во время выполнения с помощью интерфейса &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt; (db, &lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitsqllength&quot;&gt;SQLITE_LIMIT_SQL_LENGTH&lt;/a&gt; , size).</target>
        </trans-unit>
        <trans-unit id="d303fbf5ebde80b928a0a149ac1d360f8b2d9beb" translate="yes" xml:space="preserve">
          <source>The maximum length of an SQL statement, in bytes.</source>
          <target state="translated">Максимальная длина SQL-оператора,в байтах.</target>
        </trans-unit>
        <trans-unit id="c8feb93491c3d188a9985624d09a15796f2e0e57" translate="yes" xml:space="preserve">
          <source>The maximum length of the pattern argument to the &lt;a href=&quot;../lang_expr#like&quot;&gt;LIKE&lt;/a&gt; or &lt;a href=&quot;../lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; operators.</source>
          <target state="translated">Максимальная длина аргумента шаблона для операторов &lt;a href=&quot;../lang_expr#like&quot;&gt;LIKE&lt;/a&gt; или &lt;a href=&quot;../lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1ee02be23a19dec285dd5109a44c64362161f0e7" translate="yes" xml:space="preserve">
          <source>The maximum length of the pattern argument to the &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; or &lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; operators.</source>
          <target state="translated">Максимальная длина аргумента шаблона для операторов &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; или &lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b23da6f4323ba72ffe46e74c0191923768cdb864" translate="yes" xml:space="preserve">
          <source>The maximum number of &lt;a href=&quot;../lang_attach&quot;&gt;attached databases&lt;/a&gt;.</source>
          <target state="translated">Максимальное количество &lt;a href=&quot;../lang_attach&quot;&gt;подключенных баз данных&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b544569d59df80608bd6a41e19a745bdff4577b6" translate="yes" xml:space="preserve">
          <source>The maximum number of &lt;a href=&quot;lang_attach&quot;&gt;attached databases&lt;/a&gt;.</source>
          <target state="translated">Максимальное количество &lt;a href=&quot;lang_attach&quot;&gt;подключенных баз данных&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="471b9bc71d47534b60a1c278c46d4cee7c9664ba" translate="yes" xml:space="preserve">
          <source>The maximum number of arguments in a function can be lowered at run-time using the &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitfunctionarg&quot;&gt;SQLITE_LIMIT_FUNCTION_ARG&lt;/a&gt;,size) interface.</source>
          <target state="translated">Максимальное количество аргументов в функции можно уменьшить во время выполнения с помощью интерфейса &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt; (db, &lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitfunctionarg&quot;&gt;SQLITE_LIMIT_FUNCTION_ARG&lt;/a&gt; , size).</target>
        </trans-unit>
        <trans-unit id="00eff3b06f801e572f28af21289c2619b46c2f08" translate="yes" xml:space="preserve">
          <source>The maximum number of arguments on a function.</source>
          <target state="translated">Максимальное количество аргументов в функции.</target>
        </trans-unit>
        <trans-unit id="b6c416e24701b8851e7053c0bb7cd7dd6b331315" translate="yes" xml:space="preserve">
          <source>The maximum number of attached databases can be lowered at run-time using the &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitattached&quot;&gt;SQLITE_LIMIT_ATTACHED&lt;/a&gt;,size) interface.</source>
          <target state="translated">Максимальное количество подключенных баз данных можно уменьшить во время выполнения с помощью интерфейса &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt; (db, &lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitattached&quot;&gt;SQLITE_LIMIT_ATTACHED&lt;/a&gt; , size).</target>
        </trans-unit>
        <trans-unit id="0b6c3c6cf8605d1353c6caeac57deb9da3ed0c6e" translate="yes" xml:space="preserve">
          <source>The maximum number of auxiliary worker threads that a single &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; may start.</source>
          <target state="translated">Максимальное количество вспомогательных рабочих потоков, которые может запустить один &lt;a href=&quot;#sqlite3_stmt&quot;&gt;подготовленный оператор&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="66f8c3a081d879e272abf19945402c6cac2a7ecc" translate="yes" xml:space="preserve">
          <source>The maximum number of auxiliary worker threads that a single &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; may start.</source>
          <target state="translated">Максимальное количество вспомогательных рабочих потоков, которые может запустить один &lt;a href=&quot;stmt&quot;&gt;подготовленный оператор&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bbb454e2483711c9ac94945a0c80d3f47e450874" translate="yes" xml:space="preserve">
          <source>The maximum number of bytes in a string or BLOB in SQLite is defined by the preprocessor macro SQLITE_MAX_LENGTH. The default value of this macro is 1 billion (1 thousand million or 1,000,000,000). You can raise or lower this value at compile-time using a command-line option like this:</source>
          <target state="translated">Максимальное количество байт в строке или BLOB в SQLite определяется препроцессорным макросом SQLITE_MAX_LENGTH.По умолчанию значение этого макроса составляет 1 миллиард (1 тысячу миллионов или 1 000 000 000).Вы можете увеличить или уменьшить это значение во время компиляции,используя опцию командной строки,подобную этой:</target>
        </trans-unit>
        <trans-unit id="da1ee68dd77283238b55af162c380f02592134ee" translate="yes" xml:space="preserve">
          <source>The maximum number of bytes in the text of an SQL statement is limited to SQLITE_MAX_SQL_LENGTH which defaults to 1000000. You can redefine this limit to be as large as the smaller of SQLITE_MAX_LENGTH and 1073741824.</source>
          <target state="translated">Максимальное количество байт в тексте SQL-оператора ограничено SQLITE_MAX_SQL_LENGTH,который по умолчанию имеет значение 1000000.Вы можете переопределить это ограничение так,чтобы оно было таким же большим,как и меньшее из SQLITE_MAX_LENGTH и 1073741824.</target>
        </trans-unit>
        <trans-unit id="6345ddabb514350f3e36f681af647ea84308cf28" translate="yes" xml:space="preserve">
          <source>The maximum number of columns can be lowered at run-time using the &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitcolumn&quot;&gt;SQLITE_LIMIT_COLUMN&lt;/a&gt;,size) interface.</source>
          <target state="translated">Максимальное количество столбцов можно уменьшить во время выполнения с помощью интерфейса &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt; (db, &lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitcolumn&quot;&gt;SQLITE_LIMIT_COLUMN&lt;/a&gt; , size).</target>
        </trans-unit>
        <trans-unit id="1c620a336050426a95c894972afda47b3aee66a2" translate="yes" xml:space="preserve">
          <source>The maximum number of columns in a table definition or in the result set of a &lt;a href=&quot;../lang_select&quot;&gt;SELECT&lt;/a&gt; or the maximum number of columns in an index or in an ORDER BY or GROUP BY clause.</source>
          <target state="translated">Максимальное количество столбцов в определении таблицы или в результирующем наборе &lt;a href=&quot;../lang_select&quot;&gt;оператора SELECT&lt;/a&gt; или максимальное количество столбцов в индексе или в предложении ORDER BY или GROUP BY.</target>
        </trans-unit>
        <trans-unit id="355eec7f9bb7446523a2374f005ae8119aa229d8" translate="yes" xml:space="preserve">
          <source>The maximum number of columns in a table definition or in the result set of a &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; or the maximum number of columns in an index or in an ORDER BY or GROUP BY clause.</source>
          <target state="translated">Максимальное количество столбцов в определении таблицы или в результирующем наборе &lt;a href=&quot;lang_select&quot;&gt;оператора SELECT&lt;/a&gt; или максимальное количество столбцов в индексе или в предложении ORDER BY или GROUP BY.</target>
        </trans-unit>
        <trans-unit id="8374b8e68f54521ffc214c5ed7e8c2d7fd95f1b7" translate="yes" xml:space="preserve">
          <source>The maximum number of compound SELECT terms can be lowered at run-time using the &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitcompoundselect&quot;&gt;SQLITE_LIMIT_COMPOUND_SELECT&lt;/a&gt;,size) interface.</source>
          <target state="translated">Максимальное количество составных терминов SELECT можно уменьшить во время выполнения с помощью интерфейса &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt; (db, &lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitcompoundselect&quot;&gt;SQLITE_LIMIT_COMPOUND_SELECT&lt;/a&gt; , size).</target>
        </trans-unit>
        <trans-unit id="63cbc7c9607d5bbb2a5e8441eb06e668604fc05c" translate="yes" xml:space="preserve">
          <source>The maximum number of instructions in a virtual machine program used to implement an SQL statement. If &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; or the equivalent tries to allocate space for more than this many opcodes in a single prepared statement, an SQLITE_NOMEM error is returned.</source>
          <target state="translated">Максимальное количество инструкций в программе виртуальной машины, используемых для реализации оператора SQL. Если &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; или эквивалент пытается выделить пространство для большего количества кодов операций в одном подготовленном операторе, возвращается ошибка SQLITE_NOMEM.</target>
        </trans-unit>
        <trans-unit id="3914cdf98f328c74ff19ff41972588f848a7b49e" translate="yes" xml:space="preserve">
          <source>The maximum number of instructions in a virtual machine program used to implement an SQL statement. If &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; or the equivalent tries to allocate space for more than this many opcodes in a single prepared statement, an SQLITE_NOMEM error is returned.</source>
          <target state="translated">Максимальное количество инструкций в программе виртуальной машины, используемых для реализации оператора SQL. Если &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; или эквивалент пытается выделить пространство для большего количества кодов операций в одном подготовленном операторе, возвращается ошибка SQLITE_NOMEM.</target>
        </trans-unit>
        <trans-unit id="7c57be7916f18cb9fd931235954ed49b10f67a38" translate="yes" xml:space="preserve">
          <source>The maximum number of terms in a compound SELECT statement.</source>
          <target state="translated">Максимальное количество терминов в составном заявлении SELECT.</target>
        </trans-unit>
        <trans-unit id="6409e263b558e4fc8032ff274ccb7661be29c559" translate="yes" xml:space="preserve">
          <source>The maximum number of tokens in the returned text. This must be greater than zero and equal to or less than 64.</source>
          <target state="translated">Максимальное количество маркеров в возвращаемом тексте.Оно должно быть больше нуля и равно или меньше 64.</target>
        </trans-unit>
        <trans-unit id="970d6e67d87a8bc5f32df0c8fe5b2ab66eff4335" translate="yes" xml:space="preserve">
          <source>The maximum parameter number is set at compile-time by the &lt;a href=&quot;limits#max_variable_number&quot;&gt;SQLITE_MAX_VARIABLE_NUMBER&lt;/a&gt; macro. An individual &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; D can reduce its maximum parameter number below the compile-time maximum using the &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;(D, &lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitvariablenumber&quot;&gt;SQLITE_LIMIT_VARIABLE_NUMBER&lt;/a&gt;,...) interface.</source>
          <target state="translated">Максимальный номер параметра устанавливается во время &lt;a href=&quot;limits#max_variable_number&quot;&gt;компиляции&lt;/a&gt; макросом SQLITE_MAX_VARIABLE_NUMBER . Отдельное &lt;a href=&quot;c3ref/sqlite3&quot;&gt;соединение&lt;/a&gt; D с базой данных может уменьшить максимальное число параметров ниже максимума времени компиляции с помощью интерфейса &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt; (D, &lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitvariablenumber&quot;&gt;SQLITE_LIMIT_VARIABLE_NUMBER&lt;/a&gt; , ...).</target>
        </trans-unit>
        <trans-unit id="eeb9b32b1bfb4a0ced4bb9bc2aaa054c3abdfc92" translate="yes" xml:space="preserve">
          <source>The maximum size of any string or BLOB or table row, in bytes.</source>
          <target state="translated">Максимальный размер любой строки или BLOB или строки таблицы,в байтах.</target>
        </trans-unit>
        <trans-unit id="c7f288d6ab417ac4a35975a5356fac79645319c2" translate="yes" xml:space="preserve">
          <source>The maximum string or BLOB length can be lowered at run-time using the &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitlength&quot;&gt;SQLITE_LIMIT_LENGTH&lt;/a&gt;,size) interface.</source>
          <target state="translated">Максимальную длину строки или &lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitlength&quot;&gt;большого двоичного объекта&lt;/a&gt; можно уменьшить во время выполнения с помощью интерфейса &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt; (db, SQLITE_LIMIT_LENGTH , size).</target>
        </trans-unit>
        <trans-unit id="770a09ba0039805fb6c3142551082e18eaaafe07" translate="yes" xml:space="preserve">
          <source>The meaning of P5 depends on whether or not the SQLITE_ENABLE_NULL_TRIM compile-time option is enabled:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5cc8ccfaed1025b2039c6bdfd6b0a5399eacb5ca" translate="yes" xml:space="preserve">
          <source>The meanings for all $nResCode result code values are shown below, in numeric order.</source>
          <target state="translated">Значения для всех значений кода результата $nResCode показаны ниже,в числовом порядке.</target>
        </trans-unit>
        <trans-unit id="2c0dcd2e74747cfdf6b8873df9cf97a473ffe1cd" translate="yes" xml:space="preserve">
          <source>The meanings for all 102 result code values are shown below, in numeric order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4cad3638dbf4cc08ff40caa02c71d9ae2dc2cc12" translate="yes" xml:space="preserve">
          <source>The meanings for all 92 result code values are shown below, in numeric order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07eeff254885d567e91c4b2aaaeee641fbf91699" translate="yes" xml:space="preserve">
          <source>The meanings of the fields of the schema table are as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acfaa39aa41d2de54931d409a9de16ab158bc08a" translate="yes" xml:space="preserve">
          <source>The meanings of these various return values are as follows:</source>
          <target state="translated">Значения этих различных возвратных значений выглядят следующим образом:</target>
        </trans-unit>
        <trans-unit id="3594f845ca8155469ebf0d3a1db0993f4bb9cbd1" translate="yes" xml:space="preserve">
          <source>The measurements in this article were made during the week of 2017-06-05 using a version of SQLite in between 3.19.2 and 3.20.0. You may expect future versions of SQLite to perform even better.</source>
          <target state="translated">Измерения в данной статье проводились в течение недели 2017-06-05 годов с использованием версии SQLite между 3.19.2 и 3.20.0.Можно ожидать,что будущие версии SQLite будут работать еще лучше.</target>
        </trans-unit>
        <trans-unit id="5036b12169e90ae6667838e4b73b7f71ccf84ec9" translate="yes" xml:space="preserve">
          <source>The memory allocation limits can also be adjusted using &lt;a href=&quot;../pragma#pragma_soft_heap_limit&quot;&gt;PRAGMA soft_heap_limit&lt;/a&gt; and &lt;a href=&quot;../pragma#pragma_hard_heap_limit&quot;&gt;PRAGMA hard_heap_limit&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2809fd545c907ef31fca4768c017467b4928225" translate="yes" xml:space="preserve">
          <source>The memory allocation limits can also be adjusted using &lt;a href=&quot;pragma#pragma_soft_heap_limit&quot;&gt;PRAGMA soft_heap_limit&lt;/a&gt; and &lt;a href=&quot;pragma#pragma_hard_heap_limit&quot;&gt;PRAGMA hard_heap_limit&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e788358e2ac74022367111d33deb5ddc9a976282" translate="yes" xml:space="preserve">
          <source>The memory corruption problem becomes more acute when using &lt;a href=&quot;mmap&quot;&gt;memory-mapped I/O&lt;/a&gt;. When all or part of the database file is mapped into the application's address space, then a stray pointer that overwrites any part of that mapped space will immediately corrupt the database file, without requiring the application to do a subsequent write() system call.</source>
          <target state="translated">Проблема повреждения памяти становится более острой при использовании &lt;a href=&quot;mmap&quot;&gt;ввода-вывода с отображением памяти&lt;/a&gt; . Когда весь или часть файла базы данных отображается в адресное пространство приложения, случайный указатель, который перезаписывает любую часть этого отображаемого пространства, немедленно повреждает файл базы данных, не требуя от приложения выполнения последующего системного вызова write ().</target>
        </trans-unit>
        <trans-unit id="1f25753cb6dacb02b829c0a340f5d35891b7f9cb" translate="yes" xml:space="preserve">
          <source>The memory footprint of the application can be dramatically reduced by only loading content that is relevant to the current display and keeping the bulk of the content on disk. The fast query capability of SQLite make this a viable alternative to keeping all content in memory at all times. And when applications use less memory, it makes the entire computer more responsive, further enhancing the user experience.</source>
          <target state="translated">Плотность памяти приложения может быть значительно уменьшена за счет загрузки только того содержимого,которое имеет отношение к текущему дисплею,и сохранения основной части содержимого на диске.Возможности SQLite по быстрым запросам делают эту возможность жизнеспособной альтернативой постоянному хранению всего содержимого в памяти.А когда приложения используют меньше памяти,это делает весь компьютер более отзывчивым,еще больше повышая удобство работы пользователя.</target>
        </trans-unit>
        <trans-unit id="9d3e4b06e9105ca7c88a4e1edabcb69936b1841b" translate="yes" xml:space="preserve">
          <source>The memory high-water mark is reset to the current value of &lt;a href=&quot;#sqlite3_memory_highwater&quot;&gt;sqlite3_memory_used()&lt;/a&gt; if and only if the parameter to &lt;a href=&quot;#sqlite3_memory_highwater&quot;&gt;sqlite3_memory_highwater()&lt;/a&gt; is true. The value returned by &lt;a href=&quot;#sqlite3_memory_highwater&quot;&gt;sqlite3_memory_highwater(1)&lt;/a&gt; is the high-water mark prior to the reset.</source>
          <target state="translated">Метка максимума памяти сбрасывается до текущего значения &lt;a href=&quot;#sqlite3_memory_highwater&quot;&gt;sqlite3_memory_used ()&lt;/a&gt; тогда и только тогда, когда параметр &lt;a href=&quot;#sqlite3_memory_highwater&quot;&gt;sqlite3_memory_highwater ()&lt;/a&gt; имеет значение true. Значение, возвращаемое &lt;a href=&quot;#sqlite3_memory_highwater&quot;&gt;sqlite3_memory_highwater (1),&lt;/a&gt; является высшей отметкой до сброса.</target>
        </trans-unit>
        <trans-unit id="cd5593ab95a8d1e1ac6cc8d242678782f1a535e8" translate="yes" xml:space="preserve">
          <source>The memory high-water mark is reset to the current value of &lt;a href=&quot;memory_highwater&quot;&gt;sqlite3_memory_used()&lt;/a&gt; if and only if the parameter to &lt;a href=&quot;memory_highwater&quot;&gt;sqlite3_memory_highwater()&lt;/a&gt; is true. The value returned by &lt;a href=&quot;memory_highwater&quot;&gt;sqlite3_memory_highwater(1)&lt;/a&gt; is the high-water mark prior to the reset.</source>
          <target state="translated">Метка максимума памяти сбрасывается до текущего значения &lt;a href=&quot;memory_highwater&quot;&gt;sqlite3_memory_used ()&lt;/a&gt; тогда и только тогда, когда параметр &lt;a href=&quot;memory_highwater&quot;&gt;sqlite3_memory_highwater ()&lt;/a&gt; имеет значение true. Значение, возвращаемое &lt;a href=&quot;memory_highwater&quot;&gt;sqlite3_memory_highwater (1),&lt;/a&gt; является высшей отметкой до сброса.</target>
        </trans-unit>
        <trans-unit id="a98788d1208d8031c1910803fa2f1051d600b111" translate="yes" xml:space="preserve">
          <source>The memory pointed to by the character pointers returned for the declaration type and collation sequence is valid until the next call to any SQLite API function.</source>
          <target state="translated">Память,на которую указывают символьные указатели,возвращаемые для типа декларации и последовательности сравнения,действительна до следующего вызова любой функции SQLite API.</target>
        </trans-unit>
        <trans-unit id="523aa17230ae599153575b20eede454c13803757" translate="yes" xml:space="preserve">
          <source>The memory returned by sqlite3_malloc(), sqlite3_realloc(), sqlite3_malloc64(), and sqlite3_realloc64() is always aligned to at least an 8 byte boundary, or to a 4 byte boundary if the &lt;a href=&quot;../compile#4_byte_aligned_malloc&quot;&gt;SQLITE_4_BYTE_ALIGNED_MALLOC&lt;/a&gt; compile-time option is used.</source>
          <target state="translated">Память, возвращаемая sqlite3_malloc (), sqlite3_realloc (), sqlite3_malloc64 () и sqlite3_realloc64 () всегда выравнивается по крайней мере по 8-байтовой границе или по 4-байтовой границе, если используется &lt;a href=&quot;../compile#4_byte_aligned_malloc&quot;&gt;параметр времени&lt;/a&gt; компиляции SQLITE_4_BYTE_ALIGNED_MALLOC .</target>
        </trans-unit>
        <trans-unit id="0b4a85ec728749e1396a0209dbea3173ce995dba" translate="yes" xml:space="preserve">
          <source>The memory returned by sqlite3_malloc(), sqlite3_realloc(), sqlite3_malloc64(), and sqlite3_realloc64() is always aligned to at least an 8 byte boundary, or to a 4 byte boundary if the &lt;a href=&quot;compile#4_byte_aligned_malloc&quot;&gt;SQLITE_4_BYTE_ALIGNED_MALLOC&lt;/a&gt; compile-time option is used.</source>
          <target state="translated">Память, возвращаемая sqlite3_malloc (), sqlite3_realloc (), sqlite3_malloc64 () и sqlite3_realloc64 () всегда выравнивается по крайней мере по 8-байтовой границе или по 4-байтовой границе, если используется &lt;a href=&quot;compile#4_byte_aligned_malloc&quot;&gt;параметр времени&lt;/a&gt; компиляции SQLITE_4_BYTE_ALIGNED_MALLOC .</target>
        </trans-unit>
        <trans-unit id="d4065cde811c203e3d250a3f54d5601da517866b" translate="yes" xml:space="preserve">
          <source>The memsys5 allocator is designed for use on embedded systems, though there is nothing to prevent its use on workstations. The szBuf is typically between a few hundred kilobytes up to a few dozen megabytes, depending on system requirements and memory budget.</source>
          <target state="translated">Аллокатор memsys5 предназначен для использования на встраиваемых системах,хотя ничто не мешает его использованию на рабочих станциях.Обычно szBuf составляет от нескольких сотен килобайт до нескольких десятков мегабайт,в зависимости от системных требований и бюджета памяти.</target>
        </trans-unit>
        <trans-unit id="15e755d3b15a2797fc8e730750dc9e96957bcf11" translate="yes" xml:space="preserve">
          <source>The min() aggregate function returns the minimum non-NULL value of all values in the group. The minimum value is the first non-NULL value that would appear in an ORDER BY of the column. Aggregate min() returns NULL if and only if there are no non-NULL values in the group.</source>
          <target state="translated">Функция агрегата min()возвращает минимальное не нулевое значение всех значений в группе.Минимальное значение-это первое не нулевое значение,которое появляется в колонке ORDER BY.Функция агрегата min()возвращает NULL,если и только если в группе нет не NULL-значений.</target>
        </trans-unit>
        <trans-unit id="114a5a7dbd98c187abf7e68d111172546895bf6d" translate="yes" xml:space="preserve">
          <source>The min/max-value pair columns are stored as 32-bit floating point values for &quot;rtree&quot; virtual tables or as 32-bit signed integers in &quot;rtree_i32&quot; virtual tables. Unlike regular SQLite tables which can store data in a variety of datatypes and formats, the R*Tree rigidly enforce these storage types. If any other type of value is inserted into such a column, the r-tree module silently converts it to the required type before writing the new record to the database.</source>
          <target state="translated">Столбцы пары min/max-значений хранятся в виде 32-битных значений с плавающей точкой для виртуальных таблиц &quot;rtree&quot; или в виде 32-битных целых чисел,подписанных в виртуальных таблицах &quot;rtree_i32&quot;.В отличие от обычных таблиц SQLite,которые могут хранить данные в различных типах и форматах,R*Tree жестко контролирует эти типы хранения.Если в такой столбец вставляется значение любого другого типа,модуль r-дерева бесшумно преобразует его в нужный тип перед записью новой записи в БД.</target>
        </trans-unit>
        <trans-unit id="697dd64d2ba004e05302a199cbf94ae930397047" translate="yes" xml:space="preserve">
          <source>The minimum &quot;three+four&quot; value</source>
          <target state="translated">Минимальное значение &quot;три+четыре&quot;</target>
        </trans-unit>
        <trans-unit id="4344744cb5e4e7fe1c07e4d9e9f4f1a35db07ca5" translate="yes" xml:space="preserve">
          <source>The minimum size of an SQLite database is one page for each table and each index. With a larger page size, the size of an empty database for a given schema will grow by a factor of four, therefore. However, once the database begins to fill with content the size of the older 1024-byte page databases and the newer 4096-byte page databases will quickly converge. Due to relaxed bin-packing constraints, the 4096-byte page size might actually result in a smaller file, once substantial content is added.</source>
          <target state="translated">Минимальный размер базы данных SQLite-одна страница для каждой таблицы и каждого индекса.При большем размере страницы размер пустой БД для заданной схемы вырастет,таким образом,в четыре раза.Однако,как только БД начнет заполняться содержимым,размер старых 1024-байтных страниц БД и более новых 4096-байтных страниц БД быстро сойдутся воедино.Из-за ослабленных ограничений на упаковку бинарных файлов,размер 4096-байтовой страницы может фактически привести к уменьшению файла,как только будет добавлено значительное содержимое.</target>
        </trans-unit>
        <trans-unit id="e5d2ce57cb5bfbf79b3c98a499658be04c3e7756" translate="yes" xml:space="preserve">
          <source>The minor version number Y was historically incremented for new features and/or new interfaces that did not significantly change the structure of the code. The addition of &lt;a href=&quot;lang_with&quot;&gt;common table expressions&lt;/a&gt;, &lt;a href=&quot;partialindex&quot;&gt;partial indexes&lt;/a&gt;, and &lt;a href=&quot;expridx&quot;&gt;indexes on expressions&lt;/a&gt; are all examples of &quot;minor&quot; changes. Again, the distinction between &quot;major&quot; and &quot;minor&quot; is subjective.</source>
          <target state="translated">Дополнительный номер версии Y исторически увеличивался для новых функций и / или новых интерфейсов, которые существенно не меняли структуру кода. Добавление &lt;a href=&quot;lang_with&quot;&gt;общих табличных выражений&lt;/a&gt; , &lt;a href=&quot;partialindex&quot;&gt;частичных индексов&lt;/a&gt; и &lt;a href=&quot;expridx&quot;&gt;индексов к выражениям&lt;/a&gt; - все это примеры &amp;laquo;незначительных&amp;raquo; изменений. Опять же, различие между &amp;laquo;большим&amp;raquo; и &amp;laquo;второстепенным&amp;raquo; субъективно.</target>
        </trans-unit>
        <trans-unit id="daac53b800202886e5a1bc16ab5a5eb44a3f8d4d" translate="yes" xml:space="preserve">
          <source>The mirror is an incremental export of the &lt;a href=&quot;https://sqlite.org/src/timeline&quot;&gt;canonical Fossil repository&lt;/a&gt; for SQLite. A cron-job updates the GitHub repository once an hour. This is a one-way, read-only code mirror. No pull requests or changes are accepted via GitHub. The GitHub repository merely copies the content from the Fossil repository. All changes are input via Fossil.</source>
          <target state="translated">Зеркало представляет собой инкрементный экспорт &lt;a href=&quot;https://sqlite.org/src/timeline&quot;&gt;канонического репозитория Fossil&lt;/a&gt; для SQLite. Cron-job обновляет репозиторий GitHub раз в час. Это одностороннее зеркало кода, доступное только для чтения. Запросы на вытягивание или изменения через GitHub не принимаются. Репозиторий GitHub просто копирует контент из репозитория Fossil. Все изменения вводятся через Fossil.</target>
        </trans-unit>
        <trans-unit id="8699fa6e48270c38aaec7f72b7768d7c856e3da2" translate="yes" xml:space="preserve">
          <source>The mmap_size is set separately for each database file using the &quot;&lt;a href=&quot;pragma#pragma_mmap_size&quot;&gt;PRAGMA mmap_size&lt;/a&gt;&quot; statement. The usual default mmap_size is zero, meaning that memory mapped I/O is disabled by default. However, the default mmap_size can be increased either at compile-time using the &lt;a href=&quot;compile#default_mmap_size&quot;&gt;SQLITE_DEFAULT_MMAP_SIZE&lt;/a&gt; macro or at start-time using the &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmmapsize&quot;&gt;SQLITE_CONFIG_MMAP_SIZE&lt;/a&gt;,...) interface.</source>
          <target state="translated">Mmap_size устанавливается отдельно для каждого файла базы данных с помощью &lt;a href=&quot;pragma#pragma_mmap_size&quot;&gt;оператора PRAGMA mmap_size&lt;/a&gt; . Обычно mmap_size по умолчанию равен нулю, что означает, что ввод-вывод с отображением памяти по умолчанию отключен. Однако значение по умолчанию mmap_size может быть увеличено либо во время компиляции с &lt;a href=&quot;compile#default_mmap_size&quot;&gt;помощью&lt;/a&gt; макроса SQLITE_DEFAULT_MMAP_SIZE, либо во время запуска с помощью интерфейса &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt; ( &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmmapsize&quot;&gt;SQLITE_CONFIG_MMAP_SIZE&lt;/a&gt; , ...).</target>
        </trans-unit>
        <trans-unit id="bc3aa8081ad975eaa64522ee2647fdff6a383213" translate="yes" xml:space="preserve">
          <source>The mode query parameter determines if the new database is opened read-only, read-write, read-write and created if it does not exist, or that the database is a pure in-memory database that never interacts with disk, respectively.</source>
          <target state="translated">Параметр mode request определяет,открывается ли новая БД только на чтение,читать-запись,читать-запись и создается ли она,если ее нет,или же БД является чистой БД в памяти,которая никогда не взаимодействует с диском,соответственно.</target>
        </trans-unit>
        <trans-unit id="f2526ac46e681fb29c61b97dfb71933e5d3d8f00" translate="yes" xml:space="preserve">
          <source>The modifications made to each row affected by an UPDATE statement are determined by the list of assignments following the SET keyword. Each assignment specifies a column-name to the left of the equals sign and a scalar expression to the right. For each affected row, the named columns are set to the values found by evaluating the corresponding scalar expressions. If a single column-name appears more than once in the list of assignment expressions, all but the rightmost occurrence is ignored. Columns that do not appear in the list of assignments are left unmodified. The scalar expressions may refer to columns of the row being updated. In this case all scalar expressions are evaluated before any assignments are made.</source>
          <target state="translated">Изменения,внесенные в каждую строку,на которую влияет оператор UPDATE,определяются списком назначений,следующим за ключевым словом SET.Каждое присваивание задает имя столбца слева от знака равенства и скалярное выражение справа.Для каждой затрагиваемой строки именованные столбцы устанавливаются на значения,найденные при вычислении соответствующих скалярных выражений.Если одно и то же имя столбца появляется в списке выражений присваивания более одного раза,то все,кроме самого правого,вхождения игнорируются.Столбцы,которые не появляются в списке назначений,остаются неизменными.Скалярные выражения могут относиться к обновляемым столбцам строки.В этом случае все скалярные выражения оцениваются перед выполнением каких-либо присваиваний.</target>
        </trans-unit>
        <trans-unit id="c57c56215c73a95bddb16c7f419303a4f511dbe2" translate="yes" xml:space="preserve">
          <source>The module name is registered on the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; specified by the first parameter. The name of the module is given by the second parameter. The third parameter is a pointer to the implementation of the &lt;a href=&quot;#sqlite3_module&quot;&gt;virtual table module&lt;/a&gt;. The fourth parameter is an arbitrary client data pointer that is passed through into the &lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; and &lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; methods of the virtual table module when a new virtual table is be being created or reinitialized.</source>
          <target state="translated">Имя модуля регистрируется в &lt;a href=&quot;#sqlite3&quot;&gt;соединении&lt;/a&gt; с базой данных, указанном первым параметром. Имя модуля задается вторым параметром. Третий параметр - это указатель на реализацию &lt;a href=&quot;#sqlite3_module&quot;&gt;модуля виртуальной таблицы&lt;/a&gt; . Четвертый параметр - это произвольный указатель данных клиента, который передается в методы &lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; и &lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; модуля виртуальной таблицы, когда создается или повторно инициализируется новая виртуальная таблица.</target>
        </trans-unit>
        <trans-unit id="f7d008fdf7032ca8558d613dfe5b4ba03ec8869a" translate="yes" xml:space="preserve">
          <source>The module name is registered on the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; specified by the first parameter. The name of the module is given by the second parameter. The third parameter is a pointer to the implementation of the &lt;a href=&quot;module&quot;&gt;virtual table module&lt;/a&gt;. The fourth parameter is an arbitrary client data pointer that is passed through into the &lt;a href=&quot;../vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; and &lt;a href=&quot;../vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; methods of the virtual table module when a new virtual table is be being created or reinitialized.</source>
          <target state="translated">Имя модуля регистрируется в &lt;a href=&quot;sqlite3&quot;&gt;соединении&lt;/a&gt; с базой данных, указанном первым параметром. Имя модуля задается вторым параметром. Третий параметр - это указатель на реализацию &lt;a href=&quot;module&quot;&gt;модуля виртуальной таблицы&lt;/a&gt; . Четвертый параметр - это произвольный указатель данных клиента, который передается в методы &lt;a href=&quot;../vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; и &lt;a href=&quot;../vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; модуля виртуальной таблицы, когда создается или повторно инициализируется новая виртуальная таблица.</target>
        </trans-unit>
        <trans-unit id="c29884604bb765a8ff66e73918a8eec45479c155" translate="yes" xml:space="preserve">
          <source>The module name must be changed from &quot;fts3&quot; or &quot;fts4&quot; to &quot;fts5&quot;.</source>
          <target state="translated">Название модуля должно быть изменено с &quot;fts3&quot; или &quot;fts4&quot; на &quot;fts5&quot;.</target>
        </trans-unit>
        <trans-unit id="ea30bfabecd455dc9fb80bfe26599d0bf2066398" translate="yes" xml:space="preserve">
          <source>The module structure contains methods that are invoked by SQLite to perform various actions on the virtual table such as creating new instances of a virtual table or destroying old ones, reading and writing data, searching for and deleting, updating, or inserting rows. The module structure is explained in more detail below.</source>
          <target state="translated">Структура модуля содержит методы,которые вызываются SQLite для выполнения различных действий с виртуальной таблицей,таких как создание новых экземпляров виртуальной таблицы или уничтожение старых,чтение и запись данных,поиск и удаление,обновление или вставка строк.Более подробно структура модуля описана ниже.</target>
        </trans-unit>
        <trans-unit id="e7e8ce1834b0e39b1a04f1ee58c27c3761f545ea" translate="yes" xml:space="preserve">
          <source>The module structure defines all of the methods for each virtual table object. The module structure also contains the iVersion field which defines the particular edition of the module table structure. Currently, iVersion is always 3 or less, but in future releases of SQLite the module structure definition might be extended with additional methods and in that case the maximum iVersion value will be increased.</source>
          <target state="translated">Модульная структура определяет все методы для каждого объекта виртуальной таблицы.Модульная структура также содержит поле iVersion,которое определяет конкретную редакцию структуры таблицы модуля.В настоящее время iVersion всегда 3 и менее,но в будущих релизах SQLite определение модульной структуры может быть расширено дополнительными методами и в этом случае максимальное значение iVersion будет увеличено.</target>
        </trans-unit>
        <trans-unit id="f82636212897757718a1a7712ed9f6ebe7472ac1" translate="yes" xml:space="preserve">
          <source>The module-name is the name of an object that implements the virtual table. The module-name must be registered with the SQLite database connection using &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module()&lt;/a&gt; or &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module_v2()&lt;/a&gt; prior to issuing the CREATE VIRTUAL TABLE statement. The module takes zero or more comma-separated arguments. The arguments can be just about any text as long as it has balanced parentheses. The argument syntax is sufficiently general that the arguments can be made to appear as &lt;a href=&quot;lang_createtable#tablecoldef&quot;&gt;column definitions&lt;/a&gt; in a traditional &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; statement. SQLite passes the module arguments directly to the &lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; and &lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; methods of the module implementation without any interpretation. It is the responsibility of the module implementation to parse and interpret its own arguments.</source>
          <target state="translated">Имя модуля - это имя объекта, реализующего виртуальную таблицу. Имя модуля должно быть зарегистрировано в соединении с базой данных SQLite с помощью &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module ()&lt;/a&gt; или &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module_v2 ()&lt;/a&gt; до выполнения оператора CREATE VIRTUAL TABLE. Модуль принимает ноль или более аргументов, разделенных запятыми. Аргументами может быть любой текст, если в нем есть сбалансированные круглые скобки. Синтаксис аргументов достаточно общий, чтобы аргументы отображались как &lt;a href=&quot;lang_createtable#tablecoldef&quot;&gt;определения столбцов&lt;/a&gt; в традиционном операторе &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; . SQLite передает аргументы модуля напрямую в &lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; и &lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect&lt;/a&gt;методы реализации модуля без какой-либо интерпретации. Реализация модуля несет ответственность за анализ и интерпретацию собственных аргументов.</target>
        </trans-unit>
        <trans-unit id="44619ca32ea56419710789f2ec6fc9766c59ac70" translate="yes" xml:space="preserve">
          <source>The most common reason an attempt to obtain a</source>
          <target state="translated">Наиболее распространенная причина-попытка получить</target>
        </trans-unit>
        <trans-unit id="b4677e9c54155902987749f94de50b511a297fed" translate="yes" xml:space="preserve">
          <source>The most common way to force an SQLite database to exist purely in memory is to open the database using the special filename &quot;&lt;b&gt;:memory:&lt;/b&gt;&quot;. In other words, instead of passing the name of a real disk file into one of the &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open16()&lt;/a&gt;, or &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; functions, pass in the string &quot;:memory:&quot;. For example:</source>
          <target state="translated">Самый распространенный способ заставить базу данных SQLite существовать исключительно в памяти - это открыть базу данных с использованием специального имени файла &quot; &lt;b&gt;: memory:&lt;/b&gt; &quot;. Другими словами, вместо того, чтобы передавать имя реального файла на диске в одну из функций &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open ()&lt;/a&gt; , &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open16 ()&lt;/a&gt; или &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2 ()&lt;/a&gt; , передайте строку &quot;: memory:&quot;. Например:</target>
        </trans-unit>
        <trans-unit id="03a7919d9a36d839fb3e6c8676819056867ece77" translate="yes" xml:space="preserve">
          <source>The most efficient way to apply changes to a B-Tree (the data structure that SQLite uses to store each table and index on disk) is to make the changes in key order. But if an SQL table has one or more indexes, the key order for each index may be different from the main table and the other auxiliary indexes. As a result, when executing a series of &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;, &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; and &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; statements it is not generally possible to order the operations so that all b-trees are updated in key order. The RBU update process works around this by applying all changes to the main table in one pass, then applying changes to each index in separate passes, ensuring each B-Tree is updated optimally. For a large database file (one that does not fit in the OS disk cache) this procedure can result in two orders of magnitude faster updates.</source>
          <target state="translated">Самый эффективный способ применить изменения к B-дереву (структуре данных, которую SQLite использует для хранения каждой таблицы и индекса на диске) - это внести изменения в ключевом порядке. Но если таблица SQL имеет один или несколько индексов, порядок ключей для каждого индекса может отличаться от основной таблицы и других вспомогательных индексов. В результате при выполнении серии &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; , &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; и &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt;операторов, как правило, невозможно упорядочить операции так, чтобы все b-деревья обновлялись в ключевом порядке. Процесс обновления RBU помогает обойти это, применяя все изменения к основной таблице за один проход, а затем применяя изменения к каждому индексу на отдельных этапах, обеспечивая оптимальное обновление каждого B-дерева. Для большого файла базы данных (который не помещается в дисковом кэше ОС) эта процедура может привести к ускорению обновлений на два порядка.</target>
        </trans-unit>
        <trans-unit id="0aab584bc04ad9506143fb4e57b11f24aeb68952" translate="yes" xml:space="preserve">
          <source>The most useful</source>
          <target state="translated">Самые полезные</target>
        </trans-unit>
        <trans-unit id="672a287b758e4f6545eeda0d335349088507b997" translate="yes" xml:space="preserve">
          <source>The most useful thing about FTS tables is the queries that may be performed using the built-in full-text index. Full-text queries are performed by specifying a clause of the form &quot;&amp;lt;column&amp;gt; MATCH &amp;lt;full-text query expression&amp;gt;&quot; as part of the WHERE clause of a SELECT statement that reads data from an FTS table. &lt;a href=&quot;fts3#simple_fts_queries&quot;&gt;Simple FTS queries&lt;/a&gt; that return all documents that contain a given term are described above. In that discussion the right-hand operand of the MATCH operator was assumed to be a string consisting of a single term. This section describes the more complex query types supported by FTS tables, and how they may be utilized by specifying a more complex query expression as the right-hand operand of a MATCH operator.</source>
          <target state="translated">Самое полезное в таблицах FTS - это запросы, которые можно выполнять с использованием встроенного полнотекстового индекса. Полнотекстовые запросы выполняются путем указания предложения формы &amp;laquo;&amp;lt;столбец&amp;gt; MATCH &amp;lt;выражение полнотекстового запроса&amp;gt;&amp;raquo; как части предложения WHERE оператора SELECT, который считывает данные из таблицы FTS. Выше описаны &lt;a href=&quot;fts3#simple_fts_queries&quot;&gt;простые запросы FTS,&lt;/a&gt; которые возвращают все документы, содержащие данный термин. В этом обсуждении предполагалось, что правый операнд оператора MATCH представляет собой строку, состоящую из одного члена. В этом разделе описаны более сложные типы запросов, поддерживаемые таблицами FTS, и то, как их можно использовать, задав более сложное выражение запроса в качестве правого операнда оператора MATCH.</target>
        </trans-unit>
        <trans-unit id="b952b720a1c68c621b96fa1e29a1ec3a3e91db58" translate="yes" xml:space="preserve">
          <source>The multi-argument max() function returns the argument with the maximum value, or return NULL if any argument is NULL. The multi-argument max() function searches its arguments from left to right for an argument that defines a collating function and uses that collating function for all string comparisons. If none of the arguments to max() define a collating function, then the BINARY collating function is used. Note that &lt;b&gt;max()&lt;/b&gt; is a simple function when it has 2 or more arguments but operates as an &lt;a href=&quot;lang_aggfunc#maxggunc&quot;&gt;aggregate function&lt;/a&gt; if given only a single argument.</source>
          <target state="translated">Функция max () с несколькими аргументами возвращает аргумент с максимальным значением или возвращает NULL, если какой-либо аргумент равен NULL. Функция max () с несколькими аргументами ищет в своих аргументах слева направо аргумент, который определяет функцию сопоставления, и использует эту функцию сопоставления для всех сравнений строк. Если ни один из аргументов max () не определяет функцию сортировки, то используется ДВОИЧНАЯ функция сортировки. Обратите внимание, что &lt;b&gt;max ()&lt;/b&gt; - это простая функция, когда она имеет 2 или более аргумента, но работает как &lt;a href=&quot;lang_aggfunc#maxggunc&quot;&gt;агрегатная функция,&lt;/a&gt; если задан только один аргумент.</target>
        </trans-unit>
        <trans-unit id="4978bfa5c1668418de3cae9f58ae0236b3a923fa" translate="yes" xml:space="preserve">
          <source>The multi-argument min() function returns the argument with the minimum value. The multi-argument min() function searches its arguments from left to right for an argument that defines a collating function and uses that collating function for all string comparisons. If none of the arguments to min() define a collating function, then the BINARY collating function is used. Note that &lt;b&gt;min()&lt;/b&gt; is a simple function when it has 2 or more arguments but operates as an &lt;a href=&quot;lang_aggfunc#minggunc&quot;&gt;aggregate function&lt;/a&gt; if given only a single argument.</source>
          <target state="translated">Функция min () с несколькими аргументами возвращает аргумент с минимальным значением. Функция min () с несколькими аргументами ищет в своих аргументах слева направо аргумент, который определяет функцию сопоставления, и использует эту функцию сопоставления для всех сравнений строк. Если ни один из аргументов min () не определяет функцию сортировки, то используется ДВОИЧНАЯ функция сортировки. Обратите внимание, что &lt;b&gt;min ()&lt;/b&gt; - это простая функция, когда она имеет 2 или более аргумента, но работает как &lt;a href=&quot;lang_aggfunc#minggunc&quot;&gt;агрегатная функция,&lt;/a&gt; если ей задан только один аргумент.</target>
        </trans-unit>
        <trans-unit id="78c0cf060a6f9ee3d1106d60ebe5e6c21511776f" translate="yes" xml:space="preserve">
          <source>The multiply operator now correctly detects 64-bit integer overflow and promotes to floating point in all corner-cases. Fix for ticket &lt;a href=&quot;https://www.sqlite.org/src/info/1ec41379c9c1e400&quot;&gt;1ec41379c9c1e400&lt;/a&gt;.</source>
          <target state="translated">Оператор умножения теперь правильно обнаруживает переполнение 64-битных целых чисел и переводит их в числа с плавающей запятой во всех угловых случаях. Исправление для билета &lt;a href=&quot;https://www.sqlite.org/src/info/1ec41379c9c1e400&quot;&gt;1ec41379c9c1e400&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ee9132cb0f48417f8650cad9e27fe43d03b0618b" translate="yes" xml:space="preserve">
          <source>The mutation-test.tcl script takes care of all of the details for running a mutation test:</source>
          <target state="translated">Скрипт mutation-test.tcl позаботится обо всех деталях запуска теста на мутацию:</target>
        </trans-unit>
        <trans-unit id="2945579c517aa1d3b8ba9d11b0bc3f91de1e9921" translate="yes" xml:space="preserve">
          <source>The mutex module within SQLite defines &lt;a href=&quot;#sqlite3_mutex&quot;&gt;sqlite3_mutex&lt;/a&gt; to be an abstract type for a mutex object. The SQLite core never looks at the internal representation of an &lt;a href=&quot;#sqlite3_mutex&quot;&gt;sqlite3_mutex&lt;/a&gt;. It only deals with pointers to the &lt;a href=&quot;#sqlite3_mutex&quot;&gt;sqlite3_mutex&lt;/a&gt; object.</source>
          <target state="translated">Модуль мьютекса в SQLite определяет &lt;a href=&quot;#sqlite3_mutex&quot;&gt;sqlite3_mutex&lt;/a&gt; как абстрактный тип для объекта мьютекса. Ядро SQLite никогда не смотрит на внутреннее представление &lt;a href=&quot;#sqlite3_mutex&quot;&gt;sqlite3_mutex&lt;/a&gt; . Он имеет дело только с указателями на объект &lt;a href=&quot;#sqlite3_mutex&quot;&gt;sqlite3_mutex&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d0e09c593f6493d406d9e4e9dcac2eadda30e574" translate="yes" xml:space="preserve">
          <source>The mutex module within SQLite defines &lt;a href=&quot;mutex&quot;&gt;sqlite3_mutex&lt;/a&gt; to be an abstract type for a mutex object. The SQLite core never looks at the internal representation of an &lt;a href=&quot;mutex&quot;&gt;sqlite3_mutex&lt;/a&gt;. It only deals with pointers to the &lt;a href=&quot;mutex&quot;&gt;sqlite3_mutex&lt;/a&gt; object.</source>
          <target state="translated">Модуль мьютекса в SQLite определяет &lt;a href=&quot;mutex&quot;&gt;sqlite3_mutex&lt;/a&gt; как абстрактный тип для объекта мьютекса. Ядро SQLite никогда не смотрит на внутреннее представление &lt;a href=&quot;mutex&quot;&gt;sqlite3_mutex&lt;/a&gt; . Он имеет дело только с указателями на объект &lt;a href=&quot;mutex&quot;&gt;sqlite3_mutex&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2683feab4dd898006f40d9a775532ccca7b7b569" translate="yes" xml:space="preserve">
          <source>The mxFrame value is always greater than or equal to both &lt;a href=&quot;walformat#nbackfill&quot;&gt;nBackfill&lt;/a&gt; and nBackfillAttempted.</source>
          <target state="translated">Значение mxFrame всегда больше или равно как &lt;a href=&quot;walformat#nbackfill&quot;&gt;nBackfill, так&lt;/a&gt; и nBackfillAttempted.</target>
        </trans-unit>
        <trans-unit id="ab3c5c72a969cacdc78a3e4dd0229038bdf0e320" translate="yes" xml:space="preserve">
          <source>The mxPathname field is the maximum length of a file pathname that this VFS can use. SQLite sometimes has to preallocate buffers of this size, so it should be as small as reasonably possible. Some filesystems permit huge pathnames, but in practice pathnames rarely extend beyond 100 bytes or so. You do not have to put the longest pathname that the underlying filesystem can handle here. You only have to put the longest pathname that you want SQLite to be able to handle. A few hundred is a good value in most cases.</source>
          <target state="translated">Поле mxPathname-это максимальная длина патнама файла,которую может использовать эта VFS.SQLite иногда вынужден предварительно выделять буферы такого размера,поэтому он должен быть как можно меньше.Некоторые файловые системы допускают использование огромных патнанов,но на практике патнаны редко расширяются более чем на 100 байт или около того.Вам не нужно ставить здесь самый длинный путь,с которым может справиться базовая файловая система.Вы должны поставить только самый длинный путь,который SQLite сможет обработать.Несколько сотен-это хорошая величина в большинстве случаев.</target>
        </trans-unit>
        <trans-unit id="cb1334872e71aa02626433d46e5f9130af9a0bfd" translate="yes" xml:space="preserve">
          <source>The nArg parameter specifies the number of arguments to the function. A value of 0 indicates that any number of arguments is allowed. The eTextRep parameter specifies what representation text values are expected to be in for arguments to this function. The value of this parameter should be one of the parameters defined above. SQLite version 3 allows multiple implementations of the same function using different text representations. The database engine chooses the function that minimization the number of text conversions required.</source>
          <target state="translated">Параметр nArg задает количество аргументов функции.Значение 0 указывает,что допустимо любое количество аргументов.Параметр eTextRep указывает,какие значения текста представления ожидаются для аргументов этой функции.Значение этого параметра должно быть одним из параметров,определенных выше.SQLite версии 3 позволяет несколько реализаций одной и той же функции с использованием разных текстовых представлений.Движок базы данных выбирает функцию,которая минимизирует количество необходимых преобразований текста.</target>
        </trans-unit>
        <trans-unit id="15067be8341cb3e5ea308646b0092b9f585804c8" translate="yes" xml:space="preserve">
          <source>The nBackfill can only be increased while holding the WAL_CKPT_LOCK. However, nBackfill is changed to zero during a &lt;a href=&quot;fileformat2#walreset&quot;&gt;WAL reset&lt;/a&gt;, and this happens while holding the WAL_WRITE_LOCK.</source>
          <target state="translated">NBackfill можно увеличить, только удерживая WAL_CKPT_LOCK. Однако nBackfill изменяется на ноль во время &lt;a href=&quot;fileformat2#walreset&quot;&gt;сброса WAL&lt;/a&gt; , и это происходит при удерживании WAL_WRITE_LOCK.</target>
        </trans-unit>
        <trans-unit id="99673f4f335d79523c7b7494142bf07ba1cd84e2" translate="yes" xml:space="preserve">
          <source>The nBackfill number is never greater than &lt;a href=&quot;walformat#mxframe&quot;&gt;mxFrame&lt;/a&gt;. When nBackfill equals &lt;a href=&quot;walformat#mxframe&quot;&gt;mxFrame&lt;/a&gt;, that means that the WAL content has been completely written back into the database and it is ok to &lt;a href=&quot;fileformat2#walreset&quot;&gt;reset the WAL&lt;/a&gt; if there are no locks held on any of WAL_READ_LOCK(N) for N&amp;gt;0.</source>
          <target state="translated">Число nBackfill никогда не превышает &lt;a href=&quot;walformat#mxframe&quot;&gt;mxFrame&lt;/a&gt; . Когда nBackfill равно &lt;a href=&quot;walformat#mxframe&quot;&gt;mxFrame&lt;/a&gt; , это означает, что содержимое WAL было полностью записано обратно в базу данных, и можно &lt;a href=&quot;fileformat2#walreset&quot;&gt;сбросить WAL,&lt;/a&gt; если нет блокировок, удерживаемых ни на одном из WAL_READ_LOCK (N) для N&amp;gt; 0.</target>
        </trans-unit>
        <trans-unit id="58aea584e25c7551e85c617c6b8537adc3f19238" translate="yes" xml:space="preserve">
          <source>The name &quot;memsys5&quot; used for the zero-malloc memory allocator implies that there are several additional memory allocators available, and indeed there are. The default memory allocator is &quot;memsys1&quot;. The debugging memory allocator is &quot;memsys2&quot;. Those have already been covered.</source>
          <target state="translated">Название &quot;memsys5&quot;,используемое для аллокатора нулевого аллокатора памяти,подразумевает наличие нескольких дополнительных аллокаторов памяти.По умолчанию используется аллокатор памяти &quot;memsys1&quot;.Отладочный аллокатор памяти-&quot;memsys2&quot;.Это уже было рассмотрено.</target>
        </trans-unit>
        <trans-unit id="e00b973d0e23f6d37321209e23fc2917cf32700a" translate="yes" xml:space="preserve">
          <source>The name &quot;sqlite_schema&quot; does not appear anywhere in the file format. That name is just a convention used by the database implementation. Due to historical and operational considerations, the &quot;sqlite_schema&quot; table can also sometimes be called by one of the following aliases:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5db0afbba9901c1e9e8534384d38571355c85857" translate="yes" xml:space="preserve">
          <source>The name for the &lt;a href=&quot;datatype3#collation&quot;&gt;collating sequence&lt;/a&gt; used to compare values in the index-column.</source>
          <target state="translated">Имя &lt;a href=&quot;datatype3#collation&quot;&gt;последовательности сортировки,&lt;/a&gt; используемой для сравнения значений в столбце индекса.</target>
        </trans-unit>
        <trans-unit id="d0a42cf139ce30315511c41a36a93d913d4ae81d" translate="yes" xml:space="preserve">
          <source>The name of a result column is the value of the &quot;AS&quot; clause for that column, if there is an AS clause. If there is no AS clause then the name of the column is unspecified and may change from one release of SQLite to the next.</source>
          <target state="translated">Название столбца результата является значением пункта &quot;AS&quot; для этого столбца,если существует пункт &quot;AS&quot;.При отсутствии AS-пункта название столбца не указывается и может изменяться от одного выпуска SQLite к другому.</target>
        </trans-unit>
        <trans-unit id="a57f858acf3d2e5077979e3afa2c8309985a2b90" translate="yes" xml:space="preserve">
          <source>The name of an SQLite database is the name of a file that will contain the database. If the file does not exist, SQLite attempts to create and initialize it. If the file is read-only (due to permission bits or because it is located on read-only media like a CD-ROM) then SQLite opens the database for reading only. The entire SQL database is stored in a single file on the disk. But additional temporary files may be created during the execution of an SQL command in order to store the database rollback journal or temporary and intermediate results of a query.</source>
          <target state="translated">Имя базы данных SQLite-это имя файла,который будет содержать базу данных.Если файл не существует,SQLite пытается его создать и инициализировать.Если файл доступен только для чтения (из-за битов разрешения или потому,что он расположен на носителе только для чтения,например,на компакт-диске),то SQLite открывает базу данных только для чтения.Вся база данных SQL хранится в одном файле на диске.Однако во время выполнения команды SQL могут быть созданы дополнительные временные файлы для хранения журнала отката БД или временных и промежуточных результатов запроса.</target>
        </trans-unit>
        <trans-unit id="2e5f7637f527bcb85ea83184153ee4c57e5bbfca" translate="yes" xml:space="preserve">
          <source>The name of each column in the table.</source>
          <target state="translated">Название каждого столбца в таблице.</target>
        </trans-unit>
        <trans-unit id="e1e64668404efe0d041f261ba3d958b47753bba4" translate="yes" xml:space="preserve">
          <source>The name of the FTS5 table column that contains the term.</source>
          <target state="translated">Название столбца таблицы FTS5,содержащего этот термин.</target>
        </trans-unit>
        <trans-unit id="fb2519166ef6466d94c575e04a046d25ae02cbef" translate="yes" xml:space="preserve">
          <source>The name of the collation is a UTF-8 string for sqlite3_create_collation() and sqlite3_create_collation_v2() and a UTF-16 string in native byte order for sqlite3_create_collation16(). Collation names that compare equal according to &lt;a href=&quot;#sqlite3_stricmp&quot;&gt;sqlite3_strnicmp()&lt;/a&gt; are considered to be the same name.</source>
          <target state="translated">Имя сопоставления - это строка UTF-8 для sqlite3_create_collation () и sqlite3_create_collation_v2 () и строка UTF-16 в собственном порядке байтов для sqlite3_create_collation16 (). Имена параметров сортировки, которые сравниваются равными согласно &lt;a href=&quot;#sqlite3_stricmp&quot;&gt;sqlite3_strnicmp ()&lt;/a&gt; , считаются одинаковыми.</target>
        </trans-unit>
        <trans-unit id="7df8bfa2bb01af5c880a238a6167d3b3a1623f37" translate="yes" xml:space="preserve">
          <source>The name of the collation is a UTF-8 string for sqlite3_create_collation() and sqlite3_create_collation_v2() and a UTF-16 string in native byte order for sqlite3_create_collation16(). Collation names that compare equal according to &lt;a href=&quot;stricmp&quot;&gt;sqlite3_strnicmp()&lt;/a&gt; are considered to be the same name.</source>
          <target state="translated">Имя сопоставления - это строка UTF-8 для sqlite3_create_collation () и sqlite3_create_collation_v2 () и строка UTF-16 в собственном порядке байтов для sqlite3_create_collation16 (). Имена параметров сортировки, которые сравниваются равными согласно &lt;a href=&quot;stricmp&quot;&gt;sqlite3_strnicmp ()&lt;/a&gt; , считаются одинаковыми.</target>
        </trans-unit>
        <trans-unit id="60f9c38a5b1707739850b72dfb67adc25dbc2069" translate="yes" xml:space="preserve">
          <source>The name of the column being indexed, or NULL if the index-column is the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; of the table being indexed or an &lt;a href=&quot;expridx&quot;&gt;expression&lt;/a&gt;.</source>
          <target state="translated">Имя индексируемого столбца или NULL, если индекс-столбец является &lt;a href=&quot;lang_createtable#rowid&quot;&gt;идентификатором строки&lt;/a&gt; индексируемой таблицы или &lt;a href=&quot;expridx&quot;&gt;выражением&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a2c4a68aabf0cd9d6847a72cb797a421605fdb66" translate="yes" xml:space="preserve">
          <source>The name of the column being indexed. This columns is NULL if the column is the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; or an &lt;a href=&quot;expridx&quot;&gt;expression&lt;/a&gt;.</source>
          <target state="translated">Имя индексируемого столбца. Этот столбец имеет значение NULL, если столбец является &lt;a href=&quot;lang_createtable#rowid&quot;&gt;идентификатором строки&lt;/a&gt; или &lt;a href=&quot;expridx&quot;&gt;выражением&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2755fad1da17fab976d4effee601e3a0ced598c2" translate="yes" xml:space="preserve">
          <source>The name of the column that contains the term instance.</source>
          <target state="translated">Название колонки,содержащей экземпляр термина.</target>
        </trans-unit>
        <trans-unit id="d4c672f643ac02f7fa3683763e45ddf698d1be4b" translate="yes" xml:space="preserve">
          <source>The name of the database is usually just the name of a disk file in which the database is stored. If the name of the database is the special name &quot;&lt;a href=&quot;inmemorydb&quot;&gt;:memory:&lt;/a&gt;&quot; then a new database is created in memory. If the name of the database is an empty string, then the database is created in an empty file that is automatically deleted when the database connection closes. &lt;a href=&quot;uri&quot;&gt;URI filenames&lt;/a&gt; can be used if the &quot;&lt;b&gt;-uri yes&lt;/b&gt;&quot; option is supplied on the &lt;b&gt;sqlite3&lt;/b&gt; command.</source>
          <target state="translated">Имя базы данных - это обычно просто имя файла на диске, в котором хранится база данных. Если имя базы данных - это специальное имя &amp;laquo; &lt;a href=&quot;inmemorydb&quot;&gt;: memory:&lt;/a&gt; &amp;raquo;, то в памяти создается новая база данных. Если имя базы данных представляет собой пустую строку, то база данных создается в пустом файле, который автоматически удаляется при закрытии соединения с базой данных. &lt;a href=&quot;uri&quot;&gt;URI имена файлов&lt;/a&gt; могут быть использованы , если &amp;laquo; &lt;b&gt;-uri да&lt;/b&gt; опция&amp;raquo; поставляется на &lt;b&gt;sqlite3&lt;/b&gt; команды.</target>
        </trans-unit>
        <trans-unit id="638ad72e8f8e6b978d1b5c7a5434bac446aa668c" translate="yes" xml:space="preserve">
          <source>The name of the database on which the transaction was committed</source>
          <target state="translated">Название базы данных,по которой была совершена транзакция.</target>
        </trans-unit>
        <trans-unit id="b53c39aeaa16a31f4a835cb5ee0c4ef2cb1c4ca7" translate="yes" xml:space="preserve">
          <source>The name of the database table,</source>
          <target state="translated">Имя таблицы базы данных,</target>
        </trans-unit>
        <trans-unit id="1389d8d4ecdcdbedac7a4549e6a07ae7ad0ad26c" translate="yes" xml:space="preserve">
          <source>The name of the database which is being changed</source>
          <target state="translated">Имя изменяемой базы данных</target>
        </trans-unit>
        <trans-unit id="fc047e5a2c9d6a845176aac031ed03d6a1b50ee2" translate="yes" xml:space="preserve">
          <source>The name of the desired tokenizer should be substituted in place of 'porter' in the example, of course. If the tokenizer requires one or more arguments, they should be separated by commas in the fts3tokenize declaration (even though they are separated by spaces in declarations of regular fts4 tables). The following creates fts4 and fts3tokenize tables that use the same tokenizer:</source>
          <target state="translated">Разумеется,вместо 'porter' в примере должно быть подставлено имя желаемого токенайзера.Если токенайзер требует одного или нескольких аргументов,то они должны быть разделены запятыми в декларации fts3tokenize (даже если они разделены пробелами в декларациях обычных таблиц fts4).Далее создаются fts4 и fts3токенизирующие таблицы,использующие один и тот же токенайзер:</target>
        </trans-unit>
        <trans-unit id="9a63a9136665984fc122cf635a36ad0166ead67d" translate="yes" xml:space="preserve">
          <source>The name of the index.</source>
          <target state="translated">Название индекса.</target>
        </trans-unit>
        <trans-unit id="c2412b63f15e8dfde7222fa76ad9e5504c06aea1" translate="yes" xml:space="preserve">
          <source>The name of the new table.</source>
          <target state="translated">Название нового стола.</target>
        </trans-unit>
        <trans-unit id="a12d264e140fa64a7adf3172f5ec27d60bbcedb0" translate="yes" xml:space="preserve">
          <source>The name of the result column is a combination of the source table and source column name: TABLE.COLUMN</source>
          <target state="translated">Имя столбца результата-это комбинация из исходной таблицы и имени столбца источника:TABLE.COLUMN</target>
        </trans-unit>
        <trans-unit id="85777de7d38bf8fc5dfa8258c31af44f8a1c7698" translate="yes" xml:space="preserve">
          <source>The name of the table contains one or more &quot;_&quot; characters.</source>
          <target state="translated">Имя таблицы содержит один или несколько символов &quot;_&quot;.</target>
        </trans-unit>
        <trans-unit id="d14fb34ff4c810e0436eba6520cbeda0158f9e95" translate="yes" xml:space="preserve">
          <source>The name of the table data is read from.</source>
          <target state="translated">Имя данных таблицы считывается из.</target>
        </trans-unit>
        <trans-unit id="a43b536a14c1d7b3d8b50ac0e9b44a83e9c467f9" translate="yes" xml:space="preserve">
          <source>The name of the table in which the xColumnSize values are stored (unless columnsize=0 is specified) is &quot;&amp;lt;name&amp;gt;_docsize&quot;, where &amp;lt;name&amp;gt; is the name of the FTS5 table itself. The &lt;a href=&quot;https://www.sqlite.org/download.html&quot;&gt;sqlite3_analyzer&lt;/a&gt; tool may be used on an existing database in order to determine how much space might be saved by recreating an FTS5 table using columnsize=0.</source>
          <target state="translated">Имя таблицы, в которой хранятся значения xColumnSize (если не указано columnsize = 0), - &amp;laquo;&amp;lt;name&amp;gt; _docsize&amp;raquo;, где &amp;lt;name&amp;gt; - это имя самой таблицы FTS5. Инструмент &lt;a href=&quot;https://www.sqlite.org/download.html&quot;&gt;sqlite3_analyzer&lt;/a&gt; можно использовать в существующей базе данных, чтобы определить, сколько места можно сэкономить, воссоздав таблицу FTS5 с помощью columnsize = 0.</target>
        </trans-unit>
        <trans-unit id="ba455f33d978f1db1e5e1561024b5ab7e0845678" translate="yes" xml:space="preserve">
          <source>The name of the table or index that is implemented by the btree of the current row</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9dba3fb9b44494b1bade858ebafe1459aa85475" translate="yes" xml:space="preserve">
          <source>The name of the table to be modified in an &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;, &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt;, or &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; statement must be an unqualified table name. In other words, one must use just &quot;</source>
          <target state="translated">Имя таблицы, которая должна быть изменена в операторе &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; , &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; или &lt;a href=&quot;lang_insert&quot;&gt;INSERT,&lt;/a&gt; должно быть неполным именем таблицы. Другими словами, нужно использовать только &quot;</target>
        </trans-unit>
        <trans-unit id="6e32ef9d959d1305ba25656ee3bbcec3b526eef2" translate="yes" xml:space="preserve">
          <source>The name that occurs after the AS keyword is the name of the database used internally by SQLite. The schema-names 'main' and 'temp' refer to the main database and the database used for temporary tables. The main and temp databases cannot be attached or detached.</source>
          <target state="translated">Имя,которое возникает после ключевого слова AS,является именем базы данных,используемой внутри SQLite.Схематические имена 'main' и 'temp' относятся к основной БД и БД,используемой для временных таблиц.Главная и временная БД не могут быть подключены или отключены.</target>
        </trans-unit>
        <trans-unit id="c7f1793be68e4540903171531d569a4a7be0fbfa" translate="yes" xml:space="preserve">
          <source>The names and numeric values for existing result codes are fixed and unchanging. However, new result codes, and especially new extended result codes, might appear in future releases of SQLite.</source>
          <target state="translated">Названия и числовые значения для существующих кодов результатов являются фиксированными и неизменными.Однако в будущих релизах SQLite могут появиться новые коды результатов,и особенно новые расширенные коды результатов.</target>
        </trans-unit>
        <trans-unit id="6c186656572f2bf1670bbd5a3b99aeadd51bedda" translate="yes" xml:space="preserve">
          <source>The names of the columns are contained in first</source>
          <target state="translated">Названия столбцов содержатся в первом</target>
        </trans-unit>
        <trans-unit id="6e42a281800acf1a1a711bf3baf9388c4ecfa00b" translate="yes" xml:space="preserve">
          <source>The names returned are the original un-aliased names of the database, table, and column.</source>
          <target state="translated">Возвращаемые имена-это оригинальные несмещенные имена базы данных,таблицы и столбца.</target>
        </trans-unit>
        <trans-unit id="9d972c129d1db380a40044755e84ee7d9ba4bda3" translate="yes" xml:space="preserve">
          <source>The new &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config()&lt;/a&gt; interface allows an application to customize the behavior of SQLite at run-time. Customizations possible using &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config()&lt;/a&gt; include the following:</source>
          <target state="translated">Новый интерфейс &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config ()&lt;/a&gt; позволяет приложению настраивать поведение SQLite во время выполнения. Возможные настройки с помощью &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config ()&lt;/a&gt; включают следующее:</target>
        </trans-unit>
        <trans-unit id="3df658c177f1eac56b80fa5f85864ebd817426dc" translate="yes" xml:space="preserve">
          <source>The new &lt;a href=&quot;c3ref/status&quot;&gt;sqlite3_status()&lt;/a&gt; interface allows an application to query the performance status of SQLite at runtime.</source>
          <target state="translated">Новый интерфейс &lt;a href=&quot;c3ref/status&quot;&gt;sqlite3_status ()&lt;/a&gt; позволяет приложению запрашивать статус производительности SQLite во время выполнения.</target>
        </trans-unit>
        <trans-unit id="a8d3b04d8482aa6bd5d923ab36f6fdfe7a6ac1b9" translate="yes" xml:space="preserve">
          <source>The new API for SQLite 3.0 contains routines that accept text as both UTF-8 and UTF-16 in the native byte order of the host machine. Each database file manages text as either UTF-8, UTF-16BE (big-endian), or UTF-16LE (little-endian). Internally and in the disk file, the same text representation is used everywhere. If the text representation specified by the database file (in the file header) does not match the text representation required by the interface routines, then text is converted on-the-fly. Constantly converting text from one representation to another can be computationally expensive, so it is suggested that programmers choose a single representation and stick with it throughout their application.</source>
          <target state="translated">Новый API для SQLite 3.0 содержит подпрограммы,которые принимают текст как UTF-8,так и UTF-16 в родном порядке байт хост-машины.Каждый файл базы данных управляет текстом в формате UTF-8,UTF-16BE (big-endian)или UTF-16LE (little-endian).Внутри и в дисковом файле везде используется одно и то же текстовое представление.Если текстовое представление,заданное файлом БД (в заголовке файла),не совпадает с текстовым представлением,требуемым подпрограммами интерфейса,то текст преобразуется &quot;на лету&quot;.Постоянное преобразование текста из одного представления в другое может быть связано с большими вычислительными затратами,поэтому программистам предлагается выбрать одно представление и придерживаться его во всем своем приложении.</target>
        </trans-unit>
        <trans-unit id="f5fd61ae1c4f097aa92960dd4fc53f087c2a1de0" translate="yes" xml:space="preserve">
          <source>The new OP_SeekScan opcode is used to improve performance of multi-column index look-ups when later columns are constrained by an IN operator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30af4368149bbc60ce20946b58b7cfd9adb8ff97" translate="yes" xml:space="preserve">
          <source>The new OS interface for SQLite is built around an object named &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;. The &quot;vfs&quot; stands for &quot;Virtual File System&quot;. The sqlite3_vfs object is basically a structure containing pointers to functions that implement the primitive disk I/O operations that SQLite needs to perform in order to read and write databases. In this article, we will often refer to an sqlite3_vfs objects as a &quot;VFS&quot;.</source>
          <target state="translated">Новый интерфейс ОС для SQLite построен вокруг объекта с именем &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; . &amp;laquo;Vfs&amp;raquo; означает &amp;laquo;виртуальная файловая система&amp;raquo;. Объект sqlite3_vfs - это в основном структура, содержащая указатели на функции, реализующие примитивные операции дискового ввода-вывода, которые SQLite должен выполнять для чтения и записи баз данных. В этой статье мы часто будем называть объекты sqlite3_vfs &amp;laquo;VFS&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="6c9ac7112282c02c3ac370e4792bfc347f1711f1" translate="yes" xml:space="preserve">
          <source>The new change is ignored. This case does not occur if the new changeset was recorded immediately after the changesets already added to the changegroup.</source>
          <target state="translated">Новое изменение игнорируется.Этот случай не происходит,если новый changeset был записан сразу после того,как changeset уже был добавлен в группу изменений.</target>
        </trans-unit>
        <trans-unit id="7b39e9d3e42d3852cda66bb7e7297a2f31d0e706" translate="yes" xml:space="preserve">
          <source>The new database connection will use the &quot;multi-thread&quot; &lt;a href=&quot;../threadsafe&quot;&gt;threading mode&lt;/a&gt;. This means that separate threads are allowed to use SQLite at the same time, as long as each thread is using a different &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67ff5fb06e02cb095d4456f9e428328e41689b42" translate="yes" xml:space="preserve">
          <source>The new database connection will use the &quot;multi-thread&quot; &lt;a href=&quot;threadsafe&quot;&gt;threading mode&lt;/a&gt;. This means that separate threads are allowed to use SQLite at the same time, as long as each thread is using a different &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ed188f9846a7395326bff47f2223ddc25ac3eab" translate="yes" xml:space="preserve">
          <source>The new database connection will use the &quot;serialized&quot; &lt;a href=&quot;../threadsafe&quot;&gt;threading mode&lt;/a&gt;. This means the multiple threads can safely attempt to use the same database connection at the same time. (Mutexes will block any actual concurrency, but in this mode there is no harm in trying.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2075b8f3b4c50de265f00054b0d87b23e094598" translate="yes" xml:space="preserve">
          <source>The new database connection will use the &quot;serialized&quot; &lt;a href=&quot;threadsafe&quot;&gt;threading mode&lt;/a&gt;. This means the multiple threads can safely attempt to use the same database connection at the same time. (Mutexes will block any actual concurrency, but in this mode there is no harm in trying.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81ae31ac06c9efe8e8edfec9e13527250faad45f" translate="yes" xml:space="preserve">
          <source>The new database file format uses B+trees for tables. In a B+tree, all data is stored in the leaves of the tree instead of in both the leaves and the intermediate branch nodes. The use of B+trees for tables allows for better scalability and the storage of larger data fields without the use of overflow pages. Traditional B-trees are still used for indices.</source>
          <target state="translated">Новый формат файла базы данных использует B+деревья для таблиц.В B+tree все данные хранятся в листьях дерева,а не в листьях и промежуточных узлах ветвей.Использование B+tree для таблиц позволяет улучшить масштабируемость и хранение больших полей данных без использования страниц переполнения.Традиционные B-деревья по-прежнему используются для индексов.</target>
        </trans-unit>
        <trans-unit id="31e91eb6ebd1ae009dff2061b0ed5da69f5f04a8" translate="yes" xml:space="preserve">
          <source>The new file format also supports variable pages sizes between 512 and 65536 bytes. The size of a page is stored in the file header so the same library can read databases with different pages sizes, in theory, though this feature has not yet been implemented in practice.</source>
          <target state="translated">Новый формат файлов также поддерживает переменный размер страниц от 512 до 65536 байт.Размер страницы хранится в заголовке файла,так что одна и та же библиотека может читать базы данных с разными размерами страниц,теоретически,хотя эта возможность еще не реализована на практике.</target>
        </trans-unit>
        <trans-unit id="b7b98e36d84deeda55906998dc0425a8e896c821" translate="yes" xml:space="preserve">
          <source>The new file format omits unused fields from its disk images. For example, indices use only the key part of a B-tree record and not the data. So for indices, the field that records the length of the data is omitted. Integer values such as the length of key and data are stored using a variable-length encoding so that only one or two bytes are required to store the most common cases but up to 64-bits of information can be encoded if needed. Integer and floating point data is stored on the disk in binary rather than being converted into ASCII as in SQLite version 2.8. These changes taken together result in database files that are typically 25% to 35% smaller than the equivalent files in SQLite version 2.8.</source>
          <target state="translated">Новый формат файла исключает неиспользуемые поля из образов диска.Например,индексы используют только ключевую часть записи B-дерева,а не данные.Таким образом,для индексов опускается поле,записывающее длину данных.Целые значения,такие как длина ключа и данных,хранятся в кодировке переменной длины,так что для хранения наиболее распространенных случаев требуется только один или два байта,но при необходимости можно закодировать до 64 бит информации.Целые данные и данные с плавающей запятой хранятся на диске в двоичном виде,а не преобразуются в ASCII,как в SQLite версии 2.8.Эти изменения,взятые вместе,приводят к тому,что файлы базы данных,как правило,на 25-35% меньше,чем эквивалентные файлы в SQLite версии 2.8.</target>
        </trans-unit>
        <trans-unit id="5a8ddfc73fc040315222214bdfe8a3558fe0da52" translate="yes" xml:space="preserve">
          <source>The new interface uses three separate functions to replace the single &lt;b&gt;sqlite_exec&lt;/b&gt; function.</source>
          <target state="translated">В новом интерфейсе используются три отдельные функции, заменяющие одну функцию &lt;b&gt;sqlite_exec&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="601cb56433c850ed70120e223ec644602fc957a5" translate="yes" xml:space="preserve">
          <source>The new object is configured with the rebase buffer obtained from sqlite3changeset_apply_v2() by calling sqlite3rebaser_configure(). If the local changeset is to be rebased against multiple remote changesets, then sqlite3rebaser_configure() should be called multiple times, in the same order that the multiple sqlite3changeset_apply_v2() calls were made.</source>
          <target state="translated">Новый объект конфигурируется буфером rebase,полученным из sqlite3changeset_apply_v2()с помощью вызова sqlite3rebaser_configure().Если локальный changeset должен быть rebase против нескольких удалённых changesetов,то sqlite3rebaser_configure()должна быть вызвана несколько раз в том же порядке,в котором было сделано несколько вызовов sqlite3changeset_apply_v2().</target>
        </trans-unit>
        <trans-unit id="a80319826820a0baa113ed82a7da25195888339a" translate="yes" xml:space="preserve">
          <source>The new row must meet the same criteria as for &lt;a href=&quot;#sqlite3_blob_open&quot;&gt;sqlite3_blob_open()&lt;/a&gt; - it must exist and there must be either a blob or text value stored in the nominated column. If the new row is not present in the table, or if it does not contain a blob or text value, or if another error occurs, an SQLite error code is returned and the blob handle is considered aborted. All subsequent calls to &lt;a href=&quot;#sqlite3_blob_read&quot;&gt;sqlite3_blob_read()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_blob_write&quot;&gt;sqlite3_blob_write()&lt;/a&gt; or &lt;a href=&quot;#sqlite3_blob_reopen&quot;&gt;sqlite3_blob_reopen()&lt;/a&gt; on an aborted blob handle immediately return SQLITE_ABORT. Calling &lt;a href=&quot;#sqlite3_blob_bytes&quot;&gt;sqlite3_blob_bytes()&lt;/a&gt; on an aborted blob handle always returns zero.</source>
          <target state="translated">Новая строка должна соответствовать тем же критериям, что и &lt;a href=&quot;#sqlite3_blob_open&quot;&gt;sqlite3_blob_open ()&lt;/a&gt; - она ​​должна существовать, и в указанном столбце должно быть либо blob, либо текстовое значение. Если новая строка отсутствует в таблице, или если она не содержит большого двоичного объекта или текстового значения, или если возникает другая ошибка, возвращается код ошибки SQLite, и дескриптор большого двоичного объекта считается прерванным. Все последующие вызовы &lt;a href=&quot;#sqlite3_blob_read&quot;&gt;sqlite3_blob_read ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_blob_write&quot;&gt;sqlite3_blob_write ()&lt;/a&gt; или &lt;a href=&quot;#sqlite3_blob_reopen&quot;&gt;sqlite3_blob_reopen ()&lt;/a&gt; для прерванного дескриптора большого двоичного объекта немедленно возвращают SQLITE_ABORT. Вызов &lt;a href=&quot;#sqlite3_blob_bytes&quot;&gt;sqlite3_blob_bytes ()&lt;/a&gt; для дескриптора прерванного большого двоичного объекта всегда возвращает ноль.</target>
        </trans-unit>
        <trans-unit id="1fc9db87ef5146974ffc63aaf19ef4d76ed16ccc" translate="yes" xml:space="preserve">
          <source>The new row must meet the same criteria as for &lt;a href=&quot;blob_open&quot;&gt;sqlite3_blob_open()&lt;/a&gt; - it must exist and there must be either a blob or text value stored in the nominated column. If the new row is not present in the table, or if it does not contain a blob or text value, or if another error occurs, an SQLite error code is returned and the blob handle is considered aborted. All subsequent calls to &lt;a href=&quot;blob_read&quot;&gt;sqlite3_blob_read()&lt;/a&gt;, &lt;a href=&quot;blob_write&quot;&gt;sqlite3_blob_write()&lt;/a&gt; or &lt;a href=&quot;blob_reopen&quot;&gt;sqlite3_blob_reopen()&lt;/a&gt; on an aborted blob handle immediately return SQLITE_ABORT. Calling &lt;a href=&quot;blob_bytes&quot;&gt;sqlite3_blob_bytes()&lt;/a&gt; on an aborted blob handle always returns zero.</source>
          <target state="translated">Новая строка должна соответствовать тем же критериям, что и &lt;a href=&quot;blob_open&quot;&gt;sqlite3_blob_open ()&lt;/a&gt; - она ​​должна существовать, и в указанном столбце должно быть либо blob, либо текстовое значение. Если новая строка отсутствует в таблице, или если она не содержит большого двоичного объекта или текстового значения, или если возникает другая ошибка, возвращается код ошибки SQLite, и дескриптор большого двоичного объекта считается прерванным. Все последующие вызовы &lt;a href=&quot;blob_read&quot;&gt;sqlite3_blob_read ()&lt;/a&gt; , &lt;a href=&quot;blob_write&quot;&gt;sqlite3_blob_write ()&lt;/a&gt; или &lt;a href=&quot;blob_reopen&quot;&gt;sqlite3_blob_reopen ()&lt;/a&gt; для прерванного дескриптора большого двоичного объекта немедленно возвращают SQLITE_ABORT. Вызов &lt;a href=&quot;blob_bytes&quot;&gt;sqlite3_blob_bytes ()&lt;/a&gt; для дескриптора прерванного большого двоичного объекта всегда возвращает ноль.</target>
        </trans-unit>
        <trans-unit id="477dc8c1b42a8f1f1f9e215976276669879cbe40" translate="yes" xml:space="preserve">
          <source>The new values for each modified field of the row, and</source>
          <target state="translated">Новые значения для каждого измененного поля строки,и</target>
        </trans-unit>
        <trans-unit id="9ca11824ed5a21754d9f34df6fca6bca218bd35f" translate="yes" xml:space="preserve">
          <source>The new window definition must not include a PARTITION BY clause. The PARTITION BY clause, if there is one, must be supplied by the base window specification.</source>
          <target state="translated">Новое определение окна не должно включать пункт PARTITION BY.Оговорка PARTITION BY,если она существует,должна быть предоставлена спецификацией базового окна.</target>
        </trans-unit>
        <trans-unit id="f3a9a1d6f9268d0f1362c9fb457875a7fb250370" translate="yes" xml:space="preserve">
          <source>The newer &quot;.eqp trace&quot; command does everything that &quot;.eqp full&quot; does and also turns on &lt;a href=&quot;pragma#pragma_vdbe_trace&quot;&gt;VDBE tracing&lt;/a&gt;.</source>
          <target state="translated">Новая команда &amp;laquo;.eqp trace&amp;raquo; делает все, что делает &amp;laquo;.eqp full&amp;raquo;, а также включает &lt;a href=&quot;pragma#pragma_vdbe_trace&quot;&gt;трассировку VDBE&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fd8ed5a57b50230eec8d4ec2e3e5c1e149c55cc8" translate="yes" xml:space="preserve">
          <source>The newer xQueryFunc callback receives more information from the r-tree query engine on each call, and it sends more information back to the query engine before it returns. To help keep the interface manageable, the xQueryFunc callback sends and receives information from the query engine as fields in the sqlite3_rtree_query_info structure:</source>
          <target state="translated">Более новый обратный вызов xQueryFunc получает больше информации от механизма запросов r-дерева при каждом вызове,и он посылает больше информации обратно в механизм запросов до того,как он вернется.Чтобы сделать интерфейс управляемым,xQueryFunc отправляет и получает информацию от движка запросов в виде полей в структуре sqlite3_rtree_query_info:</target>
        </trans-unit>
        <trans-unit id="03223a32a94905afaa2e599c575bdc7c618a776e" translate="yes" xml:space="preserve">
          <source>The next &quot;.mode&quot; command will reset the &quot;.separator&quot; back to its default. So you will need repeat the &quot;.separator&quot; command whenever you change modes if you want to continue using a non-standard separator.</source>
          <target state="translated">Следующая команда &quot;.режим&quot; вернет &quot;.сепаратор&quot; в состояние по умолчанию.Таким образом,если вы хотите продолжать использовать нестандартный разделитель,вам нужно будет повторять команду &quot;.разделитель&quot; каждый раз,когда вы меняете режимы.</target>
        </trans-unit>
        <trans-unit id="9bff369a4e5022b3604d755cd856a8cb8591c715" translate="yes" xml:space="preserve">
          <source>The next block contains an example rank function that uses matchinfo data implemented in C. Instead of a single weight, it allows a weight to be externally assigned to each column of each document. It may be registered with SQLite like any other user function using &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function&lt;/a&gt;.</source>
          <target state="translated">Следующий блок содержит пример функции ранжирования, которая использует данные matchinfo, реализованные на C. Вместо единственного веса он позволяет внешне присваивать вес каждому столбцу каждого документа. Его можно зарегистрировать в SQLite, как и любую другую пользовательскую функцию, с помощью &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5e308fd7498285ea1f61e243e9d3f001701f643f" translate="yes" xml:space="preserve">
          <source>The next block of SQL enhances the query with solutions to two other problems that may arise in developing search applications using FTS:</source>
          <target state="translated">Следующий блок SQL дополняет запрос решением двух других проблем,которые могут возникнуть при разработке поисковых приложений с использованием FTS:</target>
        </trans-unit>
        <trans-unit id="acd253e5152192f86ab636fd16bb5196034aa10b" translate="yes" xml:space="preserve">
          <source>The next chart compares SQLite database updates in &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt; against raw direct-to-disk overwrites of separate files on disk. The &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous&lt;/a&gt; setting is NORMAL. All database writes are in a single transaction. The timer for the database writes is stopped after the transaction commits, but before a &lt;a href=&quot;wal#ckpt&quot;&gt;checkpoint&lt;/a&gt; is run. Note that the SQLite writes, unlike the direct-to-disk writes, are &lt;a href=&quot;transactional&quot;&gt;transactional&lt;/a&gt; and &lt;a href=&quot;transactional&quot;&gt;power-safe&lt;/a&gt;, though because the synchronous setting is NORMAL instead of FULL, the transactions are not durable.</source>
          <target state="translated">На следующей диаграмме сравниваются обновления базы данных SQLite в &lt;a href=&quot;wal&quot;&gt;режиме WAL&lt;/a&gt; с непосредственной перезаписью отдельных файлов на диске непосредственно на диск. &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;Синхронная ПРАГМА&lt;/a&gt; установка NORMAL. Все записи в базу данных выполняются за одну транзакцию. Таймер записи в базу данных останавливается после фиксации транзакции, но до запуска &lt;a href=&quot;wal#ckpt&quot;&gt;контрольной точки&lt;/a&gt; . Обратите внимание, что запись SQLite, в отличие от записи напрямую на диск, является &lt;a href=&quot;transactional&quot;&gt;транзакционной&lt;/a&gt; и &lt;a href=&quot;transactional&quot;&gt;энергобезопасной&lt;/a&gt; , хотя, поскольку синхронный параметр НОРМАЛЬНЫЙ вместо ПОЛНЫЙ, транзакции недолговечны.</target>
        </trans-unit>
        <trans-unit id="0aae132ea98563594c1fa5eb1b5277ade35e9e0f" translate="yes" xml:space="preserve">
          <source>The next chart shows the performance of SQLite versus direct-to-disk when transactions are disabled (&lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode=OFF&lt;/a&gt;) and &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous&lt;/a&gt; is set to OFF. These settings put SQLite on an equal footing with direct-to-disk writes, which is to say they make the data prone to corruption due to system crashes and power failures.</source>
          <target state="translated">Следующая диаграмма показывает производительность SQLite по сравнению с прямой &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;записью&lt;/a&gt; на диск, когда транзакции отключены ( PRAGMA journal_mode = OFF ), а &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;синхронный PRAGMA&lt;/a&gt; установлен на OFF. Эти настройки ставят SQLite в один ряд с прямой записью на диск, то есть они делают данные склонными к повреждению из-за сбоев системы и сбоев питания.</target>
        </trans-unit>
        <trans-unit id="a36fc6db6d371099515d1fcc0740a7c0b2437b14" translate="yes" xml:space="preserve">
          <source>The next example demonstrates lag(), lead(), first_value(), last_value() and nth_value(). The frame-spec is ignored by both lag() and lead(), but respected by first_value(), last_value() and nth_value().</source>
          <target state="translated">Следующий пример демонстрирует функции lag(),lead(),first_value(),last_value()и nth_value().Фрейм-spec игнорируется функциями lag()и lead(),но учитывается функциями first_value(),last_value()и nth_value().</target>
        </trans-unit>
        <trans-unit id="edb143346c38b864be88a8c33e46d2997195abb0" translate="yes" xml:space="preserve">
          <source>The next example uses two common table expressions in a single WITH clause. The following table records a family tree:</source>
          <target state="translated">Следующий пример использует два общих выражения таблицы в одном выражении WITH.Следующая таблица записывает семейное дерево:</target>
        </trans-unit>
        <trans-unit id="1e6dfc599524aaa9c044c52fd99b0a8ed104813e" translate="yes" xml:space="preserve">
          <source>The next interface routine to SQLite is a convenience function used to test whether or not a string forms a complete SQL statement. If the &lt;b&gt;sqlite_complete&lt;/b&gt; function returns true when its input is a string, then the argument forms a complete SQL statement. There are no guarantees that the syntax of that statement is correct, but we at least know the statement is complete. If &lt;b&gt;sqlite_complete&lt;/b&gt; returns false, then more text is required to complete the SQL statement.</source>
          <target state="translated">Следующая процедура интерфейса SQLite - это удобная функция, используемая для проверки того, образует ли строка полный оператор SQL. Если функция &lt;b&gt;sqlite_complete&lt;/b&gt; возвращает истину, когда ее входные данные являются строкой, тогда аргумент формирует полный оператор SQL. Нет никаких гарантий, что синтаксис этого оператора правильный, но мы, по крайней мере, знаем, что утверждение завершено. Если &lt;b&gt;sqlite_complete&lt;/b&gt; возвращает false, то для завершения оператора SQL требуется дополнительный текст.</target>
        </trans-unit>
        <trans-unit id="c0fe3b1ebf5cdcafa2a519a22d91d50cf98645d3" translate="yes" xml:space="preserve">
          <source>The next step in a multi-file commit is the creation of a &quot;master journal&quot; file. The name of the master journal file is the same name as the original database filename (the database that was opened using the &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt; interface, not one of the &lt;a href=&quot;lang_attach&quot;&gt;ATTACHed&lt;/a&gt; auxiliary databases) with the text &quot;&lt;b&gt;-mj&lt;/b&gt;</source>
          <target state="translated">Следующим шагом в многофайловой фиксации является создание файла &amp;laquo;главного журнала&amp;raquo;. Имя главного файла журнала совпадает с именем исходного файла базы данных (база данных, открытая с помощью интерфейса &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open ()&lt;/a&gt; , а не одна из вспомогательных баз данных, &lt;a href=&quot;lang_attach&quot;&gt;подключенных&lt;/a&gt; к ATTACH ) с текстом &amp;laquo; &lt;b&gt;-mj&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="0cd61740e94e70cec25ceb66f34763d5696dff28" translate="yes" xml:space="preserve">
          <source>The next step in a multi-file commit is the creation of a &quot;super-journal&quot; file. The name of the super-journal file is the same name as the original database filename (the database that was opened using the &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt; interface, not one of the &lt;a href=&quot;lang_attach&quot;&gt;ATTACHed&lt;/a&gt; auxiliary databases) with the text &quot;&lt;b&gt;-mj&lt;/b&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3da089b39e9e2681938268cb3d32b250cde300bb" translate="yes" xml:space="preserve">
          <source>The next step is to delete the master journal file. This is the point where the multi-file transaction commits. This step corresponds to &lt;a href=&quot;#section_3_11&quot;&gt;step 3.11&lt;/a&gt; in the single-file commit scenario where the rollback journal is deleted.</source>
          <target state="translated">Следующим шагом является удаление главного файла журнала. Это точка, где фиксируется транзакция с несколькими файлами. Этот шаг соответствует &lt;a href=&quot;#section_3_11&quot;&gt;шагу 3.11&lt;/a&gt; в сценарии фиксации одного файла, когда журнал отката удаляется.</target>
        </trans-unit>
        <trans-unit id="8eca8d6f0301fd62dd1a522a60a7179d3923b8b3" translate="yes" xml:space="preserve">
          <source>The next step is to delete the super-journal file. This is the point where the multi-file transaction commits. This step corresponds to &lt;a href=&quot;#section_3_11&quot;&gt;step 3.11&lt;/a&gt; in the single-file commit scenario where the rollback journal is deleted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f8a36a95656f30638f07c12cb9da14410f8f263" translate="yes" xml:space="preserve">
          <source>The next step is to flush the content of the rollback journal file to nonvolatile storage. As we will see later, this is a critical step in insuring that the database can survive an unexpected power loss. This step also takes a lot of time, since writing to nonvolatile storage is normally a slow operation.</source>
          <target state="translated">Следующим шагом является промывка содержимого файла журнала отката в энергонезависимое хранилище.Как мы увидим позже,это критически важный шаг в обеспечении того,чтобы база данных могла пережить неожиданное отключение электроэнергии.Этот шаг также занимает много времени,поскольку запись в энергонезависимое хранилище обычно выполняется медленно.</target>
        </trans-unit>
        <trans-unit id="2d76b37ca4cb1c2c8f635e9aaada12e5312b553c" translate="yes" xml:space="preserve">
          <source>The next step is to move the changes in the public branch over into the private branch. In other words, we want to create circle (5) in the diagram above. Begin by changing to the private branch using &quot;&lt;code&gt;fossil update private&lt;/code&gt;&quot;. Then type this command:</source>
          <target state="translated">Следующий шаг - переместить изменения из публичной ветви в частную. Другими словами, мы хотим создать круг (5) на диаграмме выше. Начните с перехода в частную ветку, используя &amp;laquo; &lt;code&gt;fossil update private&lt;/code&gt; &amp;raquo;. Затем введите эту команду:</target>
        </trans-unit>
        <trans-unit id="7e4259fddae0dc878cdf5dde573b08c0dee99991" translate="yes" xml:space="preserve">
          <source>The next step is to record the full pathname of the master journal file in the header of every rollback journal. Space to hold the master journal filename was reserved at the beginning of each rollback journal as the rollback journals were created.</source>
          <target state="translated">Следующий шаг-записать полное имя файла главного журнала в заголовок каждого журнала отката.В начале каждого откатного журнала по мере создания откатных журналов резервировалось место для хранения имени файла главного журнала.</target>
        </trans-unit>
        <trans-unit id="75cf4af1420a93693d3db893fcca12c3f40102cd" translate="yes" xml:space="preserve">
          <source>The next step is to record the full pathname of the super-journal file in the header of every rollback journal. Space to hold the super-journal filename was reserved at the beginning of each rollback journal as the rollback journals were created.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10799d0f2a52185a80b7f98059fdd7fef8ba0412" translate="yes" xml:space="preserve">
          <source>The next three bytes in the header record the number of vertexes in the polygon as a big-endian integer. Thus there is an upper bound of about 16 million vertexes per polygon.</source>
          <target state="translated">Следующие три байта в заголовке записывают количество вершин в полигоне в виде big-endian целого числа.Таким образом,на каждый многоугольник приходится около 16 миллионов вершин.</target>
        </trans-unit>
        <trans-unit id="a4532dd188d90322b7de7cb35c04fd5fcf2e6593" translate="yes" xml:space="preserve">
          <source>The next use of the &lt;a href=&quot;opcode#Rowid&quot;&gt;Rowid&lt;/a&gt; or &lt;a href=&quot;opcode#Column&quot;&gt;Column&lt;/a&gt; or &lt;a href=&quot;opcode#Next&quot;&gt;Next&lt;/a&gt; instruction for P1 will refer to the first entry in the database table or index. If the table or index is empty, jump immediately to P2. If the table or index is not empty, fall through to the following instruction.</source>
          <target state="translated">Следующее использование &lt;a href=&quot;opcode#Rowid&quot;&gt;RowId&lt;/a&gt; или &lt;a href=&quot;opcode#Column&quot;&gt;колонке&lt;/a&gt; или &lt;a href=&quot;opcode#Next&quot;&gt;Next&lt;/a&gt; инструкции для P1 будет относиться к первой записи в таблице базы данных или индекса. Если таблица или индекс пусты, сразу переходите к P2. Если таблица или индекс не пустые, выполните следующую инструкцию.</target>
        </trans-unit>
        <trans-unit id="db275badbcaa5bbb5c1ecd5830883705763b811b" translate="yes" xml:space="preserve">
          <source>The next use of the &lt;a href=&quot;opcode#Rowid&quot;&gt;Rowid&lt;/a&gt; or &lt;a href=&quot;opcode#Column&quot;&gt;Column&lt;/a&gt; or &lt;a href=&quot;opcode#Prev&quot;&gt;Prev&lt;/a&gt; instruction for P1 will refer to the last entry in the database table or index. If the table or index is empty and P2&amp;gt;0, then jump immediately to P2. If P2 is 0 or if the table or index is not empty, fall through to the following instruction.</source>
          <target state="translated">Следующее использование &lt;a href=&quot;opcode#Rowid&quot;&gt;RowId&lt;/a&gt; или &lt;a href=&quot;opcode#Column&quot;&gt;колонке&lt;/a&gt; или &lt;a href=&quot;opcode#Prev&quot;&gt;Prev&lt;/a&gt; инструкции для P1 будет относиться к последней записи в таблице базы данных или индекса. Если таблица или индекс пусты и P2&amp;gt; 0, немедленно переходите к P2. Если P2 равен 0 или если таблица или индекс не пустые, выполните следующую инструкцию.</target>
        </trans-unit>
        <trans-unit id="971bdad47f863dca0857c6853816fdb36613779f" translate="yes" xml:space="preserve">
          <source>The no-op memory allocator is not useful by itself. It exists only as a placeholder so that SQLite has a memory allocator to link against on systems that may not have malloc(), free(), or realloc() in their standard library. An application that is compiled with &lt;a href=&quot;compile#zero_malloc&quot;&gt;SQLITE_ZERO_MALLOC&lt;/a&gt; will need to use &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config()&lt;/a&gt; together with &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmalloc&quot;&gt;SQLITE_CONFIG_MALLOC&lt;/a&gt; or &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigheap&quot;&gt;SQLITE_CONFIG_HEAP&lt;/a&gt; to specify a new alternative memory allocator before beginning to use SQLite.</source>
          <target state="translated">Сам по себе неоперативный распределитель памяти бесполезен. Он существует только как заполнитель, поэтому SQLite имеет распределитель памяти для связывания в системах, которые могут не иметь malloc (), free () или realloc () в своей стандартной библиотеке. Приложение, которое скомпилировано с &lt;a href=&quot;compile#zero_malloc&quot;&gt;SQLITE_ZERO_MALLOC,&lt;/a&gt; должно будет использовать &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config ()&lt;/a&gt; вместе с &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmalloc&quot;&gt;SQLITE_CONFIG_MALLOC&lt;/a&gt; или &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigheap&quot;&gt;SQLITE_CONFIG_HEAP,&lt;/a&gt; чтобы указать новый альтернативный распределитель памяти перед началом использования SQLite.</target>
        </trans-unit>
        <trans-unit id="fa03e3271f78c25f5482177efc3b575ee4cb93ab" translate="yes" xml:space="preserve">
          <source>The nolock query parameter is a boolean that disables all calls to the xLock, xUnlock, and xCheckReservedLock methods of the VFS when true. The nolock query parameter might be used, for example, when trying to access a file on a filesystem that does not support file locking. Caution: If two or more &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt; try to interact with the same SQLite database and one or more of those connections has enabled &quot;nolock&quot;, then database corruption can result. The &quot;nolock&quot; query parameter should only be used if the application can guarantee that writes to the database are serialized.</source>
          <target state="translated">Параметр запроса nolock - это логическое значение, которое отключает все вызовы методов xLock, xUnlock и xCheckReservedLock VFS, если оно истинно. Параметр запроса nolock может использоваться, например, при попытке доступа к файлу в файловой системе, которая не поддерживает блокировку файлов. Внимание: если два или более &lt;a href=&quot;c3ref/sqlite3&quot;&gt;подключения&lt;/a&gt; к базе данных пытаются взаимодействовать с одной и той же базой данных SQLite, и одно или несколько из этих подключений включили &amp;laquo;блокировку&amp;raquo;, это может привести к повреждению базы данных. Параметр запроса &amp;laquo;nolock&amp;raquo; следует использовать только в том случае, если приложение может гарантировать сериализацию записи в базу данных.</target>
        </trans-unit>
        <trans-unit id="b327cb7b48d6db3fd953f98055ad0798aba25bf9" translate="yes" xml:space="preserve">
          <source>The normal ROWID selection algorithm described above will generate monotonically increasing unique ROWIDs as long as you never use the maximum ROWID value and you never delete the entry in the table with the largest ROWID. If you ever delete rows or if you ever create a row with the maximum possible ROWID, then ROWIDs from previously deleted rows might be reused when creating new rows and newly created ROWIDs might not be in strictly ascending order.</source>
          <target state="translated">Обычный алгоритм выбора ROWID,описанный выше,будет генерировать монотонно увеличивающиеся уникальные ROWID до тех пор,пока вы никогда не используете максимальное значение ROWID и никогда не удаляете запись в таблице с наибольшим ROWID.Если Вы когда-либо удаляли строки или если Вы когда-либо создавали строку с максимально возможным ROWID,то ROWID из ранее удаленных строк могут быть повторно использованы при создании новых строк,а вновь созданные ROWID могут быть не в строгом порядке возрастания.</target>
        </trans-unit>
        <trans-unit id="dd6fdcceb1d1ed51baa294f01d457a9007d5dbff" translate="yes" xml:space="preserve">
          <source>The notindexed= option is not available. Adding &lt;a href=&quot;fts5#the_unindexed_column_option&quot;&gt;UNINDEXED&lt;/a&gt; to the column definition is equivalent.</source>
          <target state="translated">Параметр notindexed = недоступен. Добавление &lt;a href=&quot;fts5#the_unindexed_column_option&quot;&gt;UNINDEXED&lt;/a&gt; к определению столбца эквивалентно.</target>
        </trans-unit>
        <trans-unit id="e15aca005b3d3fc4e0be53d1a5e363f5a459da35" translate="yes" xml:space="preserve">
          <source>The nullif(X,Y) function returns its first argument if the arguments are different and NULL if the arguments are the same. The nullif(X,Y) function searches its arguments from left to right for an argument that defines a collating function and uses that collating function for all string comparisons. If neither argument to nullif() defines a collating function then the BINARY is used.</source>
          <target state="translated">Функция nullif(X,Y)возвращает свой первый аргумент,если аргументы разные,и NULL,если аргументы одинаковые.Функция nullif(X,Y)ищет слева направо свои аргументы,которые определяют функцию сравнения и использует эту функцию для всех строковых сравнений.Если ни один из аргументов nullif()не определяет функцию сравнения,то используется БИНАРИЙ.</target>
        </trans-unit>
        <trans-unit id="0d33dbf967cc9fffb2bcf5f7dd0e676a56e0fe27" translate="yes" xml:space="preserve">
          <source>The number of arguments to a function is sometimes stored in a signed character. So there is a hard upper bound on SQLITE_MAX_FUNCTION_ARG of 127.</source>
          <target state="translated">Количество аргументов к функции иногда хранится в знаковом символе.Поэтому на SQLITE_MAX_FUNCTION_ARG из 127 существует жесткая верхняя граница.</target>
        </trans-unit>
        <trans-unit id="22855456991124f9a63a13f70b4de30a07b1a44f" translate="yes" xml:space="preserve">
          <source>The number of characters in cFrom and cTo do not need to be the same. The rule above says that &quot;ss&quot; on user input will match &quot;&amp;szlig;&quot; with a penalty of 8.</source>
          <target state="translated">Количество символов в cFrom и cTo не обязательно должно быть одинаковым. Приведенное выше правило гласит, что &quot;ss&quot; при вводе пользователем будет соответствовать &quot;&amp;szlig;&quot; со штрафом 8.</target>
        </trans-unit>
        <trans-unit id="1dc8b6de1e412ad3d4600fff75a5432b18cfae89" translate="yes" xml:space="preserve">
          <source>The number of columns in a table</source>
          <target state="translated">Количество колонок в таблице</target>
        </trans-unit>
        <trans-unit id="c449227bed7d73e21c9772a435303abb6080e61e" translate="yes" xml:space="preserve">
          <source>The number of columns in a table is limited by the &lt;a href=&quot;limits#max_column&quot;&gt;SQLITE_MAX_COLUMN&lt;/a&gt; compile-time parameter. A single row of a table cannot store more than &lt;a href=&quot;limits#max_length&quot;&gt;SQLITE_MAX_LENGTH&lt;/a&gt; bytes of data. Both of these limits can be lowered at runtime using the &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit()&lt;/a&gt; C/C++ interface.</source>
          <target state="translated">Количество столбцов в таблице ограничено параметром времени компиляции &lt;a href=&quot;limits#max_column&quot;&gt;SQLITE_MAX_COLUMN&lt;/a&gt; . В одной строке таблицы не может храниться более &lt;a href=&quot;limits#max_length&quot;&gt;SQLITE_MAX_LENGTH&lt;/a&gt; байтов данных. Оба эти ограничения могут быть снижены во время выполнения с помощью интерфейса &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit ()&lt;/a&gt; C / C ++.</target>
        </trans-unit>
        <trans-unit id="8a6392262a1b2aadeab5c7954067326f2acb3a1d" translate="yes" xml:space="preserve">
          <source>The number of columns in a view</source>
          <target state="translated">Количество колонок в представлении</target>
        </trans-unit>
        <trans-unit id="7da1c90b5d954b64a1a4a566749d8c554741462e" translate="yes" xml:space="preserve">
          <source>The number of columns in an index</source>
          <target state="translated">Количество столбцов в индексе</target>
        </trans-unit>
        <trans-unit id="155a4bbdc3161555e0a5db3b049b1a9960793a80" translate="yes" xml:space="preserve">
          <source>The number of columns in each row returned by the SELECT statement (if any) and the specific values returned have no effect on the results of the EXISTS operator. In particular, rows containing NULL values are not handled any differently from rows without NULL values.</source>
          <target state="translated">Количество столбцов в каждой строке,возвращаемое оператором SELECT (если таковой имеется),и конкретные значения,возвращаемые оператором EXISTS,не влияют на результаты работы оператора EXISTS.В частности,строки,содержащие NULL-значения,не обрабатываются иначе,чем строки без NULL-значений.</target>
        </trans-unit>
        <trans-unit id="b33773d9bb8fcd548b7aa9142e9dd252802d3ebf" translate="yes" xml:space="preserve">
          <source>The number of columns in the result set of a SELECT statement</source>
          <target state="translated">Количество столбцов в результирующем наборе SELECT-оператора</target>
        </trans-unit>
        <trans-unit id="5962dbc1c4fa716686ee3f9c370159a83fff2488" translate="yes" xml:space="preserve">
          <source>The number of columns in the rows returned by a simple SELECT statement is equal to the number of expressions in the result expression list after substitution of * and alias.* expressions. Each result row is calculated by evaluating the expressions in the result expression list with respect to a single row of input data or, for aggregate queries, with respect to a group of rows.</source>
          <target state="translated">Количество столбцов в строках,возвращаемых простым оператором SELECT,равно количеству выражений в списке выражений результата после замены выражений*и alias.*.Каждая строка результата вычисляется путем вычисления выражений в списке результирующих выражений относительно одной строки входных данных или,для агрегированных запросов,относительно группы строк.</target>
        </trans-unit>
        <trans-unit id="efcaef0127aaba4759abf4c43138ceabba69a62b" translate="yes" xml:space="preserve">
          <source>The number of columns in the table, and</source>
          <target state="translated">Количество колонок в таблице,и</target>
        </trans-unit>
        <trans-unit id="ec4b9441464f8df5d1135d79fc696ff2d27c10ef" translate="yes" xml:space="preserve">
          <source>The number of columns the table has, and</source>
          <target state="translated">Количество колонок в таблице,и</target>
        </trans-unit>
        <trans-unit id="f71fcd9bd24f5e705202e8ea9d15f75d827b7073" translate="yes" xml:space="preserve">
          <source>The number of entries in the write-ahead log (WAL) file for that database</source>
          <target state="translated">Количество записей в файле журнала записи (WAL)для этой базы данных</target>
        </trans-unit>
        <trans-unit id="146718a82c006ef871da6bc05817a225f7435b26" translate="yes" xml:space="preserve">
          <source>The number of fields in this row.</source>
          <target state="translated">Количество полей в этой строке.</target>
        </trans-unit>
        <trans-unit id="049187119aa733be135d042e46c0767e81dbbd57" translate="yes" xml:space="preserve">
          <source>The number of freelist pages is stored as a 4-byte big-endian integer in the database header at an offset of 36 from the beginning of the file. The database header also stores the page number of the first freelist trunk page as a 4-byte big-endian integer at an offset of 32 from the beginning of the file.</source>
          <target state="translated">Количество страниц фрилиста хранится в заголовке БД в виде 4-байтового большого числа со смещением 36 от начала файла.В заголовке БД номер страницы первой страницы ствола фрилиста также хранится в виде 4-байтового big-endian целого числа со смещением 32 от начала файла.</target>
        </trans-unit>
        <trans-unit id="1267821fa107fc1f1ce35c73214837ec37375367" translate="yes" xml:space="preserve">
          <source>The number of keys on an interior b-tree page, K, is almost always at least 2 and is usually much more than 2. The only exception is when page 1 is an interior b-tree page. Page 1 has 100 fewer bytes of storage space available, due to the presence of the database header at the beginning of that page, and so sometimes (rarely) if page 1 is an interior b-tree page, it can end up holding just a a single key. In all other cases, K is 2 or more. The upper bound on K is as many keys as will fit on the page. Large keys on index b-trees are split up into &lt;a href=&quot;fileformat2#ovflpgs&quot;&gt;overflow pages&lt;/a&gt; so that no single key uses more than one fourth of the available storage space on the page and hence every internal page is able to store at least 4 keys. The integer keys of table b-trees are never large enough to require overflow, so key overflow only occurs on index b-trees.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="297412af9b640397abb6b05573031f719033bedb" translate="yes" xml:space="preserve">
          <source>The number of matchable phrases in the query.</source>
          <target state="translated">Количество совпадающих фраз в запросе.</target>
        </trans-unit>
        <trans-unit id="96242742547a237955f6f616dd7a1536e46de1dc" translate="yes" xml:space="preserve">
          <source>The number of open read-transactions on the shared-cache drops to zero.</source>
          <target state="translated">Количество открытых read-транзакций на разделяемом кэше снижается до нуля.</target>
        </trans-unit>
        <trans-unit id="140866849ab31e765e1dcf46dadf93357615ced1" translate="yes" xml:space="preserve">
          <source>The number of registers in a single prepared statement is fixed at compile-time. The content of all registers is cleared when a prepared statement is &lt;a href=&quot;c3ref/reset&quot;&gt;reset&lt;/a&gt; or &lt;a href=&quot;c3ref/finalize&quot;&gt;finalized&lt;/a&gt;.</source>
          <target state="translated">Количество регистров в одном подготовленном операторе фиксируется во время компиляции. Содержимое всех регистров очищается, когда подготовленный оператор &lt;a href=&quot;c3ref/reset&quot;&gt;сбрасывается&lt;/a&gt; или &lt;a href=&quot;c3ref/finalize&quot;&gt;завершается&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4967dccc017338cead0491dfe60a2adb347e1af4" translate="yes" xml:space="preserve">
          <source>The number of rows in a &lt;a href=&quot;lang_select#values&quot;&gt;VALUES clause&lt;/a&gt; is no longer limited by &lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitcompoundselect&quot;&gt;SQLITE_LIMIT_COMPOUND_SELECT&lt;/a&gt;.</source>
          <target state="translated">Количество строк в предложении &lt;a href=&quot;lang_select#values&quot;&gt;VALUES&lt;/a&gt; больше не ограничивается &lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitcompoundselect&quot;&gt;SQLITE_LIMIT_COMPOUND_SELECT&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="36747c7623716448e27a5f87c9f1a06587b9fa71" translate="yes" xml:space="preserve">
          <source>The number of rows in the FTS4 table. This value is only available when querying FTS4 tables, not FTS3.</source>
          <target state="translated">Количество строк в таблице FTS4.Это значение доступно только при запросе таблиц FTS4,а не FTS3.</target>
        </trans-unit>
        <trans-unit id="e61b9ea13ff6553c9d51a6610c8145f4cf2adbcc" translate="yes" xml:space="preserve">
          <source>The number of rows in the FTS5 table for which column $col contains at least one instance of the term.</source>
          <target state="translated">Количество строк в таблице FTS5,для которых столбец $col содержит хотя бы один экземпляр термина.</target>
        </trans-unit>
        <trans-unit id="05c84b067bb80eadabe7075383b96e16df1c5aad" translate="yes" xml:space="preserve">
          <source>The number of rows that contain at least one instance of the term.</source>
          <target state="translated">Количество строк,содержащих хотя бы один экземпляр термина.</target>
        </trans-unit>
        <trans-unit id="32422ea0ce2f612eaf439b2072fddd2d97242e6b" translate="yes" xml:space="preserve">
          <source>The number of system calls for filesystem operations is reduced, possibly resulting in a small performance increase.</source>
          <target state="translated">Количество системных вызовов операций с файловой системой уменьшается,что может привести к небольшому повышению производительности.</target>
        </trans-unit>
        <trans-unit id="e6551507f016b4d4b5fee98e7304b5666b04c04e" translate="yes" xml:space="preserve">
          <source>The number of terms in a GROUP BY or ORDER BY clause</source>
          <target state="translated">Количество терминов в пункте GROUP BY или ORDER BY</target>
        </trans-unit>
        <trans-unit id="1c91b565cbe9942030a8129bf45c560b0a7de90f" translate="yes" xml:space="preserve">
          <source>The number of terms in the SET clause of an UPDATE statement</source>
          <target state="translated">Количество терминов в пункте SET заявления UPDATE</target>
        </trans-unit>
        <trans-unit id="70c8732a507183c03eb179514303045a0317c738" translate="yes" xml:space="preserve">
          <source>The number of the current row's peer group within its partition - the rank of the current row without gaps. Partitions are numbered starting from 1 in the order defined by the ORDER BY clause in the window definition. If there is no ORDER BY clause, then all rows are considered peers and this function always returns 1.</source>
          <target state="translated">Номер одноранговой группы текущей строки внутри ее раздела-ранг текущей строки без пробелов.Простенки нумеруются,начиная с 1,в порядке,определенном пунктом ЗАПИСЬ BY в дефиниции окна.Если нет пункта ORDER BY,то все строки считаются одноранговыми,и эта функция всегда возвращает 1.</target>
        </trans-unit>
        <trans-unit id="19450a48e3be402fdbd06d100d558662cd52a063" translate="yes" xml:space="preserve">
          <source>The number of the row within the current partition. Rows are numbered starting from 1 in the order defined by the ORDER BY clause in the window definition, or in arbitrary order otherwise.</source>
          <target state="translated">Номер строки внутри текущего раздела.Строки нумеруются,начиная с 1,в порядке,определенном пунктом ЗАПИСЬ BY в дефиниции окна,или в произвольном порядке.</target>
        </trans-unit>
        <trans-unit id="4dd0d77e2a923847446dbf60b3f48736890bd6ba" translate="yes" xml:space="preserve">
          <source>The number of user defined columns in the FTS table (i.e. not including the docid or the &lt;a href=&quot;fts3#hiddencol&quot;&gt;FTS hidden column&lt;/a&gt;).</source>
          <target state="translated">Количество определяемых пользователем столбцов в таблице FTS (т. Е. Не включая docid или &lt;a href=&quot;fts3#hiddencol&quot;&gt;скрытый столбец FTS&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="ec04163c2280ea8f1f3a4d1db55ac34599bd6c09" translate="yes" xml:space="preserve">
          <source>The number of values in an INSERT statement</source>
          <target state="translated">Количество значений в заявлении INSERT</target>
        </trans-unit>
        <trans-unit id="0c5896381d0db64fdbbf15f25aac8c07347171d8" translate="yes" xml:space="preserve">
          <source>The numbered list above notes that the data for the first page of the database file, if it exists and is not already loaded into the</source>
          <target state="translated">Приведенный выше пронумерованный список отмечает,что данные для первой страницы файла базы данных,если она существует и еще не загружена в</target>
        </trans-unit>
        <trans-unit id="57671fab77edd8c578d7c9204ffe057965cc804a" translate="yes" xml:space="preserve">
          <source>The numbers here have become meaningless. This page has been retained only as an historical artifact.</source>
          <target state="translated">Цифры здесь стали бессмысленными.Эта страница сохранилась только как исторический артефакт.</target>
        </trans-unit>
        <trans-unit id="dde5b38271f3bab6f5848df944b4001a9705e033" translate="yes" xml:space="preserve">
          <source>The numbers on the left are the CPU cycle counts for that line of code, of course.</source>
          <target state="translated">Цифры слева-это,конечно же,цикл процессора для этой строки кода.</target>
        </trans-unit>
        <trans-unit id="a08476269382d9cd02770e2cab87ae0ab5a527b0" translate="yes" xml:space="preserve">
          <source>The object is deleted using a call to sqlite3changegroup_delete().</source>
          <target state="translated">Объект удаляется с помощью вызова sqlite3changegroup_delete().</target>
        </trans-unit>
        <trans-unit id="5ae7075075a940fc9e83c06d49e89ed478d0bf99" translate="yes" xml:space="preserve">
          <source>The one-byte flag at offset 0 indicating the b-tree page type.</source>
          <target state="translated">Однобайтовый флаг со смещением 0,указывающий тип страницы b-дерева.</target>
        </trans-unit>
        <trans-unit id="8ef8e17609c1f629f28fe60dfd6c0e8997843e40" translate="yes" xml:space="preserve">
          <source>The one-byte integer at offset 7 gives the number of fragmented free bytes within the cell content area.</source>
          <target state="translated">Одно-байтовое целое число со смещением 7 дает количество фрагментированных свободных байтов в области содержимого ячейки.</target>
        </trans-unit>
        <trans-unit id="729502a2e01c1766734981063a90830e318512ca" translate="yes" xml:space="preserve">
          <source>The online backup API is &lt;a href=&quot;c3ref/backup_finish#sqlite3backupinit&quot;&gt;documented here&lt;/a&gt;. The remainder of this page contains two C language examples illustrating common uses of the API and discussions thereof. Reading these examples is no substitute for reading the API documentation!</source>
          <target state="translated">Здесь &lt;a href=&quot;c3ref/backup_finish#sqlite3backupinit&quot;&gt;документирован&lt;/a&gt; API онлайн-резервного копирования . Оставшаяся часть этой страницы содержит два примера языка C, иллюстрирующие общие способы использования API и их обсуждения. Чтение этих примеров не заменяет чтение документации API!</target>
        </trans-unit>
        <trans-unit id="0ca3b9f46f696e6082e6b7a829be81ef745b8e77" translate="yes" xml:space="preserve">
          <source>The only SQLite compile-time option used was &lt;a href=&quot;compile#enable_memsys5&quot;&gt;-DSQLITE_ENABLE_MEMSYS5&lt;/a&gt;. The optional &lt;a href=&quot;malloc#memsys5&quot;&gt;memsys5&lt;/a&gt; memory allocator is used for performance testing because it gives results that are more repeatable than the library-supplied malloc()/free() on Ubuntu.</source>
          <target state="translated">Единственная используемая опция времени компиляции SQLite была &lt;a href=&quot;compile#enable_memsys5&quot;&gt;-DSQLITE_ENABLE_MEMSYS5&lt;/a&gt; . Дополнительный &lt;a href=&quot;malloc#memsys5&quot;&gt;распределитель&lt;/a&gt; памяти memsys5 используется для тестирования производительности, поскольку он дает более воспроизводимые результаты, чем предоставляемый библиотекой malloc () / free () в Ubuntu.</target>
        </trans-unit>
        <trans-unit id="89c13a55d3d11964427a1a5b2d10d0b78ec66565" translate="yes" xml:space="preserve">
          <source>The only compression algorithm supported is &lt;a href=&quot;https://zlib.net&quot;&gt;&quot;deflate&quot;&lt;/a&gt;.</source>
          <target state="translated">Единственный поддерживаемый алгоритм сжатия - &lt;a href=&quot;https://zlib.net&quot;&gt;&amp;laquo;deflate&amp;raquo;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ecb1124fca00e2a69914563c0d3a9baa08011926" translate="yes" xml:space="preserve">
          <source>The only difference between the following two CASE expressions is that the</source>
          <target state="translated">Единственное различие между двумя следующими выражениями CASE заключается в том,что</target>
        </trans-unit>
        <trans-unit id="f71f4a9db1fb88c54de0203ce462454fe4edc774" translate="yes" xml:space="preserve">
          <source>The only difference is that the public sqlite3_XXX functions enumerated above silently ignore any invocations that pass a NULL pointer instead of a valid mutex handle. The implementations of the methods defined by this structure are not required to handle this case, the results of passing a NULL pointer instead of a valid mutex handle are undefined (i.e. it is acceptable to provide an implementation that segfaults if it is passed a NULL pointer).</source>
          <target state="translated">Единственное отличие состоит в том,что публичные функции sqlite3_XXX,перечисленные выше,беззвучно игнорируют любые вызовы,которые передают NULL указатель вместо действительного хэндла мьютекса.Реализации методов,определенных данной структурой,для обработки этого случая не требуются,результаты передачи указателя NULL вместо действительного хэндла мьютекса неопределенны (т.е.допустима реализация,которая segfaults в случае передачи указателя NULL).</target>
        </trans-unit>
        <trans-unit id="9650a6c44a89db8ce8453af489933161fa10a223" translate="yes" xml:space="preserve">
          <source>The only difference is that the public sqlite3_XXX functions enumerated above silently ignore any invocations that pass a NULL pointer instead of a valid mutex handle. The implementations of the methods defined by this structure are not required to handle this case. The results of passing a NULL pointer instead of a valid mutex handle are undefined (i.e. it is acceptable to provide an implementation that segfaults if it is passed a NULL pointer).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="927a15e9b9c9c5a21e0cad33a99f89864994a2c1" translate="yes" xml:space="preserve">
          <source>The only really hard part is step 1. You might want to start with an existing virtual table implementation and modify it to suit your needs. The &lt;a href=&quot;https://sqlite.org/src/dir?ci=trunk&amp;amp;type=tree&quot;&gt;SQLite source tree&lt;/a&gt; contains many virtual table implementations that are suitable for copying, including:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b216563d4489c23da5dd8ef7bbce7ce15447a023" translate="yes" xml:space="preserve">
          <source>The only really hard part is step 1. You might want to start with an existing virtual table implementation and modify it to suit your needs. There are several virtual table implementations in the SQLite source tree (for testing purposes). You might use one of those as a guide. Locate these test virtual table implementations by searching for &quot;sqlite3_create_module&quot;.</source>
          <target state="translated">Единственная действительно сложная часть-это шаг 1.Возможно,вы захотите начать с существующей реализации виртуальной таблицы и модифицировать ее в соответствии с вашими потребностями.В дереве исходных текстов SQLite есть несколько реализаций виртуальных таблиц (для тестовых целей).Вы можете использовать одну из них в качестве руководства.Найдите эти тестовые реализации виртуальных таблиц с помощью поиска &quot;sqlite3_create_module&quot;.</target>
        </trans-unit>
        <trans-unit id="6a54b4d13a6de9bd96883cd76ca40e5bd7dd1a4b" translate="yes" xml:space="preserve">
          <source>The only reasons for providing functions other than strftime() is for convenience and for efficiency.</source>
          <target state="translated">Единственная причина предоставления функций,отличных от strftime()-это удобство и эффективность.</target>
        </trans-unit>
        <trans-unit id="c64051b826835db581e8535aa4a8fb802f2e8d26" translate="yes" xml:space="preserve">
          <source>The only schema altering commands directly supported by SQLite are the &quot;&lt;a href=&quot;lang_altertable#altertabrename&quot;&gt;rename table&lt;/a&gt;&quot;, &quot;&lt;a href=&quot;lang_altertable#altertabmvcol&quot;&gt;rename column&lt;/a&gt;&quot;, and &quot;&lt;a href=&quot;lang_altertable#altertabaddcol&quot;&gt;add column&lt;/a&gt;&quot; commands shown above. However, applications can make other arbitrary changes to the format of a table using a simple sequence of operations. The steps to make arbitrary changes to the schema design of some table X are as follows:</source>
          <target state="translated">Единственные команды изменения схемы, напрямую поддерживаемые SQLite, - это команды &amp;laquo; &lt;a href=&quot;lang_altertable#altertabrename&quot;&gt;переименовать таблицу&lt;/a&gt; &amp;raquo;, &amp;laquo; &lt;a href=&quot;lang_altertable#altertabmvcol&quot;&gt;переименовать столбец&lt;/a&gt; &amp;raquo; и &amp;laquo; &lt;a href=&quot;lang_altertable#altertabaddcol&quot;&gt;добавить столбец&lt;/a&gt; &amp;raquo;, показанные выше. Однако приложения могут вносить другие произвольные изменения в формат таблицы, используя простую последовательность операций. Шаги по внесению произвольных изменений в схему некоторой таблицы X следующие:</target>
        </trans-unit>
        <trans-unit id="a93c45a553bd489c541613e587314033dbb5442e" translate="yes" xml:space="preserve">
          <source>The only significant design decision that developers need to make is whether to use -Os (optimize for size) or -O6 (optimize for speed). The -O6 setting makes binaries that run about 2% or 3% faster, but which are also 66% larger. The performance here is measured by counting CPU cycles using cachegrind. I-cache misses are not considered in the analysis. If I-cache misses are considered, builds with -O6 might not be any faster than builds with -Os.</source>
          <target state="translated">Единственное значимое проектное решение,которое необходимо принять разработчикам,это использовать -OO (оптимизация под размер)или -O6 (оптимизация под скорость).Настройка -O6 делает двоичные файлы,которые работают примерно на 2% или 3% быстрее,но которые также на 66% больше.Производительность здесь измеряется путем подсчета циклов процессора с помощью кэшфренда.Пропуски I-кэша в анализе не учитываются.Если учитывать пропуски в I-cache,то сборки с -O6 могут быть не быстрее,чем сборки с -O.</target>
        </trans-unit>
        <trans-unit id="67fcf151555c1f1738044349d853d4cc0820a67f" translate="yes" xml:space="preserve">
          <source>The only thing that is really new about the current example is the WHERE clause which is implemented by instructions at addresses 7 through 10. Instructions at address 7 and 8 push onto the stack the value of the &quot;one&quot; column from the table and the literal string &quot;H%&quot;. The &lt;a href=&quot;opcode#Function&quot;&gt;Function&lt;/a&gt; instruction at address 9 pops these two values from the stack and pushes the result of the LIKE() function back onto the stack. The &lt;a href=&quot;opcode#IfNot&quot;&gt;IfNot&lt;/a&gt; instruction pops the top stack value and causes an immediate jump forward to the Next instruction if the top value was false (&lt;em&gt;not&lt;/em&gt; not like the literal string &quot;H%&quot;). Taking this jump effectively skips the callback, which is the whole point of the WHERE clause. If the result of the comparison is true, the jump is not taken and control falls through to the Callback instruction below.</source>
          <target state="translated">Единственное, что действительно ново в текущем примере, - это предложение WHERE, которое реализуется инструкциями по адресам с 7 по 10. Инструкции по адресам 7 и 8 помещают в стек значение столбца &quot;один&quot; из таблицы и литерала. строка &quot;H%&quot;. &lt;a href=&quot;opcode#Function&quot;&gt;Функция&lt;/a&gt; Инструкция по адресу 9 выскакивает эти два значения из стека и помещает результат LIKE () функции на стек. &lt;a href=&quot;opcode#IfNot&quot;&gt;IFNOT&lt;/a&gt; инструкция выталкивает значение верхнего стека и вызывает немедленный переход вперед к следующей инструкции , если верхнее значение было ложным ( &lt;em&gt;не&lt;/em&gt;не похоже на буквальную строку &quot;H%&quot;). Выполнение этого перехода фактически пропускает обратный вызов, в чем заключается весь смысл предложения WHERE. Если результат сравнения верен, переход не выполняется, и управление передается инструкции обратного вызова ниже.</target>
        </trans-unit>
        <trans-unit id="7db0a106b3cc6051a669fd3768b87982a2f1bf0d" translate="yes" xml:space="preserve">
          <source>The only time this would ever be an issue is when you have a program using version 2.8.0 or later that crashes with an incomplete transaction, then you try to examine the database using version 2.7.6 or earlier. The 2.7.6 code will not be able to read the journal file and thus will not be able to rollback the incomplete transaction to restore the database.</source>
          <target state="translated">Единственный раз,когда это может стать проблемой,это когда у вас есть программа,использующая версию 2.8.0 или более позднюю,которая выходит из строя с неполной транзакцией,а затем вы пытаетесь изучить базу данных,используя версию 2.7.6 или более раннюю версию.Код версии 2.7.6 не сможет прочитать файл журнала и,следовательно,не сможет откатить незавершенную транзакцию для восстановления базы данных.</target>
        </trans-unit>
        <trans-unit id="3427e2677eb5693de36c8d23ded03f405a1417be" translate="yes" xml:space="preserve">
          <source>The only way that SQLite can know that the left-most columns of an index have many duplicate is if the &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; command has been run on the database. Without the results of ANALYZE, SQLite has to guess at the &quot;shape&quot; of the data in the table, and the default guess is that there are an average of 10 duplicates for every value in the left-most column of the index. But skip-scan only becomes profitable (it only gets to be faster than a full table scan) when the number of duplicates is about 18 or more. Hence, a skip-scan is never used on a database that has not been analyzed.</source>
          <target state="translated">SQLite может узнать, что у крайних левых столбцов индекса много дубликатов, только если в базе данных была запущена команда &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; . Без результатов ANALYZE SQLite должен угадать &amp;laquo;форму&amp;raquo; данных в таблице, и по умолчанию предполагается, что для каждого значения в крайнем левом столбце индекса существует в среднем 10 дубликатов. Но сканирование с пропуском становится прибыльным (оно может быть быстрее, чем полное сканирование таблицы), только когда количество дубликатов составляет около 18 или больше. Следовательно, сканирование с пропуском никогда не используется для базы данных, которая не была проанализирована.</target>
        </trans-unit>
        <trans-unit id="245c56bccd061276354c331751cdfed36f0c96cc" translate="yes" xml:space="preserve">
          <source>The only way that SQLite can know that there are many duplicates in the left-most columns of an index is if the &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; command has been run on the database. Without the results of ANALYZE, SQLite has to guess at the &quot;shape&quot; of the data in the table, and the default guess is that there are an average of 10 duplicates for every value in the left-most column of the index. Skip-scan only becomes profitable (it only gets to be faster than a full table scan) when the number of duplicates is about 18 or more. Hence, a skip-scan is never used on a database that has not been analyzed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4470bf44a4ab413995e0a4a3db8d3df4a465f540" translate="yes" xml:space="preserve">
          <source>The opening and/or creating of the database file is deferred until the file is actually needed. This allows options and parameters, such as the native text representation and default page size, to be set using PRAGMA statements.</source>
          <target state="translated">Открытие и/или создание файла базы данных откладывается до тех пор,пока файл не будет действительно необходим.Это позволяет задавать с помощью операторов PRAGMA такие опции и параметры,как родное текстовое представление и размер страницы по умолчанию.</target>
        </trans-unit>
        <trans-unit id="0fff8fde33861bc909ec1bcff7cb77c490217d5b" translate="yes" xml:space="preserve">
          <source>The operating system interface layer understands and tracks all five locking states described above. The pager module only tracks four of the five locking states. A PENDING lock is always just a temporary stepping stone on the path to an EXCLUSIVE lock and so the pager module does not track PENDING locks.</source>
          <target state="translated">Интерфейсный уровень операционной системы понимает и отслеживает все пять описанных выше состояний блокировки.Модуль пейджера отслеживает только четыре из пяти блокирующих состояний.Блокировка PENDING-это всегда лишь временная ступенька на пути к блокировке EXCLUSIVE,поэтому модуль пейджера не отслеживает блокировку PENDING.</target>
        </trans-unit>
        <trans-unit id="6f69f5f3efa82abf10e6a8b25aaa02ea47607f29" translate="yes" xml:space="preserve">
          <source>The operating system must have a unified buffer cache in order for the memory-mapped I/O extension to work correctly, especially in situations where two processes are accessing the same database file and one process is using memory-mapped I/O while the other is not. Not all operating systems have a unified buffer cache. In some operating systems that claim to have a unified buffer cache, the implementation is buggy and can lead to corrupt databases.</source>
          <target state="translated">Операционная система должна иметь унифицированный буферный кэш,чтобы расширение ввода/вывода,отображенное на карту памяти,корректно работало,особенно в ситуациях,когда два процесса обращаются к одному файлу базы данных,а один процесс использует отображенные на карту памяти вводы/выводы,а другой-нет.Не все операционные системы имеют единый буферный кэш.В некоторых операционных системах,которые утверждают,что имеют унифицированный буферный кэш,реализация является ошибочной и может привести к повреждению баз данных.</target>
        </trans-unit>
        <trans-unit id="2fef3a1777aac58cd8a21d6d8b1475aa38c4964a" translate="yes" xml:space="preserve">
          <source>The operations above can potentially cause vast changes the raw database file, and hence cause very different SHA1 hashes at the file level. But since the content represented in the database file is unchanged by these operations, the hash computed by dbhash is also unchanged.</source>
          <target state="translated">Операции,описанные выше,потенциально могут привести к огромным изменениям в файле исходной базы данных,и,следовательно,вызвать очень разные SHA1 хэши на файловом уровне.Но поскольку содержимое,представленное в файле базы данных,этими операциями не изменяется,хэш,вычисленный dbhash,также не изменяется.</target>
        </trans-unit>
        <trans-unit id="fa365bc2db1bf185a92f2d5ef6ff8250e55de644" translate="yes" xml:space="preserve">
          <source>The optimization that uses an index to quickly compute an aggregate min() or max() is extended to work with &lt;a href=&quot;expridx&quot;&gt;indexes on expressions&lt;/a&gt;.</source>
          <target state="translated">Оптимизация, которая использует индекс для быстрого вычисления агрегата min () или max (), расширена для работы с &lt;a href=&quot;expridx&quot;&gt;индексами для выражений&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c0ff09fb1c0cc730867c7410dca6d8522dc6581b" translate="yes" xml:space="preserve">
          <source>The optimizer automatically inverts terms of the form &quot;expr OP column&quot; and makes other simplifications to the WHERE clause in an attempt to get as many WHERE clause terms into the form shown above as possible. The aConstraint[] array only reports WHERE clause terms that are relevant to the particular virtual table being queried.</source>
          <target state="translated">Оптимизатор автоматически инвертирует термины формы &quot;expr OP column&quot; и вносит другие упрощения в выражение WHERE,пытаясь получить как можно больше терминов выражения WHERE в форме,показанной выше.Массив aConstraint[]сообщает только те условия выражения WHERE,которые имеют отношение к конкретной опрашиваемой виртуальной таблице.</target>
        </trans-unit>
        <trans-unit id="3a8fb11a2c37159ec0832c94b1217f4e3525fc9f" translate="yes" xml:space="preserve">
          <source>The optimizer has more freedom to reorder tables in the FROM clause even in there are LEFT joins.</source>
          <target state="translated">Оптимизатор имеет больше свободы для переупорядочивания таблиц в пункте FROM даже при наличии LEFT-соеденений.</target>
        </trans-unit>
        <trans-unit id="ed82314b13b2ea2beac78e23a61e927cbc2a784b" translate="yes" xml:space="preserve">
          <source>The optimizer will now scan tables in the reverse if doing so will satisfy an ORDER BY ... DESC clause.</source>
          <target state="translated">Оптимизатор теперь будет сканировать таблицы в обратном порядке,если это удовлетворяет ЗАКАЗЧИКУ BY ...пункт DESC.</target>
        </trans-unit>
        <trans-unit id="8d9594a87362ce1971b7a9efe4bfc116ba95e426" translate="yes" xml:space="preserve">
          <source>The option</source>
          <target state="translated">Опция</target>
        </trans-unit>
        <trans-unit id="a17a0a84a2d535101cac8aa7214d0ca78303a13a" translate="yes" xml:space="preserve">
          <source>The option causes SQLite to omit its built-in operating system interfaces for Unix, Windows, and OS/2. The resulting library will have no default &lt;a href=&quot;c3ref/vfs&quot;&gt;operating system interface&lt;/a&gt;. Applications must use &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register()&lt;/a&gt; to register an appropriate interface before using SQLite. Applications must also supply implementations for the &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_os_init()&lt;/a&gt; and &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_os_end()&lt;/a&gt; interfaces. The usual practice is for the supplied &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_os_init()&lt;/a&gt; to invoke &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register()&lt;/a&gt;. SQLite will automatically invoke &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_os_init()&lt;/a&gt; when it initializes.</source>
          <target state="translated">Эта опция заставляет SQLite опускать свои встроенные интерфейсы операционной системы для Unix, Windows и OS / 2. Полученная библиотека не будет иметь &lt;a href=&quot;c3ref/vfs&quot;&gt;интерфейса операционной системы по&lt;/a&gt; умолчанию . Приложения должны использовать &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register ()&lt;/a&gt; для регистрации соответствующего интерфейса перед использованием SQLite. Приложения также должны предоставлять реализации для интерфейсов &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_os_init ()&lt;/a&gt; и &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_os_end ()&lt;/a&gt; . Обычная практика заключается в том, что поставляемый &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_os_init ()&lt;/a&gt; вызывает &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register ()&lt;/a&gt; . SQLite автоматически вызовет &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_os_init ()&lt;/a&gt; при инициализации.</target>
        </trans-unit>
        <trans-unit id="18b9f1ce4c729b2ded7edcf5db48cd7ab36a842d" translate="yes" xml:space="preserve">
          <source>The optional</source>
          <target state="translated">Дополнительный</target>
        </trans-unit>
        <trans-unit id="e154860c714282a196150a8b230c6746d885f55b" translate="yes" xml:space="preserve">
          <source>The optional &quot;</source>
          <target state="translated">Опциональный &quot;</target>
        </trans-unit>
        <trans-unit id="44528aeaa99ba557a8ba7b80ef11d6c589ba4953" translate="yes" xml:space="preserve">
          <source>The optional &quot;AS alias&quot; phrase provides an alternative name for the table into which content is being inserted. The alias name can be used within WHERE and SET clauses of the &lt;a href=&quot;lang_upsert&quot;&gt;UPSERT&lt;/a&gt;. If there is no &lt;a href=&quot;syntax/upsert-clause&quot;&gt;upsert-clause&lt;/a&gt;, then the alias is pointless, but also harmless.</source>
          <target state="translated">Необязательная фраза &amp;laquo;Псевдоним AS&amp;raquo; обеспечивает альтернативное имя для таблицы, в которую вставляется контент. Псевдоним можно использовать в предложениях WHERE и SET в &lt;a href=&quot;lang_upsert&quot;&gt;UPSERT&lt;/a&gt; . Если нет &lt;a href=&quot;syntax/upsert-clause&quot;&gt;upsert-clause&lt;/a&gt; , тогда псевдоним бессмыслен, но также безвреден.</target>
        </trans-unit>
        <trans-unit id="af3a99778493ef21555e9c9fa86a7e91b06e70d3" translate="yes" xml:space="preserve">
          <source>The optional &quot;OR</source>
          <target state="translated">Опциональное &quot;ИЛИ</target>
        </trans-unit>
        <trans-unit id="20d5db3386f7bebafe75fa5cbd335d930edd4888" translate="yes" xml:space="preserve">
          <source>The optional EXCLUDE clause may take any of the following four forms:</source>
          <target state="translated">Необязательное условие EXCLUDE может принимать любую из следующих четырех форм:</target>
        </trans-unit>
        <trans-unit id="f5dad0eb12cbe81d01819ac36d3268610ba8edac" translate="yes" xml:space="preserve">
          <source>The optional IF EXISTS clause suppresses the error that would normally result if the table does not exist.</source>
          <target state="translated">Необязательное условие IF EXISTS подавляет ошибку,которая обычно возникает,если таблица не существует.</target>
        </trans-unit>
        <trans-unit id="5cb5d652a77ff38b54b62cd30fd9ed282bedd94d" translate="yes" xml:space="preserve">
          <source>The optional MASK argument is a bitmask of optimizations to perform:</source>
          <target state="translated">Необязательный аргумент MASK-это битовая маска выполняемых оптимизаций:</target>
        </trans-unit>
        <trans-unit id="6a52a350b8227e3f2c9ade5a4eb34242d4d7eced" translate="yes" xml:space="preserve">
          <source>The optional argument is the name of the schema or database to be serialized. The default value is &quot;main&quot;.</source>
          <target state="translated">Необязательным аргументом является имя схемы или базы данных для сериализации.Значение по умолчанию-&quot;главное&quot;.</target>
        </trans-unit>
        <trans-unit id="38da3cf28a52f4f6d620faa6e6cb2361f1cf4901" translate="yes" xml:space="preserve">
          <source>The optional expression that occurs in between the CASE keyword and the first WHEN keyword is called the &quot;base&quot; expression. There are two basic forms of the CASE expression: those with a base expression and those without.</source>
          <target state="translated">Необязательное выражение,которое возникает между ключевым словом CASE и первым WHEN,называется &quot;базовым&quot;.Существует две основные формы выражения CASE:с базовым выражением и без него.</target>
        </trans-unit>
        <trans-unit id="4916a24a4905c950af19989b67424175234963da" translate="yes" xml:space="preserve">
          <source>The optional expression that occurs in between the CASE keyword and the first WHEN keyword is called the &quot;base&quot; expression. There are two fundamental forms of the CASE expression: those with a base expression and those without.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b46109c9ae9c950c43fe7007d16547e58baf09ab" translate="yes" xml:space="preserve">
          <source>The optional shared cache and memory management features that were introduced in version 3.3.0 can now be used across multiple threads within the same process. Formerly, these extensions only applied to database connections operating within a single thread.</source>
          <target state="translated">Дополнительные функции управления общим кэшем и памятью,которые были введены в версии 3.3.0,теперь могут использоваться в нескольких потоках в рамках одного процесса.Раньше эти расширения применялись только к соединениям с базами данных,работающим в одном потоке.</target>
        </trans-unit>
        <trans-unit id="095e758e6c75bd1010500f9c5cbf1c0112ebeaf1" translate="yes" xml:space="preserve">
          <source>The order of evaluation of function arguments.</source>
          <target state="translated">Порядок оценки аргументов функции.</target>
        </trans-unit>
        <trans-unit id="671d3f63e428cbeb09358473179412be4940924b" translate="yes" xml:space="preserve">
          <source>The order of keys in an index b-tree is determined by the sort order of the records that the keys represent. Record comparison progresses column by column. Columns of a record are examined from left to right. The first pair of columns that are not equal determines the relative order of the two records. The sort order of individual columns is as follows:</source>
          <target state="translated">Порядок расположения ключей в b-дереве индекса определяется порядком расположения записей,которые представляют собой ключи.Сравнение записей происходит по столбцам.Столбцы записи рассматриваются слева направо.Первая пара столбцов,которые не равны,определяет относительный порядок обеих записей.Порядок сортировки отдельных столбцов следующий:</target>
        </trans-unit>
        <trans-unit id="2b489797ae43740676c30370f9b2ea776aa65877" translate="yes" xml:space="preserve">
          <source>The order of tables in a join is adjusted automatically to make better use of indices</source>
          <target state="translated">Порядок таблиц в соединении корректируется автоматически для лучшего использования индексов.</target>
        </trans-unit>
        <trans-unit id="140f29de259bdc1e34708f12946df0112e292cdd" translate="yes" xml:space="preserve">
          <source>The order of the buffer pointer and buffer size parameters in the built-in snprintf() implementation is reversed from the order used in standard-library implementations.</source>
          <target state="translated">Порядок указания указателя на буфер и параметров размера буфера во встроенной реализации snprintf()отличается от порядка,используемого в реализации стандартной библиотеки.</target>
        </trans-unit>
        <trans-unit id="5e9268cc64b3aabab9ece14a89f94084ddd4b3cc" translate="yes" xml:space="preserve">
          <source>The order of the columns in the data_% table does not matter.</source>
          <target state="translated">Порядок столбцов в таблице data_% не имеет значения.</target>
        </trans-unit>
        <trans-unit id="b1b615b19c9501777b15d4388be1e80320f4db76" translate="yes" xml:space="preserve">
          <source>The order of the entries indicates the nesting order. In this case, the scan of table t1 using index i2 is the outer loop (since it appears first) and the full-table scan of table t2 is the inner loop (since it appears last). In the following example, the positions of t1 and t2 in the FROM clause of the SELECT are reversed. The query strategy remains the same. The output from EXPLAIN QUERY PLAN shows how the query is actually evaluated, not how it is specified in the SQL statement.</source>
          <target state="translated">Порядок записей указывает на порядок вложенности.В этом случае сканирование таблицы t1 с использованием индекса i2 является внешним циклом (так как появляется первым),а сканирование полного стола таблицы t2-внутренним циклом (так как появляется последним).В следующем примере позиции t1 и t2 в пункте FROM SELECT перевернуты.Стратегия запроса остается прежней.Вывод EXPLAIN QUERY PLAN показывает,как запрос на самом деле обрабатывается,а не как он указан в SQL-запросе.</target>
        </trans-unit>
        <trans-unit id="70ac1e5ab36762649806ee198f0345318ef8e4bd" translate="yes" xml:space="preserve">
          <source>The orderByConsumed means that output from &lt;a href=&quot;../vtab#xfilter&quot;&gt;xFilter&lt;/a&gt;/&lt;a href=&quot;../vtab#xnext&quot;&gt;xNext&lt;/a&gt; will occur in the correct order to satisfy the ORDER BY clause so that no separate sorting step is required.</source>
          <target state="translated">OrderByConsumed означает, что вывод из &lt;a href=&quot;../vtab#xfilter&quot;&gt;xFilter&lt;/a&gt; / &lt;a href=&quot;../vtab#xnext&quot;&gt;xNext&lt;/a&gt; будет происходить в правильном порядке, чтобы удовлетворить предложение ORDER BY, так что отдельный этап сортировки не требуется.</target>
        </trans-unit>
        <trans-unit id="a4ee366293d58487c3c181ee97d4fddeec053e83" translate="yes" xml:space="preserve">
          <source>The orderByConsumed means that output from &lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter&lt;/a&gt;/&lt;a href=&quot;vtab#xnext&quot;&gt;xNext&lt;/a&gt; will occur in the correct order to satisfy the ORDER BY clause so that no separate sorting step is required.</source>
          <target state="translated">OrderByConsumed означает, что вывод из &lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter&lt;/a&gt; / &lt;a href=&quot;vtab#xnext&quot;&gt;xNext&lt;/a&gt; будет происходить в правильном порядке, чтобы удовлетворить предложение ORDER BY, так что отдельный этап сортировки не требуется.</target>
        </trans-unit>
        <trans-unit id="361a689885e1ba1224dc1550da95ae3bd8151f01" translate="yes" xml:space="preserve">
          <source>The original UTF8 text of the vocabulary word</source>
          <target state="translated">Оригинальный текст слова в кодировке UTF8.</target>
        </trans-unit>
        <trans-unit id="8f218b03066661856e3cf8a761cc5ae4bbd68ed0" translate="yes" xml:space="preserve">
          <source>The original document we put here was more of a &lt;a href=&quot;codeofethics&quot;&gt;Code of Ethics of the Project Founder&lt;/a&gt;. While we stand by those principles, they are not in line with the modern technical meaning of a Code of Conduct and have hence been renamed.</source>
          <target state="translated">Исходный документ, который мы разместили здесь, был скорее &lt;a href=&quot;codeofethics&quot;&gt;Кодексом этики основателя проекта&lt;/a&gt; . Хотя мы придерживаемся этих принципов, они не соответствуют современному техническому значению Кодекса поведения и поэтому были переименованы.</target>
        </trans-unit>
        <trans-unit id="c32bb1620d101b8c498092185971e74a9cc27eb4" translate="yes" xml:space="preserve">
          <source>The original implementation of SQLite sought to follow &lt;a href=&quot;https://en.wikipedia.org/wiki/Robustness_principle&quot;&gt;Postel's Law&lt;/a&gt; which states in part &quot;Be liberal in what you accept&quot;. This used to be considered good design - that a system would accept dodgy inputs and try to do the best it could without complaining too much. But lately, people have come to realize that it is sometimes better to be strict in what you accept, so as to more easily find errors in the input.</source>
          <target state="translated">Первоначальная реализация SQLite стремилась следовать &lt;a href=&quot;https://en.wikipedia.org/wiki/Robustness_principle&quot;&gt;закону Постела,&lt;/a&gt; который частично гласил: &amp;laquo;Будьте либеральны в том, что вы принимаете&amp;raquo;. Раньше это считалось хорошим дизайном - система будет принимать изворотливые входы и стараться делать все, что в ее силах, без особых жалоб. Но в последнее время люди пришли к выводу, что иногда лучше быть строгим в том, что вы принимаете, чтобы легче находить ошибки во вводимых данных.</target>
        </trans-unit>
        <trans-unit id="faed9cec852456e57ebf990afb4cf1cac2f27e57" translate="yes" xml:space="preserve">
          <source>The original values for each modified field of the row.</source>
          <target state="translated">Исходные значения для каждого измененного поля строки.</target>
        </trans-unit>
        <trans-unit id="2a41f1df0018eecb7b908d40c9986e3b87989e32" translate="yes" xml:space="preserve">
          <source>The original values of any modified fields are omitted from UPDATE records.</source>
          <target state="translated">Исходные значения любых измененных полей опускаются из записей UPDATE.</target>
        </trans-unit>
        <trans-unit id="f1449473437f390f79738378e7abd93ce9be7fe0" translate="yes" xml:space="preserve">
          <source>The other advantage to using SQLite in place of ZIP is that the document can now be updated incrementally, without risk of corrupting the document if a power loss or other crash occurs in the middle of the update. (Remember that writes to &lt;a href=&quot;atomiccommit&quot;&gt;SQLite databases are atomic&lt;/a&gt;.) True, all the content is still kept in a single big XML file (&quot;content.xml&quot;) which must be completely rewritten if so much as a single character changes. But with SQLite, only that one file needs to change. The other 77 files in the repository can remain unaltered. They do not all have to be rewritten, which in turn makes &quot;File/Save&quot; run much faster and saves wear on SSDs.</source>
          <target state="translated">Другое преимущество использования SQLite вместо ZIP заключается в том, что теперь документ можно обновлять постепенно, без риска его повреждения в случае потери питания или другого сбоя в середине обновления. (Помните, что запись в &lt;a href=&quot;atomiccommit&quot;&gt;базы данных SQLite является атомарной&lt;/a&gt; .) Верно, все содержимое по-прежнему хранится в одном большом XML-файле (&amp;laquo;content.xml&amp;raquo;), который необходимо полностью переписать, если изменяется хотя бы один символ. Но с SQLite нужно изменить только один файл. Остальные 77 файлов в репозитории можно оставить без изменений. Их не все нужно переписывать, что, в свою очередь, ускоряет работу &amp;laquo;Файл / Сохранить&amp;raquo; и снижает износ SSD.</target>
        </trans-unit>
        <trans-unit id="ff8ed48a831b734ff6e1604276150ac99b9ac0e1" translate="yes" xml:space="preserve">
          <source>The other allowed parameters to sqlite3_mutex_alloc() (anything other than SQLITE_MUTEX_FAST and SQLITE_MUTEX_RECURSIVE) each return a pointer to a static preexisting mutex. Nine static mutexes are used by the current version of SQLite. Future versions of SQLite may add additional static mutexes. Static mutexes are for internal use by SQLite only. Applications that use SQLite mutexes should use only the dynamic mutexes returned by SQLITE_MUTEX_FAST or SQLITE_MUTEX_RECURSIVE.</source>
          <target state="translated">Остальные разрешенные параметры sqlite3_mutex_alloc()(что угодно,только не SQLITE_MUTEX_FAST и SQLITE_MUTEX_RECURSIVE)возвращают указатель на статический ранее существовавший мьютекс.Девять статических мьютексов используются текущей версией SQLite.Будущие версии SQLite могут добавлять дополнительные статические мьютексы.Статические мьютексы предназначены только для внутреннего использования SQLite.Приложения,использующие мьютексы SQLite,должны использовать только динамические мьютексы,возвращаемые SQLITE_MUTEX_FAST или SQLITE_MUTEX_RECURSIVE.</target>
        </trans-unit>
        <trans-unit id="e68942fbbde7b9568017891360f3a9246030e2a2" translate="yes" xml:space="preserve">
          <source>The other file, &quot;fts5.h&quot;, is not required to compile the FTS5 extension. It is used by applications that implement &lt;a href=&quot;fts5#extending_fts5&quot;&gt;custom FTS5 tokenizers or auxiliary functions&lt;/a&gt;.</source>
          <target state="translated">Другой файл, &amp;laquo;fts5.h&amp;raquo;, не требуется для компиляции расширения FTS5. Он используется приложениями, реализующими &lt;a href=&quot;fts5#extending_fts5&quot;&gt;специальные токенизаторы FTS5 или вспомогательные функции&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f74c4fa3b3502ec3d363778205dc40519edfac8e" translate="yes" xml:space="preserve">
          <source>The other information required to create a changeset or patchset is read from the database file when &lt;a href=&quot;session/sqlite3session_changeset&quot;&gt;sqlite3session_changeset()&lt;/a&gt; or &lt;a href=&quot;session/sqlite3session_patchset&quot;&gt;sqlite3session_patchset()&lt;/a&gt; is called. Specifically,</source>
          <target state="translated">Другая информация, необходимая для создания &lt;a href=&quot;session/sqlite3session_changeset&quot;&gt;набора изменений&lt;/a&gt; или &lt;a href=&quot;session/sqlite3session_patchset&quot;&gt;набора исправлений,&lt;/a&gt; считывается из файла базы данных при вызове sqlite3session_changeset () или sqlite3session_patchset () . В частности,</target>
        </trans-unit>
        <trans-unit id="4ceb7a7a69cfd1205ea5e7612f272fc9e42d8423" translate="yes" xml:space="preserve">
          <source>The outer SELECT is implemented by instructions 11 through 25. In particular, the WHERE clause containing the IN operator is implemented by instructions at 16, 17, and 20. Instruction 16 pushes the value of the &quot;two&quot; column for the current row onto the stack and instruction 17 checks to see that it is non-NULL. If this is successful, execution jumps to 20, where it tests to see if top of the stack matches any key in the temporary table. The rest of the code is the same as what has been shown before.</source>
          <target state="translated">Внешний SELECT реализуется с помощью инструкций 11-25.В частности,пункт WHERE,содержащий оператора IN,реализуется инструкциями 16,17 и 20.Инструкция 16 выталкивает значение столбца &quot;два&quot; для текущей строки на стек,а инструкция 17 проверяет,не является ли оно НОЛЬКОЙ.При успешном выполнении выполняется скачок на 20,где проверяется,совпадает ли верхняя часть стека с каким-либо ключом во временной таблице.Остальной код совпадает с тем,что было показано ранее.</target>
        </trans-unit>
        <trans-unit id="636166e4ba0668356d630c0a9cb37eba4fcc8c00" translate="yes" xml:space="preserve">
          <source>The outer SELECT is implemented by instructions 14 through 25. In particular, the WHERE clause that contains the nested select is implemented by instructions 19 through 21. You can see that the result of the inner select is loaded onto the stack by instruction 20 and used by the conditional jump at 21.</source>
          <target state="translated">Внешний SELECT реализуется с помощью инструкций 14-25.В частности,пункт WHERE,содержащий вложенный отбор,реализуется инструкциями 19-21.Видно,что результат внутреннего селекции загружается в стек по команде 20 и используется условным скачком на 21.</target>
        </trans-unit>
        <trans-unit id="fcdaf6e60b18b913fe64114ea32692d007183ab8" translate="yes" xml:space="preserve">
          <source>The outer loop over table examp is implement by instructions 7 through 23. The inner loop is instructions 13 through 22. Notice that the &quot;two&amp;lt;50&quot; term of the WHERE expression involves only columns from the first table and can be factored out of the inner loop. SQLite does this and implements the &quot;two&amp;lt;50&quot; test in instructions 10 through 12. The &quot;four==two&quot; test is implement by instructions 14 through 16 in the inner loop.</source>
          <target state="translated">Пример внешнего цикла над таблицей реализуется инструкциями с 7 по 23. Внутренний цикл - это инструкции с 13 по 22. Обратите внимание, что термин &amp;laquo;два &amp;lt;50&amp;raquo; в выражении WHERE включает только столбцы из первой таблицы и может быть исключен из внутренний цикл. SQLite делает это и реализует тест &amp;laquo;два &amp;lt;50&amp;raquo; в инструкциях с 10 по 12. Тест &amp;laquo;четыре == два&amp;raquo; реализуется инструкциями с 14 по 16 во внутреннем цикле.</target>
        </trans-unit>
        <trans-unit id="0e7b99d6dfc2b5d85e34f55e3ea4da579b189034" translate="yes" xml:space="preserve">
          <source>The output begins with a report of the &lt;a href=&quot;c3ref/c_source_id&quot;&gt;SQLITE_SOURCE_ID&lt;/a&gt; (cross-checked again &lt;a href=&quot;c3ref/libversion&quot;&gt;sqlite3_sourceid()&lt;/a&gt;) for the SQLite under test and the compile-time options used as reported by &lt;a href=&quot;c3ref/compileoption_get&quot;&gt;sqlite3_compileoption_get()&lt;/a&gt;. The output concludes with a summary of the test results and a repeat of the &lt;a href=&quot;c3ref/c_source_id&quot;&gt;SQLITE_SOURCE_ID&lt;/a&gt;. If any errors are detected, additional lines detail the problem. The error reporting lines always begin with a single space character so that they can be quickly extracted from large output files using:</source>
          <target state="translated">Вывод начинается с отчета &lt;a href=&quot;c3ref/c_source_id&quot;&gt;SQLITE_SOURCE_ID&lt;/a&gt; (перепроверенный снова &lt;a href=&quot;c3ref/libversion&quot;&gt;sqlite3_sourceid ()&lt;/a&gt; ) для тестируемого SQLite и используемых параметров времени компиляции, как сообщает &lt;a href=&quot;c3ref/compileoption_get&quot;&gt;sqlite3_compileoption_get ()&lt;/a&gt; . Вывод завершается сводкой результатов теста и повторением &lt;a href=&quot;c3ref/c_source_id&quot;&gt;SQLITE_SOURCE_ID&lt;/a&gt; . Если обнаружены какие-либо ошибки, дополнительные строки подробно описывают проблему. Строки сообщения об ошибках всегда начинаются с одного символа пробела, чтобы их можно было быстро извлечь из больших выходных файлов, используя:</target>
        </trans-unit>
        <trans-unit id="b2295d00e027ddb605dbb2cc9b7646825272b788" translate="yes" xml:space="preserve">
          <source>The output from EXPLAIN and EXPLAIN QUERY PLAN is intended for interactive analysis and troubleshooting only. The details of the output format are subject to change from one release of SQLite to the next. Applications should not use EXPLAIN or EXPLAIN QUERY PLAN since their exact behavior is variable and only partially documented.</source>
          <target state="translated">Выходные данные EXPLAIN и EXPLAIN QUERY PLAN предназначены только для интерактивного анализа и поиска и устранения неисправностей.Детали выходного формата могут изменяться от одного релиза SQLite к другому.Приложения не должны использовать EXPLAIN или EXPLAIN QUERY PLAN,так как их точное поведение является переменным и только частично документировано.</target>
        </trans-unit>
        <trans-unit id="235163a8fba9aa1445cd051f01c741ea66911c96" translate="yes" xml:space="preserve">
          <source>The output from the &lt;a href=&quot;https://sqlite.org/src/file/tool/cg_anno.tcl&quot;&gt;cg_anno.tcl&lt;/a&gt; script shows the number of CPU cycles spent on each line of code. The report is approximately 80,000 lines long. The following is a brief snippet taken from the middle of the report to show what it looks like:</source>
          <target state="translated">Выходные &lt;a href=&quot;https://sqlite.org/src/file/tool/cg_anno.tcl&quot;&gt;данные&lt;/a&gt; сценария cg_anno.tcl показывают количество циклов ЦП, потраченных на каждую строку кода. Отчет занимает около 80 000 строк. Ниже приводится краткий фрагмент, взятый из середины отчета, чтобы показать, как он выглядит:</target>
        </trans-unit>
        <trans-unit id="4c55fd24704ccac9a200bb25fe01e36a7bd6347b" translate="yes" xml:space="preserve">
          <source>The output from the mkth3.tcl script is a C program that contains everything needed to run the tests - everything that is except for the SQLite library itself. The generated test program contains implementations for all of the support interfaces used by the test modules and it contains the &lt;code&gt;main()&lt;/code&gt; routine that drives the tests. To convert the test program into a working executable, simply compile it against SQLite:</source>
          <target state="translated">Результатом выполнения сценария mkth3.tcl является программа на языке C, содержащая все необходимое для запуска тестов - все, кроме самой библиотеки SQLite. Сгенерированная тестовая программа содержит реализации для всех интерфейсов поддержки, используемых тестовыми модулями, и содержит процедуру &lt;code&gt;main()&lt;/code&gt; запускает тесты. Чтобы преобразовать тестовую программу в рабочий исполняемый файл, просто скомпилируйте ее с SQLite:</target>
        </trans-unit>
        <trans-unit id="abe6a29295e5add598505fe98eb212b9e3e6e910" translate="yes" xml:space="preserve">
          <source>The output is a human-readable ASCII text report that provides information on the space utilization of the database file. The report is intended to be self-explanatory, though there is some &lt;a href=&quot;sqlanalyze#defs&quot;&gt;additional explanation&lt;/a&gt; of the various parameters reported toward the end of the report.</source>
          <target state="translated">Результатом является удобочитаемый текстовый отчет ASCII, который предоставляет информацию об использовании пространства файлом базы данных. Отчет не требует пояснений, хотя есть некоторые &lt;a href=&quot;sqlanalyze#defs&quot;&gt;дополнительные объяснения&lt;/a&gt; различных параметров, представленных в конце отчета.</target>
        </trans-unit>
        <trans-unit id="89607a5138078e5c86fca97ee25682b106679c11" translate="yes" xml:space="preserve">
          <source>The output is also valid SQL. Most of the report text is contained within a header comment, with various SQL statements that create and initialize a database at the &lt;a href=&quot;sqlanalyze#sqlx&quot;&gt;end of the report&lt;/a&gt;. The constructed database contains the raw data from which the report was extracted. Hence the original report can be read into an instance of the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; and then the raw data can be queried to dig deeper into the space utilization of a particular database file.</source>
          <target state="translated">Вывод также является допустимым SQL. Большая часть текста отчета содержится в комментарии заголовка с различными операторами SQL, которые создают и инициализируют базу данных в &lt;a href=&quot;sqlanalyze#sqlx&quot;&gt;конце отчета&lt;/a&gt; . Созданная база данных содержит необработанные данные, из которых был извлечен отчет. Следовательно, исходный отчет может быть прочитан в экземпляре &lt;a href=&quot;cli&quot;&gt;оболочки командной строки,&lt;/a&gt; а затем необработанные данные могут быть запрошены, чтобы глубже изучить использование пространства конкретным файлом базы данных.</target>
        </trans-unit>
        <trans-unit id="bcfd95781cb98e2851bb0886cd3f1a588c682428" translate="yes" xml:space="preserve">
          <source>The output of &lt;a href=&quot;c3ref/trace_v2&quot;&gt;sqlite3_trace_v2()&lt;/a&gt; now shows each individual SQL statement run within a trigger.</source>
          <target state="translated">В выводе &lt;a href=&quot;c3ref/trace_v2&quot;&gt;sqlite3_trace_v2 ()&lt;/a&gt; теперь отображается каждый отдельный оператор SQL, выполняемый в триггере.</target>
        </trans-unit>
        <trans-unit id="2d09f331aa1d428bbd3337e80bd418ed5659e816" translate="yes" xml:space="preserve">
          <source>The output of this revised query is:</source>
          <target state="translated">Вывод этого пересмотренного запроса:</target>
        </trans-unit>
        <trans-unit id="e3541aa5b140ee88f1e6bb5e89e08e8618d880af" translate="yes" xml:space="preserve">
          <source>The outputs s0 and s1 are both weighted checksums using Fibonacci weights in reverse order. (The largest Fibonacci weight occurs on the first element of the sequence being summed.) The s1 value spans all 32-bit integer terms of the sequence whereas s0 omits the final term.</source>
          <target state="translated">Выходы s0 и s1 являются контрольными суммами с использованием весов Фибоначчи в обратном порядке.(Наибольший вес Фибоначчи приходится на первый элемент суммируемой последовательности).Значение s1 охватывает все 32-битные целые члены последовательности,в то время как s0 опускает последний член.</target>
        </trans-unit>
        <trans-unit id="2d1abc65d901f9a5d25ea3d57ab5dd49e8f85287" translate="yes" xml:space="preserve">
          <source>The overflow thresholds are designed to give a minimum fanout of 4 for index b-trees and to make sure enough of the payload is on the b-tree page that the record header can usually be accessed without consulting an overflow page. In hindsight, the designer of the SQLite b-tree logic realized that these thresholds could have been made much simpler. However, the computations cannot be changed without resulting in an incompatible file format. And the current computations work well, even if they are a little complex.</source>
          <target state="translated">Пороговые значения переполнения рассчитаны таким образом,что для индексных b-деревьев минимальный разгон составляет 4,а полезная нагрузка находится на странице b-деревьев,к заголовку записи обычно можно получить доступ,не обращаясь к странице переполнения.Оглядываясь назад,конструктор логики b-дерева SQLite понял,что эти пороги можно было бы сделать гораздо проще.Однако изменить вычисления невозможно,не получив в результате несовместимого формата файла.И текущие вычисления хорошо работают,даже если они немного сложны.</target>
        </trans-unit>
        <trans-unit id="ac70d959175f460608260178c8989bd26b78e65e" translate="yes" xml:space="preserve">
          <source>The pAppData pointer is unused by the SQLite core. The pointer is available to store auxiliary information that a VFS information might want to carry around.</source>
          <target state="translated">Указатель pAppData не используется ядром SQLite.Указатель доступен для хранения вспомогательной информации,которую может захотеть нести информация VFS.</target>
        </trans-unit>
        <trans-unit id="18730b00ae23b4c106f1118f96d5a509058fa368" translate="yes" xml:space="preserve">
          <source>The pBuf parameter is a pointer to a contiguous range of bytes that SQLite will use for page-cache memory allocations. The buffer must be at least sz*N bytes in size. The &quot;sz&quot; parameter is the size of each page-cache allocation. N is the maximum number of available allocations.</source>
          <target state="translated">Параметр pBuf-это указатель на смежный диапазон байт,который SQLite будет использовать для выделения памяти для кэширования страниц.Буфер должен иметь размер не менее sz*N байт.Параметр &quot;sz&quot;-размер каждого распределения страничного кэша.N-максимальное количество доступных распределений.</target>
        </trans-unit>
        <trans-unit id="ac154834d9f47915a3416a80860f0b58cefd5585" translate="yes" xml:space="preserve">
          <source>The pContext member of the sqlite3_rtree_geometry structure is always set to a copy of the pContext argument passed to sqlite3_rtree_geometry_callback() when the callback is registered. The aParam[] array (size nParam) contains the parameter values passed to the SQL function on the right-hand side of the MATCH operator. In the example &quot;circle&quot; query above, nParam would be set to 3 and the aParam[] array would contain the three values 45.3, 22.9 and 5.0.</source>
          <target state="translated">Член pContext структуры sqlite3_rtree_geometry всегда устанавливается в качестве копии аргумента pContext,переданного sqlite3_rtree_geometry_callback()при регистрации обратного вызова.Массив aParam[](размер nParam)содержит значения параметров,передаваемых в SQL-функцию справа от MATCH-оператора.В приведенном выше примере запроса &quot;круг&quot; nParam был бы равен 3,а массив aParam[]содержал бы три значения 45.3,22.9 и 5.0.</target>
        </trans-unit>
        <trans-unit id="e127dc3dcbbc20bee3b0cdc450a4bea7c1e6776f" translate="yes" xml:space="preserve">
          <source>The pIter argument passed to this function may either be an iterator passed to a conflict-handler by &lt;a href=&quot;#sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply()&lt;/a&gt;, or an iterator created by &lt;a href=&quot;#sqlite3changeset_start&quot;&gt;sqlite3changeset_start()&lt;/a&gt;. In the latter case, the most recent call to &lt;a href=&quot;#sqlite3changeset_next&quot;&gt;sqlite3changeset_next()&lt;/a&gt; must have returned &lt;a href=&quot;rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt;. If this is not the case, this function returns &lt;a href=&quot;rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt;.</source>
          <target state="translated">Аргумент pIter, переданный этой функции, может быть либо итератором, переданным обработчику конфликтов &lt;a href=&quot;#sqlite3changeset_apply&quot;&gt;функцией sqlite3changeset_apply ()&lt;/a&gt; , либо итератором, созданным &lt;a href=&quot;#sqlite3changeset_start&quot;&gt;функцией sqlite3changeset_start ()&lt;/a&gt; . В последнем случае последний вызов &lt;a href=&quot;#sqlite3changeset_next&quot;&gt;sqlite3changeset_next ()&lt;/a&gt; должен был вернуть &lt;a href=&quot;rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt; . Если это не так, эта функция возвращает &lt;a href=&quot;rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="135aebf5a9dd2b851dadacfebf43a14b9409aa81" translate="yes" xml:space="preserve">
          <source>The pIter argument passed to this function may either be an iterator passed to a conflict-handler by &lt;a href=&quot;#sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply()&lt;/a&gt;, or an iterator created by &lt;a href=&quot;#sqlite3changeset_start&quot;&gt;sqlite3changeset_start()&lt;/a&gt;. In the latter case, the most recent call to &lt;a href=&quot;#sqlite3changeset_next&quot;&gt;sqlite3changeset_next()&lt;/a&gt; must have returned SQLITE_ROW. Furthermore, it may only be called if the type of change that the iterator currently points to is either &lt;a href=&quot;c3ref/c_alter_table&quot;&gt;SQLITE_DELETE&lt;/a&gt; or &lt;a href=&quot;c3ref/c_alter_table&quot;&gt;SQLITE_UPDATE&lt;/a&gt;. Otherwise, this function returns &lt;a href=&quot;rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt; and sets *ppValue to NULL.</source>
          <target state="translated">Аргумент pIter, переданный этой функции, может быть либо итератором, переданным обработчику конфликтов &lt;a href=&quot;#sqlite3changeset_apply&quot;&gt;функцией sqlite3changeset_apply ()&lt;/a&gt; , либо итератором, созданным &lt;a href=&quot;#sqlite3changeset_start&quot;&gt;функцией sqlite3changeset_start ()&lt;/a&gt; . В последнем случае последний вызов &lt;a href=&quot;#sqlite3changeset_next&quot;&gt;sqlite3changeset_next ()&lt;/a&gt; должен был вернуть SQLITE_ROW. Более того, он может быть вызван только в том случае, если тип изменения, на который в настоящее время указывает итератор, - это &lt;a href=&quot;c3ref/c_alter_table&quot;&gt;SQLITE_DELETE&lt;/a&gt; или &lt;a href=&quot;c3ref/c_alter_table&quot;&gt;SQLITE_UPDATE&lt;/a&gt; . В противном случае эта функция возвращает &lt;a href=&quot;rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt; и устанавливает * ppValue в NULL.</target>
        </trans-unit>
        <trans-unit id="47ae6763d58288a12e6ca470cf923677f0731f46" translate="yes" xml:space="preserve">
          <source>The pIter argument passed to this function may either be an iterator passed to a conflict-handler by &lt;a href=&quot;#sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply()&lt;/a&gt;, or an iterator created by &lt;a href=&quot;#sqlite3changeset_start&quot;&gt;sqlite3changeset_start()&lt;/a&gt;. In the latter case, the most recent call to &lt;a href=&quot;#sqlite3changeset_next&quot;&gt;sqlite3changeset_next()&lt;/a&gt; must have returned SQLITE_ROW. Furthermore, it may only be called if the type of change that the iterator currently points to is either &lt;a href=&quot;c3ref/c_alter_table&quot;&gt;SQLITE_UPDATE&lt;/a&gt; or &lt;a href=&quot;c3ref/c_alter_table&quot;&gt;SQLITE_INSERT&lt;/a&gt;. Otherwise, this function returns &lt;a href=&quot;rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt; and sets *ppValue to NULL.</source>
          <target state="translated">Аргумент pIter, переданный этой функции, может быть либо итератором, переданным обработчику конфликтов &lt;a href=&quot;#sqlite3changeset_apply&quot;&gt;функцией sqlite3changeset_apply ()&lt;/a&gt; , либо итератором, созданным &lt;a href=&quot;#sqlite3changeset_start&quot;&gt;функцией sqlite3changeset_start ()&lt;/a&gt; . В последнем случае последний вызов &lt;a href=&quot;#sqlite3changeset_next&quot;&gt;sqlite3changeset_next ()&lt;/a&gt; должен был вернуть SQLITE_ROW. Более того, он может быть вызван только в том случае, если тип изменения, на который в настоящее время указывает итератор, - это либо &lt;a href=&quot;c3ref/c_alter_table&quot;&gt;SQLITE_UPDATE,&lt;/a&gt; либо &lt;a href=&quot;c3ref/c_alter_table&quot;&gt;SQLITE_INSERT&lt;/a&gt; . В противном случае эта функция возвращает &lt;a href=&quot;rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt; и устанавливает * ppValue в NULL.</target>
        </trans-unit>
        <trans-unit id="5f4815a3e637ae9700d2b5b8cf01f7df97a164dc" translate="yes" xml:space="preserve">
          <source>The pIter argument passed to this function may either be an iterator passed to a conflict-handler by &lt;a href=&quot;sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply()&lt;/a&gt;, or an iterator created by &lt;a href=&quot;sqlite3changeset_start&quot;&gt;sqlite3changeset_start()&lt;/a&gt;. In the latter case, the most recent call to &lt;a href=&quot;sqlite3changeset_next&quot;&gt;sqlite3changeset_next()&lt;/a&gt; must have returned &lt;a href=&quot;../rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt;. If this is not the case, this function returns &lt;a href=&quot;../rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt;.</source>
          <target state="translated">Аргумент pIter, переданный этой функции, может быть либо итератором, переданным обработчику конфликтов &lt;a href=&quot;sqlite3changeset_apply&quot;&gt;функцией sqlite3changeset_apply ()&lt;/a&gt; , либо итератором, созданным &lt;a href=&quot;sqlite3changeset_start&quot;&gt;функцией sqlite3changeset_start ()&lt;/a&gt; . В последнем случае последний вызов &lt;a href=&quot;sqlite3changeset_next&quot;&gt;sqlite3changeset_next ()&lt;/a&gt; должен был вернуть &lt;a href=&quot;../rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt; . Если это не так, эта функция возвращает &lt;a href=&quot;../rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5cb49779aa9657ac4af96a2c62fd60bce7011cad" translate="yes" xml:space="preserve">
          <source>The pIter argument passed to this function may either be an iterator passed to a conflict-handler by &lt;a href=&quot;sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply()&lt;/a&gt;, or an iterator created by &lt;a href=&quot;sqlite3changeset_start&quot;&gt;sqlite3changeset_start()&lt;/a&gt;. In the latter case, the most recent call to &lt;a href=&quot;sqlite3changeset_next&quot;&gt;sqlite3changeset_next()&lt;/a&gt; must have returned SQLITE_ROW. Furthermore, it may only be called if the type of change that the iterator currently points to is either &lt;a href=&quot;../c3ref/c_alter_table&quot;&gt;SQLITE_DELETE&lt;/a&gt; or &lt;a href=&quot;../c3ref/c_alter_table&quot;&gt;SQLITE_UPDATE&lt;/a&gt;. Otherwise, this function returns &lt;a href=&quot;../rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt; and sets *ppValue to NULL.</source>
          <target state="translated">Аргумент pIter, переданный этой функции, может быть либо итератором, переданным обработчику конфликтов &lt;a href=&quot;sqlite3changeset_apply&quot;&gt;функцией sqlite3changeset_apply ()&lt;/a&gt; , либо итератором, созданным &lt;a href=&quot;sqlite3changeset_start&quot;&gt;функцией sqlite3changeset_start ()&lt;/a&gt; . В последнем случае последний вызов &lt;a href=&quot;sqlite3changeset_next&quot;&gt;sqlite3changeset_next ()&lt;/a&gt; должен был вернуть SQLITE_ROW. Более того, он может быть вызван только в том случае, если тип изменения, на который в настоящее время указывает итератор, - это &lt;a href=&quot;../c3ref/c_alter_table&quot;&gt;SQLITE_DELETE&lt;/a&gt; или &lt;a href=&quot;../c3ref/c_alter_table&quot;&gt;SQLITE_UPDATE&lt;/a&gt; . В противном случае эта функция возвращает &lt;a href=&quot;../rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt; и устанавливает * ppValue в NULL.</target>
        </trans-unit>
        <trans-unit id="836812d109e0eaaadd1e45a40c1311bde5cb7d98" translate="yes" xml:space="preserve">
          <source>The pIter argument passed to this function may either be an iterator passed to a conflict-handler by &lt;a href=&quot;sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply()&lt;/a&gt;, or an iterator created by &lt;a href=&quot;sqlite3changeset_start&quot;&gt;sqlite3changeset_start()&lt;/a&gt;. In the latter case, the most recent call to &lt;a href=&quot;sqlite3changeset_next&quot;&gt;sqlite3changeset_next()&lt;/a&gt; must have returned SQLITE_ROW. Furthermore, it may only be called if the type of change that the iterator currently points to is either &lt;a href=&quot;../c3ref/c_alter_table&quot;&gt;SQLITE_UPDATE&lt;/a&gt; or &lt;a href=&quot;../c3ref/c_alter_table&quot;&gt;SQLITE_INSERT&lt;/a&gt;. Otherwise, this function returns &lt;a href=&quot;../rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt; and sets *ppValue to NULL.</source>
          <target state="translated">Аргумент pIter, переданный этой функции, может быть либо итератором, переданным обработчику конфликтов &lt;a href=&quot;sqlite3changeset_apply&quot;&gt;функцией sqlite3changeset_apply ()&lt;/a&gt; , либо итератором, созданным &lt;a href=&quot;sqlite3changeset_start&quot;&gt;функцией sqlite3changeset_start ()&lt;/a&gt; . В последнем случае последний вызов &lt;a href=&quot;sqlite3changeset_next&quot;&gt;sqlite3changeset_next ()&lt;/a&gt; должен был вернуть SQLITE_ROW. Более того, он может быть вызван только в том случае, если тип изменения, на который в настоящее время указывает итератор, - это либо &lt;a href=&quot;../c3ref/c_alter_table&quot;&gt;SQLITE_UPDATE,&lt;/a&gt; либо &lt;a href=&quot;../c3ref/c_alter_table&quot;&gt;SQLITE_INSERT&lt;/a&gt; . В противном случае эта функция возвращает &lt;a href=&quot;../rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt; и устанавливает * ppValue в NULL.</target>
        </trans-unit>
        <trans-unit id="87ffccb080e4ff9265c31827b97ddd2621e463bc" translate="yes" xml:space="preserve">
          <source>The pNext field is the only field in the sqlite3_vfs structure that SQLite will ever modify. SQLite will only access or modify this field while holding a particular static mutex. The application should never modify anything within the sqlite3_vfs object once the object has been registered.</source>
          <target state="translated">Поле pNext-единственное поле в структуре sqlite3_vfs,которое SQLite когда-либо изменит.SQLite будет получать доступ к этому полю или модифицировать его,удерживая определенный статический мьютекс.Приложение никогда не должно ничего изменять внутри объекта sqlite3_vfs после регистрации объекта.</target>
        </trans-unit>
        <trans-unit id="754388a17b97b997745df633f79a8efeaffaaacb" translate="yes" xml:space="preserve">
          <source>The pNext field is used internally by SQLite. Specifically, SQLite uses this field to form a linked list of registered VFSes.</source>
          <target state="translated">Поле pNext используется внутри SQLite.В частности,SQLite использует это поле для формирования связанного списка зарегистрированных VFS.</target>
        </trans-unit>
        <trans-unit id="ed269faa072ea0bc301321c2683b96864943c28b" translate="yes" xml:space="preserve">
          <source>The pUser and xDelUser members of the sqlite3_rtree_geometry structure are initially set to NULL. The pUser variable may be set by the callback implementation to any arbitrary value that may be useful to subsequent invocations of the callback within the same query (for example, a pointer to a complicated data structure used to test for region intersection). If the xDelUser variable is set to a non-NULL value, then after the query has finished running SQLite automatically invokes it with the value of the pUser variable as the only argument. In other words, xDelUser may be set to a destructor function for the pUser value.</source>
          <target state="translated">Члены структуры sqlite3_rtree_geometry pUser и xDelUser изначально установлены в NULL.Переменная pUser может быть установлена с помощью реализации обратного вызова на любое произвольное значение,которое может быть полезно при последующих вызовах обратного вызова в рамках одного и того же запроса (например,указатель на сложную структуру данных,используемую для проверки на пересечение области).Если переменная xDelUser установлена в значение,отличное от NULL,то после завершения запроса SQLite автоматически вызывает ее со значением переменной pUser в качестве единственного аргумента.Другими словами,xDelUser может быть установлен в функцию деструктора для значения пунсера.</target>
        </trans-unit>
        <trans-unit id="17b3e72d28371d5d2ffa9ec67e0ffe035454e59f" translate="yes" xml:space="preserve">
          <source>The page cache allocates from its own memory pool supplied by &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt;,...) rather than from the heap.</source>
          <target state="translated">Кэш страниц выделяется из собственного пула памяти, предоставленного &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config&lt;/a&gt; ( &lt;a href=&quot;#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt; , ...), а не из кучи.</target>
        </trans-unit>
        <trans-unit id="c49923490f20015de5b3c1344ee709093d18e9ac" translate="yes" xml:space="preserve">
          <source>The page cache allocates from its own memory pool supplied by &lt;a href=&quot;config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c_config_covering_index_scan#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt;,...) rather than from the heap.</source>
          <target state="translated">Кэш страниц выделяется из собственного пула памяти, предоставленного &lt;a href=&quot;config&quot;&gt;sqlite3_config&lt;/a&gt; ( &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt; , ...), а не из кучи.</target>
        </trans-unit>
        <trans-unit id="a302370f325aa6580998e916c1cd813d2e0b53c6" translate="yes" xml:space="preserve">
          <source>The page number in the database file</source>
          <target state="translated">Номер страницы в файле базы данных</target>
        </trans-unit>
        <trans-unit id="cb3defd1f8ac1da0588e9ad79d27848df6931c39" translate="yes" xml:space="preserve">
          <source>The page number of the database page associated with this</source>
          <target state="translated">Номер страницы базы данных,связанный с этим</target>
        </trans-unit>
        <trans-unit id="0780190de9ffbf4345610e2662e0abd5cdf52be0" translate="yes" xml:space="preserve">
          <source>The page number of the database page for the current row</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d2ed89da4b6a6d4a6521b481ff6c43d5bdf9213" translate="yes" xml:space="preserve">
          <source>The page number of the largest root b-tree page when in auto-vacuum or incremental-vacuum modes, or zero otherwise.</source>
          <target state="translated">Номер страницы самого большого корневого b-дерева страницы в режиме автоматического вакуума или инкрементального вакуума,или ноль в противном случае.</target>
        </trans-unit>
        <trans-unit id="9a28509eee63401403c2ae3763725cac2ca99893" translate="yes" xml:space="preserve">
          <source>The page number of the page on which this row was found.</source>
          <target state="translated">Номер страницы,на которой была найдена эта строка.</target>
        </trans-unit>
        <trans-unit id="41b015c66ddae0dbc3440c640484bd01738dbaf6" translate="yes" xml:space="preserve">
          <source>The page size and cache size can also be set or changed at run-time using the &lt;a href=&quot;pragma#pragma_page_size&quot;&gt;page_size pragma&lt;/a&gt; and &lt;a href=&quot;pragma#pragma_cache_size&quot;&gt;cache_size pragma&lt;/a&gt;, respectively.</source>
          <target state="translated">Размер страницы и размер кеша также можно установить или изменить во время выполнения с помощью &lt;a href=&quot;pragma#pragma_page_size&quot;&gt;прагмы page_size&lt;/a&gt; и &lt;a href=&quot;pragma#pragma_cache_size&quot;&gt;прагмы cache_size&lt;/a&gt; соответственно.</target>
        </trans-unit>
        <trans-unit id="0105846f7fbf6f81d53292a1128d1e82d5804983" translate="yes" xml:space="preserve">
          <source>The page to be fetched is determined by the key. The minimum key value is 1. After it has been retrieved using xFetch, the page is considered to be &quot;pinned&quot;.</source>
          <target state="translated">Страница,которую нужно забрать,определяется клавишей.Минимальное значение ключа равно 1.После того,как она была получена с помощью xFetch,страница считается &quot;pinned&quot;.</target>
        </trans-unit>
        <trans-unit id="ae6ce89a0e7b046f1218400c05d873074d2788d0" translate="yes" xml:space="preserve">
          <source>The page-cache memory allocator is disabled by default. An application can enable it at start-time as follows:</source>
          <target state="translated">По умолчанию аллокатор страничной кэш-памяти отключен.Приложение может включить его при запуске следующим образом:</target>
        </trans-unit>
        <trans-unit id="79944cfbe90583fe884c628acc92c56b549b69ab" translate="yes" xml:space="preserve">
          <source>The pager and btree subsystems added back. They are now the only available backend.</source>
          <target state="translated">Подсистемы пейджера и btree добавлены обратно.Теперь они являются единственным доступным бэкэндом.</target>
        </trans-unit>
        <trans-unit id="177ac3877a5c726efa0192a81b9a621bfc8aa28e" translate="yes" xml:space="preserve">
          <source>The pager is unconcerned with the details of B-Trees, text encodings, indices, and so forth. From the point of view of the pager the database consists of a single file of uniform-sized blocks. Each block is called a &quot;page&quot; and is usually 1024 bytes in size. The pages are numbered beginning with 1. So the first 1024 bytes of the database are called &quot;page 1&quot; and the second 1024 bytes are call &quot;page 2&quot; and so forth. All other encoding details are handled by higher layers of the library. The pager communicates with the operating system using one of several modules (Examples: &lt;a href=&quot;http://www.sqlite.org/src/finfo?name=src/os_unix.c&quot;&gt; os_unix.c&lt;/a&gt;, &lt;a href=&quot;http://www.sqlite.org/src/finfo?name=src/os_win.c&quot;&gt; os_win.c&lt;/a&gt;) that provides a uniform abstraction for operating system services.</source>
          <target state="translated">Пейджер не заботится о деталях B-деревьев, кодировках текста, индексах и так далее. С точки зрения пейджера база данных состоит из одного файла блоков одинакового размера. Каждый блок называется &amp;laquo;страницей&amp;raquo; и обычно имеет размер 1024 байта. Страницы нумеруются, начиная с 1. Таким образом, первые 1024 байта базы данных называются &amp;laquo;страницей 1&amp;raquo;, а вторые 1024 байта - &amp;laquo;страницей 2&amp;raquo; и так далее. Все остальные детали кодирования обрабатываются более высокими уровнями библиотеки. Пейджер взаимодействует с операционной системой с помощью одного из нескольких модулей (примеры: &lt;a href=&quot;http://www.sqlite.org/src/finfo?name=src/os_unix.c&quot;&gt;os_unix.c&lt;/a&gt; , &lt;a href=&quot;http://www.sqlite.org/src/finfo?name=src/os_win.c&quot;&gt;os_win.c&lt;/a&gt; ), который обеспечивает единообразную абстракцию для служб операционной системы.</target>
        </trans-unit>
        <trans-unit id="82bc2a399f48d653b62ff2df3d5391e1390404ef" translate="yes" xml:space="preserve">
          <source>The pager is unconcerned with the details of B-Trees, text encodings, indices, and so forth. From the point of view of the pager the database consists of a single file of uniform-sized blocks. Each block is called a &quot;page&quot; and is usually 1024 bytes in size. The pages are numbered beginning with 1. So the first 1024 bytes of the database are called &quot;page 1&quot; and the second 1024 bytes are call &quot;page 2&quot; and so forth. All other encoding details are handled by higher layers of the library. The pager communicates with the operating system using one of several modules (Examples: &lt;a href=&quot;https://www.sqlite.org/src/finfo?name=src/os_unix.c&quot;&gt; os_unix.c&lt;/a&gt;, &lt;a href=&quot;https://www.sqlite.org/src/finfo?name=src/os_win.c&quot;&gt; os_win.c&lt;/a&gt;) that provides a uniform abstraction for operating system services.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5acaa405b470e4fb9ef36344daf0f015a3d5bf69" translate="yes" xml:space="preserve">
          <source>The pager module effectively controls access for separate threads, or separate processes, or both. Throughout this document whenever the word &quot;process&quot; is written you may substitute the word &quot;thread&quot; without changing the truth of the statement.</source>
          <target state="translated">Модуль пейджера эффективно управляет доступом к отдельным потокам,или отдельным процессам,или и тем,и другим.В этом документе при написании слова &quot;процесс&quot; вы можете заменить слово &quot;поток&quot;,не изменяя правдивости утверждения.</target>
        </trans-unit>
        <trans-unit id="3fbaa9934c130eb17f7eada7403c9132c86bbc58" translate="yes" xml:space="preserve">
          <source>The pager module is very robust but it can be subverted. This section attempts to identify and explain the risks. (See also the &lt;a href=&quot;atomiccommit#sect_9_0&quot;&gt;Things That Can Go Wrong&lt;/a&gt; section of the article on &lt;a href=&quot;atomiccommit&quot;&gt;Atomic Commit&lt;/a&gt;.</source>
          <target state="translated">Модуль пейджера очень надежен, но его можно разрушить. В этом разделе делается попытка идентифицировать и объяснить риски. (См. Также раздел &amp;laquo; &lt;a href=&quot;atomiccommit#sect_9_0&quot;&gt;Вещи, которые могут пойти не так&lt;/a&gt; &amp;raquo; статьи об &lt;a href=&quot;atomiccommit&quot;&gt;атомарной фиксации&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0f15cdebe573fd03148e855390c11255190632e7" translate="yes" xml:space="preserve">
          <source>The paragraph above notes that a MATCH operator with a simple term as the right-hand operand evaluates to true for all documents that contain the specified term. In this context, the &quot;document&quot; may refer to either the data stored in a single column of a row of an FTS table, or to the contents of all columns in a single row, depending on the identifier used as the left-hand operand to the MATCH operator. If the identifier specified as the left-hand operand of the MATCH operator is an FTS table column name, then the document that the search term must be contained in is the value stored in the specified column. However, if the identifier is the name of the FTS</source>
          <target state="translated">В параграфе выше отмечено,что оператор MATCH с простым термином в качестве правостороннего оператора оценивает верность для всех документов,которые содержат указанный термин.В этом контексте &quot;документ&quot; может относиться либо к данным,хранящимся в одном столбце строки таблицы FTS,либо к содержанию всех столбцов в одной строке,в зависимости от идентификатора,используемого в качестве левого операндов оператора Сопоставления.Если идентификатором,указанным в качестве левого операнда оператора Системы Сопоставления,является название столбца таблицы ФСТ,то документом,в котором должен содержаться поисковый термин,является значение,записанное в указанном столбце.Однако если идентификатором является имя ПФТС</target>
        </trans-unit>
        <trans-unit id="15582287ef68bc76059b207ebd8e45ad35a9f199" translate="yes" xml:space="preserve">
          <source>The parameter P is passed through as the only parameter to the callback function X. The parameter N is the approximate number of &lt;a href=&quot;../opcode&quot;&gt;virtual machine instructions&lt;/a&gt; that are evaluated between successive invocations of the callback X. If N is less than one then the progress handler is disabled.</source>
          <target state="translated">Параметр P передается как единственный параметр функции обратного вызова X. Параметр N - это приблизительное количество &lt;a href=&quot;../opcode&quot;&gt;инструкций виртуальной машины&lt;/a&gt; , которые оцениваются между последовательными вызовами обратного вызова X. Если N меньше единицы, то обработчик выполнения отключен. .</target>
        </trans-unit>
        <trans-unit id="de8aa7c163a7cfc0e81022005dde253ed27f9cea" translate="yes" xml:space="preserve">
          <source>The parameter P is passed through as the only parameter to the callback function X. The parameter N is the approximate number of &lt;a href=&quot;opcode&quot;&gt;virtual machine instructions&lt;/a&gt; that are evaluated between successive invocations of the callback X. If N is less than one then the progress handler is disabled.</source>
          <target state="translated">Параметр P передается как единственный параметр функции обратного вызова X. Параметр N - это приблизительное количество &lt;a href=&quot;opcode&quot;&gt;инструкций виртуальной машины&lt;/a&gt; , которые оцениваются между последовательными вызовами обратного вызова X. Если N меньше единицы, то обработчик выполнения отключен. .</target>
        </trans-unit>
        <trans-unit id="b6a1b97180e82088f349d801a8feb225d5ea8536" translate="yes" xml:space="preserve">
          <source>The parameters to the callback are the pArg value, the amount of memory currently in use, and the size of the allocation that provoked the callback. The callback will presumably invoke &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_free()&lt;/a&gt; to free up memory space. The callback may invoke &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc()&lt;/a&gt; or &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_realloc()&lt;/a&gt; but if it does, no additional callbacks will be invoked by the recursive calls.</source>
          <target state="translated">Параметрами обратного вызова являются значение pArg, объем используемой в данный момент памяти и размер выделения, вызвавшего обратный вызов. Обратный вызов предположительно вызовет &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_free ()&lt;/a&gt; для освобождения места в памяти. Обратный вызов может вызывать &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc ()&lt;/a&gt; или &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_realloc (),&lt;/a&gt; но в этом случае рекурсивные вызовы не будут вызывать никаких дополнительных обратных вызовов.</target>
        </trans-unit>
        <trans-unit id="a0635b4b828516772af2e4a5c5f8f7c2b0b83854" translate="yes" xml:space="preserve">
          <source>The parent and sub-query may contain WHERE clauses. Subject to rules (11), (12) and (13), they may also contain ORDER BY, LIMIT and OFFSET clauses.</source>
          <target state="translated">Родительский и подзапрос могут содержать ГДЕ клаузулы.В соответствии с правилами (11),(12)и (13),они могут также содержать положения ЗАКАЗАТЕЛЬСТВА,ОГРАНИЧЕНИЯ и ОТМЕНА.</target>
        </trans-unit>
        <trans-unit id="6d5030cd0c93ffa44cd5f784ea6b109c2ce36ffc" translate="yes" xml:space="preserve">
          <source>The parent key columns named in the foreign key constraint are not the primary key of the parent table and are not subject to a unique constraint using collating sequence specified in the CREATE TABLE, or</source>
          <target state="translated">Столбцы родительских ключей,названные в ограничении постороннего ключа,не являются первичным ключом таблицы родительских ключей и не подвержены уникальному ограничению с использованием последовательности сравнения,указанной в CREATE TABLE,либо</target>
        </trans-unit>
        <trans-unit id="0feae637448fae26652f631fd44b61bcd440968a" translate="yes" xml:space="preserve">
          <source>The parent key columns named in the foreign key constraint do not exist, or</source>
          <target state="translated">Столбцы родительского ключа,названные в ограничении постороннего ключа,не существуют,или</target>
        </trans-unit>
        <trans-unit id="ba132dacfac52109e850c048192c0d768817957a" translate="yes" xml:space="preserve">
          <source>The parent table does not exist, or</source>
          <target state="translated">Родительской таблицы не существует,или</target>
        </trans-unit>
        <trans-unit id="cfb0e652f64b7c831f470e25c9ae00145b03ba52" translate="yes" xml:space="preserve">
          <source>The parser assigns meaning to tokens based on their context. The parser for SQLite is generated using the &lt;a href=&quot;lemon&quot;&gt;Lemon parser generator&lt;/a&gt;. Lemon does the same job as YACC/BISON, but it uses a different input syntax which is less error-prone. Lemon also generates a parser which is reentrant and thread-safe. And Lemon defines the concept of a non-terminal destructor so that it does not leak memory when syntax errors are encountered. The grammar file that drives Lemon and that defines the SQL language that SQLite understands is found in &lt;a href=&quot;https://sqlite.org/src/file/src/parse.y&quot;&gt;parse.y&lt;/a&gt;.</source>
          <target state="translated">Парсер присваивает значение токенам в зависимости от их контекста. Парсер для SQLite создается с помощью &lt;a href=&quot;lemon&quot;&gt;генератора синтаксического анализатора Lemon&lt;/a&gt; . Lemon выполняет ту же работу, что и YACC / BISON, но использует другой синтаксис ввода, который менее подвержен ошибкам. Lemon также создает синтаксический анализатор, который является реентерабельным и потокобезопасным. И Lemon определяет концепцию нетерминального деструктора, чтобы он не утекал памяти при обнаружении синтаксических ошибок. Файл грамматики, управляющий Lemon и определяющий язык SQL, который понимает SQLite, находится в &lt;a href=&quot;https://sqlite.org/src/file/src/parse.y&quot;&gt;parse.y&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9872a2b10d55c6bd43d5d98d5414737378783a62" translate="yes" xml:space="preserve">
          <source>The parser forwards the AST on to the code generator. The code generator is the heart of SQLite, and is where most of the magic happens. The code generator resolves symbolic names in the AST - matching the names of columns and tables in the input SQL into actual columns and tables of the database. The code generator also does various transformations on the AST to &quot;optimize&quot; it. Finally the code generator chooses appropriate algorithms to implement the operations requested by the AST and constructs bytecode to carry out those operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bba39e24b4502de9e348487cd65024dc8a8b4825" translate="yes" xml:space="preserve">
          <source>The parser now insists on seeing a semicolon or the end of input before executing a statement. This avoids an accidental disaster if the WHERE keyword is misspelled in an UPDATE or DELETE statement.</source>
          <target state="translated">Теперь парсер настаивает на том,чтобы перед выполнением оператора видеть точку с запятой или конец ввода.Это позволяет избежать случайной катастрофы,если ключевое слово WHERE будет неправильно написано в операторе UPDATE или DELETE.</target>
        </trans-unit>
        <trans-unit id="276468011b3fce8fd043bc0ac6f52f8e374eb1fe" translate="yes" xml:space="preserve">
          <source>The parser used by SQLite is forgiving. It is often possible to use a keyword as an identifier as long as such use does not result in a parsing ambiguity. For example, the statement &quot;CREATE TABLE BEGIN(REPLACE,PRAGMA,END);&quot; is accepted by SQLite, and creates a new table named &quot;BEGIN&quot; with three columns named &quot;REPLACE&quot;, &quot;PRAGMA&quot;, and &quot;END&quot;. Nevertheless, best practice is to avoid using keywords as identifiers. Common techniques used to avoid keyword name collisions include:</source>
          <target state="translated">Парсер,используемый SQLite,прощает.Часто в качестве идентификатора можно использовать ключевое слово,если такое использование не приводит к неоднозначности разбора.Например,оператор &quot;CREATE TABLE BEGIN(REPLACE,PRAGMA,END);&quot; принимается SQLite и создает новую таблицу под названием &quot;BEGIN&quot; с тремя столбцами &quot;REPLACE&quot;,&quot;PRAGMA&quot; и &quot;END&quot;.Тем не менее,лучшая практика заключается в том,чтобы избегать использования ключевых слов в качестве идентификаторов.Обычные методы,используемые для избежания коллизий имен ключевых слов,включают в себя:</target>
        </trans-unit>
        <trans-unit id="cf399069b7a65af0b661c7a78ceab3a98b1156db" translate="yes" xml:space="preserve">
          <source>The parser's stack was overflowing on a very long UPDATE statement. This is now fixed.</source>
          <target state="translated">Стек синтаксического анализатора был переполнен на очень длинном заявлении UPDATE.Теперь это исправлено.</target>
        </trans-unit>
        <trans-unit id="3f01287feae0670aa81041fc77641d185841977a" translate="yes" xml:space="preserve">
          <source>The parsing of SQL statements is a significant consumer of CPU cycles in any SQL database engine. On-going efforts to optimize SQLite have caused the developers to spend a lot of time tweaking Lemon to generate faster parsers. These efforts have benefited all users of the Lemon parser generator, not just SQLite. But if Lemon had been a separately maintained tool, it would have been more difficult to make coordinated changes to both SQLite and Lemon, and as a result not as much optimization would have been accomplished. Hence, the fact that the parser generator tool is included in the source tree for SQLite has turned out to be a net benefit for both the tool itself and for SQLite.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5c83958bfdec6a8c2fd0d74498090055bde1a94" translate="yes" xml:space="preserve">
          <source>The parsing of SQL statements is a significant consumer of CPU cycles in any SQL database engine. On-going efforts to optimize SQLite have caused the developers to spend a lot of time tweaking Lemon to generate faster parsers. These efforts have benefited all users of the Lemon parser generator, not just SQLite. But if Lemon had been a separately maintained tool, it would have been more difficulty to make coordinated changes to both SQLite and Lemon, and as a result not as much optimization would have been accomplished. Hence, the fact that the parser generator tool is included in the source tree for SQLite has turned out to be a net benefit for both the tool itself and for SQLite.</source>
          <target state="translated">Разбор SQL выражений является важным потребителем циклов процессора в любом движке базы данных SQL.Постоянные усилия по оптимизации SQLite привели к тому,что разработчики потратили много времени на доработку Lemon для создания более быстрых парсеров.Эти усилия принесли пользу всем пользователям генератора парсеров Lemon,а не только SQLite.Но если бы Lemon был отдельно поддерживаемым инструментом,было бы сложнее вносить согласованные изменения как в SQLite,так и в Lemon,и в результате оптимизации было бы не так много.Следовательно,тот факт,что инструмент генерации синтаксического анализатора включен в дерево исходных текстов для SQLite,оказался чистым преимуществом как для самого инструмента,так и для SQLite.</target>
        </trans-unit>
        <trans-unit id="7d2ca17144abc28a05044c4d5d55dce18e17a921" translate="yes" xml:space="preserve">
          <source>The part of the name prior to the last &quot;_&quot; exactly matches the name of a virtual table that was created using &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt;. (Shadow tables are not recognized for &lt;a href=&quot;vtab#epovtab&quot;&gt;eponymous virtual tables&lt;/a&gt; and &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued functions&lt;/a&gt;.)</source>
          <target state="translated">Часть имени перед последним &quot;_&quot; в точности соответствует имени виртуальной таблицы, созданной с помощью &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; . (Теневые таблицы не распознаются для &lt;a href=&quot;vtab#epovtab&quot;&gt;одноименных виртуальных таблиц&lt;/a&gt; и &lt;a href=&quot;vtab#tabfunc2&quot;&gt;функций, возвращающих табличное значение&lt;/a&gt; .)</target>
        </trans-unit>
        <trans-unit id="042a9e73444095c51cd83e16473e75bf7e45a5e4" translate="yes" xml:space="preserve">
          <source>The patch level Z was historically only used for bug-fix releases that changed only a small number of code lines.</source>
          <target state="translated">Уровень заплаток Z исторически использовался только для исправлений ошибок в релизах,которые изменяли лишь небольшое количество строк кода.</target>
        </trans-unit>
        <trans-unit id="274dfc20017243c18164f876bdd5c3980ade92fe" translate="yes" xml:space="preserve">
          <source>The path component of the URI specifies the disk file that is the SQLite database to be opened. If the path component is omitted, then the database is stored in a temporary file that will be automatically deleted when the database connection closes. If the authority section is present, then the path is always an absolute pathname. If the authority section is omitted, then the path is an absolute pathname if it begins with the &quot;/&quot; character (ASCII code 0x2f) and is a relative pathname otherwise. On windows, if the absolute path begins with &quot;&lt;b&gt;/&lt;i&gt;X&lt;/i&gt;:/&lt;/b&gt;&quot; where &lt;b&gt;&lt;i&gt;X&lt;/i&gt;&lt;/b&gt; is any single ASCII alphabetic character (&quot;a&quot; through &quot;z&quot; or &quot;A&quot; through &quot;Z&quot;) then the &quot;&lt;b&gt;&lt;i&gt;X:&lt;/i&gt;&lt;/b&gt;&quot; is understood to be the drive letter of the volume containing the file, not the toplevel directory.</source>
          <target state="translated">Компонент пути в URI указывает файл на диске, который является базой данных SQLite, которую нужно открыть. Если компонент пути опущен, то база данных сохраняется во временном файле, который будет автоматически удален при закрытии соединения с базой данных. Если присутствует раздел полномочий, то путь всегда является абсолютным путем. Если раздел полномочий не указан, то путь является абсолютным путем, если он начинается с символа &amp;laquo;/&amp;raquo; (код ASCII 0x2f), и является относительным путем в противном случае. В Windows, если абсолютный путь начинается с &amp;laquo; &lt;b&gt;/ &lt;i&gt;X&lt;/i&gt; : /&lt;/b&gt; &amp;raquo;, где &lt;b&gt;&lt;i&gt;X&lt;/i&gt;&lt;/b&gt; - это любой отдельный буквенный символ ASCII (от &amp;laquo;a&amp;raquo; до &amp;laquo;z&amp;raquo; или от &amp;laquo;A&amp;raquo; до &amp;laquo;Z&amp;raquo;), то &amp;laquo; &lt;b&gt;&lt;i&gt;X:&lt;/i&gt;&lt;/b&gt;&quot;понимается как буква диска тома, содержащего файл, а не каталог верхнего уровня.</target>
        </trans-unit>
        <trans-unit id="f3532ac83d22ad95431b31438dce70e426b9f355" translate="yes" xml:space="preserve">
          <source>The path is optional if the authority is present. If the authority is omitted then the path is required.</source>
          <target state="translated">Путь является необязательным,если орган власти присутствует.Если полномочия опущены,то путь необходим.</target>
        </trans-unit>
        <trans-unit id="5dd0cabb7668cbee80844078c73a695152a285b7" translate="yes" xml:space="preserve">
          <source>The pattern matching algorithm used in the default &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; and &lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; implementation of SQLite can exhibit O(N&amp;amp;sup2) performance (where N is the number of characters in the pattern) for certain pathological cases. To avoid denial-of-service attacks from miscreants who are able to specify their own LIKE or GLOB patterns, the length of the LIKE or GLOB pattern is limited to SQLITE_MAX_LIKE_PATTERN_LENGTH bytes. The default value of this limit is 50000. A modern workstation can evaluate even a pathological LIKE or GLOB pattern of 50000 bytes relatively quickly. The denial of service problem only comes into play when the pattern length gets into millions of bytes. Nevertheless, since most useful LIKE or GLOB patterns are at most a few dozen bytes in length, paranoid application developers may want to reduce this parameter to something in the range of a few hundred if they know that external users are able to generate arbitrary patterns.</source>
          <target state="translated">Алгоритм сопоставления с образцом, используемый по умолчанию в &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; и &lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt;реализация SQLite может демонстрировать производительность O (N &amp;amp; sup2) (где N - количество символов в шаблоне) для определенных патологических случаев. Чтобы избежать атак типа &amp;laquo;отказ в обслуживании&amp;raquo; со стороны злоумышленников, которые могут указывать свои собственные шаблоны LIKE или GLOB, длина шаблона LIKE или GLOB ограничена байтами SQLITE_MAX_LIKE_PATTERN_LENGTH. Значение этого предела по умолчанию - 50000. Современная рабочая станция может относительно быстро оценить даже патологический шаблон LIKE или GLOB размером 50000 байт. Проблема отказа в обслуживании возникает только тогда, когда длина шаблона достигает миллионов байтов. Тем не менее, поскольку наиболее полезные шаблоны LIKE или GLOB имеют длину не более нескольких десятков байтов,разработчики приложений-параноиков могут захотеть уменьшить этот параметр до нескольких сотен, если они знают, что внешние пользователи могут генерировать произвольные шаблоны.</target>
        </trans-unit>
        <trans-unit id="d6c16218a9785941384e3fbed5d84494c8c3a3ec" translate="yes" xml:space="preserve">
          <source>The pattern matching algorithm used in the default &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; and &lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; implementation of SQLite can exhibit O(N&amp;sup2;) performance (where N is the number of characters in the pattern) for certain pathological cases. To avoid denial-of-service attacks from miscreants who are able to specify their own LIKE or GLOB patterns, the length of the LIKE or GLOB pattern is limited to SQLITE_MAX_LIKE_PATTERN_LENGTH bytes. The default value of this limit is 50000. A modern workstation can evaluate even a pathological LIKE or GLOB pattern of 50000 bytes relatively quickly. The denial of service problem only comes into play when the pattern length gets into millions of bytes. Nevertheless, since most useful LIKE or GLOB patterns are at most a few dozen bytes in length, paranoid application developers may want to reduce this parameter to something in the range of a few hundred if they know that external users are able to generate arbitrary patterns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="202855d0443faeb5dfa8c360619529b04d6a4b20" translate="yes" xml:space="preserve">
          <source>The people table has one entry for each person in a large organization. Each person is either a &quot;student&quot; or a &quot;teacher&quot;, as determined by the &quot;role&quot; field. And we record the height in centimeters of each person. The role and height are indexed. Notice that the left-most column of the index is not very selective - it only contains two possible values.</source>
          <target state="translated">В таблице &quot;Люди&quot; есть по одной записи на каждого человека в большой организации.Каждый человек является либо &quot;учеником&quot;,либо &quot;учителем&quot;,что определяется полем &quot;роль&quot;.И мы записываем высоту в сантиметрах каждого человека.Роль и рост индексируются.Обратите внимание,что крайний левый столбец индекса не очень селективен-он содержит только два возможных значения.</target>
        </trans-unit>
        <trans-unit id="6e5ee4166c936fcf879a132b411a3178c46f082a" translate="yes" xml:space="preserve">
          <source>The people table has one entry for each person in a large organization. Each person is either a &quot;student&quot; or a &quot;teacher&quot;, as determined by the &quot;role&quot; field. The table also records the height in centimeters of each person. The role and height are indexed. Notice that the left-most column of the index is not very selective - it only contains two possible values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92b29d0fa9a5e447b11571a63811cd4169611d21" translate="yes" xml:space="preserve">
          <source>The per-connection statistics do not use global variables and hence do not require mutexes to update or access. Consequently the per-connection statistics continue to function even if &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmemstatus&quot;&gt;SQLITE_CONFIG_MEMSTATUS&lt;/a&gt; is turned off.</source>
          <target state="translated">Статистика для каждого соединения не использует глобальные переменные и, следовательно, не требует мьютексов для обновления или доступа. Следовательно, статистика для каждого соединения продолжает работать, даже если &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmemstatus&quot;&gt;SQLITE_CONFIG_MEMSTATUS&lt;/a&gt; отключен.</target>
        </trans-unit>
        <trans-unit id="50dbff919de02c3f0e66d4c1de101521648ed2d5" translate="yes" xml:space="preserve">
          <source>The performance can be improved slightly by bypassing the SQL layer and reading the blob content directly using the &lt;a href=&quot;c3ref/blob_read&quot;&gt;sqlite3_blob_read()&lt;/a&gt; interface, as shown in the next chart:</source>
          <target state="translated">Производительность можно немного улучшить, обойдя уровень SQL и прочитав содержимое &lt;a href=&quot;c3ref/blob_read&quot;&gt;большого двоичного объекта&lt;/a&gt; напрямую с помощью интерфейса sqlite3_blob_read () , как показано на следующей диаграмме:</target>
        </trans-unit>
        <trans-unit id="095c3d78e34e00649d5524d5d46327c65695f40f" translate="yes" xml:space="preserve">
          <source>The performance difference arises (we believe) because when working from an SQLite database, the open() and close() system calls are invoked only once, whereas open() and close() are invoked once for each blob when using blobs stored in individual files. It appears that the overhead of calling open() and close() is greater than the overhead of using the database. The size reduction arises from the fact that individual files are padded out to the next multiple of the filesystem block size, whereas the blobs are packed more tightly into an SQLite database.</source>
          <target state="translated">Разница в производительности возникает (нам кажется)потому,что при работе из базы данных SQLite системные вызовы open()и close()вызываются только один раз,в то время как open()и close()вызываются один раз для каждого блока при использовании блоков,хранящихся в отдельных файлах.Оказывается,что накладные расходы при вызове open()и close()больше,чем накладные расходы при использовании базы данных.Уменьшение размера происходит за счет того,что отдельные файлы добавляются в блок размером,кратным размеру блока файловой системы,в то время как блобы более плотно упаковываются в базу данных SQLite.</target>
        </trans-unit>
        <trans-unit id="2a5a29c317c697ba64096b7f2c68033b4565ac42" translate="yes" xml:space="preserve">
          <source>The permutation is only valid until the next &lt;a href=&quot;opcode#Compare&quot;&gt;Compare&lt;/a&gt; that has the OPFLAG_PERMUTE bit set in P5. Typically the &lt;a href=&quot;opcode#Permutation&quot;&gt;Permutation&lt;/a&gt; should occur immediately prior to the &lt;a href=&quot;opcode#Compare&quot;&gt;Compare&lt;/a&gt;.</source>
          <target state="translated">Перестановка действительна только до следующего &lt;a href=&quot;opcode#Compare&quot;&gt;сравнения&lt;/a&gt; , в котором бит OPFLAG_PERMUTE установлен в P5. Обычно &lt;a href=&quot;opcode#Permutation&quot;&gt;перестановка&lt;/a&gt; должна происходить непосредственно перед &lt;a href=&quot;opcode#Compare&quot;&gt;сравнением&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="645402751e5b5ab0dd0504759786ac3f99e9f97b" translate="yes" xml:space="preserve">
          <source>The persistence of WAL mode means that applications can be converted to using SQLite in WAL mode without making any changes to the application itself. One has merely to run &quot;&lt;code&gt;PRAGMA journal_mode=WAL;&lt;/code&gt;&quot; on the database file(s) using the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; or other utility, then restart the application.</source>
          <target state="translated">Постоянство режима WAL означает, что приложения могут быть преобразованы для использования SQLite в режиме WAL без внесения каких-либо изменений в само приложение. &lt;code&gt;PRAGMA journal_mode=WAL;&lt;/code&gt; просто запустить PRAGMA journal_mode = WAL; для файла (ов) базы данных с помощью &lt;a href=&quot;cli&quot;&gt;оболочки командной строки&lt;/a&gt; или другой утилиты, а затем перезапустить приложение.</target>
        </trans-unit>
        <trans-unit id="37f0ea5f181b03035443f3a918ec838d5bf0f5c4" translate="yes" xml:space="preserve">
          <source>The phrase &quot;VALUES(</source>
          <target state="translated">Фраза &quot;VALUES(</target>
        </trans-unit>
        <trans-unit id="afda55d9895c016a5496f6b600205dbf8fbc7d06" translate="yes" xml:space="preserve">
          <source>The planner avoids query plans that use indexes with unknown collating functions.</source>
          <target state="translated">Планировщик избегает планов запросов,использующих индексы с неизвестными функциями сопоставления.</target>
        </trans-unit>
        <trans-unit id="926646f3fb08c1ad8acc73155c7f0bcd303e689e" translate="yes" xml:space="preserve">
          <source>The planner omits unused LEFT JOINs even if they are not the right-most joins of a query.</source>
          <target state="translated">Планировщик опускает неиспользуемые левые входы,даже если они не являются самыми правыми входами в запрос.</target>
        </trans-unit>
        <trans-unit id="5852e8af03eff264841e6547e952b8e08ad085dc" translate="yes" xml:space="preserve">
          <source>The platform used for these tests is a 1.6GHz Athlon with 1GB or memory and an IDE disk drive. The operating system is RedHat Linux 7.2 with a stock kernel.</source>
          <target state="translated">Платформа,используемая для этих тестов-это Athlon 1.6 ГГц с 1 ГБ или памятью и дисковым накопителем IDE.Операционная система-RedHat Linux 7.2 со стандартным ядром.</target>
        </trans-unit>
        <trans-unit id="e614d538ab4445c07af270ecdc6677ad39ccfb17" translate="yes" xml:space="preserve">
          <source>The point is this: an SQL database schema almost always does a far better job of defining and organizing the tables and data structures and their relationships. And having clear, concise, and well-defined representation almost always results in an application that performs better, has fewer problems, and is easier to develop and maintain.</source>
          <target state="translated">Дело в том,что схема базы данных SQL почти всегда выполняет гораздо лучшую работу по определению и организации таблиц и структур данных,а также их взаимосвязей.А наличие четкого,лаконичного и четкого представления почти всегда приводит к тому,что приложение работает лучше,имеет меньше проблем и проще в разработке и обслуживании.</target>
        </trans-unit>
        <trans-unit id="1249a327a44d56131079defe491a7680b8885a62" translate="yes" xml:space="preserve">
          <source>The pointer arguments to &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_realloc()&lt;/a&gt; must be either NULL or else pointers obtained from a prior invocation of &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc()&lt;/a&gt; or &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_realloc()&lt;/a&gt; that have not yet been released.</source>
          <target state="translated">Аргументы указателя на &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free ()&lt;/a&gt; и &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_realloc ()&lt;/a&gt; должны быть либо NULL, либо указатели, полученные в результате предыдущего вызова &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc ()&lt;/a&gt; или &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_realloc (),&lt;/a&gt; которые еще не были выпущены.</target>
        </trans-unit>
        <trans-unit id="70d5983c94ca6fdbfd5d05e2d8f25d536fa0e2f9" translate="yes" xml:space="preserve">
          <source>The pointer arguments to &lt;a href=&quot;free&quot;&gt;sqlite3_free()&lt;/a&gt; and &lt;a href=&quot;free&quot;&gt;sqlite3_realloc()&lt;/a&gt; must be either NULL or else pointers obtained from a prior invocation of &lt;a href=&quot;free&quot;&gt;sqlite3_malloc()&lt;/a&gt; or &lt;a href=&quot;free&quot;&gt;sqlite3_realloc()&lt;/a&gt; that have not yet been released.</source>
          <target state="translated">Аргументы указателя на &lt;a href=&quot;free&quot;&gt;sqlite3_free ()&lt;/a&gt; и &lt;a href=&quot;free&quot;&gt;sqlite3_realloc ()&lt;/a&gt; должны быть либо NULL, либо указатели, полученные в результате предыдущего вызова &lt;a href=&quot;free&quot;&gt;sqlite3_malloc ()&lt;/a&gt; или &lt;a href=&quot;free&quot;&gt;sqlite3_realloc (),&lt;/a&gt; которые еще не были выпущены.</target>
        </trans-unit>
        <trans-unit id="19e21383ec674e61332285628bf7a07277fe3452" translate="yes" xml:space="preserve">
          <source>The pointer type is not intended to be flexible and dynamic. The pointer type is intended to be a design-time constant. Applications should not synthesize pointer type strings at run-time. Providing support for dynamic pointer type strings would lead developers to misuse the pointer-passing interfaces by creating run-time synthesized pointer type strings. Requiring the pointer type strings to be static encourages developers to do the right thing by choosing fixed pointer type names at design-time and encoding those names as constant strings.</source>
          <target state="translated">Тип указателя не рассчитан на гибкость и динамику.Тип указателя предназначен для константы времени проектирования.Приложения не должны синтезировать строки типа указателя во время исполнения.Обеспечение поддержки динамических строк указательных типов приведет к тому,что разработчики будут злоупотреблять интерфейсами обхода указателей,создавая строки указательных типов,синтезируемые во время исполнения.Требование к строкам типа указателя быть статическими побуждает разработчиков поступать правильно,выбирая фиксированные имена типов указателей во время исполнения и кодируя эти имена как константные строки.</target>
        </trans-unit>
        <trans-unit id="0a50e253ab7c267f33ad3d5a3deec486738946df" translate="yes" xml:space="preserve">
          <source>The pointers returned are valid until a type conversion occurs as described above, or until &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; or &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset()&lt;/a&gt; or &lt;a href=&quot;#sqlite3_finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt; is called. The memory space used to hold strings and BLOBs is freed automatically. Do not pass the pointers returned from &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_blob()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_text()&lt;/a&gt;, etc. into &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free()&lt;/a&gt;.</source>
          <target state="translated">Указатели , возвращаемые действительны до тех пор , преобразование типа не происходит , как описано выше, или до &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step ()&lt;/a&gt; или &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset ()&lt;/a&gt; или &lt;a href=&quot;#sqlite3_finalize&quot;&gt;sqlite3_finalize ()&lt;/a&gt; называется. Пространство памяти, используемое для хранения строк и больших двоичных объектов, освобождается автоматически. Не передавайте указатели, возвращенные из &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_blob ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_text ()&lt;/a&gt; и т. Д., В &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3551cf33afa7b1894cdea20e6326c2bf8dcf19de" translate="yes" xml:space="preserve">
          <source>The pointers returned are valid until a type conversion occurs as described above, or until &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; or &lt;a href=&quot;reset&quot;&gt;sqlite3_reset()&lt;/a&gt; or &lt;a href=&quot;finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt; is called. The memory space used to hold strings and BLOBs is freed automatically. Do not pass the pointers returned from &lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_blob()&lt;/a&gt;, &lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_text()&lt;/a&gt;, etc. into &lt;a href=&quot;free&quot;&gt;sqlite3_free()&lt;/a&gt;.</source>
          <target state="translated">Указатели , возвращаемые действительны до тех пор , преобразование типа не происходит , как описано выше, или до &lt;a href=&quot;step&quot;&gt;sqlite3_step ()&lt;/a&gt; или &lt;a href=&quot;reset&quot;&gt;sqlite3_reset ()&lt;/a&gt; или &lt;a href=&quot;finalize&quot;&gt;sqlite3_finalize ()&lt;/a&gt; называется. Пространство памяти, используемое для хранения строк и больших двоичных объектов, освобождается автоматически. Не передавайте указатели, возвращенные из &lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_blob ()&lt;/a&gt; , &lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_text ()&lt;/a&gt; и т. Д., В &lt;a href=&quot;free&quot;&gt;sqlite3_free ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9edff31b2dc071eb66ab4aa44d22adfef6b1aa3c" translate="yes" xml:space="preserve">
          <source>The pointers that piggy-back on SQL NULL values using the &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer()&lt;/a&gt;, &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer()&lt;/a&gt;, and &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_pointer()&lt;/a&gt; interface are transient and ephemeral. The pointers are never written into the database. The pointers will not survive sorting. The latter fact is why there is no sqlite3_column_pointer() interface, since it is impossible to predict whether or not the query planner will insert a sort operation prior to returning a value from a query, so it would be impossible to know if a pointer value inserted into a query by &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer()&lt;/a&gt; or &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer()&lt;/a&gt; would survive through to the result set.</source>
          <target state="translated">Указатели, которые совмещают значения SQL NULL с помощью интерфейсов &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer ()&lt;/a&gt; , &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer ()&lt;/a&gt; и &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_pointer (),&lt;/a&gt; являются временными и эфемерными. Указатели никогда не записываются в базу данных. Указатели не переживут сортировку. Последний факт является причиной отсутствия интерфейса sqlite3_column_pointer (), поскольку невозможно предсказать, будет ли планировщик запросов вставлять операцию сортировки перед возвратом значения из запроса, поэтому было бы невозможно узнать, является ли значение указателя вставленные в запрос &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer ()&lt;/a&gt; или &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer ()&lt;/a&gt; , сохранятся до набора результатов.</target>
        </trans-unit>
        <trans-unit id="41025b56b1d99416ab106417d2e02a42b25af90e" translate="yes" xml:space="preserve">
          <source>The porter tokenizer is a wrapper tokenizer. It takes the output of some other tokenizer and applies the &lt;a href=&quot;http://tartarus.org/martin/PorterStemmer/&quot;&gt;porter stemming algorithm&lt;/a&gt; to each token before it returns it to FTS5. This allows search terms like &quot;correction&quot; to match similar words such as &quot;corrected&quot; or &quot;correcting&quot;. The porter stemmer algorithm is designed for use with English language terms only - using it with other languages may or may not improve search utility.</source>
          <target state="translated">Токенизатор переносчика - это токенизатор-оболочка. Он принимает выходные данные другого токенизатора и применяет &lt;a href=&quot;http://tartarus.org/martin/PorterStemmer/&quot;&gt;алгоритм&lt;/a&gt; выделения портера к каждому токену, прежде чем вернуть его в FTS5. Это позволяет таким поисковым запросам, как &amp;laquo;исправление&amp;raquo;, совпадать с похожими словами, например &amp;laquo;исправлено&amp;raquo; или &amp;laquo;исправление&amp;raquo;. Алгоритм переносного стеммера предназначен для использования только с терминами на английском языке - его использование с другими языками может улучшить или не улучшить утилиту поиска.</target>
        </trans-unit>
        <trans-unit id="019bce8583fdda23526c796c86c34c98cfb4abf1" translate="yes" xml:space="preserve">
          <source>The porter tokenizer is a wrapper tokenizer. It takes the output of some other tokenizer and applies the &lt;a href=&quot;https://tartarus.org/martin/PorterStemmer/&quot;&gt;porter stemming algorithm&lt;/a&gt; to each token before it returns it to FTS5. This allows search terms like &quot;correction&quot; to match similar words such as &quot;corrected&quot; or &quot;correcting&quot;. The porter stemmer algorithm is designed for use with English language terms only - using it with other languages may or may not improve search utility.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8db274801095c26d088720201acb1bad2d40d917" translate="yes" xml:space="preserve">
          <source>The power of an SQLite database could, in theory, be achieved using a custom file format. But any custom file format that is as expressive as a relational database would likely require an enormous design specification and many tens or hundreds of thousands of lines of code to implement. And the end result would be an &quot;opaque blob&quot; that is inaccessible without specialized tools.</source>
          <target state="translated">Мощность базы данных SQLite теоретически может быть достигнута с помощью пользовательского формата файлов.Но любой пользовательский формат файла,столь же выразительный,как реляционная база данных,скорее всего,потребует огромной проектной спецификации и множества десятков или сотен тысяч строк кода для реализации.И конечным результатом был бы &quot;непрозрачный блок&quot;,недоступный без специализированных инструментов.</target>
        </trans-unit>
        <trans-unit id="4938c1fbe50ea261772ee32f2ec000b4cb6af37b" translate="yes" xml:space="preserve">
          <source>The powersafe overwrite property for individual databases can be specified as the database is opened using the &quot;psow&quot; query parameter with a &lt;a href=&quot;uri&quot;&gt;URI filename&lt;/a&gt;. For example, to always assume powersafe overwrite for a file (perhaps to ensure maximum write performance), open it as</source>
          <target state="translated">Свойство перезаписи powersafe для отдельных баз данных можно указать при открытии базы данных с помощью параметра запроса &amp;laquo;psow&amp;raquo; с &lt;a href=&quot;uri&quot;&gt;именем URI-файла&lt;/a&gt; . Например, чтобы всегда предполагать безопасную перезапись файла (возможно, для обеспечения максимальной производительности записи), откройте его как</target>
        </trans-unit>
        <trans-unit id="67790abdb6b576eda27fab78ba503267f5a114fa" translate="yes" xml:space="preserve">
          <source>The powersafe overwrite property says nothing about the state of the bytes that were written. Those bytes might contain their old values, their new values, random values, or some combination of these. The powersafe overwrite property merely states that writes cannot change bytes outside of the range of bytes written.</source>
          <target state="translated">Перезапись собственности в системе &quot;Powersafe&quot; ничего не говорит о состоянии написанных байтов.Эти байты могут содержать свои старые значения,новые значения,случайные значения или их некоторую комбинацию.Свойство powersafe overwrite (безопасная перезапись)просто заявляет,что записываемый байт не может быть изменён за пределами диапазона записанных байтов.</target>
        </trans-unit>
        <trans-unit id="1389e8d5f9998cc48b0c99ae215e31d8f358ccd0" translate="yes" xml:space="preserve">
          <source>The pragma command is specific to SQLite and is not compatible with any other SQL database engine.</source>
          <target state="translated">Прагматическая команда специфична для SQLite и не совместима ни с каким другим движком баз данных SQL.</target>
        </trans-unit>
        <trans-unit id="f45ce9f6459acccc6664213a9c9d236d0392b096" translate="yes" xml:space="preserve">
          <source>The pragma is like &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;integrity_check&lt;/a&gt; except that it does not verify UNIQUE constraints and does not verify that index content matches table content. By skipping UNIQUE and index consistency checks, quick_check is able to run faster. PRAGMA quick_check runs in O(N) time whereas &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt; requires O(NlogN) time where N is the total number of rows in the database. Otherwise the two pragmas are the same.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b9cdfdccce2f8d840c93537988a1d96c50df274" translate="yes" xml:space="preserve">
          <source>The pragma is like &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;integrity_check&lt;/a&gt; except that it does not verify UNIQUE constraints and does not verify that index content matches table content. By skipping UNIQUE and index consistency checks, quick_check is able to run much faster than integrity_check. Otherwise the two pragmas are the same.</source>
          <target state="translated">Прагма похожа на &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;целостность_check,&lt;/a&gt; за исключением того, что она не проверяет ограничения UNIQUE и не проверяет соответствие содержимого индекса содержимому таблицы. Пропуск UNIQUE и проверки целостности индекса, quick_check может работать намного быстрее, чем Integrity_check. В остальном две прагмы одинаковы.</target>
        </trans-unit>
        <trans-unit id="da60401a603e537afbb64f9be897b6e57271b0ee" translate="yes" xml:space="preserve">
          <source>The pre-update hook</source>
          <target state="translated">Крючок до обновления</target>
        </trans-unit>
        <trans-unit id="77a94c0ef3120048af1c78a5031b2bc8f51341cf" translate="yes" xml:space="preserve">
          <source>The pre-update hook.</source>
          <target state="translated">Крючок,который использовался до свидания.</target>
        </trans-unit>
        <trans-unit id="464d49040a7350ab38dd3a440629e97d8425be1c" translate="yes" xml:space="preserve">
          <source>The precautions above are not required in order to use SQLite safely with potentially hostile inputs. However, they do provide an extra layer of defense against zero-day exploits and are encouraged for applications that pass data from untrusted sources into SQLite.</source>
          <target state="translated">Вышеуказанные меры предосторожности не требуются для безопасного использования SQLite с потенциально враждебными входными данными.Тем не менее,они обеспечивают дополнительный уровень защиты от эксплойтов нулевого дня и поощряются для приложений,которые передают данные из недоверенных источников в SQLite.</target>
        </trans-unit>
        <trans-unit id="05bf811875969018cb62c264a6781abc17b442f0" translate="yes" xml:space="preserve">
          <source>The precedence order for ON CONFLICT clauses was changed so that ON CONFLICT clauses on BEGIN statements have a higher precedence than ON CONFLICT clauses on constraints.</source>
          <target state="translated">Порядок приоритета клаузул ПО КОНФЛИТИКЕ был изменен таким образом,что клаузулы ПО КОНФЛИТИКЕ в заявлениях о НАЧАЛОВЕЧЕНИИ имеют больший приоритет,чем клаузулы ПО КОНФЛИТИКЕ в заявлениях об ограничениях.</target>
        </trans-unit>
        <trans-unit id="122c8023ebc9769b59f3a1882e33d76b3169c9fd" translate="yes" xml:space="preserve">
          <source>The preceding paragraphs contain a lot of information. To ease the task of constructing a new VFS for SQLite we offer the following implementation checklist:</source>
          <target state="translated">В предыдущих параграфах содержится много информации.Для облегчения задачи построения новой VFS для SQLite мы предлагаем следующий контрольный список реализации:</target>
        </trans-unit>
        <trans-unit id="661723ea54e783ccd80036c290bfdccff5b43478" translate="yes" xml:space="preserve">
          <source>The precision field, if it is present, must follow the width separated by a single &quot;.&quot; character. If there is no width, then the &quot;.&quot; that introduces the precision immediately follows either the flags (if there are any) or the initial &quot;%&quot;.</source>
          <target state="translated">Поле точности,если оно присутствует,должно следовать ширине,разделенной одним символом &quot;...&quot;.Если ширина отсутствует,то знак &quot;...&quot;,который вводит точность,следует либо за флагами (если таковые имеются),либо за начальным &quot;%&quot;.</target>
        </trans-unit>
        <trans-unit id="1f4e06f8dccb411ae11d13e1945ae927355460b6" translate="yes" xml:space="preserve">
          <source>The precision provided by IEEE 754 Binary64 is sufficient for most computations. For example, if &quot;47.49&quot; represents a price and inflation is running at 2% per year, then the price is going up by about 0.0000000301 dollars per second. The error in the recorded value of 47.49 represents about 66 nanoseconds worth of inflation. So if the 47.49 price is exact when you enter it, then the effects of inflation will cause the true value to exactly equal the value actually stored (47.4900000000000019895196601282805204391479492187) in less than one ten-millionth of a second. Surely that level of precision is sufficient for most purposes?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="274c336721e63c209854a5c06e41f1f163132ddd" translate="yes" xml:space="preserve">
          <source>The preferred routine to use is &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt;. The &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; interface is legacy and should be avoided. &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v3()&lt;/a&gt; has an extra &quot;prepFlags&quot; option that is used for special purposes.</source>
          <target state="translated">Предпочтительная процедура - &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; . Интерфейс &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare ()&lt;/a&gt; является устаревшим, и его следует избегать. &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v3 ()&lt;/a&gt; имеет дополнительную опцию &quot;PrepFlags&quot;, которая используется для специальных целей.</target>
        </trans-unit>
        <trans-unit id="2a1d33401c2095551ef53ebdb2c936c2ab4e7f75" translate="yes" xml:space="preserve">
          <source>The preferred routine to use is &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt;. The &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; interface is legacy and should be avoided. &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v3()&lt;/a&gt; has an extra &quot;prepFlags&quot; option that is used for special purposes.</source>
          <target state="translated">Предпочтительная процедура - &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; . Интерфейс &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare ()&lt;/a&gt; является устаревшим, и его следует избегать. &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v3 ()&lt;/a&gt; имеет дополнительную опцию &quot;PrepFlags&quot;, которая используется для специальных целей.</target>
        </trans-unit>
        <trans-unit id="e5802699120466acd022e1fa07d198c436289856" translate="yes" xml:space="preserve">
          <source>The prefix on temporary filenames on Windows is changed from &quot;sqlite&quot; to &quot;etilqs&quot;.</source>
          <target state="translated">Префикс на временных именах файлов в Windows изменен с &quot;sqlite&quot; на &quot;etilqs&quot;.</target>
        </trans-unit>
        <trans-unit id="f3230410aa1ec23cdd51b1c85ef3e6e8a5bf6364" translate="yes" xml:space="preserve">
          <source>The presence of a busy handler does not guarantee that it will be invoked when there is lock contention. If SQLite determines that invoking the busy handler could result in a deadlock, it will go ahead and return &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY&lt;/a&gt; to the application instead of invoking the busy handler. Consider a scenario where one process is holding a read lock that it is trying to promote to a reserved lock and a second process is holding a reserved lock that it is trying to promote to an exclusive lock. The first process cannot proceed because it is blocked by the second and the second process cannot proceed because it is blocked by the first. If both processes invoke the busy handlers, neither will make any progress. Therefore, SQLite returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY&lt;/a&gt; for the first process, hoping that this will induce the first process to release its read lock and allow the second process to proceed.</source>
          <target state="translated">Наличие обработчика занятости не гарантирует, что он будет вызван при конфликте блокировок. Если SQLite определяет, что вызов обработчика занятости может привести к тупиковой ситуации, он будет продолжать и возвращать &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY&lt;/a&gt; приложению вместо вызова обработчика занятости. Рассмотрим сценарий, в котором один процесс удерживает блокировку чтения, которую он пытается преобразовать в зарезервированную блокировку, а второй процесс удерживает зарезервированную блокировку, которую он пытается повысить до монопольной блокировки. Первый процесс не может продолжаться, потому что он заблокирован вторым, а второй процесс не может продолжаться, потому что он заблокирован первым. Если оба процесса вызывают обработчики занятости, ни один из них не продвинется. Следовательно, SQLite возвращает &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY&lt;/a&gt;для первого процесса, надеясь, что это заставит первый процесс снять блокировку чтения и позволить второму процессу продолжить работу.</target>
        </trans-unit>
        <trans-unit id="f52f9d0c779543db7a531d457708b0c4e1e3b230" translate="yes" xml:space="preserve">
          <source>The presence of a busy handler does not guarantee that it will be invoked when there is lock contention. If SQLite determines that invoking the busy handler could result in a deadlock, it will go ahead and return &lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; to the application instead of invoking the busy handler. Consider a scenario where one process is holding a read lock that it is trying to promote to a reserved lock and a second process is holding a reserved lock that it is trying to promote to an exclusive lock. The first process cannot proceed because it is blocked by the second and the second process cannot proceed because it is blocked by the first. If both processes invoke the busy handlers, neither will make any progress. Therefore, SQLite returns &lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; for the first process, hoping that this will induce the first process to release its read lock and allow the second process to proceed.</source>
          <target state="translated">Наличие обработчика занятости не гарантирует, что он будет вызван при конфликте блокировок. Если SQLite определяет, что вызов обработчика занятости может привести к тупиковой ситуации, он будет продолжать и возвращать &lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; приложению вместо вызова обработчика занятости. Рассмотрим сценарий, в котором один процесс удерживает блокировку чтения, которую он пытается преобразовать в зарезервированную блокировку, а второй процесс удерживает зарезервированную блокировку, которую он пытается повысить до монопольной блокировки. Первый процесс не может продолжаться, потому что он заблокирован вторым, а второй процесс не может продолжаться, потому что он заблокирован первым. Если оба процесса вызывают обработчики занятости, ни один из них не продвинется. Следовательно, SQLite возвращает &lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;для первого процесса, надеясь, что это заставит первый процесс снять блокировку чтения и позволить второму процессу продолжить работу.</target>
        </trans-unit>
        <trans-unit id="b2efda84ef1340b69a62f5b61118269d4141c529" translate="yes" xml:space="preserve">
          <source>The presence of a hot journal is our indication that a previous process was trying to commit a transaction but it aborted for some reason prior to the completion of the commit. A hot journal means that the database file is in an inconsistent state and needs to be repaired (by rollback) prior to being used.</source>
          <target state="translated">Наличие горячего журнала-это наш признак того,что предыдущий процесс пытался совершить транзакцию,но она была прервана по каким-то причинам до завершения коммита.Горячий журнал означает,что файл базы данных находится в непоследовательном состоянии и нуждается в ремонте (откатом)перед использованием.</target>
        </trans-unit>
        <trans-unit id="53e2bd6dac9cbbc9b06c74e123d964800e4d3352" translate="yes" xml:space="preserve">
          <source>The presence of the &quot;noskipscan&quot; token on the sqlite_stat1.stat field of an index prevents that index from being used with the &lt;a href=&quot;optoverview#skipscan&quot;&gt;skip-scan optimization&lt;/a&gt;.</source>
          <target state="translated">Наличие токена &amp;laquo;noskipscan&amp;raquo; в поле sqlite_stat1.stat индекса предотвращает использование этого индекса при &lt;a href=&quot;optoverview#skipscan&quot;&gt;оптимизации&lt;/a&gt; с пропуском сканирования .</target>
        </trans-unit>
        <trans-unit id="a01f573624c54e96d01f0d23d0ba8b3593807a0a" translate="yes" xml:space="preserve">
          <source>The presentation of the query planner problem above is a simplification. The costs are estimates. We cannot know what the true cost of running a loop is until we actually run the loop. SQLite makes guesses for the cost of running a loop based on the availability of indexes and constraints found in the WHERE clause. These guesses are usually pretty good, but they can sometimes be off. Using the &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; command to collect additional statistical information about the database can sometimes enable SQLite to make better guesses about the cost.</source>
          <target state="translated">Представленная выше проблема планировщика запросов является упрощением. Стоимость ориентировочная. Мы не можем знать, какова истинная стоимость выполнения цикла, пока не запустим цикл. SQLite делает предположения о стоимости выполнения цикла на основе доступности индексов и ограничений, найденных в предложении WHERE. Эти предположения обычно довольно хороши, но иногда они могут быть ошибочными. Использование команды &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; для сбора дополнительной статистической информации о базе данных иногда позволяет SQLite делать более точные предположения о стоимости.</target>
        </trans-unit>
        <trans-unit id="1c32ea8c1623df88595d5e28c3a4322ef70e185f" translate="yes" xml:space="preserve">
          <source>The preupdate hook interfaces were originally added to support the &lt;a href=&quot;sessionintro&quot;&gt;session&lt;/a&gt; extension.</source>
          <target state="translated">Интерфейсы ловушек перед обновлением были изначально добавлены для поддержки расширения &lt;a href=&quot;sessionintro&quot;&gt;сеанса&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="54aaab8c82da084a0f8a9658f2bc76535e494e38" translate="yes" xml:space="preserve">
          <source>The preupdate hook only fires for changes to real database tables; the preupdate hook is not invoked for changes to &lt;a href=&quot;../vtab&quot;&gt;virtual tables&lt;/a&gt; or to system tables like sqlite_master or sqlite_stat1.</source>
          <target state="translated">Ловушка preupdate срабатывает только при изменении реальных таблиц базы данных; ловушка preupdate не вызывается для изменений &lt;a href=&quot;../vtab&quot;&gt;виртуальных&lt;/a&gt; или системных таблиц, таких как sqlite_master или sqlite_stat1.</target>
        </trans-unit>
        <trans-unit id="56711536eb144f6abbe43b67b69a4f340bd68f45" translate="yes" xml:space="preserve">
          <source>The preupdate hook only fires for changes to real database tables; the preupdate hook is not invoked for changes to &lt;a href=&quot;../vtab&quot;&gt;virtual tables&lt;/a&gt; or to system tables like sqlite_sequence or sqlite_stat1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f619ca19c48dc2cd5df5d0de6abefa9c15ce6509" translate="yes" xml:space="preserve">
          <source>The preupdate hook only fires for changes to real database tables; the preupdate hook is not invoked for changes to &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt; or to system tables like sqlite_master or sqlite_stat1.</source>
          <target state="translated">Ловушка preupdate срабатывает только при изменении реальных таблиц базы данных; ловушка preupdate не вызывается для изменений &lt;a href=&quot;vtab&quot;&gt;виртуальных&lt;/a&gt; или системных таблиц, таких как sqlite_master или sqlite_stat1.</target>
        </trans-unit>
        <trans-unit id="f6985f034f86292cf6702a3b24e4e0140c1d7b08" translate="yes" xml:space="preserve">
          <source>The preupdate hook only fires for changes to real database tables; the preupdate hook is not invoked for changes to &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt; or to system tables like sqlite_sequence or sqlite_stat1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="548d335209dbce4d25a40d42ac27b0b5a00affc4" translate="yes" xml:space="preserve">
          <source>The previous discussion has treated searching and sorting as separate topics. But in practice, it is often the case that one wants to search and sort at the same time. Fortunately, it is possible to do this using a single index.</source>
          <target state="translated">В предыдущей дискуссии поиск и сортировка рассматривались как отдельные темы.Но на практике часто бывает так,что хочется искать и сортировать одновременно.К счастью,это можно сделать с помощью одного индекса.</target>
        </trans-unit>
        <trans-unit id="5a894252915223aa28176cd8caebb845eabbbe5b" translate="yes" xml:space="preserve">
          <source>The previous example is a specific case of a more general problem: The state of an SQLite database is controlled by both the database file and the journal file. In a quiescent state, the journal file does not exist and only the database file matters. But if the journal file does exist, it must be kept together with the database to avoid corruption. The following actions are all likely to lead to corruption:</source>
          <target state="translated">Предыдущий пример является частным случаем более общей проблемы:состояние базы данных SQLite контролируется как файлом базы данных,так и файлом журнала.В состоянии покоя файл журнала не существует и имеет значение только файл БД.Но если файл журнала действительно существует,то во избежание повреждения его необходимо хранить вместе с БД.Все перечисленные ниже действия могут привести к коррупции:</target>
        </trans-unit>
        <trans-unit id="96495b049cd011fd87b80d69ae6b3a8f79a60e9a" translate="yes" xml:space="preserve">
          <source>The previous example will return every row for which the _shape overlaps the polygon in the $query_polygon parameter. The geopoly_within() function works similarly, but only returns rows for which the _shape is completely contained within $query_polygon.</source>
          <target state="translated">В предыдущем примере будет возвращена каждая строка,для которой _shape перекрывает полигон в параметре $query_polygon.Функция geopoly_within()работает аналогично,но возвращает только те строки,для которых _shape полностью содержится в $query_polygon.</target>
        </trans-unit>
        <trans-unit id="493e14ba39e9f9ab43ab64d3b6be4b87292ba69a" translate="yes" xml:space="preserve">
          <source>The previous example, SQLite uses index &quot;i1&quot; to optimize a WHERE clause term of the form (a=?) - in this case &quot;a=1&quot;. The previous example could not use a &lt;a href=&quot;queryplanner#covidx&quot;&gt;covering index&lt;/a&gt;, but the following example can, and that fact is reflected in the output:</source>
          <target state="translated">В предыдущем примере SQLite использует индекс &amp;laquo;i1&amp;raquo; для оптимизации условия предложения WHERE формы (a =?) - в данном случае &amp;laquo;a = 1&amp;raquo;. В предыдущем примере нельзя было использовать &lt;a href=&quot;queryplanner#covidx&quot;&gt;индекс покрытия&lt;/a&gt; , но в следующем примере можно, и этот факт отражен в выходных данных:</target>
        </trans-unit>
        <trans-unit id="69c7b95e4071269d47577736bbe07ea0a083b117" translate="yes" xml:space="preserve">
          <source>The previous fix was not quite right. This one seems to work better.</source>
          <target state="translated">Предыдущее исправление было не совсем верным.Эта,кажется,работает лучше.</target>
        </trans-unit>
        <trans-unit id="fdab229cc2f18edd4b33bcf4f2dc07383013038b" translate="yes" xml:space="preserve">
          <source>The previous paragraph describes what happens when the synchronous pragma setting is &quot;full&quot;.</source>
          <target state="translated">В предыдущем параграфе описывается,что происходит,когда синхронная установка прагмы &quot;переполнена&quot;.</target>
        </trans-unit>
        <trans-unit id="af577bd70a120b3a01a3ee4e9c639a65b514f294" translate="yes" xml:space="preserve">
          <source>The previous paragraph is also true (separate database connections are isolated from one another) in &lt;a href=&quot;sharedcache&quot;&gt;shared cache mode&lt;/a&gt; as long as the &lt;a href=&quot;pragma#pragma_read_uncommitted&quot;&gt;read_uncommitted pragma&lt;/a&gt; remains turned off. The &lt;a href=&quot;pragma#pragma_read_uncommitted&quot;&gt;read_uncommitted pragma&lt;/a&gt; is off by default and so if the application does nothing to turn it on, it will remain off. Hence, unless the &lt;a href=&quot;pragma#pragma_read_uncommitted&quot;&gt;read_uncommitted pragma&lt;/a&gt; is used to change the default behavior, changes made by one database connection are invisible to readers on a different database connection sharing the same cache until the writer commits its transaction.</source>
          <target state="translated">Предыдущий абзац также верен (отдельные соединения с базой данных изолированы друг от друга) в &lt;a href=&quot;sharedcache&quot;&gt;режиме общего кэша,&lt;/a&gt; пока &lt;a href=&quot;pragma#pragma_read_uncommitted&quot;&gt;прагма read_uncommitted&lt;/a&gt; остается выключенной. &lt;a href=&quot;pragma#pragma_read_uncommitted&quot;&gt;Read_uncommitted Прагма&lt;/a&gt; отключена по умолчанию , и поэтому , если приложение не делает ничего , чтобы включить его, он останется выключенным. Следовательно, если &lt;a href=&quot;pragma#pragma_read_uncommitted&quot;&gt;прагма read_uncommitted&lt;/a&gt; не используется для изменения поведения по умолчанию, изменения, сделанные одним соединением с базой данных, невидимы для читателей в другом соединении с базой данных, использующих один и тот же кеш, пока писатель не зафиксирует свою транзакцию.</target>
        </trans-unit>
        <trans-unit id="4443bdbe2499eab3d6d488e897e8d552fc707661" translate="yes" xml:space="preserve">
          <source>The previous paragraph states that SQLite does not assume that sector writes are atomic. This is true by default. But as of SQLite version 3.5.0, there is a new interface called the Virtual File System (&lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;) interface. The &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; is the only means by which SQLite communicates to the underlying filesystem. The code comes with default VFS implementations for Unix and Windows and there is a mechanism for creating new custom VFS implementations at runtime. In this new VFS interface there is a method called xDeviceCharacteristics. This method interrogates the underlying filesystem to discover various properties and behaviors that the filesystem may or may not exhibit. The xDeviceCharacteristics method might indicate that sector writes are atomic, and if it does so indicate, SQLite will try to take advantage of that fact. But the default xDeviceCharacteristics method for both Unix and Windows does not indicate atomic sector writes and so these optimizations are normally omitted.</source>
          <target state="translated">В предыдущем абзаце говорится, что SQLite не предполагает, что запись в сектор является атомарной. Это верно по умолчанию. Но с версии SQLite 3.5.0 появился новый интерфейс, называемый интерфейсом виртуальной файловой системы ( &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; ). &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;- единственное средство, с помощью которого SQLite взаимодействует с базовой файловой системой. Код поставляется с реализациями VFS по умолчанию для Unix и Windows, и есть механизм для создания новых пользовательских реализаций VFS во время выполнения. В этом новом интерфейсе VFS есть метод под названием xDeviceCharacteristics. Этот метод опрашивает нижележащую файловую систему, чтобы обнаружить различные свойства и поведение, которые файловая система может или не может проявлять. Метод xDeviceCharacteristics может указывать на то, что запись в сектор является атомарной, и если это указывает, SQLite попытается воспользоваться этим фактом. Но метод xDeviceCharacteristics по умолчанию как для Unix, так и для Windows не указывает запись атомарного сектора, и поэтому эти оптимизации обычно не выполняются.</target>
        </trans-unit>
        <trans-unit id="342bf4dfcd7ddbf3e5538a244e6458410341ab97" translate="yes" xml:space="preserve">
          <source>The previous paragraphs describe the behavior of temporary databases under the default SQLite configuration. An application can use the &lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;temp_store pragma&lt;/a&gt; and the &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; compile-time parameter to force temporary databases to behave as pure in-memory databases, if desired.</source>
          <target state="translated">В предыдущих абзацах описывается поведение временных баз данных в конфигурации SQLite по умолчанию. Приложение может использовать &lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;прагму temp_store&lt;/a&gt; и параметр &lt;a href=&quot;compile#temp_store&quot;&gt;времени&lt;/a&gt; компиляции SQLITE_TEMP_STORE, чтобы при необходимости временные базы данных вели себя как чистые базы данных в памяти.</target>
        </trans-unit>
        <trans-unit id="6e1f293bab97b2b5f7895a766acf571a1f59dca9" translate="yes" xml:space="preserve">
          <source>The previous query is equivalent to the following:</source>
          <target state="translated">Предыдущий запрос эквивалентен следующему:</target>
        </trans-unit>
        <trans-unit id="2a8f5ff04cf0666d4b31c9cd45d0419954ccab05" translate="yes" xml:space="preserve">
          <source>The previous step created circle (1) in the diagram above. This step will create circle (2). Run the following command:</source>
          <target state="translated">На предыдущем этапе был создан круг (1)на диаграмме выше.На этом шаге будет создана окружность (2).Выполните следующую команду:</target>
        </trans-unit>
        <trans-unit id="73d4cf9a53d1a814d3d61247ac59a2dcf02d4a89" translate="yes" xml:space="preserve">
          <source>The primary page cache implementation is in the &lt;a href=&quot;https://sqlite.org/src/file/src/pager.c&quot;&gt;pager.c&lt;/a&gt; file. &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt; logic is in the separate &lt;a href=&quot;https://sqlite.org/src/file/src/wal.c&quot;&gt;wal.c&lt;/a&gt;. In-memory caching is implemented by the &lt;a href=&quot;https://sqlite.org/src/file/src/pcache.c&quot;&gt;pcache.c&lt;/a&gt; and &lt;a href=&quot;https://sqlite.org/src/file/src/pcache1.c&quot;&gt;pcache1.c&lt;/a&gt; files. The interface between page cache subsystem and the rest of SQLite is defined by the header file &lt;a href=&quot;https://sqlite.org/src/file/src/pager.h&quot;&gt;pager.h&lt;/a&gt;.</source>
          <target state="translated">Реализация кэша первичной страницы находится в файле &lt;a href=&quot;https://sqlite.org/src/file/src/pager.c&quot;&gt;pager.c&lt;/a&gt; . &lt;a href=&quot;wal&quot;&gt;Режим WAL&lt;/a&gt; логика находится в отдельном &lt;a href=&quot;https://sqlite.org/src/file/src/wal.c&quot;&gt;wal.c&lt;/a&gt; . Кэширование в памяти реализуется &lt;a href=&quot;https://sqlite.org/src/file/src/pcache.c&quot;&gt;файлами pcache.c&lt;/a&gt; и &lt;a href=&quot;https://sqlite.org/src/file/src/pcache1.c&quot;&gt;pcache1.c&lt;/a&gt; . Интерфейс между подсистемой кеширования страниц и остальной частью SQLite определяется заголовочным файлом &lt;a href=&quot;https://sqlite.org/src/file/src/pager.h&quot;&gt;pager.h&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="01bd1fccd0eb574f8649d147f7495318ef2ed3aa" translate="yes" xml:space="preserve">
          <source>The primary use of Lemon is to create the SQL language parser. A grammar file (&lt;a href=&quot;https://sqlite.org/src/file/src/parse.y&quot;&gt;parse.y&lt;/a&gt;) is compiled by Lemon into parse.c and parse.h. The parse.c file is incorporated into the &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt; without further modification.</source>
          <target state="translated">Основное использование Lemon - создание синтаксического анализатора языка SQL. Файл грамматики ( &lt;a href=&quot;https://sqlite.org/src/file/src/parse.y&quot;&gt;parse.y&lt;/a&gt; ) компилируется Lemon в parse.c и parse.h. Файл parse.c включается в &lt;a href=&quot;amalgamation&quot;&gt;объединение&lt;/a&gt; без дальнейших изменений.</target>
        </trans-unit>
        <trans-unit id="c694d6e20cc8030ef2cf2b05c8cbbbe628062074" translate="yes" xml:space="preserve">
          <source>The principal task of an SQL database engine is to evaluate SQL statements of SQL. To accomplish this, the developer needs two objects:</source>
          <target state="translated">Основной задачей движка базы данных SQL является оценка SQL выражений SQL.Для этого разработчику необходимы два объекта:</target>
        </trans-unit>
        <trans-unit id="cfcb012162b1a505da1f19d8786ad1f42bcacc75" translate="yes" xml:space="preserve">
          <source>The principle difference between FTS3/4 and FTS5 is that in FTS3/4, each instance-list is stored as a single large database record, whereas in FTS5 large instance-lists are divided between multiple database records. This has the following implications for dealing with large databases that contain large lists:</source>
          <target state="translated">Принципиальное различие между FTS3/4 и FTS5 заключается в том,что в FTS3/4 каждый экземпляр-лист хранится как одна большая запись базы данных,в то время как в FTS5 большие экземпляры-листы разделены между несколькими записями базы данных.Это имеет следующие последствия для работы с большими базами данных,содержащими большие списки:</target>
        </trans-unit>
        <trans-unit id="d7231b054e5abc6f0cfc5cc85f7e3279373f74d4" translate="yes" xml:space="preserve">
          <source>The printf() in SQLite supports new non-standard substitution types (&lt;a href=&quot;printf#percentq&quot;&gt;%q&lt;/a&gt;, &lt;a href=&quot;printf#percentq&quot;&gt;%Q&lt;/a&gt;, &lt;a href=&quot;printf#percentw&quot;&gt;%w&lt;/a&gt;, and &lt;a href=&quot;printf#percentz&quot;&gt;%z&lt;/a&gt;) that are useful both internally to SQLite and to applications using SQLite. Standard library printf()s cannot normally be extended in this way.</source>
          <target state="translated">Printf () в SQLite поддерживает новые нестандартные типы подстановки ( &lt;a href=&quot;printf#percentq&quot;&gt;% q&lt;/a&gt; , &lt;a href=&quot;printf#percentq&quot;&gt;% Q&lt;/a&gt; , &lt;a href=&quot;printf#percentw&quot;&gt;% w&lt;/a&gt; и &lt;a href=&quot;printf#percentz&quot;&gt;% z&lt;/a&gt; ), которые полезны как внутри SQLite, так и для приложений, использующих SQLite. Стандартная библиотека printf () s обычно не может быть расширена таким образом.</target>
        </trans-unit>
        <trans-unit id="0592c94ffabf868a1145cae373098959875b4ffd" translate="yes" xml:space="preserve">
          <source>The printf(FORMAT,...) SQL function works like the &lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_mprintf()&lt;/a&gt; C-language function and the printf() function from the standard C library. The first argument is a format string that specifies how to construct the output string using values taken from subsequent arguments. If the FORMAT argument is missing or NULL then the result is NULL. The %n format is silently ignored and does not consume an argument. The %p format is an alias for %X. The %z format is interchangeable with %s. If there are too few arguments in the argument list, missing arguments are assumed to have a NULL value, which is translated into 0 or 0.0 for numeric formats or an empty string for %s. See the &lt;a href=&quot;printf&quot;&gt;built-in printf()&lt;/a&gt; documentation for additional information.</source>
          <target state="translated">Функция SQL printf (FORMAT, ...) работает так же, как функция языка C &lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_mprintf ()&lt;/a&gt; и функция printf () из стандартной библиотеки C. Первый аргумент - это строка формата, указывающая, как построить строку вывода с использованием значений, взятых из последующих аргументов. Если аргумент FORMAT отсутствует или равен NULL, результатом будет NULL. Формат% n игнорируется и не использует аргумент. Формат% p - это псевдоним для% X. Формат% z взаимозаменяем с% s. Если в списке аргументов слишком мало аргументов, предполагается, что отсутствующие аргументы имеют значение NULL, которое преобразуется в 0 или 0,0 для числовых форматов или в пустую строку для% s. Дополнительную информацию см. Во &lt;a href=&quot;printf&quot;&gt;встроенной&lt;/a&gt; документации printf () .</target>
        </trans-unit>
        <trans-unit id="f7aa000e854fa1e51d2a8e3276f08d834816bb0a" translate="yes" xml:space="preserve">
          <source>The private memory cell is initialized to NULL by the first two instructions. Instructions 2 through 13 implement the inner SELECT statement against the examp2 table. Notice that instead of sending the result to a callback or storing the result on a sorter, the result of the query is pushed into the memory cell by instruction 10 and the loop is abandoned by the jump at instruction 11. The jump at instruction at 11 is vestigial and never executes.</source>
          <target state="translated">Первые две инструкции инициализируют личную ячейку памяти в NULL.Инструкции 2-13 реализуют внутреннее утверждение SELECT в сравнении с таблицей Examp2.Обратите внимание,что вместо того,чтобы отправить результат на обратный вызов или сохранить его на сортировщике,результат запроса заталкивается в ячейку памяти по команде 10,и цикл прекращается прыжком по команде 11.Прыжок на инструкцию 11 является рутинным и никогда не выполняется.</target>
        </trans-unit>
        <trans-unit id="576c1ad7241fb816002c325b35c536b5acba643f" translate="yes" xml:space="preserve">
          <source>The problem is that the indexes are not of equal quality. A check-in is likely to only have one child. So the first field of PLINK_I1 will usually narrow down the search to just a single row. But there are thousands and thousands check-ins tagged with &quot;trunk&quot;, so the first field of TAGXREF_I1 will be of little help in narrowing down the search.</source>
          <target state="translated">Проблема в том,что показатели не одинакового качества.Скорее всего,у зарегистрированного ребенка будет только один ребенок.Поэтому первое поле PLINK_I1 обычно сужает поиск до одной строки.Но есть тысячи и тысячи регистраций,помеченных &quot;багажником&quot;,поэтому первое поле TAGXREF_I1 будет малополезно в сужении поиска.</target>
        </trans-unit>
        <trans-unit id="4910b74e848d7f84054aa8b42c2da7951eb8cf1a" translate="yes" xml:space="preserve">
          <source>The problem of dynamic memory allocation, and specifically the problem of a memory allocator breakdown, has been studied by J. M. Robson and the results published as:</source>
          <target state="translated">Проблема динамического выделения памяти,а именно проблема пробоя аллокатора памяти,была изучена Дж.М.Робсоном и результаты опубликованы как:</target>
        </trans-unit>
        <trans-unit id="c0e48a1c7e6fc766c0233c83a22616959f0ed84b" translate="yes" xml:space="preserve">
          <source>The problem of finding the best query plan is equivalent to finding a minimum-cost path through the graph that visits each node exactly once.</source>
          <target state="translated">Проблема нахождения наилучшего плана запроса эквивалентна нахождению минимально затратного пути через граф,который посещает каждый узел ровно один раз.</target>
        </trans-unit>
        <trans-unit id="0f52798620170b176ff3d3af06fd50b65930b59c" translate="yes" xml:space="preserve">
          <source>The problem was fixed on 2011-02-20. The fix first appears in SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_6.html&quot;&gt;version 3.7.6&lt;/a&gt; (2011-04-12).</source>
          <target state="translated">Проблема устранена 20 февраля 2011 г. Исправление впервые появляется в SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_6.html&quot;&gt;версии 3.7.6&lt;/a&gt; (2011-04-12).</target>
        </trans-unit>
        <trans-unit id="0a9231ded77785fbf75b111ccef695ba60c384a1" translate="yes" xml:space="preserve">
          <source>The problem with looking up information by rowid is that you probably do not care what the price of &quot;item 4&quot; is - you want to know the price of peaches. And so a rowid lookup is not helpful.</source>
          <target state="translated">Проблема с поиском информации по rowid заключается в том,что вам наверняка все равно,какова цена &quot;п.4&quot;-вы хотите знать цену персиков.И поэтому поиск по шумовке не поможет.</target>
        </trans-unit>
        <trans-unit id="5ca928318271d59121bcae8c1e00c91157b277dc" translate="yes" xml:space="preserve">
          <source>The problem with this latter query is that it must apply the contained_in() function to millions of entries in the demo_data table. The use of the R*Tree in the penultimate query reduces the number of calls to contained_in() function to a small subset of the entire table. The R*Tree index did not find the exact answer itself, it merely limited the search space.</source>
          <target state="translated">Проблема этого последнего запроса заключается в том,что он должен применить функцию contain_in()к миллионам записей в таблице demo_data.Использование R*Tree в предпоследнем запросе уменьшает количество вызовов функции contain_in()до небольшого подмножества всей таблицы.Сам по себе индекс R*Tree не нашел точного ответа,а лишь ограничил пространство поиска.</target>
        </trans-unit>
        <trans-unit id="4d80ba47d569d0e4a2a3e8f3108543e7f76afec3" translate="yes" xml:space="preserve">
          <source>The procedure used to detect a</source>
          <target state="translated">Процедура,используемая для обнаружения</target>
        </trans-unit>
        <trans-unit id="7c5ac2fd9c78337a35d0c9980fe79b8e26f93a08" translate="yes" xml:space="preserve">
          <source>The process is explained at &lt;a href=&quot;http://wiki.tcl-lang.org/21708&quot;&gt;http://wiki.tcl-lang.org/21708&lt;/a&gt;.</source>
          <target state="translated">Этот процесс объясняется на &lt;a href=&quot;http://wiki.tcl-lang.org/21708&quot;&gt;http://wiki.tcl-lang.org/21708&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6eeaa105f7c556f91bf9c6156b767ca4d840a8c0" translate="yes" xml:space="preserve">
          <source>The progress callback can be used to display the status of a lengthy query or to process GUI events during a lengthy query.</source>
          <target state="translated">Обратный вызов прогресса может использоваться для отображения состояния длинного запроса или для обработки GUI-событий во время длинного запроса.</target>
        </trans-unit>
        <trans-unit id="c69ceeecbdd66434afc39e336822e8ab81198858" translate="yes" xml:space="preserve">
          <source>The progress handler callback must not do anything that will modify the database connection that invoked the progress handler. Note that &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; both modify their database connections for the meaning of &quot;modify&quot; in this paragraph.</source>
          <target state="translated">Обратный вызов обработчика прогресса не должен делать ничего, что могло бы изменить соединение с базой данных, вызвавшее обработчик прогресса. Обратите внимание, что &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; и &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step ()&lt;/a&gt; оба изменяют свои соединения с базой данных для значения слова &amp;laquo;изменить&amp;raquo; в этом абзаце.</target>
        </trans-unit>
        <trans-unit id="cfdeee9bdc15af91672d8ad9f38656051ea8a13d" translate="yes" xml:space="preserve">
          <source>The progress handler callback must not do anything that will modify the database connection that invoked the progress handler. Note that &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; and &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; both modify their database connections for the meaning of &quot;modify&quot; in this paragraph.</source>
          <target state="translated">Обратный вызов обработчика прогресса не должен делать ничего, что могло бы изменить соединение с базой данных, вызвавшее обработчик прогресса. Обратите внимание, что &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; и &lt;a href=&quot;step&quot;&gt;sqlite3_step ()&lt;/a&gt; оба изменяют свои соединения с базой данных для значения слова &amp;laquo;изменить&amp;raquo; в этом абзаце.</target>
        </trans-unit>
        <trans-unit id="d0b8dc8c8f3e20ba03797e52e7e128023b09d0a3" translate="yes" xml:space="preserve">
          <source>The properties of the &lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt; and &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE&lt;/a&gt; commands described above only apply if foreign keys are enabled. If the user considers them undesirable, then the workaround is to use &lt;a href=&quot;pragma#pragma_foreign_keys&quot;&gt;PRAGMA foreign_keys&lt;/a&gt; to disable foreign key constraints before executing the DROP or ALTER TABLE command. Of course, while foreign key constraints are disabled, there is nothing to stop the user from violating foreign key constraints and thus creating an internally inconsistent database.</source>
          <target state="translated">Свойства команд &lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt; и &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE,&lt;/a&gt; описанные выше, применяются только в том случае, если включены внешние ключи. Если пользователь считает их нежелательными, то обходной путь заключается в использовании &lt;a href=&quot;pragma#pragma_foreign_keys&quot;&gt;PRAGMA foreign_keys&lt;/a&gt; для отключения ограничений внешнего ключа перед выполнением команды DROP или ALTER TABLE. Конечно, хотя ограничения внешнего ключа отключены, ничто не мешает пользователю нарушить ограничения внешнего ключа и тем самым создать внутренне противоречивую базу данных.</target>
        </trans-unit>
        <trans-unit id="12341c72ae5851f82e7e9d06ed859f6acb79d027" translate="yes" xml:space="preserve">
          <source>The prover that determines whether any column of the right-hand table of a LEFT JOIN must be non-NULL in the WHERE clause is imperfect. It sometimes returns a false negative. In other words, it sometimes fails to reduce the strength of a LEFT JOIN when doing so was in fact possible. For example, the prover does not know the &lt;a href=&quot;lang_datefunc&quot;&gt;datetime() SQL function&lt;/a&gt; will always return NULL if its first argument is NULL, and so it will not recognize that the LEFT JOIN in the following query could be strength-reduced:</source>
          <target state="translated">Программа доказательства, которая определяет, должен ли какой-либо столбец правой таблицы LEFT JOIN иметь значение, отличное от NULL в предложении WHERE, является несовершенным. Иногда возвращает ложноотрицательный результат. Другими словами, иногда не удается уменьшить силу LEFT JOIN, когда это было фактически возможно. Например, доказывающая сторона не знает, что &lt;a href=&quot;lang_datefunc&quot;&gt;функция SQL datetime ()&lt;/a&gt; всегда будет возвращать NULL, если ее первый аргумент - NULL, и поэтому он не распознает, что LEFT JOIN в следующем запросе может быть уменьшено:</target>
        </trans-unit>
        <trans-unit id="48a058bacf71fa48c37c493961b3f8857c5bcde0" translate="yes" xml:space="preserve">
          <source>The psow query parameter overrides the &lt;a href=&quot;psow&quot;&gt;powersafe overwrite&lt;/a&gt; property of the database file being opened. The psow query parameter works with the default windows and unix &lt;a href=&quot;vfs&quot;&gt;VFSes&lt;/a&gt; but might be a no-op for other proprietary or non-standard VFSes.</source>
          <target state="translated">Параметр запроса &lt;a href=&quot;psow&quot;&gt;psow переопределяет&lt;/a&gt; свойство перезаписи в режиме powerafe для открываемого файла базы данных. Параметр запроса psow работает с Windows по умолчанию и &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; Unix, но может быть недоступен для других проприетарных или нестандартных VFS.</target>
        </trans-unit>
        <trans-unit id="ffe108cd06e0c16c268bec90ba5007639fcc32ef" translate="yes" xml:space="preserve">
          <source>The pthreads interface provides the pthread_cond_wait() function. This function allows the caller to simultaneously release a mutex and start waiting for an asynchronous signal. Using this function, a &quot;fired&quot; flag and a mutex, the race-condition described above may be eliminated as follows:</source>
          <target state="translated">Интерфейс pthreads предоставляет функцию pthread_cond_wait().Эта функция позволяет вызывающему абоненту одновременно освободить мьютекс и начать ожидание асинхронного сигнала.Используя эту функцию,&quot;выстрел&quot; флага и мьютекс,описанное выше состояние гонки может быть устранено следующим образом:</target>
        </trans-unit>
        <trans-unit id="5730c4be2fce644af4a3a0b4f7bf8a21afa9d144" translate="yes" xml:space="preserve">
          <source>The pthreads library is needed to make SQLite threadsafe. But since the CLI is single threaded, we could instruct SQLite to build in a non-threadsafe mode and thereby omit the pthreads library:</source>
          <target state="translated">Библиотека pthreads необходима для обеспечения потоковой безопасности SQLite.Но поскольку CLI является однопоточным,мы могли бы инструктировать SQLite строить в неритмически безопасном режиме и тем самым опустить библиотеку pthreads:</target>
        </trans-unit>
        <trans-unit id="ead084e5ac51c3a25e7e77f7295b3ad410aff0a2" translate="yes" xml:space="preserve">
          <source>The purpose of the master journal is to ensure that multi-file transactions are atomic across a power-loss. But if the database files have other settings that compromise integrity across a power-loss event (such as &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous=OFF&lt;/a&gt; or &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode=MEMORY&lt;/a&gt;) then the creation of the master journal is omitted, as an optimization.</source>
          <target state="translated">Задача главного журнала - обеспечить атомарность многофайловых транзакций при отключении питания. Но если в файлах базы данных есть другие настройки, которые нарушают целостность при отключении питания (например, &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous = OFF&lt;/a&gt; или &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode = MEMORY&lt;/a&gt; ), то создание главного журнала опускается в качестве оптимизации.</target>
        </trans-unit>
        <trans-unit id="80a4c796df15be02f28a9491edc718e0a6ad327d" translate="yes" xml:space="preserve">
          <source>The purpose of the other files and folders is presently unknown to the author but is probably not difficult to figure out.</source>
          <target state="translated">Назначение других файлов и папок в настоящее время неизвестно автору,но,вероятно,нетрудно выяснить.</target>
        </trans-unit>
        <trans-unit id="f221997932c715d1cdc1bd2a990d3e44e81c153a" translate="yes" xml:space="preserve">
          <source>The purpose of the super-journal is to ensure that multi-file transactions are atomic across a power-loss. But if the database files have other settings that compromise integrity across a power-loss event (such as &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous=OFF&lt;/a&gt; or &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode=MEMORY&lt;/a&gt;) then the creation of the super-journal is omitted, as an optimization.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ad934bb2af516663297a114c16808bb7efaf019" translate="yes" xml:space="preserve">
          <source>The purpose of the wal-index is to answer this question quickly:</source>
          <target state="translated">Цель wal-index-быстро ответить на этот вопрос:</target>
        </trans-unit>
        <trans-unit id="138e57468a79af5c77be9bf617137e42c028e084" translate="yes" xml:space="preserve">
          <source>The purpose of this document is to argue in favor of a fourth new category of application file format: An SQLite database file.</source>
          <target state="translated">Целью данного документа является аргументация в пользу четвертой новой категории формата файла заявки:Файл базы данных SQLite.</target>
        </trans-unit>
        <trans-unit id="a73682c963786c3512a8e2606835fb2fa3f30921" translate="yes" xml:space="preserve">
          <source>The purpose of this document is to brief the reader on how SQLite development team functions on a daily basis, as they continuously enhance the SQLite software and work to improve its already high reliability. The document achieves its purpose if a competent developer can be assimilated into the development team quickly after perusing this document.</source>
          <target state="translated">Цель данного документа-рассказать читателю о том,как ежедневно работает команда разработчиков SQLite,поскольку они постоянно совершенствуют программное обеспечение SQLite и работают над повышением его и без того высокой надежности.Документ достигает своей цели,если компетентный разработчик может быть быстро ассимилирован в команду разработчиков после ознакомления с ним.</target>
        </trans-unit>
        <trans-unit id="634e9e567d1f1f2dd99eda8c5536d500fa1e6e07" translate="yes" xml:space="preserve">
          <source>The push-down optimization cannot always be used. For example, if the subquery contains a LIMIT, then pushing down any part of the WHERE clause from the outer query could change the result of the inner query. There are other restrictions, explained in a comment in the source code on the pushDownWhereTerms() routine that implements this optimization.</source>
          <target state="translated">Оптимизация по нажатию не всегда может быть использована.Например,если подзапрос содержит LIMIT,то нажатие любой части выражения WHERE из внешнего запроса может изменить результат внутреннего запроса.Существуют и другие ограничения,описанные в комментарии к рутине pushDownWhereTerms(),реализующей эту оптимизацию.</target>
        </trans-unit>
        <trans-unit id="95403298754cba937ffb2896cd7e77d09dc82fdd" translate="yes" xml:space="preserve">
          <source>The quality management plan was originally composed by going through the description of outputs in section 11 of DO-178B (pages 48 through 56) and writing down those elements that seemed relevant to SQLite. The text will be subsequent revised to track enhancements to the SQLite quality process.</source>
          <target state="translated">Изначально план управления качеством был составлен путем просмотра описания результатов в разделе 11 DO-178B (страницы 48-56)и записи тех элементов,которые казались релевантными для SQLite.Текст будет впоследствии пересмотрен для отслеживания усовершенствований в процессе обеспечения качества SQLite.</target>
        </trans-unit>
        <trans-unit id="06064891cfb2016593d8db9b131661701e81d4c1" translate="yes" xml:space="preserve">
          <source>The query above could be made to run faster by using the FTS &lt;a href=&quot;fts3#matchinfo&quot;&gt;matchinfo&lt;/a&gt; function to determine the number of query term instances that appear in each result. The matchinfo function is much more efficient than the offsets function. Furthermore, the matchinfo function provides extra information regarding the overall number of occurrences of each query term in the entire document set (not just the current row) and the number of documents in which each query term appears. This may be used (for example) to attach a higher weight to less common terms which may increase the overall computed relevancy of those results the user considers more interesting.</source>
          <target state="translated">Вышеупомянутый запрос может выполняться быстрее, используя функцию FTS &lt;a href=&quot;fts3#matchinfo&quot;&gt;matchinfo&lt;/a&gt; для определения количества экземпляров термина запроса, которые появляются в каждом результате. Функция matchinfo намного эффективнее, чем функция смещений. Кроме того, функция matchinfo предоставляет дополнительную информацию об общем количестве вхождений каждого термина запроса во всем наборе документов (а не только в текущей строке) и количестве документов, в которых появляется каждый термин запроса. Это может использоваться (например) для придания более высокого веса менее распространенным терминам, что может увеличить общую вычисленную релевантность тех результатов, которые пользователь считает более интересными.</target>
        </trans-unit>
        <trans-unit id="418f38a31900c8102303fe91cea3cb03a0bfc91a" translate="yes" xml:space="preserve">
          <source>The query above could be rewritten as a join and without the use of row values:</source>
          <target state="translated">Вышеприведенный запрос можно переписать как соединительный и без использования значений строк:</target>
        </trans-unit>
        <trans-unit id="8505932c272eacf13a6ac016c3034294904230a0" translate="yes" xml:space="preserve">
          <source>The query above will return suggestions for the whole input word that begins with $prefix. The $wholeline parameter is all text from the beginning of the line up to the insertion point. The $wholeline parameter is used for context.</source>
          <target state="translated">Запрос,приведенный выше,вернет предложения для всего входного слова,которое начинается с $prefix.Параметр $wholeline-это весь текст от начала строки до точки вставки.Параметр $wholeline используется для контекста.</target>
        </trans-unit>
        <trans-unit id="f9921b4f3858e29c8d8f50be7ccdabc32d452e7c" translate="yes" xml:space="preserve">
          <source>The query above will use the po_parent index to help find the answer, since the po_parent index contains entries for all rows of interest. Note that since po_parent is smaller than a full index, the query will likely run faster too.</source>
          <target state="translated">В вышеприведенном запросе будет использован индекс po_parent для поиска ответа,так как индекс po_parent содержит записи для всех интересующих строк.Обратите внимание,что поскольку po_parent меньше полного индекса,запрос,скорее всего,будет выполняться быстрее.</target>
        </trans-unit>
        <trans-unit id="0190a12968e1ccf51186372beeb26ae3012cb0b9" translate="yes" xml:space="preserve">
          <source>The query above would very quickly locate the id of 1 even if the R*Tree contained millions of entries. The previous is an example of a &quot;contained-within&quot; query. The R*Tree also supports &quot;overlapping&quot; queries. For example, to find all bounding boxes that overlap the Charlotte area:</source>
          <target state="translated">Запрос,заданный выше,очень быстро определил бы идентификатор 1,даже если бы R*дерево содержало миллионы записей.Предыдущий-пример запроса &quot;Содержимое-внутри&quot;.R*дерево также поддерживает &quot;перекрывающиеся&quot; запросы.Например,чтобы найти все ограничивающие поля,которые перекрывают область Шарлотты:</target>
        </trans-unit>
        <trans-unit id="94364d8100096142da610b0a18f63efa10ad070a" translate="yes" xml:space="preserve">
          <source>The query component of a URI may contain parameters that are interpreted either by SQLite itself, or by a &lt;a href=&quot;../vfs&quot; id=&quot;coreuriqueryparameters&quot;&gt;custom VFS implementation&lt;/a&gt;. SQLite and its built-in &lt;a href=&quot;../vfs&quot;&gt;VFSes&lt;/a&gt; interpret the following query parameters:</source>
          <target state="translated">Компонент запроса URI может содержать параметры, которые интерпретируются либо самим SQLite, либо &lt;a href=&quot;../vfs&quot; id=&quot;coreuriqueryparameters&quot;&gt;специальной реализацией VFS&lt;/a&gt; . SQLite и его встроенные &lt;a href=&quot;../vfs&quot;&gt;VFS&lt;/a&gt; интерпретируют следующие параметры запроса:</target>
        </trans-unit>
        <trans-unit id="86e91a7c9e388f3708828edd53ce0492e58dcf0d" translate="yes" xml:space="preserve">
          <source>The query component of a URI may contain parameters that are interpreted either by SQLite itself, or by a &lt;a href=&quot;vfs&quot; id=&quot;coreuriqueryparameters&quot;&gt;custom VFS implementation&lt;/a&gt;. SQLite and its built-in &lt;a href=&quot;vfs&quot;&gt;VFSes&lt;/a&gt; interpret the following query parameters:</source>
          <target state="translated">Компонент запроса URI может содержать параметры, которые интерпретируются либо самим SQLite, либо &lt;a href=&quot;vfs&quot; id=&quot;coreuriqueryparameters&quot;&gt;специальной реализацией VFS&lt;/a&gt; . SQLite и его встроенные &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; интерпретируют следующие параметры запроса:</target>
        </trans-unit>
        <trans-unit id="f6f2f3df836d46d9540098c193cbe7de6978b27d" translate="yes" xml:space="preserve">
          <source>The query contains both a search restriction in the WHERE clause and a sort order in the ORDER BY clause. Both the search and the sort can be accomplished at the same time using the two-column index Idx3.</source>
          <target state="translated">Запрос содержит как ограничение на поиск в пункте WHERE,так и порядок сортировки в пункте ORDER BY.Поиск и сортировка могут быть выполнены одновременно с использованием двухколоночного индекса Idx3.</target>
        </trans-unit>
        <trans-unit id="bb441cf385ae38b5e50765b319372e3b2d5a50b2" translate="yes" xml:space="preserve">
          <source>The query does a binary search on the index to find the subset of rows that have fruit='Orange'. (Because the fruit column is the left-most column of the index and the rows of the index are in sorted order, all such rows will be adjacent.) Then it scans the matching index rows from top to bottom to get the rowids for the original table, and for each rowid does a binary search on the original table to find the price.</source>
          <target state="translated">Запрос выполняет двоичный поиск по индексу,чтобы найти подмножество строк,которые имеют плод='Оранжевый'.(Поскольку столбец фруктов-это самый левый столбец индекса,а строки индекса отсортированы в порядке,все такие строки будут соседними).Затем он сканирует соответствующие строки индекса сверху вниз,чтобы получить рядки для исходной таблицы,и для каждой рядки выполняет двоичный поиск по исходной таблице,чтобы найти цену.</target>
        </trans-unit>
        <trans-unit id="0da70d4a5a91c3bdacf749b9198a4a57a477e008" translate="yes" xml:space="preserve">
          <source>The query is not an aggregate</source>
          <target state="translated">Запрос не является совокупностью</target>
        </trans-unit>
        <trans-unit id="d5463ef5a6e2ace12b54dcf259b0837fe48d0c3a" translate="yes" xml:space="preserve">
          <source>The query loop is built from instructions 5 through 13. Instructions 6 through 8 build a record that contains the azData[] values for a single invocation of the callback. A sort key is generated by instructions 9 through 11. Instruction 12 combines the invocation record and the sort key into a single entry and puts that entry on the sort list.</source>
          <target state="translated">Цикл запросов строится из инструкций 5-13.Инструкции 6-8 строят запись,содержащую значения azData[]для одного вызова обратного вызова.Ключ сортировки генерируется командами с 9 по 11.Инструкция 12 объединяет запись вызова и ключ сортировки в одну запись и помещает эту запись в список сортировки.</target>
        </trans-unit>
        <trans-unit id="b89b1eb2c0211443a7be50a77507c951f5a3834f" translate="yes" xml:space="preserve">
          <source>The query loop is implemented by instructions 8 through 22. The aggregate key specified by the GROUP BY clause is computed by instructions 9 and 10. Instruction 11 causes the appropriate bucket to come into focus. If a bucket with the given key does not already exists, a new bucket is created and control falls through to instructions 12 and 13 which initialize the bucket. If the bucket does already exist, then a jump is made to instruction 14. The values of aggregate functions are updated by the instructions between 11 and 21. Instructions 14 through 18 update memory slot 1 to hold the next value &quot;min(three+four)&quot;. Then the sum of the &quot;four&quot; column is updated by instructions 19 through 21.</source>
          <target state="translated">Цикл запросов реализуется с помощью инструкций 8-22.Совокупный ключ,указанный в пункте GROUP BY,вычисляется с помощью инструкций 9 и 10.Инструкция 11 приводит к тому,что соответствующее ведро попадает в фокус.Если ведро с заданной клавишей еще не существует,создается новое ведро,и управление переходит к инструкциям 12 и 13,которые инициализируют ведро.Если ведро уже существует,то выполняется переход к инструкции 14.Значения агрегатных функций обновляются инструкциями между 11 и 21.Инструкции с 14 по 18 обновляют слот памяти 1 для удержания следующего значения &quot;min(three+four)&quot;.Затем сумма &quot;четырех&quot; столбцов обновляется командами с 19 по 21.</target>
        </trans-unit>
        <trans-unit id="a6ac9b746a0ebf6db3c5dac60c7fc4d3c527912f" translate="yes" xml:space="preserve">
          <source>The query optimizer might translate this into three separate constraints:</source>
          <target state="translated">Оптимизатор запросов может преобразовать это в три отдельных ограничения:</target>
        </trans-unit>
        <trans-unit id="ca7f72fc82a7c6f8223569dbd345a23847f45a71" translate="yes" xml:space="preserve">
          <source>The query optimizer now attempts to implement the ORDER BY clause using an index. Sorting is still used if not suitable index is available.</source>
          <target state="translated">Оптимизатор запросов теперь пытается реализовать выражение ORDER BY с помощью индекса.Сортировка по-прежнему используется,если нет подходящего индекса.</target>
        </trans-unit>
        <trans-unit id="074dd395e411c2a7564e05c9a803ff7d91501e5c" translate="yes" xml:space="preserve">
          <source>The query planner considers the LIMIT clause when estimating the cost of ORDER BY.</source>
          <target state="translated">Планировщик запросов учитывает пункт LIMIT при оценке стоимости ЗАКАЗЧИКА BY.</target>
        </trans-unit>
        <trans-unit id="efb22d31da7b95dc237d9b06fed089e63b961bd2" translate="yes" xml:space="preserve">
          <source>The query planner examines the values of bound parameters to help determine if a partial index is usable.</source>
          <target state="translated">Планировщик запросов изучает значения связанных параметров,чтобы определить,можно ли использовать частичный индекс.</target>
        </trans-unit>
        <trans-unit id="e51e3ffe015829441eac83092590224609d07ba7" translate="yes" xml:space="preserve">
          <source>The query planner in SQLite normally does a terrific job of selecting fast algorithms for running your SQL statements. This is true of the legacy query planner and even more true of the new NGQP. There may be an occasional situation where, due to incomplete information, the query planner selects a suboptimal plan. This will happen less often with the NGQP than with the legacy query planner, but it might still happen. Only in those rare cases do application developers need to get involved and help the query planner to do the right thing. In the common case, the NGQP is just a new enhancement to SQLite that makes the application run a little faster and which requires no new developer thought or action.</source>
          <target state="translated">Планировщик запросов в SQLite обычно делает потрясающую работу по выбору быстрых алгоритмов для выполнения ваших SQL-запросов.Это относится и к старому планировщику запросов,и к новому NGQP.Могут возникать ситуации,когда из-за неполноты информации планировщик запросов выбирает неоптимальный план.Это будет происходить реже в NGQP,чем в старом планировщике запросов,но все же может произойти.Только в этих редких случаях разработчикам приложений необходимо вмешаться и помочь планировщику запросов поступить правильно.В обычном случае NGQP-это просто новое усовершенствование SQLite,которое делает работу приложения немного быстрее и не требует от разработчика новых мыслей или действий.</target>
        </trans-unit>
        <trans-unit id="7056feb20ef72b761795635d81c08e5ed2af62a2" translate="yes" xml:space="preserve">
          <source>The query planner in future versions of SQLite might grow smart enough to make transformations such as the above automatically, in both directions. That is to say, future versions of SQLite might transform queries of the first form into the second, or queries written the second way into the first. As of SQLite version 3.22.0 (2018-01-22), the query planner will flatten the subquery if the outer query does not make use of any user-defined functions or subqueries in its result set. For the examples shown above, however, SQLite implements each of the queries as written.</source>
          <target state="translated">Планировщик запросов в будущих версиях SQLite может вырасти достаточно умным,чтобы автоматически выполнять преобразования,подобные вышеописанным,в обоих направлениях.То есть будущие версии SQLite могут преобразовывать запросы первой формы во вторую или запросы,написанные вторым способом,в первый.Начиная с версии SQLite 3.22.0 (2018-01-22),планировщик запросов будет планировать подзапросы,если внешний запрос не использует никаких пользовательских функций или подзапросов в своем результирующем множестве.Однако в приведенных выше примерах SQLite реализует каждый из запросов в том виде,в котором он был написан.</target>
        </trans-unit>
        <trans-unit id="f9ae7f14e38f472239e8cbf47519f9f962bf6c41" translate="yes" xml:space="preserve">
          <source>The query planner is able to optimize IN operators on &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt; even if the &lt;a href=&quot;vtab#xbestindex&quot;&gt;xBestIndex&lt;/a&gt; method does not set the sqlite3_index_constraint_usage.omit flag of the virtual table column to the left of the IN operator.</source>
          <target state="translated">Планировщик запросов может оптимизировать операторы IN для &lt;a href=&quot;vtab&quot;&gt;виртуальных таблиц,&lt;/a&gt; даже если метод &lt;a href=&quot;vtab#xbestindex&quot;&gt;xBestIndex&lt;/a&gt; не устанавливает флаг sqlite3_index_constraint_usage.omit столбца виртуальной таблицы слева от оператора IN.</target>
        </trans-unit>
        <trans-unit id="4b67d5103aec179badd00d13df4b687ed31a2fd8" translate="yes" xml:space="preserve">
          <source>The query planner is more aggressive about using &lt;a href=&quot;optoverview#autoindex&quot;&gt;automatic indexes&lt;/a&gt; for views and subqueries for which it is not possible to create a persistent index.</source>
          <target state="translated">Планировщик запросов более агрессивно использует &lt;a href=&quot;optoverview#autoindex&quot;&gt;автоматические индексы&lt;/a&gt; для представлений и подзапросов, для которых невозможно создать постоянный индекс.</target>
        </trans-unit>
        <trans-unit id="0ff80f93923c8ea0ed391da80428d773af3f58c7" translate="yes" xml:space="preserve">
          <source>The query planner is now able to use &lt;a href=&quot;partialindex&quot;&gt;partial indexes&lt;/a&gt; that contain AND-connected terms in the WHERE clause.</source>
          <target state="translated">Планировщик запросов теперь может использовать &lt;a href=&quot;partialindex&quot;&gt;частичные индексы&lt;/a&gt; , содержащие термины, соединенные И в предложении WHERE.</target>
        </trans-unit>
        <trans-unit id="f1bf26dc5394aa893fb29edbb88f7b0f3c1a3bf4" translate="yes" xml:space="preserve">
          <source>The query planner loads the content of the statistics tables into memory when the schema is read. Hence, when an application changes the statistics tables directly, SQLite will not immediately notice the changes. An application can force the query planner to reread the statistics tables by running &lt;b&gt;ANALYZE sqlite_master&lt;/b&gt;.</source>
          <target state="translated">Планировщик запросов загружает содержимое таблиц статистики в память при чтении схемы. Следовательно, когда приложение напрямую изменяет таблицы статистики, SQLite не сразу заметит изменения. Приложение может заставить планировщик запросов перечитать таблицы статистики, запустив &lt;b&gt;ANALYZE sqlite_master&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="b54043d2a3881a0e42bb93d2a4b188d8e3b927bd" translate="yes" xml:space="preserve">
          <source>The query planner loads the content of the statistics tables into memory when the schema is read. Hence, when an application changes the statistics tables directly, SQLite will not immediately notice the changes. An application can force the query planner to reread the statistics tables by running &lt;b&gt;ANALYZE sqlite_schema&lt;/b&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="764ebb928a21a2403e7ad4384e4177e72689b2ef" translate="yes" xml:space="preserve">
          <source>The query planner must decide between many possible implementations of this query, but two plans in particular are of note:</source>
          <target state="translated">Планировщик запросов должен выбирать между многими возможными реализациями этого запроса,но следует обратить внимание на два плана:</target>
        </trans-unit>
        <trans-unit id="35937457496b4c465e761e374d83f1c328cfb649" translate="yes" xml:space="preserve">
          <source>The query planner now does a better job of optimizing &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; accesses in a 3-way or higher join where constraints on the virtual table are split across two or more other tables of the join.</source>
          <target state="translated">Планировщик запросов теперь лучше справляется с оптимизацией доступа к &lt;a href=&quot;vtab&quot;&gt;виртуальным таблицам&lt;/a&gt; при трехстороннем или более высоком соединении, когда ограничения виртуальной таблицы разделяются между двумя или более другими таблицами соединения.</target>
        </trans-unit>
        <trans-unit id="ecefb9cd6e1de2d9ed81b2814e874ca9b432f553" translate="yes" xml:space="preserve">
          <source>The query planner now prefers to implement FROM-clause subqueries using &lt;a href=&quot;optoverview#coroutines&quot;&gt;co-routines&lt;/a&gt; rather using the &lt;a href=&quot;optoverview#flattening&quot;&gt;query flattener&lt;/a&gt; optimization. Support for the use of co-routines for subqueries may no longer be disabled.</source>
          <target state="translated">Планировщик запросов теперь предпочитает реализовывать подзапросы FROM-clause с помощью &lt;a href=&quot;optoverview#coroutines&quot;&gt;сопрограмм,&lt;/a&gt; а не с помощью оптимизации &lt;a href=&quot;optoverview#flattening&quot;&gt;сглаживания запросов&lt;/a&gt; . Поддержка использования сопрограмм для подзапросов больше не может быть отключена.</target>
        </trans-unit>
        <trans-unit id="39ca8ebd42e9f170c8e29a8cb05c453c4287996d" translate="yes" xml:space="preserve">
          <source>The query planner now recognizes that any column in the right-hand table of a LEFT JOIN can be NULL, even if that column has a NOT NULL constraint. Avoid trying to optimize out NULL tests in those cases. Fix for ticket &lt;a href=&quot;https://www.sqlite.org/src/info/6f2222d550f5b0ee7ed&quot;&gt;6f2222d550f5b0ee7ed&lt;/a&gt;.</source>
          <target state="translated">Планировщик запросов теперь распознает, что любой столбец в правой таблице LEFT JOIN может иметь значение NULL, даже если этот столбец имеет ограничение NOT NULL. Не пытайтесь оптимизировать тесты NULL в таких случаях. Исправление для билета &lt;a href=&quot;https://www.sqlite.org/src/info/6f2222d550f5b0ee7ed&quot;&gt;6f2222d550f5b0ee7ed&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ec8769590db8f2b5c877d645663be729be900155" translate="yes" xml:space="preserve">
          <source>The query planner now uses &lt;a href=&quot;fileformat2#stat4tab&quot;&gt;sqlite_stat4&lt;/a&gt; information (created by &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt;) to help determine if the &lt;a href=&quot;optoverview#skipscan&quot;&gt;skip-scan optimization&lt;/a&gt; is appropriate.</source>
          <target state="translated">Планировщик запросов теперь использует информацию &lt;a href=&quot;fileformat2#stat4tab&quot;&gt;sqlite_stat4&lt;/a&gt; (созданную &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; ), чтобы определить, подходит ли &lt;a href=&quot;optoverview#skipscan&quot;&gt;оптимизация&lt;/a&gt; с пропуском сканирования .</target>
        </trans-unit>
        <trans-unit id="c31a7ce3fe100e3f0ec40a06c5c355aa9ab9699f" translate="yes" xml:space="preserve">
          <source>The query planner used &lt;a href=&quot;fileformat2#stat1tab&quot;&gt;sqlite_stat1&lt;/a&gt;-style statistics for one or more indexes of the table at some point during the lifetime of the current connection.</source>
          <target state="translated">Планировщик запросов использовал статистику в стиле &lt;a href=&quot;fileformat2#stat1tab&quot;&gt;sqlite_stat1&lt;/a&gt; для одного или нескольких индексов таблицы в какой-то момент в течение времени жизни текущего соединения.</target>
        </trans-unit>
        <trans-unit id="a97e7a7c05ace47af23f942a5bb054692500ea21" translate="yes" xml:space="preserve">
          <source>The query planner uses a full scan of a &lt;a href=&quot;partialindex&quot;&gt;partial index&lt;/a&gt; instead of a full scan of the main table, in cases where that makes sense.</source>
          <target state="translated">Планировщик запросов использует полное сканирование &lt;a href=&quot;partialindex&quot;&gt;частичного индекса&lt;/a&gt; вместо полного сканирования основной таблицы в тех случаях, когда это имеет смысл.</target>
        </trans-unit>
        <trans-unit id="5c0c2991e6f563d6716af52b8b617039da1f2fdd" translate="yes" xml:space="preserve">
          <source>The query starts by doing a binary search on the Idx1 index for entries that have fruit='Peach'. SQLite can do this binary search on the Idx1 index but not on the original FruitsForSale table because the rows in Idx1 are sorted by the &quot;fruit&quot; column. Having found a row in the Idx1 index that has fruit='Peach', the database engine can extract the rowid for that row. Then the database engines does a second binary search on the original FruitsForSale table to find the original row that contains fruit='Peach'. From the row in the FruitsForSale table, SQLite can then extract the value of the price column. This procedure is illustrated by &lt;a href=&quot;#fig5&quot;&gt;figure 5&lt;/a&gt;.</source>
          <target state="translated">Запрос начинается с выполнения двоичного поиска по индексу Idx1 записей, в которых есть fruit = 'Peach'. SQLite может выполнять этот двоичный поиск по индексу Idx1, но не по исходной таблице FruitsForSale, потому что строки в Idx1 сортируются по столбцу &quot;фрукты&quot;. Найдя строку в индексе Idx1, у которой есть fruit = 'Peach', механизм базы данных может извлечь rowid для этой строки. Затем движки базы данных выполняют второй бинарный поиск в исходной таблице FruitsForSale, чтобы найти исходную строку, содержащую fruit = 'Peach'. Затем из строки таблицы FruitsForSale SQLite может извлечь значение столбца цен. Эта процедура показана на &lt;a href=&quot;#fig5&quot;&gt;рисунке 5&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7d2f0fdfeb4c2c835aff8667a9df0a76c56f4c48" translate="yes" xml:space="preserve">
          <source>The query string is optional. If the query string is present, then all query parameters are passed through into the xOpen method of the underlying &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;.</source>
          <target state="translated">Строка запроса не является обязательной. Если строка запроса присутствует, то все параметры запроса передаются в метод xOpen базовой &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="85170b302d04cae08fe65e554bbdfb1393e9fe62" translate="yes" xml:space="preserve">
          <source>The query syntax has been revised where necessary to remove ambiguities and to make it possible to escape special characters in query terms.</source>
          <target state="translated">Синтаксис запроса был изменен там,где это необходимо,чтобы удалить неясности и позволить избежать специальных символов в терминах запроса.</target>
        </trans-unit>
        <trans-unit id="6a08992b107064a2b4d32992f6db718c41160975" translate="yes" xml:space="preserve">
          <source>The query_only pragma prevents all changes to database files when enabled.</source>
          <target state="translated">Прагма query_only предотвращает все изменения в файлах базы данных,когда она включена.</target>
        </trans-unit>
        <trans-unit id="c11b766a9a9b16341cc1ae469b721f6d16c2804c" translate="yes" xml:space="preserve">
          <source>The query_only pragma prevents data changes on database files when enabled. When this pragma is enabled, any attempt to CREATE, DELETE, DROP, INSERT, or UPDATE will result in an &lt;a href=&quot;rescode#readonly&quot;&gt;SQLITE_READONLY&lt;/a&gt; error. However, the database is not truly read-only. You can still run a &lt;a href=&quot;wal#ckpt&quot;&gt;checkpoint&lt;/a&gt; or a &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; and the return value of the &lt;a href=&quot;c3ref/db_readonly&quot;&gt;sqlite3_db_readonly()&lt;/a&gt; routine is not affected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c227c47e0d2b0279a9dff3f8b02f840ecf77eb68" translate="yes" xml:space="preserve">
          <source>The quote(X) function returns the text of an SQL literal which is the value of its argument suitable for inclusion into an SQL statement. Strings are surrounded by single-quotes with escapes on interior quotes as needed. BLOBs are encoded as hexadecimal literals. Strings with embedded NUL characters cannot be represented as string literals in SQL and hence the returned string literal is truncated prior to the first NUL.</source>
          <target state="translated">Функция quote(X)возвращает текст SQL-литерала,который является значением его аргумента,подходящим для включения в SQL-оператор.Строки окружены одиночными кавычками с экранированиями на внутренних кавычках по мере необходимости.BLOB кодируются как шестнадцатеричные литералы.Строки со встроенными NUL-символами не могут быть представлены в SQL как строковые литералы,поэтому возвращаемый строковый литерал усекается до первого NUL.</target>
        </trans-unit>
        <trans-unit id="9f63b25a5004d971fa73a7b89854797c36e88a71" translate="yes" xml:space="preserve">
          <source>The random() function provides 64 bits of randomness instead of only 32 bits.</source>
          <target state="translated">Функция random()обеспечивает 64 бита случайности,а не только 32 бита.</target>
        </trans-unit>
        <trans-unit id="db5db9919e511217ef7da4b79216c59c757f004b" translate="yes" xml:space="preserve">
          <source>The random() function returns a pseudo-random integer between -9223372036854775808 and +9223372036854775807.</source>
          <target state="translated">Функция random()возвращает псевдослучайное целое число между -9223372036854775808 и +9223372036854775807.</target>
        </trans-unit>
        <trans-unit id="dc66046ce33b1a2430fa7d3f10cb359cc80fae20" translate="yes" xml:space="preserve">
          <source>The randomblob(N) function return an N-byte blob containing pseudo-random bytes. If N is less than 1 then a 1-byte random blob is returned.</source>
          <target state="translated">Функция randomblob(N)возвращает N-байтовый блок,содержащий псевдослучайные байты.Если N меньше 1,возвращается 1-байтовый случайный блок.</target>
        </trans-unit>
        <trans-unit id="c291d5ba33f13d62c916974b77fcaf954ce3ff7e" translate="yes" xml:space="preserve">
          <source>The rank of the column within the index. (0 means left-most. Key columns come before auxiliary columns.)</source>
          <target state="translated">Ранг столбца внутри индекса.(0 означает самый левый.Ключевые столбцы идут перед вспомогательными).</target>
        </trans-unit>
        <trans-unit id="0b2bd6ab8a45c757d36fc0179def745c6a1bbb66" translate="yes" xml:space="preserve">
          <source>The rank of the column within the index. (0 means left-most.)</source>
          <target state="translated">Ранг столбца внутри индекса.(0 означает самый левый.)</target>
        </trans-unit>
        <trans-unit id="463c4210effd7ad2a8dada3187acf9269beea08a" translate="yes" xml:space="preserve">
          <source>The rank of the column within the table being indexed, or -1 if the index-column is the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; of the table being indexed and -2 if the &lt;a href=&quot;expridx&quot;&gt;index is on an expression&lt;/a&gt;.</source>
          <target state="translated">Ранг столбца в индексируемой таблице или -1, если индекс-столбец является &lt;a href=&quot;lang_createtable#rowid&quot;&gt;идентификатором строки&lt;/a&gt; индексируемой таблицы, и -2, если &lt;a href=&quot;expridx&quot;&gt;индекс находится в выражении&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="84413b7d19914c0bede4000ce3b0ffb8491410c6" translate="yes" xml:space="preserve">
          <source>The rank of the column within the table being indexed. A value of -1 means &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; and a value of -2 means that an &lt;a href=&quot;expridx&quot;&gt;expression&lt;/a&gt; is being used.</source>
          <target state="translated">Ранг столбца в индексируемой таблице. Значение -1 означает &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid,&lt;/a&gt; а значение -2 означает, что используется &lt;a href=&quot;expridx&quot;&gt;выражение&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8754b3bec73ba7fde29d928b708ca495c5b77ae4" translate="yes" xml:space="preserve">
          <source>The rank of word.</source>
          <target state="translated">Чин слова.</target>
        </trans-unit>
        <trans-unit id="2dd609ed9718452c7fad1b16788c833004253127" translate="yes" xml:space="preserve">
          <source>The rank option is used to change the default auxiliary function mapping for the rank column. The option should be set to a text value in the same format as described for &lt;a href=&quot;fts5#sorting_by_auxiliary_function_results&quot;&gt;&quot;rank MATCH ?&quot;&lt;/a&gt; terms above. For example:</source>
          <target state="translated">Опция ранга используется для изменения отображения вспомогательной функции по умолчанию для столбца ранга. Параметр должен быть установлен на текстовое значение в том же формате, как описано для &lt;a href=&quot;fts5#sorting_by_auxiliary_function_results&quot;&gt;&quot;СООТВЕТСТВИЕ ранжированию?&quot; &lt;/a&gt;условия выше. Например:</target>
        </trans-unit>
        <trans-unit id="3e012920d09c510ffee894f9967688d5537ade9a" translate="yes" xml:space="preserve">
          <source>The rate of enhancement for SQLite over the previous five years (2010-2015) is approximately 6 increments of Y per year. The numbering format used by for &lt;a href=&quot;c3ref/c_source_id&quot;&gt;SQLITE_VERSION_NUMBER&lt;/a&gt; and &lt;a href=&quot;c3ref/libversion&quot;&gt;sqlite3_libversion_number()&lt;/a&gt; allows versions up to 3.999.999, which is more than enough for the planned end-of-support date for SQLite in 2050. However, the current tarball naming conventions only reserve two digits for the Y and so the naming format for downloads will need to be revised in about 2030.</source>
          <target state="translated">Скорость улучшения SQLite за предыдущие пять лет (2010-2015) составляет примерно 6 приращений Y в год. Формат нумерации, используемый для &lt;a href=&quot;c3ref/c_source_id&quot;&gt;SQLITE_VERSION_NUMBER&lt;/a&gt; и &lt;a href=&quot;c3ref/libversion&quot;&gt;sqlite3_libversion_number (),&lt;/a&gt; допускает версии до 3.999.999, что более чем достаточно для запланированной даты окончания поддержки SQLite в 2050 году. Однако текущие соглашения об именах архивов резервируют только две цифры для букву Y, поэтому примерно к 2030 году необходимо будет пересмотреть формат именования загрузок.</target>
        </trans-unit>
        <trans-unit id="e8a5095befc118ca6a6fec21354c920d6bd315d2" translate="yes" xml:space="preserve">
          <source>The reader algorithm in the previous paragraphs works correctly, but because frames for page P can appear anywhere within the WAL, the reader has to scan the entire WAL looking for page P frames. If the WAL is large (multiple megabytes is typical) that scan can be slow, and read performance suffers. To overcome this problem, a separate data structure called the wal-index is maintained to expedite the search for frames of a particular page.</source>
          <target state="translated">Алгоритм читателя в предыдущих параграфах работает правильно,но поскольку фреймы для страницы P могут появиться где угодно в пределах WAL,читателю придется сканировать всю WAL в поисках фреймов для страницы P.Если WAL большой (типично несколько мегабайт),то сканирование может быть медленным,а производительность чтения страдает.Для решения этой проблемы поддерживается отдельная структура данных,называемая wal-index,для ускорения поиска фреймов определенной страницы.</target>
        </trans-unit>
        <trans-unit id="3e2fc6a74baa30b6fadb3fd43bce3110d90f198d" translate="yes" xml:space="preserve">
          <source>The readfile(X) SQL function reads the entire content of the file named X and returns that content as a BLOB. This can be used to load content into a table. For example:</source>
          <target state="translated">SQL-функция readfile(X)читает все содержимое файла с именем X и возвращает это содержимое в виде BLOB.Это может быть использовано для загрузки содержимого в таблицу.Например:</target>
        </trans-unit>
        <trans-unit id="f5d4c0c9266d8eca05dca08f98a5cbf6d922d36a" translate="yes" xml:space="preserve">
          <source>The realization that an aggregate query is really two consecutive loops makes it much easier to understand the difference between a WHERE clause and a HAVING clause in SQL query statement. The WHERE clause is a restriction on the first loop and the HAVING clause is a restriction on the second loop. You can see this by adding both a WHERE and a HAVING clause to our example query:</source>
          <target state="translated">Понимание того,что совокупный запрос-это действительно два последовательных цикла,значительно облегчает понимание разницы между выражением WHERE и выражением HAVING в операторе SQL-запроса.Выражение WHERE-это ограничение на первый цикл,а выражение HAVING-на второй.Это можно увидеть,добавив в наш пример запроса и выражение WHERE,и выражение HAVING:</target>
        </trans-unit>
        <trans-unit id="4a5758542d7b569e5728a8a94a0c5f527ec1ddfe" translate="yes" xml:space="preserve">
          <source>The reallocarray() interface is a recent innovation (circa 2014) from the OpenBSD community that grow out of efforts to prevent the next &lt;a href=&quot;http://heartbleed.com&quot;&gt;&quot;heartbleed&quot; bug&lt;/a&gt; by avoiding 32-bit integer arithmetic overflow on memory allocation size computations. The reallocarray() function has both unit-size and count parameters. To allocate memory sufficient to hold an array of N elements each X-bytes in size, one calls &quot;reallocarray(0,X,N)&quot;. This is preferred over the traditional technique of invoking &quot;malloc(X*N)&quot; as reallocarray() eliminates the risk that the X*N multiplication will overflow and cause malloc() to return a buffer that is a different size from what the application expected.</source>
          <target state="translated">Интерфейс reallocarray () - это недавнее нововведение (около 2014 г.) сообщества OpenBSD, которое выросло из усилий по предотвращению следующей &lt;a href=&quot;http://heartbleed.com&quot;&gt;ошибки&lt;/a&gt; с &amp;laquo;сердечным кровотечением&amp;raquo; , избегая 32-битного целочисленного арифметического переполнения при вычислениях размера выделения памяти. Функция reallocarray () имеет параметры как размера единицы, так и числа. Чтобы выделить память, достаточную для хранения массива из N элементов размером каждого X байта, вызывается &amp;laquo;reallocarray (0, X, N)&amp;raquo;. Это предпочтительнее традиционной техники вызова malloc (X * N), поскольку reallocarray () устраняет риск того, что умножение X * N приведет к переполнению и заставит malloc () вернуть буфер, размер которого отличается от того, что приложение ожидается.</target>
        </trans-unit>
        <trans-unit id="a25a89f7da0624003a3e075ec1d5437a5611f942" translate="yes" xml:space="preserve">
          <source>The reason for attempting to read the</source>
          <target state="translated">Причина попытки прочитать</target>
        </trans-unit>
        <trans-unit id="61ed3e5eacc7786aa96400e0606560d6b0c2919c" translate="yes" xml:space="preserve">
          <source>The reason for this is easy to understand: When a document is inserted into the FTS5 table, an entry is added to the full-text index to record the position of each token within the new document. When a document is removed, the original data is required in order to determine the set of entries that need to be removed from the full-text index. So if the data supplied to FTS5 when a row is deleted using this command is different from that used to determine the set of token instances when it was inserted, some full-text index entries may not be correctly deleted, or FTS5 may try to remove index entries that do not exist. This can leave the full-text index in an unpredictable state, making future query results unreliable.</source>
          <target state="translated">Причину этого легко понять:Когда документ вставляется в таблицу FTS5,в полнотекстовый индекс добавляется запись о положении каждого маркера в новом документе.Когда документ удаляется,требуются исходные данные для определения набора записей,которые необходимо удалить из полнотекстового индекса.Таким образом,если данные,поступающие в FTS5 при удалении строки с помощью этой команды,отличаются от данных,используемых для определения набора экземпляров маркеров,когда они были вставлены,некоторые элементы полнотекстового индекса могут быть удалены некорректно,или FTS5 может попытаться удалить несуществующие элементы индекса.Это может привести к тому,что полнотекстовый индекс останется в непредсказуемом состоянии,что сделает результаты будущих запросов ненадежными.</target>
        </trans-unit>
        <trans-unit id="aaf49440241f0d03e40af262860c9b5798f65bc8" translate="yes" xml:space="preserve">
          <source>The reason that the &lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_snprintf()&lt;/a&gt; has its buffer pointer and buffer size arguments reversed from what is found in the standard library snprintf() routine is because there was no snprintf() routine in the standard C library when Hipp was first implementing his version, and he chose a different order than the designers of the standard C library.</source>
          <target state="translated">Причина, по которой &lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_snprintf ()&lt;/a&gt; имеет обратный указатель буфера и аргументы размера буфера по сравнению с подпрограммой snprintf () стандартной библиотеки, заключается в том, что в стандартной библиотеке C не было подпрограммы snprintf (), когда Хипп впервые реализовал свою версию, и он выбрал другой порядок, чем разработчики стандартной библиотеки C.</target>
        </trans-unit>
        <trans-unit id="791eaa4dd6fb2ae12ed4b869340107d40b780f17" translate="yes" xml:space="preserve">
          <source>The reasons why C is the best language to implement SQLite include:</source>
          <target state="translated">Причины,по которым C является лучшим языком для реализации SQLite,включают в себя:</target>
        </trans-unit>
        <trans-unit id="570c3cd1b218e89b5e9796c1a0c8bf3041d5fcd8" translate="yes" xml:space="preserve">
          <source>The recommended fix for this problem is to select a different filesystem. These days, there is a huge selection of high-performance, reliable, patent-free filesystems that support long filenames. Where possible, it is recommended that embedded devices use one of these other filesystems. This will avoid compatibility issues and the danger of &lt;a href=&quot;shortnames#db83corrupt&quot;&gt;database corruption caused by inconsistent use of 8+3 filenames&lt;/a&gt;.</source>
          <target state="translated">Рекомендуемое решение этой проблемы - выбрать другую файловую систему. В наши дни существует огромный выбор высокопроизводительных, надежных, свободных от патентов файловых систем, которые поддерживают длинные имена файлов. По возможности рекомендуется, чтобы встроенные устройства использовали одну из этих других файловых систем. Это позволит избежать проблем с совместимостью и опасности &lt;a href=&quot;shortnames#db83corrupt&quot;&gt;повреждения базы данных из-за непоследовательного использования имен файлов 8 + 3&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="25181bcaf1df8e046a1c955d3b9df90abb750621" translate="yes" xml:space="preserve">
          <source>The recommended setting is 0, meaning that double-quoted strings are disallowed in all contexts. However, the default setting is 3 for maximum compatibility with legacy applications.</source>
          <target state="translated">Рекомендуемое значение-0,что означает,что строки в двойных кавычках запрещены во всех контекстах.Однако по умолчанию установлено значение 3 для максимальной совместимости с устаревшими приложениями.</target>
        </trans-unit>
        <trans-unit id="932d02d128af056f356f5d45448ef957094cec8a" translate="yes" xml:space="preserve">
          <source>The recommended usage pattern for the &lt;a href=&quot;pragma#pragma_analysis_limit&quot;&gt;analysis_limit&lt;/a&gt; pragma is like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9e4e6885559253d0ddfdbd8cf19b8d22821af1f" translate="yes" xml:space="preserve">
          <source>The recommended way of creating, updating, listing, and extracting an SQLite Archive is to use the &lt;a href=&quot;cli&quot;&gt;sqlite3.exe command-line shell&lt;/a&gt; for SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_23_0.html&quot;&gt;version 3.23.0&lt;/a&gt; (2018-04-02) or later. This CLI supports the -A command-line option that allows easy management of SQLite Archives. The CLI for SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_22_0.html&quot;&gt;version 3.22.0&lt;/a&gt; (2018-01-22) has the &lt;a href=&quot;cli#sqlar&quot;&gt;.archive command&lt;/a&gt; for managing SQLite Archives, but that requires interacting with the shell.</source>
          <target state="translated">Рекомендуемый способ создания, обновления, перечисления и извлечения архива SQLite - использовать &lt;a href=&quot;cli&quot;&gt;оболочку командной строки &lt;/a&gt;&lt;a href=&quot;https://sqlite.org/releaselog/3_23_0.html&quot;&gt;sqlite3.exe&lt;/a&gt; для SQLite версии 3.23.0 (2018-04-02) или новее. Этот интерфейс командной строки поддерживает параметр командной строки -A, который позволяет легко управлять архивами SQLite. В CLI для SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_22_0.html&quot;&gt;версии 3.22.0&lt;/a&gt; (2018-01-22) есть команда &lt;a href=&quot;cli#sqlar&quot;&gt;.archive&lt;/a&gt; для управления архивами SQLite, но для этого требуется взаимодействие с оболочкой.</target>
        </trans-unit>
        <trans-unit id="4601afd19c62f4d6f4dd6a59905680482f9f3f16" translate="yes" xml:space="preserve">
          <source>The record format makes extensive use of the &lt;a href=&quot;fileformat2#varint&quot;&gt;variable-length integer&lt;/a&gt; or &lt;a href=&quot;fileformat2#varint&quot;&gt;varint&lt;/a&gt; representation of 64-bit signed integers defined above.</source>
          <target state="translated">Формат записи широко использует &lt;a href=&quot;fileformat2#varint&quot;&gt;целое число переменной длины&lt;/a&gt; или представление &lt;a href=&quot;fileformat2#varint&quot;&gt;varint&lt;/a&gt; 64-битных целых чисел со знаком, определенных выше.</target>
        </trans-unit>
        <trans-unit id="b82eef28a6cb7dd57ec4d49f060118580d2825f6" translate="yes" xml:space="preserve">
          <source>The recursive SELECT statements must be separated from the non-recursive SELECT statemens and from each other using by the UNION or UNION ALL operators. If there are two or more recursive SELECT statements, they all must be separated from each other using the same operator that separates the first recursive SELECT from the last non-recursive SELECT statement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f45dfeab7c8fdea2c19dfb3263b7e954261008d" translate="yes" xml:space="preserve">
          <source>The register P3 contains one less than the maximum number of allowed errors. At most reg(P3) errors will be reported. In other words, the analysis stops as soon as reg(P1) errors are seen. Reg(P1) is updated with the number of errors remaining.</source>
          <target state="translated">Регистр P3 содержит на одну ошибку меньше максимального количества допустимых ошибок.В большинстве случаев будут зарегистрированы ошибки reg(P3).Другими словами,анализ прекращается,как только обнаруживаются ошибки reg(P1).Reg(P1)обновляется с количеством оставшихся ошибок.</target>
        </trans-unit>
        <trans-unit id="b0a0f881a2de041dc76deecadc2825d6252c40fe" translate="yes" xml:space="preserve">
          <source>The registers P1 through P1+P2-1 contain a single row of results. This opcode causes the sqlite3_step() call to terminate with an SQLITE_ROW return code and it sets up the sqlite3_stmt structure to provide access to the r(P1)..r(P1+P2-1) values as the result row.</source>
          <target state="translated">Регистры P1-P1+P2-1 содержат один ряд результатов.Этот опкод вызывает завершение вызова sqlite3_step()кодом возврата SQLITE_ROW и устанавливает структуру sqlite3_stmt для предоставления доступа к значениям r(P1)...r(P1+P2-1)в виде строки результата.</target>
        </trans-unit>
        <trans-unit id="3af4c8adff2c9c78e4e3d405284a88188dcbb490" translate="yes" xml:space="preserve">
          <source>The registers released will be the P2 registers starting at P1, except if bit ii of P3 set, then do not release register P1+ii. In other words, P3 is a mask of registers to preserve.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ad008f7525662f6767cf59c0a5ffbf397455036" translate="yes" xml:space="preserve">
          <source>The relative precedence of the set operations is different. In particular, using the standard query syntax the &quot;OR&quot; operator has a higher precedence than &quot;AND&quot;. The precedence of operators when using the standard query syntax is:</source>
          <target state="translated">Относительная приоритетность заданных операций различна.В частности,при использовании стандартного синтаксиса запроса оператор &quot;ИЛИ&quot; имеет больший приоритет,чем &quot;И&quot;.При использовании стандартного синтаксиса запроса операторы имеют приоритет:</target>
        </trans-unit>
        <trans-unit id="4055a7e54aa1eb8dd8ef4889c3d207a5659a2b35" translate="yes" xml:space="preserve">
          <source>The release build is used to validate the generated machine code.</source>
          <target state="translated">Конструкция выпуска используется для проверки сгенерированного машинного кода.</target>
        </trans-unit>
        <trans-unit id="4fe1d3a13dd63ed4836e434d893dc270763cfe84" translate="yes" xml:space="preserve">
          <source>The release checklist is continuously evolving. As new problems or potential problems are discovered, new checklist items are added to make sure those problems do not appear in subsequent releases. The release checklist has proven to be an invaluable tool in helping to ensure that nothing is overlooked during the release process.</source>
          <target state="translated">Контрольный список выпусков постоянно развивается.По мере обнаружения новых проблем или потенциальных проблем,добавляются новые пункты контрольного списка,чтобы убедиться,что эти проблемы не появятся в последующих релизах.Контрольный список выпусков оказался неоценимым инструментом,помогающим убедиться в том,что ничто не будет упущено из виду в процессе выпуска.</target>
        </trans-unit>
        <trans-unit id="54fb9bcb3273ff541df78c3b4ae7a5c1d95caf43" translate="yes" xml:space="preserve">
          <source>The release checklist is not automated: developers run each item on the checklist manually. We find that it is important to keep a human in the loop. Sometimes problems are found while running a checklist item even though the test itself passed. It is important to have a human reviewing the test output at the highest level, and constantly asking &quot;Is this really right?&quot;</source>
          <target state="translated">Контрольный список выпуска не автоматизирован:разработчики запускают каждый пункт контрольного списка вручную.Мы считаем,что важно держать человека в курсе дела.Иногда проблемы обнаруживаются при запуске элемента контрольного списка,несмотря на то,что сам тест прошел.Важно,чтобы человек просматривал результат теста на самом высоком уровне и постоянно спрашивал:&quot;Это правда?&quot;.</target>
        </trans-unit>
        <trans-unit id="2c9d643524e4e559789769fa0d9c05fd5ba6364a" translate="yes" xml:space="preserve">
          <source>The relevancy of a document may depend on something other than just the data available in the return value of matchinfo. For example each document in the database may be assigned a static weight based on factors unrelated to its content (origin, author, age, number of references etc.). These values can be stored by the application in a separate table that can be joined against the documents table in the sub-query so that the rank function may access them.</source>
          <target state="translated">Актуальность документа может зависеть не только от данных,доступных в возвращаемом значении совпадения.Например,каждому документу в базе данных может быть присвоен статический вес,основанный на факторах,не связанных с его содержанием (происхождение,автор,возраст,количество ссылок и т.д.).Эти значения могут быть сохранены приложением в отдельной таблице,которая может быть объединена с таблицей документов в подзапросе,чтобы к ним мог получить доступ ранговый функционал.</target>
        </trans-unit>
        <trans-unit id="d03714ee4fa95f4e8679f472e2f3c59cc9a47883" translate="yes" xml:space="preserve">
          <source>The reliability and robustness of SQLite is achieved in part by thorough and careful testing.</source>
          <target state="translated">Надежность и надежность SQLite достигается отчасти благодаря тщательному и тщательному тестированию.</target>
        </trans-unit>
        <trans-unit id="7a3157bd64ab9a637ba9a36bada2711bd2147294" translate="yes" xml:space="preserve">
          <source>The remainder of this document will guide the reader through the steps needed to maintain a private branch. The general idea is the same as outlined above. This section merely provides more detail.</source>
          <target state="translated">Остальная часть этого документа поможет читателю разобраться в шагах,необходимых для поддержания частного филиала.Общая идея аналогична изложенной выше.Этот раздел содержит лишь более подробную информацию.</target>
        </trans-unit>
        <trans-unit id="30a538553e382aa8cfb9498b6fd827480cf2d80b" translate="yes" xml:space="preserve">
          <source>The remaining fields of the &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object all store pointers to functions that implement primitive operations. We call these &quot;methods&quot;. The first method, xOpen, is used to open files on the underlying storage media. The result is an &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; object. There are additional methods, defined by the &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; object itself that are used to read and write and close the file. The additional methods are detailed below. The filename is in UTF-8. SQLite will guarantee that the zFilename string passed to xOpen() is a full pathname as generated by xFullPathname() and that the string will be valid and unchanged until xClose() is called. So the &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; can store a pointer to the filename if it needs to remember the filename for some reason. The flags argument to xOpen() is a copy of the flags argument to sqlite3_open_v2(). If sqlite3_open() or sqlite3_open16() is used, then flags is &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_READWRITE&lt;/a&gt; | &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_CREATE&lt;/a&gt;. If xOpen() opens a file read-only then it sets *pOutFlags to include &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_READONLY&lt;/a&gt;. Other bits in *pOutFlags may be set. SQLite will also add one of the following flags to the xOpen() call, depending on the object being opened:</source>
          <target state="translated">Все остальные поля объекта &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; хранят указатели на функции, реализующие примитивные операции. Мы называем это &amp;laquo;методами&amp;raquo;. Первый метод, xOpen, используется для открытия файлов на нижележащем носителе. Результатом является объект &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; . Существуют дополнительные методы, определяемые самим объектом &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; , которые используются для чтения, записи и закрытия файла. Дополнительные методы подробно описаны ниже. Имя файла в кодировке UTF-8. SQLite гарантирует, что строка zFilename, переданная в xOpen (), является полным путем, сгенерированным xFullPathname (), и что строка будет действительной и неизменной до вызова xClose (). Итак, &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt;может хранить указатель на имя файла, если ему по какой-то причине необходимо запомнить имя файла. Аргумент flags функции xOpen () является копией аргумента flags функции sqlite3_open_v2 (). Если используется sqlite3_open () или sqlite3_open16 (), тогда flags - &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_READWRITE&lt;/a&gt; | &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_CREATE&lt;/a&gt; . Если xOpen () открывает файл только для чтения, он устанавливает * pOutFlags для включения &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_READONLY&lt;/a&gt; . Другие биты в * pOutFlags могут быть установлены. SQLite также добавит один из следующих флагов к вызову xOpen (), в зависимости от открываемого объекта:</target>
        </trans-unit>
        <trans-unit id="75ee3ed9cd8aa1cdca7e660d366395ab9cdd104b" translate="yes" xml:space="preserve">
          <source>The remaining seven methods defined by this structure (xMutexAlloc, xMutexFree, xMutexEnter, xMutexTry, xMutexLeave, xMutexHeld and xMutexNotheld) implement the following interfaces (respectively):</source>
          <target state="translated">Остальные семь методов,определяемые этой структурой (xMutexAlloc,xMutexFree,xMutexEnter,xMutexTry,xMutexLeave,xMutexHeld и xMutexNotheld)реализуют следующие интерфейсы (соответственно):</target>
        </trans-unit>
        <trans-unit id="01d5ccb02fb58f9483b8bb4a6c89788e5e99328d" translate="yes" xml:space="preserve">
          <source>The remove_diacritics option is not supported.</source>
          <target state="translated">Опция remove_diacritics не поддерживается.</target>
        </trans-unit>
        <trans-unit id="5dc3bfc4e2330eb1c8eb7d47b9e9b34b4b7effb1" translate="yes" xml:space="preserve">
          <source>The remove_diacritics option may be set to &quot;0&quot;, &quot;1&quot; or &quot;2&quot;. The default value is &quot;1&quot;. If it is set to &quot;1&quot; or &quot;2&quot;, then diacritics are removed from Latin script characters as described above. However, if it is set to &quot;1&quot;, then diacritics are not removed in the fairly uncommon case where a single unicode codepoint is used to represent a character with more that one diacritic. For example, diacritics are not removed from codepoint 0x1ED9 (&quot;LATIN SMALL LETTER O WITH CIRCUMFLEX AND DOT BELOW&quot;). This is technically a bug, but cannot be fixed without creating backwards compatibility problems. If this option is set to &quot;2&quot;, then diacritics are correctly removed from all Latin characters.</source>
          <target state="translated">Опция remove_diacritics может быть установлена на &quot;0&quot;,&quot;1&quot; или &quot;2&quot;.Значение по умолчанию-&quot;1&quot;.Если установлено &quot;1&quot; или &quot;2&quot;,то диакритические знаки удаляются из символов латинского алфавита,как описано выше.Однако,если установлено значение &quot;1&quot;,то диакритические знаки не удаляются в достаточно редком случае,когда для представления символа с более чем одним диакритическим знаком используется одна юникодная кодовая точка.Например,диакритические знаки не удаляются из кодовой точки 0x1ED9 (&quot;LATIN SMALL LETTER O WITH CIRCUMFLEX AND DOT BELOW&quot;).Технически это ошибка,но она не может быть исправлена без создания проблем с обратной совместимостью.Если эта опция установлена в &quot;2&quot;,то диакритические знаки правильно удаляются из всех латинских символов.</target>
        </trans-unit>
        <trans-unit id="e878b1555960f1149f69c44e721edf9e3c3726dd" translate="yes" xml:space="preserve">
          <source>The replace(X,Y,Z) function returns a string formed by substituting string Z for every occurrence of string Y in string X. The &lt;a href=&quot;datatype3#collation&quot;&gt;BINARY&lt;/a&gt; collating sequence is used for comparisons. If Y is an empty string then return X unchanged. If Z is not initially a string, it is cast to a UTF-8 string prior to processing.</source>
          <target state="translated">Функция replace (X, Y, Z) возвращает строку, образованную заменой строки Z на каждое вхождение строки Y в строке X. &lt;a href=&quot;datatype3#collation&quot;&gt;Двоичная&lt;/a&gt; последовательность сортировки используется для сравнений. Если Y - пустая строка, вернуть X без изменений. Если Z изначально не является строкой, перед обработкой он преобразуется в строку UTF-8.</target>
        </trans-unit>
        <trans-unit id="7d84cb3d97dd720ff83b043f47169f048a42ed9d" translate="yes" xml:space="preserve">
          <source>The repository created in the previous step is initially empty. The next step is to load the baseline SQLite release - circle (1) in the diagram above.</source>
          <target state="translated">Репозиторий,созданный на предыдущем этапе,изначально пуст.На следующем этапе необходимо загрузить базовый релиз SQLite-круг (1)на диаграмме выше.</target>
        </trans-unit>
        <trans-unit id="10c2d611bbd1154503c3d2f589b7893620f36217" translate="yes" xml:space="preserve">
          <source>The reserved region is an area of unused space at the end of every page (except the locking page) that extensions can use to hold per-page information. The size of the reserved region is determined by the one-byte unsigned integer found at an offset of 20 into the database file header. The size of the reserved region is usually zero.</source>
          <target state="translated">Зарезервированная область-это область неиспользованного пространства в конце каждой страницы (за исключением зарезервированной страницы),которую расширения могут использовать для хранения информации на каждую страницу.Размер зарезервированной области определяется однобайтовым беззнаковым целым числом,находящимся со смещением 20 в заголовке файла БД.Размер зарезервированного региона обычно равен нулю.</target>
        </trans-unit>
        <trans-unit id="5406b5dfde9f00d0738ba2c75a1507fa33caf617" translate="yes" xml:space="preserve">
          <source>The reserved region.</source>
          <target state="translated">Зарезервированный регион.</target>
        </trans-unit>
        <trans-unit id="aad9068a01cab0c1ed6f0408e5a3ca43105c9476" translate="yes" xml:space="preserve">
          <source>The response of SQLite to out-of-memory (OOM) errors is tested using a specialized memory allocator overlay that can simulate memory failures. The overlay is a layer that is inserted in between the memory allocator and the rest of SQLite. The overlay passes most memory allocation requests straight through to the underlying allocator and passes the results back up to the requester. But the overlay can be set to cause the Nth memory allocation to fail. To run an OOM test, the overlay is first set to fail on the first allocation attempt. Then some test script is run and verification that the allocation was correctly caught and handled is made. Then the overlay is set to fail on the second allocation and the test repeats. The failure point continues to advance one allocation at a time until the entire test procedure runs to completion without hitting a memory allocation error. This whole test sequence run twice. On the first pass, the overlay is set to fail only the Nth allocation. On the second pass, the overlay is set to fail the Nth and all subsequent allocations.</source>
          <target state="translated">Реакция SQLite на ошибки вне памяти (OOM)проверяется с помощью специализированного оверлея аллокатора памяти,который может имитировать сбои в памяти.Оверлей-это слой,который вставляется между аллокатором памяти и остальной частью SQLite.Оверлей передает большинство запросов на выделение памяти прямо к соответствующему аллокатору и передает результаты обратно запросчику.Но оверлей можно настроить так,чтобы N-ый аллокатор памяти не справился с выделением памяти.Для запуска теста OOM оверлей сначала устанавливается на неудачу при первой попытке выделения памяти.Затем выполняется какой-то тестовый скрипт и производится проверка,что выделение было корректно поймано и обработано.Затем оверлей устанавливается как неудачный при второй попытке выделения памяти,и тест повторяется.Точка отказа продолжает продвигаться по одному распределению за раз до тех пор,пока вся процедура теста не завершится без ошибки выделения памяти.Вся эта тестовая последовательность выполняется дважды.При первом проходе оверлей устанавливается на неудачное N-е распределение.При втором проходе оверлей устанавливается на неудачное N-е и все последующие выделения.</target>
        </trans-unit>
        <trans-unit id="12691a5bbec67aa65e24fe31d2477402bd3c4199" translate="yes" xml:space="preserve">
          <source>The rest of the module structure consists of methods used to implement various features of the virtual table. Details on what each of these methods do are provided in the sequel.</source>
          <target state="translated">Остальная часть модульной структуры состоит из методов,используемых для реализации различных возможностей виртуальной таблицы.Подробная информация о том,что каждый из этих методов делает,приведена в сиквеле.</target>
        </trans-unit>
        <trans-unit id="4c062c28bf53cd1153a7f659fc941fb25e4394ee" translate="yes" xml:space="preserve">
          <source>The result column names generated for compound subqueries have been simplified to show only the name of the column of the original table and omit the table name. This makes SQLite operate more like other SQL database engines.</source>
          <target state="translated">Имена столбцов результата,сгенерированные для составных подзапросов,были упрощены,чтобы показать только имя столбца исходной таблицы и опустить имя таблицы.Это делает SQLite более похожим на другие движки баз данных SQL.</target>
        </trans-unit>
        <trans-unit id="8fba3a08c8f1c5c3b4c188d84f260675274f7bae" translate="yes" xml:space="preserve">
          <source>The result of &quot;(1,2,3)=(1,NULL,3)&quot; is NULL because the result might be true if we replaced NULL&amp;rarr;2 or false if we replaced NULL&amp;rarr;9. The result of &quot;(1,2,3)=(1,NULL,4)&quot; is not NULL because there is no substitutions of the constituent NULL that will make the expression true, since 3 will never equal 4 in the third column.</source>
          <target state="translated">Результатом &amp;laquo;(1,2,3) = (1, NULL, 3)&amp;raquo; является NULL, потому что результат может быть истинным, если мы заменим NULL &amp;rarr; 2, или false, если мы заменим NULL &amp;rarr; 9. Результат &amp;laquo;(1,2,3) = (1, NULL, 4)&amp;raquo; не является NULL, потому что нет никаких замен составляющих NULL, которые сделают выражение истинным, поскольку 3 никогда не будет равно 4 в третьем столбце.</target>
        </trans-unit>
        <trans-unit id="8f8beef2187bafe894f67b36f4b351c6bf0083c2" translate="yes" xml:space="preserve">
          <source>The result of an IN or NOT IN operator is determined by the following matrix:</source>
          <target state="translated">Результат работы оператора IN или NOT IN определяется следующей матрицей:</target>
        </trans-unit>
        <trans-unit id="61365ffa3c163a280c658c5edf1eb2a5c12ca346" translate="yes" xml:space="preserve">
          <source>The result of any binary operator is either a numeric value or NULL, except for the</source>
          <target state="translated">Результатом любого двоичного оператора является либо числовое значение,либо NULL,кроме</target>
        </trans-unit>
        <trans-unit id="efe84f22635d66f10495dd8d63c09814ab5f5a9a" translate="yes" xml:space="preserve">
          <source>The result of combining all input changesets together is obtained by the application via a call to sqlite3changegroup_output().</source>
          <target state="translated">Результат объединения всех входных изменяемых параметров вместе получается приложением с помощью вызова sqlite3changegroup_output().</target>
        </trans-unit>
        <trans-unit id="bf374835b6b23f4254068862fbe80fd36859e25a" translate="yes" xml:space="preserve">
          <source>The result of opening a file is an instance of an &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; object. The &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; object is an abstract base class defined as follows:</source>
          <target state="translated">Результатом открытия файла является экземпляр объекта &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; . Объект &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; - это абстрактный базовый класс, определенный следующим образом:</target>
        </trans-unit>
        <trans-unit id="8384d1099fcb8eaa40cfc52c9ccfbf281fc795df" translate="yes" xml:space="preserve">
          <source>The result of the compound select is sent to the callback routine by the loop at instructions 22 through 25. There is nothing new or remarkable about this loop, except for the fact that the Column instruction at 23 will be extracting a column out of the record key rather than the record data.</source>
          <target state="translated">Результат выбора соединения посылается в программу обратного вызова петлей в соответствии с инструкциями с 22 по 25.В этом цикле нет ничего нового и примечательного,кроме того,что команда &quot;Столбец на 23&quot; будет извлекать столбец из ключа записи,а не данные записи.</target>
        </trans-unit>
        <trans-unit id="a2285b0635d880f7a2485fe902caef319bce2b4f" translate="yes" xml:space="preserve">
          <source>The result of this last example should be every unique value of the &quot;two&quot; column in the examp table, except any value that is in the &quot;four&quot; column of examp2 is removed. The code to implement this query is as follows:</source>
          <target state="translated">Результатом этого последнего примера должно быть каждое уникальное значение столбца &quot;два&quot; в экзаменационной таблице,за исключением любого значения,которое находится в столбце &quot;четыре&quot; экзамена2.Код для реализации данного запроса выглядит следующим образом:</target>
        </trans-unit>
        <trans-unit id="ccf7a73ae578c847fadf3966512c178de5c0acda" translate="yes" xml:space="preserve">
          <source>The result of total() is always a floating point value. The result of sum() is an integer value if all non-NULL inputs are integers. If any input to sum() is neither an integer or a NULL then sum() returns a floating point value which might be an approximation to the true sum.</source>
          <target state="translated">Результатом функции total()всегда является значение с плавающей точкой.Результат функции sum()является целочисленным значением,если все не нулевые входы являются целыми числами.Если любой вход sum()не является ни целым числом,ни NULL,то sum()возвращает значение с плавающей точкой,которое может быть аппроксимацией к истинной сумме.</target>
        </trans-unit>
        <trans-unit id="3501cb60eee256e312e1519991e5a4a97f468bc9" translate="yes" xml:space="preserve">
          <source>The result shown above (0.0000011126) is the correct answer. But if you do this computation using binary64 floating-point, the answer you get is 0.00000095367431640625 - an error of about 14%. If you do many similar computations as part of your program, the errors add up so that your final result might be completely meaningless.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a6fa042949920d8ab9a65592e82f3922c405d35" translate="yes" xml:space="preserve">
          <source>The resulting &quot;sqlite3.c&quot; amalgamation code file (and its associated header file &quot;sqlite3.h&quot;) can then be moved to a non-unix platform for final compilation using a native compiler.</source>
          <target state="translated">Полученный в результате слияния файл с кодом &quot;sqlite3.c&quot; (и связанный с ним заголовочный файл &quot;sqlite3.h&quot;)можно переместить на нефиксированную платформу для окончательной компиляции с помощью родного компилятора.</target>
        </trans-unit>
        <trans-unit id="e2d2e1926aa6ddaac2f60d9749f53fb11268ec2a" translate="yes" xml:space="preserve">
          <source>The results of a comparison depend on the storage classes of the operands, according to the following rules:</source>
          <target state="translated">Результаты сравнения зависят от классов хранения операндов,по следующим правилам:</target>
        </trans-unit>
        <trans-unit id="32d9d0342a63956078e67d37802198109f0decfd" translate="yes" xml:space="preserve">
          <source>The results presented here come with the following caveats:</source>
          <target state="translated">Представленные здесь результаты содержат следующие предостережения:</target>
        </trans-unit>
        <trans-unit id="0aa6d6ab54b80d454b7163f11aaed1a126d7a246" translate="yes" xml:space="preserve">
          <source>The return value from both sqlite3_soft_heap_limit64() and sqlite3_hard_heap_limit64() is the size of the heap limit prior to the call, or negative in the case of an error. If the argument N is negative then no change is made to the heap limit. Hence, the current size of heap limits can be determined by invoking sqlite3_soft_heap_limit64(-1) or sqlite3_hard_heap_limit(-1).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9310ef8309cce9fab8d7528f6f21efe5cbb34c7" translate="yes" xml:space="preserve">
          <source>The return value from sqlite3_soft_heap_limit64() is the size of the soft heap limit prior to the call, or negative in the case of an error. If the argument N is negative then no change is made to the soft heap limit. Hence, the current size of the soft heap limit can be determined by invoking sqlite3_soft_heap_limit64() with a negative argument.</source>
          <target state="translated">Возвращаемое из sqlite3_soft_heap_limit64()значение-это размер лимита мягкой кучи до вызова,или отрицательное в случае ошибки.Если аргумент N отрицательный,то лимит мягкой кучи не изменяется.Следовательно,текущий размер лимита мягкой кучи можно определить,вызвав sqlite3_soft_heap_limit64()с отрицательным аргументом.</target>
        </trans-unit>
        <trans-unit id="b9ca53c6554299d5eae8ef584802645a6046ae33" translate="yes" xml:space="preserve">
          <source>The return value indicates the final state of the indirect flag: 0 if it is clear, or 1 if it is set.</source>
          <target state="translated">Возвращаемое значение указывает на конечное состояние опосредованного флага:0,если он чист,или 1,если он установлен.</target>
        </trans-unit>
        <trans-unit id="7ce2179f1a4d84a59cb420b693cc86ea07338afc" translate="yes" xml:space="preserve">
          <source>The return value indicates the final state of the session object: 0 if the session is disabled, or 1 if it is enabled.</source>
          <target state="translated">Возвращаемое значение указывает на конечное состояние объекта сеанса:0,если сеанс выключен,или 1,если он включен.</target>
        </trans-unit>
        <trans-unit id="cae4bd57ed056db33a88f07df4b39cc7f3ccb51d" translate="yes" xml:space="preserve">
          <source>The return value of the &lt;a href=&quot;c3ref/threadsafe&quot;&gt;sqlite3_threadsafe()&lt;/a&gt; interface is determined by the compile-time threading mode selection. If single-thread mode is selected at compile-time, then &lt;a href=&quot;c3ref/threadsafe&quot;&gt;sqlite3_threadsafe()&lt;/a&gt; returns false. If either the multi-thread or serialized modes are selected, then &lt;a href=&quot;c3ref/threadsafe&quot;&gt;sqlite3_threadsafe()&lt;/a&gt; returns true. The &lt;a href=&quot;c3ref/threadsafe&quot;&gt;sqlite3_threadsafe()&lt;/a&gt; interface predates the multi-thread mode and start-time and run-time mode selection and so is unable to distinguish between multi-thread and serialized mode nor is it able to report start-time or run-time mode changes.</source>
          <target state="translated">Возвращаемое значение интерфейса &lt;a href=&quot;c3ref/threadsafe&quot;&gt;sqlite3_threadsafe ()&lt;/a&gt; определяется выбором режима многопоточности во время компиляции. Если во время компиляции выбран однопоточный режим, &lt;a href=&quot;c3ref/threadsafe&quot;&gt;sqlite3_threadsafe ()&lt;/a&gt; возвращает false. Если выбран многопоточный или сериализованный режимы, &lt;a href=&quot;c3ref/threadsafe&quot;&gt;sqlite3_threadsafe ()&lt;/a&gt; возвращает true. Интерфейс &lt;a href=&quot;c3ref/threadsafe&quot;&gt;sqlite3_threadsafe ()&lt;/a&gt; предшествует многопоточному режиму и выбору режима времени запуска и времени выполнения и поэтому не может различать многопоточный и сериализованный режим, а также не может сообщать об изменениях режима запуска или времени выполнения.</target>
        </trans-unit>
        <trans-unit id="39d80cd93bcac1fdb374e9a2b5c0dd95b400a1d6" translate="yes" xml:space="preserve">
          <source>The return value of the &lt;b&gt;sqlite_open&lt;/b&gt; function is a pointer to an opaque &lt;b&gt;sqlite&lt;/b&gt; structure. This pointer will be the first argument to all subsequent SQLite function calls that deal with the same database. NULL is returned if the open fails for any reason.</source>
          <target state="translated">Возвращаемое значение функции &lt;b&gt;sqlite_open&lt;/b&gt; - указатель на непрозрачную структуру &lt;b&gt;sqlite&lt;/b&gt; . Этот указатель будет первым аргументом для всех последующих вызовов функций SQLite, имеющих дело с той же базой данных. NULL возвращается, если открытие не удалось по какой-либо причине.</target>
        </trans-unit>
        <trans-unit id="6ab6c5924ac478fb10f4cbca37723d1a21ffdbb3" translate="yes" xml:space="preserve">
          <source>The returned string pointer is valid until either the &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; is destroyed by &lt;a href=&quot;#sqlite3_finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt; or until the statement is automatically reprepared by the first call to &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; for a particular run or until the next call to sqlite3_column_name() or sqlite3_column_name16() on the same column.</source>
          <target state="translated">Возвращенный строковый указатель действителен до тех пор, пока &lt;a href=&quot;#sqlite3_stmt&quot;&gt;подготовленный оператор не&lt;/a&gt; будет уничтожен &lt;a href=&quot;#sqlite3_finalize&quot;&gt;sqlite3_finalize (),&lt;/a&gt; или пока оператор не будет автоматически представлен первым вызовом &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step ()&lt;/a&gt; для определенного запуска, или до следующего вызова sqlite3_column_name () или sqlite3_column_name16 () на тот же столбец.</target>
        </trans-unit>
        <trans-unit id="b378f46326a64f9ce7b892670372ed936b24e5cc" translate="yes" xml:space="preserve">
          <source>The returned string pointer is valid until either the &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; is destroyed by &lt;a href=&quot;finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt; or until the statement is automatically reprepared by the first call to &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; for a particular run or until the next call to sqlite3_column_name() or sqlite3_column_name16() on the same column.</source>
          <target state="translated">Возвращенный строковый указатель действителен до тех пор, пока &lt;a href=&quot;stmt&quot;&gt;подготовленный оператор не&lt;/a&gt; будет уничтожен &lt;a href=&quot;finalize&quot;&gt;sqlite3_finalize (),&lt;/a&gt; или пока оператор не будет автоматически представлен первым вызовом &lt;a href=&quot;step&quot;&gt;sqlite3_step ()&lt;/a&gt; для определенного запуска, или до следующего вызова sqlite3_column_name () или sqlite3_column_name16 () на тот же столбец.</target>
        </trans-unit>
        <trans-unit id="bee83cce7953088554432a61ef6e85ee98f1b384" translate="yes" xml:space="preserve">
          <source>The rewritten expression above is conceptual; WHERE clauses containing OR are not really rewritten this way. The actual implementation of the OR clause uses a mechanism that is more efficient and that works even for &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables or tables in which the &quot;rowid&quot; is inaccessible. But the essence of the implementation is captured by the statement above: Separate indices are used to find candidate result rows from each OR clause term and the final result is the union of those rows.</source>
          <target state="translated">Переписанное выше выражение является концептуальным; Предложения WHERE, содержащие OR, на самом деле не переписываются таким образом. Фактическая реализация предложения OR использует механизм, который более эффективен и работает даже для таблиц &lt;a href=&quot;withoutrowid&quot;&gt;БЕЗ ROWID&lt;/a&gt; или таблиц, в которых &quot;rowid&quot; недоступен. Но суть реализации отражена в приведенном выше утверждении: отдельные индексы используются для поиска строк результатов-кандидатов из каждого члена предложения OR, а конечный результат - это объединение этих строк.</target>
        </trans-unit>
        <trans-unit id="cbb9e35f3e4288e3a391570d497ad6531d2b29a9" translate="yes" xml:space="preserve">
          <source>The rewritten expression above is conceptual; WHERE clauses containing OR are not really rewritten this way. The actual implementation of the OR clause uses a mechanism that is more efficient and that works even for &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables or tables in which the &quot;rowid&quot; is inaccessible. Nevertheless, the essence of the implementation is captured by the statement above: Separate indexes are used to find candidate result rows from each OR clause term and the final result is the union of those rows.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bd2a272126ae7fe0bcc8e6d37c8017e55bcc2f1" translate="yes" xml:space="preserve">
          <source>The rewritten term then might go on to constrain an index using the normal rules for *IN* operators. Note that</source>
          <target state="translated">Затем переписанный термин может быть использован для ограничения индекса,используя обычные правила для операторов *IN*.Обратите внимание,что</target>
        </trans-unit>
        <trans-unit id="ef14765b49eac9a83db5b6d2871d0bce22ce3fcc" translate="yes" xml:space="preserve">
          <source>The rewritten term then might go on to constrain an index using the normal rules for &lt;b&gt;IN&lt;/b&gt; operators. Note that</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0930df338a07de9990756603662657ba4f08d89" translate="yes" xml:space="preserve">
          <source>The right-hand operand of an IN or NOT IN operator has no affinity if the operand is a list and has the same affinity as the affinity of the result set expression if the operand is a SELECT.</source>
          <target state="translated">Правый операнд оператора IN или NOT IN не имеет сродства,если операнд является списком и имеет такое же сродство,как и сродство выражения результирующего множества,если операнд является ВЫБОРНЫМ (SELECT).</target>
        </trans-unit>
        <trans-unit id="066626c86d12ae463e5bc63db194f29a635a8420" translate="yes" xml:space="preserve">
          <source>The right-hand side of the IN operator can now be a list of expressions instead of just a list of constants</source>
          <target state="translated">Справа от оператора IN теперь может быть список выражений,а не просто список констант</target>
        </trans-unit>
        <trans-unit id="5c40f29b907e12e70ce95f7046453c736453580d" translate="yes" xml:space="preserve">
          <source>The right-hand side of the LIKE or GLOB must be either a string literal or a &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameter&lt;/a&gt; bound to a string literal that does not begin with a wildcard character.</source>
          <target state="translated">Правая часть LIKE или GLOB должна быть либо строковым литералом, либо &lt;a href=&quot;lang_expr#varparam&quot;&gt;параметром,&lt;/a&gt; привязанным к строковому литералу, который не начинается с символа подстановки.</target>
        </trans-unit>
        <trans-unit id="b4246dd614eb68d70df4434b2497d819d23353bb" translate="yes" xml:space="preserve">
          <source>The right-hand table of the LEFT JOIN is not be used anywhere in the query outside of its own USING or ON clause.</source>
          <target state="translated">Правая таблица ЛЕВОГО СОВЕТА не используется нигде в запросе вне его собственного пункта USING или ON.</target>
        </trans-unit>
        <trans-unit id="fc3dd2572b5bfa090299b30f5d81e58803cff0cb" translate="yes" xml:space="preserve">
          <source>The right-hand-side of the MATCH or = operator must be a constant expression that evaluates to a string consisting of the auxiliary function to invoke, followed by zero or more comma separated arguments within parenthesis. Arguments must be SQL literals. For example:</source>
          <target state="translated">Правая часть оператора MATCH или=должна быть константным выражением,которое вычисляет к строке,состоящей из вспомогательной функции для вызова,за которой следует аргумент,разделенный нулем или более запятыми в круглых скобках.Аргументами должны быть SQL-литералы.Например:</target>
        </trans-unit>
        <trans-unit id="60bf6a0aa9c141c91d3c15f81e63af1fbe6058ec" translate="yes" xml:space="preserve">
          <source>The right-most SELECT of the compound select must not make use of &lt;a href=&quot;lang_aggfunc&quot;&gt;aggregate&lt;/a&gt; or &lt;a href=&quot;windowfunctions&quot;&gt;window functions&lt;/a&gt;.</source>
          <target state="translated">Крайний правый SELECT в составном select не должен использовать &lt;a href=&quot;lang_aggfunc&quot;&gt;агрегатные&lt;/a&gt; или &lt;a href=&quot;windowfunctions&quot;&gt;оконные функции&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7b1ae3c5986255800fb2859410b2b4acb04d2122" translate="yes" xml:space="preserve">
          <source>The rollback journal contains a small header (shown in green in the diagram) that records the original size of the database file. So if a change causes the database file to grow, we will still know the original size of the database. The page number is stored together with each database page that is written into the rollback journal.</source>
          <target state="translated">Журнал отката содержит небольшой заголовок (показан на диаграмме зеленым цветом),в котором записывается исходный размер файла базы данных.Таким образом,если изменение приводит к росту файла базы данных,мы все равно будем знать исходный размер базы данных.Номер страницы хранится вместе с каждой страницей БД,которая записывается в журнал отката.</target>
        </trans-unit>
        <trans-unit id="1c053ab6c700ac534ac79f62078cfd2e255f73f2" translate="yes" xml:space="preserve">
          <source>The rollback journal does not contain the name of a master journal file (see &lt;a href=&quot;#section_5_5&quot;&gt;section 5.5&lt;/a&gt; below) or if does contain the name of a master journal, then that master journal file exists.</source>
          <target state="translated">Журнал отката не содержит имени главного файла журнала (см. &lt;a href=&quot;#section_5_5&quot;&gt;Раздел 5.5&lt;/a&gt; ниже) или, если он содержит имя главного журнала, то этот главный файл журнала существует.</target>
        </trans-unit>
        <trans-unit id="070c8fccacf99462797ddd5845e4bd8960ffcf17" translate="yes" xml:space="preserve">
          <source>The rollback journal does not contain the name of a super-journal file (see &lt;a href=&quot;#section_5_5&quot;&gt;section 5.5&lt;/a&gt; below) or if does contain the name of a super-journal, then that super-journal file exists.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e312e9592f38c1d0abcf1823ca656ae6dc24729" translate="yes" xml:space="preserve">
          <source>The rollback journal exists.</source>
          <target state="translated">Журнал отката существует.</target>
        </trans-unit>
        <trans-unit id="a6a9ff12c8273f443fb56b2bd7d0ab6853333cef" translate="yes" xml:space="preserve">
          <source>The rollback journal file can be deleted,</source>
          <target state="translated">Файл журнала отката может быть удален,</target>
        </trans-unit>
        <trans-unit id="841baedc01f54f9ab6f694a5b23bcc695e5f21f1" translate="yes" xml:space="preserve">
          <source>The rollback journal file can be truncated to zero length, or</source>
          <target state="translated">Файл журнала отката может быть усечен до нулевой длины,или</target>
        </trans-unit>
        <trans-unit id="31415ebe9f384149b021a50dd2fb2ee645763262" translate="yes" xml:space="preserve">
          <source>The rollback journal is</source>
          <target state="translated">Журнал отката</target>
        </trans-unit>
        <trans-unit id="08afad671df0d2c575466e5f9fe1a518b69a6c6b" translate="yes" xml:space="preserve">
          <source>The rollback journal is a file associated with each SQLite database file that holds information used to restore the database file to its initial state during the course of a transaction. The rollback journal file is always located in the same directory as the database file and has the same name as the database file but with the string &quot;&lt;code&gt;-journal&lt;/code&gt;&quot; appended. There can only be a single rollback journal associated with a give database and hence there can only be one write transaction open against a single database at one time.</source>
          <target state="translated">Журнал отката - это файл, связанный с каждым файлом базы данных SQLite, который содержит информацию, используемую для восстановления файла базы данных в исходное состояние в ходе транзакции. Файл журнала отката всегда находится в том же каталоге, что и файл базы данных, и имеет то же имя, что и файл базы данных, но с добавленной строкой &amp;laquo; &lt;code&gt;-journal&lt;/code&gt; &amp;raquo;. Может быть только один журнал отката, связанный с данной базой данных, и, следовательно, может быть только одна транзакция записи, открытая для одной базы данных одновременно.</target>
        </trans-unit>
        <trans-unit id="8a29cd2d15ece2c4c624bfe95a88741dea324ccf" translate="yes" xml:space="preserve">
          <source>The rollback journal is complete and intact on disk when the power is restored. This is a key point. The reason for the flush operation in &lt;a href=&quot;#section_3_7&quot;&gt;step 3.7&lt;/a&gt; is to make absolutely sure that all of the rollback journal is safely on nonvolatile storage prior to making any changes to the database file itself.</source>
          <target state="translated">Журнал отката будет полным и сохранится на диске после восстановления питания. Это ключевой момент. Причина операции сброса на &lt;a href=&quot;#section_3_7&quot;&gt;шаге 3.7&lt;/a&gt; состоит в том, чтобы до внесения каких-либо изменений в сам файл базы данных убедиться, что весь журнал отката безопасно находится в энергонезависимой памяти.</target>
        </trans-unit>
        <trans-unit id="5d1b7832cc643f77f52a69083206bb3b5fc3e74c" translate="yes" xml:space="preserve">
          <source>The rollback journal is not an empty file.</source>
          <target state="translated">Журнал отката не является пустым файлом.</target>
        </trans-unit>
        <trans-unit id="194c559058723739212e12d7c3749019f8df5f55" translate="yes" xml:space="preserve">
          <source>The root page numbers of all tables in the database are integers stored in P4_INTARRAY argument.</source>
          <target state="translated">Номера корневых страниц всех таблиц в БД-это целые числа,которые хранятся в аргументе P4_INTARRAY.</target>
        </trans-unit>
        <trans-unit id="a973ad8403210b9b222fd26c2aef5b8f2808389c" translate="yes" xml:space="preserve">
          <source>The round(X,Y) function returns a floating-point value X rounded to Y digits to the right of the decimal point. If the Y argument is omitted, it is assumed to be 0.</source>
          <target state="translated">Функция round(X,Y)возвращает значение с плавающей точкой X,округленное до Y цифр справа от десятичной запятой.Если аргумент Y опущен,то предполагается,что он равен 0.</target>
        </trans-unit>
        <trans-unit id="5fa12ab6f93c055083bc1a95b917e71f9cff725b" translate="yes" xml:space="preserve">
          <source>The routines &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt;, &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt;, &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare16()&lt;/a&gt;, &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare16_v2()&lt;/a&gt;, &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec()&lt;/a&gt;, and &lt;a href=&quot;c3ref/free_table&quot;&gt;sqlite3_get_table()&lt;/a&gt; accept an SQL statement list (sql-stmt-list) which is a semicolon-separated list of statements.</source>
          <target state="translated">Подпрограммы &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; , &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare ()&lt;/a&gt; , &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare16 ()&lt;/a&gt; , &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare16_v2 ()&lt;/a&gt; , &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec ()&lt;/a&gt; и &lt;a href=&quot;c3ref/free_table&quot;&gt;sqlite3_get_table ()&lt;/a&gt; принимают список операторов SQL (sql-stmt-list), который представляет собой список операторов, разделенных точкой с запятой.</target>
        </trans-unit>
        <trans-unit id="94230b7f00353328063595629d48ef7be9fce389" translate="yes" xml:space="preserve">
          <source>The row-value notation is useful for updating two or more columns of a table from the result of a single query. An example of this is in the full-text search feature of the &lt;a href=&quot;https://www.fossil-scm.org/&quot;&gt;Fossil version control system&lt;/a&gt;.</source>
          <target state="translated">Обозначение значения строки полезно для обновления двух или более столбцов таблицы из результата одного запроса. Примером этого является функция полнотекстового поиска в системе &lt;a href=&quot;https://www.fossil-scm.org/&quot;&gt;контроля версий Fossil&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="12b6af8126e4e3b962d71bf35b72e9a66ab6fcba" translate="yes" xml:space="preserve">
          <source>The row_number() of the first peer in each group - the rank of the current row with gaps. If there is no ORDER BY clause, then all rows are considered peers and this function always returns 1.</source>
          <target state="translated">Функция row_number()первого ровесника в каждой группе-ранг текущей строки с пробелами.Если нет пункта ORDER BY,то все строки считаются равными и эта функция всегда возвращает 1.</target>
        </trans-unit>
        <trans-unit id="d3978e13ae998834400769bcf87213e9a57acdbe" translate="yes" xml:space="preserve">
          <source>The row_number() window function assigns consecutive integers to each row in order of the &quot;ORDER BY&quot; clause within the window-defn (in this case &quot;ORDER BY y&quot;). Note that this does not affect the order in which results are returned from the overall query. The order of the final output is still governed by the ORDER BY clause attached to the SELECT statement (in this case &quot;ORDER BY x&quot;).</source>
          <target state="translated">Функция окна row_number()присваивает каждой строке последовательные целые числа в порядке пункта &quot;ORDER BY&quot; внутри окна-defn (в данном случае &quot;ORDER BY y&quot;).Обратите внимание,что это не влияет на порядок,в котором результаты возвращаются из общего запроса.Порядок конечного результата по-прежнему регулируется пунктом &quot;ЗАКАЗАТЬ ПО&quot;,приложенным к заявлению SELECT (в данном случае &quot;ЗАКАЗАТЬ ПО x&quot;).</target>
        </trans-unit>
        <trans-unit id="97fcd9de22c4efb0eb648cf609eba1ee3fdf411d" translate="yes" xml:space="preserve">
          <source>The rowid (and &quot;oid&quot; and &quot;_rowid_&quot;) is omitted in &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables. WITHOUT ROWID tables are only available in SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_2.html&quot;&gt;version 3.8.2&lt;/a&gt; (2013-12-06) and later. A table that lacks the WITHOUT ROWID clause is called a &quot;rowid table&quot;.</source>
          <target state="translated">Идентификатор строки (а также &amp;laquo;oid&amp;raquo; и &amp;laquo;_rowid_&amp;raquo;) опускается в таблицах &lt;a href=&quot;withoutrowid&quot;&gt;БЕЗ ROWID&lt;/a&gt; . Таблицы БЕЗ ROWID доступны только в &lt;a href=&quot;https://sqlite.org/releaselog/3_8_2.html&quot;&gt;версии&lt;/a&gt; SQLite 3.8.2 (2013-12-06) и новее. Таблица, в которой отсутствует предложение WITHOUT ROWID, называется &quot;таблицей rowid&quot;.</target>
        </trans-unit>
        <trans-unit id="a4a453c67097537d0d10c4b81190fd5d03a4b9dd" translate="yes" xml:space="preserve">
          <source>The rowid column is not accessible on a WITHOUT ROWID virtual table (of course).</source>
          <target state="translated">Столбец rowid недоступен на виртуальной таблице БЕЗ СТРАНИЦ (конечно же).</target>
        </trans-unit>
        <trans-unit id="101d05f0746854eb07065f446e80313cdc7692a7" translate="yes" xml:space="preserve">
          <source>The rowid of the document that contains the term instance.</source>
          <target state="translated">Строка документа,содержащая экземпляр термина.</target>
        </trans-unit>
        <trans-unit id="21037157130833680d029f7ec56534a7a85bda67" translate="yes" xml:space="preserve">
          <source>The rowid of the row in the table being changed</source>
          <target state="translated">Изменение рядовой части строки в таблице</target>
        </trans-unit>
        <trans-unit id="4967842a66478a8da76fb91a725d0ca4385c40a8" translate="yes" xml:space="preserve">
          <source>The rtreecheck() function performs the following checks:</source>
          <target state="translated">Функция rtreecheck()выполняет следующие проверки:</target>
        </trans-unit>
        <trans-unit id="93e10cfe1c883491ee9016750849300312683ba1" translate="yes" xml:space="preserve">
          <source>The rtrim(X,Y) function returns a string formed by removing any and all characters that appear in Y from the right side of X. If the Y argument is omitted, rtrim(X) removes spaces from the right side of X.</source>
          <target state="translated">Функция rtrim(X,Y)возвращает строку,образованную удалением всех символов,которые появляются в Y с правой стороны X.Если аргумент Y опущен,rtrim(X)удаляет пробелы с правой стороны X.</target>
        </trans-unit>
        <trans-unit id="46ff031bad92aa35bcef2484317fc2661aa2d589" translate="yes" xml:space="preserve">
          <source>The rule above says that the letter &quot;a&quot; in user input can be matched against the letter &quot;&amp;auml;&quot; in the dictionary with a penalty of 5.</source>
          <target state="translated">Приведенное выше правило гласит, что буква &amp;laquo;а&amp;raquo; в пользовательском вводе может быть сопоставлена ​​с буквой &amp;laquo;&amp;auml;&amp;raquo; в словаре со штрафом 5.</target>
        </trans-unit>
        <trans-unit id="ed3a2c883d263a1e9abd7d6661fda464d09422b3" translate="yes" xml:space="preserve">
          <source>The rules for determining which collating function to use for a binary comparison operator (=, &amp;lt;, &amp;gt;, &amp;lt;=, &amp;gt;=, !=, IS, and IS NOT) are as follows:</source>
          <target state="translated">Правила определения того, какую функцию сопоставления использовать для оператора двоичного сравнения (=, &amp;lt;,&amp;gt;, &amp;lt;=,&amp;gt; =,! =, IS и IS NOT), следующие:</target>
        </trans-unit>
        <trans-unit id="27705c6545cd7b92f01b98bd6ebfb1aa891406e9" translate="yes" xml:space="preserve">
          <source>The rules for when tables are analyzed are likely to change in future releases.</source>
          <target state="translated">Правила проведения анализа таблиц,скорее всего,изменятся в будущих релизах.</target>
        </trans-unit>
        <trans-unit id="819c15849a2758e415f2520702095eeff7ea13a5" translate="yes" xml:space="preserve">
          <source>The safest and easiest to remember policy is this: assume that any result from</source>
          <target state="translated">Самая безопасная и легкая для запоминания политика заключается в следующем:предположим,что любой результат от</target>
        </trans-unit>
        <trans-unit id="9bfc94ce3f6dbf06df6c899612d318253dda6014" translate="yes" xml:space="preserve">
          <source>The safest policy is to invoke these routines in one of the following ways:</source>
          <target state="translated">Самая безопасная политика заключается в том,чтобы использовать эти процедуры одним из следующих способов:</target>
        </trans-unit>
        <trans-unit id="376b573ee029dd7d9463b27b130e605260069a93" translate="yes" xml:space="preserve">
          <source>The salt-1 and salt-2 values in the frame-header match salt values in the wal-header</source>
          <target state="translated">Значения соли-1 и соли-2 в заголовке кадра совпадают со значениями соли в заголовке стены.</target>
        </trans-unit>
        <trans-unit id="b0647dc001e4e971c816ce4a73a18b5c698aa62d" translate="yes" xml:space="preserve">
          <source>The same SQL statement will fail on every other SQL implementation that we know of due to the use of keywords &quot;union&quot;, &quot;true&quot;, and &quot;with&quot; as identifiers.</source>
          <target state="translated">Один и тот же SQL-оператор не будет работать на всех других известных нам SQL реализациях из-за использования в качестве идентификаторов ключевых слов &quot;union&quot;,&quot;true&quot; и &quot;with&quot;.</target>
        </trans-unit>
        <trans-unit id="67d39480596a16c7c11f0309e84be58f71d89746" translate="yes" xml:space="preserve">
          <source>The same basic B-Tree format is used but the details of the index keys were changed in order to provide better query optimization opportunities. Some of the headers were also changed in order to increase the maximum size of a row from 64KB to 24MB.</source>
          <target state="translated">Используется тот же базовый формат B-Tree,но детали индексных ключей были изменены,чтобы обеспечить лучшие возможности оптимизации запросов.Также были изменены некоторые заголовки,чтобы увеличить максимальный размер строки с 64KB до 24MB.</target>
        </trans-unit>
        <trans-unit id="8827fbb3b64d8c27595464e7777bbb4e772df118" translate="yes" xml:space="preserve">
          <source>The same basic algorithm is followed, except this time the matching rows of the index are scanned from bottom to top instead of from top to bottom, so that the states will appear in descending order.</source>
          <target state="translated">Используется тот же базовый алгоритм,за исключением того,что в этот раз соответствующие строки индекса сканируются снизу вверх,а не сверху вниз,так что состояния будут отображаться в порядке убывания.</target>
        </trans-unit>
        <trans-unit id="8ef4bb6f50ee96f372f99fa9088d7b9c16950c07" translate="yes" xml:space="preserve">
          <source>The same core string formatter is also used internally by SQLite.</source>
          <target state="translated">Тот же самый формирователь строк ядра также используется внутри SQLite.</target>
        </trans-unit>
        <trans-unit id="c76359de67616f16a26e96d68504c135072ade53" translate="yes" xml:space="preserve">
          <source>The same database connection may now be used simultaneously by separate threads.</source>
          <target state="translated">Одно и то же подключение к БД теперь может использоваться одновременно отдельными потоками.</target>
        </trans-unit>
        <trans-unit id="5f8ba3c2f9144ee232f4993ee2d9beb3988a44ac" translate="yes" xml:space="preserve">
          <source>The same indexes are used to speed up every loop in both implementation options. The only difference in these two query plans is the order in which the loops are nested.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3bfa6cdc7cb80687d83044e6ab3337ab8d5595b5" translate="yes" xml:space="preserve">
          <source>The same indices are used to speed up every loop in both implementation options. The only difference in these two query plans is the order in which the loops are nested.</source>
          <target state="translated">Одни и те же индексы используются для ускорения каждого цикла в обоих вариантах реализации.Единственное отличие этих двух планов запросов-порядок вложения циклов.</target>
        </trans-unit>
        <trans-unit id="d1cd4608c87b02b3bc5ed6c81e7bb9ae9c4b8e13" translate="yes" xml:space="preserve">
          <source>The same technique ensures that an SQLite database file cannot be corrupted by a system failure that occurs at an inopportune moment. If a system failure does occur before SQLite has had a chance to execute sufficient</source>
          <target state="translated">Эта же техника гарантирует,что файл базы данных SQLite не может быть поврежден системным сбоем,который происходит в неподходящий момент.Если сбой системы все же произойдет до того,как SQLite получит возможность выполнить достаточное количество операций.</target>
        </trans-unit>
        <trans-unit id="40cbe38c06ce85b1c49ad0c8414f8f89ac5525ac" translate="yes" xml:space="preserve">
          <source>The same thing can be done with an enterprise client/server database, of course. The advantage of SQLite is that it is easier to install and use and the resulting database is a single file that can be written to a USB memory stick or emailed to a colleague.</source>
          <target state="translated">То же самое,конечно,можно сделать и с базой данных корпоративных клиентов/серверов.Преимущество SQLite заключается в том,что его проще установить и использовать,а результирующая база данных представляет собой единый файл,который можно записать на USB-накопитель или отправить коллеге по электронной почте.</target>
        </trans-unit>
        <trans-unit id="d9e7d4c0bf312ba2ed4d788d1d81806125454441" translate="yes" xml:space="preserve">
          <source>The scalar SQL function rtreecheck(R) or rtreecheck(S,R) runs an integrity check on the rtree table named R contained within database S. The function returns a human-language description of any problems found, or the string 'ok' if everything is ok. Running rtreecheck() on an R*Tree virtual table is similar to running &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt; on a database.</source>
          <target state="translated">Скалярная функция SQL rtreecheck (R) или rtreecheck (S, R) запускает проверку целостности таблицы rtree с именем R, содержащейся в базе данных S. Функция возвращает описание любых обнаруженных проблем на человеческом языке или строку 'ok', если все в порядке. Запуск rtreecheck () в виртуальной таблице R * Tree аналогичен запуску &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA Integrity_check&lt;/a&gt; в базе данных.</target>
        </trans-unit>
        <trans-unit id="181bcf0e796a132dd22a68144a4e494726dfbf32" translate="yes" xml:space="preserve">
          <source>The scenario above sounds far-fetched. But the SQLite developers are aware of at least one commercial product that was released with exactly this bug. The vendor came to the SQLite developers seeking help in tracking down some infrequent database corruption issues they were seeing on Linux and Mac. The problem was eventually traced to the fact that the application was linking against two separate copies of SQLite. The solution was to change the application build procedures to link against just one copy of SQLite instead of two.</source>
          <target state="translated">Сценарий выше звучит надуманно.Но разработчики SQLite знают хотя бы об одном коммерческом продукте,который был выпущен именно с этой ошибкой.Продавец обратился к разработчикам SQLite за помощью в отслеживании некоторых редких проблем с повреждением баз данных,которые они видят на Linux и Mac.В конце концов,проблема была связана с тем,что приложение было связано с двумя отдельными копиями SQLite.Решение состояло в том,чтобы изменить процедуры сборки приложения и привязать его к одной копии SQLite,а не к двум.</target>
        </trans-unit>
        <trans-unit id="7cf33abd12fd2e97d31a441b54d245ec800fc490" translate="yes" xml:space="preserve">
          <source>The schema above defines a directed graph with the ability to store a name at each node. Now consider a query against this schema:</source>
          <target state="translated">Приведенная выше схема определяет направленный график с возможностью хранения имени в каждом узле.Теперь рассмотрим запрос к этой схеме:</target>
        </trans-unit>
        <trans-unit id="d37b6e6570fc572ab09d9f50bc38138c9b41b0ec" translate="yes" xml:space="preserve">
          <source>The schema cookie is a 4-byte big-endian integer at offset 40 that is incremented whenever the database schema changes. A prepared statement is compiled against a specific version of the database schema. When the database schema changes, the statement must be reprepared. When a prepared statement runs, it first checks the schema cookie to ensure the value is the same as when the statement was prepared and if the schema cookie has changed, the statement either automatically reprepares and reruns or it aborts with an &lt;a href=&quot;rescode#schema&quot;&gt;SQLITE_SCHEMA&lt;/a&gt; error.</source>
          <target state="translated">Файл cookie схемы представляет собой 4-байтовое целое число с прямым порядком байтов со смещением 40, которое увеличивается при каждом изменении схемы базы данных. Подготовленный оператор компилируется в соответствии с конкретной версией схемы базы данных. При изменении схемы базы данных оператор должен быть воспроизведен. Когда подготовленный оператор запускается, он сначала проверяет файл cookie схемы, чтобы убедиться, что значение такое же, как и при подготовке оператора, и если файл cookie схемы изменился, оператор либо автоматически выполняет повторное сравнение и запускается повторно, либо прерывается с ошибкой &lt;a href=&quot;rescode#schema&quot;&gt;SQLITE_SCHEMA&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1ab0e540f94c93f90585f3869aa649d5881cec37" translate="yes" xml:space="preserve">
          <source>The schema cookie.</source>
          <target state="translated">Печенье-схема.</target>
        </trans-unit>
        <trans-unit id="4488aa59b7580b3c4da5952eb56f99b2cde228a2" translate="yes" xml:space="preserve">
          <source>The schema depicted above is not designed to store the full-text index directly. Instead, it is used to store one or more b-tree structures. There is one b-tree for each row in the %_segdir table. The %_segdir table row contains the root node and various meta-data associated with the b-tree structure, and the %_segments table contains all other (non-root) b-tree nodes. Each b-tree is referred to as a &quot;segment&quot;. Once it has been created, a segment b-tree is never updated (although it may be deleted altogether).</source>
          <target state="translated">Схема,изображенная выше,не предназначена для непосредственного хранения полнотекстового индекса.Вместо этого она используется для хранения одной или нескольких b-деревянных структур.В таблице %_segdir для каждой строки имеется по одному b-дереву.Строка таблицы %_segdir содержит корневой узел и различные мета-данные,связанные с b-деревянной структурой,а таблица %_segments содержит все остальные (не корневые)b-деревянные узлы.Каждое b-дерево называется &quot;сегментом&quot;.После его создания b-дерево сегмента никогда не обновляется (хотя может быть удалено вообще).</target>
        </trans-unit>
        <trans-unit id="2b92ee620ed7f83eb29e5266f914917afed4620a" translate="yes" xml:space="preserve">
          <source>The schema for the DBSTAT virtual table looks like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fd02dc53052cb07a4282595789654910705302c" translate="yes" xml:space="preserve">
          <source>The schema for the dbstat virtual table is this:</source>
          <target state="translated">Схема для виртуальной таблицы dbstat такая:</target>
        </trans-unit>
        <trans-unit id="2252a25e95423355b1edc92e550e314acf60ad89" translate="yes" xml:space="preserve">
          <source>The schema for the table returned by json_each() and json_tree() is as follows:</source>
          <target state="translated">Схема для таблицы,возвращаемой функциями json_each()и json_tree(),выглядит следующим образом:</target>
        </trans-unit>
        <trans-unit id="c3619e8cc0e29548b78032aaa5130408e5391fbe" translate="yes" xml:space="preserve">
          <source>The schema for the tables_used table is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f20e4cd592c03cab97adad3d2182916294f862d" translate="yes" xml:space="preserve">
          <source>The schema format number for a new database can be set at runtime using the &lt;a href=&quot;pragma#pragma_legacy_file_format&quot;&gt;PRAGMA legacy_file_format&lt;/a&gt; command.</source>
          <target state="translated">Номер формата схемы для новой базы данных может быть установлен во время выполнения с помощью команды &lt;a href=&quot;pragma#pragma_legacy_file_format&quot;&gt;PRAGMA legacy_file_format&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="933a80ece41d7c4fe3169e373964e2826ef1d8f7" translate="yes" xml:space="preserve">
          <source>The schema format number is a 4-byte big-endian integer at offset 44. The schema format number is similar to the file format read and write version numbers at offsets 18 and 19 except that the schema format number refers to the high-level SQL formatting rather than the low-level b-tree formatting. Four schema format numbers are currently defined:</source>
          <target state="translated">Номер формата схемы представляет собой 4-байтовое биг-ендианское целое число со смещением 44.Номер формата схемы аналогичен формату файла считывания и записи номеров версий со смещением 18 и 19,за исключением того,что номер формата схемы относится к высокоуровневому форматированию SQL,а не к низкоуровневому форматированию b-дерева.В настоящее время определены четыре номера формата схемы:</target>
        </trans-unit>
        <trans-unit id="62a7a887a20a821d1b69e9b449caf90b4200d958" translate="yes" xml:space="preserve">
          <source>The schema format number. Supported schema formats are 1, 2, 3, and 4.</source>
          <target state="translated">Номер формата схемы.Поддерживаются форматы схем 1,2,3 и 4.</target>
        </trans-unit>
        <trans-unit id="c07d56a869023707575ade10738a217ecfcee4af" translate="yes" xml:space="preserve">
          <source>The schema of an SQL database is able to represent information more directly and succinctly than a key/value database such as a ZIP archive. This makes the document content more accessible to third-party applications and scripts and facilitates advanced features such as built-in document versioning, and incremental saving of work in progress for recovery after a crash.</source>
          <target state="translated">Схема базы данных SQL способна представлять информацию более непосредственно и лаконично,чем база данных ключей/значений,такая как ZIP-архив.Это делает содержимое документов более доступным для сторонних приложений и скриптов,а также облегчает использование таких расширенных функций,как встроенная версионность документов и инкрементальное сохранение текущей работы для восстановления после сбоя.</target>
        </trans-unit>
        <trans-unit id="4828e232778c36009f5d78cd72861a810e476bb6" translate="yes" xml:space="preserve">
          <source>The schema of the bytecode table is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a339d84c3beee1eeb93694c936d75161789ed451" translate="yes" xml:space="preserve">
          <source>The schema table can always be referenced using the name &quot;sqlite_schema&quot;, especially if qualifed by the schema name like &quot;main.sqlite_schema&quot; or &quot;temp.sqlite_schema&quot;. But for historical compatibility, some alternative names are also recognized, including:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70d31e0ed54ade1f01f5803b76d2ee1ab0a7fa16" translate="yes" xml:space="preserve">
          <source>The schema_version pragma will get or set the value of the schema-version integer at offset 40 in the &lt;a href=&quot;fileformat2#database_header&quot;&gt;database header&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87cc88d5b4a5e95bb023c0790cc28378b9e2bd05" translate="yes" xml:space="preserve">
          <source>The schema_version pragma will to get or set the value of the schema-version integer at offset 40 in the &lt;a href=&quot;fileformat2#database_header&quot;&gt;database header&lt;/a&gt;.</source>
          <target state="translated">Прагма schema_version будет получать или устанавливать значение целого числа версии схемы со смещением 40 в &lt;a href=&quot;fileformat2#database_header&quot;&gt;заголовке базы данных&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="077341a10c528ac1588a1408b9034c9f8021b705" translate="yes" xml:space="preserve">
          <source>The scheme of the URI must be &quot;&lt;code&gt;file:&lt;/code&gt;&quot;. Any other scheme results in the input being treated as an ordinary filename.</source>
          <target state="translated">Схема URI должна быть &amp;laquo; &lt;code&gt;file:&lt;/code&gt; &amp;raquo;. Любая другая схема приводит к тому, что ввод обрабатывается как обычное имя файла.</target>
        </trans-unit>
        <trans-unit id="08d91918dffee8fc87a94df6946790f6caab8817" translate="yes" xml:space="preserve">
          <source>The score is a combination of rank and distance. The idea is that a lower score is better. The virtual table attempts to find words with the lowest score and by default (unless overridden by ORDER BY) returns results in order of increasing score.</source>
          <target state="translated">Счет представляет собой комбинацию ранга и расстояния.Идея заключается в том,что меньший балл лучше.Виртуальная таблица пытается найти слова с наименьшим количеством баллов и по умолчанию (если только они не переопределены ORDER BY)возвращает результаты в порядке возрастания баллов.</target>
        </trans-unit>
        <trans-unit id="61fd3b441b127465c680d5c3514e6d464720698f" translate="yes" xml:space="preserve">
          <source>The script compiles the TH3 test harness into machine code (&quot;th3.o&quot;) if necessary.</source>
          <target state="translated">При необходимости скрипт компилирует тестовый жгут TH3 в машинный код (&quot;th3.o&quot;).</target>
        </trans-unit>
        <trans-unit id="9f405708716b43bff0ad67cd4c7d9fb92e6afc28" translate="yes" xml:space="preserve">
          <source>The script compiles the sqlite3.c source file into assembly language (&quot;sqlite3.s&quot;) if necessary.</source>
          <target state="translated">При необходимости скрипт компилирует исходный файл sqlite3.c на ассемблере (&quot;sqlite3.s&quot;).</target>
        </trans-unit>
        <trans-unit id="9bf1fc92f793f60b433b7ebac87847be7a48eb60" translate="yes" xml:space="preserve">
          <source>The script loops through instructions in the assembly language file to locate branch operations.</source>
          <target state="translated">Скрипт проходит через инструкции в файле на языке ассемблера,чтобы найти операции с ветвями.</target>
        </trans-unit>
        <trans-unit id="576c62795ba33247bec0c331da3dd87f14e7a748" translate="yes" xml:space="preserve">
          <source>The script makes a copy of the original sqlite3.s file.</source>
          <target state="translated">Скрипт делает копию оригинального файла sqlite3.s.</target>
        </trans-unit>
        <trans-unit id="fbefc60f4848710280b3f195980be93ae6fb0731" translate="yes" xml:space="preserve">
          <source>The script shows progress for each cycle of the previous step then displays a summary of &quot;survivors&quot; at the end. A &quot;survivor&quot; is a mutation that was not detected by TH3.</source>
          <target state="translated">Сценарий показывает прогресс для каждого цикла предыдущего шага,а затем в конце отображает сводку &quot;выживших&quot;.Выживший&quot;-это мутация,которая не была обнаружена TH3.</target>
        </trans-unit>
        <trans-unit id="4a731425cd1bb86844c78ad068a724419eca7459" translate="yes" xml:space="preserve">
          <source>The search for these strings in the type declaration is case insensitive, of course. If any of the above strings occur anywhere in the type declaration, then the datatype of the column is text. Notice that the type &quot;VARCHAR&quot; contains &quot;CHAR&quot; as a substring so it is considered text.</source>
          <target state="translated">Поиск этих строк в объявлении типа,конечно,не чувствителен к регистру.Если какая-либо из вышеперечисленных строк встречается где-либо в объявлении типа,то типом данных столбца является текст.Обратите внимание,что тип &quot;VARCHAR&quot; содержит &quot;CHAR&quot; в качестве подстроки,поэтому он считается текстом.</target>
        </trans-unit>
        <trans-unit id="201735a6137bd8c721345300624cc86e3645ba64" translate="yes" xml:space="preserve">
          <source>The second &lt;a href=&quot;opcode#Transaction&quot;&gt;Transaction&lt;/a&gt; instruction begins a transaction and starts a rollback journal for database 1, the database used for temporary tables.</source>
          <target state="translated">Вторая инструкция &lt;a href=&quot;opcode#Transaction&quot;&gt;Transaction&lt;/a&gt; начинает транзакцию и запускает журнал отката для базы данных 1, базы данных, используемой для временных таблиц.</target>
        </trans-unit>
        <trans-unit id="541464126fdf47682a89498dd2c1f59037e5c50b" translate="yes" xml:space="preserve">
          <source>The second SELECT is implemented by instructions 14 through 19. Instruction 14 initializes the loop by rewinding its cursor. A new result row is created from the &quot;four&quot; column of table &quot;examp2&quot; by instructions 15 and 16. But instead of using PutStrKey to write this new row into the temporary table, we instead call Delete to remove it from the temporary table if it exists.</source>
          <target state="translated">Второй ВЫБОР осуществляется с помощью инструкций с 14 по 19.Инструкция 14 инициализирует петлю,перематывая курсор.Новая строка результата создается из столбца &quot;четыре&quot; таблицы &quot;экзамен2&quot; инструкциями 15 и 16.Но вместо того,чтобы использовать PutStrKey для записи этой новой строки во временную таблицу,мы вызываем команду Delete,чтобы удалить ее из временной таблицы,если она существует.</target>
        </trans-unit>
        <trans-unit id="b382925f3a88c50c566963d5ae8b2f2a69bce488" translate="yes" xml:space="preserve">
          <source>The second advantage the SQLite printf routines have over &lt;b&gt;sprintf&lt;/b&gt; are two new formatting options specifically designed to support string literals in SQL. Within the format string, the %q formatting option works very much like %s in that it reads a null-terminated string from the argument list and inserts it into the result. But %q translates the inserted string by making two copies of every single-quote (') character in the substituted string. This has the effect of escaping the end-of-string meaning of single-quote within a string literal. The %Q formatting option works similar; it translates the single-quotes like %q and additionally encloses the resulting string in single-quotes. If the argument for the %Q formatting options is a NULL pointer, the resulting string is NULL without single quotes.</source>
          <target state="translated">Второе преимущество подпрограмм SQLite printf перед &lt;b&gt;sprintf&lt;/b&gt; - это две новые опции форматирования, специально разработанные для поддержки строковых литералов в SQL. В строке формата параметр форматирования% q работает очень похоже на% s, поскольку он считывает строку с завершающим нулем из списка аргументов и вставляет ее в результат. Но% q переводит вставленную строку, создавая две копии каждого символа одинарной кавычки (') в подставляемой строке. Это имеет эффект экранирования значения одинарной кавычки в конце строки внутри строкового литерала. Параметр форматирования% Q работает аналогично; он переводит одинарные кавычки, например% q, и дополнительно заключает полученную строку в одинарные кавычки. Если аргумент для параметров форматирования% Q является указателем NULL, результирующая строка будет NULL без одинарных кавычек.</target>
        </trans-unit>
        <trans-unit id="24bd2add8c4054117cbe09f659537f282404edb5" translate="yes" xml:space="preserve">
          <source>The second and all subsequent 32768-byte units of the shm file are like this:</source>
          <target state="translated">Второй и все последующие 32768-байтовые единицы файла shm такие:</target>
        </trans-unit>
        <trans-unit id="2f88dda8423c5371c7ad74eb85809481a6d1addf" translate="yes" xml:space="preserve">
          <source>The second and third forms return the computed edit distance between strings 'string1' and &quot;string2'. In the second form, a language id of 0 is used. The language id is specified in the third form.</source>
          <target state="translated">Вторая и третья формы возвращают вычисленное расстояние редактирования между строками 'string1' и 'string2'.Во второй форме используется идентификатор языка 0.Идентификатор языка указывается в третьей форме.</target>
        </trans-unit>
        <trans-unit id="bab5b375ff048a5d63f1a3b4cc3d343effcaa9c1" translate="yes" xml:space="preserve">
          <source>The second argument (xFilter) is the &quot;filter callback&quot;. For changes to rows in tables that are not attached to the Session object, the filter is called to determine whether changes to the table's rows should be tracked or not. If xFilter returns 0, changes are not tracked. Note that once a table is attached, xFilter will not be called again.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3a47f0193da66fdda72484a51d350d2076b5681" translate="yes" xml:space="preserve">
          <source>The second argument (xFilter) is the &quot;filter callback&quot;. For changes to rows in tables that are not attached to the Session object, the filter is called to determine whether changes to the table's rows should be tracked or not. If xFilter returns 0, changes is not tracked. Note that once a table is attached, xFilter will not be called again.</source>
          <target state="translated">Второй аргумент (xFilter)-&quot;обратный вызов фильтра&quot;.При изменениях строк в таблицах,которые не привязаны к объекту сеанса,фильтр вызывается для определения того,должны ли быть отслежены изменения в строках таблицы.Если xFilter возвращает 0,изменения не отслеживаются.Обратите внимание,что после прикрепления таблицы xFilter больше не будет вызываться.</target>
        </trans-unit>
        <trans-unit id="718f90fed591046439ad14f60ea06810377e7e83" translate="yes" xml:space="preserve">
          <source>The second argument indicates the reason that FTS5 is requesting tokenization of the supplied text. This is always one of the following four values:</source>
          <target state="translated">Второй аргумент указывает на причину,по которой FTS5 запрашивает токенирование поставляемого текста.Это всегда одно из следующих четырех значений:</target>
        </trans-unit>
        <trans-unit id="1b37e9b1846948d626696aade4d54493fddd03d8" translate="yes" xml:space="preserve">
          <source>The second argument is a pointer to the function to invoke when a row is updated, inserted or deleted in a rowid table. The first argument to the callback is a copy of the third argument to sqlite3_update_hook(). The second callback argument is one of &lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;SQLITE_INSERT&lt;/a&gt;, &lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;SQLITE_DELETE&lt;/a&gt;, or &lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;SQLITE_UPDATE&lt;/a&gt;, depending on the operation that caused the callback to be invoked. The third and fourth arguments to the callback contain pointers to the database and table name containing the affected row. The final callback parameter is the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; of the row. In the case of an update, this is the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; after the update takes place.</source>
          <target state="translated">Второй аргумент - это указатель на функцию, вызываемую при обновлении, вставке или удалении строки в таблице rowid. Первый аргумент обратного вызова - это копия третьего аргумента sqlite3_update_hook (). Второй аргумент обратного вызова - это &lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;SQLITE_INSERT&lt;/a&gt; , &lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;SQLITE_DELETE&lt;/a&gt; или &lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;SQLITE_UPDATE&lt;/a&gt; , в зависимости от операции, которая вызвала вызов обратного вызова. Третий и четвертый аргументы обратного вызова содержат указатели на базу данных и имя таблицы, содержащей затронутую строку. Последний параметр обратного вызова - это &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; строки. В случае обновления это &lt;a href=&quot;lang_createtable#rowid&quot;&gt;идентификатор строки&lt;/a&gt; после обновления.</target>
        </trans-unit>
        <trans-unit id="f6eef977cb1db09c38e32ceda39f74ec952be8d2" translate="yes" xml:space="preserve">
          <source>The second argument is a pointer to the function to invoke when a row is updated, inserted or deleted in a rowid table. The first argument to the callback is a copy of the third argument to sqlite3_update_hook(). The second callback argument is one of &lt;a href=&quot;c_alter_table&quot;&gt;SQLITE_INSERT&lt;/a&gt;, &lt;a href=&quot;c_alter_table&quot;&gt;SQLITE_DELETE&lt;/a&gt;, or &lt;a href=&quot;c_alter_table&quot;&gt;SQLITE_UPDATE&lt;/a&gt;, depending on the operation that caused the callback to be invoked. The third and fourth arguments to the callback contain pointers to the database and table name containing the affected row. The final callback parameter is the &lt;a href=&quot;../lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; of the row. In the case of an update, this is the &lt;a href=&quot;../lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; after the update takes place.</source>
          <target state="translated">Второй аргумент - это указатель на функцию, вызываемую при обновлении, вставке или удалении строки в таблице rowid. Первый аргумент обратного вызова - это копия третьего аргумента sqlite3_update_hook (). Второй аргумент обратного вызова - это &lt;a href=&quot;c_alter_table&quot;&gt;SQLITE_INSERT&lt;/a&gt; , &lt;a href=&quot;c_alter_table&quot;&gt;SQLITE_DELETE&lt;/a&gt; или &lt;a href=&quot;c_alter_table&quot;&gt;SQLITE_UPDATE&lt;/a&gt; , в зависимости от операции, которая вызвала вызов обратного вызова. Третий и четвертый аргументы обратного вызова содержат указатели на базу данных и имя таблицы, содержащей затронутую строку. Последний параметр обратного вызова - это &lt;a href=&quot;../lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; строки. В случае обновления это &lt;a href=&quot;../lang_createtable#rowid&quot;&gt;идентификатор строки&lt;/a&gt; после обновления.</target>
        </trans-unit>
        <trans-unit id="724bd11ad92d936922e1ead7d8425d39851a3038" translate="yes" xml:space="preserve">
          <source>The second argument is the index of the SQL parameter to be set. The leftmost SQL parameter has an index of 1. When the same named SQL parameter is used more than once, second and subsequent occurrences have the same index as the first occurrence. The index for named parameters can be looked up using the &lt;a href=&quot;#sqlite3_bind_parameter_index&quot;&gt;sqlite3_bind_parameter_index()&lt;/a&gt; API if desired. The index for &quot;?NNN&quot; parameters is the value of NNN. The NNN value must be between 1 and the &lt;a href=&quot;#sqlite3_limit&quot;&gt;sqlite3_limit()&lt;/a&gt; parameter &lt;a href=&quot;#sqlitelimitvariablenumber&quot;&gt;SQLITE_LIMIT_VARIABLE_NUMBER&lt;/a&gt; (default value: 32766).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4e308f3aa98b17590b5e994747b662ab58b2433" translate="yes" xml:space="preserve">
          <source>The second argument is the index of the SQL parameter to be set. The leftmost SQL parameter has an index of 1. When the same named SQL parameter is used more than once, second and subsequent occurrences have the same index as the first occurrence. The index for named parameters can be looked up using the &lt;a href=&quot;#sqlite3_bind_parameter_index&quot;&gt;sqlite3_bind_parameter_index()&lt;/a&gt; API if desired. The index for &quot;?NNN&quot; parameters is the value of NNN. The NNN value must be between 1 and the &lt;a href=&quot;#sqlite3_limit&quot;&gt;sqlite3_limit()&lt;/a&gt; parameter &lt;a href=&quot;#sqlitelimitvariablenumber&quot;&gt;SQLITE_LIMIT_VARIABLE_NUMBER&lt;/a&gt; (default value: 999).</source>
          <target state="translated">Второй аргумент - это индекс устанавливаемого параметра SQL. Самый левый параметр SQL имеет индекс 1. Когда один и тот же именованный параметр SQL используется более одного раза, второе и последующие вхождения имеют тот же индекс, что и первое вхождение. При необходимости индекс для именованных параметров можно найти с помощью API &lt;a href=&quot;#sqlite3_bind_parameter_index&quot;&gt;sqlite3_bind_parameter_index ()&lt;/a&gt; . Индекс для параметров &amp;laquo;? NNN&amp;raquo; - это значение NNN. Значение NNN должно быть между 1 и &lt;a href=&quot;#sqlite3_limit&quot;&gt;sqlite3_limit ()&lt;/a&gt; параметр &lt;a href=&quot;#sqlitelimitvariablenumber&quot;&gt;SQLITE_LIMIT_VARIABLE_NUMBER&lt;/a&gt; (значение по умолчанию: 999).</target>
        </trans-unit>
        <trans-unit id="ff965dc4a3884d50d8419508e30018f226ac3b0d" translate="yes" xml:space="preserve">
          <source>The second argument is the index of the SQL parameter to be set. The leftmost SQL parameter has an index of 1. When the same named SQL parameter is used more than once, second and subsequent occurrences have the same index as the first occurrence. The index for named parameters can be looked up using the &lt;a href=&quot;bind_parameter_index&quot;&gt;sqlite3_bind_parameter_index()&lt;/a&gt; API if desired. The index for &quot;?NNN&quot; parameters is the value of NNN. The NNN value must be between 1 and the &lt;a href=&quot;limit&quot;&gt;sqlite3_limit()&lt;/a&gt; parameter &lt;a href=&quot;c_limit_attached#sqlitelimitvariablenumber&quot;&gt;SQLITE_LIMIT_VARIABLE_NUMBER&lt;/a&gt; (default value: 32766).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3f014790ea15d84ae5efd1a40e8d6440e64de4e" translate="yes" xml:space="preserve">
          <source>The second argument is the index of the SQL parameter to be set. The leftmost SQL parameter has an index of 1. When the same named SQL parameter is used more than once, second and subsequent occurrences have the same index as the first occurrence. The index for named parameters can be looked up using the &lt;a href=&quot;bind_parameter_index&quot;&gt;sqlite3_bind_parameter_index()&lt;/a&gt; API if desired. The index for &quot;?NNN&quot; parameters is the value of NNN. The NNN value must be between 1 and the &lt;a href=&quot;limit&quot;&gt;sqlite3_limit()&lt;/a&gt; parameter &lt;a href=&quot;c_limit_attached#sqlitelimitvariablenumber&quot;&gt;SQLITE_LIMIT_VARIABLE_NUMBER&lt;/a&gt; (default value: 999).</source>
          <target state="translated">Второй аргумент - это индекс устанавливаемого параметра SQL. Самый левый параметр SQL имеет индекс 1. Когда один и тот же именованный параметр SQL используется более одного раза, второе и последующие вхождения имеют тот же индекс, что и первое вхождение. При необходимости индекс для именованных параметров можно найти с помощью API &lt;a href=&quot;bind_parameter_index&quot;&gt;sqlite3_bind_parameter_index ()&lt;/a&gt; . Индекс для параметров &amp;laquo;? NNN&amp;raquo; - это значение NNN. Значение NNN должно быть между 1 и &lt;a href=&quot;limit&quot;&gt;sqlite3_limit ()&lt;/a&gt; параметр &lt;a href=&quot;c_limit_attached#sqlitelimitvariablenumber&quot;&gt;SQLITE_LIMIT_VARIABLE_NUMBER&lt;/a&gt; (значение по умолчанию: 999).</target>
        </trans-unit>
        <trans-unit id="2fb1bff691f79072fe4cf1aa2d31d1bd3832725a" translate="yes" xml:space="preserve">
          <source>The second argument passed to the xToken() callback (&quot;tflags&quot;) should normally be set to 0. The exception is if the tokenizer supports synonyms. In this case see the discussion below for details.</source>
          <target state="translated">Второй аргумент,передаваемый в функцию обратного вызова xToken()(&quot;tflags&quot;),обычно должен быть равен 0.Исключение составляют случаи,когда токенайзер поддерживает синонимы.В этом случае смотрите подробности ниже.</target>
        </trans-unit>
        <trans-unit id="ca943db57529952ad5f76d4c9a47b52221a6d6e3" translate="yes" xml:space="preserve">
          <source>The second argument to sqlite3_db_config(D,V,...) is the &lt;a href=&quot;#sqlitedbconfiglookaside&quot;&gt;configuration verb&lt;/a&gt; - an integer code that indicates what aspect of the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; is being configured. Subsequent arguments vary depending on the configuration verb.</source>
          <target state="translated">Второй аргумент sqlite3_db_config (D, V, ...) - это команда &lt;a href=&quot;#sqlitedbconfiglookaside&quot;&gt;настройки&lt;/a&gt; - целочисленный код, указывающий, какой аспект &lt;a href=&quot;#sqlite3&quot;&gt;подключения&lt;/a&gt; к базе данных настраивается. Последующие аргументы меняются в зависимости от глагола конфигурации.</target>
        </trans-unit>
        <trans-unit id="a7845e3bb7f88361055af36d05adde4b952592f9" translate="yes" xml:space="preserve">
          <source>The second argument to sqlite3_db_config(D,V,...) is the &lt;a href=&quot;c_dbconfig_defensive#sqlitedbconfiglookaside&quot;&gt;configuration verb&lt;/a&gt; - an integer code that indicates what aspect of the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; is being configured. Subsequent arguments vary depending on the configuration verb.</source>
          <target state="translated">Второй аргумент sqlite3_db_config (D, V, ...) - это команда &lt;a href=&quot;c_dbconfig_defensive#sqlitedbconfiglookaside&quot;&gt;настройки&lt;/a&gt; - целочисленный код, указывающий, какой аспект &lt;a href=&quot;sqlite3&quot;&gt;подключения&lt;/a&gt; к базе данных настраивается. Последующие аргументы меняются в зависимости от глагола конфигурации.</target>
        </trans-unit>
        <trans-unit id="7ca88f23336b34513d2d790b7c87ef9c5d8d0e67" translate="yes" xml:space="preserve">
          <source>The second argument to the error logger callback is an integer &lt;a href=&quot;rescode#extrc&quot;&gt;extended error code&lt;/a&gt;. The third argument to the error logger is the text of the error message. The error message text is stored in a fixed-length stack buffer in the calling function and so will only be valid for the duration of the error logger callback function. The error logger should make a copy of this message into persistent storage if retention of the message is needed.</source>
          <target state="translated">Второй аргумент обратного вызова регистратора ошибок - это &lt;a href=&quot;rescode#extrc&quot;&gt;расширенный&lt;/a&gt; целочисленный код ошибки . Третий аргумент регистратора ошибок - это текст сообщения об ошибке. Текст сообщения об ошибке хранится в буфере стека фиксированной длины в вызывающей функции и поэтому будет действителен только на время выполнения функции обратного вызова регистратора ошибок. Регистратор ошибок должен сделать копию этого сообщения в постоянном хранилище, если необходимо сохранить сообщение.</target>
        </trans-unit>
        <trans-unit id="a2a47b21d6064e4d10a2f6d6161c0f1dce1664a1" translate="yes" xml:space="preserve">
          <source>The second argument, &quot;zSql&quot;, is the statement to be compiled, encoded as either UTF-8 or UTF-16. The sqlite3_prepare(), sqlite3_prepare_v2(), and sqlite3_prepare_v3() interfaces use UTF-8, and sqlite3_prepare16(), sqlite3_prepare16_v2(), and sqlite3_prepare16_v3() use UTF-16.</source>
          <target state="translated">Второй аргумент,&quot;zSql&quot;,это оператор,который должен быть скомпилирован,закодированный либо как UTF-8,либо как UTF-16.Интерфейсы sqlite3_prepare(),sqlite3_prepare_v2()и sqlite3_prepare_v3()используют UTF-8,а sqlite3_prepare16(),sqlite3_prepare16_v2()и sqlite3_prepare16_v3()используют UTF-16.</target>
        </trans-unit>
        <trans-unit id="f2e250c2ef383dec7dc31067a07b23d0da95c91b" translate="yes" xml:space="preserve">
          <source>The second beta release for SQLite 3.0.</source>
          <target state="translated">Второй бета-релиз для SQLite 3.0.</target>
        </trans-unit>
        <trans-unit id="771287a1de97a728b2134cd9c420c1c39a0f52c6" translate="yes" xml:space="preserve">
          <source>The second column is the name of the table.</source>
          <target state="translated">Вторая колонка-это название таблицы.</target>
        </trans-unit>
        <trans-unit id="68511a08109abd7af5a81fce815eeb4f023584c9" translate="yes" xml:space="preserve">
          <source>The second form changes the journaling mode for &quot;</source>
          <target state="translated">Вторая форма меняет режим протоколирования на &quot;</target>
        </trans-unit>
        <trans-unit id="2f272c30ebac8ce92b2f903964b40a07bad463d7" translate="yes" xml:space="preserve">
          <source>The second form of the INSERT statement contains a &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statement instead of a VALUES clause. A new entry is inserted into the table for each row of data returned by executing the SELECT statement. If a column-list is specified, the number of columns in the result of the SELECT must be the same as the number of items in the column-list. Otherwise, if no column-list is specified, the number of columns in the result of the SELECT must be the same as the number of columns in the table. Any SELECT statement, including &lt;a href=&quot;lang_select#compound&quot;&gt;compound SELECTs&lt;/a&gt; and SELECT statements with &lt;a href=&quot;lang_select#orderby&quot;&gt;ORDER BY&lt;/a&gt; and/or &lt;a href=&quot;lang_select#limitoffset&quot;&gt;LIMIT&lt;/a&gt; clauses, may be used in an INSERT statement of this form.</source>
          <target state="translated">Вторая форма оператора INSERT содержит &lt;a href=&quot;lang_select&quot;&gt;оператор SELECT&lt;/a&gt; вместо предложения VALUES. В таблицу добавляется новая запись для каждой строки данных, возвращаемых при выполнении оператора SELECT. Если указан список столбцов, количество столбцов в результате SELECT должно быть таким же, как количество элементов в списке столбцов. В противном случае, если список столбцов не указан, количество столбцов в результате SELECT должно быть таким же, как количество столбцов в таблице. Любой оператор SELECT, включая &lt;a href=&quot;lang_select#compound&quot;&gt;составные операторы&lt;/a&gt; SELECT и SELECT с предложениями &lt;a href=&quot;lang_select#orderby&quot;&gt;ORDER BY&lt;/a&gt; и / или &lt;a href=&quot;lang_select#limitoffset&quot;&gt;LIMIT&lt;/a&gt; , может использоваться в операторе INSERT этой формы.</target>
        </trans-unit>
        <trans-unit id="ec9aa9593798c759bbdf9a6cf2b73541eab87efe" translate="yes" xml:space="preserve">
          <source>The second form of the command is this:</source>
          <target state="translated">Вторая форма команды такая:</target>
        </trans-unit>
        <trans-unit id="fa9b557c755fe5c619c7e5fc0af0adff81ce48ad" translate="yes" xml:space="preserve">
          <source>The second form of the pragma listed above is used to set a new limit in bytes for the specified database. A negative number implies no limit. To always truncate rollback journals and WAL files to their minimum size, set the journal_size_limit to zero. Both the first and second forms of the pragma listed above return a single result row containing a single integer column - the value of the journal size limit in bytes. The default journal size limit is -1 (no limit). The &lt;a href=&quot;compile#default_journal_size_limit&quot;&gt;SQLITE_DEFAULT_JOURNAL_SIZE_LIMIT&lt;/a&gt; preprocessor macro can be used to change the default journal size limit at compile-time.</source>
          <target state="translated">Вторая форма прагмы, указанная выше, используется для установки нового ограничения в байтах для указанной базы данных. Отрицательное число означает отсутствие ограничений. Чтобы всегда обрезать журналы отката и файлы WAL до минимального размера, установите для параметра journal_size_limit значение ноль. И первая, и вторая формы прагмы, перечисленные выше, возвращают одну строку результата, содержащую один целочисленный столбец - значение ограничения размера журнала в байтах. Ограничение размера журнала по умолчанию - -1 (без ограничений). &lt;a href=&quot;compile#default_journal_size_limit&quot;&gt;SQLITE_DEFAULT_JOURNAL_SIZE_LIMIT&lt;/a&gt; препроцессор макрос может быть использован для изменения журнала предельного размера по умолчанию во время компиляции.</target>
        </trans-unit>
        <trans-unit id="4008980ca9a9274111928748bc06de4b907efa68" translate="yes" xml:space="preserve">
          <source>The second integer, if it is present, is the aggregate size of all data stored on leaf pages in bytes. If the value is negative, then the segment is the output of an unfinished incremental-merge operation, and the absolute value is current size in bytes.</source>
          <target state="translated">Второе целое число,если оно присутствует,является совокупным размером всех данных,хранящихся на страницах листа в байтах.Если значение отрицательное,то сегмент является выводом незавершенной операции инкременталь-мергера,а абсолютное значение-текущий размер в байтах.</target>
        </trans-unit>
        <trans-unit id="211c21970b7cdeb91101e574bc29708c2cdfae64" translate="yes" xml:space="preserve">
          <source>The second line above creates a virtual table named &quot;t1&quot; that reads the content of the file named in the argument. The number and names of the columns is determined automatically by reading the first line of content. Other options to the CSV virtual table provide the ability to take the CSV content from a string rather than a separate file, and give the programmer more control over the number and names of the columns. The options are detailed below. The CSV virtual table is usually created as a TEMP table so that it exists only for the current database connection and does not become a permanent part of the database schema. Note that there is no &quot;CREATE TEMP VIRTUAL TABLE&quot; command in SQLite. Instead, prepend the &quot;temp.&quot; schema prefix to the name of the virtual table.</source>
          <target state="translated">Во второй строке выше создается виртуальная таблица с именем &quot;t1&quot;,которая читает содержимое файла с именем в аргументе.Номер и имена столбцов определяются автоматически при прочтении первой строки содержимого.Другие опции виртуальной таблицы CSV предоставляют возможность взять содержимое CSV из строки,а не из отдельного файла,и дать программисту больше контроля над количеством и именами столбцов.Опции подробно описаны ниже.Виртуальная таблица CSV обычно создается как таблица TEMP,так что она существует только для текущего соединения с БД и не становится постоянной частью схемы БД.Обратите внимание,что в SQLite отсутствует команда &quot;CREATE TEMP VIRTUAL TABLE&quot;.Вместо этого представьте префикс схемы &quot;temp.&quot; к имени виртуальной таблицы.</target>
        </trans-unit>
        <trans-unit id="c3933495d9788c26f88ba69fbabb317f1e83064e" translate="yes" xml:space="preserve">
          <source>The second line of the file contains 211792 characters of impenetrable XML. Yes, 211792 characters all on one line. This file is a good stress-test for a text editor. Thankfully, the file is not some obscure binary format, but in terms of accessibility, it might as well be written in Klingon.</source>
          <target state="translated">Вторая строка файла содержит 211792 символа непроницаемого XML.Да,211792 символа все в одной строке.Этот файл является хорошим стресс-тестом для текстового редактора.К счастью,этот файл не является каким-то непонятным бинарным форматом,но с точки зрения доступности он может быть написан и на клингонском языке.</target>
        </trans-unit>
        <trans-unit id="5c1d27adf7a874de9fb599be39fb1d27d63c3092" translate="yes" xml:space="preserve">
          <source>The second number Y is incremented for any change that breaks forward compatibility by adding new features. Most future SQLite releases are expected to increment the second number Y. The Z is reset to zero whenever Y is increased.</source>
          <target state="translated">Второе число Y увеличивается для любого изменения,которое нарушает прямую совместимость путем добавления новых функций.Ожидается,что большинство будущих релизов SQLite будут увеличивать второе число Y.Z сбрасывается на ноль всякий раз,когда число Y увеличивается.</target>
        </trans-unit>
        <trans-unit id="50b9dd44fd65466aa651f4fce7056da00ed7e13a" translate="yes" xml:space="preserve">
          <source>The second parameter (argc) and the fourth parameter (columnNames) are still valid and can be used to determine the number and names of the result columns if there had been a result. The default behavior is not to invoke the callback at all if the result set is empty.</source>
          <target state="translated">Второй параметр (argc)и четвертый параметр (columnNames)все еще действительны и могут быть использованы для определения количества и названий столбцов результата,если бы был получен результат.Поведение по умолчанию заключается в том,чтобы вообще не вызывать обратный вызов,если результирующий набор пуст.</target>
        </trans-unit>
        <trans-unit id="682054ab4ce2cb4dfe2528dcad7556d5d406ca5f" translate="yes" xml:space="preserve">
          <source>The second parameter is the name of the SQL function to be created or redefined. The length of the name is limited to 255 bytes in a UTF-8 representation, exclusive of the zero-terminator. Note that the name length limit is in UTF-8 bytes, not characters nor UTF-16 bytes. Any attempt to create a function with a longer name will result in &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_MISUSE&lt;/a&gt; being returned.</source>
          <target state="translated">Второй параметр - это имя функции SQL, которую нужно создать или переопределить. Длина имени ограничена 255 байтами в представлении UTF-8, исключая нулевой терминатор. Обратите внимание, что максимальная длина имени указана в байтах UTF-8, а не в символах или байтах UTF-16. Любая попытка создать функцию с более длинным именем приведет к &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;возврату SQLITE_MISUSE&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="266b83f6439ab5e88dcd3928741ef542cdbb6626" translate="yes" xml:space="preserve">
          <source>The second parameter is the name of the SQL function to be created or redefined. The length of the name is limited to 255 bytes in a UTF-8 representation, exclusive of the zero-terminator. Note that the name length limit is in UTF-8 bytes, not characters nor UTF-16 bytes. Any attempt to create a function with a longer name will result in &lt;a href=&quot;../rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt; being returned.</source>
          <target state="translated">Второй параметр - это имя функции SQL, которую нужно создать или переопределить. Длина имени ограничена 255 байтами в представлении UTF-8, исключая нулевой терминатор. Обратите внимание, что максимальная длина имени указана в байтах UTF-8, а не в символах или байтах UTF-16. Любая попытка создать функцию с более длинным именем приведет к &lt;a href=&quot;../rescode#misuse&quot;&gt;возврату SQLITE_MISUSE&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="560b989b803d6b51bde79f3db2c1500c44cc5751" translate="yes" xml:space="preserve">
          <source>The second parameter to the preupdate callback is a pointer to the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; that registered the preupdate hook. The third parameter to the preupdate callback is one of the constants &lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;SQLITE_INSERT&lt;/a&gt;, &lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;SQLITE_DELETE&lt;/a&gt;, or &lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;SQLITE_UPDATE&lt;/a&gt; to identify the kind of update operation that is about to occur. The fourth parameter to the preupdate callback is the name of the database within the database connection that is being modified. This will be &quot;main&quot; for the main database or &quot;temp&quot; for TEMP tables or the name given after the AS keyword in the &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; statement for attached databases. The fifth parameter to the preupdate callback is the name of the table that is being modified.</source>
          <target state="translated">Второй параметр обратного вызова preupdate - это указатель на &lt;a href=&quot;#sqlite3&quot;&gt;соединение&lt;/a&gt; с базой данных, которое зарегистрировало обработчик preupdate. Третий параметр обратного вызова перед обновлением - это одна из констант &lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;SQLITE_INSERT&lt;/a&gt; , &lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;SQLITE_DELETE&lt;/a&gt; или &lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;SQLITE_UPDATE&lt;/a&gt; для определения типа операции обновления, которая должна произойти. Четвертым параметром обратного вызова перед обновлением является имя базы данных в изменяемом соединении с базой данных. Это будет &amp;laquo;main&amp;raquo; для основной базы данных или &amp;laquo;temp&amp;raquo; для таблиц TEMP или имя, указанное после ключевого слова AS в операторе &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; для присоединенных баз данных. Пятый параметр обратного вызова перед обновлением - это имя изменяемой таблицы.</target>
        </trans-unit>
        <trans-unit id="097d5db1a651bbf810ec3be53362ed0414cfc3f9" translate="yes" xml:space="preserve">
          <source>The second parameter to the preupdate callback is a pointer to the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; that registered the preupdate hook. The third parameter to the preupdate callback is one of the constants &lt;a href=&quot;c_alter_table&quot;&gt;SQLITE_INSERT&lt;/a&gt;, &lt;a href=&quot;c_alter_table&quot;&gt;SQLITE_DELETE&lt;/a&gt;, or &lt;a href=&quot;c_alter_table&quot;&gt;SQLITE_UPDATE&lt;/a&gt; to identify the kind of update operation that is about to occur. The fourth parameter to the preupdate callback is the name of the database within the database connection that is being modified. This will be &quot;main&quot; for the main database or &quot;temp&quot; for TEMP tables or the name given after the AS keyword in the &lt;a href=&quot;../lang_attach&quot;&gt;ATTACH&lt;/a&gt; statement for attached databases. The fifth parameter to the preupdate callback is the name of the table that is being modified.</source>
          <target state="translated">Второй параметр обратного вызова preupdate - это указатель на &lt;a href=&quot;sqlite3&quot;&gt;соединение&lt;/a&gt; с базой данных, которое зарегистрировало обработчик preupdate. Третий параметр обратного вызова перед обновлением - это одна из констант &lt;a href=&quot;c_alter_table&quot;&gt;SQLITE_INSERT&lt;/a&gt; , &lt;a href=&quot;c_alter_table&quot;&gt;SQLITE_DELETE&lt;/a&gt; или &lt;a href=&quot;c_alter_table&quot;&gt;SQLITE_UPDATE&lt;/a&gt; для определения типа операции обновления, которая должна произойти. Четвертым параметром обратного вызова перед обновлением является имя базы данных в изменяемом соединении с базой данных. Это будет &amp;laquo;main&amp;raquo; для основной базы данных или &amp;laquo;temp&amp;raquo; для таблиц TEMP или имя, указанное после ключевого слова AS в операторе &lt;a href=&quot;../lang_attach&quot;&gt;ATTACH&lt;/a&gt; для присоединенных баз данных. Пятый параметр обратного вызова перед обновлением - это имя изменяемой таблицы.</target>
        </trans-unit>
        <trans-unit id="f5ad56c8e6b709d2294efc15c0b9ac27fea8d776" translate="yes" xml:space="preserve">
          <source>The second step finds the four shortest paths to visit two nodes beginning with one of the four paths from the previous step. In the case where two or more paths are equivalent (they have the same set of visited nodes, though possibly in a different order) only the first and lowest-cost path is retained. We have:</source>
          <target state="translated">На втором этапе находятся четыре кратчайших пути для посещения двух узлов,начинающихся с одного из четырех путей,указанных на предыдущем этапе.В случае,когда два или более путей эквивалентны (они имеют один и тот же набор посещенных узлов,хотя,возможно,и в другом порядке),сохраняется только первый и самый дешевый путь.У нас есть:</target>
        </trans-unit>
        <trans-unit id="73fbb8fcf9b3b6fa8277785714e82cfa142507c2" translate="yes" xml:space="preserve">
          <source>The second through fifth forms of this pragma set the encoding that the main database will be created with if it is created by this session. The string 'UTF-16' is interpreted as &quot;UTF-16 encoding using native machine byte-ordering&quot;. It is not possible to change the text encoding of a database after it has been created and any attempt to do so will be silently ignored.</source>
          <target state="translated">Вторая-пятая формы этой прагмы задают кодировку,с помощью которой будет создана основная база данных,если она будет создана к этому сеансу.Строка 'UTF-16' интерпретируется как &quot;кодировка UTF-16 с использованием байт-заказа на родной машине&quot;.Изменить текстовую кодировку БД после ее создания невозможно,и любая попытка сделать это будет молча игнорироваться.</target>
        </trans-unit>
        <trans-unit id="5882943850506b5e4c2358f26a0aca06e4d009ac" translate="yes" xml:space="preserve">
          <source>The secure_delete setting causes deleted content to be overwritten with zeros. There is a small performance penalty since additional I/O must occur. On the other hand, secure_delete can prevent fragments of sensitive information from lingering in unused parts of the database file after it has been deleted. See the documentation on the &lt;a href=&quot;pragma#pragma_secure_delete&quot;&gt;secure_delete pragma&lt;/a&gt; for additional information.</source>
          <target state="translated">Параметр secure_delete вызывает перезапись удаленного содержимого нулями. Существует небольшое снижение производительности, поскольку должен происходить дополнительный ввод-вывод. С другой стороны, secure_delete может предотвратить сохранение фрагментов конфиденциальной информации в неиспользуемых частях файла базы данных после его удаления. Дополнительную информацию см. В документации по &lt;a href=&quot;pragma#pragma_secure_delete&quot;&gt;прагме secure_delete&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8c43aaf2166362418b74a582dbeb5524f0656e30" translate="yes" xml:space="preserve">
          <source>The seekHit integer represents the maximum of terms in an index for which there is known to be at least one match. If the seekHit value is smaller than the total number of equality terms in an index lookup, then the &lt;a href=&quot;opcode#IfNoHope&quot;&gt;IfNoHope&lt;/a&gt; opcode might run to see if the IN loop can be abandoned early, thus saving work. This is part of the IN-early-out optimization.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b04afcfc3f7fd09080833015b31410c518c0339" translate="yes" xml:space="preserve">
          <source>The separate &lt;a href=&quot;fileformat2&quot;&gt;file format&lt;/a&gt; description provides details on the structure of a database file and of the write-head log file used in &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt;. But details of the locking protocol and of the format of the WAL-index are deliberately omitted since those details are left to discretion of individual &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; implementations. This document fills in those missing details for the unix and windows &lt;a href=&quot;vfs&quot;&gt;VFSes&lt;/a&gt;.</source>
          <target state="translated">В отдельном описании &lt;a href=&quot;fileformat2&quot;&gt;формата файла&lt;/a&gt; содержится подробная информация о структуре файла базы данных и файла журнала головки записи, используемого в &lt;a href=&quot;wal&quot;&gt;режиме WAL&lt;/a&gt; . Но детали протокола блокировки и формата WAL-индекса намеренно опускаются, поскольку эти детали оставлены на усмотрение отдельных реализаций &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; . Этот документ заполняет недостающие детали для &lt;a href=&quot;vfs&quot;&gt;VFS для UNIX&lt;/a&gt; и Windows .</target>
        </trans-unit>
        <trans-unit id="92103d1dd017d8e08e89604f71cfaaa913bec164" translate="yes" xml:space="preserve">
          <source>The session extension facilitates this by recording all changes to both Alice's and Bob's databases and writing those changes into changeset or patchset files. At the end of the day, Alice can send her changeset to Bob and Bob can &quot;apply&quot; it to his database. The result (assuming there are no conflicts) is that Bob's database then contains both his changes and Alice's changes. Likewise, Bob can send a changeset of his work over to Alice and she can apply his changes to her database.</source>
          <target state="translated">Расширение сеанса облегчает это,записывая все изменения в базы данных как Алисы,так и Боба,и записывая эти изменения в changeset или patchset файлы.В конце концов,Элис может отправить свой changeset Бобу,а Боб может &quot;применить&quot; его к своей базе данных.В результате (при условии отсутствия конфликтов)база данных Боба будет содержать как его изменения,так и изменения Элис.Аналогичным образом,Боб может отправить набор изменений своей работы Элис,а она может &quot;применить&quot; его изменения к своей базе данных.</target>
        </trans-unit>
        <trans-unit id="1c8659fbbef014d7697d1ea170e739bed552acd5" translate="yes" xml:space="preserve">
          <source>The session extension only works with tables that have a declared PRIMARY KEY. The PRIMARY KEY of a table may be an INTEGER PRIMARY KEY (rowid alias) or an external PRIMARY KEY.</source>
          <target state="translated">Расширение сессии работает только с таблицами,которые имеют объявленный PRIMARY KEY.PRIMARY KEY таблицы может быть INTEGER PRIMARY KEY (псевдоним rowid)или внешним PRIMARY KEY.</target>
        </trans-unit>
        <trans-unit id="8619b8eb0bb510e39b3c8622337b2bb7b6549aba" translate="yes" xml:space="preserve">
          <source>The session extension provide a mechanism for recording changes to some or all of the &lt;a href=&quot;rowidtable&quot;&gt;rowid tables&lt;/a&gt; in an SQLite database, and packaging those changes into a &quot;changeset&quot; or &quot;patchset&quot; file that can later be used to apply the same set of changes to another database with the same schema and compatible starting data. A &quot;changeset&quot; may also be inverted and used to &quot;undo&quot; a session.</source>
          <target state="translated">Расширение сеанса обеспечивает механизм для записи изменений в некоторые или все &lt;a href=&quot;rowidtable&quot;&gt;таблицы идентификаторов строк&lt;/a&gt; в базе данных SQLite и упаковки этих изменений в файл &amp;laquo;набора изменений&amp;raquo; или &amp;laquo;набора исправлений&amp;raquo;, который впоследствии можно использовать для применения того же набора изменений к другому. база данных с той же схемой и совместимыми стартовыми данными. &amp;laquo;Набор изменений&amp;raquo; также может быть инвертирован и использован для &amp;laquo;отмены&amp;raquo; сеанса.</target>
        </trans-unit>
        <trans-unit id="0b97f5ba300285bc33992abb7779519b897b7aa7" translate="yes" xml:space="preserve">
          <source>The session object &quot;indirect&quot; flag is set when the change is made, or</source>
          <target state="translated">Флаг объекта сеанса &quot;непрямой&quot; устанавливается при изменении,или</target>
        </trans-unit>
        <trans-unit id="ffcb76dee8dc3b4cb20fe29908bbbe2ff2230909" translate="yes" xml:space="preserve">
          <source>The session object is configured with a set of tables to monitor changes on.</source>
          <target state="translated">Объект сеанса настраивается с набором таблиц для отслеживания изменений.</target>
        </trans-unit>
        <trans-unit id="0c67ff7ccfd533851dea34da8187939bbeae8841" translate="yes" xml:space="preserve">
          <source>The session object is deleted using a call to the &lt;a href=&quot;session/sqlite3session_delete&quot;&gt;sqlite3session_delete()&lt;/a&gt; API function.</source>
          <target state="translated">Объект сеанса удаляется с помощью вызова функции API &lt;a href=&quot;session/sqlite3session_delete&quot;&gt;sqlite3session_delete ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b41c2d1dd25f0b9daf0304c7870c3eb7ae78b919" translate="yes" xml:space="preserve">
          <source>The session object therefore accumulates two types of records - those that consist of primary key values only (created when the user inserts a new record) and those that consist of the primary key values and the original values of other table columns (created when the users deletes or updates a record).</source>
          <target state="translated">Следовательно,объект сеанса аккумулирует два типа записей-те,которые состоят только из значений первичного ключа (создаются,когда пользователь вставляет новую запись)и те,которые состоят из значений первичного ключа и исходных значений других столбцов таблицы (создаются,когда пользователь удаляет или обновляет запись).</target>
        </trans-unit>
        <trans-unit id="67b4d05a6aa852ba851b95d39158470c33cead0c" translate="yes" xml:space="preserve">
          <source>The session object will be used to create changesets for tables in database zDb, where zDb is either &quot;main&quot;, or &quot;temp&quot;, or the name of an attached database. It is not an error if database zDb is not attached to the database when the session object is created.</source>
          <target state="translated">Объект сессии будет использоваться для создания таблиц изменений в БД zDb,где zDb-это либо &quot;главная&quot;,либо &quot;временная&quot;,либо имя подключенной БД.Это не является ошибкой,если при создании объекта сессии БД zDb не подключена к БД.</target>
        </trans-unit>
        <trans-unit id="45a8679117c7936fefc29c4e8b252b099d09917b" translate="yes" xml:space="preserve">
          <source>The sessions module never invokes an xOutput callback with the third parameter set to a value less than or equal to zero. Other than this, no guarantees are made as to the size of the chunks of data returned.</source>
          <target state="translated">Модуль сеансов никогда не вызывает обратного вызова xOutput с третьим параметром,установленным в значение меньше или равным нулю.Кроме этого,не даётся никаких гарантий относительно размера возвращаемых кусков данных.</target>
        </trans-unit>
        <trans-unit id="a218d47a709906affb4f3ae717da9de3077b519d" translate="yes" xml:space="preserve">
          <source>The sessions module revolves around creating and manipulating changesets. A changeset is a blob of data that encodes a series of changes to a database. Each change in a changeset is one of the following:</source>
          <target state="translated">Модуль сеансов вращается вокруг создания и манипулирования модификациями.Изменения-это блок данных,который кодирует серию изменений в базу данных.Каждое изменение в changesetе является одним из следующих:</target>
        </trans-unit>
        <trans-unit id="d639d6bbcd88a2f2cd5339240f5d5c5de8f80432" translate="yes" xml:space="preserve">
          <source>The set X contains the index in aPgno of every entry in the current 32768-byte unit of the shm file that might possible be a solution to the FindFrame(P,M) function. Each of these entries must be checked separately to ensure that the aPgno value is P and that the frame number does not exceed M. The largest frame number that passes those two tests is the answer.</source>
          <target state="translated">Набор X содержит индекс в aPgno каждой записи в текущей 32768-байтовой единице файла shm,что может быть решением для функции FindFrame(P,M).Каждая из этих записей должна быть проверена отдельно,чтобы убедиться,что значение aPgno равно P и что номер кадра не превышает M.Самый большой номер кадра,который проходит эти два теста,является ответом.</target>
        </trans-unit>
        <trans-unit id="daeab809359987c0f17f57c78f38704f62041f7b" translate="yes" xml:space="preserve">
          <source>The set of</source>
          <target state="translated">Набор</target>
        </trans-unit>
        <trans-unit id="df619f50e7143055665ccf4d69e938c1340f4737" translate="yes" xml:space="preserve">
          <source>The set of built-in auxiliary functions provided by FTS5 may be improved upon in the future.</source>
          <target state="translated">Набор встроенных вспомогательных функций,предоставляемых FTS5,может быть улучшен в будущем.</target>
        </trans-unit>
        <trans-unit id="a49341beec33b485301f8bafe6ae6c61c6f39915" translate="yes" xml:space="preserve">
          <source>The set of checklist items for release checklist is potentially updated for each release. The content and complete history of each release checklist are retained for the historical record.</source>
          <target state="translated">Набор элементов контрольного списка для каждого релиза потенциально обновляется для каждого релиза.Содержание и полная история каждого релиза сохраняются для исторической записи.</target>
        </trans-unit>
        <trans-unit id="0f5a66644e1d1f4b0f41c960d4f2f7a794b20868" translate="yes" xml:space="preserve">
          <source>The set of static mutexes may change from one SQLite release to the next. Applications that override the built-in mutex logic must be prepared to accommodate additional static mutexes.</source>
          <target state="translated">Набор статических мьютексов может меняться от одного релиза SQLite к другому.Приложения,переопределяющие встроенную логику мьютекса,должны быть готовы к размещению дополнительных статических мьютексов.</target>
        </trans-unit>
        <trans-unit id="9b60f1982b5c4164ca917a617479f0aacfe46294" translate="yes" xml:space="preserve">
          <source>The shadow tables are ordinary SQLite data tables. You can query them directly if you like, though this unlikely to reveal anything particularly useful. And you can &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;, &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt;, &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; or even &lt;a href=&quot;lang_droptable&quot;&gt;DROP&lt;/a&gt; the shadow tables, though doing so will corrupt your R*Tree index. So it is best to simply ignore the shadow tables. Recognize that they hold your R*Tree index information and let it go as that.</source>
          <target state="translated">Теневые таблицы - это обычные таблицы данных SQLite. Вы можете запросить их напрямую, если хотите, хотя это вряд ли даст вам что-нибудь особенно полезное. И вы можете &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; , &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; , &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; или даже &lt;a href=&quot;lang_droptable&quot;&gt;DROP&lt;/a&gt; теневых таблиц, хотя это приведет к коррумпированному индексу R * Tree. Так что лучше просто игнорировать теневые таблицы. Осознайте, что они хранят информацию о вашем индексе R * Tree, и оставьте ее как есть.</target>
        </trans-unit>
        <trans-unit id="7b89e4e1261efca1d668789aecafeceb06cf0045" translate="yes" xml:space="preserve">
          <source>The shared library filename passed to &lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension()&lt;/a&gt; may omit the filename suffix, and an appropriate architecture-dependent suffix (&quot;.so&quot;, &quot;.dylib&quot;, or &quot;.dll&quot;) will be added automatically.</source>
          <target state="translated">Имя файла общей библиотеки, переданное в &lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension (),&lt;/a&gt; может опускать суффикс имени файла, и соответствующий архитектурно-зависимый суффикс (&amp;laquo;.so&amp;raquo;, &amp;laquo;.dylib&amp;raquo; или &amp;laquo;.dll&amp;raquo;) будет добавлен автоматически.</target>
        </trans-unit>
        <trans-unit id="683712ddb2de169a205df89a5ffe29d5c006c2b5" translate="yes" xml:space="preserve">
          <source>The shared-memory file contains no persistent content. The only purpose of the shared-memory file is to provide a block of shared memory for use by multiple processes all accessing the same database in WAL mode. If the &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; is able to provide an alternative method for accessing shared memory, then that alternative method might be used rather than the shared-memory file. For example, if &lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;PRAGMA locking_mode&lt;/a&gt; is set to EXCLUSIVE (meaning that only one process is able to access the database file) then the shared memory will be allocated from heap rather than out of the shared-memory file, and the shared-memory file will never be created.</source>
          <target state="translated">Файл с общей памятью не содержит постоянного содержимого. Единственная цель файла с общей памятью - предоставить блок общей памяти для использования несколькими процессами, обращающимися к одной и той же базе данных в режиме WAL. Если &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; может предоставить альтернативный метод доступа к разделяемой памяти, то этот альтернативный метод может использоваться вместо файла с разделяемой памятью. Например, если &lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;PRAGMA lock_mode&lt;/a&gt; установлен в EXCLUSIVE (это означает, что только один процесс может получить доступ к файлу базы данных), то общая память будет выделяться из кучи, а не из файла с общей памятью, и файл с общей памятью будет никогда не создаваться.</target>
        </trans-unit>
        <trans-unit id="d84d71db4e9c7a1a18a467e4bbe2be0320c053f2" translate="yes" xml:space="preserve">
          <source>The shared-memory file has the same lifetime as its associated WAL file. The shared-memory file is created when the WAL file is created and is deleted when the WAL file is deleted. During WAL file recovery, the shared memory file is recreated from scratch based on the contents of the WAL file being recovered.</source>
          <target state="translated">Файл общей памяти имеет то же время жизни,что и связанный с ним файл WAL.Файл общей памяти создается при создании файла WAL и удаляется при удалении файла WAL.Во время восстановления файла WAL файл общей памяти воссоздается с нуля на основе содержимого восстанавливаемого файла WAL.</target>
        </trans-unit>
        <trans-unit id="c6175d074e784d9fffd662056186d3e1dc1f4cc9" translate="yes" xml:space="preserve">
          <source>The shm does not contain any database content and is not required to recover the database following a crash. For that reason, the first client to connect to a quiescent database will normally truncate the shm file if it exists. Since the content of the shm file does not need to be preserved across a crash, the shm file is never fsync()-ed to disk. In fact, if there were a mechanism by which SQLite could tell the operating system to never persist the shm file to disk but always hold it in cache memory, SQLite would use that mechanism to avoid any unnecessary disk I/O associated with the shm file. However, no such mechanism exists in standard posix.</source>
          <target state="translated">ШМ не содержит содержимого базы данных и не требуется для восстановления базы данных после аварии.По этой причине первый клиент,подключившийся к базе данных в состоянии покоя,обычно усекает shm-файл,если он существует.Поскольку содержимое файла shm не нужно сохранять во время аварии,файл shm никогда не помещается на диск с помощью функции fsync()-ed.На самом деле,если бы существовал механизм,с помощью которого SQLite мог бы сказать операционной системе никогда не сохранять файл shm на диск,но всегда хранить его в кэш-памяти,SQLite бы использовал этот механизм,чтобы избежать лишних дисковых операций ввода/вывода,связанных с файлом shm.Однако в стандартном исполнении такого механизма не существует.</target>
        </trans-unit>
        <trans-unit id="2ce5842569cd9ae6cb873fe122d925e98dfd9e57" translate="yes" xml:space="preserve">
          <source>The shm file consists of one or more hash tables, where each hash table is 32768 bytes in size. Except, a 136-byte header is carved out of the front of the very first hash table, so the first hash table is only 32632 bytes in size. The total size of the shm file is always a multiple of 32768. In most cases, the total size of the shm file is exactly 32768 bytes. The shm file only needs to grow beyond a single hash table if when the wal file grows very large (more than 4079 frames). Since the default &lt;a href=&quot;c3ref/wal_autocheckpoint&quot;&gt;automatic checkpoint threshold&lt;/a&gt; is 1000, WAL files rare reach the 4079 threshold needed to make the shm file grow.</source>
          <target state="translated">Файл shm состоит из одной или нескольких хеш-таблиц, каждая из которых имеет размер 32768 байт. За исключением того, что 136-байтовый заголовок вырезан из передней части самой первой хеш-таблицы, поэтому размер первой хеш-таблицы составляет всего 32632 байта. Общий размер файла shm всегда кратен 32768. В большинстве случаев общий размер файла shm составляет ровно 32768 байт. Файл shm должен вырасти за пределы одной хеш-таблицы только в том случае, если файл wal становится очень большим (более 4079 кадров). Поскольку &lt;a href=&quot;c3ref/wal_autocheckpoint&quot;&gt;порог автоматической контрольной точки&lt;/a&gt; по умолчанию равен 1000, файлы WAL редко достигают порога 4079, необходимого для увеличения размера файла shm.</target>
        </trans-unit>
        <trans-unit id="0d8774149ef596e36906cd1fe56afff10a697841" translate="yes" xml:space="preserve">
          <source>The signature of the xAccess method has been modified to return an &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; and to store its output into an integer pointed to by a parameter, rather than returning the output directly. This change allows the xAccess() method to report failures. In association with this signature change, a new extended error code &lt;a href=&quot;rescode#ioerr_access&quot;&gt;SQLITE_IOERR_ACCESS&lt;/a&gt; has been added.</source>
          <target state="translated">Сигнатура метода xAccess была изменена для возврата &lt;a href=&quot;rescode&quot;&gt;кода ошибки&lt;/a&gt; и сохранения ее вывода в виде целого числа, на которое указывает параметр, вместо того, чтобы возвращать вывод напрямую. Это изменение позволяет методу xAccess () сообщать об ошибках. В связи с этим изменением подписи был добавлен новый расширенный код ошибки &lt;a href=&quot;rescode#ioerr_access&quot;&gt;SQLITE_IOERR_ACCESS&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="73da15d1378e7e4cecf6c05a9921a5f1b3117f3b" translate="yes" xml:space="preserve">
          <source>The signature of the xCheckReservedLock method on &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; has been modified so that it returns an &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; and stores its boolean result into an integer pointed to by a parameter. In association with this change, a new extended error code &lt;a href=&quot;rescode#ioerr_checkreservedlock&quot;&gt;SQLITE_IOERR_CHECKRESERVEDLOCK&lt;/a&gt; has been added.</source>
          <target state="translated">Сигнатура метода xCheckReservedLock в &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; была изменена так, что он возвращает &lt;a href=&quot;rescode&quot;&gt;код ошибки&lt;/a&gt; и сохраняет свой логический результат в целое число, на которое указывает параметр. В связи с этим изменением был добавлен новый расширенный код ошибки &lt;a href=&quot;rescode#ioerr_checkreservedlock&quot;&gt;SQLITE_IOERR_CHECKRESERVEDLOCK&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="23da313c5318bbaf1e11638c6787139e74ceff62" translate="yes" xml:space="preserve">
          <source>The simple, modular design of SQLite makes it a good platform for prototyping new, experimental database language features or ideas.</source>
          <target state="translated">Простой модульный дизайн SQLite делает его хорошей платформой для прототипирования новых,экспериментальных возможностей языка баз данных или идей.</target>
        </trans-unit>
        <trans-unit id="2d0de7ad7a0838db1beb185b37e3f4659d20a947" translate="yes" xml:space="preserve">
          <source>The single row of result-set data created by evaluating the aggregate and non-aggregate expressions in the result-set forms the result of an aggregate query without a GROUP BY clause. An aggregate query without a GROUP BY clause always returns exactly one row of data, even if there are zero rows of input data.</source>
          <target state="translated">Единая строка данных результирующей выборки,созданная путем вычисления агрегированных и не агрегированных выражений в результирующей выборке,формирует результат агрегированного запроса без пункта GROUP BY.Агрегированный запрос без пункта GROUP BY всегда возвращает ровно одну строку данных,даже если есть нулевые строки входных данных.</target>
        </trans-unit>
        <trans-unit id="9e5842a2d17c6ea95217db027ef9476039d3c1f4" translate="yes" xml:space="preserve">
          <source>The single-argument form of carray() requires a special C-language interface named &quot;sqlite3_carray_bind()&quot; in order to attach values:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fee8fe6df1809775fcd62fdf9f110bcf759d94a6" translate="yes" xml:space="preserve">
          <source>The six streaming API xxx_strm() functions serve similar purposes to the corresponding non-streaming API functions:</source>
          <target state="translated">Шесть потоковых функций API xxx_strm()служат аналогично соответствующим не потоковым функциям API:</target>
        </trans-unit>
        <trans-unit id="af903c0dcc364c9d11abbe191c3960a1c5d014f5" translate="yes" xml:space="preserve">
          <source>The sixth argument to sqlite3_bind_text64() must be one of &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF8&lt;/a&gt;, &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16&lt;/a&gt;, &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16BE&lt;/a&gt;, or &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16LE&lt;/a&gt; to specify the encoding of the text in the third parameter. If the sixth argument to sqlite3_bind_text64() is not one of the allowed values shown above, or if the text encoding is different from the encoding specified by the sixth parameter, then the behavior is undefined.</source>
          <target state="translated">Шестой аргумент sqlite3_bind_text64 () должен быть одним из &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF8&lt;/a&gt; , &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16&lt;/a&gt; , &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16BE&lt;/a&gt; или &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16LE,&lt;/a&gt; чтобы указать кодировку текста в третьем параметре. Если шестой аргумент sqlite3_bind_text64 () не является одним из допустимых значений, показанных выше, или если кодировка текста отличается от кодировки, указанной шестым параметром, то поведение не определено.</target>
        </trans-unit>
        <trans-unit id="3a920902ff183846916ffe84129516653c512659" translate="yes" xml:space="preserve">
          <source>The sixth argument to sqlite3_bind_text64() must be one of &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF8&lt;/a&gt;, &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16&lt;/a&gt;, &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16BE&lt;/a&gt;, or &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16LE&lt;/a&gt; to specify the encoding of the text in the third parameter. If the sixth argument to sqlite3_bind_text64() is not one of the allowed values shown above, or if the text encoding is different from the encoding specified by the sixth parameter, then the behavior is undefined.</source>
          <target state="translated">Шестой аргумент sqlite3_bind_text64 () должен быть одним из &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF8&lt;/a&gt; , &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16&lt;/a&gt; , &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16BE&lt;/a&gt; или &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16LE,&lt;/a&gt; чтобы указать кодировку текста в третьем параметре. Если шестой аргумент sqlite3_bind_text64 () не является одним из допустимых значений, показанных выше, или если кодировка текста отличается от кодировки, указанной шестым параметром, то поведение не определено.</target>
        </trans-unit>
        <trans-unit id="e8b06ccbdc8c379a9a470f7c185a0247a80f8e2b" translate="yes" xml:space="preserve">
          <source>The sixth, seventh and eighth parameters passed to the three &quot;sqlite3_create_function*&quot; functions, xFunc, xStep and xFinal, are pointers to C-language functions that implement the SQL function or aggregate. A scalar SQL function requires an implementation of the xFunc callback only; NULL pointers must be passed as the xStep and xFinal parameters. An aggregate SQL function requires an implementation of xStep and xFinal and NULL pointer must be passed for xFunc. To delete an existing SQL function or aggregate, pass NULL pointers for all three function callbacks.</source>
          <target state="translated">Шестой,седьмой и восьмой параметры,переданные трем функциям &quot;sqlite3_create_function*&quot;,xFunc,xStep и xFinal,являются указателями на функции языка C,реализующие функцию SQL или агрегат.Скалярная SQL-функция требует только реализации обратного вызова xFunc;в качестве параметров xStep и xFinal должны передаваться указатели NULL.Функция агрегированного SQL требует реализации указателя xStep,а указатели xFinal и NULL должны передаваться для xFunc.Чтобы удалить существующую SQL-функцию или агрегат,необходимо передать NULL указатели для всех трех обратных вызовов функций.</target>
        </trans-unit>
        <trans-unit id="5a1e0ca7d22b49ccdf57dfbe9e13e610f7e7488a" translate="yes" xml:space="preserve">
          <source>The sixth, seventh, eighth and ninth parameters (xStep, xFinal, xValue and xInverse) passed to sqlite3_create_window_function are pointers to C-language callbacks that implement the new function. xStep and xFinal must both be non-NULL. xValue and xInverse may either both be NULL, in which case a regular aggregate function is created, or must both be non-NULL, in which case the new function may be used as either an aggregate or aggregate window function. More details regarding the implementation of aggregate window functions are &lt;a href=&quot;../windowfunctions#udfwinfunc&quot;&gt;available here&lt;/a&gt;.</source>
          <target state="translated">Шестой, седьмой, восьмой и девятый параметры (xStep, xFinal, xValue и xInverse), переданные в sqlite3_create_window_function, являются указателями на обратные вызовы языка C, реализующие новую функцию. Оба xStep и xFinal не должны быть NULL. xValue и xInverse могут быть либо NULL, и в этом случае создается обычная агрегатная функция, либо оба должны быть не NULL, и в этом случае новая функция может использоваться либо как агрегатная, либо как агрегатная оконная функция. Более подробная информация о реализации агрегированных оконных функций &lt;a href=&quot;../windowfunctions#udfwinfunc&quot;&gt;доступна здесь&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9f70d86715eabcca8a7d61d2f6e68b2fc4d6a57e" translate="yes" xml:space="preserve">
          <source>The sixth, seventh, eighth and ninth parameters (xStep, xFinal, xValue and xInverse) passed to sqlite3_create_window_function are pointers to C-language callbacks that implement the new function. xStep and xFinal must both be non-NULL. xValue and xInverse may either both be NULL, in which case a regular aggregate function is created, or must both be non-NULL, in which case the new function may be used as either an aggregate or aggregate window function. More details regarding the implementation of aggregate window functions are &lt;a href=&quot;windowfunctions#udfwinfunc&quot;&gt;available here&lt;/a&gt;.</source>
          <target state="translated">Шестой, седьмой, восьмой и девятый параметры (xStep, xFinal, xValue и xInverse), переданные в sqlite3_create_window_function, являются указателями на обратные вызовы языка C, реализующие новую функцию. Оба xStep и xFinal не должны быть NULL. xValue и xInverse могут быть либо NULL, и в этом случае создается обычная агрегатная функция, либо оба должны быть не NULL, и в этом случае новая функция может использоваться либо как агрегатная, либо как агрегатная оконная функция. Более подробная информация о реализации агрегированных оконных функций &lt;a href=&quot;windowfunctions#udfwinfunc&quot;&gt;доступна здесь&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="650196bb22cf5bf05d1563df9b31bf781c3e9a6d" translate="yes" xml:space="preserve">
          <source>The size of the blobs in the test data affects performance. The filesystem will generally be faster for larger blobs, since the overhead of open() and close() is amortized over more bytes of I/O, whereas the database will be more efficient in both speed and space as the average blob size decreases.</source>
          <target state="translated">Размер капель в тестовых данных влияет на производительность.Файловая система,как правило,будет быстрее для больших блоков,так как накладные расходы open()и close()амортизируются за большее количество байт ввода/вывода,в то время как база данных будет более эффективной как по скорости,так и по объему,так как средний размер блока уменьшается.</target>
        </trans-unit>
        <trans-unit id="71ba6b5b378d657456a5945d2ff20a780b1b14d4" translate="yes" xml:space="preserve">
          <source>The size of the lookaside memory pool has a global default value but can also be configured on a connection-by-connection basis. To change the default size of the lookaside memory pool at compile-time, use the &lt;a href=&quot;compile#default_lookaside&quot;&gt;-DSQLITE_DEFAULT_LOOKASIDE=&lt;i&gt;SZ,N&lt;/i&gt;&lt;/a&gt; option. To change the default size of the lookaside memory pool at start-time, use the &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config()&lt;/a&gt; interface:</source>
          <target state="translated">Размер резервного пула памяти имеет глобальное значение по умолчанию, но его также можно настроить для каждого соединения. Чтобы изменить размер по умолчанию пула памяти ассоциативного во время компиляции, используйте &lt;a href=&quot;compile#default_lookaside&quot;&gt;-DSQLITE_DEFAULT_LOOKASIDE = &lt;i&gt;SZ, N&lt;/i&gt;&lt;/a&gt; вариант. Чтобы изменить размер резервного пула памяти по умолчанию во время запуска, используйте интерфейс &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config ()&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="7032e0044fe8cbf0ccd0392512f38ee2b17ffc25" translate="yes" xml:space="preserve">
          <source>The size of the matching term in bytes.</source>
          <target state="translated">Размер совпадающего термина в байтах.</target>
        </trans-unit>
        <trans-unit id="481f99d28cac0daa50062e9ad3a05601840366c0" translate="yes" xml:space="preserve">
          <source>The size of the memory-mapped I/O region cannot be changed while the memory-mapped I/O region is in active use, to avoid unmapping memory out from under running SQL statements. For this reason, the mmap_size pragma may be a no-op if the prior mmap_size is non-zero and there are other SQL statements running concurrently on the same &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt;.</source>
          <target state="translated">Размер области ввода-вывода с отображением памяти не может быть изменен, пока область ввода-вывода с отображением памяти находится в активном использовании, чтобы избежать отмены отображения памяти из-за выполнения операторов SQL. По этой причине прагма mmap_size может не работать, если предыдущий mmap_size не равен нулю и есть другие операторы SQL, выполняющиеся одновременно с тем же &lt;a href=&quot;c3ref/sqlite3&quot;&gt;соединением с базой данных&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="19c67c781984d7843a725bf421c45281605af01e" translate="yes" xml:space="preserve">
          <source>The snippet function first attempts to find a fragment of text consisting of</source>
          <target state="translated">Функция сниппета сначала пытается найти фрагмент текста,состоящего из</target>
        </trans-unit>
        <trans-unit id="54b3f9fdd628ef57cd97424e1a01116d0ba15ccd" translate="yes" xml:space="preserve">
          <source>The snippet function is used to create formatted fragments of document text for display as part of a full-text query results report. The snippet function may be passed between one and six arguments, as follows:</source>
          <target state="translated">Функция фрагментации используется для создания форматированных фрагментов текста документа для отображения в рамках полнотекстового отчета о результатах запроса.Функция сниппета может быть передана между одним и шестью аргументами следующим образом:</target>
        </trans-unit>
        <trans-unit id="25ab90403f978d997e2573cced370b12d71d602c" translate="yes" xml:space="preserve">
          <source>The snippet() function is similar to highlight(), except that instead of returning entire column values, it automatically selects and extracts a short fragment of document text to process and return. The snippet() function must be passed five parameters following the table name argument:</source>
          <target state="translated">Функция snippet()аналогична функции highlight(),за исключением того,что вместо возврата значений всей колонки она автоматически выбирает и извлекает короткий фрагмент текста документа для обработки и возврата.Функция snippet()должна передавать пять параметров,следующих за аргументом имени таблицы:</target>
        </trans-unit>
        <trans-unit id="650db23255aac8aa4103c6f6d9992ba8c2854051" translate="yes" xml:space="preserve">
          <source>The soft heap limit is &quot;soft&quot; in this sense: If SQLite is not able to free up enough auxiliary memory to stay below the limit, it goes ahead and allocates the extra memory and exceeds its limit. This occurs under the theory that it is better to use additional memory than to fail outright.</source>
          <target state="translated">Лимит &quot;мягкой кучи&quot; в этом смысле &quot;мягкий&quot;:если SQLite не в состоянии освободить достаточно вспомогательной памяти,чтобы остаться ниже лимита,то он выделяет дополнительную память и превышает ее лимит.Это происходит в соответствии с теорией,что лучше использовать дополнительную память,чем выходить из строя.</target>
        </trans-unit>
        <trans-unit id="f259c7b18142819d8b2454c94e82cad365d3cfbd" translate="yes" xml:space="preserve">
          <source>The soft heap limit is not enforced in the current implementation if one or more of following conditions are true:</source>
          <target state="translated">Мягкое ограничение кучности не применяется в текущей реализации,если одно или несколько из следующих условий являются верными:</target>
        </trans-unit>
        <trans-unit id="62f643dbe59889b37bb6ee27203ce861b75e4df1" translate="yes" xml:space="preserve">
          <source>The soft heap limit is set to zero.</source>
          <target state="translated">Предел мягкой кучи установлен на ноль.</target>
        </trans-unit>
        <trans-unit id="1e9f9417ca080fbcc56641af6510e79f88f545c2" translate="yes" xml:space="preserve">
          <source>The soft heap limit may not be greater than the hard heap limit. If the hard heap limit is enabled and if sqlite3_soft_heap_limit(N) is invoked with a value of N that is greater than the hard heap limit, the the soft heap limit is set to the value of the hard heap limit. The soft heap limit is automatically enabled whenever the hard heap limit is enabled. When sqlite3_hard_heap_limit64(N) is invoked and the soft heap limit is outside the range of 1..N, then the soft heap limit is set to N. Invoking sqlite3_soft_heap_limit64(0) when the hard heap limit is enabled makes the soft heap limit equal to the hard heap limit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84963983acb45095ae249428915953ba1875b5f1" translate="yes" xml:space="preserve">
          <source>The solution was computed in less than 300 milliseconds on a modern workstation.</source>
          <target state="translated">Решение было рассчитано менее чем за 300 миллисекунд на современном рабочем месте.</target>
        </trans-unit>
        <trans-unit id="d8fc439428a4b57b8a635dfdc3bc6c9e9458a598" translate="yes" xml:space="preserve">
          <source>The solver works by adding new entries to the &quot;x&quot; recursive table. Given prior entries, the recursive-select tries to fill in a single new position with all values between 1 and 9 that actually work in that position. The complicated &quot;NOT EXISTS&quot; subquery is the magic that figures out whether or not each candidate &quot;s&quot; string is a valid sudoku puzzle or not.</source>
          <target state="translated">Решение работает путем добавления новых записей в рекурсивной таблице &quot;x&quot;.Учитывая предыдущие записи,рекурсивный выбор пытается заполнить одну новую позицию со всеми значениями от 1 до 9,которые на самом деле работают в этой позиции.Сложный подзапрос &quot;NOT EXISTS&quot;-это волшебство,которое определяет,является ли каждая строка кандидата &quot;s&quot; действительной головоломкой судоку или нет.</target>
        </trans-unit>
        <trans-unit id="a81e5007b5735cbaaaf41fe92b085a6bb28859ca" translate="yes" xml:space="preserve">
          <source>The sorter can use auxiliary helper threads to increase real-time response. This feature is off by default and may be enabled using the &lt;a href=&quot;pragma#pragma_threads&quot;&gt;PRAGMA threads&lt;/a&gt; command or the &lt;a href=&quot;compile#default_worker_threads&quot;&gt;SQLITE_DEFAULT_WORKER_THREADS&lt;/a&gt; compile-time option.</source>
          <target state="translated">Сортировщик может использовать вспомогательные вспомогательные потоки для увеличения отклика в реальном времени. Эта функция по умолчанию отключена и может быть включена с помощью команды &lt;a href=&quot;pragma#pragma_threads&quot;&gt;PRAGMA threads&lt;/a&gt; или параметра &lt;a href=&quot;compile#default_worker_threads&quot;&gt;времени&lt;/a&gt; компиляции SQLITE_DEFAULT_WORKER_THREADS .</target>
        </trans-unit>
        <trans-unit id="f3082f533e58c712999cbf940673f567d8a29017" translate="yes" xml:space="preserve">
          <source>The soundex(X) function returns a string that is the soundex encoding of the string X. The string &quot;?000&quot; is returned if the argument is NULL or contains no ASCII alphabetic characters. This function is omitted from SQLite by default. It is only available if the &lt;a href=&quot;compile#soundex&quot;&gt;SQLITE_SOUNDEX&lt;/a&gt; compile-time option is used when SQLite is built.</source>
          <target state="translated">Функция soundex (X) возвращает строку, которая является кодировкой soundex строки X. Строка &amp;laquo;? 000&amp;raquo; возвращается, если аргумент равен NULL или не содержит буквенных символов ASCII. По умолчанию эта функция отсутствует в SQLite. Он доступен, только если используется &lt;a href=&quot;compile#soundex&quot;&gt;параметр времени&lt;/a&gt; компиляции SQLITE_SOUNDEX при сборке SQLite.</target>
        </trans-unit>
        <trans-unit id="9611e60fec986c004f40bb3986af444fd02497aa" translate="yes" xml:space="preserve">
          <source>The source &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; may be used by the application for other purposes while a backup operation is underway or being initialized. If SQLite is compiled and configured to support threadsafe database connections, then the source database connection may be used concurrently from within other threads.</source>
          <target state="translated">Соединение с исходной &lt;a href=&quot;#sqlite3&quot;&gt;базой данных&lt;/a&gt; может использоваться приложением для других целей, пока выполняется или инициализируется операция резервного копирования. Если SQLite скомпилирован и настроен для поддержки поточно-безопасных соединений с базой данных, то соединение с исходной базой данных может использоваться одновременно из других потоков.</target>
        </trans-unit>
        <trans-unit id="d46770cf519d64fb4869e93bb4ebad2a0d214ebb" translate="yes" xml:space="preserve">
          <source>The source &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; may be used by the application for other purposes while a backup operation is underway or being initialized. If SQLite is compiled and configured to support threadsafe database connections, then the source database connection may be used concurrently from within other threads.</source>
          <target state="translated">Соединение с исходной &lt;a href=&quot;sqlite3&quot;&gt;базой данных&lt;/a&gt; может использоваться приложением для других целей, пока выполняется или инициализируется операция резервного копирования. Если SQLite скомпилирован и настроен для поддержки поточно-безопасных соединений с базой данных, то соединение с исходной базой данных может использоваться одновременно из других потоков.</target>
        </trans-unit>
        <trans-unit id="cb98bce78cf336a453aacfd68f1f2a70ccf1bb9e" translate="yes" xml:space="preserve">
          <source>The source code files for other SQL database engines typically begin with a comment describing your legal rights to view and copy that file. The SQLite source code contains no license since it is not governed by copyright. Instead of a license, the SQLite source code offers a blessing:</source>
          <target state="translated">Файлы исходного кода для других движков баз данных SQL обычно начинаются с комментария,описывающего ваши законные права на просмотр и копирование этого файла.Исходный код SQLite не содержит лицензии,так как он не регулируется авторским правом.Вместо лицензии исходный код SQLite предлагает благословение:</target>
        </trans-unit>
        <trans-unit id="b230daf41ab11e7921fa2a959263c09c6fe7e609" translate="yes" xml:space="preserve">
          <source>The source code for Geopoly is included in the &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt; but is not included in the library unless the &lt;a href=&quot;compile#enable_geopoly&quot;&gt;-DSQLITE_ENABLE_GEOPOLY&lt;/a&gt; compile-time option is used.</source>
          <target state="translated">Исходный код для Geopoly включен в &lt;a href=&quot;amalgamation&quot;&gt;объединение,&lt;/a&gt; но не включен в библиотеку, если не используется параметр &lt;a href=&quot;compile#enable_geopoly&quot;&gt;-DSQLITE_ENABLE_GEOPOLY&lt;/a&gt; во время компиляции.</target>
        </trans-unit>
        <trans-unit id="9ce563d47e369284dcc9eb90d209f5fe50c9d87d" translate="yes" xml:space="preserve">
          <source>The source code for SQLite is in the public domain. No claim of copyright is made on any part of the core source code. (The documentation and test code is a different matter - some sections of documentation and test logic are governed by open-source licenses.) All contributors to the SQLite core software have signed affidavits specifically disavowing any copyright interest in the code. This means that anybody is able to legally do anything they want with the SQLite source code.</source>
          <target state="translated">Исходный код SQLite находится в открытом доступе.Никакие авторские права не распространяются на любую часть основного исходного кода.(Документация и тестовый код-это другой вопрос-некоторые разделы документации и тестовая логика регулируются лицензиями с открытым исходным кодом).Все разработчики основного программного обеспечения SQLite подписали аффидевиты,в которых конкретно отказываются от любых авторских прав на код.Это означает,что любой человек может на законных основаниях делать с исходным кодом SQLite все,что угодно.</target>
        </trans-unit>
        <trans-unit id="1cfec4458134c689073b56a3f124a05cfee319a4" translate="yes" xml:space="preserve">
          <source>The source code in public SQLite releases uses unix line endings (ASCII code 10: &quot;newline&quot; only, NL) and spaces instead of tabs. If you will be changing the line ending to windows-style line endings (ASCII codes 13, 10: &quot;carriage-return&quot; and &quot;newline&quot;; CR-NL) or if you will be changing space indents into tab indents, &lt;b&gt;make that change now&lt;/b&gt; before you check in the baseline. The merging process will only work well if the differences between the public and the private branches are minimal. If every single line of the source file is changed in the private branch because you changed from NL to CR-NL line endings, then the merge steps will not work correctly.</source>
          <target state="translated">В исходном коде общедоступных выпусков SQLite используются окончания строк unix (код ASCII 10: только &amp;laquo;новая строка&amp;raquo;, NL) и пробелы вместо табуляции. Если вы измените окончание строки на окончание строки в стиле Windows (коды ASCII 13, 10: &amp;laquo;возврат каретки&amp;raquo; и &amp;laquo;новая строка&amp;raquo;; CR-NL) или если вы собираетесь заменять отступы пробелов на отступы табуляции, &lt;b&gt;внесите это изменение теперь,&lt;/b&gt; прежде чем вы проверяете базовый уровень. Процесс слияния будет успешным только в том случае, если различия между государственной и частной ветвями минимальны. Если каждая отдельная строка исходного файла изменена в частной ветви, потому что вы изменили окончание строки с NL на CR-NL, то шаги слияния не будут работать правильно.</target>
        </trans-unit>
        <trans-unit id="c71fe30151d8d1ffe822e83fe610e421f8822069" translate="yes" xml:space="preserve">
          <source>The source code module that implements the spellfix1 virtual table also implements several SQL functions that might be useful to applications that employ spellfix1 or for testing or diagnostic work while developing applications that use spellfix1. The following auxiliary functions are available:</source>
          <target state="translated">Модуль исходного кода,реализующий виртуальную таблицу spellfix1,также реализует несколько SQL-функций,которые могут быть полезны приложениям,использующим spellfix1,а также для тестирования или диагностики при разработке приложений,использующих spellfix1.Доступны следующие вспомогательные функции:</target>
        </trans-unit>
        <trans-unit id="06e0d7a5506cbf178b35ec85914ad01a3f38017c" translate="yes" xml:space="preserve">
          <source>The source code to SQLite is designed to be readable and accessible to the average programmer. All procedures and data structures and many automatic variables are carefully commented with useful information about what they do. Boilerplate commenting is omitted.</source>
          <target state="translated">Исходный код SQLite разработан таким образом,чтобы быть удобочитаемым и доступным среднестатистическому программисту.Все процедуры и структуры данных,а также многие автоматические переменные тщательно прокомментированы с полезной информацией о том,что они делают.Комментарий к Boilerplate опущен.</target>
        </trans-unit>
        <trans-unit id="042c70a1cba19758906aae3ec84cad7dc8c53383" translate="yes" xml:space="preserve">
          <source>The source code to the SQLite R*Tree module is included as part of the &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt; but is disabled by default. To enable the R*Tree module, simply compile with the &lt;a href=&quot;compile#enable_rtree&quot;&gt;SQLITE_ENABLE_RTREE&lt;/a&gt; C-preprocessor macro defined. With many compilers, this is accomplished by adding the option &quot;-DSQLITE_ENABLE_RTREE=1&quot; to the compiler command-line.</source>
          <target state="translated">Исходный код модуля SQLite R * Tree включен как часть &lt;a href=&quot;amalgamation&quot;&gt;объединения,&lt;/a&gt; но по умолчанию отключен. Чтобы включить модуль R * Tree, просто скомпилируйте с определенным &lt;a href=&quot;compile#enable_rtree&quot;&gt;макросом SQLITE_ENABLE_RTREE&lt;/a&gt; C-препроцессора. Во многих компиляторах это достигается путем добавления опции &quot;-DSQLITE_ENABLE_RTREE = 1&quot; в командную строку компилятора.</target>
        </trans-unit>
        <trans-unit id="a40cbeb8ac52569bca99e948856ab4db846ed02b" translate="yes" xml:space="preserve">
          <source>The source code to the bytecode engine is in the &lt;a href=&quot;http://www.sqlite.org/src/file/src/vdbe.c&quot;&gt;vdbe.c&lt;/a&gt; source file. The &lt;a href=&quot;opcode#codes&quot;&gt;opcode definitions&lt;/a&gt; in this document are derived from comments in that source file. The source code comments are the canonical source of information about the bytecode engine. When in doubt, refer to the source code.</source>
          <target state="translated">Исходный код механизма байт-кода находится в исходном файле &lt;a href=&quot;http://www.sqlite.org/src/file/src/vdbe.c&quot;&gt;vdbe.c. &lt;/a&gt;Определения &lt;a href=&quot;opcode#codes&quot;&gt;кодов операций&lt;/a&gt; в этом документе основаны на комментариях в этом исходном файле. Комментарии к исходному коду являются каноническим источником информации о механизме байт-кода. В случае сомнений обратитесь к исходному коду.</target>
        </trans-unit>
        <trans-unit id="ec46398b190fd4712f7c9072a7d45135878f4398" translate="yes" xml:space="preserve">
          <source>The source code to the bytecode engine is in the &lt;a href=&quot;https://www.sqlite.org/src/file/src/vdbe.c&quot;&gt;vdbe.c&lt;/a&gt; source file. The &lt;a href=&quot;opcode#codes&quot;&gt;opcode definitions&lt;/a&gt; in this document are derived from comments in that source file. The source code comments are the canonical source of information about the bytecode engine. When in doubt, refer to the source code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="013177e363c21284dd8426d7c41bb413bf325a0a" translate="yes" xml:space="preserve">
          <source>The source code to the software that runs the checklists is stored in its own Fossil repository at &lt;a href=&quot;https://www.sqlite.org/checklistapp&quot;&gt;https://www.sqlite.org/checklistapp&lt;/a&gt;.</source>
          <target state="translated">Исходный код программного обеспечения, запускающего контрольные списки, хранится в собственном репозитории Fossil по адресу &lt;a href=&quot;https://www.sqlite.org/checklistapp&quot;&gt;https://www.sqlite.org/checklistapp&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="79b8e8d26e2fd4c36bb8b15bd366cedd02031771" translate="yes" xml:space="preserve">
          <source>The source code to the sqlite3 command line interface is in a single file named &quot;shell.c&quot;. The shell.c source file is generated from other sources, but most of the code for shell.c can be found in &lt;a href=&quot;https://sqlite.org/src/file/src/shell.c.in&quot;&gt;src/shell.c.in&lt;/a&gt;. (Regenerate shell.c by typing &quot;make shell.c&quot; from the canonical source tree.) &lt;a href=&quot;howtocompile&quot;&gt;Compile&lt;/a&gt; the shell.c file (together with the &lt;a href=&quot;amalgamation&quot;&gt;sqlite3 library source code&lt;/a&gt;) to generate the executable. For example:</source>
          <target state="translated">Исходный код интерфейса командной строки sqlite3 находится в одном файле с именем &amp;laquo;shell.c&amp;raquo;. Исходный файл shell.c создается из других источников, но большую часть кода для shell.c можно найти в &lt;a href=&quot;https://sqlite.org/src/file/src/shell.c.in&quot;&gt;src / shell.c.in&lt;/a&gt; . (Восстановите shell.c, набрав &amp;laquo;make shell.c&amp;raquo; из канонического исходного дерева.) &lt;a href=&quot;howtocompile&quot;&gt;Скомпилируйте&lt;/a&gt; файл shell.c (вместе с &lt;a href=&quot;amalgamation&quot;&gt;исходным кодом библиотеки&lt;/a&gt; sqlite3 ), чтобы сгенерировать исполняемый файл. Например:</target>
        </trans-unit>
        <trans-unit id="3baebed042eebfba10dcbc501e7f4785bd1f6d07" translate="yes" xml:space="preserve">
          <source>The source file and entry point are named for &quot;unionvtab&quot; instead of &quot;swarmvtab&quot;. Unionvtab is a &lt;a href=&quot;unionvtab&quot;&gt;separately documented&lt;/a&gt; virtual table that is bundled with swarmvtab.</source>
          <target state="translated">Исходный файл и точка входа названы по имени unionvtab вместо swarmvtab. Unionvtab - это &lt;a href=&quot;unionvtab&quot;&gt;отдельно документированная&lt;/a&gt; виртуальная таблица, которая входит в комплект swarmvtab.</target>
        </trans-unit>
        <trans-unit id="f3fba365763538ecbddb6c57bd7009fd058f9084" translate="yes" xml:space="preserve">
          <source>The special &quot;:memory:&quot; filename also works when using &lt;a href=&quot;uri&quot;&gt;URI filenames&lt;/a&gt;. For example:</source>
          <target state="translated">Специальное имя файла &quot;: memory:&quot; также работает при использовании &lt;a href=&quot;uri&quot;&gt;имен файлов URI&lt;/a&gt; . Например:</target>
        </trans-unit>
        <trans-unit id="e94ff833d41c9d30c15767ac9e7aeb85daf442aa" translate="yes" xml:space="preserve">
          <source>The special UPSERT processing happens only for uniqueness constraint on the table that is receiving the INSERT. A &quot;uniqueness constraint&quot; is an explicit UNIQUE or PRIMARY KEY constraint within the CREATE TABLE statement, or a &lt;a href=&quot;lang_createindex#uniqueidx&quot;&gt;unique index&lt;/a&gt;. UPSERT does not intervene for failed NOT NULL or foreign key constraints or for constraints that are implemented using triggers.</source>
          <target state="translated">Специальная обработка UPSERT происходит только для ограничения уникальности таблицы, которая получает INSERT. &amp;laquo;Ограничение уникальности&amp;raquo; - это явное ограничение UNIQUE или PRIMARY KEY в операторе CREATE TABLE или &lt;a href=&quot;lang_createindex#uniqueidx&quot;&gt;уникальный индекс&lt;/a&gt; . UPSERT не вмешивается в случае неудачных ограничений NOT NULL или внешнего ключа или ограничений, которые реализованы с помощью триггеров.</target>
        </trans-unit>
        <trans-unit id="2e94e3f68bdf7fc07fc0dcd878c089797a3fe9a2" translate="yes" xml:space="preserve">
          <source>The special filename &quot;:memory:&quot; can be used anywhere that a database filename is permitted. For example, it can be used as the</source>
          <target state="translated">Специальное имя файла &quot;:memory:&quot; может быть использовано везде,где разрешено использование имени файла базы данных.Например,оно может быть использовано как</target>
        </trans-unit>
        <trans-unit id="dff68709141a31a267598fa549dc38cfbd61c946" translate="yes" xml:space="preserve">
          <source>The special processing for opening ZIP archives is a trick of the command-line shell, not the core SQLite library. So if you want to open a ZIP archive as a database in your application, you will need to activate the &lt;a href=&quot;zipfile&quot;&gt;Zipfile virtual table&lt;/a&gt; module then run an appropriate &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; statement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29bca994e11cb6f841a93aac5cdb8471376e38df" translate="yes" xml:space="preserve">
          <source>The specified column of row iRow contains a value that is not a TEXT or BLOB value,</source>
          <target state="translated">Указанный столбец строки iRow содержит значение,которое не является значением TEXT или BLOB,</target>
        </trans-unit>
        <trans-unit id="06e48e6df6f51c35512fa45acc8a0e8a634c95f8" translate="yes" xml:space="preserve">
          <source>The speedtest1.c program is updated from time to time as the SQLite developers' understanding of what constitutes &quot;typical&quot; usage evolves.</source>
          <target state="translated">Программа speedtest1.c время от времени обновляется по мере развития понимания разработчиками SQLite,что такое &quot;типичное&quot; использование.</target>
        </trans-unit>
        <trans-unit id="5446f248e6916745d646dc3f5e88e893b3ad00cc" translate="yes" xml:space="preserve">
          <source>The speedtest1.c workload that is being measured tries to be representative of a wide range of typical uses of SQLite. But every application is different. The speedtest1.c workload might not be a good proxy for the kinds of activities performed by some applications. The SQLite developers are constantly working to improve the speedtest1.c program, to make it a better proxy for actual SQLite usage. Community feedback is welcomed.</source>
          <target state="translated">Измеряемая рабочая нагрузка speedtest1.c пытается быть репрезентативной для широкого диапазона типичного использования SQLite.Но каждое приложение отличается от других.Рабочая нагрузка speedtest1.c может не быть хорошим прокси-сервером для видов деятельности,выполняемых некоторыми приложениями.Разработчики SQLite постоянно работают над улучшением программы speedtest1.c,чтобы сделать ее лучшим прокси для фактического использования SQLite.Обратная связь с сообществом приветствуется.</target>
        </trans-unit>
        <trans-unit id="92167de554e681259504f6e2f3edf942b7026bd6" translate="yes" xml:space="preserve">
          <source>The spellfix1 virtual table creates a single shadow table named &quot;%_vocab&quot; (where the % is replaced by the name of the virtual table; Ex: &quot;demo_vocab&quot; for the &quot;demo&quot; virtual table). the shadow table contains the following columns:</source>
          <target state="translated">Виртуальная таблица spellfix1 создает единственную теневую таблицу с именем &quot;%_vocab&quot; (где % заменяется именем виртуальной таблицы;Ex:&quot;demo_vocab&quot; для виртуальной таблицы &quot;demo&quot;).теневая таблица содержит следующие столбцы:</target>
        </trans-unit>
        <trans-unit id="f9097157fe13f14b48b89617ee87aed62da83c73" translate="yes" xml:space="preserve">
          <source>The spellfix1 virtual table uses editdist3 if the &quot;edit_cost_table=TABLE&quot; option is specified as an argument when the spellfix1 virtual table is created. But editdist3 can also be tested directly using the built-in &quot;editdist3()&quot; SQL function. The editdist3() SQL function has 3 forms:</source>
          <target state="translated">Виртуальная таблица spellfix1 использует editdist3,если в качестве аргумента при создании виртуальной таблицы spellfix1 указана опция &quot;edit_cost_table=TABLE&quot;.Но editdist3 также может быть протестирован непосредственно с помощью встроенной SQL-функции &quot;editdist3()&quot;.SQL-функция editdist3()имеет 3 формы:</target>
        </trans-unit>
        <trans-unit id="e416e23f51996e4d87d84d45407db4bd482280e4" translate="yes" xml:space="preserve">
          <source>The sqlar_compress(X) function attempts to compress a copy of the string or blob X using the &lt;a href=&quot;https://zlib.net/&quot;&gt;Default&lt;/a&gt; algorithm and returns the result as a blob. If the input X is incompressible, then a copy of X is returned. This routine is used when inserting content into an SQLite Archive.</source>
          <target state="translated">Функция sqlar_compress (X) пытается сжать копию строки или большого двоичного объекта X, используя алгоритм по &lt;a href=&quot;https://zlib.net/&quot;&gt;умолчанию&lt;/a&gt; , и возвращает результат в виде большого двоичного объекта . Если вход X несжимаемый, то возвращается копия X. Эта процедура используется при вставке содержимого в архив SQLite.</target>
        </trans-unit>
        <trans-unit id="0c132e268d7082089985d58b1716bee78c9b6c72" translate="yes" xml:space="preserve">
          <source>The sqlar_uncompress(Y,SZ) function will undo the compression accomplished by sqlar_compress(X). The Y parameter is the compressed content (the output from a prior call to sqlar_compress()) and SZ is the original uncompressed size of the input X that generated Y. If SZ is less than or equal to the size of Y, that indicates that no compression occurred, and so sqlar_uncompress(Y,SZ) returns a copy of Y. Otherwise, sqlar_uncompress(Y,SZ) runs the Inflate algorithm on Y to uncompress it and restore it to its original form and returns the uncompressed content. This routine is used when extracting content from an SQLite Archive.</source>
          <target state="translated">Функция sqlar_uncompress(Y,SZ)отменит компрессию,выполненную sqlar_compress(X).Параметр Y-это сжатое содержимое (вывод из предыдущего вызова sqlar_compress()),а SZ-исходный несжатый размер входа X,который генерировал Y.Если SZ меньше или равна размеру Y,это означает,что сжатия не произошло,и поэтому sqlar_uncompress(Y,SZ)возвращает копию Y.В противном случае,sqlar_uncompress(Y,SZ)запускает алгоритм Inflate по Y,чтобы распаковать его и восстановить в исходном виде,а затем возвращает несжатое содержимое.Эта рутина используется при извлечении содержимого из архива SQLite.</target>
        </trans-unit>
        <trans-unit id="9894bd2027e1ec7fe1defc073eb794af8cfcddba" translate="yes" xml:space="preserve">
          <source>The sqldiff.exe utility does not (currently) display differences in &lt;a href=&quot;lang_createtrigger&quot;&gt;TRIGGERs&lt;/a&gt; or &lt;a href=&quot;lang_createview&quot;&gt;VIEWs&lt;/a&gt;.</source>
          <target state="translated">Утилита sqldiff.exe (в настоящее время) не отображает различия в &lt;a href=&quot;lang_createtrigger&quot;&gt;TRIGGER&lt;/a&gt; или &lt;a href=&quot;lang_createview&quot;&gt;VIEW&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1eec35831f2ddb18882fbe495fb78b6e88f27f70" translate="yes" xml:space="preserve">
          <source>The sqldiff.exe utility is unable to compute differences for rowid tables for which the rowid is inaccessible. An example of a table with an inaccessible rowid is:</source>
          <target state="translated">Утилита sqldiff.exe не может вычислить различия для таблиц rowid,для которых rowid недоступен.Пример таблицы с недоступным rowid:</target>
        </trans-unit>
        <trans-unit id="199f0fae6d132ab01eeef495a83df7f5456338b1" translate="yes" xml:space="preserve">
          <source>The sqldiff.exe utility works by finding rows in the source and destination that are logical &quot;pairs&quot;. The default behavior is to treat two rows as pairs if they are in tables with the same name and they have the same &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;, or in the case of a &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; table if they have the same &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt;. Any differences in the content of paired rows are output as UPDATEs. Rows in the source database that could not be paired are output as DELETEs. Rows in the destination database that could not be paired are output as INSERTs.</source>
          <target state="translated">Утилита sqldiff.exe работает, находя строки в источнике и месте назначения, которые являются логическими &amp;laquo;парами&amp;raquo;. По умолчанию две строки рассматриваются как пары, если они находятся в таблицах с одинаковыми именами и имеют одинаковый &lt;a href=&quot;lang_createtable#rowid&quot;&gt;идентификатор строки&lt;/a&gt; , или в случае таблицы &lt;a href=&quot;withoutrowid&quot;&gt;БЕЗ ROWID,&lt;/a&gt; если у них одинаковый &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;ПЕРВИЧНЫЙ КЛЮЧ&lt;/a&gt; . Любые различия в содержимом парных строк выводятся как ОБНОВЛЕНИЯ. Строки в исходной базе данных, которые не удалось объединить в пары, выводятся как DELETE. Строки в целевой базе данных, которые не могут быть объединены в пары, выводятся как INSERT.</target>
        </trans-unit>
        <trans-unit id="5a94a70315a765a01576195e900e88922987242a" translate="yes" xml:space="preserve">
          <source>The sqlite3 program is able to show the results of a query in 14 different formats:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a33930cce71afaf2bac4391a7d92f2102fe6799" translate="yes" xml:space="preserve">
          <source>The sqlite3 program is able to show the results of a query in eight different formats: &quot;csv&quot;, &quot;column&quot;, &quot;html&quot;, &quot;insert&quot;, &quot;line&quot;, &quot;list&quot;, &quot;quote&quot;, &quot;tabs&quot;, and &quot;tcl&quot;. You can use the &quot;.mode&quot; dot command to switch between these output formats.</source>
          <target state="translated">Программа sqlite3 способна показывать результаты запроса в восьми различных форматах:&quot;csv&quot;,&quot;столбец&quot;,&quot;html&quot;,&quot;вставить&quot;,&quot;строка&quot;,&quot;список&quot;,&quot;кавычки&quot;,&quot;вкладки&quot; и &quot;tcl&quot;.Вы можете использовать точечную команду &quot;.mode&quot; для переключения между этими форматами вывода.</target>
        </trans-unit>
        <trans-unit id="c934dde95758c5fad9d43c84ef7f4c41bf3fe114" translate="yes" xml:space="preserve">
          <source>The sqlite3 program provides several convenience commands that are useful for looking at the schema of the database. There is nothing that these commands do that cannot be done by some other means. These commands are provided purely as a shortcut.</source>
          <target state="translated">Программа sqlite3 предоставляет несколько удобных команд,которые полезны для просмотра схемы БД.В этих командах нет ничего такого,что нельзя было бы сделать какими-либо другими способами.Эти команды предоставляются исключительно в виде ярлыка.</target>
        </trans-unit>
        <trans-unit id="d730ebfc68ed44661fe9aaa4784f842bff23a6ec" translate="yes" xml:space="preserve">
          <source>The sqlite3_aggregate_context(C,N) routine returns a NULL pointer when first called if N is less than or equal to zero or if a memory allocate error occurs.</source>
          <target state="translated">Рутина sqlite3_aggregate_context(C,N)возвращает указатель NULL при первом вызове,если N меньше или равно нулю,или если произошла ошибка выделения памяти.</target>
        </trans-unit>
        <trans-unit id="a781b80076608933fb39f35323ee417edf53e9fb" translate="yes" xml:space="preserve">
          <source>The sqlite3_analyzer utility program is updated to provide better descriptions and to compute a more accurate estimate for &quot;Non-sequential pages&quot;</source>
          <target state="translated">Утилита-анализатор sqlite3_Analyzer обновлена для получения более точных описаний и вычисления более точной оценки для &quot;Непоследовательных страниц&quot;.</target>
        </trans-unit>
        <trans-unit id="cea6cec9b3cecf3cdb8b21b8c439ffacaf7e4757" translate="yes" xml:space="preserve">
          <source>The sqlite3_analyzer.exe Utility Program</source>
          <target state="translated">Коммунальная программа sqlite3_nalyzer.exe</target>
        </trans-unit>
        <trans-unit id="08064e181ad262ed7b2155684ee88c71ec311b40" translate="yes" xml:space="preserve">
          <source>The sqlite3_analyzer.exe utility is updated to report the depth of each btree and to show the average fanout for indexes and WITHOUT ROWID tables.</source>
          <target state="translated">Обновлена утилита sqlite3_nalyzer.exe,которая сообщает глубину каждого дерева и показывает средний размах для индексов и таблиц БЕЗ ROWID.</target>
        </trans-unit>
        <trans-unit id="69ea749b99043a4585c42b36d581974b4510bba7" translate="yes" xml:space="preserve">
          <source>The sqlite3_backup object records state information about an ongoing online backup operation. The sqlite3_backup object is created by a call to &lt;a href=&quot;#sqlite3backupinit&quot;&gt;sqlite3_backup_init()&lt;/a&gt; and is destroyed by a call to &lt;a href=&quot;#sqlite3backupfinish&quot;&gt;sqlite3_backup_finish()&lt;/a&gt;.</source>
          <target state="translated">Объект sqlite3_backup записывает информацию о состоянии текущей операции резервного копирования в оперативном режиме. Объект sqlite3_backup создается вызовом &lt;a href=&quot;#sqlite3backupinit&quot;&gt;sqlite3_backup_init ()&lt;/a&gt; и уничтожается вызовом &lt;a href=&quot;#sqlite3backupfinish&quot;&gt;sqlite3_backup_finish ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ff5c92c4105199925092609d2d9f802d1fa55672" translate="yes" xml:space="preserve">
          <source>The sqlite3_backup object records state information about an ongoing online backup operation. The sqlite3_backup object is created by a call to &lt;a href=&quot;backup_finish#sqlite3backupinit&quot;&gt;sqlite3_backup_init()&lt;/a&gt; and is destroyed by a call to &lt;a href=&quot;backup_finish#sqlite3backupfinish&quot;&gt;sqlite3_backup_finish()&lt;/a&gt;.</source>
          <target state="translated">Объект sqlite3_backup записывает информацию о состоянии текущей операции резервного копирования в оперативном режиме. Объект sqlite3_backup создается вызовом &lt;a href=&quot;backup_finish#sqlite3backupinit&quot;&gt;sqlite3_backup_init ()&lt;/a&gt; и уничтожается вызовом &lt;a href=&quot;backup_finish#sqlite3backupfinish&quot;&gt;sqlite3_backup_finish ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="db586a6cde9f4397b1aba32074e60460ba79310a" translate="yes" xml:space="preserve">
          <source>The sqlite3_backup_remaining() and sqlite3_backup_pagecount() APIs report values stored by the previous call to sqlite3_backup_step(), they do not actually inspect the source database file. This means that if the source database is written to by another thread or process after the call to sqlite3_backup_step() returns but before the values returned by sqlite3_backup_remaining() and sqlite3_backup_pagecount() are used, the values may be technically incorrect. This is not usually a problem.</source>
          <target state="translated">API sqlite3_backup_remaining()и sqlite3_backup_pagecount()сообщают в sqlite3_backup_step()значения,сохраненные при предыдущем вызове,фактически не проверяют файл исходной базы данных.Это означает,что если исходная база данных записывается другим потоком или процессом после вызова sqlite3_backup_step(),но до использования значений,возвращенных функциями sqlite3_backup_remaining()и sqlite3_backup_pagecount(),эти значения могут быть технически некорректными.Обычно это не является проблемой.</target>
        </trans-unit>
        <trans-unit id="ab13e83a5eec05a800456f808bd2ed14f96ad7d8" translate="yes" xml:space="preserve">
          <source>The sqlite3_backup_remaining() routine returns the number of pages still to be backed up at the conclusion of the most recent sqlite3_backup_step(). The sqlite3_backup_pagecount() routine returns the total number of pages in the source database at the conclusion of the most recent sqlite3_backup_step(). The values returned by these functions are only updated by sqlite3_backup_step(). If the source database is modified in a way that changes the size of the source database or the number of pages remaining, those changes are not reflected in the output of sqlite3_backup_pagecount() and sqlite3_backup_remaining() until after the next sqlite3_backup_step().</source>
          <target state="translated">Рутина sqlite3_backup_remaining()возвращает количество страниц,которые еще нужно зарезервировать по завершению последней функции sqlite3_backup_step().Рутина sqlite3_backup_pagecount()возвращает общее количество страниц в исходной базе данных по завершению последней функции sqlite3_backup_step().Значения,возвращаемые этими функциями,обновляются только функцией sqlite3_backup_step().Если исходная база данных изменяется таким образом,что изменяется размер исходной базы данных или количество оставшихся страниц,то эти изменения не отражаются в выводе sqlite3_backup_pagecount()и sqlite3_backup_remaining()до следующего sqlite3_backup_step().</target>
        </trans-unit>
        <trans-unit id="027c7809f8a158ea3a080d548eaba037441f7cc5" translate="yes" xml:space="preserve">
          <source>The sqlite3_backup_step() might return &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_READONLY&lt;/a&gt; if</source>
          <target state="translated">Sqlite3_backup_step () может вернуть &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_READONLY,&lt;/a&gt; если</target>
        </trans-unit>
        <trans-unit id="44bfd22dba6c2a0335c1b72cfe8865a0ed15325c" translate="yes" xml:space="preserve">
          <source>The sqlite3_backup_step() might return &lt;a href=&quot;../rescode#readonly&quot;&gt;SQLITE_READONLY&lt;/a&gt; if</source>
          <target state="translated">Sqlite3_backup_step () может вернуть &lt;a href=&quot;../rescode#readonly&quot;&gt;SQLITE_READONLY,&lt;/a&gt; если</target>
        </trans-unit>
        <trans-unit id="a2f8db9336dd78e8265a2d46cc59a9e446011dc7" translate="yes" xml:space="preserve">
          <source>The sqlite3_bind_* routines return &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; on success or an &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; if anything goes wrong. &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_TOOBIG&lt;/a&gt; might be returned if the size of a string or BLOB exceeds limits imposed by &lt;a href=&quot;#sqlite3_limit&quot;&gt;sqlite3_limit&lt;/a&gt;(&lt;a href=&quot;#sqlitelimitlength&quot;&gt;SQLITE_LIMIT_LENGTH&lt;/a&gt;) or &lt;a href=&quot;limits#max_length&quot;&gt;SQLITE_MAX_LENGTH&lt;/a&gt;. &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_RANGE&lt;/a&gt; is returned if the parameter index is out of range. &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOMEM&lt;/a&gt; is returned if malloc() fails.</source>
          <target state="translated">Подпрограммы sqlite3_bind_ * возвращают &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; в случае успеха или &lt;a href=&quot;rescode&quot;&gt;код ошибки,&lt;/a&gt; если что-то пойдет не так. &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_TOOBIG&lt;/a&gt; может быть возвращен, если размер строки или BLOB превышает ограничения, налагаемые &lt;a href=&quot;#sqlite3_limit&quot;&gt;sqlite3_limit&lt;/a&gt; ( &lt;a href=&quot;#sqlitelimitlength&quot;&gt;SQLITE_LIMIT_LENGTH&lt;/a&gt; ) или &lt;a href=&quot;limits#max_length&quot;&gt;SQLITE_MAX_LENGTH&lt;/a&gt; . &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_RANGE&lt;/a&gt; возвращается, если индекс параметра выходит за пределы допустимого диапазона. &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOMEM&lt;/a&gt; возвращается, если malloc () не работает.</target>
        </trans-unit>
        <trans-unit id="eb0da7fe06be85118ba3dab99ff46185b6777bbe" translate="yes" xml:space="preserve">
          <source>The sqlite3_bind_* routines return &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; on success or an &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; if anything goes wrong. &lt;a href=&quot;../rescode#toobig&quot;&gt;SQLITE_TOOBIG&lt;/a&gt; might be returned if the size of a string or BLOB exceeds limits imposed by &lt;a href=&quot;limit&quot;&gt;sqlite3_limit&lt;/a&gt;(&lt;a href=&quot;c_limit_attached#sqlitelimitlength&quot;&gt;SQLITE_LIMIT_LENGTH&lt;/a&gt;) or &lt;a href=&quot;../limits#max_length&quot;&gt;SQLITE_MAX_LENGTH&lt;/a&gt;. &lt;a href=&quot;../rescode#range&quot;&gt;SQLITE_RANGE&lt;/a&gt; is returned if the parameter index is out of range. &lt;a href=&quot;../rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt; is returned if malloc() fails.</source>
          <target state="translated">Подпрограммы sqlite3_bind_ * возвращают &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; в случае успеха или &lt;a href=&quot;../rescode&quot;&gt;код ошибки,&lt;/a&gt; если что-то пойдет не так. &lt;a href=&quot;../rescode#toobig&quot;&gt;SQLITE_TOOBIG&lt;/a&gt; может быть возвращен, если размер строки или BLOB превышает ограничения, налагаемые &lt;a href=&quot;limit&quot;&gt;sqlite3_limit&lt;/a&gt; ( &lt;a href=&quot;c_limit_attached#sqlitelimitlength&quot;&gt;SQLITE_LIMIT_LENGTH&lt;/a&gt; ) или &lt;a href=&quot;../limits#max_length&quot;&gt;SQLITE_MAX_LENGTH&lt;/a&gt; . &lt;a href=&quot;../rescode#range&quot;&gt;SQLITE_RANGE&lt;/a&gt; возвращается, если индекс параметра выходит за пределы допустимого диапазона. &lt;a href=&quot;../rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt; возвращается, если malloc () не работает.</target>
        </trans-unit>
        <trans-unit id="6f71713542739e9593b1adb467245384ef671786" translate="yes" xml:space="preserve">
          <source>The sqlite3_bind_parameter_name(P,N) interface returns the name of the N-th &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;SQL parameter&lt;/a&gt; in the &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; P. SQL parameters of the form &quot;?NNN&quot; or &quot;:AAA&quot; or &quot;@AAA&quot; or &quot;$AAA&quot; have a name which is the string &quot;?NNN&quot; or &quot;:AAA&quot; or &quot;@AAA&quot; or &quot;$AAA&quot; respectively. In other words, the initial &quot;:&quot; or &quot;$&quot; or &quot;@&quot; or &quot;?&quot; is included as part of the name. Parameters of the form &quot;?&quot; without a following integer have no name and are referred to as &quot;nameless&quot; or &quot;anonymous parameters&quot;.</source>
          <target state="translated">Интерфейс sqlite3_bind_parameter_name (P, N) возвращает имя N-го &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;параметра SQL&lt;/a&gt; в &lt;a href=&quot;#sqlite3_stmt&quot;&gt;подготовленном операторе&lt;/a&gt; P. Параметры SQL в форме &amp;laquo;? NNN&amp;raquo; или &amp;laquo;: AAA&amp;raquo; или &amp;laquo;@AAA&amp;raquo; или &amp;laquo;$ AAA&amp;raquo; имеют имя, которое является строкой &amp;laquo;? NNN&amp;raquo; или &amp;laquo;: AAA&amp;raquo;, &amp;laquo;@AAA&amp;raquo; или &amp;laquo;$ AAA&amp;raquo; соответственно. Другими словами, начальные символы &amp;laquo;:&amp;raquo;, &amp;laquo;$&amp;raquo;, &amp;laquo;@&amp;raquo; или &amp;laquo;?&amp;raquo; входит как часть имени. Параметры формы &quot;?&quot; без следующего целого числа не имеют имени и называются &amp;laquo;безымянными&amp;raquo; или &amp;laquo;анонимными параметрами&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="8f7478b82c93544aa582bd52cdb8be854dddfaed" translate="yes" xml:space="preserve">
          <source>The sqlite3_bind_parameter_name(P,N) interface returns the name of the N-th &lt;a href=&quot;bind_blob&quot;&gt;SQL parameter&lt;/a&gt; in the &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; P. SQL parameters of the form &quot;?NNN&quot; or &quot;:AAA&quot; or &quot;@AAA&quot; or &quot;$AAA&quot; have a name which is the string &quot;?NNN&quot; or &quot;:AAA&quot; or &quot;@AAA&quot; or &quot;$AAA&quot; respectively. In other words, the initial &quot;:&quot; or &quot;$&quot; or &quot;@&quot; or &quot;?&quot; is included as part of the name. Parameters of the form &quot;?&quot; without a following integer have no name and are referred to as &quot;nameless&quot; or &quot;anonymous parameters&quot;.</source>
          <target state="translated">Интерфейс sqlite3_bind_parameter_name (P, N) возвращает имя N-го &lt;a href=&quot;bind_blob&quot;&gt;параметра SQL&lt;/a&gt; в &lt;a href=&quot;stmt&quot;&gt;подготовленном операторе&lt;/a&gt; P. Параметры SQL в форме &amp;laquo;? NNN&amp;raquo; или &amp;laquo;: AAA&amp;raquo; или &amp;laquo;@AAA&amp;raquo; или &amp;laquo;$ AAA&amp;raquo; имеют имя, которое является строкой &amp;laquo;? NNN&amp;raquo; или &amp;laquo;: AAA&amp;raquo;, &amp;laquo;@AAA&amp;raquo; или &amp;laquo;$ AAA&amp;raquo; соответственно. Другими словами, начальные символы &amp;laquo;:&amp;raquo;, &amp;laquo;$&amp;raquo;, &amp;laquo;@&amp;raquo; или &amp;laquo;?&amp;raquo; входит как часть имени. Параметры формы &quot;?&quot; без следующего целого числа не имеют имени и называются &amp;laquo;безымянными&amp;raquo; или &amp;laquo;анонимными параметрами&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="2f7ba9ace88be98840180479bfcb11ff0ebe16ce" translate="yes" xml:space="preserve">
          <source>The sqlite3_bind_pointer(S,I,P,T,D) routine causes the I-th parameter in &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; S to have an SQL value of NULL, but to also be associated with the pointer P of type T. D is either a NULL pointer or a pointer to a destructor function for P. SQLite will invoke the destructor D with a single argument of P when it is finished using P. The T parameter should be a static string, preferably a string literal. The sqlite3_bind_pointer() routine is part of the &lt;a href=&quot;bindptr&quot;&gt;pointer passing interface&lt;/a&gt; added for SQLite 3.20.0.</source>
          <target state="translated">Подпрограмма sqlite3_bind_pointer (S, I, P, T, D) заставляет I-й параметр в &lt;a href=&quot;#sqlite3_stmt&quot;&gt;подготовленном операторе&lt;/a&gt; S иметь значение SQL NULL, но также быть связанным с указателем P типа T. D является либо NULL указатель или указатель на функцию деструктора для P. SQLite вызовет деструктор D с одним аргументом P, когда он завершится с использованием P. Параметр T должен быть статической строкой, предпочтительно строковым литералом. Подпрограмма sqlite3_bind_pointer () является частью &lt;a href=&quot;bindptr&quot;&gt;интерфейса передачи указателя,&lt;/a&gt; добавленного для SQLite 3.20.0.</target>
        </trans-unit>
        <trans-unit id="658c91c6c69fa0e297b2600c0a7ae1e8d41b306a" translate="yes" xml:space="preserve">
          <source>The sqlite3_bind_pointer(S,I,P,T,D) routine causes the I-th parameter in &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; S to have an SQL value of NULL, but to also be associated with the pointer P of type T. D is either a NULL pointer or a pointer to a destructor function for P. SQLite will invoke the destructor D with a single argument of P when it is finished using P. The T parameter should be a static string, preferably a string literal. The sqlite3_bind_pointer() routine is part of the &lt;a href=&quot;../bindptr&quot;&gt;pointer passing interface&lt;/a&gt; added for SQLite 3.20.0.</source>
          <target state="translated">Подпрограмма sqlite3_bind_pointer (S, I, P, T, D) заставляет I-й параметр в &lt;a href=&quot;stmt&quot;&gt;подготовленном операторе&lt;/a&gt; S иметь значение SQL NULL, но также быть связанным с указателем P типа T. D является либо NULL указатель или указатель на функцию деструктора для P. SQLite вызовет деструктор D с одним аргументом P, когда он завершится с использованием P. Параметр T должен быть статической строкой, предпочтительно строковым литералом. Подпрограмма sqlite3_bind_pointer () является частью &lt;a href=&quot;../bindptr&quot;&gt;интерфейса передачи указателя,&lt;/a&gt; добавленного для SQLite 3.20.0.</target>
        </trans-unit>
        <trans-unit id="6397a7b2569f0831356316d22abee5d260da2f56" translate="yes" xml:space="preserve">
          <source>The sqlite3_bind_zeroblob() routine binds a BLOB of length N that is filled with zeroes. A zeroblob uses a fixed amount of memory (just an integer to hold its size) while it is being processed. Zeroblobs are intended to serve as placeholders for BLOBs whose content is later written using &lt;a href=&quot;#sqlite3_blob_open&quot;&gt;incremental BLOB I/O&lt;/a&gt; routines. A negative value for the zeroblob results in a zero-length BLOB.</source>
          <target state="translated">Подпрограмма sqlite3_bind_zeroblob () связывает большой двоичный объект длины N, заполненный нулями. Zeroblob использует фиксированный объем памяти (просто целое число для хранения его размера) во время обработки. Нулевые двоичные объекты предназначены для использования в качестве заполнителей для больших двоичных объектов, содержимое которых позже записывается с использованием процедур &lt;a href=&quot;#sqlite3_blob_open&quot;&gt;инкрементного ввода-вывода&lt;/a&gt; больших двоичных объектов . Отрицательное значение для zeroblob приводит к BLOB нулевой длины.</target>
        </trans-unit>
        <trans-unit id="c43ef2df76e0304e4b4beb3c8e7c5dbefc82b96b" translate="yes" xml:space="preserve">
          <source>The sqlite3_bind_zeroblob() routine binds a BLOB of length N that is filled with zeroes. A zeroblob uses a fixed amount of memory (just an integer to hold its size) while it is being processed. Zeroblobs are intended to serve as placeholders for BLOBs whose content is later written using &lt;a href=&quot;blob_open&quot;&gt;incremental BLOB I/O&lt;/a&gt; routines. A negative value for the zeroblob results in a zero-length BLOB.</source>
          <target state="translated">Подпрограмма sqlite3_bind_zeroblob () связывает большой двоичный объект длины N, заполненный нулями. Zeroblob использует фиксированный объем памяти (просто целое число для хранения его размера) во время обработки. Нулевые двоичные объекты предназначены для использования в качестве заполнителей для больших двоичных объектов, содержимое которых позже записывается с использованием процедур &lt;a href=&quot;blob_open&quot;&gt;инкрементного ввода-вывода&lt;/a&gt; больших двоичных объектов . Отрицательное значение для zeroblob приводит к BLOB нулевой длины.</target>
        </trans-unit>
        <trans-unit id="3d2cce49ac08682bc109d88559efafcb5bc906c9" translate="yes" xml:space="preserve">
          <source>The sqlite3_busy_handler(D,X,P) routine sets a callback function X that might be invoked with argument P whenever an attempt is made to access a database table associated with &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; D when another thread or process has the table locked. The sqlite3_busy_handler() interface is used to implement &lt;a href=&quot;#sqlite3_busy_timeout&quot;&gt;sqlite3_busy_timeout()&lt;/a&gt; and &lt;a href=&quot;pragma#pragma_busy_timeout&quot;&gt;PRAGMA busy_timeout&lt;/a&gt;.</source>
          <target state="translated">Подпрограмма sqlite3_busy_handler (D, X, P) устанавливает функцию обратного вызова X, которая может быть вызвана с аргументом P всякий раз, когда делается попытка доступа к таблице базы данных, связанной с &lt;a href=&quot;#sqlite3&quot;&gt;подключением к базе данных&lt;/a&gt; D, когда другой поток или процесс заблокировали таблицу. Интерфейс sqlite3_busy_handler () используется для реализации &lt;a href=&quot;#sqlite3_busy_timeout&quot;&gt;sqlite3_busy_timeout ()&lt;/a&gt; и &lt;a href=&quot;pragma#pragma_busy_timeout&quot;&gt;PRAGMA busy_timeout&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d3363e5f93709d191e40f4d06f477acdab0e375e" translate="yes" xml:space="preserve">
          <source>The sqlite3_busy_handler(D,X,P) routine sets a callback function X that might be invoked with argument P whenever an attempt is made to access a database table associated with &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; D when another thread or process has the table locked. The sqlite3_busy_handler() interface is used to implement &lt;a href=&quot;busy_timeout&quot;&gt;sqlite3_busy_timeout()&lt;/a&gt; and &lt;a href=&quot;../pragma#pragma_busy_timeout&quot;&gt;PRAGMA busy_timeout&lt;/a&gt;.</source>
          <target state="translated">Подпрограмма sqlite3_busy_handler (D, X, P) устанавливает функцию обратного вызова X, которая может быть вызвана с аргументом P всякий раз, когда делается попытка доступа к таблице базы данных, связанной с &lt;a href=&quot;sqlite3&quot;&gt;подключением к базе данных&lt;/a&gt; D, когда другой поток или процесс заблокировали таблицу. Интерфейс sqlite3_busy_handler () используется для реализации &lt;a href=&quot;busy_timeout&quot;&gt;sqlite3_busy_timeout ()&lt;/a&gt; и &lt;a href=&quot;../pragma#pragma_busy_timeout&quot;&gt;PRAGMA busy_timeout&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e8d93853c1f8ff5d06942fd5a08d82650ba96772" translate="yes" xml:space="preserve">
          <source>The sqlite3_close() and sqlite3_close_v2() routines are destructors for the &lt;a href=&quot;#sqlite3&quot;&gt;sqlite3&lt;/a&gt; object. Calls to sqlite3_close() and sqlite3_close_v2() return &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; if the &lt;a href=&quot;#sqlite3&quot;&gt;sqlite3&lt;/a&gt; object is successfully destroyed and all associated resources are deallocated.</source>
          <target state="translated">Подпрограммы sqlite3_close () и sqlite3_close_v2 () являются деструкторами для объекта &lt;a href=&quot;#sqlite3&quot;&gt;sqlite3&lt;/a&gt; . Звонки на sqlite3_close () и sqlite3_close_v2 () возвращает &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; если &lt;a href=&quot;#sqlite3&quot;&gt;sqlite3&lt;/a&gt; объект успешно разрушен , и все связанные с ним ресурсы высвобождены.</target>
        </trans-unit>
        <trans-unit id="c3b661e4a47ed928f3b7e88dd929f7831fe5385b" translate="yes" xml:space="preserve">
          <source>The sqlite3_close() and sqlite3_close_v2() routines are destructors for the &lt;a href=&quot;sqlite3&quot;&gt;sqlite3&lt;/a&gt; object. Calls to sqlite3_close() and sqlite3_close_v2() return &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; if the &lt;a href=&quot;sqlite3&quot;&gt;sqlite3&lt;/a&gt; object is successfully destroyed and all associated resources are deallocated.</source>
          <target state="translated">Подпрограммы sqlite3_close () и sqlite3_close_v2 () являются деструкторами для объекта &lt;a href=&quot;sqlite3&quot;&gt;sqlite3&lt;/a&gt; . Звонки на sqlite3_close () и sqlite3_close_v2 () возвращает &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; если &lt;a href=&quot;sqlite3&quot;&gt;sqlite3&lt;/a&gt; объект успешно разрушен , и все связанные с ним ресурсы высвобождены.</target>
        </trans-unit>
        <trans-unit id="2e35c3e04c8fe7269b95a0494cefdd5cde7acf02" translate="yes" xml:space="preserve">
          <source>The sqlite3_collation_needed() routine registers a callback which the database engine will invoke if it encounters an unknown collating sequence. The callback can lookup an appropriate comparison function and invoke sqlite_3_create_collation() as needed. The fourth parameter to the callback is the name of the collating sequence in UTF-8. For sqlite3_collation_need16() the callback sends the collating sequence name in UTF-16 host byte order.</source>
          <target state="translated">Рутина sqlite3_collation_need()регистрирует обратный вызов,который будет вызван движком БД,если он столкнется с неизвестной коллекционной последовательностью.Обратный вызов может найти соответствующую функцию сравнения и вызвать sqlite_3_create_collation()по мере необходимости.Четвертым параметром обратного вызова является имя коллекционной последовательности в UTF-8.Для sqlite3_collation_need16()обратный вызов посылает имя коллекционной последовательности в порядке байт хоста UTF-16.</target>
        </trans-unit>
        <trans-unit id="289668a545984e8fa7c4b426fa20f850363028a3" translate="yes" xml:space="preserve">
          <source>The sqlite3_column_decltype() routine returns text which is the declared type of the column in the CREATE TABLE statement. For an expression, the return type is an empty string. sqlite3_column_name() returns the name of the Nth column. sqlite3_column_bytes() returns the number of bytes in a column that has type BLOB or the number of bytes in a TEXT string with UTF-8 encoding. sqlite3_column_bytes16() returns the same value for BLOBs but for TEXT strings returns the number of bytes in a UTF-16 encoding. sqlite3_column_blob() return BLOB data. sqlite3_column_text() return TEXT data as UTF-8. sqlite3_column_text16() return TEXT data as UTF-16. sqlite3_column_int() return INTEGER data in the host machines native integer format. sqlite3_column_int64() returns 64-bit INTEGER data. Finally, sqlite3_column_double() return floating point data.</source>
          <target state="translated">Рутина sqlite3_column_decltype()возвращает текст,который является объявленным типом столбца в операторе CREATE TABLE.Для выражения тип возвращаемого текста-пустая строка.sqlite3_column_name()возвращает имя N-ой колонки.sqlite3_column_bytes()возвращает количество байт в колонке,имеющей тип BLOB или количество байт в TEXT-строке в кодировке UTF-8.sqlite3_column_bytes16()возвращает то же самое значение для BLOB-строк,но для TEXT-строк возвращает количество байт в кодировке UTF-16.sqlite3_column_blob()возвращает BLOB-данные.sqlite3_column_text()возвращает данные TEXT в кодировке UTF-8.sqlite3_column_text16()возвращает данные TEXT в кодировке UTF-16.sqlite3_column_int()возвращает данные INTEGER в родном целочисленном формате для хост-машин.sqlite3_column_int64()возвращает 64-битные данные INTEGER.Наконец,функция sqlite3_column_double()возвращает данные с плавающей точкой.</target>
        </trans-unit>
        <trans-unit id="a9b38d21f857b4d104b01ccf828564edcab9302b" translate="yes" xml:space="preserve">
          <source>The sqlite3_column_type() routine returns the &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;datatype code&lt;/a&gt; for the initial data type of the result column. The returned value is one of &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_INTEGER&lt;/a&gt;, &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_FLOAT&lt;/a&gt;, &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_TEXT&lt;/a&gt;, &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_BLOB&lt;/a&gt;, or &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_NULL&lt;/a&gt;. The return value of sqlite3_column_type() can be used to decide which of the first six interface should be used to extract the column value. The value returned by sqlite3_column_type() is only meaningful if no automatic type conversions have occurred for the value in question. After a type conversion, the result of calling sqlite3_column_type() is undefined, though harmless. Future versions of SQLite may change the behavior of sqlite3_column_type() following a type conversion.</source>
          <target state="translated">Подпрограмма sqlite3_column_type () возвращает &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;код типа данных&lt;/a&gt; для исходного типа данных столбца результата. Возвращаемое значение - одно из &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_INTEGER&lt;/a&gt; , &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_FLOAT&lt;/a&gt; , &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_TEXT&lt;/a&gt; , &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_BLOB&lt;/a&gt; или &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_NULL&lt;/a&gt; . Возвращаемое значение sqlite3_column_type () может использоваться, чтобы решить, какой из первых шести интерфейсов следует использовать для извлечения значения столбца. Значение, возвращаемое функцией sqlite3_column_type (), имеет смысл только в том случае, если для рассматриваемого значения не было выполнено автоматическое преобразование типов. После преобразования типа результат вызова sqlite3_column_type () не определен, но безвреден. В будущих версиях SQLite может измениться поведение sqlite3_column_type () после преобразования типа.</target>
        </trans-unit>
        <trans-unit id="d87c623fe2ec1f08f5218d69ec07d1b6f1fe406e" translate="yes" xml:space="preserve">
          <source>The sqlite3_column_type() routine returns the &lt;a href=&quot;c_blob&quot;&gt;datatype code&lt;/a&gt; for the initial data type of the result column. The returned value is one of &lt;a href=&quot;c_blob&quot;&gt;SQLITE_INTEGER&lt;/a&gt;, &lt;a href=&quot;c_blob&quot;&gt;SQLITE_FLOAT&lt;/a&gt;, &lt;a href=&quot;c_blob&quot;&gt;SQLITE_TEXT&lt;/a&gt;, &lt;a href=&quot;c_blob&quot;&gt;SQLITE_BLOB&lt;/a&gt;, or &lt;a href=&quot;c_blob&quot;&gt;SQLITE_NULL&lt;/a&gt;. The return value of sqlite3_column_type() can be used to decide which of the first six interface should be used to extract the column value. The value returned by sqlite3_column_type() is only meaningful if no automatic type conversions have occurred for the value in question. After a type conversion, the result of calling sqlite3_column_type() is undefined, though harmless. Future versions of SQLite may change the behavior of sqlite3_column_type() following a type conversion.</source>
          <target state="translated">Подпрограмма sqlite3_column_type () возвращает &lt;a href=&quot;c_blob&quot;&gt;код типа данных&lt;/a&gt; для исходного типа данных столбца результата. Возвращаемое значение - одно из &lt;a href=&quot;c_blob&quot;&gt;SQLITE_INTEGER&lt;/a&gt; , &lt;a href=&quot;c_blob&quot;&gt;SQLITE_FLOAT&lt;/a&gt; , &lt;a href=&quot;c_blob&quot;&gt;SQLITE_TEXT&lt;/a&gt; , &lt;a href=&quot;c_blob&quot;&gt;SQLITE_BLOB&lt;/a&gt; или &lt;a href=&quot;c_blob&quot;&gt;SQLITE_NULL&lt;/a&gt; . Возвращаемое значение sqlite3_column_type () может использоваться, чтобы решить, какой из первых шести интерфейсов следует использовать для извлечения значения столбца. Значение, возвращаемое функцией sqlite3_column_type (), имеет смысл только в том случае, если для рассматриваемого значения не было выполнено автоматическое преобразование типов. После преобразования типа результат вызова sqlite3_column_type () не определен, но безвреден. В будущих версиях SQLite может измениться поведение sqlite3_column_type () после преобразования типа.</target>
        </trans-unit>
        <trans-unit id="80c9429e83e0f6600057106ffc072b05d6e8df14" translate="yes" xml:space="preserve">
          <source>The sqlite3_commit_hook() interface registers a callback function to be invoked whenever a transaction is &lt;a href=&quot;../lang_transaction&quot;&gt;committed&lt;/a&gt;. Any callback set by a previous call to sqlite3_commit_hook() for the same database connection is overridden. The sqlite3_rollback_hook() interface registers a callback function to be invoked whenever a transaction is &lt;a href=&quot;../lang_transaction&quot;&gt;rolled back&lt;/a&gt;. Any callback set by a previous call to sqlite3_rollback_hook() for the same database connection is overridden. The pArg argument is passed through to the callback. If the callback on a commit hook function returns non-zero, then the commit is converted into a rollback.</source>
          <target state="translated">Интерфейс sqlite3_commit_hook () регистрирует функцию обратного вызова, которая будет вызываться всякий раз, когда транзакция &lt;a href=&quot;../lang_transaction&quot;&gt;фиксируется&lt;/a&gt; . Любой обратный вызов, установленный предыдущим вызовом sqlite3_commit_hook () для того же подключения к базе данных, отменяется. Интерфейс sqlite3_rollback_hook () регистрирует функцию обратного вызова, которая будет вызываться всякий раз, когда транзакция &lt;a href=&quot;../lang_transaction&quot;&gt;откатывается&lt;/a&gt; . Любой обратный вызов, установленный предыдущим вызовом sqlite3_rollback_hook () для того же подключения к базе данных, отменяется. Аргумент pArg передается функции обратного вызова. Если обратный вызов функции обработчика фиксации возвращает ненулевое значение, фиксация преобразуется в откат.</target>
        </trans-unit>
        <trans-unit id="c831f98581f1e28276e947cc54e55e8093cff2bf" translate="yes" xml:space="preserve">
          <source>The sqlite3_commit_hook() interface registers a callback function to be invoked whenever a transaction is &lt;a href=&quot;lang_transaction&quot;&gt;committed&lt;/a&gt;. Any callback set by a previous call to sqlite3_commit_hook() for the same database connection is overridden. The sqlite3_rollback_hook() interface registers a callback function to be invoked whenever a transaction is &lt;a href=&quot;lang_transaction&quot;&gt;rolled back&lt;/a&gt;. Any callback set by a previous call to sqlite3_rollback_hook() for the same database connection is overridden. The pArg argument is passed through to the callback. If the callback on a commit hook function returns non-zero, then the commit is converted into a rollback.</source>
          <target state="translated">Интерфейс sqlite3_commit_hook () регистрирует функцию обратного вызова, которая будет вызываться всякий раз, когда транзакция &lt;a href=&quot;lang_transaction&quot;&gt;фиксируется&lt;/a&gt; . Любой обратный вызов, установленный предыдущим вызовом sqlite3_commit_hook () для того же подключения к базе данных, отменяется. Интерфейс sqlite3_rollback_hook () регистрирует функцию обратного вызова, которая будет вызываться всякий раз, когда транзакция &lt;a href=&quot;lang_transaction&quot;&gt;откатывается&lt;/a&gt; . Любой обратный вызов, установленный предыдущим вызовом sqlite3_rollback_hook () для того же подключения к базе данных, отменяется. Аргумент pArg передается функции обратного вызова. Если обратный вызов функции обработчика фиксации возвращает ненулевое значение, фиксация преобразуется в откат.</target>
        </trans-unit>
        <trans-unit id="8ed0ff1b29d3e198ebfc7c54c6d04128fb45e5b9" translate="yes" xml:space="preserve">
          <source>The sqlite3_commit_hook(D,C,P) and sqlite3_rollback_hook(D,C,P) functions return the P argument from the previous call of the same function on the same &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; D, or NULL for the first call for each function on D.</source>
          <target state="translated">Функции sqlite3_commit_hook (D, C, P) и sqlite3_rollback_hook (D, C, P) возвращают аргумент P из предыдущего вызова той же функции в том же &lt;a href=&quot;#sqlite3&quot;&gt;соединении с базой данных&lt;/a&gt; D или NULL для первого вызова каждой функции на D.</target>
        </trans-unit>
        <trans-unit id="5c814d040fa0b2376c6a44e987d8d06f8d405641" translate="yes" xml:space="preserve">
          <source>The sqlite3_commit_hook(D,C,P) and sqlite3_rollback_hook(D,C,P) functions return the P argument from the previous call of the same function on the same &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; D, or NULL for the first call for each function on D.</source>
          <target state="translated">Функции sqlite3_commit_hook (D, C, P) и sqlite3_rollback_hook (D, C, P) возвращают аргумент P из предыдущего вызова той же функции в том же &lt;a href=&quot;sqlite3&quot;&gt;соединении с базой данных&lt;/a&gt; D или NULL для первого вызова каждой функции на D.</target>
        </trans-unit>
        <trans-unit id="a783ef29506da5187d0b6a8b529c5db8a199c982" translate="yes" xml:space="preserve">
          <source>The sqlite3_compileoption_get() function allows iterating over the list of options that were defined at compile time by returning the N-th compile time option string. If N is out of range, sqlite3_compileoption_get() returns a NULL pointer. The SQLITE_ prefix is omitted from any strings returned by sqlite3_compileoption_get().</source>
          <target state="translated">Функция sqlite3_compileoption_get()позволяет проводить итерации над списком опций,которые были определены при компиляции,возвращая строку N-ой опции времени компиляции.Если N находится вне диапазона,sqlite3_compileoption_get()возвращает указатель NULL.Префикс SQLITE_опускается из любых строк,возвращаемых функцией sqlite3_compileoption_get().</target>
        </trans-unit>
        <trans-unit id="39c27e864f7c32b9ceed46ceee3feba79ed9e6fc" translate="yes" xml:space="preserve">
          <source>The sqlite3_compileoption_used() function returns 0 or 1 indicating whether the specified option was defined at compile time. The SQLITE_ prefix may be omitted from the option name passed to sqlite3_compileoption_used().</source>
          <target state="translated">Функция sqlite3_compileoption_used()возвращает 0 или 1,указывая,была ли указанная опция определена во время компиляции.Префикс SQLITE_может быть опущен из названия опции,переданного в функцию sqlite3_compileoption_used().</target>
        </trans-unit>
        <trans-unit id="c2f7b71d769d28cabe75800e2f0fc786a0e3ca05" translate="yes" xml:space="preserve">
          <source>The sqlite3_config() interface is used to make global configuration changes to SQLite in order to tune SQLite to the specific needs of the application. The default configuration is recommended for most applications and so this routine is usually not necessary. It is provided to support rare applications with unusual needs.</source>
          <target state="translated">Интерфейс sqlite3_config()используется для внесения глобальных конфигурационных изменений в SQLite с целью настройки SQLite под конкретные потребности приложения.Конфигурация по умолчанию рекомендуется для большинства приложений,поэтому такая рутина обычно не требуется.Она предусмотрена для поддержки редких приложений с необычными потребностями.</target>
        </trans-unit>
        <trans-unit id="2a43551c13014713b84ff3176d603e20a0bb2d0e" translate="yes" xml:space="preserve">
          <source>The sqlite3_config() interface may only be invoked prior to library initialization using &lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_initialize()&lt;/a&gt; or after shutdown by &lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_shutdown()&lt;/a&gt;. If sqlite3_config() is called after &lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_initialize()&lt;/a&gt; and before &lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_shutdown()&lt;/a&gt; then it will return SQLITE_MISUSE. Note, however, that sqlite3_config() can be called as part of the implementation of an application-defined &lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_os_init()&lt;/a&gt;.</source>
          <target state="translated">Интерфейс sqlite3_config () можно вызывать только до инициализации библиотеки с помощью &lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_initialize ()&lt;/a&gt; или после завершения работы с помощью &lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_shutdown ()&lt;/a&gt; . Если sqlite3_config () вызывается после &lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_initialize ()&lt;/a&gt; и перед &lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_shutdown (),&lt;/a&gt; тогда он вернет SQLITE_MISUSE. Обратите внимание, однако, что sqlite3_config () может вызываться как часть реализации определяемой приложением &lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_os_init ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="950f596cd61399b38213d68d8e3371f1294cd97c" translate="yes" xml:space="preserve">
          <source>The sqlite3_config() interface may only be invoked prior to library initialization using &lt;a href=&quot;initialize&quot;&gt;sqlite3_initialize()&lt;/a&gt; or after shutdown by &lt;a href=&quot;initialize&quot;&gt;sqlite3_shutdown()&lt;/a&gt;. If sqlite3_config() is called after &lt;a href=&quot;initialize&quot;&gt;sqlite3_initialize()&lt;/a&gt; and before &lt;a href=&quot;initialize&quot;&gt;sqlite3_shutdown()&lt;/a&gt; then it will return SQLITE_MISUSE. Note, however, that sqlite3_config() can be called as part of the implementation of an application-defined &lt;a href=&quot;initialize&quot;&gt;sqlite3_os_init()&lt;/a&gt;.</source>
          <target state="translated">Интерфейс sqlite3_config () можно вызывать только до инициализации библиотеки с помощью &lt;a href=&quot;initialize&quot;&gt;sqlite3_initialize ()&lt;/a&gt; или после завершения работы с помощью &lt;a href=&quot;initialize&quot;&gt;sqlite3_shutdown ()&lt;/a&gt; . Если sqlite3_config () вызывается после &lt;a href=&quot;initialize&quot;&gt;sqlite3_initialize ()&lt;/a&gt; и перед &lt;a href=&quot;initialize&quot;&gt;sqlite3_shutdown (),&lt;/a&gt; тогда он вернет SQLITE_MISUSE. Обратите внимание, однако, что sqlite3_config () может вызываться как часть реализации определяемой приложением &lt;a href=&quot;initialize&quot;&gt;sqlite3_os_init ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f36e7397009cd60c7259be5a8cbdeb80264ff811" translate="yes" xml:space="preserve">
          <source>The sqlite3_context_db_handle() interface returns a copy of the pointer to the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; (the 1st parameter) of the &lt;a href=&quot;#sqlite3_create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_create_function&quot;&gt;sqlite3_create_function16()&lt;/a&gt; routines that originally registered the application defined function.</source>
          <target state="translated">Интерфейс sqlite3_context_db_handle () возвращает копию указателя на &lt;a href=&quot;#sqlite3&quot;&gt;соединение&lt;/a&gt; с базой данных (1-й параметр &lt;a href=&quot;#sqlite3_create_function&quot;&gt;)&lt;/a&gt; подпрограмм &lt;a href=&quot;#sqlite3_create_function&quot;&gt;sqlite3_create_function ()&lt;/a&gt; и sqlite3_create_function16 () , которые первоначально зарегистрировали функцию, определенную приложением.</target>
        </trans-unit>
        <trans-unit id="04b3afa93b5033ef2c02acd3a1ef18374b3a066e" translate="yes" xml:space="preserve">
          <source>The sqlite3_context_db_handle() interface returns a copy of the pointer to the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; (the 1st parameter) of the &lt;a href=&quot;create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt; and &lt;a href=&quot;create_function&quot;&gt;sqlite3_create_function16()&lt;/a&gt; routines that originally registered the application defined function.</source>
          <target state="translated">Интерфейс sqlite3_context_db_handle () возвращает копию указателя на &lt;a href=&quot;sqlite3&quot;&gt;соединение&lt;/a&gt; с базой данных (1-й параметр &lt;a href=&quot;create_function&quot;&gt;)&lt;/a&gt; подпрограмм &lt;a href=&quot;create_function&quot;&gt;sqlite3_create_function ()&lt;/a&gt; и sqlite3_create_function16 () , которые первоначально зарегистрировали функцию, определенную приложением.</target>
        </trans-unit>
        <trans-unit id="0b0f49ec423453d8567eeff6ab2f843591a04245" translate="yes" xml:space="preserve">
          <source>The sqlite3_create_collation() function honors the SQLITE_UTF16_ALIGNED flag.</source>
          <target state="translated">Функция sqlite3_create_collation()помечает флаг SQLITE_UTF16_ALIGNED.</target>
        </trans-unit>
        <trans-unit id="0e46987511170cbb4e8e90d14cfd9fe052087146" translate="yes" xml:space="preserve">
          <source>The sqlite3_create_collation() function specifies a collating sequence name and a comparison function to implement that collating sequence. The comparison function is only used for comparing text values. The eTextRep parameter is one of SQLITE_UTF8, SQLITE_UTF16LE, SQLITE_UTF16BE, or SQLITE_ANY to specify which text representation the comparison function works with. Separate comparison functions can exist for the same collating sequence for each of the UTF-8, UTF-16LE and UTF-16BE text representations. The sqlite3_create_collation16() works like sqlite3_create_collation() except that the collation name is specified in UTF-16 host byte order instead of in UTF-8.</source>
          <target state="translated">Функция sqlite3_create_collation()задает имя коллекционной последовательности и функцию сравнения для реализации этой коллекционной последовательности.Функция сравнения используется только для сравнения текстовых значений.Параметр eTextRep является одним из параметров SQLITE_UTF8,SQLITE_UTF16LE,SQLITE_UTF16BE или SQLITE_ANY для указания,с каким текстовым представлением работает функция сравнения.Отдельные функции сравнения могут существовать для одной и той же последовательности сравнения для каждого из текстовых представлений UTF-8,UTF-16LE и UTF-16BE.Функция sqlite3_create_collation16()работает как sqlite3_create_collation()за исключением того,что имя коллирования указывается в порядке байт хоста UTF-16,а не в UTF-8.</target>
        </trans-unit>
        <trans-unit id="3bb1bc030c0ecaf171e6e7837d4fc5ad509b9304" translate="yes" xml:space="preserve">
          <source>The sqlite3_create_collation_v2() works like sqlite3_create_collation() with the addition that the xDestroy callback is invoked on pArg when the collating function is deleted. Collating functions are deleted when they are overridden by later calls to the collation creation functions or when the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; is closed using &lt;a href=&quot;#sqlite3_close&quot;&gt;sqlite3_close()&lt;/a&gt;.</source>
          <target state="translated">Sqlite3_create_collation_v2 () работает аналогично sqlite3_create_collation () с добавлением того, что обратный вызов xDestroy вызывается в pArg при удалении функции сортировки. Функции сортировки удаляются, когда они переопределяются последующими вызовами функций создания сопоставления или когда &lt;a href=&quot;#sqlite3&quot;&gt;соединение&lt;/a&gt; с базой данных закрывается с помощью &lt;a href=&quot;#sqlite3_close&quot;&gt;sqlite3_close ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cce8a06023084f98541458166466b478b68c97fc" translate="yes" xml:space="preserve">
          <source>The sqlite3_create_collation_v2() works like sqlite3_create_collation() with the addition that the xDestroy callback is invoked on pArg when the collating function is deleted. Collating functions are deleted when they are overridden by later calls to the collation creation functions or when the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; is closed using &lt;a href=&quot;close&quot;&gt;sqlite3_close()&lt;/a&gt;.</source>
          <target state="translated">Sqlite3_create_collation_v2 () работает аналогично sqlite3_create_collation () с добавлением того, что обратный вызов xDestroy вызывается в pArg при удалении функции сортировки. Функции сортировки удаляются, когда они переопределяются последующими вызовами функций создания сопоставления или когда &lt;a href=&quot;sqlite3&quot;&gt;соединение&lt;/a&gt; с базой данных закрывается с помощью &lt;a href=&quot;close&quot;&gt;sqlite3_close ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="35eaa1fdb7403d0bf2c872e0985b90cb08324f23" translate="yes" xml:space="preserve">
          <source>The sqlite3_create_filename(D,J,W,N,P) allocates memory to hold a version of database filename D with corresponding journal file J and WAL file W and with N URI parameters key/values pairs in the array P. The result from sqlite3_create_filename(D,J,W,N,P) is a pointer to a database filename that is safe to pass to routines like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2321a78d45e7f791f5be9bd5eeeecdd73b61cbff" translate="yes" xml:space="preserve">
          <source>The sqlite3_create_module_v2() interface has a fifth parameter which is a pointer to a destructor for the pClientData. SQLite will invoke the destructor function (if it is not NULL) when SQLite no longer needs the pClientData pointer. The destructor will also be invoked if the call to sqlite3_create_module_v2() fails. The sqlite3_create_module() interface is equivalent to sqlite3_create_module_v2() with a NULL destructor.</source>
          <target state="translated">Интерфейс sqlite3_create_module_v2()имеет пятый параметр-указатель на деструктор для pClientData.SQLite вызовет функцию деструктора (если она не NULL),когда SQLite больше не будет нужен указатель на pClientData.Деструктор также будет вызван,если вызов sqlite3_create_module_v2()не удастся.Интерфейс sqlite3_create_module()эквивалентен sqlite3_create_module_v2()с деструктором NULL.</target>
        </trans-unit>
        <trans-unit id="ce43917c89192dc7d4a31aeaa86afac14bcedebc" translate="yes" xml:space="preserve">
          <source>The sqlite3_data_count(P) interface returns the number of columns in the current row of the result set of &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; P. If prepared statement P does not have results ready to return (via calls to the &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column()&lt;/a&gt; family of interfaces) then sqlite3_data_count(P) returns 0. The sqlite3_data_count(P) routine also returns 0 if P is a NULL pointer. The sqlite3_data_count(P) routine returns 0 if the previous call to &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step&lt;/a&gt;(P) returned &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_DONE&lt;/a&gt;. The sqlite3_data_count(P) will return non-zero if previous call to &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step&lt;/a&gt;(P) returned &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ROW&lt;/a&gt;, except in the case of the &lt;a href=&quot;pragma#pragma_incremental_vacuum&quot;&gt;PRAGMA incremental_vacuum&lt;/a&gt; where it always returns zero since each step of that multi-step pragma returns 0 columns of data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b23578428cca6b0b7cc9f351266849d54d3f4ac7" translate="yes" xml:space="preserve">
          <source>The sqlite3_data_count(P) interface returns the number of columns in the current row of the result set of &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; P. If prepared statement P does not have results ready to return (via calls to the &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_*()&lt;/a&gt; of interfaces) then sqlite3_data_count(P) returns 0. The sqlite3_data_count(P) routine also returns 0 if P is a NULL pointer. The sqlite3_data_count(P) routine returns 0 if the previous call to &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step&lt;/a&gt;(P) returned &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_DONE&lt;/a&gt;. The sqlite3_data_count(P) will return non-zero if previous call to &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step&lt;/a&gt;(P) returned &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ROW&lt;/a&gt;, except in the case of the &lt;a href=&quot;pragma#pragma_incremental_vacuum&quot;&gt;PRAGMA incremental_vacuum&lt;/a&gt; where it always returns zero since each step of that multi-step pragma returns 0 columns of data.</source>
          <target state="translated">Интерфейс sqlite3_data_count (P) возвращает количество столбцов в текущей строке набора результатов &lt;a href=&quot;#sqlite3_stmt&quot;&gt;подготовленного оператора&lt;/a&gt; P. Если подготовленный оператор P не имеет результатов, готовых к возврату (через вызовы &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column _ * ()&lt;/a&gt; интерфейсов), тогда sqlite3_data_count ( P) возвращает 0. Подпрограмма sqlite3_data_count (P) также возвращает 0, если P является указателем NULL. Подпрограмма sqlite3_data_count (P) возвращает 0, если предыдущий вызов &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step&lt;/a&gt; (P) вернул &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_DONE&lt;/a&gt; . Sqlite3_data_count (P) вернет ненулевое значение, если предыдущий вызов &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step&lt;/a&gt; (P) вернул &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ROW&lt;/a&gt; , за исключением случая &lt;a href=&quot;pragma#pragma_incremental_vacuum&quot;&gt;PRAGMA incremental_vacuum&lt;/a&gt;где он всегда возвращает ноль, поскольку каждый шаг этой многошаговой прагмы возвращает 0 столбцов данных.</target>
        </trans-unit>
        <trans-unit id="f5791b68b76b19a4a15dafbc0a31b6f189b8fc89" translate="yes" xml:space="preserve">
          <source>The sqlite3_data_count(P) interface returns the number of columns in the current row of the result set of &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; P. If prepared statement P does not have results ready to return (via calls to the &lt;a href=&quot;column_blob&quot;&gt;sqlite3_column()&lt;/a&gt; family of interfaces) then sqlite3_data_count(P) returns 0. The sqlite3_data_count(P) routine also returns 0 if P is a NULL pointer. The sqlite3_data_count(P) routine returns 0 if the previous call to &lt;a href=&quot;step&quot;&gt;sqlite3_step&lt;/a&gt;(P) returned &lt;a href=&quot;../rescode#done&quot;&gt;SQLITE_DONE&lt;/a&gt;. The sqlite3_data_count(P) will return non-zero if previous call to &lt;a href=&quot;step&quot;&gt;sqlite3_step&lt;/a&gt;(P) returned &lt;a href=&quot;../rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt;, except in the case of the &lt;a href=&quot;../pragma#pragma_incremental_vacuum&quot;&gt;PRAGMA incremental_vacuum&lt;/a&gt; where it always returns zero since each step of that multi-step pragma returns 0 columns of data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0331c5159620074031eabe2d2fffeb3879925815" translate="yes" xml:space="preserve">
          <source>The sqlite3_data_count(P) interface returns the number of columns in the current row of the result set of &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; P. If prepared statement P does not have results ready to return (via calls to the &lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_*()&lt;/a&gt; of interfaces) then sqlite3_data_count(P) returns 0. The sqlite3_data_count(P) routine also returns 0 if P is a NULL pointer. The sqlite3_data_count(P) routine returns 0 if the previous call to &lt;a href=&quot;step&quot;&gt;sqlite3_step&lt;/a&gt;(P) returned &lt;a href=&quot;../rescode#done&quot;&gt;SQLITE_DONE&lt;/a&gt;. The sqlite3_data_count(P) will return non-zero if previous call to &lt;a href=&quot;step&quot;&gt;sqlite3_step&lt;/a&gt;(P) returned &lt;a href=&quot;../rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt;, except in the case of the &lt;a href=&quot;../pragma#pragma_incremental_vacuum&quot;&gt;PRAGMA incremental_vacuum&lt;/a&gt; where it always returns zero since each step of that multi-step pragma returns 0 columns of data.</source>
          <target state="translated">Интерфейс sqlite3_data_count (P) возвращает количество столбцов в текущей строке набора результатов &lt;a href=&quot;stmt&quot;&gt;подготовленного оператора&lt;/a&gt; P. Если подготовленный оператор P не имеет результатов, готовых к возврату (через вызовы &lt;a href=&quot;column_blob&quot;&gt;sqlite3_column _ * ()&lt;/a&gt; интерфейсов), тогда sqlite3_data_count ( P) возвращает 0. Подпрограмма sqlite3_data_count (P) также возвращает 0, если P является указателем NULL. Подпрограмма sqlite3_data_count (P) возвращает 0, если предыдущий вызов &lt;a href=&quot;step&quot;&gt;sqlite3_step&lt;/a&gt; (P) вернул &lt;a href=&quot;../rescode#done&quot;&gt;SQLITE_DONE&lt;/a&gt; . Sqlite3_data_count (P) вернет ненулевое значение, если предыдущий вызов &lt;a href=&quot;step&quot;&gt;sqlite3_step&lt;/a&gt; (P) вернул &lt;a href=&quot;../rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt; , за исключением случая &lt;a href=&quot;../pragma#pragma_incremental_vacuum&quot;&gt;PRAGMA incremental_vacuum&lt;/a&gt;где он всегда возвращает ноль, поскольку каждый шаг этой многошаговой прагмы возвращает 0 столбцов данных.</target>
        </trans-unit>
        <trans-unit id="043836a9d52018cfd95036ef1de8601c0dd65b27" translate="yes" xml:space="preserve">
          <source>The sqlite3_db_config() interface is used to make configuration changes to a &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt;. The interface is similar to &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config()&lt;/a&gt; except that the changes apply to a single &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; (specified in the first argument).</source>
          <target state="translated">Интерфейс sqlite3_db_config () используется для внесения изменений в конфигурацию &lt;a href=&quot;#sqlite3&quot;&gt;соединения&lt;/a&gt; с базой данных . Интерфейс похож на &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config (),&lt;/a&gt; за исключением того, что изменения применяются к одному &lt;a href=&quot;#sqlite3&quot;&gt;соединению с базой данных&lt;/a&gt; (указанному в первом аргументе).</target>
        </trans-unit>
        <trans-unit id="cb382b8043f6bd41fb4e955562ae2dd8de8821a6" translate="yes" xml:space="preserve">
          <source>The sqlite3_db_config() interface is used to make configuration changes to a &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt;. The interface is similar to &lt;a href=&quot;config&quot;&gt;sqlite3_config()&lt;/a&gt; except that the changes apply to a single &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; (specified in the first argument).</source>
          <target state="translated">Интерфейс sqlite3_db_config () используется для внесения изменений в конфигурацию &lt;a href=&quot;sqlite3&quot;&gt;соединения&lt;/a&gt; с базой данных . Интерфейс похож на &lt;a href=&quot;config&quot;&gt;sqlite3_config (),&lt;/a&gt; за исключением того, что изменения применяются к одному &lt;a href=&quot;sqlite3&quot;&gt;соединению с базой данных&lt;/a&gt; (указанному в первом аргументе).</target>
        </trans-unit>
        <trans-unit id="d9890e9099b39efa9f23ed1209f98fc2abd695d1" translate="yes" xml:space="preserve">
          <source>The sqlite3_db_filename(D,N) interface returns a pointer to a filename associated with database N of connection D. The main database file has the name &quot;main&quot;. If there is no attached database N on the database connection D, or if database N is a temporary or in-memory database, then this function will return either a NULL pointer or an empty string.</source>
          <target state="translated">Интерфейс sqlite3_db_filename(D,N)возвращает указатель на имя файла,связанного с БД N соединения D.Основной файл БД имеет имя &quot;main&quot;.Если к БД с подключением D не подключена БД N,или БД N является временной или внутрипамятной БД,то данная функция вернет либо указатель NULL,либо пустую строку.</target>
        </trans-unit>
        <trans-unit id="6ce559d2134cd8f80b32424d9cafa088f3f1de6d" translate="yes" xml:space="preserve">
          <source>The sqlite3_db_filename(D,N) interface returns a pointer to the filename associated with database N of connection D. If there is no attached database N on the database connection D, or if database N is a temporary or in-memory database, then this function will return either a NULL pointer or an empty string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a0142f7765d452e556a6d1ade538189bbf023a1" translate="yes" xml:space="preserve">
          <source>The sqlite3_db_handle interface returns the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; handle to which a &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; belongs. The &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; returned by sqlite3_db_handle is the same &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; that was the first argument to the &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; call (or its variants) that was used to create the statement in the first place.</source>
          <target state="translated">Интерфейс sqlite3_db_handle возвращает дескриптор &lt;a href=&quot;#sqlite3&quot;&gt;соединения&lt;/a&gt; с базой данных, которому принадлежит &lt;a href=&quot;#sqlite3_stmt&quot;&gt;подготовленный оператор&lt;/a&gt; . Соединение с &lt;a href=&quot;#sqlite3&quot;&gt;базой данных,&lt;/a&gt; возвращаемое sqlite3_db_handle, является тем же &lt;a href=&quot;#sqlite3&quot;&gt;соединением с базой данных,&lt;/a&gt; которое было первым аргументом вызова &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; (или его вариантов), который изначально использовался для создания оператора.</target>
        </trans-unit>
        <trans-unit id="0ed4944069eec7d7c0e7904b6909ffc71d6a37af" translate="yes" xml:space="preserve">
          <source>The sqlite3_db_handle interface returns the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; handle to which a &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; belongs. The &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; returned by sqlite3_db_handle is the same &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; that was the first argument to the &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; call (or its variants) that was used to create the statement in the first place.</source>
          <target state="translated">Интерфейс sqlite3_db_handle возвращает дескриптор &lt;a href=&quot;sqlite3&quot;&gt;соединения&lt;/a&gt; с базой данных, которому принадлежит &lt;a href=&quot;stmt&quot;&gt;подготовленный оператор&lt;/a&gt; . Соединение с &lt;a href=&quot;sqlite3&quot;&gt;базой данных,&lt;/a&gt; возвращаемое sqlite3_db_handle, является тем же &lt;a href=&quot;sqlite3&quot;&gt;соединением с базой данных,&lt;/a&gt; которое было первым аргументом вызова &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; (или его вариантов), который изначально использовался для создания оператора.</target>
        </trans-unit>
        <trans-unit id="f13e3d008759351c9d014a67b0c7d66c909c38ed" translate="yes" xml:space="preserve">
          <source>The sqlite3_db_readonly(D,N) interface returns 1 if the database N of connection D is read-only, 0 if it is read/write, or -1 if N is not the name of a database on connection D.</source>
          <target state="translated">Интерфейс sqlite3_db_readonly(D,N)возвращает 1,если БД N соединения D доступна только для чтения,0,если оно доступно для чтения/записи или -1,если N не является именем БД по соединению D.</target>
        </trans-unit>
        <trans-unit id="7c54e0312a49676acc8e0fa5a98fa6c3ca389049" translate="yes" xml:space="preserve">
          <source>The sqlite3_db_release_memory(D) interface attempts to free as much heap memory as possible from database connection D. Unlike the &lt;a href=&quot;#sqlite3_release_memory&quot;&gt;sqlite3_release_memory()&lt;/a&gt; interface, this interface is in effect even when the &lt;a href=&quot;compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt; compile-time option is omitted.</source>
          <target state="translated">Интерфейс sqlite3_db_release_memory (D) пытается освободить как можно больше памяти кучи из соединения с базой данных D. В отличие от интерфейса &lt;a href=&quot;#sqlite3_release_memory&quot;&gt;sqlite3_release_memory ()&lt;/a&gt; , этот интерфейс действует даже в том случае, если параметр &lt;a href=&quot;compile#enable_memory_management&quot;&gt;времени&lt;/a&gt; компиляции SQLITE_ENABLE_MEMORY_MANAGEMENT опущен.</target>
        </trans-unit>
        <trans-unit id="a4505b330dae36966abd878a7a5251bb10a809a6" translate="yes" xml:space="preserve">
          <source>The sqlite3_db_release_memory(D) interface attempts to free as much heap memory as possible from database connection D. Unlike the &lt;a href=&quot;release_memory&quot;&gt;sqlite3_release_memory()&lt;/a&gt; interface, this interface is in effect even when the &lt;a href=&quot;../compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt; compile-time option is omitted.</source>
          <target state="translated">Интерфейс sqlite3_db_release_memory (D) пытается освободить как можно больше памяти кучи из соединения с базой данных D. В отличие от интерфейса &lt;a href=&quot;release_memory&quot;&gt;sqlite3_release_memory ()&lt;/a&gt; , этот интерфейс действует даже в том случае, если параметр &lt;a href=&quot;../compile#enable_memory_management&quot;&gt;времени&lt;/a&gt; компиляции SQLITE_ENABLE_MEMORY_MANAGEMENT опущен.</target>
        </trans-unit>
        <trans-unit id="83634ce6a2d174966fca0f07d2eb6e5e52439e9f" translate="yes" xml:space="preserve">
          <source>The sqlite3_db_status() routine returns SQLITE_OK on success and a non-zero &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; on failure.</source>
          <target state="translated">Подпрограмма sqlite3_db_status () возвращает SQLITE_OK в случае успеха и ненулевой &lt;a href=&quot;../rescode&quot;&gt;код ошибки&lt;/a&gt; в случае ошибки.</target>
        </trans-unit>
        <trans-unit id="7babdc84886f95b16b07a064461180aa8e231247" translate="yes" xml:space="preserve">
          <source>The sqlite3_db_status() routine returns SQLITE_OK on success and a non-zero &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; on failure.</source>
          <target state="translated">Подпрограмма sqlite3_db_status () возвращает SQLITE_OK в случае успеха и ненулевой &lt;a href=&quot;rescode&quot;&gt;код ошибки&lt;/a&gt; в случае ошибки.</target>
        </trans-unit>
        <trans-unit id="18d47ae58f8b29dbac7701bb014dc19e22eadf62" translate="yes" xml:space="preserve">
          <source>The sqlite3_deserialize() interface will fail with SQLITE_BUSY if the database is currently in a read transaction or is involved in a backup operation.</source>
          <target state="translated">Интерфейс sqlite3_deserialize()не будет работать с SQLITE_BUSY,если база данных в данный момент находится в транзакции чтения или участвует в операции резервного копирования.</target>
        </trans-unit>
        <trans-unit id="12340c8333dc6a82eca44a1f4c8bbf0434fac375" translate="yes" xml:space="preserve">
          <source>The sqlite3_deserialize(D,S,P,N,M,F) interface causes the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; D to disconnect from database S and then reopen S as an in-memory database based on the serialization contained in P. The serialized database P is N bytes in size. M is the size of the buffer P, which might be larger than N. If M is larger than N, and the SQLITE_DESERIALIZE_READONLY bit is not set in F, then SQLite is permitted to add content to the in-memory database as long as the total size does not exceed M bytes.</source>
          <target state="translated">Интерфейс sqlite3_deserialize (D, S, P, N, M, F) заставляет &lt;a href=&quot;#sqlite3&quot;&gt;соединение&lt;/a&gt; D с базой данных отключиться от базы данных S, а затем повторно открыть S как базу данных в памяти на основе сериализации, содержащейся в P. Сериализованная база данных P равна N байтов размером. M - это размер буфера P, который может быть больше N. Если M больше N, а бит SQLITE_DESERIALIZE_READONLY не установлен в F, то SQLite разрешено добавлять контент в базу данных в памяти, пока общий размер не превышает M байтов.</target>
        </trans-unit>
        <trans-unit id="afac5ec67e0561a540471ae51b94788f3734ed79" translate="yes" xml:space="preserve">
          <source>The sqlite3_deserialize(D,S,P,N,M,F) interface causes the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; D to disconnect from database S and then reopen S as an in-memory database based on the serialization contained in P. The serialized database P is N bytes in size. M is the size of the buffer P, which might be larger than N. If M is larger than N, and the SQLITE_DESERIALIZE_READONLY bit is not set in F, then SQLite is permitted to add content to the in-memory database as long as the total size does not exceed M bytes.</source>
          <target state="translated">Интерфейс sqlite3_deserialize (D, S, P, N, M, F) заставляет &lt;a href=&quot;sqlite3&quot;&gt;соединение&lt;/a&gt; D с базой данных отключиться от базы данных S, а затем повторно открыть S как базу данных в памяти на основе сериализации, содержащейся в P. Сериализованная база данных P равна N байтов размером. M - это размер буфера P, который может быть больше N. Если M больше N, а бит SQLITE_DESERIALIZE_READONLY не установлен в F, то SQLite разрешено добавлять контент в базу данных в памяти, пока общий размер не превышает M байтов.</target>
        </trans-unit>
        <trans-unit id="6ae05681a8b59259daa468a1d8590729337a135a" translate="yes" xml:space="preserve">
          <source>The sqlite3_drop_modules(D,L) interface removes all virtual table modules from database connection D except those named on list L. The L parameter must be either NULL or a pointer to an array of pointers to strings where the array is terminated by a single NULL pointer. If the L parameter is NULL, then all virtual table modules are removed.</source>
          <target state="translated">Интерфейс sqlite3_drop_modules(D,L)удаляет из соединения с БД D все модули виртуальных таблиц,кроме модулей,указанных в списке L.Параметр L должен быть либо NULL,либо указателем на массив указателей на строки,где массив завершается одним NULL указателем.Если параметр L равен NULL,то удаляются все виртуальные модули таблиц.</target>
        </trans-unit>
        <trans-unit id="cb17fe8b042f1bd6f76a39ed23dd1524edfc2345" translate="yes" xml:space="preserve">
          <source>The sqlite3_errcode() routine returns a result code for the most recent major API call. sqlite3_errmsg() returns an English-language text error message for the most recent error. The error message is represented in UTF-8 and will be ephemeral - it could disappear on the next call to any SQLite API function. sqlite3_errmsg16() works like sqlite3_errmsg() except that it returns the error message represented as UTF-16 in host native byte order.</source>
          <target state="translated">Рутина sqlite3_errcode()возвращает код результата последнего основного вызова API.sqlite3_errmsg()возвращает англоязычное текстовое сообщение об ошибке последнего вызова API.Сообщение об ошибке представлено в UTF-8 и будет эфемерным-оно может исчезнуть при следующем вызове любой функции API SQLite.sqlite3_errmsg16()работает как sqlite3_errmsg()за исключением того,что возвращает сообщение об ошибке,представленное в виде UTF-16 в родном для хоста порядке байт.</target>
        </trans-unit>
        <trans-unit id="5e0d9cf7c1277961ee0db98705525eacc5bb425f" translate="yes" xml:space="preserve">
          <source>The sqlite3_errmsg() and sqlite3_errmsg16() return English-language text that describes the error, as either UTF-8 or UTF-16 respectively. Memory to hold the error message string is managed internally. The application does not need to worry about freeing the result. However, the error string might be overwritten or deallocated by subsequent calls to other SQLite interface functions.</source>
          <target state="translated">Функции sqlite3_errmsg()и sqlite3_errmsg16()возвращают англоязычный текст,который описывает ошибку как UTF-8 или UTF-16 соответственно.Память для хранения строки сообщения об ошибке управляется внутренне.Приложению не нужно беспокоиться об освобождении результата.Однако строка сообщения об ошибке может быть перезаписана или удалена последующими вызовами других функций интерфейса SQLite.</target>
        </trans-unit>
        <trans-unit id="a3b2d05546afbeecb20b8fe87e3f3189bfedb642" translate="yes" xml:space="preserve">
          <source>The sqlite3_errstr() interface returns the English-language text that describes the &lt;a href=&quot;../rescode&quot;&gt;result code&lt;/a&gt;, as UTF-8. Memory to hold the error message string is managed internally and must not be freed by the application.</source>
          <target state="translated">Интерфейс sqlite3_errstr () возвращает текст на английском языке, который описывает &lt;a href=&quot;../rescode&quot;&gt;код результата&lt;/a&gt; , как UTF-8. Память для хранения строки сообщения об ошибке управляется внутренне и не должна освобождаться приложением.</target>
        </trans-unit>
        <trans-unit id="3185f0fefecbff2d0db8b69bac9298083b70809e" translate="yes" xml:space="preserve">
          <source>The sqlite3_errstr() interface returns the English-language text that describes the &lt;a href=&quot;rescode&quot;&gt;result code&lt;/a&gt;, as UTF-8. Memory to hold the error message string is managed internally and must not be freed by the application.</source>
          <target state="translated">Интерфейс sqlite3_errstr () возвращает текст на английском языке, который описывает &lt;a href=&quot;rescode&quot;&gt;код результата&lt;/a&gt; , как UTF-8. Память для хранения строки сообщения об ошибке управляется внутренне и не должна освобождаться приложением.</target>
        </trans-unit>
        <trans-unit id="eec19de3d00e4cd6319cb02ddf72d5b612e30300" translate="yes" xml:space="preserve">
          <source>The sqlite3_exec() interface is a convenience wrapper around &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt;, and &lt;a href=&quot;#sqlite3_finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt;, that allows an application to run multiple statements of SQL without having to use a lot of C code.</source>
          <target state="translated">Интерфейс sqlite3_exec () - это удобная оболочка для &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step ()&lt;/a&gt; и &lt;a href=&quot;#sqlite3_finalize&quot;&gt;sqlite3_finalize ()&lt;/a&gt; , которая позволяет приложению запускать несколько операторов SQL без необходимости использования большого количества кода C.</target>
        </trans-unit>
        <trans-unit id="9a4e88bd32574fff7b2361feb6cf37710d7194a2" translate="yes" xml:space="preserve">
          <source>The sqlite3_exec() interface is a convenience wrapper around &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt;, &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt;, and &lt;a href=&quot;finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt;, that allows an application to run multiple statements of SQL without having to use a lot of C code.</source>
          <target state="translated">Интерфейс sqlite3_exec () - это удобная оболочка для &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; , &lt;a href=&quot;step&quot;&gt;sqlite3_step ()&lt;/a&gt; и &lt;a href=&quot;finalize&quot;&gt;sqlite3_finalize ()&lt;/a&gt; , которая позволяет приложению запускать несколько операторов SQL без необходимости использования большого количества кода C.</target>
        </trans-unit>
        <trans-unit id="5f6ecb5327784e2b3ab3076a060e42400e8e6e49" translate="yes" xml:space="preserve">
          <source>The sqlite3_exec() interface runs zero or more UTF-8 encoded, semicolon-separate SQL statements passed into its 2nd argument, in the context of the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; passed in as its 1st argument. If the callback function of the 3rd argument to sqlite3_exec() is not NULL, then it is invoked for each result row coming out of the evaluated SQL statements. The 4th argument to sqlite3_exec() is relayed through to the 1st argument of each callback invocation. If the callback pointer to sqlite3_exec() is NULL, then no callback is ever invoked and result rows are ignored.</source>
          <target state="translated">Интерфейс sqlite3_exec () выполняет ноль или более операторов SQL в кодировке UTF-8, разделенных точкой с запятой, переданных во второй аргумент в контексте соединения с &lt;a href=&quot;#sqlite3&quot;&gt;базой данных,&lt;/a&gt; переданного в качестве первого аргумента. Если функция обратного вызова третьего аргумента sqlite3_exec () не имеет значения NULL, то она вызывается для каждой строки результата, полученной из оцененных операторов SQL. 4-й аргумент sqlite3_exec () передается 1-му аргументу каждого вызова обратного вызова. Если указатель обратного вызова на sqlite3_exec () равен NULL, то обратный вызов никогда не вызывается, а строки результатов игнорируются.</target>
        </trans-unit>
        <trans-unit id="7f2bf987e70ab4f6565417a4f7295b79e8706b9e" translate="yes" xml:space="preserve">
          <source>The sqlite3_exec() interface runs zero or more UTF-8 encoded, semicolon-separate SQL statements passed into its 2nd argument, in the context of the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; passed in as its 1st argument. If the callback function of the 3rd argument to sqlite3_exec() is not NULL, then it is invoked for each result row coming out of the evaluated SQL statements. The 4th argument to sqlite3_exec() is relayed through to the 1st argument of each callback invocation. If the callback pointer to sqlite3_exec() is NULL, then no callback is ever invoked and result rows are ignored.</source>
          <target state="translated">Интерфейс sqlite3_exec () выполняет ноль или более операторов SQL в кодировке UTF-8, разделенных точкой с запятой, переданных во второй аргумент в контексте соединения с &lt;a href=&quot;sqlite3&quot;&gt;базой данных,&lt;/a&gt; переданного в качестве первого аргумента. Если функция обратного вызова третьего аргумента sqlite3_exec () не имеет значения NULL, то она вызывается для каждой строки результата, полученной из оцененных операторов SQL. 4-й аргумент sqlite3_exec () передается 1-му аргументу каждого вызова обратного вызова. Если указатель обратного вызова на sqlite3_exec () равен NULL, то обратный вызов никогда не вызывается, а строки результатов игнорируются.</target>
        </trans-unit>
        <trans-unit id="fdc80de144729ab29ec768dc45f521935b24167a" translate="yes" xml:space="preserve">
          <source>The sqlite3_expanded_sql() interface returns NULL if insufficient memory is available to hold the result, or if the result would exceed the the maximum string length determined by the &lt;a href=&quot;#sqlitelimitlength&quot;&gt;SQLITE_LIMIT_LENGTH&lt;/a&gt;.</source>
          <target state="translated">Интерфейс sqlite3_expanded_sql () возвращает NULL, если недостаточно памяти для хранения результата или если результат превысит максимальную длину строки, определяемую параметром &lt;a href=&quot;#sqlitelimitlength&quot;&gt;SQLITE_LIMIT_LENGTH&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="253eafa1da6e36def799917e15566e8c664899fe" translate="yes" xml:space="preserve">
          <source>The sqlite3_expanded_sql() interface returns NULL if insufficient memory is available to hold the result, or if the result would exceed the the maximum string length determined by the &lt;a href=&quot;c_limit_attached#sqlitelimitlength&quot;&gt;SQLITE_LIMIT_LENGTH&lt;/a&gt;.</source>
          <target state="translated">Интерфейс sqlite3_expanded_sql () возвращает NULL, если недостаточно памяти для хранения результата или если результат превысит максимальную длину строки, определяемую параметром &lt;a href=&quot;c_limit_attached#sqlitelimitlength&quot;&gt;SQLITE_LIMIT_LENGTH&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1d1fd4c0ad3995d89a0ef41f1f46affc2269eba4" translate="yes" xml:space="preserve">
          <source>The sqlite3_extended_result_codes() routine enables or disables the &lt;a href=&quot;../rescode#extrc&quot;&gt;extended result codes&lt;/a&gt; feature of SQLite. The extended result codes are disabled by default for historical compatibility.</source>
          <target state="translated">Подпрограмма sqlite3_extended_result_codes () включает или отключает функцию &lt;a href=&quot;../rescode#extrc&quot;&gt;расширенных кодов результатов&lt;/a&gt; SQLite. Расширенные коды результатов по умолчанию отключены для исторической совместимости.</target>
        </trans-unit>
        <trans-unit id="904ab00e0ae19fa09117889888e1162471d32017" translate="yes" xml:space="preserve">
          <source>The sqlite3_extended_result_codes() routine enables or disables the &lt;a href=&quot;rescode#extrc&quot;&gt;extended result codes&lt;/a&gt; feature of SQLite. The extended result codes are disabled by default for historical compatibility.</source>
          <target state="translated">Подпрограмма sqlite3_extended_result_codes () включает или отключает функцию &lt;a href=&quot;rescode#extrc&quot;&gt;расширенных кодов результатов&lt;/a&gt; SQLite. Расширенные коды результатов по умолчанию отключены для исторической совместимости.</target>
        </trans-unit>
        <trans-unit id="5daeea1eac71cd621bf8b80af259a724f2e831b8" translate="yes" xml:space="preserve">
          <source>The sqlite3_finalize() function is called to delete a &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt;. If the most recent evaluation of the statement encountered no errors or if the statement is never been evaluated, then sqlite3_finalize() returns SQLITE_OK. If the most recent evaluation of statement S failed, then sqlite3_finalize(S) returns the appropriate &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; or &lt;a href=&quot;rescode#extrc&quot;&gt;extended error code&lt;/a&gt;.</source>
          <target state="translated">Функция sqlite3_finalize () вызывается для удаления &lt;a href=&quot;#sqlite3_stmt&quot;&gt;подготовленного оператора&lt;/a&gt; . Если последняя оценка оператора не обнаружила ошибок или если оператор никогда не оценивался, то sqlite3_finalize () возвращает SQLITE_OK. Если последняя оценка оператора S завершилась неудачно, sqlite3_finalize (S) возвращает соответствующий &lt;a href=&quot;rescode&quot;&gt;код ошибки&lt;/a&gt; или &lt;a href=&quot;rescode#extrc&quot;&gt;расширенный код ошибки&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="74837217c620c1e41ee1e321a9ad17968e0d6486" translate="yes" xml:space="preserve">
          <source>The sqlite3_finalize() function is called to delete a &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt;. If the most recent evaluation of the statement encountered no errors or if the statement is never been evaluated, then sqlite3_finalize() returns SQLITE_OK. If the most recent evaluation of statement S failed, then sqlite3_finalize(S) returns the appropriate &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; or &lt;a href=&quot;../rescode#extrc&quot;&gt;extended error code&lt;/a&gt;.</source>
          <target state="translated">Функция sqlite3_finalize () вызывается для удаления &lt;a href=&quot;stmt&quot;&gt;подготовленного оператора&lt;/a&gt; . Если последняя оценка оператора не обнаружила ошибок или если оператор никогда не оценивался, то sqlite3_finalize () возвращает SQLITE_OK. Если последняя оценка оператора S завершилась неудачно, sqlite3_finalize (S) возвращает соответствующий &lt;a href=&quot;../rescode&quot;&gt;код ошибки&lt;/a&gt; или &lt;a href=&quot;../rescode#extrc&quot;&gt;расширенный код ошибки&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cfdc64000a1f68dd938d60f9bb70e02c947748fd" translate="yes" xml:space="preserve">
          <source>The sqlite3_finalize(S) routine can be called at any point during the life cycle of &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; S: before statement S is ever evaluated, after one or more calls to &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset()&lt;/a&gt;, or after any call to &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; regardless of whether or not the statement has completed execution.</source>
          <target state="translated">Подпрограмму sqlite3_finalize (S) можно вызвать в любой момент в течение жизненного цикла &lt;a href=&quot;#sqlite3_stmt&quot;&gt;подготовленного оператора&lt;/a&gt; S: до того, как оператор S будет когда-либо оценен, после одного или нескольких вызовов &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset ()&lt;/a&gt; или после любого вызова &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step ()&lt;/a&gt; независимо от того, используется ли не выполнение инструкции завершено.</target>
        </trans-unit>
        <trans-unit id="1dec5478469a2333006cfdfd3bbed8c6613161e2" translate="yes" xml:space="preserve">
          <source>The sqlite3_finalize(S) routine can be called at any point during the life cycle of &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; S: before statement S is ever evaluated, after one or more calls to &lt;a href=&quot;reset&quot;&gt;sqlite3_reset()&lt;/a&gt;, or after any call to &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; regardless of whether or not the statement has completed execution.</source>
          <target state="translated">Подпрограмму sqlite3_finalize (S) можно вызвать в любой момент в течение жизненного цикла &lt;a href=&quot;stmt&quot;&gt;подготовленного оператора&lt;/a&gt; S: до того, как оператор S будет когда-либо оценен, после одного или нескольких вызовов &lt;a href=&quot;reset&quot;&gt;sqlite3_reset ()&lt;/a&gt; или после любого вызова &lt;a href=&quot;step&quot;&gt;sqlite3_step ()&lt;/a&gt; независимо от того, используется ли не выполнение инструкции завершено.</target>
        </trans-unit>
        <trans-unit id="408796a34b26a6721118a4ab1b7c1f9baef90909" translate="yes" xml:space="preserve">
          <source>The sqlite3_free_filename(Y) routine releases a memory allocation previously obtained from sqlite3_create_filename(). Invoking sqlite3_free_filename(Y) where Y is a NULL pointer is a harmless no-op.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a8a4dfedb4d5de550dae28093210eb5e1165c50" translate="yes" xml:space="preserve">
          <source>The sqlite3_get_autocommit() interface returns non-zero or zero if the given database connection is or is not in autocommit mode, respectively. Autocommit mode is on by default. Autocommit mode is disabled by a &lt;a href=&quot;../lang_transaction&quot;&gt;BEGIN&lt;/a&gt; statement. Autocommit mode is re-enabled by a &lt;a href=&quot;../lang_transaction&quot;&gt;COMMIT&lt;/a&gt; or &lt;a href=&quot;../lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt;.</source>
          <target state="translated">Интерфейс sqlite3_get_autocommit () возвращает ненулевое или нулевое значение, если данное соединение с базой данных находится или не находится в режиме автоматической фиксации, соответственно. По умолчанию режим автоматической фиксации включен. Режим автоматической фиксации отключен оператором &lt;a href=&quot;../lang_transaction&quot;&gt;BEGIN&lt;/a&gt; . Режим автоматической фиксации снова включается посредством &lt;a href=&quot;../lang_transaction&quot;&gt;COMMIT&lt;/a&gt; или &lt;a href=&quot;../lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c6407bbe024eecae19905f3987328770ebef955e" translate="yes" xml:space="preserve">
          <source>The sqlite3_get_autocommit() interface returns non-zero or zero if the given database connection is or is not in autocommit mode, respectively. Autocommit mode is on by default. Autocommit mode is disabled by a &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt; statement. Autocommit mode is re-enabled by a &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; or &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt;.</source>
          <target state="translated">Интерфейс sqlite3_get_autocommit () возвращает ненулевое или нулевое значение, если данное соединение с базой данных находится или не находится в режиме автоматической фиксации, соответственно. По умолчанию режим автоматической фиксации включен. Режим автоматической фиксации отключен оператором &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt; . Режим автоматической фиксации снова включается посредством &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; или &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c54753db8fb054877250927a699aaaed04734d2b" translate="yes" xml:space="preserve">
          <source>The sqlite3_get_auxdata(C,N) interface returns a pointer to the metadata associated by the sqlite3_set_auxdata(C,N,P,X) function with the Nth argument value to the application-defined function. N is zero for the left-most function argument. If there is no metadata associated with the function argument, the sqlite3_get_auxdata(C,N) interface returns a NULL pointer.</source>
          <target state="translated">Интерфейс sqlite3_get_auxdata(C,N)возвращает указатель на метаданные,ассоциированные функцией sqlite3_set_auxdata(C,N,P,X)со значением N-го аргумента на функцию,определяемую приложением.N равен нулю для самого левого аргумента функции.Если метаданные,связанные с аргументом функции,отсутствуют,то интерфейс sqlite3_get_auxdata(C,N)возвращает указатель NULL.</target>
        </trans-unit>
        <trans-unit id="35597daf57a6a6a4650eb220c2a29fa2c91a59d0" translate="yes" xml:space="preserve">
          <source>The sqlite3_get_table() function evaluates one or more semicolon-separated SQL statements in the zero-terminated UTF-8 string of its 2nd parameter and returns a result table to the pointer given in its 3rd parameter.</source>
          <target state="translated">Функция sqlite3_get_table()вычисляет один или несколько SQL-операторов,разделенных точкой с запятой,в строке с нулевой точкой UTF-8 своего 2-го параметра и возвращает итоговую таблицу указателю,заданному в 3-м параметре.</target>
        </trans-unit>
        <trans-unit id="acdf7ebaf34cc7cf8bdf020e8dc45c52df0d628c" translate="yes" xml:space="preserve">
          <source>The sqlite3_get_table() interface is implemented as a wrapper around &lt;a href=&quot;#sqlite3_exec&quot;&gt;sqlite3_exec()&lt;/a&gt;. The sqlite3_get_table() routine does not have access to any internal data structures of SQLite. It uses only the public interface defined here. As a consequence, errors that occur in the wrapper layer outside of the internal &lt;a href=&quot;#sqlite3_exec&quot;&gt;sqlite3_exec()&lt;/a&gt; call are not reflected in subsequent calls to &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errcode()&lt;/a&gt; or &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errmsg()&lt;/a&gt;.</source>
          <target state="translated">Интерфейс sqlite3_get_table () реализован как оболочка вокруг &lt;a href=&quot;#sqlite3_exec&quot;&gt;sqlite3_exec ()&lt;/a&gt; . Подпрограмма sqlite3_get_table () не имеет доступа ни к каким внутренним структурам данных SQLite. Он использует только определенный здесь публичный интерфейс. Как следствие, ошибки, возникающие на уровне оболочки вне внутреннего вызова &lt;a href=&quot;#sqlite3_exec&quot;&gt;sqlite3_exec ()&lt;/a&gt; , не отражаются в последующих вызовах &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errcode ()&lt;/a&gt; или &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errmsg ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="566ec671a5bf78f09b92642b451438dd26c86350" translate="yes" xml:space="preserve">
          <source>The sqlite3_get_table() interface is implemented as a wrapper around &lt;a href=&quot;exec&quot;&gt;sqlite3_exec()&lt;/a&gt;. The sqlite3_get_table() routine does not have access to any internal data structures of SQLite. It uses only the public interface defined here. As a consequence, errors that occur in the wrapper layer outside of the internal &lt;a href=&quot;exec&quot;&gt;sqlite3_exec()&lt;/a&gt; call are not reflected in subsequent calls to &lt;a href=&quot;errcode&quot;&gt;sqlite3_errcode()&lt;/a&gt; or &lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg()&lt;/a&gt;.</source>
          <target state="translated">Интерфейс sqlite3_get_table () реализован как оболочка вокруг &lt;a href=&quot;exec&quot;&gt;sqlite3_exec ()&lt;/a&gt; . Подпрограмма sqlite3_get_table () не имеет доступа ни к каким внутренним структурам данных SQLite. Он использует только определенный здесь публичный интерфейс. Как следствие, ошибки, возникающие на уровне оболочки вне внутреннего вызова &lt;a href=&quot;exec&quot;&gt;sqlite3_exec ()&lt;/a&gt; , не отражаются в последующих вызовах &lt;a href=&quot;errcode&quot;&gt;sqlite3_errcode ()&lt;/a&gt; или &lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b9b992cc0be7235d15c4a18cbb125e283656622e" translate="yes" xml:space="preserve">
          <source>The sqlite3_hard_heap_limit64(N) interface sets a hard upper bound of N bytes on the amount of memory that will be allocated. The sqlite3_hard_heap_limit64(N) interface is similar to sqlite3_soft_heap_limit64(N) except that memory allocations will fail when the hard heap limit is reached.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a1053b2bb267ced2e3415b8b71b02dc7bb0d976" translate="yes" xml:space="preserve">
          <source>The sqlite3_index_info structure and its substructures is used as part of the &lt;a href=&quot;../vtab&quot;&gt;virtual table&lt;/a&gt; interface to pass information into and receive the reply from the &lt;a href=&quot;../vtab#xbestindex&quot;&gt;xBestIndex&lt;/a&gt; method of a &lt;a href=&quot;module&quot;&gt;virtual table module&lt;/a&gt;. The fields under **Inputs** are the inputs to xBestIndex and are read-only. xBestIndex inserts its results into the **Outputs** fields.</source>
          <target state="translated">Структура sqlite3_index_info и ее подструктуры используются как часть интерфейса &lt;a href=&quot;../vtab&quot;&gt;виртуальной таблицы&lt;/a&gt; для передачи информации и получения ответа от метода &lt;a href=&quot;../vtab#xbestindex&quot;&gt;xBestIndex &lt;/a&gt;&lt;a href=&quot;module&quot;&gt;модуля виртуальной таблицы&lt;/a&gt; . Поля под ** Inputs ** являются входными данными для xBestIndex и доступны только для чтения. xBestIndex вставляет свои результаты в поля ** Outputs **.</target>
        </trans-unit>
        <trans-unit id="779db7516101e2733ab83d988869d6422e837e26" translate="yes" xml:space="preserve">
          <source>The sqlite3_index_info structure and its substructures is used as part of the &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; interface to pass information into and receive the reply from the &lt;a href=&quot;vtab#xbestindex&quot;&gt;xBestIndex&lt;/a&gt; method of a &lt;a href=&quot;#sqlite3_module&quot;&gt;virtual table module&lt;/a&gt;. The fields under **Inputs** are the inputs to xBestIndex and are read-only. xBestIndex inserts its results into the **Outputs** fields.</source>
          <target state="translated">Структура sqlite3_index_info и ее подструктуры используются как часть интерфейса &lt;a href=&quot;vtab&quot;&gt;виртуальной таблицы&lt;/a&gt; для передачи информации и получения ответа от метода &lt;a href=&quot;vtab#xbestindex&quot;&gt;xBestIndex &lt;/a&gt;&lt;a href=&quot;#sqlite3_module&quot;&gt;модуля виртуальной таблицы&lt;/a&gt; . Поля под ** Inputs ** являются входными данными для xBestIndex и доступны только для чтения. xBestIndex вставляет свои результаты в поля ** Outputs **.</target>
        </trans-unit>
        <trans-unit id="f7b3a693ac538b125172c62d75cc7d377f31b955" translate="yes" xml:space="preserve">
          <source>The sqlite3_initialize() interface is threadsafe, but sqlite3_shutdown() is not. The sqlite3_shutdown() interface must only be called from a single thread. All open &lt;a href=&quot;#sqlite3&quot;&gt;database connections&lt;/a&gt; must be closed and all other SQLite resources must be deallocated prior to invoking sqlite3_shutdown().</source>
          <target state="translated">Интерфейс sqlite3_initialize () потокобезопасен, а sqlite3_shutdown () - нет. Интерфейс sqlite3_shutdown () должен вызываться только из одного потока. Все открытые &lt;a href=&quot;#sqlite3&quot;&gt;соединения с базой данных&lt;/a&gt; должны быть закрыты, а все другие ресурсы SQLite должны быть освобождены до вызова sqlite3_shutdown ().</target>
        </trans-unit>
        <trans-unit id="88e442978d61726b76c4c6bd7b1f8a87808c119b" translate="yes" xml:space="preserve">
          <source>The sqlite3_initialize() interface is threadsafe, but sqlite3_shutdown() is not. The sqlite3_shutdown() interface must only be called from a single thread. All open &lt;a href=&quot;sqlite3&quot;&gt;database connections&lt;/a&gt; must be closed and all other SQLite resources must be deallocated prior to invoking sqlite3_shutdown().</source>
          <target state="translated">Интерфейс sqlite3_initialize () потокобезопасен, а sqlite3_shutdown () - нет. Интерфейс sqlite3_shutdown () должен вызываться только из одного потока. Все открытые &lt;a href=&quot;sqlite3&quot;&gt;соединения с базой данных&lt;/a&gt; должны быть закрыты, а все другие ресурсы SQLite должны быть освобождены до вызова sqlite3_shutdown ().</target>
        </trans-unit>
        <trans-unit id="0e2957684efb0782443d87103a368a9305c21dfe" translate="yes" xml:space="preserve">
          <source>The sqlite3_initialize() routine initializes the SQLite library. The sqlite3_shutdown() routine deallocates any resources that were allocated by sqlite3_initialize(). These routines are designed to aid in process initialization and shutdown on embedded systems. Workstation applications using SQLite normally do not need to invoke either of these routines.</source>
          <target state="translated">Рутина sqlite3_initialize()инициализирует библиотеку SQLite.Рутина sqlite3_shutdown()выполняет удаление любых ресурсов,которые были выделены функцией sqlite3_initialize().Эти подпрограммы предназначены для облегчения инициализации и завершения процесса на встраиваемых системах.Приложениям,использующим SQLite на рабочих станциях,как правило,не требуется выполнять ни одну из этих процедур.</target>
        </trans-unit>
        <trans-unit id="6344d658101e62a854952f62047632e568cb77e6" translate="yes" xml:space="preserve">
          <source>The sqlite3_initialize() routine is called internally by many other SQLite interfaces so that an application usually does not need to invoke sqlite3_initialize() directly. For example, &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open()&lt;/a&gt; calls sqlite3_initialize() so the SQLite library will be automatically initialized when &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open()&lt;/a&gt; is called if it has not be initialized already. However, if SQLite is compiled with the &lt;a href=&quot;compile#omit_autoinit&quot;&gt;SQLITE_OMIT_AUTOINIT&lt;/a&gt; compile-time option, then the automatic calls to sqlite3_initialize() are omitted and the application must call sqlite3_initialize() directly prior to using any other SQLite interface. For maximum portability, it is recommended that applications always invoke sqlite3_initialize() directly prior to using any other SQLite interface. Future releases of SQLite may require this. In other words, the behavior exhibited when SQLite is compiled with &lt;a href=&quot;compile#omit_autoinit&quot;&gt;SQLITE_OMIT_AUTOINIT&lt;/a&gt; might become the default behavior in some future release of SQLite.</source>
          <target state="translated">Подпрограмма sqlite3_initialize () вызывается изнутри многими другими интерфейсами SQLite, поэтому приложению обычно не требуется напрямую вызывать sqlite3_initialize (). Например, &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open ()&lt;/a&gt; вызывает sqlite3_initialize (), поэтому библиотека SQLite будет автоматически инициализирована при &lt;a href=&quot;#sqlite3_open&quot;&gt;вызове sqlite3_open (),&lt;/a&gt; если она еще не была инициализирована. Однако, если SQLite скомпилирован с &lt;a href=&quot;compile#omit_autoinit&quot;&gt;SQLITE_OMIT_AUTOINIT&lt;/a&gt;во время компиляции, то автоматические вызовы sqlite3_initialize () опускаются, и приложение должно вызывать sqlite3_initialize () непосредственно перед использованием любого другого интерфейса SQLite. Для максимальной переносимости рекомендуется, чтобы приложения всегда вызывали sqlite3_initialize () непосредственно перед использованием любого другого интерфейса SQLite. Это может потребоваться в будущих выпусках SQLite. Другими словами, поведение, проявляющееся при компиляции SQLite с &lt;a href=&quot;compile#omit_autoinit&quot;&gt;SQLITE_OMIT_AUTOINIT,&lt;/a&gt; может стать поведением по умолчанию в некоторых будущих выпусках SQLite.</target>
        </trans-unit>
        <trans-unit id="fcebb10283d6873f839e3d670ae393ff5c1368df" translate="yes" xml:space="preserve">
          <source>The sqlite3_initialize() routine is called internally by many other SQLite interfaces so that an application usually does not need to invoke sqlite3_initialize() directly. For example, &lt;a href=&quot;open&quot;&gt;sqlite3_open()&lt;/a&gt; calls sqlite3_initialize() so the SQLite library will be automatically initialized when &lt;a href=&quot;open&quot;&gt;sqlite3_open()&lt;/a&gt; is called if it has not be initialized already. However, if SQLite is compiled with the &lt;a href=&quot;../compile#omit_autoinit&quot;&gt;SQLITE_OMIT_AUTOINIT&lt;/a&gt; compile-time option, then the automatic calls to sqlite3_initialize() are omitted and the application must call sqlite3_initialize() directly prior to using any other SQLite interface. For maximum portability, it is recommended that applications always invoke sqlite3_initialize() directly prior to using any other SQLite interface. Future releases of SQLite may require this. In other words, the behavior exhibited when SQLite is compiled with &lt;a href=&quot;../compile#omit_autoinit&quot;&gt;SQLITE_OMIT_AUTOINIT&lt;/a&gt; might become the default behavior in some future release of SQLite.</source>
          <target state="translated">Подпрограмма sqlite3_initialize () вызывается изнутри многими другими интерфейсами SQLite, поэтому приложению обычно не требуется напрямую вызывать sqlite3_initialize (). Например, &lt;a href=&quot;open&quot;&gt;sqlite3_open ()&lt;/a&gt; вызывает sqlite3_initialize (), поэтому библиотека SQLite будет автоматически инициализирована при &lt;a href=&quot;open&quot;&gt;вызове sqlite3_open (),&lt;/a&gt; если она еще не была инициализирована. Однако, если SQLite скомпилирован с &lt;a href=&quot;../compile#omit_autoinit&quot;&gt;SQLITE_OMIT_AUTOINIT&lt;/a&gt;во время компиляции, то автоматические вызовы sqlite3_initialize () опускаются, и приложение должно вызывать sqlite3_initialize () непосредственно перед использованием любого другого интерфейса SQLite. Для максимальной переносимости рекомендуется, чтобы приложения всегда вызывали sqlite3_initialize () непосредственно перед использованием любого другого интерфейса SQLite. Это может потребоваться в будущих выпусках SQLite. Другими словами, поведение, проявляющееся при компиляции SQLite с &lt;a href=&quot;../compile#omit_autoinit&quot;&gt;SQLITE_OMIT_AUTOINIT,&lt;/a&gt; может стать поведением по умолчанию в некоторых будущих выпусках SQLite.</target>
        </trans-unit>
        <trans-unit id="ce2e2f5e58c3c92f466c0d1a9cbb3782ccb3ca7e" translate="yes" xml:space="preserve">
          <source>The sqlite3_initialize() routine returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; on success. If for some reason, sqlite3_initialize() is unable to initialize the library (perhaps it is unable to allocate a needed resource such as a mutex) it returns an &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; other than &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt;.</source>
          <target state="translated">Процедура sqlite3_initialize () в &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;случае&lt;/a&gt; успеха возвращает SQLITE_OK . Если по какой-то причине sqlite3_initialize () не может инициализировать библиотеку (возможно, она не может выделить необходимый ресурс, такой как мьютекс), она возвращает &lt;a href=&quot;rescode&quot;&gt;код ошибки,&lt;/a&gt; отличный от &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7cfd6fb2b2f9b6bef5dc2729044b616aa2e46340" translate="yes" xml:space="preserve">
          <source>The sqlite3_initialize() routine returns &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; on success. If for some reason, sqlite3_initialize() is unable to initialize the library (perhaps it is unable to allocate a needed resource such as a mutex) it returns an &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; other than &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;.</source>
          <target state="translated">Процедура sqlite3_initialize () в &lt;a href=&quot;../rescode#ok&quot;&gt;случае&lt;/a&gt; успеха возвращает SQLITE_OK . Если по какой-то причине sqlite3_initialize () не может инициализировать библиотеку (возможно, она не может выделить необходимый ресурс, такой как мьютекс), она возвращает &lt;a href=&quot;../rescode&quot;&gt;код ошибки,&lt;/a&gt; отличный от &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="004164880e4716eb9f6522ffa56490d8e1026730" translate="yes" xml:space="preserve">
          <source>The sqlite3_int64 and sqlite3_uint64 are the preferred type definitions. The sqlite_int64 and sqlite_uint64 types are supported for backwards compatibility only.</source>
          <target state="translated">Предпочтительными определениями типов являются sqlite3_int64 и sqlite3_uint64.Типы sqlite_int64 и sqlite_uint64 поддерживаются только для обратной совместимости.</target>
        </trans-unit>
        <trans-unit id="7d87f3d7209e128d2babe00e667401d22d9cc8a5" translate="yes" xml:space="preserve">
          <source>The sqlite3_int64 and sqlite_int64 types can store integer values between -9223372036854775808 and +9223372036854775807 inclusive. The sqlite3_uint64 and sqlite_uint64 types can store integer values between 0 and +18446744073709551615 inclusive.</source>
          <target state="translated">Типы sqlite3_int64 и sqlite_int64 могут хранить целочисленные значения между -9223372036854775808 и +9223372036854775807 включительно.Типы sqlite3_uint64 и sqlite_uint64 могут хранить целочисленные значения от 0 до +18446744073709551615 включительно.</target>
        </trans-unit>
        <trans-unit id="d1945cfc4228bc66b1032ca0f61bc88893782d0c" translate="yes" xml:space="preserve">
          <source>The sqlite3_interrupt(D) call is in effect until all currently running SQL statements on &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; D complete. Any new SQL statements that are started after the sqlite3_interrupt() call and before the running statement count reaches zero are interrupted as if they had been running prior to the sqlite3_interrupt() call. New SQL statements that are started after the running statement count reaches zero are not effected by the sqlite3_interrupt(). A call to sqlite3_interrupt(D) that occurs when there are no running SQL statements is a no-op and has no effect on SQL statements that are started after the sqlite3_interrupt() call returns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7eba8c8e6f99b81a907173174c705f9ed98298ab" translate="yes" xml:space="preserve">
          <source>The sqlite3_interrupt(D) call is in effect until all currently running SQL statements on &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; D complete. Any new SQL statements that are started after the sqlite3_interrupt() call and before the running statements reaches zero are interrupted as if they had been running prior to the sqlite3_interrupt() call. New SQL statements that are started after the running statement count reaches zero are not effected by the sqlite3_interrupt(). A call to sqlite3_interrupt(D) that occurs when there are no running SQL statements is a no-op and has no effect on SQL statements that are started after the sqlite3_interrupt() call returns.</source>
          <target state="translated">Вызов sqlite3_interrupt (D) действует до тех пор, пока не завершатся все выполняющиеся в данный момент операторы SQL для &lt;a href=&quot;#sqlite3&quot;&gt;соединения&lt;/a&gt; D с базой данных . Любые новые операторы SQL, которые запускаются после вызова sqlite3_interrupt () и до того, как текущие операторы достигают нуля, прерываются, как если бы они выполнялись до вызова sqlite3_interrupt (). Новые операторы SQL, которые запускаются после того, как счетчик запущенных операторов достигает нуля, не обрабатываются sqlite3_interrupt (). Вызов sqlite3_interrupt (D), который происходит, когда нет запущенных операторов SQL, является бездействующим и не влияет на операторы SQL, которые запускаются после возврата из вызова sqlite3_interrupt ().</target>
        </trans-unit>
        <trans-unit id="397354330de52f0df08035b92ede80f0eda59fd9" translate="yes" xml:space="preserve">
          <source>The sqlite3_interrupt(D) call is in effect until all currently running SQL statements on &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; D complete. Any new SQL statements that are started after the sqlite3_interrupt() call and before the running statement count reaches zero are interrupted as if they had been running prior to the sqlite3_interrupt() call. New SQL statements that are started after the running statement count reaches zero are not effected by the sqlite3_interrupt(). A call to sqlite3_interrupt(D) that occurs when there are no running SQL statements is a no-op and has no effect on SQL statements that are started after the sqlite3_interrupt() call returns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6b86af3fa8ce3c883af892e74e82bdad0554e41" translate="yes" xml:space="preserve">
          <source>The sqlite3_interrupt(D) call is in effect until all currently running SQL statements on &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; D complete. Any new SQL statements that are started after the sqlite3_interrupt() call and before the running statements reaches zero are interrupted as if they had been running prior to the sqlite3_interrupt() call. New SQL statements that are started after the running statement count reaches zero are not effected by the sqlite3_interrupt(). A call to sqlite3_interrupt(D) that occurs when there are no running SQL statements is a no-op and has no effect on SQL statements that are started after the sqlite3_interrupt() call returns.</source>
          <target state="translated">Вызов sqlite3_interrupt (D) действует до тех пор, пока не завершатся все выполняющиеся в данный момент операторы SQL для &lt;a href=&quot;sqlite3&quot;&gt;соединения&lt;/a&gt; D с базой данных . Любые новые операторы SQL, которые запускаются после вызова sqlite3_interrupt () и до того, как текущие операторы достигают нуля, прерываются, как если бы они выполнялись до вызова sqlite3_interrupt (). Новые операторы SQL, которые запускаются после того, как счетчик запущенных операторов достигает нуля, не обрабатываются sqlite3_interrupt (). Вызов sqlite3_interrupt (D), который происходит, когда нет запущенных операторов SQL, является бездействующим и не влияет на операторы SQL, которые запускаются после возврата из вызова sqlite3_interrupt ().</target>
        </trans-unit>
        <trans-unit id="3bfe2e62ea9486a964b648fd6403e7edfa3b65f8" translate="yes" xml:space="preserve">
          <source>The sqlite3_keyword_check(Z,L) interface checks to see whether or not the L-byte UTF8 identifier that Z points to is a keyword, returning non-zero if it is and zero if not.</source>
          <target state="translated">Интерфейс sqlite3_keyword_check(Z,L)проверяет,является ли L-байтовый идентификатор UTF8,на который указывает Z,ключевым словом,возвращая ненулевое,если да,и нулевое,если нет.</target>
        </trans-unit>
        <trans-unit id="d4d8092bdf6d249db5e6e39b2ccbee0c913272c1" translate="yes" xml:space="preserve">
          <source>The sqlite3_keyword_count() interface returns the number of distinct keywords understood by SQLite.</source>
          <target state="translated">Интерфейс sqlite3_keyword_count()возвращает количество различных ключевых слов,понятных SQLite.</target>
        </trans-unit>
        <trans-unit id="dc0acf41ffb529d44b2ebca13529ac325b17bad2" translate="yes" xml:space="preserve">
          <source>The sqlite3_keyword_name(N,Z,L) interface finds the N-th keyword and makes *Z point to that keyword expressed as UTF8 and writes the number of bytes in the keyword into *L. The string that *Z points to is not zero-terminated. The sqlite3_keyword_name(N,Z,L) routine returns SQLITE_OK if N is within bounds and SQLITE_ERROR if not. If either Z or L are NULL or invalid pointers then calls to sqlite3_keyword_name(N,Z,L) result in undefined behavior.</source>
          <target state="translated">Интерфейс sqlite3_keyword_name(N,Z,L)находит N-е ключевое слово и записывает количество байт в *L.Строка,на которую указывает *Z,не является нулевой.Рутина sqlite3_keyword_name(N,Z,L)возвращает SQLITE_OK,если N находится в границах,и SQLITE_ERROR,если нет.Если Z или L-NULL или недействительные указатели,то обращение к sqlite3_keyword_name(N,Z,L)приводит к неопределенному поведению.</target>
        </trans-unit>
        <trans-unit id="0a1d77fc76c131dee5ee5dd030d6d5133cee00d1" translate="yes" xml:space="preserve">
          <source>The sqlite3_last_insert_rowid(D) interface usually returns the &lt;a href=&quot;../lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; of the most recent successful &lt;a href=&quot;../lang_insert&quot;&gt;INSERT&lt;/a&gt; into a rowid table or &lt;a href=&quot;../vtab&quot;&gt;virtual table&lt;/a&gt; on database connection D. Inserts into &lt;a href=&quot;../withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables are not recorded. If no successful &lt;a href=&quot;../lang_insert&quot;&gt;INSERT&lt;/a&gt;s into rowid tables have ever occurred on the database connection D, then sqlite3_last_insert_rowid(D) returns zero.</source>
          <target state="translated">Интерфейс sqlite3_last_insert_rowid (D) обычно возвращает &lt;a href=&quot;../lang_createtable#rowid&quot;&gt;идентификатор&lt;/a&gt; строки самого последнего успешного &lt;a href=&quot;../lang_insert&quot;&gt;INSERT&lt;/a&gt; в таблицу идентификаторов строк или &lt;a href=&quot;../vtab&quot;&gt;виртуальную таблицу&lt;/a&gt; при подключении к базе данных D. Вставки в таблицы &lt;a href=&quot;../withoutrowid&quot;&gt;БЕЗ ROWID&lt;/a&gt; не записываются. Если в соединении D с базой данных никогда не происходило успешных &lt;a href=&quot;../lang_insert&quot;&gt;операций INSERT&lt;/a&gt; в таблицы rowid, тогда sqlite3_last_insert_rowid (D) возвращает ноль.</target>
        </trans-unit>
        <trans-unit id="96cc17a506c60ac9000086a1e0105e51d535d45e" translate="yes" xml:space="preserve">
          <source>The sqlite3_last_insert_rowid(D) interface usually returns the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; of the most recent successful &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; into a rowid table or &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; on database connection D. Inserts into &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables are not recorded. If no successful &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;s into rowid tables have ever occurred on the database connection D, then sqlite3_last_insert_rowid(D) returns zero.</source>
          <target state="translated">Интерфейс sqlite3_last_insert_rowid (D) обычно возвращает &lt;a href=&quot;lang_createtable#rowid&quot;&gt;идентификатор&lt;/a&gt; строки самого последнего успешного &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; в таблицу идентификаторов строк или &lt;a href=&quot;vtab&quot;&gt;виртуальную таблицу&lt;/a&gt; при подключении к базе данных D. Вставки в таблицы &lt;a href=&quot;withoutrowid&quot;&gt;БЕЗ ROWID&lt;/a&gt; не записываются. Если в соединении D с базой данных никогда не происходило успешных &lt;a href=&quot;lang_insert&quot;&gt;операций INSERT&lt;/a&gt; в таблицы rowid, тогда sqlite3_last_insert_rowid (D) возвращает ноль.</target>
        </trans-unit>
        <trans-unit id="97d28d93a8572fd39455b44f97795fb1531500e9" translate="yes" xml:space="preserve">
          <source>The sqlite3_load_extension() interface attempts to load an &lt;a href=&quot;../loadext&quot;&gt;SQLite extension&lt;/a&gt; library contained in the file zFile. If the file cannot be loaded directly, attempts are made to load with various operating-system specific extensions added. So for example, if &quot;samplelib&quot; cannot be loaded, then names like &quot;samplelib.so&quot; or &quot;samplelib.dylib&quot; or &quot;samplelib.dll&quot; might be tried also.</source>
          <target state="translated">Интерфейс sqlite3_load_extension () пытается загрузить библиотеку &lt;a href=&quot;../loadext&quot;&gt;расширений SQLite,&lt;/a&gt; содержащуюся в файле zFile. Если файл не может быть загружен напрямую, предпринимаются попытки загрузки с добавлением различных расширений для конкретной операционной системы. Так, например, если &quot;samplelib&quot; не может быть загружен, можно также попробовать такие имена, как &quot;samplelib.so&quot;, &quot;samplelib.dylib&quot; или &quot;samplelib.dll&quot;.</target>
        </trans-unit>
        <trans-unit id="29a1d12e678745f57cc139b953c6116a8408aff6" translate="yes" xml:space="preserve">
          <source>The sqlite3_load_extension() interface attempts to load an &lt;a href=&quot;loadext&quot;&gt;SQLite extension&lt;/a&gt; library contained in the file zFile. If the file cannot be loaded directly, attempts are made to load with various operating-system specific extensions added. So for example, if &quot;samplelib&quot; cannot be loaded, then names like &quot;samplelib.so&quot; or &quot;samplelib.dylib&quot; or &quot;samplelib.dll&quot; might be tried also.</source>
          <target state="translated">Интерфейс sqlite3_load_extension () пытается загрузить библиотеку &lt;a href=&quot;loadext&quot;&gt;расширений SQLite,&lt;/a&gt; содержащуюся в файле zFile. Если файл не может быть загружен напрямую, предпринимаются попытки загрузки с добавлением различных расширений для конкретной операционной системы. Так, например, если &quot;samplelib&quot; не может быть загружен, можно также попробовать такие имена, как &quot;samplelib.so&quot;, &quot;samplelib.dylib&quot; или &quot;samplelib.dll&quot;.</target>
        </trans-unit>
        <trans-unit id="653b87892cb27376af041bf3731e3304fd208799" translate="yes" xml:space="preserve">
          <source>The sqlite3_log() interface is intended for use by extensions such as virtual tables, collating functions, and SQL functions. While there is nothing to prevent an application from calling sqlite3_log(), doing so is considered bad form.</source>
          <target state="translated">Интерфейс sqlite3_log()предназначен для использования такими расширениями,как виртуальные таблицы,коллекционные функции и функции SQL.Хотя ничто не мешает приложению вызывать sqlite3_log(),это считается плохой формой.</target>
        </trans-unit>
        <trans-unit id="c4ad2aeb0d9be1f2327ef6d534ab004f6a2b8dc6" translate="yes" xml:space="preserve">
          <source>The sqlite3_malloc() routine returns a pointer to a block of memory at least N bytes in length, where N is the parameter. If sqlite3_malloc() is unable to obtain sufficient free memory, it returns a NULL pointer. If the parameter N to sqlite3_malloc() is zero or negative then sqlite3_malloc() returns a NULL pointer.</source>
          <target state="translated">Рутина sqlite3_malloc()возвращает указатель на блок памяти длиной не менее N байт,где N-параметр.Если sqlite3_malloc()не может получить достаточное количество свободной памяти,то возвращается указатель NULL.Если параметр N sqlite3_malloc()равен нулю или отрицателен,то sqlite3_malloc()возвращает указатель NULL.</target>
        </trans-unit>
        <trans-unit id="a4e65f99f4accbf5db989c9154cb81e75b9ee8ed" translate="yes" xml:space="preserve">
          <source>The sqlite3_malloc64(N) routine works just like sqlite3_malloc(N) except that N is an unsigned 64-bit integer instead of a signed 32-bit integer.</source>
          <target state="translated">Рутина sqlite3_malloc64(N)работает так же,как sqlite3_malloc(N),за исключением того,что N является беззнаковым 64-битным целым числом,а не знаковым 32-битным целым.</target>
        </trans-unit>
        <trans-unit id="6aa420d40670b164a1cce9b427bd49e7d1c5fd88" translate="yes" xml:space="preserve">
          <source>The sqlite3_mprintf() and sqlite3_vmprintf() routines write their results into memory obtained from &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc64()&lt;/a&gt;. The strings returned by these two routines should be released by &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free()&lt;/a&gt;. Both routines return a NULL pointer if &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc64()&lt;/a&gt; is unable to allocate enough memory to hold the resulting string.</source>
          <target state="translated">Подпрограммы sqlite3_mprintf () и sqlite3_vmprintf () записывают свои результаты в память, полученную из &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc64 ()&lt;/a&gt; . Строки, возвращаемые этими двумя подпрограммами, должны быть освобождены &lt;a href=&quot;#sqlite3_free&quot;&gt;функцией sqlite3_free ()&lt;/a&gt; . Обе подпрограммы возвращают указатель NULL, если &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc64 ()&lt;/a&gt; не может выделить достаточно памяти для хранения результирующей строки.</target>
        </trans-unit>
        <trans-unit id="aeca10a8c44ac57eac0c9c7f71ba952063b68cc0" translate="yes" xml:space="preserve">
          <source>The sqlite3_mprintf() and sqlite3_vmprintf() routines write their results into memory obtained from &lt;a href=&quot;free&quot;&gt;sqlite3_malloc64()&lt;/a&gt;. The strings returned by these two routines should be released by &lt;a href=&quot;free&quot;&gt;sqlite3_free()&lt;/a&gt;. Both routines return a NULL pointer if &lt;a href=&quot;free&quot;&gt;sqlite3_malloc64()&lt;/a&gt; is unable to allocate enough memory to hold the resulting string.</source>
          <target state="translated">Подпрограммы sqlite3_mprintf () и sqlite3_vmprintf () записывают свои результаты в память, полученную из &lt;a href=&quot;free&quot;&gt;sqlite3_malloc64 ()&lt;/a&gt; . Строки, возвращаемые этими двумя подпрограммами, должны быть освобождены &lt;a href=&quot;free&quot;&gt;функцией sqlite3_free ()&lt;/a&gt; . Обе подпрограммы возвращают указатель NULL, если &lt;a href=&quot;free&quot;&gt;sqlite3_malloc64 ()&lt;/a&gt; не может выделить достаточно памяти для хранения результирующей строки.</target>
        </trans-unit>
        <trans-unit id="f0bcf6e7726b974822789eb5eaa08500974adb52" translate="yes" xml:space="preserve">
          <source>The sqlite3_mutex_alloc() routine allocates a new mutex and returns a pointer to it. The sqlite3_mutex_alloc() routine returns NULL if it is unable to allocate the requested mutex. The argument to sqlite3_mutex_alloc() must one of these integer constants:</source>
          <target state="translated">Рутина sqlite3_mutex_alloc()выделяет новый мьютекс и возвращает на него указатель.Программа sqlite3_mutex_alloc()возвращает NULL,если не может выделить запрашиваемый мьютекс.Аргумент sqlite3_mutex_alloc()должен содержать одну из этих целочисленных констант:</target>
        </trans-unit>
        <trans-unit id="2d81df454ad810426381d8f39e8b57e0d9de3e46" translate="yes" xml:space="preserve">
          <source>The sqlite3_mutex_enter() and sqlite3_mutex_try() routines attempt to enter a mutex. If another thread is already within the mutex, sqlite3_mutex_enter() will block and sqlite3_mutex_try() will return SQLITE_BUSY. The sqlite3_mutex_try() interface returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; upon successful entry. Mutexes created using SQLITE_MUTEX_RECURSIVE can be entered multiple times by the same thread. In such cases, the mutex must be exited an equal number of times before another thread can enter. If the same thread tries to enter any mutex other than an SQLITE_MUTEX_RECURSIVE more than once, the behavior is undefined.</source>
          <target state="translated">Подпрограммы sqlite3_mutex_enter () и sqlite3_mutex_try () пытаются ввести мьютекс. Если другой поток уже находится в мьютексе, sqlite3_mutex_enter () заблокируется, а sqlite3_mutex_try () вернет SQLITE_BUSY. Интерфейс sqlite3_mutex_try () возвращает &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; при успешном входе. Мьютексы, созданные с использованием SQLITE_MUTEX_RECURSIVE, можно вводить несколько раз одним и тем же потоком. В таких случаях из мьютекса необходимо выйти равное количество раз, прежде чем другой поток сможет войти. Если один и тот же поток пытается ввести любой мьютекс, отличный от SQLITE_MUTEX_RECURSIVE, более одного раза, поведение не определено.</target>
        </trans-unit>
        <trans-unit id="3b45ebc24527ab0f89738f7016be66d43d5251ac" translate="yes" xml:space="preserve">
          <source>The sqlite3_mutex_enter() and sqlite3_mutex_try() routines attempt to enter a mutex. If another thread is already within the mutex, sqlite3_mutex_enter() will block and sqlite3_mutex_try() will return SQLITE_BUSY. The sqlite3_mutex_try() interface returns &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; upon successful entry. Mutexes created using SQLITE_MUTEX_RECURSIVE can be entered multiple times by the same thread. In such cases, the mutex must be exited an equal number of times before another thread can enter. If the same thread tries to enter any mutex other than an SQLITE_MUTEX_RECURSIVE more than once, the behavior is undefined.</source>
          <target state="translated">Подпрограммы sqlite3_mutex_enter () и sqlite3_mutex_try () пытаются ввести мьютекс. Если другой поток уже находится в мьютексе, sqlite3_mutex_enter () заблокируется, а sqlite3_mutex_try () вернет SQLITE_BUSY. Интерфейс sqlite3_mutex_try () возвращает &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; при успешном входе. Мьютексы, созданные с использованием SQLITE_MUTEX_RECURSIVE, можно вводить несколько раз одним и тем же потоком. В таких случаях из мьютекса необходимо выйти равное количество раз, прежде чем другой поток сможет войти. Если один и тот же поток пытается ввести любой мьютекс, отличный от SQLITE_MUTEX_RECURSIVE, более одного раза, поведение не определено.</target>
        </trans-unit>
        <trans-unit id="a9c3683cf3483b6e604960673d2e4ca248bc41dc" translate="yes" xml:space="preserve">
          <source>The sqlite3_mutex_free() routine deallocates a previously allocated dynamic mutex. Attempting to deallocate a static mutex results in undefined behavior.</source>
          <target state="translated">Обычная функция sqlite3_mutex_free()выполняет раздачу ранее выделенного динамического мьютекса.Попытка разобрать статический мьютекс приводит к неопределенному поведению.</target>
        </trans-unit>
        <trans-unit id="c54fa9a704452135b01172d66edadf344257a173" translate="yes" xml:space="preserve">
          <source>The sqlite3_mutex_held() and sqlite3_mutex_notheld() routines are intended for use inside assert() statements. The SQLite core never uses these routines except inside an assert() and applications are advised to follow the lead of the core. The SQLite core only provides implementations for these routines when it is compiled with the SQLITE_DEBUG flag. External mutex implementations are only required to provide these routines if SQLITE_DEBUG is defined and if NDEBUG is not defined.</source>
          <target state="translated">Рутины sqlite3_mutex_held()и sqlite3_mutex_notheld()предназначены для использования внутри операторов assert().Ядро SQLite никогда не использует эти подпрограммы,кроме как внутри функции assert(),и приложениям рекомендуется следовать указаниям ядра.Ядро SQLite предоставляет реализации для этих процедур только тогда,когда оно скомпилировано с флагом SQLITE_DEBUG.Внешние реализации мьютекса необходимы для обеспечения этих подпрограмм только в том случае,если определен флаг SQLITE_DEBUG и не определен NDEBUG.</target>
        </trans-unit>
        <trans-unit id="93534cd54fb671abd29d988fdeee0858c44767d1" translate="yes" xml:space="preserve">
          <source>The sqlite3_mutex_leave() routine exits a mutex that was previously entered by the same thread. The behavior is undefined if the mutex is not currently entered by the calling thread or is not currently allocated.</source>
          <target state="translated">Рутина sqlite3_mutex_leave()выходит из мьютекса,который ранее был введен тем же самым потоком.Поведение мьютекса не определено,если мьютекс в данный момент не введен вызывающим потоком или не выделен.</target>
        </trans-unit>
        <trans-unit id="fb745ae4bf7930e6464af0ad23559d80e7f2b3bc" translate="yes" xml:space="preserve">
          <source>The sqlite3_open() routine returns an integer error code rather than a pointer to the sqlite3 structure as the version 2 interface did. The difference between sqlite3_open() and sqlite3_open16() is that sqlite3_open16() takes UTF-16 (in host native byte order) for the name of the database file. If a new database file needs to be created, then sqlite3_open16() sets the internal text representation to UTF-16 whereas sqlite3_open() sets the text representation to UTF-8.</source>
          <target state="translated">Рутина sqlite3_open()возвращает целочисленный код ошибки,а не указатель на структуру sqlite3,как это делал интерфейс версии 2.Разница между функциями sqlite3_open()и sqlite3_open16()заключается в том,что sqlite3_open16()принимает UTF-16 (в родном для хоста порядке байт)за имя файла базы данных.Если необходимо создать новый файл базы данных,то sqlite3_open16()устанавливает внутреннее текстовое представление в UTF-16,а sqlite3_open()устанавливает текстовое представление в UTF-8.</target>
        </trans-unit>
        <trans-unit id="49cca3441049c31bbff034c5494130978bd29358" translate="yes" xml:space="preserve">
          <source>The sqlite3_open_v2() interface works like sqlite3_open() except that it accepts two additional parameters for additional control over the new database connection. The flags parameter to sqlite3_open_v2() can take one of the following three values, optionally combined with the &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_NOMUTEX&lt;/a&gt;, &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_FULLMUTEX&lt;/a&gt;, &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_SHAREDCACHE&lt;/a&gt;, &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_PRIVATECACHE&lt;/a&gt;, and/or &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_URI&lt;/a&gt; flags:</source>
          <target state="translated">Интерфейс sqlite3_open_v2 () работает так же, как sqlite3_open (), за исключением того, что он принимает два дополнительных параметра для дополнительного контроля над новым подключением к базе данных. Параметр flags для sqlite3_open_v2 () может принимать одно из следующих трех значений, необязательно в сочетании с &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;флагами SQLITE_OPEN_NOMUTEX&lt;/a&gt; , &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_FULLMUTEX&lt;/a&gt; , &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_SHAREDCACHE&lt;/a&gt; , &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_PRIVATECACHE&lt;/a&gt; и / или &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_URI&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="e598ece82e5f2beb42f8604c9b91c3f1054b0c31" translate="yes" xml:space="preserve">
          <source>The sqlite3_open_v2() interface works like sqlite3_open() except that it accepts two additional parameters for additional control over the new database connection. The flags parameter to sqlite3_open_v2() can take one of the following three values, optionally combined with the &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_NOMUTEX&lt;/a&gt;, &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_FULLMUTEX&lt;/a&gt;, &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_SHAREDCACHE&lt;/a&gt;, &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_PRIVATECACHE&lt;/a&gt;, and/or &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_URI&lt;/a&gt; flags:</source>
          <target state="translated">Интерфейс sqlite3_open_v2 () работает так же, как sqlite3_open (), за исключением того, что он принимает два дополнительных параметра для дополнительного контроля над новым подключением к базе данных. Параметр flags для sqlite3_open_v2 () может принимать одно из следующих трех значений, необязательно в сочетании с &lt;a href=&quot;c_open_autoproxy&quot;&gt;флагами SQLITE_OPEN_NOMUTEX&lt;/a&gt; , &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_FULLMUTEX&lt;/a&gt; , &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_SHAREDCACHE&lt;/a&gt; , &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_PRIVATECACHE&lt;/a&gt; и / или &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_URI&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="5a0142d09a66478c971c322bbffc0dda8bf83c4b" translate="yes" xml:space="preserve">
          <source>The sqlite3_open_v2() interface works like sqlite3_open() except that it accepts two additional parameters for additional control over the new database connection. The flags parameter to sqlite3_open_v2() must include, at a minimum, one of the following three flag combinations:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e55b10d2fb69bf6bea01941ab944f29f8bde45c" translate="yes" xml:space="preserve">
          <source>The sqlite3_os_init() routine does operating-system specific initialization of the SQLite library. The sqlite3_os_end() routine undoes the effect of sqlite3_os_init(). Typical tasks performed by these routines include allocation or deallocation of static resources, initialization of global variables, setting up a default &lt;a href=&quot;#sqlite3_vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; module, or setting up a default configuration using &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config()&lt;/a&gt;.</source>
          <target state="translated">Подпрограмма sqlite3_os_init () выполняет инициализацию библиотеки SQLite в зависимости от операционной системы. Подпрограмма sqlite3_os_end () отменяет эффект sqlite3_os_init (). Типичные задачи, выполняемые этими подпрограммами, включают выделение или освобождение статических ресурсов, инициализацию глобальных переменных, установку модуля &lt;a href=&quot;#sqlite3_vfs&quot;&gt;sqlite3_vfs по&lt;/a&gt; умолчанию или установку конфигурации по умолчанию с помощью &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ea78da5df45c282e78d4b89a318af0ce437587df" translate="yes" xml:space="preserve">
          <source>The sqlite3_os_init() routine does operating-system specific initialization of the SQLite library. The sqlite3_os_end() routine undoes the effect of sqlite3_os_init(). Typical tasks performed by these routines include allocation or deallocation of static resources, initialization of global variables, setting up a default &lt;a href=&quot;vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; module, or setting up a default configuration using &lt;a href=&quot;config&quot;&gt;sqlite3_config()&lt;/a&gt;.</source>
          <target state="translated">Подпрограмма sqlite3_os_init () выполняет инициализацию библиотеки SQLite в зависимости от операционной системы. Подпрограмма sqlite3_os_end () отменяет эффект sqlite3_os_init (). Типичные задачи, выполняемые этими подпрограммами, включают выделение или освобождение статических ресурсов, инициализацию глобальных переменных, установку модуля &lt;a href=&quot;vfs&quot;&gt;sqlite3_vfs по&lt;/a&gt; умолчанию или установку конфигурации по умолчанию с помощью &lt;a href=&quot;config&quot;&gt;sqlite3_config ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3bd4022600e005736b49c1c51ead1422ec8da9c9" translate="yes" xml:space="preserve">
          <source>The sqlite3_pcache type is opaque. It is implemented by the pluggable module. The SQLite core has no knowledge of its size or internal structure and never deals with the sqlite3_pcache object except by holding and passing pointers to the object.</source>
          <target state="translated">Тип sqlite3_pcache непрозрачен.Реализуется подключаемым модулем.Ядро SQLite не знает ни его размера,ни внутренней структуры и никогда не работает с объектом sqlite3_pcache,кроме как удерживая и передавая указатели на объект.</target>
        </trans-unit>
        <trans-unit id="07293c189451b8c181f77d9379a0238420ee3f47" translate="yes" xml:space="preserve">
          <source>The sqlite3_pcache_methods structure and the &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigpcache&quot;&gt;SQLITE_CONFIG_PCACHE&lt;/a&gt; and &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfiggetpcache&quot;&gt;SQLITE_CONFIG_GETPCACHE&lt;/a&gt; configuration parameters are deprecated. They are replaced by a new &lt;a href=&quot;c3ref/pcache_methods2&quot;&gt;sqlite3_pcache_methods2&lt;/a&gt; structure and &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigpcache2&quot;&gt;SQLITE_CONFIG_PCACHE2&lt;/a&gt; and &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfiggetpcache2&quot;&gt;SQLITE_CONFIG_GETPCACHE2&lt;/a&gt; configuration parameters.</source>
          <target state="translated">Структура sqlite3_pcache_methods и параметры конфигурации &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigpcache&quot;&gt;SQLITE_CONFIG_PCACHE&lt;/a&gt; и &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfiggetpcache&quot;&gt;SQLITE_CONFIG_GETPCACHE&lt;/a&gt; устарели. Они заменены новой структурой &lt;a href=&quot;c3ref/pcache_methods2&quot;&gt;sqlite3_pcache_methods2&lt;/a&gt; и параметрами конфигурации &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigpcache2&quot;&gt;SQLITE_CONFIG_PCACHE2&lt;/a&gt; и &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfiggetpcache2&quot;&gt;SQLITE_CONFIG_GETPCACHE2&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="445aa02fd749c19bfbd930e14dfefb0c0e11a4d3" translate="yes" xml:space="preserve">
          <source>The sqlite3_pcache_page object represents a single page in the page cache. The page cache will allocate instances of this object. Various methods of the page cache use pointers to instances of this object as parameters or as their return value.</source>
          <target state="translated">Объект sqlite3_pcache_page представляет собой одну страницу в кэше страниц.В кэше страниц будут выделяться экземпляры этого объекта.Различные методы кэширования страниц используют указатели на экземпляры данного объекта в качестве параметров или их возвращаемого значения.</target>
        </trans-unit>
        <trans-unit id="7bf15591143e8308e465ab8ab773665acb5da577" translate="yes" xml:space="preserve">
          <source>The sqlite3_prepare interface compiles a single SQL statement into byte code for later execution. This interface is now the preferred way of accessing the database.</source>
          <target state="translated">Интерфейс sqlite3_prepare компилирует один SQL-оператор в байтовый код для последующего выполнения.Этот интерфейс теперь является предпочтительным способом доступа к БД.</target>
        </trans-unit>
        <trans-unit id="63425e76fcf41641f3bb3043a50f94b90abaff47" translate="yes" xml:space="preserve">
          <source>The sqlite3_prepare_v2(), sqlite3_prepare_v3(), sqlite3_prepare16_v2(), and sqlite3_prepare16_v3() interfaces are recommended for all new programs. The older interfaces (sqlite3_prepare() and sqlite3_prepare16()) are retained for backwards compatibility, but their use is discouraged. In the &quot;vX&quot; interfaces, the prepared statement that is returned (the &lt;a href=&quot;#sqlite3_stmt&quot;&gt;sqlite3_stmt&lt;/a&gt; object) contains a copy of the original SQL text. This causes the &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; interface to behave differently in three ways:</source>
          <target state="translated">Интерфейсы sqlite3_prepare_v2 (), sqlite3_prepare_v3 (), sqlite3_prepare16_v2 () и sqlite3_prepare16_v3 () рекомендуются для всех новых программ. Старые интерфейсы (sqlite3_prepare () и sqlite3_prepare16 ()) сохранены для обратной совместимости, но их использование не рекомендуется. В интерфейсах &amp;laquo;vX&amp;raquo; возвращаемый подготовленный оператор ( объект &lt;a href=&quot;#sqlite3_stmt&quot;&gt;sqlite3_stmt&lt;/a&gt; ) содержит копию исходного текста SQL. Это приводит к тому, что интерфейс &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step ()&lt;/a&gt; ведет себя по-разному тремя способами:</target>
        </trans-unit>
        <trans-unit id="31c4a31d37db839c6c488798a5abc3fd1e42192d" translate="yes" xml:space="preserve">
          <source>The sqlite3_prepare_v2(), sqlite3_prepare_v3(), sqlite3_prepare16_v2(), and sqlite3_prepare16_v3() interfaces are recommended for all new programs. The older interfaces (sqlite3_prepare() and sqlite3_prepare16()) are retained for backwards compatibility, but their use is discouraged. In the &quot;vX&quot; interfaces, the prepared statement that is returned (the &lt;a href=&quot;stmt&quot;&gt;sqlite3_stmt&lt;/a&gt; object) contains a copy of the original SQL text. This causes the &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; interface to behave differently in three ways:</source>
          <target state="translated">Интерфейсы sqlite3_prepare_v2 (), sqlite3_prepare_v3 (), sqlite3_prepare16_v2 () и sqlite3_prepare16_v3 () рекомендуются для всех новых программ. Старые интерфейсы (sqlite3_prepare () и sqlite3_prepare16 ()) сохранены для обратной совместимости, но их использование не рекомендуется. В интерфейсах &amp;laquo;vX&amp;raquo; возвращаемый подготовленный оператор ( объект &lt;a href=&quot;stmt&quot;&gt;sqlite3_stmt&lt;/a&gt; ) содержит копию исходного текста SQL. Это приводит к тому, что интерфейс &lt;a href=&quot;step&quot;&gt;sqlite3_step ()&lt;/a&gt; ведет себя по-разному тремя способами:</target>
        </trans-unit>
        <trans-unit id="1133258b4a9a31b0c0513ddc50dd402acde6047e" translate="yes" xml:space="preserve">
          <source>The sqlite3_progress_handler(D,N,X,P) interface causes the callback function X to be invoked periodically during long running calls to &lt;a href=&quot;#sqlite3_exec&quot;&gt;sqlite3_exec()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_free_table&quot;&gt;sqlite3_get_table()&lt;/a&gt; for database connection D. An example use for this interface is to keep a GUI updated during a large query.</source>
          <target state="translated">Интерфейс sqlite3_progress_handler (D, N, X, P) вызывает периодический вызов функции обратного вызова X во время длительных вызовов &lt;a href=&quot;#sqlite3_exec&quot;&gt;sqlite3_exec ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step ()&lt;/a&gt; и &lt;a href=&quot;#sqlite3_free_table&quot;&gt;sqlite3_get_table ()&lt;/a&gt; для подключения к базе данных D. Пример использования этого интерфейса: обновлять графический интерфейс во время большого запроса.</target>
        </trans-unit>
        <trans-unit id="6ede9775015331a2dade498d028dbb0b1a89b661" translate="yes" xml:space="preserve">
          <source>The sqlite3_progress_handler(D,N,X,P) interface causes the callback function X to be invoked periodically during long running calls to &lt;a href=&quot;exec&quot;&gt;sqlite3_exec()&lt;/a&gt;, &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; and &lt;a href=&quot;free_table&quot;&gt;sqlite3_get_table()&lt;/a&gt; for database connection D. An example use for this interface is to keep a GUI updated during a large query.</source>
          <target state="translated">Интерфейс sqlite3_progress_handler (D, N, X, P) вызывает периодический вызов функции обратного вызова X во время длительных вызовов &lt;a href=&quot;exec&quot;&gt;sqlite3_exec ()&lt;/a&gt; , &lt;a href=&quot;step&quot;&gt;sqlite3_step ()&lt;/a&gt; и &lt;a href=&quot;free_table&quot;&gt;sqlite3_get_table ()&lt;/a&gt; для подключения к базе данных D. Пример использования этого интерфейса: обновлять графический интерфейс во время большого запроса.</target>
        </trans-unit>
        <trans-unit id="92b3414b60e6ff01e63206d0ac8d5d46b8bec0e5" translate="yes" xml:space="preserve">
          <source>The sqlite3_realloc(X,N) interface attempts to resize a prior memory allocation X to be at least N bytes. If the X parameter to sqlite3_realloc(X,N) is a NULL pointer then its behavior is identical to calling sqlite3_malloc(N). If the N parameter to sqlite3_realloc(X,N) is zero or negative then the behavior is exactly the same as calling sqlite3_free(X). sqlite3_realloc(X,N) returns a pointer to a memory allocation of at least N bytes in size or NULL if insufficient memory is available. If M is the size of the prior allocation, then min(N,M) bytes of the prior allocation are copied into the beginning of buffer returned by sqlite3_realloc(X,N) and the prior allocation is freed. If sqlite3_realloc(X,N) returns NULL and N is positive, then the prior allocation is not freed.</source>
          <target state="translated">Интерфейс sqlite3_realloc(X,N)пытается изменить размер ранее выделенной памяти X как минимум на N байт.Если параметр X sqlite3_realloc(X,N)является указателем NULL,то его поведение идентично вызову sqlite3_malloc(N).Если параметр N sqlite3_realloc(X,N)равен нулю или отрицателен,то его поведение аналогично вызову sqlite3_free(X).sqlite3_realloc(X,N)возвращает указатель на выделение памяти размером не менее N байт или NULL,если памяти недостаточно.Если M-размер предыдущего выделения,то min(N,M)байт предыдущего выделения копируется в начало буфера,возвращаемого sqlite3_realloc(X,N),и предыдущее выделение освобождается.Если sqlite3_realloc(X,N)возвращает NULL,а N положительное,то предыдущее выделение не освобождается.</target>
        </trans-unit>
        <trans-unit id="e95adede07a7a66375653b101c394b5d26a89fcd" translate="yes" xml:space="preserve">
          <source>The sqlite3_realloc64(X,N) interfaces works the same as sqlite3_realloc(X,N) except that N is a 64-bit unsigned integer instead of a 32-bit signed integer.</source>
          <target state="translated">Интерфейсы sqlite3_realloc64(X,N)работают так же,как и sqlite3_realloc(X,N),за исключением того,что N является 64-битным беззнаковым целым числом вместо 32-битного знакового.</target>
        </trans-unit>
        <trans-unit id="c45df4cf90bd7042631d9142c52fed7adb90361e" translate="yes" xml:space="preserve">
          <source>The sqlite3_rebaser object is deleted by calling sqlite3rebaser_delete().</source>
          <target state="translated">Удаление объекта sqlite3_rebaser производится вызовом sqlite3rebaser_delete().</target>
        </trans-unit>
        <trans-unit id="4a286ff8214a968ca30b48466d6f539d2ffd723c" translate="yes" xml:space="preserve">
          <source>The sqlite3_release_memory() interface attempts to free N bytes of heap memory by deallocating non-essential memory allocations held by the database library. Memory used to cache database pages to improve performance is an example of non-essential memory. sqlite3_release_memory() returns the number of bytes actually freed, which might be more or less than the amount requested. The sqlite3_release_memory() routine is a no-op returning zero if SQLite is not compiled with &lt;a href=&quot;../compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt;.</source>
          <target state="translated">Интерфейс sqlite3_release_memory () пытается освободить N байтов кучи, освобождая несущественные выделения памяти, хранящиеся в библиотеке базы данных. Память, используемая для кэширования страниц базы данных с целью повышения производительности, является примером несущественной памяти. sqlite3_release_memory () возвращает количество фактически освобожденных байтов, которое может быть больше или меньше запрошенного количества. Процедура sqlite3_release_memory () - это не &lt;a href=&quot;../compile#enable_memory_management&quot;&gt;операция,&lt;/a&gt; возвращающая ноль, если SQLite не скомпилирован с SQLITE_ENABLE_MEMORY_MANAGEMENT .</target>
        </trans-unit>
        <trans-unit id="e641eb92f089a94b694e1eb10428491e684eab1f" translate="yes" xml:space="preserve">
          <source>The sqlite3_release_memory() interface attempts to free N bytes of heap memory by deallocating non-essential memory allocations held by the database library. Memory used to cache database pages to improve performance is an example of non-essential memory. sqlite3_release_memory() returns the number of bytes actually freed, which might be more or less than the amount requested. The sqlite3_release_memory() routine is a no-op returning zero if SQLite is not compiled with &lt;a href=&quot;compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt;.</source>
          <target state="translated">Интерфейс sqlite3_release_memory () пытается освободить N байтов кучи, освобождая несущественные выделения памяти, хранящиеся в библиотеке базы данных. Память, используемая для кэширования страниц базы данных с целью повышения производительности, является примером несущественной памяти. sqlite3_release_memory () возвращает количество фактически освобожденных байтов, которое может быть больше или меньше запрошенного количества. Процедура sqlite3_release_memory () - это не &lt;a href=&quot;compile#enable_memory_management&quot;&gt;операция,&lt;/a&gt; возвращающая ноль, если SQLite не скомпилирован с SQLITE_ENABLE_MEMORY_MANAGEMENT .</target>
        </trans-unit>
        <trans-unit id="54ae89d5ac2183e89297de25b936056b80fa288f" translate="yes" xml:space="preserve">
          <source>The sqlite3_reset() function is called to reset a &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; object back to its initial state, ready to be re-executed. Any SQL statement variables that had values bound to them using the &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;sqlite3_bind_*() API&lt;/a&gt; retain their values. Use &lt;a href=&quot;#sqlite3_clear_bindings&quot;&gt;sqlite3_clear_bindings()&lt;/a&gt; to reset the bindings.</source>
          <target state="translated">Функция sqlite3_reset () вызывается для сброса &lt;a href=&quot;#sqlite3_stmt&quot;&gt;подготовленного&lt;/a&gt; объекта оператора обратно в его начальное состояние, готового к повторному выполнению. Все переменные инструкции SQL, значения которых были привязаны к ним с помощью &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;API sqlite3_bind _ * (),&lt;/a&gt; сохраняют свои значения. Используйте &lt;a href=&quot;#sqlite3_clear_bindings&quot;&gt;sqlite3_clear_bindings ()&lt;/a&gt; для сброса привязок.</target>
        </trans-unit>
        <trans-unit id="55cabea2592a4db5b69eb055b74aa3254a909a13" translate="yes" xml:space="preserve">
          <source>The sqlite3_reset() function is called to reset a &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; object back to its initial state, ready to be re-executed. Any SQL statement variables that had values bound to them using the &lt;a href=&quot;bind_blob&quot;&gt;sqlite3_bind_*() API&lt;/a&gt; retain their values. Use &lt;a href=&quot;clear_bindings&quot;&gt;sqlite3_clear_bindings()&lt;/a&gt; to reset the bindings.</source>
          <target state="translated">Функция sqlite3_reset () вызывается для сброса &lt;a href=&quot;stmt&quot;&gt;подготовленного&lt;/a&gt; объекта оператора обратно в его начальное состояние, готового к повторному выполнению. Все переменные инструкции SQL, значения которых были привязаны к ним с помощью &lt;a href=&quot;bind_blob&quot;&gt;API sqlite3_bind _ * (),&lt;/a&gt; сохраняют свои значения. Используйте &lt;a href=&quot;clear_bindings&quot;&gt;sqlite3_clear_bindings ()&lt;/a&gt; для сброса привязок.</target>
        </trans-unit>
        <trans-unit id="ee8a502aaf09ac296b4bb201f29d8a4e68054a04" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_blob() interface sets the result from an application-defined function to be the BLOB whose content is pointed to by the second parameter and which is N bytes long where N is the third parameter.</source>
          <target state="translated">Интерфейс sqlite3_result_blob()устанавливает результат от функции,определяемой приложением,в BLOB,на содержимое которой указывает второй параметр,а длина N байт,где N-третий параметр.</target>
        </trans-unit>
        <trans-unit id="b7904572bea3279794f2bcc9179991e08e12d408" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_double() interface sets the result from an application-defined function to be a floating point value specified by its 2nd argument.</source>
          <target state="translated">Интерфейс sqlite3_result_double()устанавливает в качестве результата работы функции,определяемой приложением,значение с плавающей точкой,заданное ее 2-м аргументом.</target>
        </trans-unit>
        <trans-unit id="ea6209b4564a5f3773fd6febf3293c65522a4bc0" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_error() and sqlite3_result_error16() functions cause the implemented SQL function to throw an exception. SQLite uses the string pointed to by the 2nd parameter of sqlite3_result_error() or sqlite3_result_error16() as the text of an error message. SQLite interprets the error message string from sqlite3_result_error() as UTF-8. SQLite interprets the string from sqlite3_result_error16() as UTF-16 in native byte order. If the third parameter to sqlite3_result_error() or sqlite3_result_error16() is negative then SQLite takes as the error message all text up through the first zero character. If the third parameter to sqlite3_result_error() or sqlite3_result_error16() is non-negative then SQLite takes that many bytes (not characters) from the 2nd parameter as the error message. The sqlite3_result_error() and sqlite3_result_error16() routines make a private copy of the error message text before they return. Hence, the calling function can deallocate or modify the text after they return without harm. The sqlite3_result_error_code() function changes the error code returned by SQLite as a result of an error in a function. By default, the error code is SQLITE_ERROR. A subsequent call to sqlite3_result_error() or sqlite3_result_error16() resets the error code to SQLITE_ERROR.</source>
          <target state="translated">Функции sqlite3_result_error()и sqlite3_result_error16()приводят к тому,что реализованная SQL-функция бросает исключение.В качестве текста сообщения об ошибке SQLite использует строку,на которую указывает 2-й параметр sqlite3_result_error()или sqlite3_result_error16().SQLite интерпретирует строку сообщения об ошибке из sqlite3_result_error()как UTF-8.SQLite интерпретирует строку из sqlite3_result_error16()как UTF-16 в родном порядке байт.Если третий параметр sqlite3_result_error()или sqlite3_result_error16()отрицательный,то SQLite принимает за сообщение об ошибке весь текст вверх через первый нулевой символ.Если третий параметр sqlite3_result_error()или sqlite3_result_error16()не имеет отрицательного значения,то SQLite принимает в качестве сообщения об ошибке столько байт (не символов)от 2-го параметра.Рутины sqlite3_result_error()и sqlite3_result_error16()делают приватную копию текста сообщения об ошибке перед возвращением.Следовательно,вызывающая функция может разблокировать или модифицировать текст после их возврата без ущерба.Функция sqlite3_result_error_code()изменяет код ошибки,возвращаемый SQLite в результате ошибки в функции.По умолчанию код ошибки SQLITE_ERROR.Последующий вызов sqlite3_result_error()или sqlite3_result_error16()сбрасывает код ошибки на SQLITE_ERROR.</target>
        </trans-unit>
        <trans-unit id="29f28f42596987edc9ab24a265ebb7acbdeb19a7" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_error() and sqlite3_result_error16() functions cause the implemented SQL function to throw an exception. SQLite uses the string pointed to by the 2nd parameter of sqlite3_result_error() or sqlite3_result_error16() as the text of an error message. SQLite interprets the error message string from sqlite3_result_error() as UTF-8. SQLite interprets the string from sqlite3_result_error16() as UTF-16 using the same &lt;a href=&quot;#byteorderdeterminationrules&quot;&gt;byte-order determination rules&lt;/a&gt; as &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;sqlite3_bind_text16()&lt;/a&gt;. If the third parameter to sqlite3_result_error() or sqlite3_result_error16() is negative then SQLite takes as the error message all text up through the first zero character. If the third parameter to sqlite3_result_error() or sqlite3_result_error16() is non-negative then SQLite takes that many bytes (not characters) from the 2nd parameter as the error message. The sqlite3_result_error() and sqlite3_result_error16() routines make a private copy of the error message text before they return. Hence, the calling function can deallocate or modify the text after they return without harm. The sqlite3_result_error_code() function changes the error code returned by SQLite as a result of an error in a function. By default, the error code is SQLITE_ERROR. A subsequent call to sqlite3_result_error() or sqlite3_result_error16() resets the error code to SQLITE_ERROR.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5a0bd3f253d68fda2502decfe5e0f0d13527f91" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_error() and sqlite3_result_error16() functions cause the implemented SQL function to throw an exception. SQLite uses the string pointed to by the 2nd parameter of sqlite3_result_error() or sqlite3_result_error16() as the text of an error message. SQLite interprets the error message string from sqlite3_result_error() as UTF-8. SQLite interprets the string from sqlite3_result_error16() as UTF-16 using the same &lt;a href=&quot;bind_blob#byteorderdeterminationrules&quot;&gt;byte-order determination rules&lt;/a&gt; as &lt;a href=&quot;bind_blob&quot;&gt;sqlite3_bind_text16()&lt;/a&gt;. If the third parameter to sqlite3_result_error() or sqlite3_result_error16() is negative then SQLite takes as the error message all text up through the first zero character. If the third parameter to sqlite3_result_error() or sqlite3_result_error16() is non-negative then SQLite takes that many bytes (not characters) from the 2nd parameter as the error message. The sqlite3_result_error() and sqlite3_result_error16() routines make a private copy of the error message text before they return. Hence, the calling function can deallocate or modify the text after they return without harm. The sqlite3_result_error_code() function changes the error code returned by SQLite as a result of an error in a function. By default, the error code is SQLITE_ERROR. A subsequent call to sqlite3_result_error() or sqlite3_result_error16() resets the error code to SQLITE_ERROR.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9161e1bf262f2df329446fa1f6bc65f20e7794e5" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_error_nomem() interface causes SQLite to throw an error indicating that a memory allocation failed.</source>
          <target state="translated">Интерфейс sqlite3_result_error_nomem()приводит к тому,что SQLite выдает ошибку,указывающую на неудачное выделение памяти.</target>
        </trans-unit>
        <trans-unit id="9e5d46d0dedea736182a8b4b5fc9e97d872ed801" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_error_toobig() interface causes SQLite to throw an error indicating that a string or BLOB is too long to represent.</source>
          <target state="translated">Интерфейс sqlite3_result_error_toobig()заставляет SQLite выдавать ошибку,указывающую на то,что строка или BLOB слишком длинная для представления.</target>
        </trans-unit>
        <trans-unit id="f6cfb870f85ac1c6d72052f09d1c9de9769820e3" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_int() interface sets the return value of the application-defined function to be the 32-bit signed integer value given in the 2nd argument. The sqlite3_result_int64() interface sets the return value of the application-defined function to be the 64-bit signed integer value given in the 2nd argument.</source>
          <target state="translated">Интерфейс sqlite3_result_int()устанавливает возвращаемое значение функции,определяемой приложением,в качестве 32-битного знакового целого значения,заданного во 2-м аргументе.Интерфейс sqlite3_result_int64()устанавливает возвращаемое значение функции,определяемой приложением,в качестве 64-битного знакового целого значения,заданного во 2-м аргументе.</target>
        </trans-unit>
        <trans-unit id="6279fe7ee925bdc0e3f640e0b50cfa7f6bf20e52" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_null() interface sets the return value of the application-defined function to be NULL.</source>
          <target state="translated">Интерфейс sqlite3_result_null()устанавливает возвращаемое значение функции,определяемой приложением,в NULL.</target>
        </trans-unit>
        <trans-unit id="16d6bb7320a3240a335aa7ac5ed9b9a1d6945bef" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_pointer(C,P,T,D) interface sets the result to an SQL NULL value, just like &lt;a href=&quot;#sqlite3_result_blob&quot;&gt;sqlite3_result_null(C)&lt;/a&gt;, except that it also associates the host-language pointer P or type T with that NULL value such that the pointer can be retrieved within an &lt;a href=&quot;#sqlite3_create_function&quot;&gt;application-defined SQL function&lt;/a&gt; using &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_pointer()&lt;/a&gt;. If the D parameter is not NULL, then it is a pointer to a destructor for the P parameter. SQLite invokes D with P as its only argument when SQLite is finished with P. The T parameter should be a static string and preferably a string literal. The sqlite3_result_pointer() routine is part of the &lt;a href=&quot;bindptr&quot;&gt;pointer passing interface&lt;/a&gt; added for SQLite 3.20.0.</source>
          <target state="translated">Интерфейс sqlite3_result_pointer (C, P, T, D) устанавливает результат равным значению SQL NULL, так же, как &lt;a href=&quot;#sqlite3_result_blob&quot;&gt;sqlite3_result_null (C)&lt;/a&gt; , за исключением того, что он также связывает указатель языка хоста P или тип T с этим значением NULL, так что указатель могут быть получены в рамках определяемой &lt;a href=&quot;#sqlite3_create_function&quot;&gt;приложением функции SQL&lt;/a&gt; с помощью &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_pointer ()&lt;/a&gt; . Если параметр D не равен NULL, то это указатель на деструктор для параметра P. SQLite вызывает D с P в качестве единственного аргумента, когда SQLite завершает работу с P. Параметр T должен быть статической строкой и предпочтительно строковым литералом. Подпрограмма sqlite3_result_pointer () является частью &lt;a href=&quot;bindptr&quot;&gt;интерфейса передачи указателя,&lt;/a&gt; добавленного для SQLite 3.20.0.</target>
        </trans-unit>
        <trans-unit id="2141ed898fc1d1e35a1c686aae779faa61d104a5" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_pointer(C,P,T,D) interface sets the result to an SQL NULL value, just like &lt;a href=&quot;#sqlite3_result_blob&quot;&gt;sqlite3_result_null(C)&lt;/a&gt;, except that it also associates the host-language pointer P or type T with that NULL value such that the pointer can be retrieved within an &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL function&lt;/a&gt; using &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_pointer()&lt;/a&gt;. If the D parameter is not NULL, then it is a pointer to a destructor for the P parameter. SQLite invokes D with P as its only argument when SQLite is finished with P. The T parameter should be a static string and preferably a string literal. The sqlite3_result_pointer() routine is part of the &lt;a href=&quot;bindptr&quot;&gt;pointer passing interface&lt;/a&gt; added for SQLite 3.20.0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abeb9a4e536ac73c7793be889cbe18ade4a8329e" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_pointer(C,P,T,D) interface sets the result to an SQL NULL value, just like &lt;a href=&quot;result_blob&quot;&gt;sqlite3_result_null(C)&lt;/a&gt;, except that it also associates the host-language pointer P or type T with that NULL value such that the pointer can be retrieved within an &lt;a href=&quot;../appfunc&quot;&gt;application-defined SQL function&lt;/a&gt; using &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_pointer()&lt;/a&gt;. If the D parameter is not NULL, then it is a pointer to a destructor for the P parameter. SQLite invokes D with P as its only argument when SQLite is finished with P. The T parameter should be a static string and preferably a string literal. The sqlite3_result_pointer() routine is part of the &lt;a href=&quot;../bindptr&quot;&gt;pointer passing interface&lt;/a&gt; added for SQLite 3.20.0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="870667722e41d2c1c37c185e96c88c88778eea77" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_pointer(C,P,T,D) interface sets the result to an SQL NULL value, just like &lt;a href=&quot;result_blob&quot;&gt;sqlite3_result_null(C)&lt;/a&gt;, except that it also associates the host-language pointer P or type T with that NULL value such that the pointer can be retrieved within an &lt;a href=&quot;create_function&quot;&gt;application-defined SQL function&lt;/a&gt; using &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_pointer()&lt;/a&gt;. If the D parameter is not NULL, then it is a pointer to a destructor for the P parameter. SQLite invokes D with P as its only argument when SQLite is finished with P. The T parameter should be a static string and preferably a string literal. The sqlite3_result_pointer() routine is part of the &lt;a href=&quot;../bindptr&quot;&gt;pointer passing interface&lt;/a&gt; added for SQLite 3.20.0.</source>
          <target state="translated">Интерфейс sqlite3_result_pointer (C, P, T, D) устанавливает результат равным значению SQL NULL, так же, как &lt;a href=&quot;result_blob&quot;&gt;sqlite3_result_null (C)&lt;/a&gt; , за исключением того, что он также связывает указатель языка хоста P или тип T с этим значением NULL, так что указатель могут быть получены в рамках определяемой &lt;a href=&quot;create_function&quot;&gt;приложением функции SQL&lt;/a&gt; с помощью &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_pointer ()&lt;/a&gt; . Если параметр D не равен NULL, то это указатель на деструктор для параметра P. SQLite вызывает D с P в качестве единственного аргумента, когда SQLite завершает работу с P. Параметр T должен быть статической строкой и предпочтительно строковым литералом. Подпрограмма sqlite3_result_pointer () является частью &lt;a href=&quot;../bindptr&quot;&gt;интерфейса передачи указателя,&lt;/a&gt; добавленного для SQLite 3.20.0.</target>
        </trans-unit>
        <trans-unit id="a4e926904c44e1c10338c3ed629ffd93dee056e2" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_subtype(C,T) function causes the subtype of the result from the &lt;a href=&quot;#sqlite3_create_function&quot;&gt;application-defined SQL function&lt;/a&gt; with &lt;a href=&quot;#sqlite3_context&quot;&gt;sqlite3_context&lt;/a&gt; C to be the value T. Only the lower 8 bits of the subtype T are preserved in current versions of SQLite; higher order bits are discarded. The number of subtype bytes preserved by SQLite might increase in future releases of SQLite.</source>
          <target state="translated">Функция sqlite3_result_subtype (C, T) заставляет подтип результата от определяемой &lt;a href=&quot;#sqlite3_create_function&quot;&gt;приложением функции SQL&lt;/a&gt; с &lt;a href=&quot;#sqlite3_context&quot;&gt;sqlite3_context&lt;/a&gt; C быть значением T. В текущих версиях SQLite сохраняются только младшие 8 битов подтипа T; биты более высокого порядка отбрасываются. Количество байтов подтипа, сохраняемых SQLite, может увеличиться в будущих выпусках SQLite.</target>
        </trans-unit>
        <trans-unit id="14b620485a8968d2bc78129bd173a352a06dd552" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_subtype(C,T) function causes the subtype of the result from the &lt;a href=&quot;../appfunc&quot;&gt;application-defined SQL function&lt;/a&gt; with &lt;a href=&quot;context&quot;&gt;sqlite3_context&lt;/a&gt; C to be the value T. Only the lower 8 bits of the subtype T are preserved in current versions of SQLite; higher order bits are discarded. The number of subtype bytes preserved by SQLite might increase in future releases of SQLite.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b466179681aeddfbf231a03d679d2648006d92dc" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_subtype(C,T) function causes the subtype of the result from the &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL function&lt;/a&gt; with &lt;a href=&quot;#sqlite3_context&quot;&gt;sqlite3_context&lt;/a&gt; C to be the value T. Only the lower 8 bits of the subtype T are preserved in current versions of SQLite; higher order bits are discarded. The number of subtype bytes preserved by SQLite might increase in future releases of SQLite.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d462f96f6d4a97e8d351d18ac7f1c494815765c7" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_subtype(C,T) function causes the subtype of the result from the &lt;a href=&quot;create_function&quot;&gt;application-defined SQL function&lt;/a&gt; with &lt;a href=&quot;context&quot;&gt;sqlite3_context&lt;/a&gt; C to be the value T. Only the lower 8 bits of the subtype T are preserved in current versions of SQLite; higher order bits are discarded. The number of subtype bytes preserved by SQLite might increase in future releases of SQLite.</source>
          <target state="translated">Функция sqlite3_result_subtype (C, T) заставляет подтип результата от определяемой &lt;a href=&quot;create_function&quot;&gt;приложением функции SQL&lt;/a&gt; с &lt;a href=&quot;context&quot;&gt;sqlite3_context&lt;/a&gt; C быть значением T. В текущих версиях SQLite сохраняются только младшие 8 битов подтипа T; биты более высокого порядка отбрасываются. Количество байтов подтипа, сохраняемых SQLite, может увеличиться в будущих выпусках SQLite.</target>
        </trans-unit>
        <trans-unit id="8fc6882e24d42f347f5ab25fb2f2b1c639f2f020" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_text(), sqlite3_result_text16(), sqlite3_result_text16le(), and sqlite3_result_text16be() interfaces set the return value of the application-defined function to be a text string which is represented as UTF-8, UTF-16 native byte order, UTF-16 little endian, or UTF-16 big endian, respectively. The sqlite3_result_text64() interface sets the return value of an application-defined function to be a text string in an encoding specified by the fifth (and last) parameter, which must be one of &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF8&lt;/a&gt;, &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16&lt;/a&gt;, &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16BE&lt;/a&gt;, or &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16LE&lt;/a&gt;. SQLite takes the text result from the application from the 2nd parameter of the sqlite3_result_text* interfaces. If the 3rd parameter to the sqlite3_result_text* interfaces is negative, then SQLite takes result text from the 2nd parameter through the first zero character. If the 3rd parameter to the sqlite3_result_text* interfaces is non-negative, then as many bytes (not characters) of the text pointed to by the 2nd parameter are taken as the application-defined function result. If the 3rd parameter is non-negative, then it must be the byte offset into the string where the NUL terminator would appear if the string where NUL terminated. If any NUL characters occur in the string at a byte offset that is less than the value of the 3rd parameter, then the resulting string will contain embedded NULs and the result of expressions operating on strings with embedded NULs is undefined. If the 4th parameter to the sqlite3_result_text* interfaces or sqlite3_result_blob is a non-NULL pointer, then SQLite calls that function as the destructor on the text or BLOB result when it has finished using that result. If the 4th parameter to the sqlite3_result_text* interfaces or to sqlite3_result_blob is the special constant SQLITE_STATIC, then SQLite assumes that the text or BLOB result is in constant space and does not copy the content of the parameter nor call a destructor on the content when it has finished using that result. If the 4th parameter to the sqlite3_result_text* interfaces or sqlite3_result_blob is the special constant SQLITE_TRANSIENT then SQLite makes a copy of the result into space obtained from &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc()&lt;/a&gt; before it returns.</source>
          <target state="translated">Интерфейсы sqlite3_result_text (), sqlite3_result_text16 (), sqlite3_result_text16le () и sqlite3_result_text16be () устанавливают возвращаемое значение функции, определяемой приложением, как текстовую строку, которая представлена ​​как UTF-8, собственный порядок байтов UTF-16, UTF- 16 с прямым порядком байтов или UTF-16 с прямым порядком байтов соответственно. Интерфейс sqlite3_result_text64 () устанавливает возвращаемое значение функции, определяемой приложением, как текстовую строку в кодировке, заданной пятым (и последним) параметром, который должен быть одним из &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF8&lt;/a&gt; , &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16&lt;/a&gt; , &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16BE&lt;/a&gt; или &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16LE.&lt;/a&gt;. SQLite берет текстовый результат из приложения из 2-го параметра интерфейсов sqlite3_result_text *. Если 3-й параметр интерфейсов sqlite3_result_text * отрицательный, то SQLite принимает текст результата от 2-го параметра до первого нулевого символа. Если 3-й параметр интерфейсов sqlite3_result_text * неотрицателен, то в качестве результата функции, определяемой приложением, принимается столько же байтов (не символов) текста, на которое указывает 2-й параметр. Если 3-й параметр неотрицателен, то это должно быть байтовое смещение в строке, где появится терминатор NUL, если строка, в которой завершается NUL. Если какие-либо символы NUL встречаются в строке со смещением байта, меньшим, чем значение 3-го параметра,тогда результирующая строка будет содержать встроенные NUL, а результат выражений, работающих со строками со встроенными NUL, не определен. Если 4-й параметр для интерфейсов sqlite3_result_text * или sqlite3_result_blob является указателем, отличным от NULL, то SQLite вызывает эту функцию как деструктор для текста или результата BLOB, когда он закончил использовать этот результат. Если 4-й параметр для интерфейсов sqlite3_result_text * или sqlite3_result_blob является специальной константой SQLITE_STATIC, то SQLite предполагает, что текст или результат BLOB находится в постоянном пространстве и не копирует содержимое параметра и не вызывает деструктор для содержимого, когда он имеет закончил использовать этот результат.Если 4-й параметр для интерфейсов sqlite3_result_text * или sqlite3_result_blob - это специальная константа SQLITE_TRANSIENT, тогда SQLite копирует результат в пространство, полученное из&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc ()&lt;/a&gt; перед возвратом.</target>
        </trans-unit>
        <trans-unit id="ffc0515c64350de79930cdbbfae27bfbd23133bf" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_text(), sqlite3_result_text16(), sqlite3_result_text16le(), and sqlite3_result_text16be() interfaces set the return value of the application-defined function to be a text string which is represented as UTF-8, UTF-16 native byte order, UTF-16 little endian, or UTF-16 big endian, respectively. The sqlite3_result_text64() interface sets the return value of an application-defined function to be a text string in an encoding specified by the fifth (and last) parameter, which must be one of &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF8&lt;/a&gt;, &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16&lt;/a&gt;, &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16BE&lt;/a&gt;, or &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16LE&lt;/a&gt;. SQLite takes the text result from the application from the 2nd parameter of the sqlite3_result_text* interfaces. If the 3rd parameter to the sqlite3_result_text* interfaces is negative, then SQLite takes result text from the 2nd parameter through the first zero character. If the 3rd parameter to the sqlite3_result_text* interfaces is non-negative, then as many bytes (not characters) of the text pointed to by the 2nd parameter are taken as the application-defined function result. If the 3rd parameter is non-negative, then it must be the byte offset into the string where the NUL terminator would appear if the string where NUL terminated. If any NUL characters occur in the string at a byte offset that is less than the value of the 3rd parameter, then the resulting string will contain embedded NULs and the result of expressions operating on strings with embedded NULs is undefined. If the 4th parameter to the sqlite3_result_text* interfaces or sqlite3_result_blob is a non-NULL pointer, then SQLite calls that function as the destructor on the text or BLOB result when it has finished using that result. If the 4th parameter to the sqlite3_result_text* interfaces or to sqlite3_result_blob is the special constant SQLITE_STATIC, then SQLite assumes that the text or BLOB result is in constant space and does not copy the content of the parameter nor call a destructor on the content when it has finished using that result. If the 4th parameter to the sqlite3_result_text* interfaces or sqlite3_result_blob is the special constant SQLITE_TRANSIENT then SQLite makes a copy of the result into space obtained from &lt;a href=&quot;free&quot;&gt;sqlite3_malloc()&lt;/a&gt; before it returns.</source>
          <target state="translated">Интерфейсы sqlite3_result_text (), sqlite3_result_text16 (), sqlite3_result_text16le () и sqlite3_result_text16be () устанавливают возвращаемое значение функции, определяемой приложением, как текстовую строку, которая представлена ​​как UTF-8, собственный порядок байтов UTF-16, UTF- 16 с прямым порядком байтов или UTF-16 с прямым порядком байтов соответственно. Интерфейс sqlite3_result_text64 () устанавливает возвращаемое значение функции, определяемой приложением, как текстовую строку в кодировке, заданной пятым (и последним) параметром, который должен быть одним из &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF8&lt;/a&gt; , &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16&lt;/a&gt; , &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16BE&lt;/a&gt; или &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16LE.&lt;/a&gt;. SQLite берет текстовый результат из приложения из 2-го параметра интерфейсов sqlite3_result_text *. Если 3-й параметр интерфейсов sqlite3_result_text * отрицательный, то SQLite принимает текст результата от 2-го параметра до первого нулевого символа. Если 3-й параметр интерфейсов sqlite3_result_text * неотрицателен, то в качестве результата функции, определяемой приложением, принимается столько же байтов (не символов) текста, на которое указывает 2-й параметр. Если 3-й параметр неотрицателен, то это должно быть байтовое смещение в строке, где появится терминатор NUL, если строка, в которой завершается NUL. Если какие-либо символы NUL встречаются в строке со смещением байта, меньшим, чем значение 3-го параметра,тогда результирующая строка будет содержать встроенные NUL, а результат выражений, работающих со строками со встроенными NUL, не определен. Если 4-й параметр для интерфейсов sqlite3_result_text * или sqlite3_result_blob является указателем, отличным от NULL, то SQLite вызывает эту функцию как деструктор для текста или результата BLOB, когда он закончил использовать этот результат. Если 4-й параметр для интерфейсов sqlite3_result_text * или sqlite3_result_blob является специальной константой SQLITE_STATIC, то SQLite предполагает, что текст или результат BLOB находится в постоянном пространстве и не копирует содержимое параметра и не вызывает деструктор для содержимого, когда он имеет закончил использовать этот результат.Если 4-й параметр для интерфейсов sqlite3_result_text * или sqlite3_result_blob - это специальная константа SQLITE_TRANSIENT, тогда SQLite копирует результат в пространство, полученное из&lt;a href=&quot;free&quot;&gt;sqlite3_malloc ()&lt;/a&gt; перед возвратом.</target>
        </trans-unit>
        <trans-unit id="66d19148a84e04f07a639f83744f212454fd9d54" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_value() interface sets the result of the application-defined function to be a copy of the &lt;a href=&quot;#sqlite3_value&quot;&gt;unprotected sqlite3_value&lt;/a&gt; object specified by the 2nd parameter. The sqlite3_result_value() interface makes a copy of the &lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt; so that the &lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt; specified in the parameter may change or be deallocated after sqlite3_result_value() returns without harm. A &lt;a href=&quot;#sqlite3_value&quot;&gt;protected sqlite3_value&lt;/a&gt; object may always be used where an &lt;a href=&quot;#sqlite3_value&quot;&gt;unprotected sqlite3_value&lt;/a&gt; object is required, so either kind of &lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt; object can be used with this interface.</source>
          <target state="translated">Интерфейс sqlite3_result_value () устанавливает результат функции, определяемой приложением, как копию &lt;a href=&quot;#sqlite3_value&quot;&gt;незащищенного&lt;/a&gt; объекта sqlite3_value, указанного вторым параметром. Интерфейс sqlite3_result_value () делает копию &lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value,&lt;/a&gt; так что &lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value,&lt;/a&gt; указанное в параметре, может измениться или быть освобождено после того, как sqlite3_result_value () вернется без вреда. &lt;a href=&quot;#sqlite3_value&quot;&gt;Защищенный sqlite3_value&lt;/a&gt; объект всегда может быть использован , где &lt;a href=&quot;#sqlite3_value&quot;&gt;незащищенный sqlite3_value&lt;/a&gt; требуется объект, так как вид &lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt; объекта может быть использован с этим интерфейсом.</target>
        </trans-unit>
        <trans-unit id="9c611bb0b94d5204b93fd73ea02598841b3b449f" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_value() interface sets the result of the application-defined function to be a copy of the &lt;a href=&quot;value&quot;&gt;unprotected sqlite3_value&lt;/a&gt; object specified by the 2nd parameter. The sqlite3_result_value() interface makes a copy of the &lt;a href=&quot;value&quot;&gt;sqlite3_value&lt;/a&gt; so that the &lt;a href=&quot;value&quot;&gt;sqlite3_value&lt;/a&gt; specified in the parameter may change or be deallocated after sqlite3_result_value() returns without harm. A &lt;a href=&quot;value&quot;&gt;protected sqlite3_value&lt;/a&gt; object may always be used where an &lt;a href=&quot;value&quot;&gt;unprotected sqlite3_value&lt;/a&gt; object is required, so either kind of &lt;a href=&quot;value&quot;&gt;sqlite3_value&lt;/a&gt; object can be used with this interface.</source>
          <target state="translated">Интерфейс sqlite3_result_value () устанавливает результат функции, определяемой приложением, как копию &lt;a href=&quot;value&quot;&gt;незащищенного&lt;/a&gt; объекта sqlite3_value, указанного вторым параметром. Интерфейс sqlite3_result_value () делает копию &lt;a href=&quot;value&quot;&gt;sqlite3_value,&lt;/a&gt; так что &lt;a href=&quot;value&quot;&gt;sqlite3_value,&lt;/a&gt; указанное в параметре, может измениться или быть освобождено после того, как sqlite3_result_value () вернется без вреда. &lt;a href=&quot;value&quot;&gt;Защищенный sqlite3_value&lt;/a&gt; объект всегда может быть использован , где &lt;a href=&quot;value&quot;&gt;незащищенный sqlite3_value&lt;/a&gt; требуется объект, так как вид &lt;a href=&quot;value&quot;&gt;sqlite3_value&lt;/a&gt; объекта может быть использован с этим интерфейсом.</target>
        </trans-unit>
        <trans-unit id="3b2bde2ed5663531d681bf21defe3755de5aa926" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_zeroblob(C,N) and sqlite3_result_zeroblob64(C,N) interfaces set the result of the application-defined function to be a BLOB containing all zero bytes and N bytes in size.</source>
          <target state="translated">Интерфейсы sqlite3_result_zeroblob(C,N)и sqlite3_result_zeroblob64(C,N)устанавливают результат определяемой приложением функции в BLOB,содержащий все нулевые байты и N байт в размере.</target>
        </trans-unit>
        <trans-unit id="38bbbf7ab9a0945b32615ce5c77fecc3dda2b8bb" translate="yes" xml:space="preserve">
          <source>The sqlite3_rtree_geometry structure that the first argument to the xGeom callback points to has a structure shown below. The exact same sqlite3_rtree_geometry structure is used for every callback for same MATCH operator in the same query. The contents of the sqlite3_rtree_geometry structure are initialized by SQLite but are not subsequently modified. The callback is free to make changes to the pUser and xDelUser elements of the structure if desired.</source>
          <target state="translated">Структура sqlite3_rtree_geometry,на которую указывает первый аргумент обратного вызова xGeom,имеет структуру,показанную ниже.Точно такая же структура sqlite3_rtree_geometry используется для каждого обратного вызова для одного и того же MATCH-оператора в одном и том же запросе.Содержимое структуры sqlite3_rtree_geometry инициализируется SQLite,но в дальнейшем не изменяется.Обратный вызов свободен для внесения изменений в элементы структуры pUser и xDelUser при желании.</target>
        </trans-unit>
        <trans-unit id="23ca7c4bc54ebb3192ebcd695698caa11c607135" translate="yes" xml:space="preserve">
          <source>The sqlite3_rtree_query_callback() became available with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_5.html&quot;&gt;version 3.8.5&lt;/a&gt; (2014-06-04) and is the preferred interface. The sqlite3_rtree_geometry_callback() is an older and less flexible interface that is supported for backwards compatibility.</source>
          <target state="translated">Sqlite3_rtree_query_callback () стал доступен с &lt;a href=&quot;https://sqlite.org/releaselog/3_8_5.html&quot;&gt;версией&lt;/a&gt; SQLite 3.8.5 (2014-06-04) и является предпочтительным интерфейсом. Sqlite3_rtree_geometry_callback () - это более старый и менее гибкий интерфейс, который поддерживается для обратной совместимости.</target>
        </trans-unit>
        <trans-unit id="a4141688a761802a4dde7063e989412b5ba08576" translate="yes" xml:space="preserve">
          <source>The sqlite3_serialize(D,S,P,F) interface returns a pointer to memory that is a serialization of the S database on &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; D. If P is not a NULL pointer, then the size of the database in bytes is written into *P.</source>
          <target state="translated">Интерфейс sqlite3_serialize (D, S, P, F) возвращает указатель на память, который является сериализацией базы &lt;a href=&quot;#sqlite3&quot;&gt;данных&lt;/a&gt; S при подключении к базе данных D. Если P не является указателем NULL, то размер базы данных в байтах записывается в * П.</target>
        </trans-unit>
        <trans-unit id="fd8828a508df0b7bef3d1d62a2ae33a5520d58f6" translate="yes" xml:space="preserve">
          <source>The sqlite3_serialize(D,S,P,F) interface returns a pointer to memory that is a serialization of the S database on &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; D. If P is not a NULL pointer, then the size of the database in bytes is written into *P.</source>
          <target state="translated">Интерфейс sqlite3_serialize (D, S, P, F) возвращает указатель на память, который является сериализацией базы &lt;a href=&quot;sqlite3&quot;&gt;данных&lt;/a&gt; S при подключении к базе данных D. Если P не является указателем NULL, то размер базы данных в байтах записывается в * П.</target>
        </trans-unit>
        <trans-unit id="d9311ad5ed8e88f0e0e396fbe1a059c5d4e870f6" translate="yes" xml:space="preserve">
          <source>The sqlite3_set_auxdata(C,N,P,X) interface saves P as metadata for the N-th argument of the application-defined function. Subsequent calls to sqlite3_get_auxdata(C,N) return P from the most recent sqlite3_set_auxdata(C,N,P,X) call if the metadata is still valid or NULL if the metadata has been discarded. After each call to sqlite3_set_auxdata(C,N,P,X) where X is not NULL, SQLite will invoke the destructor function X with parameter P exactly once, when the metadata is discarded. SQLite is free to discard the metadata at any time, including:</source>
          <target state="translated">Интерфейс sqlite3_set_auxdata(C,N,P,X)сохраняет P в качестве метаданных для N-ого аргумента функции,определяемой приложением.Последующие вызовы sqlite3_get_auxdata(C,N)возвращают P из последнего вызова sqlite3_set_auxdata(C,N,P,X),если метаданные все еще действительны,или NULL,если метаданные были отброшены.После каждого вызова sqlite3_set_auxdata(C,N,P,X),где X не NULL,SQLite будет вызывать функцию деструктора X с параметром P ровно один раз,когда метаданные будут отброшены.SQLite свободен отбрасывать метаданные в любое время,в том числе:</target>
        </trans-unit>
        <trans-unit id="ce7e4094de25df6c5d0672255fe4f34354822777" translate="yes" xml:space="preserve">
          <source>The sqlite3_set_last_insert_rowid(D, R) method allows the application to set the value returned by calling sqlite3_last_insert_rowid(D) to R without inserting a row into the database.</source>
          <target state="translated">Метод sqlite3_set_last_insert_rowid(D,R)позволяет программе устанавливать значение,возвращаемое вызовом sqlite3_last_insert_rowid(D)в R без вставки строки в БД.</target>
        </trans-unit>
        <trans-unit id="e1bb92256471e00d9337dbe91acedaceec62010e" translate="yes" xml:space="preserve">
          <source>The sqlite3_sleep() function causes the current thread to suspend execution for at least a number of milliseconds specified in its parameter.</source>
          <target state="translated">Функция sqlite3_sleep()заставляет текущий поток приостановить выполнение не менее чем на несколько миллисекунд,указанных в его параметре.</target>
        </trans-unit>
        <trans-unit id="932dc970d1649bf3cbe1cd6e521c5a774af59735" translate="yes" xml:space="preserve">
          <source>The sqlite3_snapshot object records state information about an historical version of the database file so that it is possible to later open a new read transaction that sees that historical version of the database rather than the most recent version.</source>
          <target state="translated">Записи объекта sqlite3_snapshot содержат информацию об исторической версии файла базы данных,так что позже можно открыть новую прочитанную транзакцию,которая видит эту историческую версию базы данных,а не самую последнюю версию.</target>
        </trans-unit>
        <trans-unit id="242ec5992913a3f34748a4cb2f4099b50b723004" translate="yes" xml:space="preserve">
          <source>The sqlite3_snapshot_cmp(P1, P2) interface is used to compare the ages of two valid snapshot handles.</source>
          <target state="translated">Интерфейс sqlite3_snapshot_cmp(P1,P2)используется для сравнения возраста двух корректных обработчиков снимков.</target>
        </trans-unit>
        <trans-unit id="01e7a2ddf509d560437f8041b7f083cd66113cd5" translate="yes" xml:space="preserve">
          <source>The sqlite3_snprintf() routine is similar to &quot;snprintf()&quot; from the standard C library. The result is written into the buffer supplied as the second parameter whose size is given by the first parameter. Note that the order of the first two parameters is reversed from snprintf(). This is an historical accident that cannot be fixed without breaking backwards compatibility. Note also that sqlite3_snprintf() returns a pointer to its buffer instead of the number of characters actually written into the buffer. We admit that the number of characters written would be a more useful return value but we cannot change the implementation of sqlite3_snprintf() now without breaking compatibility.</source>
          <target state="translated">Рутина sqlite3_snprintf()аналогична &quot;snprintf()&quot; из стандартной библиотеки Си.Результат записывается в буфер,поставляемый в качестве второго параметра,размер которого задается первым параметром.Обратите внимание,что порядок следования первых двух параметров обратный от snprintf().Это исторический случай,который не может быть исправлен без нарушения обратной совместимости.Обратите также внимание,что sqlite3_snprintf()возвращает указатель на свой буфер вместо количества символов,фактически записанных в буфер.Мы признаем,что количество записанных символов было бы более полезным возвращаемым значением,но теперь мы не можем изменить реализацию sqlite3_snprintf()без нарушения совместимости.</target>
        </trans-unit>
        <trans-unit id="a1e7c63d0192b11455ed615eabf6f8b339d7c44c" translate="yes" xml:space="preserve">
          <source>The sqlite3_soft_heap_limit64() interface sets and/or queries the soft limit on the amount of heap memory that may be allocated by SQLite. SQLite strives to keep heap memory utilization below the soft heap limit by reducing the number of pages held in the page cache as heap memory usages approaches the limit. The soft heap limit is &quot;soft&quot; because even though SQLite strives to stay below the limit, it will exceed the limit rather than generate an &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOMEM&lt;/a&gt; error. In other words, the soft heap limit is advisory only.</source>
          <target state="translated">Интерфейс sqlite3_soft_heap_limit64 () устанавливает и / или запрашивает мягкий предел объема памяти кучи, который может быть выделен SQLite. SQLite стремится поддерживать использование памяти кучи ниже предела мягкой кучи, уменьшая количество страниц, хранящихся в кеше страниц, по мере приближения использования памяти кучи к пределу. Предел мягкой кучи является &amp;laquo;мягким&amp;raquo;, потому что даже если SQLite стремится оставаться ниже лимита, он превысит лимит, а не сгенерирует ошибку &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOMEM&lt;/a&gt; . Другими словами, ограничение мягкой кучи носит рекомендательный характер.</target>
        </trans-unit>
        <trans-unit id="d5aefe7f58cf6098f950ef6aaad46d0524e32f68" translate="yes" xml:space="preserve">
          <source>The sqlite3_soft_heap_limit64() interface sets and/or queries the soft limit on the amount of heap memory that may be allocated by SQLite. SQLite strives to keep heap memory utilization below the soft heap limit by reducing the number of pages held in the page cache as heap memory usages approaches the limit. The soft heap limit is &quot;soft&quot; because even though SQLite strives to stay below the limit, it will exceed the limit rather than generate an &lt;a href=&quot;../rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt; error. In other words, the soft heap limit is advisory only.</source>
          <target state="translated">Интерфейс sqlite3_soft_heap_limit64 () устанавливает и / или запрашивает мягкий предел объема памяти кучи, который может быть выделен SQLite. SQLite стремится поддерживать использование памяти кучи ниже предела мягкой кучи, уменьшая количество страниц, хранящихся в кеше страниц, по мере приближения использования памяти кучи к пределу. Предел мягкой кучи является &amp;laquo;мягким&amp;raquo;, потому что даже если SQLite стремится оставаться ниже лимита, он превысит лимит, а не сгенерирует ошибку &lt;a href=&quot;../rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt; . Другими словами, ограничение мягкой кучи носит рекомендательный характер.</target>
        </trans-unit>
        <trans-unit id="b94ad72c9e1e61f387a8b9571668f6ee1d93f6d1" translate="yes" xml:space="preserve">
          <source>The sqlite3_sql(P) interface returns a pointer to a copy of the UTF-8 SQL text used to create &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; P if P was created by &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v3()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16_v2()&lt;/a&gt;, or &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16_v3()&lt;/a&gt;. The sqlite3_expanded_sql(P) interface returns a pointer to a UTF-8 string containing the SQL text of prepared statement P with &lt;a href=&quot;lang_expr#varparam&quot;&gt;bound parameters&lt;/a&gt; expanded. The sqlite3_normalized_sql(P) interface returns a pointer to a UTF-8 string containing the normalized SQL text of prepared statement P. The semantics used to normalize a SQL statement are unspecified and subject to change. At a minimum, literal values will be replaced with suitable placeholders.</source>
          <target state="translated">Интерфейс sqlite3_sql (P) возвращает указатель на копию текста SQL UTF-8, используемого для создания &lt;a href=&quot;#sqlite3_stmt&quot;&gt;подготовленного оператора&lt;/a&gt; P, если P был создан с помощью &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v3 ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16_v2 ()&lt;/a&gt; или &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16_v3 ()&lt;/a&gt; . Интерфейс sqlite3_expanded_sql (P) возвращает указатель на строку UTF-8, содержащую текст SQL подготовленного оператора P с расширенными &lt;a href=&quot;lang_expr#varparam&quot;&gt;связанными параметрами&lt;/a&gt; . Интерфейс sqlite3_normalized_sql (P) возвращает указатель на строку UTF-8, содержащую нормализованный текст SQL подготовленного оператора P. Семантика, используемая для нормализации оператора SQL, не указана и может быть изменена. Как минимум, буквальные значения будут заменены подходящими заполнителями.</target>
        </trans-unit>
        <trans-unit id="45ba0cce80e217739aee37fc8f257b9f4497c286" translate="yes" xml:space="preserve">
          <source>The sqlite3_sql(P) interface returns a pointer to a copy of the UTF-8 SQL text used to create &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; P if P was created by &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt;, &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v3()&lt;/a&gt;, &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16_v2()&lt;/a&gt;, or &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16_v3()&lt;/a&gt;. The sqlite3_expanded_sql(P) interface returns a pointer to a UTF-8 string containing the SQL text of prepared statement P with &lt;a href=&quot;../lang_expr#varparam&quot;&gt;bound parameters&lt;/a&gt; expanded. The sqlite3_normalized_sql(P) interface returns a pointer to a UTF-8 string containing the normalized SQL text of prepared statement P. The semantics used to normalize a SQL statement are unspecified and subject to change. At a minimum, literal values will be replaced with suitable placeholders.</source>
          <target state="translated">Интерфейс sqlite3_sql (P) возвращает указатель на копию текста SQL UTF-8, используемого для создания &lt;a href=&quot;stmt&quot;&gt;подготовленного оператора&lt;/a&gt; P, если P был создан с помощью &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; , &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v3 ()&lt;/a&gt; , &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16_v2 ()&lt;/a&gt; или &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16_v3 ()&lt;/a&gt; . Интерфейс sqlite3_expanded_sql (P) возвращает указатель на строку UTF-8, содержащую текст SQL подготовленного оператора P с расширенными &lt;a href=&quot;../lang_expr#varparam&quot;&gt;связанными параметрами&lt;/a&gt; . Интерфейс sqlite3_normalized_sql (P) возвращает указатель на строку UTF-8, содержащую нормализованный текст SQL подготовленного оператора P. Семантика, используемая для нормализации оператора SQL, не указана и может быть изменена. Как минимум, буквальные значения будут заменены подходящими заполнителями.</target>
        </trans-unit>
        <trans-unit id="e775091a2d75ef8eec628ca58240bb3a4c44f41a" translate="yes" xml:space="preserve">
          <source>The sqlite3_status() and sqlite3_status64() routines return SQLITE_OK on success and a non-zero &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; on failure.</source>
          <target state="translated">Подпрограммы sqlite3_status () и sqlite3_status64 () возвращают SQLITE_OK в случае успеха и ненулевой &lt;a href=&quot;../rescode&quot;&gt;код ошибки&lt;/a&gt; в случае ошибки.</target>
        </trans-unit>
        <trans-unit id="08017cba5dea56fb38bd261f36812b68e5da595b" translate="yes" xml:space="preserve">
          <source>The sqlite3_status() and sqlite3_status64() routines return SQLITE_OK on success and a non-zero &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; on failure.</source>
          <target state="translated">Подпрограммы sqlite3_status () и sqlite3_status64 () возвращают SQLITE_OK в случае успеха и ненулевой &lt;a href=&quot;rescode&quot;&gt;код ошибки&lt;/a&gt; в случае ошибки.</target>
        </trans-unit>
        <trans-unit id="8844a5c0b1eb32242054752c1e25f36f36feae1a" translate="yes" xml:space="preserve">
          <source>The sqlite3_step() interface returns SQLITE_BUSY if it is unable to commit a change because of a lock</source>
          <target state="translated">Интерфейс sqlite3_step()возвращает SQLITE_BUSY,если он не может зафиксировать изменение из-за блокировки</target>
        </trans-unit>
        <trans-unit id="aadfbac7c6cbfe9d27468ec7c9a622af76c3660e" translate="yes" xml:space="preserve">
          <source>The sqlite3_step() routine return SQLITE_ROW if it is returning a single row of the result set, or SQLITE_DONE if execution has completed, either normally or due to an error. It might also return SQLITE_BUSY if it is unable to open the database file. If the return value is SQLITE_ROW, then the following routines can be used to extract information about that row of the result set:</source>
          <target state="translated">Рутина sqlite3_step()возвращает SQLITE_ROW,если она возвращает одну строку результирующего множества,или SQLITE_DONE,если выполнение завершилось,либо нормально,либо из-за ошибки.Она также может вернуть SQLITE_BUSY,если не может открыть файл базы данных.Если возвращаемое значение-SQLITE_ROW,то для извлечения информации об этой строке результирующего множества можно воспользоваться следующими подпрограммами:</target>
        </trans-unit>
        <trans-unit id="68ecf4c95ec171ac99c79d0f7b7218a0a2a7996e" translate="yes" xml:space="preserve">
          <source>The sqlite3_stmt_busy(S) interface returns true (non-zero) if the &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; S has been stepped at least once using &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step(S)&lt;/a&gt; but has neither run to completion (returned &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_DONE&lt;/a&gt; from &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step(S)&lt;/a&gt;) nor been reset using &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset(S)&lt;/a&gt;. The sqlite3_stmt_busy(S) interface returns false if S is a NULL pointer. If S is not a NULL pointer and is not a pointer to a valid &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; object, then the behavior is undefined and probably undesirable.</source>
          <target state="translated">Интерфейс sqlite3_stmt_busy (S) возвращает истину (ненулевое значение), если &lt;a href=&quot;#sqlite3_stmt&quot;&gt;подготовленный оператор&lt;/a&gt; S был выполнен по крайней мере один раз с использованием &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step (S),&lt;/a&gt; но не был выполнен до завершения (возвращен &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_DONE&lt;/a&gt; из &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step (S)&lt;/a&gt; ) и не был сброшен с помощью &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset ( S)&lt;/a&gt; . Интерфейс sqlite3_stmt_busy (S) возвращает false, если S является указателем NULL. Если S не является указателем NULL и не является указателем на действительный &lt;a href=&quot;#sqlite3_stmt&quot;&gt;подготовленный&lt;/a&gt; объект оператора , то поведение не определено и, вероятно, нежелательно.</target>
        </trans-unit>
        <trans-unit id="30e9a2351b8f1f389c8c1f5ed3bb5643292d6719" translate="yes" xml:space="preserve">
          <source>The sqlite3_stmt_busy(S) interface returns true (non-zero) if the &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; S has been stepped at least once using &lt;a href=&quot;step&quot;&gt;sqlite3_step(S)&lt;/a&gt; but has neither run to completion (returned &lt;a href=&quot;../rescode#done&quot;&gt;SQLITE_DONE&lt;/a&gt; from &lt;a href=&quot;step&quot;&gt;sqlite3_step(S)&lt;/a&gt;) nor been reset using &lt;a href=&quot;reset&quot;&gt;sqlite3_reset(S)&lt;/a&gt;. The sqlite3_stmt_busy(S) interface returns false if S is a NULL pointer. If S is not a NULL pointer and is not a pointer to a valid &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; object, then the behavior is undefined and probably undesirable.</source>
          <target state="translated">Интерфейс sqlite3_stmt_busy (S) возвращает истину (ненулевое значение), если &lt;a href=&quot;stmt&quot;&gt;подготовленный оператор&lt;/a&gt; S был выполнен по крайней мере один раз с использованием &lt;a href=&quot;step&quot;&gt;sqlite3_step (S),&lt;/a&gt; но не был выполнен до завершения (возвращен &lt;a href=&quot;../rescode#done&quot;&gt;SQLITE_DONE&lt;/a&gt; из &lt;a href=&quot;step&quot;&gt;sqlite3_step (S)&lt;/a&gt; ) и не был сброшен с помощью &lt;a href=&quot;reset&quot;&gt;sqlite3_reset ( S)&lt;/a&gt; . Интерфейс sqlite3_stmt_busy (S) возвращает false, если S является указателем NULL. Если S не является указателем NULL и не является указателем на действительный &lt;a href=&quot;stmt&quot;&gt;подготовленный&lt;/a&gt; объект оператора , то поведение не определено и, вероятно, нежелательно.</target>
        </trans-unit>
        <trans-unit id="90793b88a180a777be3c4f2d53caba9bba6af112" translate="yes" xml:space="preserve">
          <source>The sqlite3_stmt_isexplain(S) interface returns 1 if the prepared statement S is an EXPLAIN statement, or 2 if the statement S is an EXPLAIN QUERY PLAN. The sqlite3_stmt_isexplain(S) interface returns 0 if S is an ordinary statement or a NULL pointer.</source>
          <target state="translated">Интерфейс sqlite3_stmt_isexplain(S)возвращает 1,если подготовленный оператор S является оператором EXPLAIN,или 2,если оператор S является оператором EXPLAIN QUERY PLAN.Интерфейс sqlite3_stmt_isexplain(S)возвращает 0,если оператор S является обычным оператором или указателем NULL.</target>
        </trans-unit>
        <trans-unit id="959c0941832b79e09f96d36c140b66399c0579af" translate="yes" xml:space="preserve">
          <source>The sqlite3_stmt_readonly(X) interface returns true (non-zero) if and only if the &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; X makes no direct changes to the content of the database file.</source>
          <target state="translated">Интерфейс sqlite3_stmt_readonly (X) возвращает истину (ненулевое значение) тогда и только тогда, когда &lt;a href=&quot;#sqlite3_stmt&quot;&gt;подготовленный оператор&lt;/a&gt; X не вносит прямых изменений в содержимое файла базы данных.</target>
        </trans-unit>
        <trans-unit id="ac5964bf97c9886f6e336072767ae1979506a3cb" translate="yes" xml:space="preserve">
          <source>The sqlite3_stmt_readonly(X) interface returns true (non-zero) if and only if the &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; X makes no direct changes to the content of the database file.</source>
          <target state="translated">Интерфейс sqlite3_stmt_readonly (X) возвращает истину (ненулевое значение) тогда и только тогда, когда &lt;a href=&quot;stmt&quot;&gt;подготовленный оператор&lt;/a&gt; X не вносит прямых изменений в содержимое файла базы данных.</target>
        </trans-unit>
        <trans-unit id="46d5fb0793437180a07e66953d44f2fda8b50c88" translate="yes" xml:space="preserve">
          <source>The sqlite3_str object is created using &lt;a href=&quot;#sqlite3_str_new&quot;&gt;sqlite3_str_new()&lt;/a&gt;.</source>
          <target state="translated">Объект sqlite3_str создается с помощью &lt;a href=&quot;#sqlite3_str_new&quot;&gt;sqlite3_str_new ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="58bd138876e3ab72759402d62d6773f8d1b76c11" translate="yes" xml:space="preserve">
          <source>The sqlite3_str object is created using &lt;a href=&quot;str_new&quot;&gt;sqlite3_str_new()&lt;/a&gt;.</source>
          <target state="translated">Объект sqlite3_str создается с помощью &lt;a href=&quot;str_new&quot;&gt;sqlite3_str_new ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="709d2526ae98679c1dec5db36348e5bd59a7a2cf" translate="yes" xml:space="preserve">
          <source>The sqlite3_str object is destroyed and the string it created is returned using the &lt;a href=&quot;#sqlite3_str_finish&quot;&gt;sqlite3_str_finish()&lt;/a&gt; interface.</source>
          <target state="translated">Объект sqlite3_str уничтожается, а созданная им строка возвращается с использованием интерфейса &lt;a href=&quot;#sqlite3_str_finish&quot;&gt;sqlite3_str_finish ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="17671bb4cfc45e29421b502c0583cd6458abaa8b" translate="yes" xml:space="preserve">
          <source>The sqlite3_str object is destroyed and the string it created is returned using the &lt;a href=&quot;str_finish&quot;&gt;sqlite3_str_finish()&lt;/a&gt; interface.</source>
          <target state="translated">Объект sqlite3_str уничтожается, а созданная им строка возвращается с использованием интерфейса &lt;a href=&quot;str_finish&quot;&gt;sqlite3_str_finish ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9c1806bb938001e1be73835ffc5a99f71985fc2b" translate="yes" xml:space="preserve">
          <source>The sqlite3_table_column_metadata(X,D,T,C,....) routine returns information about column C of table T in database D on &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; X. The sqlite3_table_column_metadata() interface returns SQLITE_OK and fills in the non-NULL pointers in the final five arguments with appropriate values if the specified column exists. The sqlite3_table_column_metadata() interface returns SQLITE_ERROR and if the specified column does not exist. If the column-name parameter to sqlite3_table_column_metadata() is a NULL pointer, then this routine simply checks for the existence of the table and returns SQLITE_OK if the table exists and SQLITE_ERROR if it does not. If the table name parameter T in a call to sqlite3_table_column_metadata(X,D,T,C,...) is NULL then the result is undefined behavior.</source>
          <target state="translated">Подпрограмма sqlite3_table_column_metadata (X, D, T, C, ....) возвращает информацию о столбце C таблицы T в базе данных D при &lt;a href=&quot;#sqlite3&quot;&gt;подключении к базе данных&lt;/a&gt; X. Интерфейс sqlite3_table_column_metadata () возвращает SQLITE_OK и заполняет указатели, отличные от NULL в последние пять аргументов с соответствующими значениями, если указанный столбец существует. Интерфейс sqlite3_table_column_metadata () возвращает SQLITE_ERROR и, если указанный столбец не существует. Если параметр имени столбца для sqlite3_table_column_metadata () является указателем NULL, то эта процедура просто проверяет наличие таблицы и возвращает SQLITE_OK, если таблица существует, и SQLITE_ERROR, если нет. Если параметр имени таблицы T в вызове sqlite3_table_column_metadata (X, D, T, C, ...) равен NULL, то результатом будет неопределенное поведение.</target>
        </trans-unit>
        <trans-unit id="1a9220a600a9fb3a4c23d26f17dc0f839445989b" translate="yes" xml:space="preserve">
          <source>The sqlite3_table_column_metadata(X,D,T,C,....) routine returns information about column C of table T in database D on &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; X. The sqlite3_table_column_metadata() interface returns SQLITE_OK and fills in the non-NULL pointers in the final five arguments with appropriate values if the specified column exists. The sqlite3_table_column_metadata() interface returns SQLITE_ERROR if the specified column does not exist. If the column-name parameter to sqlite3_table_column_metadata() is a NULL pointer, then this routine simply checks for the existence of the table and returns SQLITE_OK if the table exists and SQLITE_ERROR if it does not. If the table name parameter T in a call to sqlite3_table_column_metadata(X,D,T,C,...) is NULL then the result is undefined behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14811f3f6309b7a46fb7b07e8c86e4e522dd9f2d" translate="yes" xml:space="preserve">
          <source>The sqlite3_table_column_metadata(X,D,T,C,....) routine returns information about column C of table T in database D on &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; X. The sqlite3_table_column_metadata() interface returns SQLITE_OK and fills in the non-NULL pointers in the final five arguments with appropriate values if the specified column exists. The sqlite3_table_column_metadata() interface returns SQLITE_ERROR and if the specified column does not exist. If the column-name parameter to sqlite3_table_column_metadata() is a NULL pointer, then this routine simply checks for the existence of the table and returns SQLITE_OK if the table exists and SQLITE_ERROR if it does not. If the table name parameter T in a call to sqlite3_table_column_metadata(X,D,T,C,...) is NULL then the result is undefined behavior.</source>
          <target state="translated">Подпрограмма sqlite3_table_column_metadata (X, D, T, C, ....) возвращает информацию о столбце C таблицы T в базе данных D при &lt;a href=&quot;sqlite3&quot;&gt;подключении к базе данных&lt;/a&gt; X. Интерфейс sqlite3_table_column_metadata () возвращает SQLITE_OK и заполняет указатели, отличные от NULL в последние пять аргументов с соответствующими значениями, если указанный столбец существует. Интерфейс sqlite3_table_column_metadata () возвращает SQLITE_ERROR и, если указанный столбец не существует. Если параметр имени столбца для sqlite3_table_column_metadata () является указателем NULL, то эта процедура просто проверяет наличие таблицы и возвращает SQLITE_OK, если таблица существует, и SQLITE_ERROR, если нет. Если параметр имени таблицы T в вызове sqlite3_table_column_metadata (X, D, T, C, ...) равен NULL, то результатом будет неопределенное поведение.</target>
        </trans-unit>
        <trans-unit id="1c11863e106d03a5d69e9f5e41b5782d50d0ba8d" translate="yes" xml:space="preserve">
          <source>The sqlite3_table_column_metadata(X,D,T,C,....) routine returns information about column C of table T in database D on &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; X. The sqlite3_table_column_metadata() interface returns SQLITE_OK and fills in the non-NULL pointers in the final five arguments with appropriate values if the specified column exists. The sqlite3_table_column_metadata() interface returns SQLITE_ERROR if the specified column does not exist. If the column-name parameter to sqlite3_table_column_metadata() is a NULL pointer, then this routine simply checks for the existence of the table and returns SQLITE_OK if the table exists and SQLITE_ERROR if it does not. If the table name parameter T in a call to sqlite3_table_column_metadata(X,D,T,C,...) is NULL then the result is undefined behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6f71c56bc991c72ab07825bab1be2b2926a3b41" translate="yes" xml:space="preserve">
          <source>The sqlite3_test_control() interface is used to read out internal state of SQLite and to inject faults into SQLite for testing purposes. The first parameter is an operation code that determines the number, meaning, and operation of all subsequent parameters.</source>
          <target state="translated">Интерфейс sqlite3_test_control()используется для считывания внутреннего состояния SQLite и внесения ошибок в SQLite для тестирования.Первый параметр-это код операции,определяющий количество,значение и работу всех последующих параметров.</target>
        </trans-unit>
        <trans-unit id="5082c0760e0921243970779b3672c52191342376" translate="yes" xml:space="preserve">
          <source>The sqlite3_threadsafe() function returns zero if and only if SQLite was compiled with mutexing code omitted due to the &lt;a href=&quot;../compile#threadsafe&quot;&gt;SQLITE_THREADSAFE&lt;/a&gt; compile-time option being set to 0.</source>
          <target state="translated">Функция sqlite3_threadsafe () возвращает ноль тогда и только тогда, когда SQLite был скомпилирован с опущенным кодом мьютекса из-за того, что для параметра &lt;a href=&quot;../compile#threadsafe&quot;&gt;времени&lt;/a&gt; компиляции SQLITE_THREADSAFE установлено значение 0.</target>
        </trans-unit>
        <trans-unit id="a21f6ed50c99e2696e83c890474c76bf238b4d0d" translate="yes" xml:space="preserve">
          <source>The sqlite3_threadsafe() function returns zero if and only if SQLite was compiled with mutexing code omitted due to the &lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE&lt;/a&gt; compile-time option being set to 0.</source>
          <target state="translated">Функция sqlite3_threadsafe () возвращает ноль тогда и только тогда, когда SQLite был скомпилирован с опущенным кодом мьютекса из-за того, что для параметра &lt;a href=&quot;compile#threadsafe&quot;&gt;времени&lt;/a&gt; компиляции SQLITE_THREADSAFE установлено значение 0.</target>
        </trans-unit>
        <trans-unit id="bda43267162a3774849f8ead3ae62d9dfab76a35" translate="yes" xml:space="preserve">
          <source>The sqlite3_trace() callbacks occur before each statement is executed, not when the statement is compiled.</source>
          <target state="translated">Обратные вызовы sqlite3_trace()происходят перед выполнением каждого оператора,а не при компиляции оператора.</target>
        </trans-unit>
        <trans-unit id="1ffc76f2d02a8dff2313298df0260161ca209b9b" translate="yes" xml:space="preserve">
          <source>The sqlite3_trace_v2() interface is intended to replace the legacy interfaces &lt;a href=&quot;#sqlite3_profile&quot;&gt;sqlite3_trace()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_profile&quot;&gt;sqlite3_profile()&lt;/a&gt;, both of which are deprecated.</source>
          <target state="translated">Интерфейс sqlite3_trace_v2 () предназначен для замены устаревших интерфейсов &lt;a href=&quot;#sqlite3_profile&quot;&gt;sqlite3_trace ()&lt;/a&gt; и &lt;a href=&quot;#sqlite3_profile&quot;&gt;sqlite3_profile ()&lt;/a&gt; , оба из которых устарели.</target>
        </trans-unit>
        <trans-unit id="377ad2a0a4bd528d9de5514af64376270faee9cf" translate="yes" xml:space="preserve">
          <source>The sqlite3_trace_v2() interface is intended to replace the legacy interfaces &lt;a href=&quot;profile&quot;&gt;sqlite3_trace()&lt;/a&gt; and &lt;a href=&quot;profile&quot;&gt;sqlite3_profile()&lt;/a&gt;, both of which are deprecated.</source>
          <target state="translated">Интерфейс sqlite3_trace_v2 () предназначен для замены устаревших интерфейсов &lt;a href=&quot;profile&quot;&gt;sqlite3_trace ()&lt;/a&gt; и &lt;a href=&quot;profile&quot;&gt;sqlite3_profile ()&lt;/a&gt; , оба из которых устарели.</target>
        </trans-unit>
        <trans-unit id="423d6e23fa8d1a2ce23d8999f3685bde80941a45" translate="yes" xml:space="preserve">
          <source>The sqlite3_trace_v2(D,M,X,P) interface registers a trace callback function X against &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; D, using property mask M and context pointer P. If the X callback is NULL or if the M mask is zero, then tracing is disabled. The M argument should be the bitwise OR-ed combination of zero or more &lt;a href=&quot;#SQLITE_TRACE&quot;&gt;SQLITE_TRACE&lt;/a&gt; constants.</source>
          <target state="translated">Интерфейс sqlite3_trace_v2 (D, M, X, P) регистрирует функцию обратного вызова трассировки X для &lt;a href=&quot;#sqlite3&quot;&gt;соединения&lt;/a&gt; с базой данных D, используя маску свойств M и указатель контекста P. Если обратный вызов X равен NULL или если маска M равна нулю, трассировка отключена. . Аргумент M должен быть комбинацией нуля или более констант &lt;a href=&quot;#SQLITE_TRACE&quot;&gt;SQLITE_TRACE, созданной методом&lt;/a&gt; побитового ИЛИ .</target>
        </trans-unit>
        <trans-unit id="c43af05001b13bd414732905f7825bbbb97dce0a" translate="yes" xml:space="preserve">
          <source>The sqlite3_trace_v2(D,M,X,P) interface registers a trace callback function X against &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; D, using property mask M and context pointer P. If the X callback is NULL or if the M mask is zero, then tracing is disabled. The M argument should be the bitwise OR-ed combination of zero or more &lt;a href=&quot;c_trace&quot;&gt;SQLITE_TRACE&lt;/a&gt; constants.</source>
          <target state="translated">Интерфейс sqlite3_trace_v2 (D, M, X, P) регистрирует функцию обратного вызова трассировки X для &lt;a href=&quot;sqlite3&quot;&gt;соединения&lt;/a&gt; с базой данных D, используя маску свойств M и указатель контекста P. Если обратный вызов X равен NULL или если маска M равна нулю, трассировка отключена. . Аргумент M должен быть комбинацией нуля или более констант &lt;a href=&quot;c_trace&quot;&gt;SQLITE_TRACE, созданной методом&lt;/a&gt; побитового ИЛИ .</target>
        </trans-unit>
        <trans-unit id="6feba83e9a10c6c07d482619d7953b682da3b975" translate="yes" xml:space="preserve">
          <source>The sqlite3_txn_state(D,S) interface returns the current &lt;a href=&quot;#SQLITE_TXN_NONE&quot;&gt;transaction state&lt;/a&gt; of schema S in database connection D. If S is NULL, then the highest transaction state of any schema on database connection D is returned. Transaction states are (in order of lowest to highest):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f2eef336e211ebe9225c5190790ccb47f8b29b5" translate="yes" xml:space="preserve">
          <source>The sqlite3_txn_state(D,S) interface returns the current &lt;a href=&quot;c_txn_none&quot;&gt;transaction state&lt;/a&gt; of schema S in database connection D. If S is NULL, then the highest transaction state of any schema on database connection D is returned. Transaction states are (in order of lowest to highest):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99807c4e04d2f72ca0bf7cd79e0b0ccb8d1cdec6" translate="yes" xml:space="preserve">
          <source>The sqlite3_update_hook() interface registers a callback function with the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; identified by the first argument to be invoked whenever a row is updated, inserted or deleted in a &lt;a href=&quot;rowidtable&quot;&gt;rowid table&lt;/a&gt;. Any callback set by a previous call to this function for the same database connection is overridden.</source>
          <target state="translated">Интерфейс sqlite3_update_hook () регистрирует функцию обратного вызова с &lt;a href=&quot;#sqlite3&quot;&gt;подключением&lt;/a&gt; к базе данных, идентифицированным первым аргументом, которая будет вызываться всякий раз, когда строка обновляется, вставляется или удаляется в &lt;a href=&quot;rowidtable&quot;&gt;таблице rowid&lt;/a&gt; . Любой обратный вызов, установленный предыдущим вызовом этой функции для того же подключения к базе данных, отменяется.</target>
        </trans-unit>
        <trans-unit id="f13c4b8c3d5b462597549f85fa26ca8898f02c2a" translate="yes" xml:space="preserve">
          <source>The sqlite3_update_hook() interface registers a callback function with the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; identified by the first argument to be invoked whenever a row is updated, inserted or deleted in a &lt;a href=&quot;../rowidtable&quot;&gt;rowid table&lt;/a&gt;. Any callback set by a previous call to this function for the same database connection is overridden.</source>
          <target state="translated">Интерфейс sqlite3_update_hook () регистрирует функцию обратного вызова с &lt;a href=&quot;sqlite3&quot;&gt;подключением&lt;/a&gt; к базе данных, идентифицированным первым аргументом, которая будет вызываться всякий раз, когда строка обновляется, вставляется или удаляется в &lt;a href=&quot;../rowidtable&quot;&gt;таблице rowid&lt;/a&gt; . Любой обратный вызов, установленный предыдущим вызовом этой функции для того же подключения к базе данных, отменяется.</target>
        </trans-unit>
        <trans-unit id="299c5d8dbf8312233913ebdfb7abe735c08c4d12" translate="yes" xml:space="preserve">
          <source>The sqlite3_update_hook(D,C,P) function returns the P argument from the previous call on the same &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; D, or NULL for the first call on D.</source>
          <target state="translated">Функция sqlite3_update_hook (D, C, P) возвращает аргумент P из предыдущего вызова в том же &lt;a href=&quot;#sqlite3&quot;&gt;соединении с базой данных&lt;/a&gt; D или NULL для первого вызова D.</target>
        </trans-unit>
        <trans-unit id="b7813b4170b9b916299f8d86a0cb2ffbf096aaa5" translate="yes" xml:space="preserve">
          <source>The sqlite3_update_hook(D,C,P) function returns the P argument from the previous call on the same &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; D, or NULL for the first call on D.</source>
          <target state="translated">Функция sqlite3_update_hook (D, C, P) возвращает аргумент P из предыдущего вызова в том же &lt;a href=&quot;sqlite3&quot;&gt;соединении с базой данных&lt;/a&gt; D или NULL для первого вызова D.</target>
        </trans-unit>
        <trans-unit id="9e5c2049439d88f4f1e900d8863f9c93f3ca0ab3" translate="yes" xml:space="preserve">
          <source>The sqlite3_uri_boolean(F,P,B) routine assumes that P is a boolean parameter and returns true (1) or false (0) according to the value of P. The sqlite3_uri_boolean(F,P,B) routine returns true (1) if the value of query parameter P is one of &quot;yes&quot;, &quot;true&quot;, or &quot;on&quot; in any case or if the value begins with a non-zero number. The sqlite3_uri_boolean(F,P,B) routines returns false (0) if the value of query parameter P is one of &quot;no&quot;, &quot;false&quot;, or &quot;off&quot; in any case or if the value begins with a numeric zero. If P is not a query parameter on F or if the value of P does not match any of the above, then sqlite3_uri_boolean(F,P,B) returns (B!=0).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07d5885fa75b35071ed61bef7a0d72dc8a43c3b7" translate="yes" xml:space="preserve">
          <source>The sqlite3_uri_boolean(F,P,B) routine assumes that P is a boolean parameter and returns true (1) or false (0) according to the value of P. The sqlite3_uri_boolean(F,P,B) routine returns true (1) if the value of query parameter P is one of &quot;yes&quot;, &quot;true&quot;, or &quot;on&quot; in any case or if the value begins with a non-zero number. The sqlite3_uri_boolean(F,P,B) routines returns false (0) if the value of query parameter P is one of &quot;no&quot;, &quot;false&quot;, or &quot;off&quot; in any case or if the value begins with a numeric zero. If P is not a query parameter on F or if the value of P is does not match any of the above, then sqlite3_uri_boolean(F,P,B) returns (B!=0).</source>
          <target state="translated">Рутина sqlite3_uri_boolean(F,P,B)предполагает,что P является булевым параметром,и возвращает true (1)или false (0)в соответствии со значением P.Рутина sqlite3_uri_boolean(F,P,B)возвращает true (1),если значение параметра запроса P в любом случае одно из &quot;yes&quot;,&quot;true&quot; или &quot;on&quot;,или если значение начинается с ненулевого числа.Рутина sqlite3_uri_boolean(F,P,B)возвращает false (0),если значение параметра запроса P в любом случае одно из &quot;no&quot;,&quot;false&quot; или &quot;off&quot;,или если значение начинается с числового нуля.Если P не является параметром запроса на F или если значение P не совпадает ни с одним из вышеперечисленных,то sqlite3_uri_boolean(F,P,B)возвращает (B!=0).</target>
        </trans-unit>
        <trans-unit id="d8465d3a607ae26cbee19418630adba78c7f16b3" translate="yes" xml:space="preserve">
          <source>The sqlite3_uri_int64(F,P,D) routine converts the value of P into a 64-bit signed integer and returns that integer, or D if P does not exist. If the value of P is something other than an integer, then zero is returned.</source>
          <target state="translated">Рутина sqlite3_uri_int64(F,P,D)преобразует значение P в 64-битное целое число со знаком и возвращает это число,или D,если P не существует.Если значение P не является целым числом,то возвращается ноль.</target>
        </trans-unit>
        <trans-unit id="00f6b921b58342af7827ee6740ce3bd7da1204bf" translate="yes" xml:space="preserve">
          <source>The sqlite3_uri_key(F,N) returns a pointer to the name (not the value) of the N-th query parameter for filename F, or a NULL pointer if N is less than zero or greater than the number of query parameters minus 1. The N value is zero-based so N should be 0 to obtain the name of the first query parameter, 1 for the second parameter, and so forth.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4924027328fd6dc74b1360ec20381b3f6724812a" translate="yes" xml:space="preserve">
          <source>The sqlite3_user_data() interface returns a copy of the pointer that was the pUserData parameter (the 5th parameter) of the &lt;a href=&quot;#sqlite3_create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_create_function&quot;&gt;sqlite3_create_function16()&lt;/a&gt; routines that originally registered the application defined function.</source>
          <target state="translated">Интерфейс sqlite3_user_data () возвращает копию указателя, который был параметром pUserData (5-й параметр &lt;a href=&quot;#sqlite3_create_function&quot;&gt;)&lt;/a&gt; подпрограмм &lt;a href=&quot;#sqlite3_create_function&quot;&gt;sqlite3_create_function ()&lt;/a&gt; и sqlite3_create_function16 () , которые первоначально регистрировали функцию, определенную приложением.</target>
        </trans-unit>
        <trans-unit id="bf548778e52386bbdaeeb7ac3a4e8320cb6164f6" translate="yes" xml:space="preserve">
          <source>The sqlite3_user_data() interface returns a copy of the pointer that was the pUserData parameter (the 5th parameter) of the &lt;a href=&quot;create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt; and &lt;a href=&quot;create_function&quot;&gt;sqlite3_create_function16()&lt;/a&gt; routines that originally registered the application defined function.</source>
          <target state="translated">Интерфейс sqlite3_user_data () возвращает копию указателя, который был параметром pUserData (5-й параметр &lt;a href=&quot;create_function&quot;&gt;)&lt;/a&gt; подпрограмм &lt;a href=&quot;create_function&quot;&gt;sqlite3_create_function ()&lt;/a&gt; и sqlite3_create_function16 () , которые первоначально регистрировали функцию, определенную приложением.</target>
        </trans-unit>
        <trans-unit id="ea63e7ca04dfc54c7a9a4dfd28964eb4fb6446f1" translate="yes" xml:space="preserve">
          <source>The sqlite3_value objects that are passed as parameters into the implementation of &lt;a href=&quot;#sqlite3_create_function&quot;&gt;application-defined SQL functions&lt;/a&gt; are protected. The sqlite3_value object returned by &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_value()&lt;/a&gt; is unprotected. Unprotected sqlite3_value objects may only be used as arguments to &lt;a href=&quot;#sqlite3_result_blob&quot;&gt;sqlite3_result_value()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;sqlite3_bind_value()&lt;/a&gt;, and &lt;a href=&quot;#sqlite3_value_dup&quot;&gt;sqlite3_value_dup()&lt;/a&gt;. The &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_type()&lt;/a&gt; family of interfaces require protected sqlite3_value objects.</source>
          <target state="translated">Объекты sqlite3_value, которые передаются в качестве параметров в реализацию &lt;a href=&quot;#sqlite3_create_function&quot;&gt;определяемых приложением функций SQL&lt;/a&gt; , защищены. Объект sqlite3_value, возвращаемый &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;функцией sqlite3_column_value (),&lt;/a&gt; не защищен. Незащищенные объекты sqlite3_value могут использоваться только в качестве аргументов для &lt;a href=&quot;#sqlite3_result_blob&quot;&gt;sqlite3_result_value ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;sqlite3_bind_value ()&lt;/a&gt; и &lt;a href=&quot;#sqlite3_value_dup&quot;&gt;sqlite3_value_dup ()&lt;/a&gt; . Для семейства интерфейсов &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_type ()&lt;/a&gt; требуются защищенные объекты sqlite3_value.</target>
        </trans-unit>
        <trans-unit id="878c26369032034cf1577de94a30701d2b72bfbf" translate="yes" xml:space="preserve">
          <source>The sqlite3_value objects that are passed as parameters into the implementation of &lt;a href=&quot;../appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt; are protected. The sqlite3_value object returned by &lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_value()&lt;/a&gt; is unprotected. Unprotected sqlite3_value objects may only be used as arguments to &lt;a href=&quot;result_blob&quot;&gt;sqlite3_result_value()&lt;/a&gt;, &lt;a href=&quot;bind_blob&quot;&gt;sqlite3_bind_value()&lt;/a&gt;, and &lt;a href=&quot;value_dup&quot;&gt;sqlite3_value_dup()&lt;/a&gt;. The &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_type()&lt;/a&gt; family of interfaces require protected sqlite3_value objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d8545cde1bbfc4f37da956f6919362a532aef6b" translate="yes" xml:space="preserve">
          <source>The sqlite3_value objects that are passed as parameters into the implementation of &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt; are protected. The sqlite3_value object returned by &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_value()&lt;/a&gt; is unprotected. Unprotected sqlite3_value objects may only be used as arguments to &lt;a href=&quot;#sqlite3_result_blob&quot;&gt;sqlite3_result_value()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;sqlite3_bind_value()&lt;/a&gt;, and &lt;a href=&quot;#sqlite3_value_dup&quot;&gt;sqlite3_value_dup()&lt;/a&gt;. The &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_type()&lt;/a&gt; family of interfaces require protected sqlite3_value objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d38041b5ccb2d09a369551e816f131ddba2abad9" translate="yes" xml:space="preserve">
          <source>The sqlite3_value objects that are passed as parameters into the implementation of &lt;a href=&quot;create_function&quot;&gt;application-defined SQL functions&lt;/a&gt; are protected. The sqlite3_value object returned by &lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_value()&lt;/a&gt; is unprotected. Unprotected sqlite3_value objects may only be used as arguments to &lt;a href=&quot;result_blob&quot;&gt;sqlite3_result_value()&lt;/a&gt;, &lt;a href=&quot;bind_blob&quot;&gt;sqlite3_bind_value()&lt;/a&gt;, and &lt;a href=&quot;value_dup&quot;&gt;sqlite3_value_dup()&lt;/a&gt;. The &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_type()&lt;/a&gt; family of interfaces require protected sqlite3_value objects.</source>
          <target state="translated">Объекты sqlite3_value, которые передаются в качестве параметров в реализацию &lt;a href=&quot;create_function&quot;&gt;определяемых приложением функций SQL&lt;/a&gt; , защищены. Объект sqlite3_value, возвращаемый &lt;a href=&quot;column_blob&quot;&gt;функцией sqlite3_column_value (),&lt;/a&gt; не защищен. Незащищенные объекты sqlite3_value могут использоваться только в качестве аргументов для &lt;a href=&quot;result_blob&quot;&gt;sqlite3_result_value ()&lt;/a&gt; , &lt;a href=&quot;bind_blob&quot;&gt;sqlite3_bind_value ()&lt;/a&gt; и &lt;a href=&quot;value_dup&quot;&gt;sqlite3_value_dup ()&lt;/a&gt; . Для семейства интерфейсов &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_type ()&lt;/a&gt; требуются защищенные объекты sqlite3_value.</target>
        </trans-unit>
        <trans-unit id="a0129b60c59e08fad26659c0f3fdb0270cff463d" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_dup(V) interface makes a copy of the &lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt; object D and returns a pointer to that copy. The &lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt; returned is a &lt;a href=&quot;#sqlite3_value&quot;&gt;protected sqlite3_value&lt;/a&gt; object even if the input is not. The sqlite3_value_dup(V) interface returns NULL if V is NULL or if a memory allocation fails.</source>
          <target state="translated">Интерфейс sqlite3_value_dup (V) создает копию объекта &lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt; D и возвращает указатель на эту копию. &lt;a href=&quot;#sqlite3_value&quot;&gt;Sqlite3_value&lt;/a&gt; вернулся является &lt;a href=&quot;#sqlite3_value&quot;&gt;защищенным sqlite3_value&lt;/a&gt; объекта , даже если на входе нет. Интерфейс sqlite3_value_dup (V) возвращает NULL, если V равен NULL или при сбое выделения памяти.</target>
        </trans-unit>
        <trans-unit id="0aa98b18c314b7d86c75837f6de77eb6d3e0637d" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_dup(V) interface makes a copy of the &lt;a href=&quot;value&quot;&gt;sqlite3_value&lt;/a&gt; object D and returns a pointer to that copy. The &lt;a href=&quot;value&quot;&gt;sqlite3_value&lt;/a&gt; returned is a &lt;a href=&quot;value&quot;&gt;protected sqlite3_value&lt;/a&gt; object even if the input is not. The sqlite3_value_dup(V) interface returns NULL if V is NULL or if a memory allocation fails.</source>
          <target state="translated">Интерфейс sqlite3_value_dup (V) создает копию объекта &lt;a href=&quot;value&quot;&gt;sqlite3_value&lt;/a&gt; D и возвращает указатель на эту копию. &lt;a href=&quot;value&quot;&gt;Sqlite3_value&lt;/a&gt; вернулся является &lt;a href=&quot;value&quot;&gt;защищенным sqlite3_value&lt;/a&gt; объекта , даже если на входе нет. Интерфейс sqlite3_value_dup (V) возвращает NULL, если V равен NULL или при сбое выделения памяти.</target>
        </trans-unit>
        <trans-unit id="e0414ddee749e340e753046c8b57c08bdec5a9dc" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_free(V) interface frees an &lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt; object previously obtained from &lt;a href=&quot;#sqlite3_value_dup&quot;&gt;sqlite3_value_dup()&lt;/a&gt;. If V is a NULL pointer then sqlite3_value_free(V) is a harmless no-op.</source>
          <target state="translated">Интерфейс sqlite3_value_free (V) освобождает объект &lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value,&lt;/a&gt; ранее полученный из &lt;a href=&quot;#sqlite3_value_dup&quot;&gt;sqlite3_value_dup ()&lt;/a&gt; . Если V является указателем NULL, тогда sqlite3_value_free (V) - безобидный запрет.</target>
        </trans-unit>
        <trans-unit id="e1cbff52a059b27e36ab50ec612e0a1c2d7433c2" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_free(V) interface frees an &lt;a href=&quot;value&quot;&gt;sqlite3_value&lt;/a&gt; object previously obtained from &lt;a href=&quot;value_dup&quot;&gt;sqlite3_value_dup()&lt;/a&gt;. If V is a NULL pointer then sqlite3_value_free(V) is a harmless no-op.</source>
          <target state="translated">Интерфейс sqlite3_value_free (V) освобождает объект &lt;a href=&quot;value&quot;&gt;sqlite3_value,&lt;/a&gt; ранее полученный из &lt;a href=&quot;value_dup&quot;&gt;sqlite3_value_dup ()&lt;/a&gt; . Если V является указателем NULL, тогда sqlite3_value_free (V) - безобидный запрет.</target>
        </trans-unit>
        <trans-unit id="7d48e35fde2b5031a0a61511df13116d92432d3c" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_frombind(X) interface returns non-zero if the value X originated from one of the &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;sqlite3_bind()&lt;/a&gt; interfaces. If X comes from an SQL literal value, or a table column, and expression, then sqlite3_value_frombind(X) returns zero.</source>
          <target state="translated">Интерфейс sqlite3_value_frombind (X) возвращает ненулевое значение, если значение X получено из одного из интерфейсов &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;sqlite3_bind ()&lt;/a&gt; . Если X происходит из литерального значения SQL или столбца таблицы и выражения, тогда sqlite3_value_frombind (X) возвращает ноль.</target>
        </trans-unit>
        <trans-unit id="80d4668ad9e2d92c3db76ff20be74213c969d9ff" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_frombind(X) interface returns non-zero if the value X originated from one of the &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;sqlite3_bind()&lt;/a&gt; interfaces. If X comes from an SQL literal value, or a table column, or an expression, then sqlite3_value_frombind(X) returns zero.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4099e909bffc50f671788cefdd0e00a496608c5a" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_frombind(X) interface returns non-zero if the value X originated from one of the &lt;a href=&quot;bind_blob&quot;&gt;sqlite3_bind()&lt;/a&gt; interfaces. If X comes from an SQL literal value, or a table column, and expression, then sqlite3_value_frombind(X) returns zero.</source>
          <target state="translated">Интерфейс sqlite3_value_frombind (X) возвращает ненулевое значение, если значение X получено из одного из интерфейсов &lt;a href=&quot;bind_blob&quot;&gt;sqlite3_bind ()&lt;/a&gt; . Если X происходит из литерального значения SQL или столбца таблицы и выражения, тогда sqlite3_value_frombind (X) возвращает ноль.</target>
        </trans-unit>
        <trans-unit id="d098066d168e6b39abb688284c2a26c07f3bcf76" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_frombind(X) interface returns non-zero if the value X originated from one of the &lt;a href=&quot;bind_blob&quot;&gt;sqlite3_bind()&lt;/a&gt; interfaces. If X comes from an SQL literal value, or a table column, or an expression, then sqlite3_value_frombind(X) returns zero.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4ba714b8f0c8b8a0a85eade6cc85a5f85674f5b" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_numeric_type() interface attempts to apply numeric affinity to the value. This means that an attempt is made to convert the value to an integer or floating point. If such a conversion is possible without loss of information (in other words, if the value is a string that looks like a number) then the conversion is performed. Otherwise no conversion occurs. The &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;datatype&lt;/a&gt; after conversion is returned.</source>
          <target state="translated">Интерфейс sqlite3_value_numeric_type () пытается применить числовое сродство к значению. Это означает, что делается попытка преобразовать значение в целое число или с плавающей запятой. Если такое преобразование возможно без потери информации (другими словами, если значение представляет собой строку, которая выглядит как число), то преобразование выполняется. В противном случае преобразование не происходит. Тип &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;данных&lt;/a&gt; после преобразования возвращается.</target>
        </trans-unit>
        <trans-unit id="d57e13a61eeb32fc6ccab4def9ab890b09fb83b8" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_numeric_type() interface attempts to apply numeric affinity to the value. This means that an attempt is made to convert the value to an integer or floating point. If such a conversion is possible without loss of information (in other words, if the value is a string that looks like a number) then the conversion is performed. Otherwise no conversion occurs. The &lt;a href=&quot;c_blob&quot;&gt;datatype&lt;/a&gt; after conversion is returned.</source>
          <target state="translated">Интерфейс sqlite3_value_numeric_type () пытается применить числовое сродство к значению. Это означает, что делается попытка преобразовать значение в целое число или с плавающей запятой. Если такое преобразование возможно без потери информации (другими словами, если значение представляет собой строку, которая выглядит как число), то преобразование выполняется. В противном случае преобразование не происходит. Тип &lt;a href=&quot;c_blob&quot;&gt;данных&lt;/a&gt; после преобразования возвращается.</target>
        </trans-unit>
        <trans-unit id="4ec72e1543814b021a25a90d5cb860b5227da9f5" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_subtype(V) function returns the subtype for an &lt;a href=&quot;#sqlite3_create_function&quot;&gt;application-defined SQL function&lt;/a&gt; argument V. The subtype information can be used to pass a limited amount of context from one SQL function to another. Use the &lt;a href=&quot;#sqlite3_result_subtype&quot;&gt;sqlite3_result_subtype()&lt;/a&gt; routine to set the subtype for the return value of an SQL function.</source>
          <target state="translated">Функция sqlite3_value_subtype (V) возвращает подтип для аргумента V &lt;a href=&quot;#sqlite3_create_function&quot;&gt;функции SQL, определяемого приложением.&lt;/a&gt; Информация о подтипе может использоваться для передачи ограниченного объема контекста от одной функции SQL к другой. Используйте процедуру &lt;a href=&quot;#sqlite3_result_subtype&quot;&gt;sqlite3_result_subtype (),&lt;/a&gt; чтобы установить подтип для возвращаемого значения функции SQL.</target>
        </trans-unit>
        <trans-unit id="ac784313e8a1c8814ecb1722aed4c17998bb6a84" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_subtype(V) function returns the subtype for an &lt;a href=&quot;../appfunc&quot;&gt;application-defined SQL function&lt;/a&gt; argument V. The subtype information can be used to pass a limited amount of context from one SQL function to another. Use the &lt;a href=&quot;result_subtype&quot;&gt;sqlite3_result_subtype()&lt;/a&gt; routine to set the subtype for the return value of an SQL function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9482d5c89729cab0c852ef903cf3adcd7fd134d" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_subtype(V) function returns the subtype for an &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL function&lt;/a&gt; argument V. The subtype information can be used to pass a limited amount of context from one SQL function to another. Use the &lt;a href=&quot;#sqlite3_result_subtype&quot;&gt;sqlite3_result_subtype()&lt;/a&gt; routine to set the subtype for the return value of an SQL function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff11a55e63d67f21f428483b7880706f081aadf2" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_subtype(V) function returns the subtype for an &lt;a href=&quot;create_function&quot;&gt;application-defined SQL function&lt;/a&gt; argument V. The subtype information can be used to pass a limited amount of context from one SQL function to another. Use the &lt;a href=&quot;result_subtype&quot;&gt;sqlite3_result_subtype()&lt;/a&gt; routine to set the subtype for the return value of an SQL function.</source>
          <target state="translated">Функция sqlite3_value_subtype (V) возвращает подтип для аргумента V &lt;a href=&quot;create_function&quot;&gt;функции SQL, определяемого приложением.&lt;/a&gt; Информация о подтипе может использоваться для передачи ограниченного объема контекста от одной функции SQL к другой. Используйте процедуру &lt;a href=&quot;result_subtype&quot;&gt;sqlite3_result_subtype (),&lt;/a&gt; чтобы установить подтип для возвращаемого значения функции SQL.</target>
        </trans-unit>
        <trans-unit id="b0e636524c92f0e1651fb00be6db5e8d57af0255" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_text16() interface extracts a UTF-16 string in the native byte-order of the host machine. The sqlite3_value_text16be() and sqlite3_value_text16le() interfaces extract UTF-16 strings as big-endian and little-endian respectively.</source>
          <target state="translated">Интерфейс sqlite3_value_text16()извлекает строку UTF-16 в родном порядке байт хост-машины.Интерфейсы sqlite3_value_text16be()и sqlite3_value_text16le()извлекают строки UTF-16 в виде big-endian и little-endian соответственно.</target>
        </trans-unit>
        <trans-unit id="abd8dcf49d86f46dedd1a279c57c33b107030fa7" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_type(V) interface returns the &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;datatype code&lt;/a&gt; for the initial datatype of the &lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt; object V. The returned value is one of &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_INTEGER&lt;/a&gt;, &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_FLOAT&lt;/a&gt;, &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_TEXT&lt;/a&gt;, &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_BLOB&lt;/a&gt;, or &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_NULL&lt;/a&gt;. Other interfaces might change the datatype for an sqlite3_value object. For example, if the datatype is initially SQLITE_INTEGER and sqlite3_value_text(V) is called to extract a text value for that integer, then subsequent calls to sqlite3_value_type(V) might return SQLITE_TEXT. Whether or not a persistent internal datatype conversion occurs is undefined and may change from one release of SQLite to the next.</source>
          <target state="translated">Интерфейс sqlite3_value_type (V) возвращает &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;код типа данных&lt;/a&gt; для начального типа данных объекта &lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt; V. Возвращаемое значение - одно из &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_INTEGER&lt;/a&gt; , &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_FLOAT&lt;/a&gt; , &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_TEXT&lt;/a&gt; , &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_BLOB&lt;/a&gt; или &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_NULL&lt;/a&gt; . Другие интерфейсы могут изменить тип данных для объекта sqlite3_value. Например, если типом данных изначально является SQLITE_INTEGER и вызывается sqlite3_value_text (V) для извлечения текстового значения для этого целого числа, то последующие вызовы sqlite3_value_type (V) могут вернуть SQLITE_TEXT. Не определено, происходит ли постоянное внутреннее преобразование типа данных, и оно может изменяться от одного выпуска SQLite к другому.</target>
        </trans-unit>
        <trans-unit id="9cdf3c345651dd059fa86a01b992ffdfc67b3546" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_type(V) interface returns the &lt;a href=&quot;c_blob&quot;&gt;datatype code&lt;/a&gt; for the initial datatype of the &lt;a href=&quot;value&quot;&gt;sqlite3_value&lt;/a&gt; object V. The returned value is one of &lt;a href=&quot;c_blob&quot;&gt;SQLITE_INTEGER&lt;/a&gt;, &lt;a href=&quot;c_blob&quot;&gt;SQLITE_FLOAT&lt;/a&gt;, &lt;a href=&quot;c_blob&quot;&gt;SQLITE_TEXT&lt;/a&gt;, &lt;a href=&quot;c_blob&quot;&gt;SQLITE_BLOB&lt;/a&gt;, or &lt;a href=&quot;c_blob&quot;&gt;SQLITE_NULL&lt;/a&gt;. Other interfaces might change the datatype for an sqlite3_value object. For example, if the datatype is initially SQLITE_INTEGER and sqlite3_value_text(V) is called to extract a text value for that integer, then subsequent calls to sqlite3_value_type(V) might return SQLITE_TEXT. Whether or not a persistent internal datatype conversion occurs is undefined and may change from one release of SQLite to the next.</source>
          <target state="translated">Интерфейс sqlite3_value_type (V) возвращает &lt;a href=&quot;c_blob&quot;&gt;код типа данных&lt;/a&gt; для начального типа данных объекта &lt;a href=&quot;value&quot;&gt;sqlite3_value&lt;/a&gt; V. Возвращаемое значение - одно из &lt;a href=&quot;c_blob&quot;&gt;SQLITE_INTEGER&lt;/a&gt; , &lt;a href=&quot;c_blob&quot;&gt;SQLITE_FLOAT&lt;/a&gt; , &lt;a href=&quot;c_blob&quot;&gt;SQLITE_TEXT&lt;/a&gt; , &lt;a href=&quot;c_blob&quot;&gt;SQLITE_BLOB&lt;/a&gt; или &lt;a href=&quot;c_blob&quot;&gt;SQLITE_NULL&lt;/a&gt; . Другие интерфейсы могут изменить тип данных для объекта sqlite3_value. Например, если типом данных изначально является SQLITE_INTEGER и вызывается sqlite3_value_text (V) для извлечения текстового значения для этого целого числа, то последующие вызовы sqlite3_value_type (V) могут вернуть SQLITE_TEXT. Не определено, происходит ли постоянное внутреннее преобразование типа данных, и оно может изменяться от одного выпуска SQLite к другому.</target>
        </trans-unit>
        <trans-unit id="9fd8993db96d6be0a53b95ff8fe5c5a06191a2c2" translate="yes" xml:space="preserve">
          <source>The sqlite3_version[] string constant contains the text of &lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_VERSION&lt;/a&gt; macro. The sqlite3_libversion() function returns a pointer to the to the sqlite3_version[] string constant. The sqlite3_libversion() function is provided for use in DLLs since DLL users usually do not have direct access to string constants within the DLL. The sqlite3_libversion_number() function returns an integer equal to &lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_VERSION_NUMBER&lt;/a&gt;. The sqlite3_sourceid() function returns a pointer to a string constant whose value is the same as the &lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_SOURCE_ID&lt;/a&gt; C preprocessor macro. Except if SQLite is built using an edited copy of &lt;a href=&quot;amalgamation&quot;&gt;the amalgamation&lt;/a&gt;, then the last four characters of the hash might be different from &lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_SOURCE_ID&lt;/a&gt;.</source>
          <target state="translated">Строковая константа sqlite3_version [] содержит текст макроса &lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_VERSION&lt;/a&gt; . Функция sqlite3_libversion () возвращает указатель на строковую константу sqlite3_version []. Функция sqlite3_libversion () предназначена для использования в библиотеках DLL, поскольку пользователи DLL обычно не имеют прямого доступа к строковым константам внутри библиотеки DLL. Функция sqlite3_libversion_number () возвращает целое число, равное &lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_VERSION_NUMBER&lt;/a&gt; . Функция sqlite3_sourceid () возвращает указатель на &lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;строковую&lt;/a&gt; константу, значение которой совпадает со значением макроса препроцессора C SQLITE_SOURCE_ID . За исключением случаев, когда SQLite создается с использованием отредактированной копии &lt;a href=&quot;amalgamation&quot;&gt;объединения&lt;/a&gt; , последние четыре символа хеш- &lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;кода&lt;/a&gt; могут отличаться от SQLITE_SOURCE_ID .</target>
        </trans-unit>
        <trans-unit id="a807d081504ff9864c4a0f322dee10127ba34ee0" translate="yes" xml:space="preserve">
          <source>The sqlite3_version[] string constant contains the text of &lt;a href=&quot;c_source_id&quot;&gt;SQLITE_VERSION&lt;/a&gt; macro. The sqlite3_libversion() function returns a pointer to the to the sqlite3_version[] string constant. The sqlite3_libversion() function is provided for use in DLLs since DLL users usually do not have direct access to string constants within the DLL. The sqlite3_libversion_number() function returns an integer equal to &lt;a href=&quot;c_source_id&quot;&gt;SQLITE_VERSION_NUMBER&lt;/a&gt;. The sqlite3_sourceid() function returns a pointer to a string constant whose value is the same as the &lt;a href=&quot;c_source_id&quot;&gt;SQLITE_SOURCE_ID&lt;/a&gt; C preprocessor macro. Except if SQLite is built using an edited copy of &lt;a href=&quot;../amalgamation&quot;&gt;the amalgamation&lt;/a&gt;, then the last four characters of the hash might be different from &lt;a href=&quot;c_source_id&quot;&gt;SQLITE_SOURCE_ID&lt;/a&gt;.</source>
          <target state="translated">Строковая константа sqlite3_version [] содержит текст макроса &lt;a href=&quot;c_source_id&quot;&gt;SQLITE_VERSION&lt;/a&gt; . Функция sqlite3_libversion () возвращает указатель на строковую константу sqlite3_version []. Функция sqlite3_libversion () предназначена для использования в библиотеках DLL, поскольку пользователи DLL обычно не имеют прямого доступа к строковым константам внутри библиотеки DLL. Функция sqlite3_libversion_number () возвращает целое число, равное &lt;a href=&quot;c_source_id&quot;&gt;SQLITE_VERSION_NUMBER&lt;/a&gt; . Функция sqlite3_sourceid () возвращает указатель на &lt;a href=&quot;c_source_id&quot;&gt;строковую&lt;/a&gt; константу, значение которой совпадает со значением макроса препроцессора C SQLITE_SOURCE_ID . За исключением случаев, когда SQLite создается с использованием отредактированной копии &lt;a href=&quot;../amalgamation&quot;&gt;объединения&lt;/a&gt; , последние четыре символа хеш- &lt;a href=&quot;c_source_id&quot;&gt;кода&lt;/a&gt; могут отличаться от SQLITE_SOURCE_ID .</target>
        </trans-unit>
        <trans-unit id="b7f0635e95ae6f97edbc2a13b7ebfc89ee7bf9a3" translate="yes" xml:space="preserve">
          <source>The sqlite3_vfs_find() interface returns a pointer to a VFS given its name. Names are case sensitive. Names are zero-terminated UTF-8 strings. If there is no match, a NULL pointer is returned. If zVfsName is NULL then the default VFS is returned.</source>
          <target state="translated">Интерфейс sqlite3_vfs_find()возвращает указатель на VFS с его именем.Имена чувствительны к регистру.Имена-ноль-терминированные UTF-8 строки.Если совпадение отсутствует,возвращается указатель NULL.Если zVfsName равно NULL,возвращается VFS по умолчанию.</target>
        </trans-unit>
        <trans-unit id="88892501427d74185f6b1bff1e11e202173ae158" translate="yes" xml:space="preserve">
          <source>The sqlite3_vsnprintf() routine is a varargs version of sqlite3_snprintf().</source>
          <target state="translated">Рутина sqlite3_vsnprintf()является varargs версией sqlite3_snprintf().</target>
        </trans-unit>
        <trans-unit id="356433cad1c4d15f2f32ad4a2430dfb62b71a5c8" translate="yes" xml:space="preserve">
          <source>The sqlite3_vtab_nochange() routine is an optimization. Virtual table implementations should continue to give a correct answer even if the sqlite3_vtab_nochange() interface were to always return false. In the current implementation, the sqlite3_vtab_nochange() interface does always returns false for the enhanced &lt;a href=&quot;../lang_update#upfrom&quot;&gt;UPDATE FROM&lt;/a&gt; statement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="409bceec3a12ab1303b2c91da2663bb3cd84af64" translate="yes" xml:space="preserve">
          <source>The sqlite3_vtab_nochange() routine is an optimization. Virtual table implementations should continue to give a correct answer even if the sqlite3_vtab_nochange() interface were to always return false. In the current implementation, the sqlite3_vtab_nochange() interface does always returns false for the enhanced &lt;a href=&quot;lang_update#upfrom&quot;&gt;UPDATE FROM&lt;/a&gt; statement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfe11fb394a04090848d426f27d7f821bd426298" translate="yes" xml:space="preserve">
          <source>The sqlite3_wal_checkpoint(D,X) is equivalent to &lt;a href=&quot;#sqlite3_wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2&lt;/a&gt;(D,X,&lt;a href=&quot;#SQLITE_CHECKPOINT_FULL&quot;&gt;SQLITE_CHECKPOINT_PASSIVE&lt;/a&gt;,0,0).</source>
          <target state="translated">Sqlite3_wal_checkpoint (D, X) эквивалентен &lt;a href=&quot;#sqlite3_wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2&lt;/a&gt; (D, X, &lt;a href=&quot;#SQLITE_CHECKPOINT_FULL&quot;&gt;SQLITE_CHECKPOINT_PASSIVE&lt;/a&gt; , 0,0).</target>
        </trans-unit>
        <trans-unit id="a5b2980a50de42ca24a7d3c803dbeadfa7a488ca" translate="yes" xml:space="preserve">
          <source>The sqlite3_wal_checkpoint(D,X) is equivalent to &lt;a href=&quot;wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2&lt;/a&gt;(D,X,&lt;a href=&quot;c_checkpoint_full&quot;&gt;SQLITE_CHECKPOINT_PASSIVE&lt;/a&gt;,0,0).</source>
          <target state="translated">Sqlite3_wal_checkpoint (D, X) эквивалентен &lt;a href=&quot;wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2&lt;/a&gt; (D, X, &lt;a href=&quot;c_checkpoint_full&quot;&gt;SQLITE_CHECKPOINT_PASSIVE&lt;/a&gt; , 0,0).</target>
        </trans-unit>
        <trans-unit id="7f281b26d80df2d4297decb3bb5684de63641309" translate="yes" xml:space="preserve">
          <source>The sqlite3_wal_checkpoint_v2(D,X,M,L,C) interface runs a checkpoint operation on database X of &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; D in mode M. Status information is written back into integers pointed to by L and C. The M parameter must be a valid &lt;a href=&quot;#SQLITE_CHECKPOINT_FULL&quot;&gt;checkpoint mode&lt;/a&gt;:</source>
          <target state="translated">Интерфейс sqlite3_wal_checkpoint_v2 (D, X, M, L, C) запускает операцию контрольной точки в базе данных X соединения с &lt;a href=&quot;#sqlite3&quot;&gt;базой данных&lt;/a&gt; D в режиме M. Информация о состоянии записывается обратно в целые числа, на которые указывают L и C. Параметр M должен быть допустимым. &lt;a href=&quot;#SQLITE_CHECKPOINT_FULL&quot;&gt;режим контрольной точки&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="4f16d84b1dffbf24b61871d0a39f458136f5ce78" translate="yes" xml:space="preserve">
          <source>The sqlite3_wal_checkpoint_v2(D,X,M,L,C) interface runs a checkpoint operation on database X of &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; D in mode M. Status information is written back into integers pointed to by L and C. The M parameter must be a valid &lt;a href=&quot;c_checkpoint_full&quot;&gt;checkpoint mode&lt;/a&gt;:</source>
          <target state="translated">Интерфейс sqlite3_wal_checkpoint_v2 (D, X, M, L, C) запускает операцию контрольной точки в базе данных X соединения с &lt;a href=&quot;sqlite3&quot;&gt;базой данных&lt;/a&gt; D в режиме M. Информация о состоянии записывается обратно в целые числа, на которые указывают L и C. Параметр M должен быть допустимым. &lt;a href=&quot;c_checkpoint_full&quot;&gt;режим контрольной точки&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="121e4ad510585a0237e3a007626cc2d427159cf6" translate="yes" xml:space="preserve">
          <source>The sqlite3changeset_apply() function automatically converts the zero-length blob back to a NULL value when updating the sqlite_stat1 table. However, if the application calls sqlite3changeset_new(), sqlite3changeset_old() or sqlite3changeset_conflict on a changeset iterator directly (including on a changeset iterator passed to a conflict-handler callback) then the X'' value is returned. The application must translate X'' to NULL itself if required.</source>
          <target state="translated">Функция sqlite3changeset_apply()при обновлении таблицы sqlite_stat1 автоматически преобразует блок нулевой длины обратно в значение NULL.Однако,если приложение вызывает sqlite3changeset_new(),sqlite3changeset_old()или sqlite3changeset_conflict на итераторе changeset непосредственно (в том числе и на итераторе changeset,переданном обратному конфликтообладателю),то возвращается значение X''.При необходимости приложение должно самостоятельно перевести X'' в NULL.</target>
        </trans-unit>
        <trans-unit id="ab7530db4d4c9fc320d8eb6c02294cea75207425" translate="yes" xml:space="preserve">
          <source>The sqlite3rbu_open(T,A,S) function returns a pointer to an &quot;sqlite3rbu&quot; object, which is then passed into the subsequent interfaces.</source>
          <target state="translated">Функция sqlite3rbu_open(T,A,S)возвращает указатель на объект &quot;sqlite3rbu&quot;,который затем передаётся в последующие интерфейсы.</target>
        </trans-unit>
        <trans-unit id="bcc8971708ade277f3f9ba38012f5db2060092ea" translate="yes" xml:space="preserve">
          <source>The sqlite3session_config() interface is not threadsafe. If it is invoked while any other thread is inside any other sessions method then the results are undefined. Furthermore, if it is invoked after any sessions related objects have been created, the results are also undefined.</source>
          <target state="translated">Интерфейс sqlite3session_config()не является потокобезопасным.Если он вызывается в то время,как любой другой поток находится внутри любого другого метода сеанса,то результаты не определяются.Более того,если он вызывается после создания объектов,связанных с сессиями,результаты также не определяются.</target>
        </trans-unit>
        <trans-unit id="ed3502dd7610ba7f06fbfad0a9a6bcb2eec2c983" translate="yes" xml:space="preserve">
          <source>The sqlite3session_config() interface is used to make global configuration changes to the sessions module in order to tune it to the specific needs of the application.</source>
          <target state="translated">Интерфейс sqlite3session_config()используется для внесения глобальных конфигурационных изменений в модуль сеансов с целью его настройки под конкретные нужды приложения.</target>
        </trans-unit>
        <trans-unit id="517ed7f5443765d182eb47f3b8b955f48af65e6e" translate="yes" xml:space="preserve">
          <source>The sqlite_compileoption_get() SQL function is a wrapper around the &lt;a href=&quot;c3ref/compileoption_get&quot;&gt;sqlite3_compileoption_get()&lt;/a&gt; C/C++ function. This routine returns the N-th compile-time option used to build SQLite or NULL if N is out of range. See also the &lt;a href=&quot;pragma#pragma_compile_options&quot;&gt;compile_options pragma&lt;/a&gt;.</source>
          <target state="translated">SQL-функция sqlite_compileoption_get () представляет собой оболочку для &lt;a href=&quot;c3ref/compileoption_get&quot;&gt;функции sqlite3_compileoption_get ()&lt;/a&gt; C / C ++. Эта процедура возвращает N-й параметр времени компиляции, используемый для построения SQLite, или NULL, если N выходит за пределы допустимого диапазона. См. Также &lt;a href=&quot;pragma#pragma_compile_options&quot;&gt;прагму compile_options&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="62942f05e5a1956f6b33c8235e025eeea5e49332" translate="yes" xml:space="preserve">
          <source>The sqlite_compileoption_used() SQL function is a wrapper around the &lt;a href=&quot;c3ref/compileoption_get&quot;&gt;sqlite3_compileoption_used()&lt;/a&gt; C/C++ function. When the argument X to sqlite_compileoption_used(X) is a string which is the name of a compile-time option, this routine returns true (1) or false (0) depending on whether or not that option was used during the build.</source>
          <target state="translated">SQL-функция sqlite_compileoption_used () является оболочкой для &lt;a href=&quot;c3ref/compileoption_get&quot;&gt;функции sqlite3_compileoption_used ()&lt;/a&gt; C / C ++. Когда аргумент X для sqlite_compileoption_used (X) является строкой, которая является именем параметра времени компиляции, эта процедура возвращает истину (1) или ложь (0) в зависимости от того, использовалась ли эта опция во время сборки.</target>
        </trans-unit>
        <trans-unit id="029c047f81979126902e66d7c2206be9ceebe6ff" translate="yes" xml:space="preserve">
          <source>The sqlite_master table contains one row for each table, index, view, and trigger (collectively &quot;objects&quot;) in the database schema, except there is no entry for the sqlite_master table itself. The sqlite_master table contains entries for &lt;a href=&quot;fileformat2#intschema&quot;&gt;internal schema objects&lt;/a&gt; in addition to application- and programmer-defined objects.</source>
          <target state="translated">Таблица sqlite_master содержит по одной строке для каждой таблицы, индекса, представления и триггера (в совокупности &amp;laquo;объекты&amp;raquo;) в схеме базы данных, за исключением того, что для самой таблицы sqlite_master нет записи. Таблица sqlite_master содержит записи для &lt;a href=&quot;fileformat2#intschema&quot;&gt;объектов внутренней схемы&lt;/a&gt; в дополнение к объектам, определяемым приложением и программистом.</target>
        </trans-unit>
        <trans-unit id="9e701356a8021b4fb9727300fa9f7200eddb250b" translate="yes" xml:space="preserve">
          <source>The sqlite_master.name column will hold the name of the object. &lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE&lt;/a&gt; and &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt; constraints on tables cause SQLite to create &lt;a href=&quot;fileformat2#intschema&quot;&gt;internal indexes&lt;/a&gt; with names of the form &quot;sqlite_autoindex_TABLE_N&quot; where TABLE is replaced by the name of the table that contains the constraint and N is an integer beginning with 1 and increasing by one with each constraint seen in the table definition. In a &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; table, there is no sqlite_master entry for the PRIMARY KEY, but the &quot;sqlite_autoindex_TABLE_N&quot; name is set aside for the PRIMARY KEY as if the sqlite_master entry did exist. This will affect the numbering of subsequent UNIQUE constraints. The &quot;sqlite_autoindex_TABLE_N&quot; name is never allocated for an &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;, either in rowid tables or WITHOUT ROWID tables.</source>
          <target state="translated">Столбец sqlite_master.name будет содержать имя объекта. Ограничения &lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE&lt;/a&gt; и &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt; для таблиц заставляют SQLite создавать &lt;a href=&quot;fileformat2#intschema&quot;&gt;внутренние индексы&lt;/a&gt; с именами в форме &amp;laquo;sqlite_autoindex_TABLE_N&amp;raquo;, где TABLE заменяется именем таблицы, содержащей ограничение, а N - целое число, начинающееся с 1 и увеличивающееся на единицу с каждым ограничением. видно в определении таблицы. В таблице &lt;a href=&quot;withoutrowid&quot;&gt;БЕЗ ROWID&lt;/a&gt; отсутствует запись sqlite_master для ПЕРВИЧНОГО КЛЮЧА, но имя &amp;laquo;sqlite_autoindex_TABLE_N&amp;raquo; для ПЕРВИЧНОГО КЛЮЧА отложено, как если бы запись sqlite_master действительно существовала. Это повлияет на нумерацию последующих ограничений UNIQUE. &quot;Sqlite_autoindex_TABLE_N&quot;имя никогда не выделяется для &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;, либо в таблицах rowid, либо в таблицах БЕЗ ROWID.</target>
        </trans-unit>
        <trans-unit id="3bae42f70521e9e8cd4db2168d1d1babca7ff5fa" translate="yes" xml:space="preserve">
          <source>The sqlite_master.rootpage column stores the page number of the root b-tree page for tables and indexes. For rows that define views, triggers, and virtual tables, the rootpage column is 0 or NULL.</source>
          <target state="translated">В колонке sqlite_master.rootpage хранится номер страницы корневой b-деревянной страницы для таблиц и индексов.Для строк,определяющих представления,триггеры и виртуальные таблицы,столбец корневой страницы равен 0 или NULL.</target>
        </trans-unit>
        <trans-unit id="ccb922e59255362de7628494ea2946015486eb28" translate="yes" xml:space="preserve">
          <source>The sqlite_master.sql column stores SQL text that describes the object. This SQL text is a &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt;, &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt;, &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt;, &lt;a href=&quot;lang_createview&quot;&gt;CREATE VIEW&lt;/a&gt;, or &lt;a href=&quot;lang_createtrigger&quot;&gt;CREATE TRIGGER&lt;/a&gt; statement that if evaluated against the database file when it is the main database of a &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; would recreate the object. The text is usually a copy of the original statement used to create the object but with normalizations applied so that the text conforms to the following rules:</source>
          <target state="translated">В столбце sqlite_master.sql хранится текст SQL, описывающий объект. Этот текст SQL представляет собой оператор &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; , &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; , &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt; , &lt;a href=&quot;lang_createview&quot;&gt;CREATE VIEW&lt;/a&gt; или &lt;a href=&quot;lang_createtrigger&quot;&gt;CREATE TRIGGER,&lt;/a&gt; который при вычислении по файлу базы данных, когда он является основной базой &lt;a href=&quot;c3ref/sqlite3&quot;&gt;данных соединения&lt;/a&gt; с базой данных , воссоздает объект. Текст обычно является копией исходного оператора, использованного для создания объекта, но с нормализацией, применяемой так, чтобы текст соответствовал следующим правилам:</target>
        </trans-unit>
        <trans-unit id="8ef76cce54ac5ead8c9ecfb2e98b71a272278d61" translate="yes" xml:space="preserve">
          <source>The sqlite_master.tbl_name column holds the name of a table or view that the object is associated with. For a table or view, the tbl_name column is a copy of the name column. For an index, the tbl_name is the name of the table that is indexed. For a trigger, the tbl_name column stores the name of the table or view that causes the trigger to fire.</source>
          <target state="translated">В столбце sqlite_master.tbl_name хранится имя таблицы или представления,с которым ассоциируется объект.Для таблицы или представления столбец tbl_name является копией столбца имени.Для индекса столбец tbl_name-это имя таблицы,которая индексируется.Для триггера столбец tbl_name хранит имя таблицы или представления,которое вызывает срабатывание триггера.</target>
        </trans-unit>
        <trans-unit id="1161ce8b03e8867e67c57e405c9c72a8e7f39824" translate="yes" xml:space="preserve">
          <source>The sqlite_master.type column will be one of the following text strings: 'table', 'index', 'view', or 'trigger' according to the type of object defined. The 'table' string is used for both ordinary and &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt;.</source>
          <target state="translated">Столбец sqlite_master.type будет представлять собой одну из следующих текстовых строк: &amp;laquo;таблица&amp;raquo;, &amp;laquo;индекс&amp;raquo;, &amp;laquo;представление&amp;raquo; или &amp;laquo;триггер&amp;raquo; в соответствии с типом определенного объекта. Строка table используется как для обычных, так и для &lt;a href=&quot;vtab&quot;&gt;виртуальных таблиц&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8a4ecb6a492d4b0952a80c0d2b263ba43418de02" translate="yes" xml:space="preserve">
          <source>The sqlite_offset(X) SQL function is only available if SQLite is built using the &lt;a href=&quot;compile#enable_offset_sql_func&quot;&gt;-DSQLITE_ENABLE_OFFSET_SQL_FUNC&lt;/a&gt; compile-time option.</source>
          <target state="translated">Функция SQL sqlite_offset (X) доступна только в том случае, если SQLite построен с использованием параметра &lt;a href=&quot;compile#enable_offset_sql_func&quot;&gt;времени&lt;/a&gt; компиляции -DSQLITE_ENABLE_OFFSET_SQL_FUNC .</target>
        </trans-unit>
        <trans-unit id="f36120db3cfab77bf49cfde55bfe4a03928e953b" translate="yes" xml:space="preserve">
          <source>The sqlite_offset(X) function returns the byte offset in the database file for the beginning of the record from which value would be read. If X is not a column in an ordinary table, then sqlite_offset(X) returns NULL. The value returned by sqlite_offset(X) might reference either the original table or an index, depending on the query. If the value X would normally be extracted from an index, the sqlite_offset(X) returns the offset to the corresponding index record. If the value X would be extracted from the original table, then sqlite_offset(X) returns the offset to the table record.</source>
          <target state="translated">Функция sqlite_offset(X)возвращает смещение байта в файле базы данных для начала записи,из которой будет считываться значение.Если X не является столбцом в обычной таблице,то sqlite_offset(X)возвращает NULL.Значение,возвращаемое sqlite_offset(X),может содержать ссылку либо на исходную таблицу,либо на индекс,в зависимости от запроса.Если значение X обычно извлекается из индекса,sqlite_offset(X)возвращает смещение к соответствующей записи индекса.Если значение X будет извлечено из исходной таблицы,то sqlite_offset(X)возвращает смещение в запись таблицы.</target>
        </trans-unit>
        <trans-unit id="7edde881cc83be6805465c505116db44a7c10317" translate="yes" xml:space="preserve">
          <source>The sqlite_schema table contains one row for each table, index, view, and trigger (collectively &quot;objects&quot;) in the database schema, except there is no entry for the sqlite_schema table itself. The sqlite_schema table contains entries for &lt;a href=&quot;fileformat2#intschema&quot;&gt;internal schema objects&lt;/a&gt; in addition to application- and programmer-defined objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8cd91bb0f299cfe62ef641ec65f9fe2bb5de142" translate="yes" xml:space="preserve">
          <source>The sqlite_schema table contains one row for each table, index, view, and trigger (collectively &quot;objects&quot;) in the schema, except there is no entry for the sqlite_schema table itself. See the &lt;a href=&quot;fileformat2#ffschema&quot;&gt;schema storage&lt;/a&gt; subsection of the &lt;a href=&quot;fileformat2&quot;&gt;file format&lt;/a&gt; documentation for additional information on how SQLite uses the sqlite_schema table internally.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01b38e5a9d3444c64ea7992a244995da2b49b851" translate="yes" xml:space="preserve">
          <source>The sqlite_schema.name column will hold the name of the object. (&lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE&lt;/a&gt; and &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt; constraints on tables cause SQLite to create &lt;a href=&quot;fileformat2#intschema&quot;&gt;internal indexes&lt;/a&gt; with names of the form &quot;sqlite_autoindex_TABLE_N&quot; where TABLE is replaced by the name of the table that contains the constraint and N is an integer beginning with 1 and increasing by one with each constraint seen in the table definition. In a &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; table, there is no sqlite_schema entry for the PRIMARY KEY, but the &quot;sqlite_autoindex_TABLE_N&quot; name is set aside for the PRIMARY KEY as if the sqlite_schema entry did exist. This will affect the numbering of subsequent UNIQUE constraints. The &quot;sqlite_autoindex_TABLE_N&quot; name is never allocated for an &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;, either in rowid tables or WITHOUT ROWID tables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e02071e2d759314e2fb363a98ec697450c31c3a5" translate="yes" xml:space="preserve">
          <source>The sqlite_schema.name column will hold the name of the object. &lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE&lt;/a&gt; and &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt; constraints on tables cause SQLite to create &lt;a href=&quot;fileformat2#intschema&quot;&gt;internal indexes&lt;/a&gt; with names of the form &quot;sqlite_autoindex_TABLE_N&quot; where TABLE is replaced by the name of the table that contains the constraint and N is an integer beginning with 1 and increasing by one with each constraint seen in the table definition. In a &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; table, there is no sqlite_schema entry for the PRIMARY KEY, but the &quot;sqlite_autoindex_TABLE_N&quot; name is set aside for the PRIMARY KEY as if the sqlite_schema entry did exist. This will affect the numbering of subsequent UNIQUE constraints. The &quot;sqlite_autoindex_TABLE_N&quot; name is never allocated for an &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;, either in rowid tables or WITHOUT ROWID tables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b54e4469dd50abde5034fd8f801a4d0306037ed0" translate="yes" xml:space="preserve">
          <source>The sqlite_schema.rootpage column stores the page number of the root b-tree page for tables and indexes. For rows that define views, triggers, and virtual tables, the rootpage column is 0 or NULL.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee6bcf89a71c75b0fa182495e5015131f7df248c" translate="yes" xml:space="preserve">
          <source>The sqlite_schema.sql column stores SQL text that describes the object. This SQL text is a &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt;, &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt;, &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt;, &lt;a href=&quot;lang_createview&quot;&gt;CREATE VIEW&lt;/a&gt;, or &lt;a href=&quot;lang_createtrigger&quot;&gt;CREATE TRIGGER&lt;/a&gt; statement that if evaluated against the database file when it is the main database of a &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; would recreate the object. The text is usually a copy of the original statement used to create the object but with normalizations applied so that the text conforms to the following rules:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d911ebef016f1f15b28a4875cf26c113309d9fa3" translate="yes" xml:space="preserve">
          <source>The sqlite_schema.tbl_name column holds the name of a table or view that the object is associated with. For a table or view, the tbl_name column is a copy of the name column. For an index, the tbl_name is the name of the table that is indexed. For a trigger, the tbl_name column stores the name of the table or view that causes the trigger to fire.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02a28099cf1bad8380c62abb7ce56059bbeb63ba" translate="yes" xml:space="preserve">
          <source>The sqlite_schema.type column will be one of the following text strings: 'table', 'index', 'view', or 'trigger' according to the type of object defined. The 'table' string is used for both ordinary and &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f99e581aad3bfe8af33ed6ae438c6f190e18bdd" translate="yes" xml:space="preserve">
          <source>The sqlite_sequence table is an internal table used to help implement &lt;a href=&quot;autoinc&quot;&gt;AUTOINCREMENT&lt;/a&gt;. The sqlite_sequence table is created automatically whenever any ordinary table with an AUTOINCREMENT integer primary key is created. Once created, the sqlite_sequence table exists in the sqlite_master table forever; it cannot be dropped. The schema for the sqlite_sequence table is:</source>
          <target state="translated">Таблица sqlite_sequence - это внутренняя таблица, которая помогает реализовать &lt;a href=&quot;autoinc&quot;&gt;AUTOINCREMENT&lt;/a&gt; . Таблица sqlite_sequence создается автоматически при создании любой обычной таблицы с целочисленным первичным ключом AUTOINCREMENT. После создания таблица sqlite_sequence существует в таблице sqlite_master навсегда; его нельзя отбросить. Схема для таблицы sqlite_sequence:</target>
        </trans-unit>
        <trans-unit id="45d57d826d6c576b74670b2e5b7c281dbdfadbab" translate="yes" xml:space="preserve">
          <source>The sqlite_sequence table is an internal table used to help implement &lt;a href=&quot;autoinc&quot;&gt;AUTOINCREMENT&lt;/a&gt;. The sqlite_sequence table is created automatically whenever any ordinary table with an AUTOINCREMENT integer primary key is created. Once created, the sqlite_sequence table exists in the sqlite_schema table forever; it cannot be dropped. The schema for the sqlite_sequence table is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2336dfb15c81a1bc2e023f4a5ddff1cb80eb4aa" translate="yes" xml:space="preserve">
          <source>The sqlite_source_id() function returns a string that identifies the specific version of the source code that was used to build the SQLite library. The string returned by sqlite_source_id() is the date and time that the source code was checked in followed by the SHA1 hash for that check-in. This function is an SQL wrapper around the &lt;a href=&quot;c3ref/libversion&quot;&gt;sqlite3_sourceid()&lt;/a&gt; C interface.</source>
          <target state="translated">Функция sqlite_source_id () возвращает строку, которая определяет конкретную версию исходного кода, которая использовалась для создания библиотеки SQLite. Строка, возвращаемая sqlite_source_id (), представляет собой дату и время, когда исходный код был проверен, за которым следует хеш SHA1 для этой регистрации. Эта функция является оболочкой SQL для интерфейса C. &lt;a href=&quot;c3ref/libversion&quot;&gt;sqlite3_sourceid ()&lt;/a&gt; C.</target>
        </trans-unit>
        <trans-unit id="7f3f3c25482d0c81576dfc7ce696a273cc1dcba3" translate="yes" xml:space="preserve">
          <source>The sqlite_stat1 is an internal table created by the &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; command and used to hold supplemental information about tables and indexes that the query planner can use to help it find better ways of performing queries. Applications can update, delete from, insert into or drop the sqlite_stat1 table, but may not create or alter the sqlite_stat1 table. The schema of the sqlite_stat1 table is as follows:</source>
          <target state="translated">Sqlite_stat1 - это внутренняя таблица, созданная командой &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; и используемая для хранения дополнительной информации о таблицах и индексах, которую планировщик запросов может использовать для поиска лучших способов выполнения запросов. Приложения могут обновлять, удалять, вставлять или удалять таблицу sqlite_stat1, но не могут создавать или изменять таблицу sqlite_stat1. Схема таблицы sqlite_stat1 выглядит следующим образом:</target>
        </trans-unit>
        <trans-unit id="eac5f10d8bfa6fc7cd030e9acfc883c862434c99" translate="yes" xml:space="preserve">
          <source>The sqlite_stat2 entries for an index that have sqlite_stat2.sampleno between 0 and 9 inclusive are samples of the left-most key value in the index taken at evenly spaced points along the index. Let C be the number of rows in the index. Then the sampled rows are given by</source>
          <target state="translated">Записи sqlite_stat2 для индекса,имеющего sqlite_stat2.sampleno между 0 и 9 включительно,являются выборками крайнего левого значения ключа в индексе,взятого в равномерно распределенных точках вдоль индекса.Пусть C будет числом строк в индексе.Затем выборочные строки задаются</target>
        </trans-unit>
        <trans-unit id="db07f0500ccc51725e75c485f7f2868bee244cc2" translate="yes" xml:space="preserve">
          <source>The sqlite_stat2 is only created and is only used if SQLite is compiled with SQLITE_ENABLE_STAT2 and if the SQLite version number is between 3.6.18 (2009-09-11) and 3.7.8 (2011-09-19). The sqlite_stat2 table is neither read nor written by any version of SQLite before 3.6.18 nor after 3.7.8. The sqlite_stat2 table contains additional information about the distribution of keys within an index. The schema of the sqlite_stat2 table is as follows:</source>
          <target state="translated">sqlite_stat2 создается и используется только в том случае,если SQLite скомпилирован с SQLITE_ENABLE_STAT2 и номер версии SQLite находится между 3.6.18 (2009-09-11)и 3.7.8 (2011-09-19).Таблица sqlite_stat2 не читается и не записывается ни одной из версий SQLite до 3.6.18,ни после 3.7.8.Таблица sqlite_stat2 содержит дополнительную информацию о распределении ключей внутри индекса.Схема таблицы sqlite_stat2 выглядит следующим образом:</target>
        </trans-unit>
        <trans-unit id="5e0f4c3583a4ba1380f140be5cb19d805481ba5e" translate="yes" xml:space="preserve">
          <source>The sqlite_stat2.idx column and the sqlite_stat2.tbl column in each row of the sqlite_stat2 table identify an index described by that row. There are usually 10 rows in the sqlite_stat2 table for each index.</source>
          <target state="translated">Столбец sqlite_stat2.idx и столбец sqlite_stat2.tbl в каждой строке таблицы sqlite_stat2 определяют индекс,описанный этой строкой.Обычно для каждого индекса в таблице sqlite_stat2 имеется 10 строк.</target>
        </trans-unit>
        <trans-unit id="2f0561169a2bdda1f406d666ccb3f34136d53934" translate="yes" xml:space="preserve">
          <source>The sqlite_stat3 is only used if SQLite is compiled with &lt;a href=&quot;compile#enable_stat3&quot;&gt;SQLITE_ENABLE_STAT3&lt;/a&gt; or &lt;a href=&quot;compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt; and if the SQLite version number is 3.7.9 (2011-11-01) or greater. The sqlite_stat3 table is neither read nor written by any version of SQLite before 3.7.9. If the &lt;a href=&quot;compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt; compile-time option is used and the SQLite version number is 3.8.1 (2013-10-17) or greater, then sqlite_stat3 might be read but not written. The sqlite_stat3 table contains additional information about the distribution of keys within an index, information that the query planner can use to devise better and faster query algorithms. The schema of the sqlite_stat3 table is as follows:</source>
          <target state="translated">Sqlite_stat3 используется только в том случае, если SQLite скомпилирован с &lt;a href=&quot;compile#enable_stat3&quot;&gt;SQLITE_ENABLE_STAT3&lt;/a&gt; или &lt;a href=&quot;compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt; и если номер версии SQLite равен 3.7.9 (2011-11-01) или выше. Таблица sqlite_stat3 не читается и не записывается ни одной версией SQLite до 3.7.9. Если используется &lt;a href=&quot;compile#enable_stat4&quot;&gt;параметр времени&lt;/a&gt; компиляции SQLITE_ENABLE_STAT4 и номер версии SQLite равен 3.8.1 (2013-10-17) или выше, тогда sqlite_stat3 может быть прочитан, но не записан. Таблица sqlite_stat3 содержит дополнительную информацию о распределении ключей в индексе, информацию, которую планировщик запросов может использовать для разработки более эффективных и быстрых алгоритмов запросов. Схема таблицы sqlite_stat3 выглядит следующим образом:</target>
        </trans-unit>
        <trans-unit id="00890c07b6c2c2c2cdb8874e2a1b39eb7801c048" translate="yes" xml:space="preserve">
          <source>The sqlite_stat4 is a generalization of the sqlite_stat3 table. The sqlite_stat3 table provides information about the left-most column of an index whereas the sqlite_stat4 table provides information about all columns of the index.</source>
          <target state="translated">Таблица sqlite_stat4 является обобщением таблицы sqlite_stat3.Таблица sqlite_stat3 предоставляет информацию о самом левом столбце индекса,в то время как таблица sqlite_stat4 предоставляет информацию обо всех столбцах индекса.</target>
        </trans-unit>
        <trans-unit id="17be4a34aae6ba200b1b6b315d0554ec130a710a" translate="yes" xml:space="preserve">
          <source>The sqlite_stat4 is only created and is only used if SQLite is compiled with &lt;a href=&quot;compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt; and if the SQLite version number is 3.8.1 (2013-10-17) or greater. The sqlite_stat4 table is neither read nor written by any version of SQLite before 3.8.1. The sqlite_stat4 table contains additional information about the distribution of keys within an index or the distribution of keys in the primary key of a &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; table. The query planner can sometimes use the additional information in the sqlite_stat4 table to devise better and faster query algorithms. The schema of the sqlite_stat4 table is as follows:</source>
          <target state="translated">Sqlite_stat4 создается только и используется только в том случае, если SQLite скомпилирован с &lt;a href=&quot;compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt; и если номер версии SQLite равен 3.8.1 (2013-10-17) или выше. Таблица sqlite_stat4 не читается и не записывается ни одной версией SQLite до 3.8.1. Таблица sqlite_stat4 содержит дополнительную информацию о распределении ключей в индексе или распределении ключей в первичном ключе таблицы &lt;a href=&quot;withoutrowid&quot;&gt;БЕЗ ROWID&lt;/a&gt; . Планировщик запросов иногда может использовать дополнительную информацию в таблице sqlite_stat4 для разработки более эффективных и быстрых алгоритмов запросов. Схема таблицы sqlite_stat4 выглядит следующим образом:</target>
        </trans-unit>
        <trans-unit id="dc1ec4b833f86cdac2f0f4646210820d900eb53f" translate="yes" xml:space="preserve">
          <source>The sqlite_stat4.idx column holds name of the index that the row describes, or in the case of an sqlite_stat4 entry for a &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; table, the name of the table itself.</source>
          <target state="translated">Столбец sqlite_stat4.idx содержит имя индекса, который описывает строка, или, в случае записи sqlite_stat4 для таблицы &lt;a href=&quot;withoutrowid&quot;&gt;БЕЗ ROWID&lt;/a&gt; , имя самой таблицы.</target>
        </trans-unit>
        <trans-unit id="1916f53e908a81ccd0bcf17da67632c5df8295de" translate="yes" xml:space="preserve">
          <source>The sqlite_stat4.nDLt column holds a list of N integers where the K-th integer is the approximate number of entries in the index that are distinct in the first K columns and where the left-most K columns are collectively less than the left-most K columns of the sample.</source>
          <target state="translated">Столбец sqlite_stat4.nDLt содержит список N целых чисел,где K-ое целое число-это приблизительное количество записей в индексе,которые отличаются в первых K столбцах,и где крайние левые K столбцы вместе меньше крайних левых K столбцов выборки.</target>
        </trans-unit>
        <trans-unit id="dc87c0d99b695b0cfc2da2e070670a4e3020def1" translate="yes" xml:space="preserve">
          <source>The sqlite_stat4.nEq column holds a list of N integers where the K-th integer is the approximate number of entries in the index whose left-most K columns exactly match the K left-most columns of the sample.</source>
          <target state="translated">В столбце sqlite_stat4.nEq находится список N целых чисел,где K-ое число-это приблизительное количество записей в индексе,чьи крайние левые K столбцы точно совпадают с крайними левыми K столбцами выборки.</target>
        </trans-unit>
        <trans-unit id="9c81743d3d82af763c76e0a7b4201b09b9bf99f3" translate="yes" xml:space="preserve">
          <source>The sqlite_stat4.nLt column holds a list of N integers where the K-th integer is the approximate number of entries in the index whose K left-most columns are collectively less than the K left-most columns of the sample.</source>
          <target state="translated">В столбце sqlite_stat4.nLt находится список из N целых чисел,где K-е число-это приблизительное количество записей в индексе,чьи K крайних левых столбцов вместе меньше,чем K крайних левых столбцов выборки.</target>
        </trans-unit>
        <trans-unit id="d2e1c17126c7777e5bb111d59ea8156e8e7627c8" translate="yes" xml:space="preserve">
          <source>The sqlite_stat4.sample column holds a BLOB in the &lt;a href=&quot;fileformat2#record_format&quot;&gt;record format&lt;/a&gt; that encodes the indexed columns followed by the rowid for a rowid table or by the columns of the primary key for a WITHOUT ROWID table. The sqlite_stat4.sample BLOB for the WITHOUT ROWID table itself contains just the columns of the primary key. Let the number of columns encoded by the sqlite_stat4.sample blob be N. For indexes on an ordinary rowid table, N will be one more than the number of columns indexed. For indexes on WITHOUT ROWID tables, N will be the number of columns indexed plus the number of columns in the primary key. For a WITHOUT ROWID table, N will be the number of columns in the primary key.</source>
          <target state="translated">Столбец sqlite_stat4.sample содержит большой двоичный объект в &lt;a href=&quot;fileformat2#record_format&quot;&gt;формате записи,&lt;/a&gt; который кодирует индексированные столбцы, за которыми следует идентификатор строки для таблицы идентификаторов строк или столбцы первичного ключа для таблицы БЕЗ ROWID. Большой двоичный объект sqlite_stat4.sample для самой таблицы БЕЗ ROWID содержит только столбцы первичного ключа. Пусть количество столбцов, закодированных с помощью большого двоичного объекта sqlite_stat4.sample, равно N. Для индексов в обычной таблице rowid N будет на единицу больше, чем количество проиндексированных столбцов. Для индексов в таблицах БЕЗ ROWID N будет числом проиндексированных столбцов плюс количество столбцов в первичном ключе. Для таблицы БЕЗ ROWID N будет числом столбцов в первичном ключе.</target>
        </trans-unit>
        <trans-unit id="d3368a66552678e4208326d2b99cb82cd670c435" translate="yes" xml:space="preserve">
          <source>The sqlite_stat4.tbl column holds name of the table that owns the index that the row describes</source>
          <target state="translated">В столбце sqlite_stat4.tbl хранится имя таблицы,которой принадлежит индекс,описываемый в строке</target>
        </trans-unit>
        <trans-unit id="b005c74909d1b6008d9a724163e0fb64f6a832fd" translate="yes" xml:space="preserve">
          <source>The sqlite_version() function returns the version string for the SQLite library that is running. This function is an SQL wrapper around the &lt;a href=&quot;c3ref/libversion&quot;&gt;sqlite3_libversion()&lt;/a&gt; C-interface.</source>
          <target state="translated">Функция sqlite_version () возвращает строку версии для запущенной библиотеки SQLite. Эта функция является оболочкой SQL вокруг C-интерфейса &lt;a href=&quot;c3ref/libversion&quot;&gt;sqlite3_libversion ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="eeb9bf4120a8b3a5d3dfa457114e73704c247a52" translate="yes" xml:space="preserve">
          <source>The stability of the SQLite database file format and the fact that the file format is cross-platform combine to make SQLite database files an excellent choice as an &lt;a href=&quot;appfileformat&quot;&gt;Application File Format&lt;/a&gt;. The US Library Of Congress acknowledges this by listing SQLite as a &lt;a href=&quot;locrsf&quot;&gt;recommended storage format&lt;/a&gt; for long-term preservation of digital content.</source>
          <target state="translated">Стабильность формата файла базы данных SQLite и тот факт, что формат файла является кросс-платформенным, в совокупности делают файлы базы данных SQLite отличным выбором в качестве &lt;a href=&quot;appfileformat&quot;&gt;формата файла приложения&lt;/a&gt; . Библиотека Конгресса США признает это, перечисляя SQLite в качестве &lt;a href=&quot;locrsf&quot;&gt;рекомендуемого формата хранения&lt;/a&gt; для долгосрочного хранения цифрового контента.</target>
        </trans-unit>
        <trans-unit id="edcbc0ddf3b476ae82b56edb901d58f590378e61" translate="yes" xml:space="preserve">
          <source>The standard SQLite source tree contains built-in VFSes for unix and windows. Alternative VFSes can be added at start-time or run-time using the &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register()&lt;/a&gt; interface.</source>
          <target state="translated">Стандартное дерево исходного кода SQLite содержит встроенные файловые системы VFS для unix и windows. Альтернативные VFS могут быть добавлены во время запуска или выполнения с помощью интерфейса &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3afa9cfa18cab2a00e2e2667b20527102ceccaa0" translate="yes" xml:space="preserve">
          <source>The state of the computer when a database connection is first opened is shown conceptually by the diagram at the right. The area of the diagram on the extreme right (labeled &quot;Disk&quot;) represents information stored on the mass storage device. Each rectangle is a sector. The blue color represents that the sectors contain original data. The middle area is the operating systems disk cache. At the onset of our example, the cache is cold and this is represented by leaving the rectangles of the disk cache empty. The left area of the diagram shows the content of memory for the process that is using SQLite. The database connection has just been opened and no information has been read yet, so the user space is empty.</source>
          <target state="translated">Состояние компьютера при первом открытии подключения к БД концептуально показано диаграммой справа.Область диаграммы справа в крайнем углу (помеченная &quot;Диск&quot;)представляет информацию,хранящуюся на запоминающем устройстве.Каждый прямоугольник представляет собой сектор.Синим цветом показано,что сектора содержат исходные данные.Средняя область-дисковый кэш операционной системы.В начале нашего примера,кэш холодный,и это выражается в том,что прямоугольники дисковой кэш-памяти остаются пустыми.Левая область диаграммы показывает содержимое памяти для процесса,использующего SQLite.Соединение с базой данных только что было открыто и никакой информации пока не прочитано,поэтому пользовательское пространство пустое.</target>
        </trans-unit>
        <trans-unit id="c2357c705a667a06ce3b401fc40060cc2044167c" translate="yes" xml:space="preserve">
          <source>The statement above creates a new geopoly table named &quot;newtab&quot;. Every geopoly table contains a built-in integer &quot;rowid&quot; column and a &quot;_shape&quot; column that contains the polygon associated with that row of the table. The example above also defines three auxiliary data columns named &quot;a&quot;, &quot;b&quot;, and &quot;c&quot; that can store whatever additional information the application needs to associate with each polygon. If there is no need to store auxiliary information, the list of auxiliary columns can be omitted.</source>
          <target state="translated">Вышеупомянутое утверждение создает новую геополитическую таблицу под названием &quot;newtab&quot;.Каждая геополитическая таблица содержит встроенный целочисленный столбец &quot;rowid&quot; и столбец &quot;_shape&quot;,содержащий полигон,связанный с этой строкой таблицы.Пример выше также определяет три вспомогательных столбца данных с именами &quot;a&quot;,&quot;b&quot; и &quot;c&quot;,которые могут хранить любую дополнительную информацию,необходимую приложению для связи с каждым полигоном.Если нет необходимости хранить вспомогательную информацию,список вспомогательных столбцов можно опустить.</target>
        </trans-unit>
        <trans-unit id="d3ed1fe19431b8dcc87a89320be8ef338ed550ea" translate="yes" xml:space="preserve">
          <source>The statement above has three ordinary columns, &quot;a&quot; (the PRIMARY KEY), &quot;b&quot;, and &quot;c&quot;, and two generated columns &quot;d&quot; and &quot;e&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ab1aefcd821f7c6a31149043d5432c19acbdf4f" translate="yes" xml:space="preserve">
          <source>The statement above may appear syntactically incorrect to some. Refer to the section describing the &lt;a href=&quot;fts3#simple_fts_queries&quot;&gt;simple fts queries&lt;/a&gt; for an explanation.</source>
          <target state="translated">Приведенное выше утверждение может кому-то показаться синтаксически неверным. Обратитесь к разделу, описывающему &lt;a href=&quot;fts3#simple_fts_queries&quot;&gt;простые запросы fts&lt;/a&gt; для объяснения.</target>
        </trans-unit>
        <trans-unit id="ecd0da773db50485ad79c3fe0dd58ba001f98f02" translate="yes" xml:space="preserve">
          <source>The statement journal is given a randomized name, not necessarily in the same directory as the main database, and is automatically deleted at the conclusion of the transaction. The size of the statement journal is proportional to the size of the change implemented by the UPDATE or INSERT statement that caused the statement journal to be created.</source>
          <target state="translated">Журналу оператора присваивается рандомизированное имя,не обязательно в том же каталоге,что и основной БД,и автоматически удаляется при заключении сделки.Размер журнала операторов пропорционален размеру изменения,реализованного оператором UPDATE или INSERT,вызвавшего создание журнала операторов.</target>
        </trans-unit>
        <trans-unit id="abce2a89006a756ad8f25f400ff4bbb7de7fef61" translate="yes" xml:space="preserve">
          <source>The status method is basically a wrapper on the &lt;a href=&quot;c3ref/stmt_status&quot;&gt;sqlite3_stmt_status()&lt;/a&gt; C-language interface.</source>
          <target state="translated">Метод status - это, по сути, оболочка интерфейса языка C. &lt;a href=&quot;c3ref/stmt_status&quot;&gt;sqlite3_stmt_status ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c5cf163b4b04538a4fb65ca4f4e01be3e19142a2" translate="yes" xml:space="preserve">
          <source>The step function for an aggregate should always begin with a call to the &lt;a href=&quot;c3ref/aggregate_context&quot;&gt;sqlite3_aggregate_context()&lt;/a&gt; routine to fetch the persistent state of the aggregate function. On the first invocation of the step() function, the aggregate context is initialized to a block of memory that is N bytes in size, where N is the second parameter to sqlite3_aggregate_context() and that memory is zeroed. On all subsequent calls to the step() function, the same block of memory is returned. Except, sqlite3_aggregate_context() might return NULL in the case of an out-of-memory error, so aggregate functions should be prepared to deal with that case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2957b92cef7bca913b9349499bded01bd701447b" translate="yes" xml:space="preserve">
          <source>The strategy is to compile a single SQL statement using &lt;b&gt;sqlite_compile&lt;/b&gt; then invoke &lt;b&gt;sqlite_step&lt;/b&gt; multiple times, once for each row of output, and finally call &lt;b&gt;sqlite_finalize&lt;/b&gt; to clean up after the SQL has finished execution.</source>
          <target state="translated">Стратегия состоит в том, чтобы скомпилировать один оператор SQL с помощью &lt;b&gt;sqlite_compile,&lt;/b&gt; затем вызвать &lt;b&gt;sqlite_step&lt;/b&gt; несколько раз, по одному разу для каждой строки вывода и, наконец, вызвать &lt;b&gt;sqlite_finalize&lt;/b&gt; для очистки после завершения выполнения SQL.</target>
        </trans-unit>
        <trans-unit id="7809402bc982c32307d88a8090b6d47f604ca513" translate="yes" xml:space="preserve">
          <source>The string value P4 of length P1 (bytes) is stored in register P2.</source>
          <target state="translated">Строковое значение P4 длины P1 (байт)хранится в регистре P2.</target>
        </trans-unit>
        <trans-unit id="9a7f87028156aaa8a8bf754d55b553e046a12fec" translate="yes" xml:space="preserve">
          <source>The string value returned by this routine is owned and managed by the database connection. The value will be valid until the database N is &lt;a href=&quot;../lang_detach&quot;&gt;DETACH&lt;/a&gt;-ed or until the database connection closes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb38b0feb448edc668a127b1d9c6a6f2f876060a" translate="yes" xml:space="preserve">
          <source>The string value returned by this routine is owned and managed by the database connection. The value will be valid until the database N is &lt;a href=&quot;lang_detach&quot;&gt;DETACH&lt;/a&gt;-ed or until the database connection closes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="995f4878031e82187c641f145afc9d059e07a6dd" translate="yes" xml:space="preserve">
          <source>The strings returned by sqlite3_sql(P) and sqlite3_normalized_sql(P) are managed by SQLite and are automatically freed when the prepared statement is finalized. The string returned by sqlite3_expanded_sql(P), on the other hand, is obtained from &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc()&lt;/a&gt; and must be free by the application by passing it to &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free()&lt;/a&gt;.</source>
          <target state="translated">Строки, возвращаемые sqlite3_sql (P) и sqlite3_normalized_sql (P), управляются SQLite и автоматически освобождаются, когда подготовленный оператор завершается. Строка, возвращаемая sqlite3_expanded_sql (P), с другой стороны, получается из &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc ()&lt;/a&gt; и должна быть освобождена приложением, передав ее в &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6988de3a51ce0d23769efda8a1dd27ed60344374" translate="yes" xml:space="preserve">
          <source>The strings returned by sqlite3_sql(P) and sqlite3_normalized_sql(P) are managed by SQLite and are automatically freed when the prepared statement is finalized. The string returned by sqlite3_expanded_sql(P), on the other hand, is obtained from &lt;a href=&quot;free&quot;&gt;sqlite3_malloc()&lt;/a&gt; and must be free by the application by passing it to &lt;a href=&quot;free&quot;&gt;sqlite3_free()&lt;/a&gt;.</source>
          <target state="translated">Строки, возвращаемые sqlite3_sql (P) и sqlite3_normalized_sql (P), управляются SQLite и автоматически освобождаются, когда подготовленный оператор завершается. Строка, возвращаемая sqlite3_expanded_sql (P), с другой стороны, получается из &lt;a href=&quot;free&quot;&gt;sqlite3_malloc ()&lt;/a&gt; и должна быть освобождена приложением, передав ее в &lt;a href=&quot;free&quot;&gt;sqlite3_free ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3deeab5872c796defa91ce886ebd57387fbb18a8" translate="yes" xml:space="preserve">
          <source>The subquery and outer query do not both use LIMIT.</source>
          <target state="translated">В подзапросе и внешнем запросе не используется LIMIT.</target>
        </trans-unit>
        <trans-unit id="77e0e5365d2489d6a42fa705340d96f457af3864" translate="yes" xml:space="preserve">
          <source>The subquery and the outer query do not both have ORDER BY clauses.</source>
          <target state="translated">Подзапрос и внешний запрос не имеют пунктов ORDER BY.</target>
        </trans-unit>
        <trans-unit id="c18b6359aac0e334ed733af3b59f97a0357158e6" translate="yes" xml:space="preserve">
          <source>The subquery does not use LIMIT or the outer query does not use aggregates.</source>
          <target state="translated">В подзапросе не используется LIMIT или во внешнем запросе не используются агрегаты.</target>
        </trans-unit>
        <trans-unit id="b5bd1b6abc2be3885b869265a72b70231dcb2d09" translate="yes" xml:space="preserve">
          <source>The subquery does not use LIMIT or the outer query is not a join.</source>
          <target state="translated">Подзапрос не использует LIMIT или внешний запрос не является соединением.</target>
        </trans-unit>
        <trans-unit id="9a0c8ea79566123f0e4ecc1c9a70135357fff910" translate="yes" xml:space="preserve">
          <source>The subquery does not use OFFSET.</source>
          <target state="translated">В подзапросе не используется OFFSET.</target>
        </trans-unit>
        <trans-unit id="8e09a48cd0d988ee9dac8cadad6cdbfcea3b74f2" translate="yes" xml:space="preserve">
          <source>The subquery has a FROM clause.</source>
          <target state="translated">В подзапросе есть пункт FROM.</target>
        </trans-unit>
        <trans-unit id="36f95cae80ab7a78b4e298e8fc4b136f62be389f" translate="yes" xml:space="preserve">
          <source>The subquery in the FROM clause computes the amount by which the inventory should be reduced for each itemId. That subquery is joined against the inventory table and the quantity of each affected inventory row is reduced by the appropriate amount.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14960c81162a6f569b4caa226a699f43010d4c7e" translate="yes" xml:space="preserve">
          <source>The subquery is not DISTINCT.</source>
          <target state="translated">Подзапрос не DISTINCT.</target>
        </trans-unit>
        <trans-unit id="560b14fd5f0c196e23d6c05b79eac72d5d601e25" translate="yes" xml:space="preserve">
          <source>The subquery may not be a recursive CTE.</source>
          <target state="translated">Подзапрос может не быть рекурсивным CTE.</target>
        </trans-unit>
        <trans-unit id="7577bd701d8770ad9fc4050124549876822aa978" translate="yes" xml:space="preserve">
          <source>The substitute character (unicode codepoint 26).</source>
          <target state="translated">Символ подстановки (кодовый юникод 26).</target>
        </trans-unit>
        <trans-unit id="1b25cfaa2f051cde5a374dd5fbd3d25bcae8f82b" translate="yes" xml:space="preserve">
          <source>The substr() function in the SQL view above returns the text of the rbu_control argument with the first character (the one corresponding to column &quot;i&quot;, which is not required by the FTS table) removed.</source>
          <target state="translated">Функция substr()в SQL-виде выше возвращает текст аргумента rbu_control с удаленным первым символом (символ,соответствующий столбцу &quot;i&quot;,который не требуется таблицей FTS).</target>
        </trans-unit>
        <trans-unit id="1eb749257ff54f4f9f61b55605ad1eef34135ccf" translate="yes" xml:space="preserve">
          <source>The substr(X,Y,Z) function returns a substring of input string X that begins with the Y-th character and which is Z characters long. If Z is omitted then substr(X,Y) returns all characters through the end of the string X beginning with the Y-th. The left-most character of X is number 1. If Y is negative then the first character of the substring is found by counting from the right rather than the left. If Z is negative then the abs(Z) characters preceding the Y-th character are returned. If X is a string then characters indices refer to actual UTF-8 characters. If X is a BLOB then the indices refer to bytes.</source>
          <target state="translated">Функция подстроки(X,Y,Z)возвращает подстроку входной строки X,которая начинается с Y-символа и имеет длину Z символов.Если Z опущена,то функция substr(X,Y,Y)возвращает все символы через конец строки X,начинающийся с Y-ого символа.Самый левый символ X-номер 1.Если Y отрицательный,то первый символ подстроки будет найден путем подсчета справа,а не слева.Если Z отрицательный,то возвращаются абс(Z)символы,предшествующие Y-му символу.Если X-строка,то символьные индексы относятся к действительным символам UTF-8.Если X-BLOB,то индексы относятся к байтам.</target>
        </trans-unit>
        <trans-unit id="8f8f72577e48839e2c6e724a5bcfafdf7566b512" translate="yes" xml:space="preserve">
          <source>The sum of all &quot;four&quot; values. This is used to compute &quot;avg(four)&quot;.</source>
          <target state="translated">Сумма всех &quot;четырех&quot; значений.Это используется для вычисления &quot;avg(четыре)&quot;.</target>
        </trans-unit>
        <trans-unit id="4a5f1cfa6e3d0c304a8016c9b0a8f3f6f7afd998" translate="yes" xml:space="preserve">
          <source>The sum() and total() aggregate functions return sum of all non-NULL values in the group. If there are no non-NULL input rows then sum() returns NULL but total() returns 0.0. NULL is not normally a helpful result for the sum of no rows but the SQL standard requires it and most other SQL database engines implement sum() that way so SQLite does it in the same way in order to be compatible. The non-standard total() function is provided as a convenient way to work around this design problem in the SQL language.</source>
          <target state="translated">Функции sum()и total()агрегата возвращают сумму всех не нулевых значений в группе.Если нет не нулевых входных строк,то функция sum()возвращает NULL,но total()возвращает 0.0.Обычно NULL не является полезным результатом для суммы без строк,но стандарт SQL требует этого,и большинство других движков баз данных SQL реализуют sum()таким образом,чтобы SQLite делал это таким же образом,чтобы быть совместимым.Нестандартная функция total()предусмотрена в качестве удобного способа обойти эту проблему проектирования на языке SQL.</target>
        </trans-unit>
        <trans-unit id="c8cc59294c9d81aba99fd5de24fb6dc6b41b0132" translate="yes" xml:space="preserve">
          <source>The super-journal file is only created for &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; operations that involve multiple database files where at least two of the databases meet all of the following requirements:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ee67fa1e83c36dfa202c1d70aacf19927252737" translate="yes" xml:space="preserve">
          <source>The super-journal file is used as part of the atomic commit process when a single transaction makes changes to multiple databases that have been added to a single &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; using the &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; statement. The super-journal file is always located in the same directory as the main database file (the main database file is the database that is identified in the original &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open16()&lt;/a&gt;, or &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; call that created the &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt;) with a randomized suffix. The super-journal file contains the names of all of the various attached auxiliary databases that were changed during the transaction. The multi-database transaction commits when the super-journal file is deleted. See the documentation titled &lt;a href=&quot;atomiccommit&quot;&gt;Atomic Commit In SQLite&lt;/a&gt; for additional detail.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b11b2e43da7a9faed114feb7f008a51dec0a5a77" translate="yes" xml:space="preserve">
          <source>The suppression of redundant columns in the key suffix of an index entry only occurs in WITHOUT ROWID tables. In an ordinary rowid table, the index entry always ends with the rowid even if the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; column is one of the columns being indexed.</source>
          <target state="translated">Подавление избыточных столбцов в ключевом суффиксе записи индекса происходит только в таблицах БЕЗ ROWID. В обычной таблице rowid запись индекса всегда заканчивается rowid, даже если столбец &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; является одним из индексируемых столбцов.</target>
        </trans-unit>
        <trans-unit id="2572ed867faedb74714d50c5898bcb75f0754e78" translate="yes" xml:space="preserve">
          <source>The swarmvtab implementation may open or close databases at any point. By default, it attempts to limit the maximum number of simultaneously open database files to nine. This is not a hard limit - it is possible to construct a scenario that will cause swarmvtab to exceed it.</source>
          <target state="translated">Реализация swarmvtab может открыть или закрыть базы данных в любой момент.По умолчанию она пытается ограничить максимальное количество одновременно открытых файлов БД девятью.Это не жесткое ограничение-можно построить сценарий,при котором swarmvtab превысит его.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
