<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="sqlite">
    <body>
      <group id="sqlite">
        <trans-unit id="9f9e99aa51f888cdf6630598d938ef39ae15f9a3" translate="yes" xml:space="preserve">
          <source>The sync operations that SQLite performs to help ensure integrity can be disabled at run-time using the &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;synchronous pragma&lt;/a&gt;. By setting PRAGMA synchronous=OFF, all sync operations are omitted. This makes SQLite seem to run faster, but it also allows the operating system to freely reorder writes, which could result in database corruption if a power failure or hard reset occurs prior to all content reaching persistent storage.</source>
          <target state="translated">Операции синхронизации, выполняемые SQLite для обеспечения целостности, можно отключить во время выполнения с помощью &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;прагмы synchronous&lt;/a&gt; . При установке PRAGMA synchronous = OFF все операции синхронизации опускаются. Это заставляет SQLite работать быстрее, но также позволяет операционной системе свободно переупорядочивать записи, что может привести к повреждению базы данных, если сбой питания или полный сброс произойдет до того, как весь контент попадет в постоянное хранилище.</target>
        </trans-unit>
        <trans-unit id="8ed0f1cf6ef82d0d97320ed63cceee25b526aa88" translate="yes" xml:space="preserve">
          <source>The synchronous version of SQLite is the slowest of the group in this test, but the asynchronous version is the fastest. The difference is the extra time needed to execute fsync().</source>
          <target state="translated">Синхронная версия SQLite-самая медленная из группы в данном тесте,но асинхронная-самая быстрая.Разница заключается в дополнительном времени,необходимом для выполнения fsync().</target>
        </trans-unit>
        <trans-unit id="88535ccaca4588c188d3dec59b74e5b6c648c437" translate="yes" xml:space="preserve">
          <source>The syntax for a window function is like this:</source>
          <target state="translated">Синтаксис для оконной функции такой:</target>
        </trans-unit>
        <trans-unit id="e97f2e6030323368e9626fb51e9e8ff6dc7c7f0a" translate="yes" xml:space="preserve">
          <source>The syntax for integer and floating point literals (collectively &quot;numeric literals&quot;) is shown by the following diagram:</source>
          <target state="translated">Синтаксис целых и плавающих литералов (вместе &quot;числовые литералы&quot;)показан на следующей диаграмме:</target>
        </trans-unit>
        <trans-unit id="c1140f24a0825da092ba683013464dc50c75b952" translate="yes" xml:space="preserve">
          <source>The syntax for row values and the circumstances in which row values can be used are illustrated in examples below.</source>
          <target state="translated">Синтаксис значений рядов и обстоятельства,при которых значения рядов могут быть использованы,проиллюстрированы в примерах ниже.</target>
        </trans-unit>
        <trans-unit id="0601104dedcf396efbb0c30203a6d31fd40a4a67" translate="yes" xml:space="preserve">
          <source>The syntax for the ON CONFLICT clause is as shown above for the CREATE TABLE command. For the INSERT and UPDATE commands, the keywords &quot;ON CONFLICT&quot; are replaced by &quot;OR&quot; so that the syntax reads more naturally. For example, instead of &quot;INSERT ON CONFLICT IGNORE&quot; we have &quot;INSERT OR IGNORE&quot;. The keywords change but the meaning of the clause is the same either way.</source>
          <target state="translated">Синтаксис пункта ON CONFLICT выглядит так,как показано выше для команды CREATE TABLE.Для команд INSERT и UPDATE ключевые слова &quot;ON CONFLICT&quot; заменены на &quot;OR&quot;,чтобы синтаксис читался более естественно.Например,вместо &quot;INSERT ON CONFLICT IGNORE&quot; мы имеем &quot;INSERT OR IGNORE&quot;.Ключевые слова меняются,но значение пункта в любом случае одинаково.</target>
        </trans-unit>
        <trans-unit id="f067d61a53dcb338fdf63bf3df528ef6a0487e73" translate="yes" xml:space="preserve">
          <source>The syntax looks like this:</source>
          <target state="translated">Синтаксис выглядит так:</target>
        </trans-unit>
        <trans-unit id="a61a22c417283e11aa14f2ba9ecd8cd0c90ce62d" translate="yes" xml:space="preserve">
          <source>The syntax of the &lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt;, &lt;a href=&quot;lang_dropindex&quot;&gt;DROP INDEX&lt;/a&gt;, &lt;a href=&quot;lang_dropview&quot;&gt;DROP VIEW&lt;/a&gt;, &lt;a href=&quot;lang_droptrigger&quot;&gt;DROP TRIGGER&lt;/a&gt;, &lt;a href=&quot;lang_reindex&quot;&gt;REINDEX&lt;/a&gt;, &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE&lt;/a&gt; and many other commands all permit the user to specify a database object either by its name alone, or by a combination of its name and the name of its database. If no database is specified as part of the object reference, then SQLite searches the main, temp and all attached databases for an object with a matching name. The temp database is searched first, followed by the main database, followed all attached databases in the order that they were attached. The reference resolves to the first match found. For example:</source>
          <target state="translated">Синтаксис команд &lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt; , &lt;a href=&quot;lang_dropindex&quot;&gt;DROP INDEX&lt;/a&gt; , &lt;a href=&quot;lang_dropview&quot;&gt;DROP VIEW&lt;/a&gt; , &lt;a href=&quot;lang_droptrigger&quot;&gt;DROP TRIGGER&lt;/a&gt; , &lt;a href=&quot;lang_reindex&quot;&gt;REINDEX&lt;/a&gt; , &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE&lt;/a&gt; и многих других команд позволяет пользователю указать объект базы данных либо только по его имени, либо по комбинации его имени и имени свою базу данных. Если база данных не указана как часть ссылки на объект, SQLite ищет в основной, временной и всех подключенных базах данных объект с совпадающим именем. Сначала ищется временная база данных, затем основная база данных, а затем все присоединенные базы данных в том порядке, в котором они были присоединены. Ссылка преобразуется в первое найденное совпадение. Например:</target>
        </trans-unit>
        <trans-unit id="070a4a12a4cd8479f973f088343e30dee884b914" translate="yes" xml:space="preserve">
          <source>The syntax that occurs in between the &quot;ON CONFLICT&quot; and &quot;DO&quot; keywords is called the &quot;conflict target&quot;. The conflict target specifies a specific uniqueness constraint that will trigger the upsert. The conflict target is required for DO UPDATE upserts, but is optional for DO NOTHING. When the conflict target is omitted, the upsert behavior is triggered by a violation of any uniqueness constraint on the table of the INSERT.</source>
          <target state="translated">Синтаксис,возникающий между ключевыми словами &quot;ON CONFLICT&quot; и &quot;DO&quot;,называется &quot;конфликтной целью&quot;.Конфликтная цель задает специфическое ограничение уникальности,которое спровоцирует взлет.Конфликтная цель необходима для поднятия DO UPDATE,но необязательна для DO NOTHING.Когда конфликтная цель опущена,поведение выпадения вызывается нарушением любого ограничения уникальности на таблице INSERT.</target>
        </trans-unit>
        <trans-unit id="6578fb33b7ba1ef0fa58c80688a069c9340aa258" translate="yes" xml:space="preserve">
          <source>The szOsFile field is the size in bytes of the structure that defines an open file: the &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; object. This object will be described more fully below. The point here is that each VFS implementation can define its own &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; object containing whatever information the VFS implementation needs to store about an open file. SQLite needs to know how big this object is, however, in order to preallocate enough space to hold it.</source>
          <target state="translated">Поле szOsFile - это размер в байтах структуры, которая определяет открытый файл: объект &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; . Более подробно этот объект будет описан ниже. Дело в том, что каждая реализация VFS может определять свой собственный объект &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file,&lt;/a&gt; содержащий любую информацию, которую реализация VFS должна хранить об открытом файле. Однако SQLite необходимо знать, насколько велик этот объект, чтобы предварительно выделить достаточно места для его хранения.</target>
        </trans-unit>
        <trans-unit id="4160b3968588675d955230ce2bf92a9066be0932" translate="yes" xml:space="preserve">
          <source>The szOsFile field is the size of the subclassed &lt;a href=&quot;#sqlite3_file&quot;&gt;sqlite3_file&lt;/a&gt; structure used by this VFS. mxPathname is the maximum length of a pathname in this VFS.</source>
          <target state="translated">Поле szOsFile - это размер подклассовой структуры &lt;a href=&quot;#sqlite3_file&quot;&gt;sqlite3_file,&lt;/a&gt; используемой этой VFS. mxPathname - максимальная длина пути в этой VFS.</target>
        </trans-unit>
        <trans-unit id="0c08ad2486a604361da59adedd8095e01f05af8a" translate="yes" xml:space="preserve">
          <source>The szOsFile field is the size of the subclassed &lt;a href=&quot;file&quot;&gt;sqlite3_file&lt;/a&gt; structure used by this VFS. mxPathname is the maximum length of a pathname in this VFS.</source>
          <target state="translated">Поле szOsFile - это размер подклассовой структуры &lt;a href=&quot;file&quot;&gt;sqlite3_file,&lt;/a&gt; используемой этой VFS. mxPathname - максимальная длина пути в этой VFS.</target>
        </trans-unit>
        <trans-unit id="34b2e05f8be89f8919f89034a92c2255013098b0" translate="yes" xml:space="preserve">
          <source>The t2 table is completely unused in the query above, and so the query planner is able to implement the query as if it were written:</source>
          <target state="translated">Таблица t2 полностью не используется в вышеуказанном запросе,поэтому планировщик запросов может реализовать запрос так,как если бы он был записан:</target>
        </trans-unit>
        <trans-unit id="4238f21507c2ee050a84b88e1b8452b278b7cbd3" translate="yes" xml:space="preserve">
          <source>The table &quot;t1&quot; has four columns &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, and &quot;d&quot; that have no particular datatype assigned. You can store anything you want in any of those columns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69666453d6f0a7ffe136a772a15ed97e78f29762" translate="yes" xml:space="preserve">
          <source>The table being clear is in the main database file if P2==0. If P2==1 then the table to be clear is in the auxiliary database file that is used to store tables create using CREATE TEMPORARY TABLE.</source>
          <target state="translated">Очищаемая таблица находится в основном файле БД,если P2==0.Если P2==1,то очищаемая таблица находится во вспомогательном файле БД,который используется для хранения таблиц,создаваемых с помощью CREATE TEMPORARY TABLE.</target>
        </trans-unit>
        <trans-unit id="b84cc68d91e3409f1edcdf58fc339f372294c1e2" translate="yes" xml:space="preserve">
          <source>The table being destroyed is in the main database file if P3==0. If P3==1 then the table to be clear is in the auxiliary database file that is used to store tables create using CREATE TEMPORARY TABLE.</source>
          <target state="translated">Уничтожаемая таблица находится в основном файле БД,если P3==0.Если P3==1,то очищаемая таблица находится во вспомогательном файле БД,который используется для хранения таблиц,создаваемых с помощью CREATE TEMPORARY TABLE.</target>
        </trans-unit>
        <trans-unit id="41f345ab868d88acd8992e4784839c2d5c1e8639" translate="yes" xml:space="preserve">
          <source>The table below lists a few of the virtual tables implementations available for SQLite. Developers can deploy these virtual tables in their own applications, or use the implementations shown below as templates for writing their own virtual tables.</source>
          <target state="translated">В таблице ниже перечислены некоторые из реализаций виртуальных таблиц,доступных для SQLite.Разработчики могут развернуть эти виртуальные таблицы в своих приложениях или использовать реализации,показанные ниже,в качестве шаблонов для написания собственных виртуальных таблиц.</target>
        </trans-unit>
        <trans-unit id="0d5035ee89279b64afd0eeb8d11272d1a3924472" translate="yes" xml:space="preserve">
          <source>The table conceptually has a number of rows and columns. But these numbers are not part of the result table itself. These numbers are obtained separately. Let N be the number of rows and M be the number of columns.</source>
          <target state="translated">Таблица концептуально имеет ряд строк и столбцов.Но эти числа не являются частью самой таблицы результатов.Эти номера получены отдельно.Пусть N будет числом строк,а M-числом столбцов.</target>
        </trans-unit>
        <trans-unit id="dcf57858fad384bb52da74fd124071a651012ac9" translate="yes" xml:space="preserve">
          <source>The table has at least as many columns as recorded in the changeset, and</source>
          <target state="translated">В таблице есть как минимум столько же столбцов,сколько было записано в changeset,и</target>
        </trans-unit>
        <trans-unit id="c59c86844961ecda887187879536aa8941add7f6" translate="yes" xml:space="preserve">
          <source>The table has primary key columns in the same position as recorded in the changeset.</source>
          <target state="translated">Таблица имеет колонки с первичными ключами в той же позиции,что и записанная в changeset.</target>
        </trans-unit>
        <trans-unit id="80f1ee5eb53df523cde7e4859fa53a41bb0e9f57" translate="yes" xml:space="preserve">
          <source>The table has the same name as the name recorded in the changeset, and</source>
          <target state="translated">Таблица имеет то же имя,что и имя,записанное в changeset,и</target>
        </trans-unit>
        <trans-unit id="7d27b581c3631a8cd2d37de114b2996daa06d034" translate="yes" xml:space="preserve">
          <source>The table named in the table_info pragma can also be a view.</source>
          <target state="translated">Таблица,названная в прагме table_info,также может быть представлением.</target>
        </trans-unit>
        <trans-unit id="79bd6ebb5ebe8eca1811d6164c483996ae2dbb59" translate="yes" xml:space="preserve">
          <source>The table named on the left-hand side of the AS keyword must appear exactly once in the FROM clause of the right-most SELECT statement of the compound select, and nowhere else.</source>
          <target state="translated">Таблица,названная с левой стороны ключевого слова AS,должна появиться ровно один раз в пункте FROM крайнего правого оператора SELECT составного селекции,и больше нигде.</target>
        </trans-unit>
        <trans-unit id="747fb24ebf8caf800f314099b86fad330ec2bb21" translate="yes" xml:space="preserve">
          <source>The table that is being changed</source>
          <target state="translated">Таблица,которая меняется</target>
        </trans-unit>
        <trans-unit id="e089550b926c62bbc2dcb5b20ca60a982f76e723" translate="yes" xml:space="preserve">
          <source>The table-name specified as part of a DELETE statement within a trigger body must be unqualified. In other words, the</source>
          <target state="translated">Название таблицы,указанное как часть заявления об УДАЛЕНИИ внутри тела триггера,должно быть безоговорочным.Другими словами,</target>
        </trans-unit>
        <trans-unit id="f34e54cb0abeaba37df0e01490317583d5a035fb" translate="yes" xml:space="preserve">
          <source>The table-name specified as part of an UPDATE statement within a trigger body must be unqualified. In other words, the</source>
          <target state="translated">Название таблицы,указанное как часть заявления UPDATE в теле триггера,должно быть безоговорочным.Другими словами</target>
        </trans-unit>
        <trans-unit id="234e68825ade4fb4c6a3d0e2fe2ac2487e1f2eea" translate="yes" xml:space="preserve">
          <source>The table-valued function returns one row for each record (file, directory or symbolic link) in the zip archive. Each row has the following columns:</source>
          <target state="translated">Функция табличного значения возвращает по одной строке для каждой записи (файла,каталога или символической ссылки)в zip-архиве.Каждая строка имеет следующие столбцы:</target>
        </trans-unit>
        <trans-unit id="d7dc1f7c6b1a5d93554b66158b8eab41e9fa0f02" translate="yes" xml:space="preserve">
          <source>The table-valued function syntax may also be used to specify an alternative ranking function. In this case the text describing the ranking function should be specified as the second table-valued function argument. The following three queries are equivalent:</source>
          <target state="translated">Синтаксис функции табличных значений может также использоваться для указания альтернативной функции ранжирования.В этом случае текст,описывающий рейтинговую функцию,должен быть указан в качестве второго аргумента таблично-значимой функции.Следующие три запроса эквивалентны:</target>
        </trans-unit>
        <trans-unit id="194c5b8001842ee44aaaa2c4539d9e178d7c37bd" translate="yes" xml:space="preserve">
          <source>The table-valued functions for PRAGMA feature was added in SQLite version 3.16.0 (2017-01-02). Prior versions of SQLite cannot use this feature.</source>
          <target state="translated">В SQLite версии 3.16.0 (2017-01-02)добавлены табличные функции для функции PRAGMA.Предыдущие версии SQLite не могли использовать эту функцию.</target>
        </trans-unit>
        <trans-unit id="273bdbb137f334009fcac2c6deba9c8d09edc07d" translate="yes" xml:space="preserve">
          <source>The tableZ table has a single column named &quot;INTEGER&quot;. That column has no datatype specified, but it is the PRIMARY KEY. The column is &lt;em&gt;not&lt;/em&gt; the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; for the table because it has no datatype. The &quot;INTEGER&quot; token is used as an identifier for the column name, not as a datatype keyword.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1296ca23d366e0c8b6ad53b34a86a007a9e6fcba" translate="yes" xml:space="preserve">
          <source>The tables necessary to do full and proper unicode case folding are larger than the whole SQLite library.</source>
          <target state="translated">Таблицы,необходимые для полного и правильного юникодного сгибания корпуса,больше,чем вся библиотека SQLite.</target>
        </trans-unit>
        <trans-unit id="1fa68f636ed5379e184e8d386d825c36877f4a63" translate="yes" xml:space="preserve">
          <source>The tables that participate in a union-vtab can be in the same database file, or they can be in separate databases files that are &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt;-ed to the same database connection.</source>
          <target state="translated">Таблицы, участвующие в union-vtab, могут находиться в одном файле базы данных или в отдельных файлах базы данных, которые &lt;a href=&quot;lang_attach&quot;&gt;прикреплены&lt;/a&gt; к одному и тому же соединению с базой данных.</target>
        </trans-unit>
        <trans-unit id="0d9a0645c34c7b267a5cc6a578129314b8359efc" translate="yes" xml:space="preserve">
          <source>The tables_used table is intended to show which btrees of the database file are read or written by a prepared statement, both by the main statement itself but also by related triggers and foreign key actions. The columns are as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30590c6f42ddca035bfcfa04a6fd54a5c5428cad" translate="yes" xml:space="preserve">
          <source>The target database may already contain a row with the same PRIMARY KEY values as specified by the INSERT change.</source>
          <target state="translated">Целевая база данных может уже содержать строку с теми же значениями PRIMARY KEY,которые указаны изменением INSERT.</target>
        </trans-unit>
        <trans-unit id="ddffb3a24b55dea30b114ff8f89840fe90c8c752" translate="yes" xml:space="preserve">
          <source>The target database may contain a row with the specified PRIMARY KEY values, but the current values of the fields that will be modified by the change may not match the original values stored within the changeset. This type of conflict is not detected when using a patchset.</source>
          <target state="translated">Целевая база данных может содержать строку с указанными значениями PRIMARY KEY,однако текущие значения полей,которые будут изменены в результате изменения,могут не совпадать с исходными значениями,сохраненными в changeset.Этот тип конфликта не обнаруживается при использовании патчсета.</target>
        </trans-unit>
        <trans-unit id="9637f3da3aa12d5bcfe7a6adc7e68c320df396f3" translate="yes" xml:space="preserve">
          <source>The target database may contain a row with the specified PRIMARY KEY values, but the other fields may contain values that do not match those stored as part of the changeset. This type of conflict is not detected when using a patchset.</source>
          <target state="translated">Целевая база данных может содержать строку с указанными значениями PRIMARY KEY,но другие поля могут содержать значения,не совпадающие со значениями,сохраненными в changeset.Этот тип конфликта не обнаруживается при использовании набора патчей.</target>
        </trans-unit>
        <trans-unit id="11c37f0367cfc6691a61d3fba7a936ab62a7d348" translate="yes" xml:space="preserve">
          <source>The target database may contain no row with the specified PRIMARY KEY values to delete.</source>
          <target state="translated">Целевая база данных может не содержать строк с указанными для удаления значениями PRIMARY KEY.</target>
        </trans-unit>
        <trans-unit id="e2b06a833985a4c35aa0208799ae843a7b65a575" translate="yes" xml:space="preserve">
          <source>The target database may contain no row with the specified PRIMARY KEY values to modify.</source>
          <target state="translated">Целевая база данных может не содержать строк с заданными значениями PRIMARY KEY для изменения.</target>
        </trans-unit>
        <trans-unit id="6f87cac991eff302d9976172f7bdf73e926bb9c2" translate="yes" xml:space="preserve">
          <source>The target database may not be in &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt;.</source>
          <target state="translated">Целевая база данных может быть не в &lt;a href=&quot;wal&quot;&gt;режиме WAL&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e79db16e64c18b69803344025e269d729d3745a5" translate="yes" xml:space="preserve">
          <source>The target table is not included in the FROM clause, unless the intent is to do a self-join against the target table. In the event of a self-join, the table in the FROM clause must be aliased to a different name than the target table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="711e958f26b3fdef5ca444454f4ee0f963fc86d6" translate="yes" xml:space="preserve">
          <source>The task of the &quot;query planner&quot; is to figure out the best algorithm or &quot;query plan&quot; to accomplish an SQL statement. Beginning with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_0.html&quot;&gt;version 3.8.0&lt;/a&gt; (2013-08-26), the query planner component has been rewritten so that it runs faster and generates better plans. The rewrite is called the &quot;next generation query planner&quot; or &quot;NGQP&quot;.</source>
          <target state="translated">Задача &amp;laquo;планировщика запросов&amp;raquo; - выяснить лучший алгоритм или &amp;laquo;план запроса&amp;raquo; для выполнения оператора SQL. Начиная с &lt;a href=&quot;https://sqlite.org/releaselog/3_8_0.html&quot;&gt;версии&lt;/a&gt; SQLite 3.8.0 (2013-08-26), компонент планировщика запросов был переписан, чтобы он работал быстрее и генерировал лучшие планы. Перезапись называется &amp;laquo;планировщик запросов следующего поколения&amp;raquo; или &amp;laquo;NGQP&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="42a7ae31a25e761d6c699099d742c17f30af41a6" translate="yes" xml:space="preserve">
          <source>The team_id field cannot be unique because there usually multiple people on the same team. One cannot make the combination of team_id and is_team_leader unique since there are usually multiple non-leaders on each team. The solution to enforcing one leader per team is to create a unique index on team_id but restricted to those entries for which is_team_leader is true:</source>
          <target state="translated">Поле team_id не может быть уникальным,потому что обычно в одной команде несколько человек.Нельзя сделать уникальной комбинацию team_id и is_team_leader,так как в каждой команде обычно несколько нелидеров.Решение по введению в действие одного лидера в каждой команде заключается в создании уникального индекса на идентификаторе_команды,но только для тех записей,для которых значение_team_leader равно true:</target>
        </trans-unit>
        <trans-unit id="0785e2dbbfabdba0d3916b209d305b3e5683f44f" translate="yes" xml:space="preserve">
          <source>The technique of having xFindFunction() return values of &lt;a href=&quot;c3ref/c_index_constraint_eq&quot;&gt;SQLITE_INDEX_CONSTRAINT_FUNCTION&lt;/a&gt; was initially used in the implementation of the &lt;a href=&quot;geopoly&quot;&gt;Geopoly module&lt;/a&gt;. The xFindFunction() method of that module returns SQLITE_INDEX_CONSTRAINT_FUNCTION for the &lt;a href=&quot;geopoly#goverlap&quot;&gt;geopoly_overlap()&lt;/a&gt; SQL function and it returns SQLITE_INDEX_CONSTRAINT_FUNCTION+1 for the &lt;a href=&quot;geopoly#gwithin&quot;&gt;geopoly_within()&lt;/a&gt; SQL function. This permits search optimizations for queries such as:</source>
          <target state="translated">Методика возврата xFindFunction () значений &lt;a href=&quot;c3ref/c_index_constraint_eq&quot;&gt;SQLITE_INDEX_CONSTRAINT_FUNCTION&lt;/a&gt; изначально использовалась при реализации &lt;a href=&quot;geopoly&quot;&gt;модуля Geopoly&lt;/a&gt; . Метод xFindFunction () этого модуля возвращает SQLITE_INDEX_CONSTRAINT_FUNCTION для функции SQL &lt;a href=&quot;geopoly#goverlap&quot;&gt;geopoly_overlap ()&lt;/a&gt; и возвращает SQLITE_INDEX_CONSTRAINT_FUNCTION + 1 для функции SQL &lt;a href=&quot;geopoly#gwithin&quot;&gt;geopoly_within ()&lt;/a&gt; . Это позволяет оптимизировать поиск по таким запросам, как:</target>
        </trans-unit>
        <trans-unit id="2710792de033b547bac6e441ea1f9b9d8e9fc431" translate="yes" xml:space="preserve">
          <source>The temp.sqlite_parameters table only provides values for parameters in the command-line shell. The temp.sqlite_parameter table has no effect on queries that are run directly using the SQLite C-language API. Individual applications are expected to implement their own parameter binding. You can search for &quot;sqlite_parameters&quot; in the &lt;a href=&quot;https://sqlite.org/src/file/src/shell.c.in&quot;&gt;command-line shell source code&lt;/a&gt; to see how the command-line shell does parameter binding, and use that as a hint for how to implement it yourself.</source>
          <target state="translated">Таблица temp.sqlite_parameters предоставляет значения только для параметров в оболочке командной строки. Таблица temp.sqlite_parameter не влияет на запросы, которые выполняются напрямую с помощью SQLite C-language API. Ожидается, что отдельные приложения будут реализовывать свои собственные привязки параметров. Вы можете найти &amp;laquo;sqlite_parameters&amp;raquo; в &lt;a href=&quot;https://sqlite.org/src/file/src/shell.c.in&quot;&gt;исходном коде оболочки командной строки,&lt;/a&gt; чтобы увидеть, как оболочка командной строки выполняет привязку параметров, и использовать это как подсказку о том, как реализовать это самостоятельно.</target>
        </trans-unit>
        <trans-unit id="e0243e43a9e092811e1870e88e873ed47024b50d" translate="yes" xml:space="preserve">
          <source>The temporary file created by the &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; command exists only for the duration of the command itself. The size of the temporary file will be no larger than the original database.</source>
          <target state="translated">Временный файл, созданный командой &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM,&lt;/a&gt; существует только на время действия самой команды. Размер временного файла не будет больше размера исходной базы данных.</target>
        </trans-unit>
        <trans-unit id="2f2df5fab6b729ca7d2c3e78798e53760ca0b74f" translate="yes" xml:space="preserve">
          <source>The temporary files associated with the TEMP database and its rollback journal are only created if the application makes use of the &quot;CREATE TEMP TABLE&quot; statement.</source>
          <target state="translated">Временные файлы,связанные с базой данных TEMP и ее журналом отката,создаются только в том случае,если приложение использует оператор &quot;CREATE TEMP TABLE&quot;.</target>
        </trans-unit>
        <trans-unit id="f07c39bdad21f0453b3d046fa930925221ebb2c1" translate="yes" xml:space="preserve">
          <source>The temporary files associated with transaction control, namely the rollback journal, master journal, write-ahead log (WAL) files, and shared-memory files, are always written to disk. But the other kinds of temporary files might be stored in memory only and never written to disk. Whether or not temporary files other than the rollback, master, and statement journals are written to disk or stored only in memory depends on the &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; compile-time parameter, the &lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;temp_store pragma&lt;/a&gt;, and on the size of the temporary file.</source>
          <target state="translated">Временные файлы, связанные с управлением транзакциями, а именно журнал отката, главный журнал, файлы журнала упреждающей записи (WAL) и файлы совместно используемой памяти, всегда записываются на диск. Но другие типы временных файлов могут храниться только в памяти и никогда не записываться на диск. Записываются ли временные файлы, отличные от журналов отката, главного журнала и операторов, на диск или хранятся только в памяти, зависит от параметра &lt;a href=&quot;compile#temp_store&quot;&gt;времени&lt;/a&gt; компиляции SQLITE_TEMP_STORE , &lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;прагмы temp_store&lt;/a&gt; и от размера временного файла.</target>
        </trans-unit>
        <trans-unit id="408ca6d25d3ec064e51ba766d2fa74811ccbfcc3" translate="yes" xml:space="preserve">
          <source>The temporary files associated with transaction control, namely the rollback journal, super-journal, write-ahead log (WAL) files, and shared-memory files, are always written to disk. But the other kinds of temporary files might be stored in memory only and never written to disk. Whether or not temporary files other than the rollback, super, and statement journals are written to disk or stored only in memory depends on the &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; compile-time parameter, the &lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;temp_store pragma&lt;/a&gt;, and on the size of the temporary file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42ee5d948678f086d276ab61d7dad5de2797f6e5" translate="yes" xml:space="preserve">
          <source>The term number of the matching term within the full-text query expression. Terms within a query expression are numbered starting from 0 in the order that they occur.</source>
          <target state="translated">Номер совпадающего члена в выражении полнотекстового запроса.Термины в выражении запроса нумеруются,начиная с 0,в порядке их появления.</target>
        </trans-unit>
        <trans-unit id="2146ad4958dfdca7b01896ef7e97e3c556f6bfc0" translate="yes" xml:space="preserve">
          <source>The term, as stored in the FTS5 index.</source>
          <target state="translated">Термин,хранящийся в индексе FTS5.</target>
        </trans-unit>
        <trans-unit id="efaf8ed4fd273fae5234c31a87ca20e1f921ce05" translate="yes" xml:space="preserve">
          <source>The terms &quot;protected&quot; and &quot;unprotected&quot; refer to whether or not a mutex is held. An internal mutex is held for a protected sqlite3_value object but no mutex is held for an unprotected sqlite3_value object. If SQLite is compiled to be single-threaded (with &lt;a href=&quot;../compile#threadsafe&quot;&gt;SQLITE_THREADSAFE=0&lt;/a&gt; and with &lt;a href=&quot;threadsafe&quot;&gt;sqlite3_threadsafe()&lt;/a&gt; returning 0) or if SQLite is run in one of reduced mutex modes &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigsinglethread&quot;&gt;SQLITE_CONFIG_SINGLETHREAD&lt;/a&gt; or &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigmultithread&quot;&gt;SQLITE_CONFIG_MULTITHREAD&lt;/a&gt; then there is no distinction between protected and unprotected sqlite3_value objects and they can be used interchangeably. However, for maximum code portability it is recommended that applications still make the distinction between protected and unprotected sqlite3_value objects even when not strictly required.</source>
          <target state="translated">Термины &amp;laquo;защищенный&amp;raquo; и &amp;laquo;незащищенный&amp;raquo; относятся к тому, удерживается ли мьютекс. Внутренний мьютекс сохраняется для защищенного объекта sqlite3_value, но не сохраняется мьютекс для незащищенного объекта sqlite3_value. Если SQLite скомпилирован как однопоточный (с &lt;a href=&quot;../compile#threadsafe&quot;&gt;SQLITE_THREADSAFE = 0&lt;/a&gt; и &lt;a href=&quot;threadsafe&quot;&gt;sqlite3_threadsafe (),&lt;/a&gt; возвращающим 0) или если SQLite запущен в одном из сокращенных режимов мьютекса, &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigsinglethread&quot;&gt;SQLITE_CONFIG_SINGLETHREAD&lt;/a&gt; или &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigmultithread&quot;&gt;SQLITE_CONFIG_MULTITHREAD,&lt;/a&gt; тогда нет различий между защищенными и незащищенными объектами sq3. использоваться как взаимозаменяемые. Однако для максимальной переносимости кода рекомендуется, чтобы приложения по-прежнему делали различие между защищенными и незащищенными объектами sqlite3_value, даже если это не требуется строго.</target>
        </trans-unit>
        <trans-unit id="9b59119835d0c98638847083b9be8651dcfed7b3" translate="yes" xml:space="preserve">
          <source>The terms &quot;protected&quot; and &quot;unprotected&quot; refer to whether or not a mutex is held. An internal mutex is held for a protected sqlite3_value object but no mutex is held for an unprotected sqlite3_value object. If SQLite is compiled to be single-threaded (with &lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE=0&lt;/a&gt; and with &lt;a href=&quot;#sqlite3_threadsafe&quot;&gt;sqlite3_threadsafe()&lt;/a&gt; returning 0) or if SQLite is run in one of reduced mutex modes &lt;a href=&quot;#sqliteconfigsinglethread&quot;&gt;SQLITE_CONFIG_SINGLETHREAD&lt;/a&gt; or &lt;a href=&quot;#sqliteconfigmultithread&quot;&gt;SQLITE_CONFIG_MULTITHREAD&lt;/a&gt; then there is no distinction between protected and unprotected sqlite3_value objects and they can be used interchangeably. However, for maximum code portability it is recommended that applications still make the distinction between protected and unprotected sqlite3_value objects even when not strictly required.</source>
          <target state="translated">Термины &amp;laquo;защищенный&amp;raquo; и &amp;laquo;незащищенный&amp;raquo; относятся к тому, удерживается ли мьютекс. Внутренний мьютекс сохраняется для защищенного объекта sqlite3_value, но не сохраняется мьютекс для незащищенного объекта sqlite3_value. Если SQLite скомпилирован как однопоточный (с &lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE = 0&lt;/a&gt; и &lt;a href=&quot;#sqlite3_threadsafe&quot;&gt;sqlite3_threadsafe (),&lt;/a&gt; возвращающим 0) или если SQLite запущен в одном из сокращенных режимов мьютекса, &lt;a href=&quot;#sqliteconfigsinglethread&quot;&gt;SQLITE_CONFIG_SINGLETHREAD&lt;/a&gt; или &lt;a href=&quot;#sqliteconfigmultithread&quot;&gt;SQLITE_CONFIG_MULTITHREAD,&lt;/a&gt; тогда нет различий между защищенными и незащищенными объектами sq3. использоваться как взаимозаменяемые. Однако для максимальной переносимости кода рекомендуется, чтобы приложения по-прежнему делали различие между защищенными и незащищенными объектами sqlite3_value, даже если это не требуется строго.</target>
        </trans-unit>
        <trans-unit id="d0d8bb329a3e29ad5aa4a494be22dcdfc57447c5" translate="yes" xml:space="preserve">
          <source>The terms in W and X must match exactly. SQLite does not do algebra to try to get them to look the same. The term &quot;b=6&quot; does not match &quot;b=3+3&quot; or &quot;b-6=0&quot; or &quot;b BETWEEN 6 AND 6&quot;. &quot;b=6&quot; will match to &quot;6=b&quot; as long as &quot;b=6&quot; is on the index and &quot;6=b&quot; is in the query. If a term of the form &quot;6=b&quot; appears in the index, it will never match anything.</source>
          <target state="translated">Условия в W и X должны точно совпадать.SQLite не делает алгебру,чтобы заставить их выглядеть одинаково.Термин &quot;b=6&quot; не совпадает с &quot;b=3+3&quot; или &quot;b-6=0&quot; или &quot;b BETWEEN 6 AND 6&quot;.&quot;b=6&quot; будет совпадать с &quot;6=b&quot; до тех пор,пока &quot;b=6&quot; находится в индексе,а &quot;6=b&quot;-в запросе.Если в индексе появится выражение вида &quot;6=b&quot;,то оно никогда ничему не будет соответствовать.</target>
        </trans-unit>
        <trans-unit id="1a91aabb1ee8a98e3573519dc568a9cdcf09f371" translate="yes" xml:space="preserve">
          <source>The test infrastructure verifies that SQLite does not misuse dynamically allocated memory by using a specially instrumented memory allocator. The instrumented memory allocator is enabled at compile-time using the &lt;a href=&quot;compile#memdebug&quot;&gt;SQLITE_MEMDEBUG&lt;/a&gt; option. The instrumented memory allocator is much slower than the default memory allocator and so its use is not recommended in production. But when enabled during testing, the instrumented memory allocator performs the following checks:</source>
          <target state="translated">Инфраструктура тестирования проверяет, что SQLite не злоупотребляет динамически выделяемой памятью, используя специально оборудованный распределитель памяти. Инструментальный распределитель памяти включается во время компиляции с &lt;a href=&quot;compile#memdebug&quot;&gt;помощью&lt;/a&gt; опции SQLITE_MEMDEBUG . Инструментальный распределитель памяти намного медленнее, чем распределитель памяти по умолчанию, поэтому его использование не рекомендуется в производственной среде. Но при включении во время тестирования инструментальный распределитель памяти выполняет следующие проверки:</target>
        </trans-unit>
        <trans-unit id="23d89111adcbe2ab0ff1f685425a6f5892695526" translate="yes" xml:space="preserve">
          <source>The test suite is designed to be run three times, once for each of the ALWAYS() and NEVER() definitions shown above. All three test runs should yield exactly the same result. There is a run-time test using the &lt;a href=&quot;c3ref/test_control&quot;&gt;sqlite3_test_control&lt;/a&gt;(&lt;a href=&quot;c3ref/c_testctrl_always&quot;&gt;SQLITE_TESTCTRL_ALWAYS&lt;/a&gt;, ...) interface that can be used to verify that the macros are correctly set to the first form (the pass-through form) for deployment.</source>
          <target state="translated">Набор тестов разработан для трехкратного выполнения, по одному для каждого из определений ALWAYS () и NEVER (), показанных выше. Все три тестовых прогона должны дать точно такой же результат. Существует тест во время выполнения с использованием интерфейса &lt;a href=&quot;c3ref/test_control&quot;&gt;sqlite3_test_control&lt;/a&gt; ( &lt;a href=&quot;c3ref/c_testctrl_always&quot;&gt;SQLITE_TESTCTRL_ALWAYS&lt;/a&gt; , ...), который можно использовать для проверки правильности установки макросов для первой формы (сквозной формы) для развертывания.</target>
        </trans-unit>
        <trans-unit id="77fbf4494f9eeac6c3dd3e8030fecebddc25654d" translate="yes" xml:space="preserve">
          <source>The test suites for SQLite also explore the result of stacking multiple failures. For example, tests are run to ensure correct behavior when an I/O error or OOM fault occurs while trying to recover from a prior crash.</source>
          <target state="translated">Тестовые наборы для SQLite также исследуют результат стекирования множественных сбоев.Например,тесты выполняются для обеспечения правильного поведения при ошибке ввода/вывода или ошибке OOM при попытке восстановления после предыдущего сбоя.</target>
        </trans-unit>
        <trans-unit id="a7eb514323fac72f4df40162cf2fb7ca6826d6f1" translate="yes" xml:space="preserve">
          <source>The test1.dir directory will contain 100,000 files with names like &quot;000000&quot;, &quot;000001&quot;, &quot;000002&quot; and so forth but the test1.tree directory will contain the same files in subdirectories like &quot;00/00/00&quot;, &quot;00/00/01&quot;, and so on. The test1.dir and test1.test directories take up approximately the same amount of space, though test1.test is very slightly larger due to the extra directory entries.</source>
          <target state="translated">Каталог test1.dir будет содержать 100,000 файлов с именами типа &quot;000000&quot;,&quot;000001&quot;,&quot;000002&quot; и так далее,но каталог test1.tree будет содержать те же файлы в подкаталогах типа &quot;00/00/00&quot;,&quot;00/00/01&quot; и так далее.Каталоги test1.dir и test1.test занимают примерно одинаковое количество места,хотя test1.test из-за дополнительных записей в каталоге очень большой.</target>
        </trans-unit>
        <trans-unit id="833841004a13aff638c7a47f3f35a8f25f41ac0a" translate="yes" xml:space="preserve">
          <source>The test_async.c drive now does full file locking and works correctly when used simultaneously by multiple processes on the same database.</source>
          <target state="translated">Диск test_async.c теперь выполняет полную блокировку файлов и корректно работает при одновременном использовании несколькими процессами в одной и той же БД.</target>
        </trans-unit>
        <trans-unit id="eb420a5e9808216cc66d2c072d0472129ab690a9" translate="yes" xml:space="preserve">
          <source>The testcase() macro is often used to verify that boundary cases of an inequality comparison are checked. For example, at &lt;a href=&quot;https://sqlite.org/src/artifact/18a53540aa3?ln=5766&quot;&gt;https://sqlite.org/src/artifact/18a53540aa3?ln=5766&lt;/a&gt;. These kind of checks help to prevent off-by-one errors.</source>
          <target state="translated">Макрос testcase () часто используется для проверки того, что проверяются граничные случаи сравнения неравенств. Например, на &lt;a href=&quot;https://sqlite.org/src/artifact/18a53540aa3?ln=5766&quot;&gt;https://sqlite.org/src/artifact/18a53540aa3?ln=5766&lt;/a&gt; . Такие проверки помогают предотвратить случайные ошибки.</target>
        </trans-unit>
        <trans-unit id="bfd50a8b5d17dc1d197a2f0aeffde22600cc3d5e" translate="yes" xml:space="preserve">
          <source>The testcase(X) macro is normally a no-op, but for a coverage test build it does generate a small amount of extra code that includes at least one branch, in order to verify that test cases exist for which X is both true and false.</source>
          <target state="translated">Макрос testtcase(X)обычно не работает,но для сборки теста покрытия он генерирует небольшое количество дополнительного кода,включающего хотя бы одну ветку,чтобы проверить,что существуют тестовые случаи,для которых X и правда,и ложь.</target>
        </trans-unit>
        <trans-unit id="198025ed4b90dd540b423fcfb30efac73a9076a6" translate="yes" xml:space="preserve">
          <source>The testing process for SQLite is described in the &lt;a href=&quot;testing&quot;&gt;testing&lt;/a&gt; document. Testing objectives include:</source>
          <target state="translated">Процесс тестирования SQLite описан в &lt;a href=&quot;testing&quot;&gt;тестовом&lt;/a&gt; документе. Цели тестирования включают:</target>
        </trans-unit>
        <trans-unit id="7f341b9da6892f9f513eb1e23029aaad7d1945bb" translate="yes" xml:space="preserve">
          <source>The testing process is controlled by the &lt;a href=&quot;testing#cklist&quot;&gt;release testing checklists&lt;/a&gt;. The checklists succinctly summary all steps necessary to fully validate SQLite, and they record when and by whom each validation step was performed.</source>
          <target state="translated">Процесс тестирования контролируется &lt;a href=&quot;testing#cklist&quot;&gt;контрольными списками тестирования релизов&lt;/a&gt; . В контрольных списках кратко перечислены все шаги, необходимые для полной проверки SQLite, и в них записывается, когда и кем был выполнен каждый шаг проверки.</target>
        </trans-unit>
        <trans-unit id="b10a0b7612e25fb69c97ba29101b2f64b4a7581b" translate="yes" xml:space="preserve">
          <source>The text format is pure SQL so you can also use the .dump command to export an SQLite database into other popular SQL database engines. Like this:</source>
          <target state="translated">Текстовый формат является чистым SQL,поэтому вы также можете использовать команду .dump для экспорта базы данных SQLite в другие популярные движки баз данных SQL.Вот так:</target>
        </trans-unit>
        <trans-unit id="002ca6dfea0de9e1d73a68077f123004fa9755de" translate="yes" xml:space="preserve">
          <source>The text in the sqlite_master.sql column is a copy of the original CREATE statement text that created the object, except normalized as described above and as modified by subsequent &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE&lt;/a&gt; statements. The sqlite_master.sql is NULL for the &lt;a href=&quot;fileformat2#intschema&quot;&gt;internal indexes&lt;/a&gt; that are automatically created by &lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE&lt;/a&gt; or &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt; constraints.</source>
          <target state="translated">Текст в столбце sqlite_master.sql является копией исходного текста оператора CREATE, создавшего объект, за исключением нормализованного, как описано выше, и измененного последующими операторами &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE&lt;/a&gt; . Sqlite_master.sql имеет значение NULL для &lt;a href=&quot;fileformat2#intschema&quot;&gt;внутренних индексов&lt;/a&gt; , которые автоматически создаются ограничениями &lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE&lt;/a&gt; или &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="df540746bab5e3cce21edce12d96e726e4a223e9" translate="yes" xml:space="preserve">
          <source>The text in the sqlite_schema.sql column is a copy of the original CREATE statement text that created the object, except normalized as described above and as modified by subsequent &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE&lt;/a&gt; statements. The sqlite_schema.sql is NULL for the &lt;a href=&quot;fileformat2#intschema&quot;&gt;internal indexes&lt;/a&gt; that are automatically created by &lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE&lt;/a&gt; or &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt; constraints.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3362b59e42a116b494bb787cf561f00b28111a39" translate="yes" xml:space="preserve">
          <source>The text of query parameters is appended to the filename argument of the xOpen method of the &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;. Any %HH escape sequences in the query parameters are resolved prior to being appended to the xOpen filename. A single zero-byte separates the xOpen filename argument from the key of the first query parameters, each key and value, and each subsequent key from the prior value. The list of query parameters appended to the xOpen filename is terminated by a single zero-length key. Note that the value of a query parameter can be an empty string.</source>
          <target state="translated">Текст параметров запроса добавляется к аргументу имени файла метода xOpen &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; . Любые escape-последовательности% HH в параметрах запроса разрешаются перед добавлением к имени файла xOpen. Один нулевой байт отделяет аргумент имени файла xOpen от ключа первых параметров запроса, каждого ключа и значения и каждого последующего ключа от предыдущего значения. Список параметров запроса, добавленный к имени файла xOpen, завершается одним ключом нулевой длины. Обратите внимание, что значение параметра запроса может быть пустой строкой.</target>
        </trans-unit>
        <trans-unit id="f010a4aeda05a6fff949d6b23c4d99edd507a5b9" translate="yes" xml:space="preserve">
          <source>The text of the word that matches the pattern. Both word and pattern can contain unicode characters and can be mixed case.</source>
          <target state="translated">Текст слова,совпадающий с образцом.Как слово,так и образец могут содержать символы в кодировке Unicode и могут иметь смешанный регистр.</target>
        </trans-unit>
        <trans-unit id="7af9ff5f020628933bb8ed136e797234a16f70b6" translate="yes" xml:space="preserve">
          <source>The text output of the one-argument form of ieee754() is great for human readability, but it awkward to use as part of a larger expression. Hence The ieee754_mantissa() and ieee754_exponent() routines were added to return the M and E values corresponding to their single argument F value. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4b0dc57bbaf15993013eb4fb283d70eb9d49a61" translate="yes" xml:space="preserve">
          <source>The text output of the one-argument form of ieee754() is great for human readability, but it is awkward to use as part of a larger expression. Hence the ieee754_mantissa() and ieee754_exponent() routines were added to return the M and E values corresponding to their single argument F value. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34ac3915c6fa697bff1880701cc84fcf41ef0614" translate="yes" xml:space="preserve">
          <source>The text to add to the start or end of the selected text to indicate that the returned text does not occur at the start or end of its column, respectively.</source>
          <target state="translated">Текст,который необходимо добавить в начало или конец выделенного текста,чтобы указать,что возвращаемый текст не встречается в начале или в конце его столбца соответственно.</target>
        </trans-unit>
        <trans-unit id="5d227441e585adc9dccb7fd5119a447b09eeb780" translate="yes" xml:space="preserve">
          <source>The text to insert after each phrase match within the returned text.</source>
          <target state="translated">Текст,который необходимо вставить после каждого совпадения фраз в возвращаемом тексте.</target>
        </trans-unit>
        <trans-unit id="c372789c27ae2ac063bb79f99aab7639b81bdf47" translate="yes" xml:space="preserve">
          <source>The text to insert after each phrase match.</source>
          <target state="translated">Текст для вставки после каждого совпадения фраз.</target>
        </trans-unit>
        <trans-unit id="98deed99ebb119a4eabb19891d9d80c8f6d99766" translate="yes" xml:space="preserve">
          <source>The text to insert before each phrase match within the returned text.</source>
          <target state="translated">Текст,который необходимо вставить перед каждой фразой,совпадает с возвращенным текстом.</target>
        </trans-unit>
        <trans-unit id="011020fd80da1d64051ffd57ff7d4f9db6949595" translate="yes" xml:space="preserve">
          <source>The text to insert before each phrase match.</source>
          <target state="translated">Текст,который необходимо вставить перед каждым словосочетанием.</target>
        </trans-unit>
        <trans-unit id="41db7390257d3e1c83cfe7262fbe75efa4098374" translate="yes" xml:space="preserve">
          <source>The theoretical maximum number of rows in a table is 2&lt;sup&gt;&lt;small&gt;64&lt;/small&gt;&lt;/sup&gt; (18446744073709551616 or about 1.8e+19). This limit is unreachable since the maximum database size of 140 terabytes will be reached first. A 140 terabytes database can hold no more than approximately 1e+13 rows, and then only if there are no indices and if each row contains very little data.</source>
          <target state="translated">Теоретическое максимальное количество строк в таблице - 2 &lt;sup&gt;&lt;small&gt;64&lt;/small&gt;&lt;/sup&gt; (18446744073709551616 или около 1,8e + 19). Этот предел недостижим, так как сначала будет достигнут максимальный размер базы данных в 140 терабайт. База данных размером 140 терабайт может содержать не более примерно 1e + 13 строк, и то только при отсутствии индексов и если каждая строка содержит очень мало данных.</target>
        </trans-unit>
        <trans-unit id="9c469d0a6dd7814f8f536d83dd0c0d4f9236b847" translate="yes" xml:space="preserve">
          <source>The theoretical maximum number of rows in a table is 2&lt;sup&gt;&lt;small&gt;64&lt;/small&gt;&lt;/sup&gt; (18446744073709551616 or about 1.8e+19). This limit is unreachable since the maximum database size of 281 terabytes will be reached first. A 281 terabytes database can hold no more than approximately 2e+13 rows, and then only if there are no indices and if each row contains very little data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e681320a770693ff8880c2fe787c3d46c58d6fe" translate="yes" xml:space="preserve">
          <source>The these routines may attempt to convert the datatype of the result. For example, if the internal representation is FLOAT and a text result is requested, &lt;a href=&quot;#sqlite3_mprintf&quot;&gt;sqlite3_snprintf()&lt;/a&gt; is used internally to perform the conversion automatically. The following table details the conversions that are applied:</source>
          <target state="translated">Эти подпрограммы могут пытаться преобразовать тип данных результата. Например, если внутреннее представление - FLOAT и запрашивается текстовый результат, &lt;a href=&quot;#sqlite3_mprintf&quot;&gt;sqlite3_snprintf ()&lt;/a&gt; используется внутренне для автоматического выполнения преобразования. В следующей таблице подробно описаны применяемые преобразования:</target>
        </trans-unit>
        <trans-unit id="d45ababe332de0d6a9b7d204a8229a091726f141" translate="yes" xml:space="preserve">
          <source>The these routines may attempt to convert the datatype of the result. For example, if the internal representation is FLOAT and a text result is requested, &lt;a href=&quot;mprintf&quot;&gt;sqlite3_snprintf()&lt;/a&gt; is used internally to perform the conversion automatically. The following table details the conversions that are applied:</source>
          <target state="translated">Эти подпрограммы могут пытаться преобразовать тип данных результата. Например, если внутреннее представление - FLOAT и запрашивается текстовый результат, &lt;a href=&quot;mprintf&quot;&gt;sqlite3_snprintf ()&lt;/a&gt; используется внутренне для автоматического выполнения преобразования. В следующей таблице подробно описаны применяемые преобразования:</target>
        </trans-unit>
        <trans-unit id="f29b8fd84fbcfd59fccde21c2067cc383b5612cf" translate="yes" xml:space="preserve">
          <source>The third and fourth parameters to this function are the table and column name of the desired column, respectively.</source>
          <target state="translated">Третий и четвертый параметры этой функции-это название таблицы и столбца нужного столбца соответственно.</target>
        </trans-unit>
        <trans-unit id="5dad7ccfb7adf02e60a4718cd1bfaf6cc7ad8094" translate="yes" xml:space="preserve">
          <source>The third argument (eTextRep) must be one of the constants:</source>
          <target state="translated">Третий аргумент (eTextRep)должен быть одной из констант:</target>
        </trans-unit>
        <trans-unit id="a12fbbce4ea7f98c6f3257e48e8cfdd9d6a7f402" translate="yes" xml:space="preserve">
          <source>The third argument is the value to bind to the parameter. If the third parameter to sqlite3_bind_text() or sqlite3_bind_text16() or sqlite3_bind_blob() is a NULL pointer then the fourth parameter is ignored and the end result is the same as sqlite3_bind_null().</source>
          <target state="translated">Третий аргумент-значение для привязки к параметру.Если третий параметр sqlite3_bind_text()или sqlite3_bind_text16()или sqlite3_bind_blob()является указателем NULL,то четвертый параметр игнорируется и конечный результат равен sqlite3_bind_null().</target>
        </trans-unit>
        <trans-unit id="cfd2994dc5175da09229d952b2be33f11c05e0da" translate="yes" xml:space="preserve">
          <source>The third argument is the value to bind to the parameter. If the third parameter to sqlite3_bind_text() or sqlite3_bind_text16() or sqlite3_bind_blob() is a NULL pointer then the fourth parameter is ignored and the end result is the same as sqlite3_bind_null(). If the third parameter to sqlite3_bind_text() is not NULL, then it should be a pointer to well-formed UTF8 text. If the third parameter to sqlite3_bind_text16() is not NULL, then it should be a pointer to well-formed UTF16 text. If the third parameter to sqlite3_bind_text64() is not NULL, then it should be a pointer to a well-formed unicode string that is either UTF8 if the sixth parameter is SQLITE_UTF8, or UTF16 otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8896799f29c2adcd495a7004a3dfd8ef2c595b55" translate="yes" xml:space="preserve">
          <source>The third argument to the &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfiglog&quot;&gt;SQLITE_CONFIG_LOG&lt;/a&gt;,...) interface (the &quot;pData&quot; argument in the example above) is a pointer to arbitrary data. SQLite passes this pointer through to the first argument of the error logger callback. The pointer can be used to pass application-specific setup or state information, if desired. Or it can simply be a NULL pointer which is ignored by the callback.</source>
          <target state="translated">Третий аргумент интерфейса &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt; ( &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfiglog&quot;&gt;SQLITE_CONFIG_LOG&lt;/a&gt; , ...) (аргумент &amp;laquo;pData&amp;raquo; в приведенном выше примере) - это указатель на произвольные данные. SQLite передает этот указатель на первый аргумент обратного вызова регистратора ошибок. При желании указатель может использоваться для передачи информации о настройке или состоянии конкретного приложения. Или это может быть просто указатель NULL, который игнорируется обратным вызовом.</target>
        </trans-unit>
        <trans-unit id="8e80d3a19f53ad5c94b48f6b4deace1bd8cd6a01" translate="yes" xml:space="preserve">
          <source>The third chart shows that reading blob content out of SQLite can be twice as fast as reading from individual files on disk for Mac and Android, and an amazing ten times faster for Windows.</source>
          <target state="translated">Третий график показывает,что чтение блоков из SQLite может быть в два раза быстрее,чем чтение отдельных файлов на диске для Mac и Android,и в десять раз быстрее для Windows.</target>
        </trans-unit>
        <trans-unit id="ce81cfaf801aa960a0d4e258e6f72c47aaf642db" translate="yes" xml:space="preserve">
          <source>The third column is the minimum value for any rowid in the table.</source>
          <target state="translated">Третий столбец-это минимальное значение для любой строки таблицы.</target>
        </trans-unit>
        <trans-unit id="66b245a2c0333e9c6e002eaadabc21caae3f20aa" translate="yes" xml:space="preserve">
          <source>The third form of an INSERT statement is with DEFAULT VALUES. The INSERT ... DEFAULT VALUES statement inserts a single new row into the named table. Each column of the new row is populated with its &lt;a href=&quot;lang_createtable#dfltval&quot;&gt;default value&lt;/a&gt;, or with a NULL if no default value is specified as part of the column definition in the &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; statement. The &lt;a href=&quot;syntax/upsert-clause&quot;&gt;upsert-clause&lt;/a&gt; is not supported after DEFAULT VALUES.</source>
          <target state="translated">Третья форма оператора INSERT - со ЗНАЧЕНИЯМИ ПО УМОЛЧАНИЮ. Оператор INSERT ... DEFAULT VALUES вставляет одну новую строку в указанную таблицу. Каждый столбец новой строки заполняется &lt;a href=&quot;lang_createtable#dfltval&quot;&gt;значением по умолчанию&lt;/a&gt; или NULL, если значение по умолчанию не указано как часть определения столбца в операторе &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; . Предложение &lt;a href=&quot;syntax/upsert-clause&quot;&gt;upsert&lt;/a&gt; не поддерживается после DEFAULT VALUES.</target>
        </trans-unit>
        <trans-unit id="80211bcbcab262c368d4da63de6e8f61d55d7f66" translate="yes" xml:space="preserve">
          <source>The third line of the example shows the virtual table being used, to read all content of the CSV file. This is perhaps the simplest possible use of the virtual table. The CSV virtual table can be used anywhere an ordinary virtual table can be used. One can use the CSV virtual table inside subqueries, or &lt;a href=&quot;lang_with&quot;&gt;common table expressions&lt;/a&gt; or add WHERE, GROUP BY, HAVING, ORDER BY, and LIMIT clauses as required.</source>
          <target state="translated">Третья строка примера показывает используемую виртуальную таблицу для чтения всего содержимого файла CSV. Это, пожалуй, самое простое возможное использование виртуальной таблицы. Виртуальную таблицу CSV можно использовать везде, где можно использовать обычную виртуальную таблицу. Можно использовать виртуальную таблицу CSV внутри подзапросов или &lt;a href=&quot;lang_with&quot;&gt;общих табличных выражений&lt;/a&gt; или добавить при необходимости предложения WHERE, GROUP BY, HAVING, ORDER BY и LIMIT.</target>
        </trans-unit>
        <trans-unit id="37d0f732f75ffbc9298be10c6e109dfc37fa5d4b" translate="yes" xml:space="preserve">
          <source>The third number Z is incremented for releases consisting of only small changes that implement performance enhancements and/or bug fixes.</source>
          <target state="translated">Третье число Z увеличивается для релизов,состоящих только из небольших изменений,в которых реализованы улучшения производительности и/или исправления ошибок.</target>
        </trans-unit>
        <trans-unit id="d43fa02ec7a69fa0b5cb4656ab69a4413a6918c8" translate="yes" xml:space="preserve">
          <source>The third optimization, zeroing the journal file header rather than deleting the rollback journal file, does not depend on holding an exclusive lock at all times. This optimization can be set independently of exclusive lock mode using the &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;journal_mode pragma&lt;/a&gt; as described in &lt;a href=&quot;#section_7_6&quot;&gt;section 7.6&lt;/a&gt; below.</source>
          <target state="translated">Третья оптимизация, обнуление заголовка файла журнала вместо удаления файла журнала отката, не зависит от постоянного удержания монопольной блокировки. Эта оптимизация может быть установлена ​​независимо от режима монопольной блокировки с помощью &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;прагмы journal_mode,&lt;/a&gt; как описано в &lt;a href=&quot;#section_7_6&quot;&gt;разделе 7.6&lt;/a&gt; ниже.</target>
        </trans-unit>
        <trans-unit id="226219f131eebb1bb82e3a9e80c20160ef9e49d4" translate="yes" xml:space="preserve">
          <source>The third parameter (nArg) is the number of arguments that the SQL function or aggregate takes. If this parameter is -1, then the SQL function or aggregate may take any number of arguments between 0 and the limit set by &lt;a href=&quot;#sqlite3_limit&quot;&gt;sqlite3_limit&lt;/a&gt;(&lt;a href=&quot;#sqlitelimitfunctionarg&quot;&gt;SQLITE_LIMIT_FUNCTION_ARG&lt;/a&gt;). If the third parameter is less than -1 or greater than 127 then the behavior is undefined.</source>
          <target state="translated">Третий параметр (nArg) - это количество аргументов, которые принимает функция или агрегат SQL. Если этот параметр равен -1, тогда функция или агрегат SQL может принимать любое количество аргументов от 0 до предела, установленного &lt;a href=&quot;#sqlite3_limit&quot;&gt;sqlite3_limit&lt;/a&gt; ( &lt;a href=&quot;#sqlitelimitfunctionarg&quot;&gt;SQLITE_LIMIT_FUNCTION_ARG&lt;/a&gt; ). Если третий параметр меньше -1 или больше 127, поведение не определено.</target>
        </trans-unit>
        <trans-unit id="11f56952c8e04a9269627afb8274637d6b360ea2" translate="yes" xml:space="preserve">
          <source>The third parameter (nArg) is the number of arguments that the SQL function or aggregate takes. If this parameter is -1, then the SQL function or aggregate may take any number of arguments between 0 and the limit set by &lt;a href=&quot;limit&quot;&gt;sqlite3_limit&lt;/a&gt;(&lt;a href=&quot;c_limit_attached#sqlitelimitfunctionarg&quot;&gt;SQLITE_LIMIT_FUNCTION_ARG&lt;/a&gt;). If the third parameter is less than -1 or greater than 127 then the behavior is undefined.</source>
          <target state="translated">Третий параметр (nArg) - это количество аргументов, которые принимает функция или агрегат SQL. Если этот параметр равен -1, тогда функция или агрегат SQL может принимать любое количество аргументов от 0 до предела, установленного &lt;a href=&quot;limit&quot;&gt;sqlite3_limit&lt;/a&gt; ( &lt;a href=&quot;c_limit_attached#sqlitelimitfunctionarg&quot;&gt;SQLITE_LIMIT_FUNCTION_ARG&lt;/a&gt; ). Если третий параметр меньше -1 или больше 127, поведение не определено.</target>
        </trans-unit>
        <trans-unit id="7effa7c199d796ec9c7957d5b06f69295ac44ef2" translate="yes" xml:space="preserve">
          <source>The third step starts with the four shortest two-node paths and finds the four shortest three-node paths:</source>
          <target state="translated">Третий шаг начинается с четырех кратчайших двух-узловых путей и находит четыре кратчайших трех-узловых пути:</target>
        </trans-unit>
        <trans-unit id="97390ca779620e87876318d53cdbb5c0eb4c1782" translate="yes" xml:space="preserve">
          <source>The threading mode can be selected at compile-time (when the SQLite library is being compiled from source code) or at start-time (when the application that intends to use SQLite is initializing) or at run-time (when a new SQLite database connection is being created). Generally speaking, run-time overrides start-time and start-time overrides compile-time. Except, single-thread mode cannot be overridden once selected.</source>
          <target state="translated">Режим нити может быть выбран во время компиляции (когда библиотека SQLite компилируется из исходного кода),во время запуска (когда приложение,которое намерено использовать SQLite,инициализируется)или во время выполнения (когда создается новое подключение к базе данных SQLite).Вообще говоря,время выполнения переопределяет время запуска и время запуска переопределяет время компиляции.Кроме того,однопоточный режим не может быть переопределен один раз.</target>
        </trans-unit>
        <trans-unit id="7a0e198fd0423256115863d78eac9cac1343e176" translate="yes" xml:space="preserve">
          <source>The threading mode for an individual database connection is determined by flags given as the third argument to &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;. The &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_NOMUTEX&lt;/a&gt; flag causes the database connection to be in the multi-thread mode and the &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_FULLMUTEX&lt;/a&gt; flag causes the connection to be in serialized mode. If neither flag is specified or if &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt; or &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open16()&lt;/a&gt; are used instead of &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;, then the default mode determined by the compile-time and start-time settings is used.</source>
          <target state="translated">Режим потоковой передачи для отдельного соединения с базой данных определяется флагами, заданными в качестве третьего аргумента &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2 ()&lt;/a&gt; . &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_NOMUTEX&lt;/a&gt; флаг вызывает соединение с базой данных , чтобы быть в режиме многопоточного и &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_FULLMUTEX&lt;/a&gt; флаг вызывает соединение находиться в последовательном режиме. Если ни один флаг указан или если &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open ()&lt;/a&gt; или &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open16 ()&lt;/a&gt; используется вместо &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2 ()&lt;/a&gt; , то режим по умолчанию определяется во время компиляции и запуска времени используются настройка.</target>
        </trans-unit>
        <trans-unit id="a70f1f8b6fb5520108a2b27f649a3322d3c256dc" translate="yes" xml:space="preserve">
          <source>The three auxiliary functions are only useful within a SELECT statement that uses the FTS table's full-text index. If used within a SELECT that uses the &quot;query by rowid&quot; or &quot;linear scan&quot; strategies, then the snippet and offsets both return an empty string, and the matchinfo function returns a blob value zero bytes in size.</source>
          <target state="translated">Три вспомогательные функции полезны только в операторе SELECT,использующем полнотекстовый индекс таблицы FTS.Если она используется внутри SELECT,использующего стратегии &quot;запрос по rowid&quot; или &quot;линейное сканирование&quot;,то фрагмент и смещение возвращают пустую строку,а функция matchinfo возвращает блочное значение нулевого байта в размере.</target>
        </trans-unit>
        <trans-unit id="6eb0a1f7b89a823f8bdbde0d13568a18262e614a" translate="yes" xml:space="preserve">
          <source>The three basic query types described above may be used to query the full-text index for the set of documents that match the specified criteria. Using the FTS query expression language it is possible to perform various set operations on the results of basic queries. There are currently three supported operations:</source>
          <target state="translated">Три основных типа запросов,описанных выше,могут быть использованы для запроса полнотекстового индекса для набора документов,соответствующих указанным критериям.Используя язык выражения запросов FTS,можно выполнять различные наборы операций над результатами базовых запросов.В настоящее время поддерживаются три операции:</target>
        </trans-unit>
        <trans-unit id="0bcf82aa96037363ce9292444de8c7ae637936e7" translate="yes" xml:space="preserve">
          <source>The three forms above are equivalent for all FTS tables that are not external content tables. They check that the index data structures are not corrupt, and, if the FTS table is not contentless, that the contents of the index match the contents of the table itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7097964beca5dc252968954049e7c0946f78e4a9" translate="yes" xml:space="preserve">
          <source>The three leftmost columns of a zipfile virtual table, &quot;name&quot;, &quot;mode&quot; and &quot;mtime&quot;, may each be set to any value that may be inserted into the same column (see above). If either &quot;mode&quot; or &quot;mtime&quot; is set to NULL, the final value is determined as described for an INSERT of a NULL value - the current time for &quot;mtime&quot; and either 33188 or 16877 for &quot;mode&quot;, depending on whether or not the values specified for the next four columns of the zipfile table indicate that the entry is a directory or a file.</source>
          <target state="translated">Три крайние левые колонки виртуальной таблицы zip-файла-&quot;имя&quot;,&quot;режим&quot; и &quot;время&quot;-могут быть установлены на любое значение,которое может быть вставлено в одну и ту же колонку (см.выше).Если для &quot;режима&quot; или &quot;mtime&quot; установлено значение NULL,то конечное значение определяется,как описано для ИНСЕРТА значения NULL-текущее время для &quot;mtime&quot; и либо 33188,либо 16877 для &quot;режима&quot;,в зависимости от того,указывают ли значения,указанные для следующих четырех столбцов zip-таблицы,на то,что запись является каталогом или файлом.</target>
        </trans-unit>
        <trans-unit id="3411dedba6408ea6c13a17f75aea9b87b7d91fad" translate="yes" xml:space="preserve">
          <source>The time string can be followed by zero or more modifiers that alter date and/or time. Each modifier is a transformation that is applied to the time value to its left. Modifiers are applied from left to right; order is important. The available modifiers are as follows.</source>
          <target state="translated">За строкой времени могут следовать нулевые или более модификаторы,изменяющие дату и/или время.Каждый модификатор представляет собой преобразование,которое применяется к значению времени слева от него.Модификаторы применяются слева направо;порядок важен.Доступные модификаторы следующие.</target>
        </trans-unit>
        <trans-unit id="30024a74e5aefa6cc166b0948a8f34eea1be4641" translate="yes" xml:space="preserve">
          <source>The time taken to execute each virtual machine operation can vary based on many factors. A typical value for a 1 GHz PC is between half and three million per second but may be much higher or lower, depending on the query. As such it is difficult to schedule background operations based on virtual machine operations. Instead, it is recommended that a callback be scheduled relatively frequently (say every 1000 instructions) and external timer routines used to determine whether or not background jobs need to be run.</source>
          <target state="translated">Время,затрачиваемое на выполнение каждой операции виртуальной машины,может варьироваться в зависимости от многих факторов.Типичное значение для ПК с частотой 1 ГГц составляет от полутора до трех миллионов в секунду,но может быть значительно больше или меньше в зависимости от запроса.В связи с этим сложно запланировать фоновые операции на основе операций виртуальной машины.Вместо этого рекомендуется относительно часто планировать обратный вызов (скажем,каждые 1000 инструкций)и использовать внешние подпрограммы таймера для определения необходимости выполнения фоновых заданий.</target>
        </trans-unit>
        <trans-unit id="8835050f4b3154465ec715623586121c193bcc48" translate="yes" xml:space="preserve">
          <source>The time value can be followed by zero or more modifiers that alter date and/or time. Each modifier is a transformation that is applied to the time value to its left. Modifiers are applied from left to right; order is important. The available modifiers are as follows.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d31d23c9c6ce92ba1161f4e9fe89ef4c4bc1cceb" translate="yes" xml:space="preserve">
          <source>The times reported on all tests represent wall-clock time in seconds. Two separate time values are reported for SQLite. The first value is for SQLite in its default configuration with full disk synchronization turned on. With synchronization turned on, SQLite executes an &lt;b&gt;fsync()&lt;/b&gt; system call (or the equivalent) at key points to make certain that critical data has actually been written to the disk drive surface. Synchronization is necessary to guarantee the integrity of the database if the operating system crashes or the computer powers down unexpectedly in the middle of a database update. The second time reported for SQLite is when synchronization is turned off. With synchronization off, SQLite is sometimes much faster, but there is a risk that an operating system crash or an unexpected power failure could damage the database. Generally speaking, the synchronous SQLite times are for comparison against PostgreSQL (which is also synchronous) and the asynchronous SQLite times are for comparison against the asynchronous MySQL engine.</source>
          <target state="translated">Время, указанное во всех тестах, представляет собой время настенных часов в секундах. Для SQLite представлены два отдельных значения времени. Первое значение предназначено для SQLite в его конфигурации по умолчанию с включенной полной синхронизацией диска. При включенной синхронизации SQLite выполняет &lt;b&gt;fsync ()&lt;/b&gt;системный вызов (или его эквивалент) в ключевых точках, чтобы убедиться, что критически важные данные действительно записаны на поверхность диска. Синхронизация необходима для гарантии целостности базы данных в случае сбоя операционной системы или непредвиденного отключения компьютера во время обновления базы данных. Второй раз для SQLite сообщается, что синхронизация отключена. Если синхронизация отключена, SQLite иногда работает намного быстрее, но существует риск того, что сбой операционной системы или неожиданный сбой питания могут повредить базу данных. Вообще говоря, синхронное время SQLite предназначено для сравнения с PostgreSQL (который также является синхронным), а время асинхронного SQLite - для сравнения с асинхронным механизмом MySQL.</target>
        </trans-unit>
        <trans-unit id="0fc05e4c39e5e71215073020483f372e45a3d893" translate="yes" xml:space="preserve">
          <source>The total amount of free space on a b-tree page consists of the size of the unallocated region plus the total size of all freeblocks plus the number of fragmented free bytes. SQLite may from time to time reorganize a b-tree page so that there are no freeblocks or fragment bytes, all unused bytes are contained in the unallocated space region, and all cells are packed tightly at the end of the page. This is called &quot;defragmenting&quot; the b-tree page.</source>
          <target state="translated">Общее количество свободного места на b-деревянной странице складывается из размера нераспределенной области плюс суммарный размер всех фриблок плюс количество фрагментированных свободных байтов.SQLite может время от времени реорганизовывать b-деревневую страницу таким образом,чтобы на ней не было ни фрагментарных,ни свободных байтов,все неиспользованные байты находились в нераспределенном пространстве,а все ячейки были плотно упакованы в конце страницы.Это называется &quot;дефрагментацией&quot; b-деревянной страницы.</target>
        </trans-unit>
        <trans-unit id="460e85c11483674a3089f1a062d5d6ad1f387294" translate="yes" xml:space="preserve">
          <source>The total number of instances of the term in the entire FTS5 table.</source>
          <target state="translated">Общее количество экземпляров срока во всей таблице FTS5.</target>
        </trans-unit>
        <trans-unit id="8456fd817ff013feb889e3e84d49e1da8d0b8117" translate="yes" xml:space="preserve">
          <source>The total number of instances of the term that appear in column $col of the FTS5 table (considering all rows).</source>
          <target state="translated">Общее количество экземпляров термина,указанных в столбце $col таблицы FTS5 (с учетом всех строк).</target>
        </trans-unit>
        <trans-unit id="8b23a01c6d0371374c2abef2c4b0a82ba4134902" translate="yes" xml:space="preserve">
          <source>The total number of pages in the btree for the current row</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e6d24f273b69a04a7a37a510d51811f2500b867" translate="yes" xml:space="preserve">
          <source>The total number of rows in the FTS table for which the column contains at least one instance of the phrase.</source>
          <target state="translated">Общее количество строк в таблице FTS,для которых столбец содержит хотя бы один экземпляр фразы.</target>
        </trans-unit>
        <trans-unit id="36827e0806ceb5dc326cee16a98d2a59022e566e" translate="yes" xml:space="preserve">
          <source>The total number of times the phrase appears in the column in all rows in the FTS table.</source>
          <target state="translated">Общее количество раз,когда фраза появляется в столбце во всех строках таблицы FTS.</target>
        </trans-unit>
        <trans-unit id="cf5b068f292efb4fb2def2e783aac8fbf8f0464d" translate="yes" xml:space="preserve">
          <source>The total_changes() function returns the number of row changes caused by INSERT, UPDATE or DELETE statements since the current database connection was opened. This function is a wrapper around the &lt;a href=&quot;c3ref/total_changes&quot;&gt;sqlite3_total_changes()&lt;/a&gt; C/C++ interface.</source>
          <target state="translated">Функция total_changes () возвращает количество изменений строки, вызванных операторами INSERT, UPDATE или DELETE с момента открытия текущего соединения с базой данных. Эта функция является оболочкой для интерфейса &lt;a href=&quot;c3ref/total_changes&quot;&gt;sqlite3_total_changes ()&lt;/a&gt; C / C ++.</target>
        </trans-unit>
        <trans-unit id="e56b60d01d475c54e2abcd03a315a64862d2471f" translate="yes" xml:space="preserve">
          <source>The traditional rollback journal works by writing a copy of the original unchanged database content into a separate rollback journal file and then writing changes directly into the database file. In the event of a crash or &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt;, the original content contained in the rollback journal is played back into the database file to revert the database file to its original state. The &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; occurs when the rollback journal is deleted.</source>
          <target state="translated">Традиционный журнал отката работает путем записи копии исходного неизмененного содержимого базы данных в отдельный файл журнала отката, а затем записи изменений непосредственно в файл базы данных. В случае сбоя или &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt; исходное содержимое, содержащееся в журнале отката, воспроизводится в файле базы данных, чтобы вернуть файл базы данных в исходное состояние. &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; происходит , когда журнал отката удаляется.</target>
        </trans-unit>
        <trans-unit id="fa45945065730186850cef64d952ee165c9cc090" translate="yes" xml:space="preserve">
          <source>The traditional way of communicating this information was to transform a C-language pointer into a BLOB or a 64-bit integer, then move that BLOB or integer through SQLite using the usual interfaces like &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_blob()&lt;/a&gt;, &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_blob()&lt;/a&gt;, &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_blob()&lt;/a&gt; or the integer equivalents.</source>
          <target state="translated">Традиционным способом передачи этой информации было преобразование указателя на языке C в BLOB или 64-битное целое число, а затем перемещение этого BLOB или целого числа через SQLite с использованием обычных интерфейсов, таких как &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_blob ()&lt;/a&gt; , &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_blob ()&lt;/a&gt; , &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_blob ()&lt;/a&gt; или целочисленные эквиваленты.</target>
        </trans-unit>
        <trans-unit id="c2d0f49e1ec0a4672583f25736f97bcbd3e6ba07" translate="yes" xml:space="preserve">
          <source>The transaction command can be used to group together several SQLite commands in a safe way. You can always start transactions manually using BEGIN, of course. But if an error occurs so that the COMMIT or ROLLBACK are never run, then the database will remain locked indefinitely. Also, BEGIN does not nest, so you have to make sure no other transactions are active before starting a new one. The &quot;transaction&quot; method takes care of all of these details automatically.</source>
          <target state="translated">Команда транзакции может быть использована для безопасной группировки нескольких команд SQLite.Разумеется,вы всегда можете запускать транзакции вручную с помощью BEGIN.Но если произойдет ошибка,в результате которой COMMIT или ROLLBACK никогда не будут запущены,то БД останется заблокированной на неопределенный срок.Кроме того,BEGIN не гнездится,поэтому вы должны убедиться,что никакие другие транзакции не активны,прежде чем запускать новую.Метод &quot;транзакции&quot; заботится обо всех этих деталях автоматически.</target>
        </trans-unit>
        <trans-unit id="66431b524eb3e3d97e40f460537f3aa544382bf9" translate="yes" xml:space="preserve">
          <source>The transaction has already committed at this point so timing is not critical in the deletion of the rollback journals. The current implementation deletes a single rollback journal then unlocks the corresponding database file before proceeding to the next rollback journal. But in the future we might change this so that all rollback journals are deleted before any database files are unlocked. As long as the rollback journal is deleted before its corresponding database file is unlocked it does not matter in what order the rollback journals are deleted or the database files are unlocked.</source>
          <target state="translated">Сделка уже совершена на данный момент,поэтому сроки не являются критичными при удалении откатных журналов.Текущая реализация удаляет один журнал отката,затем разблокирует соответствующий файл базы данных,прежде чем перейти к следующему журналу отката.Но в будущем мы можем изменить это так,что все откатные журналы будут удалены до того,как будут разблокированы какие-либо файлы БД.До тех пор,пока откатный журнал удаляется до разблокировки соответствующего файла БД,не имеет значения,в каком порядке удаляются откатные журналы или разблокируются файлы БД.</target>
        </trans-unit>
        <trans-unit id="439b3c25010ac483338852bbf167e17f82acaecb" translate="yes" xml:space="preserve">
          <source>The transformation converts each vertex of the polygon according to the following formula:</source>
          <target state="translated">Преобразование преобразует каждую вершину многоугольника по следующей формуле:</target>
        </trans-unit>
        <trans-unit id="970a22ffd83744a201d5b074bf5b2eed9b68c352" translate="yes" xml:space="preserve">
          <source>The transient table in which the result is built is created by instruction 0. Three loops then follow. The loop at instructions 5 through 10 implements the first SELECT statement. The second SELECT statement is implemented by the loop at instructions 14 through 19. Finally, a loop at instructions 22 through 25 reads the transient table and invokes the callback once for each row in the result.</source>
          <target state="translated">Таблица переходных процессов,в которой строится результат,создается командой 0.Затем следуют три цикла.Цикл на инструкциях 5-10 реализует первый оператор SELECT.Второй оператор SELECT реализуется циклом на инструкциях 14-19.Наконец,цикл на инструкциях с 22 по 25 читает таблицу переходных процессов и вызывает обратный вызов один раз для каждой строки результата.</target>
        </trans-unit>
        <trans-unit id="952fc2249e617c46359543a66e348109d3087d3d" translate="yes" xml:space="preserve">
          <source>The transient table in which the results of the inner SELECT are stored is created by the &lt;a href=&quot;opcode#OpenTemp&quot;&gt;OpenTemp&lt;/a&gt; instruction at 0. This opcode is used for tables that exist for the duration of a single SQL statement only. The transient cursor is always opened read/write even if the main database is read-only. The transient table is deleted automatically when the cursor is closed. The P2 value of 1 means the cursor points to a BTree index, which has no data but can have an arbitrary key.</source>
          <target state="translated">Временная таблица, в которой хранятся результаты внутреннего SELECT, создается инструкцией &lt;a href=&quot;opcode#OpenTemp&quot;&gt;OpenTemp&lt;/a&gt; в 0. Этот код операции используется для таблиц, которые существуют только в течение одного оператора SQL. Временный курсор всегда открывается для чтения / записи, даже если основная база данных доступна только для чтения. Таблица переходных процессов автоматически удаляется при закрытии курсора. Значение P2, равное 1, означает, что курсор указывает на индекс BTree, который не имеет данных, но может иметь произвольный ключ.</target>
        </trans-unit>
        <trans-unit id="592350be0cb11625e2bd092767c6171c56d03c65" translate="yes" xml:space="preserve">
          <source>The transition from SQLite version 3.4.2 to 3.5.0 is a major change. Every source code file in the SQLite core had to be modified, some extensively. And the change introduced some minor incompatibilities in the C interface. But we feel that the benefits of the transition from 3.4.2 to 3.5.0 far outweigh the pain of porting. The new VFS layer is now well-defined and stable and should simplify future customizations. The VFS layer, and the separable memory allocator and mutex subsystems allow a standard SQLite source code amalgamation to be used in an embedded project without change, greatly simplifying configuration management. And the resulting system is much more tolerant of highly threaded designs.</source>
          <target state="translated">Переход с версии SQLite 3.4.2 на 3.5.0 является существенным изменением.Каждый файл исходного кода в ядре SQLite требовал значительных изменений.И это изменение ввело некоторые незначительные несовместимости в C-интерфейсе.Но мы считаем,что преимущества перехода с 3.4.2 на 3.5.0 намного перевешивают боль переноса.Новый слой VFS теперь четко определен и стабилен и должен упростить будущие настройки.Уровень VFS,а также разделяемые подсистемы выделения памяти и мьютекса позволяют без изменений использовать стандартное слияние исходного кода SQLite во встроенном проекте,значительно упрощая управление конфигурацией.А получившаяся система гораздо более терпима к высокопоточным конструкциям.</target>
        </trans-unit>
        <trans-unit id="b0ecdf62ac64721b60f0c811bc6ae15d2a3d1b27" translate="yes" xml:space="preserve">
          <source>The trick here is the -DTCLSH=1 option. The TCL interface module for SQLite includes a &lt;b&gt;main()&lt;/b&gt; procedure that initializes a TCL interpreter and enters a command-line loop when it is compiled with -DTCLSH=1. The command above works on both Linux and Mac OS X, though one may need to adjust the library options depending on the platform and which version of TCL one is linking against.</source>
          <target state="translated">Уловка здесь - опция -DTCLSH = 1. Модуль интерфейса TCL для SQLite включает процедуру &lt;b&gt;main ()&lt;/b&gt; , которая инициализирует интерпретатор TCL и входит в цикл командной строки, когда он компилируется с -DTCLSH = 1. Приведенная выше команда работает как в Linux, так и в Mac OS X, хотя может потребоваться настроить параметры библиотеки в зависимости от платформы и версии TCL, с которой выполняется компоновка.</target>
        </trans-unit>
        <trans-unit id="fc5d00c95debe18bbcee9e720337d19dcab11f5a" translate="yes" xml:space="preserve">
          <source>The trigger created by the previous statement is named &quot;AFTER&quot; and it is a &quot;BEFORE&quot; trigger. The &quot;AFTER&quot; token is used as an identifier instead of as a keyword, as that is the only way to parse the statement. Another example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51f7616fb947ecce3ab64c4648e82fa63ff1f24e" translate="yes" xml:space="preserve">
          <source>The trigram tokenizer supports a single option - &quot;case_sensitive&quot;. With the default value, 0, matching is case-insensitive. If this value is set to 1, then all matches are case-sensitive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b9b7cf0a7967eed621bbbad3863190e29c44d61" translate="yes" xml:space="preserve">
          <source>The trim(X,Y) function returns a string formed by removing any and all characters that appear in Y from both ends of X. If the Y argument is omitted, trim(X) removes spaces from both ends of X.</source>
          <target state="translated">Функция trim(X,Y)возвращает строку,образованную удалением всех символов,которые появляются в Y,из обоих концов X.Если аргумент Y опущен,trim(X)удаляет пробелы из обоих концов X.</target>
        </trans-unit>
        <trans-unit id="02041028dd7a37adeacbb35b1200b0b1a6b27a53" translate="yes" xml:space="preserve">
          <source>The true primary key for a rowid table (the value that is used as the key to look up rows in the underlying &lt;a href=&quot;fileformat2#btree&quot;&gt;B-tree&lt;/a&gt; storage engine) is the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;.</source>
          <target state="translated">Истинный первичный ключ для таблицы rowid (значение, которое используется в качестве ключа для поиска строк в базовом механизме хранения &lt;a href=&quot;fileformat2#btree&quot;&gt;B-дерева&lt;/a&gt; ) - это &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3f9dae6c570b0f408d716bb105a5e25850cccf9f" translate="yes" xml:space="preserve">
          <source>The truncate optimization can also be disabled at runtime using the &lt;a href=&quot;c3ref/set_authorizer&quot;&gt;sqlite3_set_authorizer()&lt;/a&gt; interface. If an authorizer callback returns &lt;a href=&quot;c3ref/c_deny&quot;&gt;SQLITE_IGNORE&lt;/a&gt; for an &lt;a href=&quot;c3ref/c_alter_table&quot;&gt;SQLITE_DELETE&lt;/a&gt; action code, then the DELETE operation will proceed but the truncate optimization will be bypassed and rows will be deleted one by one.</source>
          <target state="translated">Оптимизацию усечения также можно отключить во время выполнения с помощью интерфейса &lt;a href=&quot;c3ref/set_authorizer&quot;&gt;sqlite3_set_authorizer ()&lt;/a&gt; . Если обратный вызов авторизатора возвращает &lt;a href=&quot;c3ref/c_deny&quot;&gt;SQLITE_IGNORE&lt;/a&gt; для &lt;a href=&quot;c3ref/c_alter_table&quot;&gt;кода&lt;/a&gt; действия SQLITE_DELETE , тогда операция DELETE будет продолжена, но оптимизация усечения будет пропущена, и строки будут удалены одна за другой.</target>
        </trans-unit>
        <trans-unit id="7489f83785acf46d79dbedce76141d020e3a30b4" translate="yes" xml:space="preserve">
          <source>The truncate optimization can be permanently disabled for all queries by recompiling SQLite with the &lt;a href=&quot;compile#omit_truncate_optimization&quot;&gt;SQLITE_OMIT_TRUNCATE_OPTIMIZATION&lt;/a&gt; compile-time switch.</source>
          <target state="translated">Оптимизацию усечения можно навсегда отключить для всех запросов, перекомпилировав SQLite с переключателем времени компиляции &lt;a href=&quot;compile#omit_truncate_optimization&quot;&gt;SQLITE_OMIT_TRUNCATE_OPTIMIZATION&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="30f49567fa43c7d2e5e26ee8efe4338c93c45898" translate="yes" xml:space="preserve">
          <source>The trusted_schema setting is a per-connection boolean that determines whether or not SQL functions and virtual tables that have not been security audited are allowed to be run by views, triggers, or in expressions of the schema such as &lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK constraints&lt;/a&gt;, &lt;a href=&quot;lang_createtable#dfltval&quot;&gt;DEFAULT clauses&lt;/a&gt;, &lt;a href=&quot;gencol&quot;&gt;generated columns&lt;/a&gt;, &lt;a href=&quot;expridx&quot;&gt;expression indexes&lt;/a&gt;, and/or &lt;a href=&quot;partialindex&quot;&gt;partial indexes&lt;/a&gt;. This setting can also be controlled using the &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigtrustedschema&quot;&gt;SQLITE_DBCONFIG_TRUSTED_SCHEMA&lt;/a&gt;,...) C-language interface.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e242c8734781e20213900394ec30db10b58ee560" translate="yes" xml:space="preserve">
          <source>The two &quot;0&quot; parameters do server a purpose in some contexts, but for using these routine to print a parse tree as ASCII-art on the terminal, they should both be &quot;0&quot;.</source>
          <target state="translated">Оба параметра &quot;0&quot; в некоторых контекстах выполняют функцию сервера,но для использования этих рутинных действий для печати дерева разбора в виде ASCII-арта на терминале,оба они должны быть &quot;0&quot;.</target>
        </trans-unit>
        <trans-unit id="46623d6b4b79b06cc3078e791041446a91edf407" translate="yes" xml:space="preserve">
          <source>The two 4-byte big-endian integers at offsets 52 and 64 are used to manage the &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum&lt;/a&gt; and &lt;a href=&quot;pragma#pragma_incremental_vacuum&quot;&gt;incremental_vacuum&lt;/a&gt; modes. If the integer at offset 52 is zero then pointer-map (ptrmap) pages are omitted from the database file and neither auto_vacuum nor incremental_vacuum are supported. If the integer at offset 52 is non-zero then it is the page number of the largest root page in the database file, the database file will contain ptrmap pages, and the mode must be either auto_vacuum or incremental_vacuum. In this latter case, the integer at offset 64 is true for incremental_vacuum and false for auto_vacuum. If the integer at offset 52 is zero then the integer at offset 64 must also be zero.</source>
          <target state="translated">Два 4-байтовых целых числа с &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;прямым порядком&lt;/a&gt; байтов в смещениях 52 и 64 используются для управления режимами auto_vacuum и &lt;a href=&quot;pragma#pragma_incremental_vacuum&quot;&gt;incremental_vacuum&lt;/a&gt; . Если целое число по смещению 52 равно нулю, то страницы указателя-карты (ptrmap) исключаются из файла базы данных, и ни auto_vacuum, ни incremental_vacuum не поддерживаются. Если целое число по смещению 52 не равно нулю, то это номер страницы самой большой корневой страницы в файле базы данных, файл базы данных будет содержать страницы ptrmap, и режим должен быть либо auto_vacuum, либо incremental_vacuum. В этом последнем случае целое число по смещению 64 истинно для incremental_vacuum и ложно для auto_vacuum. Если целое число по смещению 52 равно нулю, то целое число по смещению 64 также должно быть нулевым.</target>
        </trans-unit>
        <trans-unit id="5d5cec8b4b21ae2b9d4802acdeb66477068dae88" translate="yes" xml:space="preserve">
          <source>The two &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued functions&lt;/a&gt; are:</source>
          <target state="translated">Две возвращающие &lt;a href=&quot;vtab#tabfunc2&quot;&gt;табличное значение функции&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="60d1d8fda3bbd4cfca022cc996f0d5a823d5b6ed" translate="yes" xml:space="preserve">
          <source>The two exceptions are:</source>
          <target state="translated">Два исключения:</target>
        </trans-unit>
        <trans-unit id="e1f0bf58781420b540ac606f0e7579a8a2be4378" translate="yes" xml:space="preserve">
          <source>The two fragments of SQL below are similar, but not entirely equivalent, as the latter will fail if the definition of window &quot;win&quot; contains a frame specification.</source>
          <target state="translated">Два фрагмента SQL ниже схожи,но не полностью эквивалентны,так как последний провалится,если определение окна &quot;win&quot; будет содержать спецификацию кадра.</target>
        </trans-unit>
        <trans-unit id="f9a92735a6c1a485477340ad1399f41bdfef6983" translate="yes" xml:space="preserve">
          <source>The two remaining tables, %_segments and %_segdir, are used to store the full-text index. Conceptually, this index is a lookup table that maps each term (word) to the set of docid values corresponding to records in the %_content table that contain one or more occurrences of the term. To retrieve all documents that contain a specified term, the FTS module queries this index to determine the set of docid values for records that contain the term, then retrieves the required documents from the %_content table. Regardless of the schema of the FTS virtual table, the %_segments and %_segdir tables are always created as follows:</source>
          <target state="translated">Остальные две таблицы,%_сегменты и %_сегдир,используются для хранения полнотекстового индекса.Концептуально этот индекс представляет собой поисковую таблицу,которая сопоставляет каждый термин (слово)с набором документальных значений,соответствующих записям в таблице %_content,содержащим одно или несколько вхождений этого термина.Для получения всех документов,которые содержат заданный термин,модуль FTS запрашивает этот индекс для определения набора документальных значений для записей,которые содержат термин,а затем извлекает необходимые документы из таблицы %_content.Независимо от схемы виртуальной таблицы FTS,таблицы %_segments и %_segdir всегда создаются следующим образом:</target>
        </trans-unit>
        <trans-unit id="57eb59a7de5c1f2eacd1a8c2e2793991396d4104" translate="yes" xml:space="preserve">
          <source>The two salt value copied from the WAL file header. These values are in the byte-order of the WAL file, which might be different from the native byte-order of the machine.</source>
          <target state="translated">Два значения соли скопированы из заголовка файла WAL.Эти значения находятся в байтовом порядке файла WAL,который может отличаться от родного байтового порядка машины.</target>
        </trans-unit>
        <trans-unit id="ccc9e431ebc7fabfa6726082e51ef8838fff247f" translate="yes" xml:space="preserve">
          <source>The two-argument version of &lt;a href=&quot;fts3#f3tknzr&quot;&gt;fts3_tokenizer()&lt;/a&gt; accepts a pointer to the tokenizer method object even without the &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config&lt;/a&gt;(&lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigenablefts3tokenizer&quot;&gt;SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER&lt;/a&gt;) setting if the second argument is a &lt;a href=&quot;lang_expr#varparam&quot;&gt;bound parameter&lt;/a&gt;</source>
          <target state="translated">Версия &lt;a href=&quot;fts3#f3tknzr&quot;&gt;fts3_tokenizer () с&lt;/a&gt; двумя аргументами принимает указатель на объект метода токенизатора даже без настройки &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config&lt;/a&gt; ( &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigenablefts3tokenizer&quot;&gt;SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER&lt;/a&gt; ), если второй аргумент является &lt;a href=&quot;lang_expr#varparam&quot;&gt;связанным параметром&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6b8d35e3a824a79bc7ce101b6a6ae7997418f4f7" translate="yes" xml:space="preserve">
          <source>The two-byte integer at offset 1 gives the start of the first freeblock on the page, or is zero if there are no freeblocks.</source>
          <target state="translated">Двухбайтовое целое число со смещением 1 дает начало первого свободного блока на странице,или равно нулю,если свободных блоков нет.</target>
        </trans-unit>
        <trans-unit id="c4473928239ae1bda74a9fb4bb8276860fc5ffb5" translate="yes" xml:space="preserve">
          <source>The two-byte integer at offset 3 gives the number of cells on the page.</source>
          <target state="translated">Двухбайтовое целое число со смещением 3 дает количество ячеек на странице.</target>
        </trans-unit>
        <trans-unit id="a06521372b9101f2c70d6a3c29239fdaf5cbc5a7" translate="yes" xml:space="preserve">
          <source>The two-byte integer at offset 5 designates the start of the cell content area. A zero value for this integer is interpreted as 65536.</source>
          <target state="translated">Двухбайтовое целое число со смещением 5 обозначает начало области содержимого ячейки.Нулевое значение для этого целого числа интерпретируется как 65536.</target>
        </trans-unit>
        <trans-unit id="85da2eb104aa5ac23b3d2218d186677a6dbc8b7e" translate="yes" xml:space="preserve">
          <source>The two-byte value beginning at offset 16 determines the page size of the database. For SQLite versions 3.7.0.1 (2010-08-04) and earlier, this value is interpreted as a big-endian integer and must be a power of two between 512 and 32768, inclusive. Beginning with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_1.html&quot;&gt;version 3.7.1&lt;/a&gt; (2010-08-23), a page size of 65536 bytes is supported. The value 65536 will not fit in a two-byte integer, so to specify a 65536-byte page size, the value at offset 16 is 0x00 0x01. This value can be interpreted as a big-endian 1 and thought of as a magic number to represent the 65536 page size. Or one can view the two-byte field as a little endian number and say that it represents the page size divided by 256. These two interpretations of the page-size field are equivalent.</source>
          <target state="translated">Двухбайтовое значение, начинающееся со смещения 16, определяет размер страницы базы данных. Для версий SQLite 3.7.0.1 (2010-08-04) и более ранних это значение интерпретируется как целое число с прямым порядком байтов и должно быть степенью двойки от 512 до 32768 включительно. Начиная с &lt;a href=&quot;https://sqlite.org/releaselog/3_7_1.html&quot;&gt;версии&lt;/a&gt; SQLite 3.7.1 (2010-08-23), поддерживается размер страницы 65536 байт. Значение 65536 не помещается в двухбайтовое целое число, поэтому, чтобы указать размер страницы 65536 байт, значение по смещению 16 равно 0x00 0x01. Это значение можно интерпретировать как 1 с прямым порядком байтов и рассматривать как магическое число, представляющее размер страницы 65536. Или можно рассматривать двухбайтовое поле как число с прямым порядком байтов и сказать, что оно представляет размер страницы, деленный на 256. Эти две интерпретации поля размера страницы эквивалентны.</target>
        </trans-unit>
        <trans-unit id="d620a0d4c1327669927184e30780adb142926606" translate="yes" xml:space="preserve">
          <source>The typedef is necessary to work around problems in certain C++ compilers.</source>
          <target state="translated">Типef необходим для работы над проблемами в некоторых Си++компиляторах.</target>
        </trans-unit>
        <trans-unit id="2acee6be58c92d0d4d1c18a3c705f7ce6eca583d" translate="yes" xml:space="preserve">
          <source>The typeof(X) function returns a string that indicates the &lt;a href=&quot;datatype3&quot;&gt;datatype&lt;/a&gt; of the expression X: &quot;null&quot;, &quot;integer&quot;, &quot;real&quot;, &quot;text&quot;, or &quot;blob&quot;.</source>
          <target state="translated">Функция typeof (X) возвращает строку, которая указывает &lt;a href=&quot;datatype3&quot;&gt;тип данных&lt;/a&gt; выражения X: &amp;laquo;null&amp;raquo;, &amp;laquo;integer&amp;raquo;, &amp;laquo;real&amp;raquo;, &amp;laquo;text&amp;raquo; или &amp;laquo;blob&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="7de0eb427df1bd72e4d6981f084f01d2fd7b104b" translate="yes" xml:space="preserve">
          <source>The types and default collation sequences attached to each column must be the same for all component tables.</source>
          <target state="translated">Типы и последовательности сверки по умолчанию,прикрепленные к каждому столбцу,должны быть одинаковыми для всех таблиц компонентов.</target>
        </trans-unit>
        <trans-unit id="7a193d6baad5e9eae89c634a076cd20d9e39a2d0" translate="yes" xml:space="preserve">
          <source>The unary operator</source>
          <target state="translated">Унарный оператор</target>
        </trans-unit>
        <trans-unit id="5de3e6de824f9a3c28afdefed054e3e170c8e0d8" translate="yes" xml:space="preserve">
          <source>The uncompress function should uncompress data previously compressed by the compress function. In other words, for all SQLite values X, it should be true that uncompress(compress(X)) equals X. When data that has been compressed by the compress function is read from the database by FTS4, it is passed to the uncompress function before it is used.</source>
          <target state="translated">Функция распаковки должна распаковать данные,ранее сжатые функцией компрессии.Другими словами,для всех значений X в SQLite должно быть верно,что unompress(compress(X))равно X.Когда данные,которые были сжаты функцией компрессии,считываются из базы данных по FTS4,они передаются в функцию распаковки перед использованием.</target>
        </trans-unit>
        <trans-unit id="04cb6e28b7a92f43a8ce66195a1ea7614bfeaae5" translate="yes" xml:space="preserve">
          <source>The underlying implementation can support some subset of these locking levels as long as it meets the other requirements of this paragraph. The locking level is specified as the second argument to both xLock and xUnlock. The xLock method increases the locking level to the specified locking level or higher. The xUnlock method decreases the locking level to no lower than the level specified. &lt;a href=&quot;c3ref/c_lock_exclusive&quot;&gt;SQLITE_LOCK_NONE&lt;/a&gt; means that the file is unlocked. &lt;a href=&quot;c3ref/c_lock_exclusive&quot;&gt;SQLITE_LOCK_SHARED&lt;/a&gt; gives permission to read the file. Multiple database connections can hold &lt;a href=&quot;c3ref/c_lock_exclusive&quot;&gt;SQLITE_LOCK_SHARED&lt;/a&gt; at the same time. &lt;a href=&quot;c3ref/c_lock_exclusive&quot;&gt;SQLITE_LOCK_RESERVED&lt;/a&gt; is like &lt;a href=&quot;c3ref/c_lock_exclusive&quot;&gt;SQLITE_LOCK_SHARED&lt;/a&gt; in that it is permission to read the file. But only a single connection can hold a reserved lock at any point in time. The &lt;a href=&quot;c3ref/c_lock_exclusive&quot;&gt;SQLITE_LOCK_PENDING&lt;/a&gt; is also permission to read the file. Other connections can continue to read the file as well, but no other connection is allowed to escalate a lock from none to shared. &lt;a href=&quot;c3ref/c_lock_exclusive&quot;&gt;SQLITE_LOCK_EXCLUSIVE&lt;/a&gt; is permission to write on the file. Only a single connection can hold an exclusive lock and no other connection can hold any lock (other than &quot;none&quot;) while one connection holds an exclusive lock. The xLock returns &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; on success, &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; if it is unable to obtain the lock, or &lt;a href=&quot;rescode#ioerr_rdlock&quot;&gt;SQLITE_IOERR_RDLOCK&lt;/a&gt; if something else goes wrong. The xUnlock method returns &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; on success and &lt;a href=&quot;rescode#ioerr_unlock&quot;&gt;SQLITE_IOERR_UNLOCK&lt;/a&gt; for problems.</source>
          <target state="translated">Базовая реализация может поддерживать некоторое подмножество этих уровней блокировки, если она соответствует другим требованиям этого параграфа. Уровень блокировки указывается вторым аргументом как для xLock, так и для xUnlock. Метод xLock увеличивает уровень блокировки до указанного уровня блокировки или выше. Метод xUnlock снижает уровень блокировки не ниже указанного. &lt;a href=&quot;c3ref/c_lock_exclusive&quot;&gt;SQLITE_LOCK_NONE&lt;/a&gt; означает, что файл разблокирован. &lt;a href=&quot;c3ref/c_lock_exclusive&quot;&gt;SQLITE_LOCK_SHARED&lt;/a&gt; дает разрешение на чтение файла. &lt;a href=&quot;c3ref/c_lock_exclusive&quot;&gt;SQLITE_LOCK_SHARED&lt;/a&gt; может одновременно содержать несколько соединений с базой данных . &lt;a href=&quot;c3ref/c_lock_exclusive&quot;&gt;SQLITE_LOCK_RESERVED&lt;/a&gt; похож на &lt;a href=&quot;c3ref/c_lock_exclusive&quot;&gt;SQLITE_LOCK_SHARED&lt;/a&gt;в том, что это разрешение на чтение файла. Но только одно соединение может удерживать зарезервированную блокировку в любой момент времени. &lt;a href=&quot;c3ref/c_lock_exclusive&quot;&gt;SQLITE_LOCK_PENDING&lt;/a&gt; также разрешение на чтение файла. Другие соединения также могут продолжать читать файл, но никакому другому соединению не разрешено повышать блокировку с нулевой до общей.&lt;a href=&quot;c3ref/c_lock_exclusive&quot;&gt;SQLITE_LOCK_EXCLUSIVE&lt;/a&gt; - это разрешение на запись в файл. Только одно соединение может удерживать исключительную блокировку, и никакое другое соединение не может удерживать какую-либо блокировку (кроме &quot;none&quot;), в то время как одно соединение имеет исключительную блокировку. XLock возвращает &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; в случае успеха, &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY,&lt;/a&gt; если он не может получить блокировку, или &lt;a href=&quot;rescode#ioerr_rdlock&quot;&gt;SQLITE_IOERR_RDLOCK,&lt;/a&gt; если что-то еще пойдет не так. Метод xUnlock возвращает&lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; при успехе и &lt;a href=&quot;rescode#ioerr_unlock&quot;&gt;SQLITE_IOERR_UNLOCK&lt;/a&gt; при проблемах.</target>
        </trans-unit>
        <trans-unit id="0269000c82eb39065f294879a620aecf2c6e833d" translate="yes" xml:space="preserve">
          <source>The underscore character (unicode codepoint 96).</source>
          <target state="translated">Символ подчёркивания (кодовый знак юникода 96).</target>
        </trans-unit>
        <trans-unit id="94b1d236b1b1bdea969b9f218085fccfc7fb6de3" translate="yes" xml:space="preserve">
          <source>The undo::activate command creates temporary triggers in the database that record all changes made to the tables named in the arguments.</source>
          <target state="translated">Команда undo::activate создает в БД временные триггеры,которые записывают все изменения,внесенные в таблицы с именами в аргументах.</target>
        </trans-unit>
        <trans-unit id="9d719f9a44e55c933ab5b5fa11156ee426d1545d" translate="yes" xml:space="preserve">
          <source>The undocumented &lt;b&gt;sqlite3_os_switch()&lt;/b&gt; interface has been removed.</source>
          <target state="translated">Недокументированный интерфейс &lt;b&gt;sqlite3_os_switch ()&lt;/b&gt; был удален.</target>
        </trans-unit>
        <trans-unit id="93cdbdaae25242141056e83b2feecd9f656881a8" translate="yes" xml:space="preserve">
          <source>The unicode tokenizer classifies all unicode characters as either &quot;separator&quot; or &quot;token&quot; characters. By default all space and punctuation characters, as defined by Unicode 6.1, are considered separators, and all other characters as token characters. More specifically, all unicode characters assigned to a &lt;a href=&quot;https://en.wikipedia.org/wiki/Unicode_character_property#General_Category&quot;&gt; general category&lt;/a&gt; beginning with &quot;L&quot; or &quot;N&quot; (letters and numbers, specifically) or to category &quot;Co&quot; (&quot;other, private use&quot;) are considered tokens. All other characters are separators.</source>
          <target state="translated">Токенизатор Юникода классифицирует все символы Юникода как символы-разделители или символы-токены. По умолчанию все пробелы и знаки препинания, как определено в Unicode 6.1, считаются разделителями, а все остальные символы - символами-маркерами. Более конкретно, все символы Юникода, присвоенные &lt;a href=&quot;https://en.wikipedia.org/wiki/Unicode_character_property#General_Category&quot;&gt;общей категории,&lt;/a&gt; начинающейся с &amp;laquo;L&amp;raquo; или &amp;laquo;N&amp;raquo; (буквы и цифры, в частности) или категории &amp;laquo;Со&amp;raquo; (&amp;laquo;другое, личное использование&amp;raquo;), считаются токенами. Все остальные символы являются разделителями.</target>
        </trans-unit>
        <trans-unit id="8359d1281537e2db390ccb27a011cf0c1e07387b" translate="yes" xml:space="preserve">
          <source>The unicode(X) function returns the numeric unicode code point corresponding to the first character of the string X. If the argument to unicode(X) is not a string then the result is undefined.</source>
          <target state="translated">Функция unicode(X)возвращает числовую точку кода юникода,соответствующую первому символу строки X.Если аргумент к unicode(X)не является строкой,то результат является неопределенным.</target>
        </trans-unit>
        <trans-unit id="b06912261f5bb2d984a2ea7d12c5ea40ed3062a1" translate="yes" xml:space="preserve">
          <source>The union-vtab is not built into SQLite. Union-vtab is a &lt;a href=&quot;loadext&quot;&gt;loadable extension&lt;/a&gt;. The source code for union-vtab is contained in a single file located at &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/unionvtab.c&quot;&gt;ext/misc/unionvtab.c&lt;/a&gt; in the SQLite source tree.</source>
          <target state="translated">Union-vtab не встроен в SQLite. Union-vtab - это&lt;a href=&quot;loadext&quot;&gt; загружаемое расширение&lt;/a&gt; . Исходный код union-vtab содержится в одном файле, расположенном по адресу &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/unionvtab.c&quot;&gt;ext / misc / unionvtab.c&lt;/a&gt; в дереве исходных текстов SQLite.</target>
        </trans-unit>
        <trans-unit id="70f606d5ad9373cd7360030770268b87dc04b4a8" translate="yes" xml:space="preserve">
          <source>The union-vtab is read-only. Support for writing may be added at a later time, but writing is not a part of the initial implementation.</source>
          <target state="translated">Юнион-втаб доступен только для чтения.Поддержка написания может быть добавлена позже,но написание не является частью первоначальной реализации.</target>
        </trans-unit>
        <trans-unit id="217c127b8d7dc9166357c6c852e4edb92e8bd2cc" translate="yes" xml:space="preserve">
          <source>The union-vtab shall optimize access to the underlying real tables when the constraints on the query are among forms shown below. Other kinds of constraints may be optimized in the future, but only these constraints are optimized in the initial implementation.</source>
          <target state="translated">Union-vtab должен оптимизировать доступ к основным реальным таблицам,когда ограничения на запрос входят в число форм,показанных ниже.Другие виды ограничений могут быть оптимизированы в будущем,но только эти ограничения оптимизируются в начальной реализации.</target>
        </trans-unit>
        <trans-unit id="5ad25f83f6534911bf90077b4a8c2d24284bf894" translate="yes" xml:space="preserve">
          <source>The unique id (INTEGER PRIMARY KEY)</source>
          <target state="translated">Уникальный идентификатор (INTEGER PRIMARY KEY).</target>
        </trans-unit>
        <trans-unit id="37c73afc15f55751239631e696091c5fb7a86756" translate="yes" xml:space="preserve">
          <source>The unix &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; will never use a file descriptor less than</source>
          <target state="translated">Unix &lt;a href=&quot;vfs&quot;&gt; VFS&lt;/a&gt; никогда не будет использовать дескриптор файла меньше, чем</target>
        </trans-unit>
        <trans-unit id="ae8287e8b161fa1549dd3442fa8607f53d8dfe62" translate="yes" xml:space="preserve">
          <source>The unlikely(X) function returns the argument X unchanged. The unlikely(X) function is a no-op that the code generator optimizes away so that it consumes no CPU cycles at run-time (that is, during calls to &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt;). The purpose of the unlikely(X) function is to provide a hint to the query planner that the argument X is a boolean value that is usually not true. The unlikely(X) function is equivalent to &lt;a href=&quot;lang_corefunc#likelihood&quot;&gt;likelihood&lt;/a&gt;(X, 0.0625).</source>
          <target state="translated">Функция маловероятно (X) возвращает аргумент X без изменений. Маловероятная (X) функция - это запретная операция, которую генератор кода оптимизирует, чтобы не потреблять циклы ЦП во время выполнения (то есть во время вызовов &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step ()&lt;/a&gt; ). Назначение маловероятной (X) функции - указать планировщику запросов, что аргумент X является логическим значением, которое обычно не соответствует действительности. Функция маловероятной (X) эквивалентна &lt;a href=&quot;lang_corefunc#likelihood&quot;&gt;правдоподобию&lt;/a&gt; (X, 0,0625).</target>
        </trans-unit>
        <trans-unit id="f74bf3865d4b8d380ed09cdf9682ebd8ba365f80" translate="yes" xml:space="preserve">
          <source>The unlock-notify callback is not reentrant. If an application invokes any sqlite3_xxx API functions from within an unlock-notify callback, a crash or deadlock may be the result.</source>
          <target state="translated">Обратный звонок по разблокировке не возвращается.Если приложение вызывает какие-либо функции sqlite3_xxx API в рамках обратного вызова уведомления о разблокировке,может произойти аварийное завершение работы или тупик.</target>
        </trans-unit>
        <trans-unit id="9f10c2e623337226e56371f152fe9704c596a75e" translate="yes" xml:space="preserve">
          <source>The unlock_notify method is used access the &lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify()&lt;/a&gt; interface to the SQLite core library for testing purposes. The use of this method by applications is discouraged.</source>
          <target state="translated">Метод unlock_notify используется для доступа к &lt;a href=&quot;c3ref/unlock_notify&quot;&gt;&lt;/a&gt; интерфейсу sqlite3_unlock_notify () к основной библиотеке SQLite в целях тестирования. Использование этого метода приложениями не рекомендуется.</target>
        </trans-unit>
        <trans-unit id="c0db7fcedecb648c350c1b6f11ba954f23165737" translate="yes" xml:space="preserve">
          <source>The update hook implementation must not do anything that will modify the database connection that invoked the update hook. Any actions to modify the database connection must be deferred until after the completion of the &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; call that triggered the update hook. Note that &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; both modify their database connections for the meaning of &quot;modify&quot; in this paragraph.</source>
          <target state="translated">Реализация ловушки обновления не должна делать ничего, что изменило бы соединение с базой данных, вызвавшее ловушку обновления. Любые действия по изменению подключения к базе данных должны быть отложены до завершения вызова &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step (),&lt;/a&gt; который запустил ловушку обновления. Обратите внимание, что &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; и &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step ()&lt;/a&gt; оба изменяют свои соединения с базой данных для значения слова &amp;laquo;изменить&amp;raquo; в этом абзаце.</target>
        </trans-unit>
        <trans-unit id="09532968164962481e11046837aaa8bacbe59ea0" translate="yes" xml:space="preserve">
          <source>The update hook implementation must not do anything that will modify the database connection that invoked the update hook. Any actions to modify the database connection must be deferred until after the completion of the &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; call that triggered the update hook. Note that &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; and &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; both modify their database connections for the meaning of &quot;modify&quot; in this paragraph.</source>
          <target state="translated">Реализация ловушки обновления не должна делать ничего, что изменило бы соединение с базой данных, вызвавшее ловушку обновления. Любые действия по изменению подключения к базе данных должны быть отложены до завершения вызова &lt;a href=&quot;step&quot;&gt;sqlite3_step (),&lt;/a&gt; который запустил ловушку обновления. Обратите внимание, что &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; и &lt;a href=&quot;step&quot;&gt;sqlite3_step ()&lt;/a&gt; оба изменяют свои соединения с базой данных для значения слова &amp;laquo;изменить&amp;raquo; в этом абзаце.</target>
        </trans-unit>
        <trans-unit id="f188e349260d6d862bd1151de1aa0b41c96135c8" translate="yes" xml:space="preserve">
          <source>The update hook is not invoked when internal system tables are modified (i.e. sqlite_master and sqlite_sequence). The update hook is not invoked when &lt;a href=&quot;../withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables are modified.</source>
          <target state="translated">Ловушка обновления не вызывается при изменении внутренних системных таблиц (например, sqlite_master и sqlite_sequence). &lt;a href=&quot;../withoutrowid&quot;&gt;Ловушка&lt;/a&gt; обновления не вызывается при изменении таблиц БЕЗ ROWID .</target>
        </trans-unit>
        <trans-unit id="d4c3b215f10d00c42f1094ebb70e270136be0ef6" translate="yes" xml:space="preserve">
          <source>The update hook is not invoked when internal system tables are modified (i.e. sqlite_master and sqlite_sequence). The update hook is not invoked when &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables are modified.</source>
          <target state="translated">Ловушка обновления не вызывается при изменении внутренних системных таблиц (например, sqlite_master и sqlite_sequence). &lt;a href=&quot;withoutrowid&quot;&gt;Ловушка&lt;/a&gt; обновления не вызывается при изменении таблиц БЕЗ ROWID .</target>
        </trans-unit>
        <trans-unit id="f04fa9936d514fac1b991da703764bce23461785" translate="yes" xml:space="preserve">
          <source>The update hook is not invoked when internal system tables are modified (i.e. sqlite_sequence). The update hook is not invoked when &lt;a href=&quot;../withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables are modified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b14dc5637688b2512ff9a25b9caa046cb0c8fc2" translate="yes" xml:space="preserve">
          <source>The update hook is not invoked when internal system tables are modified (i.e. sqlite_sequence). The update hook is not invoked when &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables are modified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b3d709a5bf6d8d9c48b677160252ac4da74295a" translate="yes" xml:space="preserve">
          <source>The upper bound on the database &lt;a href=&quot;pragma#pragma_cache_size&quot;&gt;cache size&lt;/a&gt; has traditionally defaulted to 2000 pages. SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_12_0.html&quot;&gt;version 3.12.0&lt;/a&gt; also changes this default setting to be &quot;-2000&quot; which means 2000*1024 bytes, regardless of page size. So, the upper bound on the amount of memory used for the page cache is unchanged.</source>
          <target state="translated">Верхняя граница &lt;a href=&quot;pragma#pragma_cache_size&quot;&gt;размера кэша&lt;/a&gt; базы данных по умолчанию составляет 2000 страниц. SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_12_0.html&quot;&gt;версии 3.12.0&lt;/a&gt; также изменяет этот параметр по умолчанию на &amp;laquo;-2000&amp;raquo;, что означает 2000 * 1024 байта, независимо от размера страницы. Таким образом, верхняя граница объема памяти, используемой для кеширования страниц, не изменилась.</target>
        </trans-unit>
        <trans-unit id="55e210be964a43ed3f79f81acfb0252d2ec508a2" translate="yes" xml:space="preserve">
          <source>The upper(X) function returns a copy of input string X in which all lower-case ASCII characters are converted to their upper-case equivalent.</source>
          <target state="translated">Функция upper(X)возвращает копию входной строки X,в которой все строчные ASCII-символы преобразуются в их прописной эквивалент.</target>
        </trans-unit>
        <trans-unit id="2ff3bb49a7df2e57465c506adbfbac36859c676c" translate="yes" xml:space="preserve">
          <source>The upsert above inserts the new vocabulary word &quot;jovial&quot; if that word is not already in the dictionary, or if it is already in the dictionary, it increments the counter. The &quot;count+1&quot; expression could also be written as &quot;vocabulary.count&quot;. PostgreSQL requires the second form, but SQLite accepts either.</source>
          <target state="translated">Вверху вставляется новое словосочетание &quot;йовиальный&quot;,если этого слова еще нет в словаре,или если оно уже есть в словаре,оно увеличивает счетчик.Выражение &quot;счет+1&quot; также может быть записано как &quot;vocabulary.count&quot;.PostgreSQL требует второй формы,но SQLite принимает и то,и другое.</target>
        </trans-unit>
        <trans-unit id="f98914d65daf1eee948f9cf4215d1bc155ef41fa" translate="yes" xml:space="preserve">
          <source>The usage of pagecache memory is somewhat harder to control in SQLite version 3.6.1, though mechanisms are planned for subsequent releases that will make controlling pagecache memory much easier. Prior to the introduction of these new mechanisms, the only way to control pagecache memory is using the &lt;a href=&quot;pragma#pragma_cache_size&quot;&gt;cache_size pragma&lt;/a&gt;.</source>
          <target state="translated">Использование памяти pagecache несколько сложнее контролировать в SQLite версии 3.6.1, хотя в последующих выпусках запланированы механизмы, которые значительно упростят управление памятью pagecache. До введения этих новых механизмов единственным способом управления памятью кэша страниц было использование &lt;a href=&quot;pragma#pragma_cache_size&quot;&gt;прагмы cache_size&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="83c37f6e9e518d22e126d6f49713b321c1f31d9b" translate="yes" xml:space="preserve">
          <source>The use of &quot;:&quot; instead of &quot;$&quot; before the name of a variable can sometimes be useful if the SQL text is enclosed in double-quotes &quot;...&quot; instead of curly-braces {...}. When the SQL is contained within double-quotes &quot;...&quot; then TCL will do the substitution of $-variables, which can lead to SQL injection if extreme care is not used. But TCL will never substitute a :-variable regardless of whether double-quotes &quot;...&quot; or curly-braces {...} are used to enclose the SQL, so the use of :-variables adds an extra measure of defense against SQL injection.</source>
          <target state="translated">Использование &quot;:&quot; вместо &quot;$&quot; перед именем переменной иногда может быть полезно,если SQL текст заключен в двойные кавычки &quot;...&quot; вместо фигурных скобок {...}.Когда SQL заключен в двойные кавычки &quot;...&quot;,то TCL сделает замену $-переменных,что может привести к SQL инъекции,если не использовать крайние меры предосторожности.Но TCL никогда не заменит :-переменную независимо от того,используются ли двойные кавычки &quot;...&quot; или фигурные скобки {...}для вложения SQL,поэтому использование :-переменных добавляет дополнительную меру защиты от SQL инъекции.</target>
        </trans-unit>
        <trans-unit id="c10b4d5006af0e657932026cc02e7f4a31cf3940" translate="yes" xml:space="preserve">
          <source>The use of NUL characters in SQL text strings is not recommended.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53ba0fe6640d81c27b2028a34ac03622ddcd61d3" translate="yes" xml:space="preserve">
          <source>The use of a ZIP archive to encapsulate XML files plus resources is an elegant approach to an application file format. It is clearly superior to a custom binary file format. But using an SQLite database as the container, instead of ZIP, would be more elegant still.</source>
          <target state="translated">Использование ZIP-архива для инкапсуляции XML-файлов плюс ресурсов является элегантным подходом к формату файла приложения.Он явно превосходит пользовательский двоичный формат файла.Но использование базы данных SQLite в качестве контейнера вместо ZIP было бы еще более элегантным.</target>
        </trans-unit>
        <trans-unit id="62a1d7ca77be3f3b5567800401dc0bf052c2aaae" translate="yes" xml:space="preserve">
          <source>The use of a virtual machine in SQLite has been a great benefit to the library's development. The virtual machine provides a crisp, well-defined junction between the front-end of SQLite (the part that parses SQL statements and generates virtual machine code) and the back-end (the part that executes the virtual machine code and computes a result.) The virtual machine allows the developers to see clearly and in an easily readable form what SQLite is trying to do with each statement it compiles, which is a tremendous help in debugging. Depending on how it is compiled, SQLite also has the capability of tracing the execution of the virtual machine - printing each virtual machine instruction and its result as it executes.</source>
          <target state="translated">Использование виртуальной машины в SQLite было большим преимуществом при разработке библиотеки.Виртуальная машина обеспечивает четкий,четко определенный переход между внешним интерфейсом SQLite (часть,которая разбирает SQL-операторы и генерирует код виртуальной машины)и внутренним интерфейсом (часть,которая выполняет код виртуальной машины и вычисляет результат).Виртуальная машина позволяет разработчикам четко и в легко читаемом виде видеть,что SQLite пытается сделать с каждым оператором,который он компилирует,что является огромным подспорьем в отладке.В зависимости от того,как она компилируется,SQLite также имеет возможность отслеживать выполнение виртуальной машины-распечатывать каждую инструкцию виртуальной машины и ее результат по мере выполнения.</target>
        </trans-unit>
        <trans-unit id="9d27ce1c6f5449fceeec41db3a7baef374e89122" translate="yes" xml:space="preserve">
          <source>The use of each of these methods will be explained in the sequel, though not in the order shown above.</source>
          <target state="translated">Использование каждого из этих методов будет объяснено в сиквеле,хотя и не в порядке,показанном выше.</target>
        </trans-unit>
        <trans-unit id="ac3e9e4d3a0d1a6a51dbf276370664c84cd0bc3c" translate="yes" xml:space="preserve">
          <source>The use of persistent journal mode provides a noticeable performance improvement on many systems. Of course, the drawback is that the journal files remain on the disk, using disk space and cluttering directories, long after the transaction commits. The only safe way to delete a persistent journal file is to commit a transaction with journaling mode set to DELETE:</source>
          <target state="translated">Использование режима постоянного журнала обеспечивает заметное повышение производительности многих систем.Конечно,недостатком является то,что файлы журнала остаются на диске,используя дисковое пространство и загромождающие каталоги,долгое время после фиксации транзакции.Единственный безопасный способ удалить файл постоянного журнала-это зафиксировать транзакцию в режиме записи,установленном в DELETE:</target>
        </trans-unit>
        <trans-unit id="ac2e1cc15280219a058aa01cbdd9d14acc3c174c" translate="yes" xml:space="preserve">
          <source>The use of pointer-passing is an advanced technique that should be used infrequently and cautiously. Pointer-passing should not be used haphazardly or carelessly. Pointer-passing is a sharp tool that can leave deep scars if misused.</source>
          <target state="translated">Использование обхода указателя-это продвинутая техника,которую следует использовать нечасто и с осторожностью.Указка-обход не должна использоваться бессистемно или небрежно.Указка-обход является острым инструментом,который может оставить глубокие шрамы при неправильном использовании.</target>
        </trans-unit>
        <trans-unit id="716439e76a7ceab1c8c91b09a2f76c73c53bf8c1" translate="yes" xml:space="preserve">
          <source>The use of subtypes on pointers prevented pointer forgery using pure SQL. But subtypes do nothing to prevent an attacker from reading the values of pointers. In other words, subtypes on pointer values prevent attacks using SQL statements like this:</source>
          <target state="translated">Использование подтипов на указателях предотвратило подделку указателей с использованием чистого SQL.Но подтипы ничего не делают для того,чтобы помешать злоумышленнику читать значения указателей.Другими словами,подтипы на значениях указателей предотвращают атаки с использованием подобных SQL выражений:</target>
        </trans-unit>
        <trans-unit id="d8ed607375ddfb8582a61f0a5132f51fb52c53b0" translate="yes" xml:space="preserve">
          <source>The use of the &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt; is recommended for all applications.</source>
          <target state="translated">Использование &lt;a href=&quot;amalgamation&quot;&gt;амальгамации&lt;/a&gt; рекомендуется для всех приложений.</target>
        </trans-unit>
        <trans-unit id="789c46abbb3fc4976d476150773395da4c1e0a98" translate="yes" xml:space="preserve">
          <source>The use of the UTF-8 interfaces is preferred, as SQLite currently does all parsing using UTF-8. The UTF-16 interfaces are provided as a convenience. The UTF-16 interfaces work by converting the input text into UTF-8, then invoking the corresponding UTF-8 interface.</source>
          <target state="translated">Предпочтительно использовать интерфейсы UTF-8,так как SQLite в настоящее время выполняет весь парсинг с использованием UTF-8.Интерфейсы UTF-16 предоставляются для удобства.Интерфейсы UTF-16 работают путем преобразования входного текста в UTF-8,а затем вызова соответствующего интерфейса UTF-8.</target>
        </trans-unit>
        <trans-unit id="7ed5c8c8570cfb3a0d0049b76c3fa5c381dc896c" translate="yes" xml:space="preserve">
          <source>The use of the error logger callback is highly recommended. The debugging information that the error logger provides has proven very useful in tracking down obscure problems that occurs with applications after they get into the field. The error logger callback has also proven useful in catching errors occasional errors that the application misses because of inconsistent checking of API return codes. Developers are encouraged to implement an error logger callback early in the development cycle in order to spot unexpected behavior quickly, and to leave the error logger callback turned on through deployment. If the error logger never finds a problem, then no harm is done. But failure to set up an appropriate error logger might compromise diagnostic capabilities later on.</source>
          <target state="translated">Настоятельно рекомендуется использовать обратный вызов регистратора ошибок.Отладочная информация,предоставляемая регистратором ошибок,оказалась очень полезной для отслеживания неясных проблем,которые возникают с приложениями после того,как они попадают в поле.Обратный вызов регистратора ошибок также оказался полезным для отлова случайных ошибок,которые приложение пропускает из-за непоследовательной проверки кодов возврата API.Разработчикам рекомендуется реализовать обратный вызов регистратора ошибок на ранней стадии цикла разработки,чтобы быстро обнаружить неожиданное поведение и оставить включенным обратный вызов регистратора ошибок во время развертывания.Если регистратор ошибок никогда не найдет проблему,то вреда от этого не будет.Но неустановка соответствующего регистратора ошибок может впоследствии поставить под угрозу диагностические возможности.</target>
        </trans-unit>
        <trans-unit id="a848d528e6bb7ea17daf03362baa03e736e192f7" translate="yes" xml:space="preserve">
          <source>The use of the standardized speedtest1.c workload and cachegrind has enabled significant performance improvement. However, it is important to recognize the limitations of this approach:</source>
          <target state="translated">Использование стандартизированной рабочей нагрузки speedtest1.c и кэшфренда позволило значительно повысить производительность.Однако важно признать ограничения этого подхода:</target>
        </trans-unit>
        <trans-unit id="fbf470196dd9e32d7a6c5961b17698cfadfdbb60" translate="yes" xml:space="preserve">
          <source>The use of variable-length records by SQLite has a number of advantages. It results in smaller database files, obviously. It also makes the database run faster, since there is less information to move to and from disk. And, the use of variable-length records makes it possible for SQLite to employ manifest typing instead of static typing.</source>
          <target state="translated">Использование SQLite записей переменной длины имеет ряд преимуществ.Очевидно,что это приводит к меньшему размеру файлов базы данных.Кроме того,это ускоряет работу базы данных,т.к.меньше информации нужно перемещать на диск и с диска.Кроме того,использование записей переменной длины позволяет SQLite использовать манифестный набор текста вместо статического.</target>
        </trans-unit>
        <trans-unit id="f495ec4a4bf3743c12d1f50425c742888001cad3" translate="yes" xml:space="preserve">
          <source>The user_version pragma will to get or set the value of the user-version integer at offset 60 in the &lt;a href=&quot;fileformat2#database_header&quot;&gt;database header&lt;/a&gt;. The user-version is an integer that is available to applications to use however they want. SQLite makes no use of the user-version itself.</source>
          <target state="translated">Прагма user_version будет получать или устанавливать значение целого числа версии пользователя по смещению 60 в &lt;a href=&quot;fileformat2#database_header&quot;&gt;заголовке базы данных&lt;/a&gt; . Версия пользователя - это целое число, которое доступно приложениям для использования по своему усмотрению. SQLite не использует саму пользовательскую версию.</target>
        </trans-unit>
        <trans-unit id="81fbf2e7b21c5d201e92f96deae7ccf53bbeeddc" translate="yes" xml:space="preserve">
          <source>The usermerge option is similar to the automerge and crisismerge options. It is the minimum number of b-tree segments that will be merged together by a 'merge' command with a positive parameter. For example:</source>
          <target state="translated">Опция usermerge похожа на опции automerge и crisismerge.Это минимальное количество сегментов b-дерева,которые будут объединены командой 'слияние' с положительным параметром.Например:</target>
        </trans-unit>
        <trans-unit id="7380a4170d0b89318a355604d7dab9b3376f5f00" translate="yes" xml:space="preserve">
          <source>The usual &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;, &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;, and &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; commands work on an R*Tree index just like on regular tables. So to insert some data into our sample R*Tree index, we can do something like this:</source>
          <target state="translated">Обычные команды &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; , &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; и &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; работают с индексом R * Tree так же, как и с обычными таблицами. Итак, чтобы вставить некоторые данные в наш пример индекса R * Tree, мы можем сделать что-то вроде этого:</target>
        </trans-unit>
        <trans-unit id="7245ad2ccb3652b74420857f1f81436b120932a2" translate="yes" xml:space="preserve">
          <source>The usual case is that sqlite3_serialize() copies the serialization of the database into memory obtained from &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc64()&lt;/a&gt; and returns a pointer to that memory. The caller is responsible for freeing the returned value to avoid a memory leak. However, if the F argument contains the SQLITE_SERIALIZE_NOCOPY bit, then no memory allocations are made, and the sqlite3_serialize() function will return a pointer to the contiguous memory representation of the database that SQLite is currently using for that database, or NULL if the no such contiguous memory representation of the database exists. A contiguous memory representation of the database will usually only exist if there has been a prior call to &lt;a href=&quot;#sqlite3_deserialize&quot;&gt;sqlite3_deserialize(D,S,...)&lt;/a&gt; with the same values of D and S. The size of the database is written into *P even if the SQLITE_SERIALIZE_NOCOPY bit is set but no contiguous copy of the database exists.</source>
          <target state="translated">Обычно sqlite3_serialize () копирует сериализацию базы данных в память, полученную из &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc64 (),&lt;/a&gt; и возвращает указатель на эту память. Вызывающий отвечает за освобождение возвращаемого значения во избежание утечки памяти. Однако, если аргумент F содержит бит SQLITE_SERIALIZE_NOCOPY, то выделение памяти не производится, и функция sqlite3_serialize () вернет указатель на непрерывное представление памяти базы данных, которую SQLite в настоящее время использует для этой базы данных, или NULL, если нет такое непрерывное представление базы данных в памяти существует. Непрерывное представление базы данных в памяти обычно существует только в том случае, если был предыдущий вызов &lt;a href=&quot;#sqlite3_deserialize&quot;&gt;sqlite3_deserialize (D, S, ...)&lt;/a&gt; с теми же значениями D и S. Размер базы данных записывается в * P, даже если бит SQLITE_SERIALIZE_NOCOPY установлен, но непрерывной копии базы данных не существует.</target>
        </trans-unit>
        <trans-unit id="69659aa2e08fcc19f80f4fa144bcabaf8c7b3ed8" translate="yes" xml:space="preserve">
          <source>The usual case is that sqlite3_serialize() copies the serialization of the database into memory obtained from &lt;a href=&quot;free&quot;&gt;sqlite3_malloc64()&lt;/a&gt; and returns a pointer to that memory. The caller is responsible for freeing the returned value to avoid a memory leak. However, if the F argument contains the SQLITE_SERIALIZE_NOCOPY bit, then no memory allocations are made, and the sqlite3_serialize() function will return a pointer to the contiguous memory representation of the database that SQLite is currently using for that database, or NULL if the no such contiguous memory representation of the database exists. A contiguous memory representation of the database will usually only exist if there has been a prior call to &lt;a href=&quot;deserialize&quot;&gt;sqlite3_deserialize(D,S,...)&lt;/a&gt; with the same values of D and S. The size of the database is written into *P even if the SQLITE_SERIALIZE_NOCOPY bit is set but no contiguous copy of the database exists.</source>
          <target state="translated">Обычно sqlite3_serialize () копирует сериализацию базы данных в память, полученную из &lt;a href=&quot;free&quot;&gt;sqlite3_malloc64 (),&lt;/a&gt; и возвращает указатель на эту память. Вызывающий отвечает за освобождение возвращаемого значения во избежание утечки памяти. Однако, если аргумент F содержит бит SQLITE_SERIALIZE_NOCOPY, то выделение памяти не производится, и функция sqlite3_serialize () вернет указатель на непрерывное представление памяти базы данных, которую SQLite в настоящее время использует для этой базы данных, или NULL, если нет такое непрерывное представление базы данных в памяти существует. Непрерывное представление базы данных в памяти обычно существует только в том случае, если был предыдущий вызов &lt;a href=&quot;deserialize&quot;&gt;sqlite3_deserialize (D, S, ...)&lt;/a&gt; с теми же значениями D и S. Размер базы данных записывается в * P, даже если бит SQLITE_SERIALIZE_NOCOPY установлен, но непрерывной копии базы данных не существует.</target>
        </trans-unit>
        <trans-unit id="2878cf43bc017da229299a9eeb8ee3b6c95340de" translate="yes" xml:space="preserve">
          <source>The usual case is that the entire database file is checked. However, if the argument is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fc6512389ff21ec6ba0d889f8647d34fa1771be" translate="yes" xml:space="preserve">
          <source>The usual output is an SQL script that will transform database1.sqlite (the &quot;source&quot; database) into database2.sqlite (the &quot;destination&quot; database). This behavior can be altered using command-line switches:</source>
          <target state="translated">Обычный вывод-это SQL скрипт,который преобразует database1.sqlite (&quot;исходную&quot; БД)в database2.sqlite (&quot;целевую&quot; БД).Это поведение может быть изменено с помощью переключателей командной строки:</target>
        </trans-unit>
        <trans-unit id="ebe7d136ea02a608354f8bf5123226386a80e2bf" translate="yes" xml:space="preserve">
          <source>The usual usage pattern for an sqlite3_changegroup object is as follows:</source>
          <target state="translated">Обычный шаблон использования объекта sqlite3_changegroup следующий:</target>
        </trans-unit>
        <trans-unit id="f006b61943f366c81b0414ad0d7a764b14620096" translate="yes" xml:space="preserve">
          <source>The usual way of storing a date in a database table is as a single field, as either a unix timestamp, a julian day number, or an ISO-8601 dates string. But some application store dates as three separate fields for the year, month, and day.</source>
          <target state="translated">Обычный способ хранения даты в таблице базы данных-в виде одного поля,в виде одноименной метки времени,юлианского номера дня или строки с датами в формате ISO-8601.Но некоторые приложения хранят даты в виде трех отдельных полей для года,месяца и дня.</target>
        </trans-unit>
        <trans-unit id="e446494ebae458b5aea2681dfd535005a9fb5001" translate="yes" xml:space="preserve">
          <source>The value</source>
          <target state="translated">Значение</target>
        </trans-unit>
        <trans-unit id="1493e5c49d89b37715d26870b14178bb98eff899" translate="yes" xml:space="preserve">
          <source>The value extracted is stored in register P3.</source>
          <target state="translated">Извлеченное значение сохраняется в регистре P3.</target>
        </trans-unit>
        <trans-unit id="b67d4fe7f5972a61b5da20c2ef9a98c84328f043" translate="yes" xml:space="preserve">
          <source>The value of NEW.rowid is undefined in a BEFORE INSERT trigger in which the rowid is not explicitly set to an integer.</source>
          <target state="translated">Значение NEW.rowid не определено в триггере BEFORE INSERT,в котором rowid явно не установлен в целое число.</target>
        </trans-unit>
        <trans-unit id="6ccbeb6aa89a69300ffd6eb190f7535f8bc566cf" translate="yes" xml:space="preserve">
          <source>The value of SQLITE_THREADSAFE can be determined at run-time using the &lt;a href=&quot;c3ref/threadsafe&quot;&gt;sqlite3_threadsafe()&lt;/a&gt; interface.</source>
          <target state="translated">Значение SQLITE_THREADSAFE можно определить во время выполнения с помощью интерфейса &lt;a href=&quot;c3ref/threadsafe&quot;&gt;sqlite3_threadsafe ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d5ab5daf4c7771df3bc76b4527132dffd8bea934" translate="yes" xml:space="preserve">
          <source>The value of an &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; column must always be a non-NULL integer. The PRIMARY KEY columns of a &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; table are also required to be non-NULL.</source>
          <target state="translated">Значение столбца &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; всегда должно быть целым числом, отличным от NULL. Столбцы PRIMARY KEY таблицы &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; также должны быть не NULL.</target>
        </trans-unit>
        <trans-unit id="94d5eebfcf21e24cf605bf00db4a0642798783cd" translate="yes" xml:space="preserve">
          <source>The value of the N parameter to these interfaces should be non-negative. Future enhancements may make use of negative N values to define new kinds of function caching behavior.</source>
          <target state="translated">Значение параметра N для этих интерфейсов должно быть неотрицательным.Будущие усовершенствования могут использовать отрицательные значения N для определения новых типов поведения кэширования функций.</target>
        </trans-unit>
        <trans-unit id="cc7bdc3b5bd50bd43536e1eeee3d4c188a48e335" translate="yes" xml:space="preserve">
          <source>The value of the change counter is copied to the database handle change counter (returned by subsequent calls to sqlite3_changes()). Then the VMs internal change counter resets to 0. This is used by trigger programs.</source>
          <target state="translated">Значение счетчика изменений копируется в счетчик изменений хэндла (возвращается последующими вызовами sqlite3_changes()).Затем внутренний счетчик изменений ВМ сбрасывается на 0,что используется триггерными программами.</target>
        </trans-unit>
        <trans-unit id="4a5b194cd44f85aade16e1c37ccac8a115177304" translate="yes" xml:space="preserve">
          <source>The value returned by sqlite3_backup_finish is &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; if no sqlite3_backup_step() errors occurred, regardless or whether or not sqlite3_backup_step() completed. If an out-of-memory condition or IO error occurred during any prior sqlite3_backup_step() call on the same &lt;a href=&quot;#sqlite3_backup&quot;&gt;sqlite3_backup&lt;/a&gt; object, then sqlite3_backup_finish() returns the corresponding &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt;.</source>
          <target state="translated">Значение, возвращаемое sqlite3_backup_finish, равно &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK,&lt;/a&gt; если ошибок sqlite3_backup_step () не возникло, независимо от того, завершилась ли sqlite3_backup_step () или нет. Если во время любого предыдущего вызова sqlite3_backup_step () того же объекта sqlite3_backup возникла проблема &lt;a href=&quot;#sqlite3_backup&quot;&gt;нехватки&lt;/a&gt; памяти или ошибка ввода-вывода , то sqlite3_backup_finish () вернет соответствующий &lt;a href=&quot;rescode&quot;&gt;код ошибки&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a8b2a631496d509ee2b275504f995fbe8e4ff87c" translate="yes" xml:space="preserve">
          <source>The value returned by sqlite3_backup_finish is &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; if no sqlite3_backup_step() errors occurred, regardless or whether or not sqlite3_backup_step() completed. If an out-of-memory condition or IO error occurred during any prior sqlite3_backup_step() call on the same &lt;a href=&quot;backup&quot;&gt;sqlite3_backup&lt;/a&gt; object, then sqlite3_backup_finish() returns the corresponding &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt;.</source>
          <target state="translated">Значение, возвращаемое sqlite3_backup_finish, равно &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK,&lt;/a&gt; если ошибок sqlite3_backup_step () не возникло, независимо от того, завершилась ли sqlite3_backup_step () или нет. Если во время любого предыдущего вызова sqlite3_backup_step () того же объекта sqlite3_backup возникла проблема &lt;a href=&quot;backup&quot;&gt;нехватки&lt;/a&gt; памяти или ошибка ввода-вывода , то sqlite3_backup_finish () вернет соответствующий &lt;a href=&quot;../rescode&quot;&gt;код ошибки&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bc51fa501b0d744e2b8200daac75839a3f391d4e" translate="yes" xml:space="preserve">
          <source>The values &lt;b&gt;M&lt;/b&gt; and &lt;b&gt;n&lt;/b&gt; are properties of the application. If an application is constructed in such a way that both &lt;b&gt;M&lt;/b&gt; and &lt;b&gt;n&lt;/b&gt; are known, or at least have known upper bounds, and if the application uses the &lt;a href=&quot;malloc#memsys5&quot;&gt;memsys5&lt;/a&gt; memory allocator and is provided with &lt;b&gt;N&lt;/b&gt; bytes of available memory space using &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigheap&quot;&gt;SQLITE_CONFIG_HEAP&lt;/a&gt; then Robson proves that no memory allocation request will ever fail within the application. To put this another way, the application developer can select a value for &lt;b&gt;N&lt;/b&gt; that will guarantee that no call to any SQLite interface will ever return &lt;a href=&quot;rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt;. The memory pool will never become so fragmented that a new memory allocation request cannot be satisfied. This is an important property for applications where a software fault could cause injury, physical harm, or loss of irreplaceable data.</source>
          <target state="translated">Значения &lt;b&gt;M&lt;/b&gt; и &lt;b&gt;n&lt;/b&gt; являются свойствами приложения. Если приложение построено таким образом, что известны как &lt;b&gt;M, так&lt;/b&gt; и &lt;b&gt;n&lt;/b&gt; , или, по крайней мере, известны верхние границы, и если приложение использует &lt;a href=&quot;malloc#memsys5&quot;&gt;распределитель&lt;/a&gt; памяти memsys5 и ему предоставляется &lt;b&gt;N&lt;/b&gt; байтов доступного пространства памяти с помощью &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigheap&quot;&gt;SQLITE_CONFIG_HEAP,&lt;/a&gt; то Робсон доказывает, что ни один запрос на выделение памяти никогда не завершится ошибкой в ​​приложении. &lt;a href=&quot;rescode#nomem&quot;&gt;Другими&lt;/a&gt; словами, разработчик приложения может выбрать значение для &lt;b&gt;N,&lt;/b&gt; которое будет гарантировать, что ни один вызов любого интерфейса SQLite никогда не вернет SQLITE_NOMEM.. Пул памяти никогда не станет настолько фрагментированным, чтобы новый запрос на выделение памяти не мог быть удовлетворен. Это важное свойство для приложений, в которых программный сбой может привести к травмам, физическому ущербу или потере незаменимых данных.</target>
        </trans-unit>
        <trans-unit id="22f534f2da25c6b7c05e8783b8e5bfbbc59c87e8" translate="yes" xml:space="preserve">
          <source>The values for each column in the record immediately follow the header. For serial types 0, 8, 9, 12, and 13, the value is zero bytes in length. If all columns are of these types then the body section of the record is empty.</source>
          <target state="translated">Значения для каждого столбца записи сразу же следуют за заголовком.Для последовательных типов 0,8,9,12 и 13 значение равно нулю байт.Если все столбцы относятся к этим типам,то участок тела записи пуст.</target>
        </trans-unit>
        <trans-unit id="d128efd1de498da70d20d12d2513201d5001c97a" translate="yes" xml:space="preserve">
          <source>The values for each column of the row are stored in these columns. The &quot;.recover&quot; command creates the lost_and_found table with as many columns as required by the longest orphaned row.</source>
          <target state="translated">В этих столбцах хранятся значения для каждого столбца строки.Команда &quot;.восстановить&quot; создает таблицу lost_and_found с таким количеством столбцов,которое требуется для самой длинной осиротевшей строки.</target>
        </trans-unit>
        <trans-unit id="fd6b2ec514a48d20f0372d7449abd69ec8081347" translate="yes" xml:space="preserve">
          <source>The values placed in the sqlite_stat1 table by an approximate ANALYZE are not exactly the same as what would be computed by an unrestricted analysis. But they are usually close enough. The index statistics in the sqlite_stat1 table are approximations in any case, so the fact that the results of an approximate ANALYZE are slightly different from a traditional full scan ANALYZE has little practical impact. It is possible to construct a pathological case where an approximate ANALYZE is noticeably inferior to a full-scan ANALYZE, but such cases rare in real-world problems.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61332fb4ed04580474ae395b4c8e0cfc53138b43" translate="yes" xml:space="preserve">
          <source>The values returned by &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_bytes()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_bytes16()&lt;/a&gt; do not include the zero terminators at the end of the string. For clarity: the values returned by &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_bytes()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_bytes16()&lt;/a&gt; are the number of bytes in the string, not the number of characters.</source>
          <target state="translated">Значения, возвращаемые &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_bytes ()&lt;/a&gt; и &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_bytes16 ()&lt;/a&gt; , не включают нулевые терминаторы в конце строки. Для ясности: значения, возвращаемые &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_bytes ()&lt;/a&gt; и &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_bytes16 (),&lt;/a&gt; представляют собой количество байтов в строке, а не количество символов.</target>
        </trans-unit>
        <trans-unit id="56d75a71d4310cb50689d453693c130f5e211175" translate="yes" xml:space="preserve">
          <source>The values returned by &lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_bytes()&lt;/a&gt; and &lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_bytes16()&lt;/a&gt; do not include the zero terminators at the end of the string. For clarity: the values returned by &lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_bytes()&lt;/a&gt; and &lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_bytes16()&lt;/a&gt; are the number of bytes in the string, not the number of characters.</source>
          <target state="translated">Значения, возвращаемые &lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_bytes ()&lt;/a&gt; и &lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_bytes16 ()&lt;/a&gt; , не включают нулевые терминаторы в конце строки. Для ясности: значения, возвращаемые &lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_bytes ()&lt;/a&gt; и &lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_bytes16 (),&lt;/a&gt; представляют собой количество байтов в строке, а не количество символов.</target>
        </trans-unit>
        <trans-unit id="9a34a413d802292386ca8ed35bad50613a2e40f9" translate="yes" xml:space="preserve">
          <source>The values returned by sqlite3_errcode() and/or sqlite3_extended_errcode() might change with each API call. Except, there are some interfaces that are guaranteed to never change the value of the error code. The error-code preserving interfaces are:</source>
          <target state="translated">Значения,возвращаемые функциями sqlite3_errcode()и/или sqlite3_extended_errcode(),могут меняться при каждом вызове API.Кроме того,существуют некоторые интерфейсы,которые гарантированно никогда не изменят значение кода ошибки.Интерфейсы,сохраняющие код ошибки:</target>
        </trans-unit>
        <trans-unit id="af0883b91a2c32edd6bb6e8adf9674294de318ba" translate="yes" xml:space="preserve">
          <source>The variable &lt;b&gt;$x&lt;/b&gt; is set by the above code to</source>
          <target state="translated">Переменная &lt;b&gt;$ x&lt;/b&gt; устанавливается приведенным выше кодом как</target>
        </trans-unit>
        <trans-unit id="e81b821adc588b80803661eb9435ef7daf5e77e6" translate="yes" xml:space="preserve">
          <source>The variable i in the previous expression varies between 0 and 9. Conceptually, the index space is divided into 10 uniform buckets and the samples are the middle row from each bucket.</source>
          <target state="translated">Переменная i в предыдущем выражении варьируется от 0 до 9.Концептуально,индексное пространство разделено на 10 однородных ведер,а образцы-это средняя строка от каждого ведра.</target>
        </trans-unit>
        <trans-unit id="e46969b4d5144ef5a3ecc1c7c5e86080c0dd5e34" translate="yes" xml:space="preserve">
          <source>The various &lt;b&gt;sqlite_stat&lt;/b&gt;</source>
          <target state="translated">Различные &lt;b&gt;sqlite_stat&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="4ea0a2ad541e7dfd246d5e09a98161b66d983211" translate="yes" xml:space="preserve">
          <source>The various SQLite Archive Archive commands are implemented using SQL statements. Application developers can easily add SQLite Archive Archive reading and writing support to their own projects by running the appropriate SQL.</source>
          <target state="translated">Различные команды SQLite Archive Archive реализуются с помощью операторов SQL.Разработчики приложения могут легко добавить поддержку чтения и записи SQLite Archive Archive в свои собственные проекты,запустив соответствующий SQL.</target>
        </trans-unit>
        <trans-unit id="22f8ca9c7ec1168dbb45b57fd3ebfbf3e9d60926" translate="yes" xml:space="preserve">
          <source>The various assert()-like macros behave differently according to how SQLite is built.</source>
          <target state="translated">Различные макросы assert()-like ведут себя по-разному в зависимости от того,как построен SQLite.</target>
        </trans-unit>
        <trans-unit id="8789a3da4f75d5b0392ef189d216e2c9312d1546" translate="yes" xml:space="preserve">
          <source>The various unix VFSes differ only in the way they handle file locking - they share most of their implementation in common with one another and are all located in the same SQLite source file: &lt;a href=&quot;http://www.sqlite.org/src/doc/trunk/src/os_unix.c&quot;&gt;os_unix.c&lt;/a&gt;. Note that except for &quot;unix&quot; and &quot;unix-excl&quot;, the various unix VFSes all use incompatible locking implementations. If two processes are accessing the same SQLite database using different unix VFSes, they may not see each others locks and may end up interfering with one another, resulting in database corruption. The &quot;unix-none&quot; VFS in particular does no locking at all and will easily result in database corruption if used by two or more database connections at the same time. Programmers are encouraged to use only &quot;unix&quot; or &quot;unix-excl&quot; unless there is a compelling reason to do otherwise.</source>
          <target state="translated">Различные виртуальные файловые системы UNIX различаются только способом обработки блокировок файлов - они имеют большую часть своей общей реализации, и все они расположены в одном исходном файле SQLite: &lt;a href=&quot;http://www.sqlite.org/src/doc/trunk/src/os_unix.c&quot;&gt;os_unix.c&lt;/a&gt; . Обратите внимание, что, за исключением unix и unix-excl, все VFS для unix используют несовместимые реализации блокировки. Если два процесса обращаются к одной и той же базе данных SQLite с использованием разных VFS Unix, они могут не видеть блокировки друг друга и могут в конечном итоге мешать друг другу, что приведет к повреждению базы данных. В частности, VFS &quot;unix-none&quot; вообще не блокирует и может легко привести к повреждению базы данных, если используется двумя или более соединениями с базой данных одновременно. Программистам рекомендуется использовать только &amp;laquo;unix&amp;raquo; или &amp;laquo;unix-excl&amp;raquo;.если нет веских причин поступить иначе.</target>
        </trans-unit>
        <trans-unit id="712cb1b968b5dc142c808025ffeb918e4c54b863" translate="yes" xml:space="preserve">
          <source>The various unix VFSes differ only in the way they handle file locking - they share most of their implementation in common with one another and are all located in the same SQLite source file: &lt;a href=&quot;https://www.sqlite.org/src/doc/trunk/src/os_unix.c&quot;&gt;os_unix.c&lt;/a&gt;. Note that except for &quot;unix&quot; and &quot;unix-excl&quot;, the various unix VFSes all use incompatible locking implementations. If two processes are accessing the same SQLite database using different unix VFSes, they may not see each others locks and may end up interfering with one another, resulting in database corruption. The &quot;unix-none&quot; VFS in particular does no locking at all and will easily result in database corruption if used by two or more database connections at the same time. Programmers are encouraged to use only &quot;unix&quot; or &quot;unix-excl&quot; unless there is a compelling reason to do otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5ffe5eea46cbcd5a1594ce73f72bf62a68d39e3" translate="yes" xml:space="preserve">
          <source>The versions of SQLite that come preinstalled on Apple Mac OS X computers contain a version of SQLite that has been extended to use alternative locking strategies that work on all network filesystems that Apple supports. These extensions used by Apple work great as long as all processes are accessing the database file in the same way. Unfortunately, the locking mechanisms do not exclude one another, so if one process is accessing a file using (for example) AFP locking and another process (perhaps on a different machine) is using dot-file locks, the two processes might collide because AFP locks do not exclude dot-file locks or vice versa.</source>
          <target state="translated">Версии SQLite,которые поставляются предустановленными на компьютерах Apple Mac OS X,содержат версию SQLite,которая была расширена для использования альтернативных стратегий блокировки,работающих на всех сетевых файловых системах,поддерживаемых Apple.Эти расширения,используемые Apple,отлично работают до тех пор,пока все процессы одинаково обращаются к файлу базы данных.К сожалению,механизмы блокировки не исключают друг друга,поэтому если один процесс получает доступ к файлу,используя (например)блокировку AFP,а другой процесс (возможно,на другой машине)использует блокировку dot-файлов,эти два процесса могут столкнуться,поскольку блокировки AFP не исключают блокировку dot-файлов,или наоборот.</target>
        </trans-unit>
        <trans-unit id="27a68965a58736f6647ab050fea465e20bf8ddef" translate="yes" xml:space="preserve">
          <source>The versions of the SQLite amalgamation that are supplied on the &lt;a href=&quot;https://sqlite.org/download.html&quot;&gt;download page&lt;/a&gt; are normally adequate for most users. However, some projects may want or need to build their own amalgamations. A common reason for building a custom amalgamation is in order to use certain &lt;a href=&quot;compile&quot;&gt;compile-time options&lt;/a&gt; to customize the SQLite library. Recall that the SQLite amalgamation contains a lot of C-code that is generated by auxiliary programs and scripts. Many of the compile-time options effect this generated code and must be supplied to the code generators before the amalgamation is assembled. The set of compile-time options that must be passed into the code generators can vary from one release of SQLite to the next, but at the time of this writing (circa SQLite 3.6.20, 2009-11-04) the set of options that must be known by the code generators includes:</source>
          <target state="translated">Версии объединения SQLite, представленные на &lt;a href=&quot;https://sqlite.org/download.html&quot;&gt;странице загрузки&lt;/a&gt; , обычно подходят для большинства пользователей. Однако некоторым проектам может потребоваться или необходимо создать собственные объединения. Распространенная причина создания настраиваемого объединения - использование определенных &lt;a href=&quot;compile&quot;&gt;параметров времени компиляции&lt;/a&gt;для настройки библиотеки SQLite. Напомним, что объединение SQLite содержит много C-кода, который генерируется вспомогательными программами и скриптами. Многие из параметров времени компиляции влияют на этот сгенерированный код и должны быть переданы генераторам кода перед сборкой объединения. Набор параметров времени компиляции, которые необходимо передать генераторам кода, может варьироваться от одного выпуска SQLite к другому, но на момент написания этой статьи (около SQLite 3.6.20, 2009-11-04) набор параметров которые должны быть известны генераторам кода, включают:</target>
        </trans-unit>
        <trans-unit id="d08eefb01c3e7948c8ed07ad520422cff4b9225d" translate="yes" xml:space="preserve">
          <source>The very name &quot;Structured Query Language&quot; tells us that SQL should support nested queries. And, in fact, two different kinds of nesting are supported. Any SELECT statement that returns a single-row, single-column result can be used as a term in an expression of another SELECT statement. And, a SELECT statement that returns a single-column, multi-row result can be used as the right-hand operand of the IN and NOT IN operators. We will begin this section with an example of the first kind of nesting, where a single-row, single-column SELECT is used as a term in an expression of another SELECT. Here is our example:</source>
          <target state="translated">Само название &quot;Язык структурированных запросов&quot; говорит о том,что SQL должен поддерживать вложенные запросы.И,фактически,поддерживаются два различных вида вложенности.Любой оператор SELECT,возвращающий результат,состоящий из одной строки и одной колонки,может быть использован в качестве термина в выражении другого оператора SELECT.А оператор SELECT,возвращающий многострочный результат в один столбец,может использоваться в качестве правого оператора операторов IN и NOT IN.Мы начнем этот раздел с примера первого вида вложенности,когда однорядный,многострочный результат SELECT используется в качестве термина в выражении другого оператора SELECT.Вот наш пример:</target>
        </trans-unit>
        <trans-unit id="20c4a011c8e3b37249d4469eb52a0ff7a1d9c48e" translate="yes" xml:space="preserve">
          <source>The vfs query parameter causes the database connection to be opened using the &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; called</source>
          <target state="translated">Параметр запроса vfs вызывает открытие соединения с базой данных с помощью &lt;a href=&quot;vfs&quot;&gt;VFS,&lt;/a&gt; называемой</target>
        </trans-unit>
        <trans-unit id="7fc9c565eeb1c6123557989180ff5a163d06934e" translate="yes" xml:space="preserve">
          <source>The view to drop is identified by the view-name and optional schema-name specified as part of the DROP VIEW statement. This reference is resolved using the standard procedure for &lt;a href=&quot;lang_naming&quot;&gt;object resolution&lt;/a&gt;.</source>
          <target state="translated">Отбрасываемое представление идентифицируется именем представления и необязательным именем схемы, указанным как часть оператора DROP VIEW. Эта ссылка разрешается с использованием стандартной процедуры &lt;a href=&quot;lang_naming&quot;&gt;разрешения объекта&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3b2c6960eedc019bcf13fce258370b16a245ba89" translate="yes" xml:space="preserve">
          <source>The view v1 cannot be &lt;a href=&quot;optoverview#flattening&quot;&gt;flattened&lt;/a&gt; because it is DISTINCT. It must instead be run as a subquery with the results being stored in a transient table, then the join is performed between t2 and the transient table. The push-down optimization pushes down the &quot;b BETWEEN 10 AND 20&quot; term into the view. This makes the transient table smaller, and helps the subquery to run faster if there is an index on t1.b. The resulting evaluation is like this:</source>
          <target state="translated">Представление v1 не может быть &lt;a href=&quot;optoverview#flattening&quot;&gt;сведено,&lt;/a&gt; потому что оно ОТЛИЧИТЕЛЬНО. Вместо этого он должен выполняться как подзапрос с сохранением результатов в таблице переходных процессов, после чего выполняется соединение между t2 и таблицей переходных процессов. Оптимизация &quot;вниз&quot; выталкивает элемент &quot;b МЕЖДУ 10 И 20&quot; в представление. Это делает таблицу переходных процессов меньше и помогает подзапросу работать быстрее, если на t1.b есть индекс. Итоговая оценка выглядит так:</target>
        </trans-unit>
        <trans-unit id="ce6b93653a867ff824a137b275a2d8a4b5929427" translate="yes" xml:space="preserve">
          <source>The virtual machine itself is entirely contained in a single source file &lt;a href=&quot;https://sqlite.org/src/file/src/vdbe.c&quot;&gt;vdbe.c&lt;/a&gt;. The &lt;a href=&quot;https://sqlite.org/src/file/src/vdbe.h&quot;&gt;vdbe.h&lt;/a&gt; header file defines an interface between the virtual machine and the rest of the SQLite library and &lt;a href=&quot;https://sqlite.org/src/file/src/vdbeInt.h&quot;&gt;vdbeInt.h&lt;/a&gt; which defines structures and interfaces that are private the virtual machine itself. Various other &lt;b&gt;vdbe*.c&lt;/b&gt; files are helpers to the virtual machine. The &lt;a href=&quot;https://sqlite.org/src/file/src/vdbeaux.c&quot;&gt;vdbeaux.c&lt;/a&gt; file contains utilities used by the virtual machine and interface modules used by the rest of the library to construct VM programs. The &lt;a href=&quot;https://sqlite.org/src/file/src/vdbeapi.c&quot;&gt;vdbeapi.c&lt;/a&gt; file contains external interfaces to the virtual machine such as the &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_int()&lt;/a&gt; and &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt;. Individual values (strings, integer, floating point numbers, and BLOBs) are stored in an internal object named &quot;Mem&quot; which is implemented by &lt;a href=&quot;https://sqlite.org/src/file/src/vdbemem.c&quot;&gt;vdbemem.c&lt;/a&gt;.</source>
          <target state="translated">Сама виртуальная машина целиком содержится в одном исходном файле &lt;a href=&quot;https://sqlite.org/src/file/src/vdbe.c&quot;&gt;vdbe.c&lt;/a&gt; . &lt;a href=&quot;https://sqlite.org/src/file/src/vdbe.h&quot;&gt;Vdbe.h&lt;/a&gt; заголовочного файл определяет интерфейс между виртуальной машиной и остальной частью библиотеки SQLite и &lt;a href=&quot;https://sqlite.org/src/file/src/vdbeInt.h&quot;&gt;vdbeInt.h&lt;/a&gt; , который определяет структуру и интерфейсы , которые являются закрытыми самим виртуальной машиной. Различные другие &lt;b&gt;файлы vdbe * .c&lt;/b&gt; являются помощниками для виртуальной машины. &lt;a href=&quot;https://sqlite.org/src/file/src/vdbeaux.c&quot;&gt;Vdbeaux.c&lt;/a&gt; файл содержит утилиты , используемые в виртуальных машин и интерфейсных модулей , используемых в остальной части библиотеки для построения программ VM. &lt;a href=&quot;https://sqlite.org/src/file/src/vdbeapi.c&quot;&gt;Vdbeapi.c&lt;/a&gt; файл содержит внешние интерфейсы для виртуальной машины , такие как &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_int ()&lt;/a&gt; и &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step ()&lt;/a&gt;. Отдельные значения (строки, целые числа, числа с плавающей запятой и &lt;a href=&quot;https://sqlite.org/src/file/src/vdbemem.c&quot;&gt;большие двоичные объекты&lt;/a&gt; ) хранятся во внутреннем объекте с именем &amp;laquo;Mem&amp;raquo;, который реализуется vdbemem.c .</target>
        </trans-unit>
        <trans-unit id="00bcd77d6dec3bc1a5f96c0e0f3985aefbea69f9" translate="yes" xml:space="preserve">
          <source>The virtual table contains an xShadowName method.</source>
          <target state="translated">Виртуальная таблица содержит метод xShadowName.</target>
        </trans-unit>
        <trans-unit id="aba94b8d1e25fe7120c464dc013b1d34868edb66" translate="yes" xml:space="preserve">
          <source>The virtual table mechanism allows an application to publish interfaces that are accessible from SQL statements as if they were tables. SQL statements can do almost anything to a virtual table that they can do to a real table, with the following exceptions:</source>
          <target state="translated">Механизм виртуальных таблиц позволяет приложению публиковать интерфейсы,доступные из SQL-операторов,как если бы они были таблицами.SQL-операторы могут сделать с виртуальной таблицей практически все,что они могут сделать с реальной таблицей,со следующими исключениями:</target>
        </trans-unit>
        <trans-unit id="7616eb3efb8cfc2b544466ae9f36f2a81289f276" translate="yes" xml:space="preserve">
          <source>The virtual table will return one row of output for each token in the input string. The &quot;token&quot; column is the text of the token. The &quot;start&quot; and &quot;end&quot; columns are the byte offset to the beginning and end of the token in the original input string. The &quot;position&quot; column is the sequence number of the token in the original input string. There is also an &quot;input&quot; column which is simply a copy of the input string that is specified in the WHERE clause. Note that a constraint of the form &quot;input=?&quot; must appear in the WHERE clause or else the virtual table will have no input to tokenize and will return no rows. The example above generates the following output:</source>
          <target state="translated">Виртуальная таблица вернет по одной строке вывода для каждой лексемы во входной строке.Столбец &quot;токен&quot;-это текст токена.Столбцы &quot;начало&quot; и &quot;конец&quot;-это смещение байта к началу и концу токена в исходной строке ввода.Столбец &quot;позиция&quot;-это порядковый номер токена в исходной строке ввода.Существует также столбец &quot;input&quot;,который является просто копией входной строки,указанной в пункте WHERE.Обратите внимание,что ограничение формы &quot;input=?&quot; должно появиться в выражении WHERE,иначе виртуальная таблица не будет иметь входных данных для токенов и не вернет строк.В примере,приведенном выше,будет выдан следующий вывод:</target>
        </trans-unit>
        <trans-unit id="e7d6d48d0123dd78c2ece991b5f7661cea292174" translate="yes" xml:space="preserve">
          <source>The wal-index file or &quot;shm&quot; file is not actually used as a file. Rather, individual database clients mmap the shm file and use it as shared memory for coordinating access to the database and as a cache for quickly locating frame within the wal file. The name of the shm file is the main database file name with the four characters &quot;-shm&quot; appended. Or, for 8+3 filesystems, the shm file is the main database file with the suffix changed to &quot;.SHM&quot;.</source>
          <target state="translated">Файл wal-index или файл &quot;shm&quot; на самом деле не используется в качестве файла.Скорее,отдельные клиенты базы данных mmap-файл shm и используют его в качестве общей памяти для координации доступа к базе данных и в качестве кэша для быстрого определения местоположения фрейма в файле wal.Имя файла shm является основным именем файла базы данных с четырьмя символами &quot;-шм&quot;.Или,для 8+3 файловых систем,файл shm является основным файлом БД с суффиксом,измененным на &quot;.SHM&quot;.</target>
        </trans-unit>
        <trans-unit id="2705cff44fec902d1ca3ce2af3b554cabc339fb3" translate="yes" xml:space="preserve">
          <source>The wal-index file, usually named &quot;X-shm&quot;.</source>
          <target state="translated">Файл wal-index,обычно называемый &quot;X-shm&quot;.</target>
        </trans-unit>
        <trans-unit id="3164ee82328b180dbc8289eddc9db733f9109901" translate="yes" xml:space="preserve">
          <source>The wal-index is transient. After a crash, the wal-index is reconstructed from the original WAL file. The VFS is required to either truncate or zero the header of the wal-index when the last connection to it closes. Because the wal-index is transient, it can use an architecture-specific format; it does not have to be cross-platform. Hence, unlike the database and WAL file formats which store all values as big endian, the wal-index stores multi-byte values in the native byte order of the host computer.</source>
          <target state="translated">Уолл-индекс преходящий.После сбоя,wal-index восстанавливается из оригинального файла WAL.VFS требуется либо усечь,либо обнулить заголовок wal-index при закрытии последнего соединения с ним.Поскольку wal-index является переходным,он может использовать формат,специфичный для архитектуры;он не обязательно должен быть кроссплатформенным.Следовательно,в отличие от форматов баз данных и файлов WAL,в которых все значения хранятся как большие эндианы,wal-index хранит многобайтовые значения в родном порядке байт на хост-компьютере.</target>
        </trans-unit>
        <trans-unit id="f37728360280f92c82e5f63eda2235cd3fe649d8" translate="yes" xml:space="preserve">
          <source>The wal_checkpoint pragma returns a single row with three integer columns. The first column is usually 0 but will be 1 if a RESTART or FULL or TRUNCATE checkpoint was blocked from completing, for example because another thread or process was actively using the database. In other words, the first column is 0 if the equivalent call to &lt;a href=&quot;c3ref/wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2()&lt;/a&gt; would have returned &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; or 1 if the equivalent call would have returned &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;. The second column is the number of modified pages that have been written to the write-ahead log file. The third column is the number of pages in the write-ahead log file that have been successfully moved back into the database file at the conclusion of the checkpoint. The second and third column are -1 if there is no write-ahead log, for example if this pragma is invoked on a database connection that is not in &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt;.</source>
          <target state="translated">Прагма wal_checkpoint возвращает одну строку с тремя целочисленными столбцами. Первый столбец обычно равен 0, но будет равен 1, если выполнение контрольной точки RESTART, FULL или TRUNCATE было заблокировано, например, из-за того, что другой поток или процесс активно использовали базу данных. Другими словами, первый столбец равен 0, если эквивалентный вызов &lt;a href=&quot;c3ref/wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2 ()&lt;/a&gt; вернул бы &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; или 1, если бы эквивалентный вызов вернул бы &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;. Во втором столбце указано количество измененных страниц, которые были записаны в файл журнала упреждающей записи. Третий столбец - это количество страниц в файле журнала упреждающей записи, которые были успешно перемещены обратно в файл базы данных по завершении контрольной точки. Второй и третий столбцы имеют значение -1, если журнал упреждающей записи отсутствует, например, если эта прагма вызывается для соединения с базой данных, которое не находится в &lt;a href=&quot;wal&quot;&gt;режиме WAL&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7abca67d3b2f6649a3ed46e41721882b254d1af5" translate="yes" xml:space="preserve">
          <source>The way SQLite deals with this is to first run the inner SELECT (the one against examp2) and store its result in a private memory cell. SQLite then substitutes the value of this private memory cell for the inner SELECT when it evaluates the outer SELECT. The code looks like this:</source>
          <target state="translated">Способ,которым SQLite справляется с этим,заключается в том,чтобы сначала запустить внутренний SELECT (тот,который против examp2)и сохранить его результат в частной ячейке памяти.Затем SQLite подставляет значение этой частной ячейки памяти во внутреннюю SELECT при оценке внешнего SELECT.Код выглядит следующим образом:</target>
        </trans-unit>
        <trans-unit id="d9f0711eae8ce05c73449f6cd3513a09a5b0c229" translate="yes" xml:space="preserve">
          <source>The way in which the IN and NOT IN operators handle NULL values in their right-hand expressions has been brought into compliance with the SQL standard and with other SQL database engines.</source>
          <target state="translated">То,как операторы IN и NOT IN обрабатывают NULL-значения в своих правосторонних выражениях,было приведено в соответствие со стандартом SQL и другими движками баз данных SQL.</target>
        </trans-unit>
        <trans-unit id="1bcbf2e1391b1aa7e3ebafdb83d7f3bc20c48ce0" translate="yes" xml:space="preserve">
          <source>The whole point of the xShadowName method is to protect the content of shadow tables from being corrupted by hostile SQL. Every virtual table implementation that uses shadow tables should be able to detect and cope with corrupted shadow table content. However, bugs in particular virtual table implementation might allow a deliberately corrupted shadow table to cause a crash or other malfunction. The xShadowName mechanism seeks to avoid zero-day exploits by preventing ordinary SQL statements from deliberately corrupting shadow tables.</source>
          <target state="translated">Весь смысл метода xShadowName заключается в защите содержимого теневых таблиц от повреждения враждебным SQL.Каждая реализация виртуальной таблицы,использующая теневые таблицы,должна быть способна обнаруживать поврежденное содержимое теневых таблиц и справляться с ним.Однако ошибки,в частности,в реализации виртуальных таблиц,могут позволить намеренно поврежденной теневой таблице вызвать сбой или другие неполадки.Механизм xShadowName стремится избежать эксплойтов нулевого дня,предотвращая намеренное повреждение теневых таблиц обычными SQL операторами.</target>
        </trans-unit>
        <trans-unit id="7ba3625dd3002c676817bb5d0641f1c309f9b35c" translate="yes" xml:space="preserve">
          <source>The width field specifies the minimum width of the substituted value in the output. If the string or number that is written into the output is shorter than the width, then the value is padded. Padding is on the left (the value is right-justified) by default. If the &quot;-&quot; flag is used, then the padding is on the right and the value is left-justified.</source>
          <target state="translated">Поле width (Ширина)задает минимальную ширину замещаемого значения на выходе.Если строка или число,записанное в вывод,меньше ширины,то значение подставляется.По умолчанию подставка находится слева (значение обосновано справа).Если используется флаг &quot;-&quot;,то подкладка находится справа,а значение-слева (значение обосновано справа).</target>
        </trans-unit>
        <trans-unit id="a12aad5ee5dbe2d3fff555e1c8b3c9090a69eb38" translate="yes" xml:space="preserve">
          <source>The width is measured in bytes by default. However, if the &quot;!&quot; flag is present then the width is in characters. This only makes a difference for multi-byte utf-8 characters, and those only occur on string substitutions.</source>
          <target state="translated">По умолчанию ширина измеряется в байтах.Однако,если присутствует флаг &quot;!&quot;,то ширина измеряется в символах.Это имеет значение только для многобайтовых символов utf-8,а такие символы встречаются только при замене строк.</target>
        </trans-unit>
        <trans-unit id="bb37fe25186c24e9c2d6b18924cc12e6bf999427" translate="yes" xml:space="preserve">
          <source>The word transliterated into lower-case ASCII. There is a standard table of mappings from non-ASCII characters into ASCII. Examples: &quot;&amp;aelig;&quot; -&amp;gt; &quot;ae&quot;, &quot;&amp;thorn;&quot; -&amp;gt; &quot;th&quot;, &quot;&amp;szlig;&quot; -&amp;gt; &quot;ss&quot;, &quot;&amp;aacute;&quot; -&amp;gt; &quot;a&quot;, ... The accessory function spellfix1_translit(X) will do the non-ASCII to ASCII mapping. The built-in lower(X) function will convert to lower-case. Thus: k1 = lower(spellfix1_translit(word)). If the word is already all lower-case ASCII, then the k1 column will contain a NULL. This reduces the storage requirements for the %_vocab table and helps spellfix to run a little faster. Therefore, it is advantageous to populate as much of the spellfix table as possible using lower-case ASCII vocabulary.</source>
          <target state="translated">Слово транслитерируется в нижний регистр ASCII. Существует стандартная таблица сопоставлений символов, отличных от ASCII, в ASCII. Примеры: &amp;laquo;&amp;aelig;&amp;raquo; -&amp;gt; &amp;laquo;ae&amp;raquo;, &amp;laquo;&amp;thorn;&amp;raquo; -&amp;gt; &amp;laquo;th&amp;raquo;, &amp;laquo;&amp;szlig;&amp;raquo; -&amp;gt; &amp;laquo;ss&amp;raquo;, &amp;laquo;&amp;aacute;&amp;raquo; -&amp;gt; &amp;laquo;a&amp;raquo;, ... Дополнительная функция spellfix1_translit (X) выполнит отображение не-ASCII в ASCII. Встроенная функция lower (X) будет преобразовывать в нижний регистр. Таким образом: k1 = нижний (spellfix1_translit (слово)). Если слово уже состоит из ASCII нижнего регистра, тогда столбец k1 будет содержать NULL. Это снижает требования к хранилищу для таблицы% _vocab и помогает программе spellfix работать немного быстрее. Следовательно, выгодно заполнить как можно большую часть таблицы исправлений орфографии, используя словарь ASCII нижнего регистра.</target>
        </trans-unit>
        <trans-unit id="2aea0dad5536afb073da7952899f42822308cf24" translate="yes" xml:space="preserve">
          <source>The working directory</source>
          <target state="translated">Рабочая директория</target>
        </trans-unit>
        <trans-unit id="1191da9cfb737ab513b0974862b6931c34d468a3" translate="yes" xml:space="preserve">
          <source>The write-ahead log file, usually named &quot;X-wal&quot;.</source>
          <target state="translated">Файл журнала с записями наперед,обычно называемый &quot;X-wal&quot;.</target>
        </trans-unit>
        <trans-unit id="aa76cd0207c05b41731ac87f189a853ae60f3634" translate="yes" xml:space="preserve">
          <source>The write-ahead log or &quot;wal&quot; file is a roll-forward journal that records transactions that have been committed but not yet applied to the main database. Details on the format of the wal file are describe in the &lt;a href=&quot;fileformat2#walformat&quot;&gt;WAL format&lt;/a&gt; subsection of the main &lt;a href=&quot;fileformat2&quot;&gt;file format&lt;/a&gt; document. The wal file is named by appending the four characters &quot;-wal&quot; to the end of the name of the main database file. Except on 8+3 filesystems, such names are not allowed, and in that case the file suffix is changed to &quot;.WAL&quot;. But as 8+3 filesystems are increasingly rare, that exceptional case can usually be ignored.</source>
          <target state="translated">Журнал упреждающей записи или файл wal - это журнал с повтором транзакций, в котором записываются транзакции, которые были зафиксированы, но еще не применены к основной базе данных. Подробности о формате файла wal описаны в подразделе &lt;a href=&quot;fileformat2#walformat&quot;&gt;формата WAL&lt;/a&gt; основного документа &lt;a href=&quot;fileformat2&quot;&gt;формата файла&lt;/a&gt; . Файл wal именуется добавлением четырех символов &amp;laquo;-wal&amp;raquo; в конец имени основного файла базы данных. За исключением файловых систем 8 + 3, такие имена не допускаются, и в этом случае суффикс файла изменяется на &amp;laquo;.WAL&amp;raquo;. Но поскольку файловые системы 8 + 3 встречаются все реже, этот исключительный случай обычно можно игнорировать.</target>
        </trans-unit>
        <trans-unit id="9fcf91986e20f3838e989f19567544d31cd8c593" translate="yes" xml:space="preserve">
          <source>The writefile(X,Y) SQL function write the blob Y into the file named X and returns the number of bytes written. Use this function to extract the content of a single table column into a file. For example:</source>
          <target state="translated">SQL функция writeefile(X,Y)записывает блок Y в файл с именем X и возвращает количество записанных байт.Используйте эту функцию для извлечения содержимого одного столбца таблицы в файл.Например:</target>
        </trans-unit>
        <trans-unit id="35efa113638256d189c7bffd527a8b95982adee0" translate="yes" xml:space="preserve">
          <source>The writing test above is not completely fair, since SQLite is doing &lt;a href=&quot;transactional&quot;&gt;power-safe transactions&lt;/a&gt; whereas the direct-to-disk writing is not. To put the tests on a more equal footing, add either the --nosync option to the SQLite writes to disable calling fsync() or FlushFileBuffers() to force content to disk, or using the --fsync option for the direct-to-disk tests to force them to invoke fsync() or FlushFileBuffers() when updating disk files.</source>
          <target state="translated">Приведенный выше тест записи не совсем честен, поскольку SQLite выполняет &lt;a href=&quot;transactional&quot;&gt;безопасные транзакции,&lt;/a&gt; тогда как прямая запись на диск - нет. Чтобы поставить тесты на более равные условия, добавьте либо параметр --nosync для записи SQLite, чтобы отключить вызов fsync (), либо FlushFileBuffers () для принудительного размещения содержимого на диске, или используйте параметр --fsync для прямого доступа к тесты диска, чтобы заставить их вызывать fsync () или FlushFileBuffers () при обновлении файлов на диске.</target>
        </trans-unit>
        <trans-unit id="3500eedb790da60f6c7c2c2fe42347161ad2dc7e" translate="yes" xml:space="preserve">
          <source>The xAccess method is used to check for access permissions on a file. The filename will be UTF-8 encoded. The flags argument will be &lt;a href=&quot;c3ref/c_access_exists&quot;&gt;SQLITE_ACCESS_EXISTS&lt;/a&gt; to check for the existence of the file, &lt;a href=&quot;c3ref/c_access_exists&quot;&gt;SQLITE_ACCESS_READWRITE&lt;/a&gt; to check to see if the file is both readable and writable, or &lt;a href=&quot;c3ref/c_access_exists&quot;&gt;SQLITE_ACCESS_READ&lt;/a&gt; to check to see if the file is at least readable. The &quot;file&quot; named by the second parameter might be a directory or folder name.</source>
          <target state="translated">Метод xAccess используется для проверки прав доступа к файлу. Имя файла будет в кодировке UTF-8. Аргументом flags будет &lt;a href=&quot;c3ref/c_access_exists&quot;&gt;SQLITE_ACCESS_EXISTS&lt;/a&gt; для проверки существования файла, &lt;a href=&quot;c3ref/c_access_exists&quot;&gt;SQLITE_ACCESS_READWRITE,&lt;/a&gt; чтобы проверить , доступен ли файл как для чтения, так и для записи, или &lt;a href=&quot;c3ref/c_access_exists&quot;&gt;SQLITE_ACCESS_READ,&lt;/a&gt; чтобы проверить, является ли файл хотя бы читаемым. &amp;laquo;Файл&amp;raquo;, названный вторым параметром, может быть именем каталога или папки.</target>
        </trans-unit>
        <trans-unit id="7e3dceb3a3d82f8b52bd7f5b2f951ed3b0619691" translate="yes" xml:space="preserve">
          <source>The xAccess() method is invoked again to detect if the journal file is still in the file system. If it is, then it is a hot-journal file and SQLite tries to roll it back (see section</source>
          <target state="translated">Метод xAccess()снова вызывается для того,чтобы определить,находится ли файл журнала в файловой системе.Если это так,то это горячий файл журнала,и SQLite пытается откатить его обратно (см.раздел</target>
        </trans-unit>
        <trans-unit id="be1521ac61f6da801d0f89ccb40ef26362bd2aea" translate="yes" xml:space="preserve">
          <source>The xAccess() method of the VFS is allowed to return -1 to signal a memory allocation error.</source>
          <target state="translated">Метод xAccess()VFS позволяет вернуть -1 для сигнала об ошибке выделения памяти.</target>
        </trans-unit>
        <trans-unit id="dbb116d3015d148d9aef4ab4eaf91f8dc7699911" translate="yes" xml:space="preserve">
          <source>The xBestIndex function may have requested the values of certain expressions using the aConstraintUsage[].argvIndex values of the &lt;a href=&quot;c3ref/index_info&quot;&gt;sqlite3_index_info&lt;/a&gt; structure. Those values are passed to xFilter using the argc and argv parameters.</source>
          <target state="translated">Функция xBestIndex могла запросить значения определенных выражений, используя значения aConstraintUsage [] .argvIndex структуры &lt;a href=&quot;c3ref/index_info&quot;&gt;sqlite3_index_info&lt;/a&gt; . Эти значения передаются в xFilter с использованием параметров argc и argv.</target>
        </trans-unit>
        <trans-unit id="e673068c08d7f626c7139b66b363abe588afdbfb" translate="yes" xml:space="preserve">
          <source>The xBestIndex method fills the idxNum and idxStr fields with information that communicates an indexing strategy to the &lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter&lt;/a&gt; method. The information in idxNum and idxStr is arbitrary as far as the SQLite core is concerned. The SQLite core just copies the information through to the &lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter&lt;/a&gt; method. Any desired meaning can be assigned to idxNum and idxStr as long as xBestIndex and xFilter agree on what that meaning is.</source>
          <target state="translated">Метод xBestIndex заполняет поля idxNum и idxStr информацией, которая передает стратегию &lt;a href=&quot;vtab#xfilter&quot;&gt;индексации&lt;/a&gt; методу xFilter . Информация в idxNum и idxStr является произвольной для ядра SQLite. Ядро SQLite просто копирует информацию в метод &lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter&lt;/a&gt; . Любое желаемое значение может быть присвоено idxNum и idxStr, если xBestIndex и xFilter согласны с тем, что это за значение.</target>
        </trans-unit>
        <trans-unit id="7549b2c421b13b6947674708c7a5360fc1373a57" translate="yes" xml:space="preserve">
          <source>The xBestIndex method is required for every virtual table implementation.</source>
          <target state="translated">Метод xBestIndex требуется для каждой реализации виртуальной таблицы.</target>
        </trans-unit>
        <trans-unit id="6671b4241ef5e4b25933598f6cbd513b0faa9c69" translate="yes" xml:space="preserve">
          <source>The xBestIndex method may optionally populate the idxFlags field with a mask of SQLITE_INDEX_SCAN_* flags. Currently there is only one such flag - SQLITE_INDEX_SCAN_UNIQUE. If the xBestIndex method sets this flag, SQLite assumes that the strategy may visit at most one row.</source>
          <target state="translated">Метод xBestIndex может опционально заполнять поле idxFlags маской флагов SQLITE_INDEX_SCAN_*.На данный момент существует только один такой флаг-SQLITE_INDEX_SCAN_UNIQUE.Если метод xBestIndex устанавливает этот флаг,то SQLite предполагает,что стратегия может посещать не более одной строки.</target>
        </trans-unit>
        <trans-unit id="60dc1bff84d7b24ecf260c549a70a2e550acd608" translate="yes" xml:space="preserve">
          <source>The xBestIndex method may set aConstraintUsage[].argvIndex entries to values greater than zero. Exactly one entry should be set to 1, another to 2, another to 3, and so forth up to as many or as few as the xBestIndex method wants. The EXPR of the corresponding constraints will then be passed in as the argv[] parameters to xFilter.</source>
          <target state="translated">Метод xBestIndex может устанавливать для записей aConstraintUsage[].argvIndex значения больше нуля.Точно одна запись должна быть установлена в 1,другая в 2,третья и т.д.до тех пор,пока метод xBestIndex не захочет.Затем EXPR соответствующих ограничений будет передан в качестве параметров argv[]в xFilter.</target>
        </trans-unit>
        <trans-unit id="b0c67bb7b3ba635b9cd74ad89d5155e843f934eb" translate="yes" xml:space="preserve">
          <source>The xBestIndex method should return SQLITE_OK on success. If any kind of fatal error occurs, an appropriate error code (ex: &lt;a href=&quot;rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt;) should be returned instead.</source>
          <target state="translated">Метод xBestIndex должен вернуть SQLITE_OK в случае успеха. Если происходит какая-либо фатальная ошибка, вместо &lt;a href=&quot;rescode#nomem&quot;&gt;нее&lt;/a&gt; должен быть возвращен соответствующий код ошибки (например: SQLITE_NOMEM ).</target>
        </trans-unit>
        <trans-unit id="6e2147722085d4c968213130f4ef993a32c73b66" translate="yes" xml:space="preserve">
          <source>The xBestIndex method will be invoked once for each of the potential plans above. For plan 1, the aConstraint[].usable flag for for the SQLITE_CONSTRAINT_EQ constraint on the param1 column will be true because the right-hand side value for the &quot;param1 = ?&quot; constraint will be known, since it is determined by the outer realtab loop. But for plan 2, the aConstraint[].usable flag for &quot;param1 = ?&quot; will be false because the right-hand side value is determined by an inner loop and is thus an unknown quantity. Because param1 is a required input to the table-valued functions, the xBestIndex method should return SQLITE_CONSTRAINT when presented with plan 2, indicating that a required input is missing. This forces the query planner to select plan 1.</source>
          <target state="translated">Метод xBestIndex будет вызван один раз для каждого из потенциальных планов,описанных выше.Для плана 1 флаг aConstraint[].usable для ограничения SQLITE_CONSTRAINT_EQ в столбце param1 будет истинен,так как будет известно значение правой стороны для ограничения &quot;param1=?&quot;,так как оно определяется внешним циклом realtab.Но для плана 2 флаг aConstraint[].usable для &quot;param1=?&quot; будет ложным,так как значение правой стороны определяется внутренним циклом и,таким образом,является неизвестной величиной.Так как param1 является обязательным входом для функций с табличными значениями,метод xBestIndex должен возвращать SQLITE_CONSTRAINT при представлении плана 2,что указывает на отсутствие нужного входа.Это заставляет планировщика запроса выбрать план 1.</target>
        </trans-unit>
        <trans-unit id="c5e6a28d9d92d2bf9deb3f28a367d165a9d141f6" translate="yes" xml:space="preserve">
          <source>The xCachesize() method may be called at any time by SQLite to set the suggested maximum cache-size (number of pages stored by) the cache instance passed as the first argument. This is the value configured using the SQLite &quot;&lt;a href=&quot;../pragma#pragma_cache_size&quot; id=&quot;thexcachesizepagecachemethod&quot;&gt;PRAGMA cache_size&lt;/a&gt;&quot; command. As with the bPurgeable parameter, the implementation is not required to do anything with this value; it is advisory only.</source>
          <target state="translated">Метод xCachesize () может быть вызван SQLite в любое время, чтобы установить предлагаемый максимальный размер кэша (количество страниц, сохраняемых) экземпляром кэша, переданным в качестве первого аргумента. Это значение, настроенное с помощью команды SQLite &quot; &lt;a href=&quot;../pragma#pragma_cache_size&quot; id=&quot;thexcachesizepagecachemethod&quot;&gt;PRAGMA cache_size&lt;/a&gt; &quot;. Как и в случае с параметром bPurgeable, реализации не требуется ничего делать с этим значением; это только рекомендательный характер.</target>
        </trans-unit>
        <trans-unit id="64860c154593114b929547aef1bfe359a445dd93" translate="yes" xml:space="preserve">
          <source>The xCachesize() method may be called at any time by SQLite to set the suggested maximum cache-size (number of pages stored by) the cache instance passed as the first argument. This is the value configured using the SQLite &quot;&lt;a href=&quot;pragma#pragma_cache_size&quot; id=&quot;thexcachesizepagecachemethod&quot;&gt;PRAGMA cache_size&lt;/a&gt;&quot; command. As with the bPurgeable parameter, the implementation is not required to do anything with this value; it is advisory only.</source>
          <target state="translated">Метод xCachesize () может быть вызван SQLite в любое время, чтобы установить предлагаемый максимальный размер кэша (количество страниц, сохраняемых) экземпляром кэша, переданным в качестве первого аргумента. Это значение, настроенное с помощью команды SQLite &quot; &lt;a href=&quot;pragma#pragma_cache_size&quot; id=&quot;thexcachesizepagecachemethod&quot;&gt;PRAGMA cache_size&lt;/a&gt; &quot;. Как и в случае с параметром bPurgeable, реализации не требуется ничего делать с этим значением; это только рекомендательный характер.</target>
        </trans-unit>
        <trans-unit id="76bfcc9d387b84934d7209d1ccf2568a52cae2ff" translate="yes" xml:space="preserve">
          <source>The xCheckReservedLock() method checks to see if another connection or another process is currently holding a reserved, pending, or exclusive lock on the file. It returns true or false.</source>
          <target state="translated">Метод xCheckReservedLock()проверяет,не содержит ли другое соединение или другой процесс в настоящее время зарезервированную,ожидающую или эксклюзивную блокировку файла.Он возвращает true или false.</target>
        </trans-unit>
        <trans-unit id="5108534fb3c98c994a35c533b42cb72d472a86d4" translate="yes" xml:space="preserve">
          <source>The xClose method closes a cursor previously opened by &lt;a href=&quot;vtab#xopen&quot;&gt;xOpen&lt;/a&gt;. The SQLite core will always call xClose once for each cursor opened using xOpen.</source>
          <target state="translated">Метод xClose закрывает курсор, ранее открытый &lt;a href=&quot;vtab#xopen&quot;&gt;xOpen&lt;/a&gt; . Ядро SQLite всегда будет вызывать xClose один раз для каждого курсора, открытого с помощью xOpen.</target>
        </trans-unit>
        <trans-unit id="a1fcaec496244ffb2502893506be9bff99222ddb" translate="yes" xml:space="preserve">
          <source>The xClose method closes the file. The space for the &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; structure is deallocated by the caller. But if the &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; contains pointers to other allocated memory or resources, those allocations should be released by the xClose method.</source>
          <target state="translated">Метод xClose закрывает файл. Пространство для структуры &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; освобождается вызывающей стороной. Но если &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; содержит указатели на другую выделенную память или ресурсы, эти выделения должны быть освобождены методом xClose.</target>
        </trans-unit>
        <trans-unit id="2af5d67c2c34fed358127148fe670412a17ae024" translate="yes" xml:space="preserve">
          <source>The xClose method is required for every virtual table implementation.</source>
          <target state="translated">Метод xClose требуется для каждой реализации виртуальной таблицы.</target>
        </trans-unit>
        <trans-unit id="57537332c9edcb104197db5e7bb9793f5df28547" translate="yes" xml:space="preserve">
          <source>The xColumn method is required for every virtual table implementation.</source>
          <target state="translated">Метод xColumn необходим для каждой реализации виртуальной таблицы.</target>
        </trans-unit>
        <trans-unit id="ef93eeb561a6057de6700b4a7eda4c4170148438" translate="yes" xml:space="preserve">
          <source>The xColumnSize API always returns -1. There is no way to determine the number of tokens in a value stored within a contentless FTS5 table configured with columnsize=0.</source>
          <target state="translated">API xColumnSize всегда возвращает -1.Нет способа определить количество токенов в значении,хранящемся в бесконтактной таблице FTS5,сконфигурированной с размером столбца=0.</target>
        </trans-unit>
        <trans-unit id="9e2d00478c87bed4be4b97709f42f53211a90ec1" translate="yes" xml:space="preserve">
          <source>The xConnect method is required for every virtual table implementation, though the &lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; and xConnect pointers of the &lt;a href=&quot;c3ref/module&quot;&gt;sqlite3_module&lt;/a&gt; object may point to the same function if the virtual table does not need to initialize backing store.</source>
          <target state="translated">Метод xConnect требуется для каждой реализации виртуальной таблицы, хотя указатели &lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; и xConnect объекта &lt;a href=&quot;c3ref/module&quot;&gt;sqlite3_module&lt;/a&gt; могут указывать на ту же функцию, если виртуальной таблице не требуется инициализировать резервное хранилище.</target>
        </trans-unit>
        <trans-unit id="3a84b2667247b1e27fdcdd3d4cc56221f573c090" translate="yes" xml:space="preserve">
          <source>The xConnect method is very similar to &lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt;. It has the same parameters and constructs a new &lt;a href=&quot;c3ref/vtab&quot;&gt;sqlite3_vtab&lt;/a&gt; structure just like xCreate. And it must also call &lt;a href=&quot;c3ref/declare_vtab&quot;&gt;sqlite3_declare_vtab()&lt;/a&gt; like xCreate.</source>
          <target state="translated">Метод xConnect очень похож на &lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; . Он имеет те же параметры и создает новую структуру &lt;a href=&quot;c3ref/vtab&quot;&gt;sqlite3_vtab,&lt;/a&gt; как и xCreate. И он также должен вызывать &lt;a href=&quot;c3ref/declare_vtab&quot;&gt;sqlite3_declare_vtab (),&lt;/a&gt; как xCreate.</target>
        </trans-unit>
        <trans-unit id="9ec50befd1d20d9f6756f231c4255cc685afba32" translate="yes" xml:space="preserve">
          <source>The xConnect method must return &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; if it is successful in creating the new virtual table, or &lt;a href=&quot;rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt; if it is not successful. If not successful, the &lt;a href=&quot;c3ref/vtab&quot;&gt;sqlite3_vtab&lt;/a&gt; structure must not be allocated. An error message may optionally be returned in *pzErr if unsuccessful. Space to hold the error message string must be allocated using an SQLite memory allocation function like &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc()&lt;/a&gt; or &lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_mprintf()&lt;/a&gt; as the SQLite core will attempt to free the space using &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_free()&lt;/a&gt; after the error has been reported up to the application.</source>
          <target state="translated">Метод xConnect должен возвращать &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK,&lt;/a&gt; если он успешно создает новую виртуальную таблицу, или &lt;a href=&quot;rescode#error&quot;&gt;SQLITE_ERROR,&lt;/a&gt; если это не удается. В случае &lt;a href=&quot;c3ref/vtab&quot;&gt;неудачи&lt;/a&gt; нельзя выделять структуру sqlite3_vtab . В случае неудачи сообщение об ошибке может быть возвращено в * pzErr. Пространство для хранения строки сообщения об ошибке должно быть выделено с помощью функции выделения памяти SQLite, такой как &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc ()&lt;/a&gt; или &lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_mprintf (),&lt;/a&gt; поскольку ядро ​​SQLite попытается освободить пространство с помощью &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_free ()&lt;/a&gt; после того, как об ошибке было сообщено приложению.</target>
        </trans-unit>
        <trans-unit id="6920f3a6545664c297cabaad1f1d797cb28640a2" translate="yes" xml:space="preserve">
          <source>The xCreate and xConnect methods are only different when the virtual table has some kind of backing store that must be initialized the first time the virtual table is created. The xCreate method creates and initializes the backing store. The xConnect method just connects to an existing backing store. When xCreate and xConnect are the same, the table is an &lt;a href=&quot;vtab#epovtab&quot;&gt;eponymous virtual table&lt;/a&gt;.</source>
          <target state="translated">Методы xCreate и xConnect различаются только в том случае, если виртуальная таблица имеет какое-то резервное хранилище, которое необходимо инициализировать при первом создании виртуальной таблицы. Метод xCreate создает и инициализирует резервное хранилище. Метод xConnect просто подключается к существующему хранилищу резервных копий. Когда xCreate и xConnect совпадают, таблица является &lt;a href=&quot;vtab#epovtab&quot;&gt;одноименной виртуальной таблицей&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="dcf39a347f064ec02d2e007cec689340fd805ffc" translate="yes" xml:space="preserve">
          <source>The xCreate method is called to create a new instance of a virtual table in response to a &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; statement. If the xCreate method is the same pointer as the &lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; method, then the virtual table is an &lt;a href=&quot;vtab#epovtab&quot;&gt;eponymous virtual table&lt;/a&gt;. If the xCreate method is omitted (if it is a NULL pointer) then the virtual table is an &lt;a href=&quot;vtab#epoonlyvtab&quot;&gt;eponymous-only virtual table&lt;/a&gt;.</source>
          <target state="translated">Метод xCreate вызывается для создания нового экземпляра виртуальной таблицы в ответ на оператор &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; . Если метод xCreate является тем же указателем, что и метод &lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; , тогда виртуальная таблица является &lt;a href=&quot;vtab#epovtab&quot;&gt;одноименной виртуальной таблицей&lt;/a&gt; . Если метод xCreate опущен (если это указатель NULL), тогда виртуальная таблица является &lt;a href=&quot;vtab#epoonlyvtab&quot;&gt;одноименной виртуальной таблицей&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7fa820ae673d5a152c6735ecfbe5a6902d1afc09" translate="yes" xml:space="preserve">
          <source>The xCreate method need not initialize the pModule, nRef, and zErrMsg fields of the &lt;a href=&quot;c3ref/vtab&quot;&gt;sqlite3_vtab&lt;/a&gt; object. The SQLite core will take care of that chore.</source>
          <target state="translated">Метод xCreate не требует инициализации полей pModule, nRef и zErrMsg объекта &lt;a href=&quot;c3ref/vtab&quot;&gt;sqlite3_vtab&lt;/a&gt; . Об этом позаботится ядро ​​SQLite.</target>
        </trans-unit>
        <trans-unit id="06c7e419a8719bf400eb11e6ddbab813f843fcfc" translate="yes" xml:space="preserve">
          <source>The xCreate should return &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; if it is successful in creating the new virtual table, or &lt;a href=&quot;rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt; if it is not successful. If not successful, the &lt;a href=&quot;c3ref/vtab&quot;&gt;sqlite3_vtab&lt;/a&gt; structure must not be allocated. An error message may optionally be returned in *pzErr if unsuccessful. Space to hold the error message string must be allocated using an SQLite memory allocation function like &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc()&lt;/a&gt; or &lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_mprintf()&lt;/a&gt; as the SQLite core will attempt to free the space using &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_free()&lt;/a&gt; after the error has been reported up to the application.</source>
          <target state="translated">XCreate должен вернуть &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK,&lt;/a&gt; если он успешно создает новую виртуальную таблицу, или &lt;a href=&quot;rescode#error&quot;&gt;SQLITE_ERROR,&lt;/a&gt; если это не удалось. В случае &lt;a href=&quot;c3ref/vtab&quot;&gt;неудачи&lt;/a&gt; нельзя выделять структуру sqlite3_vtab . В случае неудачи сообщение об ошибке может быть возвращено в * pzErr. Пространство для хранения строки сообщения об ошибке должно быть выделено с помощью функции выделения памяти SQLite, такой как &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc ()&lt;/a&gt; или &lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_mprintf (),&lt;/a&gt; поскольку ядро ​​SQLite попытается освободить пространство с помощью &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_free ()&lt;/a&gt; после того, как об ошибке было сообщено приложению.</target>
        </trans-unit>
        <trans-unit id="f958ace0be88d27965e6fd7b0b417f1f44eb7a29" translate="yes" xml:space="preserve">
          <source>The xCurrentTime method finds the current time and date and writes the result as a double-precision floating point value into pointer provided by the second parameter. The time and date is in coordinated universal time (UTC) and is a fractional Julian day number.</source>
          <target state="translated">Метод xCurrentTime находит текущее время и дату и записывает результат в виде значения с плавающей точкой двойной точности в указатель,предоставленный вторым параметром.Время и дата находятся в координированном универсальном времени (UTC)и представляют собой дробное число юлианских суток.</target>
        </trans-unit>
        <trans-unit id="6df2a95b2c02a08ca9301c1af593f076dcec3de1" translate="yes" xml:space="preserve">
          <source>The xDelete callback, if one is specified, is also invoked on the auxiliary data pointer after the FTS5 query has finished.</source>
          <target state="translated">Обратный вызов xDelete,если он указан,также вызывается на вспомогательный указатель данных после завершения FTS5-запроса.</target>
        </trans-unit>
        <trans-unit id="684db9583b8006f9c3587ed123a3291e36233a15" translate="yes" xml:space="preserve">
          <source>The xDelete method in the built-in &lt;a href=&quot;vfs&quot;&gt;VFSes&lt;/a&gt; now return SQLITE_IOERR_DELETE_NOENT if the file to be deleted does not exist.</source>
          <target state="translated">Метод xDelete во встроенных &lt;a href=&quot;vfs&quot;&gt;виртуальных файловых системах&lt;/a&gt; теперь возвращает SQLITE_IOERR_DELETE_NOENT, если удаляемый файл не существует.</target>
        </trans-unit>
        <trans-unit id="8acbdfc184b8627360b75ab194ff6c7691155e56" translate="yes" xml:space="preserve">
          <source>The xDelete method is used to delete a file. The name of the file is given in the second parameter. The filename will be in UTF-8. The VFS must convert the filename into whatever character representation the underlying operating system expects. If the syncDir parameter is true, then the xDelete method should not return until the change to the directory contents for the directory containing the deleted file have been synced to disk in order to ensure that the file does not &quot;reappear&quot; if a power failure occurs soon after.</source>
          <target state="translated">Метод xDelete используется для удаления файла.Имя файла указывается во втором параметре.Имя файла будет в кодировке UTF-8.VFS должна преобразовать имя файла в любое символьное представление,которое ожидает операционная система.Если параметр syncDir верен,то метод xDelete не должен возвращаться до тех пор,пока изменение содержимого каталога,содержащего удаленный файл,не будет синхронизировано на диск,чтобы файл не &quot;появился&quot; в случае отключения питания вскоре после этого.</target>
        </trans-unit>
        <trans-unit id="a6b9e63dc2c6d8a6c7065b91aea92c7e5db6e627" translate="yes" xml:space="preserve">
          <source>The xDestroy argument to sqlite3_carray_bind() routine is a pointer to a function that frees the input array. SQLite will invoke this function after it has finished with the data. The xDestroy argument may optionally be one of the following constants defined in &quot;sqlite3.h&quot;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11b2a4e02961f3a81754bcacd1c2618edac811a1" translate="yes" xml:space="preserve">
          <source>The xDestroy callback is &lt;u&gt;not&lt;/u&gt; called if the sqlite3_create_collation_v2() function fails. Applications that invoke sqlite3_create_collation_v2() with a non-NULL xDestroy argument should check the return code and dispose of the application data pointer themselves rather than expecting SQLite to deal with it for them. This is different from every other SQLite interface. The inconsistency is unfortunate but cannot be changed without breaking backwards compatibility.</source>
          <target state="translated">Обратный вызов xDestroy &lt;u&gt;не&lt;/u&gt; вызывается, если функция sqlite3_create_collation_v2 () не работает. Приложения, которые вызывают sqlite3_create_collation_v2 () с аргументом xDestroy, отличным от NULL, должны сами проверять код возврата и удалять указатель данных приложения, а не ожидать, что SQLite обработает это за них. Это отличается от любого другого интерфейса SQLite. Несогласованность вызывает сожаление, но ее нельзя изменить без нарушения обратной совместимости.</target>
        </trans-unit>
        <trans-unit id="82fcb2416a6d15ad9c7eed2868bb3c1083659be9" translate="yes" xml:space="preserve">
          <source>The xDestroy method is required for every virtual table implementation, though it is acceptable for the &lt;a href=&quot;vtab#xdisconnect&quot;&gt;xDisconnect&lt;/a&gt; and xDestroy methods to be the same function if that makes sense for the particular virtual table.</source>
          <target state="translated">Метод xDestroy требуется для каждой реализации виртуальной таблицы, хотя допустимо, чтобы методы &lt;a href=&quot;vtab#xdisconnect&quot;&gt;xDisconnect&lt;/a&gt; и xDestroy были одной и той же функцией, если это имеет смысл для конкретной виртуальной таблицы.</target>
        </trans-unit>
        <trans-unit id="433eafbb64ee6df6fcf2cd0863165758dd2318f2" translate="yes" xml:space="preserve">
          <source>The xDestroy() method is used to delete a cache allocated by xCreate(). All resources associated with the specified cache should be freed. After calling the xDestroy() method, SQLite considers the &lt;a href=&quot;#sqlite3_pcache&quot; id=&quot;thexdestroypagecachemethod&quot;&gt;sqlite3_pcache*&lt;/a&gt; handle invalid, and will not use it with any other sqlite3_pcache_methods2 functions.</source>
          <target state="translated">Метод xDestroy () используется для удаления кеша, выделенного xCreate (). Все ресурсы, связанные с указанным кешем, должны быть освобождены. После вызова метода xDestroy () SQLite считает дескриптор &lt;a href=&quot;#sqlite3_pcache&quot; id=&quot;thexdestroypagecachemethod&quot;&gt;sqlite3_pcache *&lt;/a&gt; недействительным и не будет использовать его с другими функциями sqlite3_pcache_methods2.</target>
        </trans-unit>
        <trans-unit id="8baf35611bcad0c5db55f35fee163e2aa0c149e9" translate="yes" xml:space="preserve">
          <source>The xDestroy() method is used to delete a cache allocated by xCreate(). All resources associated with the specified cache should be freed. After calling the xDestroy() method, SQLite considers the &lt;a href=&quot;pcache&quot; id=&quot;thexdestroypagecachemethod&quot;&gt;sqlite3_pcache*&lt;/a&gt; handle invalid, and will not use it with any other sqlite3_pcache_methods2 functions.</source>
          <target state="translated">Метод xDestroy () используется для удаления кеша, выделенного xCreate (). Все ресурсы, связанные с указанным кешем, должны быть освобождены. После вызова метода xDestroy () SQLite считает дескриптор &lt;a href=&quot;pcache&quot; id=&quot;thexdestroypagecachemethod&quot;&gt;sqlite3_pcache *&lt;/a&gt; недействительным и не будет использовать его с другими функциями sqlite3_pcache_methods2.</target>
        </trans-unit>
        <trans-unit id="604385447aab898766cb3896d8016d04ab97fc0d" translate="yes" xml:space="preserve">
          <source>The xDeviceCharacteristics method of the &lt;a href=&quot;#sqlite3_io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object returns an integer which is a vector of these bit values expressing I/O characteristics of the mass storage device that holds the file that the &lt;a href=&quot;#sqlite3_io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; refers to.</source>
          <target state="translated">Метод xDeviceCharacteristics объекта &lt;a href=&quot;#sqlite3_io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; возвращает целое число, которое является вектором этих битовых значений, выражающих характеристики ввода-вывода запоминающего устройства большой емкости, содержащего файл, на который ссылается &lt;a href=&quot;#sqlite3_io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b98ec973b9735d7dd446dd0f56fe3b7eb0a27d7c" translate="yes" xml:space="preserve">
          <source>The xDeviceCharacteristics method of the &lt;a href=&quot;io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object returns an integer which is a vector of these bit values expressing I/O characteristics of the mass storage device that holds the file that the &lt;a href=&quot;io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; refers to.</source>
          <target state="translated">Метод xDeviceCharacteristics объекта &lt;a href=&quot;io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; возвращает целое число, которое является вектором этих битовых значений, выражающих характеристики ввода-вывода запоминающего устройства большой емкости, содержащего файл, на который ссылается &lt;a href=&quot;io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c2e8466b1e208836960d6bb4f90ed3ea7832fd67" translate="yes" xml:space="preserve">
          <source>The xDeviceCharacteristics method returns an integer bit vector that defines any special properties that the underlying storage medium might have that SQLite can use to increase performance. The allowed return is the bit-wise OR of the following values:</source>
          <target state="translated">Метод xDeviceCharacteristics возвращает целочисленный битовый вектор,который определяет любые специальные свойства,которые может иметь базовый носитель данных,который SQLite может использовать для повышения производительности.Допустимым возвратом является битовое ИЛИ следующих значений:</target>
        </trans-unit>
        <trans-unit id="1262b3501d52f25dbe2da92b37772cb17c293d40" translate="yes" xml:space="preserve">
          <source>The xDisconnect method is required for every virtual table implementation, though it is acceptable for the xDisconnect and &lt;a href=&quot;vtab#sqlite3_module.xDestroy&quot;&gt;xDestroy&lt;/a&gt; methods to be the same function if that makes sense for the particular virtual table.</source>
          <target state="translated">Метод xDisconnect требуется для каждой реализации виртуальной таблицы, хотя допустимо, чтобы методы xDisconnect и &lt;a href=&quot;vtab#sqlite3_module.xDestroy&quot;&gt;xDestroy&lt;/a&gt; были одной и той же функцией, если это имеет смысл для конкретной виртуальной таблицы.</target>
        </trans-unit>
        <trans-unit id="80202d349ad4d59a55548ad8afd689feeefba61b" translate="yes" xml:space="preserve">
          <source>The xDlOpen, xDlError, xDlSym, and xDlClose methods are all used for accessing shared libraries at run-time. These methods may be omitted (and their pointers set to zero) if the library is compiled with &lt;a href=&quot;compile#omit_load_extension&quot;&gt;SQLITE_OMIT_LOAD_EXTENSION&lt;/a&gt; or if the &lt;a href=&quot;c3ref/enable_load_extension&quot;&gt;sqlite3_enable_load_extension()&lt;/a&gt; interface is never used to enable dynamic extension loading. The xDlOpen method opens a shared library or DLL and returns a pointer to a handle. NULL is returned if the open fails. If the open fails, the xDlError method can be used to obtain a text error message. The message is written into the zErrMsg buffer of the third parameter which is at least nByte bytes in length. The xDlSym returns a pointer to a symbol in the shared library. The name of the symbol is given by the second parameter. UTF-8 encoding is assumed. If the symbol is not found a NULL pointer is returned. The xDlClose routine closes the shared library.</source>
          <target state="translated">Все методы xDlOpen, xDlError, xDlSym и xDlClose используются для доступа к разделяемым библиотекам во время выполнения. Эти методы могут быть опущены (и их указатели установлены в ноль), если библиотека скомпилирована с &lt;a href=&quot;compile#omit_load_extension&quot;&gt;SQLITE_OMIT_LOAD_EXTENSION&lt;/a&gt; или если &lt;a href=&quot;c3ref/enable_load_extension&quot;&gt;sqlite3_enable_load_extension ()&lt;/a&gt;интерфейс никогда не используется для включения динамической загрузки расширений. Метод xDlOpen открывает общую библиотеку или DLL и возвращает указатель на дескриптор. NULL возвращается, если открытие не удалось. В случае сбоя открытия можно использовать метод xDlError для получения текстового сообщения об ошибке. Сообщение записывается в буфер zErrMsg третьего параметра, который имеет длину не менее nByte байт. XDlSym возвращает указатель на символ в общей библиотеке. Имя символа задается вторым параметром. Предполагается кодировка UTF-8. Если символ не найден, возвращается NULL указатель. Подпрограмма xDlClose закрывает общую библиотеку.</target>
        </trans-unit>
        <trans-unit id="2a328c23f376e27049c3463e790fd30ea24be07c" translate="yes" xml:space="preserve">
          <source>The xEof method is required for every virtual table implementation.</source>
          <target state="translated">Метод xEof необходим для каждой реализации виртуальной таблицы.</target>
        </trans-unit>
        <trans-unit id="2f524de9f6418ba3f20971cbbb6e678439f267fb" translate="yes" xml:space="preserve">
          <source>The xEof method must return false (zero) if the specified cursor currently points to a valid row of data, or true (non-zero) otherwise. This method is called by the SQL engine immediately after each &lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter&lt;/a&gt; and &lt;a href=&quot;vtab#xnext&quot;&gt;xNext&lt;/a&gt; invocation.</source>
          <target state="translated">Метод xEof должен возвращать false (ноль), если указанный курсор в настоящий момент указывает на допустимую строку данных, или true (ненулевое значение) в противном случае. Этот метод вызывается механизмом SQL сразу после каждого &lt;a href=&quot;vtab#xfilter&quot;&gt;вызова xFilter&lt;/a&gt; и &lt;a href=&quot;vtab#xnext&quot;&gt;xNext&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="31055a962a7bb13c9dfa534ee5cb14dc7402ab08" translate="yes" xml:space="preserve">
          <source>The xFetch() method locates a page in the cache and returns a pointer to an sqlite3_pcache_page object associated with that page, or a NULL pointer. The pBuf element of the returned sqlite3_pcache_page object will be a pointer to a buffer of szPage bytes used to store the content of a single database page. The pExtra element of sqlite3_pcache_page will be a pointer to the szExtra bytes of extra storage that SQLite has requested for each entry in the page cache.</source>
          <target state="translated">Метод xFetch()находит страницу в кэше и возвращает указатель на объект sqlite3_pcache_page,связанный с этой страницей,или указатель NULL.Элемент pBuf возвращаемого объекта sqlite3_pcache_page будет указателем на буфер байт szPage,используемый для хранения содержимого одной страницы БД.Элемент pExtra sqlite3_pcache_page будет указателем на байты szExtra дополнительного хранилища,которые SQLite запрашивал для каждого элемента в кэше страниц.</target>
        </trans-unit>
        <trans-unit id="eec30896c07568e6756a1fd11de9a9be38006b51" translate="yes" xml:space="preserve">
          <source>The xFileControl() method is a generic interface that allows custom VFS implementations to directly control an open file using the (new and experimental) &lt;a href=&quot;c3ref/file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; interface. The second &quot;op&quot; argument is an integer opcode. The third argument is a generic pointer which is intended to be a pointer to a structure that may contain arguments or space in which to write return values. Potential uses for xFileControl() might be functions to enable blocking locks with timeouts, to change the locking strategy (for example to use dot-file locks), to inquire about the status of a lock, or to break stale locks. The SQLite core reserves opcodes less than 100 for its own use. A &lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntllockstate&quot;&gt;list of opcodes&lt;/a&gt; less than 100 is available. Applications that define a custom xFileControl method should use opcodes greater than 100 to avoid conflicts.</source>
          <target state="translated">Метод xFileControl () - это общий интерфейс, который позволяет настраиваемым реализациям VFS напрямую управлять открытым файлом с помощью (нового и экспериментального &lt;a href=&quot;c3ref/file_control&quot;&gt;)&lt;/a&gt; интерфейса sqlite3_file_control () . Второй аргумент op - это целочисленный код операции. Третий аргумент - это общий указатель, который предназначен для использования в качестве указателя на структуру, которая может содержать аргументы или пространство для записи возвращаемых значений. Возможным использованием xFileControl () могут быть функции для включения блокирующих блокировок с тайм-аутом, для изменения стратегии блокировки (например, для использования блокировок точечных файлов), для запроса состояния блокировки или для снятия устаревших блокировок. Ядро SQLite резервирует коды операций менее 100 для собственного использования. &lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntllockstate&quot;&gt;Список опкодов&lt;/a&gt;доступно менее 100. Приложения, которые определяют собственный метод xFileControl, должны использовать коды операций больше 100, чтобы избежать конфликтов.</target>
        </trans-unit>
        <trans-unit id="dddf7acfafd6d3f8269f8f981d3bcbe57970b96a" translate="yes" xml:space="preserve">
          <source>The xFileControl() method is a generic interface that allows custom VFS implementations to directly control an open file using the &lt;a href=&quot;#sqlite3_file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; interface. The second &quot;op&quot; argument is an integer opcode. The third argument is a generic pointer intended to point to a structure that may contain arguments or space in which to write return values. Potential uses for xFileControl() might be functions to enable blocking locks with timeouts, to change the locking strategy (for example to use dot-file locks), to inquire about the status of a lock, or to break stale locks. The SQLite core reserves all opcodes less than 100 for its own use. A &lt;a href=&quot;#SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&quot;&gt;list of opcodes&lt;/a&gt; less than 100 is available. Applications that define a custom xFileControl method should use opcodes greater than 100 to avoid conflicts. VFS implementations should return &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOTFOUND&lt;/a&gt; for file control opcodes that they do not recognize.</source>
          <target state="translated">Метод xFileControl () - это общий интерфейс, который позволяет настраиваемым реализациям VFS напрямую управлять открытым файлом с помощью интерфейса &lt;a href=&quot;#sqlite3_file_control&quot;&gt;sqlite3_file_control ()&lt;/a&gt; . Второй аргумент op - это целочисленный код операции. Третий аргумент - это общий указатель, предназначенный для указания на структуру, которая может содержать аргументы или пространство для записи возвращаемых значений. Возможным использованием xFileControl () могут быть функции для включения блокирующих блокировок с тайм-аутом, для изменения стратегии блокировки (например, для использования блокировок точечных файлов), для запроса состояния блокировки или для снятия устаревших блокировок. Ядро SQLite резервирует все коды операций менее 100 для собственного использования. &lt;a href=&quot;#SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&quot;&gt;Список опкодов&lt;/a&gt;доступно менее 100. Приложения, которые определяют собственный метод xFileControl, должны использовать коды операций больше 100, чтобы избежать конфликтов. Реализации VFS должны возвращать &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOTFOUND&lt;/a&gt; для кодов операций управления файлами, которые они не распознают.</target>
        </trans-unit>
        <trans-unit id="0cff0bc514819c033ff2d05910e11b13ceab5fce" translate="yes" xml:space="preserve">
          <source>The xFileControl() method is a generic interface that allows custom VFS implementations to directly control an open file using the &lt;a href=&quot;file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; interface. The second &quot;op&quot; argument is an integer opcode. The third argument is a generic pointer intended to point to a structure that may contain arguments or space in which to write return values. Potential uses for xFileControl() might be functions to enable blocking locks with timeouts, to change the locking strategy (for example to use dot-file locks), to inquire about the status of a lock, or to break stale locks. The SQLite core reserves all opcodes less than 100 for its own use. A &lt;a href=&quot;c_fcntl_begin_atomic_write&quot;&gt;list of opcodes&lt;/a&gt; less than 100 is available. Applications that define a custom xFileControl method should use opcodes greater than 100 to avoid conflicts. VFS implementations should return &lt;a href=&quot;../rescode#notfound&quot;&gt;SQLITE_NOTFOUND&lt;/a&gt; for file control opcodes that they do not recognize.</source>
          <target state="translated">Метод xFileControl () - это общий интерфейс, который позволяет настраиваемым реализациям VFS напрямую управлять открытым файлом с помощью интерфейса &lt;a href=&quot;file_control&quot;&gt;sqlite3_file_control ()&lt;/a&gt; . Второй аргумент op - это целочисленный код операции. Третий аргумент - это общий указатель, предназначенный для указания на структуру, которая может содержать аргументы или пространство для записи возвращаемых значений. Возможным использованием xFileControl () могут быть функции для включения блокирующих блокировок с тайм-аутом, для изменения стратегии блокировки (например, для использования блокировок точечных файлов), для запроса состояния блокировки или для снятия устаревших блокировок. Ядро SQLite резервирует все коды операций менее 100 для собственного использования. &lt;a href=&quot;c_fcntl_begin_atomic_write&quot;&gt;Список опкодов&lt;/a&gt;доступно менее 100. Приложения, которые определяют собственный метод xFileControl, должны использовать коды операций больше 100, чтобы избежать конфликтов. Реализации VFS должны возвращать &lt;a href=&quot;../rescode#notfound&quot;&gt;SQLITE_NOTFOUND&lt;/a&gt; для кодов операций управления файлами, которые они не распознают.</target>
        </trans-unit>
        <trans-unit id="3203c926180842d31c782d904c037633ddf2f91f" translate="yes" xml:space="preserve">
          <source>The xFileSize() method determines the current size of the file in bytes and writes that value into *pSize. It returns &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; on success and &lt;a href=&quot;rescode#ioerr_fstat&quot;&gt;SQLITE_IOERR_FSTAT&lt;/a&gt; if something goes wrong.</source>
          <target state="translated">Метод xFileSize () определяет текущий размер файла в байтах и ​​записывает это значение в * pSize. Он возвращает &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; в случае успеха и &lt;a href=&quot;rescode#ioerr_fstat&quot;&gt;SQLITE_IOERR_FSTAT,&lt;/a&gt; если что-то пойдет не так.</target>
        </trans-unit>
        <trans-unit id="96653ab4bb654a8e871b1a8c14aa48716aadb8ae" translate="yes" xml:space="preserve">
          <source>The xFilter method is required for every virtual table implementation.</source>
          <target state="translated">Метод xFilter требуется для каждой реализации виртуальной таблицы.</target>
        </trans-unit>
        <trans-unit id="4479f4bd625e3440b28fa60e755d9671817cfbcf" translate="yes" xml:space="preserve">
          <source>The xFullPathname method is used to convert a relative pathname into a full pathname. The resulting full pathname is written into the buffer provided by the third parameter. SQLite will size the output buffer to at least mxPathname bytes. Both the input and output names should be in UTF-8.</source>
          <target state="translated">Метод xFullPathname используется для преобразования относительного имени в полное.Полученный полный путь записывается в буфер,предоставляемый третьим параметром.SQLite будет размер выходного буфера не менее mxPathname в байтах.Имена как входного,так и выходного должны быть в кодировке UTF-8.</target>
        </trans-unit>
        <trans-unit id="5dbd41bd881211c13a1dbbcb8c736851e1bf5d97" translate="yes" xml:space="preserve">
          <source>The xGeom callback always does a depth-first search of the r-tree.</source>
          <target state="translated">Обратный вызов xGeom всегда выполняет глубинный поиск r-дерева.</target>
        </trans-unit>
        <trans-unit id="454e11b15802805175a3b539debe13d361beb72d" translate="yes" xml:space="preserve">
          <source>The xGetTempName method computes the name of a temporary file that SQLite can use. The name should be written into the buffer given by the second parameter. SQLite will size that buffer to hold at least mxPathname bytes. The generated filename should be in UTF-8. To avoid security problems, the generated temporary filename should contain enough randomness to prevent an attacker from guessing the temporary filename in advance.</source>
          <target state="translated">Метод xGetTempName вычисляет имя временного файла,который SQLite может использовать.Имя должно быть записано в буфер,заданный вторым параметром.SQLite будет размер этого буфера не менее mxPathname байт.Генерируемое имя файла должно быть в UTF-8.Чтобы избежать проблем с безопасностью,сгенерированное временное имя файла должно содержать достаточное количество случайностей,чтобы злоумышленник не смог заранее угадать временное имя файла.</target>
        </trans-unit>
        <trans-unit id="5d25f32f0f944f020730e420a59b761837d6fa20" translate="yes" xml:space="preserve">
          <source>The xGetTempname method has been removed from &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;. In its place, the xOpen method is enhanced to open a temporary file of its own invention when the filename parameter is NULL.</source>
          <target state="translated">Метод xGetTempname был удален из &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; . Вместо этого метод xOpen расширен и позволяет открывать временный файл собственного изобретения, когда параметр filename равен NULL.</target>
        </trans-unit>
        <trans-unit id="e9de98bc73bd358a33146535bc6a4c0838edf0ac" translate="yes" xml:space="preserve">
          <source>The xInit method initializes the memory allocator. For example, it might allocate any require mutexes or initialize internal data structures. The xShutdown method is invoked (indirectly) by &lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_shutdown()&lt;/a&gt; and should deallocate any resources acquired by xInit. The pAppData pointer is used as the only parameter to xInit and xShutdown.</source>
          <target state="translated">Метод xInit инициализирует распределитель памяти. Например, он может выделить любые требуемые мьютексы или инициализировать внутренние структуры данных. Метод xShutdown вызывается (косвенно) &lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_shutdown ()&lt;/a&gt; и должен освободить все ресурсы, полученные xInit. Указатель pAppData используется как единственный параметр для xInit и xShutdown.</target>
        </trans-unit>
        <trans-unit id="3fa9fa67f04b6378191cf480be2d31d4ea4b3e4c" translate="yes" xml:space="preserve">
          <source>The xInit method initializes the memory allocator. For example, it might allocate any require mutexes or initialize internal data structures. The xShutdown method is invoked (indirectly) by &lt;a href=&quot;initialize&quot;&gt;sqlite3_shutdown()&lt;/a&gt; and should deallocate any resources acquired by xInit. The pAppData pointer is used as the only parameter to xInit and xShutdown.</source>
          <target state="translated">Метод xInit инициализирует распределитель памяти. Например, он может выделить любые требуемые мьютексы или инициализировать внутренние структуры данных. Метод xShutdown вызывается (косвенно) &lt;a href=&quot;initialize&quot;&gt;sqlite3_shutdown ()&lt;/a&gt; и должен освободить все ресурсы, полученные xInit. Указатель pAppData используется как единственный параметр для xInit и xShutdown.</target>
        </trans-unit>
        <trans-unit id="b5977e9a51901888e399d44616a096c8dd4ad36a" translate="yes" xml:space="preserve">
          <source>The xInit method initializes the memory allocator. For example, it might allocate any required mutexes or initialize internal data structures. The xShutdown method is invoked (indirectly) by &lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_shutdown()&lt;/a&gt; and should deallocate any resources acquired by xInit. The pAppData pointer is used as the only parameter to xInit and xShutdown.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9b210b9a34cdea6b00c84f118c3818052de5137" translate="yes" xml:space="preserve">
          <source>The xInit method initializes the memory allocator. For example, it might allocate any required mutexes or initialize internal data structures. The xShutdown method is invoked (indirectly) by &lt;a href=&quot;initialize&quot;&gt;sqlite3_shutdown()&lt;/a&gt; and should deallocate any resources acquired by xInit. The pAppData pointer is used as the only parameter to xInit and xShutdown.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="928f04710edbd4aadd8a60154ed8a2e307eed0ef" translate="yes" xml:space="preserve">
          <source>The xInit() method is called once for each effective call to &lt;a href=&quot;#sqlite3_initialize&quot; id=&quot;thexinitpagecachemethod&quot;&gt;sqlite3_initialize()&lt;/a&gt; (usually only once during the lifetime of the process). The xInit() method is passed a copy of the sqlite3_pcache_methods2.pArg value. The intent of the xInit() method is to set up global data structures required by the custom page cache implementation. If the xInit() method is NULL, then the built-in default page cache is used instead of the application defined page cache.</source>
          <target state="translated">Метод xInit () вызывается один раз для каждого эффективного вызова &lt;a href=&quot;#sqlite3_initialize&quot; id=&quot;thexinitpagecachemethod&quot;&gt;sqlite3_initialize ()&lt;/a&gt; (обычно только один раз за время существования процесса). В метод xInit () передается копия значения sqlite3_pcache_methods2.pArg. Назначение метода xInit () - настроить глобальные структуры данных, необходимые для реализации пользовательского кэша страниц. Если метод xInit () имеет значение ПУСТО (NULL), то используется встроенный по умолчанию кеш страниц вместо кеша страниц, определяемого приложением.</target>
        </trans-unit>
        <trans-unit id="6ba32c8d759124102ccc057ecbe6a0c1c85fb3b5" translate="yes" xml:space="preserve">
          <source>The xInit() method is called once for each effective call to &lt;a href=&quot;initialize&quot; id=&quot;thexinitpagecachemethod&quot;&gt;sqlite3_initialize()&lt;/a&gt; (usually only once during the lifetime of the process). The xInit() method is passed a copy of the sqlite3_pcache_methods2.pArg value. The intent of the xInit() method is to set up global data structures required by the custom page cache implementation. If the xInit() method is NULL, then the built-in default page cache is used instead of the application defined page cache.</source>
          <target state="translated">Метод xInit () вызывается один раз для каждого эффективного вызова &lt;a href=&quot;initialize&quot; id=&quot;thexinitpagecachemethod&quot;&gt;sqlite3_initialize ()&lt;/a&gt; (обычно только один раз за время существования процесса). В метод xInit () передается копия значения sqlite3_pcache_methods2.pArg. Назначение метода xInit () - настроить глобальные структуры данных, необходимые для реализации пользовательского кэша страниц. Если метод xInit () имеет значение ПУСТО (NULL), то используется встроенный по умолчанию кеш страниц вместо кеша страниц, определяемого приложением.</target>
        </trans-unit>
        <trans-unit id="8a32ff6fcc7d9e120e222fe6ef8bbf8b9661df8a" translate="yes" xml:space="preserve">
          <source>The xLock and xUnlock methods are used to set and clear file locks. SQLite supports five levels of file locks, in order:</source>
          <target state="translated">Методы xLock и xUnlock используются для установки и очистки файловых замков.SQLite поддерживает пять уровней блокировки файлов по порядку:</target>
        </trans-unit>
        <trans-unit id="8a5c74b276f4ba001214e303873304b1cefc6f0e" translate="yes" xml:space="preserve">
          <source>The xMalloc, xRealloc, and xFree methods must work like the malloc(), realloc() and free() functions from the standard C library. SQLite guarantees that the second argument to xRealloc is always a value returned by a prior call to xRoundup.</source>
          <target state="translated">Методы xMalloc,xRealloc и xFree должны работать как функции malloc(),realloc()и free()из стандартной библиотеки Си.SQLite гарантирует,что вторым аргументом в xRealloc всегда будет значение,возвращенное предыдущим вызовом в xRoundup.</target>
        </trans-unit>
        <trans-unit id="f3c67d901eafc4b8170f137f64b1ed5325131c31" translate="yes" xml:space="preserve">
          <source>The xMutexEnd method defined by this structure is invoked as part of system shutdown by the sqlite3_shutdown() function. The implementation of this method is expected to release all outstanding resources obtained by the mutex methods implementation, especially those obtained by the xMutexInit method. The xMutexEnd() interface is invoked exactly once for each call to &lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_shutdown()&lt;/a&gt;.</source>
          <target state="translated">Метод xMutexEnd, определенный этой структурой, вызывается как часть завершения работы системы функцией sqlite3_shutdown (). Ожидается, что реализация этого метода освободит все невыполненные ресурсы, полученные с помощью реализации методов мьютекса, особенно те, которые получены с помощью метода xMutexInit. Интерфейс xMutexEnd () вызывается ровно один раз для каждого вызова &lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_shutdown ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="29460abd69ce976afdb57bd86f856a912e6b2129" translate="yes" xml:space="preserve">
          <source>The xMutexEnd method defined by this structure is invoked as part of system shutdown by the sqlite3_shutdown() function. The implementation of this method is expected to release all outstanding resources obtained by the mutex methods implementation, especially those obtained by the xMutexInit method. The xMutexEnd() interface is invoked exactly once for each call to &lt;a href=&quot;initialize&quot;&gt;sqlite3_shutdown()&lt;/a&gt;.</source>
          <target state="translated">Метод xMutexEnd, определенный этой структурой, вызывается как часть завершения работы системы функцией sqlite3_shutdown (). Ожидается, что реализация этого метода освободит все невыполненные ресурсы, полученные с помощью реализации методов мьютекса, особенно те, которые получены с помощью метода xMutexInit. Интерфейс xMutexEnd () вызывается ровно один раз для каждого вызова &lt;a href=&quot;initialize&quot;&gt;sqlite3_shutdown ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cd4f06c8938e3564cfbf224eac3d8cf5b5b06a0d" translate="yes" xml:space="preserve">
          <source>The xMutexInit method defined by this structure is invoked as part of system initialization by the sqlite3_initialize() function. The xMutexInit routine is called by SQLite exactly once for each effective call to &lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_initialize()&lt;/a&gt;.</source>
          <target state="translated">Метод xMutexInit, определенный этой структурой, вызывается как часть инициализации системы функцией sqlite3_initialize (). Подпрограмма xMutexInit вызывается SQLite ровно один раз для каждого эффективного вызова &lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_initialize ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="dab4cb79a586f29424445d440e5fffbfe8ba4495" translate="yes" xml:space="preserve">
          <source>The xMutexInit method defined by this structure is invoked as part of system initialization by the sqlite3_initialize() function. The xMutexInit routine is called by SQLite exactly once for each effective call to &lt;a href=&quot;initialize&quot;&gt;sqlite3_initialize()&lt;/a&gt;.</source>
          <target state="translated">Метод xMutexInit, определенный этой структурой, вызывается как часть инициализации системы функцией sqlite3_initialize (). Подпрограмма xMutexInit вызывается SQLite ровно один раз для каждого эффективного вызова &lt;a href=&quot;initialize&quot;&gt;sqlite3_initialize ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="89ac720acef7b2cd1f40cadc5a9b4008a6051773" translate="yes" xml:space="preserve">
          <source>The xMutexInit() method must be threadsafe. It must be harmless to invoke xMutexInit() multiple times within the same process and without intervening calls to xMutexEnd(). Second and subsequent calls to xMutexInit() must be no-ops.</source>
          <target state="translated">Метод xMutexInit()должен быть потокобезопасен.Должно быть безопасно вызывать xMutexInit()несколько раз в рамках одного и того же процесса и без вмешательства вызова xMutexEnd().Второй и последующие вызовы xMutexInit()должны быть безостановочными.</target>
        </trans-unit>
        <trans-unit id="35cc67c51c972e7defc85a2cd19b646cf64aa418" translate="yes" xml:space="preserve">
          <source>The xNext method advances a &lt;a href=&quot;c3ref/vtab_cursor&quot;&gt;virtual table cursor&lt;/a&gt; to the next row of a result set initiated by &lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter&lt;/a&gt;. If the cursor is already pointing at the last row when this routine is called, then the cursor no longer points to valid data and a subsequent call to the &lt;a href=&quot;vtab#xeof&quot;&gt;xEof&lt;/a&gt; method must return true (non-zero). If the cursor is successfully advanced to another row of content, then subsequent calls to &lt;a href=&quot;vtab#xeof&quot;&gt;xEof&lt;/a&gt; must return false (zero).</source>
          <target state="translated">Метод xNext &lt;a href=&quot;c3ref/vtab_cursor&quot;&gt;перемещает курсор виртуальной таблицы&lt;/a&gt; к следующей строке набора результатов, инициированного &lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter&lt;/a&gt; . Если курсор уже указывает на последнюю строку при вызове этой подпрограммы, то курсор больше не указывает на действительные данные, и последующий вызов метода &lt;a href=&quot;vtab#xeof&quot;&gt;xEof&lt;/a&gt; должен возвращать истину (ненулевое значение). Если курсор успешно перемещается на другую строку содержимого, последующие вызовы &lt;a href=&quot;vtab#xeof&quot;&gt;xEof&lt;/a&gt; должны возвращать false (ноль).</target>
        </trans-unit>
        <trans-unit id="c07bbf2e5005e8108d2f1c166d0b989d5b0ef5de" translate="yes" xml:space="preserve">
          <source>The xNext method is required for every virtual table implementation.</source>
          <target state="translated">Метод xNext требуется для каждой реализации виртуальной таблицы.</target>
        </trans-unit>
        <trans-unit id="eee0d952c4251db31a384eceabf2a26d2118eb4d" translate="yes" xml:space="preserve">
          <source>The xOpen method creates a new cursor used for accessing (read and/or writing) a virtual table. A successful invocation of this method will allocate the memory for the &lt;a href=&quot;c3ref/vtab_cursor&quot;&gt;sqlite3_vtab_cursor&lt;/a&gt; (or a subclass), initialize the new object, and make *ppCursor point to the new object. The successful call then returns &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;.</source>
          <target state="translated">Метод xOpen создает новый курсор, используемый для доступа (чтения и / или записи) к виртуальной таблице. Успешный вызов этого метода выделит память для &lt;a href=&quot;c3ref/vtab_cursor&quot;&gt;sqlite3_vtab_cursor&lt;/a&gt; (или подкласса), инициализирует новый объект и заставит * ppCursor указывать на новый объект. Затем успешный вызов возвращает &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="00b35252e3240b77ad5fc35ac862013d23c8ea89" translate="yes" xml:space="preserve">
          <source>The xOpen method is required for every virtual table implementation.</source>
          <target state="translated">Метод xOpen требуется для каждой реализации виртуальной таблицы.</target>
        </trans-unit>
        <trans-unit id="fe219d8e760e2d5872424a8a4fa6980f7d9bd820" translate="yes" xml:space="preserve">
          <source>The xOpen method need not initialize the pVtab field of the &lt;a href=&quot;c3ref/vtab_cursor&quot;&gt;sqlite3_vtab_cursor&lt;/a&gt; structure. The SQLite core will take care of that chore automatically.</source>
          <target state="translated">Метод xOpen не требует инициализации поля pVtab структуры &lt;a href=&quot;c3ref/vtab_cursor&quot;&gt;sqlite3_vtab_cursor&lt;/a&gt; . Ядро SQLite автоматически выполнит эту работу.</target>
        </trans-unit>
        <trans-unit id="5883a2e08ea426f3d0e98ebbcc84b207e43eeb5d" translate="yes" xml:space="preserve">
          <source>The xOutput callback is invoked zero or more times to return data to the application. The first parameter passed to each call is a copy of the pOut pointer supplied by the application. The second parameter, pData, points to a buffer nData bytes in size containing the chunk of output data being returned. If the xOutput callback successfully processes the supplied data, it should return SQLITE_OK to indicate success. Otherwise, it should return some other SQLite error code. In this case processing is immediately abandoned and the streaming API function returns a copy of the xOutput error code to the application.</source>
          <target state="translated">Обратный вызов xOutput вызывается нулевым или более раз для возврата данных в приложение.Первый параметр,передаваемый каждому вызову,является копией указателя pOut,поставляемого приложением.Второй параметр,pData,указывает на буфер nData байт размером с кусок возвращаемых выходных данных.Если xOutput callback успешно обрабатывает предоставленные данные,он должен вернуть SQLITE_OK,чтобы указать на успех.В противном случае,он должен вернуть другой код ошибки SQLite.В этом случае обработка немедленно прекращается и потоковая API-функция возвращает приложению копию кода ошибки xOutput.</target>
        </trans-unit>
        <trans-unit id="4fdec734fe0825d4b45223206e7ef21a40dca7d6" translate="yes" xml:space="preserve">
          <source>The xPagecount() method must return the number of pages currently stored in the cache, both pinned and unpinned.</source>
          <target state="translated">Метод xPagecount()должен возвращать количество страниц,хранящихся в кэше в данный момент,как пиннированных,так и не пиннированных.</target>
        </trans-unit>
        <trans-unit id="f7670800549df532ce782308a5027526fc2bbf4f" translate="yes" xml:space="preserve">
          <source>The xQueryFunc must set the eWithin field of sqlite3_rtree_query_info to one of the values NOT_WITHIN, PARTLY_WITHIN, or FULLY_WITHIN depending on whether or not the bounding box defined by aCoord[] is completely outside the region, overlaps the region, or is completely inside the region, respectively. In addition, the xQueryFunc must set the rScore field to a non-negative value that indicates the order in which subtrees and entries of the query should be analyzed and returned. Smaller scores are processed first.</source>
          <target state="translated">xQueryFunc должен установить поле eWithin sqlite3_rtree_query_info в одно из значений NOT_WITHIN,PARTLY_WITHIN или FULLY_WITHIN в зависимости от того,находится ли ограничительное поле,определенное aCoord[]полностью вне региона,перекрывает регион или полностью внутри региона,соответственно.Кроме того,xQueryFunc должен установить для поля rScore неотрицательное значение,указывающее порядок анализа и возврата поддеревьев и записей запроса.Сначала обрабатываются меньшие оценки.</target>
        </trans-unit>
        <trans-unit id="243e65d787818469363333eb640b0b44f38c6ec4" translate="yes" xml:space="preserve">
          <source>The xRandomness method is used exactly once to initialize the pseudo-random number generator (PRNG) inside of SQLite. Only the xRandomness method on the default VFS is used. The xRandomness methods on other VFSes are never accessed by SQLite. The xRandomness routine requests that nByte bytes of randomness be written into zOut. The routine returns the actual number of bytes of randomness obtained. The quality of the randomness so obtained will determine the quality of the randomness generated by built-in SQLite functions such as random() and randomblob(). SQLite also uses its PRNG to generate temporary file names. On some platforms (ex: Windows) SQLite assumes that temporary file names are unique without actually testing for collisions, so it is important to have good-quality randomness even if the random() and randomblob() functions are never used.</source>
          <target state="translated">Метод xRandomness используется ровно один раз для инициализации генератора псевдослучайных чисел (PRNG)внутри SQLite.Используется только метод xRandomness на VFS по умолчанию.Доступ к методам xRandomness на других VFS никогда не осуществляется SQLite.Метод xRandomness требует,чтобы в zOut были записаны nByte байты случайности.Рутина возвращает реальное количество полученных байт случайности.Качество полученной таким образом случайности определяет качество случайности,генерируемой встроенными функциями SQLite,такими как random()и randomblob().SQLite также использует свой PRNG для генерации имен временных файлов.На некоторых платформах (например,Windows)SQLite предполагает,что имена временных файлов уникальны без фактической проверки на коллизии,поэтому важно иметь хорошее качество случайности,даже если функции random()и randomblob()никогда не используются.</target>
        </trans-unit>
        <trans-unit id="2203fe5d9da94fc2d593e73757d6951b646a5aac" translate="yes" xml:space="preserve">
          <source>The xRandomness(), xSleep(), xCurrentTime(), and xCurrentTimeInt64() interfaces are not strictly a part of the filesystem, but they are included in the VFS structure for completeness. The xRandomness() function attempts to return nBytes bytes of good-quality randomness into zOut. The return value is the actual number of bytes of randomness obtained. The xSleep() method causes the calling thread to sleep for at least the number of microseconds given. The xCurrentTime() method returns a Julian Day Number for the current date and time as a floating point value. The xCurrentTimeInt64() method returns, as an integer, the Julian Day Number multiplied by 86400000 (the number of milliseconds in a 24-hour day). SQLite will use the xCurrentTimeInt64() method to get the current date and time if that method is available (if iVersion is 2 or greater and the function pointer is not NULL) and will fall back to xCurrentTime() if xCurrentTimeInt64() is unavailable.</source>
          <target state="translated">Интерфейсы xRandomness(),xSleep(),xCurrentTime()и xCurrentTimeInt64()не являются строго частью файловой системы,но для полноты они включены в структуру VFS.Функция xRandomness()пытается вернуть nBytes байт хорошего качества в zOut.Возвращаемое значение представляет собой фактическое количество полученных байт случайности.Метод xSleep()заставляет вызывающий поток спать,по крайней мере,в течение заданного количества микросекунд.Метод xCurrentTime()возвращает в качестве значения с плавающей точкой Julian Day Number для текущей даты и времени.Метод xCurrentTimeInt64()возвращает в виде целого числа номер юлианского дня,умноженного на 86400000 (количество миллисекунд за 24-часовой день).SQLite будет использовать метод xCurrentTimeInt64()для получения текущей даты и времени,если этот метод доступен (если iVersion равна 2 или больше и указатель функции не NULL)и вернется к xCurrentTime(),если xCurrentTimeInt64()недоступен.</target>
        </trans-unit>
        <trans-unit id="9578c347ea12c88b2a68bb1b8891cc899dd6f688" translate="yes" xml:space="preserve">
          <source>The xRead method reads iAmt bytes from the file beginning at a byte offset to iOfst. The data read is stored in the pointer of the second parameter. xRead returns the &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; on success, &lt;a href=&quot;rescode#ioerr_short_read&quot;&gt;SQLITE_IOERR_SHORT_READ&lt;/a&gt; if it was not able to read the full number of bytes because it reached end-of-file, or &lt;a href=&quot;rescode#ioerr_read&quot;&gt;SQLITE_IOERR_READ&lt;/a&gt; for any other error.</source>
          <target state="translated">Метод xRead считывает байты iAmt из файла, начиная с байтового смещения до iOfst. Считанные данные сохраняются в указателе второго параметра. xRead возвращает &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; в случае успеха, &lt;a href=&quot;rescode#ioerr_short_read&quot;&gt;SQLITE_IOERR_SHORT_READ,&lt;/a&gt; если он не смог прочитать полное количество байтов, потому что он достиг конца файла, или &lt;a href=&quot;rescode#ioerr_read&quot;&gt;SQLITE_IOERR_READ&lt;/a&gt; для любой другой ошибки.</target>
        </trans-unit>
        <trans-unit id="179305437ddf972de11f25d6c031548629b7dbeb" translate="yes" xml:space="preserve">
          <source>The xRekey() method is used to change the key value associated with the page passed as the second argument. If the cache previously contains an entry associated with newKey, it must be discarded. Any prior cache entry associated with newKey is guaranteed not to be pinned.</source>
          <target state="translated">Метод xRekey()используется для изменения значения ключа,связанного со страницей,переданной в качестве второго аргумента.Если в кэше ранее содержалась запись,связанная с newKey,то она должна быть отброшена.Любой предыдущий элемент кэша,связанный с newKey,гарантированно не будет пин-кодом.</target>
        </trans-unit>
        <trans-unit id="ee97077a16637439ff4f073f89fa74d3ae66efba" translate="yes" xml:space="preserve">
          <source>The xRename method is optional. If omitted, then the virtual table may not be renamed using the ALTER TABLE RENAME command.</source>
          <target state="translated">Метод xRename не является обязательным.Если его опустить,виртуальная таблица не может быть переименована с помощью команды ALTER TABLE RENAME.</target>
        </trans-unit>
        <trans-unit id="ac1529fc1db9096e5e7532c56994cf7e11a7e7d4" translate="yes" xml:space="preserve">
          <source>The xRoundup method returns what would be the allocated size of a memory allocation given a particular requested size. Most memory allocators round up memory allocations at least to the next multiple of 8. Some allocators round up to a larger multiple or to a power of 2. Every memory allocation request coming in through &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc()&lt;/a&gt; or &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_realloc()&lt;/a&gt; first calls xRoundup. If xRoundup returns 0, that causes the corresponding memory allocation to fail.</source>
          <target state="translated">Метод xRoundup возвращает размер выделенной памяти для конкретного запрошенного размера. Большинство распределителей памяти округляют распределение памяти по крайней мере до следующего кратного 8. Некоторые распределители округляют до большего кратного или до степени 2. Каждый запрос на выделение памяти, поступающий через &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc ()&lt;/a&gt; или &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_realloc (),&lt;/a&gt; сначала вызывает xRoundup. Если xRoundup возвращает 0, это приводит к сбою соответствующего выделения памяти.</target>
        </trans-unit>
        <trans-unit id="5558ee9f292501795b089dc2d3175bf349258bae" translate="yes" xml:space="preserve">
          <source>The xRoundup method returns what would be the allocated size of a memory allocation given a particular requested size. Most memory allocators round up memory allocations at least to the next multiple of 8. Some allocators round up to a larger multiple or to a power of 2. Every memory allocation request coming in through &lt;a href=&quot;free&quot;&gt;sqlite3_malloc()&lt;/a&gt; or &lt;a href=&quot;free&quot;&gt;sqlite3_realloc()&lt;/a&gt; first calls xRoundup. If xRoundup returns 0, that causes the corresponding memory allocation to fail.</source>
          <target state="translated">Метод xRoundup возвращает размер выделенной памяти для конкретного запрошенного размера. Большинство распределителей памяти округляют распределение памяти по крайней мере до следующего кратного 8. Некоторые распределители округляют до большего кратного или до степени 2. Каждый запрос на выделение памяти, поступающий через &lt;a href=&quot;free&quot;&gt;sqlite3_malloc ()&lt;/a&gt; или &lt;a href=&quot;free&quot;&gt;sqlite3_realloc (),&lt;/a&gt; сначала вызывает xRoundup. Если xRoundup возвращает 0, это приводит к сбою соответствующего выделения памяти.</target>
        </trans-unit>
        <trans-unit id="ac776ca96c027496fe8cb024585d72e01e0bde03" translate="yes" xml:space="preserve">
          <source>The xRowid method is required for every virtual table implementation.</source>
          <target state="translated">Метод xRowid требуется для каждой реализации виртуальной таблицы.</target>
        </trans-unit>
        <trans-unit id="f91951a49d3cd2a19053a4c5034726651d8bcc0a" translate="yes" xml:space="preserve">
          <source>The xSectorSize returns the &quot;sector size&quot; of the underlying non-volatile media. A &quot;sector&quot; is defined as the smallest unit of storage that can be written without disturbing adjacent storage. On a disk drive the &quot;sector size&quot; has until recently been 512 bytes, though there is a push to increase this value to 4KiB. SQLite needs to know the sector size so that it can write a full sector at a time, and thus avoid corrupting adjacent storage space if a power loss occurs in the middle of a write.</source>
          <target state="translated">xSectorSize возвращает &quot;размер сектора&quot; подстилающей энергонезависимой среды.Сектор&quot; определяется как наименьшая единица хранения,которая может быть записана без нарушения соседнего хранения.На дисковом накопителе &quot;размер сектора&quot; до недавнего времени составлял 512 байт,хотя существует толчок для увеличения этого значения до 4 КБ.SQLite необходимо знать размер сектора,чтобы иметь возможность записывать полный сектор за раз,и таким образом не повредить соседнее пространство хранения,если в середине записи произойдет отключение питания.</target>
        </trans-unit>
        <trans-unit id="7905596593f9a3650933e2dff7d4278590e16d18" translate="yes" xml:space="preserve">
          <source>The xSectorSize() method returns the sector size of the device that underlies the file. The sector size is the minimum write that can be performed without disturbing other bytes in the file. The xDeviceCharacteristics() method returns a bit vector describing behaviors of the underlying device:</source>
          <target state="translated">Метод xSectorSize()возвращает размер сектора устройства,лежащего в основе файла.Размер сектора-это минимальный размер записи,которую можно выполнить,не мешая другим байтам в файле.Метод xDeviceCharacteristics()возвращает битовый вектор,описывающий поведение лежащего в основе устройства:</target>
        </trans-unit>
        <trans-unit id="c28ec934424705226c30dba3dc7fb3bbb1c98c66" translate="yes" xml:space="preserve">
          <source>The xSetSystemCall(), xGetSystemCall(), and xNestSystemCall() interfaces are not used by the SQLite core. These optional interfaces are provided by some VFSes to facilitate testing of the VFS code. By overriding system calls with functions under its control, a test program can simulate faults and error conditions that would otherwise be difficult or impossible to induce. The set of system calls that can be overridden varies from one VFS to another, and from one version of the same VFS to the next. Applications that use these interfaces must be prepared for any or all of these interfaces to be NULL or for their behavior to change from one release to the next. Applications must not attempt to access any of these methods if the iVersion of the VFS is less than 3.</source>
          <target state="translated">Интерфейсы xSetSystemCall(),xGetSystemCall()и xNestSystemCall()не используются ядром SQLite.Эти дополнительные интерфейсы предоставляются некоторыми VFS для облегчения тестирования кода VFS.Переопределяя системные вызовы с функциями,находящимися под его контролем,тестовая программа может имитировать ошибки и условия возникновения ошибок,которые в противном случае было бы трудно или невозможно вызвать.Набор системных вызовов,которые могут быть переопределены,варьируется от одной VFS к другой,и от одной версии той же VFS к другой.Приложения,использующие эти интерфейсы,должны быть готовы к тому,что любой или все эти интерфейсы будут NULL,или к тому,что их поведение будет меняться от одного выпуска к другому.Приложения не должны пытаться получить доступ к любому из этих методов,если iVersion VFS меньше 3.</target>
        </trans-unit>
        <trans-unit id="5423cabb179d0301d2f1838406af9e345543b685" translate="yes" xml:space="preserve">
          <source>The xShadowName method exists to allow SQLite to determine whether a certain real table is in fact a shadow table for a virtual table.</source>
          <target state="translated">Метод xShadowName существует для того,чтобы SQLite мог определить,является ли на самом деле определенная реальная таблица теневой таблицей для виртуальной.</target>
        </trans-unit>
        <trans-unit id="947c2bf35d5cbfd4ce5579dacd8c602d7123b2d2" translate="yes" xml:space="preserve">
          <source>The xShadowName method returns true when its input is the part of the table name past the last &quot;_&quot; character.</source>
          <target state="translated">Метод xShadowName возвращает true,когда его ввод является частью имени таблицы после последнего символа &quot;_&quot;.</target>
        </trans-unit>
        <trans-unit id="bb9ed2671c0267a52c772896119a40dfbdf41d3e" translate="yes" xml:space="preserve">
          <source>The xShmLock method can transition between unlocked and SHARED or between unlocked and EXCLUSIVE. It cannot transition between SHARED and EXCLUSIVE.</source>
          <target state="translated">Метод xShmLock может переключаться между разблокированным и SHARED или между разблокированным и EXCLUSIVE.Он не может переключаться между SHARED и EXCLUSIVE.</target>
        </trans-unit>
        <trans-unit id="3b138a7b2ca75c6da01e38d919aae9bc4beaeeca" translate="yes" xml:space="preserve">
          <source>The xShmLock method on &lt;a href=&quot;#sqlite3_io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; may use values between 0 and this upper bound as its &quot;offset&quot; argument. The SQLite core will never attempt to acquire or release a lock outside of this range</source>
          <target state="translated">Метод xShmLock в &lt;a href=&quot;#sqlite3_io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; может использовать значения от 0 до этой верхней границы в качестве аргумента &amp;laquo;смещения&amp;raquo;. Ядро SQLite никогда не будет пытаться установить или снять блокировку за пределами этого диапазона.</target>
        </trans-unit>
        <trans-unit id="99e14d7c5dc9f436dda83c4868de4dcfa29aa8e2" translate="yes" xml:space="preserve">
          <source>The xShmLock method on &lt;a href=&quot;io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; may use values between 0 and this upper bound as its &quot;offset&quot; argument. The SQLite core will never attempt to acquire or release a lock outside of this range</source>
          <target state="translated">Метод xShmLock в &lt;a href=&quot;io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; может использовать значения от 0 до этой верхней границы в качестве аргумента &amp;laquo;смещения&amp;raquo;. Ядро SQLite никогда не будет пытаться установить или снять блокировку за пределами этого диапазона.</target>
        </trans-unit>
        <trans-unit id="c9d6171767cbe080777a834fc404f8313c3bd7a0" translate="yes" xml:space="preserve">
          <source>The xShutdown() method is called by &lt;a href=&quot;#sqlite3_initialize&quot; id=&quot;thexshutdownpagecachemethod&quot;&gt;sqlite3_shutdown()&lt;/a&gt;. It can be used to clean up any outstanding resources before process shutdown, if required. The xShutdown() method may be NULL.</source>
          <target state="translated">Метод xShutdown () вызывается &lt;a href=&quot;#sqlite3_initialize&quot; id=&quot;thexshutdownpagecachemethod&quot;&gt;sqlite3_shutdown ()&lt;/a&gt; . При необходимости его можно использовать для очистки любых невыполненных ресурсов перед остановкой процесса. Метод xShutdown () может иметь значение NULL.</target>
        </trans-unit>
        <trans-unit id="89b517d093efdb5642222dcbac94dd78a355996a" translate="yes" xml:space="preserve">
          <source>The xShutdown() method is called by &lt;a href=&quot;initialize&quot; id=&quot;thexshutdownpagecachemethod&quot;&gt;sqlite3_shutdown()&lt;/a&gt;. It can be used to clean up any outstanding resources before process shutdown, if required. The xShutdown() method may be NULL.</source>
          <target state="translated">Метод xShutdown () вызывается &lt;a href=&quot;initialize&quot; id=&quot;thexshutdownpagecachemethod&quot;&gt;sqlite3_shutdown ()&lt;/a&gt; . При необходимости его можно использовать для очистки любых невыполненных ресурсов перед остановкой процесса. Метод xShutdown () может иметь значение NULL.</target>
        </trans-unit>
        <trans-unit id="809b6a168241db65edee19e686edd4e9bd3b2bfa" translate="yes" xml:space="preserve">
          <source>The xSleep method is used to suspend the calling thread for at least the number of microseconds given. This method is used to implement the &lt;a href=&quot;c3ref/sleep&quot;&gt;sqlite3_sleep()&lt;/a&gt; and &lt;a href=&quot;c3ref/busy_timeout&quot;&gt;sqlite3_busy_timeout()&lt;/a&gt; APIs. In the case of &lt;a href=&quot;c3ref/sleep&quot;&gt;sqlite3_sleep()&lt;/a&gt; the xSleep method of the default VFS is always used. If the underlying system does not have a microsecond resolution sleep capability, then the sleep time should be rounded up. xSleep returns this rounded-up value.</source>
          <target state="translated">Метод xSleep используется для приостановки вызывающего потока по крайней мере на указанное количество микросекунд. Этот метод используется для реализации API &lt;a href=&quot;c3ref/sleep&quot;&gt;sqlite3_sleep ()&lt;/a&gt; и &lt;a href=&quot;c3ref/busy_timeout&quot;&gt;sqlite3_busy_timeout ()&lt;/a&gt; . В случае &lt;a href=&quot;c3ref/sleep&quot;&gt;sqlite3_sleep ()&lt;/a&gt; всегда используется метод xSleep VFS по умолчанию. Если базовая система не имеет возможности сна с разрешением в микросекунды, время сна следует округлить в большую сторону. xSleep возвращает это округленное значение.</target>
        </trans-unit>
        <trans-unit id="097b3f659c15f2c222834063189d1813c9097500" translate="yes" xml:space="preserve">
          <source>The xSync method is called again, to ensure that the update to the</source>
          <target state="translated">Метод xSync вызывается снова,чтобы убедиться в том,что обновление для</target>
        </trans-unit>
        <trans-unit id="c43866c10fb70246bff455fcc260272ec7695054" translate="yes" xml:space="preserve">
          <source>The xSync method is used to force previously written data out of operating system cache and into non-volatile memory. The second parameter is usually &lt;a href=&quot;c3ref/c_sync_dataonly&quot;&gt;SQLITE_SYNC_NORMAL&lt;/a&gt;. If the second parameter is &lt;a href=&quot;c3ref/c_sync_dataonly&quot;&gt;SQLITE_SYNC_FULL&lt;/a&gt; then the xSync method should make sure that data has also been flushed through the disk controllers cache. The &lt;a href=&quot;c3ref/c_sync_dataonly&quot;&gt;SQLITE_SYNC_FULL&lt;/a&gt; parameter is the equivalent of the F_FULLSYNC ioctl() on Mac OS X. The xSync method returns &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; on success and &lt;a href=&quot;rescode#ioerr_fsync&quot;&gt;SQLITE_IOERR_FSYNC&lt;/a&gt; if anything goes wrong.</source>
          <target state="translated">Метод xSync используется для принудительного удаления ранее записанных данных из кеша операционной системы в энергонезависимую память. Второй параметр обычно - &lt;a href=&quot;c3ref/c_sync_dataonly&quot;&gt;SQLITE_SYNC_NORMAL&lt;/a&gt; . Если вторым параметром является &lt;a href=&quot;c3ref/c_sync_dataonly&quot;&gt;SQLITE_SYNC_FULL,&lt;/a&gt; тогда метод xSync должен убедиться, что данные также были сброшены через кеш дисковых контроллеров. Параметр &lt;a href=&quot;c3ref/c_sync_dataonly&quot;&gt;SQLITE_SYNC_FULL&lt;/a&gt; является эквивалентом F_FULLSYNC ioctl () в Mac OS X. Метод xSync возвращает &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; в случае успеха и &lt;a href=&quot;rescode#ioerr_fsync&quot;&gt;SQLITE_IOERR_FSYNC,&lt;/a&gt; если что-то пойдет не так.</target>
        </trans-unit>
        <trans-unit id="d363e92ec2dbc091f6f79c8b02f677c3bfbb4dc4" translate="yes" xml:space="preserve">
          <source>The xSync method of the file-handle opened on the journal file is called. This operation ensures that all</source>
          <target state="translated">Вызывается метод xSync файл-ручка,открытая на файле журнала.Эта операция гарантирует,что все</target>
        </trans-unit>
        <trans-unit id="2abc7e1d2661195eacab3734a083049181c96938" translate="yes" xml:space="preserve">
          <source>The xTruncate method truncates a file to be nByte bytes in length. If the file is already nByte bytes or less in length then this method is a no-op. The xTruncate method returns &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; on success and &lt;a href=&quot;rescode#ioerr_truncate&quot;&gt;SQLITE_IOERR_TRUNCATE&lt;/a&gt; if anything goes wrong.</source>
          <target state="translated">Метод xTruncate обрезает файл до размера nByte байтов. Если размер файла уже равен nByte или меньше байтов, то этот метод не работает. Метод xTruncate возвращает &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; в случае успеха и &lt;a href=&quot;rescode#ioerr_truncate&quot;&gt;SQLITE_IOERR_TRUNCATE,&lt;/a&gt; если что-то пойдет не так.</target>
        </trans-unit>
        <trans-unit id="264cd9fc05e84b4a4186bdf81ed3b9dddd14f364" translate="yes" xml:space="preserve">
          <source>The xUpdate method is optional. If the xUpdate pointer in the &lt;a href=&quot;c3ref/module&quot;&gt;sqlite3_module&lt;/a&gt; for a virtual table is a NULL pointer, then the virtual table is read-only.</source>
          <target state="translated">Метод xUpdate не является обязательным. Если указатель xUpdate в модуле &lt;a href=&quot;c3ref/module&quot;&gt;sqlite3_module&lt;/a&gt; для виртуальной таблицы является указателем NULL, тогда виртуальная таблица доступна только для чтения.</target>
        </trans-unit>
        <trans-unit id="e7991b9300a6d5d1e9dd517f980e91bd729b810d" translate="yes" xml:space="preserve">
          <source>The xUpdate method must return &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; if and only if it is successful. If a failure occurs, the xUpdate must return an appropriate &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt;. On a failure, the pVTab-&amp;gt;zErrMsg element may optionally be replaced with error message text stored in memory allocated from SQLite using functions such as &lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_mprintf()&lt;/a&gt; or &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc()&lt;/a&gt;.</source>
          <target state="translated">Метод xUpdate должен возвращать &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; тогда и только тогда, когда он успешен. В случае сбоя xUpdate должен вернуть соответствующий &lt;a href=&quot;rescode&quot;&gt;код ошибки&lt;/a&gt; . В случае сбоя элемент pVTab-&amp;gt; zErrMsg можно дополнительно заменить текстом сообщения об ошибке, хранящимся в памяти, выделенной из SQLite, с использованием таких функций, как &lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_mprintf ()&lt;/a&gt; или &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4f4c20f5295bf2671dba3e7fbec564fd71238ee3" translate="yes" xml:space="preserve">
          <source>The xUpdate method will do a DELETE or an INSERT or both. The argv[0] element (which corresponds to memory cell P3) is the rowid of a row to delete. If argv[0] is NULL then no deletion occurs. The argv[1] element is the rowid of the new row. This can be NULL to have the virtual table select the new rowid for itself. The subsequent elements in the array are the values of columns in the new row.</source>
          <target state="translated">Метод xUpdate сделает УДАЛЕНИЕ или ИНСЕРТ,или и то,и другое.Элемент argv[0](который соответствует ячейке памяти P3)является rowid строки для удаления.Если argv[0]равен NULL,то удаление не происходит.Элемент argv[1]является штрихкодом новой строки.Это может быть NULL,чтобы виртуальная таблица сама выбирала новый rowid.Последующие элементы в массиве являются значениями столбцов в новой строке.</target>
        </trans-unit>
        <trans-unit id="dce6593181b88387e0232c4fe3315ea114b78c31" translate="yes" xml:space="preserve">
          <source>The xWrite method writes iAmt bytes of data from the second parameter into the file beginning at an offset of iOfst bytes. If the size of the file is less than iOfst bytes prior to the write, then xWrite should ensure that the file is extended with zeros up to iOfst bytes prior to beginning its write. xWrite continues to extends the file as necessary so that the size of the file is at least iAmt+iOfst bytes at the conclusion of the xWrite call. The xWrite method returns &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; on success. If the write cannot complete because the underlying storage medium is full, then &lt;a href=&quot;rescode#full&quot;&gt;SQLITE_FULL&lt;/a&gt; is returned. &lt;a href=&quot;rescode#ioerr_write&quot;&gt;SQLITE_IOERR_WRITE&lt;/a&gt; should be returned for any other error.</source>
          <target state="translated">Метод xWrite записывает байты iAmt данных из второго параметра в файл, начиная со смещения iOfst байтов. Если размер файла меньше iOfst байтов до записи, то xWrite должен гарантировать, что файл расширен нулями до iOfst байтов до начала записи. xWrite продолжает расширять файл по мере необходимости, так что размер файла составляет не менее iAmt + iOfst байт в конце вызова xWrite. В случае успеха метод xWrite возвращает &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; . Если запись не может быть завершена из-за того, что нижележащий носитель данных заполнен, возвращается &lt;a href=&quot;rescode#full&quot;&gt;SQLITE_FULL&lt;/a&gt; . &lt;a href=&quot;rescode#ioerr_write&quot;&gt;SQLITE_IOERR_WRITE&lt;/a&gt; должен быть возвращен для любой другой ошибки.</target>
        </trans-unit>
        <trans-unit id="d58a45ae0f446bdb86db23efea40a4365e8b2411" translate="yes" xml:space="preserve">
          <source>The zFormat string must not be NULL.</source>
          <target state="translated">Строка zFormat не должна быть NULL.</target>
        </trans-unit>
        <trans-unit id="4f80fc797d2d3e861743d9ee1212caa09c71f3bc" translate="yes" xml:space="preserve">
          <source>The zName field holds the name of the VFS module. The name must be unique across all VFS modules.</source>
          <target state="translated">В поле zName содержится имя модуля VFS.Имя должно быть уникальным для всех модулей VFS.</target>
        </trans-unit>
        <trans-unit id="2e8507d62c194c1ae3ea2e8955ca09d80822bd5b" translate="yes" xml:space="preserve">
          <source>The zName field is the symbolic name of the VFS. This is the name that the &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_find()&lt;/a&gt; compares against when it is looking for a VFS.</source>
          <target state="translated">Поле zName - это символическое имя VFS. Это имя, с которым &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_find ()&lt;/a&gt; сравнивает, когда ищет VFS.</target>
        </trans-unit>
        <trans-unit id="159171a13f5482b6256b050c73e581c3c1ed7fde" translate="yes" xml:space="preserve">
          <source>The zeroblob(N) function returns a BLOB consisting of N bytes of 0x00. SQLite manages these zeroblobs very efficiently. Zeroblobs can be used to reserve space for a BLOB that is later written using &lt;a href=&quot;c3ref/blob_open&quot;&gt;incremental BLOB I/O&lt;/a&gt;. This SQL function is implemented using the &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_zeroblob()&lt;/a&gt; routine from the C/C++ interface.</source>
          <target state="translated">Функция zeroblob (N) возвращает большой двоичный объект, состоящий из N байтов размером 0x00. SQLite очень эффективно управляет этими нулевыми шарами. Нулевые двоичные объекты можно использовать для резервирования места для больших двоичных объектов, которые позже записываются с использованием &lt;a href=&quot;c3ref/blob_open&quot;&gt;инкрементного ввода-вывода&lt;/a&gt; больших двоичных объектов . Эта функция SQL реализована с помощью процедуры &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_zeroblob ()&lt;/a&gt; из интерфейса C / C ++.</target>
        </trans-unit>
        <trans-unit id="211680c2a7f3cd39edd65730ba2dc5798231d4d2" translate="yes" xml:space="preserve">
          <source>The zipfile module provides read/write access to simple &lt;a href=&quot;https://en.wikipedia.org/wiki/Zip_%28file_format%29&quot;&gt;ZIP archives&lt;/a&gt;. The current implementation has the following restrictions:</source>
          <target state="translated">Модуль zipfile обеспечивает доступ для чтения / записи к простым &lt;a href=&quot;https://en.wikipedia.org/wiki/Zip_%28file_format%29&quot;&gt;архивам ZIP&lt;/a&gt; . Текущая реализация имеет следующие ограничения:</target>
        </trans-unit>
        <trans-unit id="1b7b70776cb9a79f5d42a047fb481e44592ef0cc" translate="yes" xml:space="preserve">
          <source>The zipfile module provides three similar interfaces for accessing, updating and creating zip file archives:</source>
          <target state="translated">Модуль zip-файлов предоставляет три похожих интерфейса для доступа,обновления и создания zip-архивов:</target>
        </trans-unit>
        <trans-unit id="a3bf102cd7b1098b918321543923b0fbcf9afd25" translate="yes" xml:space="preserve">
          <source>The zipfile module provides two similar interfaces for accessing zip archives. A table-valued function, which provides read-only access to existing archives, and a virtual table interface, which provides both read and write access.</source>
          <target state="translated">Модуль zip-архивов предоставляет два одинаковых интерфейса для доступа к zip-архивам.Функция табличной оценки,обеспечивающая доступ только на чтение к существующим архивам,и виртуальный табличный интерфейс,обеспечивающий доступ как на чтение,так и на запись.</target>
        </trans-unit>
        <trans-unit id="7f26831f509249abeae6c04bd252c7253425a19e" translate="yes" xml:space="preserve">
          <source>The zipfile() aggregate function may be called with 2, 4 or 5 arguments. If it is called with 5 arguments, then the entry added to the archive is equivalent to inserting the same values into the &quot;name&quot;, &quot;mode&quot;, &quot;mtime&quot;, &quot;data&quot; and &quot;method&quot; columns of a zipfile virtual table.</source>
          <target state="translated">Функция агрегата zipfile()может быть вызвана с 2,4 или 5 аргументами.Если она вызывается с 5 аргументами,то добавляемая в архив запись эквивалентна вставке тех же значений в столбцы &quot;имя&quot;,&quot;режим&quot;,&quot;mtime&quot;,&quot;данные&quot; и &quot;метод&quot; виртуальной zip-таблицы.</target>
        </trans-unit>
        <trans-unit id="fda3c54068d6592ac94595a28e9ae2b5a7631d94" translate="yes" xml:space="preserve">
          <source>Then any query that uses operators =, &amp;lt;, &amp;gt;, &amp;lt;=, &amp;gt;=, &amp;lt;&amp;gt;, IN, LIKE, or GLOB on column &quot;c&quot; would be usable with the partial index because those comparison operators are only true if &quot;c&quot; is not NULL. So the following query could use the partial index:</source>
          <target state="translated">Тогда любой запрос, в котором используются операторы =, &amp;lt;,&amp;gt;, &amp;lt;=,&amp;gt; =, &amp;lt;&amp;gt;, IN, LIKE или GLOB в столбце &amp;laquo;c&amp;raquo;, можно будет использовать с частичным индексом, поскольку эти операторы сравнения верны только в том случае, если &amp;laquo;c&amp;raquo; не NULL. Таким образом, следующий запрос может использовать частичный индекс:</target>
        </trans-unit>
        <trans-unit id="d38e46789e87cb85236cff516beec8a98a69642c" translate="yes" xml:space="preserve">
          <source>Then continue to merge the changes in &quot;trunk&quot; with your &quot;private&quot; changes as described in section 3.7.</source>
          <target state="translated">Затем продолжайте объединять изменения в &quot;багажнике&quot; со своими &quot;личными&quot; изменениями,как описано в разделе 3.7.</target>
        </trans-unit>
        <trans-unit id="4221ef1a5952683847cd93186bb995482d485923" translate="yes" xml:space="preserve">
          <source>Then creating &lt;a href=&quot;lang_createview&quot;&gt;VIEWs&lt;/a&gt; in that schema that implement the official information schema tables using table-valued PRAGMA functions.</source>
          <target state="translated">Затем создание &lt;a href=&quot;lang_createview&quot;&gt;представлений&lt;/a&gt; в этой схеме, которые реализуют таблицы схемы официальной информации с использованием возвращающих табличное значение функций PRAGMA.</target>
        </trans-unit>
        <trans-unit id="24143dcd35d1fb5f0ef327aba489cfb57e18e5f5" translate="yes" xml:space="preserve">
          <source>Then download the new version of the SQLite sources and overwrite the files that are in the checkout.</source>
          <target state="translated">Затем загрузите новую версию исходников SQLite и перезапишите файлы,которые находятся на кассе.</target>
        </trans-unit>
        <trans-unit id="350d0a66ff74448747b37fd69238737bb7294306" translate="yes" xml:space="preserve">
          <source>Then either of the two queries below may be executed to find the number of documents in the database that contain the word &quot;linux&quot; (351). Using one desktop PC hardware configuration, the query on the FTS3 table returns in approximately 0.03 seconds, versus 22.5 for querying the ordinary table.</source>
          <target state="translated">Затем можно выполнить любой из двух нижеперечисленных запросов,чтобы найти в базе данных количество документов,содержащих слово &quot;linux&quot; (351).При использовании конфигурации аппаратного обеспечения одного настольного ПК запрос к таблице FTS3 возвращается примерно за 0.03 секунды по сравнению с 22.5 для запроса к обычной таблице.</target>
        </trans-unit>
        <trans-unit id="dec93deaca5432fc2b3655d16d3eb7b184d40788" translate="yes" xml:space="preserve">
          <source>Then for each &quot;id&quot; value returned, suppose the application creates an UPDATE statement like the following and binds the &quot;id&quot; value returned against the &quot;?1&quot; parameter:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b72f2d807bd1572c917e30647dff75353e7ffc89" translate="yes" xml:space="preserve">
          <source>Then let the application maintain a separate pool of larger lookaside memory buffers that it can distribute to &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt; as they are created. In the common case, the application will only have a single &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; and so the lookaside memory pool can consist of a single large buffer.</source>
          <target state="translated">Затем позвольте приложению поддерживать отдельный пул более крупных буферов внешней памяти, которые оно может распределять по &lt;a href=&quot;c3ref/sqlite3&quot;&gt;соединениям&lt;/a&gt; с базой данных по мере их создания. В общем случае приложение будет иметь только одно &lt;a href=&quot;c3ref/sqlite3&quot;&gt;соединение с базой данных,&lt;/a&gt; поэтому резервный пул памяти может состоять из одного большого буфера.</target>
        </trans-unit>
        <trans-unit id="e376e98c10da73b25d2ab9a479ff86c1a4e0ab3c" translate="yes" xml:space="preserve">
          <source>Then no rows are returned. SQLite knows that the t1.b column actually holds a 7-character string, and the 7-character string 'abc'||char(0)||'xyz' is not equal to the 3-character string 'abc', and so no rows are returned. But a user might be easily confused by this because the &lt;a href=&quot;cli&quot;&gt;CLI&lt;/a&gt; output seems to show that the string has only 3 characters. This seems like a bug. But it is how SQLite works.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13bc76c23a2d1597cb4fa248a96e4ed2a6339b15" translate="yes" xml:space="preserve">
          <source>Then one of the constraints would be on the &quot;a&quot; column with operator &quot;=&quot; and an expression of &quot;5&quot;. Constraints need not have a literal representation of the WHERE clause. The query optimizer might make transformations to the WHERE clause in order to extract as many constraints as it can. So, for example, if the WHERE clause contained something like this:</source>
          <target state="translated">Тогда одно из ограничений будет на столбце &quot;a&quot; с оператором &quot;=&quot; и выражением &quot;5&quot;.Ограничения не обязательно должны иметь буквальное представление пункта WHERE.Оптимизатор запроса может выполнить преобразования к выражению WHERE,чтобы извлечь как можно больше ограничений.Так,например,если выражение WHERE содержало нечто подобное:</target>
        </trans-unit>
        <trans-unit id="a6d85a4cee37097aa0048aa17c7e903390d7845d" translate="yes" xml:space="preserve">
          <source>Then run &quot;sh speed-check.sh trunk&quot;.</source>
          <target state="translated">Затем запустите &quot;sh speed-check.sh trunk&quot;.</target>
        </trans-unit>
        <trans-unit id="5af7ca0994a03bba6845a3d09f85ba03527c6bbf" translate="yes" xml:space="preserve">
          <source>Then that term is rewritten as follows:</source>
          <target state="translated">Затем этот термин переписывается следующим образом:</target>
        </trans-unit>
        <trans-unit id="89cb6c0dfe329a7ee49493775fd34d7651a1097e" translate="yes" xml:space="preserve">
          <source>Then the LIKE operator pays attention to case and the example above would evaluate to false. Note that case insensitivity only applies to latin1 characters - basically the upper and lower case letters of English in the lower 127 byte codes of ASCII. International character sets are case sensitive in SQLite unless an application-defined &lt;a href=&quot;datatype3#collation&quot;&gt;collating sequence&lt;/a&gt; and &lt;a href=&quot;lang_corefunc#like&quot;&gt;like() SQL function&lt;/a&gt; are provided that take non-ASCII characters into account. But if an application-defined collating sequence and/or like() SQL function are provided, the LIKE optimization described here will never be taken.</source>
          <target state="translated">Затем оператор LIKE обращает внимание на регистр, и приведенный выше пример оценивается как false. Обратите внимание, что нечувствительность к регистру применяется только к символам latin1 - в основном к верхним и нижним буквам английского языка в нижних 127-байтовых кодах ASCII. Международные наборы символов чувствительны к регистру в SQLite, если не предусмотрена определяемая приложением &lt;a href=&quot;datatype3#collation&quot;&gt;последовательность сортировки&lt;/a&gt; и &lt;a href=&quot;lang_corefunc#like&quot;&gt;функция SQL like ()&lt;/a&gt; , которая учитывает символы, отличные от ASCII. Но если предоставляется определяемая приложением последовательность сортировки и / или функция SQL like (), описанная здесь оптимизация LIKE никогда не будет выполняться.</target>
        </trans-unit>
        <trans-unit id="783cca209591ee05ee977f8ea807705747f13238" translate="yes" xml:space="preserve">
          <source>Then the LIKE operator pays attention to case and the example above would evaluate to false. Note that case insensitivity only applies to latin1 characters - basically the upper and lower case letters of English in the lower 127 byte codes of ASCII. International character sets are case sensitive in SQLite unless an application-defined &lt;a href=&quot;datatype3#collation&quot;&gt;collating sequence&lt;/a&gt; and &lt;a href=&quot;lang_corefunc#like&quot;&gt;like() SQL function&lt;/a&gt; are provided that take non-ASCII characters into account. If an application-defined collating sequence and/or like() SQL function are provided, the LIKE optimization described here will never be taken.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be60a7454a5a8c066c86b3ca9b68995e4f6f1ddf" translate="yes" xml:space="preserve">
          <source>Then the RBU database should contain:</source>
          <target state="translated">Тогда база данных RBU должна содержать:</target>
        </trans-unit>
        <trans-unit id="afb35789040d9830a99208d5f4ddcf476245eb59" translate="yes" xml:space="preserve">
          <source>Then the UPDATE might fail with an SQLITE_LOCKED error. The reason is that the initial query has not run to completion. It is remembering its place in the middle of a scan of the R-Tree. So an update to the R-Tree cannot be tolerated as this would disrupt the scan.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="996a8ef99f82edf5bb93411418cadd30d4e95347" translate="yes" xml:space="preserve">
          <source>Then the generated SQL will look like the following:</source>
          <target state="translated">Тогда сгенерированный SQL будет выглядеть следующим образом:</target>
        </trans-unit>
        <trans-unit id="0e329a491713b53943766e19e0cd3bc2370d4353" translate="yes" xml:space="preserve">
          <source>Then the index is usable by the query because the &quot;b=6&quot; term appears in both the index definition and in the query. Remember: terms in the index should be OR-connected and terms in the query should be AND-connected.</source>
          <target state="translated">Тогда индекс можно использовать по запросу,потому что термин &quot;b=6&quot; появляется и в определении индекса,и в запросе.Помните:термины в индексе должны быть ИЛИ связаны,а термины в запросе должны быть ИЛИ связаны.</target>
        </trans-unit>
        <trans-unit id="2efe4248a37f7b9e147bfa69326ac21ae4833059" translate="yes" xml:space="preserve">
          <source>Then the index might be used if the initial columns of the index (columns a, b, and so forth) appear in WHERE clause terms. The initial columns of the index must be used with the *=* or *IN* or *IS* operators. The right-most column that is used can employ inequalities. For the right-most column of an index that is used, there can be up to two inequalities that must sandwich the allowed values of the column between two extremes.</source>
          <target state="translated">Тогда индекс может быть использован,если начальные столбцы индекса (столбцы a,b и т.д.)появляются в условиях пункта ГДЕ.Начальные колонки индекса должны использоваться с операторами *=*или *IN*или *IS*.В самом правом столбце могут использоваться неравенства.Для самого правого столбца используемого индекса может быть до двух неравенств,которые должны смешивать допустимые значения столбца между двумя крайними точками.</target>
        </trans-unit>
        <trans-unit id="e6dd71db1e289fe23af7edb740c92dbe34d62cf9" translate="yes" xml:space="preserve">
          <source>Then the index might be used if the initial columns of the index (columns a, b, and so forth) appear in WHERE clause terms. The initial columns of the index must be used with the &lt;b&gt;=&lt;/b&gt; or &lt;b&gt;IN&lt;/b&gt; or &lt;b&gt;IS&lt;/b&gt; operators. The right-most column that is used can employ inequalities. For the right-most column of an index that is used, there can be up to two inequalities that must sandwich the allowed values of the column between two extremes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f563dfd5bcb7f2cd99d04f3adadee6fc2e0e90d8" translate="yes" xml:space="preserve">
          <source>Then the index will &lt;u&gt;not&lt;/u&gt; be used because the expression on the CREATE INDEX statement (x+y) is not the same as the expression as it appears in the query (y+x). The two expressions might be mathematically equivalent, but the SQLite query planner insists that they be the same, not merely equivalent. Consider rewriting the query thusly:</source>
          <target state="translated">Тогда индекс &lt;u&gt;не&lt;/u&gt; будет использоваться, потому что выражение в операторе CREATE INDEX (x + y) не совпадает с выражением, указанным в запросе (y + x). Эти два выражения могут быть математически эквивалентными, но планировщик запросов SQLite настаивает на том, чтобы они были одинаковыми, а не просто эквивалентными. Попробуйте переписать запрос следующим образом:</target>
        </trans-unit>
        <trans-unit id="faa0b455785c0547f03cc054aee1b96482863f25" translate="yes" xml:space="preserve">
          <source>Then the locking mode applies only to the named database. If no database name qualifier precedes the &quot;locking_mode&quot; keyword then the locking mode is applied to all databases, including any new databases added by subsequent &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; commands.</source>
          <target state="translated">Тогда режим блокировки применяется только к указанной базе данных. Если квалификатор имени базы данных не предшествует ключевому слову &amp;laquo;lock_mode&amp;raquo;, то режим блокировки применяется ко всем базам данных, включая любые новые базы данных, добавленные последующими командами &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2ace62cf521cfc04b47d7dad558287516162d423" translate="yes" xml:space="preserve">
          <source>Then the virtual table would be created with two hidden columns, and with datatypes of &quot;VARCHAR(12)&quot; and &quot;INTEGER&quot;.</source>
          <target state="translated">Затем будет создана виртуальная таблица с двумя скрытыми столбцами,а также с типами данных &quot;VARCHAR(12)&quot; и &quot;INTEGER&quot;.</target>
        </trans-unit>
        <trans-unit id="b398879a2efe1c2e2e8691470971432fd8ac7954" translate="yes" xml:space="preserve">
          <source>Then to read the first page of that database file, one merely runs:</source>
          <target state="translated">Затем,чтобы прочитать первую страницу этого файла базы данных,достаточно просто запустить его:</target>
        </trans-unit>
        <trans-unit id="9a0f2cc8cc7905afb88e588449e50b02e607b774" translate="yes" xml:space="preserve">
          <source>Then two &quot;virtual&quot; terms are added as follows:</source>
          <target state="translated">Затем добавляются два &quot;виртуальных&quot; термина следующим образом:</target>
        </trans-unit>
        <trans-unit id="ca7fe30da623ecbcc16dc68b6763c7b9a4af11d0" translate="yes" xml:space="preserve">
          <source>Then use the &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_XXXX()&lt;/a&gt; functions to bind your large string values to the SQL statement. The use of binding obviates the need to escape quote characters in the string, reducing the risk of SQL injection attacks. It also runs faster since the large string does not need to be parsed or copied as much.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d3ddffeb2cfef8ef81678864135303a52c1015f" translate="yes" xml:space="preserve">
          <source>Then use the &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_XXXX()&lt;/a&gt; functions to bind your large string values to the SQL statement. The use of binding obviates the need to escape quote characters in the string, reducing the risk of SQL injection attacks. It is also runs faster since the large string does not need to be parsed or copied as much.</source>
          <target state="translated">Затем используйте функции &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_XXXX (),&lt;/a&gt; чтобы привязать большие строковые значения к оператору SQL. Использование привязки устраняет необходимость экранирования кавычек в строке, снижая риск атак с использованием SQL-инъекций. Кроме того, он работает быстрее, поскольку большую строку не нужно так много анализировать или копировать.</target>
        </trans-unit>
        <trans-unit id="265606c9637ac4024a4237e1919b8d5a2a194605" translate="yes" xml:space="preserve">
          <source>Then, love your neighbor as yourself.</source>
          <target state="translated">Тогда люби ближнего,как самого себя.</target>
        </trans-unit>
        <trans-unit id="aaba5b69e34e258d19f535d62804a66ddc861cc0" translate="yes" xml:space="preserve">
          <source>Then, when the application attempts to open the database, register the system() function, then run an innocent query against the &quot;tab1&quot; table, it instead deletes all the files in its working directory. Yikes!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cfbc622cd136a62d323c5b8bab5c8bc5876d69e" translate="yes" xml:space="preserve">
          <source>There are &lt;a href=&quot;vtablist&quot;&gt;many other virtual table implementations&lt;/a&gt; in the SQLite source tree that can be used as examples. Locate these other virtual table implementations by searching for &quot;sqlite3_create_module&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf0cc9442c93b87173641af3ce48fe6ba6a56819" translate="yes" xml:space="preserve">
          <source>There are U or more such b-trees on a single level (see the documentation for the &lt;a href=&quot;fts5#the_automerge_configuration_option&quot;&gt;FTS5 automerge option&lt;/a&gt; for an explanation of b-tree levels), where U is the value assigned to the &lt;a href=&quot;fts5#the_usermerge_configuration_option&quot;&gt;FTS5 usermerge option&lt;/a&gt; option.</source>
          <target state="translated">На одном уровне существует U или более таких b-деревьев (см. Документацию по &lt;a href=&quot;fts5#the_automerge_configuration_option&quot;&gt;опции автоматического слияния FTS5&lt;/a&gt; для объяснения уровней b-дерева), где U - значение, присвоенное &lt;a href=&quot;fts5#the_usermerge_configuration_option&quot;&gt;опции&lt;/a&gt; опции FTS5 usermerge .</target>
        </trans-unit>
        <trans-unit id="fd10b08d9cff8fbc86ae03afd572ce0a4529a480" translate="yes" xml:space="preserve">
          <source>There are advantages and disadvantages to being serverless. The main advantage is that there is no separate server process to install, setup, configure, initialize, manage, and troubleshoot. This is one reason why SQLite is a &quot;&lt;a href=&quot;zeroconf&quot;&gt;zero-configuration&lt;/a&gt;&quot; database engine. Programs that use SQLite require no administrative support for setting up the database engine before they are run. Any program that is able to access the disk is able to use an SQLite database.</source>
          <target state="translated">У бессерверного режима есть свои преимущества и недостатки. Главное преимущество заключается в том, что нет отдельного серверного процесса для установки, настройки, настройки, инициализации, управления и устранения неполадок. Это одна из причин, почему SQLite является ядром базы данных с &lt;a href=&quot;zeroconf&quot;&gt;нулевой конфигурацией&lt;/a&gt; . Программы, использующие SQLite, не требуют административной поддержки для настройки ядра базы данных перед запуском. Любая программа, имеющая доступ к диску, может использовать базу данных SQLite.</target>
        </trans-unit>
        <trans-unit id="9e47d4a7ae3779b3ce3872907368c2ebe6ca93d1" translate="yes" xml:space="preserve">
          <source>There are advantages and disadvantages to being serverless. The main advantage is that there is no separate server process to install, setup, configure, initialize, manage, and troubleshoot. This is one reason why SQLite is a &quot;zero-configuration&quot; database engine. Programs that use SQLite require no administrative support for setting up the database engine before they are run. Any program that is able to access the disk is able to use an SQLite database.</source>
          <target state="translated">Есть преимущества и недостатки безсерверной работы.Основным преимуществом является отсутствие отдельного серверного процесса для установки,настройки,конфигурирования,инициализации,управления и поиска неисправностей.Это одна из причин,по которой SQLite является движком баз данных &quot;нулевой конфигурации&quot;.Программы,использующие SQLite,не требуют никакой административной поддержки для настройки движка баз данных перед их запуском.Любая программа,имеющая доступ к диску,может использовать базу данных SQLite.</target>
        </trans-unit>
        <trans-unit id="a00099ff32dd16c72c3ea081a513584d8f3c38e0" translate="yes" xml:space="preserve">
          <source>There are advantages and disadvantages to using WAL instead of a rollback journal. Advantages include:</source>
          <target state="translated">Существуют преимущества и недостатки использования WAL вместо журнала отката.Преимущества включают в себя:</target>
        </trans-unit>
        <trans-unit id="3093b427039bbfacae2cf7cc0c20cdff14795a5c" translate="yes" xml:space="preserve">
          <source>There are advantages and disadvantages to using memory-mapped I/O. Advantages include:</source>
          <target state="translated">Существуют преимущества и недостатки использования ввода/вывода с отображением на карте памяти.Преимущества включают в себя:</target>
        </trans-unit>
        <trans-unit id="79bd071128837bce919057f74da96b8e84ac063f" translate="yes" xml:space="preserve">
          <source>There are certain reasonable restrictions on expressions that appear in CREATE INDEX statements:</source>
          <target state="translated">Существуют определенные разумные ограничения на выражения,которые появляются в утверждениях CREATE INDEX:</target>
        </trans-unit>
        <trans-unit id="0440cacf20ea4b02e6a0db0e8999f07d0748bd04" translate="yes" xml:space="preserve">
          <source>There are compile-time options that will set upper bounds on the sizes of various structures in SQLite. The compile-time options normally set a hard upper bound that can be changed at run-time on individual &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt; using the &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit()&lt;/a&gt; interface.</source>
          <target state="translated">Существуют параметры времени компиляции, которые устанавливают верхние границы размеров различных структур в SQLite. Параметры времени компиляции обычно устанавливают жесткую верхнюю границу, которая может быть изменена во время выполнения для отдельных &lt;a href=&quot;c3ref/sqlite3&quot;&gt;подключений к базе данных&lt;/a&gt; с помощью интерфейса &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5db06d3cdfac9a23d2859adb4baf70db2e25be47" translate="yes" xml:space="preserve">
          <source>There are currently 170 opcodes defined by the virtual machine. All currently defined opcodes are described in the table below. This table was generated automatically by scanning the source code from the file &lt;a href=&quot;http://www.sqlite.org/src/artifact/da4030a71acf42be18001b9b7067d6d34ffb76610603ce6fafa52854b9e52936&quot;&gt;vdbe.c&lt;/a&gt;.</source>
          <target state="translated">В настоящее время виртуальная машина определяет 170 кодов операций. Все определенные в настоящее время коды операций описаны в таблице ниже. Эта таблица была сгенерирована автоматически путем сканирования исходного кода из файла &lt;a href=&quot;http://www.sqlite.org/src/artifact/da4030a71acf42be18001b9b7067d6d34ffb76610603ce6fafa52854b9e52936&quot;&gt;vdbe.c&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3d151e494351273cc5176bb466ee794220518dba" translate="yes" xml:space="preserve">
          <source>There are currently 175 opcodes defined by the virtual machine. All currently defined opcodes are described in the table below. This table was generated automatically by scanning the source code from the file &lt;a href=&quot;http://www.sqlite.org/src/artifact/e9f7f818f128c8600058c0eabb6b3975974c95153a104d340f419adabbc15b9f&quot;&gt;vdbe.c&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c8c754c74f74295c6d11fd1e2df954669be9710" translate="yes" xml:space="preserve">
          <source>There are currently 176 opcodes defined by the virtual machine. All currently defined opcodes are described in the table below. This table was generated automatically by scanning the source code from the file &lt;a href=&quot;https://www.sqlite.org/src/artifact/d24a43b6b1ed2dba893636a14f5e56001444ab3fd5465e3bca8ab01799840acd&quot;&gt;vdbe.c&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f94a164918f438c0d1173d53f7a4f94c08b35d7" translate="yes" xml:space="preserve">
          <source>There are currently the following configuration options:</source>
          <target state="translated">В настоящее время существуют следующие варианты конфигурации:</target>
        </trans-unit>
        <trans-unit id="3c95acf82c00de5d5751bda48036e2a0038274e3" translate="yes" xml:space="preserve">
          <source>There are details to fill in here. Perhaps a screen can be provided that displays a history changes (perhaps with a graph) allowing the user to select which version they want to view or edit. Perhaps some facility can be provided to merge forks that might occur in the version history. And perhaps the application should provide a means to purge old and unwanted versions. The key point is that using an SQLite database to store the content, rather than a ZIP archive, makes all of these features much, much easier to implement, which increases the possibility that they will eventually get implemented.</source>
          <target state="translated">Здесь есть подробности,которые нужно заполнить.Возможно,можно предусмотреть экран,на котором будет отображаться история изменений (возможно,с графиком),позволяющий пользователю выбрать,какую версию он хочет просмотреть или отредактировать.Возможно,будет предоставлена возможность объединить вилки,которые могут встречаться в истории версий.И,возможно,приложение должно предоставлять средства для очистки старых и нежелательных версий.Ключевым моментом является то,что использование базы данных SQLite для хранения контента,а не ZIP-архива,делает все эти возможности намного,намного проще в реализации,что увеличивает вероятность того,что они в конечном итоге будут реализованы.</target>
        </trans-unit>
        <trans-unit id="97fa5e0129d965dcc6b70eeae4ab75a90f4ae6ee" translate="yes" xml:space="preserve">
          <source>There are dozens and dozens of SQL function implementations scattered throughout the SQLite source code that can be used as example applications. The built-in SQL functions use the same interface as application-defined SQL functions, so built-in functions can be used as examples too. Search for &quot;sqlite3_context&quot; in the SQLite source code to find examples.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98cb1601f44f3fee5a33f8d40abfeb82b5e7251a" translate="yes" xml:space="preserve">
          <source>There are five separate read locks, numbers 0 through 4. Read locks may be either SHARED or EXCLUSIVE. Connections obtain a shared lock on one of the read locks bytes while they are within a transaction. Connections also obtain an exclusive lock on read locks, one at a time, for the brief moment while they are updating the values of the corresponding read-marks. Read locks 1 through 4 are held exclusively when running &lt;a href=&quot;walformat#recovery&quot;&gt;recovery&lt;/a&gt;.</source>
          <target state="translated">Существует пять отдельных блокировок чтения, номера от 0 до 4. Блокировки чтения могут быть ОБЩИМИ или ИСКЛЮЧИТЕЛЬНЫМИ. Соединения получают разделяемую блокировку на один из байтов блокировки чтения, пока они находятся в транзакции. Соединения также получают эксклюзивную блокировку блокировок чтения, по одной за раз, на короткий момент, пока они обновляют значения соответствующих меток чтения. Блокировки чтения с 1 по 4 удерживаются только при запуске &lt;a href=&quot;walformat#recovery&quot;&gt;восстановления&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c457ee41ba8d1b7387ba8e7edc9a0ac19be4f375" translate="yes" xml:space="preserve">
          <source>There are five ways to describe starting and ending frame boundaries:</source>
          <target state="translated">Существует пять способов описания границ начального и конечного кадров:</target>
        </trans-unit>
        <trans-unit id="c2ce0d23c5814413e2c1fb5364c7eef30a6e31f7" translate="yes" xml:space="preserve">
          <source>There are four independent test harnesses used for testing the core SQLite library. Each test harness is designed, maintained, and managed separately from the others.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="253fb3b554421e91657bed4f34f13690b219d88b" translate="yes" xml:space="preserve">
          <source>There are many SQL-based database management systems available, besides SQLite. Common options include MySQL, PostgreSQL, and SQL-Server. All these systems use the SQL langauge to communicate with the application, just like SQLite. But these other systems different from SQLite in important respects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4083c54b42aa73500fa86d4b0409e55690866a09" translate="yes" xml:space="preserve">
          <source>There are many advantages to using SQLite as an application file format, including:</source>
          <target state="translated">Использование SQLite в качестве формата файла приложения имеет много преимуществ,в том числе:</target>
        </trans-unit>
        <trans-unit id="7e1c62962db715e611550a655ba502415a8c24f6" translate="yes" xml:space="preserve">
          <source>There are many benefits to this approach, including improved performance, reduced cost and complexity, and improved reliability. See technical notes &lt;a href=&quot;aff_short&quot;&gt;&quot;aff_short.html&quot;&lt;/a&gt; and &lt;a href=&quot;appfileformat&quot;&gt;&quot;appfileformat.html&quot;&lt;/a&gt; and &lt;a href=&quot;fasterthanfs&quot;&gt;&quot;fasterthanfs.html&quot;&lt;/a&gt; for more information. This use case is closely related to the &lt;a href=&quot;#wireproto&quot;&gt;data transfer format&lt;/a&gt; and &lt;a href=&quot;#container&quot;&gt;data container&lt;/a&gt; use cases below.</source>
          <target state="translated">У этого подхода много преимуществ, включая повышенную производительность, снижение стоимости и сложности, а также повышенную надежность. См технических примечаний &lt;a href=&quot;aff_short&quot;&gt;&amp;laquo;aff_short.html&amp;raquo;&lt;/a&gt; и &lt;a href=&quot;appfileformat&quot;&gt;&amp;laquo;appfileformat.html&amp;raquo;&lt;/a&gt; и &lt;a href=&quot;fasterthanfs&quot;&gt;&amp;laquo;fasterthanfs.html&amp;raquo;&lt;/a&gt; для получения дополнительной информации. Этот вариант использования тесно связан с &lt;a href=&quot;#wireproto&quot;&gt;форматом передачи данных&lt;/a&gt; и &lt;a href=&quot;#container&quot;&gt;контейнер данных&lt;/a&gt; случаев использования ниже.</target>
        </trans-unit>
        <trans-unit id="a6dd1c1ec54122d1cd8a41e77d633d60c4de1054" translate="yes" xml:space="preserve">
          <source>There are many different extended result codes for I/O errors that identify the specific I/O operation that failed.</source>
          <target state="translated">Существует много различных расширенных кодов результатов для ошибок ввода/вывода,которые идентифицируют конкретную операцию ввода/вывода,которая не удалась.</target>
        </trans-unit>
        <trans-unit id="f265782324871b5641aee92d51fefe1edfb475af" translate="yes" xml:space="preserve">
          <source>There are many fraudulent USB sticks in circulation that report to have a high capacity (ex: 8GB) but are really only capable of storing a much smaller amount (ex: 1GB). Attempts to write on these devices will often result in unrelated files being overwritten. Any use of a fraudulent flash memory device can easily lead to database corruption, therefore. Internet searches such as &quot;fake capacity usb&quot; will turn up lots of disturbing information about this problem.</source>
          <target state="translated">В обращении есть много фальшивых USB-накопителей,которые,как сообщается,имеют большую емкость (например,8 Гб),но на самом деле способны хранить только гораздо меньшее количество (например,1 Гб).Попытки записи на таких устройствах часто приводят к перезаписи несвязанных файлов.Поэтому любое использование мошеннического устройства флэш-памяти может легко привести к повреждению базы данных.Поиски в Интернете,такие как &quot;фальшивые емкости USB&quot; найдут много тревожной информации об этой проблеме.</target>
        </trans-unit>
        <trans-unit id="a53dc58a565490cefd808a058bfaad47e191a084" translate="yes" xml:space="preserve">
          <source>There are many more features not listed above. SQLite may be small in size and have &quot;Lite&quot; in its name, but it is not lacking in capability.</source>
          <target state="translated">Есть много других функций,не перечисленных выше.SQLite может быть небольшого размера и иметь в названии &quot;Lite&quot;,но в его названии нет недостатка в возможностях.</target>
        </trans-unit>
        <trans-unit id="60f662540321a06d796e68831dc73409bf49f397" translate="yes" xml:space="preserve">
          <source>There are many other dot-commands available in the command-line shell. See the &quot;.help&quot; command for a complete list for any particular version and build of SQLite.</source>
          <target state="translated">В оболочке командной строки доступно множество других точечных команд.Полный список для любой конкретной версии и сборки SQLite см.в команде &quot;.help&quot;.</target>
        </trans-unit>
        <trans-unit id="53f739b37a172fddf027f7c8afb4029bf933f8fe" translate="yes" xml:space="preserve">
          <source>There are many other testing options, which can be seen by running the command:</source>
          <target state="translated">Существует множество других опций тестирования,которые можно увидеть,запустив команду:</target>
        </trans-unit>
        <trans-unit id="461c7676d827031f4cd64d05f3d67e68ce256daf" translate="yes" xml:space="preserve">
          <source>There are many ways to measure test coverage. The most popular metric is &quot;statement coverage&quot;. When you hear someone say that their program as &quot;XX% test coverage&quot; without further explanation, they usually mean statement coverage. Statement coverage measures what percentage of lines of code are executed at least once by the test suite.</source>
          <target state="translated">Существует множество способов измерить покрытие теста.Наиболее популярной метрикой является &quot;покрытие теста&quot;.Когда Вы слышите,как кто-то говорит,что его программа,как &quot;XX% тестовое покрытие&quot;,без дальнейших объяснений,как правило,означает покрытие утверждения.Покрытие операторов измеряет,какой процент строк кода хотя бы один раз выполняется тестовым набором.</target>
        </trans-unit>
        <trans-unit id="15784824361af8c293ec21cb8076051131fb442d" translate="yes" xml:space="preserve">
          <source>There are no arbitrary limits in TH3. One could generate a single test program that contained all test modules and all configuration files. However, such a test program might be too large to deploy on embedded platforms. (As of 2018-05-19, a full-up TH3 test is over 850,000 lines and 58MB of C code.) TH3 provides the ability to break the library of test modules up into smaller, more easily digested pieces.</source>
          <target state="translated">В ТН3 нет произвольных ограничений.Можно создать единую тестовую программу,содержащую все тестовые модули и все конфигурационные файлы.Однако такая тестовая программа может быть слишком большой для развертывания на встраиваемых платформах.(По состоянию на 2018-05-19 годы,полный тест TH3 составляет более 850 000 строк и 58MB кода на языке C).TH3 дает возможность разбить библиотеку тестовых модулей на более мелкие,легко усваиваемые части.</target>
        </trans-unit>
        <trans-unit id="67165e227e06a66e9e2a7c9a359bffd814ca48a8" translate="yes" xml:space="preserve">
          <source>There are no arbitrary limits on the number of indices that can be attached to a single table. The number of columns in an index is limited to the value set by &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;(&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitcolumn&quot;&gt;SQLITE_LIMIT_COLUMN&lt;/a&gt;,...).</source>
          <target state="translated">Не существует произвольных ограничений на количество индексов, которые могут быть прикреплены к одной таблице. Количество столбцов в индексе ограничено значением, установленным &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt; ( &lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitcolumn&quot;&gt;SQLITE_LIMIT_COLUMN&lt;/a&gt; , ...).</target>
        </trans-unit>
        <trans-unit id="75e5745eabbe1f0d9742be6d3047103706a06632" translate="yes" xml:space="preserve">
          <source>There are no arguments to this option. This option sets the &lt;a href=&quot;../threadsafe&quot;&gt;threading mode&lt;/a&gt; to Multi-thread. In other words, it disables mutexing on &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; and &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; objects. The application is responsible for serializing access to &lt;a href=&quot;sqlite3&quot;&gt;database connections&lt;/a&gt; and &lt;a href=&quot;stmt&quot;&gt;prepared statements&lt;/a&gt;. But other mutexes are enabled so that SQLite will be safe to use in a multi-threaded environment as long as no two threads attempt to use the same &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; at the same time. If SQLite is compiled with the &lt;a href=&quot;../compile#threadsafe&quot;&gt;SQLITE_THREADSAFE=0&lt;/a&gt; compile-time option then it is not possible to set the Multi-thread &lt;a href=&quot;../threadsafe&quot;&gt;threading mode&lt;/a&gt; and &lt;a href=&quot;config&quot;&gt;sqlite3_config()&lt;/a&gt; will return &lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt; if called with the SQLITE_CONFIG_MULTITHREAD configuration option.</source>
          <target state="translated">У этого варианта нет аргументов. Этот параметр устанавливает &lt;a href=&quot;../threadsafe&quot;&gt;режим&lt;/a&gt; многопоточности. Другими словами, он отключает мьютекс для &lt;a href=&quot;sqlite3&quot;&gt;подключения к базе данных&lt;/a&gt; и &lt;a href=&quot;stmt&quot;&gt;подготовленных&lt;/a&gt; объектов операторов . Приложение отвечает за сериализацию доступа к &lt;a href=&quot;sqlite3&quot;&gt;соединениям&lt;/a&gt; с базой данных и &lt;a href=&quot;stmt&quot;&gt;подготовленным операторам&lt;/a&gt; . Но другие мьютексы включены, поэтому SQLite можно будет безопасно использовать в многопоточной среде, если ни один из двух потоков не пытается использовать одно и то же &lt;a href=&quot;sqlite3&quot;&gt;соединение с базой данных&lt;/a&gt; одновременно. Если SQLite скомпилирован с параметром &lt;a href=&quot;../compile#threadsafe&quot;&gt;времени&lt;/a&gt; компиляции SQLITE_THREADSAFE = 0, тогда невозможно установить &lt;a href=&quot;../threadsafe&quot;&gt;режим многопоточности&lt;/a&gt; и &lt;a href=&quot;config&quot;&gt;sqlite3_config ()&lt;/a&gt;вернет &lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt; при вызове с параметром конфигурации SQLITE_CONFIG_MULTITHREAD.</target>
        </trans-unit>
        <trans-unit id="438fea25e22862b67e0b2e195af310125649fa4d" translate="yes" xml:space="preserve">
          <source>There are no arguments to this option. This option sets the &lt;a href=&quot;../threadsafe&quot;&gt;threading mode&lt;/a&gt; to Serialized. In other words, this option enables all mutexes including the recursive mutexes on &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; and &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; objects. In this mode (which is the default when SQLite is compiled with &lt;a href=&quot;../compile#threadsafe&quot;&gt;SQLITE_THREADSAFE=1&lt;/a&gt;) the SQLite library will itself serialize access to &lt;a href=&quot;sqlite3&quot;&gt;database connections&lt;/a&gt; and &lt;a href=&quot;stmt&quot;&gt;prepared statements&lt;/a&gt; so that the application is free to use the same &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; or the same &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; in different threads at the same time. If SQLite is compiled with the &lt;a href=&quot;../compile#threadsafe&quot;&gt;SQLITE_THREADSAFE=0&lt;/a&gt; compile-time option then it is not possible to set the Serialized &lt;a href=&quot;../threadsafe&quot;&gt;threading mode&lt;/a&gt; and &lt;a href=&quot;config&quot;&gt;sqlite3_config()&lt;/a&gt; will return &lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt; if called with the SQLITE_CONFIG_SERIALIZED configuration option.</source>
          <target state="translated">У этого варианта нет аргументов. Эта опция устанавливает &lt;a href=&quot;../threadsafe&quot;&gt;режим потоковой передачи&lt;/a&gt; на Serialized. Другими словами, этот параметр включает все мьютексы, включая рекурсивные мьютексы при &lt;a href=&quot;sqlite3&quot;&gt;подключении к базе данных&lt;/a&gt; и &lt;a href=&quot;stmt&quot;&gt;подготовленные&lt;/a&gt; объекты операторов . В этом режиме (который используется по умолчанию, когда SQLite скомпилирован с &lt;a href=&quot;../compile#threadsafe&quot;&gt;SQLITE_THREADSAFE = 1&lt;/a&gt; ) библиотека SQLite сама сериализует доступ к &lt;a href=&quot;sqlite3&quot;&gt;соединениям&lt;/a&gt; с базой данных и &lt;a href=&quot;stmt&quot;&gt;подготовленным операторам,&lt;/a&gt; чтобы приложение могло свободно использовать одно и то же &lt;a href=&quot;sqlite3&quot;&gt;соединение с базой данных&lt;/a&gt; или один и тот же &lt;a href=&quot;stmt&quot;&gt;подготовленный оператор&lt;/a&gt; в разных потоках. в то же время. Если SQLite скомпилирован с &lt;a href=&quot;../compile#threadsafe&quot;&gt;SQLITE_THREADSAFE = 0&lt;/a&gt;параметр времени компиляции, то невозможно установить режим сериализованной &lt;a href=&quot;../threadsafe&quot;&gt;потоковой передачи,&lt;/a&gt; и &lt;a href=&quot;config&quot;&gt;sqlite3_config ()&lt;/a&gt; вернет &lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR,&lt;/a&gt; если вызывается с параметром конфигурации SQLITE_CONFIG_SERIALIZED.</target>
        </trans-unit>
        <trans-unit id="4b86fd3dbc8c8ae83073b70ec3ca59694912ef28" translate="yes" xml:space="preserve">
          <source>There are no arguments to this option. This option sets the &lt;a href=&quot;../threadsafe&quot;&gt;threading mode&lt;/a&gt; to Single-thread. In other words, it disables all mutexing and puts SQLite into a mode where it can only be used by a single thread. If SQLite is compiled with the &lt;a href=&quot;../compile#threadsafe&quot;&gt;SQLITE_THREADSAFE=0&lt;/a&gt; compile-time option then it is not possible to change the &lt;a href=&quot;../threadsafe&quot;&gt;threading mode&lt;/a&gt; from its default value of Single-thread and so &lt;a href=&quot;config&quot;&gt;sqlite3_config()&lt;/a&gt; will return &lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt; if called with the SQLITE_CONFIG_SINGLETHREAD configuration option.</source>
          <target state="translated">У этого варианта нет аргументов. Этот параметр устанавливает &lt;a href=&quot;../threadsafe&quot;&gt;однопоточный режим&lt;/a&gt; . Другими словами, он отключает все мьютексы и переводит SQLite в режим, в котором он может использоваться только одним потоком. Если SQLite скомпилирован с параметром &lt;a href=&quot;../compile#threadsafe&quot;&gt;времени&lt;/a&gt; компиляции SQLITE_THREADSAFE = 0, тогда невозможно изменить &lt;a href=&quot;../threadsafe&quot;&gt;режим потоковой передачи&lt;/a&gt; со значения по умолчанию Однопоточный, и поэтому &lt;a href=&quot;config&quot;&gt;sqlite3_config ()&lt;/a&gt; вернет &lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR,&lt;/a&gt; если вызывается с параметром конфигурации SQLITE_CONFIG_SINGLETHREAD.</target>
        </trans-unit>
        <trans-unit id="e6b294707b24261f0f532c64902934c051eedbd1" translate="yes" xml:space="preserve">
          <source>There are no arguments to this option. This option sets the &lt;a href=&quot;threadsafe&quot;&gt;threading mode&lt;/a&gt; to Multi-thread. In other words, it disables mutexing on &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; and &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; objects. The application is responsible for serializing access to &lt;a href=&quot;#sqlite3&quot;&gt;database connections&lt;/a&gt; and &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statements&lt;/a&gt;. But other mutexes are enabled so that SQLite will be safe to use in a multi-threaded environment as long as no two threads attempt to use the same &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; at the same time. If SQLite is compiled with the &lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE=0&lt;/a&gt; compile-time option then it is not possible to set the Multi-thread &lt;a href=&quot;threadsafe&quot;&gt;threading mode&lt;/a&gt; and &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config()&lt;/a&gt; will return &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt; if called with the SQLITE_CONFIG_MULTITHREAD configuration option.</source>
          <target state="translated">У этого варианта нет аргументов. Этот параметр устанавливает &lt;a href=&quot;threadsafe&quot;&gt;режим&lt;/a&gt; многопоточности. Другими словами, он отключает мьютекс для &lt;a href=&quot;#sqlite3&quot;&gt;подключения к базе данных&lt;/a&gt; и &lt;a href=&quot;#sqlite3_stmt&quot;&gt;подготовленных&lt;/a&gt; объектов операторов . Приложение отвечает за сериализацию доступа к &lt;a href=&quot;#sqlite3&quot;&gt;соединениям&lt;/a&gt; с базой данных и &lt;a href=&quot;#sqlite3_stmt&quot;&gt;подготовленным операторам&lt;/a&gt; . Но другие мьютексы включены, поэтому SQLite можно будет безопасно использовать в многопоточной среде, если ни один из двух потоков не пытается использовать одно и то же &lt;a href=&quot;#sqlite3&quot;&gt;соединение с базой данных&lt;/a&gt; одновременно. Если SQLite скомпилирован с параметром &lt;a href=&quot;compile#threadsafe&quot;&gt;времени&lt;/a&gt; компиляции SQLITE_THREADSAFE = 0, тогда невозможно установить &lt;a href=&quot;threadsafe&quot;&gt;режим многопоточности&lt;/a&gt; и &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config ()&lt;/a&gt;вернет &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt; при вызове с параметром конфигурации SQLITE_CONFIG_MULTITHREAD.</target>
        </trans-unit>
        <trans-unit id="955a610f066915f2766fca467b944718d1ee6aea" translate="yes" xml:space="preserve">
          <source>There are no arguments to this option. This option sets the &lt;a href=&quot;threadsafe&quot;&gt;threading mode&lt;/a&gt; to Serialized. In other words, this option enables all mutexes including the recursive mutexes on &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; and &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; objects. In this mode (which is the default when SQLite is compiled with &lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE=1&lt;/a&gt;) the SQLite library will itself serialize access to &lt;a href=&quot;#sqlite3&quot;&gt;database connections&lt;/a&gt; and &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statements&lt;/a&gt; so that the application is free to use the same &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; or the same &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; in different threads at the same time. If SQLite is compiled with the &lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE=0&lt;/a&gt; compile-time option then it is not possible to set the Serialized &lt;a href=&quot;threadsafe&quot;&gt;threading mode&lt;/a&gt; and &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config()&lt;/a&gt; will return &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt; if called with the SQLITE_CONFIG_SERIALIZED configuration option.</source>
          <target state="translated">У этого варианта нет аргументов. Эта опция устанавливает &lt;a href=&quot;threadsafe&quot;&gt;режим потоковой передачи&lt;/a&gt; на Serialized. Другими словами, этот параметр включает все мьютексы, включая рекурсивные мьютексы при &lt;a href=&quot;#sqlite3&quot;&gt;подключении к базе данных&lt;/a&gt; и &lt;a href=&quot;#sqlite3_stmt&quot;&gt;подготовленные&lt;/a&gt; объекты операторов . В этом режиме (который используется по умолчанию, когда SQLite скомпилирован с &lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE = 1&lt;/a&gt; ) библиотека SQLite сама сериализует доступ к &lt;a href=&quot;#sqlite3&quot;&gt;соединениям&lt;/a&gt; с базой данных и &lt;a href=&quot;#sqlite3_stmt&quot;&gt;подготовленным операторам,&lt;/a&gt; чтобы приложение могло свободно использовать одно и то же &lt;a href=&quot;#sqlite3&quot;&gt;соединение с базой данных&lt;/a&gt; или один и тот же &lt;a href=&quot;#sqlite3_stmt&quot;&gt;подготовленный оператор&lt;/a&gt; в разных потоках. в то же время. Если SQLite скомпилирован с &lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE = 0&lt;/a&gt;параметр времени компиляции, то невозможно установить режим сериализованной &lt;a href=&quot;threadsafe&quot;&gt;потоковой передачи,&lt;/a&gt; и &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config ()&lt;/a&gt; вернет &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR,&lt;/a&gt; если вызывается с параметром конфигурации SQLITE_CONFIG_SERIALIZED.</target>
        </trans-unit>
        <trans-unit id="1bc66a3a72545b16257e521a7b7467b7b7fb116b" translate="yes" xml:space="preserve">
          <source>There are no arguments to this option. This option sets the &lt;a href=&quot;threadsafe&quot;&gt;threading mode&lt;/a&gt; to Single-thread. In other words, it disables all mutexing and puts SQLite into a mode where it can only be used by a single thread. If SQLite is compiled with the &lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE=0&lt;/a&gt; compile-time option then it is not possible to change the &lt;a href=&quot;threadsafe&quot;&gt;threading mode&lt;/a&gt; from its default value of Single-thread and so &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config()&lt;/a&gt; will return &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt; if called with the SQLITE_CONFIG_SINGLETHREAD configuration option.</source>
          <target state="translated">У этого варианта нет аргументов. Этот параметр устанавливает &lt;a href=&quot;threadsafe&quot;&gt;однопоточный режим&lt;/a&gt; . Другими словами, он отключает все мьютексы и переводит SQLite в режим, в котором он может использоваться только одним потоком. Если SQLite скомпилирован с параметром &lt;a href=&quot;compile#threadsafe&quot;&gt;времени&lt;/a&gt; компиляции SQLITE_THREADSAFE = 0, тогда невозможно изменить &lt;a href=&quot;threadsafe&quot;&gt;режим потоковой передачи&lt;/a&gt; со значения по умолчанию Однопоточный, и поэтому &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config ()&lt;/a&gt; вернет &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR,&lt;/a&gt; если вызывается с параметром конфигурации SQLITE_CONFIG_SINGLETHREAD.</target>
        </trans-unit>
        <trans-unit id="33e0331165757b835edb3c42bfc1d34942851312" translate="yes" xml:space="preserve">
          <source>There are numerous test cases that verify that SQLite is able to deal with malformed database files. These tests first build a well-formed database file, then add corruption by changing one or more bytes in the file by some means other than SQLite. Then SQLite is used to read the database. In some cases, the bytes changes are in the middle of data. This causes the content of the database to change while keeping the database well-formed. In other cases, unused bytes of the file are modified, which has no effect on the integrity of the database. The interesting cases are when bytes of the file that define database structure get changed. The malformed database tests verify that SQLite finds the file format errors and reports them using the &lt;a href=&quot;rescode#corrupt&quot;&gt;SQLITE_CORRUPT&lt;/a&gt; return code without overflowing buffers, dereferencing NULL pointers, or performing other unwholesome actions.</source>
          <target state="translated">Существует множество тестовых примеров, которые подтверждают, что SQLite может работать с искаженными файлами базы данных. Эти тесты сначала создают правильно сформированный файл базы данных, а затем добавляют повреждение, изменяя один или несколько байтов в файле другими способами, кроме SQLite. Затем SQLite используется для чтения базы данных. В некоторых случаях изменения байтов происходят в середине данных. Это приводит к изменению содержимого базы данных при сохранении ее правильного формата. В других случаях изменяются неиспользуемые байты файла, что не влияет на целостность базы данных. Интересны случаи, когда изменяются байты файла, определяющие структуру базы данных. Тесты неверно сформированной базы данных подтверждают, что SQLite находит ошибки формата файла и сообщает о них с помощью &lt;a href=&quot;rescode#corrupt&quot;&gt;SQLITE_CORRUPT&lt;/a&gt; код возврата без переполнения буферов, разыменования указателей NULL или выполнения других нежелательных действий.</target>
        </trans-unit>
        <trans-unit id="f9afe2547739122b5f898fca4cf352f033d81b8f" translate="yes" xml:space="preserve">
          <source>There are only two reasonable ways to implement this query. (There are many other possible algorithms, but none of the others are contenders for being the &quot;best&quot; algorithm.)</source>
          <target state="translated">Есть только два разумных способа реализовать этот запрос.(Существует множество других возможных алгоритмов,но ни один из них не претендует на то,чтобы быть &quot;лучшим&quot; алгоритмом).</target>
        </trans-unit>
        <trans-unit id="35c4953b7b40ec225a59ad1651360c7dbd0086b0" translate="yes" xml:space="preserve">
          <source>There are other SQL database engines with liberal licenses that allow the code to be broadly and freely used. But those other engines are still governed by copyright law. SQLite is different in that copyright law simply does not apply.</source>
          <target state="translated">Существуют и другие движки баз данных SQL с либеральными лицензиями,которые позволяют широко и свободно использовать код.Но эти другие движки все равно регулируются авторским правом.SQLite отличается тем,что авторское право просто не применяется.</target>
        </trans-unit>
        <trans-unit id="00840e534b3409464615b9e5469c1789e0356b07" translate="yes" xml:space="preserve">
          <source>There are other VFS implementations both in the core SQLite source code library and in available extensions. The list above is not meant to be exhaustive but merely representative of the kinds of features that can be realized using the VFS interface.</source>
          <target state="translated">Существуют и другие реализации VFS,как в основной библиотеке исходных кодов SQLite,так и в доступных расширениях.Приведенный выше список не претендует на полноту,а лишь представляет те возможности,которые могут быть реализованы с помощью интерфейса VFS.</target>
        </trans-unit>
        <trans-unit id="fe657852dc4212647e79b2906ecbf326edcfcb96" translate="yes" xml:space="preserve">
          <source>There are several other ways to add an equivalent foreign key declaration to a &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; statement. Refer to the &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE documentation&lt;/a&gt; for details.</source>
          <target state="translated">Есть несколько других способов добавить эквивалентное объявление внешнего ключа к оператору &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; . Обратитесь к &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE документации&lt;/a&gt; для деталей.</target>
        </trans-unit>
        <trans-unit id="14687afe7afa4066d985b4f03845594063586e18" translate="yes" xml:space="preserve">
          <source>There are several ways of thinking about the RELEASE command:</source>
          <target state="translated">Существует несколько способов мышления о команде RELEASE:</target>
        </trans-unit>
        <trans-unit id="22c57ea3a56c1a621fcb33ba044a6de73ca1f510" translate="yes" xml:space="preserve">
          <source>There are several ways to approach this in FTS5:</source>
          <target state="translated">В FTS5 есть несколько способов к этому подойти:</target>
        </trans-unit>
        <trans-unit id="de40b756c06e57b21f4c7c518f428b201082172b" translate="yes" xml:space="preserve">
          <source>There are some contexts in SQLite that do not allow the use of non-deterministic functions:</source>
          <target state="translated">В SQLite есть некоторые контексты,которые не позволяют использовать недетерминированные функции:</target>
        </trans-unit>
        <trans-unit id="ffb257ce26a3636acdb1a9134b8ec418a490f506" translate="yes" xml:space="preserve">
          <source>There are some restrictions on the use of a VALUES clause that are not shown on the syntax diagrams:</source>
          <target state="translated">Существуют некоторые ограничения на использование выражения VALUES,которые не отображаются на синтаксических схемах:</target>
        </trans-unit>
        <trans-unit id="4fc9c795ba02424df295c5bd8e19a42a3240738c" translate="yes" xml:space="preserve">
          <source>There are three frame types: ROWS, GROUPS, and RANGE. The frame type determines how the starting and ending boundaries of the frame are measured.</source>
          <target state="translated">Есть три типа рам:ROWS,GROUPS и RANGE.Тип кадра определяет,как измеряются начальная и конечная границы кадра.</target>
        </trans-unit>
        <trans-unit id="b1e7d89744d05b6a27dde7db2836b2617aa1bbd6" translate="yes" xml:space="preserve">
          <source>There are three independent test harnesses used for testing the core SQLite library. Each test harness is designed, maintained, and managed separately from the others.</source>
          <target state="translated">Для тестирования основной библиотеки SQLite используются три независимые тестовые жгуты.Каждая тестовая жгутка проектируется,поддерживается и управляется отдельно от других.</target>
        </trans-unit>
        <trans-unit id="045c3584370eb289c548f60cb3b6ecaf401b3ed3" translate="yes" xml:space="preserve">
          <source>There are three levels to the shared-cache locking model, transaction level locking, table level locking and schema level locking. They are described in the following three sub-sections.</source>
          <target state="translated">Существует три уровня для модели блокировки общего кэша,блокировка на уровне транзакций,блокировка на уровне таблиц и блокировка на уровне схемы.Они описаны в следующих трех подразделах.</target>
        </trans-unit>
        <trans-unit id="e99c034a6b8af219b7e8f49f9f3d601cff4065a7" translate="yes" xml:space="preserve">
          <source>There are three math functions available:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe0a1eb5a2582532680ad7e413165b364188edac" translate="yes" xml:space="preserve">
          <source>There are three possible outcomes from this opcode:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1eaabb690f2c43b66d0713f1063a91097f30c63b" translate="yes" xml:space="preserve">
          <source>There are three possible outputs from the verify_checksum() function: 1, 0, and NULL. 1 is returned if the checksum is correct. 0 is returned if the checksum is incorrect. NULL is returned if the page is unreadable. If checksumming is enabled, the read will fail if the checksum is wrong, so the usual result from verify_checksum() on a bad checksum is NULL.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="944bcf56eaccf2f8d8f73507f47a4f5f610aa075" translate="yes" xml:space="preserve">
          <source>There are three reasons to set the locking-mode to EXCLUSIVE.</source>
          <target state="translated">Существует три причины для установки режима блокировки на EXCLUSIVE.</target>
        </trans-unit>
        <trans-unit id="e889a4b513747e6b54c292e814d5a011df18d8e5" translate="yes" xml:space="preserve">
          <source>There are three special-case entries in the cost table:</source>
          <target state="translated">В таблице расходов есть три специальные записи:</target>
        </trans-unit>
        <trans-unit id="3e8f3752e4f9aab9d7f5e605906342c5eeca4178" translate="yes" xml:space="preserve">
          <source>There are two advantages to using the SQLite printf functions instead of &lt;b&gt;sprintf&lt;/b&gt;. First of all, with the SQLite printf routines, there is never a danger of overflowing a static buffer as there is with &lt;b&gt;sprintf&lt;/b&gt;. The SQLite printf routines automatically allocate (and later frees) as much memory as is necessary to hold the SQL statements generated.</source>
          <target state="translated">У использования функций SQLite printf вместо &lt;b&gt;sprintf&lt;/b&gt; есть два преимущества . Прежде всего, с подпрограммами printf SQLite никогда не возникает опасности переполнения статического буфера, как в случае с &lt;b&gt;sprintf&lt;/b&gt; . Подпрограммы SQLite printf автоматически выделяют (а позже освобождают) столько памяти, сколько необходимо для хранения сгенерированных операторов SQL.</target>
        </trans-unit>
        <trans-unit id="391950a505dd77c6d9de2b0a8bf9dd26b935ed51" translate="yes" xml:space="preserve">
          <source>There are two aggregate SQL functions:</source>
          <target state="translated">Существует две совокупные функции SQL:</target>
        </trans-unit>
        <trans-unit id="631b7dfac93f3d53c23db92b1bef743005732dff" translate="yes" xml:space="preserve">
          <source>There are two cases to consider: (1) Table &quot;tab1&quot; does not previously exist and (2) table &quot;tab1&quot; does already exist.</source>
          <target state="translated">Есть два дела,которые нужно рассмотреть:(1)Таблицы &quot;tab1&quot; ранее не существовало и (2)таблица &quot;tab1&quot; уже существует.</target>
        </trans-unit>
        <trans-unit id="b8b8531dc422d3e33d42cc7bdad0abd37870f1fe" translate="yes" xml:space="preserve">
          <source>There are two column (M==2) and three rows (N==3). Thus the result table has 8 entries. Suppose the result table is stored in an array names azResult. Then azResult holds this content:</source>
          <target state="translated">Здесь две колонки (M==2)и три строки (N==3).Таким образом,таблица результатов имеет 8 записей.Предположим,таблица результата хранится в имени массива azResult.Затем azResult хранит это содержимое:</target>
        </trans-unit>
        <trans-unit id="e8adb25d367ffc51207827de29ffc66a0b34c609" translate="yes" xml:space="preserve">
          <source>There are two columns (M==2) and three rows (N==3). Thus the result table has 8 entries. Suppose the result table is stored in an array named azResult. Then azResult holds this content:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="928a963ad2407ff0d2d21e12347ddb23d756bb64" translate="yes" xml:space="preserve">
          <source>There are two differences in this variation. The initial-select is &quot;SELECT 1&quot; instead of &quot;VALUES(1)&quot;. But those are just different syntaxes for saying exactly the same thing. The other change is that the recursion is stopped by a LIMIT rather than a WHERE clause. The use of LIMIT means that when the one-millionth row is added to the &quot;cnt&quot; table (and returned by the main SELECT, thanks to the query optimizer) then the recursion stops immediately regardless of how many rows might be left in the queue. On more complex queries, it can sometimes be difficult to ensure that the WHERE clause will eventually cause the queue to drain and the recursion to terminate. But the LIMIT clause will always stop the recursion. So it is good practice to always include a LIMIT clause as a safety if an upper bound on the size of the recursion is known.</source>
          <target state="translated">В этом варианте есть два отличия.Первоначальный выбор-&quot;ВЫБОР 1&quot; вместо &quot;ЦЕНЫ(1)&quot;.Но это просто разные синтаксисы,чтобы сказать одно и то же.Другое изменение заключается в том,что рекурсия останавливается пунктом LIMIT,а не WHERE.Использование LIMIT означает,что когда миллионная строка добавляется в таблицу &quot;cnt&quot; (и возвращается основным SELECT,благодаря оптимизатору запросов),рекурсия останавливается немедленно,независимо от того,сколько строк может остаться в очереди.На более сложных запросах иногда бывает сложно гарантировать,что выражение WHERE в конце концов приведет к сливу очереди,а рекурсия завершится.Но выражение LIMIT всегда остановит рекурсию.Поэтому хорошая практика-всегда включать в качестве безопасности пункт LIMIT,если известна верхняя граница размера рекурсии.</target>
        </trans-unit>
        <trans-unit id="bb5962b52c02f4df27314354c0118e64e476f288" translate="yes" xml:space="preserve">
          <source>There are two separate configuration changes here which can be used either togethr or separately. The &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmultithread&quot;&gt;SQLITE_CONFIG_MULTITHREAD&lt;/a&gt; setting disables the mutexes that serialize access to &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; objects and &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; objects. With this setting, the application is free to use SQLite from multiple threads, but it must make sure than no two threads try to access the same &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; or any &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statements&lt;/a&gt; associated with the same &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; at the same time. Two threads can use SQLite at the same time, but they must use separate &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt;. The second &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmemstatus&quot;&gt;SQLITE_CONFIG_MEMSTATUS&lt;/a&gt; setting disables the mechanism in SQLite that tracks the total size of all outstanding memory allocation requests. This omits the need to mutex each call to &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc()&lt;/a&gt; and &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_free()&lt;/a&gt;, which saves a huge number of mutex operations. But a consequence of disabling the memory statistics mechanism is that the &lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_used()&lt;/a&gt;, &lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_highwater()&lt;/a&gt;, and &lt;a href=&quot;c3ref/hard_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64()&lt;/a&gt; interfaces cease to work.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10f943413bc9e88ca64edb6cc154e6b7583f6c77" translate="yes" xml:space="preserve">
          <source>There are two separate configuration changes here which can be used either togethr or separately. The &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmultithread&quot;&gt;SQLITE_CONFIG_MULTITHREAD&lt;/a&gt; setting disables the mutexes that serialize access to &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; objects and &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; objects. With this setting, the application is free to use SQLite from multiple threads, but it must make sure than no two threads try to access the same &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; or any &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statements&lt;/a&gt; associated with the same &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; at the same time. Two threads can use SQLite at the same time, but they must use separate &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt;. The second &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmemstatus&quot;&gt;SQLITE_CONFIG_MEMSTATUS&lt;/a&gt; setting disables the mechanism in SQLite that tracks the total size of all outstanding memory allocation requests. This omits the need to mutex each call to &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc()&lt;/a&gt; and &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_free()&lt;/a&gt;, which saves a huge number of mutex operations. But a consequence of disabling the memory statistics mechanism is that the &lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_used()&lt;/a&gt;, &lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_highwater()&lt;/a&gt;, and &lt;a href=&quot;c3ref/soft_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64()&lt;/a&gt; interfaces cease to work.</source>
          <target state="translated">Здесь есть два отдельных изменения конфигурации, которые можно использовать вместе или по отдельности. Параметр &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmultithread&quot;&gt;SQLITE_CONFIG_MULTITHREAD&lt;/a&gt; отключает мьютексы, которые сериализуют доступ к объектам &lt;a href=&quot;c3ref/sqlite3&quot;&gt;подключения&lt;/a&gt; к базе данных и &lt;a href=&quot;c3ref/stmt&quot;&gt;подготовленным&lt;/a&gt; объектам операторов . С этим параметром приложение может использовать SQLite из нескольких потоков, но оно должно быть уверено, что никакие два потока не попытаются получить доступ к одному и тому же &lt;a href=&quot;c3ref/sqlite3&quot;&gt;соединению с базой данных&lt;/a&gt; или любым &lt;a href=&quot;c3ref/stmt&quot;&gt;подготовленным операторам,&lt;/a&gt; связанным с одним и тем же &lt;a href=&quot;c3ref/sqlite3&quot;&gt;соединением&lt;/a&gt; с базой данных одновременно. Два потока могут использовать SQLite одновременно, но они должны использовать отдельные &lt;a href=&quot;c3ref/sqlite3&quot;&gt;соединения с базой данных&lt;/a&gt; . Второй &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmemstatus&quot;&gt;SQLITE_CONFIG_MEMSTATUS&lt;/a&gt;настройка отключает механизм в SQLite, который отслеживает общий размер всех невыполненных запросов на выделение памяти. Это избавляет от необходимости мьютексировать каждый вызов &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc ()&lt;/a&gt; и &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_free ()&lt;/a&gt; , что экономит огромное количество операций мьютекса. Но следствием отключения механизма статистики памяти является то, что интерфейсы &lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_used ()&lt;/a&gt; , &lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_highwater ()&lt;/a&gt; и &lt;a href=&quot;c3ref/soft_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64 ()&lt;/a&gt; перестают работать.</target>
        </trans-unit>
        <trans-unit id="03b9684a8e7902c26ab2183576e54dd70242a272" translate="yes" xml:space="preserve">
          <source>There are two types of simple SELECT statement - aggregate and non-aggregate queries. A simple SELECT statement is an aggregate query if it contains either a GROUP BY clause or one or more aggregate functions in the result-set. Otherwise, if a simple SELECT contains no aggregate functions or a GROUP BY clause, it is a non-aggregate query.</source>
          <target state="translated">Существует два типа простых SELECT-запросов-агрегированные и не агрегированные.Простой оператор SELECT-это агрегированный запрос,если он содержит либо пункт GROUP BY,либо одну или несколько агрегированных функций в результирующем множестве.Иначе,если простой SELECT не содержит агрегатных функций или пункта GROUP BY,это неагрегированный запрос.</target>
        </trans-unit>
        <trans-unit id="265655ffc7236582ade45c905963724f97d22dc0" translate="yes" xml:space="preserve">
          <source>There are two ways to use the &quot;content&quot; option:</source>
          <target state="translated">Существует два способа использования опции &quot;контент&quot;:</target>
        </trans-unit>
        <trans-unit id="6c855557ba4350c988043164f7d90199d18c9af0" translate="yes" xml:space="preserve">
          <source>There are typically between 10 to 40 entries in the sqlite_stat4 table for each index for which statistics are available, however these limits are not hard bounds. The meanings of the columns in the sqlite_stat4 table are as follows:</source>
          <target state="translated">Обычно в таблице sqlite_stat4 для каждого индекса,по которому доступна статистика,имеется от 10 до 40 записей,однако эти границы не являются жесткими.Значения столбцов в таблице sqlite_stat4 следующие:</target>
        </trans-unit>
        <trans-unit id="7cc2860dd2126e117e20cc785f2f36fc98950f36" translate="yes" xml:space="preserve">
          <source>There are usually multiple entries in the sqlite_stat3 table for each index. The sqlite_stat3.sample column holds the value of the left-most field of an index identified by sqlite_stat3.idx and sqlite_stat3.tbl. The sqlite_stat3.nEq column holds the approximate number of entries in the index whose left-most column exactly matches the sample. The sqlite_stat3.nLt holds the approximate number of entries in the index whose left-most column is less than the sample. The sqlite_stat3.nDLt column holds the approximate number of distinct left-most entries in the index that are less than the sample.</source>
          <target state="translated">Для каждого индекса в таблице sqlite_stat3 обычно имеется несколько записей.В столбце sqlite_stat3.sample хранится значение самого левого поля индекса,идентифицируемого sqlite_stat3.idx и sqlite_stat3.tbl.В столбце sqlite_stat3.nEq хранится примерное количество записей в индексе,крайний левый столбец которого точно совпадает с выборкой.В столбце sqlite_stat3.nLt хранится примерное количество записей в индексе,крайний левый столбец которого меньше,чем в выборке.В столбце sqlite_stat3.nDLt указано примерное количество отдельных крайних левых записей в индексе,которое меньше,чем в выборке.</target>
        </trans-unit>
        <trans-unit id="3bc8ca2faf5f82d403479bc810eea0e330c59fbe" translate="yes" xml:space="preserve">
          <source>There can be an arbitrary number of sqlite_stat3 entries per index. The &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; command will typically generate sqlite_stat3 tables that contain between 10 and 40 samples that are distributed across the key space and with large nEq values.</source>
          <target state="translated">В каждом индексе может быть произвольное количество записей sqlite_stat3. Команда &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; обычно создает таблицы sqlite_stat3, содержащие от 10 до 40 выборок, которые распределены по ключевому пространству и имеют большие значения nEq.</target>
        </trans-unit>
        <trans-unit id="76781503806bdc9ca573d5796b00968614643484" translate="yes" xml:space="preserve">
          <source>There can be an arbitrary number of sqlite_stat4 entries per index. The &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; command will typically generate sqlite_stat4 tables that contain between 10 and 40 samples that are distributed across the key space and with large nEq values.</source>
          <target state="translated">В каждом индексе может быть произвольное количество записей sqlite_stat4. Команда &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; обычно создает таблицы sqlite_stat4, содержащие от 10 до 40 выборок, распределенных по ключевому пространству и с большими значениями nEq.</target>
        </trans-unit>
        <trans-unit id="4935a4962bbd49a87bfec8ba26bcb0ee96e2bc65" translate="yes" xml:space="preserve">
          <source>There can only be a single busy handler defined for each &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt;. Setting a new busy handler clears any previously set handler. Note that calling &lt;a href=&quot;#sqlite3_busy_timeout&quot;&gt;sqlite3_busy_timeout()&lt;/a&gt; or evaluating &lt;a href=&quot;pragma#pragma_busy_timeout&quot;&gt;PRAGMA busy_timeout=N&lt;/a&gt; will change the busy handler and thus clear any previously set busy handler.</source>
          <target state="translated">Для каждого &lt;a href=&quot;#sqlite3&quot;&gt;подключения&lt;/a&gt; к базе данных может быть определен только один обработчик занятости . Установка нового обработчика занятости очищает любой ранее установленный обработчик. Обратите внимание, что вызов &lt;a href=&quot;#sqlite3_busy_timeout&quot;&gt;sqlite3_busy_timeout ()&lt;/a&gt; или оценка &lt;a href=&quot;pragma#pragma_busy_timeout&quot;&gt;PRAGMA busy_timeout = N&lt;/a&gt; изменит обработчик занятости и, таким образом, очистит любой ранее установленный обработчик занятости.</target>
        </trans-unit>
        <trans-unit id="595614b4fea7d83eeee9eca9b82c7f15a616950a" translate="yes" xml:space="preserve">
          <source>There can only be a single busy handler defined for each &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt;. Setting a new busy handler clears any previously set handler. Note that calling &lt;a href=&quot;busy_timeout&quot;&gt;sqlite3_busy_timeout()&lt;/a&gt; or evaluating &lt;a href=&quot;../pragma#pragma_busy_timeout&quot;&gt;PRAGMA busy_timeout=N&lt;/a&gt; will change the busy handler and thus clear any previously set busy handler.</source>
          <target state="translated">Для каждого &lt;a href=&quot;sqlite3&quot;&gt;подключения&lt;/a&gt; к базе данных может быть определен только один обработчик занятости . Установка нового обработчика занятости очищает любой ранее установленный обработчик. Обратите внимание, что вызов &lt;a href=&quot;busy_timeout&quot;&gt;sqlite3_busy_timeout ()&lt;/a&gt; или оценка &lt;a href=&quot;../pragma#pragma_busy_timeout&quot;&gt;PRAGMA busy_timeout = N&lt;/a&gt; изменит обработчик занятости и, таким образом, очистит любой ранее установленный обработчик занятости.</target>
        </trans-unit>
        <trans-unit id="4557f81c54cd198ad30dafda03e1a7688c37ee6a" translate="yes" xml:space="preserve">
          <source>There can only be a single busy handler for a particular &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; at any given moment. If another busy handler was defined (using &lt;a href=&quot;#sqlite3_busy_handler&quot;&gt;sqlite3_busy_handler()&lt;/a&gt;) prior to calling this routine, that other busy handler is cleared.</source>
          <target state="translated">Для конкретного &lt;a href=&quot;#sqlite3&quot;&gt;соединения с базой данных&lt;/a&gt; в любой момент может быть только один обработчик занятости . Если перед вызовом этой процедуры был определен другой обработчик занятости (с использованием &lt;a href=&quot;#sqlite3_busy_handler&quot;&gt;sqlite3_busy_handler ()&lt;/a&gt; ), этот другой обработчик занятости очищается.</target>
        </trans-unit>
        <trans-unit id="6c5612f166f3c19adb75f5b9420223d984d062bf" translate="yes" xml:space="preserve">
          <source>There can only be a single busy handler for a particular &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; at any given moment. If another busy handler was defined (using &lt;a href=&quot;busy_handler&quot;&gt;sqlite3_busy_handler()&lt;/a&gt;) prior to calling this routine, that other busy handler is cleared.</source>
          <target state="translated">Для конкретного &lt;a href=&quot;sqlite3&quot;&gt;соединения с базой данных&lt;/a&gt; в любой момент может быть только один обработчик занятости . Если перед вызовом этой процедуры был определен другой обработчик занятости (с использованием &lt;a href=&quot;busy_handler&quot;&gt;sqlite3_busy_handler ()&lt;/a&gt; ), этот другой обработчик занятости очищается.</target>
        </trans-unit>
        <trans-unit id="da947c700e89a2839d81ef99abfdba549201cf04" translate="yes" xml:space="preserve">
          <source>There can only be a single error logging callback per process. The error logging callback is registered at start-time using C-code similar to the following:</source>
          <target state="translated">На каждый процесс может быть только один обратный вызов журнала ошибок.Обратный вызов регистрации ошибок регистрируется при запуске с помощью C-кода,как показано ниже:</target>
        </trans-unit>
        <trans-unit id="297da7a4ca1508d9a0851c1993606776e3a61cd5" translate="yes" xml:space="preserve">
          <source>There can only be a single trace callback registered on a database connection. Each use of &quot;trace&quot; or &quot;trace_v2&quot; cancels all prior trace callback.</source>
          <target state="translated">При подключении к базе данных может быть зарегистрирован только один обратный вызов трассы.Каждое использование &quot;trace&quot; или &quot;trace_v2&quot; отменяет все предыдущие обратные вызовы трассы.</target>
        </trans-unit>
        <trans-unit id="13fe35de43729e33636f83c267efada945c04a07" translate="yes" xml:space="preserve">
          <source>There exists some subtle problem with mmap() on QNX such that making a second mmap() call against a single file descriptor can cause the memory obtained from the first mmap() call to be zeroed. SQLite on unix uses mmap() to create a shared memory region for transaction coordination in &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt;, and it will call mmap() multiple times for large transactions. The QNX mmap() has been demonstrated to corrupt database file under that scenario. QNX engineers are aware of this problem and are working on a solution; the problem may have already been fixed by the time you read this.</source>
          <target state="translated">Существует некоторая тонкая проблема с mmap () в QNX: второй вызов mmap () для одного файлового дескриптора может привести к обнулению памяти, полученной в результате первого вызова mmap (). SQLite в unix использует mmap () для создания области разделяемой памяти для координации транзакций в &lt;a href=&quot;wal&quot;&gt;режиме WAL&lt;/a&gt; , и он будет вызывать mmap () несколько раз для больших транзакций. Было продемонстрировано, что QNX mmap () повреждает файл базы данных в этом сценарии. Инженеры QNX знают об этой проблеме и работают над ее решением; к тому времени, когда вы это прочтете, проблема могла быть уже решена.</target>
        </trans-unit>
        <trans-unit id="d56d459074bf9b196b2551c494a4c7bec9d94df2" translate="yes" xml:space="preserve">
          <source>There has lately been a lot of interest in &quot;safe&quot; programming languages like Rust or Go in which it is impossible, or is at least difficult, to make common programming errors like memory leaks or array overruns. So the question often arises as to why SQLite is not coded in a &quot;safe&quot; language.</source>
          <target state="translated">В последнее время наблюдается большой интерес к &quot;безопасным&quot; языкам программирования,таким как Rust или Go,в которых невозможно или,по крайней мере,сложно допустить распространенные ошибки программирования,такие как утечка памяти или выход за границы массивов.Поэтому часто возникает вопрос,почему SQLite не кодируется на &quot;безопасном&quot; языке.</target>
        </trans-unit>
        <trans-unit id="52072b3d340cc958b2ff6cebc4a70e99aba7da9e" translate="yes" xml:space="preserve">
          <source>There have been three historical file formats for SQLite. SQLite 1.0 through 1.0.32 used the &lt;a href=&quot;https://www.gnu.org/software/gdbm/gdbm.html&quot;&gt;gdbm&lt;/a&gt; library as its storage engine. SQLite 2.0.0 through 2.8.17 used a custom b-tree storage engine that supported only text keys and data. All modern versions of SQLite (3.0.0 to present) use a b-tree storage engine that has full support for binary data and Unicode.</source>
          <target state="translated">Для SQLite существует три исторических формата файлов. В SQLite 1.0&amp;ndash;1.0.32 в качестве механизма хранения используется библиотека &lt;a href=&quot;https://www.gnu.org/software/gdbm/gdbm.html&quot;&gt;gdbm&lt;/a&gt; . SQLite 2.0.0&amp;ndash;2.8.17 использовал специальный механизм хранения b-tree, который поддерживал только текстовые ключи и данные. Все современные версии SQLite (от 3.0.0 до настоящего момента) используют механизм хранения b-tree, который полностью поддерживает двоичные данные и Unicode.</target>
        </trans-unit>
        <trans-unit id="3be8d2f16b71e4444f7f725739b5254eb08f103c" translate="yes" xml:space="preserve">
          <source>There is a function named &lt;a href=&quot;c3ref/last_insert_rowid&quot;&gt;sqlite3_last_insert_rowid()&lt;/a&gt; which will return the integer key for the most recent insert operation.</source>
          <target state="translated">Существует функция &lt;a href=&quot;c3ref/last_insert_rowid&quot;&gt;sqlite3_last_insert_rowid (),&lt;/a&gt; которая возвращает целочисленный ключ для последней операции вставки.</target>
        </trans-unit>
        <trans-unit id="2c4047eace270e4351576190943319e0de00174c" translate="yes" xml:space="preserve">
          <source>There is a limit, set using &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit()&lt;/a&gt; and &lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitattached&quot;&gt;SQLITE_LIMIT_ATTACHED&lt;/a&gt;, to the number of databases that can be simultaneously attached to a single database connection.</source>
          <target state="translated">Существует ограничение, устанавливаемое с помощью &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit ()&lt;/a&gt; и &lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitattached&quot;&gt;SQLITE_LIMIT_ATTACHED&lt;/a&gt; , на количество баз данных, которые могут быть одновременно подключены к одному соединению с базой данных.</target>
        </trans-unit>
        <trans-unit id="d03b97c401c9a348f14fea8d291ce117238dc810" translate="yes" xml:space="preserve">
          <source>There is a long list of conditions that must all be met in order for query flattening to occur. Some of the constraints are marked as obsolete by italic text. These extra constraints are retained in the documentation to preserve the numbering of the other constraints.</source>
          <target state="translated">Существует длинный список условий,которые должны быть выполнены для того,чтобы запрос сглаживался.Некоторые из ограничений помечены курсивом как устаревшие.Эти дополнительные ограничения сохраняются в документации для сохранения нумерации других ограничений.</target>
        </trans-unit>
        <trans-unit id="098b1868e66c13228c4371a548aa26b3bfac10d5" translate="yes" xml:space="preserve">
          <source>There is a new TypeOf() function used to determine if an expression is numeric or text.</source>
          <target state="translated">Появилась новая функция TypeOf(),используемая для определения,является ли выражение числовым или текстовым.</target>
        </trans-unit>
        <trans-unit id="e6da2fbcc052924976fcf688d82595c343604804" translate="yes" xml:space="preserve">
          <source>There is a single row in the sqlite_sequence table for each ordinary table that uses AUTOINCREMENT. The name of the table (as it appears in sqlite_master.name) is in the sqlite_sequence.main field and the largest &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; ever inserted into that table is in the sqlite_sequence.seq field. New automatically generated integer primary keys for AUTOINCREMENT tables are guaranteed to be larger than the sqlite_sequence.seq field for that table. If the sqlite_sequence.seq field of an AUTOINCREMENT table is already at the largest integer value (9223372036854775807) then attempts to add new rows to that table with an automatically generated integer primary will fail with an &lt;a href=&quot;rescode#full&quot;&gt;SQLITE_FULL&lt;/a&gt; error. The sqlite_sequence.seq field is automatically updated if required when new entries are inserted to an AUTOINCREMENT table. The sqlite_sequence row for an AUTOINCREMENT table is automatically deleted when the table is dropped. If the sqlite_sequence row for an AUTOINCREMENT table does not exist when the AUTOINCREMENT table is updated, then a new sqlite_sequence row is created. If the sqlite_sequence.seq value for an AUTOINCREMENT table is manually set to something other than an integer and there is a subsequent attempt to insert the or update the AUTOINCREMENT table, then the behavior is undefined.</source>
          <target state="translated">В таблице sqlite_sequence есть одна строка для каждой обычной таблицы, в которой используется AUTOINCREMENT. Имя таблицы (как оно отображается в sqlite_master.name) находится в поле sqlite_sequence.main, а самый большой &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY,&lt;/a&gt; когда-либо вставленный в эту таблицу, находится в поле sqlite_sequence.seq. Новые автоматически сгенерированные целочисленные первичные ключи для таблиц AUTOINCREMENT гарантированно будут больше, чем поле sqlite_sequence.seq для этой таблицы. Если поле sqlite_sequence.seq таблицы AUTOINCREMENT уже имеет наибольшее целочисленное значение (9223372036854775807), тогда попытки добавить новые строки в эту таблицу с автоматически сгенерированным целочисленным первичным числом завершатся ошибкой с &lt;a href=&quot;rescode#full&quot;&gt;SQLITE_FULL&lt;/a&gt;ошибка. Поле sqlite_sequence.seq автоматически обновляется при необходимости, когда новые записи вставляются в таблицу AUTOINCREMENT. Строка sqlite_sequence для таблицы AUTOINCREMENT автоматически удаляется при удалении таблицы. Если строка sqlite_sequence для таблицы AUTOINCREMENT не существует при обновлении таблицы AUTOINCREMENT, то создается новая строка sqlite_sequence. Если значение sqlite_sequence.seq для таблицы AUTOINCREMENT вручную установлено на значение, отличное от целого числа, и последующая попытка вставить или обновить таблицу AUTOINCREMENT, то поведение не определено.</target>
        </trans-unit>
        <trans-unit id="873101a14a572759e5a45b0dc79cf0cd42bbd9dd" translate="yes" xml:space="preserve">
          <source>There is a single row in the sqlite_sequence table for each ordinary table that uses AUTOINCREMENT. The name of the table (as it appears in sqlite_schema.name) is in the sqlite_sequence.main field and the largest &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; ever inserted into that table is in the sqlite_sequence.seq field. New automatically generated integer primary keys for AUTOINCREMENT tables are guaranteed to be larger than the sqlite_sequence.seq field for that table. If the sqlite_sequence.seq field of an AUTOINCREMENT table is already at the largest integer value (9223372036854775807) then attempts to add new rows to that table with an automatically generated integer primary will fail with an &lt;a href=&quot;rescode#full&quot;&gt;SQLITE_FULL&lt;/a&gt; error. The sqlite_sequence.seq field is automatically updated if required when new entries are inserted to an AUTOINCREMENT table. The sqlite_sequence row for an AUTOINCREMENT table is automatically deleted when the table is dropped. If the sqlite_sequence row for an AUTOINCREMENT table does not exist when the AUTOINCREMENT table is updated, then a new sqlite_sequence row is created. If the sqlite_sequence.seq value for an AUTOINCREMENT table is manually set to something other than an integer and there is a subsequent attempt to insert the or update the AUTOINCREMENT table, then the behavior is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f02c79b70988445eed051dee5ef879c5abc0fcef" translate="yes" xml:space="preserve">
          <source>There is a single row of the dbstat table for each page in the database file. Freelist pages, the lock page, and pointer-map pages of the database file do not appear in the dbstat virtual table.</source>
          <target state="translated">Для каждой страницы в файле базы данных есть одна строка таблицы dbstat.В виртуальной таблице dbstat не отображаются страницы фрилиста,страницы блокировки и страницы отображения указателя в файле базы данных.</target>
        </trans-unit>
        <trans-unit id="aad819f0714ba351410884e15d9171da8c02d268" translate="yes" xml:space="preserve">
          <source>There is also a &quot;.once -e&quot; command which works similarly, except that it names the temporary file with a &quot;.txt&quot; suffix so that the default text editor for the system will be invoked, instead of the default spreadsheet.</source>
          <target state="translated">Также существует команда &quot;.once -e&quot;,которая работает аналогичным образом,за исключением того,что она называет временный файл суффиксом &quot;.txt&quot; таким образом,что вместо стандартной электронной таблицы будет вызван текстовый редактор по умолчанию для системы.</target>
        </trans-unit>
        <trans-unit id="d689365d69d51f44124dabea5ed23d15cbc239dd" translate="yes" xml:space="preserve">
          <source>There is also a function for computing the Wagner edit distance or the Levenshtein distance between a pattern and a word. This function is exposed as spellfix1_editdist(X,Y). The edit distance function returns the &quot;cost&quot; of converting X into Y. Some transformations cost more than others. Changing one vowel into a different vowel, for example is relatively cheap, as is doubling a constant, or omitting the second character of a double-constant. Other transformations or more expensive. The idea is that the edit distance function returns a low cost for words that are similar and a higher cost for words that are further apart. In this implementation, the maximum cost of any single-character edit (delete, insert, or substitute) is 100, with lower costs for some edits (such as transforming vowels).</source>
          <target state="translated">Существует также функция для вычисления расстояния редактирования Вагнера или расстояния Левенштейна между деталью и словом.Эта функция выставляется как spellfix1_editdist(X,Y).Функция расстояния редактирования возвращает &quot;стоимость&quot; преобразования X в Y.Некоторые преобразования стоят дороже других.Изменение одной гласной на другую,например,относительно дешево,как и удвоение константы,или опускание второго символа двойной константы.Другие преобразования или стоят дороже.Идея заключается в том,что функция расстояния редактирования возвращает низкую стоимость для слов,которые похожи,и более высокую стоимость для слов,которые находятся на большем расстоянии друг от друга.В этой реализации максимальная стоимость любого односимвольного редактирования (удаление,вставка или замена)составляет 100,с более низкими затратами на некоторые редактирования (например,преобразование гласных).</target>
        </trans-unit>
        <trans-unit id="8f729e8ad1be217b3b85bb1dbd08e4580826f423" translate="yes" xml:space="preserve">
          <source>There is also a new &lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlpowersafeoverwrite&quot;&gt;SQLITE_FCNTL_POWERSAFE_OVERWRITE&lt;/a&gt; opcode for the &lt;a href=&quot;c3ref/file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; that allows an application to query the powersafe overwrite property for a database file.</source>
          <target state="translated">Также существует новый код операции &lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlpowersafeoverwrite&quot;&gt;SQLITE_FCNTL_POWERSAFE_OVERWRITE&lt;/a&gt; для &lt;a href=&quot;c3ref/file_control&quot;&gt;sqlite3_file_control (),&lt;/a&gt; который позволяет приложению запрашивать свойство перезаписи в режиме энергосбережения для файла базы данных.</target>
        </trans-unit>
        <trans-unit id="d5d98dc46e0aff9a749813616cdf742a9f8913ea" translate="yes" xml:space="preserve">
          <source>There is also an SQL function that can be used to load extensions: &lt;a href=&quot;lang_corefunc#load_extension&quot;&gt;load_extension(X,Y)&lt;/a&gt;. It works just like the &lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension()&lt;/a&gt; C interface.</source>
          <target state="translated">Также существует функция SQL, которую можно использовать для загрузки расширений: &lt;a href=&quot;lang_corefunc#load_extension&quot;&gt;load_extension (X, Y)&lt;/a&gt; . Он работает так же, как интерфейс C. &lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension ()&lt;/a&gt; C.</target>
        </trans-unit>
        <trans-unit id="043cd14b86c980f673cef92a152d79c2c6e3cf2c" translate="yes" xml:space="preserve">
          <source>There is always a default VFS. The legacy interfaces &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt; and &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open16()&lt;/a&gt; always use the default VFS. The new interface for creating database connections, &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;, allows you to specify which VFS you want to use by name.</source>
          <target state="translated">Всегда есть VFS по умолчанию. &lt;a href=&quot;c3ref/open&quot;&gt;Устаревшие&lt;/a&gt; интерфейсы sqlite3_open () и &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open16 ()&lt;/a&gt; всегда используют VFS по умолчанию. Новый интерфейс для создания подключений к базе данных &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2 ()&lt;/a&gt; позволяет вам указать, какую VFS вы хотите использовать по имени.</target>
        </trans-unit>
        <trans-unit id="a75d63f61cb222d77eadc6074711ab25e460df12" translate="yes" xml:space="preserve">
          <source>There is always one VFS which is the default VFS. On unix systems, the &quot;unix&quot; VFS comes up as the default and on windows it is &quot;win32&quot;. If no other actions are taken, new database connections will make use of the default VFS.</source>
          <target state="translated">Всегда есть одна VFS,которая является VFS по умолчанию.На unix-системах по умолчанию появляется &quot;unix&quot; VFS,а в окнах-&quot;win32&quot;.Если другие действия не предпринимаются,новые подключения к базе данных будут использовать VFS по умолчанию.</target>
        </trans-unit>
        <trans-unit id="a07e87b2dfc85be098248de6c63083968b9cc2a5" translate="yes" xml:space="preserve">
          <source>There is an additional quasi-persistent &quot;&lt;code&gt;-wal&lt;/code&gt;&quot; file and &quot;&lt;code&gt;-shm&lt;/code&gt;&quot; shared memory file associated with each database, which can make SQLite less appealing for use as an &lt;a href=&quot;appfileformat&quot;&gt;application file-format&lt;/a&gt;.</source>
          <target state="translated">Существует дополнительный квази-стойкий &amp;laquo; &lt;code&gt;-wal&lt;/code&gt; &amp;raquo; файл и &amp;laquo; &lt;code&gt;-shm&lt;/code&gt; &amp;raquo; совместно используемый файл память , связанный с каждой базой данных, которая может сделать SQLite менее привлекательным для использования в качестве &lt;a href=&quot;appfileformat&quot;&gt;файла формата приложение&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6c15ef6d2dec509f5afb1c6ad236607cae0e66e0" translate="yes" xml:space="preserve">
          <source>There is an assortment of sqlite3_bind routines used to assign values to wildcards in a prepared SQL statement. Unbound wildcards are interpreted as NULLs. Bindings are not reset by sqlite3_reset(). But wildcards can be rebound to new values after an sqlite3_reset().</source>
          <target state="translated">Существует ассортимент процедур sqlite3_bind,используемых для присвоения значений подстановочным знакам в подготовленном SQL операторе.Несвязанные подстановочные знаки интерпретируются как NULL.Привязки не сбрасываются функцией sqlite3_reset().Но после функции sqlite3_reset()подстановочные знаки могут быть возвращены к новым значениям.</target>
        </trans-unit>
        <trans-unit id="1cba197f7f4cf87333685b6d55dd8ea7d285abdf" translate="yes" xml:space="preserve">
          <source>There is an implied &quot;&lt;a href=&quot;opcode#Halt&quot;&gt;Halt&lt;/a&gt; 0 0 0&quot; instruction inserted at the very end of every program. So a jump past the last instruction of the program is the same as executing &lt;a href=&quot;opcode#Halt&quot;&gt;Halt&lt;/a&gt;.</source>
          <target state="translated">Подразумевается, что в самом конце каждой программы вставляется инструкция &amp;laquo; &lt;a href=&quot;opcode#Halt&quot;&gt;Halt&lt;/a&gt; 0 0 0&amp;raquo;. Таким образом, переход за последнюю инструкцию программы аналогичен выполнению &lt;a href=&quot;opcode#Halt&quot;&gt;Halt&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="16ef4ec82cf13cdae86f5bf01316c19576909f0f" translate="yes" xml:space="preserve">
          <source>There is an unofficial and unsanctioned Git clone of this repository at &lt;a href=&quot;https://github.com/mackyle/sqlite&quot;&gt;https://github.com/mackyle/sqlite&lt;/a&gt;.</source>
          <target state="translated">Существует неофициальный и несанкционированный клон Git этого репозитория по адресу &lt;a href=&quot;https://github.com/mackyle/sqlite&quot;&gt;https://github.com/mackyle/sqlite&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bea5c372cd0bf0b6a49c619c32079d5921e4aed3" translate="yes" xml:space="preserve">
          <source>There is another, deprecated, method for invoking the optimize operation using a SELECT statement. New code should use statements similar to the INSERT above to optimize FTS structures.</source>
          <target state="translated">Существует еще один,устаревший метод вызова операции оптимизации с помощью оператора SELECT.В новом коде для оптимизации структур FTS должны использоваться утверждения,аналогичные приведенному выше INSERT.</target>
        </trans-unit>
        <trans-unit id="b085a1ad6ab5d12c0b0eb9f325abf631b21418bf" translate="yes" xml:space="preserve">
          <source>There is no &quot;CREATE TEMP VIRTUAL TABLE&quot; statement. To create a temporary virtual table, add the &quot;temp&quot; schema before the virtual table name.</source>
          <target state="translated">Заявления &quot;CREATE TEMP VIRTUAL TABLE&quot; не существует.Чтобы создать временную виртуальную таблицу,добавьте схему &quot;temp&quot; перед именем виртуальной таблицы.</target>
        </trans-unit>
        <trans-unit id="f17db4bcecd606fe4d51c30c972432fc774cef49" translate="yes" xml:space="preserve">
          <source>There is no RESERVED lock on the corresponding database file.</source>
          <target state="translated">В соответствующем файле базы данных нет RESERVED-блокировки.</target>
        </trans-unit>
        <trans-unit id="e99ed00de2d6f07769da563a3ed2aa8bf01a7e2e" translate="yes" xml:space="preserve">
          <source>There is no agreement on what the C datatype for a UTF-16 string should be. Therefore, SQLite uses a generic type of void* to refer to UTF-16 strings. Client software can cast the void* to whatever datatype is appropriate for their system.</source>
          <target state="translated">Нет согласия по поводу того,каким должен быть тип данных C для строки UTF-16.Поэтому SQLite использует общий тип void*для ссылки на строки UTF-16.Клиентское программное обеспечение может приводить void*к любому типу данных,подходящему для его системы.</target>
        </trans-unit>
        <trans-unit id="c505515229e6ccfbb2128baeaa4350ad9e337f7c" translate="yes" xml:space="preserve">
          <source>There is no conflicting row in this case. The results of invoking the sqlite3changeset_conflict() API are undefined.</source>
          <target state="translated">В этом случае нет противоречивых строк.Результаты вызова sqlite3changeset_conflict()API неопределенны.</target>
        </trans-unit>
        <trans-unit id="a04b936246a75ee50e5104c87c5e5c3bc05ae139" translate="yes" xml:space="preserve">
          <source>There is no pre-defined release cycle. Releases occur when there is a critical mass of feature enhancements and/or bug fixes. Historically, releases have occurred about 5 or 6 times per year. Users of SQLite pick up new releases from the website on an as-needed basis.</source>
          <target state="translated">Предварительного цикла выпуска нет.Релизы происходят при наличии критической массы улучшений и/или исправлений.Исторически релизы происходили примерно 5-6 раз в год.Пользователи SQLite получают новые релизы с сайта по мере необходимости.</target>
        </trans-unit>
        <trans-unit id="dd71d330015524aacf28e91f9c23458da952387d" translate="yes" xml:space="preserve">
          <source>There is no reserved lock on the main database file.</source>
          <target state="translated">В главном файле БД нет зарезервированной блокировки.</target>
        </trans-unit>
        <trans-unit id="7df732794b7961185fb08c11a413b1539639964a" translate="yes" xml:space="preserve">
          <source>There is no support for &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt;. Changes to virtual tables are not captured.</source>
          <target state="translated">Нет поддержки &lt;a href=&quot;vtab&quot;&gt;виртуальных таблиц&lt;/a&gt; . Изменения виртуальных таблиц не фиксируются.</target>
        </trans-unit>
        <trans-unit id="11d7bfeb25e84c6d1e9766a1abf1f94079350c5e" translate="yes" xml:space="preserve">
          <source>There is normally one row per index, with the index identified by the name in the sqlite_stat1.idx column. The sqlite_stat1.tbl column is the name of the table to which the index belongs. In each such row, the sqlite_stat.stat column will be a string consisting of a list of integers followed by zero or more arguments. The first integer in this list is the approximate number of rows in the index. (The number of rows in the index is the same as the number of rows in the table, except for &lt;a href=&quot;partialindex&quot;&gt;partial indexes&lt;/a&gt;.) The second integer is the approximate number of rows in the index that have the same value in the first column of the index. The third integer is the number number of rows in the index that have the same value for the first two columns. The N-th integer (for N&amp;gt;1) is the estimated average number of rows in the index which have the same value for the first N-1 columns. For a K-column index, there will be K+1 integers in the stat column. If the index is unique, then the last integer will be 1.</source>
          <target state="translated">Обычно на каждый индекс приходится одна строка, причем индекс определяется именем в столбце sqlite_stat1.idx. Столбец sqlite_stat1.tbl - это имя таблицы, к которой принадлежит индекс. В каждой такой строке столбец sqlite_stat.stat будет строкой, состоящей из списка целых чисел, за которым следует ноль или более аргументов. Первое целое число в этом списке - приблизительное количество строк в индексе. (Количество строк в индексе такое же, как количество строк в таблице, за исключением &lt;a href=&quot;partialindex&quot;&gt;частичных индексов&lt;/a&gt;.) Второе целое число - это приблизительное количество строк в индексе, которые имеют такое же значение в первом столбце индекса. Третье целое число - это количество строк в индексе, которые имеют одинаковое значение для первых двух столбцов. N-е целое число (для N&amp;gt; 1) - это оценочное среднее количество строк в индексе, которые имеют одинаковое значение для первых N-1 столбцов. Для индекса K-столбца в столбце stat будет K + 1 целых чисел. Если индекс уникален, то последнее целое число будет равно 1.</target>
        </trans-unit>
        <trans-unit id="c9c3e6d9120e8e4bfa41b1d6a3111f7343cb6f19" translate="yes" xml:space="preserve">
          <source>There is now a compile-time option that allows an application to define alternative malloc()/free() implementations without having to modify any core SQLite code.</source>
          <target state="translated">Теперь существует возможность компиляции,которая позволяет приложению определять альтернативные реализации malloc()/free()без необходимости модификации основного кода SQLite.</target>
        </trans-unit>
        <trans-unit id="f62ae2b58bd448bf76ec1b9c9d9ded56906eaff1" translate="yes" xml:space="preserve">
          <source>There is now a compile-time option that allows an application to define alternative mutex implementations without having to modify any core SQLite code.</source>
          <target state="translated">Теперь существует возможность компиляции,которая позволяет приложению определять альтернативные реализации мьютекса без необходимости модификации основного кода SQLite.</target>
        </trans-unit>
        <trans-unit id="b1cb6058c59ace1351641df9e565cb12b51e73fe" translate="yes" xml:space="preserve">
          <source>There is one entry in the %_node table for each R*Tree node. An R*Tree node consists of one or more entries that are proximate to one another. The nodes of an R*Tree for a tree. All nodes other than the root have an entry in the %_parent shadow table that identifies the parent node. Each entry in an R*Tree has a rowid. The %_rowid shadow table maps entry rowids to the node that contains that entry.</source>
          <target state="translated">Для каждого узла R*Tree в таблице %_node есть одна запись.Узел R*Tree состоит из одной или нескольких записей,которые находятся в непосредственной близости друг от друга.Узлы R*Tree для дерева.Все узлы,кроме корня,имеют запись в таблице тени %_parent,которая идентифицирует родительский узел.Каждая запись в R*Tree имеет ряд.Таблица тени %_rowsid сопоставляет рядки записей узлу,который содержит эту запись.</target>
        </trans-unit>
        <trans-unit id="91aa566670abb0466fc190ee57ffd69271a7af7c" translate="yes" xml:space="preserve">
          <source>There is one exception to the previous paragraph: when a row is inserted, updated or deleted, if one or more of its primary key columns contain a NULL value, no record of the change is made.</source>
          <target state="translated">Есть одно исключение из предыдущего параграфа:когда строка вставляется,обновляется или удаляется,если один или несколько столбцов первичного ключа содержат NULL-значение,запись об изменении не производится.</target>
        </trans-unit>
        <trans-unit id="545885bb104866881571615fd910604fef6b0f44" translate="yes" xml:space="preserve">
          <source>There is one important difference between ON UPDATE foreign key actions and SQL triggers. An ON UPDATE action is only taken if the values of the parent key are modified so that the new parent key values are not equal to the old. For example:</source>
          <target state="translated">Существует одно важное отличие между действием постороннего ключа ON UPDATE и триггерами SQL.Действие ON UPDATE выполняется только в том случае,если значения родительского ключа изменены таким образом,что новые значения родительского ключа не совпадают со старыми.Например:</target>
        </trans-unit>
        <trans-unit id="67f4030e1b4840bae9054c024eff72bf5cb42560" translate="yes" xml:space="preserve">
          <source>There is one other subtle difference between &quot;docid&quot; and the normal SQLite aliases for the rowid column. Normally, if an INSERT or UPDATE statement assigns discrete values to two or more aliases of the rowid column, SQLite writes the rightmost of such values specified in the INSERT or UPDATE statement to the database. However, assigning a non-NULL value to both the &quot;docid&quot; and one or more of the SQLite rowid aliases when inserting or updating an FTS table is considered an error. See below for an example.</source>
          <target state="translated">Есть еще одно тонкое различие между &quot;docid&quot; и обычными псевдонимами SQLite для столбца rowid.Обычно,если оператор INSERT или UPDATE присваивает дискретные значения двум или более псевдонимам столбца rowid,SQLite записывает в БД самую правую часть таких значений,указанных в операторе INSERT или UPDATE.Однако присвоение значения,отличного от NULL,как &quot;docid&quot;,так и одного или более псевдонимов рядковых столбцов SQLite при вставке или обновлении таблицы FTS считается ошибкой.См.пример ниже.</target>
        </trans-unit>
        <trans-unit id="f856aedc1ad69cfc42357d4bdb200682208f50ab" translate="yes" xml:space="preserve">
          <source>There is only one sorter object, so there are no instructions to open or close it. It is opened automatically when needed, and it is closed when the VDBE program halts.</source>
          <target state="translated">Существует только один объект сортировщика,поэтому нет инструкций по его открытию или закрытию.Он открывается автоматически при необходимости,и закрывается,когда программа VDBE останавливается.</target>
        </trans-unit>
        <trans-unit id="6e50e0d48c576b86d93a31befcc02f54e14b5267" translate="yes" xml:space="preserve">
          <source>There is the extra operation of &lt;a href=&quot;wal#ckpt&quot;&gt;checkpointing&lt;/a&gt; which, though automatic by default, is still something that application developers need to be mindful of.</source>
          <target state="translated">Существует дополнительная операция создания &lt;a href=&quot;wal#ckpt&quot;&gt;контрольных точек,&lt;/a&gt; которая, хотя и автоматическая по умолчанию, по-прежнему является тем, о чем разработчики приложений должны помнить.</target>
        </trans-unit>
        <trans-unit id="62428f96be095192850e1858e6283c21fe02dd48" translate="yes" xml:space="preserve">
          <source>There is write permission on the directory containing the database so that the &lt;code&gt;-shm&lt;/code&gt; and &lt;code&gt;-wal&lt;/code&gt; files can be created.</source>
          <target state="translated">В каталог, содержащий базу данных, есть разрешение на &lt;code&gt;-shm&lt;/code&gt; &lt;code&gt;-wal&lt;/code&gt; можно было создавать файлы -shm и -wal .</target>
        </trans-unit>
        <trans-unit id="5b6352389dca7ff834f53599bb4e1238c6a257d8" translate="yes" xml:space="preserve">
          <source>There may be at most one unlock-notify callback registered by a blocked connection. If sqlite3_unlock_notify() is called when the blocked connection already has a registered unlock-notify callback, then the new callback replaces the old. If sqlite3_unlock_notify() is called with a NULL pointer as its second argument, then any existing unlock-notify callback is canceled. The blocked connections unlock-notify callback may also be canceled by closing the blocked connection using &lt;a href=&quot;#sqlite3_close&quot;&gt;sqlite3_close()&lt;/a&gt;.</source>
          <target state="translated">При заблокированном соединении может быть зарегистрировано не более одного обратного вызова с уведомлением о разблокировке. Если sqlite3_unlock_notify () вызывается, когда заблокированное соединение уже имеет зарегистрированный обратный вызов unlock-notify, тогда новый обратный вызов заменяет старый. Если sqlite3_unlock_notify () вызывается с указателем NULL в качестве второго аргумента, то любой существующий обратный вызов unlock-notify отменяется. Обратный вызов разблокировки-уведомления заблокированных соединений также можно отменить, закрыв заблокированное соединение с помощью &lt;a href=&quot;#sqlite3_close&quot;&gt;sqlite3_close ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="474f04800d7576cb1df432f79959d44e97ec88c4" translate="yes" xml:space="preserve">
          <source>There may be at most one unlock-notify callback registered by a blocked connection. If sqlite3_unlock_notify() is called when the blocked connection already has a registered unlock-notify callback, then the new callback replaces the old. If sqlite3_unlock_notify() is called with a NULL pointer as its second argument, then any existing unlock-notify callback is canceled. The blocked connections unlock-notify callback may also be canceled by closing the blocked connection using &lt;a href=&quot;close&quot;&gt;sqlite3_close()&lt;/a&gt;.</source>
          <target state="translated">При заблокированном соединении может быть зарегистрировано не более одного обратного вызова с уведомлением о разблокировке. Если sqlite3_unlock_notify () вызывается, когда заблокированное соединение уже имеет зарегистрированный обратный вызов unlock-notify, тогда новый обратный вызов заменяет старый. Если sqlite3_unlock_notify () вызывается с указателем NULL в качестве второго аргумента, то любой существующий обратный вызов unlock-notify отменяется. Обратный вызов разблокировки-уведомления заблокированных соединений также можно отменить, закрыв заблокированное соединение с помощью &lt;a href=&quot;close&quot;&gt;sqlite3_close ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="51e2e6b0569ca6a8c745966ed3e14378d13e60a9" translate="yes" xml:space="preserve">
          <source>There might be merge conflicts. In other words, it might be that the changes from (2) to (3) are incompatible with the changes from (1) to (4). In that case, the maintainer will have to manually resolve the conflicts. Hopefully conflicts will not come up that often. Conflicts are less likely to occur when the private edits are kept to a minimum.</source>
          <target state="translated">Могут быть конфликты слияния.Другими словами,возможно,что изменения от (2)до (3)несовместимы с изменениями от (1)до (4).В этом случае мейнтейнеру придется разрешить конфликты вручную.Будем надеяться,что конфликты будут возникать не так часто.Конфликты будут возникать реже,когда количество закрытых правок сведено к минимуму.</target>
        </trans-unit>
        <trans-unit id="c1f15675484de7896b9f4cea6917b5f96c0a2c61" translate="yes" xml:space="preserve">
          <source>There might be one or more &lt;a href=&quot;c3ref/vtab_cursor&quot;&gt;sqlite3_vtab_cursor&lt;/a&gt; objects open and in use on the virtual table instance and perhaps even on the row of the virtual table when the xUpdate method is invoked. The implementation of xUpdate must be prepared for attempts to delete or modify rows of the table out from other existing cursors. If the virtual table cannot accommodate such changes, the xUpdate method must return an &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt;.</source>
          <target state="translated">Может быть один или несколько объектов &lt;a href=&quot;c3ref/vtab_cursor&quot;&gt;sqlite3_vtab_cursor&lt;/a&gt; открыты и используются в экземпляре виртуальной таблицы и, возможно, даже в строке виртуальной таблицы, когда вызывается метод xUpdate. Реализация xUpdate должна быть подготовлена ​​к попыткам удалить или изменить строки таблицы из других существующих курсоров. Если виртуальная таблица не может вместить такие изменения, метод xUpdate должен вернуть &lt;a href=&quot;rescode&quot;&gt;код ошибки&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f17a65d092891c67c0c7c0d6ffba57606e51c65a" translate="yes" xml:space="preserve">
          <source>There must be a read-lock on the database (either a transaction must be started or there must be an open cursor) before executing this instruction.</source>
          <target state="translated">Перед выполнением данной инструкции в БД должна быть выполнена блокировка чтения (либо должна быть запущена транзакция,либо должен быть открыт курсор).</target>
        </trans-unit>
        <trans-unit id="838abced0ca5c629a232ce0c8ac382dc2a5201e9" translate="yes" xml:space="preserve">
          <source>There must be no overlap in the bands of rowids for the various tables in a union-vtab.</source>
          <target state="translated">Не должно быть перекрытия в полосах рядовых для различных таблиц в профсоюзной табличке.</target>
        </trans-unit>
        <trans-unit id="2f109c8b1d1e372963703dc38ccb68fefa2006aa" translate="yes" xml:space="preserve">
          <source>There must be no overlapping rowid ranges in the rows returned by the SQL statement. It is an error if there are.</source>
          <target state="translated">В строках,возвращаемых SQL-оператором,не должно быть перекрывающихся диапазонов rowid.Это ошибка,если она есть.</target>
        </trans-unit>
        <trans-unit id="af3fe573da439b499f0025edd3eb3c7aa3d7e8cd" translate="yes" xml:space="preserve">
          <source>There must not be a write transaction open on schema S of database connection D.</source>
          <target state="translated">На схеме S подключения D к БД не должна быть открыта транзакция записи.</target>
        </trans-unit>
        <trans-unit id="3d41940c4561987aa3b448b06598e8d1c6472839" translate="yes" xml:space="preserve">
          <source>There should be exactly one call to sqlite3_backup_finish() for each successful call to sqlite3_backup_init().</source>
          <target state="translated">Для каждого успешного вызова sqlite3_backup_finish()должен быть ровно один вызов sqlite3_backup_init().</target>
        </trans-unit>
        <trans-unit id="9cf5a0f0e6851073aea7c635470af127d9d907d8" translate="yes" xml:space="preserve">
          <source>There were reports that SQLite did not perform as well on an indexed table. This test was recently added to disprove those rumors. It is true that SQLite is not as fast at creating new index entries as the other engines (see Test 6 below) but its overall speed is still better.</source>
          <target state="translated">Были сообщения о том,что SQLite не работал так же хорошо на индексированной таблице.Недавно был добавлен этот тест,чтобы опровергнуть эти слухи.Правда,SQLite не так быстро создает новые записи индекса,как другие движки (см.ниже Тест 6),но в целом его скорость все равно лучше.</target>
        </trans-unit>
        <trans-unit id="7cdb3ca5132a0c3bc86c19fe3abd0889729f8701" translate="yes" xml:space="preserve">
          <source>These APIs are only available if the library was compiled with the &lt;a href=&quot;../compile#enable_column_metadata&quot;&gt;SQLITE_ENABLE_COLUMN_METADATA&lt;/a&gt; C-preprocessor symbol.</source>
          <target state="translated">Эти API доступны только в том случае, если библиотека была скомпилирована с &lt;a href=&quot;../compile#enable_column_metadata&quot;&gt;символом SQLITE_ENABLE_COLUMN_METADATA&lt;/a&gt; C-препроцессора.</target>
        </trans-unit>
        <trans-unit id="04c8e718505dcab90cfc6233e2bd22375b7164d1" translate="yes" xml:space="preserve">
          <source>These APIs are only available if the library was compiled with the &lt;a href=&quot;compile#enable_column_metadata&quot;&gt;SQLITE_ENABLE_COLUMN_METADATA&lt;/a&gt; C-preprocessor symbol.</source>
          <target state="translated">Эти API доступны только в том случае, если библиотека была скомпилирована с &lt;a href=&quot;compile#enable_column_metadata&quot;&gt;символом SQLITE_ENABLE_COLUMN_METADATA&lt;/a&gt; C-препроцессора.</target>
        </trans-unit>
        <trans-unit id="c0bacb531ef3c143611b93d8575c5722c7b86645" translate="yes" xml:space="preserve">
          <source>These action code values signify what kind of operation is to be authorized. The 3rd and 4th parameters to the authorization callback function will be parameters or NULL depending on which of these codes is used as the second parameter. The 5th parameter to the authorizer callback is the name of the database (&quot;main&quot;, &quot;temp&quot;, etc.) if applicable. The 6th parameter to the authorizer callback is the name of the inner-most trigger or view that is responsible for the access attempt or NULL if this access attempt is directly from top-level SQL code.</source>
          <target state="translated">Эти значения кода действия означают,какая операция должна быть авторизована.Третий и четвертый параметры для функции обратного вызова авторизации будут параметрами или NULL,в зависимости от того,какой из этих кодов используется в качестве второго параметра.Пятым параметром обратного вызова авторизации является имя базы данных (&quot;main&quot;,&quot;temp&quot; и т.д.),если это применимо.6-й параметр обратного вызова авторизатора-это имя самого внутреннего триггера или вида,отвечающего за попытку доступа,или NULL,если эта попытка доступа происходит непосредственно из SQL-кода верхнего уровня.</target>
        </trans-unit>
        <trans-unit id="08d99679f060455eb057ba3c4cf117bfe450c567" translate="yes" xml:space="preserve">
          <source>These and other similar syntax restrictions are described in the text.</source>
          <target state="translated">Эти и другие подобные синтаксические ограничения описаны в тексте.</target>
        </trans-unit>
        <trans-unit id="373ccf29c36481aabf98cf8d5fcf341e72288794" translate="yes" xml:space="preserve">
          <source>These are just a few of the benefits of using SQLite as an application file format &amp;mdash; the benefits that seem most likely to improve the user experience for applications like OpenOffice. Other applications might benefit from SQLite in different ways. See the &lt;a href=&quot;appfileformat&quot;&gt;Application File Format&lt;/a&gt; document for additional ideas.</source>
          <target state="translated">Это лишь некоторые из преимуществ использования SQLite в качестве формата файла приложения - преимущества, которые, по всей вероятности, улучшат пользовательский интерфейс для таких приложений, как OpenOffice. Другие приложения могут извлечь выгоду из SQLite по-разному. См &lt;a href=&quot;appfileformat&quot;&gt;Формат файла приложения&lt;/a&gt; документа для дополнительных идей.</target>
        </trans-unit>
        <trans-unit id="840704459c7bebebba604f0b7c84031cf12ac5c7" translate="yes" xml:space="preserve">
          <source>These are special values for the destructor that is passed in as the final argument to routines like &lt;a href=&quot;#sqlite3_result_blob&quot;&gt;sqlite3_result_blob()&lt;/a&gt;. If the destructor argument is SQLITE_STATIC, it means that the content pointer is constant and will never change. It does not need to be destroyed. The SQLITE_TRANSIENT value means that the content will likely change in the near future and that SQLite should make its own private copy of the content before returning.</source>
          <target state="translated">Это специальные значения для деструктора, который передается в качестве последнего аргумента таким процедурам, как &lt;a href=&quot;#sqlite3_result_blob&quot;&gt;sqlite3_result_blob ()&lt;/a&gt; . Если аргумент деструктора - SQLITE_STATIC, это означает, что указатель содержимого постоянен и никогда не изменится. Его не нужно уничтожать. Значение SQLITE_TRANSIENT означает, что контент, вероятно, изменится в ближайшем будущем и что SQLite должен сделать свою собственную частную копию контента перед возвратом.</target>
        </trans-unit>
        <trans-unit id="3097b1326f3eb788f48bb5e49292e793f88d3f73" translate="yes" xml:space="preserve">
          <source>These are special values for the destructor that is passed in as the final argument to routines like &lt;a href=&quot;result_blob&quot;&gt;sqlite3_result_blob()&lt;/a&gt;. If the destructor argument is SQLITE_STATIC, it means that the content pointer is constant and will never change. It does not need to be destroyed. The SQLITE_TRANSIENT value means that the content will likely change in the near future and that SQLite should make its own private copy of the content before returning.</source>
          <target state="translated">Это специальные значения для деструктора, который передается в качестве последнего аргумента таким процедурам, как &lt;a href=&quot;result_blob&quot;&gt;sqlite3_result_blob ()&lt;/a&gt; . Если аргумент деструктора - SQLITE_STATIC, это означает, что указатель содержимого постоянен и никогда не изменится. Его не нужно уничтожать. Значение SQLITE_TRANSIENT означает, что контент, вероятно, изменится в ближайшем будущем и что SQLite должен сделать свою собственную частную копию контента перед возвратом.</target>
        </trans-unit>
        <trans-unit id="49e507a42bf99a1526a38fb0d00d4e955eae6280" translate="yes" xml:space="preserve">
          <source>These are the eight locks supported:</source>
          <target state="translated">Это восемь поддерживаемых замков:</target>
        </trans-unit>
        <trans-unit id="b356241fa91bdf09876f0517086180731227ee47" translate="yes" xml:space="preserve">
          <source>These are utility routines, useful to &lt;a href=&quot;../vfs&quot;&gt;custom VFS implementations&lt;/a&gt;, that check if a database file was a URI that contained a specific query parameter, and if so obtains the value of that query parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56ef0cc4c32969ca19f4793dd10614a44d9a509c" translate="yes" xml:space="preserve">
          <source>These are utility routines, useful to &lt;a href=&quot;vfs&quot;&gt;custom VFS implementations&lt;/a&gt;, that check if a database file was a URI that contained a specific query parameter, and if so obtains the value of that query parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d61de6a061e0e9a67e085323db1a55d01abf6a99" translate="yes" xml:space="preserve">
          <source>These are utility routines, useful to VFS implementations, that check to see if a database file was a URI that contained a specific query parameter, and if so obtains the value of that query parameter.</source>
          <target state="translated">Это утилитные процедуры,полезные в реализации VFS,которые проверяют,не является ли файл базы данных URI,содержащим конкретный параметр запроса,и если да,то получают значение этого параметра запроса.</target>
        </trans-unit>
        <trans-unit id="0ae1c1d92689387597a221cbf4a8586463c0d9b8" translate="yes" xml:space="preserve">
          <source>These bit values are intended for use in the 3rd parameter to the &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; interface and in the 4th parameter to the &lt;a href=&quot;#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen&lt;/a&gt; method.</source>
          <target state="translated">Эти битовые значения предназначены для использования в третьем параметре интерфейса &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2 ()&lt;/a&gt; и в четвертом параметре метода &lt;a href=&quot;#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="091c1cd775270574b7e8fe92576bddaa3dc774e3" translate="yes" xml:space="preserve">
          <source>These bit values are intended for use in the 3rd parameter to the &lt;a href=&quot;open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; interface and in the 4th parameter to the &lt;a href=&quot;vfs#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen&lt;/a&gt; method.</source>
          <target state="translated">Эти битовые значения предназначены для использования в третьем параметре интерфейса &lt;a href=&quot;open&quot;&gt;sqlite3_open_v2 ()&lt;/a&gt; и в четвертом параметре метода &lt;a href=&quot;vfs#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7379d4e0ce4f6675fd9028087eadfa8eb7ff4976" translate="yes" xml:space="preserve">
          <source>These changes in the default behavior of SQLite are not a compatibility break. All legacy database files continue to be readable and writable by newer versions of SQLite, and all newly created database files continue to be readable and writable by legacy versions of the SQLite library. The only thing that is changing is some default settings. This should result in a performance increase for many applications.</source>
          <target state="translated">Эти изменения в поведении SQLite по умолчанию не являются нарушением совместимости.Все файлы старых баз данных продолжают быть доступны для чтения и записи новыми версиями SQLite,а все вновь созданные файлы баз данных продолжают быть доступны для чтения и записи старыми версиями библиотеки SQLite.Единственное,что меняется-это некоторые настройки по умолчанию.Это должно привести к повышению производительности для многих приложений.</target>
        </trans-unit>
        <trans-unit id="f8b6f19362cf61de4d3d35983b38ffd9c2bbd4d6" translate="yes" xml:space="preserve">
          <source>These constant define integer codes that represent the various text encodings supported by SQLite.</source>
          <target state="translated">Эти константы определяют целочисленные коды,которые представляют различные текстовые кодировки,поддерживаемые SQLite.</target>
        </trans-unit>
        <trans-unit id="28ee7781baba8510621fd94348e40d728944ee20" translate="yes" xml:space="preserve">
          <source>These constants are codes for each of those types.</source>
          <target state="translated">Эти константы являются кодами для каждого из этих типов.</target>
        </trans-unit>
        <trans-unit id="5d678085fc410906abd9ecdf3f62895a2bdac8f9" translate="yes" xml:space="preserve">
          <source>These constants are returned by &lt;a href=&quot;#sqlite3_vtab_on_conflict&quot;&gt;sqlite3_vtab_on_conflict()&lt;/a&gt; to inform a &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; implementation what the &lt;a href=&quot;lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt; mode is for the SQL statement being evaluated.</source>
          <target state="translated">Эти константы возвращаются &lt;a href=&quot;#sqlite3_vtab_on_conflict&quot;&gt;функцией sqlite3_vtab_on_conflict ()&lt;/a&gt; для информирования реализации &lt;a href=&quot;vtab&quot;&gt;виртуальной таблицы о&lt;/a&gt; том, какой режим &lt;a href=&quot;lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt; находится для оцениваемого оператора SQL.</target>
        </trans-unit>
        <trans-unit id="8d5af3a6c05bd2fcca2c0f972b2fd66256957f31" translate="yes" xml:space="preserve">
          <source>These constants are returned by &lt;a href=&quot;vtab_on_conflict&quot;&gt;sqlite3_vtab_on_conflict()&lt;/a&gt; to inform a &lt;a href=&quot;../vtab&quot;&gt;virtual table&lt;/a&gt; implementation what the &lt;a href=&quot;../lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt; mode is for the SQL statement being evaluated.</source>
          <target state="translated">Эти константы возвращаются &lt;a href=&quot;vtab_on_conflict&quot;&gt;функцией sqlite3_vtab_on_conflict ()&lt;/a&gt; для информирования реализации &lt;a href=&quot;../vtab&quot;&gt;виртуальной таблицы о&lt;/a&gt; том, какой режим &lt;a href=&quot;../lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt; находится для оцениваемого оператора SQL.</target>
        </trans-unit>
        <trans-unit id="e0814beadd7fffeacf97b8f77142e48bc418e590" translate="yes" xml:space="preserve">
          <source>These constants are the available integer &quot;verbs&quot; that can be passed as the second argument to the &lt;a href=&quot;#sqlite3_db_status&quot;&gt;sqlite3_db_status()&lt;/a&gt; interface.</source>
          <target state="translated">Эти константы представляют собой доступные целочисленные &amp;laquo;глаголы&amp;raquo;, которые можно передать в качестве второго аргумента в интерфейс &lt;a href=&quot;#sqlite3_db_status&quot;&gt;sqlite3_db_status ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ee8e50c4c247f1789de616c3122fcd5d75fef481" translate="yes" xml:space="preserve">
          <source>These constants are the available integer &quot;verbs&quot; that can be passed as the second argument to the &lt;a href=&quot;db_status&quot;&gt;sqlite3_db_status()&lt;/a&gt; interface.</source>
          <target state="translated">Эти константы представляют собой доступные целочисленные &amp;laquo;глаголы&amp;raquo;, которые можно передать в качестве второго аргумента в интерфейс &lt;a href=&quot;db_status&quot;&gt;sqlite3_db_status ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5685826d85b489c4a4722d59958f312636d778f9" translate="yes" xml:space="preserve">
          <source>These constants are the available integer configuration options that can be passed as the first argument to the &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config()&lt;/a&gt; interface.</source>
          <target state="translated">Эти константы представляют собой доступные целочисленные параметры конфигурации, которые можно передать в качестве первого аргумента в интерфейс &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cb2ae78ea5b1ae2e5bfc176e2229bcc4eaa83a74" translate="yes" xml:space="preserve">
          <source>These constants are the available integer configuration options that can be passed as the first argument to the &lt;a href=&quot;config&quot;&gt;sqlite3_config()&lt;/a&gt; interface.</source>
          <target state="translated">Эти константы представляют собой доступные целочисленные параметры конфигурации, которые можно передать в качестве первого аргумента в интерфейс &lt;a href=&quot;config&quot;&gt;sqlite3_config ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b8b83f50bcee4d621ab3350b27ae006d83053d8d" translate="yes" xml:space="preserve">
          <source>These constants are the available integer configuration options that can be passed as the second argument to the &lt;a href=&quot;#sqlite3_db_config&quot;&gt;sqlite3_db_config()&lt;/a&gt; interface.</source>
          <target state="translated">Эти константы представляют собой доступные целочисленные параметры конфигурации, которые можно передать в качестве второго аргумента в интерфейс &lt;a href=&quot;#sqlite3_db_config&quot;&gt;sqlite3_db_config ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bfdbb7c579979335802d5433a0c4351cc2e64138" translate="yes" xml:space="preserve">
          <source>These constants are the available integer configuration options that can be passed as the second argument to the &lt;a href=&quot;db_config&quot;&gt;sqlite3_db_config()&lt;/a&gt; interface.</source>
          <target state="translated">Эти константы представляют собой доступные целочисленные параметры конфигурации, которые можно передать в качестве второго аргумента в интерфейс &lt;a href=&quot;db_config&quot;&gt;sqlite3_db_config ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="adcbc56bb51ca533b4d845770250da49d6cb92e5" translate="yes" xml:space="preserve">
          <source>These constants are the valid operation code parameters used as the first argument to &lt;a href=&quot;#sqlite3_test_control&quot;&gt;sqlite3_test_control()&lt;/a&gt;.</source>
          <target state="translated">Эти константы являются допустимыми параметрами кода операции, используемыми в качестве первого аргумента &lt;a href=&quot;#sqlite3_test_control&quot;&gt;sqlite3_test_control ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c9e83fda514b191357ca2f8a433c34a6a2561552" translate="yes" xml:space="preserve">
          <source>These constants are the valid operation code parameters used as the first argument to &lt;a href=&quot;test_control&quot;&gt;sqlite3_test_control()&lt;/a&gt;.</source>
          <target state="translated">Эти константы являются допустимыми параметрами кода операции, используемыми в качестве первого аргумента &lt;a href=&quot;test_control&quot;&gt;sqlite3_test_control ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="01b7633fac6735c207dc2ef793e2ed3c159bf015" translate="yes" xml:space="preserve">
          <source>These constants define all valid values for the &quot;checkpoint mode&quot; passed as the third parameter to the &lt;a href=&quot;#sqlite3_wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2()&lt;/a&gt; interface. See the &lt;a href=&quot;#sqlite3_wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2()&lt;/a&gt; documentation for details on the meaning of each of these checkpoint modes.</source>
          <target state="translated">Эти константы определяют все допустимые значения для &amp;laquo;режима контрольной точки&amp;raquo;, передаваемые в качестве третьего параметра в интерфейс &lt;a href=&quot;#sqlite3_wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2 ()&lt;/a&gt; . См. Документацию &lt;a href=&quot;#sqlite3_wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2 ()&lt;/a&gt; для получения подробной информации о значении каждого из этих режимов контрольной точки.</target>
        </trans-unit>
        <trans-unit id="1096d3bfc46b56a1b04a8f3fad11f5e8e55e3e9f" translate="yes" xml:space="preserve">
          <source>These constants define all valid values for the &quot;checkpoint mode&quot; passed as the third parameter to the &lt;a href=&quot;wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2()&lt;/a&gt; interface. See the &lt;a href=&quot;wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2()&lt;/a&gt; documentation for details on the meaning of each of these checkpoint modes.</source>
          <target state="translated">Эти константы определяют все допустимые значения для &amp;laquo;режима контрольной точки&amp;raquo;, передаваемые в качестве третьего параметра в интерфейс &lt;a href=&quot;wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2 ()&lt;/a&gt; . См. Документацию &lt;a href=&quot;wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2 ()&lt;/a&gt; для получения подробной информации о значении каждого из этих режимов контрольной точки.</target>
        </trans-unit>
        <trans-unit id="36fb84516f125fb1ac6f3afbd3477dc152ef05b2" translate="yes" xml:space="preserve">
          <source>These constants define the current transaction state of a database file. The &lt;a href=&quot;#sqlite3_txn_state&quot;&gt;sqlite3_txn_state(D,S)&lt;/a&gt; interface returns one of these constants in order to describe the transaction state of schema S in &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; D.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b75f0cccb950872f2d6aae2a473fcad85192a557" translate="yes" xml:space="preserve">
          <source>These constants define the current transaction state of a database file. The &lt;a href=&quot;txn_state&quot;&gt;sqlite3_txn_state(D,S)&lt;/a&gt; interface returns one of these constants in order to describe the transaction state of schema S in &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; D.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f262688fc8aaf9f38b8c78556de1b6829b6de723" translate="yes" xml:space="preserve">
          <source>These constants define various flags that can be passed into &quot;prepFlags&quot; parameter of the &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v3()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16_v3()&lt;/a&gt; interfaces.</source>
          <target state="translated">Эти константы определяют различные флаги, которые могут быть переданы в параметр &quot;PrepFlags&quot; интерфейсов &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v3 ()&lt;/a&gt; и &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16_v3 ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="52a7e652cd3193b904625b47cf5fc5b4007943d0" translate="yes" xml:space="preserve">
          <source>These constants define various flags that can be passed into &quot;prepFlags&quot; parameter of the &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v3()&lt;/a&gt; and &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16_v3()&lt;/a&gt; interfaces.</source>
          <target state="translated">Эти константы определяют различные флаги, которые могут быть переданы в параметр &quot;PrepFlags&quot; интерфейсов &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v3 ()&lt;/a&gt; и &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16_v3 ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f4779c39284f3e8f89de78b1cf22bb4300a2dde2" translate="yes" xml:space="preserve">
          <source>These constants define various performance limits that can be lowered at run-time using &lt;a href=&quot;#sqlite3_limit&quot;&gt;sqlite3_limit()&lt;/a&gt;. The synopsis of the meanings of the various limits is shown below. Additional information is available at &lt;a href=&quot;limits&quot;&gt;Limits in SQLite&lt;/a&gt;.</source>
          <target state="translated">Эти константы определяют различные ограничения производительности, которые можно снизить во время выполнения с помощью &lt;a href=&quot;#sqlite3_limit&quot;&gt;sqlite3_limit ()&lt;/a&gt; . Краткое описание значений различных пределов показано ниже. Дополнительная информация доступна в &lt;a href=&quot;limits&quot;&gt;разделе Ограничения в SQLite&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="dc33a9fdf99d3b7c3164b92212d61358e77ed2b2" translate="yes" xml:space="preserve">
          <source>These constants define various performance limits that can be lowered at run-time using &lt;a href=&quot;limit&quot;&gt;sqlite3_limit()&lt;/a&gt;. The synopsis of the meanings of the various limits is shown below. Additional information is available at &lt;a href=&quot;../limits&quot;&gt;Limits in SQLite&lt;/a&gt;.</source>
          <target state="translated">Эти константы определяют различные ограничения производительности, которые можно снизить во время выполнения с помощью &lt;a href=&quot;limit&quot;&gt;sqlite3_limit ()&lt;/a&gt; . Краткое описание значений различных пределов показано ниже. Дополнительная информация доступна в &lt;a href=&quot;../limits&quot;&gt;разделе Ограничения в SQLite&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2d9ca50401c9fc616026596d32b3930da4b3846d" translate="yes" xml:space="preserve">
          <source>These constants identify classes of events that can be monitored using the &lt;a href=&quot;#sqlite3_trace_v2&quot;&gt;sqlite3_trace_v2()&lt;/a&gt; tracing logic. The M argument to &lt;a href=&quot;#sqlite3_trace_v2&quot;&gt;sqlite3_trace_v2(D,M,X,P)&lt;/a&gt; is an OR-ed combination of one or more of the following constants. The first argument to the trace callback is one of the following constants.</source>
          <target state="translated">Эти константы определяют классы событий, которые можно отслеживать с помощью логики трассировки &lt;a href=&quot;#sqlite3_trace_v2&quot;&gt;sqlite3_trace_v2 ()&lt;/a&gt; . Аргумент M для &lt;a href=&quot;#sqlite3_trace_v2&quot;&gt;sqlite3_trace_v2 (D, M, X, P)&lt;/a&gt; представляет собой комбинацию одной или нескольких из следующих констант, объединенную операцией ИЛИ. Первым аргументом обратного вызова трассировки является одна из следующих констант.</target>
        </trans-unit>
        <trans-unit id="ed407cdd4869216425bae7d051975b3bcd0fdc3b" translate="yes" xml:space="preserve">
          <source>These constants identify classes of events that can be monitored using the &lt;a href=&quot;trace_v2&quot;&gt;sqlite3_trace_v2()&lt;/a&gt; tracing logic. The M argument to &lt;a href=&quot;trace_v2&quot;&gt;sqlite3_trace_v2(D,M,X,P)&lt;/a&gt; is an OR-ed combination of one or more of the following constants. The first argument to the trace callback is one of the following constants.</source>
          <target state="translated">Эти константы определяют классы событий, которые можно отслеживать с помощью логики трассировки &lt;a href=&quot;trace_v2&quot;&gt;sqlite3_trace_v2 ()&lt;/a&gt; . Аргумент M для &lt;a href=&quot;trace_v2&quot;&gt;sqlite3_trace_v2 (D, M, X, P)&lt;/a&gt; представляет собой комбинацию одной или нескольких из следующих констант, объединенную операцией ИЛИ. Первым аргументом обратного вызова трассировки является одна из следующих констант.</target>
        </trans-unit>
        <trans-unit id="14266cc61d0db9a630a6d1107d408c2e2d4959a8" translate="yes" xml:space="preserve">
          <source>These constants may be ORed together with the &lt;a href=&quot;#SQLITE_ANY&quot;&gt;preferred text encoding&lt;/a&gt; as the fourth argument to &lt;a href=&quot;#sqlite3_create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_create_function&quot;&gt;sqlite3_create_function16()&lt;/a&gt;, or &lt;a href=&quot;#sqlite3_create_function&quot;&gt;sqlite3_create_function_v2()&lt;/a&gt;.</source>
          <target state="translated">Эти константы могут быть объединены оператором ИЛИ вместе с &lt;a href=&quot;#SQLITE_ANY&quot;&gt;предпочтительной кодировкой текста&lt;/a&gt; в качестве четвертого аргумента для &lt;a href=&quot;#sqlite3_create_function&quot;&gt;sqlite3_create_function ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_create_function&quot;&gt;sqlite3_create_function16 ()&lt;/a&gt; или &lt;a href=&quot;#sqlite3_create_function&quot;&gt;sqlite3_create_function_v2 ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4e4c2775c736d10a648ec5f64c5240681b8a597f" translate="yes" xml:space="preserve">
          <source>These constants may be ORed together with the &lt;a href=&quot;c_any&quot;&gt;preferred text encoding&lt;/a&gt; as the fourth argument to &lt;a href=&quot;create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt;, &lt;a href=&quot;create_function&quot;&gt;sqlite3_create_function16()&lt;/a&gt;, or &lt;a href=&quot;create_function&quot;&gt;sqlite3_create_function_v2()&lt;/a&gt;.</source>
          <target state="translated">Эти константы могут быть объединены оператором ИЛИ вместе с &lt;a href=&quot;c_any&quot;&gt;предпочтительной кодировкой текста&lt;/a&gt; в качестве четвертого аргумента для &lt;a href=&quot;create_function&quot;&gt;sqlite3_create_function ()&lt;/a&gt; , &lt;a href=&quot;create_function&quot;&gt;sqlite3_create_function16 ()&lt;/a&gt; или &lt;a href=&quot;create_function&quot;&gt;sqlite3_create_function_v2 ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d452c2a5987467cef42875b2093f98a07b801c06" translate="yes" xml:space="preserve">
          <source>These functions (collectively known as &quot;function creation routines&quot;) are used to add SQL functions or aggregates or to redefine the behavior of existing SQL functions or aggregates. The only differences between the three &quot;sqlite3_create_function*&quot; routines are the text encoding expected for the second parameter (the name of the function being created) and the presence or absence of a destructor callback for the application data pointer. Function sqlite3_create_window_function() is similar, but allows the user to supply the extra callback functions needed by &lt;a href=&quot;../windowfunctions#aggwinfunc&quot;&gt;aggregate window functions&lt;/a&gt;.</source>
          <target state="translated">Эти функции (вместе известные как &amp;laquo;процедуры создания функций&amp;raquo;) используются для добавления функций или агрегатов SQL или для переопределения поведения существующих функций или агрегатов SQL. Единственные различия между тремя подпрограммами sqlite3_create_function * - это кодировка текста, ожидаемая для второго параметра (имя создаваемой функции), и наличие или отсутствие обратного вызова деструктора для указателя данных приложения. Функция sqlite3_create_window_function () аналогична, но позволяет пользователю предоставлять дополнительные функции обратного вызова, необходимые для &lt;a href=&quot;../windowfunctions#aggwinfunc&quot;&gt;агрегированных оконных функций&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="460bddf16e550adbe692fb026aea91fd5c1a8fa1" translate="yes" xml:space="preserve">
          <source>These functions (collectively known as &quot;function creation routines&quot;) are used to add SQL functions or aggregates or to redefine the behavior of existing SQL functions or aggregates. The only differences between the three &quot;sqlite3_create_function*&quot; routines are the text encoding expected for the second parameter (the name of the function being created) and the presence or absence of a destructor callback for the application data pointer. Function sqlite3_create_window_function() is similar, but allows the user to supply the extra callback functions needed by &lt;a href=&quot;windowfunctions#aggwinfunc&quot;&gt;aggregate window functions&lt;/a&gt;.</source>
          <target state="translated">Эти функции (вместе известные как &amp;laquo;процедуры создания функций&amp;raquo;) используются для добавления функций или агрегатов SQL или для переопределения поведения существующих функций или агрегатов SQL. Единственные различия между тремя подпрограммами sqlite3_create_function * - это кодировка текста, ожидаемая для второго параметра (имя создаваемой функции), и наличие или отсутствие обратного вызова деструктора для указателя данных приложения. Функция sqlite3_create_window_function () аналогична, но позволяет пользователю предоставлять дополнительные функции обратного вызова, необходимые для &lt;a href=&quot;windowfunctions#aggwinfunc&quot;&gt;агрегированных оконных функций&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f5aa8ee7f5d5dcd17c7a255e21fd6564afc6f3cb" translate="yes" xml:space="preserve">
          <source>These functions add, remove, or modify a &lt;a href=&quot;../datatype3#collation&quot;&gt;collation&lt;/a&gt; associated with the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; specified as the first argument.</source>
          <target state="translated">Эти функции добавляют, удаляют или изменяют параметры &lt;a href=&quot;../datatype3#collation&quot;&gt;сортировки,&lt;/a&gt; связанные с &lt;a href=&quot;sqlite3&quot;&gt;подключением&lt;/a&gt; к базе данных, указанным в качестве первого аргумента.</target>
        </trans-unit>
        <trans-unit id="ed63a5a7289985766e806cdca8d318ceb652f682" translate="yes" xml:space="preserve">
          <source>These functions add, remove, or modify a &lt;a href=&quot;datatype3#collation&quot;&gt;collation&lt;/a&gt; associated with the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; specified as the first argument.</source>
          <target state="translated">Эти функции добавляют, удаляют или изменяют параметры &lt;a href=&quot;datatype3#collation&quot;&gt;сортировки,&lt;/a&gt; связанные с &lt;a href=&quot;#sqlite3&quot;&gt;подключением&lt;/a&gt; к базе данных, указанным в качестве первого аргумента.</target>
        </trans-unit>
        <trans-unit id="e828096ae0ef377574b3a48a5e49c755665e8418" translate="yes" xml:space="preserve">
          <source>These functions are &lt;a href=&quot;capi3ref&quot;&gt;deprecated&lt;/a&gt;. In order to maintain backwards compatibility with older code, these functions continue to be supported. However, new applications should avoid the use of these functions. To encourage programmers to avoid these functions, we will not explain what they do.</source>
          <target state="translated">Эти функции &lt;a href=&quot;capi3ref&quot;&gt;устарели&lt;/a&gt; . Эти функции продолжают поддерживаться для обеспечения обратной совместимости со старым кодом. Однако в новых приложениях следует избегать использования этих функций. Чтобы побудить программистов избегать этих функций, мы не будем объяснять, что они делают.</target>
        </trans-unit>
        <trans-unit id="a53c5b52778acbd5177be1207d66b6e2855a89a9" translate="yes" xml:space="preserve">
          <source>These functions are &lt;a href=&quot;experimental&quot;&gt;deprecated&lt;/a&gt;. In order to maintain backwards compatibility with older code, these functions continue to be supported. However, new applications should avoid the use of these functions. To encourage programmers to avoid these functions, we will not explain what they do.</source>
          <target state="translated">Эти функции &lt;a href=&quot;experimental&quot;&gt;устарели&lt;/a&gt; . Эти функции продолжают поддерживаться для обеспечения обратной совместимости со старым кодом. Однако в новых приложениях следует избегать использования этих функций. Чтобы побудить программистов избегать этих функций, мы не будем объяснять, что они делают.</target>
        </trans-unit>
        <trans-unit id="20e0d52fc906194ab3c598ecb16113bb7e27244d" translate="yes" xml:space="preserve">
          <source>These functions may be used by (non-aggregate) SQL functions to associate metadata with argument values. If the same value is passed to multiple invocations of the same SQL function during query execution, under some circumstances the associated metadata may be preserved. An example of where this might be useful is in a regular-expression matching function. The compiled version of the regular expression can be stored as metadata associated with the pattern string. Then as long as the pattern string remains the same, the compiled regular expression can be reused on multiple invocations of the same function.</source>
          <target state="translated">Эти функции могут использоваться (не агрегированными)SQL-функциями для связи метаданных со значениями аргументов.Если при выполнении запроса одно и то же значение передается нескольким вызовам одной и той же SQL-функции,то при некоторых обстоятельствах связанные с ними метаданные могут быть сохранены.Примером,где это может быть полезно,может служить функция сопоставления регулярных выражений.Скомпилированная версия регулярного выражения может храниться в виде метаданных,связанных со строкой шаблона.Тогда до тех пор,пока строка шаблона остается неизменной,скомпилированное регулярное выражение может быть повторно использовано для множественных вызовов одной и той же функции.</target>
        </trans-unit>
        <trans-unit id="6522a9f48ff48fe82ed5d5982cbd1db9ee5c56d5" translate="yes" xml:space="preserve">
          <source>These functions only work for dates between 0000-01-01 00:00:00 and 9999-12-31 23:59:59 (julian day numbers 1721059.5 through 5373484.5). For dates outside that range, the results of these functions are undefined.</source>
          <target state="translated">Эти функции работают только для дат между 0000-01-01 00:00:00 и 9999-12-31 23:59:59 (номера юлианских дней 1721059.5-5373484.5).Для дат вне этого диапазона результаты этих функций неопределенны.</target>
        </trans-unit>
        <trans-unit id="05e896fbaa59935c0c643898daaa4791cc7323f5" translate="yes" xml:space="preserve">
          <source>These functions respectively add, subtract, and multiply their arguments and return a new text string that is the decimal representation of the result. There is no division operator at this time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8d304d80363d45f2a701bb02157d9c038cae0f9" translate="yes" xml:space="preserve">
          <source>These functions work very much like the &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;parameter binding&lt;/a&gt; family of functions used to bind values to host parameters in prepared statements. Refer to the &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;SQL parameter&lt;/a&gt; documentation for additional information.</source>
          <target state="translated">Эти функции работают очень похоже на &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;параметр связывания&lt;/a&gt; семейства функций , используемых для значений связывания с параметрами хозяевах в подготовленных заявлений. Дополнительную информацию см. В документации по &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;параметрам SQL&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b317ce2527b91fa298699867534154a11da36ac3" translate="yes" xml:space="preserve">
          <source>These functions work very much like the &lt;a href=&quot;bind_blob&quot;&gt;parameter binding&lt;/a&gt; family of functions used to bind values to host parameters in prepared statements. Refer to the &lt;a href=&quot;bind_blob&quot;&gt;SQL parameter&lt;/a&gt; documentation for additional information.</source>
          <target state="translated">Эти функции работают очень похоже на &lt;a href=&quot;bind_blob&quot;&gt;параметр связывания&lt;/a&gt; семейства функций , используемых для значений связывания с параметрами хозяевах в подготовленных заявлений. Дополнительную информацию см. В документации по &lt;a href=&quot;bind_blob&quot;&gt;параметрам SQL&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ab78522f9e6af4ebb0a819cdbba908125b1aa9de" translate="yes" xml:space="preserve">
          <source>These integer constants are opcodes for the xFileControl method of the &lt;a href=&quot;#sqlite3_io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object and for the &lt;a href=&quot;#sqlite3_file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; interface.</source>
          <target state="translated">Эти целочисленные константы являются кодами операций для метода xFileControl объекта &lt;a href=&quot;#sqlite3_io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; и для интерфейса &lt;a href=&quot;#sqlite3_file_control&quot;&gt;sqlite3_file_control ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a38e815d9a81f8a36563593031ac86d208aff3ef" translate="yes" xml:space="preserve">
          <source>These integer constants are opcodes for the xFileControl method of the &lt;a href=&quot;io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object and for the &lt;a href=&quot;file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; interface.</source>
          <target state="translated">Эти целочисленные константы являются кодами операций для метода xFileControl объекта &lt;a href=&quot;io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; и для интерфейса &lt;a href=&quot;file_control&quot;&gt;sqlite3_file_control ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ea60b84c9e9ef3033a276fcbd9184666b77d102f" translate="yes" xml:space="preserve">
          <source>These integer constants can be used as the third parameter to the xAccess method of an &lt;a href=&quot;#sqlite3_vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object. They determine what kind of permissions the xAccess method is looking for. With SQLITE_ACCESS_EXISTS, the xAccess method simply checks whether the file exists. With SQLITE_ACCESS_READWRITE, the xAccess method checks whether the named directory is both readable and writable (in other words, if files can be added, removed, and renamed within the directory). The SQLITE_ACCESS_READWRITE constant is currently used only by the &lt;a href=&quot;pragma#pragma_temp_store_directory&quot;&gt;temp_store_directory pragma&lt;/a&gt;, though this could change in a future release of SQLite. With SQLITE_ACCESS_READ, the xAccess method checks whether the file is readable. The SQLITE_ACCESS_READ constant is currently unused, though it might be used in a future release of SQLite.</source>
          <target state="translated">Эти целочисленные константы можно использовать в качестве третьего параметра метода xAccess объекта &lt;a href=&quot;#sqlite3_vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; . Они определяют, какие разрешения ищет метод xAccess. С помощью SQLITE_ACCESS_EXISTS метод xAccess просто проверяет, существует ли файл. С помощью SQLITE_ACCESS_READWRITE метод xAccess проверяет, является ли указанный каталог доступным для чтения и записи (другими словами, можно ли добавлять, удалять и переименовывать файлы в каталоге). Константа SQLITE_ACCESS_READWRITE в настоящее время используется только &lt;a href=&quot;pragma#pragma_temp_store_directory&quot;&gt;прагмой temp_store_directory&lt;/a&gt;, хотя это может измениться в будущем выпуске SQLite. С помощью SQLITE_ACCESS_READ метод xAccess проверяет, доступен ли файл для чтения. Константа SQLITE_ACCESS_READ в настоящее время не используется, хотя может быть использована в будущей версии SQLite.</target>
        </trans-unit>
        <trans-unit id="311aa59e56c46be41f406ebc987fb4c56872151d" translate="yes" xml:space="preserve">
          <source>These integer constants can be used as the third parameter to the xAccess method of an &lt;a href=&quot;vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object. They determine what kind of permissions the xAccess method is looking for. With SQLITE_ACCESS_EXISTS, the xAccess method simply checks whether the file exists. With SQLITE_ACCESS_READWRITE, the xAccess method checks whether the named directory is both readable and writable (in other words, if files can be added, removed, and renamed within the directory). The SQLITE_ACCESS_READWRITE constant is currently used only by the &lt;a href=&quot;../pragma#pragma_temp_store_directory&quot;&gt;temp_store_directory pragma&lt;/a&gt;, though this could change in a future release of SQLite. With SQLITE_ACCESS_READ, the xAccess method checks whether the file is readable. The SQLITE_ACCESS_READ constant is currently unused, though it might be used in a future release of SQLite.</source>
          <target state="translated">Эти целочисленные константы можно использовать в качестве третьего параметра метода xAccess объекта &lt;a href=&quot;vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; . Они определяют, какие разрешения ищет метод xAccess. С помощью SQLITE_ACCESS_EXISTS метод xAccess просто проверяет, существует ли файл. С помощью SQLITE_ACCESS_READWRITE метод xAccess проверяет, является ли указанный каталог доступным для чтения и записи (другими словами, можно ли добавлять, удалять и переименовывать файлы в каталоге). Константа SQLITE_ACCESS_READWRITE в настоящее время используется только &lt;a href=&quot;../pragma#pragma_temp_store_directory&quot;&gt;прагмой temp_store_directory&lt;/a&gt;, хотя это может измениться в будущем выпуске SQLite. С помощью SQLITE_ACCESS_READ метод xAccess проверяет, доступен ли файл для чтения. Константа SQLITE_ACCESS_READ в настоящее время не используется, хотя может быть использована в будущей версии SQLite.</target>
        </trans-unit>
        <trans-unit id="8e30f4610e846824046fcc55a5610ab368656db0" translate="yes" xml:space="preserve">
          <source>These integer constants define the various locking operations allowed by the xShmLock method of &lt;a href=&quot;#sqlite3_io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt;. The following are the only legal combinations of flags to the xShmLock method:</source>
          <target state="translated">Эти целочисленные константы определяют различные операции блокировки, разрешенные методом xShmLock &lt;a href=&quot;#sqlite3_io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; . Ниже приведены единственные допустимые комбинации флагов для метода xShmLock:</target>
        </trans-unit>
        <trans-unit id="63c61207725308cbbebcd362e48d34bfbbce9eff" translate="yes" xml:space="preserve">
          <source>These integer constants define the various locking operations allowed by the xShmLock method of &lt;a href=&quot;io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt;. The following are the only legal combinations of flags to the xShmLock method:</source>
          <target state="translated">Эти целочисленные константы определяют различные операции блокировки, разрешенные методом xShmLock &lt;a href=&quot;io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; . Ниже приведены единственные допустимые комбинации флагов для метода xShmLock:</target>
        </trans-unit>
        <trans-unit id="46be45c61b7407297842f2bf5d770d15053c4ac4" translate="yes" xml:space="preserve">
          <source>These integer constants designate various run-time status parameters that can be returned by &lt;a href=&quot;#sqlite3_status&quot;&gt;sqlite3_status()&lt;/a&gt;.</source>
          <target state="translated">Эти целочисленные константы обозначают различные параметры состояния времени выполнения, которые могут быть возвращены &lt;a href=&quot;#sqlite3_status&quot;&gt;sqlite3_status ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9d8a64fd442238eaa787788726abe76149b5cae0" translate="yes" xml:space="preserve">
          <source>These integer constants designate various run-time status parameters that can be returned by &lt;a href=&quot;status&quot;&gt;sqlite3_status()&lt;/a&gt;.</source>
          <target state="translated">Эти целочисленные константы обозначают различные параметры состояния времени выполнения, которые могут быть возвращены &lt;a href=&quot;status&quot;&gt;sqlite3_status ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1dd74d0b7bde7f62eaef94d29d31baa355fc24b9" translate="yes" xml:space="preserve">
          <source>These interfaces add content to an sqlite3_str object previously obtained from &lt;a href=&quot;#sqlite3_str_new&quot;&gt;sqlite3_str_new()&lt;/a&gt;.</source>
          <target state="translated">Эти интерфейсы добавляют контент к объекту sqlite3_str, ранее полученному из &lt;a href=&quot;#sqlite3_str_new&quot;&gt;sqlite3_str_new ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f4c68aa7a2ee53b8d7d01e966ec46bd4df66a0b8" translate="yes" xml:space="preserve">
          <source>These interfaces add content to an sqlite3_str object previously obtained from &lt;a href=&quot;str_new&quot;&gt;sqlite3_str_new()&lt;/a&gt;.</source>
          <target state="translated">Эти интерфейсы добавляют контент к объекту sqlite3_str, ранее полученному из &lt;a href=&quot;str_new&quot;&gt;sqlite3_str_new ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="37d07c864bda5264afb416a4db651631968abf92" translate="yes" xml:space="preserve">
          <source>These interfaces are available only on Windows. The &lt;a href=&quot;#sqlite3_win32_set_directory&quot;&gt;sqlite3_win32_set_directory&lt;/a&gt; interface is used to set the value associated with the &lt;a href=&quot;#sqlite3_temp_directory&quot;&gt;sqlite3_temp_directory&lt;/a&gt; or &lt;a href=&quot;#sqlite3_data_directory&quot;&gt;sqlite3_data_directory&lt;/a&gt; variable, to zValue, depending on the value of the type parameter. The zValue parameter should be NULL to cause the previous value to be freed via &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free&lt;/a&gt;; a non-NULL value will be copied into memory obtained from &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc&lt;/a&gt; prior to being used. The &lt;a href=&quot;#sqlite3_win32_set_directory&quot;&gt;sqlite3_win32_set_directory&lt;/a&gt; interface returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; to indicate success, &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt; if the type is unsupported, or &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOMEM&lt;/a&gt; if memory could not be allocated. The value of the &lt;a href=&quot;#sqlite3_data_directory&quot;&gt;sqlite3_data_directory&lt;/a&gt; variable is intended to act as a replacement for the current directory on the sub-platforms of Win32 where that concept is not present, e.g. WinRT and UWP. The &lt;a href=&quot;#sqlite3_win32_set_directory&quot;&gt;sqlite3_win32_set_directory8&lt;/a&gt; and &lt;a href=&quot;#sqlite3_win32_set_directory&quot;&gt;sqlite3_win32_set_directory16&lt;/a&gt; interfaces behave exactly the same as the sqlite3_win32_set_directory interface except the string parameter must be UTF-8 or UTF-16, respectively.</source>
          <target state="translated">Эти интерфейсы доступны только в Windows. Интерфейс &lt;a href=&quot;#sqlite3_win32_set_directory&quot;&gt;sqlite3_win32_set_directory&lt;/a&gt; используется для установки значения, связанного с переменной &lt;a href=&quot;#sqlite3_temp_directory&quot;&gt;sqlite3_temp_directory&lt;/a&gt; или &lt;a href=&quot;#sqlite3_data_directory&quot;&gt;sqlite3_data_directory&lt;/a&gt; , на zValue, в зависимости от значения параметра типа. Параметр zValue должен иметь значение NULL, чтобы предыдущее значение было освобождено с помощью &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free&lt;/a&gt; ; значение, &lt;a href=&quot;#sqlite3_free&quot;&gt;отличное&lt;/a&gt; от NULL, будет скопировано в память, полученную из sqlite3_malloc, перед использованием. Интерфейс &lt;a href=&quot;#sqlite3_win32_set_directory&quot;&gt;sqlite3_win32_set_directory&lt;/a&gt; возвращает &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK,&lt;/a&gt; чтобы указать успех, &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR,&lt;/a&gt; если тип не поддерживается, или &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOMEM&lt;/a&gt;если не удалось выделить память. Значение переменной &lt;a href=&quot;#sqlite3_data_directory&quot;&gt;sqlite3_data_directory&lt;/a&gt; предназначено для использования в качестве замены текущего каталога на под-платформах Win32, где эта концепция отсутствует, например WinRT и UWP. Интерфейсы &lt;a href=&quot;#sqlite3_win32_set_directory&quot;&gt;sqlite3_win32_set_directory8&lt;/a&gt; и &lt;a href=&quot;#sqlite3_win32_set_directory&quot;&gt;sqlite3_win32_set_directory16&lt;/a&gt; ведут себя точно так же, как интерфейс sqlite3_win32_set_directory, за исключением того, что строковый параметр должен быть UTF-8 или UTF-16 соответственно.</target>
        </trans-unit>
        <trans-unit id="e3077cf84285d5d0c77e1603a1b1cc3c809c60d7" translate="yes" xml:space="preserve">
          <source>These interfaces are available only on Windows. The &lt;a href=&quot;win32_set_directory&quot;&gt;sqlite3_win32_set_directory&lt;/a&gt; interface is used to set the value associated with the &lt;a href=&quot;temp_directory&quot;&gt;sqlite3_temp_directory&lt;/a&gt; or &lt;a href=&quot;data_directory&quot;&gt;sqlite3_data_directory&lt;/a&gt; variable, to zValue, depending on the value of the type parameter. The zValue parameter should be NULL to cause the previous value to be freed via &lt;a href=&quot;free&quot;&gt;sqlite3_free&lt;/a&gt;; a non-NULL value will be copied into memory obtained from &lt;a href=&quot;free&quot;&gt;sqlite3_malloc&lt;/a&gt; prior to being used. The &lt;a href=&quot;win32_set_directory&quot;&gt;sqlite3_win32_set_directory&lt;/a&gt; interface returns &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; to indicate success, &lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt; if the type is unsupported, or &lt;a href=&quot;../rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt; if memory could not be allocated. The value of the &lt;a href=&quot;data_directory&quot;&gt;sqlite3_data_directory&lt;/a&gt; variable is intended to act as a replacement for the current directory on the sub-platforms of Win32 where that concept is not present, e.g. WinRT and UWP. The &lt;a href=&quot;win32_set_directory&quot;&gt;sqlite3_win32_set_directory8&lt;/a&gt; and &lt;a href=&quot;win32_set_directory&quot;&gt;sqlite3_win32_set_directory16&lt;/a&gt; interfaces behave exactly the same as the sqlite3_win32_set_directory interface except the string parameter must be UTF-8 or UTF-16, respectively.</source>
          <target state="translated">Эти интерфейсы доступны только в Windows. Интерфейс &lt;a href=&quot;win32_set_directory&quot;&gt;sqlite3_win32_set_directory&lt;/a&gt; используется для установки значения, связанного с переменной &lt;a href=&quot;temp_directory&quot;&gt;sqlite3_temp_directory&lt;/a&gt; или &lt;a href=&quot;data_directory&quot;&gt;sqlite3_data_directory&lt;/a&gt; , на zValue, в зависимости от значения параметра типа. Параметр zValue должен иметь значение NULL, чтобы предыдущее значение было освобождено с помощью &lt;a href=&quot;free&quot;&gt;sqlite3_free&lt;/a&gt; ; значение, &lt;a href=&quot;free&quot;&gt;отличное&lt;/a&gt; от NULL, будет скопировано в память, полученную из sqlite3_malloc, перед использованием. Интерфейс &lt;a href=&quot;win32_set_directory&quot;&gt;sqlite3_win32_set_directory&lt;/a&gt; возвращает &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK,&lt;/a&gt; чтобы указать успех, &lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR,&lt;/a&gt; если тип не поддерживается, или &lt;a href=&quot;../rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt;если не удалось выделить память. Значение переменной &lt;a href=&quot;data_directory&quot;&gt;sqlite3_data_directory&lt;/a&gt; предназначено для использования в качестве замены текущего каталога на под-платформах Win32, где эта концепция отсутствует, например WinRT и UWP. Интерфейсы &lt;a href=&quot;win32_set_directory&quot;&gt;sqlite3_win32_set_directory8&lt;/a&gt; и &lt;a href=&quot;win32_set_directory&quot;&gt;sqlite3_win32_set_directory16&lt;/a&gt; ведут себя точно так же, как интерфейс sqlite3_win32_set_directory, за исключением того, что строковый параметр должен быть UTF-8 или UTF-16 соответственно.</target>
        </trans-unit>
        <trans-unit id="bf73a94780de490a8f9c02eb38be04e9aad9c703" translate="yes" xml:space="preserve">
          <source>These interfaces are only available if SQLite is compiled using the &lt;a href=&quot;../compile#enable_preupdate_hook&quot;&gt;SQLITE_ENABLE_PREUPDATE_HOOK&lt;/a&gt; compile-time option.</source>
          <target state="translated">Эти интерфейсы доступны только в том случае, если SQLite скомпилирован с использованием параметра &lt;a href=&quot;../compile#enable_preupdate_hook&quot;&gt;времени&lt;/a&gt; компиляции SQLITE_ENABLE_PREUPDATE_HOOK .</target>
        </trans-unit>
        <trans-unit id="2573d74316b2beb50fe8b93933b238b687b3e25f" translate="yes" xml:space="preserve">
          <source>These interfaces are only available if SQLite is compiled using the &lt;a href=&quot;compile#enable_preupdate_hook&quot;&gt;SQLITE_ENABLE_PREUPDATE_HOOK&lt;/a&gt; compile-time option.</source>
          <target state="translated">Эти интерфейсы доступны только в том случае, если SQLite скомпилирован с использованием параметра &lt;a href=&quot;compile#enable_preupdate_hook&quot;&gt;времени&lt;/a&gt; компиляции SQLITE_ENABLE_PREUPDATE_HOOK .</target>
        </trans-unit>
        <trans-unit id="1dfbcb8f183f59b84e1cdc3c799c0026a4da7b1c" translate="yes" xml:space="preserve">
          <source>These interfaces are used to retrieve runtime status information about the performance of SQLite, and optionally to reset various highwater marks. The first argument is an integer code for the specific parameter to measure. Recognized integer codes are of the form &lt;a href=&quot;#SQLITE_STATUS_MALLOC_COUNT&quot;&gt;SQLITE_STATUS_...&lt;/a&gt;. The current value of the parameter is returned into *pCurrent. The highest recorded value is returned in *pHighwater. If the resetFlag is true, then the highest record value is reset after *pHighwater is written. Some parameters do not record the highest value. For those parameters nothing is written into *pHighwater and the resetFlag is ignored. Other parameters record only the highwater mark and not the current value. For these latter parameters nothing is written into *pCurrent.</source>
          <target state="translated">Эти интерфейсы используются для получения информации о состоянии выполнения о производительности SQLite и, при необходимости, для сброса различных отметок высокого уровня. Первый аргумент - это целочисленный код для конкретного параметра, который нужно измерить. Признанные целочисленные индексы имеют вид &lt;a href=&quot;#SQLITE_STATUS_MALLOC_COUNT&quot;&gt;SQLITE_STATUS _...&lt;/a&gt; . Текущее значение параметра возвращается в * pCurrent. Наибольшее зарегистрированное значение возвращается в * pHighwater. Если resetFlag имеет значение true, то максимальное значение записи сбрасывается после записи * pHighwater. Некоторые параметры не записывают максимальное значение. Для этих параметров в * pHighwater ничего не записывается, а resetFlag игнорируется. Другие параметры записывают только отметку паводка, но не текущее значение. Для этих последних параметров в * pCurrent ничего не записывается.</target>
        </trans-unit>
        <trans-unit id="9a006bb7b78680fec3ca85a8c33bf946ae2c290a" translate="yes" xml:space="preserve">
          <source>These interfaces are used to retrieve runtime status information about the performance of SQLite, and optionally to reset various highwater marks. The first argument is an integer code for the specific parameter to measure. Recognized integer codes are of the form &lt;a href=&quot;c_status_malloc_count&quot;&gt;SQLITE_STATUS_...&lt;/a&gt;. The current value of the parameter is returned into *pCurrent. The highest recorded value is returned in *pHighwater. If the resetFlag is true, then the highest record value is reset after *pHighwater is written. Some parameters do not record the highest value. For those parameters nothing is written into *pHighwater and the resetFlag is ignored. Other parameters record only the highwater mark and not the current value. For these latter parameters nothing is written into *pCurrent.</source>
          <target state="translated">Эти интерфейсы используются для получения информации о состоянии выполнения о производительности SQLite и, при необходимости, для сброса различных отметок высокого уровня. Первый аргумент - это целочисленный код для конкретного параметра, который нужно измерить. Признанные целочисленные индексы имеют вид &lt;a href=&quot;c_status_malloc_count&quot;&gt;SQLITE_STATUS _...&lt;/a&gt; . Текущее значение параметра возвращается в * pCurrent. Наибольшее зарегистрированное значение возвращается в * pHighwater. Если resetFlag имеет значение true, то максимальное значение записи сбрасывается после записи * pHighwater. Некоторые параметры не записывают максимальное значение. Для этих параметров в * pHighwater ничего не записывается, а resetFlag игнорируется. Другие параметры записывают только отметку паводка, но не текущее значение. Для этих последних параметров в * pCurrent ничего не записывается.</target>
        </trans-unit>
        <trans-unit id="7a26bb8a6cfb99470baf86e2f9ba8d8fe1ec3d04" translate="yes" xml:space="preserve">
          <source>These interfaces can be used by an application to monitor how much memory SQLite is using. The &lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_used()&lt;/a&gt; routine returns the number of bytes of memory currently in use and the &lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_highwater()&lt;/a&gt; returns the maximum instantaneous memory usage. Neither routine includes the overhead associated with the memory allocator. These routines are provided for use by the application. SQLite never invokes them itself. So if the application is providing its own memory allocation subsystem, it can omit these interfaces if desired.</source>
          <target state="translated">Эти интерфейсы могут использоваться приложением для отслеживания того, сколько памяти использует SQLite. В &lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_used ()&lt;/a&gt; подпрограмма возвращает количество байт памяти используемых в настоящее время , и &lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_highwater ()&lt;/a&gt; возвращает максимальное мгновенное использование памяти. Ни одна из подпрограмм не включает накладные расходы, связанные с распределителем памяти. Эти процедуры предназначены для использования приложением. SQLite никогда не вызывает их сам. Поэтому, если приложение предоставляет свою собственную подсистему распределения памяти, при желании оно может опустить эти интерфейсы.</target>
        </trans-unit>
        <trans-unit id="5e6bfb4cf13a4a1ec7a21d1345619d3a829697d4" translate="yes" xml:space="preserve">
          <source>These interfaces impose limits on the amount of heap memory that will be by all database connections within a single process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d867180f3b3d1ed5572faf6a624799c6449d787" translate="yes" xml:space="preserve">
          <source>These interfaces provide the same information as the &lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_VERSION&lt;/a&gt;, &lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_VERSION_NUMBER&lt;/a&gt;, and &lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_SOURCE_ID&lt;/a&gt; C preprocessor macros but are associated with the library instead of the header file. Cautious programmers might include assert() statements in their application to verify that values returned by these interfaces match the macros in the header, and thus ensure that the application is compiled with matching library and header files.</source>
          <target state="translated">Эти интерфейсы предоставляют ту же информацию , что и &lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;макросы&lt;/a&gt; препроцессора C &lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_VERSION&lt;/a&gt; , &lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_VERSION_NUMBER&lt;/a&gt; и SQLITE_SOURCE_ID, но связаны с библиотекой, а не с файлом заголовка. Осторожные программисты могут включать в свое приложение операторы assert (), чтобы убедиться, что значения, возвращаемые этими интерфейсами, совпадают с макросами в заголовке, и, таким образом, убедиться, что приложение скомпилировано с соответствующей библиотекой и файлами заголовков.</target>
        </trans-unit>
        <trans-unit id="7e7f85933d01fbbc2719e5dc64309e8e175f6d5d" translate="yes" xml:space="preserve">
          <source>These interfaces provide the same information as the &lt;a href=&quot;c_source_id&quot;&gt;SQLITE_VERSION&lt;/a&gt;, &lt;a href=&quot;c_source_id&quot;&gt;SQLITE_VERSION_NUMBER&lt;/a&gt;, and &lt;a href=&quot;c_source_id&quot;&gt;SQLITE_SOURCE_ID&lt;/a&gt; C preprocessor macros but are associated with the library instead of the header file. Cautious programmers might include assert() statements in their application to verify that values returned by these interfaces match the macros in the header, and thus ensure that the application is compiled with matching library and header files.</source>
          <target state="translated">Эти интерфейсы предоставляют ту же информацию , что и &lt;a href=&quot;c_source_id&quot;&gt;макросы&lt;/a&gt; препроцессора C &lt;a href=&quot;c_source_id&quot;&gt;SQLITE_VERSION&lt;/a&gt; , &lt;a href=&quot;c_source_id&quot;&gt;SQLITE_VERSION_NUMBER&lt;/a&gt; и SQLITE_SOURCE_ID, но связаны с библиотекой, а не с файлом заголовка. Осторожные программисты могут включать в свое приложение операторы assert (), чтобы убедиться, что значения, возвращаемые этими интерфейсами, совпадают с макросами в заголовке, и, таким образом, убедиться, что приложение скомпилировано с соответствующей библиотекой и файлами заголовков.</target>
        </trans-unit>
        <trans-unit id="8f3967be8dcb65457d2a35a639ddbcd4e8748853" translate="yes" xml:space="preserve">
          <source>These interfaces return the current status of an &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt; object.</source>
          <target state="translated">Эти интерфейсы возвращают текущий статус объекта &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9f4d86f27a761f3cf1b6a9d1b51464453bd7acc2" translate="yes" xml:space="preserve">
          <source>These interfaces return the current status of an &lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt; object.</source>
          <target state="translated">Эти интерфейсы возвращают текущий статус объекта &lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0bd4a9c1d8ef359db205ab90399688f58e57b40f" translate="yes" xml:space="preserve">
          <source>These interfces are provided for use by &lt;a href=&quot;../vfs#shim&quot;&gt;VFS shim&lt;/a&gt; implementations and are not useful outside of that context.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="edf2097b32647c30069fed117ef937baf26e2654" translate="yes" xml:space="preserve">
          <source>These interfces are provided for use by &lt;a href=&quot;vfs#shim&quot;&gt;VFS shim&lt;/a&gt; implementations and are not useful outside of that context.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1a8d7ae768abbd8bdb6f16b4e0e326ba78812f7" translate="yes" xml:space="preserve">
          <source>These macros are only available on Windows. They define the allowed values for the type argument to the &lt;a href=&quot;#sqlite3_win32_set_directory&quot;&gt;sqlite3_win32_set_directory&lt;/a&gt; interface.</source>
          <target state="translated">Эти макросы доступны только в Windows. Они определяют допустимые значения для аргумента типа для интерфейса &lt;a href=&quot;#sqlite3_win32_set_directory&quot;&gt;sqlite3_win32_set_directory&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a687dbdbbc158f7b1d8247c45af66df0ad45cf41" translate="yes" xml:space="preserve">
          <source>These macros are only available on Windows. They define the allowed values for the type argument to the &lt;a href=&quot;win32_set_directory&quot;&gt;sqlite3_win32_set_directory&lt;/a&gt; interface.</source>
          <target state="translated">Эти макросы доступны только в Windows. Они определяют допустимые значения для аргумента типа для интерфейса &lt;a href=&quot;win32_set_directory&quot;&gt;sqlite3_win32_set_directory&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a53b463320023e1da4e50fb5fb587f4bc7e0b044" translate="yes" xml:space="preserve">
          <source>These macros define the allowed values for the &lt;a href=&quot;#sqlite3_index_info&quot;&gt;sqlite3_index_info&lt;/a&gt;.aConstraint[].op field. Each value represents an operator that is part of a constraint term in the wHERE clause of a query that uses a &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="285af12f9b73f8c383619a138a0750effc7e59e8" translate="yes" xml:space="preserve">
          <source>These macros define the allowed values for the &lt;a href=&quot;index_info&quot;&gt;sqlite3_index_info&lt;/a&gt;.aConstraint[].op field. Each value represents an operator that is part of a constraint term in the wHERE clause of a query that uses a &lt;a href=&quot;../vtab&quot;&gt;virtual table&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8efdced9c4da4c580aa62b3a5a3c4685a1b1ed67" translate="yes" xml:space="preserve">
          <source>These macros define the various options to the &lt;a href=&quot;#sqlite3_vtab_config&quot;&gt;sqlite3_vtab_config()&lt;/a&gt; interface that &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; implementations can use to customize and optimize their behavior.</source>
          <target state="translated">Эти макросы определяют различные параметры интерфейса &lt;a href=&quot;#sqlite3_vtab_config&quot;&gt;sqlite3_vtab_config (),&lt;/a&gt; которые реализации &lt;a href=&quot;vtab&quot;&gt;виртуальных таблиц&lt;/a&gt; могут использовать для настройки и оптимизации своего поведения.</target>
        </trans-unit>
        <trans-unit id="648697ac8bc614b007ee6a86dba8449e42be0af2" translate="yes" xml:space="preserve">
          <source>These macros define the various options to the &lt;a href=&quot;vtab_config&quot;&gt;sqlite3_vtab_config()&lt;/a&gt; interface that &lt;a href=&quot;../vtab&quot;&gt;virtual table&lt;/a&gt; implementations can use to customize and optimize their behavior.</source>
          <target state="translated">Эти макросы определяют различные параметры интерфейса &lt;a href=&quot;vtab_config&quot;&gt;sqlite3_vtab_config (),&lt;/a&gt; которые реализации &lt;a href=&quot;../vtab&quot;&gt;виртуальных таблиц&lt;/a&gt; могут использовать для настройки и оптимизации своего поведения.</target>
        </trans-unit>
        <trans-unit id="e2c086e3788cfb99a6897d54171eed03d73b01e8" translate="yes" xml:space="preserve">
          <source>These macros defined the allowed values for the &lt;a href=&quot;#sqlite3_index_info&quot;&gt;sqlite3_index_info&lt;/a&gt;.aConstraint[].op field. Each value represents an operator that is part of a constraint term in the wHERE clause of a query that uses a &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt;.</source>
          <target state="translated">Эти макросы определяют допустимые значения для поля &lt;a href=&quot;#sqlite3_index_info&quot;&gt;sqlite3_index_info&lt;/a&gt; .aConstraint []. Op. Каждое значение представляет собой оператор, являющийся частью условия ограничения в предложении wHERE запроса, использующего &lt;a href=&quot;vtab&quot;&gt;виртуальную таблицу&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fa39882fd7522d6ac624eca8d9d3a80dde9e04fa" translate="yes" xml:space="preserve">
          <source>These macros defined the allowed values for the &lt;a href=&quot;index_info&quot;&gt;sqlite3_index_info&lt;/a&gt;.aConstraint[].op field. Each value represents an operator that is part of a constraint term in the wHERE clause of a query that uses a &lt;a href=&quot;../vtab&quot;&gt;virtual table&lt;/a&gt;.</source>
          <target state="translated">Эти макросы определяют допустимые значения для поля &lt;a href=&quot;index_info&quot;&gt;sqlite3_index_info&lt;/a&gt; .aConstraint []. Op. Каждое значение представляет собой оператор, являющийся частью условия ограничения в предложении wHERE запроса, использующего &lt;a href=&quot;../vtab&quot;&gt;виртуальную таблицу&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cef481ad6fa7db18e075879f04ed74ee515d6f8c" translate="yes" xml:space="preserve">
          <source>These methods do not return a result code. If an error occurs, that fact is recorded in the &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt; object and can be recovered by a subsequent call to &lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_errcode(X)&lt;/a&gt;.</source>
          <target state="translated">Эти методы не возвращают код результата. Если возникает ошибка, этот факт записывается в объект &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt; и может быть восстановлен последующим вызовом &lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_errcode (X)&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cf9638bb05ccc82e92352f4c91e50e88181ed764" translate="yes" xml:space="preserve">
          <source>These methods do not return a result code. If an error occurs, that fact is recorded in the &lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt; object and can be recovered by a subsequent call to &lt;a href=&quot;str_errcode&quot;&gt;sqlite3_str_errcode(X)&lt;/a&gt;.</source>
          <target state="translated">Эти методы не возвращают код результата. Если возникает ошибка, этот факт записывается в объект &lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt; и может быть восстановлен последующим вызовом &lt;a href=&quot;str_errcode&quot;&gt;sqlite3_str_errcode (X)&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c8abab119f90d9828a9a200b591657ce6dda56d7" translate="yes" xml:space="preserve">
          <source>These methods provide the virtual table implementation an opportunity to implement nested transactions. They are always optional and will only be called in SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_7.html&quot;&gt;version 3.7.7&lt;/a&gt; (2011-06-23) and later.</source>
          <target state="translated">Эти методы предоставляют реализации виртуальной таблицы возможность реализовать вложенные транзакции. Они всегда необязательны и будут вызываться только в SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_7.html&quot;&gt;версии 3.7.7&lt;/a&gt; (2011-06-23) и более поздних.</target>
        </trans-unit>
        <trans-unit id="46bde550196023cbdbd528e902d936fa4e39c988" translate="yes" xml:space="preserve">
          <source>These operations are described in detail in section</source>
          <target state="translated">Эти операции подробно описаны в разделе</target>
        </trans-unit>
        <trans-unit id="8a581a47ac4eaa711b3f420b4ba4930e1f71a44b" translate="yes" xml:space="preserve">
          <source>These options are obsolete and should not be used by new code. They are retained for backwards compatibility but are now no-ops.</source>
          <target state="translated">Эти опции устарели и не должны использоваться новым кодом.Они сохранены для обратной совместимости,но теперь не используются.</target>
        </trans-unit>
        <trans-unit id="559388a0d9af9b6cbe52d397cd3542b5b1c78fdd" translate="yes" xml:space="preserve">
          <source>These pages are intended to be precise and detailed specification. For a tutorial introduction, see instead:</source>
          <target state="translated">Эти страницы предназначены для точной и подробной спецификации.Введение в учебное пособие см.вместо этого:</target>
        </trans-unit>
        <trans-unit id="6abb0e63f8d45e8d38ed1d32dbd7bc6804598807" translate="yes" xml:space="preserve">
          <source>These parameters and their meanings are subject to change without notice. These values are for testing purposes only. Applications should not use any of these parameters or the &lt;a href=&quot;#sqlite3_test_control&quot;&gt;sqlite3_test_control()&lt;/a&gt; interface.</source>
          <target state="translated">Эти параметры и их значения могут быть изменены без предварительного уведомления. Эти значения предназначены только для тестирования. Приложения не должны использовать ни один из этих параметров или интерфейс &lt;a href=&quot;#sqlite3_test_control&quot;&gt;sqlite3_test_control ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="572f36fd8fcb5b2b9a0c163c10706d2d9c69fa95" translate="yes" xml:space="preserve">
          <source>These parameters and their meanings are subject to change without notice. These values are for testing purposes only. Applications should not use any of these parameters or the &lt;a href=&quot;test_control&quot;&gt;sqlite3_test_control()&lt;/a&gt; interface.</source>
          <target state="translated">Эти параметры и их значения могут быть изменены без предварительного уведомления. Эти значения предназначены только для тестирования. Приложения не должны использовать ни один из этих параметров или интерфейс &lt;a href=&quot;test_control&quot;&gt;sqlite3_test_control ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f8a0b86303fc051c5fd0870031ccb3460d4da0f7" translate="yes" xml:space="preserve">
          <source>These pragmas are only available in builds using non-standard compile-time options.</source>
          <target state="translated">Эти прагмы доступны только в сборках,использующих нестандартные опции времени компиляции.</target>
        </trans-unit>
        <trans-unit id="7d1b3b12b0e1a81b824764e591a7c4f5ca02302c" translate="yes" xml:space="preserve">
          <source>These pragmas are used for testing SQLite and are not recommended for use in application programs.</source>
          <target state="translated">Эти прагмы используются для тестирования SQLite и не рекомендуются для использования в прикладных программах.</target>
        </trans-unit>
        <trans-unit id="995493d489d94b8be4b015e9bc63ccee86968693" translate="yes" xml:space="preserve">
          <source>These preprocessor macros define integer codes that name counter values associated with the &lt;a href=&quot;#sqlite3_stmt_status&quot;&gt;sqlite3_stmt_status()&lt;/a&gt; interface. The meanings of the various counters are as follows:</source>
          <target state="translated">Эти макросы препроцессора определяют целочисленные коды, которые называют значения счетчиков, связанных с интерфейсом &lt;a href=&quot;#sqlite3_stmt_status&quot;&gt;sqlite3_stmt_status ()&lt;/a&gt; . Значения различных счетчиков следующие:</target>
        </trans-unit>
        <trans-unit id="45f1f746bd34bc0ce563d83def09a125c5bf05c1" translate="yes" xml:space="preserve">
          <source>These preprocessor macros define integer codes that name counter values associated with the &lt;a href=&quot;stmt_status&quot;&gt;sqlite3_stmt_status()&lt;/a&gt; interface. The meanings of the various counters are as follows:</source>
          <target state="translated">Эти макросы препроцессора определяют целочисленные коды, которые называют значения счетчиков, связанных с интерфейсом &lt;a href=&quot;stmt_status&quot;&gt;sqlite3_stmt_status ()&lt;/a&gt; . Значения различных счетчиков следующие:</target>
        </trans-unit>
        <trans-unit id="1d52a4f9ee56f3e7a3ab55d8ba1b413dd3cccc36" translate="yes" xml:space="preserve">
          <source>These routines are available to &lt;a href=&quot;../vfs&quot;&gt;custom VFS implementations&lt;/a&gt; for translating filenames between the main database file, the journal file, and the WAL file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c705c2e0cd7b6320d8503e4412e5e99c6ba613d2" translate="yes" xml:space="preserve">
          <source>These routines are available to &lt;a href=&quot;vfs&quot;&gt;custom VFS implementations&lt;/a&gt; for translating filenames between the main database file, the journal file, and the WAL file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2638c6822db8d54f4bd5ddffbdd3a5cd063ac265" translate="yes" xml:space="preserve">
          <source>These routines are deprecated. Use the &lt;a href=&quot;#sqlite3_trace_v2&quot;&gt;sqlite3_trace_v2()&lt;/a&gt; interface instead of the routines described here.</source>
          <target state="translated">Эти подпрограммы устарели. Используйте интерфейс &lt;a href=&quot;#sqlite3_trace_v2&quot;&gt;sqlite3_trace_v2 ()&lt;/a&gt; вместо описанных здесь подпрограмм.</target>
        </trans-unit>
        <trans-unit id="79eec12a37e6ba999a536376578f3d7f9c0f472e" translate="yes" xml:space="preserve">
          <source>These routines are deprecated. Use the &lt;a href=&quot;trace_v2&quot;&gt;sqlite3_trace_v2()&lt;/a&gt; interface instead of the routines described here.</source>
          <target state="translated">Эти подпрограммы устарели. Используйте интерфейс &lt;a href=&quot;trace_v2&quot;&gt;sqlite3_trace_v2 ()&lt;/a&gt; вместо описанных здесь подпрограмм.</target>
        </trans-unit>
        <trans-unit id="88da5c4ccf3f13c2b355a0a8cea0eee5123dacc4" translate="yes" xml:space="preserve">
          <source>These routines are used by the xFunc or xFinal callbacks that implement SQL functions and aggregates. See &lt;a href=&quot;#sqlite3_create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_create_function&quot;&gt;sqlite3_create_function16()&lt;/a&gt; for additional information.</source>
          <target state="translated">Эти процедуры используются обратными вызовами xFunc или xFinal, которые реализуют функции и агрегаты SQL. См. &lt;a href=&quot;#sqlite3_create_function&quot;&gt;Sqlite3_create_function ()&lt;/a&gt; и &lt;a href=&quot;#sqlite3_create_function&quot;&gt;sqlite3_create_function16 ()&lt;/a&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="9ac11b77df30733555a1b785ff3b36747aa22425" translate="yes" xml:space="preserve">
          <source>These routines are used by the xFunc or xFinal callbacks that implement SQL functions and aggregates. See &lt;a href=&quot;create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt; and &lt;a href=&quot;create_function&quot;&gt;sqlite3_create_function16()&lt;/a&gt; for additional information.</source>
          <target state="translated">Эти процедуры используются обратными вызовами xFunc или xFinal, которые реализуют функции и агрегаты SQL. См. &lt;a href=&quot;create_function&quot;&gt;Sqlite3_create_function ()&lt;/a&gt; и &lt;a href=&quot;create_function&quot;&gt;sqlite3_create_function16 ()&lt;/a&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="a645fc58a9b80b5d58439099cf576c18383cf676" translate="yes" xml:space="preserve">
          <source>These routines are used to register a new &lt;a href=&quot;#sqlite3_module&quot;&gt;virtual table module&lt;/a&gt; name. Module names must be registered before creating a new &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; using the module and before using a preexisting &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; for the module.</source>
          <target state="translated">Эти процедуры используются для регистрации нового имени &lt;a href=&quot;#sqlite3_module&quot;&gt;модуля виртуальной таблицы&lt;/a&gt; . Имена модулей должны быть зарегистрированы перед созданием новой &lt;a href=&quot;vtab&quot;&gt;виртуальной таблицы&lt;/a&gt; с помощью модуля и перед использованием существующей &lt;a href=&quot;vtab&quot;&gt;виртуальной таблицы&lt;/a&gt; для модуля.</target>
        </trans-unit>
        <trans-unit id="947d0c2cba6cd0b29a7af62bdccba7526d0c92de" translate="yes" xml:space="preserve">
          <source>These routines are used to register a new &lt;a href=&quot;module&quot;&gt;virtual table module&lt;/a&gt; name. Module names must be registered before creating a new &lt;a href=&quot;../vtab&quot;&gt;virtual table&lt;/a&gt; using the module and before using a preexisting &lt;a href=&quot;../vtab&quot;&gt;virtual table&lt;/a&gt; for the module.</source>
          <target state="translated">Эти процедуры используются для регистрации нового имени &lt;a href=&quot;module&quot;&gt;модуля виртуальной таблицы&lt;/a&gt; . Имена модулей должны быть зарегистрированы перед созданием новой &lt;a href=&quot;../vtab&quot;&gt;виртуальной таблицы&lt;/a&gt; с помощью модуля и перед использованием существующей &lt;a href=&quot;../vtab&quot;&gt;виртуальной таблицы&lt;/a&gt; для модуля.</target>
        </trans-unit>
        <trans-unit id="52698fd9d4ddf179ee30cea3431e78d27c345761" translate="yes" xml:space="preserve">
          <source>These routines are useful during command-line input to determine if the currently entered text seems to form a complete SQL statement or if additional input is needed before sending the text into SQLite for parsing. These routines return 1 if the input string appears to be a complete SQL statement. A statement is judged to be complete if it ends with a semicolon token and is not a prefix of a well-formed CREATE TRIGGER statement. Semicolons that are embedded within string literals or quoted identifier names or comments are not independent tokens (they are part of the token in which they are embedded) and thus do not count as a statement terminator. Whitespace and comments that follow the final semicolon are ignored.</source>
          <target state="translated">Эти процедуры полезны во время ввода из командной строки,чтобы определить,кажется ли введенный в данный момент текст полным SQL-оператором,или необходим дополнительный ввод перед отправкой текста на SQLite для разбора.Эти процедуры возвращают 1,если входная строка выглядит как полный SQL-оператор.Оператор считается полным,если он заканчивается точкой с запятой и не является префиксом хорошо сформированного оператора CREATE TRIGGER.Точки с запятой,которые встраиваются в строковые литералы или в кавычки имен идентификаторов или комментариев,не являются независимыми маркерами (они являются частью маркера,в который они встраиваются)и,таким образом,не считаются терминатором оператора.Пробельные символы и комментарии,следующие за конечной точкой с запятой,игнорируются.</target>
        </trans-unit>
        <trans-unit id="1eee207918e3686e6a6a0aff77d6f8f4cd324299" translate="yes" xml:space="preserve">
          <source>These routines are work-alikes of the &quot;printf()&quot; family of functions from the standard C library. These routines understand most of the common formatting options from the standard library printf() plus some additional non-standard formats (&lt;a href=&quot;../printf#percentq&quot;&gt;%q&lt;/a&gt;, &lt;a href=&quot;../printf#percentq&quot;&gt;%Q&lt;/a&gt;, &lt;a href=&quot;../printf#percentw&quot;&gt;%w&lt;/a&gt;, and &lt;a href=&quot;../printf#percentz&quot;&gt;%z&lt;/a&gt;). See the &lt;a href=&quot;../printf&quot;&gt;built-in printf()&lt;/a&gt; documentation for details.</source>
          <target state="translated">Эти подпрограммы являются аналогами семейства функций printf () из стандартной библиотеки C. Эти подпрограммы понимают большинство общих параметров форматирования из стандартной библиотеки printf () плюс некоторые дополнительные нестандартные форматы ( &lt;a href=&quot;../printf#percentq&quot;&gt;% q&lt;/a&gt; , &lt;a href=&quot;../printf#percentq&quot;&gt;% Q&lt;/a&gt; , &lt;a href=&quot;../printf#percentw&quot;&gt;% w&lt;/a&gt; и &lt;a href=&quot;../printf#percentz&quot;&gt;% z&lt;/a&gt; ). Подробнее см. &lt;a href=&quot;../printf&quot;&gt;Встроенную&lt;/a&gt; документацию printf () .</target>
        </trans-unit>
        <trans-unit id="5d6ce4df9ede9c6a9b8604117d8eeec42326da1e" translate="yes" xml:space="preserve">
          <source>These routines are work-alikes of the &quot;printf()&quot; family of functions from the standard C library. These routines understand most of the common formatting options from the standard library printf() plus some additional non-standard formats (&lt;a href=&quot;printf#percentq&quot;&gt;%q&lt;/a&gt;, &lt;a href=&quot;printf#percentq&quot;&gt;%Q&lt;/a&gt;, &lt;a href=&quot;printf#percentw&quot;&gt;%w&lt;/a&gt;, and &lt;a href=&quot;printf#percentz&quot;&gt;%z&lt;/a&gt;). See the &lt;a href=&quot;printf&quot;&gt;built-in printf()&lt;/a&gt; documentation for details.</source>
          <target state="translated">Эти подпрограммы являются аналогами семейства функций printf () из стандартной библиотеки C. Эти подпрограммы понимают большинство общих параметров форматирования из стандартной библиотеки printf () плюс некоторые дополнительные нестандартные форматы ( &lt;a href=&quot;printf#percentq&quot;&gt;% q&lt;/a&gt; , &lt;a href=&quot;printf#percentq&quot;&gt;% Q&lt;/a&gt; , &lt;a href=&quot;printf#percentw&quot;&gt;% w&lt;/a&gt; и &lt;a href=&quot;printf#percentz&quot;&gt;% z&lt;/a&gt; ). Подробнее см. &lt;a href=&quot;printf&quot;&gt;Встроенную&lt;/a&gt; документацию printf () .</target>
        </trans-unit>
        <trans-unit id="d695b797410a06f75931294f55b67ec9c439fcc7" translate="yes" xml:space="preserve">
          <source>These routines do not parse the SQL statements thus will not detect syntactically incorrect SQL.</source>
          <target state="translated">Эти процедуры не анализируют SQL операторы,таким образом,не будут обнаруживать синтаксически неправильный SQL.</target>
        </trans-unit>
        <trans-unit id="7531da5fcda9441742ab989cffc3d5a7ea0da49d" translate="yes" xml:space="preserve">
          <source>These routines extract type, size, and content information from &lt;a href=&quot;#sqlite3_value&quot;&gt;protected sqlite3_value&lt;/a&gt; objects. Protected sqlite3_value objects are used to pass parameter information into implementation of &lt;a href=&quot;#sqlite3_create_function&quot;&gt;application-defined SQL functions&lt;/a&gt; and &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt;.</source>
          <target state="translated">Эти процедуры извлекают информацию о типе, размере и содержимом из &lt;a href=&quot;#sqlite3_value&quot;&gt;защищенных&lt;/a&gt; объектов sqlite3_value . Защищенные объекты sqlite3_value используются для передачи информации о параметрах в реализацию &lt;a href=&quot;#sqlite3_create_function&quot;&gt;определяемых приложением функций SQL&lt;/a&gt; и &lt;a href=&quot;vtab&quot;&gt;виртуальных таблиц&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="780ed181ddbb53bd0cd75f887c1efe5a712dae77" translate="yes" xml:space="preserve">
          <source>These routines extract type, size, and content information from &lt;a href=&quot;#sqlite3_value&quot;&gt;protected sqlite3_value&lt;/a&gt; objects. Protected sqlite3_value objects are used to pass parameter information into the functions that implement &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt; and &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c79baca34267204233cef0f72fa563f702ea3b9b" translate="yes" xml:space="preserve">
          <source>These routines extract type, size, and content information from &lt;a href=&quot;value&quot;&gt;protected sqlite3_value&lt;/a&gt; objects. Protected sqlite3_value objects are used to pass parameter information into implementation of &lt;a href=&quot;create_function&quot;&gt;application-defined SQL functions&lt;/a&gt; and &lt;a href=&quot;../vtab&quot;&gt;virtual tables&lt;/a&gt;.</source>
          <target state="translated">Эти процедуры извлекают информацию о типе, размере и содержимом из &lt;a href=&quot;value&quot;&gt;защищенных&lt;/a&gt; объектов sqlite3_value . Защищенные объекты sqlite3_value используются для передачи информации о параметрах в реализацию &lt;a href=&quot;create_function&quot;&gt;определяемых приложением функций SQL&lt;/a&gt; и &lt;a href=&quot;../vtab&quot;&gt;виртуальных таблиц&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="080e4929a8edf88eab58f3131b66975c555d313b" translate="yes" xml:space="preserve">
          <source>These routines extract type, size, and content information from &lt;a href=&quot;value&quot;&gt;protected sqlite3_value&lt;/a&gt; objects. Protected sqlite3_value objects are used to pass parameter information into the functions that implement &lt;a href=&quot;../appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt; and &lt;a href=&quot;../vtab&quot;&gt;virtual tables&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6356562f1a7ea967d47e4aa35dbd596cfeb17ce" translate="yes" xml:space="preserve">
          <source>These routines must be called from the same thread as the SQL function that supplied the &lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value*&lt;/a&gt; parameters.</source>
          <target state="translated">Эти подпрограммы должны вызываться из того же потока, что и функция SQL, предоставившая параметры &lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value *&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ea74f3659cddc5ce0c6b4fa5c6b8b6ea6fcf9692" translate="yes" xml:space="preserve">
          <source>These routines must be called from the same thread as the SQL function that supplied the &lt;a href=&quot;value&quot;&gt;sqlite3_value*&lt;/a&gt; parameters.</source>
          <target state="translated">Эти подпрограммы должны вызываться из того же потока, что и функция SQL, предоставившая параметры &lt;a href=&quot;value&quot;&gt;sqlite3_value *&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a54537ed3c843a1d7c75c98c519dd12715dd5904" translate="yes" xml:space="preserve">
          <source>These routines must be called from the same thread in which the SQL function is running.</source>
          <target state="translated">Эти подпрограммы должны вызываться из того же самого потока,в котором запущена функция SQL.</target>
        </trans-unit>
        <trans-unit id="aea4f6b4200dc559c39531008b13c73c4dca39ea" translate="yes" xml:space="preserve">
          <source>These routines open an SQLite database file as specified by the filename argument. The filename argument is interpreted as UTF-8 for sqlite3_open() and sqlite3_open_v2() and as UTF-16 in the native byte order for sqlite3_open16(). A &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; handle is usually returned in *ppDb, even if an error occurs. The only exception is that if SQLite is unable to allocate memory to hold the &lt;a href=&quot;#sqlite3&quot;&gt;sqlite3&lt;/a&gt; object, a NULL will be written into *ppDb instead of a pointer to the &lt;a href=&quot;#sqlite3&quot;&gt;sqlite3&lt;/a&gt; object. If the database is opened (and/or created) successfully, then &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; is returned. Otherwise an &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; is returned. The &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errmsg()&lt;/a&gt; or &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errmsg16()&lt;/a&gt; routines can be used to obtain an English language description of the error following a failure of any of the sqlite3_open() routines.</source>
          <target state="translated">Эти процедуры открывают файл базы данных SQLite, как указано в аргументе имени файла. Аргумент имени файла интерпретируется как UTF-8 для sqlite3_open () и sqlite3_open_v2 () и как UTF-16 в собственном порядке байтов для sqlite3_open16 (). &lt;a href=&quot;#sqlite3&quot;&gt;Соединение с базой данных&lt;/a&gt; ручка обычно возвращается в * БДППАХ, даже если произошла ошибка. Единственное исключением является то , что если SQLite не может выделить память для хранения &lt;a href=&quot;#sqlite3&quot;&gt;sqlite3&lt;/a&gt; объекта, то NULL будет записано в * БДППЫ вместо указателя на &lt;a href=&quot;#sqlite3&quot;&gt;sqlite3&lt;/a&gt; объект. Если база данных открыта (и / или создана) успешно, то возвращается &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; . В противном случае возвращается &lt;a href=&quot;rescode&quot;&gt;код ошибки&lt;/a&gt; . &lt;a href=&quot;#sqlite3_errcode&quot;&gt;Sqlite3_errmsg ()&lt;/a&gt; или &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errmsg16 ()&lt;/a&gt;подпрограммы могут использоваться для получения описания ошибки на английском языке после сбоя любой из подпрограмм sqlite3_open ().</target>
        </trans-unit>
        <trans-unit id="24814302ce83d408ddc70164757005571a98a1af" translate="yes" xml:space="preserve">
          <source>These routines open an SQLite database file as specified by the filename argument. The filename argument is interpreted as UTF-8 for sqlite3_open() and sqlite3_open_v2() and as UTF-16 in the native byte order for sqlite3_open16(). A &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; handle is usually returned in *ppDb, even if an error occurs. The only exception is that if SQLite is unable to allocate memory to hold the &lt;a href=&quot;sqlite3&quot;&gt;sqlite3&lt;/a&gt; object, a NULL will be written into *ppDb instead of a pointer to the &lt;a href=&quot;sqlite3&quot;&gt;sqlite3&lt;/a&gt; object. If the database is opened (and/or created) successfully, then &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; is returned. Otherwise an &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; is returned. The &lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg()&lt;/a&gt; or &lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg16()&lt;/a&gt; routines can be used to obtain an English language description of the error following a failure of any of the sqlite3_open() routines.</source>
          <target state="translated">Эти процедуры открывают файл базы данных SQLite, как указано в аргументе имени файла. Аргумент имени файла интерпретируется как UTF-8 для sqlite3_open () и sqlite3_open_v2 () и как UTF-16 в собственном порядке байтов для sqlite3_open16 (). &lt;a href=&quot;sqlite3&quot;&gt;Соединение с базой данных&lt;/a&gt; ручка обычно возвращается в * БДППАХ, даже если произошла ошибка. Единственное исключением является то , что если SQLite не может выделить память для хранения &lt;a href=&quot;sqlite3&quot;&gt;sqlite3&lt;/a&gt; объекта, то NULL будет записано в * БДППЫ вместо указателя на &lt;a href=&quot;sqlite3&quot;&gt;sqlite3&lt;/a&gt; объект. Если база данных открыта (и / или создана) успешно, то возвращается &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; . В противном случае возвращается &lt;a href=&quot;../rescode&quot;&gt;код ошибки&lt;/a&gt; . &lt;a href=&quot;errcode&quot;&gt;Sqlite3_errmsg ()&lt;/a&gt; или &lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg16 ()&lt;/a&gt;подпрограммы могут использоваться для получения описания ошибки на английском языке после сбоя любой из подпрограмм sqlite3_open ().</target>
        </trans-unit>
        <trans-unit id="4cb0a6ed5fd628702f759fa88fc57a08522ef219" translate="yes" xml:space="preserve">
          <source>These routines provide a means to determine the database, table, and table column that is the origin of a particular result column in &lt;a href=&quot;../lang_select&quot;&gt;SELECT&lt;/a&gt; statement. The name of the database or table or column can be returned as either a UTF-8 or UTF-16 string. The _database_ routines return the database name, the _table_ routines return the table name, and the origin_ routines return the column name. The returned string is valid until the &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; is destroyed using &lt;a href=&quot;finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt; or until the statement is automatically reprepared by the first call to &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; for a particular run or until the same information is requested again in a different encoding.</source>
          <target state="translated">Эти процедуры предоставляют средства для определения базы данных, таблицы и столбца таблицы, который является источником определенного столбца результата в &lt;a href=&quot;../lang_select&quot;&gt;операторе SELECT&lt;/a&gt; . Имя базы данных, таблицы или столбца может быть возвращено как строка UTF-8 или UTF-16. Подпрограммы _database_ возвращают имя базы данных, подпрограммы _table_ возвращают имя таблицы, а подпрограммы origin_ возвращают имя столбца. Возвращенная строка действительна до тех пор, пока &lt;a href=&quot;stmt&quot;&gt;подготовленный оператор не&lt;/a&gt; будет уничтожен с помощью &lt;a href=&quot;finalize&quot;&gt;sqlite3_finalize ()&lt;/a&gt; или пока оператор не будет автоматически представлен первым вызовом &lt;a href=&quot;step&quot;&gt;sqlite3_step ()&lt;/a&gt; для определенного запуска или пока та же информация не будет запрошена снова в другой кодировке.</target>
        </trans-unit>
        <trans-unit id="6747cec9622a96ae1091ed2adc2461d962bf2710" translate="yes" xml:space="preserve">
          <source>These routines provide a means to determine the database, table, and table column that is the origin of a particular result column in &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statement. The name of the database or table or column can be returned as either a UTF-8 or UTF-16 string. The _database_ routines return the database name, the _table_ routines return the table name, and the origin_ routines return the column name. The returned string is valid until the &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; is destroyed using &lt;a href=&quot;#sqlite3_finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt; or until the statement is automatically reprepared by the first call to &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; for a particular run or until the same information is requested again in a different encoding.</source>
          <target state="translated">Эти процедуры предоставляют средства для определения базы данных, таблицы и столбца таблицы, который является источником определенного столбца результата в &lt;a href=&quot;lang_select&quot;&gt;операторе SELECT&lt;/a&gt; . Имя базы данных, таблицы или столбца может быть возвращено как строка UTF-8 или UTF-16. Подпрограммы _database_ возвращают имя базы данных, подпрограммы _table_ возвращают имя таблицы, а подпрограммы origin_ возвращают имя столбца. Возвращенная строка действительна до тех пор, пока &lt;a href=&quot;#sqlite3_stmt&quot;&gt;подготовленный оператор не&lt;/a&gt; будет уничтожен с помощью &lt;a href=&quot;#sqlite3_finalize&quot;&gt;sqlite3_finalize ()&lt;/a&gt; или пока оператор не будет автоматически представлен первым вызовом &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step ()&lt;/a&gt; для определенного запуска или пока та же информация не будет запрошена снова в другой кодировке.</target>
        </trans-unit>
        <trans-unit id="723ec7b5764e01bb470a171ac81db6f1bccacf01" translate="yes" xml:space="preserve">
          <source>These routines provide access to the set of SQL language keywords recognized by SQLite. Applications can uses these routines to determine whether or not a specific identifier needs to be escaped (for example, by enclosing in double-quotes) so as not to confuse the parser.</source>
          <target state="translated">Эти процедуры обеспечивают доступ к набору ключевых слов языка SQL,распознаваемых SQLite.Приложения могут использовать эти подпрограммы для определения необходимости экранирования конкретного идентификатора (например,путем заключения его в двойные кавычки),чтобы не запутать синтаксический анализатор.</target>
        </trans-unit>
        <trans-unit id="c63151a5ae56c785b897a0325e0c6f8aa37ea7fb" translate="yes" xml:space="preserve">
          <source>These routines provide direct access to the version of the Wagner edit-distance function that allows for application-defined weights on edit operations. The first two forms of this function compare pattern P against word W and return the edit distance. In the first function, the langid is assumed to be 0 and in the second, the langid is given by the L parameter. The third form of this function reloads edit distance coefficients from the table named by T.</source>
          <target state="translated">Эти процедуры обеспечивают прямой доступ к версии функции расстояния редактирования Вагнера,которая позволяет применять определяемые приложением веса при операциях редактирования.Первые две формы этой функции сравнивают деталь P со словом W и возвращают расстояние редактирования.В первой функции предполагается,что расстояние принимается равным 0,а во второй-что расстояние задается параметром L.Третья форма этой функции перезагружает коэффициенты расстояния редактирования из таблицы с именем T.</target>
        </trans-unit>
        <trans-unit id="6ece6463ac2989d7eff64fecae9f2305cb234cc2" translate="yes" xml:space="preserve">
          <source>These routines register callback functions that can be used for tracing and profiling the execution of SQL statements.</source>
          <target state="translated">Эти процедуры регистрируют функции обратного вызова,которые могут быть использованы для трассировки и профилирования выполнения SQL-операторов.</target>
        </trans-unit>
        <trans-unit id="40a118423314c412a0ead5a2681ebf518ed77f67" translate="yes" xml:space="preserve">
          <source>These routines return 0 if the statement is incomplete. If a memory allocation fails, then SQLITE_NOMEM is returned.</source>
          <target state="translated">Эти процедуры возвращают 0,если утверждение является неполным.Если выделение памяти не удается,возвращается SQLITE_NOMEM.</target>
        </trans-unit>
        <trans-unit id="324c17666cfb5119bcfea9a10a94bbaee6b00643" translate="yes" xml:space="preserve">
          <source>These routines return information about a single column of the current result row of a query. In every case the first argument is a pointer to the &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; that is being evaluated (the &lt;a href=&quot;#sqlite3_stmt&quot;&gt;sqlite3_stmt*&lt;/a&gt; that was returned from &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; or one of its variants) and the second argument is the index of the column for which information should be returned. The leftmost column of the result set has the index 0. The number of columns in the result can be determined using &lt;a href=&quot;#sqlite3_column_count&quot;&gt;sqlite3_column_count()&lt;/a&gt;.</source>
          <target state="translated">Эти подпрограммы возвращают информацию об одном столбце текущей строки результатов запроса. В каждом случае первый аргумент - это указатель на &lt;a href=&quot;#sqlite3_stmt&quot;&gt;подготовленный оператор&lt;/a&gt; , который оценивается ( &lt;a href=&quot;#sqlite3_stmt&quot;&gt;sqlite3_stmt *,&lt;/a&gt; который был возвращен из &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; или одного из его вариантов), а второй аргумент - это индекс столбца, для которого должна быть возвращена информация. . Самый левый столбец набора результатов имеет индекс 0. Количество столбцов в результате можно определить с помощью &lt;a href=&quot;#sqlite3_column_count&quot;&gt;sqlite3_column_count ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5435456a1f2380e65f87b371b45464ea838877ae" translate="yes" xml:space="preserve">
          <source>These routines return information about a single column of the current result row of a query. In every case the first argument is a pointer to the &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; that is being evaluated (the &lt;a href=&quot;stmt&quot;&gt;sqlite3_stmt*&lt;/a&gt; that was returned from &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; or one of its variants) and the second argument is the index of the column for which information should be returned. The leftmost column of the result set has the index 0. The number of columns in the result can be determined using &lt;a href=&quot;column_count&quot;&gt;sqlite3_column_count()&lt;/a&gt;.</source>
          <target state="translated">Эти подпрограммы возвращают информацию об одном столбце текущей строки результатов запроса. В каждом случае первый аргумент - это указатель на &lt;a href=&quot;stmt&quot;&gt;подготовленный оператор&lt;/a&gt; , который оценивается ( &lt;a href=&quot;stmt&quot;&gt;sqlite3_stmt *,&lt;/a&gt; который был возвращен из &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; или одного из его вариантов), а второй аргумент - это индекс столбца, для которого должна быть возвращена информация. . Самый левый столбец набора результатов имеет индекс 0. Количество столбцов в результате можно определить с помощью &lt;a href=&quot;column_count&quot;&gt;sqlite3_column_count ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="86c424b8734fe7ddecb01d35115c043c61c06f29" translate="yes" xml:space="preserve">
          <source>These routines return the name assigned to a particular column in the result set of a &lt;a href=&quot;../lang_select&quot;&gt;SELECT&lt;/a&gt; statement. The sqlite3_column_name() interface returns a pointer to a zero-terminated UTF-8 string and sqlite3_column_name16() returns a pointer to a zero-terminated UTF-16 string. The first parameter is the &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; that implements the &lt;a href=&quot;../lang_select&quot;&gt;SELECT&lt;/a&gt; statement. The second parameter is the column number. The leftmost column is number 0.</source>
          <target state="translated">Эти подпрограммы возвращают имя, присвоенное конкретному столбцу в наборе результатов &lt;a href=&quot;../lang_select&quot;&gt;оператора SELECT&lt;/a&gt; . Интерфейс sqlite3_column_name () возвращает указатель на строку UTF-8 с завершающим нулем, а sqlite3_column_name16 () возвращает указатель на строку UTF-16 с завершающим нулем. Первый параметр - это &lt;a href=&quot;stmt&quot;&gt;подготовленный оператор&lt;/a&gt; , реализующий &lt;a href=&quot;../lang_select&quot;&gt;оператор SELECT&lt;/a&gt; . Второй параметр - это номер столбца. Крайний левый столбец - номер 0.</target>
        </trans-unit>
        <trans-unit id="c92c0a5a51a4b6415e4465e481831e591f5adbb3" translate="yes" xml:space="preserve">
          <source>These routines return the name assigned to a particular column in the result set of a &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statement. The sqlite3_column_name() interface returns a pointer to a zero-terminated UTF-8 string and sqlite3_column_name16() returns a pointer to a zero-terminated UTF-16 string. The first parameter is the &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; that implements the &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statement. The second parameter is the column number. The leftmost column is number 0.</source>
          <target state="translated">Эти подпрограммы возвращают имя, присвоенное конкретному столбцу в наборе результатов &lt;a href=&quot;lang_select&quot;&gt;оператора SELECT&lt;/a&gt; . Интерфейс sqlite3_column_name () возвращает указатель на строку UTF-8 с завершающим нулем, а sqlite3_column_name16 () возвращает указатель на строку UTF-16 с завершающим нулем. Первый параметр - это &lt;a href=&quot;#sqlite3_stmt&quot;&gt;подготовленный оператор&lt;/a&gt; , реализующий &lt;a href=&quot;lang_select&quot;&gt;оператор SELECT&lt;/a&gt; . Второй параметр - это номер столбца. Крайний левый столбец - номер 0.</target>
        </trans-unit>
        <trans-unit id="5de2bfd9e6d919b373b4c3d1b80a7310909f2955" translate="yes" xml:space="preserve">
          <source>These routines should return true if the mutex in their argument is held or not held, respectively, by the calling thread.</source>
          <target state="translated">Эти процедуры должны возвращать true,если мьютекс в их аргументе удерживается или не удерживается,соответственно,вызывающим потоком.</target>
        </trans-unit>
        <trans-unit id="afa365b8dc52497e4284392ecbb9654dff91e29b" translate="yes" xml:space="preserve">
          <source>These routines throw an error if the first JSON argument is not well-formed or if any PATH argument is not well-formed or if any argument is a BLOB.</source>
          <target state="translated">Эти подпрограммы бросают ошибку,если первый JSON аргумент не сформирован правильно,или если любой аргумент PATH не сформирован правильно,или если любой аргумент является BLOB.</target>
        </trans-unit>
        <trans-unit id="040db3ed336324c99d540be07030ca6b73dfe1d9" translate="yes" xml:space="preserve">
          <source>These routines work just like the corresponding &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;column access functions&lt;/a&gt; except that these routines take a single &lt;a href=&quot;#sqlite3_value&quot;&gt;protected sqlite3_value&lt;/a&gt; object pointer instead of a &lt;a href=&quot;#sqlite3_stmt&quot;&gt;sqlite3_stmt*&lt;/a&gt; pointer and an integer column number.</source>
          <target state="translated">Эти процедуры работают так же, как соответствующие &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;функции доступа к столбцам,&lt;/a&gt; за исключением того, что эти процедуры принимают один &lt;a href=&quot;#sqlite3_value&quot;&gt;защищенный&lt;/a&gt; указатель на объект sqlite3_value вместо указателя &lt;a href=&quot;#sqlite3_stmt&quot;&gt;sqlite3_stmt *&lt;/a&gt; и целочисленный номер столбца.</target>
        </trans-unit>
        <trans-unit id="8f8d6c3e862ca519958d58c8125484847b89c711" translate="yes" xml:space="preserve">
          <source>These routines work just like the corresponding &lt;a href=&quot;column_blob&quot;&gt;column access functions&lt;/a&gt; except that these routines take a single &lt;a href=&quot;value&quot;&gt;protected sqlite3_value&lt;/a&gt; object pointer instead of a &lt;a href=&quot;stmt&quot;&gt;sqlite3_stmt*&lt;/a&gt; pointer and an integer column number.</source>
          <target state="translated">Эти процедуры работают так же, как соответствующие &lt;a href=&quot;column_blob&quot;&gt;функции доступа к столбцам,&lt;/a&gt; за исключением того, что эти процедуры принимают один &lt;a href=&quot;value&quot;&gt;защищенный&lt;/a&gt; указатель на объект sqlite3_value вместо указателя &lt;a href=&quot;stmt&quot;&gt;sqlite3_stmt *&lt;/a&gt; и целочисленный номер столбца.</target>
        </trans-unit>
        <trans-unit id="95d389aedaf4f8ce85f9804703017919fd80feca" translate="yes" xml:space="preserve">
          <source>These routines work only with &lt;a href=&quot;#sqlite3_value&quot;&gt;protected sqlite3_value&lt;/a&gt; objects. Any attempt to use these routines on an &lt;a href=&quot;#sqlite3_value&quot;&gt;unprotected sqlite3_value&lt;/a&gt; is not threadsafe.</source>
          <target state="translated">Эти процедуры работают только с &lt;a href=&quot;#sqlite3_value&quot;&gt;защищенными&lt;/a&gt; объектами sqlite3_value . Любая попытка использовать эти процедуры для &lt;a href=&quot;#sqlite3_value&quot;&gt;незащищенного sqlite3_value&lt;/a&gt; не является потокобезопасным.</target>
        </trans-unit>
        <trans-unit id="7a8ed928c1fb3dc4a20d3be2fb5cfe01bd35f70b" translate="yes" xml:space="preserve">
          <source>These routines work only with &lt;a href=&quot;value&quot;&gt;protected sqlite3_value&lt;/a&gt; objects. Any attempt to use these routines on an &lt;a href=&quot;value&quot;&gt;unprotected sqlite3_value&lt;/a&gt; is not threadsafe.</source>
          <target state="translated">Эти процедуры работают только с &lt;a href=&quot;value&quot;&gt;защищенными&lt;/a&gt; объектами sqlite3_value . Любая попытка использовать эти процедуры для &lt;a href=&quot;value&quot;&gt;незащищенного sqlite3_value&lt;/a&gt; не является потокобезопасным.</target>
        </trans-unit>
        <trans-unit id="cf9c078687c96682c6a85bb7a67b91a68491a0f8" translate="yes" xml:space="preserve">
          <source>These static mutexes are reserved for use internally by SQLite and should not be used by the application. The static mutexes are all non-recursive.</source>
          <target state="translated">Эти статические мьютексы предназначены для внутреннего использования SQLite и не должны использоваться приложением.Все статические мьютексы не являются рекурсивными.</target>
        </trans-unit>
        <trans-unit id="a11e17b224413c41480316935dad79b1f586c189" translate="yes" xml:space="preserve">
          <source>These techniques are designed to aid in understanding the core SQLite library itself, not applications that merely use SQLite.</source>
          <target state="translated">Эти методы призваны помочь в понимании самой основной библиотеки SQLite,а не приложений,которые просто используют SQLite.</target>
        </trans-unit>
        <trans-unit id="7f9968558d6525a5e69fdd942a06f1a35ab390ef" translate="yes" xml:space="preserve">
          <source>These tests are on a relatively small (approximately 14 megabyte) database. They do not measure how well the database engines scale to larger problems.</source>
          <target state="translated">Эти тесты проводятся на относительно небольшой (около 14 мегабайт)базе данных.Они не измеряют,насколько хорошо двигатели базы данных масштабируются для больших проблем.</target>
        </trans-unit>
        <trans-unit id="f97df2bc02e2ab86d912a22d332def150459caf8" translate="yes" xml:space="preserve">
          <source>These tests did not attempt to measure multi-user performance or optimization of complex queries involving multiple joins and subqueries.</source>
          <target state="translated">В этих тестах не делалось попыток измерить многопользовательскую производительность или оптимизировать сложные запросы с множественными соединениями и подзапросами.</target>
        </trans-unit>
        <trans-unit id="dd70aa0fe10c02751ca4c43bd10acab99e561495" translate="yes" xml:space="preserve">
          <source>These three ways of committing a transaction correspond to the DELETE, TRUNCATE, and PERSIST settings, respectively, of the &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;journal_mode pragma&lt;/a&gt;.</source>
          <target state="translated">Эти три способа фиксации транзакции соответствуют параметрам DELETE, TRUNCATE и PERSIST, соответственно, &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;прагмы journal_mode&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8f79d49bdd4e3aeeeb4789bde61715a9a01e430c" translate="yes" xml:space="preserve">
          <source>These two rules describe how the query planner for SQLite works as of this writing (2013-08-01). And the rules above will always be honored. However, future versions of SQLite might incorporate a better theorem prover that can find other cases where W&amp;rArr;X is true and thus may find more instances where partial indexes are useful.</source>
          <target state="translated">Эти два правила описывают, как работает планировщик запросов для SQLite на момент написания этой статьи (2013-08-01). И приведенные выше правила всегда будут соблюдаться. Однако будущие версии SQLite могут включать в себя более совершенное средство доказательства теорем, которое может найти другие случаи, когда W&amp;rArr;X истинно, и, таким образом, может найти больше случаев, когда частичные индексы будут полезны.</target>
        </trans-unit>
        <trans-unit id="c8fd956e215d583a512e53c2c78546d08e30ff46" translate="yes" xml:space="preserve">
          <source>Things That Can Go Wrong</source>
          <target state="translated">Вещи,которые могут пойти не так.</target>
        </trans-unit>
        <trans-unit id="42067c10086226bb2498180a8a023f3ac259d639" translate="yes" xml:space="preserve">
          <source>Things are more complicated if the sqlite3_changes() function is executed while a trigger program is running. This may happen if the program uses the &lt;a href=&quot;../lang_corefunc#changes&quot;&gt;changes() SQL function&lt;/a&gt;, or if some other callback function invokes sqlite3_changes() directly. Essentially:</source>
          <target state="translated">Ситуация усложняется, если функция sqlite3_changes () выполняется во время работы программы триггера. Это может произойти, если программа использует &lt;a href=&quot;../lang_corefunc#changes&quot;&gt;функцию SQL changes ()&lt;/a&gt; или если какая-либо другая функция обратного вызова напрямую вызывает sqlite3_changes (). По сути:</target>
        </trans-unit>
        <trans-unit id="53a7af1ec1bf96fe1cf7aeeb3a8a96e5b6a416b2" translate="yes" xml:space="preserve">
          <source>Things are more complicated if the sqlite3_changes() function is executed while a trigger program is running. This may happen if the program uses the &lt;a href=&quot;lang_corefunc#changes&quot;&gt;changes() SQL function&lt;/a&gt;, or if some other callback function invokes sqlite3_changes() directly. Essentially:</source>
          <target state="translated">Ситуация усложняется, если функция sqlite3_changes () выполняется во время работы программы триггера. Это может произойти, если программа использует &lt;a href=&quot;lang_corefunc#changes&quot;&gt;функцию SQL changes ()&lt;/a&gt; или если какая-либо другая функция обратного вызова напрямую вызывает sqlite3_changes (). По сути:</target>
        </trans-unit>
        <trans-unit id="774483139813d257b6024c3ca6cbcda75578301f" translate="yes" xml:space="preserve">
          <source>Think of each SQL statement as a separate computer program. The original SQL text is source code. A prepared statement object is the compiled object code. All SQL must be converted into a prepared statement before it can be run.</source>
          <target state="translated">Думайте о каждом SQL-операторе как о отдельной компьютерной программе.Оригинальный текст SQL является исходным кодом.Объектом подготовленного оператора является скомпилированный объектный код.Все SQL-операторы должны быть преобразованы в подготовленный оператор,прежде чем его можно будет запустить.</target>
        </trans-unit>
        <trans-unit id="2f8cd345a6425d660448be637505c8f25ad1aef9" translate="yes" xml:space="preserve">
          <source>Think of each SQL statement as a small computer program. The purpose of &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; is to compile that program into object code. The &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; is the object code. The &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; interface then runs the object code to get a result.</source>
          <target state="translated">Думайте о каждой инструкции SQL как о небольшой компьютерной программе. Цель &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare ()&lt;/a&gt; - скомпилировать эту программу в объектный код. &lt;a href=&quot;c3ref/stmt&quot;&gt;Подготовленное заявление&lt;/a&gt; является объектный код. Затем интерфейс &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step ()&lt;/a&gt; запускает объектный код для получения результата.</target>
        </trans-unit>
        <trans-unit id="cfafbb2da361739c04c43a8272cc38856e9c67a7" translate="yes" xml:space="preserve">
          <source>Third Improvement: Versioning</source>
          <target state="translated">Третье усовершенствование:Версия</target>
        </trans-unit>
        <trans-unit id="865c9c12492c3442466282bf437772709b257a8a" translate="yes" xml:space="preserve">
          <source>This API can be quite slow if used with an FTS5 table created with the &quot;detail=none&quot; option. If the FTS5 table is created with either &quot;detail=none&quot; &quot;content=&quot; option (i.e. if it is a contentless table), then this API always iterates through an empty set (all calls to xPhraseFirstColumn() set iCol to -1).</source>
          <target state="translated">Этот API может быть довольно медленным,если используется с таблицей FTS5,созданной с опцией &quot;detail=none&quot;.Если таблица FTS5 создаётся с опцией &quot;detail=none&quot; &quot;content=&quot; (т.е.если это таблица без содержимого),то этот API всегда выполняет итерации через пустой набор (все обращения к xPhraseFirstColumn()устанавливают iCol в -1).</target>
        </trans-unit>
        <trans-unit id="ebf79b4cb55761477acdbbee63fd4654b2112a93" translate="yes" xml:space="preserve">
          <source>This API can be quite slow if used with an FTS5 table created with the &quot;detail=none&quot; or &quot;detail=column&quot; option.</source>
          <target state="translated">Этот API может быть довольно медленным,если используется с таблицей FTS5,созданной с опцией &quot;detail=none&quot; или &quot;detail=column&quot;.</target>
        </trans-unit>
        <trans-unit id="320a596dec5edeedf6c5c2728a533311ecff7379" translate="yes" xml:space="preserve">
          <source>This API can be quite slow if used with an FTS5 table created with the &quot;detail=none&quot; or &quot;detail=column&quot; option. If the FTS5 table is created with either &quot;detail=none&quot; or &quot;detail=column&quot; and &quot;content=&quot; option (i.e. if it is a contentless table), then this API always iterates through an empty set (all calls to xPhraseFirst() set iCol to -1).</source>
          <target state="translated">Этот API может быть довольно медленным,если используется с таблицей FTS5,созданной с опцией &quot;detail=none&quot; или &quot;detail=column&quot;.Если таблица FTS5 создаётся с опциями &quot;detail=none&quot; или &quot;detail=column&quot; и &quot;content=&quot; (т.е.если это таблица без содержимого),то этот API всегда выполняет итерации через пустое множество (все обращения к xPhraseFirst()устанавливают iCol в -1).</target>
        </trans-unit>
        <trans-unit id="f65fb946e21f0df296308a1267bfc8d75459c36f" translate="yes" xml:space="preserve">
          <source>This API can be quite slow if used with an FTS5 table created with the &quot;detail=none&quot; or &quot;detail=column&quot; option. If the FTS5 table is created with either &quot;detail=none&quot; or &quot;detail=column&quot; and &quot;content=&quot; option (i.e. if it is a contentless table), then this API always returns 0.</source>
          <target state="translated">Этот API может быть довольно медленным,если используется с таблицей FTS5,созданной с опцией &quot;detail=none&quot; или &quot;detail=column&quot;.Если таблица FTS5 создана с опцией &quot;detail=none&quot; или &quot;detail=column&quot; и &quot;content=&quot; (т.е.если это таблица без содержания),то этот API всегда возвращает 0.</target>
        </trans-unit>
        <trans-unit id="43444bfacf757a80f8f09485afde0ead5f0a776e" translate="yes" xml:space="preserve">
          <source>This API function is used to query the FTS table for phrase iPhrase of the current query. Specifically, a query equivalent to:</source>
          <target state="translated">Данная функция API используется для запроса таблицы FTS к фразе iPhrase текущего запроса.В частности,запрос,эквивалентный:</target>
        </trans-unit>
        <trans-unit id="d89725045237fc9113c1fa0f974917002e582aec" translate="yes" xml:space="preserve">
          <source>This API is only available if the library is built with pre-processor symbol &lt;a href=&quot;../compile#enable_stmt_scanstatus&quot;&gt;SQLITE_ENABLE_STMT_SCANSTATUS&lt;/a&gt; defined.</source>
          <target state="translated">Этот API доступен только в том случае, если библиотека построена с определенным символом &lt;a href=&quot;../compile#enable_stmt_scanstatus&quot;&gt;препроцессора SQLITE_ENABLE_STMT_SCANSTATUS&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="48dac83568aa304395644b3c39b1c1984d8ea7c3" translate="yes" xml:space="preserve">
          <source>This API is only available if the library is built with pre-processor symbol &lt;a href=&quot;compile#enable_stmt_scanstatus&quot;&gt;SQLITE_ENABLE_STMT_SCANSTATUS&lt;/a&gt; defined.</source>
          <target state="translated">Этот API доступен только в том случае, если библиотека построена с определенным символом &lt;a href=&quot;compile#enable_stmt_scanstatus&quot;&gt;препроцессора SQLITE_ENABLE_STMT_SCANSTATUS&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f548cc5880d8bc2ce8ab0c825c0274336bee682c" translate="yes" xml:space="preserve">
          <source>This API makes sure a global version of a function with a particular name and number of parameters exists. If no such function exists before this API is called, a new function is created. The implementation of the new function always causes an exception to be thrown. So the new function is not good for anything by itself. Its only purpose is to be a placeholder function that can be overloaded by a &lt;a href=&quot;../vtab&quot;&gt;virtual table&lt;/a&gt;.</source>
          <target state="translated">Этот API гарантирует, что существует глобальная версия функции с определенным именем и количеством параметров. Если такая функция не существует до вызова этого API, создается новая функция. Реализация новой функции всегда вызывает исключение. Так что новая функция ни для чего не годится. Его единственная цель - быть функцией-заполнителем, которая может быть перегружена &lt;a href=&quot;../vtab&quot;&gt;виртуальной таблицей&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8540f6a2004da77a77789ccfaf202735cf5c6ba1" translate="yes" xml:space="preserve">
          <source>This API makes sure a global version of a function with a particular name and number of parameters exists. If no such function exists before this API is called, a new function is created. The implementation of the new function always causes an exception to be thrown. So the new function is not good for anything by itself. Its only purpose is to be a placeholder function that can be overloaded by a &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt;.</source>
          <target state="translated">Этот API гарантирует, что существует глобальная версия функции с определенным именем и количеством параметров. Если такая функция не существует до вызова этого API, создается новая функция. Реализация новой функции всегда вызывает исключение. Так что новая функция ни для чего не годится. Его единственная цель - быть функцией-заполнителем, которая может быть перегружена &lt;a href=&quot;vtab&quot;&gt;виртуальной таблицей&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6ab96b1e97da69a025cb8ca96b99b710398cad45" translate="yes" xml:space="preserve">
          <source>This C-preprocess macro determines the default setting of the &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigcoveringindexscan&quot;&gt;SQLITE_CONFIG_COVERING_INDEX_SCAN&lt;/a&gt; configuration setting. It defaults to 1 (on) which means that covering indices are used for full table scans where possible, in order to reduce I/O and improve performance. However, the use of a covering index for a full scan will cause results to appear in a different order from legacy, which could cause some (incorrectly-coded) legacy applications to break. Hence, the covering index scan option can be disabled at compile-time on systems that what to minimize their risk of exposing errors in legacy applications.</source>
          <target state="translated">Этот макрос предварительной обработки C определяет настройку по умолчанию для параметра конфигурации &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigcoveringindexscan&quot;&gt;SQLITE_CONFIG_COVERING_INDEX_SCAN&lt;/a&gt; . По умолчанию установлено значение 1 (включено), что означает, что индексы покрытия используются для полного сканирования таблицы, где это возможно, чтобы уменьшить количество операций ввода-вывода и повысить производительность. Однако использование покрывающего индекса для полного сканирования приведет к тому, что результаты будут отображаться в порядке, отличном от устаревшего, что может привести к поломке некоторых (неправильно закодированных) устаревших приложений. Следовательно, опцию сканирования покрывающего индекса можно отключить во время компиляции в системах, чтобы минимизировать риск выявления ошибок в устаревших приложениях.</target>
        </trans-unit>
        <trans-unit id="352e275c0ba546327eab38cacb1b8cfd047e40c3" translate="yes" xml:space="preserve">
          <source>This CVE identifies a bug in a development check-in of SQLite. The bug never appeared in any official SQLite release. &lt;a href=&quot;https://www.sqlite.org/src/info/6601da58032d18ae&quot;&gt;(details)&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b6673eaea3893e3fceb60fe446b80a1ff19d0e8" translate="yes" xml:space="preserve">
          <source>This DELETE statement will remove every record from the &quot;examp&quot; table where the &quot;two&quot; column is less than 50. The code generated to do this is as follows:</source>
          <target state="translated">Этот оператор DELETE удалит каждую запись из таблицы &quot;экзамен&quot;,где столбец &quot;два&quot; меньше 50.Код,сгенерированный для этого,выглядит следующим образом:</target>
        </trans-unit>
        <trans-unit id="b0bfab415a485beb9edddb8d5188d00815376867" translate="yes" xml:space="preserve">
          <source>This allows optimizations: (a) when P4==0 there is no need to test the RowSet object for P3, as it is guaranteed not to contain it, (b) when P4==-1 there is no need to insert the value, as it will never be tested for, and (c) when a value that is part of set X is inserted, there is no need to search to see if the same value was previously inserted as part of set X (only if it was previously inserted as part of some other set).</source>
          <target state="translated">Это позволяет оптимизировать:(a)когда P4==0,нет необходимости тестировать объект RowSet для P3,так как он гарантированно не будет содержать его,(b)когда P4==-1,нет необходимости вставлять значение,так как оно никогда не будет тестироваться,и (c)когда вставляется значение,которое является частью множества X,нет необходимости искать,не было ли это же значение ранее вставлено как часть множества X (только если оно было ранее вставлено как часть какого-то другого множества).</target>
        </trans-unit>
        <trans-unit id="e9de882f0fc5b21571717171f0fcc8e049f8f4b3" translate="yes" xml:space="preserve">
          <source>This allows separate database connections to share the same in-memory database. Of course, all database connections sharing the in-memory database need to be in the same process. The database is automatically deleted and memory is reclaimed when the last connection to the database closes.</source>
          <target state="translated">Это позволяет отдельным соединениям БД совместно использовать одну и ту же БД в памяти.Конечно,все соединения БД,разделяющие БД in-memory,должны быть в одном процессе.БД автоматически удаляется,а память восстанавливается при закрытии последнего соединения с БД.</target>
        </trans-unit>
        <trans-unit id="c92e98ecc01f031d3a1efe7cd735db9a008161b9" translate="yes" xml:space="preserve">
          <source>This article also uses the terms &quot;bytecode program&quot; and &quot;prepared statement&quot; interchangeably, as they are mostly the same thing.</source>
          <target state="translated">В этой статье также используются термины &quot;программа байткода&quot; и &quot;подготовленный оператор&quot; как взаимозаменяемые,так как они в основном одно и то же.</target>
        </trans-unit>
        <trans-unit id="a9af0cbe702f19f3f49888228ef0df406a0e5175" translate="yes" xml:space="preserve">
          <source>This article defines what the limits of SQLite are and how they can be customized for specific applications. The default settings for limits are normally quite large and adequate for almost every application. Some applications may want to increase a limit here or there, but we expect such needs to be rare. More commonly, an application might want to recompile SQLite with much lower limits to avoid excess resource utilization in the event of bug in higher-level SQL statement generators or to help thwart attackers who inject malicious SQL statements.</source>
          <target state="translated">Эта статья определяет,каковы ограничения SQLite и как их можно настроить для конкретных приложений.Настройки по умолчанию для лимитов обычно достаточно велики и адекватны практически для каждого приложения.Некоторые приложения могут захотеть увеличить лимит здесь или там,но мы ожидаем,что такие случаи будут редкими.Чаще всего,приложение может захотеть перекомпилировать SQLite с гораздо более низкими лимитами,чтобы избежать избыточного использования ресурсов в случае ошибки в генераторах SQL-операторов более высокого уровня,или чтобы помочь атакующим,которые внедряют вредоносные SQL-операторы.</target>
        </trans-unit>
        <trans-unit id="316fd7167581f1bf3b1521c621172952b269d34a" translate="yes" xml:space="preserve">
          <source>This article describes how the SQLite developers measure CPU usage, what those measurements actually mean, and the techniques used by SQLite developers on their continuing quest to further reduce the CPU usage of the SQLite library.</source>
          <target state="translated">В этой статье описывается,как разработчики SQLite измеряют использование процессора,что на самом деле означают эти измерения,и методы,используемые разработчиками SQLite в их постоянном стремлении к дальнейшему сокращению использования процессора библиотеки SQLite.</target>
        </trans-unit>
        <trans-unit id="926f25884d306babc2c568ebac87d0360fd509bf" translate="yes" xml:space="preserve">
          <source>This article describes the SQLite OS portability layer or &quot;VFS&quot; - the module at the bottom of the SQLite implementation stack that provides portability across operating systems.</source>
          <target state="translated">В статье описывается уровень переносимости операционной системы SQLite OS или &quot;VFS&quot;-модуль в нижней части стека реализации SQLite,обеспечивающий переносимость между операционными системами.</target>
        </trans-unit>
        <trans-unit id="e9493c358448eb3b281eac84dedc92f4531c0a0b" translate="yes" xml:space="preserve">
          <source>This article describes the techniques used by SQLite to create the illusion of atomic commit.</source>
          <target state="translated">Эта статья описывает методы,используемые SQLite для создания иллюзии атомного коммита.</target>
        </trans-unit>
        <trans-unit id="c7354274b5f5ad835c3ba9869336d09f507f1b91" translate="yes" xml:space="preserve">
          <source>This article describes the various temporary files that SQLite creates and uses. It describes when the files are created, when they are deleted, what they are used for, why they are important, and how to avoid them on systems where creating temporary files is expensive.</source>
          <target state="translated">В этой статье описываются различные временные файлы,которые SQLite создает и использует.В ней описывается,когда создаются файлы,когда они удаляются,для чего они используются,почему они важны и как избежать их на системах,где создание временных файлов стоит дорого.</target>
        </trans-unit>
        <trans-unit id="bf37adfcb2e68d7e2d42601f83e22affd6226d10" translate="yes" xml:space="preserve">
          <source>This article does not contain a step-by-step recipe for compiling SQLite. That would be difficult since each development situation is different. Rather, this article describes and illustrates the principals behind the compilation of SQLite. Typical compilation commands are provided as examples with the expectation that application developers can use these examples as guidance for developing their own custom compilation procedures. In other words, this article provides ideas and insights, not turnkey solutions.</source>
          <target state="translated">Данная статья не содержит пошагового рецепта компиляции SQLite.Это будет сложно,так как каждая ситуация разработки уникальна.Скорее,данная статья описывает и иллюстрирует принципы,лежащие в основе компиляции SQLite.В качестве примеров приведены типичные команды компиляции с расчетом на то,что разработчики приложений смогут использовать эти примеры в качестве руководства по разработке собственных пользовательских процедур компиляции.Другими словами,в данной статье представлены идеи и идеи,а не решения &quot;под ключ&quot;.</target>
        </trans-unit>
        <trans-unit id="945df33c68655603cf7dd0502f5d42134ad32f1a" translate="yes" xml:space="preserve">
          <source>This article has been revised multiple times in an attempt to improve clarity, address concerns and misgivings, and to fix errors identified on &lt;a href=&quot;https://news.ycombinator.com/item?id=16806114&quot;&gt;Hacker News&lt;/a&gt;, &lt;a href=&quot;https://www.reddit.com/r/programming/comments/8c2niw/why_sqlite_does_not_use_git/&quot;&gt;Reddit&lt;/a&gt; and &lt;a href=&quot;https://lobste.rs/s/slcntl/why_sqlite_does_not_use_git&quot;&gt;Lobsters&lt;/a&gt;. The complete edit history can be seen at &lt;a href=&quot;https://sqlite.org/docsrc/finfo/pages/whynotgit.in&quot;&gt;https://sqlite.org/docsrc/finfo/pages/whynotgit.in&lt;/a&gt;. (Usage hint: Click on any two nodes of the graph for a diff.)</source>
          <target state="translated">Эта статья была пересмотрена несколько раз в попытке улучшить ясность, устранить опасения и опасения, а также исправить ошибки, обнаруженные в &lt;a href=&quot;https://news.ycombinator.com/item?id=16806114&quot;&gt;Hacker News&lt;/a&gt; , &lt;a href=&quot;https://www.reddit.com/r/programming/comments/8c2niw/why_sqlite_does_not_use_git/&quot;&gt;Reddit&lt;/a&gt; и &lt;a href=&quot;https://lobste.rs/s/slcntl/why_sqlite_does_not_use_git&quot;&gt;Lobsters&lt;/a&gt; . Полную историю редактирования можно увидеть на &lt;a href=&quot;https://sqlite.org/docsrc/finfo/pages/whynotgit.in&quot;&gt;https://sqlite.org/docsrc/finfo/pages/whynotgit.in&lt;/a&gt; . (Подсказка: нажмите на любые два узла графика, чтобы увидеть разницу.)</target>
        </trans-unit>
        <trans-unit id="0e3cce9679885d41b9585cf0d093d29dd27aa92e" translate="yes" xml:space="preserve">
          <source>This article has been revised multiple times in an attempt to improve clarity, address concerns and misgivings, and to fix errors. The complete edit history for this document can be seen at &lt;a href=&quot;https://sqlite.org/docsrc/finfo/pages/whynotgit.in&quot;&gt;https://sqlite.org/docsrc/finfo/pages/whynotgit.in&lt;/a&gt;. (Usage hint: Click on any two nodes of the graph for a diff. BTW, are there any Git web interfaces that offers a similar capability?)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62a4071d7245439102f2788bb499d61e09713933" translate="yes" xml:space="preserve">
          <source>This article has reviewed all of the major techniques used by SQLite's VDBE to implement SQL statements. What has not been shown is that most of these techniques can be used in combination to generate code for an appropriately complex query statement. For example, we have shown how sorting is accomplished on a simple query and we have shown how to implement a compound query. But we did not give an example of sorting in a compound query. This is because sorting a compound query does not introduce any new concepts: it merely combines two previous ideas (sorting and compounding) in the same VDBE program.</source>
          <target state="translated">В этой статье были рассмотрены все основные методы,используемые SQLite VDBE для реализации SQL выражений.Не было показано,что большинство из этих методов могут быть использованы в комбинации для генерации кода для соответствующего сложного запроса.Например,мы показали,как выполняется сортировка по простому запросу,и показали,как реализовать сложный запрос.Однако мы не привели пример сортировки в составном запросе.Это связано с тем,что сортировка составного запроса не вводит никаких новых понятий:она просто объединяет две предыдущие идеи (сортировка и составной запрос)в одной и той же программе VDBE.</target>
        </trans-unit>
        <trans-unit id="859ce88d1dfd2b6b6ff0c486caa8bb5617ba5082" translate="yes" xml:space="preserve">
          <source>This article is &lt;u&gt;not&lt;/u&gt; a comparison between Fossil and Git. See &lt;a href=&quot;https://fossil-scm.org/fossil/doc/trunk/www/fossil-v-git.wiki&quot;&gt;https://fossil-scm.org/fossil/doc/trunk/www/fossil-v-git.wiki&lt;/a&gt; for one comparison of the two systems. Other third-party comparisons are available as well - use a search engine to find them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a20be3ae1245d83ff9c73306d203b42ad8b16c54" translate="yes" xml:space="preserve">
          <source>This article is &lt;u&gt;not&lt;/u&gt; a comparison between Fossil and Git. See &lt;a href=&quot;https://fossil-scm.org/fossil/doc/trunk/www/fossil-v-git.wiki&quot;&gt;https://fossil-scm.org/fossil/doc/trunk/www/fossil-v-git.wiki&lt;/a&gt; for one comparison of the two systems. There are others as well.</source>
          <target state="translated">Эта статья &lt;u&gt;не&lt;/u&gt; является сравнением Fossil и Git. См. &lt;a href=&quot;https://fossil-scm.org/fossil/doc/trunk/www/fossil-v-git.wiki&quot;&gt;Https://fossil-scm.org/fossil/doc/trunk/www/fossil-v-git.wiki&lt;/a&gt; для одного сравнения двух систем. Есть и другие.</target>
        </trans-unit>
        <trans-unit id="076794bd5fb5fd47410297cae8ef29f94da50472" translate="yes" xml:space="preserve">
          <source>This article is &lt;u&gt;not&lt;/u&gt; advocating that you switch your projects away from Git. You can use whatever version control system you want. If you are perfectly happy with Git, then by all means keep using Git. But, if Git is not working well for you or you are wondering if it can be improved or if there is something better, then maybe try to understand the perspectives presented below. Use the insights thus obtained to find or write a different and better version control system, or to just make improvements to Git itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afdaa5ec4a00df9435f74fca69ef2e683fab815e" translate="yes" xml:space="preserve">
          <source>This article is &lt;u&gt;not&lt;/u&gt; advocating that you switch your projects away from Git. You can use whatever version control system you want. If you are perfectly happy with Git, then by all means keep using Git. But, if you are wondering if there isn't something better, then maybe try to understand the perspectives presented below. Use the insights thus obtained to find or write a different and better version control system, or to just make improvements to Git itself.</source>
          <target state="translated">Эта статья &lt;u&gt;не&lt;/u&gt; призывает вас переключить свои проекты с Git. Вы можете использовать любую систему контроля версий, какую захотите. Если вы полностью довольны Git, продолжайте использовать Git во что бы то ни стало. Но, если вам интересно, нет ли чего-то лучшего, то, возможно, попытайтесь понять перспективы, представленные ниже. Используйте полученные таким образом идеи, чтобы найти или написать другую и лучшую систему управления версиями или просто внести улучшения в сам Git.</target>
        </trans-unit>
        <trans-unit id="7e8b2b9b07235888ae1de754eef75c5cbe3b972b" translate="yes" xml:space="preserve">
          <source>This article is a brief introduction to how the VDBE works and in particular how the various VDBE instructions (documented &lt;a href=&quot;opcode&quot;&gt;here&lt;/a&gt;) work together to do useful things with the database. The style is tutorial, beginning with simple tasks and working toward solving more complex problems. Along the way we will visit most submodules in the SQLite library. After completing this tutorial, you should have a pretty good understanding of how SQLite works and will be ready to begin studying the actual source code.</source>
          <target state="translated">Эта статья представляет собой краткое введение в то, как работает VDBE, и, в частности, как различные инструкции VDBE (задокументированные &lt;a href=&quot;opcode&quot;&gt;здесь&lt;/a&gt; ) работают вместе, чтобы делать полезные вещи с базой данных. Стиль обучения - учебник, начиная с простых задач и заканчивая решением более сложных проблем. По пути мы посетим большинство подмодулей в библиотеке SQLite. После завершения этого руководства вы должны иметь довольно хорошее представление о том, как работает SQLite, и будете готовы начать изучение фактического исходного кода.</target>
        </trans-unit>
        <trans-unit id="2a689ac1a6bfa9fdba228a490c8ca90cb86bfd11" translate="yes" xml:space="preserve">
          <source>This article is about the bottom layer.</source>
          <target state="translated">Эта статья о нижнем слое.</target>
        </trans-unit>
        <trans-unit id="8376dd4be0a7eabaff5c0a359df7f198ffdee0ed" translate="yes" xml:space="preserve">
          <source>This article only mentions the most important and most commonly used SQLite interfaces. The SQLite library includes many other APIs implementing useful features that are not described here. A &lt;a href=&quot;c3ref/funclist&quot;&gt;complete list of functions&lt;/a&gt; that form the SQLite application programming interface is found at the &lt;a href=&quot;c3ref/intro&quot;&gt;C/C++ Interface Specification&lt;/a&gt;. Refer to that document for complete and authoritative information about all SQLite interfaces.</source>
          <target state="translated">В этой статье упоминаются только самые важные и наиболее часто используемые интерфейсы SQLite. Библиотека SQLite включает множество других API, реализующих полезные функции, которые здесь не описаны. &lt;a href=&quot;c3ref/funclist&quot;&gt;Полный перечень функций&lt;/a&gt; , которые формируют SQLite интерфейса прикладного программирования находится в &lt;a href=&quot;c3ref/intro&quot;&gt;спецификации C / C ++ интерфейса&lt;/a&gt; . Обратитесь к этому документу для получения полной и достоверной информации обо всех интерфейсах SQLite.</target>
        </trans-unit>
        <trans-unit id="ecb82abd11a7741bac191b285785a86679cd3dd8" translate="yes" xml:space="preserve">
          <source>This article outlines one possible method for keeping a private branch of SQLite in sync with the public SQLite source code. There are many ways of maintaining a private branch, of course. Nobody is compelled to use the method describe here. This article is not trying to impose a particular procedure on maintainers of private branches. The point of this article is to offer an example of one process for maintaining a private branch which can be used as a template for designing processes best suited for the circumstances of each individual project.</source>
          <target state="translated">В этой статье описывается один из возможных способов синхронизации частной ветки SQLite с публичным исходным кодом SQLite.Конечно же,существует множество способов ведения частной ветки.Никто не обязан использовать описанный здесь метод.Данная статья не пытается навязать конкретную процедуру сопровождающим частных ветвей.Смысл данной статьи состоит в том,чтобы привести пример одного процесса сопровождения частной ветки,который может быть использован в качестве шаблона для процессов проектирования,наилучшим образом подходящих к обстоятельствам каждого отдельного проекта.</target>
        </trans-unit>
        <trans-unit id="6e9369c9e16c87662c003b06c9e9f9920fb45e35" translate="yes" xml:space="preserve">
          <source>This article overviews the importance of query planning, describes some of the problems inherent to query planning, and outlines how the NGQP solves those problems.</source>
          <target state="translated">В этой статье рассматривается важность планирования запросов,описываются некоторые проблемы,присущие планированию запросов,и описывается,как NGQP решает эти проблемы.</target>
        </trans-unit>
        <trans-unit id="edd2ab1205dd1a38d5ce29f020d2d454461aadbe" translate="yes" xml:space="preserve">
          <source>This article presents a technique using the SQLite &lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify()&lt;/a&gt; interface such that calls to &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; and &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; block until the required locks are available instead of returning SQLITE_LOCKED immediately. If the sqlite3_blocking_step() or sqlite3_blocking_prepare_v2() functions presented to the left return SQLITE_LOCKED, this indicates that to block would deadlock the system.</source>
          <target state="translated">В этой статье представлен метод использования интерфейса SQLite &lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify ()&lt;/a&gt; , который вызывает блоки &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step ()&lt;/a&gt; и &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; до тех пор, пока требуемые блокировки не станут доступными, вместо немедленного возврата SQLITE_LOCKED. Если функции sqlite3_blocking_step () или sqlite3_blocking_prepare_v2 (), представленные слева, возвращают SQLITE_LOCKED, это означает, что блокировка приведет к взаимной блокировке системы.</target>
        </trans-unit>
        <trans-unit id="9498c6cd8712f6376d65af391550cc9e3ffdabcd" translate="yes" xml:space="preserve">
          <source>This block of instruction cleans up the VDBE program. Three of these instructions aren't really required, but are generated by the SQLite parser from its code templates, which are designed to handle more complicated cases.</source>
          <target state="translated">Этот блок инструкций очищает программу VDBE.Три из этих инструкций на самом деле не нужны,но генерируются парсером SQLite из его шаблонов кода,которые предназначены для работы с более сложными случаями.</target>
        </trans-unit>
        <trans-unit id="4a01a06f54367b20ad3750e286b70148e2c847d5" translate="yes" xml:space="preserve">
          <source>This built-in window function calculates the window frame for each row in the same way as an aggregate window function. It returns the value of</source>
          <target state="translated">Эта встроенная функция окна вычисляет оконную раму для каждой строки таким же образом,как и совокупная функция окна.Она возвращает значение</target>
        </trans-unit>
        <trans-unit id="20ec5d83d88c2da3b16c3295bcff75c38125962e" translate="yes" xml:space="preserve">
          <source>This change is an exception to the version number rule described above in that it is neither forwards or backwards compatible. A complete reload of the database is required. This is the only exception.</source>
          <target state="translated">Это изменение является исключением из правила о номере версии,описанного выше,в том смысле,что оно не является ни прямым,ни обратным совместимым.Требуется полная перезагрузка базы данных.Это единственное исключение.</target>
        </trans-unit>
        <trans-unit id="c6a5f96c5622bed501ea8661519073e0de4f52cd" translate="yes" xml:space="preserve">
          <source>This column also always contains an integer value greater than zero.</source>
          <target state="translated">Этот столбец также всегда содержит целое значение больше нуля.</target>
        </trans-unit>
        <trans-unit id="fb0358a44a2292d9d05f4777b69d5f05939eb420" translate="yes" xml:space="preserve">
          <source>This column always contains an integer value greater than zero.</source>
          <target state="translated">Этот столбец всегда содержит целое значение больше нуля.</target>
        </trans-unit>
        <trans-unit id="1713bd9e06b77e4bbf5df2753a784a802e3933b6" translate="yes" xml:space="preserve">
          <source>This column determines which &lt;a href=&quot;fts3#*fts4languageid&quot; id=&quot;f4alid&quot;&gt;languageid&lt;/a&gt; is used to extract vocabulary from the FTS3/4 table.</source>
          <target state="translated">Этот столбец определяет, какой идентификатор &lt;a href=&quot;fts3#*fts4languageid&quot; id=&quot;f4alid&quot;&gt;языка&lt;/a&gt; используется для извлечения словаря из таблицы FTS3 / 4.</target>
        </trans-unit>
        <trans-unit id="285c275d9591ca00ecba379d1be0f439e124856e" translate="yes" xml:space="preserve">
          <source>This column may contain either the text value '*' (i.e. a single character, U+002a) or an integer between 0 and N-1, where N is again the number of user-defined columns in the corresponding FTS table.</source>
          <target state="translated">Этот столбец может содержать либо текстовое значение '*' (т.е.один символ,U+002a),либо целое число между 0 и N-1,где N-это опять же количество пользовательских столбцов в соответствующей таблице FTS.</target>
        </trans-unit>
        <trans-unit id="65f82075152c89e2aff2366597dc220e2a3e5878" translate="yes" xml:space="preserve">
          <source>This column must be set to NULL. If a non-NULL value is inserted into this column, or if a new non-NULL value is provided using an UPDATE statement, it is an error.</source>
          <target state="translated">Этот столбец должен быть установлен в NULL.Если в этот столбец вставлено значение,отличное от NULL,или если новое значение,отличное от NULL,предоставлено с помощью оператора UPDATE,это является ошибкой.</target>
        </trans-unit>
        <trans-unit id="e9e3819e4d76ebe92176deabc7d0279eab9fbfc8" translate="yes" xml:space="preserve">
          <source>This column shows the phonetic hash prefix that was used to restrict the search. For any given query, this column should be the same for every row. This information is available for diagnostic purposes and is not normally considered useful in real applications.</source>
          <target state="translated">В этой колонке показан префикс фонетического хэша,который использовался для ограничения поиска.Для любого заданного запроса этот столбец должен быть одинаковым для каждой строки.Эта информация доступна для диагностических целей и обычно не считается полезной в реальных приложениях.</target>
        </trans-unit>
        <trans-unit id="01288c4cfddc172d238625a965b9f1003be61617" translate="yes" xml:space="preserve">
          <source>This command both creates the new repository and populates it with all the latest SQLite code. You can then create a private branch as described in section 3.4.</source>
          <target state="translated">Эта команда как создает новый репозиторий,так и заполняет его последним кодом SQLite.Затем вы можете создать личную ветку,как описано в разделе 3.4.</target>
        </trans-unit>
        <trans-unit id="e0ca6b6ac38f5b817649e53a976402c687ab2fa8" translate="yes" xml:space="preserve">
          <source>This command causes SQLite to disconnect from the previous database and reattach to an in-memory database with the content in</source>
          <target state="translated">Эта команда вызывает отключение SQLite от предыдущей БД и повторное подключение к БД in-memory с содержимым в формате</target>
        </trans-unit>
        <trans-unit id="52245829743ea4e1b3e2fa49a0972f85d14c8fbb" translate="yes" xml:space="preserve">
          <source>This command causes the &quot;callback&quot; script to be invoked whenever certain conditions occurs. The conditions are determined by the</source>
          <target state="translated">Эта команда вызывает сценарий &quot;обратного вызова&quot; при возникновении определенных условий.Условия определяются</target>
        </trans-unit>
        <trans-unit id="13f59d1cb3e06c83ff056103acea107f7910080d" translate="yes" xml:space="preserve">
          <source>This command first deletes the entire full-text index, then rebuilds it based on the contents of the table or &lt;a href=&quot;fts5#external_content_tables&quot;&gt;content table&lt;/a&gt;. It is not available with &lt;a href=&quot;fts5#contentless_tables&quot;&gt;contentless tables&lt;/a&gt;.</source>
          <target state="translated">Эта команда сначала удаляет весь полнотекстовый индекс, а затем перестраивает его на основе содержимого таблицы или &lt;a href=&quot;fts5#external_content_tables&quot;&gt;таблицы содержимого&lt;/a&gt; . Это недоступно для &lt;a href=&quot;fts5#contentless_tables&quot;&gt;таблиц без содержимого&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fe5638fc83b6cdbce8fdc02e570b8e2b10a1482f" translate="yes" xml:space="preserve">
          <source>This command is only available with &lt;a href=&quot;fts5#external_content_tables&quot;&gt;external content&lt;/a&gt; and &lt;a href=&quot;fts5#contentless_tables&quot;&gt;contentless&lt;/a&gt; tables. It deletes all entries from the full-text index.</source>
          <target state="translated">Эта команда доступна только с &lt;a href=&quot;fts5#external_content_tables&quot;&gt;внешним содержанием&lt;/a&gt; и &lt;a href=&quot;fts5#contentless_tables&quot;&gt;бессодержательными&lt;/a&gt; таблицами. Удаляет все записи из полнотекстового индекса.</target>
        </trans-unit>
        <trans-unit id="7489ecbcacef562551b65244089f9307c364a891" translate="yes" xml:space="preserve">
          <source>This command is only available with &lt;a href=&quot;fts5#external_content_tables&quot;&gt;external content&lt;/a&gt; and &lt;a href=&quot;fts5#contentless_tables&quot;&gt;contentless&lt;/a&gt; tables. It is used to delete the index entries associated with a single row from the full-text index. This command and the &lt;a href=&quot;fts5#the_delete_all_command&quot;&gt;delete-all&lt;/a&gt; command are the only ways to remove entries from the full-text index of a contentless table.</source>
          <target state="translated">Эта команда доступна только с &lt;a href=&quot;fts5#external_content_tables&quot;&gt;внешним содержанием&lt;/a&gt; и &lt;a href=&quot;fts5#contentless_tables&quot;&gt;бессодержательными&lt;/a&gt; таблицами. Он используется для удаления записей индекса, связанных с одной строкой, из полнотекстового индекса. Эта команда и команда &lt;a href=&quot;fts5#the_delete_all_command&quot;&gt;delete-all&lt;/a&gt; - единственные способы удалить записи из полнотекстового индекса таблицы без содержимого.</target>
        </trans-unit>
        <trans-unit id="a1d13a5c03e8731ed6d7cfb96b7277fb1a9eb4b2" translate="yes" xml:space="preserve">
          <source>This command is used to set the persistent &quot;pgsz&quot; option.</source>
          <target state="translated">Эта команда используется для установки постоянной опции &quot;pgsz&quot;.</target>
        </trans-unit>
        <trans-unit id="b39428042e588fc7d00e73c6e90326dc9e9ea85b" translate="yes" xml:space="preserve">
          <source>This command is used to set the persistent &quot;rank&quot; option.</source>
          <target state="translated">Эта команда используется для установки постоянной опции &quot;ранга&quot;.</target>
        </trans-unit>
        <trans-unit id="85b16bab1c29894a0c668469c8830c0b869b0913" translate="yes" xml:space="preserve">
          <source>This command is used to set the persistent &quot;usermerge&quot; option.</source>
          <target state="translated">Эта команда используется для установки постоянной опции &quot;usermerge&quot;.</target>
        </trans-unit>
        <trans-unit id="3730a7c5668daaf6af3f627c894d5a241eb8942e" translate="yes" xml:space="preserve">
          <source>This command is used to verify that the full-text index is consistent with the contents of the FTS5 table or &lt;a href=&quot;fts5#external_content_tables&quot;&gt;content table&lt;/a&gt;. It is not available with &lt;a href=&quot;fts5#contentless_tables&quot;&gt;contentless tables&lt;/a&gt;.</source>
          <target state="translated">Эта команда используется для проверки того, что полнотекстовый индекс соответствует содержимому таблицы FTS5 или &lt;a href=&quot;fts5#external_content_tables&quot;&gt;таблицы содержимого&lt;/a&gt; . Это недоступно для &lt;a href=&quot;fts5#contentless_tables&quot;&gt;таблиц без содержимого&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="88394100e2d09fedf8acbb803e727baf438dfa1d" translate="yes" xml:space="preserve">
          <source>This command is used to verify that the full-text index is internally consistent, and, optionally, that it is consistent with any &lt;a href=&quot;fts5#external_content_tables&quot;&gt;external content&lt;/a&gt; table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a574335749833522810d0e9deb16c3b1a8c4736" translate="yes" xml:space="preserve">
          <source>This command may also be used with ordinary FTS4 tables, for example if the implementation of the tokenizer changes. It is an error to attempt to rebuild the full-text index maintained by a contentless FTS4 table, since no content will be available to do the rebuilding.</source>
          <target state="translated">Эта команда также может быть использована с обычными таблицами FTS4,например,если изменяется реализация токенайзера.Ошибкой является попытка пересборки полнотекстового индекса,поддерживаемого бесхозной таблицей FTS4,так как при этом не будет доступно никакого содержимого для пересборки.</target>
        </trans-unit>
        <trans-unit id="61072f8fd085f0b1c6b3c6456d8203db4cf536aa" translate="yes" xml:space="preserve">
          <source>This command merges all individual b-trees that currently make up the full-text index into a single large b-tree structure. This ensures that the full-text index consumes the minimum space within the database and is in the fastest form to query.</source>
          <target state="translated">Эта команда объединяет все отдельные b-деревья,которые в настоящее время составляют полнотекстовый указатель,в одну большую b-деревневую структуру.Это гарантирует,что полнотекстовый индекс занимает минимальное пространство в БД и находится в самой быстрой форме для запроса.</target>
        </trans-unit>
        <trans-unit id="51ac15b2185be7d66cfb5466a048917c1313d8ae" translate="yes" xml:space="preserve">
          <source>This command merges b-tree structures together until roughly N pages of merged data have been written to the database, where N is the absolute value of the parameter specified as part of the 'merge' command. The size of each page is as configured by the &lt;a href=&quot;fts5#the_pgsz_configuration_option&quot;&gt;FTS5 pgsz option&lt;/a&gt;.</source>
          <target state="translated">Эта команда объединяет структуры b-дерева вместе до тех пор, пока в базу данных не будет записано примерно N страниц объединенных данных, где N - абсолютное значение параметра, указанного как часть команды &amp;laquo;слияния&amp;raquo;. Размер каждой страницы настраивается параметром &lt;a href=&quot;fts5#the_pgsz_configuration_option&quot;&gt;FTS5 pgsz&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ebea130f81253f3360e54a067f92438ad94ce3d5" translate="yes" xml:space="preserve">
          <source>This command sequence is a lot to memorize and type. (One would want to create a bash alias or short shell script if it were used frequently.) Furthermore, it is not quite the same thing. The command above gives one a list of descendents without showing the branching structure, which is important for understanding what happened. And the command only works if you have a local clone of the repository; finding the descendents of a check-in is not something you can do with common web interfaces such as GitHub or GitLab.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6ccb891d0018f34c8b539ed4ad53a6be49ac1c9" translate="yes" xml:space="preserve">
          <source>This command sequence is a lot to memorize and type. (One would want to create a bash alias or short shell script if it were used frequently.) Furthermore, it is not quite the same thing. The command above gives one a list of descendents without showing the branching structure, which is important for understanding what happened. In contrast, Fossil offers displays such as &lt;a href=&quot;https://sqlite.org/src/timeline?d=8a439a6dda390d74&amp;amp;n=15&quot;&gt;https://sqlite.org/src/timeline?d=8a439a6dda390d74&amp;amp;n=15&lt;/a&gt;, which is a tremendous help in analyzing the aftermath of historical changes.</source>
          <target state="translated">Эта последовательность команд требует запоминания и ввода. (Можно было бы создать псевдоним bash или короткий сценарий оболочки, если бы он использовался часто.) Более того, это не совсем то же самое. Приведенная выше команда дает список потомков без отображения структуры ветвления, что важно для понимания того, что произошло. В отличие от этого Fossil предлагает такие дисплеи, как &lt;a href=&quot;https://sqlite.org/src/timeline?d=8a439a6dda390d74&amp;amp;n=15&quot;&gt;https://sqlite.org/src/timeline?d=8a439a6dda390d74&amp;amp;n=15&lt;/a&gt; , что очень помогает при анализе последствий исторических изменений.</target>
        </trans-unit>
        <trans-unit id="309dfaa9b377c5a8af4ac33fa681865f1bffbfb3" translate="yes" xml:space="preserve">
          <source>This command will create a new branch named &quot;private&quot; (you can use a different name if you like) and assign it a background color of light blue (&quot;#add8e8&quot;). You can omit the background color if you want, though having a distinct background does make it easier to tell the branch from the &quot;trunk&quot; (the public branch) on timeline displays. You can change the background color of the private branch or of the public branch (the &quot;trunk&quot;) using the web interface if you like.</source>
          <target state="translated">Эта команда создаст новую ветку с названием &quot;private&quot; (при желании вы можете использовать другое имя)и присвоит ей цвет фона светло-голубого (&quot;#add8e8&quot;).Вы можете опустить цвет фона,если хотите,хотя наличие отдельного фона действительно облегчает определение ответвления из &quot;ствола&quot; (&quot;общественного ответвления&quot;)на дисплеях шкалы времени.Вы можете изменить цвет фона частного ответвления или общего ответвления (&quot;ствол&quot;),используя веб-интерфейс,если хотите.</target>
        </trans-unit>
        <trans-unit id="5db5e98e2fd20bba8ab658518e972deb34aab3ef" translate="yes" xml:space="preserve">
          <source>This command-line shell leaves unnamed parameters unbound, meaning that they will have a value of an SQL NULL, but named parameters might be assigned values. If there exists a TEMP table named &quot;sqlite_parameters&quot; with a schema like this:</source>
          <target state="translated">Эта оболочка командной строки оставляет безымянные параметры не связанными,что означает,что они будут иметь значение SQL NULL,но именованным параметрам могут быть присвоены значения.Если существует таблица TEMP с именем &quot;sqlite_parameters&quot;,то есть такая схема:</target>
        </trans-unit>
        <trans-unit id="4c4b4e9517b3e559a4264bd38d883b4075b15dd6" translate="yes" xml:space="preserve">
          <source>This compile-time option affects the SQL &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; operator only and has no impact on the &lt;a href=&quot;c3ref/strlike&quot;&gt;sqlite3_strlike()&lt;/a&gt; C-language interface.</source>
          <target state="translated">Этот параметр времени компиляции влияет только на оператор SQL &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; и не влияет на интерфейс языка Си &lt;a href=&quot;c3ref/strlike&quot;&gt;sqlite3_strlike ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6c67f3211a79226589052fa652c6121f10cd5b9d" translate="yes" xml:space="preserve">
          <source>This compile-time option causes the &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; operator to always return False if either operand is a BLOB. The default behavior of &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; is that BLOB operands are cast to TEXT before the comparison is done.</source>
          <target state="translated">Эта опция времени компиляции заставляет оператор &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; всегда возвращать значение False, если какой-либо из операндов является BLOB. По умолчанию &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; приводит к преобразованию операндов BLOB в TEXT до того, как будет выполнено сравнение.</target>
        </trans-unit>
        <trans-unit id="b087b90d5f82c6cd11bb4d6150e1edc15e3c7080" translate="yes" xml:space="preserve">
          <source>This compile-time option changes the default setting of the &lt;a href=&quot;pragma#pragma_secure_delete&quot;&gt;secure_delete pragma&lt;/a&gt;. When this option is not used, secure_delete defaults to off. When this option is present, secure_delete defaults to on.</source>
          <target state="translated">Этот параметр времени компиляции изменяет настройку по умолчанию &lt;a href=&quot;pragma#pragma_secure_delete&quot;&gt;прагмы secure_delete&lt;/a&gt; . Когда этот параметр не используется, secure_delete по умолчанию выключен. Когда присутствует этот параметр, secure_delete по умолчанию включен.</target>
        </trans-unit>
        <trans-unit id="ec3013abfee74643b8705338ad5e107049f5af6c" translate="yes" xml:space="preserve">
          <source>This compile-time option disables the &lt;a href=&quot;pragma#pragma_case_sensitive_like&quot;&gt;PRAGMA case_sensitive_like&lt;/a&gt; command.</source>
          <target state="translated">Эта опция времени компиляции отключает команду &lt;a href=&quot;pragma#pragma_case_sensitive_like&quot;&gt;PRAGMA case_sensitive_like&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3400d01afcac3cfb7345138b17405acb7d27f932" translate="yes" xml:space="preserve">
          <source>This compile-time option enables SQLite to take advantage batch atomic write capabilities in the underlying filesystem. As of SQLite version 3.21.0 (2017-10-24) this is only supported on &lt;a href=&quot;https://en.wikipedia.org/wiki/F2FS&quot;&gt;F2FS&lt;/a&gt;. However, the interface is implemented generically, using &lt;a href=&quot;c3ref/file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; with &lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&lt;/a&gt; and &lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlcommitatomicwrite&quot;&gt;SQLITE_FCNTL_COMMIT_ATOMIC_WRITE&lt;/a&gt; so the capability can be added to other filesystem times in the future. When this option is enabled, SQLite automatically detects that the underlying filesystem supports batch atomic writes, and when it does so it avoids writing the &lt;a href=&quot;lockingv3#rollback&quot;&gt;rollback journal&lt;/a&gt; for transaction control. This can make transactions over twice as fast, while simultaneously reducing wear on SSD storage devices.</source>
          <target state="translated">Эта опция времени компиляции позволяет SQLite использовать возможности пакетной атомарной записи в базовой файловой системе. Начиная с версии SQLite 3.21.0 (2017-10-24) это поддерживается только в &lt;a href=&quot;https://en.wikipedia.org/wiki/F2FS&quot;&gt;F2FS&lt;/a&gt; . Однако интерфейс реализован в общем виде с использованием &lt;a href=&quot;c3ref/file_control&quot;&gt;sqlite3_file_control ()&lt;/a&gt; с &lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&lt;/a&gt; и &lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlcommitatomicwrite&quot;&gt;SQLITE_FCNTL_COMMIT_ATOMIC_WRITE,&lt;/a&gt; поэтому возможность может быть добавлена ​​к другим временам файловой системы в будущем. Когда эта опция включена, SQLite автоматически определяет, что базовая файловая система поддерживает пакетную атомарную запись, и когда это происходит, он избегает записи &lt;a href=&quot;lockingv3#rollback&quot;&gt;журнала отката.&lt;/a&gt;для контроля транзакций. Это может ускорить транзакции более чем в два раза и одновременно снизить износ SSD-накопителей.</target>
        </trans-unit>
        <trans-unit id="2a47cb88e70b43c326cbb7cc659779aee23f98fe" translate="yes" xml:space="preserve">
          <source>This compile-time option enables the &lt;a href=&quot;stmt&quot;&gt;SQLITE_STMT virtual table&lt;/a&gt; logic.</source>
          <target state="translated">Эта опция времени компиляции включает &lt;a href=&quot;stmt&quot;&gt;логику виртуальной таблицы SQLITE_STMT&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ff47a638485535b8abdf68c6579ec40497b2ae91" translate="yes" xml:space="preserve">
          <source>This compile-time option has been renamed to &lt;a href=&quot;compile#untestable&quot;&gt;SQLITE_UNTESTABLE&lt;/a&gt;.</source>
          <target state="translated">Этот параметр времени компиляции был переименован в &lt;a href=&quot;compile#untestable&quot;&gt;SQLITE_UNTESTABLE&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e0b75f253921594adb213c37bae38c55286027e5" translate="yes" xml:space="preserve">
          <source>This compile-time option is deprecated and untested.</source>
          <target state="translated">Этот параметр времени компиляции является устаревшим и непроверенным.</target>
        </trans-unit>
        <trans-unit id="3be0a309752742e7707ae2403c4dadee6c132ddc" translate="yes" xml:space="preserve">
          <source>This compile-time option is no longer used.</source>
          <target state="translated">Этот параметр времени компиляции больше не используется.</target>
        </trans-unit>
        <trans-unit id="4333e0a432302d984fdf33eabb1d1ed8fc11d61a" translate="yes" xml:space="preserve">
          <source>This compile-time option makes SQLite run more efficiently when processing queries that use the &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; operator, at the expense of breaking backwards compatibility. However, the backwards compatibility break may be only a technicality. There was a long-standing bug in the &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; processing logic (see &lt;a href=&quot;https://www.sqlite.org/src/info/05f43be8fdda9f&quot;&gt;https://www.sqlite.org/src/info/05f43be8fdda9f&lt;/a&gt;) that caused it to misbehavior for BLOB operands and nobody observed that bug in nearly 10 years of active use. So for more users, it is probably safe to enable this compile-time option and thereby save a little CPU time on LIKE queries.</source>
          <target state="translated">Этот параметр времени компиляции позволяет SQLite работать более эффективно при обработке запросов, использующих оператор &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; , за счет нарушения обратной совместимости. Однако нарушение обратной совместимости может быть чисто техническим. В логике обработки &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; была давняя ошибка (см. &lt;a href=&quot;https://www.sqlite.org/src/info/05f43be8fdda9f&quot;&gt;Https://www.sqlite.org/src/info/05f43be8fdda9f&lt;/a&gt; ), которая приводила к неправильному поведению операндов BLOB, и никто не заметил эту ошибку почти за 10 лет активного использования. . Так что для большего числа пользователей, вероятно, будет безопасно включить эту опцию времени компиляции и тем самым сэкономить немного времени ЦП на запросах LIKE.</target>
        </trans-unit>
        <trans-unit id="65b9357f2e420dd3508c81b4ae3257d2786b19ca" translate="yes" xml:space="preserve">
          <source>This constraint arises from the fact that numbers do not sort in lexicographical order. For example: 9&amp;lt;10 but '9'&amp;gt;'10'.</source>
          <target state="translated">Это ограничение возникает из-за того, что числа не сортируются в лексикографическом порядке. Например: 9 &amp;lt;10, но &amp;laquo;9&amp;raquo;&amp;gt; &amp;laquo;10&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="187432feb7a09e6addc8b4c1a243d9ef78920104" translate="yes" xml:space="preserve">
          <source>This design note considers the database to be a collection of objects. Each SQL table is a class. Each row is an instance of that class. There are, of course, other ways to interpret an SQL database schema, and the techniques described here work equally well under alternative interpretations, but an object-oriented view seems be more natural to most contemporary programmers.</source>
          <target state="translated">В данной проектной записке база данных рассматривается как собрание объектов.Каждая таблица SQL является классом.Каждая строка является экземпляром этого класса.Конечно,существуют и другие способы интерпретации схемы базы данных SQL,и описанные здесь приемы одинаково хорошо работают при альтернативных интерпретациях,но объектно-ориентированный вид кажется более естественным большинству современных программистов.</target>
        </trans-unit>
        <trans-unit id="993ca572c239731efd1af6cd763b4c9301db3d59" translate="yes" xml:space="preserve">
          <source>This document continues to be used for its original purpose - providing a reference to fill in the &quot;code of conduct&quot; box on supplier registration forms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f5cd63f8a1306fc33b54e6f33d75fb0c8f5824b" translate="yes" xml:space="preserve">
          <source>This document describes SQLite internals. The information provided here is not needed for routine application development using SQLite. This document is intended for people who want to delve more deeply into the internal operation of SQLite.</source>
          <target state="translated">Этот документ описывает внутреннюю структуру SQLite.Приведенная здесь информация не требуется для рутинной разработки приложений с использованием SQLite.Этот документ предназначен для людей,которые хотят глубже погрузиться во внутреннюю работу SQLite.</target>
        </trans-unit>
        <trans-unit id="29000c12ac32a9037c669c50606cdb73ab6f60c1" translate="yes" xml:space="preserve">
          <source>This document describes and defines the on-disk database file format used by all releases of SQLite since version 3.0.0 (2004-06-18).</source>
          <target state="translated">Этот документ описывает и определяет формат файлов базы данных на диске,используемый во всех релизах SQLite,начиная с версии 3.0.0 (2004-06-18).</target>
        </trans-unit>
        <trans-unit id="dc53982e7fc871bc167dd841afd5d1fa7b1536a4" translate="yes" xml:space="preserve">
          <source>This document describes how to obtain the canonical source code for SQLite - the raw source files from which the amalgamation is built. See the &lt;a href=&quot;howtocompile&quot;&gt;How To Compile SQLite&lt;/a&gt; page for additional information on what to do with the canonical source code once it is obtained.</source>
          <target state="translated">В этом документе описывается, как получить канонический исходный код для SQLite - необработанные исходные файлы, из которых создается объединение. См. Страницу &amp;laquo; &lt;a href=&quot;howtocompile&quot;&gt;Как компилировать SQLite&amp;raquo;&lt;/a&gt; для получения дополнительной информации о том, что делать с каноническим исходным кодом после его получения.</target>
        </trans-unit>
        <trans-unit id="8cb17c7b427d4b622c77f47d250d842b7e4339f9" translate="yes" xml:space="preserve">
          <source>This document describes in detail the way that SQLite uses the API provided by the VFS adaptor component to solve the problems and implement the strategies enumerated above. It also specifies the assumptions made about the properties of the system that the VFS adaptor provides access to. For example, specific assumptions about the extent of data corruption that may occur if a power failure occurs while a database file is being updated are presented in section</source>
          <target state="translated">Этот документ подробно описывает,как SQLite использует API,предоставляемый компонентом VFS адаптера,для решения проблем и реализации перечисленных выше стратегий.В нем также указаны допущения о свойствах системы,к которым VFS-адаптер предоставляет доступ.Например,в разделе представлены конкретные предположения о степени повреждения данных,которое может произойти в случае сбоя питания во время обновления файла базы данных.</target>
        </trans-unit>
        <trans-unit id="7da4581d4d5128e1ce5220b57b58fd4271a11dba" translate="yes" xml:space="preserve">
          <source>This document describes incompatibilities that have occurred in SQLite prior to 2004. Since 2004, there have been enhancements to SQLite such that newer database files are unreadable by older versions of the SQLite library. But the most recent versions of the SQLite library should be able to read and write any older SQLite database file without any problems.</source>
          <target state="translated">Этот документ описывает несовместимости,которые имели место в SQLite до 2004 года.С 2004 года в SQLite появились улучшения,которые сделали более новые файлы баз данных нечитаемыми старыми версиями библиотеки SQLite.Однако последние версии библиотеки SQLite должны иметь возможность без проблем читать и писать любые старые файлы баз данных SQLite.</target>
        </trans-unit>
        <trans-unit id="522199e4ebe6e710a972b890a7a5a64190cc5d3b" translate="yes" xml:space="preserve">
          <source>This document describes low-level details on how &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt; is implemented on unix and windows.</source>
          <target state="translated">Этот документ описывает низкоуровневую информацию о том, как &lt;a href=&quot;wal&quot;&gt;режим WAL&lt;/a&gt; реализован в unix и Windows.</target>
        </trans-unit>
        <trans-unit id="86876920b62069808dcd8a4f6cfa725666d13fe3" translate="yes" xml:space="preserve">
          <source>This document describes the architecture of the SQLite library. The information here is useful to those who want to understand or modify the inner workings of SQLite.</source>
          <target state="translated">Этот документ описывает архитектуру библиотеки SQLite.Информация здесь полезна тем,кто хочет понять или модифицировать внутренние механизмы работы SQLite.</target>
        </trans-unit>
        <trans-unit id="4d320774e9898d3525e4d8d7e2967bd5937be4b0" translate="yes" xml:space="preserve">
          <source>This document describes the support for SQL foreign key constraints introduced in SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_6_19.html&quot;&gt;version 3.6.19&lt;/a&gt; (2009-10-14).</source>
          <target state="translated">В этом документе описывается поддержка ограничений внешнего ключа SQL, представленная в SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_6_19.html&quot;&gt;версии 3.6.19&lt;/a&gt; (2009-10-14).</target>
        </trans-unit>
        <trans-unit id="2bc5a2a4190725779b47fa8957802675b43bcdcd" translate="yes" xml:space="preserve">
          <source>This document does not contain a full description of the syntax used to create foreign key constraints in SQLite. This may be found as part of the documentation for the &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; statement.</source>
          <target state="translated">Этот документ не содержит полного описания синтаксиса, используемого для создания ограничений внешнего ключа в SQLite. Это можно найти как часть документации для оператора &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1a95f5bdc9ff03cc2aba9a9f1c4e965180076c32" translate="yes" xml:space="preserve">
          <source>This document does not specify the details of the interface that must be implemented by the VFS adaptor component, that is left to</source>
          <target state="translated">В данном документе не уточняются детали интерфейса,которые должны быть реализованы компонентом VFS-адаптера,т.е.остаётся только</target>
        </trans-unit>
        <trans-unit id="4458da44ee2dc70541cbb9f7f722e55f2e9b165b" translate="yes" xml:space="preserve">
          <source>This document focuses on the NGQP. For a more general overview of the SQLite query planner that encompasses the entire history of SQLite, see the &quot;&lt;a href=&quot;optoverview&quot;&gt;The SQLite Query Optimizer Overview&lt;/a&gt;&quot; and &quot;&lt;a href=&quot;queryplanner&quot;&gt;How Indexes Work&lt;/a&gt;&quot; documents.</source>
          <target state="translated">Этот документ посвящен NGQP. Для более общего обзора планировщика запросов SQLite, который охватывает всю историю SQLite, см. &lt;a href=&quot;optoverview&quot;&gt;Документы &amp;laquo;Обзор оптимизатора запросов SQLite&lt;/a&gt; &amp;raquo; и &amp;laquo; &lt;a href=&quot;queryplanner&quot;&gt;Как работают индексы&lt;/a&gt; &amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="da2a96113e96df4cba87ef0ebb6ecd70e207ec5c" translate="yes" xml:space="preserve">
          <source>This document gives an overview of the Tcl programming interface for SQLite.</source>
          <target state="translated">Этот документ дает обзор интерфейса программирования Tcl для SQLite.</target>
        </trans-unit>
        <trans-unit id="a5a4e1d46e6e2a3f39086d506303b41bc25dcc9a" translate="yes" xml:space="preserve">
          <source>This document is a quick introduction to the changes for SQLite 3.0 for users who are already familiar with SQLite version 2.8.</source>
          <target state="translated">Этот документ является кратким введением в изменения для SQLite 3.0 для пользователей,которые уже знакомы с SQLite версии 2.8.</target>
        </trans-unit>
        <trans-unit id="c1c02e760418d224f0c07cba5a70ec82e928ba41" translate="yes" xml:space="preserve">
          <source>This document is an introduction to the session extension. The details of the interface are in the separate &lt;a href=&quot;https://sqlite.org/session/intro.html&quot;&gt;Session Extension C-language Interface&lt;/a&gt; document.</source>
          <target state="translated">Этот документ представляет собой введение в расширение сеанса. Подробная информация об интерфейсе находится в отдельном документе &amp;laquo; &lt;a href=&quot;https://sqlite.org/session/intro.html&quot;&gt;Интерфейс на языке Си для расширения сеанса&amp;raquo;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3ff7ff01849be2d401b1d6230764460ab55eb57e" translate="yes" xml:space="preserve">
          <source>This document is concerned with the persistent state of the database file, and since the wal-index is a transient structure, no further information about the format of the wal-index will be provided here. Additional details on the format of the wal-index are contained in the separate &lt;a href=&quot;walformat#walidxfmt&quot;&gt;WAL-index File Format&lt;/a&gt; document.</source>
          <target state="translated">Этот документ касается постоянного состояния файла базы данных, и поскольку wal-index является временной структурой, никакой дополнительной информации о формате wal-index здесь не будет. Дополнительная информация о формате wal-index содержится в отдельном документе &lt;a href=&quot;walformat#walidxfmt&quot;&gt;WAL-index File Format&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ce4f9d4c36f7d70e8b9276d0825d097968bc414d" translate="yes" xml:space="preserve">
          <source>This document is created by a script which scans comments in the source code file sqlite3session.h.</source>
          <target state="translated">Этот документ создан скриптом,который сканирует комментарии в файле исходного кода sqlite3session.h.</target>
        </trans-unit>
        <trans-unit id="d12748856fa96aaf8fec02bb978ea061f37e25d7" translate="yes" xml:space="preserve">
          <source>This document is still sometimes used as a &quot;Code of Conduct&quot; on supplier registration forms. But it is not a Code of Conduct in the same sense that many communities mean a Code of Conduct. Rather, this document describes the ethical principles upon which SQLite is based. Another way to look at this document is as a succinct description of the SQLite Founder's idea of what it means to be &quot;virtuous&quot;.</source>
          <target state="translated">Этот документ до сих пор иногда используется в качестве &quot;Кодекса поведения&quot; на регистрационных бланках поставщиков.Однако это не Кодекс поведения в том смысле,в каком его понимают многие сообщества.Скорее,этот документ описывает этические принципы,на которых основан SQLite.Другой способ взглянуть на этот документ-это краткое описание идеи Основателя SQLite о том,что значит быть &quot;добродетельным&quot;.</target>
        </trans-unit>
        <trans-unit id="6ead8dcfb3bc7787acee358a9c3c6b55198ad643" translate="yes" xml:space="preserve">
          <source>This document proposes to use &lt;a href=&quot;http://www.fossil-scm.org/&quot;&gt;fossil&lt;/a&gt;, but any other distributed software configuration management system such as &lt;a href=&quot;http://www.monotone.ca/&quot;&gt;monotone&lt;/a&gt; or &lt;a href=&quot;http://www.selenic.com/mercurial/wiki/&quot;&gt;mercurial&lt;/a&gt; (a.k.a. &quot;hg&quot;), or &lt;a href=&quot;http://www.git-scm.org/&quot;&gt;git&lt;/a&gt; could serve just as well. The concept will be the same, though the specifics of the procedure will vary.</source>
          <target state="translated">В этом документе предлагается использовать &lt;a href=&quot;http://www.fossil-scm.org/&quot;&gt;fossil&lt;/a&gt; , но также может подойти любая другая распределенная система управления конфигурацией программного обеспечения, такая как &lt;a href=&quot;http://www.monotone.ca/&quot;&gt;monotone&lt;/a&gt; или &lt;a href=&quot;http://www.selenic.com/mercurial/wiki/&quot;&gt;mercurial&lt;/a&gt; (также известная как &amp;laquo;hg&amp;raquo;) или &lt;a href=&quot;http://www.git-scm.org/&quot;&gt;git&lt;/a&gt; . Концепция останется прежней, но особенности процедуры будут отличаться.</target>
        </trans-unit>
        <trans-unit id="636ec508d7120bd68ebd06cf51f54cbf7197b652" translate="yes" xml:space="preserve">
          <source>This document proposes to use &lt;a href=&quot;https://www.fossil-scm.org/&quot;&gt;fossil&lt;/a&gt;, but any other distributed software configuration management system such as &lt;a href=&quot;http://www.monotone.ca/&quot;&gt;monotone&lt;/a&gt; or &lt;a href=&quot;http://www.selenic.com/mercurial/wiki/&quot;&gt;mercurial&lt;/a&gt; (a.k.a. &quot;hg&quot;), or &lt;a href=&quot;http://www.git-scm.org/&quot;&gt;git&lt;/a&gt; could serve just as well. The concept will be the same, though the specifics of the procedure will vary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98d1415d454d0b20f9e20df74b68698917685b9f" translate="yes" xml:space="preserve">
          <source>This document provides an overview of dynamic memory allocation within SQLite. The target audience is software engineers who are tuning their use of SQLite for peak performance in demanding environments. Nothing in this document is required knowledge for using SQLite. The default settings and configuration for SQLite will work well in most applications. However, the information contained in this document may be useful to engineers who are tuning SQLite to comply with special requirements or to run under unusual circumstances.</source>
          <target state="translated">В данном документе представлен обзор динамического выделения памяти в SQLite.Целевая аудитория-разработчики программного обеспечения,которые настраивают использование SQLite для достижения максимальной производительности в сложных средах.Ничего в этом документе не требует знаний для использования SQLite.Настройки и конфигурация SQLite по умолчанию будут хорошо работать в большинстве приложений.Тем не менее,информация,содержащаяся в этом документе,может быть полезна для инженеров,которые настраивают SQLite в соответствии с особыми требованиями или для работы в необычных условиях.</target>
        </trans-unit>
        <trans-unit id="c06afae30b0b7293df04fe27c7c538132693e4c6" translate="yes" xml:space="preserve">
          <source>This document provides an overview of how the query planner and optimizer for SQLite works.</source>
          <target state="translated">В этом документе представлен обзор работы планировщика запросов и оптимизатора для SQLite.</target>
        </trans-unit>
        <trans-unit id="54a3569b4cf066b2b50e3e942ef2c48ddc1b1732" translate="yes" xml:space="preserve">
          <source>This document provides background information about how the SQLite query planner and query engine work. Programmers can use this information to help create better indexes, and provide hints to help the query planner when needed.</source>
          <target state="translated">Этот документ содержит справочную информацию о том,как работает планировщик запросов SQLite и механизм запросов.Программисты могут использовать эту информацию для создания более качественных индексов и при необходимости давать подсказки,которые помогут планировщику запросов.</target>
        </trans-unit>
        <trans-unit id="db48c0715525eb5ade6fdd8bc0b1d41936f8012f" translate="yes" xml:space="preserve">
          <source>This document strives to highlight the principal differences between SQLite and other SQL implementations, as an aid to developers that are porting to or from SQLite or who are trying to build a system that works across multiple database engines.</source>
          <target state="translated">Этот документ стремится подчеркнуть основные различия между SQLite и другими реализациями SQL,в качестве подспорья для разработчиков,осуществляющих перенос на SQLite или с SQLite,или пытающихся построить систему,работающую с несколькими движками баз данных.</target>
        </trans-unit>
        <trans-unit id="499e5ba33e0583ef7d40d010da72b3c26c5f57b3" translate="yes" xml:space="preserve">
          <source>This document was originally called a &quot;Code of Conduct&quot; and was created (in a slightly different format) for the purpose of filling in a box on &quot;supplier registration&quot; forms submitted to the SQLite developers by various minor clients. However, we subsequently learned that &quot;Code of Conduct&quot; has a specific technical meaning within many software development communities, a meaning which was at odds with the intent of this document. Hence, this document is now renamed and replaced by a &lt;a href=&quot;codeofconduct&quot;&gt;Code of Conduct&lt;/a&gt; that does comply with the specific technical requirements was inserted in the place of the old name.</source>
          <target state="translated">Этот документ первоначально назывался &amp;laquo;Кодекс поведения&amp;raquo; и был создан (в несколько ином формате) с целью заполнения поля в формах &amp;laquo;регистрации поставщика&amp;raquo;, отправленных разработчикам SQLite различными второстепенными клиентами. Однако впоследствии мы узнали, что &amp;laquo;Кодекс поведения&amp;raquo; имеет особое техническое значение во многих сообществах разработчиков программного обеспечения, значение, которое расходится с целью этого документа. Следовательно, этот документ теперь переименован и заменен &lt;a href=&quot;codeofconduct&quot;&gt;Кодексом поведения,&lt;/a&gt; который действительно соответствует определенным техническим требованиям, был вставлен вместо старого названия.</target>
        </trans-unit>
        <trans-unit id="2f633f3ae0dff80c772cce82ec3bac74e6a081e1" translate="yes" xml:space="preserve">
          <source>This document was originally called a &quot;Code of Conduct&quot; and was created for the purpose of filling in a box on &quot;supplier registration&quot; forms submitted to the SQLite developers by some clients. However, we subsequently learned that &quot;Code of Conduct&quot; has a very specific and almost sacred meaning to some readers, a meaning to which this document does not conform &lt;a href=&quot;https://www.theregister.co.uk/2018/10/22/sqlite_code_of_conduct/&quot;&gt;[1]&lt;/a&gt;&lt;a href=&quot;https://pjmedia.com/news-and-politics/paula-bolyard/2018/10/24/tech-community-outraged-after-sqlite-founder-adopts-christian-code-of-conduct-n61746&quot;&gt;[2]&lt;/a&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=S48VzyCwwtk&quot;&gt;[3]&lt;/a&gt;. Therefore this document was renamed to &quot;Code of Ethics&quot;, as we are encouraged to do by rule 71 in particular and also rules 2, 8, 9, 18, 19, 30, 66, and in the spirit of all the rest.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f4b3397370025bf1fdba593094ae6486be0fecb" translate="yes" xml:space="preserve">
          <source>This document was originally created in early 2004 when SQLite version 2 was still in widespread use and was written to introduce the new concepts of SQLite version 3 to readers who were already familiar with SQLite version 2. But these days, most readers of this document have probably never seen SQLite version 2 and are only familiar with SQLite version 3. Nevertheless, this document continues to serve as an authoritative reference to how database file locking works in SQLite version 3.</source>
          <target state="translated">Этот документ был первоначально создан в начале 2004 года,когда SQLite версии 2 еще широко использовался,и был написан для того,чтобы познакомить читателей,которые уже были знакомы с SQLite версии 2,с новыми концепциями SQLite версии 3.Но в настоящее время большинство читателей этого документа,вероятно,никогда не видели SQLite версии 2 и знакомы только с SQLite версии 3.Тем не менее,этот документ продолжает служить авторитетной ссылкой на то,как работает блокировка файлов базы данных в SQLite версии 3.</target>
        </trans-unit>
        <trans-unit id="efa34a5056d6c01d0548b0f2be11ce7b6109059b" translate="yes" xml:space="preserve">
          <source>This experimental &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued function&lt;/a&gt; provides information about a single &lt;a href=&quot;fileformat2#btree&quot;&gt;B-tree&lt;/a&gt; in a database file, such as the depth, and estimated number of pages and number of entries, and so forth.</source>
          <target state="translated">Эта экспериментальная &lt;a href=&quot;vtab#tabfunc2&quot;&gt;функция с табличным значением&lt;/a&gt; предоставляет информацию об одном &lt;a href=&quot;fileformat2#btree&quot;&gt;B-дереве&lt;/a&gt; в файле базы данных, такую ​​как глубина, приблизительное количество страниц, количество записей и т. Д.</target>
        </trans-unit>
        <trans-unit id="0902999854d1422342b1343c7db1457520c25f82" translate="yes" xml:space="preserve">
          <source>This facility is provided for WinRT which does not have an OS mechanism for reading or changing the current working directory. The use of this pragma in any other context is discouraged and may be disallowed in future releases.</source>
          <target state="translated">Эта подсистема предусмотрена для WinRT,которая не имеет операционного механизма для чтения или изменения текущей рабочей директории.Использование этой прагмы в любом другом контексте не поощряется и может быть запрещено в будущих релизах.</target>
        </trans-unit>
        <trans-unit id="a16ab751fe0e625eef00360bec04f5c6e2724bea" translate="yes" xml:space="preserve">
          <source>This feature could be used to implement &lt;a href=&quot;https://en.wikipedia.org/wiki/Information_schema&quot;&gt;information schema&lt;/a&gt; by first creating a separate schema using</source>
          <target state="translated">Эту функцию можно использовать для реализации &lt;a href=&quot;https://en.wikipedia.org/wiki/Information_schema&quot;&gt;информационной схемы&lt;/a&gt; , сначала создав отдельную схему, используя</target>
        </trans-unit>
        <trans-unit id="bbc13030cdb5706fbe971e91e53cd50c5af469f0" translate="yes" xml:space="preserve">
          <source>This feature is experimental and is subject to change. Further documentation will become available if and when the table-valued functions for PRAGMAs feature becomes officially supported.</source>
          <target state="translated">Эта функция является экспериментальной и может быть изменена.Дальнейшая документация будет доступна,если и когда табличные функции для функции PRAGMA станут официально поддерживаться.</target>
        </trans-unit>
        <trans-unit id="18abc550835bcdb0029b1a86390eaca991d2351b" translate="yes" xml:space="preserve">
          <source>This field contains a checksum value, calculated based on the contents of the journaled database page data (the previous field) and the values stored in the</source>
          <target state="translated">Данное поле содержит значение контрольной суммы,рассчитанной на основе содержания данных страницы зарегистрированной базы данных (предыдущее поле)и значений,хранящихся в</target>
        </trans-unit>
        <trans-unit id="e3760b531cd8fa332f7ee70ed518883a43ad81f8" translate="yes" xml:space="preserve">
          <source>This field contains the original data for the page, exactly as it appeared in the database file before the</source>
          <target state="translated">Это поле содержит исходные данные для страницы,в точности такие,как они появились в файле базы данных перед</target>
        </trans-unit>
        <trans-unit id="3ae121150e2dd424e68324ff08f7e0c6c1d0a2a0" translate="yes" xml:space="preserve">
          <source>This field holds a phonetic code derived from coalesce(k1,word). Letters that have similar sounds are mapped into the same symbol. For example, all vowels and vowel clusters become the single symbol &quot;A&quot;. And the letters &quot;p&quot;, &quot;b&quot;, &quot;f&quot;, and &quot;v&quot; all become &quot;B&quot;. All nasal sounds are represented as &quot;N&quot;. And so forth. The mapping is based on ideas found in Soundex, Metaphone, and other long-standing phonetic matching systems. This key can be generated by the function spellfix1_phonehash(X). Hence: k2 = spellfix1_phonehash(coalesce(k1,word))</source>
          <target state="translated">В этом поле содержится фонетический код,полученный из коалесце(k1,word).Буквы,имеющие похожие звуки,отображаются в один и тот же символ.Например,все гласные и группы гласных становятся одним символом &quot;A&quot;.А буквы &quot;p&quot;,&quot;b&quot;,&quot;f&quot; и &quot;v&quot; становятся буквой &quot;B&quot;.Все носовые звуки представлены как &quot;N&quot;.И так далее.Картирование основано на идеях,найденных в Саундексе,Метафоне и других давно существующих фонетических системах согласования.Этот ключ может быть сгенерирован функцией spellfix1_phonehash(X).Следовательно:k2=spellfix1_phonehash(jointesce(k1,word)).</target>
        </trans-unit>
        <trans-unit id="7981d385aa4b9ca4b4f9844539885d4afde0da8a" translate="yes" xml:space="preserve">
          <source>This field may contain either an integer or a text field consisting of two integers separated by a space character (unicode codepoint 0x20).</source>
          <target state="translated">Это поле может содержать как целое число,так и текстовое поле,состоящее из двух целых чисел,разделенных символом пробела (кодовая точка юникода 0x20).</target>
        </trans-unit>
        <trans-unit id="de591efb54fdb80ffddf1b7c9525e6ab9978c95c" translate="yes" xml:space="preserve">
          <source>This field must be set one of integer values 0 and 8, or else to NULL.</source>
          <target state="translated">Это поле должно быть установлено одним из целочисленных значений 0 и 8,или же NULL.</target>
        </trans-unit>
        <trans-unit id="7e75b74f43def5b21dd19f54d176219e2332fba0" translate="yes" xml:space="preserve">
          <source>This field, the &lt;b&gt;database page count&lt;/b&gt;, is set to the number of pages that the</source>
          <target state="translated">В этом поле, &lt;b&gt;счетчике страниц базы данных&lt;/b&gt; , установлено количество страниц, которые</target>
        </trans-unit>
        <trans-unit id="4ce138fa916045f081e00c343e7762b51298df38" translate="yes" xml:space="preserve">
          <source>This field, the &lt;b&gt;locking page number&lt;/b&gt;, is always set to the page number of the database</source>
          <target state="translated">В этом поле, &lt;b&gt;номер страницы блокировки&lt;/b&gt; , всегда устанавливается номер страницы базы данных.</target>
        </trans-unit>
        <trans-unit id="825eef8a444b33cb8e93566d91167c3eabd02df8" translate="yes" xml:space="preserve">
          <source>This field, the &lt;b&gt;record count&lt;/b&gt;, is set to the number of</source>
          <target state="translated">Это поле, &lt;b&gt;количество записей&lt;/b&gt; , установлено на количество</target>
        </trans-unit>
        <trans-unit id="f631e740c08280177f2a7f6f8390e6ab3758fda5" translate="yes" xml:space="preserve">
          <source>This field, the &lt;b&gt;sector size&lt;/b&gt;, is set to the</source>
          <target state="translated">В этом поле, &lt;b&gt;размер сектора&lt;/b&gt; , установлено значение</target>
        </trans-unit>
        <trans-unit id="caf63c1c58b9f87489297844a819efb8d6633a40" translate="yes" xml:space="preserve">
          <source>This flag causes comma-separators to be added to the output of %d and %i substitutions, between every 3 digits from the left. This can help humans to more easily discern the magnitude of large integer values. For example, the value 2147483647 would be rendered as &quot;2147483647&quot; using &quot;%d&quot; but would appear as &quot;2,147,483,647&quot; with &quot;%,d&quot;. This flag is a non-standard extension.</source>
          <target state="translated">Этот флаг вызывает добавление разделителей запятых к выводу замен %d и %i,между каждыми 3 цифрами слева.Это может помочь людям легче различать величину больших целочисленных значений.Например,значение 2147483647 будет выведено как &quot;2147483647&quot; с помощью &quot;%d&quot;,но будет выглядеть как &quot;2,147,483,647&quot; с помощью &quot;%,d&quot;.Этот флаг является нестандартным расширением.</target>
        </trans-unit>
        <trans-unit id="a5b80382a268dfe85ecc58efaaccd407cc41e4b2" translate="yes" xml:space="preserve">
          <source>This function adds a set of changes to the session object that could be used to update the table in database zFrom (call this the &quot;from-table&quot;) so that its content is the same as the table attached to the session object (call this the &quot;to-table&quot;). Specifically:</source>
          <target state="translated">Эта функция добавляет в объект сеанса набор изменений,которые могут быть использованы для обновления таблицы в БД zFrom (назовите это &quot;from-table&quot;)так,чтобы его содержимое было таким же,как и таблица,прикрепленная к объекту сеанса (назовите это &quot;to-table&quot;).В частности:</target>
        </trans-unit>
        <trans-unit id="3b5d7e99038e4d5b072061176057f97dc299323e" translate="yes" xml:space="preserve">
          <source>This function and xPhraseNextColumn() are similar to the xPhraseFirst() and xPhraseNext() APIs described above. The difference is that instead of iterating through all instances of a phrase in the current row, these APIs are used to iterate through the set of columns in the current row that contain one or more instances of a specified phrase. For example:</source>
          <target state="translated">Эта функция и xPhraseNextColumn()аналогичны описанным выше API xPhraseFirst()и xPhraseNext().Разница заключается в том,что вместо итерации через все экземпляры фразы в текущей строке,эти API используются для итерации через набор столбцов в текущей строке,которые содержат один или несколько экземпляров указанной фразы.Например:</target>
        </trans-unit>
        <trans-unit id="80988b461d2df6302b49f4dceec8b27b005d6908" translate="yes" xml:space="preserve">
          <source>This function attempts to retrieve the text of column iCol of the current document. If successful, (*pz) is set to point to a buffer containing the text in utf-8 encoding, (*pn) is set to the size in bytes (not characters) of the buffer and SQLITE_OK is returned. Otherwise, if an error occurs, an SQLite error code is returned and the final values of (*pz) and (*pn) are undefined.</source>
          <target state="translated">Данная функция пытается получить текст колонки iCol текущего документа.В случае успеха,(*pz)указывается на буфер,содержащий текст в кодировке utf-8,(*pn)устанавливается размер в байтах (не символах)буфера и возвращается SQLITE_OK.В противном случае при возникновении ошибки возвращается код ошибки SQLite и окончательные значения (*pz)и (*pn)не определены.</target>
        </trans-unit>
        <trans-unit id="28a6bb3de337284487682e360c8a725a543916e4" translate="yes" xml:space="preserve">
          <source>This function attempts to scan the WAL file associated with database zDb of database handle db and make all valid snapshots available to sqlite3_snapshot_open(). It is an error if there is already a read transaction open on the database, or if the database is not a WAL mode database.</source>
          <target state="translated">Эта функция пытается сканировать файл WAL,связанный с базой данных zDb базы данных обрабатывать db и сделать все корректные снимки доступными для sqlite3_snapshot_open().Это ошибка,если в базе данных уже открыта прочитанная транзакция,или если база данных не является базой данных в режиме WAL.</target>
        </trans-unit>
        <trans-unit id="27eaa9cd67b4a77bfd0fe868cf2e24b92591db2f" translate="yes" xml:space="preserve">
          <source>This function causes all database schemas to be read from disk and parsed, if that has not already been done, and returns an error if any errors are encountered while loading the schema.</source>
          <target state="translated">Эта функция заставляет все схемы базы данных читаться с диска и разбираться,если это еще не сделано,и возвращает ошибку,если при загрузке схемы возникнут какие-либо ошибки.</target>
        </trans-unit>
        <trans-unit id="7d871089984a2a55cb6c89bf16fcd0bc4a023753" translate="yes" xml:space="preserve">
          <source>This function causes any pending database operation to abort and return at its earliest opportunity. This routine is typically called in response to a user action such as pressing &quot;Cancel&quot; or Ctrl-C where the user wants a long query operation to halt immediately.</source>
          <target state="translated">Эта функция приводит к тому,что любая отложенная операция с базой данных прерывается и возвращается при первой же возможности.Эта рутина обычно вызывается в ответ на действие пользователя,например,нажатие клавиши &quot;Cancel&quot; или Ctrl-C,когда пользователь хочет,чтобы операция по длинному запросу была немедленно прекращена.</target>
        </trans-unit>
        <trans-unit id="84f0a277d8eb36da2c14763cce01f3221d3f3be5" translate="yes" xml:space="preserve">
          <source>This function closes an open &lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB handle&lt;/a&gt;. The BLOB handle is closed unconditionally. Even if this routine returns an error code, the handle is still closed.</source>
          <target state="translated">Эта функция закрывает &lt;a href=&quot;#sqlite3_blob&quot;&gt;дескриптор&lt;/a&gt; открытого BLOB . Дескриптор большого двоичного объекта закрывается безоговорочно. Даже если эта процедура возвращает код ошибки, дескриптор по-прежнему закрыт.</target>
        </trans-unit>
        <trans-unit id="c52c6ec750ee5ca8bf8f3568aa703ede60385a7a" translate="yes" xml:space="preserve">
          <source>This function closes an open &lt;a href=&quot;blob&quot;&gt;BLOB handle&lt;/a&gt;. The BLOB handle is closed unconditionally. Even if this routine returns an error code, the handle is still closed.</source>
          <target state="translated">Эта функция закрывает &lt;a href=&quot;blob&quot;&gt;дескриптор&lt;/a&gt; открытого BLOB . Дескриптор большого двоичного объекта закрывается безоговорочно. Даже если эта процедура возвращает код ошибки, дескриптор по-прежнему закрыт.</target>
        </trans-unit>
        <trans-unit id="dcb5cb2e9c08e0b9f3037428dbe4920c74c2b405" translate="yes" xml:space="preserve">
          <source>This function combines the two input changesets using an sqlite3_changegroup object. Calling it produces similar results as the following code fragment:</source>
          <target state="translated">Эта функция объединяет два входных набора изменений с помощью объекта sqlite3_changegroup.Вызов ее дает такой же результат,как и следующий фрагмент кода:</target>
        </trans-unit>
        <trans-unit id="4624a9200d853f2e32a44b7a98a35021843efd43" translate="yes" xml:space="preserve">
          <source>This function does not change the order in which changes appear within the changeset. It merely reverses the sense of each individual change.</source>
          <target state="translated">Данная функция не изменяет порядок,в котором изменения появляются в наборе изменений.Она просто меняет смысл каждого отдельного изменения.</target>
        </trans-unit>
        <trans-unit id="d7cbc42833b432d19d25054e50c1379caf39e23d" translate="yes" xml:space="preserve">
          <source>This function does not set the database handle error code or message returned by the &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errcode()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errmsg()&lt;/a&gt; functions.</source>
          <target state="translated">Эта функция не устанавливает код ошибки дескриптора базы данных или сообщение, возвращаемое функциями &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errcode ()&lt;/a&gt; и &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errmsg ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2c015e6f1fde0378f350b940649e6bb977266a40" translate="yes" xml:space="preserve">
          <source>This function does not set the database handle error code or message returned by the &lt;a href=&quot;errcode&quot;&gt;sqlite3_errcode()&lt;/a&gt; and &lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg()&lt;/a&gt; functions.</source>
          <target state="translated">Эта функция не устанавливает код ошибки дескриптора базы данных или сообщение, возвращаемое функциями &lt;a href=&quot;errcode&quot;&gt;sqlite3_errcode ()&lt;/a&gt; и &lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6303b7057e9914dac072c1b4a0b74b270e4dc698" translate="yes" xml:space="preserve">
          <source>This function fails with SQLITE_ERROR if any of the following are true:</source>
          <target state="translated">Эта функция дает сбой при использовании SQLITE_ERROR,если любое из приведенных ниже значений является истинным:</target>
        </trans-unit>
        <trans-unit id="870ceb33e21de66e2ccc8a5ce1caa06026ee0a3c" translate="yes" xml:space="preserve">
          <source>This function is accessible to SQL statements via the &lt;a href=&quot;../lang_corefunc#last_insert_rowid&quot;&gt;last_insert_rowid() SQL function&lt;/a&gt;.</source>
          <target state="translated">Эта функция доступна операторам SQL через &lt;a href=&quot;../lang_corefunc#last_insert_rowid&quot;&gt;SQL-функцию last_insert_rowid ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3ed24a06a5fab16f67d5f77a45744a9d31cdf2e0" translate="yes" xml:space="preserve">
          <source>This function is accessible to SQL statements via the &lt;a href=&quot;lang_corefunc#last_insert_rowid&quot;&gt;last_insert_rowid() SQL function&lt;/a&gt;.</source>
          <target state="translated">Эта функция доступна операторам SQL через &lt;a href=&quot;lang_corefunc#last_insert_rowid&quot;&gt;SQL-функцию last_insert_rowid ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ba56f71e7eaf44d8bff350353ce98793aa844743" translate="yes" xml:space="preserve">
          <source>This function is expected to tokenize the nText byte string indicated by argument pText. pText may or may not be nul-terminated. The first argument passed to this function is a pointer to an Fts5Tokenizer object returned by an earlier call to xCreate().</source>
          <target state="translated">Предполагается,что эта функция будет токенировать строку nText байта,указанную аргументом pText.pText может быть или не быть нуль-терминированным.Первым аргументом,передаваемым в эту функцию,является указатель на объект Fts5Tokenizer,возвращаемый при более раннем вызове xCreate().</target>
        </trans-unit>
        <trans-unit id="c0f6fbfd19fbfc44b1560cfd2b05948b7fed7c50" translate="yes" xml:space="preserve">
          <source>This function is invoked to delete a tokenizer handle previously allocated using xCreate(). Fts5 guarantees that this function will be invoked exactly once for each successful call to xCreate().</source>
          <target state="translated">Эта функция вызывается для удаления хэндла токенайзера,ранее выделенного с помощью xCreate().Fts5 гарантирует,что эта функция будет вызываться ровно один раз при каждом успешном вызове xCreate().</target>
        </trans-unit>
        <trans-unit id="fcde84651450f2b10b0843fe43cf87cdc47c8be9" translate="yes" xml:space="preserve">
          <source>This function is used to &quot;invert&quot; a changeset object. Applying an inverted changeset to a database reverses the effects of applying the uninverted changeset. Specifically:</source>
          <target state="translated">Эта функция используется для &quot;инвертирования&quot; объекта changeset.Применение инвертированного changeset к базе данных отменяет эффект применения неинвертированного changeset.В частности:</target>
        </trans-unit>
        <trans-unit id="29ae82377275c7b1f1384fc8e2d212e8da0789d4" translate="yes" xml:space="preserve">
          <source>This function is used to allocate and initialize a tokenizer instance. A tokenizer instance is required to actually tokenize text.</source>
          <target state="translated">Эта функция используется для выделения и инициализации экземпляра токенайзера.Экземпляр токенайзера необходим для фактической токенировки текста.</target>
        </trans-unit>
        <trans-unit id="24b74a85f4b47c195bc0b6fe21af9724e0d1ed94" translate="yes" xml:space="preserve">
          <source>This function is used to concatenate two changesets, A and B, into a single changeset. The result is a changeset equivalent to applying changeset A followed by changeset B.</source>
          <target state="translated">Эта функция используется для объединения двух наборов изменений,A и B,в один набор изменений.В результате получается набор изменений,эквивалентный применению набора изменений А,за которым следует набор изменений В.</target>
        </trans-unit>
        <trans-unit id="69eb445f771165e9cf3bdc2eef0ebd4932045f16" translate="yes" xml:space="preserve">
          <source>This function is used to finalize an iterator allocated with &lt;a href=&quot;#sqlite3changeset_start&quot;&gt;sqlite3changeset_start()&lt;/a&gt;.</source>
          <target state="translated">Эта функция используется для завершения итератора, выделенного с помощью &lt;a href=&quot;#sqlite3changeset_start&quot;&gt;sqlite3changeset_start ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b35815e34122016382887fcb96a49b58070b37da" translate="yes" xml:space="preserve">
          <source>This function is used to finalize an iterator allocated with &lt;a href=&quot;sqlite3changeset_start&quot;&gt;sqlite3changeset_start()&lt;/a&gt;.</source>
          <target state="translated">Эта функция используется для завершения итератора, выделенного с помощью &lt;a href=&quot;sqlite3changeset_start&quot;&gt;sqlite3changeset_start ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2cfec4fd8864b11036478634ce0c848102b439e0" translate="yes" xml:space="preserve">
          <source>This function is used to find which columns comprise the PRIMARY KEY of the table modified by the change that iterator pIter currently points to. If successful, *pabPK is set to point to an array of nCol entries, where nCol is the number of columns in the table. Elements of *pabPK are set to 0x01 if the corresponding column is part of the tables primary key, or 0x00 if it is not.</source>
          <target state="translated">Эта функция используется для того,чтобы найти,какие столбцы составляют PRIMARY KEY таблицы,измененный изменением,на которое в данный момент указывает итератор pIter.В случае успеха,*pabPK указывает на массив записей nCol,где nCol-это количество столбцов в таблице.Элементы *pabPK устанавливаются в 0x01,если соответствующий столбец является частью первичного ключа таблицы,или в 0x00,если это не так.</target>
        </trans-unit>
        <trans-unit id="e114c8bad40f12de287f68c473424a8e6e66648d" translate="yes" xml:space="preserve">
          <source>This function is used to move an existing &lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB handle&lt;/a&gt; so that it points to a different row of the same database table. The new row is identified by the rowid value passed as the second argument. Only the row can be changed. The database, table and column on which the blob handle is open remain the same. Moving an existing &lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB handle&lt;/a&gt; to a new row is faster than closing the existing handle and opening a new one.</source>
          <target state="translated">Эта функция используется для перемещения существующего &lt;a href=&quot;#sqlite3_blob&quot;&gt;дескриптора большого двоичного объекта&lt;/a&gt; так, чтобы он указывал на другую строку той же таблицы базы данных. Новая строка идентифицируется значением rowid, переданным в качестве второго аргумента. Изменять можно только строку. База данных, таблица и столбец, в которых открыт дескриптор большого двоичного объекта, остаются прежними. Перемещение существующего &lt;a href=&quot;#sqlite3_blob&quot;&gt;дескриптора большого двоичного объекта&lt;/a&gt; в новую строку происходит быстрее, чем закрытие существующего дескриптора и открытие нового.</target>
        </trans-unit>
        <trans-unit id="308c798f0a295eb0c4645e5b7f42fbabbc544780" translate="yes" xml:space="preserve">
          <source>This function is used to move an existing &lt;a href=&quot;blob&quot;&gt;BLOB handle&lt;/a&gt; so that it points to a different row of the same database table. The new row is identified by the rowid value passed as the second argument. Only the row can be changed. The database, table and column on which the blob handle is open remain the same. Moving an existing &lt;a href=&quot;blob&quot;&gt;BLOB handle&lt;/a&gt; to a new row is faster than closing the existing handle and opening a new one.</source>
          <target state="translated">Эта функция используется для перемещения существующего &lt;a href=&quot;blob&quot;&gt;дескриптора большого двоичного объекта&lt;/a&gt; так, чтобы он указывал на другую строку той же таблицы базы данных. Новая строка идентифицируется значением rowid, переданным в качестве второго аргумента. Изменять можно только строку. База данных, таблица и столбец, в которых открыт дескриптор большого двоичного объекта, остаются прежними. Перемещение существующего &lt;a href=&quot;blob&quot;&gt;дескриптора большого двоичного объекта&lt;/a&gt; в новую строку происходит быстрее, чем закрытие существующего дескриптора и открытие нового.</target>
        </trans-unit>
        <trans-unit id="4b885ede0001de9f5c638f038a437a23ced24dd6" translate="yes" xml:space="preserve">
          <source>This function is used to read data from an open &lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB handle&lt;/a&gt; into a caller-supplied buffer. N bytes of data are copied into buffer Z from the open BLOB, starting at offset iOffset.</source>
          <target state="translated">Эта функция используется для чтения данных из открытого &lt;a href=&quot;#sqlite3_blob&quot;&gt;дескриптора большого двоичного&lt;/a&gt; объекта в буфер, предоставленный вызывающей стороной. N байтов данных копируются в буфер Z из открытого BLOB, начиная со смещения iOffset.</target>
        </trans-unit>
        <trans-unit id="21272222209bb70a086675dada0f2b2f97f0f8e4" translate="yes" xml:space="preserve">
          <source>This function is used to read data from an open &lt;a href=&quot;blob&quot;&gt;BLOB handle&lt;/a&gt; into a caller-supplied buffer. N bytes of data are copied into buffer Z from the open BLOB, starting at offset iOffset.</source>
          <target state="translated">Эта функция используется для чтения данных из открытого &lt;a href=&quot;blob&quot;&gt;дескриптора большого двоичного&lt;/a&gt; объекта в буфер, предоставленный вызывающей стороной. N байтов данных копируются в буфер Z из открытого BLOB, начиная со смещения iOffset.</target>
        </trans-unit>
        <trans-unit id="9f3667d662139e493e6cf3b56b1b782512c8bc44" translate="yes" xml:space="preserve">
          <source>This function is used to retrieve the total number of rows in the table. In other words, the same value that would be returned by:</source>
          <target state="translated">Эта функция используется для получения общего количества строк в таблице.Другими словами,то же самое значение,которое будет возвращено:</target>
        </trans-unit>
        <trans-unit id="b651a758789810b674e3ae5146e089dc27672b54" translate="yes" xml:space="preserve">
          <source>This function is used to set, clear or query the session object indirect flag. If the second argument passed to this function is zero, then the indirect flag is cleared. If it is greater than zero, the indirect flag is set. Passing a value less than zero does not modify the current value of the indirect flag, and may be used to query the current state of the indirect flag for the specified session object.</source>
          <target state="translated">Эта функция используется для установки,очистки или запроса косвенного флага объекта сеанса.Если второй аргумент,переданный в эту функцию,равен нулю,то косвенный флаг сбрасывается.Если он больше нуля,то устанавливается косвенный флаг.Передача значения меньше нуля не изменяет текущего значения флага непрямого и может быть использована для запроса текущего состояния флага непрямого для указанного объекта сеанса.</target>
        </trans-unit>
        <trans-unit id="57a1761e9d0e1762347b4943de9494b5f2f5f8cc" translate="yes" xml:space="preserve">
          <source>This function is used to write data into an open &lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB handle&lt;/a&gt; from a caller-supplied buffer. N bytes of data are copied from the buffer Z into the open BLOB, starting at offset iOffset.</source>
          <target state="translated">Эта функция используется для записи данных в открытый &lt;a href=&quot;#sqlite3_blob&quot;&gt;дескриптор большого двоичного&lt;/a&gt; объекта из буфера, предоставленного вызывающей стороной. N байтов данных копируются из буфера Z в открытый BLOB, начиная со смещения iOffset.</target>
        </trans-unit>
        <trans-unit id="959745cc981e8eae46a52bb0e5894da3fa5cff9f" translate="yes" xml:space="preserve">
          <source>This function is used to write data into an open &lt;a href=&quot;blob&quot;&gt;BLOB handle&lt;/a&gt; from a caller-supplied buffer. N bytes of data are copied from the buffer Z into the open BLOB, starting at offset iOffset.</source>
          <target state="translated">Эта функция используется для записи данных в открытый &lt;a href=&quot;blob&quot;&gt;дескриптор большого двоичного&lt;/a&gt; объекта из буфера, предоставленного вызывающей стороной. N байтов данных копируются из буфера Z в открытый BLOB, начиная со смещения iOffset.</target>
        </trans-unit>
        <trans-unit id="1483892d5daffd0f4eda8275dee22e2f701b626d" translate="yes" xml:space="preserve">
          <source>This function is used, along with type Fts5PhraseIter and the xPhraseNext method, to iterate through all instances of a single query phrase within the current row. This is the same information as is accessible via the xInstCount/xInst APIs. While the xInstCount/xInst APIs are more convenient to use, this API may be faster under some circumstances. To iterate through instances of phrase iPhrase, use the following code:</source>
          <target state="translated">Данная функция,наряду с типом Fts5PhraseIter и методом xPhraseNext,используется для итерации всех экземпляров одной фразы запроса внутри текущей строки.Это та же самая информация,которая доступна через xInstCount/xInst API.Хотя API xInstCount/xInst более удобны в использовании,при некоторых обстоятельствах этот API может быть быстрее.Для итерации через экземпляры фразы iPhrase используйте следующий код:</target>
        </trans-unit>
        <trans-unit id="2e540303404a447a74d8a0d678f9bad1c3c4058d" translate="yes" xml:space="preserve">
          <source>This function maps every page number into an integer between 0 and 8191 inclusive. The aHash field of each 32768-byte shm file unit maps P values into indexes of the aPgno field of the same unit as follows:</source>
          <target state="translated">Эта функция отображает каждый номер страницы в целое число от 0 до 8191 включительно.Поле aHash каждого 32768-байтового файла единицы измерения shm отображает значения P в индексы поля aPgno той же единицы измерения следующим образом:</target>
        </trans-unit>
        <trans-unit id="b474b368c95d2db3e02f8d968fb517ea9f808a38" translate="yes" xml:space="preserve">
          <source>This function may also return SQLITE_NOMEM. If it is called with the database handle in autocommit mode but fails for some other reason, whether or not a read transaction is opened on schema S is undefined.</source>
          <target state="translated">Эта функция также может возвращать SQLITE_NOMEM.Если она вызывается с хэндлом базы данных в режиме автокомитации,но не срабатывает по какой-то другой причине,то будет ли открыта прочитанная транзакция на схеме S неопределена.</target>
        </trans-unit>
        <trans-unit id="d107c7c4ed710ea3330eefcfd44db3b75a5ff363" translate="yes" xml:space="preserve">
          <source>This function may be called by either the &lt;a href=&quot;../vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; or &lt;a href=&quot;../vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; method of a &lt;a href=&quot;../vtab&quot;&gt;virtual table&lt;/a&gt; implementation to configure various facets of the virtual table interface.</source>
          <target state="translated">Эта функция может быть вызвана методом &lt;a href=&quot;../vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; или &lt;a href=&quot;../vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; реализации &lt;a href=&quot;../vtab&quot;&gt;виртуальной таблицы&lt;/a&gt; для настройки различных аспектов интерфейса виртуальной таблицы.</target>
        </trans-unit>
        <trans-unit id="436450a55b61a947a304f65e4e9be131ade57dc9" translate="yes" xml:space="preserve">
          <source>This function may be called by either the &lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; or &lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; method of a &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; implementation to configure various facets of the virtual table interface.</source>
          <target state="translated">Эта функция может быть вызвана методом &lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; или &lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; реализации &lt;a href=&quot;vtab&quot;&gt;виртуальной таблицы&lt;/a&gt; для настройки различных аспектов интерфейса виртуальной таблицы.</target>
        </trans-unit>
        <trans-unit id="892823d34401462a7936657244cacf73ba9d16a7" translate="yes" xml:space="preserve">
          <source>This function may be quite inefficient if used with an FTS5 table created with the &quot;columnsize=0&quot; option.</source>
          <target state="translated">Эта функция может быть довольно неэффективной,если используется с таблицей FTS5,созданной с опцией &quot;columnsize=0&quot;.</target>
        </trans-unit>
        <trans-unit id="e3c728fb74daea7a42a0d0a89203b1fbf38464ae" translate="yes" xml:space="preserve">
          <source>This function may only be called from within a call to the &lt;a href=&quot;../vtab#xbestindex&quot;&gt;xBestIndex&lt;/a&gt; method of a &lt;a href=&quot;../vtab&quot;&gt;virtual table&lt;/a&gt;.</source>
          <target state="translated">Эта функция может быть вызвана только из вызова метода &lt;a href=&quot;../vtab#xbestindex&quot;&gt;xBestIndex &lt;/a&gt;&lt;a href=&quot;../vtab&quot;&gt;виртуальной таблицы&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="651e6e671ae629015a6ac3d4f4c461902dc827bb" translate="yes" xml:space="preserve">
          <source>This function may only be called from within a call to the &lt;a href=&quot;../vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; method of a &lt;a href=&quot;../vtab&quot;&gt;virtual table&lt;/a&gt; implementation for an INSERT or UPDATE operation. The value returned is one of &lt;a href=&quot;c_fail&quot;&gt;SQLITE_ROLLBACK&lt;/a&gt;, &lt;a href=&quot;c_deny&quot;&gt;SQLITE_IGNORE&lt;/a&gt;, &lt;a href=&quot;c_fail&quot;&gt;SQLITE_FAIL&lt;/a&gt;, &lt;a href=&quot;../rescode#abort&quot;&gt;SQLITE_ABORT&lt;/a&gt;, or &lt;a href=&quot;c_fail&quot;&gt;SQLITE_REPLACE&lt;/a&gt;, according to the &lt;a href=&quot;../lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt; mode of the SQL statement that triggered the call to the &lt;a href=&quot;../vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; method of the &lt;a href=&quot;../vtab&quot;&gt;virtual table&lt;/a&gt;.</source>
          <target state="translated">Эта функция может быть вызвана только из вызова метода &lt;a href=&quot;../vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; реализации &lt;a href=&quot;../vtab&quot;&gt;виртуальной таблицы&lt;/a&gt; для операции INSERT или UPDATE. Возвращаемое значение - одно из &lt;a href=&quot;c_fail&quot;&gt;SQLITE_ROLLBACK&lt;/a&gt; , &lt;a href=&quot;c_deny&quot;&gt;SQLITE_IGNORE&lt;/a&gt; , &lt;a href=&quot;c_fail&quot;&gt;SQLITE_FAIL&lt;/a&gt; , &lt;a href=&quot;../rescode#abort&quot;&gt;SQLITE_ABORT&lt;/a&gt; или &lt;a href=&quot;c_fail&quot;&gt;SQLITE_REPLACE в&lt;/a&gt; соответствии с режимом &lt;a href=&quot;../lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt; оператора SQL, который инициировал вызов метода &lt;a href=&quot;../vtab#xupdate&quot;&gt;xUpdate &lt;/a&gt;&lt;a href=&quot;../vtab&quot;&gt;виртуальной таблицы&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a16a26f00d528f2a67fb084167cd62426f17fa64" translate="yes" xml:space="preserve">
          <source>This function may only be called from within a call to the &lt;a href=&quot;vtab#xbestindex&quot;&gt;xBestIndex&lt;/a&gt; method of a &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt;.</source>
          <target state="translated">Эта функция может быть вызвана только из вызова метода &lt;a href=&quot;vtab#xbestindex&quot;&gt;xBestIndex &lt;/a&gt;&lt;a href=&quot;vtab&quot;&gt;виртуальной таблицы&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a48f675a9216b80779894ce906eb64bd5d832356" translate="yes" xml:space="preserve">
          <source>This function may only be called from within a call to the &lt;a href=&quot;vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; method of a &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; implementation for an INSERT or UPDATE operation. The value returned is one of &lt;a href=&quot;#SQLITE_FAIL&quot;&gt;SQLITE_ROLLBACK&lt;/a&gt;, &lt;a href=&quot;#SQLITE_DENY&quot;&gt;SQLITE_IGNORE&lt;/a&gt;, &lt;a href=&quot;#SQLITE_FAIL&quot;&gt;SQLITE_FAIL&lt;/a&gt;, &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ABORT&lt;/a&gt;, or &lt;a href=&quot;#SQLITE_FAIL&quot;&gt;SQLITE_REPLACE&lt;/a&gt;, according to the &lt;a href=&quot;lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt; mode of the SQL statement that triggered the call to the &lt;a href=&quot;vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; method of the &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt;.</source>
          <target state="translated">Эта функция может быть вызвана только из вызова метода &lt;a href=&quot;vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; реализации &lt;a href=&quot;vtab&quot;&gt;виртуальной таблицы&lt;/a&gt; для операции INSERT или UPDATE. Возвращаемое значение - одно из &lt;a href=&quot;#SQLITE_FAIL&quot;&gt;SQLITE_ROLLBACK&lt;/a&gt; , &lt;a href=&quot;#SQLITE_DENY&quot;&gt;SQLITE_IGNORE&lt;/a&gt; , &lt;a href=&quot;#SQLITE_FAIL&quot;&gt;SQLITE_FAIL&lt;/a&gt; , &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ABORT&lt;/a&gt; или &lt;a href=&quot;#SQLITE_FAIL&quot;&gt;SQLITE_REPLACE в&lt;/a&gt; соответствии с режимом &lt;a href=&quot;lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt; оператора SQL, который инициировал вызов метода &lt;a href=&quot;vtab#xupdate&quot;&gt;xUpdate &lt;/a&gt;&lt;a href=&quot;vtab&quot;&gt;виртуальной таблицы&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9f4b868b197498e92e7be98a22186e8a9d0ec008" translate="yes" xml:space="preserve">
          <source>This function may only be called with an iterator passed to an SQLITE_CHANGESET_FOREIGN_KEY conflict handler callback. In this case it sets the output variable to the total number of known foreign key violations in the destination database and returns SQLITE_OK.</source>
          <target state="translated">Эта функция может быть вызвана только с помощью итератора,переданного обратному вызову конфликтного обработчика SQLITE_CHANGESET_FOREIGN_KEY.В этом случае она устанавливает выходную переменную на общее количество известных нарушений иностранных ключей в базе данных получателя и возвращает SQLITE_OK.</target>
        </trans-unit>
        <trans-unit id="6aefcc013460f98a7eaca0c2faea39955530e82b" translate="yes" xml:space="preserve">
          <source>This function may only be used with iterators created by function &lt;a href=&quot;#sqlite3changeset_start&quot;&gt;sqlite3changeset_start()&lt;/a&gt;. If it is called on an iterator passed to a conflict-handler callback by &lt;a href=&quot;#sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply()&lt;/a&gt;, SQLITE_MISUSE is returned and the call has no effect.</source>
          <target state="translated">Эту функцию можно использовать только с итераторами, созданными функцией &lt;a href=&quot;#sqlite3changeset_start&quot;&gt;sqlite3changeset_start ()&lt;/a&gt; . Если он вызывается на итераторе, переданном в обратный вызов обработчика конфликтов &lt;a href=&quot;#sqlite3changeset_apply&quot;&gt;функцией sqlite3changeset_apply ()&lt;/a&gt; , возвращается SQLITE_MISUSE, и вызов не имеет никакого эффекта.</target>
        </trans-unit>
        <trans-unit id="6b40997bef104535dd0852dc311c81d541b71952" translate="yes" xml:space="preserve">
          <source>This function may only be used with iterators created by function &lt;a href=&quot;sqlite3changeset_start&quot;&gt;sqlite3changeset_start()&lt;/a&gt;. If it is called on an iterator passed to a conflict-handler callback by &lt;a href=&quot;sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply()&lt;/a&gt;, SQLITE_MISUSE is returned and the call has no effect.</source>
          <target state="translated">Эту функцию можно использовать только с итераторами, созданными функцией &lt;a href=&quot;sqlite3changeset_start&quot;&gt;sqlite3changeset_start ()&lt;/a&gt; . Если он вызывается на итераторе, переданном в обратный вызов обработчика конфликтов &lt;a href=&quot;sqlite3changeset_apply&quot;&gt;функцией sqlite3changeset_apply ()&lt;/a&gt; , возвращается SQLITE_MISUSE, и вызов не имеет никакого эффекта.</target>
        </trans-unit>
        <trans-unit id="81dcfaa530f9bc3b0cf4ff6ac3dd711bd8249deb" translate="yes" xml:space="preserve">
          <source>This function may only be used with iterators created by the function &lt;a href=&quot;#sqlite3changeset_start&quot;&gt;sqlite3changeset_start()&lt;/a&gt;. If it is called on an iterator passed to a conflict-handler callback by &lt;a href=&quot;#sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply()&lt;/a&gt;, SQLITE_MISUSE is returned and the call has no effect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2a7a3750664d2ff5967d620601e32e54729a198" translate="yes" xml:space="preserve">
          <source>This function may only be used with iterators created by the function &lt;a href=&quot;sqlite3changeset_start&quot;&gt;sqlite3changeset_start()&lt;/a&gt;. If it is called on an iterator passed to a conflict-handler callback by &lt;a href=&quot;sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply()&lt;/a&gt;, SQLITE_MISUSE is returned and the call has no effect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd3cebc479567b581aaea382b042cd658c5a6fd2" translate="yes" xml:space="preserve">
          <source>This function may only modify the contents of the BLOB; it is not possible to increase the size of a BLOB using this API. If offset iOffset is less than N bytes from the end of the BLOB, &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt; is returned and no data is written. The size of the BLOB (and hence the maximum value of N+iOffset) can be determined using the &lt;a href=&quot;#sqlite3_blob_bytes&quot;&gt;sqlite3_blob_bytes()&lt;/a&gt; interface. If N or iOffset are less than zero &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt; is returned and no data is written.</source>
          <target state="translated">Эта функция может изменять только содержимое BLOB-объекта; с помощью этого API невозможно увеличить размер BLOB. Если смещение iOffset меньше N байтов от конца BLOB, возвращается &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt; и данные не записываются. Размер BLOB (и, следовательно, максимальное значение N + iOffset) можно определить с помощью интерфейса &lt;a href=&quot;#sqlite3_blob_bytes&quot;&gt;sqlite3_blob_bytes ()&lt;/a&gt; . Если N или iOffset меньше нуля, возвращается &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt; и данные не записываются.</target>
        </trans-unit>
        <trans-unit id="cc4415e783325c61d6eb500d3a2195a9814914cb" translate="yes" xml:space="preserve">
          <source>This function may only modify the contents of the BLOB; it is not possible to increase the size of a BLOB using this API. If offset iOffset is less than N bytes from the end of the BLOB, &lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt; is returned and no data is written. The size of the BLOB (and hence the maximum value of N+iOffset) can be determined using the &lt;a href=&quot;blob_bytes&quot;&gt;sqlite3_blob_bytes()&lt;/a&gt; interface. If N or iOffset are less than zero &lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt; is returned and no data is written.</source>
          <target state="translated">Эта функция может изменять только содержимое BLOB-объекта; с помощью этого API невозможно увеличить размер BLOB. Если смещение iOffset меньше N байтов от конца BLOB, возвращается &lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt; и данные не записываются. Размер BLOB (и, следовательно, максимальное значение N + iOffset) можно определить с помощью интерфейса &lt;a href=&quot;blob_bytes&quot;&gt;sqlite3_blob_bytes ()&lt;/a&gt; . Если N или iOffset меньше нуля, возвращается &lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt; и данные не записываются.</target>
        </trans-unit>
        <trans-unit id="e611001e69d55801c25d56986ec39153bc754108" translate="yes" xml:space="preserve">
          <source>This function returns SQLITE_OK if successful, or an SQLite error code otherwise.</source>
          <target state="translated">Эта функция возвращает SQLITE_OK в случае успеха,или код ошибки SQLite в противном случае.</target>
        </trans-unit>
        <trans-unit id="1c2517d3cf09b0cdb52fd7581d781f148fee8f8f" translate="yes" xml:space="preserve">
          <source>This function returns the number of rows modified, inserted or deleted by the most recently completed INSERT, UPDATE or DELETE statement on the database connection specified by the only parameter. Executing any other type of SQL statement does not modify the value returned by this function.</source>
          <target state="translated">Эта функция возвращает количество строк,измененных,вставленных или удаленных по последнему завершенному оператору INSERT,UPDATE или DELETE при подключении к БД,указанному единственным параметром.Выполнение любого другого типа SQL-оператора не изменяет значение,возвращаемое этой функцией.</target>
        </trans-unit>
        <trans-unit id="6b76b4997f936492171845d7baebab3de049f79f" translate="yes" xml:space="preserve">
          <source>This function returns the total number of rows inserted, modified or deleted by all &lt;a href=&quot;../lang_insert&quot;&gt;INSERT&lt;/a&gt;, &lt;a href=&quot;../lang_update&quot;&gt;UPDATE&lt;/a&gt; or &lt;a href=&quot;../lang_delete&quot;&gt;DELETE&lt;/a&gt; statements completed since the database connection was opened, including those executed as part of trigger programs. Executing any other type of SQL statement does not affect the value returned by sqlite3_total_changes().</source>
          <target state="translated">Эта функция возвращает общее количество строк, вставленных, измененных или удаленных всеми операторами &lt;a href=&quot;../lang_insert&quot;&gt;INSERT&lt;/a&gt; , &lt;a href=&quot;../lang_update&quot;&gt;UPDATE&lt;/a&gt; или &lt;a href=&quot;../lang_delete&quot;&gt;DELETE,&lt;/a&gt; выполненными с момента открытия соединения с базой данных, включая те, которые выполнялись как часть программ триггеров. Выполнение любого другого типа оператора SQL не влияет на значение, возвращаемое sqlite3_total_changes ().</target>
        </trans-unit>
        <trans-unit id="adf4834644160b8bd2e8b37a1e591e556b1afb6a" translate="yes" xml:space="preserve">
          <source>This function returns the total number of rows inserted, modified or deleted by all &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;, &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; or &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; statements completed since the database connection was opened, including those executed as part of trigger programs. Executing any other type of SQL statement does not affect the value returned by sqlite3_total_changes().</source>
          <target state="translated">Эта функция возвращает общее количество строк, вставленных, измененных или удаленных всеми операторами &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; , &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; или &lt;a href=&quot;lang_delete&quot;&gt;DELETE,&lt;/a&gt; выполненными с момента открытия соединения с базой данных, включая те, которые выполнялись как часть программ триггеров. Выполнение любого другого типа оператора SQL не влияет на значение, возвращаемое sqlite3_total_changes ().</target>
        </trans-unit>
        <trans-unit id="8213d08301f09db1801edcdcc6b6898d5bedde17" translate="yes" xml:space="preserve">
          <source>This function sets the database handle error code and message.</source>
          <target state="translated">Эта функция задает для базы данных код ошибки и сообщение об ошибке.</target>
        </trans-unit>
        <trans-unit id="dc027be02604df0d93fb0c7fd87bd8fb650c8db3" translate="yes" xml:space="preserve">
          <source>This function should only be called on iterators created using the &lt;a href=&quot;#sqlite3changeset_start&quot;&gt;sqlite3changeset_start()&lt;/a&gt; function. If an application calls this function with an iterator passed to a conflict-handler by &lt;a href=&quot;#sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply()&lt;/a&gt;, &lt;a href=&quot;rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt; is immediately returned and the call has no effect.</source>
          <target state="translated">Эту функцию следует вызывать только для итераторов, созданных с помощью функции &lt;a href=&quot;#sqlite3changeset_start&quot;&gt;sqlite3changeset_start ()&lt;/a&gt; . Если приложение вызывает эту функцию с итератором, переданным обработчику конфликтов &lt;a href=&quot;#sqlite3changeset_apply&quot;&gt;функцией sqlite3changeset_apply ()&lt;/a&gt; , немедленно возвращается &lt;a href=&quot;rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt; , и вызов не имеет никакого эффекта.</target>
        </trans-unit>
        <trans-unit id="2df7e3d1377d5e8297acef52974006d62b57703e" translate="yes" xml:space="preserve">
          <source>This function should only be called on iterators created using the &lt;a href=&quot;sqlite3changeset_start&quot;&gt;sqlite3changeset_start()&lt;/a&gt; function. If an application calls this function with an iterator passed to a conflict-handler by &lt;a href=&quot;sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply()&lt;/a&gt;, &lt;a href=&quot;../rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt; is immediately returned and the call has no effect.</source>
          <target state="translated">Эту функцию следует вызывать только для итераторов, созданных с помощью функции &lt;a href=&quot;sqlite3changeset_start&quot;&gt;sqlite3changeset_start ()&lt;/a&gt; . Если приложение вызывает эту функцию с итератором, переданным обработчику конфликтов &lt;a href=&quot;sqlite3changeset_apply&quot;&gt;функцией sqlite3changeset_apply ()&lt;/a&gt; , немедленно возвращается &lt;a href=&quot;../rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt; , и вызов не имеет никакого эффекта.</target>
        </trans-unit>
        <trans-unit id="6644624c994928cadd1595cf7f165d3a9a2ca4f0" translate="yes" xml:space="preserve">
          <source>This function should only be used with iterator objects passed to a conflict-handler callback by &lt;a href=&quot;#sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply()&lt;/a&gt; with either &lt;a href=&quot;#SQLITE_CHANGESET_CONFLICT&quot;&gt;SQLITE_CHANGESET_DATA&lt;/a&gt; or &lt;a href=&quot;#SQLITE_CHANGESET_CONFLICT&quot;&gt;SQLITE_CHANGESET_CONFLICT&lt;/a&gt;. If this function is called on any other iterator, &lt;a href=&quot;rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt; is returned and *ppValue is set to NULL.</source>
          <target state="translated">Эту функцию следует использовать только с объектами итератора, переданными в обратный вызов обработчика конфликтов &lt;a href=&quot;#sqlite3changeset_apply&quot;&gt;функцией sqlite3changeset_apply ()&lt;/a&gt; либо с &lt;a href=&quot;#SQLITE_CHANGESET_CONFLICT&quot;&gt;SQLITE_CHANGESET_DATA,&lt;/a&gt; либо с &lt;a href=&quot;#SQLITE_CHANGESET_CONFLICT&quot;&gt;SQLITE_CHANGESET_CONFLICT&lt;/a&gt; . Если эта функция вызывается в любой другой итератор, &lt;a href=&quot;rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt; возвращается и * ppValue установлен в NULL.</target>
        </trans-unit>
        <trans-unit id="548141af0246ca4eef33b575f89c5796207c5a05" translate="yes" xml:space="preserve">
          <source>This function should only be used with iterator objects passed to a conflict-handler callback by &lt;a href=&quot;sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply()&lt;/a&gt; with either &lt;a href=&quot;c_changeset_conflict&quot;&gt;SQLITE_CHANGESET_DATA&lt;/a&gt; or &lt;a href=&quot;c_changeset_conflict&quot;&gt;SQLITE_CHANGESET_CONFLICT&lt;/a&gt;. If this function is called on any other iterator, &lt;a href=&quot;../rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt; is returned and *ppValue is set to NULL.</source>
          <target state="translated">Эту функцию следует использовать только с объектами итератора, переданными в обратный вызов обработчика конфликтов &lt;a href=&quot;sqlite3changeset_apply&quot;&gt;функцией sqlite3changeset_apply ()&lt;/a&gt; либо с &lt;a href=&quot;c_changeset_conflict&quot;&gt;SQLITE_CHANGESET_DATA,&lt;/a&gt; либо с &lt;a href=&quot;c_changeset_conflict&quot;&gt;SQLITE_CHANGESET_CONFLICT&lt;/a&gt; . Если эта функция вызывается в любой другой итератор, &lt;a href=&quot;../rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt; возвращается и * ppValue установлен в NULL.</target>
        </trans-unit>
        <trans-unit id="aabca26792420e3dedde38828f3aa35b5f3a0612" translate="yes" xml:space="preserve">
          <source>This generates a file named &lt;b&gt;ex1.dump.gz&lt;/b&gt; that contains everything you need to reconstruct the database at a later time, or on another machine. To reconstruct the database, just type:</source>
          <target state="translated">В результате будет создан файл с именем &lt;b&gt;ex1.dump.gz&lt;/b&gt; , содержащий все необходимое для восстановления базы данных позже или на другом компьютере. Чтобы восстановить базу данных, просто введите:</target>
        </trans-unit>
        <trans-unit id="311cc4fab23f9723b1a4efe300a30ad45967a776" translate="yes" xml:space="preserve">
          <source>This graph is acyclic. And we assume that the mtime of every child checkin is no less than the mtime of all its parents. But unlike the earlier examples, this graph might have multiple paths of differing lengths between any two checkins.</source>
          <target state="translated">Этот график ациклический.И мы предполагаем,что время проверки каждого ребенка не меньше времени всех его родителей.Но в отличие от предыдущих примеров,этот граф может иметь несколько путей разной длины между любыми двумя проверками.</target>
        </trans-unit>
        <trans-unit id="fa0e2bf6a1863b49e18b3cb7db1999e03d428ead" translate="yes" xml:space="preserve">
          <source>This historical version numbering system used a two-, three-, or four-number version: W.X, W.X.Y, or W.X.Y.Z. W was the file format: 1 or 2 or 3. X was the major version. Y was the minor version. Z was used only for patch releases to fix bugs.</source>
          <target state="translated">Эта историческая система нумерации версий использовала двух-,трех-или четырехнумерную версию:W.X,W.X.Y.или W.X.Y.Z.W-формат файла:1,2 или 3.X была основной версией.Y-младшая версия.Z использовалась только в патч-релизах для исправления ошибок.</target>
        </trans-unit>
        <trans-unit id="9f4676d0afd51e8fa37c9aa0283801b026a1b72b" translate="yes" xml:space="preserve">
          <source>This instruction causes the VM to halt.</source>
          <target state="translated">Эта инструкция вызывает остановку ВМ.</target>
        </trans-unit>
        <trans-unit id="fdc444b74a87e964e8bcc2b42a370bbc5df69c15" translate="yes" xml:space="preserve">
          <source>This instruction makes a deep copy of the value. A duplicate is made of any string or blob constant. See also &lt;a href=&quot;opcode#SCopy&quot;&gt;SCopy&lt;/a&gt;.</source>
          <target state="translated">Эта инструкция делает глубокую копию значения. Дубликат любой строковой или большой двоичной константы. См. Также &lt;a href=&quot;opcode#SCopy&quot;&gt;SCopy&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0dad5db056b0ca8e5a487c8ab6c8e6dc7e0f2672" translate="yes" xml:space="preserve">
          <source>This instruction makes a shallow copy of the value. If the value is a string or blob, then the copy is only a pointer to the original and hence if the original changes so will the copy. Worse, if the original is deallocated, the copy becomes invalid. Thus the program must guarantee that the original will not change during the lifetime of the copy. Use &lt;a href=&quot;opcode#Copy&quot;&gt;Copy&lt;/a&gt; to make a complete copy.</source>
          <target state="translated">Эта инструкция делает мелкую копию значения. Если значение представляет собой строку или большой двоичный объект, то копия является только указателем на оригинал, и, следовательно, если оригинал изменяется, то будет и копия. Хуже того, если оригинал освобождается, копия становится недействительной. Таким образом, программа должна гарантировать, что оригинал не изменится в течение всего срока службы копии. Используйте &lt;a href=&quot;opcode#Copy&quot;&gt;Копировать,&lt;/a&gt; чтобы сделать полную копию.</target>
        </trans-unit>
        <trans-unit id="4df251f100bd98635ac20986854a4f9d3558bf05" translate="yes" xml:space="preserve">
          <source>This instruction only works for indices. The equivalent instruction for tables is &lt;a href=&quot;opcode#Insert&quot;&gt;Insert&lt;/a&gt;.</source>
          <target state="translated">Эта инструкция работает только для индексов. Эквивалентная инструкция для таблиц - &lt;a href=&quot;opcode#Insert&quot;&gt;Insert&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="724c5d92359b2812711bd98fdbbd0ee48ff16933" translate="yes" xml:space="preserve">
          <source>This instruction only works on tables. The equivalent instruction for indices is &lt;a href=&quot;opcode#IdxInsert&quot;&gt;IdxInsert&lt;/a&gt;.</source>
          <target state="translated">Эта инструкция работает только с таблицами. Эквивалентная инструкция для индексов - &lt;a href=&quot;opcode#IdxInsert&quot;&gt;IdxInsert&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cc342418f5a1b7e3edc039b6124a9b746a56c8e5" translate="yes" xml:space="preserve">
          <source>This instruction throws an error if the memory cell is not initially an integer.</source>
          <target state="translated">Эта инструкция вызывает ошибку,если ячейка памяти изначально не является целым числом.</target>
        </trans-unit>
        <trans-unit id="b8399072455bb3b6ee2757655f5f7b2af59230c1" translate="yes" xml:space="preserve">
          <source>This instruction works like &lt;a href=&quot;opcode#OpenRead&quot;&gt;OpenRead&lt;/a&gt; except that it opens the cursor in read/write mode.</source>
          <target state="translated">Эта инструкция работает как &lt;a href=&quot;opcode#OpenRead&quot;&gt;OpenRead,&lt;/a&gt; за исключением того, что она открывает курсор в режиме чтения / записи.</target>
        </trans-unit>
        <trans-unit id="849ae2eb4b736949542c4487e7de5222b770b0b6" translate="yes" xml:space="preserve">
          <source>This interface allows the size of various constructs to be limited on a connection by connection basis. The first parameter is the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; whose limit is to be set or queried. The second parameter is one of the &lt;a href=&quot;#SQLITE_LIMIT_ATTACHED&quot;&gt;limit categories&lt;/a&gt; that define a class of constructs to be size limited. The third parameter is the new limit for that construct.</source>
          <target state="translated">Этот интерфейс позволяет ограничивать размер различных конструкций в зависимости от соединения. Первый параметр - это &lt;a href=&quot;#sqlite3&quot;&gt;соединение&lt;/a&gt; с базой данных , ограничение которого должно быть установлено или запрошено. Второй параметр - это одна из &lt;a href=&quot;#SQLITE_LIMIT_ATTACHED&quot;&gt;категорий ограничений,&lt;/a&gt; которые определяют класс конструкций, размер которых должен быть ограничен. Третий параметр - это новый предел для этой конструкции.</target>
        </trans-unit>
        <trans-unit id="6687035e8ed6fa147345334bd3634ec9e7ff5918" translate="yes" xml:space="preserve">
          <source>This interface allows the size of various constructs to be limited on a connection by connection basis. The first parameter is the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; whose limit is to be set or queried. The second parameter is one of the &lt;a href=&quot;c_limit_attached&quot;&gt;limit categories&lt;/a&gt; that define a class of constructs to be size limited. The third parameter is the new limit for that construct.</source>
          <target state="translated">Этот интерфейс позволяет ограничивать размер различных конструкций в зависимости от соединения. Первый параметр - это &lt;a href=&quot;sqlite3&quot;&gt;соединение&lt;/a&gt; с базой данных , ограничение которого должно быть установлено или запрошено. Второй параметр - это одна из &lt;a href=&quot;c_limit_attached&quot;&gt;категорий ограничений,&lt;/a&gt; которые определяют класс конструкций, размер которых должен быть ограничен. Третий параметр - это новый предел для этой конструкции.</target>
        </trans-unit>
        <trans-unit id="9256e21c25ccdf9db985fbb93738819f3d6d967d" translate="yes" xml:space="preserve">
          <source>This interface can be used by an application to make sure that the version of SQLite that it is linking against was compiled with the desired setting of the &lt;a href=&quot;../compile#threadsafe&quot;&gt;SQLITE_THREADSAFE&lt;/a&gt; macro.</source>
          <target state="translated">Этот интерфейс может использоваться приложением, чтобы убедиться, что версия SQLite, с которой оно связывается, была скомпилирована с желаемой настройкой макроса &lt;a href=&quot;../compile#threadsafe&quot;&gt;SQLITE_THREADSAFE&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="32dc361b08c9c60505d75103bdc36b57584e9fcf" translate="yes" xml:space="preserve">
          <source>This interface can be used by an application to make sure that the version of SQLite that it is linking against was compiled with the desired setting of the &lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE&lt;/a&gt; macro.</source>
          <target state="translated">Этот интерфейс может использоваться приложением, чтобы убедиться, что версия SQLite, с которой оно связывается, была скомпилирована с желаемой настройкой макроса &lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="25ebb19095f954c7ae8a2ed499bdbfed83aadaa6" translate="yes" xml:space="preserve">
          <source>This interface can be used in combination &lt;a href=&quot;#sqlite3_next_stmt&quot;&gt;sqlite3_next_stmt()&lt;/a&gt; to locate all prepared statements associated with a database connection that are in need of being reset. This can be used, for example, in diagnostic routines to search for prepared statements that are holding a transaction open.</source>
          <target state="translated">Этот интерфейс можно использовать в комбинации &lt;a href=&quot;#sqlite3_next_stmt&quot;&gt;sqlite3_next_stmt ()&lt;/a&gt; для поиска всех подготовленных операторов, связанных с подключением к базе данных, которые необходимо сбросить. Это может использоваться, например, в диагностических процедурах для поиска подготовленных операторов, которые удерживают транзакцию открытой.</target>
        </trans-unit>
        <trans-unit id="d607ef96133a79a067aeb3d80e9e814bdda87569" translate="yes" xml:space="preserve">
          <source>This interface can be used in combination &lt;a href=&quot;next_stmt&quot;&gt;sqlite3_next_stmt()&lt;/a&gt; to locate all prepared statements associated with a database connection that are in need of being reset. This can be used, for example, in diagnostic routines to search for prepared statements that are holding a transaction open.</source>
          <target state="translated">Этот интерфейс можно использовать в комбинации &lt;a href=&quot;next_stmt&quot;&gt;sqlite3_next_stmt ()&lt;/a&gt; для поиска всех подготовленных операторов, связанных с подключением к базе данных, которые необходимо сбросить. Это может использоваться, например, в диагностических процедурах для поиска подготовленных операторов, которые удерживают транзакцию открытой.</target>
        </trans-unit>
        <trans-unit id="d798abdc7bea34806f312f897736975cfc379c7c" translate="yes" xml:space="preserve">
          <source>This interface causes the xEntryPoint() function to be invoked for each new &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; that is created. The idea here is that xEntryPoint() is the entry point for a statically linked &lt;a href=&quot;loadext&quot;&gt;SQLite extension&lt;/a&gt; that is to be automatically loaded into all new database connections.</source>
          <target state="translated">Этот интерфейс вызывает вызов функции xEntryPoint () для каждого создаваемого нового &lt;a href=&quot;#sqlite3&quot;&gt;соединения с базой данных&lt;/a&gt; . Идея здесь в том, что xEntryPoint () является точкой входа для статически связанного &lt;a href=&quot;loadext&quot;&gt;расширения SQLite&lt;/a&gt; , которое должно автоматически загружаться во все новые соединения с базой данных.</target>
        </trans-unit>
        <trans-unit id="a18b59c5465abea2190a535937651aa6f4f67fb4" translate="yes" xml:space="preserve">
          <source>This interface causes the xEntryPoint() function to be invoked for each new &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; that is created. The idea here is that xEntryPoint() is the entry point for a statically linked &lt;a href=&quot;../loadext&quot;&gt;SQLite extension&lt;/a&gt; that is to be automatically loaded into all new database connections.</source>
          <target state="translated">Этот интерфейс вызывает вызов функции xEntryPoint () для каждого создаваемого нового &lt;a href=&quot;sqlite3&quot;&gt;соединения с базой данных&lt;/a&gt; . Идея здесь в том, что xEntryPoint () является точкой входа для статически связанного &lt;a href=&quot;../loadext&quot;&gt;расширения SQLite&lt;/a&gt; , которое должно автоматически загружаться во все новые соединения с базой данных.</target>
        </trans-unit>
        <trans-unit id="9786ef1ecb8c77d789971c3f849525761d5d38c2" translate="yes" xml:space="preserve">
          <source>This interface disables all automatic extensions previously registered using &lt;a href=&quot;#sqlite3_auto_extension&quot;&gt;sqlite3_auto_extension()&lt;/a&gt;.</source>
          <target state="translated">Этот интерфейс отключает все автоматические расширения, ранее зарегистрированные с помощью &lt;a href=&quot;#sqlite3_auto_extension&quot;&gt;sqlite3_auto_extension ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2b9c0cbd974b30f6431515e1186211476ca08e78" translate="yes" xml:space="preserve">
          <source>This interface disables all automatic extensions previously registered using &lt;a href=&quot;auto_extension&quot;&gt;sqlite3_auto_extension()&lt;/a&gt;.</source>
          <target state="translated">Этот интерфейс отключает все автоматические расширения, ранее зарегистрированные с помощью &lt;a href=&quot;auto_extension&quot;&gt;sqlite3_auto_extension ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8736a85b1a1bcc4c800c4ff7d229eb677c9e2f70" translate="yes" xml:space="preserve">
          <source>This interface enables or disables both the C-API &lt;a href=&quot;#sqlite3_load_extension&quot;&gt;sqlite3_load_extension()&lt;/a&gt; and the SQL function &lt;a href=&quot;lang_corefunc#load_extension&quot;&gt;load_extension()&lt;/a&gt;. Use &lt;a href=&quot;#sqlite3_db_config&quot;&gt;sqlite3_db_config&lt;/a&gt;(db,&lt;a href=&quot;#sqlitedbconfigenableloadextension&quot;&gt;SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION&lt;/a&gt;,..) to enable or disable only the C-API.</source>
          <target state="translated">Этот интерфейс включает или отключает как C-API &lt;a href=&quot;#sqlite3_load_extension&quot;&gt;sqlite3_load_extension (), так&lt;/a&gt; и функцию SQL &lt;a href=&quot;lang_corefunc#load_extension&quot;&gt;load_extension ()&lt;/a&gt; . Используйте &lt;a href=&quot;#sqlite3_db_config&quot;&gt;sqlite3_db_config&lt;/a&gt; (db, &lt;a href=&quot;#sqlitedbconfigenableloadextension&quot;&gt;SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION&lt;/a&gt; , ..), чтобы включить или отключить только C-API.</target>
        </trans-unit>
        <trans-unit id="ab1cdc93fe51f37fdae78544827ec5e365f941a3" translate="yes" xml:space="preserve">
          <source>This interface enables or disables both the C-API &lt;a href=&quot;load_extension&quot;&gt;sqlite3_load_extension()&lt;/a&gt; and the SQL function &lt;a href=&quot;../lang_corefunc#load_extension&quot;&gt;load_extension()&lt;/a&gt;. Use &lt;a href=&quot;db_config&quot;&gt;sqlite3_db_config&lt;/a&gt;(db,&lt;a href=&quot;c_dbconfig_defensive#sqlitedbconfigenableloadextension&quot;&gt;SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION&lt;/a&gt;,..) to enable or disable only the C-API.</source>
          <target state="translated">Этот интерфейс включает или отключает как C-API &lt;a href=&quot;load_extension&quot;&gt;sqlite3_load_extension (), так&lt;/a&gt; и функцию SQL &lt;a href=&quot;../lang_corefunc#load_extension&quot;&gt;load_extension ()&lt;/a&gt; . Используйте &lt;a href=&quot;db_config&quot;&gt;sqlite3_db_config&lt;/a&gt; (db, &lt;a href=&quot;c_dbconfig_defensive#sqlitedbconfigenableloadextension&quot;&gt;SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION&lt;/a&gt; , ..), чтобы включить или отключить только C-API.</target>
        </trans-unit>
        <trans-unit id="737d038457ffc2dd705bbf7d3e67fd74eca8f49b" translate="yes" xml:space="preserve">
          <source>This interface is not for use by applications. It exists solely for verifying the correct operation of the SQLite library. Depending on how the SQLite library is compiled, this interface might not exist.</source>
          <target state="translated">Этот интерфейс не предназначен для использования приложениями.Он существует исключительно для проверки правильности работы библиотеки SQLite.В зависимости от того,как библиотека SQLite скомпилирована,данный интерфейс может не существовать.</target>
        </trans-unit>
        <trans-unit id="dec74db456b76b7c855d3cb1358c040acad3ef05" translate="yes" xml:space="preserve">
          <source>This interface is only available if SQLite is compiled with the &lt;a href=&quot;../compile#enable_deserialize&quot;&gt;SQLITE_ENABLE_DESERIALIZE&lt;/a&gt; option.</source>
          <target state="translated">Этот интерфейс доступен только в том случае, если SQLite скомпилирован с параметром &lt;a href=&quot;../compile#enable_deserialize&quot;&gt;SQLITE_ENABLE_DESERIALIZE&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5c93fb0edc37eb4be652a31e1dc573b6923060cf" translate="yes" xml:space="preserve">
          <source>This interface is only available if SQLite is compiled with the &lt;a href=&quot;../compile#enable_snapshot&quot;&gt;SQLITE_ENABLE_SNAPSHOT&lt;/a&gt; option.</source>
          <target state="translated">Этот интерфейс доступен, только если SQLite скомпилирован с параметром &lt;a href=&quot;../compile#enable_snapshot&quot;&gt;SQLITE_ENABLE_SNAPSHOT&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="17b0e4d3f046d7d363af1d959e76e0c4d41dedec" translate="yes" xml:space="preserve">
          <source>This interface is only available if SQLite is compiled with the &lt;a href=&quot;compile#enable_deserialize&quot;&gt;SQLITE_ENABLE_DESERIALIZE&lt;/a&gt; option.</source>
          <target state="translated">Этот интерфейс доступен только в том случае, если SQLite скомпилирован с параметром &lt;a href=&quot;compile#enable_deserialize&quot;&gt;SQLITE_ENABLE_DESERIALIZE&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f287e88e4474f60d3222ad14486a836ab2470ef3" translate="yes" xml:space="preserve">
          <source>This interface is only available if SQLite is compiled with the &lt;a href=&quot;compile#enable_snapshot&quot;&gt;SQLITE_ENABLE_SNAPSHOT&lt;/a&gt; option.</source>
          <target state="translated">Этот интерфейс доступен, только если SQLite скомпилирован с параметром &lt;a href=&quot;compile#enable_snapshot&quot;&gt;SQLITE_ENABLE_SNAPSHOT&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a689b67f9c0bc2c193b97b5db4c5c4f5c1e2370b" translate="yes" xml:space="preserve">
          <source>This interface is similar except that it takes a pointer to a &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; as its first argument and returns statistics about that one object rather than about the entire SQLite library. The &lt;a href=&quot;c3ref/db_status&quot;&gt;sqlite3_db_status()&lt;/a&gt; interface currently only recognizes a single verb &lt;a href=&quot;c3ref/c_dbstatus_options#sqlitedbstatuslookasideused&quot;&gt;SQLITE_DBSTATUS_LOOKASIDE_USED&lt;/a&gt;, though additional verbs may be added in the future.</source>
          <target state="translated">Этот интерфейс аналогичен, за исключением того, что он принимает указатель на &lt;a href=&quot;c3ref/sqlite3&quot;&gt;соединение&lt;/a&gt; с базой данных в качестве своего первого аргумента и возвращает статистику об этом одном объекте, а не обо всей библиотеке SQLite. В настоящее время интерфейс &lt;a href=&quot;c3ref/db_status&quot;&gt;sqlite3_db_status ()&lt;/a&gt; распознает только одну &lt;a href=&quot;c3ref/c_dbstatus_options#sqlitedbstatuslookasideused&quot;&gt;команду SQLITE_DBSTATUS_LOOKASIDE_USED&lt;/a&gt; , хотя в будущем могут быть добавлены дополнительные команды.</target>
        </trans-unit>
        <trans-unit id="6dbf3e0af679b24ae953bf947ba5e6b711370c31" translate="yes" xml:space="preserve">
          <source>This interface is threadsafe on processors where writing a 32-bit integer is atomic.</source>
          <target state="translated">Этот интерфейс является потокобезопасным на процессорах,где запись 32-битного целого является атомарной.</target>
        </trans-unit>
        <trans-unit id="107b6df452544e21fe27c0a26828c70050b20ba8" translate="yes" xml:space="preserve">
          <source>This interface is used to retrieve and reset counter values from a &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt;. The first argument is the prepared statement object to be interrogated. The second argument is an integer code for a specific &lt;a href=&quot;#SQLITE_STMTSTATUS%20counter&quot;&gt;SQLITE_STMTSTATUS counter&lt;/a&gt; to be interrogated. The current value of the requested counter is returned. If the resetFlg is true, then the counter is reset to zero after this interface call returns.</source>
          <target state="translated">Этот интерфейс используется для получения и сброса значений счетчика из &lt;a href=&quot;#sqlite3_stmt&quot;&gt;подготовленного оператора&lt;/a&gt; . Первый аргумент - это подготовленный объект оператора для опроса. Второй аргумент - это целочисленный код для &lt;a href=&quot;#SQLITE_STMTSTATUS%20counter&quot;&gt;опроса&lt;/a&gt; определенного счетчика SQLITE_STMTSTATUS . Возвращается текущее значение запрошенного счетчика. Если resetFlg истинно, то счетчик сбрасывается в ноль после возврата из этого интерфейсного вызова.</target>
        </trans-unit>
        <trans-unit id="459a2b79d755add49b63bbc4196d838dcdf41bd6" translate="yes" xml:space="preserve">
          <source>This interface is used to retrieve and reset counter values from a &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt;. The first argument is the prepared statement object to be interrogated. The second argument is an integer code for a specific &lt;a href=&quot;c_stmtstatus_counter&quot;&gt;SQLITE_STMTSTATUS counter&lt;/a&gt; to be interrogated. The current value of the requested counter is returned. If the resetFlg is true, then the counter is reset to zero after this interface call returns.</source>
          <target state="translated">Этот интерфейс используется для получения и сброса значений счетчика из &lt;a href=&quot;stmt&quot;&gt;подготовленного оператора&lt;/a&gt; . Первый аргумент - это подготовленный объект оператора для опроса. Второй аргумент - это целочисленный код для &lt;a href=&quot;c_stmtstatus_counter&quot;&gt;опроса&lt;/a&gt; определенного счетчика SQLITE_STMTSTATUS . Возвращается текущее значение запрошенного счетчика. Если resetFlg истинно, то счетчик сбрасывается в ноль после возврата из этого интерфейсного вызова.</target>
        </trans-unit>
        <trans-unit id="4800232e2d56454f4af979f9b03af1383971aa52" translate="yes" xml:space="preserve">
          <source>This interface is used to retrieve runtime status information about a single &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt;. The first argument is the database connection object to be interrogated. The second argument is an integer constant, taken from the set of &lt;a href=&quot;#SQLITE_DBSTATUS%20options&quot;&gt;SQLITE_DBSTATUS options&lt;/a&gt;, that determines the parameter to interrogate. The set of &lt;a href=&quot;#SQLITE_DBSTATUS%20options&quot;&gt;SQLITE_DBSTATUS options&lt;/a&gt; is likely to grow in future releases of SQLite.</source>
          <target state="translated">Этот интерфейс используется для получения информации о состоянии выполнения для одного &lt;a href=&quot;#sqlite3&quot;&gt;соединения с базой данных&lt;/a&gt; . Первый аргумент - это опрашиваемый объект соединения с базой данных. Второй аргумент - это целочисленная константа, взятая из набора &lt;a href=&quot;#SQLITE_DBSTATUS%20options&quot;&gt;параметров SQLITE_DBSTATUS&lt;/a&gt; , которая определяет параметр для опроса. Набор &lt;a href=&quot;#SQLITE_DBSTATUS%20options&quot;&gt;параметров SQLITE_DBSTATUS,&lt;/a&gt; вероятно, будет расширяться в будущих выпусках SQLite.</target>
        </trans-unit>
        <trans-unit id="bbc3302201d2b7cd437db8ee6aa036bac03658d0" translate="yes" xml:space="preserve">
          <source>This interface is used to retrieve runtime status information about a single &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt;. The first argument is the database connection object to be interrogated. The second argument is an integer constant, taken from the set of &lt;a href=&quot;c_dbstatus_options&quot;&gt;SQLITE_DBSTATUS options&lt;/a&gt;, that determines the parameter to interrogate. The set of &lt;a href=&quot;c_dbstatus_options&quot;&gt;SQLITE_DBSTATUS options&lt;/a&gt; is likely to grow in future releases of SQLite.</source>
          <target state="translated">Этот интерфейс используется для получения информации о состоянии выполнения для одного &lt;a href=&quot;sqlite3&quot;&gt;соединения с базой данных&lt;/a&gt; . Первый аргумент - это опрашиваемый объект соединения с базой данных. Второй аргумент - это целочисленная константа, взятая из набора &lt;a href=&quot;c_dbstatus_options&quot;&gt;параметров SQLITE_DBSTATUS&lt;/a&gt; , которая определяет параметр для опроса. Набор &lt;a href=&quot;c_dbstatus_options&quot;&gt;параметров SQLITE_DBSTATUS,&lt;/a&gt; вероятно, будет расширяться в будущих выпусках SQLite.</target>
        </trans-unit>
        <trans-unit id="0177c23c0459f643a4c9d13247ce19efb1a18257" translate="yes" xml:space="preserve">
          <source>This interface loads an SQLite extension library from the named file.</source>
          <target state="translated">Этот интерфейс загружает библиотеку расширений SQLite из именованного файла.</target>
        </trans-unit>
        <trans-unit id="8179bad6a4aa6b903a52e81e492e1156f601b09e" translate="yes" xml:space="preserve">
          <source>This interface only reports on the compile-time mutex setting of the &lt;a href=&quot;../compile#threadsafe&quot;&gt;SQLITE_THREADSAFE&lt;/a&gt; flag. If SQLite is compiled with SQLITE_THREADSAFE=1 or =2 then mutexes are enabled by default but can be fully or partially disabled using a call to &lt;a href=&quot;config&quot;&gt;sqlite3_config()&lt;/a&gt; with the verbs &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigsinglethread&quot;&gt;SQLITE_CONFIG_SINGLETHREAD&lt;/a&gt;, &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigmultithread&quot;&gt;SQLITE_CONFIG_MULTITHREAD&lt;/a&gt;, or &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigserialized&quot;&gt;SQLITE_CONFIG_SERIALIZED&lt;/a&gt;. The return value of the sqlite3_threadsafe() function shows only the compile-time setting of thread safety, not any run-time changes to that setting made by sqlite3_config(). In other words, the return value from sqlite3_threadsafe() is unchanged by calls to sqlite3_config().</source>
          <target state="translated">Этот интерфейс сообщает только о настройке мьютекса времени &lt;a href=&quot;../compile#threadsafe&quot;&gt;компиляции&lt;/a&gt; флага SQLITE_THREADSAFE . Если SQLite скомпилирован с SQLITE_THREADSAFE = 1 или = 2, то мьютексы включены по умолчанию, но могут быть полностью или частично отключены с помощью вызова &lt;a href=&quot;config&quot;&gt;sqlite3_config ()&lt;/a&gt; с глаголами &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigsinglethread&quot;&gt;SQLITE_CONFIG_SINGLETHREAD&lt;/a&gt; , &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigmultithread&quot;&gt;SQLITE_CONFIG_MULTITHREAD&lt;/a&gt; или &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigserialized&quot;&gt;SQLITE_CONIZEDIG_SERIAL&lt;/a&gt; . Возвращаемое значение функции sqlite3_threadsafe () показывает только настройку безопасности потоков во время компиляции, но не любые изменения во время выполнения этого параметра, сделанные sqlite3_config (). Другими словами, возвращаемое значение sqlite3_threadsafe () не изменяется при вызове sqlite3_config ().</target>
        </trans-unit>
        <trans-unit id="2f1c5432e18dc84d0ab872e79f78a9b49a5ab932" translate="yes" xml:space="preserve">
          <source>This interface only reports on the compile-time mutex setting of the &lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE&lt;/a&gt; flag. If SQLite is compiled with SQLITE_THREADSAFE=1 or =2 then mutexes are enabled by default but can be fully or partially disabled using a call to &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config()&lt;/a&gt; with the verbs &lt;a href=&quot;#sqliteconfigsinglethread&quot;&gt;SQLITE_CONFIG_SINGLETHREAD&lt;/a&gt;, &lt;a href=&quot;#sqliteconfigmultithread&quot;&gt;SQLITE_CONFIG_MULTITHREAD&lt;/a&gt;, or &lt;a href=&quot;#sqliteconfigserialized&quot;&gt;SQLITE_CONFIG_SERIALIZED&lt;/a&gt;. The return value of the sqlite3_threadsafe() function shows only the compile-time setting of thread safety, not any run-time changes to that setting made by sqlite3_config(). In other words, the return value from sqlite3_threadsafe() is unchanged by calls to sqlite3_config().</source>
          <target state="translated">Этот интерфейс сообщает только о настройке мьютекса времени &lt;a href=&quot;compile#threadsafe&quot;&gt;компиляции&lt;/a&gt; флага SQLITE_THREADSAFE . Если SQLite скомпилирован с SQLITE_THREADSAFE = 1 или = 2, то мьютексы включены по умолчанию, но могут быть полностью или частично отключены с помощью вызова &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config ()&lt;/a&gt; с глаголами &lt;a href=&quot;#sqliteconfigsinglethread&quot;&gt;SQLITE_CONFIG_SINGLETHREAD&lt;/a&gt; , &lt;a href=&quot;#sqliteconfigmultithread&quot;&gt;SQLITE_CONFIG_MULTITHREAD&lt;/a&gt; или &lt;a href=&quot;#sqliteconfigserialized&quot;&gt;SQLITE_CONIZEDIG_SERIAL&lt;/a&gt; . Возвращаемое значение функции sqlite3_threadsafe () показывает только настройку безопасности потоков во время компиляции, но не любые изменения во время выполнения этого параметра, сделанные sqlite3_config (). Другими словами, возвращаемое значение sqlite3_threadsafe () не изменяется при вызове sqlite3_config ().</target>
        </trans-unit>
        <trans-unit id="3e88b1695c7d666ba2e7d53c0b55a6d5efcc55d7" translate="yes" xml:space="preserve">
          <source>This interface returns a pointer the &lt;a href=&quot;#sqlite3_mutex&quot;&gt;sqlite3_mutex&lt;/a&gt; object that serializes access to the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; given in the argument when the &lt;a href=&quot;threadsafe&quot;&gt;threading mode&lt;/a&gt; is Serialized. If the &lt;a href=&quot;threadsafe&quot;&gt;threading mode&lt;/a&gt; is Single-thread or Multi-thread then this routine returns a NULL pointer.</source>
          <target state="translated">Этот интерфейс возвращает указатель на объект &lt;a href=&quot;#sqlite3_mutex&quot;&gt;sqlite3_mutex,&lt;/a&gt; который сериализует доступ к &lt;a href=&quot;#sqlite3&quot;&gt;соединению&lt;/a&gt; с базой данных, указанному в аргументе, когда &lt;a href=&quot;threadsafe&quot;&gt;режим потоковой передачи&lt;/a&gt; является сериализованным. Если &lt;a href=&quot;threadsafe&quot;&gt;режим потоков&lt;/a&gt; - однопоточный или многопоточный, то эта процедура возвращает указатель NULL.</target>
        </trans-unit>
        <trans-unit id="d1fc22f71a3cec256b724ef1c90f879b1fc5cc86" translate="yes" xml:space="preserve">
          <source>This interface returns a pointer the &lt;a href=&quot;mutex&quot;&gt;sqlite3_mutex&lt;/a&gt; object that serializes access to the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; given in the argument when the &lt;a href=&quot;../threadsafe&quot;&gt;threading mode&lt;/a&gt; is Serialized. If the &lt;a href=&quot;../threadsafe&quot;&gt;threading mode&lt;/a&gt; is Single-thread or Multi-thread then this routine returns a NULL pointer.</source>
          <target state="translated">Этот интерфейс возвращает указатель на объект &lt;a href=&quot;mutex&quot;&gt;sqlite3_mutex,&lt;/a&gt; который сериализует доступ к &lt;a href=&quot;sqlite3&quot;&gt;соединению&lt;/a&gt; с базой данных, указанному в аргументе, когда &lt;a href=&quot;../threadsafe&quot;&gt;режим потоковой передачи&lt;/a&gt; является сериализованным. Если &lt;a href=&quot;../threadsafe&quot;&gt;режим потоков&lt;/a&gt; - однопоточный или многопоточный, то эта процедура возвращает указатель NULL.</target>
        </trans-unit>
        <trans-unit id="293e65533b2e0bf802333580611e0758a28818fb" translate="yes" xml:space="preserve">
          <source>This interface returns a pointer to the next &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; after pStmt associated with the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; pDb. If pStmt is NULL then this interface returns a pointer to the first prepared statement associated with the database connection pDb. If no prepared statement satisfies the conditions of this routine, it returns NULL.</source>
          <target state="translated">Этот интерфейс возвращает указатель на следующий &lt;a href=&quot;#sqlite3_stmt&quot;&gt;подготовленный оператор&lt;/a&gt; после pStmt, связанный с &lt;a href=&quot;#sqlite3&quot;&gt;подключением&lt;/a&gt; к базе данных pDb. Если pStmt равен NULL, то этот интерфейс возвращает указатель на первый подготовленный оператор, связанный с подключением к базе данных pDb. Если ни один подготовленный оператор не удовлетворяет условиям этой процедуры, он возвращает NULL.</target>
        </trans-unit>
        <trans-unit id="298da08b2fcbf608e155bad7e295f53eb1526e44" translate="yes" xml:space="preserve">
          <source>This interface returns a pointer to the next &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; after pStmt associated with the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; pDb. If pStmt is NULL then this interface returns a pointer to the first prepared statement associated with the database connection pDb. If no prepared statement satisfies the conditions of this routine, it returns NULL.</source>
          <target state="translated">Этот интерфейс возвращает указатель на следующий &lt;a href=&quot;stmt&quot;&gt;подготовленный оператор&lt;/a&gt; после pStmt, связанный с &lt;a href=&quot;sqlite3&quot;&gt;подключением&lt;/a&gt; к базе данных pDb. Если pStmt равен NULL, то этот интерфейс возвращает указатель на первый подготовленный оператор, связанный с подключением к базе данных pDb. Если ни один подготовленный оператор не удовлетворяет условиям этой процедуры, он возвращает NULL.</target>
        </trans-unit>
        <trans-unit id="e0779d667db00a554725939028269aca490f34bf" translate="yes" xml:space="preserve">
          <source>This interface returns information about the predicted and measured performance for pStmt. Advanced applications can use this interface to compare the predicted and the measured performance and issue warnings and/or rerun &lt;a href=&quot;../lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; if discrepancies are found.</source>
          <target state="translated">Этот интерфейс возвращает информацию о прогнозируемой и измеренной производительности для pStmt. Расширенные приложения могут использовать этот интерфейс для сравнения прогнозируемой и измеренной производительности и выдачи предупреждений и / или повторного &lt;a href=&quot;../lang_analyze&quot;&gt;запуска ANALYZE&lt;/a&gt; при обнаружении расхождений.</target>
        </trans-unit>
        <trans-unit id="85a4493d9adb4944292a15518241fee7e748e502" translate="yes" xml:space="preserve">
          <source>This interface returns information about the predicted and measured performance for pStmt. Advanced applications can use this interface to compare the predicted and the measured performance and issue warnings and/or rerun &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; if discrepancies are found.</source>
          <target state="translated">Этот интерфейс возвращает информацию о прогнозируемой и измеренной производительности для pStmt. Расширенные приложения могут использовать этот интерфейс для сравнения прогнозируемой и измеренной производительности и выдачи предупреждений и / или повторного &lt;a href=&quot;lang_analyze&quot;&gt;запуска ANALYZE&lt;/a&gt; при обнаружении расхождений.</target>
        </trans-unit>
        <trans-unit id="1bb0500a44659bfdd838f99dddff5b2745a24fd7" translate="yes" xml:space="preserve">
          <source>This interface used to be the only way to cause a checkpoint to occur. But then the newer and more powerful &lt;a href=&quot;#sqlite3_wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2()&lt;/a&gt; interface was added. This interface is retained for backwards compatibility and as a convenience for applications that need to manually start a callback but which do not need the full power (and corresponding complication) of &lt;a href=&quot;#sqlite3_wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2()&lt;/a&gt;.</source>
          <target state="translated">Этот интерфейс раньше был единственным способом вызвать контрольную точку. Но затем был добавлен более новый и более мощный интерфейс &lt;a href=&quot;#sqlite3_wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2 ()&lt;/a&gt; . Этот интерфейс сохранен для обратной совместимости и в качестве удобства для приложений, которым необходимо вручную запускать обратный вызов, но которым не требуется полная мощность (и соответствующие сложности) &lt;a href=&quot;#sqlite3_wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2 ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f8650a908576cbf78aafa5f2c01220a648b07e6e" translate="yes" xml:space="preserve">
          <source>This interface used to be the only way to cause a checkpoint to occur. But then the newer and more powerful &lt;a href=&quot;wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2()&lt;/a&gt; interface was added. This interface is retained for backwards compatibility and as a convenience for applications that need to manually start a callback but which do not need the full power (and corresponding complication) of &lt;a href=&quot;wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2()&lt;/a&gt;.</source>
          <target state="translated">Этот интерфейс раньше был единственным способом вызвать контрольную точку. Но затем был добавлен более новый и более мощный интерфейс &lt;a href=&quot;wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2 ()&lt;/a&gt; . Этот интерфейс сохранен для обратной совместимости и в качестве удобства для приложений, которым необходимо вручную запускать обратный вызов, но которым не требуется полная мощность (и соответствующие сложности) &lt;a href=&quot;wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2 ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f7d4c03d6a4b6a9f5c9aedcc9b701719388f47dd" translate="yes" xml:space="preserve">
          <source>This interfaces opens a &lt;a href=&quot;#sqlite3_blob&quot;&gt;handle&lt;/a&gt; to the BLOB located in row iRow, column zColumn, table zTable in database zDb; in other words, the same BLOB that would be selected by:</source>
          <target state="translated">Этот интерфейс открывает &lt;a href=&quot;#sqlite3_blob&quot;&gt;дескриптор&lt;/a&gt; большого двоичного объекта, расположенного в строке iRow, столбце zColumn, таблице zTable в базе данных zDb; другими словами, тот же самый большой двоичный объект, который будет выбран:</target>
        </trans-unit>
        <trans-unit id="d56bad6a2645b8e7253284f59e7a63eae875fa74" translate="yes" xml:space="preserve">
          <source>This interfaces opens a &lt;a href=&quot;blob&quot;&gt;handle&lt;/a&gt; to the BLOB located in row iRow, column zColumn, table zTable in database zDb; in other words, the same BLOB that would be selected by:</source>
          <target state="translated">Этот интерфейс открывает &lt;a href=&quot;blob&quot;&gt;дескриптор&lt;/a&gt; большого двоичного объекта, расположенного в строке iRow, столбце zColumn, таблице zTable в базе данных zDb; другими словами, тот же самый большой двоичный объект, который будет выбран:</target>
        </trans-unit>
        <trans-unit id="13a6b9699070bd3ee5f0499a2e1cddf56e4de906" translate="yes" xml:space="preserve">
          <source>This is a convenience method. It saves the user from having to do a &quot;&lt;code&gt;[lindex ... 0]&lt;/code&gt;&quot; on the results of an &quot;eval&quot; in order to extract a single column result.</source>
          <target state="translated">Это удобный метод. Это избавляет пользователя от необходимости выполнять &amp;laquo; &lt;code&gt;[lindex ... 0]&lt;/code&gt; &amp;raquo; над результатами &amp;laquo;eval&amp;raquo;, чтобы извлечь результат из одного столбца.</target>
        </trans-unit>
        <trans-unit id="38e166d44e718495aa683d7ad0a1c631f4c6b59a" translate="yes" xml:space="preserve">
          <source>This is a deferred seek. Nothing actually happens until the cursor is used to read a record. That way, if no reads occur, no unnecessary I/O happens.</source>
          <target state="translated">Это отложенный поиск.На самом деле ничего не происходит до тех пор,пока курсор не будет использован для чтения записи.Таким образом,если не происходит чтения,не происходит ненужного ввода/вывода.</target>
        </trans-unit>
        <trans-unit id="2382322bd7fe40fc2a51108a576a294144a75f00" translate="yes" xml:space="preserve">
          <source>This is a deprecated version of the &lt;a href=&quot;#sqlite3_hard_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64()&lt;/a&gt; interface. This routine is provided for historical compatibility only. All new applications should use the &lt;a href=&quot;#sqlite3_hard_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64()&lt;/a&gt; interface rather than this one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3322a19f5183f0c0a12dac751f8fe80d74d2317" translate="yes" xml:space="preserve">
          <source>This is a deprecated version of the &lt;a href=&quot;#sqlite3_soft_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64()&lt;/a&gt; interface. This routine is provided for historical compatibility only. All new applications should use the &lt;a href=&quot;#sqlite3_soft_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64()&lt;/a&gt; interface rather than this one.</source>
          <target state="translated">Это устаревшая версия интерфейса &lt;a href=&quot;#sqlite3_soft_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64 ()&lt;/a&gt; . Эта процедура предоставляется только для исторической совместимости. Все новые приложения должны использовать интерфейс &lt;a href=&quot;#sqlite3_soft_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64 (),&lt;/a&gt; а не этот.</target>
        </trans-unit>
        <trans-unit id="549ad021f1f25c6ff9bbe6ad516bdc1aab2d979c" translate="yes" xml:space="preserve">
          <source>This is a deprecated version of the &lt;a href=&quot;hard_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64()&lt;/a&gt; interface. This routine is provided for historical compatibility only. All new applications should use the &lt;a href=&quot;hard_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64()&lt;/a&gt; interface rather than this one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83b5b2c4751d7d27636c7987b515f0e77b9f539e" translate="yes" xml:space="preserve">
          <source>This is a deprecated version of the &lt;a href=&quot;soft_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64()&lt;/a&gt; interface. This routine is provided for historical compatibility only. All new applications should use the &lt;a href=&quot;soft_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64()&lt;/a&gt; interface rather than this one.</source>
          <target state="translated">Это устаревшая версия интерфейса &lt;a href=&quot;soft_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64 ()&lt;/a&gt; . Эта процедура предоставляется только для исторической совместимости. Все новые приложения должны использовать интерфейс &lt;a href=&quot;soft_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64 (),&lt;/a&gt; а не этот.</target>
        </trans-unit>
        <trans-unit id="3265de0d01aec05a2acca7ad5cf1ffeadb61ea03" translate="yes" xml:space="preserve">
          <source>This is a feature, not a bug. SQLite uses &lt;a href=&quot;datatype3&quot;&gt;dynamic typing&lt;/a&gt;. It does not enforce data type constraints. Data of any type can (usually) be inserted into any column. You can put arbitrary length strings into integer columns, floating point numbers in boolean columns, or dates in character columns. The &lt;a href=&quot;datatype3&quot;&gt;datatype&lt;/a&gt; you assign to a column in the CREATE TABLE command does not restrict what data can be put into that column. Every column is able to hold an arbitrary length string. (There is one exception: Columns of type &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; may only hold a 64-bit signed integer. An error will result if you try to put anything other than an integer into an &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; column.)</source>
          <target state="translated">Это особенность, а не ошибка. SQLite использует &lt;a href=&quot;datatype3&quot;&gt;динамическую типизацию&lt;/a&gt; . Он не налагает ограничений на типы данных. Данные любого типа (обычно) могут быть вставлены в любой столбец. Вы можете помещать строки произвольной длины в целочисленные столбцы, числа с плавающей запятой в логические столбцы или даты в символьные столбцы. Тип &lt;a href=&quot;datatype3&quot;&gt;данных, который&lt;/a&gt; вы назначаете столбцу в команде CREATE TABLE, не ограничивает, какие данные могут быть помещены в этот столбец. Каждый столбец может содержать строку произвольной длины. (Есть одно исключение: столбцы типа &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; могут содержать только 64-разрядное целое число со знаком. Если вы попытаетесь поместить что-либо, кроме целого, в столбец &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY,&lt;/a&gt; возникнет ошибка .)</target>
        </trans-unit>
        <trans-unit id="5c1fa1ef2dde20cd88e16281d01dfa503bb7906f" translate="yes" xml:space="preserve">
          <source>This is a function with powerful side-effects. Most programmers would be naturally cautious about using it, but probably would not see the harm in merely having it available. But there is great risk in merely defining such a function, even if the application itself never invokes it!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7d02094df3f3fda475c3c0669d010669d55439e" translate="yes" xml:space="preserve">
          <source>This is a legacy interface that is preserved for backwards compatibility. Use of this interface is not recommended.</source>
          <target state="translated">Это унаследованный интерфейс,который сохранен для обратной совместимости.Использование этого интерфейса не рекомендуется.</target>
        </trans-unit>
        <trans-unit id="5f257f6218e523212322ebfdf81d8c0135554419" translate="yes" xml:space="preserve">
          <source>This is a limitation of the R-Tree extension only. Ordinary tables in SQLite are able to read and write at the same time. Other virtual tables might (or might not) also that capability. And R-Tree can appear to read and write at the same time in some circumstances, if it can figure out how to reliably run the query to completion before starting the update. But you shouldn't count on that for every query. Generally speaking, it is best to avoid running queries and updates to the same R-Tree at the same time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d61b35431e03f12c702f21bbd7e7a511e4a6548" translate="yes" xml:space="preserve">
          <source>This is a maintenance release only. Various minor bugs have been fixed and some portability enhancements are added.</source>
          <target state="translated">Это только для техобслуживания.Были исправлены различные мелкие ошибки и добавлены некоторые улучшения переносимости.</target>
        </trans-unit>
        <trans-unit id="899c3e8633e96cd6aefa72bc202abc232fd0022d" translate="yes" xml:space="preserve">
          <source>This is an edit distance or Levenshtein distance going from the pattern to the word.</source>
          <target state="translated">Это расстояние редактирования или расстояние Левенштейна от детали до слова.</target>
        </trans-unit>
        <trans-unit id="910e8aa32c8839104ce5280b502b0fcc013f6738" translate="yes" xml:space="preserve">
          <source>This is an optimized version of &lt;a href=&quot;opcode#SCopy&quot;&gt;SCopy&lt;/a&gt; that works only for integer values.</source>
          <target state="translated">Это оптимизированная версия &lt;a href=&quot;opcode#SCopy&quot;&gt;SCopy,&lt;/a&gt; которая работает только для целочисленных значений.</target>
        </trans-unit>
        <trans-unit id="801748b6bec70348d36bd30ab9aa7d8d99ebf0cc" translate="yes" xml:space="preserve">
          <source>This is done by using the file locking facilities provided by the VFS adaptor to serialize writers (write transactions) and preventing readers (read transactions) from accessing database files while writers are midway through updating them.</source>
          <target state="translated">Для этого используются средства блокировки файлов,предоставляемые VFS-адаптером для сериализации записывающих устройств (транзакций записи)и предотвращения доступа читателей (транзакций чтения)к файлам базы данных в то время,как записывающие устройства находятся в середине процесса их обновления.</target>
        </trans-unit>
        <trans-unit id="8da36cedfb4232a176b408433fde7c4fd7207c97" translate="yes" xml:space="preserve">
          <source>This is not a trivial point. A clear, concise, and easy to understand file format is a crucial part of any application design. Fred Brooks, in his all-time best-selling computer science text,</source>
          <target state="translated">Это не тривиальная точка зрения.Четкий,лаконичный и понятный формат файла является важной частью любого проекта приложения.Фред Брукс,в своем бестселлере по компьютерным наукам,</target>
        </trans-unit>
        <trans-unit id="1c13d43de084b1c54ea28d7db810dbdc504863cc" translate="yes" xml:space="preserve">
          <source>This is not to say that CVEs are useless. CVEs do still (mostly) report actual bugs. But in most cases the bugs are not true vulnerabilities, in the sense that they do not contribute to data loss or compromise in and of themselves. It is good that bugs are reported and fixed. But not every bug is accessible from every application. In the case of SQLite, most of the bugs reported by CVEs are inaccessible in most applications. Upgrading to the latest version of SQLite is always a good plan, but it need not be an emergency just because an anonymous grey-hat on the internet wrote up a CVE.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71f131e03503ae5c8b8ced0f182cb10a7090642b" translate="yes" xml:space="preserve">
          <source>This is not valid SQL because of the apostrophe in the word &quot;y'all&quot;. But if the %q formatting option is used instead of %s, like this:</source>
          <target state="translated">Это недействительный SQL из-за апострофа в слове &quot;y'all&quot;.Но если вместо %s используется опция форматирования %q,например,так:</target>
        </trans-unit>
        <trans-unit id="b10e12e9a12481ea13f1cbdd991de65338cc882f" translate="yes" xml:space="preserve">
          <source>This is the &quot;alternate-form-1&quot; flag. For %g and %G substitutions, this causes trailing zeros to be removed. This flag forces a decimal point to appear for all floating-point substitutions. For %o, %x, and %X substitutions, the alternate-form-1 flag cause the value to be prepended with &quot;0&quot;, &quot;0x&quot;, or &quot;0X&quot;, respectively.</source>
          <target state="translated">Это флаг &quot;альтернативная форма-1&quot;.При замене %g и %G это приводит к удалению трейлинговых нулей.Этот флаг заставляет появляться десятичную точку для всех замен с плавающей точкой.Для замен %o,%x и %X флаг переменной формы-1 вызывает префиксацию значения с &quot;0&quot;,&quot;0x&quot; или &quot;0X&quot;,соответственно.</target>
        </trans-unit>
        <trans-unit id="63cb4b6d9fe02ab2deb206f8aa9f5671d078c8f3" translate="yes" xml:space="preserve">
          <source>This is the &quot;alternate-form-2 flag. For string substitutions, this flag causes the width and precision to be understand in terms of characters rather than bytes. For floating point substitutions, the alternate-form-2 flag increases the maximum number of significant digits displayed from 16 to 26, forces the display of the decimal point and causes at least one digit to appear after the decimal point.</source>
          <target state="translated">Это флаг &quot;альтернативной формы-2&quot;.При подстановке строк этот флаг вызывает понимание ширины и точности не в байтах,а в символах.При заменах с плавающей точкой флаг переменной формы-2 увеличивает максимальное количество отображаемых значащих цифр с 16 до 26,заставляет отображать десятичную точку и заставляет по крайней мере одну цифру отображаться после запятой.</target>
        </trans-unit>
        <trans-unit id="bc902c483a7876a1b0deb3582a89dafeb4cea481" translate="yes" xml:space="preserve">
          <source>This is the Quality Management Plan for SQLite.</source>
          <target state="translated">Это план управления качеством для SQLite.</target>
        </trans-unit>
        <trans-unit id="67d77b8b0173c35f0fc8ffa751afcfc454c71889" translate="yes" xml:space="preserve">
          <source>This is the approximate number of bytes of heap memory used to store the prepared statement. This value is not actually a counter, and so the resetFlg parameter to sqlite3_stmt_status() is ignored when the opcode is SQLITE_STMTSTATUS_MEMUSED.</source>
          <target state="translated">Это приблизительное количество байтов кучи памяти,используемой для хранения подготовленного оператора.На самом деле это значение не является счетчиком,поэтому параметр resetFlg в sqlite3_stmt_status()игнорируется,когда опкод имеет значение SQLITE_STMTSTATUS_MEMUSED.</target>
        </trans-unit>
        <trans-unit id="f5f605b9bb40dfe0763a4e4919a2589f9005f3a1" translate="yes" xml:space="preserve">
          <source>This is the language-id of the word. All queries are against a single language-id, which defaults to 0. For any given query this value is the same on all rows.</source>
          <target state="translated">Это языкознание слова.Все запросы имеют один и тот же языковой код,который по умолчанию равен 0.Для любого заданного запроса это значение одинаково для всех строк.</target>
        </trans-unit>
        <trans-unit id="9fdc70ab1d09ee31e6a0831adfe5fa272a3194e2" translate="yes" xml:space="preserve">
          <source>This is the number of rows inserted into transient indices that were created automatically in order to help joins run faster. A non-zero value in this counter may indicate an opportunity to improvement performance by adding permanent indices that do not need to be reinitialized each time the statement is run.</source>
          <target state="translated">Это количество строк,вставленных в переходные индексы,которые были созданы автоматически,чтобы помочь соединениям работать быстрее.Ненулевое значение в этом счетчике может указывать на возможность улучшения производительности путем добавления постоянных индексов,которые не нужно заново инициализировать каждый раз при выполнении оператора.</target>
        </trans-unit>
        <trans-unit id="8c5491db23237dd3c1b297335729c93feb9329fe" translate="yes" xml:space="preserve">
          <source>This is the number of sort operations that have occurred. A non-zero value in this counter may indicate an opportunity to improvement performance through careful use of indices.</source>
          <target state="translated">Это количество операций сортировки,которые произошли.Ненулевое значение в этом счетчике может указывать на возможность улучшения работы за счет тщательного использования индексов.</target>
        </trans-unit>
        <trans-unit id="f6022b63855545d987e1fb6ed3574f3dde788d4f" translate="yes" xml:space="preserve">
          <source>This is the number of times that SQLite has stepped forward in a table as part of a full table scan. Large numbers for this counter may indicate opportunities for performance improvement through careful use of indices.</source>
          <target state="translated">Это количество раз,которое SQLite шагнул вперед в таблице в рамках полного сканирования таблицы.Большие числа для этого счетчика могут указывать на возможности повышения производительности за счет тщательного использования индексов.</target>
        </trans-unit>
        <trans-unit id="2e2d5cd35f18306585fb3833a8437cb1c68463de" translate="yes" xml:space="preserve">
          <source>This is the number of times that the prepare statement has been automatically regenerated due to schema changes or change to &lt;a href=&quot;../lang_expr#varparam&quot;&gt;bound parameters&lt;/a&gt; that might affect the query plan.</source>
          <target state="translated">Это количество раз, когда оператор подготовки был автоматически регенерирован из-за изменений схемы или изменения &lt;a href=&quot;../lang_expr#varparam&quot;&gt;связанных параметров,&lt;/a&gt; которые могут повлиять на план запроса.</target>
        </trans-unit>
        <trans-unit id="89a19ef4023707e912e6bb81167cc9edbf3dbf2a" translate="yes" xml:space="preserve">
          <source>This is the number of times that the prepare statement has been automatically regenerated due to schema changes or change to &lt;a href=&quot;lang_expr#varparam&quot;&gt;bound parameters&lt;/a&gt; that might affect the query plan.</source>
          <target state="translated">Это количество раз, когда оператор подготовки был автоматически регенерирован из-за изменений схемы или изменения &lt;a href=&quot;lang_expr#varparam&quot;&gt;связанных параметров,&lt;/a&gt; которые могут повлиять на план запроса.</target>
        </trans-unit>
        <trans-unit id="ad8da654215d27127f1f2f4f4e254bee11f6c200" translate="yes" xml:space="preserve">
          <source>This is the number of times that the prepare statement has been automatically regenerated due to schema changes or changes to &lt;a href=&quot;../lang_expr#varparam&quot;&gt;bound parameters&lt;/a&gt; that might affect the query plan.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b13313031c39949951f19dcc69954d4d1da9fef4" translate="yes" xml:space="preserve">
          <source>This is the number of times that the prepare statement has been automatically regenerated due to schema changes or changes to &lt;a href=&quot;lang_expr#varparam&quot;&gt;bound parameters&lt;/a&gt; that might affect the query plan.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fb615d618780dfbede44490d9c1ccf7fc81bcec" translate="yes" xml:space="preserve">
          <source>This is the number of times that the prepared statement has been run. A single &quot;run&quot; for the purposes of this counter is one or more calls to &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; followed by a call to &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset()&lt;/a&gt;. The counter is incremented on the first &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; call of each cycle.</source>
          <target state="translated">Это количество раз, когда подготовленный оператор был запущен. Единственный &amp;laquo;запуск&amp;raquo; для этого счетчика - это один или несколько вызовов &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step (),&lt;/a&gt; за которыми следует вызов &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset ()&lt;/a&gt; . Счетчик увеличивается при первом вызове &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step ()&lt;/a&gt; каждого цикла.</target>
        </trans-unit>
        <trans-unit id="02a22b1b5a6d045d2732a9c5f17c43be586d3ec0" translate="yes" xml:space="preserve">
          <source>This is the number of times that the prepared statement has been run. A single &quot;run&quot; for the purposes of this counter is one or more calls to &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; followed by a call to &lt;a href=&quot;reset&quot;&gt;sqlite3_reset()&lt;/a&gt;. The counter is incremented on the first &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; call of each cycle.</source>
          <target state="translated">Это количество раз, когда подготовленный оператор был запущен. Единственный &amp;laquo;запуск&amp;raquo; для этого счетчика - это один или несколько вызовов &lt;a href=&quot;step&quot;&gt;sqlite3_step (),&lt;/a&gt; за которыми следует вызов &lt;a href=&quot;reset&quot;&gt;sqlite3_reset ()&lt;/a&gt; . Счетчик увеличивается при первом вызове &lt;a href=&quot;step&quot;&gt;sqlite3_step ()&lt;/a&gt; каждого цикла.</target>
        </trans-unit>
        <trans-unit id="dac86b21d034a44083d19f0648edfd3d6aee1a04" translate="yes" xml:space="preserve">
          <source>This is the number of virtual machine operations executed by the prepared statement if that number is less than or equal to 2147483647. The number of virtual machine operations can be used as a proxy for the total work done by the prepared statement. If the number of virtual machine operations exceeds 2147483647 then the value returned by this statement status code is undefined.</source>
          <target state="translated">Это количество операций виртуальной машины,выполняемых подготовленным оператором,если оно меньше или равно 2147483647.Количество операций виртуальной машины может быть использовано в качестве прокси-сервера для всего объема работы,выполненной подготовленным оператором.Если количество операций виртуальной машины превышает 2147483647,то возвращаемое кодом состояния этого оператора значение не определяется.</target>
        </trans-unit>
        <trans-unit id="cd780664af2f5e88c09d027911d10ff2fa28ed11" translate="yes" xml:space="preserve">
          <source>This is the query that solves the puzzle:</source>
          <target state="translated">Это запрос,который решает головоломку:</target>
        </trans-unit>
        <trans-unit id="68e28408e53f654e22a7d4b5e13087b011ad015a" translate="yes" xml:space="preserve">
          <source>This is the rank of the word, as specified in the original INSERT statement.</source>
          <target state="translated">Это ранг слова,как указано в первоначальном утверждении INSERT.</target>
        </trans-unit>
        <trans-unit id="3c347af279705ccb7203ae88698186539d78c1bc" translate="yes" xml:space="preserve">
          <source>This is the same as &quot;&amp;lt;expr&amp;gt; PRECEDING&quot; except that the boundary is &amp;lt;expr&amp;gt; units after the current rather than before the current row.</source>
          <target state="translated">Это то же самое, что и &amp;laquo;&amp;lt;expr&amp;gt; PRECEDING&amp;raquo;, за исключением того, что граница находится на &amp;lt;expr&amp;gt; единицах после текущей, а не перед текущей строкой.</target>
        </trans-unit>
        <trans-unit id="b5b506e660f5afa226074ab8a993cee25ea85c25" translate="yes" xml:space="preserve">
          <source>This key is then limited to &quot;scope&quot; characters. The default scope value is 4, but an alternative scope can be specified using the &quot;scope=N&quot; term in the WHERE clause. After the key has been truncated, the edit distance is run against every term in the vocabulary that has a k2 value that begins with the abbreviated key.</source>
          <target state="translated">Этот ключ затем ограничивается символами &quot;рамки&quot;.Значение диапазона по умолчанию равно 4,но альтернативный диапазон может быть указан с помощью термина &quot;scope=N&quot; в выражении WHERE.После того,как ключ усечен,дистанция редактирования выполняется по отношению к каждому термину в словаре,имеющему значение k2,которое начинается с сокращенного ключа.</target>
        </trans-unit>
        <trans-unit id="09f3f2089114bd06180ad8313e37ae120cabb71b" translate="yes" xml:space="preserve">
          <source>This kind of problem comes up all the time when dealing with floating point binary numbers. The general rule to remember is that most fractional numbers that have a finite representation in decimal (a.k.a &quot;base-10&quot;) do not have a finite representation in binary (a.k.a &quot;base-2&quot;). And so they are approximated using the closest binary number available. That approximation is usually very close, but it will be slightly off and in some cases can cause your results to be a little different from what you might expect.</source>
          <target state="translated">Такие проблемы возникают постоянно,когда имеешь дело с двоичными числами с плавающей точкой.Общее правило,которое следует помнить,заключается в том,что большинство дробных чисел,которые имеют конечное представление в десятичной форме (&quot;base-10&quot;),не имеют конечного представления в двоичной форме (&quot;base-2&quot;).Поэтому они аппроксимируются с помощью ближайшего двоичного числа.Это приближение обычно очень близко,но оно будет слегка выключено и в некоторых случаях может привести к тому,что Ваши результаты будут немного отличаться от того,что Вы могли бы ожидать.</target>
        </trans-unit>
        <trans-unit id="a135a2763d0f0112ca15bcc48e7dbab83e04271e" translate="yes" xml:space="preserve">
          <source>This last code will give the following output:</source>
          <target state="translated">Этот последний код выдаст следующий результат:</target>
        </trans-unit>
        <trans-unit id="47d19850010695a0ad5164e9f6289137fa74e392" translate="yes" xml:space="preserve">
          <source>This later query generates exactly the same &lt;a href=&quot;opcode&quot;&gt;bytecode&lt;/a&gt; as the previous scalar formulation, but using syntax that it cleaner and easier to read.</source>
          <target state="translated">Этот более поздний запрос генерирует точно такой же &lt;a href=&quot;opcode&quot;&gt;байт-код,&lt;/a&gt; что и предыдущая скалярная формулировка, но с использованием синтаксиса, который более понятен и удобен для чтения.</target>
        </trans-unit>
        <trans-unit id="ee338f99e5b2a8dc89eb5fd7e38f440a68b4f663" translate="yes" xml:space="preserve">
          <source>This limit is only functional if memory usage statistics are available via the &lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_used()&lt;/a&gt; and &lt;a href=&quot;c3ref/status&quot;&gt;sqlite3_status64&lt;/a&gt;(&lt;a href=&quot;c3ref/c_status_malloc_count#sqlitestatusmemoryused&quot;&gt;SQLITE_STATUS_MEMORY_USED&lt;/a&gt;) interfaces. Without that memory usage information, SQLite has no way of knowing when it is about to go over the limit, and thus is unable to prevent the excess memory allocation. Memory usage tracking is turned on by default, but can be disabled at compile-time using the &lt;a href=&quot;compile#default_memstatus&quot;&gt;SQLITE_DEFAULT_MEMSTATUS&lt;/a&gt; option, or at start-time using &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmemstatus&quot;&gt;SQLITE_CONFIG_MEMSTATUS&lt;/a&gt;).</source>
          <target state="translated">Это ограничение работает только в том случае, если статистика использования памяти доступна через интерфейсы &lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_used ()&lt;/a&gt; и &lt;a href=&quot;c3ref/status&quot;&gt;sqlite3_status64&lt;/a&gt; ( &lt;a href=&quot;c3ref/c_status_malloc_count#sqlitestatusmemoryused&quot;&gt;SQLITE_STATUS_MEMORY_USED&lt;/a&gt; ). Без этой информации об использовании памяти SQLite не имеет возможности узнать, когда он собирается превысить лимит, и, следовательно, не может предотвратить избыточное выделение памяти. Отслеживание использования памяти включено по умолчанию, но его можно отключить во время компиляции с помощью параметра &lt;a href=&quot;compile#default_memstatus&quot;&gt;SQLITE_DEFAULT_MEMSTATUS&lt;/a&gt; или во время запуска с помощью &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt; ( &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmemstatus&quot;&gt;SQLITE_CONFIG_MEMSTATUS&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="13ca9d3dd4559d964cbe8a24d9fb9dfdfb2e704d" translate="yes" xml:space="preserve">
          <source>This loop does the actual deleting. It is organized differently from the one in the UPDATE example. The ListRead instruction plays the role that the Next did in the INSERT loop, but because it jumps to P2 on failure, and Next jumps on success, we put it at the start of the loop instead of the end. This means that we have to put a Goto at the end of the loop to jump back to the loop test at the beginning. So this loop has the form of a C while(){...} loop, while the loop in the INSERT example had the form of a do{...}while() loop. The Delete instruction fills the role that the callback function did in the preceding examples.</source>
          <target state="translated">Этот цикл выполняет фактическое удаление.Он организован иначе,чем в примере UPDATE.Инструкция ListRead играет ту же роль,что и Next в цикле INSERT,но поскольку она перепрыгивает на P2 при неудаче,а Next перепрыгивает на успех,мы ставим ее в начало цикла,а не в его конец.Это означает,что мы должны поставить Goto в конце цикла,чтобы прыгнуть обратно к тесту цикла в начале.Таким образом,этот цикл имеет форму цикла C while(){...},в то время как цикл в примере INSERT имел форму цикла do{...}while().Инструкция Delete заполняет роль,которую выполняла функция обратного вызова в предыдущих примерах.</target>
        </trans-unit>
        <trans-unit id="43be1340da3a9e761d1e60e5b0cf2fe23b219f5a" translate="yes" xml:space="preserve">
          <source>This macro determines if SQLite creates databases with the &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum&lt;/a&gt; flag set by default to OFF (0), FULL (1), or INCREMENTAL (2). The default value is 0 meaning that databases are created with auto-vacuum turned off. In any case the compile-time default may be overridden by the &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;PRAGMA auto_vacuum&lt;/a&gt; command.</source>
          <target state="translated">Этот макрос определяет, создает ли SQLite базы данных с флагом &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum,&lt;/a&gt; установленным по умолчанию на OFF (0), FULL (1) или INCREMENTAL (2). Значение по умолчанию - 0, что означает, что базы данных создаются с отключенным автоматическим вакуумом. В любом случае значение по умолчанию времени компиляции может быть отменено командой &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;PRAGMA auto_vacuum&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ce1cd413cb1e6bc64251da855027734d62907557" translate="yes" xml:space="preserve">
          <source>This macro determines the default value for the &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigtrustedschema&quot;&gt;SQLITE_DBCONFIG_TRUSTED_SCHEMA&lt;/a&gt; and &lt;a href=&quot;pragma#pragma_trusted_schema&quot;&gt;PRAGMA trusted_schema&lt;/a&gt; setting. If no alternative is specified, the trusted-schema setting defaults to ON (a value of 1) for legacy compatibility. However, for best security, systems that implement &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt; and/or &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt; should consider changing the default to OFF.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="490e529c008d3db9d5367e44a026855e51e6b03f" translate="yes" xml:space="preserve">
          <source>This macro determines the default value of the &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous&lt;/a&gt; setting for database files that open in &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt;. If not overridden at compile-time, this value is the same as &lt;a href=&quot;compile#default_synchronous&quot;&gt;SQLITE_DEFAULT_SYNCHRONOUS&lt;/a&gt;.</source>
          <target state="translated">Этот макрос определяет значение по умолчанию для &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;параметра синхронности PRAGMA&lt;/a&gt; для файлов базы данных, которые открываются в &lt;a href=&quot;wal&quot;&gt;режиме WAL&lt;/a&gt; . Если не переопределено во время компиляции, это значение совпадает с &lt;a href=&quot;compile#default_synchronous&quot;&gt;SQLITE_DEFAULT_SYNCHRONOUS&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8336b743e8d9803a85ebb0e91376530edf711cf6" translate="yes" xml:space="preserve">
          <source>This macro determines the default value of the &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous&lt;/a&gt; setting. If not overridden at compile-time, the default setting is 2 (FULL).</source>
          <target state="translated">Этот макрос определяет значение по умолчанию для &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;синхронной&lt;/a&gt; настройки PRAGMA . Если не переопределено во время компиляции, значение по умолчанию - 2 (ПОЛНЫЙ).</target>
        </trans-unit>
        <trans-unit id="f58f286fe549400b3ffb2a0508013420e777661c" translate="yes" xml:space="preserve">
          <source>This macro determines the default values for &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigdqsddl&quot;&gt;SQLITE_DBCONFIG_DQS_DDL&lt;/a&gt; and &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigdqsdml&quot;&gt;SQLITE_DBCONFIG_DQS_DML&lt;/a&gt;, which in turn how SQLite handles each &lt;a href=&quot;quirks#dblquote&quot;&gt;double-quoted string literal&lt;/a&gt;. The &quot;DQS&quot; name stands for &quot;&lt;u&gt;D&lt;/u&gt;ouble-&lt;u&gt;Q&lt;/u&gt;uoted &lt;u&gt;S&lt;/u&gt;tring&quot;. The</source>
          <target state="translated">Этот макрос определяет значения по умолчанию для &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigdqsddl&quot;&gt;SQLITE_DBCONFIG_DQS_DDL&lt;/a&gt; и &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigdqsdml&quot;&gt;SQLITE_DBCONFIG_DQS_DML&lt;/a&gt; , которые, в свою очередь, как SQLite обрабатывает каждый &lt;a href=&quot;quirks#dblquote&quot;&gt;строковый литерал в двойных кавычках&lt;/a&gt; . Название &quot;DQS&quot; означает &quot; &lt;u&gt;D&lt;/u&gt; ouble- &lt;u&gt;Q&lt;/u&gt; uoted &lt;u&gt;S&lt;/u&gt; Тринг&quot;. В</target>
        </trans-unit>
        <trans-unit id="522e09ca43264c4a7b51fc0648da718f31a48474" translate="yes" xml:space="preserve">
          <source>This macro determines the initial setting for &lt;a href=&quot;pragma#pragma_automatic_index&quot;&gt;PRAGMA automatic_index&lt;/a&gt; for newly opened &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt;. For all versions of SQLite through 3.7.17, automatic indices are normally enabled for new database connections if this compile-time option is omitted. However, that might change in future releases of SQLite.</source>
          <target state="translated">Этот макрос определяет начальную настройку &lt;a href=&quot;pragma#pragma_automatic_index&quot;&gt;PRAGMA automatic_index&lt;/a&gt; для вновь открытых &lt;a href=&quot;c3ref/sqlite3&quot;&gt;соединений с базой данных&lt;/a&gt; . Для всех версий SQLite до 3.7.17 автоматические индексы обычно включаются для новых подключений к базе данных, если этот параметр времени компиляции опущен. Однако это может измениться в будущих выпусках SQLite.</target>
        </trans-unit>
        <trans-unit id="5fa0389d41296c7a84b787e330c502e72d66ebe7" translate="yes" xml:space="preserve">
          <source>This macro determines the number of pages initially allocated by the page cache module when &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt; configuration option is not use and memory for the page cache is obtained from &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc()&lt;/a&gt; instead. The number of pages set by this macro are allocated in a single allocation, which reduces the load on the memory allocator.</source>
          <target state="translated">Этот макрос определяет количество страниц, изначально выделенных модулем кеширования страниц, когда &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigpagecache&quot;&gt;параметр&lt;/a&gt; конфигурации SQLITE_CONFIG_PAGECACHE не используется, а память для кэша страниц получается из &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc ()&lt;/a&gt; . Количество страниц, заданное этим макросом, распределяется за один раз, что снижает нагрузку на распределитель памяти.</target>
        </trans-unit>
        <trans-unit id="559bc66ac71c6e41021ef2b91f75b46c2b3b9325" translate="yes" xml:space="preserve">
          <source>This macro determines whether enforcement of &lt;a href=&quot;foreignkeys&quot;&gt;foreign key constraints&lt;/a&gt; is enabled or disabled by default for new database connections. Each database connection can always turn enforcement of foreign key constraints on and off and run-time using the &lt;a href=&quot;pragma#pragma_foreign_keys&quot;&gt;foreign_keys pragma&lt;/a&gt;. Enforcement of foreign key constraints is normally off by default, but if this compile-time parameter is set to 1, enforcement of foreign key constraints will be on by default.</source>
          <target state="translated">Этот макрос определяет, включено ли принудительное применение &lt;a href=&quot;foreignkeys&quot;&gt;ограничений внешнего ключа&lt;/a&gt; по умолчанию для новых подключений к базе данных. Каждое соединение с базой данных всегда может включать и выключать принудительное выполнение ограничений внешнего ключа и время выполнения с помощью &lt;a href=&quot;pragma#pragma_foreign_keys&quot;&gt;прагмы foreign_keys&lt;/a&gt; . Применение ограничений внешнего ключа обычно отключено по умолчанию, но если для этого параметра времени компиляции установлено значение 1, принудительное применение ограничений внешнего ключа будет включено по умолчанию.</target>
        </trans-unit>
        <trans-unit id="226608496184b7fdf2d8299d14ed30387d3f4541" translate="yes" xml:space="preserve">
          <source>This macro identifies an externally visible interface for SQLite. This macro is sometimes set to &quot;extern&quot;. But the definition is compiler-specific.</source>
          <target state="translated">Данный макрос идентифицирует внешне видимый интерфейс для SQLite.Иногда этот макрос имеет значение &quot;extern&quot;.Но определение специфично для компилятора.</target>
        </trans-unit>
        <trans-unit id="0de6453c343098370301ec003932dc6266aca99a" translate="yes" xml:space="preserve">
          <source>This macro identifies the calling convention used by operating system interfaces for target the platform for an SQLite build. This macro is normally defined to be nothing, though on Windows builds it can sometimes be set to &quot;__stdcall&quot;.</source>
          <target state="translated">Данный макрос определяет соглашение о вызовах,используемое интерфейсами операционной системы для целевой платформы для сборки SQLite.Обычно этот макрос определяется как ничтожный,хотя на сборках под Windows его иногда можно установить в значение &quot;__stdcall&quot;.</target>
        </trans-unit>
        <trans-unit id="9b44c726a2553acb75e5ed795a28d472290ceb29" translate="yes" xml:space="preserve">
          <source>This macro identifies the calling convention used by public interface routines in SQLite. This macro is normally defined to be nothing, though on Windows builds it can sometimes be set to &quot;__cdecl&quot; or &quot;__stdcall&quot;. The &quot;__cdecl&quot; setting is the default, but &quot;__stdcall&quot; is used when SQLite is intended to be compiled as a Windows system library.</source>
          <target state="translated">Данный макрос определяет соглашение о вызовах,используемое публичными интерфейсными подпрограммами SQLite.Обычно этот макрос определяется как ничтожный,хотя на сборках Windows он иногда может быть установлен в &quot;__cdecl&quot; или &quot;__stdcall&quot;.Установка &quot;__cdecl&quot; является значением по умолчанию,однако &quot;__stdcall&quot; используется,когда SQLite предназначен для компиляции в виде системной библиотеки Windows.</target>
        </trans-unit>
        <trans-unit id="b1a94429c7fe64a39ff03aac291075f1fc53f3f7" translate="yes" xml:space="preserve">
          <source>This macro is used to determine whether or not the features enabled and disabled using the SQLITE_CONFIG_MEMSTATUS argument to &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config()&lt;/a&gt; are available by default. The default value is 1 (&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmemstatus&quot;&gt;SQLITE_CONFIG_MEMSTATUS&lt;/a&gt; related features enabled).</source>
          <target state="translated">Этот макрос используется для определения того , доступны ли по умолчанию функции, включенные и отключенные с помощью аргумента SQLITE_CONFIG_MEMSTATUS для &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config ()&lt;/a&gt; . Значение по умолчанию - 1 ( &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmemstatus&quot;&gt;функции,&lt;/a&gt; связанные с SQLITE_CONFIG_MEMSTATUS, включены).</target>
        </trans-unit>
        <trans-unit id="6f913dad07b84381374f393818e5b17603014056" translate="yes" xml:space="preserve">
          <source>This macro is used to omit support for UTF16 text encoding. When this is defined all API functions that return or accept UTF16 encoded text are unavailable. These functions can be identified by the fact that they end with '16', for example &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare16()&lt;/a&gt;, &lt;a href=&quot;c3ref/column_blob&quot;&gt;sqlite3_column_text16()&lt;/a&gt; and &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_text16()&lt;/a&gt;.</source>
          <target state="translated">Этот макрос используется для исключения поддержки кодировки текста UTF16. Когда это определено, все функции API, которые возвращают или принимают текст в кодировке UTF16, недоступны. Эти функции можно определить по тому, что они заканчиваются на &amp;laquo;16&amp;raquo;, например &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare16 ()&lt;/a&gt; , &lt;a href=&quot;c3ref/column_blob&quot;&gt;sqlite3_column_text16 ()&lt;/a&gt; и &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_text16 ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="345c1823c22673f2e2116c52a9629c25f967676c" translate="yes" xml:space="preserve">
          <source>This macro is used to set the default page-size used when a database is created. The value assigned must be a power of 2. The default value is 4096. The compile-time default may be overridden at runtime by the &lt;a href=&quot;pragma#pragma_page_size&quot;&gt;PRAGMA page_size&lt;/a&gt; command.</source>
          <target state="translated">Этот макрос используется для установки размера страницы по умолчанию, используемого при создании базы данных. Присвоенное значение должно быть степенью 2. Значение по умолчанию - 4096. Значение по умолчанию времени компиляции может быть отменено во время выполнения командой &lt;a href=&quot;pragma#pragma_page_size&quot;&gt;PRAGMA page_size&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7c4d127d6e65cd3ab45a035f901ed93fb97bfdbf" translate="yes" xml:space="preserve">
          <source>This macro may not be used in combination with any of &lt;a href=&quot;compile#apicall&quot;&gt;SQLITE_APICALL&lt;/a&gt;, &lt;a href=&quot;compile#callback&quot;&gt;SQLITE_CALLBACK&lt;/a&gt;, &lt;a href=&quot;compile#cdecl&quot;&gt;SQLITE_CDECL&lt;/a&gt;, or &lt;a href=&quot;compile#syscall&quot;&gt;SQLITE_SYSCALL&lt;/a&gt;.</source>
          <target state="translated">Этот макрос нельзя использовать в сочетании с любым из &lt;a href=&quot;compile#apicall&quot;&gt;SQLITE_APICALL&lt;/a&gt; , &lt;a href=&quot;compile#callback&quot;&gt;SQLITE_CALLBACK&lt;/a&gt; , &lt;a href=&quot;compile#cdecl&quot;&gt;SQLITE_CDECL&lt;/a&gt; или &lt;a href=&quot;compile#syscall&quot;&gt;SQLITE_SYSCALL&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="419ea570d98b36b74bab8426d78c04933a0304df" translate="yes" xml:space="preserve">
          <source>This macro sets a hard upper bound on the amount of address space that can be used by any single database for memory-mapped I/O. Setting this value to 0 completely disables memory-mapped I/O and causes logic associated with memory-mapped I/O to be omitted from the build. This option does change the default memory-mapped I/O address space size (set by &lt;a href=&quot;compile#default_mmap_size&quot;&gt;SQLITE_DEFAULT_MMAP_SIZE&lt;/a&gt; or sqlite3_config(&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmmapsize&quot;&gt;SQLITE_CONFIG_MMAP_SIZE&lt;/a&gt;) or the run-time memory-mapped I/O address space size (set by sqlite3_file_control(&lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlmmapsize&quot;&gt;SQLITE_FCNTL_MMAP_SIZE&lt;/a&gt;) or &lt;a href=&quot;pragma#pragma_mmap_size&quot;&gt;PRAGMA mmap_size&lt;/a&gt;) as long as those other settings are less than the maximum value defined here.</source>
          <target state="translated">Этот макрос устанавливает жесткую верхнюю границу объема адресного пространства, которое может использоваться любой отдельной базой данных для ввода-вывода с отображением в память. Установка этого значения на 0 полностью отключает ввод-вывод с отображением в память и приводит к тому, что логика, связанная с вводом-выводом с отображением памяти, не включается в сборку. Этот вариант делает изменить по умолчанию отображаемой памяти ввода / вывода размер адресного пространства (устанавливается &lt;a href=&quot;compile#default_mmap_size&quot;&gt;SQLITE_DEFAULT_MMAP_SIZE&lt;/a&gt; или sqlite3_config ( &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmmapsize&quot;&gt;SQLITE_CONFIG_MMAP_SIZE&lt;/a&gt; ) или в оперативной памяти , отображенные I / O размер адресного пространства (устанавливается sqlite3_file_control ( &lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlmmapsize&quot;&gt;SQLITE_FCNTL_MMAP_SIZE&lt;/a&gt; ) или &lt;a href=&quot;pragma#pragma_mmap_size&quot;&gt;ПРАГМА mmap_size&lt;/a&gt; ) как при условии, что эти другие настройки меньше максимального значения, определенного здесь.</target>
        </trans-unit>
        <trans-unit id="145e78ac1776ccd32943f854f10f2f9b0fb6393c" translate="yes" xml:space="preserve">
          <source>This macro sets the default limit on the amount of memory that will be used for memory-mapped I/O for each open database file. If the</source>
          <target state="translated">Данный макрос устанавливает ограничение по умолчанию на объем памяти,который будет использоваться для отображения в памяти ввода/вывода для каждого открытого файла базы данных.Если</target>
        </trans-unit>
        <trans-unit id="6ae2df8a2127ec82caea89871c84ffb977c2588f" translate="yes" xml:space="preserve">
          <source>This macro sets the default maximum size of the page-cache for each attached database. A positive value means that the limit is N page. If N is negative that means to limit the cache size to -N*1024 bytes. The suggested maximum cache size can be overridden by the &lt;a href=&quot;pragma#pragma_cache_size&quot;&gt;PRAGMA cache_size&lt;/a&gt; command. The default value is -2000, which translates into a maximum of 2048000 bytes per cache.</source>
          <target state="translated">Этот макрос устанавливает максимальный размер кэша страниц по умолчанию для каждой присоединенной базы данных. Положительное значение означает, что ограничение составляет N страниц. Если N отрицательно, это означает ограничение размера кеша до -N * 1024 байта. Предлагаемый максимальный размер кеша может быть &lt;a href=&quot;pragma#pragma_cache_size&quot;&gt;изменен&lt;/a&gt; командой PRAGMA cache_size . Значение по умолчанию -2000, что соответствует максимуму 2048000 байт на кэш.</target>
        </trans-unit>
        <trans-unit id="069102b338eefceeca656d056762e6d78be6422a" translate="yes" xml:space="preserve">
          <source>This macro sets the default page count for the &lt;a href=&quot;wal&quot;&gt;WAL&lt;/a&gt;&lt;a href=&quot;wal#ckpt&quot;&gt;automatic checkpointing&lt;/a&gt; feature. If unspecified, the default page count is 1000.</source>
          <target state="translated">Этот макрос устанавливает количество страниц по умолчанию для функции &lt;a href=&quot;wal#ckpt&quot;&gt;автоматической контрольной точки &lt;/a&gt;&lt;a href=&quot;wal&quot;&gt;WAL&lt;/a&gt; . Если не указано иное, по умолчанию используется 1000 страниц.</target>
        </trans-unit>
        <trans-unit id="40e8768dd2f7f8b92849cd1662a4c1ca65d4e334" translate="yes" xml:space="preserve">
          <source>This macro sets the default value for the &lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitworkerthreads&quot;&gt;SQLITE_LIMIT_WORKER_THREADS&lt;/a&gt; parameter. The &lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitworkerthreads&quot;&gt;SQLITE_LIMIT_WORKER_THREADS&lt;/a&gt; parameter sets the maximum number of auxiliary threads that a single &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; will launch to assist it with a query. If not specified, the default maximum is 0. The value set here cannot be more than &lt;a href=&quot;compile#max_worker_threads&quot;&gt;SQLITE_MAX_WORKER_THREADS&lt;/a&gt;.</source>
          <target state="translated">Этот макрос устанавливает значение по умолчанию для параметра &lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitworkerthreads&quot;&gt;SQLITE_LIMIT_WORKER_THREADS&lt;/a&gt; . Параметр &lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitworkerthreads&quot;&gt;SQLITE_LIMIT_WORKER_THREADS&lt;/a&gt; устанавливает максимальное количество вспомогательных потоков, которые будет запускать один &lt;a href=&quot;c3ref/stmt&quot;&gt;подготовленный оператор&lt;/a&gt; , чтобы помочь ему с запросом. Если не указано, максимальное значение по умолчанию равно 0. Установленное здесь значение не может быть больше, чем &lt;a href=&quot;compile#max_worker_threads&quot;&gt;SQLITE_MAX_WORKER_THREADS&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7f1a3a8e3c666c19a28c715230f239e6dc92f408" translate="yes" xml:space="preserve">
          <source>This macro sets the maximum depth of the LALR(1) stack used by the SQL parser within SQLite. The default value is 100. A typical application will use less than about 20 levels of the stack. Developers whose applications contain SQL statements that need more than 100 LALR(1) stack entries should seriously consider refactoring their SQL as it is likely to be well beyond the ability of any human to comprehend.</source>
          <target state="translated">Данный макрос устанавливает максимальную глубину стека LALR(1),используемого парсером SQL внутри SQLite.Значение по умолчанию равно 100.Типичное приложение будет использовать менее 20 уровней стека.Разработчикам,чьи приложения содержат SQL-операторы,которым требуется более 100 элементов стека LALR(1),следует серьезно подумать о рефакторинге своего SQL,так как он,скорее всего,будет далеко за пределами возможностей понимания человеком.</target>
        </trans-unit>
        <trans-unit id="8108e74c0ea6d892451dd561e6365c3c14ad84ce" translate="yes" xml:space="preserve">
          <source>This macro sets the maximum depth of the search tree that corresponds to the right-hand side of the MATCH operator in an &lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt; or &lt;a href=&quot;fts3#fts4&quot;&gt;FTS4&lt;/a&gt; full-text index. The full-text search uses a recursive algorithm, so the depth of the tree is limited to prevent using too much stack space. The default limit is 12. This limit is sufficient for up to 4095 search terms on the right-hand side of the MATCH operator and it holds stack space usage to less than 2000 bytes.</source>
          <target state="translated">Этот макрос устанавливает максимальную глубину дерева поиска, которая соответствует правой части оператора MATCH в &lt;a href=&quot;fts3&quot;&gt;полнотекстовом &lt;/a&gt;&lt;a href=&quot;fts3#fts4&quot;&gt;индексе &lt;/a&gt;FTS3 или FTS4 . Полнотекстовый поиск использует рекурсивный алгоритм, поэтому глубина дерева ограничена, чтобы не использовать слишком много места в стеке. Предел по умолчанию - 12. Этого ограничения достаточно для 4095 условий поиска в правой части оператора MATCH, и он ограничивает использование пространства стека менее 2000 байтов.</target>
        </trans-unit>
        <trans-unit id="3f15f1a968a26e30aa2768ccc2b2f950c4faa629" translate="yes" xml:space="preserve">
          <source>This macro specifies the calling convention used by callback pointers in SQLite. This macro is normally defined to be nothing, though on Windows builds it can sometimes be set to &quot;__cdecl&quot; or &quot;__stdcall&quot;. The &quot;__cdecl&quot; setting is the default, but &quot;__stdcall&quot; is used when SQLite is intended to be compiled as a Windows system library.</source>
          <target state="translated">Данный макрос задает соглашение о вызовах,используемое указателями обратного вызова в SQLite.Обычно этот макрос определяется как ничтожный,хотя на сборках Windows его иногда можно установить в &quot;__cdecl&quot; или &quot;__stdcall&quot;.Настройка &quot;__cdecl&quot; является настройкой по умолчанию,однако &quot;__stdcall&quot; используется,когда SQLite предназначен для компиляции в виде системной библиотеки Windows.</target>
        </trans-unit>
        <trans-unit id="2528260ddde8472dd8957f56284dfe7c74c79aa8" translate="yes" xml:space="preserve">
          <source>This macro specifies the calling convention used by the &lt;a href=&quot;http://www.tcl.tk&quot;&gt;TCL&lt;/a&gt; library interface routines. This macro is not used by the SQLite core, but only by the &lt;a href=&quot;tclsqlite&quot;&gt;TCL Interface&lt;/a&gt; and &lt;a href=&quot;testing#tcl&quot;&gt;TCL test suite&lt;/a&gt;. This macro is normally defined to be nothing, though on Windows builds it can sometimes be set to &quot;__cdecl&quot;. This macro is used on TCL library interface routines which are always compiled as __cdecl, even on platforms that prefer to use __stdcall, so this macro should not be set to __stdcall unless the platform as a custom TCL library build that supports __stdcall.</source>
          <target state="translated">Этот макрос определяет соглашение о вызовах, используемое подпрограммами интерфейса библиотеки &lt;a href=&quot;http://www.tcl.tk&quot;&gt;TCL&lt;/a&gt; . Этот макрос не используется ядром SQLite, а только &lt;a href=&quot;tclsqlite&quot;&gt;интерфейсом &lt;/a&gt;&lt;a href=&quot;testing#tcl&quot;&gt;TCL&lt;/a&gt; и набором тестов TCL . Этот макрос обычно определяется как &amp;laquo;ничто&amp;raquo;, хотя в сборках Windows иногда может быть установлено значение &amp;laquo;__cdecl&amp;raquo;. Этот макрос используется в подпрограммах интерфейса библиотеки TCL, которые всегда компилируются как __cdecl, даже на платформах, которые предпочитают использовать __stdcall, поэтому для этого макроса не следует устанавливать значение __stdcall, если только платформа не является сборкой пользовательской библиотеки TCL, которая поддерживает __stdcall.</target>
        </trans-unit>
        <trans-unit id="b996681cfbcd7a7b511f6d650cb0de00b4677597" translate="yes" xml:space="preserve">
          <source>This macro specifies the calling convention used by the &lt;a href=&quot;https://www.tcl.tk&quot;&gt;TCL&lt;/a&gt; library interface routines. This macro is not used by the SQLite core, but only by the &lt;a href=&quot;tclsqlite&quot;&gt;TCL Interface&lt;/a&gt; and &lt;a href=&quot;testing#tcl&quot;&gt;TCL test suite&lt;/a&gt;. This macro is normally defined to be nothing, though on Windows builds it can sometimes be set to &quot;__cdecl&quot;. This macro is used on TCL library interface routines which are always compiled as __cdecl, even on platforms that prefer to use __stdcall, so this macro should not be set to __stdcall unless the platform as a custom TCL library build that supports __stdcall.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc472ae5f8b8a1fc9f763f0953cf89d622ce1417" translate="yes" xml:space="preserve">
          <source>This macro specifies the calling convention used by varargs interface routines in SQLite. This macro is normally defined to be nothing, though on Windows builds it can sometimes be set to &quot;__cdecl&quot;. This macro is used on varargs routines and so cannot be set to &quot;__stdcall&quot; since the __stdcall calling convention does not support varargs functions.</source>
          <target state="translated">Данный макрос определяет соглашение о вызовах,используемое интерфейсными подпрограммами varargs в SQLite.Обычно этот макрос определяется как ничтожный,хотя на сборках Windows его иногда можно установить в &quot;__cdecl&quot;.Этот макрос используется в подпрограммах varargs и поэтому не может быть установлен в &quot;__stdcall&quot;,так как соглашение о вызове __stdcall не поддерживает функции varargs.</target>
        </trans-unit>
        <trans-unit id="bc36de796d91df2f3c6874f4468e8054d8e3ac3e" translate="yes" xml:space="preserve">
          <source>This major version number X was historically incremented only for large and important changes to the code. What constituted &quot;large and important&quot; was subjective. The 3.6.23 to 3.7.0 change was a result of adding support for &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt;. The 3.7.17 to 3.8.0 change was a result of rewrite known as the &lt;a href=&quot;queryplanner-ng&quot;&gt;next generation query planner&lt;/a&gt;.</source>
          <target state="translated">Этот основной номер версии X исторически увеличивался только для крупных и важных изменений кода. Что считается &amp;laquo;большим и важным&amp;raquo;, было субъективным. Изменение с 3.6.23 на 3.7.0 стало результатом добавления поддержки &lt;a href=&quot;wal&quot;&gt;режима WAL&lt;/a&gt; . Изменение с 3.7.17 на 3.8.0 стало результатом переписывания, известного как &lt;a href=&quot;queryplanner-ng&quot;&gt;планировщик запросов следующего поколения&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5cef14b3410c92f823704c7230a809d3f5116354" translate="yes" xml:space="preserve">
          <source>This may conflict with a remote UPDATE or DELETE. If it conflicts with a DELETE, and the conflict resolution was OMIT, then the update is changed into an INSERT. Any undefined values in the new.* record from the update change are filled in using the old.* values from the conflicting DELETE. Or, if the conflict resolution was REPLACE, the UPDATE change is simply omitted from the rebased changeset.</source>
          <target state="translated">Это может конфликтовать с удаленным UPDATE или DELETE.Если она конфликтует с DELETE,а разрешение конфликта было OMIT,то обновление меняется на INSERT.Любые неопределенные значения в новой.*записи из изменения обновления заполняются с помощью старых.*значений из конфликтующей DELETE.Или,если конфликтное разрешение было REPLACE,изменение UPDATE просто пропускается из обновленного changeset.</target>
        </trans-unit>
        <trans-unit id="250cc754fd71fa455b1171906aaea6df74adc895" translate="yes" xml:space="preserve">
          <source>This may conflict with a remote UPDATE or DELETE. In both cases the only possible resolution is OMIT. If the remote operation was a DELETE, then add no change to the rebased changeset. If the remote operation was an UPDATE, then the old.* fields of change are updated to reflect the new.* values in the UPDATE.</source>
          <target state="translated">Это может конфликтовать с удаленным UPDATE или DELETE.В обоих случаях единственным возможным решением является OMIT.Если удаленная работа была DELETE,то не добавляйте никаких изменений в rebased changeset.Если удаленная операция была UPDATE,то старые.*поля изменений обновляются,чтобы отразить новые.*значения в UPDATE.</target>
        </trans-unit>
        <trans-unit id="8d5037a58507a3656fe5eded6e14400ea7347e50" translate="yes" xml:space="preserve">
          <source>This may only conflict with a remote INSERT. If the conflict resolution was OMIT, then add an UPDATE change to the rebased changeset. Or, if the conflict resolution was REPLACE, add nothing to the rebased changeset.</source>
          <target state="translated">Это может противоречить только удаленному ИНСЕРТУ.Если конфликт разрешен с помощью OMIT,то добавьте изменение UPDATE в rebased changeset.Или,если разрешение конфликта было REPLACE,ничего не добавлять в rebased changeset.</target>
        </trans-unit>
        <trans-unit id="e86988ffb57c2ce2d0a24b3ed45d3fc0cd35e72c" translate="yes" xml:space="preserve">
          <source>This means that SQLite transactions are not atomic across multiple database files on a power-loss when the database files have synchronous turned off or when they are using journal modes of OFF, MEMORY, or WAL. For synchronous OFF and for journal_modes OFF and MEMORY, database will usually corrupt if a transaction commit is interrupted by a power loss. For &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt;, individual database files are updated atomically across a power-loss, but in the case of a multi-file transactions, some files might rollback while others roll forward after power is restored.</source>
          <target state="translated">Это означает, что транзакции SQLite не являются атомарными по нескольким файлам базы данных при отключении питания, когда файлы базы данных отключены синхронно или когда они используют режимы журнала OFF, MEMORY или WAL. Для синхронного ВЫКЛЮЧЕНИЯ, а также для журнала_modes OFF и MEMORY база данных обычно будет повреждена, если фиксация транзакции прерывается из-за потери питания. В &lt;a href=&quot;wal&quot;&gt;режиме WAL&lt;/a&gt; отдельные файлы базы данных обновляются атомарно при отключении питания, но в случае многофайловых транзакций некоторые файлы могут откатиться, а другие - после восстановления питания.</target>
        </trans-unit>
        <trans-unit id="c4d263eb72d44481bc6aecfbc23e6defa0aa1498" translate="yes" xml:space="preserve">
          <source>This means that actions that occur during sqlite3_prepare() are unaffected by EXPLAIN.</source>
          <target state="translated">Это означает,что действия,которые происходят во время работы функции sqlite3_prepare(),не затрагиваются функцией EXPLAIN.</target>
        </trans-unit>
        <trans-unit id="607b25be39beb5f9bef58cd8962c20567dd55554" translate="yes" xml:space="preserve">
          <source>This means that for many common cases where the temporary tables and indices are small (small enough to fit into the page cache) no temporary files are created and no disk I/O occurs. Only when the temporary data becomes too large to fit in RAM does the information spill to disk.</source>
          <target state="translated">Это означает,что во многих распространенных случаях,когда временные таблицы и индексы малы (достаточно малы,чтобы поместиться в кэш страниц),не создаются временные файлы и не происходит дисковый ввод/вывод.Только когда временные данные становятся слишком большими,чтобы поместиться в оперативную память,происходит утечка информации на диск.</target>
        </trans-unit>
        <trans-unit id="593fad237e8d234622c2a00c4634885f5c48bfa8" translate="yes" xml:space="preserve">
          <source>This means that if the changes() SQL function (or similar) is used by the first INSERT, UPDATE or DELETE statement within a trigger, it returns the value as set when the calling statement began executing. If it is used by the second or subsequent such statement within a trigger program, the value returned reflects the number of rows modified by the previous INSERT, UPDATE or DELETE statement within the same trigger.</source>
          <target state="translated">Это означает,что если SQL-функция changes()(или аналогичная)используется первым оператором INSERT,UPDATE или DELETE в триггере,то она возвращает значение,установленное при начале выполнения вызывающего оператора.Если второй или последующий такой оператор используется в триггерной программе,возвращаемое значение отражает количество строк,измененных предыдущим оператором INSERT,UPDATE или DELETE в том же триггере.</target>
        </trans-unit>
        <trans-unit id="47de8d4e850286135f1da838b319021d7542c6e4" translate="yes" xml:space="preserve">
          <source>This means that in order to keep an FTS in sync with an external content table, any UPDATE or DELETE operations must be applied first to the FTS table, and then to the external content table. For example:</source>
          <target state="translated">Это означает,что для синхронизации FTS с внешней таблицей содержимого,любые операции UPDATE или DELETE должны применяться сначала к таблице FTS,а затем к внешней таблице содержимого.Например:</target>
        </trans-unit>
        <trans-unit id="e5987b4f32ba7f13fcab7f6d474b93f549e8b5dd" translate="yes" xml:space="preserve">
          <source>This means that you should always call sqlite3_column_bytes() or sqlite3_column_bytes16() &lt;u&gt;before&lt;/u&gt; calling sqlite3_column_blob(), sqlite3_column_text(), or sqlite3_column_text16().</source>
          <target state="translated">Это означает, что вы всегда должны вызывать sqlite3_column_bytes () или sqlite3_column_bytes16 () &lt;u&gt;перед&lt;/u&gt; вызовом sqlite3_column_blob (), sqlite3_column_text () или sqlite3_column_text16 ().</target>
        </trans-unit>
        <trans-unit id="a800932549bc1585500113c923ee38830d5bf518" translate="yes" xml:space="preserve">
          <source>This means, amongst other things, that if a row is inserted and then later deleted while a session object is active, neither the insert nor the delete will be present in the changeset. Or if a row is deleted and then later a row with the same primary key values inserted while a session object is active, the resulting changeset will contain an UPDATE change instead of a DELETE and an INSERT.</source>
          <target state="translated">Это означает,среди прочего,что если строка вставлена,а затем удалена,пока активен объект сессии,ни вставка,ни удаление не будут присутствовать в changeset.Или,если строка удаляется,а затем вставляется строка с теми же значениями первичного ключа,когда активен объект сессии,результирующий changeset будет содержать изменение UPDATE,а не DELETE и INSERT.</target>
        </trans-unit>
        <trans-unit id="a00a0b75d114c0d51218afdcfc54870beb085cdd" translate="yes" xml:space="preserve">
          <source>This method begins a search of a virtual table. The first argument is a cursor opened by &lt;a href=&quot;vtab#xopen&quot;&gt;xOpen&lt;/a&gt;. The next two arguments define a particular search index previously chosen by &lt;a href=&quot;vtab#xbestindex&quot;&gt;xBestIndex&lt;/a&gt;. The specific meanings of idxNum and idxStr are unimportant as long as xFilter and xBestIndex agree on what that meaning is.</source>
          <target state="translated">Этот метод начинает поиск виртуальной таблицы. Первый аргумент - это курсор, открытый &lt;a href=&quot;vtab#xopen&quot;&gt;xOpen&lt;/a&gt; . Следующие два аргумента определяют конкретный поисковый индекс, ранее выбранный &lt;a href=&quot;vtab#xbestindex&quot;&gt;xBestIndex&lt;/a&gt; . Конкретные значения idxNum и idxStr не важны, пока xFilter и xBestIndex соглашаются в том, что это за значение.</target>
        </trans-unit>
        <trans-unit id="834bb1ed541ae4dfe20c9142ebec2a570acf7ecb" translate="yes" xml:space="preserve">
          <source>This method begins a transaction on a virtual table. This is method is optional. The xBegin pointer of &lt;a href=&quot;c3ref/module&quot;&gt;sqlite3_module&lt;/a&gt; may be NULL.</source>
          <target state="translated">Этот метод начинает транзакцию на виртуальной таблице. Этот метод не является обязательным. Указатель xBegin &lt;a href=&quot;c3ref/module&quot;&gt;sqlite3_module&lt;/a&gt; может иметь значение NULL.</target>
        </trans-unit>
        <trans-unit id="a08aaa3a7033e43137865bcb5ae5a8fbc061274b" translate="yes" xml:space="preserve">
          <source>This method causes a virtual table transaction to commit. This is method is optional. The xCommit pointer of &lt;a href=&quot;c3ref/module&quot;&gt;sqlite3_module&lt;/a&gt; may be NULL.</source>
          <target state="translated">Этот метод вызывает фиксацию транзакции виртуальной таблицы. Этот метод не является обязательным. Указатель xCommit &lt;a href=&quot;c3ref/module&quot;&gt;sqlite3_module&lt;/a&gt; может иметь значение NULL.</target>
        </trans-unit>
        <trans-unit id="35812c6906eecb5f5456d27817929132fa134b1e" translate="yes" xml:space="preserve">
          <source>This method causes a virtual table transaction to rollback. This is method is optional. The xRollback pointer of &lt;a href=&quot;c3ref/module&quot;&gt;sqlite3_module&lt;/a&gt; may be NULL.</source>
          <target state="translated">Этот метод вызывает откат транзакции виртуальной таблицы. Этот метод не является обязательным. Указатель xRollback &lt;a href=&quot;c3ref/module&quot;&gt;sqlite3_module&lt;/a&gt; может иметь значение NULL.</target>
        </trans-unit>
        <trans-unit id="34e410d7a2b4537f1e469f9ac830727f0e9a19a0" translate="yes" xml:space="preserve">
          <source>This method is a destructor for a connection to the virtual table. Contrast this method with &lt;a href=&quot;vtab#sqlite3_module.xDestroy&quot;&gt;xDestroy&lt;/a&gt;. The xDestroy is a destructor for the entire virtual table.</source>
          <target state="translated">Этот метод является деструктором для подключения к виртуальной таблице. Сравните этот метод с &lt;a href=&quot;vtab#sqlite3_module.xDestroy&quot;&gt;xDestroy&lt;/a&gt; . XDestroy - это деструктор для всей виртуальной таблицы.</target>
        </trans-unit>
        <trans-unit id="fead0fa710dfed08f0c2973066d106e0409882fe" translate="yes" xml:space="preserve">
          <source>This method is always followed by one call to either the &lt;a href=&quot;vtab#xcommit&quot;&gt;xCommit&lt;/a&gt; or &lt;a href=&quot;vtab#xrollback&quot;&gt;xRollback&lt;/a&gt; method. Virtual table transactions do not nest, so the xBegin method will not be invoked more than once on a single virtual table without an intervening call to either &lt;a href=&quot;vtab#xcommit&quot;&gt;xCommit&lt;/a&gt; or &lt;a href=&quot;vtab#xrollback&quot;&gt;xRollback&lt;/a&gt;. Multiple calls to other methods can and likely will occur in between the xBegin and the corresponding &lt;a href=&quot;vtab#xcommit&quot;&gt;xCommit&lt;/a&gt; or &lt;a href=&quot;vtab#xrollback&quot;&gt;xRollback&lt;/a&gt;.</source>
          <target state="translated">За этим методом всегда следует один вызов метода &lt;a href=&quot;vtab#xcommit&quot;&gt;xCommit&lt;/a&gt; или &lt;a href=&quot;vtab#xrollback&quot;&gt;xRollback&lt;/a&gt; . Транзакции виртуальных таблиц не являются вложенными, поэтому метод xBegin не будет вызываться более одного раза для одной виртуальной таблицы без промежуточного вызова либо &lt;a href=&quot;vtab#xcommit&quot;&gt;xCommit,&lt;/a&gt; либо &lt;a href=&quot;vtab#xrollback&quot;&gt;xRollback&lt;/a&gt; . Множественные вызовы других методов могут и, вероятно, произойдут между xBegin и соответствующим &lt;a href=&quot;vtab#xcommit&quot;&gt;xCommit&lt;/a&gt; или &lt;a href=&quot;vtab#xrollback&quot;&gt;xRollback&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="83c5d6a9d04d0fa8516ae7c5f17b40f6d4c8afec" translate="yes" xml:space="preserve">
          <source>This method is called during &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; to give the virtual table implementation an opportunity to overload functions. This method may be set to NULL in which case no overloading occurs.</source>
          <target state="translated">Этот метод вызывается во время &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare (),&lt;/a&gt; чтобы дать реализации виртуальной таблицы возможность перегружать функции. Этот метод может иметь значение NULL, и в этом случае перегрузки не происходит.</target>
        </trans-unit>
        <trans-unit id="905580614d4d5c3d75c09c6cba74a2febc0c6255" translate="yes" xml:space="preserve">
          <source>This method is only invoked after call to the &lt;a href=&quot;vtab#xBegin&quot;&gt;xBegin&lt;/a&gt; method and prior to an &lt;a href=&quot;vtab#xcommit&quot;&gt;xCommit&lt;/a&gt; or &lt;a href=&quot;vtab#xrollback&quot;&gt;xRollback&lt;/a&gt;. In order to implement two-phase commit, the xSync method on all virtual tables is invoked prior to invoking the &lt;a href=&quot;vtab#xcommit&quot;&gt;xCommit&lt;/a&gt; method on any virtual table. If any of the xSync methods fail, the entire transaction is rolled back.</source>
          <target state="translated">Этот метод вызывается только после вызова метода &lt;a href=&quot;vtab#xBegin&quot;&gt;xBegin&lt;/a&gt; и до &lt;a href=&quot;vtab#xcommit&quot;&gt;xCommit&lt;/a&gt; или &lt;a href=&quot;vtab#xrollback&quot;&gt;xRollback&lt;/a&gt; . Чтобы реализовать двухэтапную фиксацию, метод xSync для всех виртуальных таблиц вызывается перед &lt;a href=&quot;vtab#xcommit&quot;&gt;вызовом&lt;/a&gt; метода xCommit для любой виртуальной таблицы. Если какой-либо из методов xSync не работает, откатывается вся транзакция.</target>
        </trans-unit>
        <trans-unit id="14ef93018d8fba942c0db9f44fa55460f6e9c76d" translate="yes" xml:space="preserve">
          <source>This method is only required window aggregate functions, not legacy aggregate function implementations. It is invoked to remove a row from the current window. The function arguments, if any, correspond to the row being removed.</source>
          <target state="translated">Этот метод является только обязательным для выполнения функций агрегирования окон,а не для реализации старых агрегированных функций.Он вызывается для удаления строки из текущего окна.Аргументы функции,если таковые имеются,соответствуют удаляемой строке.</target>
        </trans-unit>
        <trans-unit id="ce08d539ea8ee34ede5a43f0a8a17d5ea1cf7eda" translate="yes" xml:space="preserve">
          <source>This method is only required window aggregate functions, not legacy aggregate function implementations. It is invoked to return the current value of the aggregate. Unlike xFinal, the implementation should not delete any context.</source>
          <target state="translated">Этот метод является только обязательным для выполнения функций агрегирования окон,а не для реализации старых агрегированных функций.Он вызывается для возврата текущего значения агрегата.В отличие от xFinal,реализация не должна удалять контекст.</target>
        </trans-unit>
        <trans-unit id="08d8cbadac9e2ea26500ba730130d1d2ea25cffc" translate="yes" xml:space="preserve">
          <source>This method is required by both window aggregate and legacy aggregate function implementations. It is invoked to add a row to the current window. The function arguments, if any, corresponding to the row being added are passed to the implementation of xStep.</source>
          <target state="translated">Этот метод необходим как для реализации оконных агрегатов,так и для реализации старых агрегатных функций.Он вызывается для добавления строки в текущее окно.Аргументы функции,если таковые имеются,соответствующие добавляемой строке,передаются в реализацию xStep.</target>
        </trans-unit>
        <trans-unit id="9dd3404779d40aa0e18784dd6025c6e495214062" translate="yes" xml:space="preserve">
          <source>This method is required by both window aggregate and legacy aggregate function implementations. It is invoked to return the current value of the aggregate (determined by the contents of the current window), and to free any resources allocated by earlier calls to xStep.</source>
          <target state="translated">Этот метод необходим как для реализации оконных агрегатов,так и для реализации старых агрегатных функций.Он вызывается для возврата текущего значения агрегата (определяемого содержимым текущего окна),а также для освобождения ресурсов,выделенных при предыдущих вызовах xStep.</target>
        </trans-unit>
        <trans-unit id="7eac31ed05b29ccf070b56974e9ebd5c94362b9d" translate="yes" xml:space="preserve">
          <source>This method is used to profile the execution of SQL statements run by the application. The syntax is as follows:</source>
          <target state="translated">Этот метод используется для профилирования выполнения SQL-запросов,выполняемых приложением.Синтаксис таков:</target>
        </trans-unit>
        <trans-unit id="9ee8409951c2f3bc2e8906346a5b0b0340e5f814" translate="yes" xml:space="preserve">
          <source>This method maps to the &lt;a href=&quot;c3ref/enable_load_extension&quot;&gt;sqlite3_enable_load_extension()&lt;/a&gt; C/C++ interface.</source>
          <target state="translated">Этот метод соответствует интерфейсу &lt;a href=&quot;c3ref/enable_load_extension&quot;&gt;sqlite3_enable_load_extension ()&lt;/a&gt; C / C ++.</target>
        </trans-unit>
        <trans-unit id="225a540a3967cae27a759b7346927a4c3dd4b89d" translate="yes" xml:space="preserve">
          <source>This method might decide to run a &lt;a href=&quot;wal#ckpt&quot;&gt;checkpoint&lt;/a&gt; either itself or as a subsequent idle callback. Note that SQLite only allows a single WAL hook. By default this single WAL hook is used for the auto-checkpointing. If you set up an explicit WAL hook, then that one WAL hook must ensure that checkpoints are occurring since the auto-checkpointing mechanism will be disabled.</source>
          <target state="translated">Этот метод может решить запустить &lt;a href=&quot;wal#ckpt&quot;&gt;контрольную точку&lt;/a&gt; либо сам, либо как последующий обратный вызов бездействия. Обратите внимание, что SQLite допускает только одну ловушку WAL. По умолчанию этот единственный перехватчик WAL используется для автоматической проверки. Если вы настроили явный перехватчик WAL, то этот перехватчик WAL должен гарантировать наличие контрольных точек, поскольку механизм автоматической проверки будет отключен.</target>
        </trans-unit>
        <trans-unit id="eb481b19911bf534590dc3a5ac3a0d7a4a0b626e" translate="yes" xml:space="preserve">
          <source>This method must release all resources allocated by the corresponding xOpen call. The routine will not be called again even if it returns an error. The SQLite core will not use the &lt;a href=&quot;c3ref/vtab_cursor&quot;&gt;sqlite3_vtab_cursor&lt;/a&gt; again after it has been closed.</source>
          <target state="translated">Этот метод должен освободить все ресурсы, выделенные соответствующим вызовом xOpen. Подпрограмма не будет вызываться снова, даже если она вернет ошибку. Ядро SQLite больше не будет использовать &lt;a href=&quot;c3ref/vtab_cursor&quot;&gt;sqlite3_vtab_cursor&lt;/a&gt; после его закрытия.</target>
        </trans-unit>
        <trans-unit id="055d0207ea9526f8fc1f47ff97e4b9e575a536d0" translate="yes" xml:space="preserve">
          <source>This method must return &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; if successful, or an sqlite &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; if an error occurs.</source>
          <target state="translated">Этот метод должен возвращать &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK в&lt;/a&gt; случае успеха или &lt;a href=&quot;rescode&quot;&gt;код ошибки&lt;/a&gt; sqlite в случае возникновения ошибки.</target>
        </trans-unit>
        <trans-unit id="b41b86554f48d4aba1d771ee8d8fecba032486ca" translate="yes" xml:space="preserve">
          <source>This method only functions if SQLite is compiled with -DSQLITE_ENABLE_DESERIALIZE</source>
          <target state="translated">Этот метод работает только в том случае,если SQLite скомпилирован с -DSQLITE_ENABLE_DESERIALIZE.</target>
        </trans-unit>
        <trans-unit id="aca26a9b3273f84c2f90b69b02bbfb9f22a90825" translate="yes" xml:space="preserve">
          <source>This method opens a TCL channel that can be used to read or write into a preexisting BLOB in the database. The syntax is like this:</source>
          <target state="translated">Этот метод открывает канал TCL,который можно использовать для чтения или записи в уже существующий BLOB в базе данных.Синтаксис такой:</target>
        </trans-unit>
        <trans-unit id="a7939d2d993e49eddf1cab2881c4166045801fa6" translate="yes" xml:space="preserve">
          <source>This method provides notification that the virtual table implementation that the virtual table will be given a new name. If this method returns &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; then SQLite renames the table. If this method returns an &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; then the renaming is prevented.</source>
          <target state="translated">Этот метод обеспечивает уведомление о том, что реализация виртуальной таблицы, что виртуальной таблице будет присвоено новое имя. Если этот метод возвращает &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK,&lt;/a&gt; SQLite переименовывает таблицу. Если этот метод возвращает &lt;a href=&quot;rescode&quot;&gt;код ошибки,&lt;/a&gt; переименование предотвращается.</target>
        </trans-unit>
        <trans-unit id="a08efc90f97c033c6f3a136a45c2a7cd6eb3f466" translate="yes" xml:space="preserve">
          <source>This method registers a callback routine that is invoked after transaction commit when the database is in &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt;. Two arguments are appended to the callback command before it is invoked:</source>
          <target state="translated">Этот метод регистрирует процедуру обратного вызова, которая вызывается после фиксации транзакции, когда база данных находится в &lt;a href=&quot;wal&quot;&gt;режиме WAL&lt;/a&gt; . Перед вызовом к команде обратного вызова добавляются два аргумента:</target>
        </trans-unit>
        <trans-unit id="2920f36d10d056ba3578501d280b4d02be0b6e1d" translate="yes" xml:space="preserve">
          <source>This method registers a callback routine that is invoked just before SQLite tries to commit changes to a database. If the callback throws an exception or returns a non-zero result, then the transaction rolls back rather than commit.</source>
          <target state="translated">Этот метод регистрирует процедуру обратного вызова,которая вызывается непосредственно перед тем,как SQLite попытается зафиксировать изменения в базе данных.Если обратный вызов бросает исключение или возвращает ненулевой результат,то транзакция откатывается,а не фиксируется.</target>
        </trans-unit>
        <trans-unit id="20062984ae0be47aefc8270221280e0e79c3fbe2" translate="yes" xml:space="preserve">
          <source>This method registers a callback routine that is invoked just before SQLite tries to do a rollback. The script argument is run without change.</source>
          <target state="translated">Этот метод регистрирует процедуру обратного вызова,которая вызывается непосредственно перед тем,как SQLite попытается выполнить откат.Аргумент скрипта запускается без изменений.</target>
        </trans-unit>
        <trans-unit id="b68fa7e92d08c038d817ec9f0f1dc21053a80d3a" translate="yes" xml:space="preserve">
          <source>This method registers a callback routine that is invoked just before each row is modified by an UPDATE, INSERT, or DELETE statement. Four arguments are appended to the callback before it is invoked:</source>
          <target state="translated">Этот метод регистрирует процедуру обратного вызова,которая вызывается непосредственно перед тем,как каждая строка будет изменена оператором UPDATE,INSERT или DELETE.Четыре аргумента добавляются к обратному вызову перед тем,как он будет вызван:</target>
        </trans-unit>
        <trans-unit id="1de39dc4601511299a305e0af9ade7a304a3c689" translate="yes" xml:space="preserve">
          <source>This method registers a callback routine that is invoked when the SQLite engine needs a particular collating sequence but does not have that collating sequence registered. The callback can register the collating sequence. The callback is invoked with a single parameter which is the name of the needed collating sequence.</source>
          <target state="translated">Этот метод регистрирует процедуру обратного вызова,которая вызывается,когда движку SQLite требуется определенная последовательность объединения,но не регистрируется эта последовательность объединения.Обратный вызов может зарегистрировать коллекционную последовательность.Обратный вызов вызывается с одним параметром,который является именем нужной коллекционной последовательности.</target>
        </trans-unit>
        <trans-unit id="21ae789dba180ad8c87b4a2a750db64d49f46fa8" translate="yes" xml:space="preserve">
          <source>This method registers a callback that is invoked periodically during query processing. There are two arguments: the number of SQLite virtual machine opcodes between invocations, and the TCL command to invoke. Setting the progress callback to an empty string disables it.</source>
          <target state="translated">Этот метод регистрирует обратный вызов,который периодически вызывается во время обработки запроса.Существует два аргумента:количество опкодов виртуальной машины SQLite между вызовами и команда TCL для вызова.Установка обратного вызова прогресса в пустую строку отключает его.</target>
        </trans-unit>
        <trans-unit id="2dc944f8c7fefbfebd13fd137f3e37227d9d5fa9" translate="yes" xml:space="preserve">
          <source>This method registers new text collating sequences. There are two arguments: the name of the collating sequence and the name of a TCL procedure that implements a comparison function for the collating sequence.</source>
          <target state="translated">Этот метод регистрирует новые последовательности группировки текста.Есть два аргумента:имя коллекционирующей последовательности и имя процедуры TCL,реализующей функцию сравнения для коллекционирующей последовательности.</target>
        </trans-unit>
        <trans-unit id="e6fd7472db353bf284142fd5894eee70bc3b8bf2" translate="yes" xml:space="preserve">
          <source>This method releases a connection to a virtual table, just like the &lt;a href=&quot;vtab#xdisconnect&quot;&gt;xDisconnect&lt;/a&gt; method, and it also destroys the underlying table implementation. This method undoes the work of &lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt;.</source>
          <target state="translated">Этот метод освобождает соединение с виртуальной таблицей, как и метод &lt;a href=&quot;vtab#xdisconnect&quot;&gt;xDisconnect&lt;/a&gt; , а также уничтожает реализацию базовой таблицы. Этот метод отменяет работу &lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ef832304ea34e78e50a8e321fbc11fd1e9032c28" translate="yes" xml:space="preserve">
          <source>This method releases a connection to a virtual table. Only the &lt;a href=&quot;c3ref/vtab&quot;&gt;sqlite3_vtab&lt;/a&gt; object is destroyed. The virtual table is not destroyed and any backing store associated with the virtual table persists. This method undoes the work of &lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect&lt;/a&gt;.</source>
          <target state="translated">Этот метод освобождает соединение с виртуальной таблицей. &lt;a href=&quot;c3ref/vtab&quot;&gt;Уничтожается&lt;/a&gt; только объект sqlite3_vtab . Виртуальная таблица не уничтожается, и любое резервное хранилище, связанное с виртуальной таблицей, сохраняется. Этот метод отменяет работу &lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4227ff89f6190deba008640864f1fdb82c90a383" translate="yes" xml:space="preserve">
          <source>This method returns status information from the most recently evaluated SQL statement. The status method takes a single argument which should be either &quot;steps&quot; or &quot;sorts&quot;. If the argument is &quot;steps&quot;, then the method returns the number of full table scan steps that the previous SQL statement evaluated. If the argument is &quot;sorts&quot;, the method returns the number of sort operations. This information can be used to detect queries that are not using indices to speed search or sorting.</source>
          <target state="translated">Этот метод возвращает информацию о состоянии из последнего оцененного SQL-оператора.Метод статуса принимает единственный аргумент,который должен быть либо &quot;шаги&quot;,либо &quot;сортировки&quot;.Если аргумент &quot;шаги&quot;,то метод возвращает количество полных шагов сканирования таблицы,которые оценивал предыдущий SQL-оператор.Если аргумент &quot;сортирует&quot;,то метод возвращает количество операций сортировки.Эта информация может быть использована для обнаружения запросов,не использующих индексы для ускорения поиска или сортировки.</target>
        </trans-unit>
        <trans-unit id="8fc50ec02b1fc52936f33c145dd76c2dbb1165ca" translate="yes" xml:space="preserve">
          <source>This method returns the numeric error code that resulted from the most recent SQLite operation.</source>
          <target state="translated">Этот метод возвращает код числовой ошибки,который возник в результате последней операции SQLite.</target>
        </trans-unit>
        <trans-unit id="f84b852e58521bbbf0fe6bd6ba3aaa76874ffba2" translate="yes" xml:space="preserve">
          <source>This method should return an integer value that is equivalent to an SQLite error code (usually 0 for SQLITE_OK in the case of success or 1 for SQLITE_ERROR if some error occurs). As in &lt;a href=&quot;c3ref/wal_hook&quot;&gt;sqlite3_wal_hook()&lt;/a&gt;, the results of returning an integer that does not correspond to an SQLite error code are undefined. If the value returned by the script cannot be interpreted as an integer value, or if the script throws a Tcl exception, no error is returned to SQLite but a Tcl background-error is raised.</source>
          <target state="translated">Этот метод должен возвращать целочисленное значение, эквивалентное коду ошибки SQLite (обычно 0 для SQLITE_OK в случае успеха или 1 для SQLITE_ERROR в случае возникновения какой-либо ошибки). Как и в &lt;a href=&quot;c3ref/wal_hook&quot;&gt;sqlite3_wal_hook ()&lt;/a&gt; , результаты возврата целого числа, не соответствующего коду ошибки SQLite, не определены. Если значение, возвращаемое сценарием, не может быть интерпретировано как целочисленное значение, или если сценарий вызывает исключение Tcl, SQLite не возвращает ошибку, но возникает фоновая ошибка Tcl.</target>
        </trans-unit>
        <trans-unit id="69d817508f731b9a1bddece3df659e773b266409" translate="yes" xml:space="preserve">
          <source>This method signals the start of a two-phase commit on a virtual table. This is method is optional. The xSync pointer of &lt;a href=&quot;c3ref/module&quot;&gt;sqlite3_module&lt;/a&gt; may be NULL.</source>
          <target state="translated">Этот метод сигнализирует о начале двухфазной фиксации виртуальной таблицы. Этот метод не является обязательным. Указатель xSync &lt;a href=&quot;c3ref/module&quot;&gt;sqlite3_module&lt;/a&gt; может иметь значение NULL.</target>
        </trans-unit>
        <trans-unit id="1be99db4c515118ac04440359b90544a681fa330" translate="yes" xml:space="preserve">
          <source>This method takes a single boolean argument which will turn the extension loading functionality on or off.</source>
          <target state="translated">Этот метод принимает единственный логический аргумент,который включает или выключает функцию загрузки расширений.</target>
        </trans-unit>
        <trans-unit id="6c561fc9f9d18e98c0c786b020b147ec37c718e8" translate="yes" xml:space="preserve">
          <source>This misfeature means that a misspelled double-quoted identifier will be interpreted as a string literal, rather than generating an error. It also lures developers who are new to the SQL language into the bad habit of using double-quoted string literals when they really need to learn to use the correct single-quoted string literal form.</source>
          <target state="translated">Эта опечатка означает,что неправильно написанный двойной кавычки идентификатор будет интерпретирован как строковый литерал,а не сгенерирован как ошибка.Она также заманивает новичков в языке SQL в дурную привычку использовать строковые литералы в двойных кавычках,когда им действительно нужно научиться использовать правильную форму строкового литерала в одинарных кавычках.</target>
        </trans-unit>
        <trans-unit id="a7d7620eee00f67af5794e95b53ed251b900cca6" translate="yes" xml:space="preserve">
          <source>This mode blocks (invokes the &lt;a href=&quot;c3ref/busy_handler&quot;&gt;busy-handler callback&lt;/a&gt;) until there is no database writer and all readers are reading from the most recent database snapshot. It then checkpoints all frames in the log file and syncs the database file. FULL blocks concurrent writers while it is running, but readers can proceed.</source>
          <target state="translated">Этот режим блокирует (вызывает &lt;a href=&quot;c3ref/busy_handler&quot;&gt;обратный вызов обработчика занятости&lt;/a&gt; ) до тех пор, пока не исчезнет модуль записи базы данных и все считывающие устройства не будут читать из самого последнего моментального снимка базы данных. Затем он проверяет все кадры в файле журнала и синхронизирует файл базы данных. FULL блокирует одновременные записи во время работы, но читатели могут продолжить.</target>
        </trans-unit>
        <trans-unit id="d4d4de2de6eaf1fc63ccde7eca3a1fd81c8366c2" translate="yes" xml:space="preserve">
          <source>This mode blocks (it invokes the &lt;a href=&quot;#sqlite3_busy_handler&quot;&gt;busy-handler callback&lt;/a&gt;) until there is no database writer and all readers are reading from the most recent database snapshot. It then checkpoints all frames in the log file and syncs the database file. This mode blocks new database writers while it is pending, but new database readers are allowed to continue unimpeded.</source>
          <target state="translated">Этот режим блокирует (он вызывает &lt;a href=&quot;#sqlite3_busy_handler&quot;&gt;обратный вызов обработчика занятости&lt;/a&gt; ) до тех пор, пока не исчезнет модуль записи базы данных и все устройства чтения не будут читать из самого последнего снимка базы данных. Затем он проверяет все кадры в файле журнала и синхронизирует файл базы данных. Этот режим блокирует новые средства записи базы данных, пока он находится в режиме ожидания, но новые средства чтения базы данных могут продолжать работу без препятствий.</target>
        </trans-unit>
        <trans-unit id="3cc26aa0e4889928aaca415a8d70e942682adf13" translate="yes" xml:space="preserve">
          <source>This mode blocks (it invokes the &lt;a href=&quot;busy_handler&quot;&gt;busy-handler callback&lt;/a&gt;) until there is no database writer and all readers are reading from the most recent database snapshot. It then checkpoints all frames in the log file and syncs the database file. This mode blocks new database writers while it is pending, but new database readers are allowed to continue unimpeded.</source>
          <target state="translated">Этот режим блокирует (он вызывает &lt;a href=&quot;busy_handler&quot;&gt;обратный вызов обработчика занятости&lt;/a&gt; ) до тех пор, пока не исчезнет модуль записи базы данных и все устройства чтения не будут читать из самого последнего снимка базы данных. Затем он проверяет все кадры в файле журнала и синхронизирует файл базы данных. Этот режим блокирует новые средства записи базы данных, пока он находится в режиме ожидания, но новые средства чтения базы данных могут продолжать работу без препятствий.</target>
        </trans-unit>
        <trans-unit id="3564356c049b3cc19954e75da9c3a3e14807a420" translate="yes" xml:space="preserve">
          <source>This mode works the same way as FULL with the addition that after checkpointing the log file it blocks (calls the &lt;a href=&quot;c3ref/busy_handler&quot;&gt;busy-handler callback&lt;/a&gt;) until all readers are finished with the log file. This ensures that the next client to write to the database file restarts the log file from the beginning. RESTART blocks concurrent writers while it is running, but allowed readers to proceed.</source>
          <target state="translated">Этот режим работает так же, как FULL, с той лишь разницей, что после установки контрольной точки в файле журнала он блокируется (вызывает &lt;a href=&quot;c3ref/busy_handler&quot;&gt;обратный вызов обработчика занятости&lt;/a&gt; ) до тех пор, пока все считыватели не закончат работу с файлом журнала. Это гарантирует, что следующий клиент, выполняющий запись в файл базы данных, перезапустит файл журнала с самого начала. RESTART блокирует одновременные записи во время работы, но позволяет читателям продолжить.</target>
        </trans-unit>
        <trans-unit id="1fb881e2173a556242d04296f314a6e802d8d176" translate="yes" xml:space="preserve">
          <source>This mode works the same way as RESTART with the addition that the WAL file is truncated to zero bytes upon successful completion.</source>
          <target state="translated">Этот режим работает так же,как и RESTART с добавлением того,что при успешном завершении работы файл WAL усекается до нуля байт.</target>
        </trans-unit>
        <trans-unit id="94e1a681e057e0efd19e4f8568beb354e5ca747a" translate="yes" xml:space="preserve">
          <source>This mode works the same way as SQLITE_CHECKPOINT_FULL with the addition that after checkpointing the log file it blocks (calls the &lt;a href=&quot;#sqlite3_busy_handler&quot;&gt;busy-handler callback&lt;/a&gt;) until all readers are reading from the database file only. This ensures that the next writer will restart the log file from the beginning. Like SQLITE_CHECKPOINT_FULL, this mode blocks new database writer attempts while it is pending, but does not impede readers.</source>
          <target state="translated">Этот режим работает так же, как SQLITE_CHECKPOINT_FULL, с той лишь разницей, что после установки контрольной точки в файле журнала он блокируется (вызывает &lt;a href=&quot;#sqlite3_busy_handler&quot;&gt;обратный вызов обработчика занятости&lt;/a&gt; ) до тех пор, пока все считыватели не будут читать только из файла базы данных. Это гарантирует, что следующий писатель перезапустит файл журнала с самого начала. Как и SQLITE_CHECKPOINT_FULL, этот режим блокирует новые попытки записи в базу данных, пока они ожидают выполнения, но не препятствует читателям.</target>
        </trans-unit>
        <trans-unit id="2565fbfb38de6ccb4881d6d5b4ff9625664b3e35" translate="yes" xml:space="preserve">
          <source>This mode works the same way as SQLITE_CHECKPOINT_FULL with the addition that after checkpointing the log file it blocks (calls the &lt;a href=&quot;busy_handler&quot;&gt;busy-handler callback&lt;/a&gt;) until all readers are reading from the database file only. This ensures that the next writer will restart the log file from the beginning. Like SQLITE_CHECKPOINT_FULL, this mode blocks new database writer attempts while it is pending, but does not impede readers.</source>
          <target state="translated">Этот режим работает так же, как SQLITE_CHECKPOINT_FULL, с той лишь разницей, что после установки контрольной точки в файле журнала он блокируется (вызывает &lt;a href=&quot;busy_handler&quot;&gt;обратный вызов обработчика занятости&lt;/a&gt; ) до тех пор, пока все считыватели не будут читать только из файла базы данных. Это гарантирует, что следующий писатель перезапустит файл журнала с самого начала. Как и SQLITE_CHECKPOINT_FULL, этот режим блокирует новые попытки записи в базу данных, пока они ожидают выполнения, но не препятствует читателям.</target>
        </trans-unit>
        <trans-unit id="6553148329df03707f6ea6e001cc2a449f7036e8" translate="yes" xml:space="preserve">
          <source>This mode works the same way as SQLITE_CHECKPOINT_RESTART with the addition that it also truncates the log file to zero bytes just prior to a successful return.</source>
          <target state="translated">Этот режим работает так же,как и SQLITE_CHECKPOINT_RESTART с добавлением того,что он также усекает лог-файл до нуля байт непосредственно перед успешным возвращением.</target>
        </trans-unit>
        <trans-unit id="5e17d751b95d394b7ad8a49ae12b1ba579b3059a" translate="yes" xml:space="preserve">
          <source>This new index can be used to implement a faster algorithm for the original &quot;Price of Peaches&quot; query.</source>
          <target state="translated">Этот новый индекс может быть использован для реализации более быстрого алгоритма для исходного запроса &quot;Цена персиков&quot;.</target>
        </trans-unit>
        <trans-unit id="f7c2f3e95925f0342ad3f077f1f083b0da69c5fe" translate="yes" xml:space="preserve">
          <source>This new index contains all the columns of the original FruitsForSale table that are used by the query - both the search terms and the output. We call this a &quot;covering index&quot;. Because all of the information needed is in the covering index, SQLite never needs to consult the original table in order to find the price.</source>
          <target state="translated">Этот новый индекс содержит все столбцы исходной таблицы FruitsForSale,которые используются в запросе-как поисковые термины,так и вывод.Мы называем это &quot;индекс покрытия&quot;.Поскольку вся необходимая информация находится в покрывающем индексе,SQLite никогда не придется обращаться к исходной таблице,чтобы найти цену.</target>
        </trans-unit>
        <trans-unit id="acf43845a5ea53f1f00ff4c11a6f5e1b8a8b33d3" translate="yes" xml:space="preserve">
          <source>This next query solves a Sudoku puzzle. The state of the puzzle is defined by an 81-character string formed by reading entries from the puzzle box row by row from left to right and then from top to bottom. Blank squares in the puzzle are denoted by a &quot;.&quot; character. Thus the input string:</source>
          <target state="translated">Следующий запрос решает головоломку Судоку.Состояние головоломки определяется 81-символьной строкой,образованной чтением записей из коробки головоломки подряд слева направо,а затем сверху вниз.Пустые клетки головоломки обозначаются символом &quot;...&quot;.Таким образом,строка ввода:</target>
        </trans-unit>
        <trans-unit id="68714059b3f9385751b77bf5e71ea40721ded156" translate="yes" xml:space="preserve">
          <source>This object is used in only one place in the SQLite interface. A pointer to an instance of this object is the argument to &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config()&lt;/a&gt; when the configuration option is &lt;a href=&quot;#sqliteconfigmalloc&quot;&gt;SQLITE_CONFIG_MALLOC&lt;/a&gt; or &lt;a href=&quot;#sqliteconfiggetmalloc&quot;&gt;SQLITE_CONFIG_GETMALLOC&lt;/a&gt;. By creating an instance of this object and passing it to &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;#sqliteconfigmalloc&quot;&gt;SQLITE_CONFIG_MALLOC&lt;/a&gt;) during configuration, an application can specify an alternative memory allocation subsystem for SQLite to use for all of its dynamic memory needs.</source>
          <target state="translated">Этот объект используется только в одном месте интерфейса SQLite. Указатель на экземпляр этого объекта является аргументом &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config (),&lt;/a&gt; если параметр конфигурации - &lt;a href=&quot;#sqliteconfigmalloc&quot;&gt;SQLITE_CONFIG_MALLOC&lt;/a&gt; или &lt;a href=&quot;#sqliteconfiggetmalloc&quot;&gt;SQLITE_CONFIG_GETMALLOC&lt;/a&gt; . Создавая экземпляр этого объекта и передав его в &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config&lt;/a&gt; ( &lt;a href=&quot;#sqliteconfigmalloc&quot;&gt;SQLITE_CONFIG_MALLOC&lt;/a&gt; ) во время настройки, приложение может указать альтернативную подсистему распределения памяти, которую SQLite будет использовать для всех своих потребностей в динамической памяти.</target>
        </trans-unit>
        <trans-unit id="3560b833b5836cc3d10c63801ce7146372dee16e" translate="yes" xml:space="preserve">
          <source>This object is used in only one place in the SQLite interface. A pointer to an instance of this object is the argument to &lt;a href=&quot;config&quot;&gt;sqlite3_config()&lt;/a&gt; when the configuration option is &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigmalloc&quot;&gt;SQLITE_CONFIG_MALLOC&lt;/a&gt; or &lt;a href=&quot;c_config_covering_index_scan#sqliteconfiggetmalloc&quot;&gt;SQLITE_CONFIG_GETMALLOC&lt;/a&gt;. By creating an instance of this object and passing it to &lt;a href=&quot;config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c_config_covering_index_scan#sqliteconfigmalloc&quot;&gt;SQLITE_CONFIG_MALLOC&lt;/a&gt;) during configuration, an application can specify an alternative memory allocation subsystem for SQLite to use for all of its dynamic memory needs.</source>
          <target state="translated">Этот объект используется только в одном месте интерфейса SQLite. Указатель на экземпляр этого объекта является аргументом &lt;a href=&quot;config&quot;&gt;sqlite3_config (),&lt;/a&gt; если параметр конфигурации - &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigmalloc&quot;&gt;SQLITE_CONFIG_MALLOC&lt;/a&gt; или &lt;a href=&quot;c_config_covering_index_scan#sqliteconfiggetmalloc&quot;&gt;SQLITE_CONFIG_GETMALLOC&lt;/a&gt; . Создавая экземпляр этого объекта и передав его в &lt;a href=&quot;config&quot;&gt;sqlite3_config&lt;/a&gt; ( &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigmalloc&quot;&gt;SQLITE_CONFIG_MALLOC&lt;/a&gt; ) во время настройки, приложение может указать альтернативную подсистему распределения памяти, которую SQLite будет использовать для всех своих потребностей в динамической памяти.</target>
        </trans-unit>
        <trans-unit id="1882a6d3fc0a0bded1e433917173d1858c24f074" translate="yes" xml:space="preserve">
          <source>This only works when compiled with &lt;a href=&quot;compile#debug&quot;&gt;SQLITE_DEBUG&lt;/a&gt;.</source>
          <target state="translated">Это работает только при компиляции с &lt;a href=&quot;compile#debug&quot;&gt;SQLITE_DEBUG&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cfa6d4acc676d7ac09e89de67c072931e0df8cd6" translate="yes" xml:space="preserve">
          <source>This opcode (which only exists if SQLite was compiled with SQLITE_ENABLE_COLUMN_USED_MASK) identifies which columns of the table or index for cursor P1 are used. P4 is a 64-bit integer (P4_INT64) in which the first 63 bits are one for each of the first 63 columns of the table or index that are actually used by the cursor. The high-order bit is set if any column after the 64th is used.</source>
          <target state="translated">Этот опкод (который существует только в том случае,если SQLite был скомпилирован с SQLITE_ENABLE_COLUMN_USED_MASK)определяет,какие столбцы таблицы или индекса для курсора P1 используются.P4-64-битное целое число (P4_INT64),в котором первые 63 бита-по одному для каждого из первых 63 столбцов таблицы или индекса,которые фактически используются курсором.Старший бит устанавливается,если после 64-го используется какой-либо столбец.</target>
        </trans-unit>
        <trans-unit id="b79886bbc08237ffaab5449ea6dabdf7a84bb8eb" translate="yes" xml:space="preserve">
          <source>This opcode behaves like &lt;a href=&quot;opcode#NotFound&quot;&gt;NotFound&lt;/a&gt; if the seekHit flag is clear and it behaves like &lt;a href=&quot;opcode#Noop&quot;&gt;Noop&lt;/a&gt; if the seekHit flag is set.</source>
          <target state="translated">Этот код операции ведет себя как &lt;a href=&quot;opcode#NotFound&quot;&gt;NotFound,&lt;/a&gt; если флаг seekHit снят, и как &lt;a href=&quot;opcode#Noop&quot;&gt;Noop,&lt;/a&gt; если установлен флаг seekHit.</target>
        </trans-unit>
        <trans-unit id="e04269abd438fa3b7333edfe660e9856975a5dd0" translate="yes" xml:space="preserve">
          <source>This opcode does exactly the same thing as &lt;a href=&quot;opcode#Rewind&quot;&gt;Rewind&lt;/a&gt; except that it increments an undocumented global variable used for testing.</source>
          <target state="translated">Этот код операции делает то же самое, что и &lt;a href=&quot;opcode#Rewind&quot;&gt;Rewind,&lt;/a&gt; за исключением того, что увеличивает недокументированную глобальную переменную, используемую для тестирования.</target>
        </trans-unit>
        <trans-unit id="a4f693ddfe78c322d1a151b474b66eaa8e305f44" translate="yes" xml:space="preserve">
          <source>This opcode helps to optimize IN operators on a multi-column index where the IN operator is on the later terms of the index by avoiding unnecessary seeks on the btree, substituting steps to the next row of the b-tree instead. A correct answer is obtained if this opcode is omitted or is a no-op.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8090fac6edb839ad1f5d93ed66a4501d0732691" translate="yes" xml:space="preserve">
          <source>This opcode implements the IS TRUE, IS FALSE, IS NOT TRUE, and IS NOT FALSE operators.</source>
          <target state="translated">Данный опкод реализует операторы IS TRUE,IS FALSE,IS NOT TRUE и IS NOT FALSE.</target>
        </trans-unit>
        <trans-unit id="80195a95c1d144667fff82486976a6e1af2d3b57" translate="yes" xml:space="preserve">
          <source>This opcode invokes the parser to create a new virtual machine, then runs the new virtual machine. It is thus a re-entrant opcode.</source>
          <target state="translated">Этот опкод вызывает парсер для создания новой виртуальной машины,а затем запускает новую виртуальную машину.Таким образом,это повторный входной опкод.</target>
        </trans-unit>
        <trans-unit id="d5ae7a9a55b8c3387be81c142b3c731709ff4fb8" translate="yes" xml:space="preserve">
          <source>This opcode invokes the xFilter method on the virtual table specified by P1. The integer query plan parameter to xFilter is stored in register P3. Register P3+1 stores the argc parameter to be passed to the xFilter method. Registers P3+2..P3+1+argc are the argc additional parameters which are passed to xFilter as argv. Register P3+2 becomes argv[0] when passed to xFilter.</source>
          <target state="translated">Этот опкод вызывает метод xFilter на виртуальной таблице,указанной в P1.Параметр целочисленного плана запроса к xFilter хранится в регистре P3.Регистр P3+1 хранит параметр argc,который должен быть передан методу xFilter.Регистры P3+2...P3+1+argc являются дополнительными параметрами argc,которые передаются в xFilter как argv.Регистр P3+2 становится argv[0]при передаче в xFilter.</target>
        </trans-unit>
        <trans-unit id="ad711239770de096c4e38e8f308460d010c6ad04" translate="yes" xml:space="preserve">
          <source>This opcode is a prefix opcode to &lt;a href=&quot;opcode#SeekGE&quot;&gt;SeekGE&lt;/a&gt;. In other words, this opcode must be immediately followed by &lt;a href=&quot;opcode#SeekGE&quot;&gt;SeekGE&lt;/a&gt;. This constraint is checked by assert() statements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4696388c2a5ea95b129447ae7160a304f284c78" translate="yes" xml:space="preserve">
          <source>This opcode is an alias for &lt;a href=&quot;opcode#Sort&quot;&gt;Sort&lt;/a&gt; and &lt;a href=&quot;opcode#Rewind&quot;&gt;Rewind&lt;/a&gt; that is used for Sorter objects.</source>
          <target state="translated">Этот код операции является псевдонимом для &lt;a href=&quot;opcode#Sort&quot;&gt;сортировки&lt;/a&gt; и &lt;a href=&quot;opcode#Rewind&quot;&gt;перемотки назад,&lt;/a&gt; который используется для объектов сортировщика.</target>
        </trans-unit>
        <trans-unit id="2decf03594ee0b65a7f82da7f8a270404d1a31f3" translate="yes" xml:space="preserve">
          <source>This opcode is an optimization attempt only. If this opcode always falls through, the correct answer is still obtained, but extra works is performed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cd5c8a03dccaa1c2e173dfb77000d3f09963ffe" translate="yes" xml:space="preserve">
          <source>This opcode is initially coded as OP_AggStep0. On first evaluation, the FuncDef stored in P4 is converted into an sqlite3_context and the opcode is changed. In this way, the initialization of the sqlite3_context only happens once, instead of on each call to the step function.</source>
          <target state="translated">Этот опкод изначально закодирован как OP_AggStep0.При первой оценке,FuncDef,хранящийся в P4,преобразуется в sqlite3_context,а опкод изменяется.Таким образом,инициализация контекста sqlite3_context происходит только один раз,а не при каждом вызове шаговой функции.</target>
        </trans-unit>
        <trans-unit id="ccd042d8c20621b0ba115fbd962b688a465b7a1e" translate="yes" xml:space="preserve">
          <source>This opcode is normally use to move a record out of the sorter and into a register that is the source for a pseudo-table cursor created using &lt;a href=&quot;opcode#OpenPseudo&quot;&gt;OpenPseudo&lt;/a&gt;. That pseudo-table cursor is the one that is identified by parameter P3. Clearing the P3 column cache as part of this opcode saves us from having to issue a separate &lt;a href=&quot;opcode#NullRow&quot;&gt;NullRow&lt;/a&gt; instruction to clear that cache.</source>
          <target state="translated">Этот код операции обычно используется для перемещения записи из сортировщика в регистр, который является источником курсора &lt;a href=&quot;opcode#OpenPseudo&quot;&gt;псевдотаблицы,&lt;/a&gt; созданного с помощью OpenPseudo . Этот курсор псевдотаблицы идентифицируется параметром P3. Очистка кеша столбцов P3 как часть этого кода операции избавляет нас от необходимости &lt;a href=&quot;opcode#NullRow&quot;&gt;вводить&lt;/a&gt; отдельную инструкцию NullRow для очистки этого кеша.</target>
        </trans-unit>
        <trans-unit id="f368e74bed9bf6036c173d5ffc843879779adc0f" translate="yes" xml:space="preserve">
          <source>This opcode is only available if SQLite is compiled with the -DSQLITE_ENABLE_OFFSET_SQL_FUNC option.</source>
          <target state="translated">Этот опкод доступен только в том случае,если SQLite скомпилирован с опцией -DSQLITE_ENABLE_OFFSET_SQL_FUNC.</target>
        </trans-unit>
        <trans-unit id="cc6bc217f526f9cd459391c67d3dce0bbbb0723f" translate="yes" xml:space="preserve">
          <source>This opcode is only available in testing and debugging builds. It is not generated for release builds. The purpose of this opcode is to help validate the generated bytecode. This opcode does not actually contribute to computing an answer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0dd0c6b395f56420b6f36502ce5f6e4b927e5a5c" translate="yes" xml:space="preserve">
          <source>This opcode is only ever present in sub-programs called via the &lt;a href=&quot;opcode#Program&quot;&gt;Program&lt;/a&gt; instruction. &lt;a href=&quot;opcode#Copy&quot;&gt;Copy&lt;/a&gt; a value currently stored in a memory cell of the calling (parent) frame to cell P2 in the current frames address space. This is used by trigger programs to access the new.* and old.* values.</source>
          <target state="translated">Этот код операции всегда присутствует только в подпрограммах, вызываемых с помощью инструкции &lt;a href=&quot;opcode#Program&quot;&gt;Program&lt;/a&gt; . &lt;a href=&quot;opcode#Copy&quot;&gt;Скопируйте&lt;/a&gt; значение, которое в настоящее время хранится в ячейке памяти вызывающего (родительского) кадра, в ячейку P2 в адресном пространстве текущего кадра. Это используется программами-триггерами для доступа к новым. * И старым. * Значениям.</target>
        </trans-unit>
        <trans-unit id="1edae59fc3236745f7fbf501252bcea75f5db5b9" translate="yes" xml:space="preserve">
          <source>This opcode is similar to &lt;a href=&quot;opcode#NotFound&quot;&gt;NotFound&lt;/a&gt; with the exceptions that the branch is always taken if any part of the search key input is NULL.</source>
          <target state="translated">Этот код операции аналогичен &lt;a href=&quot;opcode#NotFound&quot;&gt;NotFound&lt;/a&gt; за исключением того, что ветвление всегда выполняется, если какая-либо часть ввода ключа поиска имеет значение NULL.</target>
        </trans-unit>
        <trans-unit id="1074ea1e6510853bdec71ac78b6a534ca6039b57" translate="yes" xml:space="preserve">
          <source>This opcode is used in IN clause processing for a multi-column key. If an IN clause is attached to an element of the key other than the left-most element, and if there are no matches on the most recent seek over the whole key, then it might be that one of the key element to the left is prohibiting a match, and hence there is &quot;no hope&quot; of any match regardless of how many IN clause elements are checked. In such a case, we abandon the IN clause search early, using this opcode. The opcode name comes from the fact that the jump is taken if there is &quot;no hope&quot; of achieving a match.</source>
          <target state="translated">Этот опкод используется при обработке пункта IN для многоколоночного ключа.Если пункт IN прикреплен к элементу ключа,отличному от крайнего левого элемента,и если нет совпадений в последнем поиске по всему ключу,то может оказаться,что один из ключевых элементов слева запрещает совпадение,и,следовательно,нет &quot;надежды&quot; на какое-либо совпадение,независимо от того,сколько элементов пункта IN проверено.В таком случае мы заблаговременно отказываемся от поиска по пункту IN,используя этот опкод.Название опкода происходит от того,что при &quot;отсутствии надежды&quot; на достижение совпадения выполняется переход.</target>
        </trans-unit>
        <trans-unit id="8a560c644b1064348d0d21a9885c9e73f72f185e" translate="yes" xml:space="preserve">
          <source>This opcode is used to implement the integrity_check pragma.</source>
          <target state="translated">Этот опкод используется для реализации прагмы integrity_check.</target>
        </trans-unit>
        <trans-unit id="36b9014a68a8fcf60471eef29422a00680109ffb" translate="yes" xml:space="preserve">
          <source>This opcode is used when extracting information from a column that has REAL affinity. Such column values may still be stored as integers, for space efficiency, but after extraction we want them to have only a real value.</source>
          <target state="translated">Этот опкод используется при извлечении информации из колонки,имеющей REAL сродство.Такие значения столбцов могут храниться в виде целых чисел,для эффективности использования пространства,но после извлечения мы хотим,чтобы они имели только реальное значение.</target>
        </trans-unit>
        <trans-unit id="cfa4b2533ec63a8dec1bee2b7cfac77ec376defc" translate="yes" xml:space="preserve">
          <source>This opcode leaves the cursor configured to move in forward order, from the beginning toward the end. In other words, the cursor is configured to use &lt;a href=&quot;opcode#Next&quot;&gt;Next&lt;/a&gt;, not &lt;a href=&quot;opcode#Prev&quot;&gt;Prev&lt;/a&gt;.</source>
          <target state="translated">Этот код операции оставляет курсор настроенным на перемещение в прямом порядке, от начала к концу. Другими словами, курсор настроен на использование &lt;a href=&quot;opcode#Next&quot;&gt;Next&lt;/a&gt; , а не &lt;a href=&quot;opcode#Prev&quot;&gt;Prev&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9db9421c1851bc92812d2d99ea83270abb9a3281" translate="yes" xml:space="preserve">
          <source>This opcode leaves the cursor configured to move in reverse order, from the end toward the beginning. In other words, the cursor is configured to use &lt;a href=&quot;opcode#Prev&quot;&gt;Prev&lt;/a&gt;, not &lt;a href=&quot;opcode#Next&quot;&gt;Next&lt;/a&gt;.</source>
          <target state="translated">Этот код операции оставляет курсор настроенным на перемещение в обратном порядке, от конца к началу. Другими словами, курсор настроен на использование &lt;a href=&quot;opcode#Prev&quot;&gt;Prev&lt;/a&gt; , а не &lt;a href=&quot;opcode#Next&quot;&gt;Next&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f2f0cd72e4c85aa3ba21b6915cd7acce5e5760e8" translate="yes" xml:space="preserve">
          <source>This opcode leaves the cursor in a state where it cannot be advanced in either direction. In other words, the &lt;a href=&quot;opcode#Next&quot;&gt;Next&lt;/a&gt; and &lt;a href=&quot;opcode#Prev&quot;&gt;Prev&lt;/a&gt; opcodes will not work following this opcode.</source>
          <target state="translated">Этот код операции оставляет курсор в состоянии, при котором его нельзя продвигать ни в одном направлении. Другими словами, коды операций &lt;a href=&quot;opcode#Next&quot;&gt;Next&lt;/a&gt; и &lt;a href=&quot;opcode#Prev&quot;&gt;Prev&lt;/a&gt; не будут работать после этого кода операции.</target>
        </trans-unit>
        <trans-unit id="e0f99ac32670b6df2ff48dc1552c8225ad687653" translate="yes" xml:space="preserve">
          <source>This opcode must follow an &lt;a href=&quot;opcode#Lt&quot;&gt;Lt&lt;/a&gt; or &lt;a href=&quot;opcode#Gt&quot;&gt;Gt&lt;/a&gt; comparison operator. There can be zero or more OP_ReleaseReg opcodes intervening, but no other opcodes are allowed to occur between this instruction and the previous &lt;a href=&quot;opcode#Lt&quot;&gt;Lt&lt;/a&gt; or &lt;a href=&quot;opcode#Gt&quot;&gt;Gt&lt;/a&gt;. Furthermore, the prior &lt;a href=&quot;opcode#Lt&quot;&gt;Lt&lt;/a&gt; or &lt;a href=&quot;opcode#Gt&quot;&gt;Gt&lt;/a&gt; must have the SQLITE_STOREP2 bit set in the P5 field.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6db8b6773ccb389e7a96c1d48f5077207b71453" translate="yes" xml:space="preserve">
          <source>This opcode must immediately follow an &lt;a href=&quot;opcode#Lt&quot;&gt;Lt&lt;/a&gt; or &lt;a href=&quot;opcode#Gt&quot;&gt;Gt&lt;/a&gt; comparison operator. If result of an &lt;a href=&quot;opcode#Eq&quot;&gt;Eq&lt;/a&gt; comparison on the same two operands would have be NULL or false (0), then then jump to P2. If the result of an &lt;a href=&quot;opcode#Eq&quot;&gt;Eq&lt;/a&gt; comparison on the two previous operands would have been true (1), then fall through.</source>
          <target state="translated">Этот код операции должен следовать сразу за оператором сравнения &lt;a href=&quot;opcode#Lt&quot;&gt;Lt&lt;/a&gt; или &lt;a href=&quot;opcode#Gt&quot;&gt;Gt&lt;/a&gt; . Если результат сравнения &lt;a href=&quot;opcode#Eq&quot;&gt;Eq&lt;/a&gt; для тех же двух операндов будет NULL или false (0), тогда перейдите к P2. Если бы результат сравнения &lt;a href=&quot;opcode#Eq&quot;&gt;Eq&lt;/a&gt; для двух предыдущих операндов был бы истинным (1), тогда не получится.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
