<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="sqlite">
    <body>
      <group id="sqlite">
        <trans-unit id="84d99b586ac4808874504752037c1f68b1dc681c" translate="yes" xml:space="preserve">
          <source>If a &quot;truncate file&quot; operation is executed by SQLite, and then the truncated file</source>
          <target state="translated">Если операция &quot;Усеченный файл&quot; выполняется SQLite,а затем усеченный файл</target>
        </trans-unit>
        <trans-unit id="a177cd3b97251df1bda061d91a729d6e25be393e" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;../wal#walfile&quot;&gt;WAL file&lt;/a&gt; remains on disk after all database connections close (either through the use of the &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlpersistwal&quot;&gt;SQLITE_FCNTL_PERSIST_WAL&lt;/a&gt;&lt;a href=&quot;file_control&quot;&gt;file control&lt;/a&gt; or because the last process to have the database opened exited without calling &lt;a href=&quot;close&quot;&gt;sqlite3_close()&lt;/a&gt;) and a new connection is subsequently opened on that database and &lt;a href=&quot;../wal#walfile&quot;&gt;WAL file&lt;/a&gt;, the &lt;a href=&quot;snapshot_open&quot;&gt;sqlite3_snapshot_open()&lt;/a&gt; interface will only be able to open the last transaction added to the WAL file even though the WAL file contains other valid transactions.</source>
          <target state="translated">Если &lt;a href=&quot;../wal#walfile&quot;&gt;файл WAL&lt;/a&gt; остается на диске после закрытия всех подключений к базе данных (либо с помощью &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlpersistwal&quot;&gt;файлового элемента &lt;/a&gt;&lt;a href=&quot;file_control&quot;&gt;управления &lt;/a&gt;SQLITE_FCNTL_PERSIST_WAL, либо из-за того, что последний процесс, открывший базу данных, завершился без вызова &lt;a href=&quot;close&quot;&gt;sqlite3_close ()&lt;/a&gt; ), а затем с этой базой данных открывается новое соединение и &lt;a href=&quot;../wal#walfile&quot;&gt;WAL&lt;/a&gt; , интерфейс &lt;a href=&quot;snapshot_open&quot;&gt;sqlite3_snapshot_open ()&lt;/a&gt; сможет открыть только последнюю транзакцию, добавленную в файл WAL, даже если файл WAL содержит другие допустимые транзакции.</target>
        </trans-unit>
        <trans-unit id="ce5e78d94d5947b9e328c1516e3f265b0f48637a" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; is generated from &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; then the statement is automatically re-prepared if the schema changes, up to &lt;a href=&quot;compile#max_schema_retry&quot;&gt;SQLITE_MAX_SCHEMA_RETRY&lt;/a&gt; times (default: 50). The &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; interface will only return SQLITE_SCHEMA back to the application if the failure persists after these many retries.</source>
          <target state="translated">Если &lt;a href=&quot;c3ref/stmt&quot;&gt;подготовленный оператор&lt;/a&gt; генерируется из &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2 (),&lt;/a&gt; тогда оператор автоматически повторно готовится, если схема изменяется, до &lt;a href=&quot;compile#max_schema_retry&quot;&gt;SQLITE_MAX_SCHEMA_RETRY&lt;/a&gt; раз (по умолчанию: 50). Интерфейс &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step ()&lt;/a&gt; вернет SQLITE_SCHEMA обратно приложению только в том случае, если сбой сохраняется после этих многочисленных попыток.</target>
        </trans-unit>
        <trans-unit id="3249186023e31b2ef81a917670edb42184c4e1e6" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt; operation occurs on the same &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; as a pending read or write, then the pending read or write may fail with an SQLITE_ABORT or &lt;a href=&quot;rescode#abort_rollback&quot;&gt;SQLITE_ABORT_ROLLBACK&lt;/a&gt; error.</source>
          <target state="translated">Если операция &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt; происходит в том же &lt;a href=&quot;c3ref/sqlite3&quot;&gt;соединении с базой данных,&lt;/a&gt; что и ожидающее чтение или запись, то ожидающее чтение или запись может завершиться ошибкой SQLITE_ABORT или &lt;a href=&quot;rescode#abort_rollback&quot;&gt;SQLITE_ABORT_ROLLBACK&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a092e1c1463db0502720c4f04f6df73156ddbd46" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;wal#walfile&quot;&gt;WAL file&lt;/a&gt; remains on disk after all database connections close (either through the use of the &lt;a href=&quot;#sqlitefcntlpersistwal&quot;&gt;SQLITE_FCNTL_PERSIST_WAL&lt;/a&gt;&lt;a href=&quot;#sqlite3_file_control&quot;&gt;file control&lt;/a&gt; or because the last process to have the database opened exited without calling &lt;a href=&quot;#sqlite3_close&quot;&gt;sqlite3_close()&lt;/a&gt;) and a new connection is subsequently opened on that database and &lt;a href=&quot;wal#walfile&quot;&gt;WAL file&lt;/a&gt;, the &lt;a href=&quot;#sqlite3_snapshot_open&quot;&gt;sqlite3_snapshot_open()&lt;/a&gt; interface will only be able to open the last transaction added to the WAL file even though the WAL file contains other valid transactions.</source>
          <target state="translated">Если &lt;a href=&quot;wal#walfile&quot;&gt;файл WAL&lt;/a&gt; остается на диске после закрытия всех подключений к базе данных (либо с помощью &lt;a href=&quot;#sqlitefcntlpersistwal&quot;&gt;файлового элемента &lt;/a&gt;&lt;a href=&quot;#sqlite3_file_control&quot;&gt;управления &lt;/a&gt;SQLITE_FCNTL_PERSIST_WAL, либо из-за того, что последний процесс, открывший базу данных, завершился без вызова &lt;a href=&quot;#sqlite3_close&quot;&gt;sqlite3_close ()&lt;/a&gt; ), а затем с этой базой данных открывается новое соединение и &lt;a href=&quot;wal#walfile&quot;&gt;WAL&lt;/a&gt; , интерфейс &lt;a href=&quot;#sqlite3_snapshot_open&quot;&gt;sqlite3_snapshot_open ()&lt;/a&gt; сможет открыть только последнюю транзакцию, добавленную в файл WAL, даже если файл WAL содержит другие допустимые транзакции.</target>
        </trans-unit>
        <trans-unit id="fa0658f406309a7c36c783a199e98aa7bfe2c3be" translate="yes" xml:space="preserve">
          <source>If a BEFORE UPDATE or BEFORE DELETE trigger modifies or deletes a row that was to have been updated or deleted, then the result of the subsequent update or delete operation is undefined. Furthermore, if a BEFORE trigger modifies or deletes a row, then it is undefined whether or not AFTER triggers that would have otherwise run on those rows will in fact run.</source>
          <target state="translated">Если триггер BEFORE UPDATE или BEFORE DELETE изменяет или удаляет строку,которая должна была быть обновлена или удалена,то результат последующей операции обновления или удаления не определяется.Более того,если триггер BEFORE изменяет или удаляет строку,то не определено,будут ли на самом деле выполняться триггеры,которые в противном случае должны были бы выполняться на этих строках.</target>
        </trans-unit>
        <trans-unit id="a3ab52a71f2c1fab71f9f4f7d4dd870ab7b02c55" translate="yes" xml:space="preserve">
          <source>If a COMMIT statement (or the RELEASE of a transaction SAVEPOINT) fails because the database is currently in a state that violates a deferred foreign key constraint and there are currently &lt;a href=&quot;lang_savepoint&quot;&gt;nested savepoints&lt;/a&gt;, the nested savepoints remain open.</source>
          <target state="translated">Если оператор COMMIT (или RELEASE транзакции SAVEPOINT) завершается неудачно, потому что база данных в настоящее время находится в состоянии, которое нарушает ограничение отложенного внешнего ключа, и в настоящее время существуют &lt;a href=&quot;lang_savepoint&quot;&gt;вложенные точки сохранения&lt;/a&gt; , вложенные точки сохранения остаются открытыми.</target>
        </trans-unit>
        <trans-unit id="4862567128635ae0bf91b3eee8827f7e081e0187" translate="yes" xml:space="preserve">
          <source>If a DELETE statement has a LIMIT clause, the maximum number of rows that will be deleted is found by evaluating the accompanying expression and casting it to an integer value. If the result of the evaluating the LIMIT clause cannot be losslessly converted to an integer value, it is an error. A negative LIMIT value is interpreted as &quot;no limit&quot;. If the DELETE statement also has an OFFSET clause, then it is similarly evaluated and cast to an integer value. Again, it is an error if the value cannot be losslessly converted to an integer. If there is no OFFSET clause, or the calculated integer value is negative, the effective OFFSET value is zero.</source>
          <target state="translated">Если оператор DELETE имеет выражение LIMIT,максимальное количество строк,которые будут удалены,будет найдено путем вычисления сопровождающего выражения и приведения его к целому значению.Если результат вычисления выражения LIMIT не может быть без потерь преобразован в целое значение,это является ошибкой.Отрицательное значение LIMIT интерпретируется как &quot;нет предела&quot;.Если оператор DELETE также имеет условие OFFSET,то он вычисляется аналогичным образом и приводится к целому значению.Опять же,это ошибка,если значение не может быть без потерь преобразовано в целое число.Если отсутствует выражение OFFSET или вычисленное целое значение имеет отрицательное значение,то эффективное значение OFFSET равно нулю.</target>
        </trans-unit>
        <trans-unit id="a8ebe41fb4265f7abee56db5ee7b5c4f78f4ea2f" translate="yes" xml:space="preserve">
          <source>If a FILTER clause is provided, then only rows for which the</source>
          <target state="translated">Если предусмотрено условие FILTER,то только те строки,для которых</target>
        </trans-unit>
        <trans-unit id="94816fac33b04eac89bfe331f82f9493ef356c93" translate="yes" xml:space="preserve">
          <source>If a FROM clause is specified, the data on which a simple SELECT query operates comes from the one or more tables or subqueries (SELECT statements in parentheses) specified following the FROM keyword. A subquery specified in the table-or-subquery following the FROM clause in a simple SELECT statement is handled as if it was a table containing the data returned by executing the subquery statement. Each column of the subquery has the &lt;a href=&quot;datatype3#collation&quot;&gt;collation sequence&lt;/a&gt; and &lt;a href=&quot;datatype3#affinity&quot;&gt;affinity&lt;/a&gt; of the corresponding expression in the subquery statement.</source>
          <target state="translated">Если указано предложение FROM, данные, с которыми работает простой запрос SELECT, берутся из одной или нескольких таблиц или подзапросов (операторы SELECT в скобках), указанных после ключевого слова FROM. Подзапрос, указанный в таблице или подзапросе, следующей за предложением FROM в простом операторе SELECT, обрабатывается так, как если бы это была таблица, содержащая данные, возвращенные при выполнении оператора подзапроса. Каждый столбец подзапроса имеет &lt;a href=&quot;datatype3#collation&quot;&gt;последовательность сортировки&lt;/a&gt; и &lt;a href=&quot;datatype3#affinity&quot;&gt;сродство&lt;/a&gt; соответствующего выражения в операторе подзапросов.</target>
        </trans-unit>
        <trans-unit id="257e2a863a3526135a72b7350cb70ec4620d0ce5" translate="yes" xml:space="preserve">
          <source>If a HAVING clause is specified, it is evaluated once for each group of rows as a &lt;a href=&quot;lang_expr#booleanexpr&quot;&gt;boolean expression&lt;/a&gt;. If the result of evaluating the HAVING clause is false, the group is discarded. If the HAVING clause is an aggregate expression, it is evaluated across all rows in the group. If a HAVING clause is a non-aggregate expression, it is evaluated with respect to an arbitrarily selected row from the group. The HAVING expression may refer to values, even aggregate functions, that are not in the result.</source>
          <target state="translated">Если указано предложение HAVING, оно оценивается один раз для каждой группы строк как &lt;a href=&quot;lang_expr#booleanexpr&quot;&gt;логическое выражение&lt;/a&gt; . Если результат оценки предложения HAVING ложный, группа отбрасывается. Если предложение HAVING является агрегатным выражением, оно оценивается по всем строкам в группе. Если предложение HAVING является неагрегатным выражением, оно оценивается относительно произвольно выбранной строки из группы. Выражение HAVING может относиться к значениям, даже агрегатным функциям, которых нет в результате.</target>
        </trans-unit>
        <trans-unit id="30445e74b001ab802719baf4ad36071ade7519f0" translate="yes" xml:space="preserve">
          <source>If a LIMIT clause is present, it might be possible to avoid scanning the entire table.</source>
          <target state="translated">При наличии пункта LIMIT,возможно,удастся избежать сканирования всей таблицы.</target>
        </trans-unit>
        <trans-unit id="948b4ac14d2baa3362d0ca28f059b73564c6f3e7" translate="yes" xml:space="preserve">
          <source>If a Linux &lt;a href=&quot;http://en.wikipedia.org/wiki/Ext3&quot;&gt;ext3&lt;/a&gt; filesystem is mounted without the &quot;barrier=1&quot; option in the &lt;a href=&quot;http://en.wikipedia.org/wiki/fstab&quot;&gt;/etc/fstab&lt;/a&gt; and the disk drive write cache is enabled then filesystem corruption can occur following a power loss or OS crash. Whether or not corruption can occur depends on the details of the disk control hardware; corruption is more likely with inexpensive consumer-grade disks and less of a problem for enterprise-class storage devices with advanced features such as non-volatile write caches. Various ext3 experts &lt;a href=&quot;http://www.redhat.com/archives/ext3-users/2010-July/msg00001.html&quot;&gt; confirm this behavior&lt;/a&gt;. We are told that most Linux distributions do not use barrier=1 and do not disable the write cache so most Linux distributions are vulnerable to this problem. Note that this is an operating system and hardware issue and that there is nothing that SQLite can do to work around it. &lt;a href=&quot;http://ozlabs.org/~rusty/index.cgi/tech/2009-10-20.html&quot;&gt; Other database engines&lt;/a&gt; have also run into this same problem.</source>
          <target state="translated">Если файловая система Linux &lt;a href=&quot;http://en.wikipedia.org/wiki/Ext3&quot;&gt;ext3&lt;/a&gt; смонтирована без параметра &quot;барьер = 1&quot; в &lt;a href=&quot;http://en.wikipedia.org/wiki/fstab&quot;&gt;файле / etc / fstab&lt;/a&gt; и включен кэш записи на диск, то повреждение файловой системы может произойти после потери питания или сбоя ОС. Может ли произойти повреждение, зависит от деталей оборудования управления диском; повреждение более вероятно с недорогими дисками потребительского уровня и меньше проблем для устройств хранения корпоративного класса с расширенными функциями, такими как энергонезависимые кэши записи. Различные эксперты ext3 &lt;a href=&quot;http://www.redhat.com/archives/ext3-users/2010-July/msg00001.html&quot;&gt;подтверждают такое поведение&lt;/a&gt;. Нам говорят, что в большинстве дистрибутивов Linux не используется ограничение = 1 и не отключается кэш записи, поэтому большинство дистрибутивов Linux уязвимы для этой проблемы. Обратите внимание, что это проблема операционной системы и оборудования, и SQLite ничего не может сделать для ее решения. &lt;a href=&quot;http://ozlabs.org/~rusty/index.cgi/tech/2009-10-20.html&quot;&gt;Другие движки баз данных&lt;/a&gt; также столкнулись с той же проблемой.</target>
        </trans-unit>
        <trans-unit id="99b0a8e8602a0a06983153315092cfd9796ad41e" translate="yes" xml:space="preserve">
          <source>If a NOT NULL constraint is specified, then the column must have a default value other than NULL.</source>
          <target state="translated">Если указано ограничение NOT NULL,то столбец должен иметь значение по умолчанию,отличное от NULL.</target>
        </trans-unit>
        <trans-unit id="55be5a331b8cf28f9f746d3f7eb6341aa17eff02" translate="yes" xml:space="preserve">
          <source>If a SELECT query contains an ORDER BY, GROUP BY or DISTINCT clause, SQLite may need to use a temporary b-tree structure to sort the output rows. Or, it might &lt;a href=&quot;queryplanner#sorting&quot;&gt;use an index&lt;/a&gt;. Using an index is almost always much more efficient than performing a sort. If a temporary b-tree is required, a record is added to the EXPLAIN QUERY PLAN output with the &quot;detail&quot; field set to a string value of the form &quot;USE TEMP B-TREE FOR xxx&quot;, where xxx is one of &quot;ORDER BY&quot;, &quot;GROUP BY&quot; or &quot;DISTINCT&quot;. For example:</source>
          <target state="translated">Если запрос SELECT содержит предложение ORDER BY, GROUP BY или DISTINCT, SQLite может потребоваться использовать временную структуру b-дерева для сортировки выходных строк. Или он может &lt;a href=&quot;queryplanner#sorting&quot;&gt;использовать index&lt;/a&gt; . Использование индекса почти всегда намного эффективнее, чем выполнение сортировки. Если требуется временное b-дерево, к выходным данным EXPLAIN QUERY PLAN добавляется запись с полем &quot;detail&quot;, установленным на строковое значение формы &quot;USE TEMP B-TREE FOR xxx&quot;, где xxx - одно из &quot;ORDER&quot; ПО &quot;,&quot; ГРУППА ПО &quot;или&quot; ОТЛИЧИТЕЛЬНО &quot;. Например:</target>
        </trans-unit>
        <trans-unit id="5b44dbe4fb9e1c6ef0606b8af702048ca0e438cc" translate="yes" xml:space="preserve">
          <source>If a SELECT statement that returns more than one row does not have an ORDER BY clause, the order in which the rows are returned is undefined. Or, if a SELECT statement does have an ORDER BY clause, then the list of expressions attached to the ORDER BY determine the order in which rows are returned to the user.</source>
          <target state="translated">Если оператор SELECT,возвращающий более одной строки,не имеет пункта ORDER BY,порядок,в котором возвращаются строки,не определен.Или,если оператор SELECT имеет пункт ORDER BY,то список выражений,приложенный к оператору ORDER BY,определяет порядок,в котором строки возвращаются пользователю.</target>
        </trans-unit>
        <trans-unit id="1b3cef981ef6c33ad4faa712cdaf3b903f15861f" translate="yes" xml:space="preserve">
          <source>If a UNION operator connects the initial-select with the recursive-select, then only add rows to the queue if no identical row has been previously added to the queue. Repeated rows are discarded before being added to the queue even if the repeated rows have already been extracted from the queue by the recursion step. If the operator is UNION ALL, then all rows generated by both the initial-select and the recursive-select are always added to the queue even if they are repeats. When determining if a row is repeated, NULL values compare equal to one another and not equal to any other value.</source>
          <target state="translated">Если оператор UNION соединяет начальный выбор с рекурсивным,то добавлять строки в очередь можно только в том случае,если ранее в очередь не было добавлено ни одной идентичной строки.Повторяющиеся строки отбрасываются перед добавлением в очередь,даже если повторяющиеся строки уже были извлечены из очереди по шагу рекурсии.Если оператор UNION ALL,то все строки,сгенерированные как начальным выбором,так и рекурсивным,всегда добавляются в очередь,даже если они повторяются.При определении,повторяется ли строка,NULL-значения сравниваются,равные друг другу и не равные никакому другому значению.</target>
        </trans-unit>
        <trans-unit id="56d92b47e4081e5a6e548ebb6f898e186d052899" translate="yes" xml:space="preserve">
          <source>If a WHEN clause is supplied, the SQL statements specified are only executed if the WHEN clause is true. If no WHEN clause is supplied, the SQL statements are executed every time the trigger fires.</source>
          <target state="translated">Если поставляется условие WHEN,то указанные SQL-операторы выполняются только в том случае,если условие WHEN верно.Если же условие WHEN отсутствует,то SQL-операторы выполняются каждый раз при срабатывании триггера.</target>
        </trans-unit>
        <trans-unit id="85a070271019d9b24039a7b30649256cb4c49fd9" translate="yes" xml:space="preserve">
          <source>If a WHERE clause is specified, the WHERE expression is evaluated for each row in the input data as a &lt;a href=&quot;lang_expr#booleanexpr&quot;&gt;boolean expression&lt;/a&gt;. Only rows for which the WHERE clause expression evaluates to true are included from the dataset before continuing. Rows are excluded from the result if the WHERE clause evaluates to either false or NULL.</source>
          <target state="translated">Если указано предложение WHERE, выражение WHERE оценивается для каждой строки входных данных как &lt;a href=&quot;lang_expr#booleanexpr&quot;&gt;логическое выражение&lt;/a&gt; . Перед продолжением из набора данных включаются только строки, для которых выражение предложения WHERE имеет значение true. Строки исключаются из результата, если предложение WHERE принимает значение false или NULL.</target>
        </trans-unit>
        <trans-unit id="99314068471e46954e8f897765afda682981e6bc" translate="yes" xml:space="preserve">
          <source>If a build of SQLite does not include the FTS modules, then any attempt to prepare an SQL statement to create an FTS3 or FTS4 table or to drop or access an existing FTS table in any way will fail. The error message returned will be similar to &quot;no such module: ftsN&quot; (where N is either 3 or 4).</source>
          <target state="translated">Если сборка SQLite не включает в себя модули FTS,то любая попытка подготовить SQL-оператор для создания таблицы FTS3 или FTS4 или бросить существующую таблицу FTS или получить к ней доступ каким-либо образом будет безуспешной.Возвращаемое сообщение об ошибке будет похоже на &quot;нет такого модуля:ftsN&quot; (где N-3 или 4).</target>
        </trans-unit>
        <trans-unit id="c07dc39ee71e6a6e8537165278b706aabd6e81bd" translate="yes" xml:space="preserve">
          <source>If a call to sqlite3_step() that attempts to write to a database table returns SQLITE_LOCKED, then more than one other connection may be holding a read-lock on the database table in question. In this case SQLite simply selects one of those other connections arbitrarily and issues the unlock-notify callback when that connection's transaction is finished. Whether the call to sqlite3_step() was blocked by one or many connections, when the corresponding unlock-notify callback is issued it is not guaranteed that the required lock is available, only that it may be.</source>
          <target state="translated">Если при вызове sqlite3_step(),который пытается записать в таблицу БД,возвращается SQLITE_LOCKED,то в рассматриваемой таблице БД может находиться несколько других соединений,которые удерживают блокировку на чтение.В этом случае SQLite просто произвольно выбирает одно из этих других соединений и по завершении транзакции этого соединения выдает обратный вызов с уведомлением о разблокировке.Был ли вызов sqlite3_step()заблокирован одним или несколькими соединениями,при соответствующем обратном вызове unlock-notify не гарантируется,что требуемая блокировка доступна,а только то,что она может быть.</target>
        </trans-unit>
        <trans-unit id="12e866adc40a794d5a50cd7647771628a0fe472b" translate="yes" xml:space="preserve">
          <source>If a character specified as part of the argument to &quot;tokenchars=&quot; is considered to be a token character by default, it is ignored. This is true even if it has been marked as a separator by an earlier &quot;separators=&quot; option. Similarly, if a character specified as part of a &quot;separators=&quot; option is treated as a separator character by default, it is ignored. If multiple &quot;tokenchars=&quot; or &quot;separators=&quot; options are specified, all are processed. For example:</source>
          <target state="translated">Если символ,указанный в аргументе &quot;tokenchars=&quot;,по умолчанию считается символом токена,то он игнорируется.Это справедливо,даже если он был помечен как разделитель более ранней опцией &quot;separators=&quot;.Аналогично,если символ,указанный как часть опции &quot;separators=&quot;,по умолчанию рассматривается как символ-разделитель,то он игнорируется.Если указано несколько опций &quot;tokenchars=&quot; или &quot;separators=&quot;,то все они будут обработаны.Например:</target>
        </trans-unit>
        <trans-unit id="4047a69992390b90bb1e651abb363899dad3ce20" translate="yes" xml:space="preserve">
          <source>If a collating function fails any of the above constraints and that collating function is registered and used, then the behavior of SQLite is undefined.</source>
          <target state="translated">Если функция коллатинга не справляется с любым из вышеперечисленных ограничений и эта функция коллатинга регистрируется и используется,то поведение SQLite не определено.</target>
        </trans-unit>
        <trans-unit id="4a25d30fe6f01a94e32b9a3c4b8ab96f2806f18f" translate="yes" xml:space="preserve">
          <source>If a column datatype contains the special keyword &quot;HIDDEN&quot; (in any combination of upper and lower case letters) then that keyword it is omitted from the column datatype name and the column is marked as a hidden column internally. A hidden column differs from a normal column in three respects:</source>
          <target state="translated">Если тип данных столбца содержит специальное ключевое слово &quot;HIDDEN&quot; (в любой комбинации заглавных и строчных букв),то это ключевое слово опускается из названия типа данных столбца и столбец помечается как скрытый внутри него.Скрытый столбец отличается от обычного в трех отношениях:</target>
        </trans-unit>
        <trans-unit id="4a3060f5f06633a8fd81221c196cda03a0efe5c5" translate="yes" xml:space="preserve">
          <source>If a column filter specification is preceded by a &quot;-&quot; character, then it is interpreted as a list of column not to match against. For example:</source>
          <target state="translated">Если спецификации фильтра по столбцам предшествует символ &quot;-&quot;,то он интерпретируется как список столбцов,которым не соответствует.Например:</target>
        </trans-unit>
        <trans-unit id="4784be250e1d29a9c62d93440a67186e8f2d433e" translate="yes" xml:space="preserve">
          <source>If a column has the type INTEGER PRIMARY KEY AUTOINCREMENT then a slightly different ROWID selection algorithm is used. The ROWID chosen for the new row is at least one larger than the largest ROWID that has ever before existed in that same table. If the table has never before contained any data, then a ROWID of 1 is used. If the largest possible ROWID has previously been inserted, then new INSERTs are not allowed and any attempt to insert a new row will fail with an SQLITE_FULL error. Only ROWID values from previous transactions that were committed are considered. ROWID values that were rolled back are ignored and can be reused.</source>
          <target state="translated">Если колонка имеет тип INTEGER PRIMARY KEY AUTOINCREMENT,то используется немного другой алгоритм выбора ROWID.ROWID,выбранный для новой строки,по крайней мере,на один больше,чем самый большой ROWID,который когда-либо существовал в той же самой таблице.Если таблица никогда раньше не содержала данных,то используется ROWID равный 1.Если ранее был вставлен самый большой ROWID,то новые INSERT не разрешены и любая попытка вставить новую строку будет неудачной с ошибкой SQLITE_FULL.Учитываются только значения ROWID из предыдущих транзакций,которые были зафиксированы.Значения ROWID,которые были откачены,игнорируются и могут быть использованы повторно.</target>
        </trans-unit>
        <trans-unit id="85779fa11fd249fc0a9433b1c9e912b143d1abd7" translate="yes" xml:space="preserve">
          <source>If a column-name list follows the view-name, then that list determines the names of the columns for the view. If the column-name list is omitted, then the names of the columns in the view are derived from the names of the result-set columns in the &lt;a href=&quot;syntax/select-stmt&quot;&gt;select-stmt&lt;/a&gt;. The use of column-name list is recommended. Or, if column-name list is omitted, then the result columns in the &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statement that defines the view should have well-defined names using the &quot;&lt;a href=&quot;syntax/result-column&quot;&gt;AS column-alias&lt;/a&gt;&quot; syntax. SQLite allows you to create views that depend on automatically generated column names, but you should avoid using them since the rules used to generate column names are not a defined part of the interface and might change in future releases of SQLite.</source>
          <target state="translated">Если список имен столбцов следует за именем представления, то этот список определяет имена столбцов для представления. Если список имен столбцов опущен, тогда имена столбцов в представлении являются производными от имен столбцов набора результатов в &lt;a href=&quot;syntax/select-stmt&quot;&gt;select-stmt&lt;/a&gt; . Рекомендуется использовать список имен столбцов. Или, если список имен столбцов опущен, тогда столбцы результатов в &lt;a href=&quot;lang_select&quot;&gt;операторе SELECT&lt;/a&gt; , определяющем представление, должны иметь четко определенные имена с использованием синтаксиса &amp;laquo; &lt;a href=&quot;syntax/result-column&quot;&gt;псевдоним столбца AS&lt;/a&gt; &amp;raquo;. SQLite позволяет создавать представления, которые зависят от автоматически сгенерированных имен столбцов, но вам следует избегать их использования, поскольку правила, используемые для генерации имен столбцов, не являются определенной частью интерфейса и могут измениться в будущих выпусках SQLite.</target>
        </trans-unit>
        <trans-unit id="7f7aaafed42977493a2413f4303512821df4e3b2" translate="yes" xml:space="preserve">
          <source>If a conflict handler returns this value no special action is taken. The change that caused the conflict is not applied. The session module continues to the next change in the changeset.</source>
          <target state="translated">Если обработчик конфликта возвращает это значение,никаких специальных действий не предпринимается.Изменение,которое вызвало конфликт,не применяется.Сеансовый модуль переходит к следующему изменению в changeset.</target>
        </trans-unit>
        <trans-unit id="a40b2d39f56dad1b134a26af2fe2ae696281adc1" translate="yes" xml:space="preserve">
          <source>If a covering index can be used for a query, then the multiple rowid lookups can be avoided and the cost of the query drops dramatically.</source>
          <target state="translated">Если для запроса можно использовать индекс покрытия,то можно избежать многократного поиска и стоимость запроса резко падает.</target>
        </trans-unit>
        <trans-unit id="653b4381ff1ad3607fbc3061d7b4f5d80ed74deb" translate="yes" xml:space="preserve">
          <source>If a crash or power failure occurs and results in a hot journal but that journal is deleted, the next process to open the database will not know that it contains changes that need to be rolled back. The rollback will not occur and the database will be left in an inconsistent state. Rollback journals might be deleted for any number of reasons:</source>
          <target state="translated">Если произойдет авария или сбой электропитания и в результате будет создан &quot;горячий&quot; журнал,но этот журнал будет удален,то следующий процесс открытия базы данных не будет знать о том,что в ней содержатся изменения,которые необходимо откатить.Откат не произойдет,и база данных останется в непоследовательном состоянии.Откатные журналы могут быть удалены по любой причине:</target>
        </trans-unit>
        <trans-unit id="dbc53ced19579b45a05b723b3063167292a44232" translate="yes" xml:space="preserve">
          <source>If a crash or power loss does occur and a hot journal is left on the disk, it is essential that the original database file and the hot journal remain on disk with their original names until the database file is opened by another SQLite process and rolled back. During recovery at &lt;a href=&quot;#section_4_2&quot;&gt;step 4.2&lt;/a&gt; SQLite locates the hot journal by looking for a file in the same directory as the database being opened and whose name is derived from the name of the file being opened. If either the original database file or the hot journal have been moved or renamed, then the hot journal will not be seen and the database will not be rolled back.</source>
          <target state="translated">Если происходит сбой или отключение питания и на диске остается горячий журнал, важно, чтобы исходный файл базы данных и горячий журнал оставались на диске с их исходными именами до тех пор, пока файл базы данных не будет открыт другим процессом SQLite и откат . Во время восстановления на &lt;a href=&quot;#section_4_2&quot;&gt;шаге 4.2&lt;/a&gt; SQLite находит &amp;laquo;горячий журнал&amp;raquo;, ища файл в том же каталоге, что и открываемая база данных, имя которого происходит от имени открываемого файла. Если исходный файл базы данных или горячий журнал были перемещены или переименованы, то горячий журнал не будет виден, и база данных не будет откатана.</target>
        </trans-unit>
        <trans-unit id="fb8183919d1fc07417b2707b8092ba7a7a08090d" translate="yes" xml:space="preserve">
          <source>If a crash or power loss occurs in the middle of a transaction, then the rollback journal file is left on disk. The next time another application attempts to open the database file, it notices the presence of the abandoned rollback journal (we call it a &quot;hot journal&quot; in this circumstance) and uses the information in the journal to restore the database to its state prior to the start of the incomplete transaction. This is how SQLite implements atomic commit.</source>
          <target state="translated">Если в середине транзакции происходит сбой или отключение питания,то файл журнала отката остается на диске.При следующей попытке открытия файла базы данных другое приложение замечает наличие заброшенного журнала отката (в данном случае мы называем его &quot;горячим журналом&quot;)и использует содержащуюся в нем информацию для восстановления базы данных до ее состояния до начала незавершенной транзакции.Именно так SQLite реализует атомарный коммит.</target>
        </trans-unit>
        <trans-unit id="ac9f0e2592a2df4c51e939a4b5d49b41b7d7ebcb" translate="yes" xml:space="preserve">
          <source>If a database connection is opened with the &quot;-uri 1&quot; option, then &lt;a href=&quot;uri&quot;&gt;URI filenames&lt;/a&gt; are honored by the &quot;backup&quot; and &quot;restore&quot; commands.</source>
          <target state="translated">Если соединение с базой данных открывается с параметром &amp;laquo;-uri 1&amp;raquo;, то &lt;a href=&quot;uri&quot;&gt;имена файлов URI&lt;/a&gt; учитываются командами &amp;laquo;backup&amp;raquo; и &amp;laquo;restore&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="d5923feff2a2aef8fc7abf4f600aff34fc785066" translate="yes" xml:space="preserve">
          <source>If a database connection is operating in &lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;exclusive locking mode&lt;/a&gt; or in &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;persistent journal mode&lt;/a&gt; (PRAGMA journal_mode=persist) then after committing a transaction the &lt;a href=&quot;lockingv3#rollback&quot;&gt;rollback journal&lt;/a&gt; file may remain in the file-system. This increases performance for subsequent transactions since overwriting an existing file is faster than append to a file, but it also consumes file-system space. After a large transaction (e.g. a &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt;), the rollback journal file may consume a very large amount of space.</source>
          <target state="translated">Если соединение с базой данных работает в &lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;режиме эксклюзивной блокировки&lt;/a&gt; или в режиме &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;постоянного журнала&lt;/a&gt; (PRAGMA journal_mode = persist), то после фиксации транзакции файл &lt;a href=&quot;lockingv3#rollback&quot;&gt;журнала отката&lt;/a&gt; может остаться в файловой системе. Это увеличивает производительность для последующих транзакций, поскольку перезапись существующего файла выполняется быстрее, чем добавление в файл, но при этом также расходуется пространство файловой системы. После большой транзакции (например, &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; ) файл журнала отката может занимать очень много места.</target>
        </trans-unit>
        <trans-unit id="5f55f04439258c2d344a35f29269aa9db3e5202b" translate="yes" xml:space="preserve">
          <source>If a database file is accessed using 8+3 naming rather than the default long filename, then it must be consistently accessed using 8+3 naming by every database connection every time it is opened, or else there is a risk of database corruption. The auxiliary &lt;a href=&quot;lockingv3#rollback&quot;&gt;rollback journal&lt;/a&gt; and &lt;a href=&quot;wal&quot;&gt;write-ahead log&lt;/a&gt; files are essential to SQLite for being about to recover from a crash. If an application is using 8+3 names and crashes, then the information needed to safely recover from the crash is stored in files with the &quot;&lt;code&gt;.nal&lt;/code&gt;&quot; or &quot;&lt;code&gt;.wal&lt;/code&gt;&quot; extension. If the next application to open the database does not specify the &quot;&lt;code&gt;8_3_names=1&lt;/code&gt;&quot; URI parameter, then SQLite will use the long filenames to try to locate the rollback journal or write-ahead log files. It will not find them, since they were saved using 8+3 names by the application that crashed, and hence the database will not be properly recovered and will likely go corrupt.</source>
          <target state="translated">Если доступ к файлу базы данных осуществляется с использованием именования 8 + 3, а не с использованием длинного имени файла по умолчанию, тогда к нему необходимо последовательно обращаться с использованием именования 8 + 3 при каждом подключении к базе данных при каждом его открытии, иначе существует риск повреждения базы данных. Вспомогательный &lt;a href=&quot;lockingv3#rollback&quot;&gt;журнал отката&lt;/a&gt; и файлы &lt;a href=&quot;wal&quot;&gt;журнала упреждающей записи&lt;/a&gt; необходимы SQLite для восстановления после сбоя. Если приложение использует имена 8 + 3 и дает сбой, то информация, необходимая для безопасного восстановления после сбоя, сохраняется в файлах с &lt;code&gt;.nal&lt;/code&gt; &amp;laquo; .nal &amp;raquo; или &amp;laquo; &lt;code&gt;.wal&lt;/code&gt; &amp;raquo;. Если следующее приложение для открытия базы данных не указывает &amp;laquo; &lt;code&gt;8_3_names=1&lt;/code&gt; &quot;Параметр URI, тогда SQLite будет использовать длинные имена файлов, чтобы попытаться найти журнал отката или файлы журнала упреждающей записи. Он не найдет их, поскольку они были сохранены с использованием 8 + 3 имен приложением, в котором произошел сбой, и, следовательно, база данных не будут восстановлены должным образом и, скорее всего, будут повреждены.</target>
        </trans-unit>
        <trans-unit id="bd70a20b8f5f47bbbe011a3bee3a583fecc50caa" translate="yes" xml:space="preserve">
          <source>If a database is written by SQLite version 3.7.0 or later and then written again by SQLite version 3.6.23 or earlier in such a way as to make the size of the database file decrease, then the next time that SQLite version 3.7.0 access the database file, it might report that the database file is corrupt. The database file is not really corrupt, however. Version 3.7.0 was simply being overly zealous in its corruption detection.</source>
          <target state="translated">Если БД написана SQLite версии 3.7.0 или более поздней,а затем снова написана SQLite версии 3.6.23 или более ранней таким образом,что размер файла БД уменьшается,то при следующем обращении SQLite версии 3.7.0 к файлу БД может появиться сообщение о том,что файл БД поврежден.Однако файл базы данных на самом деле не поврежден.Версия 3.7.0 была просто слишком усердной в обнаружении ее повреждений.</target>
        </trans-unit>
        <trans-unit id="c0e8b12ff7ad15986137c5d5f01f4e0ef949a4a6" translate="yes" xml:space="preserve">
          <source>If a database were originally created using SQLite version 3.7.0, then written by SQLite version 3.6.23.1 such that the size of the database file increased, then written again by SQLite version 3.7.0, the database file could go corrupt.</source>
          <target state="translated">Если БД изначально создавалась с использованием SQLite версии 3.7.0,а затем была написана SQLite версии 3.6.23.1 таким образом,что размер файла БД увеличивался,а затем снова написана SQLite версии 3.7.0,то файл БД может выйти из строя.</target>
        </trans-unit>
        <trans-unit id="f7f861f58b781638426cc97ad65bbe6addfa6a62" translate="yes" xml:space="preserve">
          <source>If a keyword in double quotes (ex: &lt;b&gt;&quot;key&quot;&lt;/b&gt; or &lt;b&gt;&quot;glob&quot;&lt;/b&gt;) is used in a context where it cannot be resolved to an identifier but where a string literal is allowed, then the token is understood to be a string literal instead of an identifier.</source>
          <target state="translated">Если ключевое слово в двойных кавычках (например, &lt;b&gt;&amp;laquo;ключ&amp;raquo;&lt;/b&gt; или &lt;b&gt;&amp;laquo;глобус&amp;raquo;&lt;/b&gt; ) используется в контексте, где оно не может быть преобразовано в идентификатор, но где разрешен строковый литерал, тогда токен считается строковым литералом, а не идентификатор.</target>
        </trans-unit>
        <trans-unit id="ff734731d1dd61e745b8c19a93e379fd051ea7fb" translate="yes" xml:space="preserve">
          <source>If a keyword in single quotes (ex: &lt;b&gt;'key'&lt;/b&gt; or &lt;b&gt;'glob'&lt;/b&gt;) is used in a context where an identifier is allowed but where a string literal is not allowed, then the token is understood to be an identifier instead of a string literal.</source>
          <target state="translated">Если ключевое слово в одинарных кавычках (например, &lt;b&gt;'key'&lt;/b&gt; или &lt;b&gt;'glob'&lt;/b&gt; ) используется в контексте, где идентификатор разрешен, но где строковый литерал не разрешен, тогда токен считается идентификатором, а не строковым литералом. .</target>
        </trans-unit>
        <trans-unit id="fd8582b07f28c43cf6305e6462fb4a6db23b8ea7" translate="yes" xml:space="preserve">
          <source>If a matchable phrase is part of a series of phrases connected by NEAR operators in the FTS query expression, then each phrase match must be sufficiently close to other phrase matches of the relevant types to satisfy the NEAR condition.</source>
          <target state="translated">Если совпадающая фраза является частью серии фраз,соединенных операторами NEAR в выражении запроса FTS,то каждое совпадение фраз должно быть достаточно близко к другим совпадениям фраз соответствующих типов для выполнения условия NEAR.</target>
        </trans-unit>
        <trans-unit id="a2a6d03cae632eedbf962d2919113c9e0642d81c" translate="yes" xml:space="preserve">
          <source>If a memory allocation error occurs, sqlite3_create_filename() might return a NULL pointer. The memory obtained from sqlite3_create_filename(X) must be released by a corresponding call to sqlite3_free_filename(Y).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16ba62507a795aad87688bd7a66b598560ff99c0" translate="yes" xml:space="preserve">
          <source>If a named virtual table that uses the dbstat module is desired, then the recommended way to create an instance of the dbstat virtual table is as follows:</source>
          <target state="translated">Если требуется именованная виртуальная таблица,использующая модуль dbstat,то рекомендуемый способ создания экземпляра виртуальной таблицы dbstat следующий:</target>
        </trans-unit>
        <trans-unit id="f0a2ba4a4cc7d08c018b4dbe8137dc10439214b7" translate="yes" xml:space="preserve">
          <source>If a numeric literal has a decimal point or an exponentiation clause or if its magnitude is less than -9223372036854775808 or greater than 9223372036854775807, then it is a floating point literal. Otherwise is it is an integer literal. The &quot;E&quot; character that begins the exponentiation clause of a floating point literal can be either upper or lower case. The &quot;.&quot; character is always used as the decimal point even if the locale setting specifies &quot;,&quot; for this role - the use of &quot;,&quot; for the decimal point would result in syntactic ambiguity.</source>
          <target state="translated">Если числовой литерал имеет десятичную точку или выражение экспоненции,или его величина меньше -9223372036854775808 или больше 9223372036854775807,то он является литералом с плавающей точкой.Иначе это целочисленный литерал.Символ &quot;E&quot;,который начинает выражение выражения литерала с плавающей точкой,может быть как верхним,так и нижним регистром.Символ &quot;...&quot; всегда используется в качестве десятичной точки,даже если в настройках локали указано &quot;,&quot; для этой роли-использование &quot;,&quot; для десятичной точки приведет к синтаксической неоднозначности.</target>
        </trans-unit>
        <trans-unit id="8cf3813aebca15b6b5e1583aeffa06f6925412e6" translate="yes" xml:space="preserve">
          <source>If a page contains no cells (which is only possible for a root page of a table that contains no rows) then the offset to the cell content area will equal the page size minus the bytes of reserved space. If the database uses a 65536-byte page size and the reserved space is zero (the usual value for reserved space) then the cell content offset of an empty page wants to be 65536. However, that integer is too large to be stored in a 2-byte unsigned integer, so a value of 0 is used in its place.</source>
          <target state="translated">Если страница не содержит ячеек (что возможно только для корневой страницы таблицы,не содержащей строк),то смещение к области содержимого ячейки будет равно размеру страницы минус байты зарезервированного пространства.Если в БД используется размер страницы 65536 байт,а зарезервированное пространство равно нулю (обычное значение для зарезервированного пространства),то смещение к ячейке содержимого пустой страницы будет равно 65536.Однако это целое число слишком велико,чтобы храниться в 2-байтовом беззнаковом числе,поэтому вместо него используется значение 0.</target>
        </trans-unit>
        <trans-unit id="c99e07bc95c7e7eeb5ce8d8ce056128a45cab0ab" translate="yes" xml:space="preserve">
          <source>If a parameter name begins with a &quot;:&quot;, then it is assumed to be a value to bind to the SQL statement before executing it. The value is always bound as text. It is an error if the specified SQL parameter does not exist. For example:</source>
          <target state="translated">Если имя параметра начинается с &quot;:&quot;,то предполагается,что это значение привязывается к SQL-оператору перед его выполнением.Значение всегда привязывается в виде текста.Это ошибка,если указанный параметр SQL не существует.Например:</target>
        </trans-unit>
        <trans-unit id="a3a6677c34d1c31ace005a4fa6f3930c2040066e" translate="yes" xml:space="preserve">
          <source>If a power failure or operating system crash occurs at this point, the transaction will not rollback when the system reboots even though there are rollback journals present. The difference is the master journal pathname in the header of the rollback journal. Upon restart, SQLite only considers a journal to be hot and will only playback the journal if there is no master journal filename in the header (which is the case for a single-file commit) or if the master journal file still exists on disk.</source>
          <target state="translated">Если в этот момент произойдет сбой питания или сбой операционной системы,транзакция не откатится при перезагрузке системы,даже несмотря на наличие журналов отката.Разница заключается в том,что в заголовке журнала отката есть главный журнал.При перезагрузке SQLite считает журнал горячим и будет проигрывать его только в том случае,если в заголовке нет имени файла главного журнала (в случае однофайловой фиксации)или если главный файл журнала все еще существует на диске.</target>
        </trans-unit>
        <trans-unit id="df0966ae095afce680bcbe564721893f2e27c89b" translate="yes" xml:space="preserve">
          <source>If a power failure or operating system crash occurs at this point, the transaction will not rollback when the system reboots even though there are rollback journals present. The difference is the super-journal pathname in the header of the rollback journal. Upon restart, SQLite only considers a journal to be hot and will only playback the journal if there is no super-journal filename in the header (which is the case for a single-file commit) or if the super-journal file still exists on disk.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f031e4113363c1780559d56fb503c736f7031cb4" translate="yes" xml:space="preserve">
          <source>If a power failure or operating system failure occurs while copying the database file the backup database may be corrupted following system recovery.</source>
          <target state="translated">Если во время копирования файла базы данных произойдет сбой электропитания или сбой операционной системы,то после восстановления системы резервная база данных может быть повреждена.</target>
        </trans-unit>
        <trans-unit id="d63fd60747c59caf947d214389cf965d0e528d08" translate="yes" xml:space="preserve">
          <source>If a query contains an ORDER BY clause with multiple terms, it might be that SQLite can use indices to cause rows to come out in the order of some prefix of the terms in the ORDER BY but that later terms in the ORDER BY are not satisfied. In that case, SQLite does block sorting. Suppose the ORDER BY clause has four terms and the natural order of the query results in rows appearing in order of the first two terms. As each row is output by the query engine and enters the sorter, the outputs in the current row corresponding to the first two terms of the ORDER BY are compared against the previous row. If they have changed, the current sort is finished and output and a new sort is started. This results in a slightly faster sort. But the bigger advantages are that many fewer rows need to be held in memory, reducing memory requirements, and outputs can begin to appear before the core query has run to completion.</source>
          <target state="translated">Если запрос содержит пункт &quot;ЗАКАЗАТЬ ПО&quot; с несколькими терминами,возможно,SQLite может использовать индексы для вызова строк в порядке некоторого префикса терминов в пункте &quot;ЗАКАЗАТЬ ПО&quot;,но более поздние термины в пункте &quot;ЗАКАЗАТЬ ПО&quot; не удовлетворяются.В этом случае SQLite действительно блокирует сортировку.Предположим,что в пункте &quot;ЗАКАЗЫВАТЬ ПО&quot; имеется четыре термина,и естественный порядок запроса приводит к тому,что строки появляются в порядке первых двух терминов.Поскольку каждая строка выводится механизмом запроса и попадает в сортировщик,результаты в текущей строке,соответствующие первым двум слагаемым пункта &quot;ЗАКАЗАТЬ ВЫБОР&quot;,сравниваются с предыдущей строкой.Если они изменились,то текущий сорт завершается и выводится и начинается новый сорт.В результате сортировка получается немного быстрее.Но большие преимущества заключаются в том,что меньше строк нужно хранить в памяти,что снижает требования к памяти,и результаты могут начать появляться еще до того,как основной запрос будет выполнен.</target>
        </trans-unit>
        <trans-unit id="ec318f6e2d2904b05a3f02946f0559cc8fefaa28" translate="yes" xml:space="preserve">
          <source>If a query contains no aggregate functions at all, then a GROUP BY clause can be added as a substitute for the DISTINCT ON clause. In other words, output rows are filtered so that only one row is shown for each distinct set of values in the GROUP BY clause. If two or more output rows would have otherwise had the same set of values for the GROUP BY columns, then one of the rows is chosen arbitrarily. (SQLite supports DISTINCT but not DISTINCT ON, whose functionality is provided instead by GROUP BY.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdf63c23188158127b26cd2c4807de45ccf6dea6" translate="yes" xml:space="preserve">
          <source>If a query contains no aggregate functions at all, then a GROUP BY clause can be added as a substitute of DISTINCT ON clause. In other words, output rows are filtered so that only one row is shows for each distinct set of values in the GROUP BY clause. If two or more output rows would have otherwise had the same set of values for the GROUP BY columns, then one of the rows is chosen arbitrarily.</source>
          <target state="translated">Если запрос вообще не содержит агрегатных функций,то в качестве замены пункта DISTINCT ON можно добавить пункт GROUP BY.Другими словами,выходные строки фильтруются таким образом,что для каждого отдельного набора значений в пункте GROUP BY отображается только одна строка.Если две или более выходных строк в противном случае имели бы один и тот же набор значений для столбцов GROUP BY,то одна из строк выбирается произвольно.</target>
        </trans-unit>
        <trans-unit id="cab66c0bca9a377eb02b4b0ac5090404c2d874c0" translate="yes" xml:space="preserve">
          <source>If a read/write client invokes &lt;a href=&quot;c3ref/file_control&quot;&gt;sqlite3_file_control&lt;/a&gt;(&lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlpersistwal&quot;&gt;SQLITE_FCNTL_PERSIST_WAL&lt;/a&gt;) prior to shutdown, then at shutdown a checkpoint is still run, but the shm file and wal file are not deleted. This allows subsequent read-only clients to connect to and read the database.</source>
          <target state="translated">Если клиент чтения / записи вызывает &lt;a href=&quot;c3ref/file_control&quot;&gt;sqlite3_file_control&lt;/a&gt; ( &lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlpersistwal&quot;&gt;SQLITE_FCNTL_PERSIST_WAL&lt;/a&gt; ) до завершения работы, то при завершении работы контрольная точка все еще выполняется, но файл shm и файл wal не удаляются. Это позволяет последующим клиентам, доступным только для чтения, подключаться к базе данных и читать ее.</target>
        </trans-unit>
        <trans-unit id="337133b7d09a387cf87665a4c7d79ff39c533386" translate="yes" xml:space="preserve">
          <source>If a row with matching primary key values is found, but one or more of the modified non-primary key fields contains a value different from an original row value stored in the changeset, the conflict-handler function is invoked with &lt;a href=&quot;#SQLITE_CHANGESET_CONFLICT&quot;&gt;SQLITE_CHANGESET_DATA&lt;/a&gt; as the second argument. Since UPDATE changes only contain values for non-primary key fields that are to be modified, only those fields need to match the original values to avoid the SQLITE_CHANGESET_DATA conflict-handler callback.</source>
          <target state="translated">Если строка с совпадающими значениями первичного ключа найдена, но одно или несколько измененных полей непервичного ключа содержат значение, отличное от значения исходной строки, сохраненного в наборе изменений, вызывается функция обработчика конфликтов с &lt;a href=&quot;#SQLITE_CHANGESET_CONFLICT&quot;&gt;SQLITE_CHANGESET_DATA&lt;/a&gt; в качестве второго аргумента . Поскольку изменения UPDATE содержат только значения для полей непервичного ключа, которые должны быть изменены, только эти поля должны соответствовать исходным значениям, чтобы избежать обратного вызова обработчика конфликтов SQLITE_CHANGESET_DATA.</target>
        </trans-unit>
        <trans-unit id="35c7138a2b7260bc49d6f60cf430df710c00202b" translate="yes" xml:space="preserve">
          <source>If a row with matching primary key values is found, but one or more of the modified non-primary key fields contains a value different from an original row value stored in the changeset, the conflict-handler function is invoked with &lt;a href=&quot;c_changeset_conflict&quot;&gt;SQLITE_CHANGESET_DATA&lt;/a&gt; as the second argument. Since UPDATE changes only contain values for non-primary key fields that are to be modified, only those fields need to match the original values to avoid the SQLITE_CHANGESET_DATA conflict-handler callback.</source>
          <target state="translated">Если строка с совпадающими значениями первичного ключа найдена, но одно или несколько измененных полей непервичного ключа содержат значение, отличное от значения исходной строки, сохраненного в наборе изменений, вызывается функция обработчика конфликтов с &lt;a href=&quot;c_changeset_conflict&quot;&gt;SQLITE_CHANGESET_DATA&lt;/a&gt; в качестве второго аргумента . Поскольку изменения UPDATE содержат только значения для полей непервичного ключа, которые должны быть изменены, только эти поля должны соответствовать исходным значениям, чтобы избежать обратного вызова обработчика конфликтов SQLITE_CHANGESET_DATA.</target>
        </trans-unit>
        <trans-unit id="1b234b4b89cfdd9943a23340845cb2723771c58a" translate="yes" xml:space="preserve">
          <source>If a row with matching primary key values is found, but one or more of the non-primary key fields contains a value different from the original row value stored in the changeset, the conflict-handler function is invoked with &lt;a href=&quot;#SQLITE_CHANGESET_CONFLICT&quot;&gt;SQLITE_CHANGESET_DATA&lt;/a&gt; as the second argument. If the database table has more columns than are recorded in the changeset, only the values of those non-primary key fields are compared against the current database contents - any trailing database table columns are ignored.</source>
          <target state="translated">Если найдена строка с совпадающими значениями первичного ключа, но одно или несколько полей непервичного ключа содержат значение, отличное от значения исходной строки, хранящегося в наборе изменений, вызывается функция обработчика конфликтов с &lt;a href=&quot;#SQLITE_CHANGESET_CONFLICT&quot;&gt;SQLITE_CHANGESET_DATA&lt;/a&gt; в качестве второго аргумента. Если в таблице базы данных больше столбцов, чем записано в наборе изменений, только значения этих полей непервичного ключа сравниваются с текущим содержимым базы данных - любые конечные столбцы таблицы базы данных игнорируются.</target>
        </trans-unit>
        <trans-unit id="ca3b8d6b7470e9a00b63341bcac487b0076109fe" translate="yes" xml:space="preserve">
          <source>If a row with matching primary key values is found, but one or more of the non-primary key fields contains a value different from the original row value stored in the changeset, the conflict-handler function is invoked with &lt;a href=&quot;c_changeset_conflict&quot;&gt;SQLITE_CHANGESET_DATA&lt;/a&gt; as the second argument. If the database table has more columns than are recorded in the changeset, only the values of those non-primary key fields are compared against the current database contents - any trailing database table columns are ignored.</source>
          <target state="translated">Если найдена строка с совпадающими значениями первичного ключа, но одно или несколько полей непервичного ключа содержат значение, отличное от значения исходной строки, хранящегося в наборе изменений, вызывается функция обработчика конфликтов с &lt;a href=&quot;c_changeset_conflict&quot;&gt;SQLITE_CHANGESET_DATA&lt;/a&gt; в качестве второго аргумента. Если в таблице базы данных больше столбцов, чем записано в наборе изменений, только значения этих полей непервичного ключа сравниваются с текущим содержимым базы данных - любые конечные столбцы таблицы базы данных игнорируются.</target>
        </trans-unit>
        <trans-unit id="e400ae567f256dbdcc0abe528516e66e2c791942" translate="yes" xml:space="preserve">
          <source>If a schema name is specified as part of an object reference, it must be either &quot;main&quot;, or &quot;temp&quot; or the schema-name of an attached database. Like other SQL identifiers, schema names are case-insensitive. If a schema name is specified, then only that one schema is searched for the named object.</source>
          <target state="translated">Если имя схемы указано как часть ссылки на объект,то оно должно быть либо &quot;основным&quot;,либо &quot;временным&quot;,либо схемным именем подключенной БД.Как и другие SQL-идентификаторы,имена схем не чувствительны к регистру.Если указано имя схемы,то для именованного объекта ищется только одна схема.</target>
        </trans-unit>
        <trans-unit id="a287d9b64545db85e7dfa26422162809454f183b" translate="yes" xml:space="preserve">
          <source>If a schema-name is specified, it must be either &quot;main&quot;, &quot;temp&quot;, or the name of an &lt;a href=&quot;lang_attach&quot;&gt;attached database&lt;/a&gt;. In this case the new table is created in the named database. If the &quot;TEMP&quot; or &quot;TEMPORARY&quot; keyword occurs between the &quot;CREATE&quot; and &quot;TABLE&quot; then the new table is created in the temp database. It is an error to specify both a schema-name and the TEMP or TEMPORARY keyword, unless the schema-name is &quot;temp&quot;. If no schema name is specified and the TEMP keyword is not present then the table is created in the main database.</source>
          <target state="translated">Если указано имя схемы, оно должно быть либо &amp;laquo;main&amp;raquo;, &amp;laquo;temp&amp;raquo;, либо именем &lt;a href=&quot;lang_attach&quot;&gt;присоединенной базы данных&lt;/a&gt; . В этом случае новая таблица создается в названной базе данных. Если ключевое слово &amp;laquo;TEMP&amp;raquo; или &amp;laquo;TEMPORARY&amp;raquo; встречается между &amp;laquo;CREATE&amp;raquo; и &amp;laquo;TABLE&amp;raquo;, то новая таблица создается во временной базе данных. Ошибкой является указание и имени схемы, и ключевого слова TEMP или TEMPORARY, если имя схемы не равно &amp;laquo;temp&amp;raquo;. Если имя схемы не указано и ключевое слово TEMP отсутствует, таблица создается в основной базе данных.</target>
        </trans-unit>
        <trans-unit id="d186fac3c43b0ebe9fb52f2e0bcd9b8dc9321942" translate="yes" xml:space="preserve">
          <source>If a schema-name is specified, then the view is created in the specified database. It is an error to specify both a schema-name and the TEMP keyword on a VIEW, unless the schema-name is &quot;temp&quot;. If no schema name is specified, and the TEMP keyword is not present, the VIEW is created in the main database.</source>
          <target state="translated">Если указано имя схемы,то представление создается в указанной БД.Ошибкой является указание как имени схемы,так и ключевого слова TEMP на VIEW,если только имя схемы не &quot;temp&quot;.Если имя схемы не указано,а ключевое слово TEMP отсутствует,то VIEW создается в основной базе данных.</target>
        </trans-unit>
        <trans-unit id="5a3b25f9ef77a5c2a55ede994e4212a6c3bae634" translate="yes" xml:space="preserve">
          <source>If a search token (on the right-hand side of the MATCH operator) in &lt;a href=&quot;fts3#fts4&quot;&gt;FTS4&lt;/a&gt; begins with &quot;^&quot; then that token must be the first in its field of the document. &lt;b&gt;** Potentially Incompatible Change **&lt;/b&gt;</source>
          <target state="translated">Если маркер поиска (справа от оператора MATCH) в &lt;a href=&quot;fts3#fts4&quot;&gt;FTS4&lt;/a&gt; начинается с &amp;laquo;^&amp;raquo;, то этот маркер должен быть первым в соответствующем поле документа. &lt;b&gt;** Потенциально несовместимое изменение **&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="e0b0e745b5660b6e63d47617f06b59c6fe2aec60" translate="yes" xml:space="preserve">
          <source>If a separate thread makes changes on the same database connection while &lt;a href=&quot;#sqlite3_changes&quot;&gt;sqlite3_changes()&lt;/a&gt; is running then the value returned is unpredictable and not meaningful.</source>
          <target state="translated">Если отдельный поток вносит изменения в одно и то же соединение с базой данных во время работы &lt;a href=&quot;#sqlite3_changes&quot;&gt;sqlite3_changes (),&lt;/a&gt; то возвращаемое значение непредсказуемо и не имеет смысла.</target>
        </trans-unit>
        <trans-unit id="e161385bf705ff3ca3325998e8904218252e0a24" translate="yes" xml:space="preserve">
          <source>If a separate thread makes changes on the same database connection while &lt;a href=&quot;#sqlite3_total_changes&quot;&gt;sqlite3_total_changes()&lt;/a&gt; is running then the value returned is unpredictable and not meaningful.</source>
          <target state="translated">Если отдельный поток вносит изменения в одно и то же соединение с базой данных во время работы &lt;a href=&quot;#sqlite3_total_changes&quot;&gt;sqlite3_total_changes (),&lt;/a&gt; то возвращаемое значение непредсказуемо и не имеет смысла.</target>
        </trans-unit>
        <trans-unit id="48949b30f7cc8dfe518df452770028dcf8268e04" translate="yes" xml:space="preserve">
          <source>If a separate thread makes changes on the same database connection while &lt;a href=&quot;changes&quot;&gt;sqlite3_changes()&lt;/a&gt; is running then the value returned is unpredictable and not meaningful.</source>
          <target state="translated">Если отдельный поток вносит изменения в одно и то же соединение с базой данных во время работы &lt;a href=&quot;changes&quot;&gt;sqlite3_changes (),&lt;/a&gt; то возвращаемое значение непредсказуемо и не имеет смысла.</target>
        </trans-unit>
        <trans-unit id="e69017ebf8db42f4c918537142f058b4e1e4b99c" translate="yes" xml:space="preserve">
          <source>If a separate thread makes changes on the same database connection while &lt;a href=&quot;total_changes&quot;&gt;sqlite3_total_changes()&lt;/a&gt; is running then the value returned is unpredictable and not meaningful.</source>
          <target state="translated">Если отдельный поток вносит изменения в одно и то же соединение с базой данных во время работы &lt;a href=&quot;total_changes&quot;&gt;sqlite3_total_changes (),&lt;/a&gt; то возвращаемое значение непредсказуемо и не имеет смысла.</target>
        </trans-unit>
        <trans-unit id="67e0dff317f2ea719a9272889d4afc4730b1b5fc" translate="yes" xml:space="preserve">
          <source>If a separate thread performs a new &lt;a href=&quot;../lang_insert&quot;&gt;INSERT&lt;/a&gt; on the same database connection while the &lt;a href=&quot;last_insert_rowid&quot;&gt;sqlite3_last_insert_rowid()&lt;/a&gt; function is running and thus changes the last insert &lt;a href=&quot;../lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;, then the value returned by &lt;a href=&quot;last_insert_rowid&quot;&gt;sqlite3_last_insert_rowid()&lt;/a&gt; is unpredictable and might not equal either the old or the new last insert &lt;a href=&quot;../lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;.</source>
          <target state="translated">Если отдельный поток выполняет новую &lt;a href=&quot;../lang_insert&quot;&gt;операцию INSERT&lt;/a&gt; для того же подключения к базе данных во время работы &lt;a href=&quot;last_insert_rowid&quot;&gt;функции sqlite3_last_insert_rowid ()&lt;/a&gt; и, таким образом, изменяет последний &lt;a href=&quot;../lang_createtable#rowid&quot;&gt;идентификатор строки&lt;/a&gt; вставки , тогда значение, возвращаемое &lt;a href=&quot;last_insert_rowid&quot;&gt;sqlite3_last_insert_rowid (),&lt;/a&gt; является непредсказуемым и может не совпадать ни со старым, ни с новым последним. вставить &lt;a href=&quot;../lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f8a05ae1d1d14adcdf537d4865ddc934cf60a0a4" translate="yes" xml:space="preserve">
          <source>If a separate thread performs a new &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; on the same database connection while the &lt;a href=&quot;#sqlite3_last_insert_rowid&quot;&gt;sqlite3_last_insert_rowid()&lt;/a&gt; function is running and thus changes the last insert &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;, then the value returned by &lt;a href=&quot;#sqlite3_last_insert_rowid&quot;&gt;sqlite3_last_insert_rowid()&lt;/a&gt; is unpredictable and might not equal either the old or the new last insert &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;.</source>
          <target state="translated">Если отдельный поток выполняет новую &lt;a href=&quot;lang_insert&quot;&gt;операцию INSERT&lt;/a&gt; для того же подключения к базе данных во время работы &lt;a href=&quot;#sqlite3_last_insert_rowid&quot;&gt;функции sqlite3_last_insert_rowid ()&lt;/a&gt; и, таким образом, изменяет последний &lt;a href=&quot;lang_createtable#rowid&quot;&gt;идентификатор строки&lt;/a&gt; вставки , тогда значение, возвращаемое &lt;a href=&quot;#sqlite3_last_insert_rowid&quot;&gt;sqlite3_last_insert_rowid (),&lt;/a&gt; является непредсказуемым и может не совпадать ни со старым, ни с новым последним. вставить &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9c0a40f4902327b395568a304aa57a5c4039b9e5" translate="yes" xml:space="preserve">
          <source>If a single database file has multiple links (either hard or soft links) then that is just another way of saying that the file has multiple names. If two or more processes open the database using different names, then they will use different rollback journals and WAL files. That means that if one process crashes, the other process will be unable to recover the transaction in progress because it will be looking in the wrong place for the appropriate journal.</source>
          <target state="translated">Если один файл базы данных имеет несколько ссылок (жесткие или мягкие),то это просто еще один способ сказать,что файл имеет несколько имён.Если два или более процессов открывают базу данных под разными именами,то они будут использовать разные журналы отката и файлы WAL.Это означает,что если один процесс выйдет из строя,другой процесс не сможет восстановить текущую транзакцию,потому что будет искать не в том месте,где находится соответствующий журнал.</target>
        </trans-unit>
        <trans-unit id="54992194ecdfbf1a36948d0111a0401fc51b1ec9" translate="yes" xml:space="preserve">
          <source>If a single row is affected by more than one operation within a session, then the change is considered indirect if all operations meet the criteria for an indirect change above, or direct otherwise.</source>
          <target state="translated">Если на один ряд влияет несколько операций в течение сессии,то изменение считается косвенным,если все операции соответствуют критериям косвенного изменения,указанным выше,или прямым иным образом.</target>
        </trans-unit>
        <trans-unit id="8aed35bc8fc658c89e5539bc9b828e9558656314" translate="yes" xml:space="preserve">
          <source>If a statement modifies the contents of the database so that an immediate foreign key constraint is in violation at the conclusion the statement, an exception is thrown and the effects of the statement are reverted. By contrast, if a statement modifies the contents of the database such that a deferred foreign key constraint is violated, the violation is not reported immediately. Deferred foreign key constraints are not checked until the transaction tries to &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt;. For as long as the user has an open transaction, the database is allowed to exist in a state that violates any number of deferred foreign key constraints. However, &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; will fail as long as foreign key constraints remain in violation.</source>
          <target state="translated">Если оператор изменяет содержимое базы данных таким образом, что при заключении оператора нарушается непосредственное ограничение внешнего ключа, генерируется исключение и действие оператора отменяется. Напротив, если оператор изменяет содержимое базы данных таким образом, что нарушается ограничение отложенного внешнего ключа, о нарушении не сообщается немедленно. Отложенные ограничения внешнего ключа не проверяются, пока транзакция не попытается выполнить &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; . Пока у пользователя есть открытая транзакция, базе данных разрешено существовать в состоянии, которое нарушает любое количество ограничений отложенного внешнего ключа. Однако &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; завершится ошибкой, пока не будут соблюдены ограничения внешнего ключа.</target>
        </trans-unit>
        <trans-unit id="4a9fe68ac2f3c48ea32a43f2c5cf9be89d342ee4" translate="yes" xml:space="preserve">
          <source>If a subquery cannot be &lt;a href=&quot;optoverview#flattening&quot;&gt;flattened&lt;/a&gt; into the outer query, it might still be possible to enhance performance by &quot;pushing down&quot; WHERE clause terms from the outer query into the subquery. Consider an example:</source>
          <target state="translated">Если подзапрос не может быть &lt;a href=&quot;optoverview#flattening&quot;&gt;уплощен&lt;/a&gt; во внешний запрос, он все еще может быть возможность повысить производительность за счет &amp;laquo;надавив&amp;raquo; ИНЕКЕ термины из внешнего запроса в подзапрос. Рассмотрим пример:</target>
        </trans-unit>
        <trans-unit id="cfbdc72faddc3dd92eaf2d66d72d9166e0ce65e3" translate="yes" xml:space="preserve">
          <source>If a system failure occurs at any time after a &quot;delete file&quot; operation (call to the VFS xDelete() method) returns successfully, it is assumed that the file-system will not contain the deleted file following system recovery.</source>
          <target state="translated">Если после успешного возвращения операции &quot;удалить файл&quot; (обращение к методу VFS xDelete())в любой момент произойдет системный сбой,то предполагается,что после восстановления системы файловая система не будет содержать удаленный файл.</target>
        </trans-unit>
        <trans-unit id="c32e1e0b557aefde59c28d931cf3e5d6733099fd" translate="yes" xml:space="preserve">
          <source>If a system failure occurs during a &quot;delete file&quot; operation, it is assumed that following system recovery the file-system will either contain the file being deleted in the state it was in before the operation was attempted, or not contain the file at all. It is assumed that it is not possible for the file to have become corrupted purely as a result of a failure occurring during a &quot;delete file&quot; operation.</source>
          <target state="translated">Если во время операции &quot;удалить файл&quot; происходит системный сбой,то предполагается,что после восстановления системы файловая система будет либо содержать удаляемый файл в том состоянии,в котором он находился до попытки операции,либо не содержать файл вообще.Предполагается,что файл не может быть поврежден только в результате сбоя при выполнении операции &quot;удалить файл&quot;.</target>
        </trans-unit>
        <trans-unit id="91f96ef24748138cdd82c09ceabe7f648ae9cf43" translate="yes" xml:space="preserve">
          <source>If a system failure occurs during or after a &quot;create file&quot; operation, but before the created file has been</source>
          <target state="translated">Если системный сбой происходит во время или после операции &quot;создать файл&quot;,но до того как созданный файл был</target>
        </trans-unit>
        <trans-unit id="1fcfee495c57582bc4c6e63019680717056464ec" translate="yes" xml:space="preserve">
          <source>If a system failure occurs during or after a &quot;truncate file&quot; operation, but before the truncated file has been</source>
          <target state="translated">Если системный сбой происходит во время или после операции &quot;усеченный файл&quot;,но до того,как усеченный файл был</target>
        </trans-unit>
        <trans-unit id="e3c60bc044d7ebf2be0e926e292ed7263d6ed54a" translate="yes" xml:space="preserve">
          <source>If a system failure occurs during or after a &quot;write file&quot; operation that causes the file to grow, but before the corresponding file has been</source>
          <target state="translated">Если системный сбой происходит во время или после операции &quot;запись файла&quot;,которая приводит к росту файла,но до того,как соответствующий файл был</target>
        </trans-unit>
        <trans-unit id="0de8e98595413448f2b535870f8da207b8048237" translate="yes" xml:space="preserve">
          <source>If a system failure occurs during or after a &quot;write file&quot; operation, but before the corresponding file has been</source>
          <target state="translated">Если системный сбой произошел во время или после операции &quot;запись файла&quot;,но до того,как соответствующий файл стал</target>
        </trans-unit>
        <trans-unit id="12d84c274c03171c71b26275c99f75f3392362a6" translate="yes" xml:space="preserve">
          <source>If a system failure occurs on a system that supports the</source>
          <target state="translated">Если системный сбой происходит в системе,которая поддерживает</target>
        </trans-unit>
        <trans-unit id="70f739b455c168080412690c97f5940222b8f766" translate="yes" xml:space="preserve">
          <source>If a system supports</source>
          <target state="translated">Если система поддерживает</target>
        </trans-unit>
        <trans-unit id="ec9800aa0fd4fbf6e94d5e57566c8304e2f2782b" translate="yes" xml:space="preserve">
          <source>If a system supports the</source>
          <target state="translated">Если система поддерживает</target>
        </trans-unit>
        <trans-unit id="16f55a3959edd0a92c0395b9cf4c3468da074f4f" translate="yes" xml:space="preserve">
          <source>If a table contains a column of type &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;, then that column becomes an alias for the ROWID. You can then access the ROWID using any of four different names, the original three names described above or the name given to the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; column. All these names are aliases for one another and work equally well in any context.</source>
          <target state="translated">Если таблица содержит столбец типа &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; , то этот столбец становится псевдонимом для ROWID. Затем вы можете получить доступ к ROWID, используя любое из четырех разных имен, исходных трех имен, описанных выше, или имени, присвоенного столбцу &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; . Все эти имена являются псевдонимами друг для друга и одинаково хорошо работают в любом контексте.</target>
        </trans-unit>
        <trans-unit id="a73b6736040e74c7d625fd213eca9757c75eee19" translate="yes" xml:space="preserve">
          <source>If a table has a single column primary key and the declared type of that column is &quot;INTEGER&quot; and the table is not a &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; table, then the column is known as an &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;. See &lt;a href=&quot;lang_createtable#rowid&quot;&gt;below&lt;/a&gt; for a description of the special properties and behaviors associated with an &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;.</source>
          <target state="translated">Если таблица имеет первичный ключ с одним столбцом, и объявленный тип этого столбца - &quot;INTEGER&quot;, а таблица не является таблицей &lt;a href=&quot;withoutrowid&quot;&gt;БЕЗ ROWID&lt;/a&gt; , то этот столбец известен как &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; . См. &lt;a href=&quot;lang_createtable#rowid&quot;&gt;Ниже&lt;/a&gt; описание специальных свойств и поведения, связанных с &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5e353db8a7a970978b864076f23349bbe29b3cd1" translate="yes" xml:space="preserve">
          <source>If a term in X is of the form &quot;z IS NOT NULL&quot; and if a term in W is a comparison operator on &quot;z&quot; other than &quot;IS&quot;, then those terms match.</source>
          <target state="translated">Если термин в X имеет форму &quot;z НЕ НУЛЬШЕ&quot; и если термин в W является оператором сравнения на &quot;z&quot;,отличным от &quot;IS&quot;,то эти термины совпадают.</target>
        </trans-unit>
        <trans-unit id="d7704041f8ff8a11a4c662eef3d671025a3e5ebe" translate="yes" xml:space="preserve">
          <source>If a term of the WHERE clause is of the following form:</source>
          <target state="translated">Если условие &quot;ГДЕ&quot; имеет следующую форму:</target>
        </trans-unit>
        <trans-unit id="e5d671a1040d0448cbcd3997833359da102571a4" translate="yes" xml:space="preserve">
          <source>If a transaction involves multiple databases, then a more complex commit sequence is used, as follows:</source>
          <target state="translated">Если транзакция включает в себя несколько баз данных,то используется более сложная последовательность коммитов,как показано ниже:</target>
        </trans-unit>
        <trans-unit id="1b08d45fd51c4591fce14d3b424e9dccc579bef5" translate="yes" xml:space="preserve">
          <source>If a transaction is aborted due to an application crash, an operating system crash, or a hardware power failure or crash, then the database may be left in an inconsistent state. The next time SQLite attempts to open the database file, the presence of the rollback journal file will be detected and the journal will be automatically played back to restore the database to its state at the start of the incomplete transaction.</source>
          <target state="translated">Если транзакция прерывается в связи с отказом приложения,сбоем операционной системы,сбоем или отказом аппаратного обеспечения электропитания,то база данных может остаться в непоследовательном состоянии.При следующей попытке SQLite открыть файл БД будет обнаружено наличие файла журнала отката,который будет автоматически проигрываться для восстановления БД до ее состояния при запуске незавершенной транзакции.</target>
        </trans-unit>
        <trans-unit id="b139c7ece8944c0ce3ad448cfb0c14ea14a36c67" translate="yes" xml:space="preserve">
          <source>If a write-transaction is open on &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; D when the &lt;a href=&quot;#sqlite3_db_cacheflush&quot;&gt;sqlite3_db_cacheflush(D)&lt;/a&gt; interface invoked, any dirty pages in the pager-cache that are not currently in use are written out to disk. A dirty page may be in use if a database cursor created by an active SQL statement is reading from it, or if it is page 1 of a database file (page 1 is always &quot;in use&quot;). The &lt;a href=&quot;#sqlite3_db_cacheflush&quot;&gt;sqlite3_db_cacheflush(D)&lt;/a&gt; interface flushes caches for all schemas - &quot;main&quot;, &quot;temp&quot;, and any &lt;a href=&quot;lang_attach&quot;&gt;attached&lt;/a&gt; databases.</source>
          <target state="translated">Если транзакция записи открыта в &lt;a href=&quot;#sqlite3&quot;&gt;соединении с базой данных&lt;/a&gt; D при вызове интерфейса &lt;a href=&quot;#sqlite3_db_cacheflush&quot;&gt;sqlite3_db_cacheflush (D)&lt;/a&gt; , все неиспользуемые грязные страницы в кэше пейджера записываются на диск. Грязная страница может использоваться, если курсор базы данных, созданный активным оператором SQL, читает из нее, или если это страница 1 файла базы данных (страница 1 всегда &amp;laquo;используется&amp;raquo;). Интерфейс &lt;a href=&quot;#sqlite3_db_cacheflush&quot;&gt;sqlite3_db_cacheflush (D)&lt;/a&gt; очищает кеши для всех схем - &amp;laquo;main&amp;raquo;, &amp;laquo;temp&amp;raquo; и любых &lt;a href=&quot;lang_attach&quot;&gt;подключенных&lt;/a&gt; баз данных.</target>
        </trans-unit>
        <trans-unit id="94598ac271e5cdca4a0d9c950ece2e2fde3c85ae" translate="yes" xml:space="preserve">
          <source>If a write-transaction is open on &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; D when the &lt;a href=&quot;db_cacheflush&quot;&gt;sqlite3_db_cacheflush(D)&lt;/a&gt; interface invoked, any dirty pages in the pager-cache that are not currently in use are written out to disk. A dirty page may be in use if a database cursor created by an active SQL statement is reading from it, or if it is page 1 of a database file (page 1 is always &quot;in use&quot;). The &lt;a href=&quot;db_cacheflush&quot;&gt;sqlite3_db_cacheflush(D)&lt;/a&gt; interface flushes caches for all schemas - &quot;main&quot;, &quot;temp&quot;, and any &lt;a href=&quot;../lang_attach&quot;&gt;attached&lt;/a&gt; databases.</source>
          <target state="translated">Если транзакция записи открыта в &lt;a href=&quot;sqlite3&quot;&gt;соединении с базой данных&lt;/a&gt; D при вызове интерфейса &lt;a href=&quot;db_cacheflush&quot;&gt;sqlite3_db_cacheflush (D)&lt;/a&gt; , все неиспользуемые грязные страницы в кэше пейджера записываются на диск. Грязная страница может использоваться, если курсор базы данных, созданный активным оператором SQL, читает из нее, или если это страница 1 файла базы данных (страница 1 всегда &amp;laquo;используется&amp;raquo;). Интерфейс &lt;a href=&quot;db_cacheflush&quot;&gt;sqlite3_db_cacheflush (D)&lt;/a&gt; очищает кеши для всех схем - &amp;laquo;main&amp;raquo;, &amp;laquo;temp&amp;raquo; и любых &lt;a href=&quot;../lang_attach&quot;&gt;подключенных&lt;/a&gt; баз данных.</target>
        </trans-unit>
        <trans-unit id="9d687ea67d2673f11d5b429c0195a169c2caa77a" translate="yes" xml:space="preserve">
          <source>If a write-transaction is started and the Vdbe.usesStmtJournal flag is true (this flag is set if the Vdbe may modify more than one row and may throw an ABORT exception), a statement transaction may also be opened. More specifically, a statement transaction is opened iff the database connection is currently not in autocommit mode, or if there are other active statements. A statement transaction allows the changes made by this VDBE to be rolled back after an error without having to roll back the entire transaction. If no error is encountered, the statement transaction will automatically commit when the VDBE halts.</source>
          <target state="translated">Если транзакция записи начинается и флаг Vdbe.useStmtJournal истинен (этот флаг устанавливается,если Vdbe может модифицировать более чем одну строку и может бросить исключение ABORT),транзакция оператора также может быть открыта.Точнее,транзакция оператора открывается,если соединение с базой данных в настоящее время не находится в режиме автокомитации,или если есть другие активные операторы.Транзакция оператора позволяет откатить изменения,сделанные этим VDBE после ошибки,без необходимости отката всей транзакции.Если ошибка не обнаружена,транзакция оператора будет автоматически зафиксирована,когда VDBE остановится.</target>
        </trans-unit>
        <trans-unit id="7e874d6b40d57619d9fa5fb8dd75a92de53ed059" translate="yes" xml:space="preserve">
          <source>If all three of the steps enumerated above are executed successfully, then it is safe to modify the content of the</source>
          <target state="translated">Если все три перечисленные выше шага будут успешно выполнены,то можно безопасно модифицировать содержание</target>
        </trans-unit>
        <trans-unit id="8a9cfb8256efd43eaa74ef64ff226cfbf427865f" translate="yes" xml:space="preserve">
          <source>If an &quot;ALTER TABLE ... RENAME TO&quot; command is used to rename a table that is the parent table of one or more foreign key constraints, the definitions of the foreign key constraints are modified to refer to the parent table by its new name. The text of the child CREATE TABLE statement or statements stored in the &lt;a href=&quot;schematab&quot;&gt;sqlite_schema table&lt;/a&gt; are modified to reflect the new parent table name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76124bb023821e31ac6f5cbf1f8b54083a3ec643" translate="yes" xml:space="preserve">
          <source>If an &quot;ALTER TABLE ... RENAME TO&quot; command is used to rename a table that is the parent table of one or more foreign key constraints, the definitions of the foreign key constraints are modified to refer to the parent table by its new name. The text of the child CREATE TABLE statement or statements stored in the sqlite_master table are modified to reflect the new parent table name.</source>
          <target state="translated">Если &quot;АЛЬТЕР-ТАБЛИЦА&quot; ...RENAME TO&quot; используется для переименования таблицы,являющейся родительской таблицей одного или нескольких ограничений внешнего ключа,определения ограничений внешнего ключа изменяются для обращения к родительской таблице по ее новому имени.Текст оператора дочерней CREATE TABLE или операторов,хранящихся в таблице sqlite_master,изменяется для отражения нового имени родительской таблицы.</target>
        </trans-unit>
        <trans-unit id="7603e9a69b7a72c62bbc679327133633953ff9aa" translate="yes" xml:space="preserve">
          <source>If an &lt;a href=&quot;#sqlite3&quot;&gt;sqlite3&lt;/a&gt; object is destroyed while a transaction is open, the transaction is automatically rolled back.</source>
          <target state="translated">Если объект &lt;a href=&quot;#sqlite3&quot;&gt;sqlite3&lt;/a&gt; уничтожается во время открытия транзакции, транзакция автоматически откатывается.</target>
        </trans-unit>
        <trans-unit id="53a3481d0fa9e30b2f0d27a6044ee94e1a62bb9b" translate="yes" xml:space="preserve">
          <source>If an &lt;a href=&quot;../lang_insert&quot;&gt;INSERT&lt;/a&gt; occurs within a trigger then this routine will return the &lt;a href=&quot;../lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; of the inserted row as long as the trigger is running. Once the trigger program ends, the value returned by this routine reverts to what it was before the trigger was fired.</source>
          <target state="translated">Если &lt;a href=&quot;../lang_insert&quot;&gt;INSERT&lt;/a&gt; происходит в триггере, эта процедура будет возвращать &lt;a href=&quot;../lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; вставленной строки, пока триггер работает. После завершения программы триггера значение, возвращаемое этой подпрограммой, возвращается к тому, что было до срабатывания триггера.</target>
        </trans-unit>
        <trans-unit id="877e1b4a7430ba11b48b32c5598ad0c65dc34442" translate="yes" xml:space="preserve">
          <source>If an &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; occurs within a trigger then this routine will return the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; of the inserted row as long as the trigger is running. Once the trigger program ends, the value returned by this routine reverts to what it was before the trigger was fired.</source>
          <target state="translated">Если &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; происходит в триггере, эта процедура будет возвращать &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; вставленной строки, пока триггер работает. После завершения программы триггера значение, возвращаемое этой подпрограммой, возвращается к тому, что было до срабатывания триггера.</target>
        </trans-unit>
        <trans-unit id="b95cb40fc8352b696796b3bff79e2f006b1ce07a" translate="yes" xml:space="preserve">
          <source>If an &lt;a href=&quot;sqlite3&quot;&gt;sqlite3&lt;/a&gt; object is destroyed while a transaction is open, the transaction is automatically rolled back.</source>
          <target state="translated">Если объект &lt;a href=&quot;sqlite3&quot;&gt;sqlite3&lt;/a&gt; уничтожается во время открытия транзакции, транзакция автоматически откатывается.</target>
        </trans-unit>
        <trans-unit id="9f62d9384e44621989efc3c00f1a3ba721b2e39d" translate="yes" xml:space="preserve">
          <source>If an FTS5 table is configured with columnsize=0 but is not a &lt;a href=&quot;fts5#contentless_tables&quot;&gt;contentless table&lt;/a&gt;, the xColumnSize API function still works, but runs much more slowly. In this case, instead of reading the value to return directly from the database, it reads the text value itself and count the tokens within it on demand.</source>
          <target state="translated">Если таблица FTS5 настроена со значением columnsize = 0, но не является &lt;a href=&quot;fts5#contentless_tables&quot;&gt;таблицей без&lt;/a&gt; содержимого, функция API xColumnSize по-прежнему работает, но работает намного медленнее. В этом случае вместо чтения возвращаемого значения непосредственно из базы данных он считывает само текстовое значение и по требованию подсчитывает токены в нем.</target>
        </trans-unit>
        <trans-unit id="a593df8166351f80d07eb58cb262614d9dbc8634" translate="yes" xml:space="preserve">
          <source>If an INSERT statement attempts to insert a NULL value into a rowid or integer primary key column, the system chooses an integer value to use as the rowid automatically. A detailed description of how this is done is provided &lt;a href=&quot;autoinc&quot;&gt;separately&lt;/a&gt;.</source>
          <target state="translated">Если оператор INSERT пытается вставить значение NULL в столбец первичного ключа rowid или integer, система автоматически выбирает целочисленное значение для использования в качестве rowid. Подробное описание того, как это делается, предоставляется &lt;a href=&quot;autoinc&quot;&gt;отдельно&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ba4158b1467dce3a1f2ceab9abb8de00b0fe4463" translate="yes" xml:space="preserve">
          <source>If an ORDER BY clause is present, it determines the order in which rows are extracted from the queue in step 2a. If there is no ORDER BY clause, then the order in which rows are extracted is undefined. (In the current implementation, the queue becomes a FIFO if the ORDER BY clause is omitted, but applications should not depend on that fact since it might change.)</source>
          <target state="translated">Если присутствует пункт ORDER BY,то он определяет порядок извлечения строк из очереди на шаге 2a.Если пункта &quot;ORDER BY&quot; нет,то порядок извлечения строк из очереди не определен.(В текущей реализации очередь становится FIFO,если опущено условие ORDER BY,но приложения не должны зависеть от этого факта,так как он может измениться).</target>
        </trans-unit>
        <trans-unit id="22141c686821647d4155d6b151a8d8fa154cd1a8" translate="yes" xml:space="preserve">
          <source>If an SQL operation is very nearly finished at the time when sqlite3_interrupt() is called, then it might not have an opportunity to be interrupted and might continue to completion.</source>
          <target state="translated">Если на момент вызова sqlite3_interrupt()SQL-операция почти завершена,то она может не иметь возможности быть прервана и продолжить выполнение.</target>
        </trans-unit>
        <trans-unit id="923eabd2cf996c975383b0dccd3e5fb8dc063dde" translate="yes" xml:space="preserve">
          <source>If an SQL statement is limited to be a million bytes in length, then obviously you will not be able to insert multi-million byte strings by embedding them as literals inside of INSERT statements. But you should not do that anyway. Use host &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameters&lt;/a&gt; for your data. Prepare short SQL statements like this:</source>
          <target state="translated">Если длина оператора SQL ограничена миллионом байтов, очевидно, что вы не сможете вставлять многомиллионные строки байтов, вставляя их как литералы внутри операторов INSERT. Но все равно этого делать не стоит. Используйте &lt;a href=&quot;lang_expr#varparam&quot;&gt;параметры&lt;/a&gt; хоста для ваших данных. Подготовьте короткие операторы SQL, подобные этому:</target>
        </trans-unit>
        <trans-unit id="a519000750401db43c985f6fefc862d71c74bede" translate="yes" xml:space="preserve">
          <source>If an SQL table is created using the &quot;WITHOUT ROWID&quot; clause at the end of its CREATE TABLE statement, then that table is a &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; table and uses a different on-disk representation. A WITHOUT ROWID table uses an index b-tree rather than a table b-tree for storage. The key for each entry in the WITHOUT ROWID b-tree is a record composed of the columns of the PRIMARY KEY followed by all remaining columns of the table. The primary key columns appear in the order they they were declared in the PRIMARY KEY clause and the remaining columns appear in the order they occur in the CREATE TABLE statement.</source>
          <target state="translated">Если таблица SQL создается с использованием предложения WITHOUT ROWID в конце оператора CREATE TABLE, то эта таблица является таблицей &lt;a href=&quot;withoutrowid&quot;&gt;БЕЗ ROWID&lt;/a&gt; и использует другое представление на диске. Таблица БЕЗ ROWID использует для хранения b-дерево индекса, а не b-дерево таблицы. Ключ для каждой записи в b-дереве БЕЗ ROWID - это запись, состоящая из столбцов ПЕРВИЧНОГО КЛЮЧА, за которыми следуют все оставшиеся столбцы таблицы. Столбцы первичного ключа появляются в том порядке, в котором они были объявлены в предложении PRIMARY KEY, а остальные столбцы появляются в том порядке, в котором они встречаются в операторе CREATE TABLE.</target>
        </trans-unit>
        <trans-unit id="7a1f15ef308e23ec2fc80a29e25882265ebf0786" translate="yes" xml:space="preserve">
          <source>If an UPDATE statement attempts to set an integer primary key or rowid column to a NULL or blob value, or to a string or real value that cannot be losslessly converted to an integer, a &quot;datatype mismatch&quot; error occurs and the statement is aborted. If an INSERT statement attempts to insert a blob value, or a string or real value that cannot be losslessly converted to an integer into an integer primary key or rowid column, a &quot;datatype mismatch&quot; error occurs and the statement is aborted.</source>
          <target state="translated">Если оператор UPDATE пытается установить целочисленный первичный ключ или рядный столбец в значение NULL или blob,или в строку или вещественное значение,которое не может быть без потерь преобразовано в целое число,возникает ошибка &quot;несоответствия типа данных&quot;,и оператор прерывается.Если оператор INSERT пытается вставить блочное или строковое или вещественное значение,которое не может быть без потерь преобразовано в целое число,в целочисленный первичный ключ или рядный столбец,возникает ошибка несоответствия типа данных,и оператор прерывается.</target>
        </trans-unit>
        <trans-unit id="284b34da69fbf9cd89926df318af7634184253b9" translate="yes" xml:space="preserve">
          <source>If an UPDATE statement has a LIMIT clause, the maximum number of rows that will be updated is found by evaluating the accompanying expression and casting it to an integer value. A negative value is interpreted as &quot;no limit&quot;.</source>
          <target state="translated">Если оператор UPDATE имеет выражение LIMIT,максимальное количество строк,которые будут обновлены,будет найдено путем вычисления сопровождающего выражения и приведения его к целому значению.Отрицательное значение интерпретируется как &quot;нет предела&quot;.</target>
        </trans-unit>
        <trans-unit id="35654cca0e06875d8f71c06cdb825a502007ac27" translate="yes" xml:space="preserve">
          <source>If an application issues a SELECT statement on a single table like &quot;</source>
          <target state="translated">Если приложение выпускает заявление SELECT на одной таблице,например,&quot;</target>
        </trans-unit>
        <trans-unit id="3c9847a3fc8345f21ef2aae877b6da29936db6dc" translate="yes" xml:space="preserve">
          <source>If an application puts SQLite in &lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;exclusive locking mode&lt;/a&gt; using the pragma:</source>
          <target state="translated">Если приложение переводит SQLite в &lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;режим монопольной блокировки,&lt;/a&gt; используя прагму:</target>
        </trans-unit>
        <trans-unit id="16930c87a89e5aa4dacec21b97a534c286412312" translate="yes" xml:space="preserve">
          <source>If an application using asynchronous IO executes transactions in quick succession, other database users may be effectively locked out of the database. This is because when a &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt; is executed, a database lock is established immediately. But when the corresponding COMMIT or ROLLBACK occurs, the lock is not released until the relevant part of the write-queue has been flushed through. As a result, if a COMMIT is followed by a BEGIN before the write-queue is flushed through, the database is never unlocked,preventing other processes from accessing the database.</source>
          <target state="translated">Если приложение, использующее асинхронный ввод-вывод, выполняет транзакции в быстрой последовательности, другие пользователи базы данных могут быть фактически заблокированы из базы данных. Это связано с тем, что при выполнении &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt; блокировка базы данных устанавливается немедленно. Но когда происходит соответствующий COMMIT или ROLLBACK, блокировка не снимается, пока соответствующая часть очереди записи не будет очищена. В результате, если за COMMIT следует BEGIN до того, как очередь записи будет очищена, база данных никогда не будет разблокирована, что предотвратит доступ других процессов к базе данных.</target>
        </trans-unit>
        <trans-unit id="dec67a679cc10b4fb4ca0df679f1b42a8a809bf0" translate="yes" xml:space="preserve">
          <source>If an attempt to acquire a</source>
          <target state="translated">При попытке приобретения</target>
        </trans-unit>
        <trans-unit id="ae2dad7a2ac6f9639d4f707a82a9b585c9a56bd8" translate="yes" xml:space="preserve">
          <source>If an attempt to upgrade to an</source>
          <target state="translated">При попытке перейти на</target>
        </trans-unit>
        <trans-unit id="0f4ee50fd2b5b886cf93345554e2cb331273f09d" translate="yes" xml:space="preserve">
          <source>If an error (e.g. an OOM condition) occurs within this function, the auxiliary data is set to NULL and an error code returned. If the xDelete parameter was not NULL, it is invoked on the auxiliary data pointer before returning.</source>
          <target state="translated">Если в рамках этой функции возникает ошибка (например,состояние OOM),то вспомогательные данные устанавливаются на NULL и возвращается код ошибки.Если параметр xDelete не был NULL,то перед возвратом он вызывается на вспомогательном указателе данных.</target>
        </trans-unit>
        <trans-unit id="8045cc0ef3fd13ca44d5e4369a94674b9f7300cd" translate="yes" xml:space="preserve">
          <source>If an error occurs in any of the three main backup API routines then the &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; and &lt;a href=&quot;c3ref/errcode&quot;&gt;message&lt;/a&gt; are attached to the destination &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt;. Additionally, if &lt;a href=&quot;c3ref/backup_finish#sqlite3backupstep&quot;&gt;sqlite3_backup_step()&lt;/a&gt; encounters an error, then the &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; is returned by both the &lt;a href=&quot;c3ref/backup_finish#sqlite3backupstep&quot;&gt;sqlite3_backup_step()&lt;/a&gt; call itself, and by the subsequent call to &lt;a href=&quot;c3ref/backup_finish#sqlite3backupfinish&quot;&gt;sqlite3_backup_finish()&lt;/a&gt;. So a call to &lt;a href=&quot;c3ref/backup_finish#sqlite3backupfinish&quot;&gt;sqlite3_backup_finish()&lt;/a&gt; does not overwrite an &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; stored in the destination &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; by &lt;a href=&quot;c3ref/backup_finish#sqlite3backupstep&quot;&gt;sqlite3_backup_step()&lt;/a&gt;. This feature is used in the example code to reduce amount of error handling required. The return values of the &lt;a href=&quot;c3ref/backup_finish#sqlite3backupstep&quot;&gt;sqlite3_backup_step()&lt;/a&gt; and &lt;a href=&quot;c3ref/backup_finish#sqlite3backupfinish&quot;&gt;sqlite3_backup_finish()&lt;/a&gt; calls are ignored and the error code indicating the success or failure of the copy operation collected from the destination &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; afterward.</source>
          <target state="translated">Если ошибка возникает в любой из трех основных подпрограмм API резервного копирования, &lt;a href=&quot;rescode&quot;&gt;код ошибки&lt;/a&gt; и &lt;a href=&quot;c3ref/errcode&quot;&gt;сообщение&lt;/a&gt; прикрепляются к целевому &lt;a href=&quot;c3ref/sqlite3&quot;&gt;соединению с базой данных&lt;/a&gt; . Кроме того, если &lt;a href=&quot;c3ref/backup_finish#sqlite3backupstep&quot;&gt;sqlite3_backup_step ()&lt;/a&gt; обнаруживает ошибку, &lt;a href=&quot;rescode&quot;&gt;код ошибки&lt;/a&gt; возвращается как самим вызовом &lt;a href=&quot;c3ref/backup_finish#sqlite3backupstep&quot;&gt;sqlite3_backup_step ()&lt;/a&gt; , так и последующим вызовом &lt;a href=&quot;c3ref/backup_finish#sqlite3backupfinish&quot;&gt;sqlite3_backup_finish ()&lt;/a&gt; . Таким образом, вызов &lt;a href=&quot;c3ref/backup_finish#sqlite3backupfinish&quot;&gt;sqlite3_backup_finish ()&lt;/a&gt; не перезаписывает &lt;a href=&quot;rescode&quot;&gt;код ошибки,&lt;/a&gt; хранящийся в соединении с целевой &lt;a href=&quot;c3ref/sqlite3&quot;&gt;базой данных с&lt;/a&gt; помощью &lt;a href=&quot;c3ref/backup_finish#sqlite3backupstep&quot;&gt;sqlite3_backup_step ()&lt;/a&gt;. Эта функция используется в примере кода, чтобы уменьшить объем необходимой обработки ошибок. Возвращаемые значения вызовов &lt;a href=&quot;c3ref/backup_finish#sqlite3backupstep&quot;&gt;sqlite3_backup_step ()&lt;/a&gt; и &lt;a href=&quot;c3ref/backup_finish#sqlite3backupfinish&quot;&gt;sqlite3_backup_finish ()&lt;/a&gt; игнорируются, а код ошибки, указывающий на успех или неудачу операции копирования, впоследствии собирается из соединения с целевой &lt;a href=&quot;c3ref/sqlite3&quot;&gt;базой данных&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e8416d9f169797cd1d1df3d689a0f3981d1e1914" translate="yes" xml:space="preserve">
          <source>If an error occurs while evaluating the SQL statements passed into sqlite3_exec(), then execution of the current statement stops and subsequent statements are skipped. If the 5th parameter to sqlite3_exec() is not NULL then any error message is written into memory obtained from &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc()&lt;/a&gt; and passed back through the 5th parameter. To avoid memory leaks, the application should invoke &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free()&lt;/a&gt; on error message strings returned through the 5th parameter of sqlite3_exec() after the error message string is no longer needed. If the 5th parameter to sqlite3_exec() is not NULL and no errors occur, then sqlite3_exec() sets the pointer in its 5th parameter to NULL before returning.</source>
          <target state="translated">Если ошибка возникает при оценке операторов SQL, переданных в sqlite3_exec (), выполнение текущего оператора останавливается, а последующие операторы пропускаются. Если 5-й параметр sqlite3_exec () не равен NULL, то любое сообщение об ошибке записывается в память, полученная из &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc (),&lt;/a&gt; и передается обратно через 5-й параметр. Чтобы избежать утечек памяти, приложение должно вызывать &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free ()&lt;/a&gt; для строк сообщений об ошибках, возвращаемых через 5-й параметр sqlite3_exec () после того, как строка сообщения об ошибке больше не нужна. Если 5-й параметр sqlite3_exec () не равен NULL и ошибок не возникает, то sqlite3_exec () устанавливает указатель в своем 5-м параметре в NULL перед возвратом.</target>
        </trans-unit>
        <trans-unit id="67c739deca1fc659fe9011cffdf430f71e9a737b" translate="yes" xml:space="preserve">
          <source>If an error occurs while evaluating the SQL statements passed into sqlite3_exec(), then execution of the current statement stops and subsequent statements are skipped. If the 5th parameter to sqlite3_exec() is not NULL then any error message is written into memory obtained from &lt;a href=&quot;free&quot;&gt;sqlite3_malloc()&lt;/a&gt; and passed back through the 5th parameter. To avoid memory leaks, the application should invoke &lt;a href=&quot;free&quot;&gt;sqlite3_free()&lt;/a&gt; on error message strings returned through the 5th parameter of sqlite3_exec() after the error message string is no longer needed. If the 5th parameter to sqlite3_exec() is not NULL and no errors occur, then sqlite3_exec() sets the pointer in its 5th parameter to NULL before returning.</source>
          <target state="translated">Если ошибка возникает при оценке операторов SQL, переданных в sqlite3_exec (), выполнение текущего оператора останавливается, а последующие операторы пропускаются. Если 5-й параметр sqlite3_exec () не равен NULL, то любое сообщение об ошибке записывается в память, полученная из &lt;a href=&quot;free&quot;&gt;sqlite3_malloc (),&lt;/a&gt; и передается обратно через 5-й параметр. Чтобы избежать утечек памяти, приложение должно вызывать &lt;a href=&quot;free&quot;&gt;sqlite3_free ()&lt;/a&gt; для строк сообщений об ошибках, возвращаемых через 5-й параметр sqlite3_exec () после того, как строка сообщения об ошибке больше не нужна. Если 5-й параметр sqlite3_exec () не равен NULL и ошибок не возникает, то sqlite3_exec () устанавливает указатель в своем 5-м параметре в NULL перед возвратом.</target>
        </trans-unit>
        <trans-unit id="194a0b44e46a56e474b265407cd79a961ab1ee3b" translate="yes" xml:space="preserve">
          <source>If an error occurs within sqlite3_backup_init(D,N,S,M), then NULL is returned and an error code and error message are stored in the destination &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; D. The error code and message for the failed call to sqlite3_backup_init() can be retrieved using the &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errcode()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errmsg()&lt;/a&gt;, and/or &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errmsg16()&lt;/a&gt; functions. A successful call to sqlite3_backup_init() returns a pointer to an &lt;a href=&quot;#sqlite3_backup&quot;&gt;sqlite3_backup&lt;/a&gt; object. The &lt;a href=&quot;#sqlite3_backup&quot;&gt;sqlite3_backup&lt;/a&gt; object may be used with the sqlite3_backup_step() and sqlite3_backup_finish() functions to perform the specified backup operation.</source>
          <target state="translated">Если ошибка возникает в sqlite3_backup_init (D, N, S, M), то возвращается NULL, а код ошибки и сообщение об ошибке сохраняются в целевом &lt;a href=&quot;#sqlite3&quot;&gt;соединении с базой данных&lt;/a&gt; D. Код ошибки и сообщение для неудачного вызова sqlite3_backup_init () могут можно получить с помощью функций &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errcode ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errmsg ()&lt;/a&gt; и / или &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errmsg16 ()&lt;/a&gt; . Успешный вызов sqlite3_backup_init () возвращает указатель на объект &lt;a href=&quot;#sqlite3_backup&quot;&gt;sqlite3_backup&lt;/a&gt; . Объект &lt;a href=&quot;#sqlite3_backup&quot;&gt;sqlite3_backup&lt;/a&gt; можно использовать с функциями sqlite3_backup_step () и sqlite3_backup_finish () для выполнения указанной операции резервного копирования.</target>
        </trans-unit>
        <trans-unit id="1200818faf5a8fe2f6854c6a6851d33b2f623b3d" translate="yes" xml:space="preserve">
          <source>If an error occurs within sqlite3_backup_init(D,N,S,M), then NULL is returned and an error code and error message are stored in the destination &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; D. The error code and message for the failed call to sqlite3_backup_init() can be retrieved using the &lt;a href=&quot;errcode&quot;&gt;sqlite3_errcode()&lt;/a&gt;, &lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg()&lt;/a&gt;, and/or &lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg16()&lt;/a&gt; functions. A successful call to sqlite3_backup_init() returns a pointer to an &lt;a href=&quot;backup&quot;&gt;sqlite3_backup&lt;/a&gt; object. The &lt;a href=&quot;backup&quot;&gt;sqlite3_backup&lt;/a&gt; object may be used with the sqlite3_backup_step() and sqlite3_backup_finish() functions to perform the specified backup operation.</source>
          <target state="translated">Если ошибка возникает в sqlite3_backup_init (D, N, S, M), то возвращается NULL, а код ошибки и сообщение об ошибке сохраняются в целевом &lt;a href=&quot;sqlite3&quot;&gt;соединении с базой данных&lt;/a&gt; D. Код ошибки и сообщение для неудачного вызова sqlite3_backup_init () могут можно получить с помощью функций &lt;a href=&quot;errcode&quot;&gt;sqlite3_errcode ()&lt;/a&gt; , &lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg ()&lt;/a&gt; и / или &lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg16 ()&lt;/a&gt; . Успешный вызов sqlite3_backup_init () возвращает указатель на объект &lt;a href=&quot;backup&quot;&gt;sqlite3_backup&lt;/a&gt; . Объект &lt;a href=&quot;backup&quot;&gt;sqlite3_backup&lt;/a&gt; можно использовать с функциями sqlite3_backup_step () и sqlite3_backup_finish () для выполнения указанной операции резервного копирования.</target>
        </trans-unit>
        <trans-unit id="100ded69e0a780b44961df68d1032c0e7c075797" translate="yes" xml:space="preserve">
          <source>If an error occurs, an SQLite error code is returned and the output variables (*pnData) and (*ppData) are set to 0. Otherwise, SQLITE_OK is returned and the output variables are set to the size of and a pointer to the output buffer, respectively. In this case it is the responsibility of the caller to eventually free the buffer using a call to sqlite3_free().</source>
          <target state="translated">При возникновении ошибки возвращается код ошибки SQLite и выходные переменные (*pnData)и (*ppData)устанавливаются в 0,в противном случае возвращается SQLITE_OK и выходные переменные устанавливаются в размер выходного буфера и указатель на него соответственно.В этом случае ответственность за окончательное освобождение буфера возлагается на вызывающего абонента с помощью вызова sqlite3_free().</target>
        </trans-unit>
        <trans-unit id="622e26e115262f02ac7f60da2462323cdc540b9f" translate="yes" xml:space="preserve">
          <source>If an error occurs, an SQLite error code is returned. Possible error codes include SQLITE_CORRUPT (if the changeset buffer is corrupt) or SQLITE_NOMEM.</source>
          <target state="translated">При возникновении ошибки возвращается код ошибки SQLite.Возможные коды ошибок включают в себя SQLITE_CORRUPT (если буфер changeset поврежден)или SQLITE_NOMEM.</target>
        </trans-unit>
        <trans-unit id="e455ebdd54ae8a16893e6de74ee6f1db7c5e35d7" translate="yes" xml:space="preserve">
          <source>If an error was encountered within a call to an sqlite3changeset_xxx() function (for example an &lt;a href=&quot;../rescode#corrupt&quot;&gt;SQLITE_CORRUPT&lt;/a&gt; in &lt;a href=&quot;sqlite3changeset_next&quot;&gt;sqlite3changeset_next()&lt;/a&gt; or an &lt;a href=&quot;../rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt; in &lt;a href=&quot;sqlite3changeset_new&quot;&gt;sqlite3changeset_new()&lt;/a&gt;) then an error code corresponding to that error is returned by this function. Otherwise, SQLITE_OK is returned. This is to allow the following pattern (pseudo-code):</source>
          <target state="translated">Если при вызове функции sqlite3changeset_xxx () возникла ошибка (например, &lt;a href=&quot;../rescode#corrupt&quot;&gt;SQLITE_CORRUPT&lt;/a&gt; в &lt;a href=&quot;sqlite3changeset_next&quot;&gt;sqlite3changeset_next ()&lt;/a&gt; или &lt;a href=&quot;../rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt; в &lt;a href=&quot;sqlite3changeset_new&quot;&gt;sqlite3changeset_new ()&lt;/a&gt; ), то эта функция возвращает код ошибки, соответствующий этой ошибке. В противном случае возвращается SQLITE_OK. Это позволяет использовать следующий шаблон (псевдокод):</target>
        </trans-unit>
        <trans-unit id="1bc5bca387ff960fe9687401573a47507a4fa49f" translate="yes" xml:space="preserve">
          <source>If an error was encountered within a call to an sqlite3changeset_xxx() function (for example an &lt;a href=&quot;rescode#corrupt&quot;&gt;SQLITE_CORRUPT&lt;/a&gt; in &lt;a href=&quot;#sqlite3changeset_next&quot;&gt;sqlite3changeset_next()&lt;/a&gt; or an &lt;a href=&quot;rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt; in &lt;a href=&quot;#sqlite3changeset_new&quot;&gt;sqlite3changeset_new()&lt;/a&gt;) then an error code corresponding to that error is returned by this function. Otherwise, SQLITE_OK is returned. This is to allow the following pattern (pseudo-code):</source>
          <target state="translated">Если при вызове функции sqlite3changeset_xxx () возникла ошибка (например, &lt;a href=&quot;rescode#corrupt&quot;&gt;SQLITE_CORRUPT&lt;/a&gt; в &lt;a href=&quot;#sqlite3changeset_next&quot;&gt;sqlite3changeset_next ()&lt;/a&gt; или &lt;a href=&quot;rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt; в &lt;a href=&quot;#sqlite3changeset_new&quot;&gt;sqlite3changeset_new ()&lt;/a&gt; ), то эта функция возвращает код ошибки, соответствующий этой ошибке. В противном случае возвращается SQLITE_OK. Это позволяет использовать следующий шаблон (псевдокод):</target>
        </trans-unit>
        <trans-unit id="1b680ceb7d64040ce2b6564485c5ca5b1c9689a0" translate="yes" xml:space="preserve">
          <source>If an fts5vocab table is created in the temp database, it may be associated with an FTS5 table in any attached database. In order to attach the fts5vocab table to an FTS5 table located in a database other than &quot;temp&quot;, the name of the database is inserted before the FTS5 table name in the CREATE VIRTUAL TABLE arguments. For example:</source>
          <target state="translated">Если таблица fts5vocab создана в базе данных temp,то она может быть связана с таблицей FTS5 в любой подключенной базе данных.Для того чтобы присоединить таблицу fts5vocab к таблице FTS5,находящейся в БД,отличной от &quot;temp&quot;,имя БД вставляется перед именем таблицы FTS5 в аргументах CREATE VIRTUAL TABLE.Например:</target>
        </trans-unit>
        <trans-unit id="3334fd5a8f49d3b3b23387e0ded39340f08eab83" translate="yes" xml:space="preserve">
          <source>If an index is available on the ORDER BY column, that index can be used for sorting. Consider the request for all items sorted by &quot;fruit&quot;:</source>
          <target state="translated">Если индекс доступен в столбце ORDER BY,то этот индекс может быть использован для сортировки.Рассмотрим запрос на все элементы,отсортированные по &quot;фруктам&quot;:</target>
        </trans-unit>
        <trans-unit id="7ff3ecb138d9749f1bf1bb734a03098e601b851c" translate="yes" xml:space="preserve">
          <source>If an index is created using a statement like this:</source>
          <target state="translated">Если индекс создается с помощью такого оператора:</target>
        </trans-unit>
        <trans-unit id="19ed5776fff64746115879da20e80724a2114442" translate="yes" xml:space="preserve">
          <source>If an instance-list grows so large that it exceeds the &lt;a href=&quot;limits#max_length&quot;&gt;SQLITE_MAX_LENGTH&lt;/a&gt; limit, FTS3/4 is unable to handle it. FTS5 does not have this problem.</source>
          <target state="translated">Если экземпляр-список растет настолько велик , что превышает &lt;a href=&quot;limits#max_length&quot;&gt;SQLITE_MAX_LENGTH&lt;/a&gt; предела, FTS3 / 4 не в состоянии справиться с этим. FTS5 не имеет этой проблемы.</target>
        </trans-unit>
        <trans-unit id="e669868d5fcfe552cb1dbbc9c2998f5505f629e6" translate="yes" xml:space="preserve">
          <source>If an interface fails with SQLITE_MISUSE, that means the interface was invoked incorrectly by the application. In that case, the error code and message may or may not be set.</source>
          <target state="translated">Если интерфейс не работает с SQLITE_MISUSE,это означает,что интерфейс был вызван приложением некорректно.В этом случае код ошибки и сообщение могут быть установлены,а могут и не установлены.</target>
        </trans-unit>
        <trans-unit id="582fb0780f4838faf9f9c1524bd108b2fc64370c" translate="yes" xml:space="preserve">
          <source>If an out-of-memory error occurs, then the return value from these routines is the same as if the column had contained an SQL NULL value. Valid SQL NULL returns can be distinguished from out-of-memory errors by invoking the &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errcode()&lt;/a&gt; immediately after the suspect return value is obtained and before any other SQLite interface is called on the same &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt;.</source>
          <target state="translated">Если возникает ошибка нехватки памяти, то возвращаемое значение из этих подпрограмм такое же, как если бы столбец содержал значение SQL NULL. Верные возвращаемые значения SQL NULL можно отличить от ошибок нехватки памяти, вызвав &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errcode ()&lt;/a&gt; сразу после получения подозрительного возвращаемого значения и перед вызовом любого другого интерфейса SQLite в том же &lt;a href=&quot;#sqlite3&quot;&gt;соединении с базой данных&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5851016a3fb15ec26147b80722e832005884d3e4" translate="yes" xml:space="preserve">
          <source>If an out-of-memory error occurs, then the return value from these routines is the same as if the column had contained an SQL NULL value. Valid SQL NULL returns can be distinguished from out-of-memory errors by invoking the &lt;a href=&quot;errcode&quot;&gt;sqlite3_errcode()&lt;/a&gt; immediately after the suspect return value is obtained and before any other SQLite interface is called on the same &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt;.</source>
          <target state="translated">Если возникает ошибка нехватки памяти, то возвращаемое значение из этих подпрограмм такое же, как если бы столбец содержал значение SQL NULL. Верные возвращаемые значения SQL NULL можно отличить от ошибок нехватки памяти, вызвав &lt;a href=&quot;errcode&quot;&gt;sqlite3_errcode ()&lt;/a&gt; сразу после получения подозрительного возвращаемого значения и перед вызовом любого другого интерфейса SQLite в том же &lt;a href=&quot;sqlite3&quot;&gt;соединении с базой данных&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="53a860ff4ceaa780f514879a263f3e2bd7a64b45" translate="yes" xml:space="preserve">
          <source>If an sqlite3_exec() callback returns non-zero, the sqlite3_exec() routine returns SQLITE_ABORT without invoking the callback again and without running any subsequent SQL statements.</source>
          <target state="translated">Если sqlite3_exec()возвращает ненулевое значение,рутина sqlite3_exec()возвращает SQLITE_ABORT без повторного вызова и без выполнения последующих SQL-запросов.</target>
        </trans-unit>
        <trans-unit id="86f2a1856f49f287cef6815b989e3bcfc9f7c019" translate="yes" xml:space="preserve">
          <source>If an update is only partially applied to the target database by the time sqlite3rbu_close() is called, state information is saved within the state database if it exists, or otherwise in the RBU database. This allows subsequent processes to automatically resume the RBU update from where it left off. If state information is stored in the RBU database, it can be removed by dropping all tables whose names begin with &quot;rbu_&quot;.</source>
          <target state="translated">Если к моменту вызова sqlite3rbu_close()обновление только частично применяется к целевой базе данных,то информация о состоянии сохраняется в базе данных состояния,если она существует,или в базе данных RBU.Это позволяет последующим процессам автоматически возобновить обновление RBU с того места,на котором оно было остановлено.Если информация о состоянии хранится в базе данных RBU,то ее можно удалить,опустив все таблицы,имена которых начинаются с &quot;rbu_&quot;.</target>
        </trans-unit>
        <trans-unit id="bd175412c5f187514ee87168844f1bedfa975635" translate="yes" xml:space="preserve">
          <source>If an xToken() callback returns any value other than SQLITE_OK, then the tokenization should be abandoned and the xTokenize() method should immediately return a copy of the xToken() return value. Or, if the input buffer is exhausted, xTokenize() should return SQLITE_OK. Finally, if an error occurs with the xTokenize() implementation itself, it may abandon the tokenization and return any error code other than SQLITE_OK or SQLITE_DONE.</source>
          <target state="translated">Если обратный вызов xToken()возвращает любое значение,отличное от SQLITE_OK,то следует отказаться от токенирования и метод xTokenize()должен немедленно вернуть копию возвращаемого значения xToken().Или,если входной буфер исчерпан,xTokenize()должна вернуть SQLITE_OK.Наконец,если возникает ошибка с самой реализацией xTokenize(),то она может отказаться от токенирования и вернуть любой код ошибки,отличный от SQLITE_OK или SQLITE_DONE.</target>
        </trans-unit>
        <trans-unit id="0be452758cf5838f411f1a08b26770962254070e" translate="yes" xml:space="preserve">
          <source>If and only if the previously described conversion of OR to an IN operator does not work, the second OR-clause optimization is attempted. Suppose the OR clause consists of multiple subterms as follows:</source>
          <target state="translated">Если и только если описанное ранее преобразование &quot;ИЛИ&quot; в оператор IN не работает,то предпринимается попытка второй оптимизации &quot;ИЛИ&quot;.Предположим,что условие &quot;ИЛИ&quot; состоит из нескольких подзаголовков следующим образом:</target>
        </trans-unit>
        <trans-unit id="1d92fd7f31be8d1f3061a17050b41ab1479f4bcd" translate="yes" xml:space="preserve">
          <source>If another database connection has the database mode open in &lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;exclusive locking mode&lt;/a&gt; then all queries against the database will return &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;. Both Chrome and Firefox open their database files in exclusive locking mode, so attempts to read Chrome or Firefox databases while the applications are running will run into this problem, for example.</source>
          <target state="translated">Если для другого соединения с базой данных открыт режим базы данных в режиме &lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;монопольной блокировки,&lt;/a&gt; то все запросы к базе данных будут возвращать &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; . И Chrome, и Firefox открывают свои файлы баз данных в режиме монопольной блокировки, поэтому, например, попытки читать базы данных Chrome или Firefox во время работы приложений могут столкнуться с этой проблемой.</target>
        </trans-unit>
        <trans-unit id="52c07a908a81f106b3dd1bc1b1492081c7a35d47" translate="yes" xml:space="preserve">
          <source>If another thread changes the autocommit status of the database connection while this routine is running, then the return value is undefined.</source>
          <target state="translated">Если во время выполнения данной рутины другой поток изменит статус автокомммиссии соединения с БД,то возвращаемое значение будет неопределенным.</target>
        </trans-unit>
        <trans-unit id="8503a498072091f7cabc2db6a10e976de9bc12b1" translate="yes" xml:space="preserve">
          <source>If another thread or process writes to the source database while this function is sleeping, then SQLite detects this and usually restarts the backup process when sqlite3_backup_step() is next called. There is one exception to this rule: If the source database is not an in-memory database, and the write is performed from within the same process as the backup operation and uses the same database handle (pDb), then the destination database (the one opened using connection pFile) is automatically updated along with the source. The backup process may then be continued after the sqlite3_sleep() call returns as if nothing had happened.</source>
          <target state="translated">Если другой поток или процесс записывает в исходную базу данных,пока эта функция находится в спящем режиме,то SQLite обнаруживает это и обычно перезапускает процесс резервного копирования при следующем вызове sqlite3_backup_step().Есть одно исключение из этого правила:если исходная база данных не является базой данных в памяти,а запись выполняется из того же процесса,что и операция резервного копирования,и при этом используется тот же самый хэндл базы данных (pDb),то база данных получателя (открытая с помощью функции соединения pFile)автоматически обновляется вместе с исходной.Затем процесс резервного копирования может быть продолжен после того,как вызов sqlite3_sleep()вернется как ни в чем не бывало.</target>
        </trans-unit>
        <trans-unit id="6abf22da0f107c51712228d5db063535c6a4d21a" translate="yes" xml:space="preserve">
          <source>If any application-defined SQL functions have potentially dangerous side-effects, or if they could potentially leak sensitive information to an attacker if misused, then tag those functions using the &lt;a href=&quot;c3ref/c_deterministic#sqlitedirectonly&quot;&gt;SQLITE_DIRECTONLY&lt;/a&gt; option on the &quot;enc&quot; parameter. This means that the function can never be run from schema-code even if the trusted-schema option is on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="452fe80b19e0f85e5121496bd6edf4647e872526" translate="yes" xml:space="preserve">
          <source>If any checksum is incorrect, the &quot;PRAGMA quick_check&quot; command will find it. To verify that checksums are actually enabled and running, use SQL like the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9f8be087686590dab771595e5bd54b7d246dba5" translate="yes" xml:space="preserve">
          <source>If any errors are encountered during compilation, an error message is written into memory obtained from &lt;b&gt;malloc&lt;/b&gt; and the 5th parameter is made to point to that memory. If the 5th parameter is NULL, then no error message is generated. If the 5th parameter is not NULL, then the calling function should dispose of the memory containing the error message by calling &lt;b&gt;sqlite_freemem&lt;/b&gt;.</source>
          <target state="translated">Если во время компиляции обнаруживаются какие-либо ошибки, сообщение об ошибке записывается в память, полученную из &lt;b&gt;malloc,&lt;/b&gt; и 5-й параметр указывается на эту память. Если 5-й параметр - ПУСТО (NULL), сообщение об ошибке не создается. Если 5-й параметр не равен NULL, вызывающая функция должна избавиться от памяти, содержащей сообщение об ошибке, путем вызова &lt;b&gt;sqlite_freemem&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="83125f64332cc16259858298cfafac27aca598bf" translate="yes" xml:space="preserve">
          <source>If any of the special-case entries shows above are omitted, then the value of 100 is used for insertion and deletion and 150 is used for substitution. To disable the default insertion, deletion, and/or substitution set their respective cost to 10000 or more.</source>
          <target state="translated">Если какая-либо из записей специального случая,показанных выше,опущена,то для вставки и удаления используется значение 100,а для подстановки-150.Чтобы отключить вставку,удаление и/или замену по умолчанию,установите их соответствующую стоимость равной 10000 или более.</target>
        </trans-unit>
        <trans-unit id="8b09289d91105f4036d96455156f97ad8f84efdf" translate="yes" xml:space="preserve">
          <source>If any of the sqlite3_bind_*() routines are called with a NULL pointer for the &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; or with a prepared statement for which &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; has been called more recently than &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset()&lt;/a&gt;, then the call will return &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_MISUSE&lt;/a&gt;. If any sqlite3_bind_() routine is passed a &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; that has been finalized, the result is undefined and probably harmful.</source>
          <target state="translated">Если какая-либо из подпрограмм sqlite3_bind _ * () вызывается с указателем NULL для &lt;a href=&quot;#sqlite3_stmt&quot;&gt;подготовленного оператора&lt;/a&gt; или с подготовленным оператором, для которого &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step ()&lt;/a&gt; был вызван позже, чем &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset ()&lt;/a&gt; , то вызов вернет &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_MISUSE&lt;/a&gt; . Если какой-либо подпрограмме sqlite3_bind_ () передается &lt;a href=&quot;#sqlite3_stmt&quot;&gt;подготовленный оператор&lt;/a&gt; , который был завершен, результат не определен и, вероятно, опасен.</target>
        </trans-unit>
        <trans-unit id="4d6ffdf1dd2e882d0d92b18297a217958bf3b943" translate="yes" xml:space="preserve">
          <source>If any of the sqlite3_bind_*() routines are called with a NULL pointer for the &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; or with a prepared statement for which &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; has been called more recently than &lt;a href=&quot;reset&quot;&gt;sqlite3_reset()&lt;/a&gt;, then the call will return &lt;a href=&quot;../rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt;. If any sqlite3_bind_() routine is passed a &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; that has been finalized, the result is undefined and probably harmful.</source>
          <target state="translated">Если какая-либо из подпрограмм sqlite3_bind _ * () вызывается с указателем NULL для &lt;a href=&quot;stmt&quot;&gt;подготовленного оператора&lt;/a&gt; или с подготовленным оператором, для которого &lt;a href=&quot;step&quot;&gt;sqlite3_step ()&lt;/a&gt; был вызван позже, чем &lt;a href=&quot;reset&quot;&gt;sqlite3_reset ()&lt;/a&gt; , то вызов вернет &lt;a href=&quot;../rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt; . Если какой-либо подпрограмме sqlite3_bind_ () передается &lt;a href=&quot;stmt&quot;&gt;подготовленный оператор&lt;/a&gt; , который был завершен, результат не определен и, вероятно, опасен.</target>
        </trans-unit>
        <trans-unit id="ecc451199e804c2d9bbaab7eeb8ae7260c861c03" translate="yes" xml:space="preserve">
          <source>If any of these options are defined, then the same set of SQLITE_OMIT_* options must also be defined when using the &lt;a href=&quot;lemon&quot;&gt;Lemon parser generator&lt;/a&gt; tool to generate the parse.c file and when compiling the 'mkkeywordhash' tool which generates the keywordhash.h file. Because of this, these options may only be used when the library is built from canonical source, not from the &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt;. Some SQLITE_OMIT_* options might work, or appear to work, when used with the &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt;. But this is not guaranteed. In general, always compile from canonical sources in order to take advantage of SQLITE_OMIT_* options.</source>
          <target state="translated">Если какой-либо из этих параметров определен, то такой же набор параметров SQLITE_OMIT_ * также должен быть определен при использовании инструмента &lt;a href=&quot;lemon&quot;&gt;генератора синтаксического анализатора Lemon&lt;/a&gt; для создания файла parse.c и при компиляции инструмента mkkeywordhash, который генерирует файл keywordhash.h. По этой причине эти параметры могут использоваться только в том случае, если библиотека построена из канонического источника, а не из &lt;a href=&quot;amalgamation&quot;&gt;объединения&lt;/a&gt; . Некоторые параметры SQLITE_OMIT_ * могут работать или казаться работающими при использовании с &lt;a href=&quot;amalgamation&quot;&gt;объединением&lt;/a&gt; . Но это не гарантируется. В общем, всегда компилируйте из канонических источников, чтобы воспользоваться опциями SQLITE_OMIT_ *.</target>
        </trans-unit>
        <trans-unit id="066af8ac5653f5f78e3e77b86a9535152f8106eb" translate="yes" xml:space="preserve">
          <source>If any other constraint violation occurs while applying a change (i.e. a UNIQUE, CHECK or NOT NULL constraint), the conflict handler is invoked with CHANGESET_CONSTRAINT as the second argument.</source>
          <target state="translated">Если при применении изменения происходит какое-либо другое нарушение ограничения (т.е.ограничение UNIQUE,CHECK или NOT NULL),то обработчик конфликта вызывается со вторым аргументом CHANGESET_CONSTRAINT.</target>
        </trans-unit>
        <trans-unit id="c1ffcbd8edc1e59c920bc1e42ef8ae6a08f1c489" translate="yes" xml:space="preserve">
          <source>If any other error occurs while flushing dirty pages to disk (for example an IO error or out-of-memory condition), then processing is abandoned and an SQLite &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; is returned to the caller immediately.</source>
          <target state="translated">Если при сбросе грязных страниц на диск возникает какая-либо другая ошибка (например, ошибка ввода-вывода или нехватка памяти), обработка прекращается, и вызывающей стороне немедленно возвращается &lt;a href=&quot;../rescode&quot;&gt;код ошибки&lt;/a&gt; SQLite .</target>
        </trans-unit>
        <trans-unit id="547159ba42f3dd194cd2ac6c73df9dfb51226b89" translate="yes" xml:space="preserve">
          <source>If any other error occurs while flushing dirty pages to disk (for example an IO error or out-of-memory condition), then processing is abandoned and an SQLite &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; is returned to the caller immediately.</source>
          <target state="translated">Если при сбросе грязных страниц на диск возникает какая-либо другая ошибка (например, ошибка ввода-вывода или нехватка памяти), обработка прекращается, и вызывающей стороне немедленно возвращается &lt;a href=&quot;rescode&quot;&gt;код ошибки&lt;/a&gt; SQLite .</target>
        </trans-unit>
        <trans-unit id="ed9a42f661215804821abb386ff5f31ffa1294e2" translate="yes" xml:space="preserve">
          <source>If any prior errors have occurred while constructing the dynamic string in sqlite3_str X, then the &lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_errcode(X)&lt;/a&gt; method will return an appropriate error code. The &lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_errcode(X)&lt;/a&gt; method returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOMEM&lt;/a&gt; following any out-of-memory error, or &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_TOOBIG&lt;/a&gt; if the size of the dynamic string exceeds &lt;a href=&quot;limits#max_length&quot;&gt;SQLITE_MAX_LENGTH&lt;/a&gt;, or &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; if there have been no errors.</source>
          <target state="translated">Если при построении динамической строки в sqlite3_str X произошли какие-либо предыдущие ошибки, то метод &lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_errcode (X)&lt;/a&gt; вернет соответствующий код ошибки. Метод &lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_errcode (X)&lt;/a&gt; возвращает &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOMEM&lt;/a&gt; после любой ошибки &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;нехватки&lt;/a&gt; памяти или SQLITE_TOOBIG, если размер динамической строки превышает &lt;a href=&quot;limits#max_length&quot;&gt;SQLITE_MAX_LENGTH&lt;/a&gt; , или &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK,&lt;/a&gt; если ошибок не было.</target>
        </trans-unit>
        <trans-unit id="2797997123bd9f48d4b03d213989316f5ee2db3a" translate="yes" xml:space="preserve">
          <source>If any prior errors have occurred while constructing the dynamic string in sqlite3_str X, then the &lt;a href=&quot;str_errcode&quot;&gt;sqlite3_str_errcode(X)&lt;/a&gt; method will return an appropriate error code. The &lt;a href=&quot;str_errcode&quot;&gt;sqlite3_str_errcode(X)&lt;/a&gt; method returns &lt;a href=&quot;../rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt; following any out-of-memory error, or &lt;a href=&quot;../rescode#toobig&quot;&gt;SQLITE_TOOBIG&lt;/a&gt; if the size of the dynamic string exceeds &lt;a href=&quot;../limits#max_length&quot;&gt;SQLITE_MAX_LENGTH&lt;/a&gt;, or &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; if there have been no errors.</source>
          <target state="translated">Если при построении динамической строки в sqlite3_str X произошли какие-либо предыдущие ошибки, то метод &lt;a href=&quot;str_errcode&quot;&gt;sqlite3_str_errcode (X)&lt;/a&gt; вернет соответствующий код ошибки. Метод &lt;a href=&quot;str_errcode&quot;&gt;sqlite3_str_errcode (X)&lt;/a&gt; возвращает &lt;a href=&quot;../rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt; после любой ошибки &lt;a href=&quot;../rescode#toobig&quot;&gt;нехватки&lt;/a&gt; памяти или SQLITE_TOOBIG, если размер динамической строки превышает &lt;a href=&quot;../limits#max_length&quot;&gt;SQLITE_MAX_LENGTH&lt;/a&gt; , или &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK,&lt;/a&gt; если ошибок не было.</target>
        </trans-unit>
        <trans-unit id="8cf62e1e5822970ab1a0772544bba1f6a9886bdb" translate="yes" xml:space="preserve">
          <source>If any views refer to table X in a way that is affected by the schema change, then drop those views using &lt;a href=&quot;lang_dropview&quot;&gt;DROP VIEW&lt;/a&gt; and recreate them with whatever changes are necessary to accommodate the schema change using &lt;a href=&quot;lang_createview&quot;&gt;CREATE VIEW&lt;/a&gt;.</source>
          <target state="translated">Если какие-либо представления ссылаются на таблицу X способом, на который влияет изменение схемы, отбросьте эти представления с помощью &lt;a href=&quot;lang_dropview&quot;&gt;DROP VIEW&lt;/a&gt; и воссоздайте их с любыми изменениями, необходимыми для адаптации к изменению схемы с помощью &lt;a href=&quot;lang_createview&quot;&gt;CREATE VIEW&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f4bcba20e82a98be0954f7a995f190f8be3b9e76" translate="yes" xml:space="preserve">
          <source>If argument P3 is non-zero, then it indicates that the sorter may assume that a stable sort considering the first P3 fields of each key is sufficient to produce the required results.</source>
          <target state="translated">Если аргумент P3 ненулевой,то это указывает на то,что сортировщик может предположить,что стабильный сорт,учитывающий первые поля P3 каждого ключа,достаточен для получения требуемого результата.</target>
        </trans-unit>
        <trans-unit id="35693c95846989c47eb6a922b6389598e5e5c2ef" translate="yes" xml:space="preserve">
          <source>If argument pnCol is not NULL, then *pnCol is set to the number of columns in the table.</source>
          <target state="translated">Если аргумент pnCol не NULL,то *pnCol задается количеством колонок в таблице.</target>
        </trans-unit>
        <trans-unit id="6eebf7ee5a909998cdac6e1af93d8bf0c4b9e6a9" translate="yes" xml:space="preserve">
          <source>If argument pzTab is not NULL, then *pzTab is set to point to a nul-terminated utf-8 encoded string containing the name of the table affected by the current change. The buffer remains valid until either sqlite3changeset_next() is called on the iterator or until the conflict-handler function returns. If pnCol is not NULL, then *pnCol is set to the number of columns in the table affected by the change. If pbIndirect is not NULL, then *pbIndirect is set to true (1) if the change is an indirect change, or false (0) otherwise. See the documentation for &lt;a href=&quot;#sqlite3session_indirect&quot;&gt;sqlite3session_indirect()&lt;/a&gt; for a description of direct and indirect changes. Finally, if pOp is not NULL, then *pOp is set to one of &lt;a href=&quot;c3ref/c_alter_table&quot;&gt;SQLITE_INSERT&lt;/a&gt;, &lt;a href=&quot;c3ref/c_alter_table&quot;&gt;SQLITE_DELETE&lt;/a&gt; or &lt;a href=&quot;c3ref/c_alter_table&quot;&gt;SQLITE_UPDATE&lt;/a&gt;, depending on the type of change that the iterator currently points to.</source>
          <target state="translated">Если аргумент pzTab не равен NULL, тогда * pzTab устанавливается так, чтобы указывать на закодированную строку utf-8 с завершающим нулем, содержащую имя таблицы, затронутой текущим изменением. Буфер остается действительным до тех пор, пока на итераторе не будет вызвана функция sqlite3changeset_next () или пока не вернется функция обработчика конфликтов. Если pnCol не равен NULL, тогда * pnCol устанавливается равным количеству столбцов в таблице, затронутых изменением. Если pbIndirect не NULL, тогда * pbIndirect устанавливается в значение true (1), если изменение является косвенным, или false (0) в противном случае. См. Документацию по &lt;a href=&quot;#sqlite3session_indirect&quot;&gt;sqlite3session_indirect ()&lt;/a&gt; для описания прямых и косвенных изменений. Наконец, если pOp не равен NULL, тогда * pOp устанавливается в одно из &lt;a href=&quot;c3ref/c_alter_table&quot;&gt;значений SQLITE_INSERT&lt;/a&gt; , &lt;a href=&quot;c3ref/c_alter_table&quot;&gt;SQLITE_DELETE&lt;/a&gt; или &lt;a href=&quot;c3ref/c_alter_table&quot;&gt;SQLITE_UPDATE.&lt;/a&gt;, в зависимости от типа изменения, на которое в настоящий момент указывает итератор.</target>
        </trans-unit>
        <trans-unit id="eeb423ada7e3f3af8ece536280a90cde13ccf0f0" translate="yes" xml:space="preserve">
          <source>If argument pzTab is not NULL, then *pzTab is set to point to a nul-terminated utf-8 encoded string containing the name of the table affected by the current change. The buffer remains valid until either sqlite3changeset_next() is called on the iterator or until the conflict-handler function returns. If pnCol is not NULL, then *pnCol is set to the number of columns in the table affected by the change. If pbIndirect is not NULL, then *pbIndirect is set to true (1) if the change is an indirect change, or false (0) otherwise. See the documentation for &lt;a href=&quot;sqlite3session_indirect&quot;&gt;sqlite3session_indirect()&lt;/a&gt; for a description of direct and indirect changes. Finally, if pOp is not NULL, then *pOp is set to one of &lt;a href=&quot;../c3ref/c_alter_table&quot;&gt;SQLITE_INSERT&lt;/a&gt;, &lt;a href=&quot;../c3ref/c_alter_table&quot;&gt;SQLITE_DELETE&lt;/a&gt; or &lt;a href=&quot;../c3ref/c_alter_table&quot;&gt;SQLITE_UPDATE&lt;/a&gt;, depending on the type of change that the iterator currently points to.</source>
          <target state="translated">Если аргумент pzTab не равен NULL, тогда * pzTab устанавливается так, чтобы указывать на закодированную строку utf-8 с завершающим нулем, содержащую имя таблицы, затронутой текущим изменением. Буфер остается действительным до тех пор, пока на итераторе не будет вызвана функция sqlite3changeset_next () или пока не вернется функция обработчика конфликтов. Если pnCol не равен NULL, тогда * pnCol устанавливается равным количеству столбцов в таблице, затронутых изменением. Если pbIndirect не NULL, тогда * pbIndirect устанавливается в значение true (1), если изменение является косвенным, или false (0) в противном случае. См. Документацию по &lt;a href=&quot;sqlite3session_indirect&quot;&gt;sqlite3session_indirect ()&lt;/a&gt; для описания прямых и косвенных изменений. Наконец, если pOp не равен NULL, тогда * pOp устанавливается в одно из &lt;a href=&quot;../c3ref/c_alter_table&quot;&gt;значений SQLITE_INSERT&lt;/a&gt; , &lt;a href=&quot;../c3ref/c_alter_table&quot;&gt;SQLITE_DELETE&lt;/a&gt; или &lt;a href=&quot;../c3ref/c_alter_table&quot;&gt;SQLITE_UPDATE.&lt;/a&gt;, в зависимости от типа изменения, на которое в настоящий момент указывает итератор.</target>
        </trans-unit>
        <trans-unit id="012db9d404feeb7b242a5f104e807e9ebcf5e6cc" translate="yes" xml:space="preserve">
          <source>If argument zTab is not NULL, then it is the name of a table to attach to the session object passed as the first argument. All subsequent changes made to the table while the session object is enabled will be recorded. See documentation for &lt;a href=&quot;#sqlite3session_changeset&quot;&gt;sqlite3session_changeset()&lt;/a&gt; for further details.</source>
          <target state="translated">Если аргумент zTab не равен NULL, то это имя таблицы, которую нужно присоединить к объекту сеанса, переданному в качестве первого аргумента. Все последующие изменения, внесенные в таблицу, пока объект сеанса включен, будут записаны. Дополнительную информацию см. В документации по &lt;a href=&quot;#sqlite3session_changeset&quot;&gt;sqlite3session_changeset ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1874355cfa55a648a95d55d6cc4ad4d5d5a5435f" translate="yes" xml:space="preserve">
          <source>If argument zTab is not NULL, then it is the name of a table to attach to the session object passed as the first argument. All subsequent changes made to the table while the session object is enabled will be recorded. See documentation for &lt;a href=&quot;sqlite3session_changeset&quot;&gt;sqlite3session_changeset()&lt;/a&gt; for further details.</source>
          <target state="translated">Если аргумент zTab не равен NULL, то это имя таблицы, которую нужно присоединить к объекту сеанса, переданному в качестве первого аргумента. Все последующие изменения, внесенные в таблицу, пока объект сеанса включен, будут записаны. Дополнительную информацию см. В документации по &lt;a href=&quot;sqlite3session_changeset&quot;&gt;sqlite3session_changeset ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="21fcaf7a804fb18a6bdf460073dabd9a55d816ad" translate="yes" xml:space="preserve">
          <source>If both SQLITE_STOREP2 and SQLITE_KEEPNULL flags are set then the content of r[P2] is only changed if the new value is NULL or 0 (false). In other words, a prior r[P2] value will not be overwritten by 1 (true).</source>
          <target state="translated">Если установлены оба флага SQLITE_STOREP2 и SQLITE_KEEPNULL,то содержимое r[P2]изменяется только в том случае,если новое значение NULL или 0 (false).Другими словами,предыдущее значение r[P2]не будет перезаписано значением 1 (true).</target>
        </trans-unit>
        <trans-unit id="f091230c98fc9fb42f84687fff668e2e8782487e" translate="yes" xml:space="preserve">
          <source>If both SQLITE_STOREP2 and SQLITE_KEEPNULL flags are set then the content of r[P2] is only changed if the new value is NULL or 1 (true). In other words, a prior r[P2] value will not be overwritten by 0 (false).</source>
          <target state="translated">Если установлены оба флага SQLITE_STOREP2 и SQLITE_KEEPNULL,то содержимое r[P2]изменяется только в том случае,если новое значение NULL или 1 (true).Другими словами,предыдущее значение r[P2]не будет перезаписано на 0 (false).</target>
        </trans-unit>
        <trans-unit id="b35b42f8226135f60e30979149548acecdb3cd9a" translate="yes" xml:space="preserve">
          <source>If both pragmas &lt;a href=&quot;pragma#pragma_short_column_names&quot;&gt;short_column_names&lt;/a&gt; and &lt;a href=&quot;pragma#pragma_full_column_names&quot;&gt;full_column_names&lt;/a&gt; are OFF then case (2) applies.</source>
          <target state="translated">Если обе &lt;a href=&quot;pragma#pragma_short_column_names&quot;&gt;прагмы short_column_names&lt;/a&gt; и &lt;a href=&quot;pragma#pragma_full_column_names&quot;&gt;full_column_names&lt;/a&gt; выключены, применяется case (2).</target>
        </trans-unit>
        <trans-unit id="c1ea5de7bdcea197233ed39232910d2d33159cd2" translate="yes" xml:space="preserve">
          <source>If certain kinds of errors occur on a statement within a multi-statement transaction (errors including &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_FULL&lt;/a&gt;, &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_IOERR&lt;/a&gt;, &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOMEM&lt;/a&gt;, &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY&lt;/a&gt;, and &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_INTERRUPT&lt;/a&gt;) then the transaction might be rolled back automatically. The only way to find out whether SQLite automatically rolled back the transaction after an error is to use this function.</source>
          <target state="translated">Если определенные виды ошибок возникают в инструкции в рамках транзакции с несколькими операторами (ошибки, включая &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_FULL&lt;/a&gt; , &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_IOERR&lt;/a&gt; , &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOMEM&lt;/a&gt; , &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY&lt;/a&gt; и &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_INTERRUPT&lt;/a&gt; ), транзакция может быть автоматически отменена . Единственный способ узнать, откатывает ли SQLite транзакцию автоматически после ошибки, - это использовать эту функцию.</target>
        </trans-unit>
        <trans-unit id="063cf3d6b1f8d89a285c8317271a90d08b9bd66c" translate="yes" xml:space="preserve">
          <source>If certain kinds of errors occur on a statement within a multi-statement transaction (errors including &lt;a href=&quot;../rescode#full&quot;&gt;SQLITE_FULL&lt;/a&gt;, &lt;a href=&quot;../rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt;, &lt;a href=&quot;../rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt;, &lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;, and &lt;a href=&quot;../rescode#interrupt&quot;&gt;SQLITE_INTERRUPT&lt;/a&gt;) then the transaction might be rolled back automatically. The only way to find out whether SQLite automatically rolled back the transaction after an error is to use this function.</source>
          <target state="translated">Если определенные виды ошибок возникают в инструкции в рамках транзакции с несколькими операторами (ошибки, включая &lt;a href=&quot;../rescode#full&quot;&gt;SQLITE_FULL&lt;/a&gt; , &lt;a href=&quot;../rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt; , &lt;a href=&quot;../rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt; , &lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; и &lt;a href=&quot;../rescode#interrupt&quot;&gt;SQLITE_INTERRUPT&lt;/a&gt; ), транзакция может быть автоматически отменена . Единственный способ узнать, откатывает ли SQLite транзакцию автоматически после ошибки, - это использовать эту функцию.</target>
        </trans-unit>
        <trans-unit id="65b57925e204e3ebe11c23e15127d898a0e33ca6" translate="yes" xml:space="preserve">
          <source>If certain kinds of errors occur within a transaction, the transaction may or may not be rolled back automatically. The errors that can cause an automatic rollback include:</source>
          <target state="translated">Если в рамках транзакции возникают определенные виды ошибок,то транзакция может автоматически откатываться,а может и не откатываться.К ошибкам,которые могут привести к автоматическому откату,относятся:</target>
        </trans-unit>
        <trans-unit id="debbf4ee0f449f15f2b2fad59057f8a4eccd847a" translate="yes" xml:space="preserve">
          <source>If changes occur on the same database connection after a query starts running but before the query completes, then it is undefined whether or not the query will see those changes.</source>
          <target state="translated">Если изменения происходят при одном и том же подключении к БД после начала выполнения запроса,но до его завершения,то неизвестно,будет ли запрос видеть эти изменения.</target>
        </trans-unit>
        <trans-unit id="92abf58210ebaa6ec510b645429d6e91e6ca04d8" translate="yes" xml:space="preserve">
          <source>If changes occur on the same database connection after a query starts running but before the query completes, then the query might return a changed row more than once, or it might return a row that was previously deleted.</source>
          <target state="translated">Если изменения происходят при одном и том же подключении к БД после начала выполнения запроса,но до его завершения,то запрос может вернуть измененную строку несколько раз,либо может вернуть ранее удаленную строку.</target>
        </trans-unit>
        <trans-unit id="437112dad4bafb7626f6351c41b7b34b2abfaca6" translate="yes" xml:space="preserve">
          <source>If changing into or out of WAL mode the procedure is more complicated.</source>
          <target state="translated">При переходе в режим WAL или из него процедура становится более сложной.</target>
        </trans-unit>
        <trans-unit id="f754396c33d700ad2fd9dbdfe823fd9ae27672f4" translate="yes" xml:space="preserve">
          <source>If column names are explicitly provided for the FTS table as part of the CREATE VIRTUAL TABLE statement, then a datatype name may be optionally specified for each column. This is pure syntactic sugar, the supplied typenames are not used by FTS or the SQLite core for any purpose. The same applies to any constraints specified along with an FTS column name - they are parsed but not used or recorded by the system in any way.</source>
          <target state="translated">Если имена столбцов явно предоставляются для таблицы FTS как часть оператора CREATE VIRTUAL TABLE,то для каждого столбца может быть опционально указано имя типа данных.Это чистый синтаксический сахар,поставляемые имена типов не используются FTS или ядром SQLite ни для каких целей.То же самое относится и к любым ограничениям,указанным вместе с именем столбца FTS-они анализируются,но не используются или не записываются системой каким-либо образом.</target>
        </trans-unit>
        <trans-unit id="4ec154d4b803f19da5aae8c26059349f5ffc0b8b" translate="yes" xml:space="preserve">
          <source>If conflict is with a remote UPDATE and the resolution is OMIT, then the old.* values are rebased using the new.* values in the remote change. Or, if the resolution is REPLACE, then the change is copied into the rebased changeset with updates to columns also updated by the conflicting remote UPDATE removed. If this means no columns would be updated, the change is omitted.</source>
          <target state="translated">Если конфликт произошел с удаленной UPDATE,а разрешение-OMIT,то старые.*значения пересчитываются,используя новые.*значения в удаленном изменении.Или,если разрешение REPLACE,то изменение копируется в rebased changeset с обновлениями в столбцы,которые также обновляются удаленным конфликтом UPDATE.Если это означает,что никакие колонки не будут обновлены,изменение опускается.</target>
        </trans-unit>
        <trans-unit id="eacad9fb0a3ce1ea1edfa735ab3f942dbf9e8cd8" translate="yes" xml:space="preserve">
          <source>If cursor P1 is an index, then the content is the key of the row. If cursor P2 is a table, then the content extracted is the data.</source>
          <target state="translated">Если курсор P1-это индекс,то его содержимое-это ключ строки.Если курсор P2-таблица,то извлекаемое содержимое-данные.</target>
        </trans-unit>
        <trans-unit id="ecd4bc0795e5315c7b840830ae1ae10db7944fd7" translate="yes" xml:space="preserve">
          <source>If cursor P1 is not open, jump to instruction P2. Otherwise, fall through.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0e0c624719d0c72631b398ea85cd293212feef6" translate="yes" xml:space="preserve">
          <source>If cursor P1 refers to an SQL table (B-Tree that uses integer keys), use the value in register P3 as a key. If cursor P1 refers to an SQL index, then P3 is the first in an array of P4 registers that are used as an unpacked index key.</source>
          <target state="translated">Если курсор P1 ссылается на таблицу SQL (B-дерево,использующее целочисленные ключи),используйте в качестве ключа значение в регистре P3.Если курсор P1 ссылается на индекс SQL,то P3 является первым в массиве регистров P4,которые используются в качестве распакованного индексного ключа.</target>
        </trans-unit>
        <trans-unit id="eed3ade81291c8b1e43812aa13b2f866776f9f36" translate="yes" xml:space="preserve">
          <source>If cursor P1 refers to an SQL table (B-Tree that uses integer keys), use the value in register P3 as the key. If cursor P1 refers to an SQL index, then P3 is the first in an array of P4 registers that are used as an unpacked index key.</source>
          <target state="translated">Если курсор P1 ссылается на таблицу SQL (B-дерево,использующее целочисленные ключи),используйте в качестве ключа значение в регистре P3.Если курсор P1 ссылается на индекс SQL,то P3 является первым в массиве регистров P4,которые используются в качестве распакованного индексного ключа.</target>
        </trans-unit>
        <trans-unit id="bde1d5766ee802e72c51189e7fb68596781976ad" translate="yes" xml:space="preserve">
          <source>If cursor P1 was previously moved via &lt;a href=&quot;opcode#DeferredSeek&quot;&gt;DeferredSeek&lt;/a&gt;, complete that seek operation now, without further delay. If the cursor seek has already occurred, this instruction is a no-op.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9a382b280888652763d650554446d773be05c07" translate="yes" xml:space="preserve">
          <source>If data is of type &lt;b&gt;text&lt;/b&gt; then the comparison is determined by the standard C data comparison functions &lt;b&gt;memcmp()&lt;/b&gt; or &lt;b&gt;strcmp()&lt;/b&gt;. The comparison looks at bytes from two inputs one by one and returns the first non-zero difference. Strings are '\000' terminated so shorter strings sort before longer strings, as you would expect.</source>
          <target state="translated">Если данные имеют &lt;b&gt;текстовый&lt;/b&gt; тип, то сравнение определяется стандартными функциями сравнения данных C &lt;b&gt;memcmp ()&lt;/b&gt; или &lt;b&gt;strcmp ()&lt;/b&gt; . Сравнение просматривает байты из двух входов один за другим и возвращает первую ненулевую разницу. Строки заканчиваются символом '\ 000', поэтому более короткие строки сортируются перед более длинными, как и следовало ожидать.</target>
        </trans-unit>
        <trans-unit id="0120d2592940874456695d5517c48510978290bc" translate="yes" xml:space="preserve">
          <source>If database zDb is the name of an attached database that is not in WAL mode, SQLITE_OK is returned and both *pnLog and *pnCkpt set to -1. If zDb is not NULL (or a zero length string) and is not the name of any attached database, SQLITE_ERROR is returned to the caller.</source>
          <target state="translated">Если база данных zDb-это имя подключенной базы данных,которая не находится в режиме WAL,то возвращается SQLITE_OK и оба *pnLog и *pnCkpt устанавливаются в -1.Если zDb не является NULL (или строкой нулевой длины)и не является именем ни одной из подключенных баз данных,то вызывающему абоненту возвращается SQLITE_ERROR.</target>
        </trans-unit>
        <trans-unit id="ed9f3d01c8cb63f65cf1f8cb1ada863d801c5821" translate="yes" xml:space="preserve">
          <source>If defined, support for sub-selects and the IN() operator are omitted.</source>
          <target state="translated">Если определено,то поддержка подвыборов и оператора IN()опускается.</target>
        </trans-unit>
        <trans-unit id="5f4710e921e7c9706b1a7d0affff80c102083b4a" translate="yes" xml:space="preserve">
          <source>If desired, you can verify the new database by running this command:</source>
          <target state="translated">При желании вы можете проверить новую БД,выполнив данную команду:</target>
        </trans-unit>
        <trans-unit id="d0b0b6a44b8709f88072f86b2bad9194c580b896" translate="yes" xml:space="preserve">
          <source>If either P1 or P2 is 0 (false) then the result is 0 even if the other input is NULL. A NULL and true or two NULLs give a NULL output.</source>
          <target state="translated">Если P1 или P2 равен 0 (ложь),то результат равен 0,даже если на другом входе NULL.NULL и true или два NULL дают результат NULL.</target>
        </trans-unit>
        <trans-unit id="0c5f4e14888f22c44de9608417d3500cbb09c876" translate="yes" xml:space="preserve">
          <source>If either P1 or P2 is nonzero (true) then the result is 1 (true) even if the other input is NULL. A NULL and false or two NULLs give a NULL output.</source>
          <target state="translated">Если P1 или P2 ненулевой (истина),то результат равен 1 (истина),даже если на другом входе NULL.NULL и false или два NULL дают результат NULL.</target>
        </trans-unit>
        <trans-unit id="f718f36fc0872a36f2f90015ef098011701953fd" translate="yes" xml:space="preserve">
          <source>If either P3 or the sorter contains a NULL in one of their significant fields (not counting the P4 fields at the end which are ignored) then the comparison is assumed to be equal.</source>
          <target state="translated">Если либо P3,либо сортировщик содержит NULL в одном из своих значимых полей (не считая P4 полей в конце,которые игнорируются),то сравнение считается равным.</target>
        </trans-unit>
        <trans-unit id="cb70cc2d7081446ae1bd92c809ed77dcb6489c40" translate="yes" xml:space="preserve">
          <source>If either X&lt;sub&gt;&lt;small&gt;i&lt;/small&gt;&lt;/sub&gt; or X&lt;sub&gt;&lt;small&gt;c&lt;/small&gt;&lt;/sub&gt; are non-numeric, then the boundary is the first row for which the expression &quot;X&lt;sub&gt;&lt;small&gt;i&lt;/small&gt;&lt;/sub&gt; IS X&lt;sub&gt;&lt;small&gt;c&lt;/small&gt;&lt;/sub&gt;&quot; is true.</source>
          <target state="translated">Если X &lt;sub&gt;&lt;small&gt;i&lt;/small&gt;&lt;/sub&gt; или X &lt;sub&gt;&lt;small&gt;c&lt;/small&gt;&lt;/sub&gt; нечисловые, то граница - это первая строка, для которой верно выражение &amp;laquo;X &lt;sub&gt;&lt;small&gt;i&lt;/small&gt;&lt;/sub&gt; IS X &lt;sub&gt;&lt;small&gt;c&lt;/small&gt;&lt;/sub&gt; &amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="40afda50342c1866ef5c9245fe131f4faa8b196a" translate="yes" xml:space="preserve">
          <source>If either operand has an explicit collating function assignment using the postfix &lt;a href=&quot;lang_expr#collateop&quot;&gt;COLLATE operator&lt;/a&gt;, then the explicit collating function is used for comparison, with precedence to the collating function of the left operand.</source>
          <target state="translated">Если какой-либо из операндов имеет явное назначение функции сортировки с использованием постфиксного &lt;a href=&quot;lang_expr#collateop&quot;&gt;оператора COLLATE&lt;/a&gt; , то для сравнения используется явная функция сортировки с приоритетом перед функцией сортировки левого операнда.</target>
        </trans-unit>
        <trans-unit id="55672cdef058eed493a94d268600f0dc4cf6e695" translate="yes" xml:space="preserve">
          <source>If either operand is a column, then the collating function of that column is used with precedence to the left operand. For the purposes of the previous sentence, a column name preceded by one or more unary &quot;+&quot; operators and/or CAST operators is still considered a column name.</source>
          <target state="translated">Если один из операндов является столбцом,то используется функция сопоставления этого столбца с предшествующим левым операндом.Для целей предыдущего предложения название столбца,которому предшествуют один или несколько одинарных операторов &quot;+&quot; и/или операторов CAST,по-прежнему считается названием столбца.</target>
        </trans-unit>
        <trans-unit id="c6ebcbeab69b86f653a3410afabe08a544dcaea8" translate="yes" xml:space="preserve">
          <source>If either the current value or the highwater mark is too large to be represented by a 32-bit integer, then the values returned by sqlite3_status() are undefined.</source>
          <target state="translated">Если текущее значение или отметка highwater слишком велика,чтобы быть представленным 32-битным целым числом,то значения,возвращаемые функцией sqlite3_status(),являются неопределенными.</target>
        </trans-unit>
        <trans-unit id="f734ad1cf91506e2435f2ec6895dbb828ca868ad" translate="yes" xml:space="preserve">
          <source>If everything is OK, the query above should return a single row where the second column is 1. Any other result indicates either that there is a checksum error, or checksum validation is disabled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10b7374ac7ffa60e3b709049b312d9aea49ec9de" translate="yes" xml:space="preserve">
          <source>If file-locking is enabled (it is enabled by default), then connections from multiple processes may also read and write the database file. However concurrency is reduced as follows:</source>
          <target state="translated">Если включена блокировка файлов (по умолчанию она включена),то соединения от нескольких процессов могут также читать и записывать файл базы данных.Однако параллельность уменьшается следующим образом:</target>
        </trans-unit>
        <trans-unit id="d3ef8fd536a105baf87d357ae62955ed380fa9cf" translate="yes" xml:space="preserve">
          <source>If foreign key constraints are enabled when it is prepared, the &lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt; command performs an implicit &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; to remove all rows from the table before dropping it. The implicit DELETE does not cause any SQL triggers to fire, but may invoke foreign key actions or constraint violations. If an immediate foreign key constraint is violated, the DROP TABLE statement fails and the table is not dropped. If a deferred foreign key constraint is violated, then an error is reported when the user attempts to commit the transaction if the foreign key constraint violations still exist at that point. Any &quot;foreign key mismatch&quot; errors encountered as part of an implicit DELETE are ignored.</source>
          <target state="translated">Если ограничения внешнего ключа включены, когда она подготовлена, команда &lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt; выполняет неявное &lt;a href=&quot;lang_delete&quot;&gt;УДАЛЕНИЕ,&lt;/a&gt; чтобы удалить все строки из таблицы перед ее удалением. Неявное DELETE не вызывает срабатывания каких-либо триггеров SQL, но может вызывать действия внешнего ключа или нарушения ограничений. Если непосредственное ограничение внешнего ключа нарушается, оператор DROP TABLE завершается ошибкой и таблица не удаляется. Если ограничение отложенного внешнего ключа нарушается, то при попытке пользователя зафиксировать транзакцию выдается сообщение об ошибке, если в этот момент все еще существуют нарушения ограничения внешнего ключа. Любые ошибки &amp;laquo;несоответствия внешнего ключа&amp;raquo;, обнаруженные как часть неявного DELETE, игнорируются.</target>
        </trans-unit>
        <trans-unit id="4f44f3a8f93f85a791245b413bb9ad1095b808f6" translate="yes" xml:space="preserve">
          <source>If foreign key constraints are enabled, disable them using &lt;a href=&quot;pragma#pragma_foreign_keys&quot;&gt;PRAGMA foreign_keys=OFF&lt;/a&gt;.</source>
          <target state="translated">Если ограничения внешнего ключа включены, отключите их с помощью &lt;a href=&quot;pragma#pragma_foreign_keys&quot;&gt;PRAGMA foreign_keys = OFF&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6a1eb421ae6f8eb8b7414f3ba7bf623bab8ed0c1" translate="yes" xml:space="preserve">
          <source>If foreign key constraints were originally enabled then run &lt;a href=&quot;pragma#pragma_foreign_key_check&quot;&gt;PRAGMA foreign_key_check&lt;/a&gt; to verify that the schema change did not break any foreign key constraints.</source>
          <target state="translated">Если ограничения внешнего ключа были изначально включены, запустите &lt;a href=&quot;pragma#pragma_foreign_key_check&quot;&gt;PRAGMA foreign_key_check,&lt;/a&gt; чтобы убедиться, что изменение схемы не нарушило никаких ограничений внешнего ключа.</target>
        </trans-unit>
        <trans-unit id="c13741cd4626e3d89fe66c4aae10d469f36c6a45" translate="yes" xml:space="preserve">
          <source>If foreign key handling is enabled, and applying a changeset leaves the database in a state containing foreign key violations, the conflict handler is invoked with CHANGESET_FOREIGN_KEY as the second argument exactly once before the changeset is committed. If the conflict handler returns CHANGESET_OMIT, the changes, including those that caused the foreign key constraint violation, are committed. Or, if it returns CHANGESET_ABORT, the changeset is rolled back.</source>
          <target state="translated">Если обработка постороннего ключа включена,а применение changeset оставляет базу данных в состоянии,содержащем нарушения постороннего ключа,то обработчик конфликта вызывается с CHANGESET_FOREIGN_KEY в качестве второго аргумента ровно один раз перед тем,как changeset будет зафиксирован.Если обработчик конфликта возвращает CHANGESET_OMIT,то происходят изменения,в том числе и те,которые привели к нарушению ограничения постороннего ключа.Или,если возвращается CHANGESET_ABORT,changeset откатывается.</target>
        </trans-unit>
        <trans-unit id="664ed429f3e8a71469131f1cf927d67cea7224ef" translate="yes" xml:space="preserve">
          <source>If foreign keys constraints were originally enabled, reenable them now.</source>
          <target state="translated">Если изначально были включены ограничения по иностранным ключам,включите их сейчас.</target>
        </trans-unit>
        <trans-unit id="ae0d6d454ce848e119fe19c9d3921a6301be3ccd" translate="yes" xml:space="preserve">
          <source>If it is not already attached to the session object passed as the first argument, this function attaches table zTbl in the same manner as the &lt;a href=&quot;#sqlite3session_attach&quot;&gt;sqlite3session_attach()&lt;/a&gt; function. If zTbl does not exist, or if it does not have a primary key, this function is a no-op (but does not return an error).</source>
          <target state="translated">Если он еще не прикреплен к объекту сеанса, переданному в качестве первого аргумента, эта функция присоединяет таблицу zTbl таким же образом, как &lt;a href=&quot;#sqlite3session_attach&quot;&gt;функция sqlite3session_attach ()&lt;/a&gt; . Если zTbl не существует или у него нет первичного ключа, эта функция не работает (но не возвращает ошибку).</target>
        </trans-unit>
        <trans-unit id="b18e9847f65d260e65a6581d1c54f05d17b07506" translate="yes" xml:space="preserve">
          <source>If it is not already attached to the session object passed as the first argument, this function attaches table zTbl in the same manner as the &lt;a href=&quot;sqlite3session_attach&quot;&gt;sqlite3session_attach()&lt;/a&gt; function. If zTbl does not exist, or if it does not have a primary key, this function is a no-op (but does not return an error).</source>
          <target state="translated">Если он еще не прикреплен к объекту сеанса, переданному в качестве первого аргумента, эта функция присоединяет таблицу zTbl таким же образом, как &lt;a href=&quot;sqlite3session_attach&quot;&gt;функция sqlite3session_attach ()&lt;/a&gt; . Если zTbl не существует или у него нет первичного ключа, эта функция не работает (но не возвращает ошибку).</target>
        </trans-unit>
        <trans-unit id="a8c1f9f82d9d1138df42ada4c0e8d4ac1b13017c" translate="yes" xml:space="preserve">
          <source>If many threads and/or processes need to write the database at the same instant (and they cannot queue up and take turns) then it is best to select a database engine that supports that capability, which always means a client/server database engine.</source>
          <target state="translated">Если многим потокам и/или процессам необходимо записывать базу данных в одно и то же время (и они не могут стоять в очереди и делать это по очереди),то лучше всего выбрать движок базы данных,поддерживающий эту возможность,что всегда означает движок базы данных клиент/сервер.</target>
        </trans-unit>
        <trans-unit id="277d800367bb442a2e4d79fba0d9ab386719bb03" translate="yes" xml:space="preserve">
          <source>If mmap_size is set to N then all current implementations map the first N bytes of the database file and use legacy xRead() calls for any content beyond N bytes. If the database file is smaller than N bytes, then the entire file is mapped. In the future, new OS interfaces could, in theory, map regions of the file other than the first N bytes, but no such implementation currently exists.</source>
          <target state="translated">Если mmap_size установлен в N,то все текущие реализации отображают первые N байт файла базы данных и используют legacy xRead()вызовы любого содержимого за пределами N байт.Если размер файла базы данных меньше N байт,то отображается весь файл.В будущем новые интерфейсы ОС теоретически могут отображать области файла,отличные от первых N байт,но в настоящее время такой реализации не существует.</target>
        </trans-unit>
        <trans-unit id="44cd764c270354ba3be43d380aabce5d77a1bc54" translate="yes" xml:space="preserve">
          <source>If more than one such fragment can be found, then fragments that contain a larger number of &quot;extra&quot; phrase matches are favored. The start of the selected text fragment may be moved a few tokens forward or backward to attempt to concentrate the phrase matches toward the center of the fragment.</source>
          <target state="translated">Если таких фрагментов больше одного,то предпочтение отдается фрагментам,содержащим большее количество &quot;лишних&quot; совпадений фраз.Начало выделенного фрагмента текста может быть сдвинуто на несколько маркеров вперед или назад,чтобы попытаться сконцентрировать совпадения фраз к центру фрагмента.</target>
        </trans-unit>
        <trans-unit id="26cb5f0f4343465953038f56daf635f7d45d2d33" translate="yes" xml:space="preserve">
          <source>If multi-threaded processing is enabled via the &lt;a href=&quot;pragma#pragma_threads&quot;&gt;PRAGMA threads&lt;/a&gt; setting, then sort operations will attempt to start helper threads when the amount of content to be sorted exceeds the minimum of the &lt;a href=&quot;pragma#pragma_cache_size&quot;&gt;cache_size&lt;/a&gt; and PMA Size determined by the &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigpmasz&quot;&gt;SQLITE_CONFIG_PMASZ&lt;/a&gt; start-time option. This compile-time option sets the default value for the &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigpmasz&quot;&gt;SQLITE_CONFIG_PMASZ&lt;/a&gt; start-time option. The default value is 250.</source>
          <target state="translated">Если многопоточная обработка включена с помощью параметра &lt;a href=&quot;pragma#pragma_threads&quot;&gt;PRAGMA Threads&lt;/a&gt; , то операции сортировки будут пытаться запустить вспомогательные потоки, когда объем сортируемого содержимого превышает минимум &lt;a href=&quot;pragma#pragma_cache_size&quot;&gt;cache_size&lt;/a&gt; и PMA Size, определяемый параметром &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigpmasz&quot;&gt;времени&lt;/a&gt; запуска SQLITE_CONFIG_PMASZ . Эта опция времени компиляции устанавливает значение по умолчанию для &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigpmasz&quot;&gt;опции времени&lt;/a&gt; начала SQLITE_CONFIG_PMASZ . Значение по умолчанию - 250.</target>
        </trans-unit>
        <trans-unit id="aefd863d94581cbe189ba146626a8379609c65b7" translate="yes" xml:space="preserve">
          <source>If multiple calls to sqlite3_create_function() specify the same function name, and the same number of arguments, and the same preferred text encoding, then the callbacks and other parameters of the second call overwrite the first, and the destructor callback from the first call (if it exists) is invoked.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="180acf91f65a788cf692bf4d0ecd25eb3f41224e" translate="yes" xml:space="preserve">
          <source>If multiple commands are being executed against the same SQLite database connection at the same time, the autocommit is deferred until the very last command completes. For example, if a SELECT statement is being executed, the execution of the command will pause as each row of the result is returned. During this pause other INSERT, UPDATE, or DELETE commands can be executed against other tables in the database. But none of these changes will commit until the original SELECT statement finishes.</source>
          <target state="translated">Если одновременно выполняется несколько команд при одном и том же подключении к БД SQLite,то автокомиссия откладывается до тех пор,пока не завершится самая последняя команда.Например,если выполняется оператор SELECT,выполнение команды будет отложено по мере возврата каждой строки результата.Во время этой паузы другие команды INSERT,UPDATE или DELETE могут выполняться против других таблиц в БД.Но ни одно из этих изменений не будет зафиксировано до тех пор,пока не завершится исходный оператор SELECT.</target>
        </trans-unit>
        <trans-unit id="02760b51331cbab337a4b4abdc9926115fb4b89f" translate="yes" xml:space="preserve">
          <source>If neither of these two query strategies can be used, all queries on FTS tables are implemented using a linear scan of the entire table. If the table contains large amounts of data, this may be an impractical approach (the first example on this page shows that a linear scan of 1.5 GB of data takes around 30 seconds using a modern PC).</source>
          <target state="translated">Если ни одна из этих двух стратегий запросов не может быть использована,то все запросы по таблицам FTS реализуются с использованием линейного сканирования всей таблицы.Если таблица содержит большое количество данных,то это может быть непрактичным подходом (первый пример на этой странице показывает,что линейное сканирование 1,5 ГБ данных занимает около 30 секунд при использовании современного ПК).</target>
        </trans-unit>
        <trans-unit id="46d15914a8966b2144fb307d96a3896b83eea8f4" translate="yes" xml:space="preserve">
          <source>If no</source>
          <target state="translated">Если нет</target>
        </trans-unit>
        <trans-unit id="d80775017369d9f582b22c2b8463af70c053cb1a" translate="yes" xml:space="preserve">
          <source>If no ROWID is specified on the insert, or if the specified ROWID has a value of NULL, then an appropriate ROWID is created automatically. The usual algorithm is to give the newly created row a ROWID that is one larger than the largest ROWID in the table prior to the insert. If the table is initially empty, then a ROWID of 1 is used. If the largest ROWID is equal to the largest possible integer (9223372036854775807) then the database engine starts picking positive candidate ROWIDs at random until it finds one that is not previously used. If no unused ROWID can be found after a reasonable number of attempts, the insert operation fails with an &lt;a href=&quot;rescode#full&quot;&gt;SQLITE_FULL&lt;/a&gt; error. If no negative ROWID values are inserted explicitly, then automatically generated ROWID values will always be greater than zero.</source>
          <target state="translated">Если во вставке не указан ROWID или если указанный ROWID имеет значение NULL, то соответствующий ROWID создается автоматически. Обычный алгоритм - присвоить вновь созданной строке ROWID, который на единицу больше, чем самый большой ROWID в таблице до вставки. Если таблица изначально пуста, то используется ROWID, равный 1. Если самый большой ROWID равен максимально возможному целому числу (9223372036854775807), тогда механизм базы данных начинает случайным образом выбирать положительные ROWID-кандидаты, пока не найдет тот, который ранее не использовался. Если после разумного количества попыток не удается найти неиспользуемый ROWID, операция вставки завершается ошибкой &lt;a href=&quot;rescode#full&quot;&gt;SQLITE_FULL&lt;/a&gt; . Если отрицательные значения ROWID не вставлены явно, автоматически сгенерированные значения ROWID всегда будут больше нуля.</target>
        </trans-unit>
        <trans-unit id="e2deadd7a9c793e3167a0e629e8b9b96ff70f176" translate="yes" xml:space="preserve">
          <source>If no error occurs, SQLITE_OK is returned.</source>
          <target state="translated">Если ошибки не происходит,возвращается SQLITE_OK.</target>
        </trans-unit>
        <trans-unit id="8e5398b47308ea9ae66110e9bb05403692680696" translate="yes" xml:space="preserve">
          <source>If no error occurs, SQLITE_OK is returned. If an error does occur, an SQLite error code is returned. The values of the output variables may not be trusted in this case.</source>
          <target state="translated">Если ошибки не происходит,возвращается SQLITE_OK.При возникновении ошибки возвращается код ошибки SQLite.В этом случае значения выходных переменных могут не доверять.</target>
        </trans-unit>
        <trans-unit id="b8dd386d2569bc5457aac9dba2010126d7a04d7d" translate="yes" xml:space="preserve">
          <source>If no master journal is involved, then a journal is hot if it exists and has a non-zero header and its corresponding database file does not have a RESERVED lock. If a master journal is named in the file journal, then the file journal is hot if its master journal exists and there is no RESERVED lock on the corresponding database file. It is important to understand when a journal is hot so the preceding rules will be repeated in bullets:</source>
          <target state="translated">Если главный журнал отсутствует,то журнал является &quot;горячим&quot;,если он существует,и имеет ненулевой заголовок,а соответствующий ему файл базы данных не имеет блокировки RESERVED (СБРОС).Если в файловом журнале есть имя главного журнала,то файловый журнал &quot;горячий&quot;,если он существует,и нет блокировки RESERVED на соответствующем файле базы данных.Важно понимать,когда журнал &quot;горячий&quot;,поэтому предыдущие правила будут повторяться пулями:</target>
        </trans-unit>
        <trans-unit id="e9ec2ab3e066aabbb424ce10a035adf5f5270552" translate="yes" xml:space="preserve">
          <source>If no row with matching primary key values is found in the database, the conflict-handler function is invoked with &lt;a href=&quot;#SQLITE_CHANGESET_CONFLICT&quot;&gt;SQLITE_CHANGESET_NOTFOUND&lt;/a&gt; passed as the second argument.</source>
          <target state="translated">Если в базе данных не найдено ни одной строки с совпадающими значениями первичного ключа, вызывается функция обработчика конфликтов с &lt;a href=&quot;#SQLITE_CHANGESET_CONFLICT&quot;&gt;SQLITE_CHANGESET_NOTFOUND,&lt;/a&gt; переданной в качестве второго аргумента.</target>
        </trans-unit>
        <trans-unit id="532395f09f545a6e9963ddaa843af136eeb8913b" translate="yes" xml:space="preserve">
          <source>If no row with matching primary key values is found in the database, the conflict-handler function is invoked with &lt;a href=&quot;c_changeset_conflict&quot;&gt;SQLITE_CHANGESET_NOTFOUND&lt;/a&gt; passed as the second argument.</source>
          <target state="translated">Если в базе данных не найдено ни одной строки с совпадающими значениями первичного ключа, вызывается функция обработчика конфликтов с &lt;a href=&quot;c_changeset_conflict&quot;&gt;SQLITE_CHANGESET_NOTFOUND,&lt;/a&gt; переданной в качестве второго аргумента.</target>
        </trans-unit>
        <trans-unit id="96d3acb3ee8eb3ea8e9644e28f8d2dc56f1b840a" translate="yes" xml:space="preserve">
          <source>If no super-journal is involved, then a journal is hot if it exists and has a non-zero header and its corresponding database file does not have a RESERVED lock. If a super-journal is named in the file journal, then the file journal is hot if its super-journal exists and there is no RESERVED lock on the corresponding database file. It is important to understand when a journal is hot so the preceding rules will be repeated in bullets:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5795a39454965fb21426bc7bb9e2147672f5e177" translate="yes" xml:space="preserve">
          <source>If none of the strings above occur anywhere in the type declaration, then the datatype is numeric. Note in particular that the datatype for columns with an empty type declaration is numeric.</source>
          <target state="translated">Если ни одна из приведенных выше строк нигде не встречается в объявлении типа,то тип данных является числовым.Обратите внимание,в частности,что тип данных для столбцов с пустым объявлением типа является числовым.</target>
        </trans-unit>
        <trans-unit id="5b0f610d4827d05770d8c3809730eca324b8d352" translate="yes" xml:space="preserve">
          <source>If offset iOffset is less than N bytes from the end of the BLOB, &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt; is returned and no data is read. If N or iOffset is less than zero, &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt; is returned and no data is read. The size of the blob (and hence the maximum value of N+iOffset) can be determined using the &lt;a href=&quot;#sqlite3_blob_bytes&quot;&gt;sqlite3_blob_bytes()&lt;/a&gt; interface.</source>
          <target state="translated">Если смещение iOffset меньше N байтов от конца BLOB, возвращается &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR,&lt;/a&gt; и данные не читаются. Если N или iOffset меньше нуля, возвращается &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt; и данные не читаются. Размер большого двоичного объекта (и, следовательно, максимальное значение N + iOffset) можно определить с помощью интерфейса &lt;a href=&quot;#sqlite3_blob_bytes&quot;&gt;sqlite3_blob_bytes ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bcc2dad992498753f10de4ee979d37a3e30daa67" translate="yes" xml:space="preserve">
          <source>If offset iOffset is less than N bytes from the end of the BLOB, &lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt; is returned and no data is read. If N or iOffset is less than zero, &lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt; is returned and no data is read. The size of the blob (and hence the maximum value of N+iOffset) can be determined using the &lt;a href=&quot;blob_bytes&quot;&gt;sqlite3_blob_bytes()&lt;/a&gt; interface.</source>
          <target state="translated">Если смещение iOffset меньше N байтов от конца BLOB, возвращается &lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR,&lt;/a&gt; и данные не читаются. Если N или iOffset меньше нуля, возвращается &lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt; и данные не читаются. Размер большого двоичного объекта (и, следовательно, максимальное значение N + iOffset) можно определить с помощью интерфейса &lt;a href=&quot;blob_bytes&quot;&gt;sqlite3_blob_bytes ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2e41507fc7f4f5f8ed7f1f9f86f50446d711b557" translate="yes" xml:space="preserve">
          <source>If one operand has INTEGER, REAL or NUMERIC affinity and the other operand has TEXT or BLOB or no affinity then NUMERIC affinity is applied to other operand.</source>
          <target state="translated">Если один операнд имеет ИНТЕГЕР,РЕАЛЬНОЕ или ЧИСЛОЧНОЕ сродство,а другой операнд имеет ТЕКСТ или КОЛИЧЕСТВО или не имеет сродства,то ЧИСЛОЧНОЕ сродство применяется к другому операнду.</target>
        </trans-unit>
        <trans-unit id="316990fa091894331a5bfab80d20b7d7b8a1b17a" translate="yes" xml:space="preserve">
          <source>If one operand has TEXT affinity and the other has no affinity, then TEXT affinity is applied to the other operand.</source>
          <target state="translated">Если один операнд имеет TEXT-аффинити,а другой нет,то TEXT-аффинити накладывается на другой операнд.</target>
        </trans-unit>
        <trans-unit id="4a746052c71f7cca567e925f8568ed0089126b0e" translate="yes" xml:space="preserve">
          <source>If one or more of the column values in the row inserted by the new change differ from those in the row deleted by the existing change, the existing DELETE is replaced by an UPDATE within the changegroup. Otherwise, if the inserted row is exactly the same as the deleted row, the existing DELETE is simply discarded.</source>
          <target state="translated">Если одно или несколько значений столбцов в строке,вставленной новым изменением,отличаются от значений в строке,удаленной существующим изменением,то существующая DELETE заменяется UPDATE в группе изменений.В противном случае,если вставленная строка в точности совпадает с удаленной,существующая DELETE просто отбрасывается.</target>
        </trans-unit>
        <trans-unit id="bbb903a0b2fa794db9f8ce5d76be92c6e8ad13da" translate="yes" xml:space="preserve">
          <source>If ownership of the pointer is passed into SQLite by providing a non-NULL D parameter to &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer()&lt;/a&gt; or &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer()&lt;/a&gt; then the ownership remains with SQLite until the object is destroyed. There is no way to transfer ownership out of SQLite and back into the application again.</source>
          <target state="translated">Если владение указателем передается в SQLite путем предоставления параметра D, отличного от NULL, для &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer ()&lt;/a&gt; или &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer (),&lt;/a&gt; то право собственности остается за SQLite до тех пор, пока объект не будет уничтожен. Невозможно передать право собственности из SQLite обратно в приложение.</target>
        </trans-unit>
        <trans-unit id="8503abe821374258f98c6ba5585311ca76bf6ece" translate="yes" xml:space="preserve">
          <source>If page 1 data is read as required by H35230, then the value of the</source>
          <target state="translated">Если данные на странице 1 считываются в соответствии с требованиями H35230,то значение параметра</target>
        </trans-unit>
        <trans-unit id="017b230392006407b67880da521173469a1b31d0" translate="yes" xml:space="preserve">
          <source>If parameter iCol is greater than or equal to the number of columns in the table, SQLITE_RANGE is returned. Or, if an error occurs (e.g. an OOM condition or IO error), an appropriate SQLite error code is returned.</source>
          <target state="translated">Если параметр iCol больше или равен количеству столбцов в таблице,возвращается SQLITE_RANGE.Или,если происходит ошибка (например,состояние OOM или ошибка ввода-вывода),возвращается соответствующий код ошибки SQLite.</target>
        </trans-unit>
        <trans-unit id="c373aca4c319795b45d2c1f0dc2245e638666f60" translate="yes" xml:space="preserve">
          <source>If parameter iCol is less than zero, set output variable *pnToken to the total number of tokens in the FTS5 table. Or, if iCol is non-negative but less than the number of columns in the table, return the total number of tokens in column iCol, considering all rows in the FTS5 table.</source>
          <target state="translated">Если параметр iCol меньше нуля,установите выходную переменную *pnToken на общее количество токенов в таблице FTS5.Или,если параметр iCol неотрицательный,но меньше количества столбцов в таблице,вернуть общее количество лексем в столбце iCol,учитывая все строки в таблице FTS5.</target>
        </trans-unit>
        <trans-unit id="686ce79e8e629eea956f529880e81a4b9a406c30" translate="yes" xml:space="preserve">
          <source>If parameter iCol is less than zero, set output variable *pnToken to the total number of tokens in the current row. Or, if iCol is non-negative but less than the number of columns in the table, set *pnToken to the number of tokens in column iCol of the current row.</source>
          <target state="translated">Если параметр iCol меньше нуля,установите выходную переменную *pnToken на общее количество токенов в текущей строке.Или,если параметр iCol неотрицательный,но меньше количества столбцов в таблице,установите *pnToken на количество токенов в столбце iCol текущей строки.</target>
        </trans-unit>
        <trans-unit id="88577f66da407130b6c2fbcee7dc6e283e2a74d7" translate="yes" xml:space="preserve">
          <source>If parameter zDb is NULL or points to a zero length string, then the specified operation is attempted on all WAL databases &lt;a href=&quot;../lang_attach&quot;&gt;attached&lt;/a&gt; to &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; db. In this case the values written to output parameters *pnLog and *pnCkpt are undefined. If an SQLITE_BUSY error is encountered when processing one or more of the attached WAL databases, the operation is still attempted on any remaining attached databases and SQLITE_BUSY is returned at the end. If any other error occurs while processing an attached database, processing is abandoned and the error code is returned to the caller immediately. If no error (SQLITE_BUSY or otherwise) is encountered while processing the attached databases, SQLITE_OK is returned.</source>
          <target state="translated">Если параметр zDb равен NULL или указывает на строку нулевой длины, то указанная операция выполняется для всех баз данных WAL, &lt;a href=&quot;../lang_attach&quot;&gt;подключенных&lt;/a&gt; к db &lt;a href=&quot;sqlite3&quot;&gt;соединения&lt;/a&gt; с базой данных . В этом случае значения, записанные в выходные параметры * pnLog и * pnCkpt, не определены. Если при обработке одной или нескольких подключенных баз данных WAL обнаруживается ошибка SQLITE_BUSY, операция все еще выполняется для всех оставшихся подключенных баз данных, и в конце возвращается SQLITE_BUSY. Если при обработке присоединенной базы данных возникает какая-либо другая ошибка, обработка прекращается, и вызывающей стороне немедленно возвращается код ошибки. Если при обработке подключенных баз данных не обнаружено ошибок (SQLITE_BUSY или иначе), возвращается SQLITE_OK.</target>
        </trans-unit>
        <trans-unit id="83e25a419f885754ebe2acacb05d4faa8a67cc7b" translate="yes" xml:space="preserve">
          <source>If parameter zDb is NULL or points to a zero length string, then the specified operation is attempted on all WAL databases &lt;a href=&quot;lang_attach&quot;&gt;attached&lt;/a&gt; to &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; db. In this case the values written to output parameters *pnLog and *pnCkpt are undefined. If an SQLITE_BUSY error is encountered when processing one or more of the attached WAL databases, the operation is still attempted on any remaining attached databases and SQLITE_BUSY is returned at the end. If any other error occurs while processing an attached database, processing is abandoned and the error code is returned to the caller immediately. If no error (SQLITE_BUSY or otherwise) is encountered while processing the attached databases, SQLITE_OK is returned.</source>
          <target state="translated">Если параметр zDb равен NULL или указывает на строку нулевой длины, то указанная операция выполняется для всех баз данных WAL, &lt;a href=&quot;lang_attach&quot;&gt;подключенных&lt;/a&gt; к db &lt;a href=&quot;#sqlite3&quot;&gt;соединения&lt;/a&gt; с базой данных . В этом случае значения, записанные в выходные параметры * pnLog и * pnCkpt, не определены. Если при обработке одной или нескольких подключенных баз данных WAL обнаруживается ошибка SQLITE_BUSY, операция все еще выполняется для всех оставшихся подключенных баз данных, и в конце возвращается SQLITE_BUSY. Если при обработке присоединенной базы данных возникает какая-либо другая ошибка, обработка прекращается, и вызывающей стороне немедленно возвращается код ошибки. Если при обработке подключенных баз данных не обнаружено ошибок (SQLITE_BUSY или иначе), возвращается SQLITE_OK.</target>
        </trans-unit>
        <trans-unit id="d5e79777c8fc72c43d9863555c6ca53f645883e2" translate="yes" xml:space="preserve">
          <source>If pnLog is not NULL, then *pnLog is set to the total number of frames in the log file or to -1 if the checkpoint could not run because of an error or because the database is not in &lt;a href=&quot;../wal&quot;&gt;WAL mode&lt;/a&gt;. If pnCkpt is not NULL,then *pnCkpt is set to the total number of checkpointed frames in the log file (including any that were already checkpointed before the function was called) or to -1 if the checkpoint could not run due to an error or because the database is not in WAL mode. Note that upon successful completion of an SQLITE_CHECKPOINT_TRUNCATE, the log file will have been truncated to zero bytes and so both *pnLog and *pnCkpt will be set to zero.</source>
          <target state="translated">Если pnLog не равен NULL, тогда * pnLog устанавливается равным общему количеству кадров в файле журнала или -1, если контрольная точка не может быть запущена из-за ошибки или потому что база данных не находится в &lt;a href=&quot;../wal&quot;&gt;режиме WAL&lt;/a&gt; . Если pnCkpt не NULL, тогда * pnCkpt устанавливается равным общему количеству кадров с контрольной точкой в ​​файле журнала (включая те, которые уже были контрольными точками до вызова функции) или в -1, если контрольная точка не может быть запущена из-за ошибки или потому что база данных не находится в режиме WAL. Обратите внимание, что после успешного завершения SQLITE_CHECKPOINT_TRUNCATE файл журнала будет усечен до нуля байтов, и поэтому и * pnLog, и * pnCkpt будут установлены в ноль.</target>
        </trans-unit>
        <trans-unit id="d64232e8314def054a53cca48179ce0748631809" translate="yes" xml:space="preserve">
          <source>If pnLog is not NULL, then *pnLog is set to the total number of frames in the log file or to -1 if the checkpoint could not run because of an error or because the database is not in &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt;. If pnCkpt is not NULL,then *pnCkpt is set to the total number of checkpointed frames in the log file (including any that were already checkpointed before the function was called) or to -1 if the checkpoint could not run due to an error or because the database is not in WAL mode. Note that upon successful completion of an SQLITE_CHECKPOINT_TRUNCATE, the log file will have been truncated to zero bytes and so both *pnLog and *pnCkpt will be set to zero.</source>
          <target state="translated">Если pnLog не равен NULL, тогда * pnLog устанавливается равным общему количеству кадров в файле журнала или -1, если контрольная точка не может быть запущена из-за ошибки или потому что база данных не находится в &lt;a href=&quot;wal&quot;&gt;режиме WAL&lt;/a&gt; . Если pnCkpt не NULL, тогда * pnCkpt устанавливается равным общему количеству кадров с контрольной точкой в ​​файле журнала (включая те, которые уже были контрольными точками до вызова функции) или в -1, если контрольная точка не может быть запущена из-за ошибки или потому что база данных не находится в режиме WAL. Обратите внимание, что после успешного завершения SQLITE_CHECKPOINT_TRUNCATE файл журнала будет усечен до нуля байтов, и поэтому и * pnLog, и * pnCkpt будут установлены в ноль.</target>
        </trans-unit>
        <trans-unit id="41dd1bdb1c62f1c1fa9eb1f2a9f608c75f290fb8" translate="yes" xml:space="preserve">
          <source>If present, output a more verbose report for each query analyzed.</source>
          <target state="translated">Если он присутствует,выводите более подробный отчет по каждому проанализированному запросу.</target>
        </trans-unit>
        <trans-unit id="dfd446567083de1e9ebdea0d18573182ac68033b" translate="yes" xml:space="preserve">
          <source>If pzTail is not NULL then *pzTail is made to point to the first byte past the end of the first SQL statement in zSql. These routines only compile the first statement in zSql, so *pzTail is left pointing to what remains uncompiled.</source>
          <target state="translated">Если pzTail не NULL,то *pzTail указывает на первый байт,прошедший через конец первого SQL-оператора в zSql.Эти процедуры компилируют только первый оператор в zSql,поэтому *pzTail указывает на то,что осталось не компилированным.</target>
        </trans-unit>
        <trans-unit id="daeeadf12f9cfe6f720cf3d4bdd4fb456397cc60" translate="yes" xml:space="preserve">
          <source>If r[P3] is zero or negative, that means there is no OFFSET and r[P2] is set to be the value of the LIMIT, r[P1].</source>
          <target state="translated">Если r[P3]равен нулю или отрицательному значению,это означает,что нет ОТМЕНА и r[P2]установлено значение ОГРАНИЧЕНИЯ,r[P1].</target>
        </trans-unit>
        <trans-unit id="6c50ebdc1c9d5314285662a0bf55da3e625fe7b5" translate="yes" xml:space="preserve">
          <source>If register P1 holds an integer convert it to a real value.</source>
          <target state="translated">Если регистр P1 содержит целое число,конвертирующее его в вещественное значение.</target>
        </trans-unit>
        <trans-unit id="24add31372893a82dd86705b4a5c1cbba71ea8ec" translate="yes" xml:space="preserve">
          <source>If required to truncate a database page from the end of the database file, the associated</source>
          <target state="translated">Если требуется усечь страницу базы данных с конца файла базы данных,то связанный с ним</target>
        </trans-unit>
        <trans-unit id="986e38dddb8763966fae3720cfb00c3ae4f64940" translate="yes" xml:space="preserve">
          <source>If result of an &lt;a href=&quot;opcode#Eq&quot;&gt;Eq&lt;/a&gt; comparison on the same two operands as the prior &lt;a href=&quot;opcode#Lt&quot;&gt;Lt&lt;/a&gt; or &lt;a href=&quot;opcode#Gt&quot;&gt;Gt&lt;/a&gt; would have been NULL or false (0), then then jump to P2. If the result of an &lt;a href=&quot;opcode#Eq&quot;&gt;Eq&lt;/a&gt; comparison on the two previous operands would have been true (1), then fall through.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3939be1758da993faac1647e5a0238d1c34fd401" translate="yes" xml:space="preserve">
          <source>If running in &lt;a href=&quot;../sharedcache&quot;&gt;shared cache mode&lt;/a&gt;, the application must guarantee that the shared cache used by the destination database is not accessed while the backup is running. In practice this means that the application must guarantee that the disk file being backed up to is not accessed by any connection within the process, not just the specific connection that was passed to sqlite3_backup_init().</source>
          <target state="translated">При работе в &lt;a href=&quot;../sharedcache&quot;&gt;режиме общего кэша&lt;/a&gt; приложение должно гарантировать, что общий кэш, используемый целевой базой данных, не будет доступен во время выполнения резервного копирования. На практике это означает, что приложение должно гарантировать, что к файлу диска, на который выполняется резервное копирование, не будет доступа ни одно соединение внутри процесса, а не только конкретное соединение, переданное в sqlite3_backup_init ().</target>
        </trans-unit>
        <trans-unit id="91671997be6a1d6d67488b4259ddff989b286fc6" translate="yes" xml:space="preserve">
          <source>If running in &lt;a href=&quot;sharedcache&quot;&gt;shared cache mode&lt;/a&gt;, the application must guarantee that the shared cache used by the destination database is not accessed while the backup is running. In practice this means that the application must guarantee that the disk file being backed up to is not accessed by any connection within the process, not just the specific connection that was passed to sqlite3_backup_init().</source>
          <target state="translated">При работе в &lt;a href=&quot;sharedcache&quot;&gt;режиме общего кэша&lt;/a&gt; приложение должно гарантировать, что общий кэш, используемый целевой базой данных, не будет доступен во время выполнения резервного копирования. На практике это означает, что приложение должно гарантировать, что к файлу диска, на который выполняется резервное копирование, не будет доступа ни одно соединение внутри процесса, а не только конкретное соединение, переданное в sqlite3_backup_init ().</target>
        </trans-unit>
        <trans-unit id="813ffbbe7a10f587c30164e3c760a93f923869e0" translate="yes" xml:space="preserve">
          <source>If set to 1, then the default &lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;locking_mode&lt;/a&gt; is set to EXCLUSIVE. If omitted or set to 0 then the default &lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;locking_mode&lt;/a&gt; is NORMAL.</source>
          <target state="translated">Если установлено в 1, то по умолчанию &lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;режим lock_mode&lt;/a&gt; установлен в EXCLUSIVE. Если опущено или установлено в 0, то по умолчанию &lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;режим lock_mode&lt;/a&gt; равен NORMAL.</target>
        </trans-unit>
        <trans-unit id="8dd726c58400329230cb7ffbb590015b7fc272ad" translate="yes" xml:space="preserve">
          <source>If single-thread mode has not been selected at compile-time or start-time, then individual database connections can be created as either multi-thread or serialized. It is not possible to downgrade an individual database connection to single-thread mode. Nor is it possible to escalate an individual database connection if the compile-time or start-time mode is single-thread.</source>
          <target state="translated">Если однопоточный режим не был выбран во время компиляции или запуска,то отдельные соединения БД можно создавать как многопоточные,так и сериализованные.Невозможно понизить класс индивидуального подключения к БД до однопоточного режима.Невозможно также перевести индивидуальное подключение к БД,если время компиляции или время запуска БД в однопоточный режим.</target>
        </trans-unit>
        <trans-unit id="297fbafe0f12618a3892916307ed5e193747b9f8" translate="yes" xml:space="preserve">
          <source>If single-thread mode is selected at compile-time, then critical mutexing logic is omitted from the build and it is impossible to enable either multi-thread or serialized modes at start-time or run-time.</source>
          <target state="translated">Если во время компиляции выбран однопоточный режим,то критическая логика мьютексинга опускается из сборки,и невозможно включить многопоточный или сериализованный режимы во время запуска или исполнения.</target>
        </trans-unit>
        <trans-unit id="bc15b1addaaecdb30cb643e4374238a5f983835b" translate="yes" xml:space="preserve">
          <source>If some future version of SQLite adds new ALTER TABLE capabilities, those capabilities will very likely use one of the two procedures outlined above.</source>
          <target state="translated">Если в какой-нибудь из будущих версий SQLite будут добавлены новые возможности ALTER TABLE,то эти возможности,скорее всего,будут использовать одну из двух процедур,описанных выше.</target>
        </trans-unit>
        <trans-unit id="a247ea4cd25be5ebc1e3446b36da4e3d6e48aaf1" translate="yes" xml:space="preserve">
          <source>If some other error occurs (e.g. an OOM condition), an SQLite error code is returned and *ppValue is set to NULL.</source>
          <target state="translated">При возникновении другой ошибки (например,условия OOM)возвращается код ошибки SQLite и *ppValue устанавливается в NULL.</target>
        </trans-unit>
        <trans-unit id="e277177a9a5ad8b0a8ae8ddf4692ab5b1cd48938" translate="yes" xml:space="preserve">
          <source>If specified, interpret all relative paths as relative to DIR, instead of the current working directory.</source>
          <target state="translated">Если указано,интерпретируйте все относительные пути как относительные к DIR,а не к текущей рабочей директории.</target>
        </trans-unit>
        <trans-unit id="c10bbb5923a9a453a504ada2ef95db3b448455c2" translate="yes" xml:space="preserve">
          <source>If specified, use file FILE as the archive. Otherwise, assume that the current &quot;main&quot; database is the archive to be operated on.</source>
          <target state="translated">Если указано,используйте в качестве архива файл FILE.В противном случае предположим,что текущей &quot;главной&quot; БД является архив,с которым необходимо работать.</target>
        </trans-unit>
        <trans-unit id="781f0c1e44a6d5e4cbc382e01b2a73157527db47" translate="yes" xml:space="preserve">
          <source>If sqlite3_backup_step() cannot obtain a required file-system lock, then the &lt;a href=&quot;#sqlite3_busy_handler&quot;&gt;busy-handler function&lt;/a&gt; is invoked (if one is specified). If the busy-handler returns non-zero before the lock is available, then &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY&lt;/a&gt; is returned to the caller. In this case the call to sqlite3_backup_step() can be retried later. If the source &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; is being used to write to the source database when sqlite3_backup_step() is called, then &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_LOCKED&lt;/a&gt; is returned immediately. Again, in this case the call to sqlite3_backup_step() can be retried later on. If &lt;a href=&quot;#SQLITE_ABORT_ROLLBACK&quot;&gt;SQLITE_IOERR_XXX&lt;/a&gt;, &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOMEM&lt;/a&gt;, or &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_READONLY&lt;/a&gt; is returned, then there is no point in retrying the call to sqlite3_backup_step(). These errors are considered fatal. The application must accept that the backup operation has failed and pass the backup operation handle to the sqlite3_backup_finish() to release associated resources.</source>
          <target state="translated">Если sqlite3_backup_step () не может получить требуемую блокировку файловой системы, то вызывается &lt;a href=&quot;#sqlite3_busy_handler&quot;&gt;функция обработчика занятости&lt;/a&gt; (если она указана). Если обработчик занятости возвращает ненулевое значение до того, как блокировка становится доступной, то &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;вызывающей стороне&lt;/a&gt; возвращается SQLITE_BUSY . В этом случае вызов sqlite3_backup_step () можно повторить позже. Если соединение с исходной &lt;a href=&quot;#sqlite3&quot;&gt;базой данных&lt;/a&gt; используется для записи в исходную базу данных при вызове sqlite3_backup_step (), &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;немедленно&lt;/a&gt; возвращается SQLITE_LOCKED . Опять же, в этом случае вызов sqlite3_backup_step () можно повторить позже. Если &lt;a href=&quot;#SQLITE_ABORT_ROLLBACK&quot;&gt;SQLITE_IOERR_XXX&lt;/a&gt; , &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOMEM&lt;/a&gt; или &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_READONLY&lt;/a&gt;возвращается, то нет смысла повторять вызов sqlite3_backup_step (). Эти ошибки считаются фатальными. Приложение должно признать, что операция резервного копирования завершилась неудачно, и передать дескриптор операции резервного копирования в sqlite3_backup_finish (), чтобы освободить связанные ресурсы.</target>
        </trans-unit>
        <trans-unit id="97664464d7946d7d0d5f82dbee0724dc2319f847" translate="yes" xml:space="preserve">
          <source>If sqlite3_backup_step() cannot obtain a required file-system lock, then the &lt;a href=&quot;busy_handler&quot;&gt;busy-handler function&lt;/a&gt; is invoked (if one is specified). If the busy-handler returns non-zero before the lock is available, then &lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; is returned to the caller. In this case the call to sqlite3_backup_step() can be retried later. If the source &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; is being used to write to the source database when sqlite3_backup_step() is called, then &lt;a href=&quot;../rescode#locked&quot;&gt;SQLITE_LOCKED&lt;/a&gt; is returned immediately. Again, in this case the call to sqlite3_backup_step() can be retried later on. If &lt;a href=&quot;../rescode#ioerr_access&quot;&gt;SQLITE_IOERR_XXX&lt;/a&gt;, &lt;a href=&quot;../rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt;, or &lt;a href=&quot;../rescode#readonly&quot;&gt;SQLITE_READONLY&lt;/a&gt; is returned, then there is no point in retrying the call to sqlite3_backup_step(). These errors are considered fatal. The application must accept that the backup operation has failed and pass the backup operation handle to the sqlite3_backup_finish() to release associated resources.</source>
          <target state="translated">Если sqlite3_backup_step () не может получить требуемую блокировку файловой системы, то вызывается &lt;a href=&quot;busy_handler&quot;&gt;функция обработчика занятости&lt;/a&gt; (если она указана). Если обработчик занятости возвращает ненулевое значение до того, как блокировка становится доступной, то &lt;a href=&quot;../rescode#busy&quot;&gt;вызывающей стороне&lt;/a&gt; возвращается SQLITE_BUSY . В этом случае вызов sqlite3_backup_step () можно повторить позже. Если соединение с исходной &lt;a href=&quot;sqlite3&quot;&gt;базой данных&lt;/a&gt; используется для записи в исходную базу данных при вызове sqlite3_backup_step (), &lt;a href=&quot;../rescode#locked&quot;&gt;немедленно&lt;/a&gt; возвращается SQLITE_LOCKED . Опять же, в этом случае вызов sqlite3_backup_step () можно повторить позже. Если &lt;a href=&quot;../rescode#ioerr_access&quot;&gt;SQLITE_IOERR_XXX&lt;/a&gt; , &lt;a href=&quot;../rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt; или &lt;a href=&quot;../rescode#readonly&quot;&gt;SQLITE_READONLY&lt;/a&gt;возвращается, то нет смысла повторять вызов sqlite3_backup_step (). Эти ошибки считаются фатальными. Приложение должно признать, что операция резервного копирования завершилась неудачно, и передать дескриптор операции резервного копирования в sqlite3_backup_finish (), чтобы освободить связанные ресурсы.</target>
        </trans-unit>
        <trans-unit id="416d4d371ff0cd3598d43dc30a0639c13aed646a" translate="yes" xml:space="preserve">
          <source>If sqlite3_deserialize(D,S,P,N,M,F) fails for any reason and if the SQLITE_DESERIALIZE_FREEONCLOSE bit is set in argument F, then &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free()&lt;/a&gt; is invoked on argument P prior to returning.</source>
          <target state="translated">Если sqlite3_deserialize (D, S, P, N, M, F) не работает по какой-либо причине и если в аргументе F установлен бит SQLITE_DESERIALIZE_FREEONCLOSE, то перед возвратом вызывается &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free ()&lt;/a&gt; для аргумента P.</target>
        </trans-unit>
        <trans-unit id="cec31d664476098d45397cb4e64acc667d8c0501" translate="yes" xml:space="preserve">
          <source>If sqlite3_deserialize(D,S,P,N,M,F) fails for any reason and if the SQLITE_DESERIALIZE_FREEONCLOSE bit is set in argument F, then &lt;a href=&quot;free&quot;&gt;sqlite3_free()&lt;/a&gt; is invoked on argument P prior to returning.</source>
          <target state="translated">Если sqlite3_deserialize (D, S, P, N, M, F) не работает по какой-либо причине и если в аргументе F установлен бит SQLITE_DESERIALIZE_FREEONCLOSE, то перед возвратом вызывается &lt;a href=&quot;free&quot;&gt;sqlite3_free ()&lt;/a&gt; для аргумента P.</target>
        </trans-unit>
        <trans-unit id="aeea9650fe067179f154dc4c0a23753bc2cbcaea" translate="yes" xml:space="preserve">
          <source>If sqlite3_malloc() fails during the processing of either routine (for example during a conversion from UTF-8 to UTF-16) then a NULL pointer is returned.</source>
          <target state="translated">Если sqlite3_malloc()дает сбой при обработке любой рутины (например,при преобразовании из UTF-8 в UTF-16),то возвращается указатель NULL.</target>
        </trans-unit>
        <trans-unit id="cac2f36b365eeaba945df88aa0f1da7631750708" translate="yes" xml:space="preserve">
          <source>If sqlite3_unlock_notify() is called in a multi-threaded application, there is a chance that the blocking connection will have already concluded its transaction by the time sqlite3_unlock_notify() is invoked. If this happens, then the specified callback is invoked immediately, from within the call to sqlite3_unlock_notify().</source>
          <target state="translated">Если sqlite3_unlock_notify()вызывается в многопоточном приложении,то есть вероятность того,что к моменту вызова sqlite3_unlock_notify()блокирующее соединение уже завершит свою транзакцию.Если это произойдет,то указанный обратный вызов вызывается немедленно,изнутри вызова sqlite3_unlock_notify().</target>
        </trans-unit>
        <trans-unit id="d3dbf8613ad9cf5c029072fff340e1a64123138d" translate="yes" xml:space="preserve">
          <source>If state database S does not exist when sqlite3rbu_vacuum() is invoked, it is automatically created and populated with the single table used to store the state of an RBU vacuum - &quot;rbu_state&quot;. If an ongoing RBU vacuum is suspended, this table is populated with state data. The next time sqlite3rbu_vacuum() is called with the same S parameter, it detects this data and attempts to resume the suspended vacuum operation. When an RBU vacuum operation is completed or encounters an error, RBU automatically deletes the contents of the rbu_state table. In this case, the next call to sqlite3rbu_vacuum() starts an entirely new vacuum operation from scratch.</source>
          <target state="translated">Если при вызове sqlite3rbu_vacuum()не существует базы данных состояния S,то она автоматически создается и заполняется единственной таблицей,в которой хранится состояние вакуума RBU-&quot;rbu_state&quot;.Если текущий вакуум RBU приостановлен,то эта таблица заполняется данными о состоянии.При следующем вызове sqlite3rbu_vacuum()с тем же параметром S,она обнаруживает эти данные и пытается возобновить приостановленную работу по вакууму.Когда операция по вакуумированию RBU завершается или обнаруживается ошибка,RBU автоматически удаляет содержимое таблицы rbu_state.В этом случае при следующем вызове sqlite3rbu_vacuum()начинается совершенно новая операция по вакуумированию с нуля.</target>
        </trans-unit>
        <trans-unit id="9b583cb7d9f730fb38a0d4c0658d985458639786" translate="yes" xml:space="preserve">
          <source>If step 1 was successful, an attempt is made to read the</source>
          <target state="translated">Если шаг 1 оказался успешным,то делается попытка прочитать</target>
        </trans-unit>
        <trans-unit id="95b4922965cf280511e54a7e6a975a3cf943cead" translate="yes" xml:space="preserve">
          <source>If successful, a pointer to a buffer containing the inverted changeset is stored in *ppOut, the size of the same buffer is stored in *pnOut, and SQLITE_OK is returned. If an error occurs, both *pnOut and *ppOut are zeroed and an SQLite error code returned.</source>
          <target state="translated">В случае успеха указатель на буфер,содержащий инвертированный changeset,хранится в *ppOut,размер того же буфера хранится в *pnOut,а SQLITE_OK возвращается.В случае ошибки,оба *pnOut и *ppOut обнуляются и возвращается код ошибки SQLite.</target>
        </trans-unit>
        <trans-unit id="2d2a26797b61cd3892af9cbfe95715fb203e64ff" translate="yes" xml:space="preserve">
          <source>If successful, this function returns SQLITE_OK and populates (*pp) with a pointer to a new sqlite3_changegroup object before returning. The caller should eventually free the returned object using a call to sqlite3changegroup_delete(). If an error occurs, an SQLite error code (i.e. SQLITE_NOMEM) is returned and *pp is set to NULL.</source>
          <target state="translated">В случае успеха эта функция возвращает SQLITE_OK и перед возвращением заполняет (*pp)указателем на новый объект sqlite3_changegroup.В конце концов,вызывающая функция должна освободить возвращенный объект с помощью вызова sqlite3changegroup_delete().При возникновении ошибки возвращается код ошибки SQLite (т.е.SQLITE_NOMEM)и *pp устанавливается в NULL.</target>
        </trans-unit>
        <trans-unit id="25d0330551ddd2fa16bdd016ab08a130f3f7634f" translate="yes" xml:space="preserve">
          <source>If successful, this function sets *ppValue to point to a protected sqlite3_value object containing the iVal'th value from the &quot;conflicting row&quot; associated with the current conflict-handler callback and returns SQLITE_OK.</source>
          <target state="translated">В случае успеха данная функция устанавливает *ppValue для указания на защищенный объект sqlite3_value,содержащий значение iVal'а из &quot;конфликтной строки&quot;,связанной с текущим обратным вызовом конфликтного обработчика,и возвращает SQLITE_OK.</target>
        </trans-unit>
        <trans-unit id="fa261183bb429d753dbe1a765227df127f987423" translate="yes" xml:space="preserve">
          <source>If successful, this function sets *ppValue to point to a protected sqlite3_value object containing the iVal'th value from the vector of new row values stored as part of the UPDATE or INSERT change and returns SQLITE_OK. If the change is an UPDATE and does not include a new value for the requested column, *ppValue is set to NULL and SQLITE_OK returned. The name of the function comes from the fact that this is similar to the &quot;new.*&quot; columns available to update or delete triggers.</source>
          <target state="translated">В случае успеха данная функция устанавливает *ppValue для указания на защищенный объект sqlite3_value,содержащий значение iVal'а из вектора значений новой строки,хранящегося в рамках изменения UPDATE или INSERT,и возвращает SQLITE_OK.Если изменение является UPDATE и не включает новое значение для запрашиваемой колонки,то *ppValue устанавливается в NULL и SQLITE_OK возвращается.Имя функции происходит от того,что оно аналогично колонкам &quot;new.*&quot;,доступным для обновления или удаления триггеров.</target>
        </trans-unit>
        <trans-unit id="8a04e15ae358710d2ad80e6a9a9c13bb73faba6b" translate="yes" xml:space="preserve">
          <source>If successful, this function sets *ppValue to point to a protected sqlite3_value object containing the iVal'th value from the vector of original row values stored as part of the UPDATE or DELETE change and returns SQLITE_OK. The name of the function comes from the fact that this is similar to the &quot;old.*&quot; columns available to update or delete triggers.</source>
          <target state="translated">В случае успеха функция устанавливает *ppValue для указания на защищенный объект sqlite3_value,содержащий значение iVal'а из вектора исходных значений строки,хранящегося в составе изменения UPDATE или DELETE и возвращает SQLITE_OK.Название функции происходит от того,что она похожа на столбцы &quot;old.*&quot;,доступные для обновления или удаления триггеров.</target>
        </trans-unit>
        <trans-unit id="5f323dfa9043b9e0668bb0be64be173c0214f5b4" translate="yes" xml:space="preserve">
          <source>If successful, xCreateFunction() returns SQLITE_OK. Otherwise, it returns an SQLite error code. In this case the xDestroy function is &lt;b&gt;not&lt;/b&gt; invoked.</source>
          <target state="translated">В случае успеха xCreateFunction () возвращает SQLITE_OK. В противном случае он возвращает код ошибки SQLite. В этом случае функция xDestroy &lt;b&gt;не&lt;/b&gt; вызывается.</target>
        </trans-unit>
        <trans-unit id="0c5491699943eedd46aaea7dc769af1705417f26" translate="yes" xml:space="preserve">
          <source>If successful, xCreateTokenizer() returns SQLITE_OK. Otherwise, it returns an SQLite error code. In this case the xDestroy function is &lt;b&gt;not&lt;/b&gt; invoked.</source>
          <target state="translated">В случае успеха xCreateTokenizer () возвращает SQLITE_OK. В противном случае он возвращает код ошибки SQLite. В этом случае функция xDestroy &lt;b&gt;не&lt;/b&gt; вызывается.</target>
        </trans-unit>
        <trans-unit id="128b9faf8d31130c2470e9c58674eddd1a9c50a3" translate="yes" xml:space="preserve">
          <source>If such a text fragment can be found, it is returned with the following modifications:</source>
          <target state="translated">Если такой фрагмент текста может быть найден,он возвращается со следующими изменениями:</target>
        </trans-unit>
        <trans-unit id="3d9b7696c9777c3fdef5f5f1690ef14ee23382d9" translate="yes" xml:space="preserve">
          <source>If the</source>
          <target state="translated">Если</target>
        </trans-unit>
        <trans-unit id="2b388f659392c2a3dcc9c7c0db559bd88cf8ff51" translate="yes" xml:space="preserve">
          <source>If the &quot;.output&quot; or &quot;.once&quot; commands have a &quot;-x&quot; argument, that causes them to accumulate output as Comma-Separated-Values (CSV) in a temporary file, then invoke the default system utility for viewing CSV files (usually a spreadsheet program) on the result. This is a quick way of sending the result of a query to a spreadsheet for easy viewing:</source>
          <target state="translated">Если команды &quot;.output&quot; или &quot;.once&quot; имеют аргумент &quot;-x&quot;,который заставляет их накапливать вывод в виде Comma-разделенных значений (CSV)во временном файле,то вызовите системную утилиту по умолчанию для просмотра CSV-файлов (обычно это программа для работы с электронными таблицами)на результат.Это быстрый способ отправки результата запроса в электронную таблицу для удобства просмотра:</target>
        </trans-unit>
        <trans-unit id="b4746f29b85def95350d80c6bb29ef47dac1ca98" translate="yes" xml:space="preserve">
          <source>If the &quot;.output&quot; or &quot;.once&quot; commands have an argument of &quot;-e&quot; then output is collected into a temporary file and the system text editor is invoked on that text file. Thus, the command &quot;.once -e&quot; achieves the same result as &quot;.once '|open -f'&quot; but with the benefit of being portable across all systems.</source>
          <target state="translated">Если команды &quot;.output&quot; или &quot;.once&quot; имеют аргумент &quot;-e&quot;,то вывод собирается во временный файл и в этом текстовом файле вызывается системный текстовый редактор.Таким образом,команда &quot;.once -e&quot; достигает того же результата,что и &quot;.once '|open -f'&quot;,но с пользой переносится на все системы.</target>
        </trans-unit>
        <trans-unit id="3daa35758772f94d91f7bd83ab5f9ceb0840b773" translate="yes" xml:space="preserve">
          <source>If the &quot;.recover&quot; command recovers one or more rows that it cannot attribute to any database table, the output script creates a &quot;lost_and_found&quot; table to store the orphaned rows. The schema of the lost_and_found table is as follows:</source>
          <target state="translated">Если команда &quot;.восстановить&quot; восстанавливает одну или несколько строк,которые она не может атрибутировать ни к одной из таблиц БД,то выходной скрипт создает таблицу &quot;lost_and_found&quot; для хранения осиротевших строк.Схема таблицы lost_and_found выглядит следующим образом:</target>
        </trans-unit>
        <trans-unit id="1ddf7f749d8128e48a3bd895bfea3bcecad29d40" translate="yes" xml:space="preserve">
          <source>If the &quot;CREATE VIRTUAL TABLE&quot; statement specifies module FTS4 (not FTS3), then special directives - FTS4 options - similar to the &quot;tokenize=*&quot; option may also appear in place of column names. An FTS4 option consists of the option name, followed by an &quot;=&quot; character, followed by the option value. The option value may optionally be enclosed in single or double quotes, with embedded quote characters escaped in the same way as for SQL literals. There may not be whitespace on either side of the &quot;=&quot; character. For example, to create an FTS4 table with the value of option &quot;matchinfo&quot; set to &quot;fts3&quot;:</source>
          <target state="translated">Если в операторе &quot;CREATE VIRTUAL TABLE&quot; указан модуль FTS4 (а не FTS3),то вместо названий колонок могут появиться специальные директивы-опции FTS4-аналогично опции &quot;tokenize=*&quot;.Опция FTS4 состоит из названия опции,за которым следует символ &quot;=&quot;,за которым следует значение опции.Значение опции может быть опционально заключено в одинарные или двойные кавычки,при этом встроенные символы кавычек экранируются так же,как и для SQL-литералов.Пробела по обеим сторонам от символа &quot;=&quot; могут отсутствовать.Например,создать таблицу FTS4 со значением опции &quot;matchinfo&quot;,установленным в &quot;fts3&quot;:</target>
        </trans-unit>
        <trans-unit id="77546b3dd108217dd30ccb1edbd6835383de8523" translate="yes" xml:space="preserve">
          <source>If the &quot;TEMP&quot; or &quot;TEMPORARY&quot; keyword occurs in between &quot;CREATE&quot; and &quot;VIEW&quot; then the view that is created is only visible to the &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; that created it and is automatically deleted when the database connection is closed.</source>
          <target state="translated">Если ключевое слово &amp;laquo;TEMP&amp;raquo; или &amp;laquo;TEMPORARY&amp;raquo; встречается между &amp;laquo;CREATE&amp;raquo; и &amp;laquo;VIEW&amp;raquo;, то созданное представление видно только для &lt;a href=&quot;c3ref/sqlite3&quot;&gt;соединения&lt;/a&gt; с базой данных, которое его создало, и автоматически удаляется при закрытии соединения с базой данных.</target>
        </trans-unit>
        <trans-unit id="e15eb31b4ca840d3439ac476fb29777eeeba453d" translate="yes" xml:space="preserve">
          <source>If the &quot;col&quot; column contains the value '*', then this column contains the number of rows of the FTS table that contain at least one instance of the term (in any column). If col contains an integer value, then this column contains the number of rows of the FTS table that contain at least one instance of the term in the column identified by the col value. As usual, the columns of the FTS table are numbered from left to right, starting with zero.</source>
          <target state="translated">Если в столбце &quot;столбец&quot; указано значение &quot;*&quot;,то в данном столбце указано количество строк таблицы FTS,содержащих хотя бы один экземпляр термина (в любом столбце).Если столбец содержит целое значение,то в данном столбце указывается количество строк таблицы FTS,которые содержат хотя бы один экземпляр термина в столбце,идентифицируемом значением столбца.Как обычно,столбцы таблицы FTS нумеруются слева направо,начиная с нуля.</target>
        </trans-unit>
        <trans-unit id="be0668162f080a59b68a89416d5dac39edc657f3" translate="yes" xml:space="preserve">
          <source>If the &quot;col&quot; column contains the value '*', then this column contains the total number of instances of the term in all rows of the FTS table (in any column). Otherwise, if col contains an integer value, then this column contains the total number of instances of the term that appear in the FTS table column identified by the col value.</source>
          <target state="translated">Если в столбце &quot;столбец&quot; указано значение &quot;*&quot;,то в данном столбце указано общее количество экземпляров термина во всех строках таблицы FTS (в любом столбце).В противном случае,если столбец содержит целое значение,то в данном столбце содержится общее количество экземпляров термина,встречающегося в столбце таблицы FTS и идентифицируемого значением столбца.</target>
        </trans-unit>
        <trans-unit id="f99db6ea5060e99b5afec54227ba46139ccc5e7b" translate="yes" xml:space="preserve">
          <source>If the &quot;schema&quot; is omitted, it defaults to the primary database (usually called 'main', unless renamed using &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigmaindbname&quot;&gt;SQLITE_DBCONFIG_MAINDBNAME&lt;/a&gt;). Hence, the following two queries are normally equivalent:</source>
          <target state="translated">Если &amp;laquo;схема&amp;raquo; опущена, по умолчанию используется первичная база данных (обычно называемая &amp;laquo;основной&amp;raquo;, если она не переименована с помощью &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigmaindbname&quot;&gt;SQLITE_DBCONFIG_MAINDBNAME&lt;/a&gt; ). Следовательно, следующие два запроса обычно эквивалентны:</target>
        </trans-unit>
        <trans-unit id="9f6d4e5f223a311e53834767137885dbc0d539c8" translate="yes" xml:space="preserve">
          <source>If the &quot;unordered&quot; argument is present, then the query planner assumes that the index is unordered and will not use the index for a range query or for sorting.</source>
          <target state="translated">Если аргумент &quot;неупорядоченный&quot; присутствует,то планировщик запросов предполагает,что индекс неупорядочен и не будет использовать его для запроса диапазона или для сортировки.</target>
        </trans-unit>
        <trans-unit id="8751a71ff20c3c0ca54298560e238a1beb92d451" translate="yes" xml:space="preserve">
          <source>If the $bigstring variable has both a string and a &quot;bytearray&quot; representation, then TCL inserts the value as a string. If it has only a &quot;bytearray&quot; representation, then the value is inserted as a BLOB. To force a value to be inserted as a BLOB even if it also has a text representation, use a &quot;@&quot; character to in place of the &quot;$&quot;. Like this:</source>
          <target state="translated">Если переменная $bigstring имеет и строковое,и &quot;байтеррейное&quot; представление,то TCL вставляет значение как строку.Если она имеет только &quot;байтеррей&quot;,то значение вставляется как BLOB.Чтобы заставить значение вставляться как BLOB,даже если оно также имеет текстовое представление,используйте символ &quot;@&quot; вместо &quot;$&quot;.Вот так:</target>
        </trans-unit>
        <trans-unit id="0c3adca9fee497a14e9991dafc4be56e1a6347bb" translate="yes" xml:space="preserve">
          <source>If the %Q formatting option is used instead of %q, like this:</source>
          <target state="translated">Если вместо %q используется опция форматирования %Q,например,так:</target>
        </trans-unit>
        <trans-unit id="0d1bfccef6e7ea95fdaf4eab71d72c15d5446d0c" translate="yes" xml:space="preserve">
          <source>If the --vtab option is passed to sqldiff.exe, then it ignores all underlying shadow tables belonging to an FTS3, FTS5 or rtree virtual table and instead includes the virtual table differences directly.</source>
          <target state="translated">Если опция --vtab передается в sqldiff.exe,то она игнорирует все лежащие в основе теневые таблицы,принадлежащие виртуальной таблице FTS3,FTS5 или rtree,и вместо этого напрямую включает в себя виртуальные различия таблиц.</target>
        </trans-unit>
        <trans-unit id="07a5d9f4ebefe616bbce2e1699c303419392f340" translate="yes" xml:space="preserve">
          <source>If the 2nd parameter actually contains two or more statements of SQL, only the first statement is compiled. (This is different from the behavior of &lt;b&gt;sqlite_exec&lt;/b&gt; which executes all SQL statements in its input string.) The 3rd parameter to &lt;b&gt;sqlite_compile&lt;/b&gt; is made to point to the first character beyond the end of the first statement of SQL in the input. If the 2nd parameter contains only a single SQL statement, then the 3rd parameter will be made to point to the '\000' terminator at the end of the 2nd parameter.</source>
          <target state="translated">Если 2-й параметр фактически содержит два или более операторов SQL, компилируется только первый оператор. (Это отличается от поведения &lt;b&gt;sqlite_exec,&lt;/b&gt; который выполняет все операторы SQL в своей входной строке.) Третий параметр &lt;b&gt;sqlite_compile&lt;/b&gt; указывает на первый символ после конца первого оператора SQL во входных данных. Если 2-й параметр содержит только один оператор SQL, тогда 3-й параметр будет указывать на терминатор '\ 000' в конце 2-го параметра.</target>
        </trans-unit>
        <trans-unit id="ace6723edaabac46df7516bfbb37cb232ed631b4" translate="yes" xml:space="preserve">
          <source>If the 2nd parameter to sqlite3_exec() is a NULL pointer, a pointer to an empty string, or a pointer that contains only whitespace and/or SQL comments, then no SQL statements are evaluated and the database is not changed.</source>
          <target state="translated">Если 2-й параметр sqlite3_exec()является указателем NULL,указателем на пустую строку или указателем,содержащим только пробелы и/или SQL-комментарии,то SQL-операторы не обрабатываются и база данных не изменяется.</target>
        </trans-unit>
        <trans-unit id="c83d25737a958db458bb466d715ef1df1385742b" translate="yes" xml:space="preserve">
          <source>If the 3rd parameter to sqlite3_open_v2() is not one of the combinations shown above optionally combined with other &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_* bits&lt;/a&gt; then the behavior is undefined.</source>
          <target state="translated">Если третий параметр sqlite3_open_v2 () не является одной из комбинаций, показанных выше, необязательно в сочетании с другими &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;битами SQLITE_OPEN_ *,&lt;/a&gt; то поведение не определено.</target>
        </trans-unit>
        <trans-unit id="a1fab614cdb3090bc486b1f93bb2bcc48a6de130" translate="yes" xml:space="preserve">
          <source>If the 3rd parameter to sqlite3_open_v2() is not one of the combinations shown above optionally combined with other &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_* bits&lt;/a&gt; then the behavior is undefined.</source>
          <target state="translated">Если третий параметр sqlite3_open_v2 () не является одной из комбинаций, показанных выше, необязательно в сочетании с другими &lt;a href=&quot;c_open_autoproxy&quot;&gt;битами SQLITE_OPEN_ *,&lt;/a&gt; то поведение не определено.</target>
        </trans-unit>
        <trans-unit id="fab55d69b6d16a6b2315e4a3b04227ca982143b2" translate="yes" xml:space="preserve">
          <source>If the 3rd parameter to sqlite3_open_v2() is not one of the required combinations shown above optionally combined with other &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_* bits&lt;/a&gt; then the behavior is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eafad762f6d4301ebb9f9fbfe8b641eb52751808" translate="yes" xml:space="preserve">
          <source>If the 3rd parameter to sqlite3_open_v2() is not one of the required combinations shown above optionally combined with other &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_* bits&lt;/a&gt; then the behavior is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34c05ef78416159159b83c40de507c749c65acd9" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_NOMUTEX&lt;/a&gt; flag is set, then the database connection opens in the multi-thread &lt;a href=&quot;threadsafe&quot;&gt;threading mode&lt;/a&gt; as long as the single-thread mode has not been set at compile-time or start-time. If the &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_FULLMUTEX&lt;/a&gt; flag is set then the database connection opens in the serialized &lt;a href=&quot;threadsafe&quot;&gt;threading mode&lt;/a&gt; unless single-thread was previously selected at compile-time or start-time. The &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_SHAREDCACHE&lt;/a&gt; flag causes the database connection to be eligible to use &lt;a href=&quot;sharedcache&quot;&gt;shared cache mode&lt;/a&gt;, regardless of whether or not shared cache is enabled using &lt;a href=&quot;#sqlite3_enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache()&lt;/a&gt;. The &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_PRIVATECACHE&lt;/a&gt; flag causes the database connection to not participate in &lt;a href=&quot;sharedcache&quot;&gt;shared cache mode&lt;/a&gt; even if it is enabled.</source>
          <target state="translated">Если &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;установлен&lt;/a&gt; флаг SQLITE_OPEN_NOMUTEX , соединение с базой данных открывается в &lt;a href=&quot;threadsafe&quot;&gt;многопоточном режиме&lt;/a&gt; до тех пор, пока однопоточный режим не был установлен во время компиляции или запуска. Если &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;установлен&lt;/a&gt; флаг SQLITE_OPEN_FULLMUTEX, соединение с базой данных открывается в режиме сериализованных &lt;a href=&quot;threadsafe&quot;&gt;потоков,&lt;/a&gt; если только однопоточный не был выбран ранее во время компиляции или запуска. &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_SHAREDCACHE&lt;/a&gt; флаг вызывает соединение с базой данных , чтобы иметь право использовать &lt;a href=&quot;sharedcache&quot;&gt;режим общего кэша&lt;/a&gt; , независимо от наличия или отсутствия общего кэша включается с помощью &lt;a href=&quot;#sqlite3_enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache ()&lt;/a&gt; . &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_PRIVATECACHE&lt;/a&gt;Флаг заставляет соединение с базой данных не участвовать в &lt;a href=&quot;sharedcache&quot;&gt;режиме общего кэша,&lt;/a&gt; даже если он включен.</target>
        </trans-unit>
        <trans-unit id="f124aef410c3a3a5452b1a6fa293c0baf98a2590" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB handle&lt;/a&gt; passed as the first argument was not opened for writing (the flags parameter to &lt;a href=&quot;#sqlite3_blob_open&quot;&gt;sqlite3_blob_open()&lt;/a&gt; was zero), this function returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_READONLY&lt;/a&gt;.</source>
          <target state="translated">Если &lt;a href=&quot;#sqlite3_blob&quot;&gt;дескриптор &lt;/a&gt;&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;большого двоичного объекта,&lt;/a&gt; переданный в качестве первого аргумента, не был открыт для записи (параметр flags для &lt;a href=&quot;#sqlite3_blob_open&quot;&gt;sqlite3_blob_open ()&lt;/a&gt; был равен нулю), эта функция возвращает SQLITE_READONLY .</target>
        </trans-unit>
        <trans-unit id="b097a680522bfef6d5db94910e22cbe0a87ca6c4" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen&lt;/a&gt; method sets the sqlite3_file.pMethods element to a non-NULL pointer, then the sqlite3_io_methods.xClose method may be invoked even if the &lt;a href=&quot;#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen&lt;/a&gt; reported that it failed. The only way to prevent a call to xClose following a failed &lt;a href=&quot;#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen&lt;/a&gt; is for the &lt;a href=&quot;#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen&lt;/a&gt; to set the sqlite3_file.pMethods element to NULL.</source>
          <target state="translated">Если метод &lt;a href=&quot;#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen&lt;/a&gt; устанавливает для элемента sqlite3_file.pMethods указатель, отличный от NULL, то метод sqlite3_io_methods.xClose может быть вызван, даже если &lt;a href=&quot;#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen&lt;/a&gt; сообщил, что он не удался. Единственный способ предотвратить вызов xClose после неудачного &lt;a href=&quot;#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen&lt;/a&gt; является для &lt;a href=&quot;#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen&lt;/a&gt; , чтобы установить элемент sqlite3_file.pMethods в NULL.</target>
        </trans-unit>
        <trans-unit id="c4075392a6aa7bc2b0c022c207b5beef854359fa" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;#sqlitefcntlbeginatomicwrite&quot; id=&quot;sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&lt;/a&gt; opcode returns SQLITE_OK, then the file descriptor is placed in &quot;batch write mode&quot;, which means all subsequent write operations will be deferred and done atomically at the next &lt;a href=&quot;#sqlitefcntlcommitatomicwrite&quot;&gt;SQLITE_FCNTL_COMMIT_ATOMIC_WRITE&lt;/a&gt;. Systems that do not support batch atomic writes will return SQLITE_NOTFOUND. Following a successful SQLITE_FCNTL_BEGIN_ATOMIC_WRITE and prior to the closing &lt;a href=&quot;#sqlitefcntlcommitatomicwrite&quot;&gt;SQLITE_FCNTL_COMMIT_ATOMIC_WRITE&lt;/a&gt; or &lt;a href=&quot;#sqlitefcntlrollbackatomicwrite&quot;&gt;SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE&lt;/a&gt;, SQLite will make no VFS interface calls on the same &lt;a href=&quot;#sqlite3_file&quot;&gt;sqlite3_file&lt;/a&gt; file descriptor except for calls to the xWrite method and the xFileControl method with &lt;a href=&quot;#sqlitefcntlsizehint&quot;&gt;SQLITE_FCNTL_SIZE_HINT&lt;/a&gt;.</source>
          <target state="translated">Если код операции &lt;a href=&quot;#sqlitefcntlbeginatomicwrite&quot; id=&quot;sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&lt;/a&gt; возвращает SQLITE_OK, то дескриптор файла переводится в &amp;laquo;режим пакетной записи&amp;raquo;, что означает, что все последующие операции записи будут отложены и будут выполняться атомарно при следующей записи &lt;a href=&quot;#sqlitefcntlcommitatomicwrite&quot;&gt;SQLITE_FCNTL_COMMIT_ATOMIC_WRITE&lt;/a&gt; . Системы, которые не поддерживают пакетную атомарную запись, вернут SQLITE_NOTFOUND. После успешного SQLITE_FCNTL_BEGIN_ATOMIC_WRITE и до закрытия &lt;a href=&quot;#sqlitefcntlcommitatomicwrite&quot;&gt;SQLITE_FCNTL_COMMIT_ATOMIC_WRITE&lt;/a&gt; или &lt;a href=&quot;#sqlitefcntlrollbackatomicwrite&quot;&gt;SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE&lt;/a&gt; , SQLite не будет делать никаких вызовов интерфейса VFS на одном &lt;a href=&quot;#sqlite3_file&quot;&gt;sqlite3_file&lt;/a&gt; дескриптора файла для вызова метода xWrite и метод xFileControl с исключением &lt;a href=&quot;#sqlitefcntlsizehint&quot;&gt;SQLITE_FCNTL_SIZE_HINT&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="eadccb78851e96452064935ca6338980e2d4c8f7" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;../vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt; method calls sqlite3_vtab_nochange() and finds that the column is not changed by the UPDATE statement, then the xColumn method can optionally return without setting a result, without calling any of the &lt;a href=&quot;result_blob&quot;&gt;sqlite3_result_xxxxx() interfaces&lt;/a&gt;. In that case, &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_nochange(X)&lt;/a&gt; will return true for the same column in the &lt;a href=&quot;../vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; method.</source>
          <target state="translated">Если метод &lt;a href=&quot;../vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt; вызывает sqlite3_vtab_nochange () и обнаруживает, что столбец не изменен оператором UPDATE, то метод xColumn может при желании вернуться без установки результата, без вызова каких-либо &lt;a href=&quot;result_blob&quot;&gt;интерфейсов sqlite3_result_xxxxx ()&lt;/a&gt; . В этом случае &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_nochange (X)&lt;/a&gt; вернет true для того же столбца в методе &lt;a href=&quot;../vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a8a1933767ab95a99c4ac8ef45461802121a0a08" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;blob&quot;&gt;BLOB handle&lt;/a&gt; passed as the first argument was not opened for writing (the flags parameter to &lt;a href=&quot;blob_open&quot;&gt;sqlite3_blob_open()&lt;/a&gt; was zero), this function returns &lt;a href=&quot;../rescode#readonly&quot;&gt;SQLITE_READONLY&lt;/a&gt;.</source>
          <target state="translated">Если &lt;a href=&quot;blob&quot;&gt;дескриптор &lt;/a&gt;&lt;a href=&quot;../rescode#readonly&quot;&gt;большого двоичного объекта,&lt;/a&gt; переданный в качестве первого аргумента, не был открыт для записи (параметр flags для &lt;a href=&quot;blob_open&quot;&gt;sqlite3_blob_open ()&lt;/a&gt; был равен нулю), эта функция возвращает SQLITE_READONLY .</target>
        </trans-unit>
        <trans-unit id="b723e9fc3d49332b65d60edda223c8ec9ca4d696" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt; interface is used to override the glob(X,Y) function with an alternative implementation then the &lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; operator will invoke the alternative implementation.</source>
          <target state="translated">Если интерфейс &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function ()&lt;/a&gt; используется для переопределения функции glob (X, Y) альтернативной реализацией, тогда оператор &lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; вызовет альтернативную реализацию.</target>
        </trans-unit>
        <trans-unit id="3092cc5ebddb90376d018bb6c31fa51fc5b9d178" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlbeginatomicwrite&quot; id=&quot;sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&lt;/a&gt; opcode returns SQLITE_OK, then the file descriptor is placed in &quot;batch write mode&quot;, which means all subsequent write operations will be deferred and done atomically at the next &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlcommitatomicwrite&quot;&gt;SQLITE_FCNTL_COMMIT_ATOMIC_WRITE&lt;/a&gt;. Systems that do not support batch atomic writes will return SQLITE_NOTFOUND. Following a successful SQLITE_FCNTL_BEGIN_ATOMIC_WRITE and prior to the closing &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlcommitatomicwrite&quot;&gt;SQLITE_FCNTL_COMMIT_ATOMIC_WRITE&lt;/a&gt; or &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlrollbackatomicwrite&quot;&gt;SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE&lt;/a&gt;, SQLite will make no VFS interface calls on the same &lt;a href=&quot;file&quot;&gt;sqlite3_file&lt;/a&gt; file descriptor except for calls to the xWrite method and the xFileControl method with &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlsizehint&quot;&gt;SQLITE_FCNTL_SIZE_HINT&lt;/a&gt;.</source>
          <target state="translated">Если код операции &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlbeginatomicwrite&quot; id=&quot;sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&lt;/a&gt; возвращает SQLITE_OK, то дескриптор файла переводится в &amp;laquo;режим пакетной записи&amp;raquo;, что означает, что все последующие операции записи будут отложены и будут выполняться атомарно при следующей записи &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlcommitatomicwrite&quot;&gt;SQLITE_FCNTL_COMMIT_ATOMIC_WRITE&lt;/a&gt; . Системы, которые не поддерживают пакетную атомарную запись, вернут SQLITE_NOTFOUND. После успешного SQLITE_FCNTL_BEGIN_ATOMIC_WRITE и до закрытия &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlcommitatomicwrite&quot;&gt;SQLITE_FCNTL_COMMIT_ATOMIC_WRITE&lt;/a&gt; или &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlrollbackatomicwrite&quot;&gt;SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE&lt;/a&gt; , SQLite не будет делать никаких вызовов интерфейса VFS на одном &lt;a href=&quot;file&quot;&gt;sqlite3_file&lt;/a&gt; дескриптора файла для вызова метода xWrite и метод xFileControl с исключением &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlsizehint&quot;&gt;SQLITE_FCNTL_SIZE_HINT&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="26aea5eaba4882a7f57e469fe581e38b779b7c63" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_NOMUTEX&lt;/a&gt; flag is set, then the database connection opens in the multi-thread &lt;a href=&quot;../threadsafe&quot;&gt;threading mode&lt;/a&gt; as long as the single-thread mode has not been set at compile-time or start-time. If the &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_FULLMUTEX&lt;/a&gt; flag is set then the database connection opens in the serialized &lt;a href=&quot;../threadsafe&quot;&gt;threading mode&lt;/a&gt; unless single-thread was previously selected at compile-time or start-time. The &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_SHAREDCACHE&lt;/a&gt; flag causes the database connection to be eligible to use &lt;a href=&quot;../sharedcache&quot;&gt;shared cache mode&lt;/a&gt;, regardless of whether or not shared cache is enabled using &lt;a href=&quot;enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache()&lt;/a&gt;. The &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_PRIVATECACHE&lt;/a&gt; flag causes the database connection to not participate in &lt;a href=&quot;../sharedcache&quot;&gt;shared cache mode&lt;/a&gt; even if it is enabled.</source>
          <target state="translated">Если &lt;a href=&quot;c_open_autoproxy&quot;&gt;установлен&lt;/a&gt; флаг SQLITE_OPEN_NOMUTEX , соединение с базой данных открывается в &lt;a href=&quot;../threadsafe&quot;&gt;многопоточном режиме&lt;/a&gt; до тех пор, пока однопоточный режим не был установлен во время компиляции или запуска. Если &lt;a href=&quot;c_open_autoproxy&quot;&gt;установлен&lt;/a&gt; флаг SQLITE_OPEN_FULLMUTEX, соединение с базой данных открывается в режиме сериализованных &lt;a href=&quot;../threadsafe&quot;&gt;потоков,&lt;/a&gt; если только однопоточный не был выбран ранее во время компиляции или запуска. &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_SHAREDCACHE&lt;/a&gt; флаг вызывает соединение с базой данных , чтобы иметь право использовать &lt;a href=&quot;../sharedcache&quot;&gt;режим общего кэша&lt;/a&gt; , независимо от наличия или отсутствия общего кэша включается с помощью &lt;a href=&quot;enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache ()&lt;/a&gt; . &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_PRIVATECACHE&lt;/a&gt;Флаг заставляет соединение с базой данных не участвовать в &lt;a href=&quot;../sharedcache&quot;&gt;режиме общего кэша,&lt;/a&gt; даже если он включен.</target>
        </trans-unit>
        <trans-unit id="3d6b9e280cf3c9ed4800b321c18f34c5a4956d1e" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;compile#enable_8_3_names&quot;&gt;SQLITE_ENABLE_8_3_NAMES=1&lt;/a&gt; option is used, then SQLite is capable of using 8+3 filenames but that capabilities is disabled and must be enabled separately for each database connection by using using &lt;a href=&quot;uri&quot;&gt;URI filenames&lt;/a&gt; when &lt;a href=&quot;c3ref/open&quot;&gt;opening&lt;/a&gt; or &lt;a href=&quot;lang_attach&quot;&gt;ATTACH-ing&lt;/a&gt; the database files and include the &quot;&lt;code&gt;8_3_names=1&lt;/code&gt;&quot; query parameter in the URI. If SQLite is compiled with &lt;a href=&quot;compile#enable_8_3_names&quot;&gt;SQLITE_ENABLE_8_3_NAMES=2&lt;/a&gt; then 8+3 filenames are enabled by default and this step can be skipped.</source>
          <target state="translated">Если используется параметр &lt;a href=&quot;compile#enable_8_3_names&quot;&gt;SQLITE_ENABLE_8_3_NAMES = 1&lt;/a&gt; , то SQLite может использовать 8 + 3 имен файлов, но эти возможности отключены и должны быть включены отдельно для каждого соединения с базой данных с использованием &lt;a href=&quot;uri&quot;&gt;имен файлов URI&lt;/a&gt; при &lt;a href=&quot;c3ref/open&quot;&gt;открытии&lt;/a&gt; или &lt;a href=&quot;lang_attach&quot;&gt;ПРИСОЕДИНЕНИИ&lt;/a&gt; файлов базы данных и включении &lt;code&gt;8_3_names=1&lt;/code&gt; запроса &amp;laquo; 8_3_names = 1 &amp;raquo; в URI. Если SQLite скомпилирован с &lt;a href=&quot;compile#enable_8_3_names&quot;&gt;SQLITE_ENABLE_8_3_NAMES = 2,&lt;/a&gt; то по умолчанию включены 8 + 3 имен файлов, и этот шаг можно пропустить.</target>
        </trans-unit>
        <trans-unit id="f14f4e625a540ecf3e1de270c88730b0b55cfa0f" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; compile-time parameter specifies disk storage for temporary files, then override that decision and use memory storage instead. Otherwise follow the recommendation of the &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; compile-time parameter.</source>
          <target state="translated">Если параметр &lt;a href=&quot;compile#temp_store&quot;&gt;времени&lt;/a&gt; компиляции SQLITE_TEMP_STORE указывает дисковое хранилище для временных файлов, тогда переопределите это решение и используйте вместо него хранилище памяти. В противном случае следуйте рекомендациям параметра времени компиляции &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cc4e5ad04a8f404976f4ea549e621889ed4a2406" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; compile-time parameter specifies memory storage for temporary files, then override that decision and use disk storage instead. Otherwise follow the recommendation of the &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; compile-time parameter.</source>
          <target state="translated">Если параметр &lt;a href=&quot;compile#temp_store&quot;&gt;времени&lt;/a&gt; компиляции SQLITE_TEMP_STORE указывает хранилище в памяти для временных файлов, то переопределите это решение и используйте вместо него дисковое хранилище. В противном случае следуйте рекомендациям параметра времени компиляции &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c75f136169c511a3f8a8fd887440953a9ba6fdef" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;datatype3#affinity&quot;&gt;affinity&lt;/a&gt; of a column is REAL and that column contains a value that can be converted to an integer without loss of information (if the value contains no fractional part and is not too large to be represented as an integer) then the column may be stored in the record as an integer. SQLite will convert the value back to floating point when extracting it from the record.</source>
          <target state="translated">Если &lt;a href=&quot;datatype3#affinity&quot;&gt;сродство&lt;/a&gt; столбца REAL и этот столбец содержит значение, которое может быть преобразовано в целое число без потери информации (если значение не содержит дробной части и не слишком велико для представления в виде целого числа), тогда столбец может быть хранится в записи как целое число. SQLite преобразует значение обратно в число с плавающей запятой при извлечении его из записи.</target>
        </trans-unit>
        <trans-unit id="6bdd9340a9dcd6ebb4b2136a687baf206a35c611" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; is not aliased by &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; then it is not persistent and might change. In particular the &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; command will change rowids for tables that do not declare an INTEGER PRIMARY KEY. Therefore, applications should not normally access the rowid directly, but instead use an INTEGER PRIMARY KEY.</source>
          <target state="translated">Если &lt;a href=&quot;lang_createtable#rowid&quot;&gt;идентификатор строки&lt;/a&gt; не имеет псевдонима &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY,&lt;/a&gt; он не является постоянным и может измениться. В частности, команда &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; изменит идентификаторы строк для таблиц, в которых не объявлен INTEGER PRIMARY KEY. Следовательно, приложения обычно не должны обращаться к rowid напрямую, а вместо этого должны использовать INTEGER PRIMARY KEY.</target>
        </trans-unit>
        <trans-unit id="96317212b202d64aa994eed839385d463798a08e" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;opcode#VColumn&quot;&gt;VColumn&lt;/a&gt; opcode is being used to fetch the value of an unchanging column during an UPDATE operation, then the P5 value is OPFLAG_NOCHNG. This will cause the sqlite3_vtab_nochange() function to return true inside the xColumn method of the virtual table implementation. The P5 column might also contain other bits (OPFLAG_LENGTHARG or OPFLAG_TYPEOFARG) but those bits are unused by &lt;a href=&quot;opcode#VColumn&quot;&gt;VColumn&lt;/a&gt;.</source>
          <target state="translated">Если код операции &lt;a href=&quot;opcode#VColumn&quot;&gt;VColumn&lt;/a&gt; используется для извлечения значения неизменяемого столбца во время операции UPDATE, то значением P5 является OPFLAG_NOCHNG. Это приведет к тому, что функция sqlite3_vtab_nochange () вернет true внутри метода xColumn реализации виртуальной таблицы. Столбец P5 может также содержать другие биты (OPFLAG_LENGTHARG или OPFLAG_TYPEOFARG), но эти биты не используются &lt;a href=&quot;opcode#VColumn&quot;&gt;VColumn&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2b4eaedd5855ff13b903e656d850adc325c12c79" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;optoverview#flattening&quot;&gt;flattening optimization&lt;/a&gt; is used on a subquery in the FROM clause of a SELECT statement, that effectively merges the subquery into the outer query. The output of EXPLAIN QUERY PLAN reflects this, as in the following example:</source>
          <target state="translated">Если &lt;a href=&quot;optoverview#flattening&quot;&gt;оптимизация сглаживания&lt;/a&gt; используется в подзапросе в предложении FROM оператора SELECT, это эффективно объединяет подзапрос во внешний запрос. Результат EXPLAIN QUERY PLAN отражает это, как в следующем примере:</target>
        </trans-unit>
        <trans-unit id="6110f6d9f2445ffa2d331ca1dfcaf53aa3a365b6" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;pragma#pragma_empty_result_callbacks&quot;&gt; EMPTY_RESULT_CALLBACKS&lt;/a&gt; pragma is set to ON and the result of a query is an empty set, then the callback is invoked once with the third parameter (argv) set to 0. In other words</source>
          <target state="translated">Если прагма &lt;a href=&quot;pragma#pragma_empty_result_callbacks&quot;&gt;EMPTY_RESULT_CALLBACKS&lt;/a&gt; установлена ​​в значение ON и результат запроса - пустой набор, то обратный вызов вызывается один раз с третьим параметром (argv), установленным в 0. Другими словами</target>
        </trans-unit>
        <trans-unit id="b1c24c8f45d6339d5389a76337c9e88f41b5e36a" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;pragma#pragma_fullfsync&quot;&gt;fullfsync&lt;/a&gt; flag is set, then the F_FULLFSYNC syncing method is used for all sync operations and the checkpoint_fullfsync setting is irrelevant.</source>
          <target state="translated">Если &lt;a href=&quot;pragma#pragma_fullfsync&quot;&gt;установлен&lt;/a&gt; флаг fullfsync , то метод синхронизации F_FULLFSYNC используется для всех операций синхронизации, а параметр checkpoint_fullfsync не имеет значения.</target>
        </trans-unit>
        <trans-unit id="a73873febe6d7de1338d537c333841d126c81b5b" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;pragma#pragma_short_column_names&quot;&gt;short_column_names&lt;/a&gt; pragma is ON, then the name of the result is the name of the source table column without the source table name prefix: COLUMN.</source>
          <target state="translated">Если прагма &lt;a href=&quot;pragma#pragma_short_column_names&quot;&gt;short_column_names включена&lt;/a&gt; , то имя результата - это имя столбца исходной таблицы без префикса имени исходной таблицы: COLUMN.</target>
        </trans-unit>
        <trans-unit id="1069754e926abbbcc7551f7b3c103d01ced65dbe" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;vfs#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen&lt;/a&gt; method sets the sqlite3_file.pMethods element to a non-NULL pointer, then the sqlite3_io_methods.xClose method may be invoked even if the &lt;a href=&quot;vfs#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen&lt;/a&gt; reported that it failed. The only way to prevent a call to xClose following a failed &lt;a href=&quot;vfs#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen&lt;/a&gt; is for the &lt;a href=&quot;vfs#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen&lt;/a&gt; to set the sqlite3_file.pMethods element to NULL.</source>
          <target state="translated">Если метод &lt;a href=&quot;vfs#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen&lt;/a&gt; устанавливает для элемента sqlite3_file.pMethods указатель, отличный от NULL, то метод sqlite3_io_methods.xClose может быть вызван, даже если &lt;a href=&quot;vfs#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen&lt;/a&gt; сообщил, что он не удался. Единственный способ предотвратить вызов xClose после неудачного &lt;a href=&quot;vfs#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen&lt;/a&gt; является для &lt;a href=&quot;vfs#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen&lt;/a&gt; , чтобы установить элемент sqlite3_file.pMethods в NULL.</target>
        </trans-unit>
        <trans-unit id="e03a0f37d058bb5a34bec7fac575235294acd0da" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt; method calls sqlite3_vtab_nochange() and finds that the column is not changed by the UPDATE statement, then the xColumn method can optionally return without setting a result, without calling any of the &lt;a href=&quot;#sqlite3_result_blob&quot;&gt;sqlite3_result_xxxxx() interfaces&lt;/a&gt;. In that case, &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_nochange(X)&lt;/a&gt; will return true for the same column in the &lt;a href=&quot;vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; method.</source>
          <target state="translated">Если метод &lt;a href=&quot;vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt; вызывает sqlite3_vtab_nochange () и обнаруживает, что столбец не изменен оператором UPDATE, то метод xColumn может при желании вернуться без установки результата, без вызова каких-либо &lt;a href=&quot;#sqlite3_result_blob&quot;&gt;интерфейсов sqlite3_result_xxxxx ()&lt;/a&gt; . В этом случае &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_nochange (X)&lt;/a&gt; вернет true для того же столбца в методе &lt;a href=&quot;vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6aba978070ccc979bd49ef28d0ef204e751d91d9" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt; method in a &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; implementation returns an error message using &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_error()&lt;/a&gt; then give that error message preference over internally-generated messages.</source>
          <target state="translated">Если метод &lt;a href=&quot;vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt; в реализации &lt;a href=&quot;vtab&quot;&gt;виртуальной таблицы&lt;/a&gt; возвращает сообщение об ошибке с помощью &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_error (),&lt;/a&gt; тогда отдайте предпочтение этому сообщению об ошибке по сравнению с сообщениями, созданными внутри.</target>
        </trans-unit>
        <trans-unit id="a18d90fb5154dfedaa1471558060511dc56cfb54" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; method is NULL, then &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; statements are prohibited for that virtual table, and the virtual table is an &quot;eponymous-only virtual table&quot;. Eponymous-only virtual tables are useful as &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued functions&lt;/a&gt;.</source>
          <target state="translated">Если метод &lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; равен NULL, то операторы &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; запрещены для этой виртуальной таблицы, а виртуальная таблица является &amp;laquo;виртуальной таблицей только для одноименного имени&amp;raquo;. Одноименные виртуальные таблицы полезны как &lt;a href=&quot;vtab#tabfunc2&quot;&gt;функции, возвращающие табличное значение&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e36f28038a4ddd30d8f77a7f397ce33837d3478d" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;vtab#xfindfunction&quot;&gt;xFindFunction()&lt;/a&gt; method for the virtual table is defined, and if xFindFunction() sometimes returns &lt;a href=&quot;c3ref/c_index_constraint_eq&quot;&gt;SQLITE_INDEX_CONSTRAINT_FUNCTION&lt;/a&gt; or larger, then the constraints might also be of the form:</source>
          <target state="translated">Если для виртуальной таблицы определен метод &lt;a href=&quot;vtab#xfindfunction&quot;&gt;xFindFunction ()&lt;/a&gt; , и если xFindFunction () иногда возвращает &lt;a href=&quot;c3ref/c_index_constraint_eq&quot;&gt;SQLITE_INDEX_CONSTRAINT_FUNCTION&lt;/a&gt; или больше, то ограничения также могут иметь форму:</target>
        </trans-unit>
        <trans-unit id="89b6cc463721d8831624d29f70a88929969774cd" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;wal&quot;&gt;write-ahead log&lt;/a&gt; is enabled (via the &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;journal_mode pragma&lt;/a&gt;), this pragma causes a &lt;a href=&quot;wal#ckpt&quot;&gt;checkpoint&lt;/a&gt; operation to run on database</source>
          <target state="translated">Если &lt;a href=&quot;wal&quot;&gt;журнал упреждающей записи&lt;/a&gt; включен (через &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;прагму journal_mode&lt;/a&gt; ), эта прагма вызывает выполнение операции &lt;a href=&quot;wal#ckpt&quot;&gt;контрольной точки&lt;/a&gt; в базе данных.</target>
        </trans-unit>
        <trans-unit id="fa30bb229e0ba6c16b036d0680166f4c0e969175" translate="yes" xml:space="preserve">
          <source>If the &lt;b&gt;header&lt;/b&gt; argument is true then the first row of the CSV file to be treated as a header rather than as data. The second line of the CSV file becomes the first row of content. If the &lt;b&gt;schema=&lt;/b&gt; options is omitted, then the first line of the CSV file determines the names of the columns.</source>
          <target state="translated">Если аргумент &lt;b&gt;заголовка&lt;/b&gt; истинен, то первая строка файла CSV должна рассматриваться как заголовок, а не как данные. Вторая строка файла CSV становится первой строкой содержимого. Если параметр &lt;b&gt;schema =&lt;/b&gt; options опущен, то первая строка файла CSV определяет имена столбцов.</target>
        </trans-unit>
        <trans-unit id="c1cfb6451556f25af13b7b368489aadb6eb20ce2" translate="yes" xml:space="preserve">
          <source>If the AUTOINCREMENT keyword appears after INTEGER PRIMARY KEY, that changes the automatic ROWID assignment algorithm to prevent the reuse of ROWIDs over the lifetime of the database. In other words, the purpose of AUTOINCREMENT is to prevent the reuse of ROWIDs from previously deleted rows.</source>
          <target state="translated">Если ключевое слово AUTOINCREMENT появляется после INTEGER PRIMARY KEY,то это изменяет алгоритм автоматического назначения ROWID,чтобы предотвратить повторное использование ROWID в течение всего срока службы базы данных.Другими словами,целью АВТОИНКРЕМЕНТА является предотвращение повторного использования ROWID из ранее удаленных рядов.</target>
        </trans-unit>
        <trans-unit id="e7ae8b25bf55713a14aa930c0d079c55585a0c82" translate="yes" xml:space="preserve">
          <source>If the C version of the &lt;a href=&quot;http://site.icu-project.org/&quot;&gt;ICU library&lt;/a&gt; is available, then FTS may also be compiled with the SQLITE_ENABLE_ICU pre-processor macro defined. Compiling with this macro enables an FTS &lt;a href=&quot;fts3#tokenizer&quot;&gt;tokenizer&lt;/a&gt; that uses the ICU library to split a document into terms (words) using the conventions for a specified language and locale.</source>
          <target state="translated">Если доступна версия C &lt;a href=&quot;http://site.icu-project.org/&quot;&gt;библиотеки ICU&lt;/a&gt; , то FTS также может быть скомпилирован с определенным макросом препроцессора SQLITE_ENABLE_ICU. Компиляция с помощью этого макроса позволяет &lt;a href=&quot;fts3#tokenizer&quot;&gt;токенизатору&lt;/a&gt; FTS, который использует библиотеку ICU, разбивать документ на термины (слова), используя соглашения для указанного языка и локали.</target>
        </trans-unit>
        <trans-unit id="aade338ead72cd83806851289f36afe9ffee6390" translate="yes" xml:space="preserve">
          <source>If the DELETE operation is attempted, but SQLite returns SQLITE_CONSTRAINT (which can only happen if a foreign key constraint is violated), the conflict-handler function is invoked with &lt;a href=&quot;#SQLITE_CHANGESET_CONFLICT&quot;&gt;SQLITE_CHANGESET_CONSTRAINT&lt;/a&gt; passed as the second argument. This includes the case where the DELETE operation is attempted because an earlier call to the conflict handler function returned &lt;a href=&quot;#SQLITE_CHANGESET_ABORT&quot;&gt;SQLITE_CHANGESET_REPLACE&lt;/a&gt;.</source>
          <target state="translated">Если выполняется попытка операции DELETE, но SQLite возвращает SQLITE_CONSTRAINT (что может произойти только в случае нарушения ограничения внешнего ключа), вызывается функция обработчика конфликтов с &lt;a href=&quot;#SQLITE_CHANGESET_CONFLICT&quot;&gt;SQLITE_CHANGESET_CONSTRAINT,&lt;/a&gt; переданным в качестве второго аргумента. Это включает случай, когда выполняется попытка операции DELETE, потому что более ранний вызов функции обработчика конфликтов вернул &lt;a href=&quot;#SQLITE_CHANGESET_ABORT&quot;&gt;SQLITE_CHANGESET_REPLACE&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c4726b3dbe2c58403328aff3054192714f5fc075" translate="yes" xml:space="preserve">
          <source>If the DELETE operation is attempted, but SQLite returns SQLITE_CONSTRAINT (which can only happen if a foreign key constraint is violated), the conflict-handler function is invoked with &lt;a href=&quot;c_changeset_conflict&quot;&gt;SQLITE_CHANGESET_CONSTRAINT&lt;/a&gt; passed as the second argument. This includes the case where the DELETE operation is attempted because an earlier call to the conflict handler function returned &lt;a href=&quot;c_changeset_abort&quot;&gt;SQLITE_CHANGESET_REPLACE&lt;/a&gt;.</source>
          <target state="translated">Если выполняется попытка операции DELETE, но SQLite возвращает SQLITE_CONSTRAINT (что может произойти только в случае нарушения ограничения внешнего ключа), вызывается функция обработчика конфликтов с &lt;a href=&quot;c_changeset_conflict&quot;&gt;SQLITE_CHANGESET_CONSTRAINT,&lt;/a&gt; переданным в качестве второго аргумента. Это включает случай, когда выполняется попытка операции DELETE, потому что более ранний вызов функции обработчика конфликтов вернул &lt;a href=&quot;c_changeset_abort&quot;&gt;SQLITE_CHANGESET_REPLACE&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a02c654b3d70302948f2081631be3edc27671a93" translate="yes" xml:space="preserve">
          <source>If the DELETE statement has an ORDER BY clause, then all rows that would be deleted in the absence of the LIMIT clause are sorted according to the ORDER BY. The first</source>
          <target state="translated">Если заявление об удалении имеет пункт ЗАКАЗАТЬ ПО ЗАКАЗЧИКУ,то все строки,которые были бы удалены при отсутствии пункта ОГРАНИЧЕНИЕ,сортируются в соответствии с пунктом ЗАКАЗЧИКА ПО ЗАКАЗЧИКУ.Первый</target>
        </trans-unit>
        <trans-unit id="63547bac31e35c719e75fc46ff0cebecf92fd269" translate="yes" xml:space="preserve">
          <source>If the DELETE statement has no ORDER BY clause, then all rows that would be deleted in the absence of the LIMIT clause are assembled in an arbitrary order before applying the LIMIT and OFFSET clauses to determine the subset that are actually deleted.</source>
          <target state="translated">Если утверждение DELETE не имеет пункта ORDER BY,то все строки,которые были бы удалены при отсутствии пункта LIMIT,собираются в произвольном порядке перед применением пунктов LIMIT и OFFSET для определения подмножества,которое фактически удаляется.</target>
        </trans-unit>
        <trans-unit id="20e8eb12f584aa2a2c71da9ffe10b6bc6f97692b" translate="yes" xml:space="preserve">
          <source>If the ESCAPE option is used, the ESCAPE character must be ASCII, or a single-byte character in UTF-8.</source>
          <target state="translated">Если используется вариант ESCAPE,то символ ESCAPE должен быть ASCII,или однобайтовый символ в UTF-8.</target>
        </trans-unit>
        <trans-unit id="d5df7edc7165f75cb1f0d5e995a539c8d7c8967f" translate="yes" xml:space="preserve">
          <source>If the F parameter is not one of the above, then the behavior is undefined and probably undesirable. Older versions of SQLite were more tolerant of invalid F parameters than newer versions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f76a2496ff32a61cee2f76ed3e0830800bfd787" translate="yes" xml:space="preserve">
          <source>If the FROM clause is omitted from a simple SELECT statement, then the input data is implicitly a single row zero columns wide (i.e.</source>
          <target state="translated">Если выражение FROM опущено из простого утверждения SELECT,то входными данными неявно являются однострочные нулевые столбцы шириной в одну строку (т.е.</target>
        </trans-unit>
        <trans-unit id="408ec930c8db59ef8bcaccad18026b5e15f9eaec" translate="yes" xml:space="preserve">
          <source>If the FTS table is an FTS4 table (not FTS3), a token may also be prefixed with a &quot;^&quot; character. In this case, in order to match the token must appear as the very first token in any column of the matching row. Examples:</source>
          <target state="translated">Если таблица FTS является таблицей FTS4 (не FTS3),то токен может быть также префиксован символом &quot;^&quot;.В этом случае для соответствия токен должен отображаться как самый первый токен в любом столбце строки соответствия.Примеры:</target>
        </trans-unit>
        <trans-unit id="93fd7e443f86d05e9fc567cfba4cc2ea3b224813" translate="yes" xml:space="preserve">
          <source>If the FTS5 table is created with the 'detail' option set to 'col', then the</source>
          <target state="translated">Если таблица FTS5 создается с опцией 'подробности',установленной в 'столбец',тогда</target>
        </trans-unit>
        <trans-unit id="99ee296e09aab46dd06e0a5f1c140a90b72606e3" translate="yes" xml:space="preserve">
          <source>If the HAVE_FDATASYNC compile-time option is true, then the default &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; for unix systems will attempt to use fdatasync() instead of fsync() where appropriate. If this flag is missing or false, then fsync() is always used.</source>
          <target state="translated">Если параметр времени компиляции HAVE_FDATASYNC равен true, то &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; по умолчанию для систем unix будет пытаться использовать fdatasync () вместо fsync () там, где это необходимо. Если этот флаг отсутствует или имеет значение false, всегда используется fsync ().</target>
        </trans-unit>
        <trans-unit id="8e31d6de70624cd3258a7c666db7d8624e2234e9" translate="yes" xml:space="preserve">
          <source>If the HAVE_GMTIME_R option is true and if &lt;a href=&quot;compile#omit_datetime_funcs&quot;&gt;SQLITE_OMIT_DATETIME_FUNCS&lt;/a&gt; is true, then the CURRENT_TIME, CURRENT_DATE, and CURRENT_TIMESTAMP keywords will use the threadsafe &quot;gmtime_r()&quot; interface rather than &quot;gmtime()&quot;. In the usual case where &lt;a href=&quot;compile#omit_datetime_funcs&quot;&gt;SQLITE_OMIT_DATETIME_FUNCS&lt;/a&gt; is not defined or is false, then the built-in &lt;a href=&quot;lang_datefunc&quot;&gt;date and time functions&lt;/a&gt; are used to implement the CURRENT_TIME, CURRENT_DATE, and CURRENT_TIMESTAMP keywords and neither gmtime_r() nor gmtime() is ever called.</source>
          <target state="translated">Если параметр HAVE_GMTIME_R - истина и если &lt;a href=&quot;compile#omit_datetime_funcs&quot;&gt;SQLITE_OMIT_DATETIME_FUNCS&lt;/a&gt; - истина, то ключевые слова CURRENT_TIME, CURRENT_DATE и CURRENT_TIMESTAMP будут использовать потокобезопасный интерфейс &amp;laquo;gmtime_r ()&amp;raquo;, а не &amp;laquo;gmtime ()&amp;raquo;. В обычном случае, когда &lt;a href=&quot;compile#omit_datetime_funcs&quot;&gt;SQLITE_OMIT_DATETIME_FUNCS&lt;/a&gt; не определен или имеет значение false, встроенные &lt;a href=&quot;lang_datefunc&quot;&gt;функции даты и времени&lt;/a&gt; используются для реализации ключевых слов CURRENT_TIME, CURRENT_DATE и CURRENT_TIMESTAMP, и ни gmtime_r (), ни gmtime () никогда не вызываются.</target>
        </trans-unit>
        <trans-unit id="40cdcf3ade2687218b791686ca4436d6b3c5cfba" translate="yes" xml:space="preserve">
          <source>If the HAVE_ISNAN option is true, then SQLite invokes the system library isnan() function to determine if a double-precision floating point value is a NaN. If HAVE_ISNAN is undefined or false, then SQLite substitutes its own home-grown implementation of isnan().</source>
          <target state="translated">Если опция HAVE_ISNAN истинна,то SQLite вызывает системную библиотеку isnan()для определения,является ли значение с плавающей точкой двойной точности NaN.Если HAVE_ISNAN неопределен или ложен,то SQLite подставляет свою собственную доморощенную реализацию isnan().</target>
        </trans-unit>
        <trans-unit id="153cb2536cd91084b29b41e9d14f8a7ef310cc61" translate="yes" xml:space="preserve">
          <source>If the HAVE_LOCALTIME_R option is true, then SQLite uses the threadsafe localtime_r() library routine instead of localtime() to help implement the &lt;a href=&quot;lang_datefunc#localtime&quot;&gt;localtime modifier&lt;/a&gt; to the built-in &lt;a href=&quot;lang_datefunc&quot;&gt;date and time functions&lt;/a&gt;.</source>
          <target state="translated">Если параметр HAVE_LOCALTIME_R имеет значение true, то SQLite использует потоковую библиотечную подпрограмму localtime_r () вместо localtime (), чтобы помочь реализовать &lt;a href=&quot;lang_datefunc#localtime&quot;&gt;модификатор localtime&lt;/a&gt; для встроенных &lt;a href=&quot;lang_datefunc&quot;&gt;функций даты и времени&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0c4b14956847344de7b5a6ccb25e5f358e368735" translate="yes" xml:space="preserve">
          <source>If the HAVE_LOCALTIME_S option is true, then SQLite uses the threadsafe localtime_s() library routine instead of localtime() to help implement the &lt;a href=&quot;lang_datefunc#localtime&quot;&gt;localtime modifier&lt;/a&gt; to the built-in &lt;a href=&quot;lang_datefunc&quot;&gt;date and time functions&lt;/a&gt;.</source>
          <target state="translated">Если параметр HAVE_LOCALTIME_S имеет значение true, тогда SQLite использует потоковую библиотечную подпрограмму localtime_s () вместо localtime (), чтобы помочь реализовать &lt;a href=&quot;lang_datefunc#localtime&quot;&gt;модификатор localtime&lt;/a&gt; для встроенных &lt;a href=&quot;lang_datefunc&quot;&gt;функций даты и времени&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="997bea68ec053527286253926a4446e11225f13c" translate="yes" xml:space="preserve">
          <source>If the HAVE_MALLOC_USABLE_SIZE option is omitted or is false, then SQLite uses a wrapper around system malloc() and realloc() that enlarges each allocation by 8 bytes and writes the size of the allocation in the initial 8 bytes, and then SQLite also implements its own home-grown version of malloc_usable_size() that consults that 8-byte prefix to find the allocation size. This approach works but it is suboptimal. Applications are encouraged to use HAVE_MALLOC_USABLE_SIZE whenever possible.</source>
          <target state="translated">Если опция HAVE_MALLOC_USABLE_SIZE опущена или является ложной,то SQLite использует обертку вокруг системных malloc()и realloc(),которая увеличивает каждое выделение на 8 байт и записывает размер выделения в начальные 8 байт,а затем SQLite также реализует свою собственную доморощенную версию malloc_usable_size(),которая для нахождения размера выделения учитывает этот 8-байтовый префикс.Такой подход работает,но он неоптимален.Приложениям рекомендуется по возможности использовать HAVE_MALLOC_USABLE_SIZE.</target>
        </trans-unit>
        <trans-unit id="55308f0ca78c87c49d7100dbf1e1e1adc1d30409" translate="yes" xml:space="preserve">
          <source>If the HAVE_MALLOC_USABLE_SIZE option is true, then SQLite tries uses the malloc_usable_size() interface to find the size of a memory allocation obtained from the standard-library malloc() or realloc() routines. This option is only applicable if the standard-library malloc() is used. On Apple systems, &quot;zone malloc&quot; is used instead, and so this option is not applicable. And, of course, if the application supplies its own malloc implementation using &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmalloc&quot;&gt;SQLITE_CONFIG_MALLOC&lt;/a&gt; then this option has no effect.</source>
          <target state="translated">Если параметр HAVE_MALLOC_USABLE_SIZE имеет значение true, то SQLite пытается использовать интерфейс malloc_usable_size () для определения размера выделения памяти, полученного с помощью подпрограмм malloc () или realloc () стандартной библиотеки. Эта опция применима, только если используется стандартная библиотека malloc (). В системах Apple вместо этого используется &amp;laquo;зона malloc&amp;raquo;, поэтому этот параметр не применим. И, конечно, если приложение предоставляет свою собственную реализацию malloc с использованием &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmalloc&quot;&gt;SQLITE_CONFIG_MALLOC,&lt;/a&gt; то эта опция не действует.</target>
        </trans-unit>
        <trans-unit id="3344d140659472562fd4dea21990938229ddf3ec" translate="yes" xml:space="preserve">
          <source>If the HAVE_STRCHRNUL option is true, then SQLite uses the strchrnul() library function. If this option is missing or false, then SQLite substitutes its own home-grown implementation of strchrnul().</source>
          <target state="translated">Если опция HAVE_STRCHRNUL истинна,то SQLite использует функцию библиотеки strchrnul().Если эта опция пропущена или ложна,то SQLite подменяет собственную доморощенную реализацию функции strchrnul().</target>
        </trans-unit>
        <trans-unit id="08d8894136dfc0e284f285c182990a928235abdc" translate="yes" xml:space="preserve">
          <source>If the HAVE_USLEEP option is true, then the default unix VFS uses the usleep() system call to implement the xSleep method. If this option is undefined or false, then xSleep on unix is implemented using sleep() which means that &lt;a href=&quot;c3ref/sleep&quot;&gt;sqlite3_sleep()&lt;/a&gt; will have a minimum wait interval of 1000 milliseconds regardless of its argument.</source>
          <target state="translated">Если параметр HAVE_USLEEP имеет значение true, то VFS unix по умолчанию использует системный вызов usleep () для реализации метода xSleep. Если этот параметр undefined или false, то xSleep в unix реализуется с помощью sleep (), что означает, что &lt;a href=&quot;c3ref/sleep&quot;&gt;sqlite3_sleep ()&lt;/a&gt; будет иметь минимальный интервал ожидания 1000 миллисекунд независимо от его аргумента.</target>
        </trans-unit>
        <trans-unit id="538ccd48ed8bd61407504bbf28bbe6d0ffe8bf96" translate="yes" xml:space="preserve">
          <source>If the HAVE_UTIME option is true, then the built-in but non-standard &quot;unix-dotfile&quot; VFS will use the utime() system call, instead of utimes(), to set the last access time on the lock file.</source>
          <target state="translated">Если опция HAVE_UTIME равна true,то встроенная,но нестандартная &quot;unix-dotfile&quot; VFS будет использовать системный вызов utime(),а не utimes(),для установки последнего времени доступа к файлу блокировки.</target>
        </trans-unit>
        <trans-unit id="7cab5093752cc9a8b0a63442b0923931057ad2d6" translate="yes" xml:space="preserve">
          <source>If the INTO clause is included, then the original database file is unchanged and a new database is created in the filename given by the argument to the INTO clause. The new database will contain the same logical content as the original database, fully vacuumed.</source>
          <target state="translated">Если включена оговорка INTO,то исходный файл БД остается неизменным,и в имени файла,заданном аргументом в оговорке INTO,создается новая БД.Новая БД будет содержать то же логическое содержание,что и исходная,с полным вакуумом.</target>
        </trans-unit>
        <trans-unit id="b0e0bffd82940bcd9134c72373f0af179d9c5474" translate="yes" xml:space="preserve">
          <source>If the LIMIT expression evaluates to non-negative value</source>
          <target state="translated">Если выражение LIMIT оценивается до неотрицательного значения</target>
        </trans-unit>
        <trans-unit id="f61e07bad4e222ccefd74ac63dc52c1ed3c63a8f" translate="yes" xml:space="preserve">
          <source>If the NATURAL keyword is in the join-operator then an implicit USING clause is added to the join-constraints. The implicit USING clause contains each of the column names that appear in both the left and right-hand input datasets. If the left and right-hand input datasets feature no common column names, then the NATURAL keyword has no effect on the results of the join. A USING or ON clause may not be added to a join that specifies the NATURAL keyword.</source>
          <target state="translated">Если ключевое слово NATURAL находится в join-операторе,то к connection-constraints добавляется неявное условие USING.Неявное выражение USING содержит имена каждого из столбцов,которые появляются как в левом,так и в правом наборе входных данных.Если левый и правый входные наборы данных не имеют общих имён колонок,то ключевое слово NATURAL не влияет на результаты соединения.Пункт USING или ON не может быть добавлен к соединению,которое определяет ключевое слово NATURAL.</target>
        </trans-unit>
        <trans-unit id="a2b9577c2b86e52c07b264eb7017d085b143b677" translate="yes" xml:space="preserve">
          <source>If the Nth column returned by the statement is an expression or subquery and is not a column value, then all of these functions return NULL. These routine might also return NULL if a memory allocation error occurs. Otherwise, they return the name of the attached database, table, or column that query result column was extracted from.</source>
          <target state="translated">Если N-я колонка,возвращаемая оператором,является выражением или подзапросом и не является значением колонки,то все эти функции возвращают NULL.Эта рутина также может вернуть NULL,если произошла ошибка выделения памяти.В противном случае они возвращают имя присоединенной БД,таблицы или столбца,из которого был извлечен столбец результата запроса.</target>
        </trans-unit>
        <trans-unit id="7286275584ec903ae36c4fc51d813a102d9d7ca1" translate="yes" xml:space="preserve">
          <source>If the Nth column returned by the statement is an expression or subquery and is not a column value, then all of these functions return NULL. These routines might also return NULL if a memory allocation error occurs. Otherwise, they return the name of the attached database, table, or column that query result column was extracted from.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f987b1e749686c5439c4369e9509e69172835e8f" translate="yes" xml:space="preserve">
          <source>If the OPFLAG_AUXDELETE bit is set on P5, that indicates that this delete one of several associated with deleting a table row and all its associated index entries. Exactly one of those deletes is the &quot;primary&quot; delete. The others are all on OPFLAG_FORDELETE cursors or else are marked with the AUXDELETE flag.</source>
          <target state="translated">Если бит OPFLAG_AUXDELETE установлен на P5,то это означает,что при этом удаляется один из нескольких,связанных с удалением строки таблицы и всех связанных с ней записей индекса.Именно одно из этих удалений является &quot;первичным&quot; удалением.Все остальные находятся на курсорах OPFLAG_FORDELETE или помечены флагом AUXDELETE.</target>
        </trans-unit>
        <trans-unit id="2e0584b25ae53697595c710240b674cfcd931b66" translate="yes" xml:space="preserve">
          <source>If the OPFLAG_ISUPDATE flag is set in P2, then P3 contains the address of the memory cell that contains the value that the rowid of the row will be set to by the update.</source>
          <target state="translated">Если флаг OPFLAG_ISUPDATE установлен в P2,то P3 содержит адрес ячейки памяти,которая содержит значение,на которое будет установлен rowid строки при обновлении.</target>
        </trans-unit>
        <trans-unit id="85453347b772792d0ef83ca6247504c978601416" translate="yes" xml:space="preserve">
          <source>If the OPFLAG_ISUPDATE flag is set, then this opcode is part of an UPDATE operation. Otherwise (if the flag is clear) then this opcode is part of an INSERT operation. The difference is only important to the update hook.</source>
          <target state="translated">Если установлен флаг OPFLAG_ISUPDATE,то этот опкод является частью операции UPDATE.В противном случае (если флаг чист)данный опкод является частью операции INSERT.Разница важна только для крючка обновления.</target>
        </trans-unit>
        <trans-unit id="358930ea0c0cb3bf8ddbac06391138cf9e1e9b1f" translate="yes" xml:space="preserve">
          <source>If the OPFLAG_LENGTHARG and OPFLAG_TYPEOFARG bits are set on P5 then the result is guaranteed to only be used as the argument of a length() or typeof() function, respectively. The loading of large blobs can be skipped for length() and all content loading can be skipped for typeof().</source>
          <target state="translated">Если биты OPFLAG_LENGTHARG и OPFLAG_TYPEOFARG установлены на P5,то гарантируется,что результат будет использоваться только в качестве аргумента функции length()или typeof()соответственно.Загрузку больших блоков можно пропустить для функции length(),а загрузку всего содержимого можно пропустить для функции typeof().</target>
        </trans-unit>
        <trans-unit id="b673a87eca1e30fb0e05ce7b3a0e2e621baf2f1c" translate="yes" xml:space="preserve">
          <source>If the OPFLAG_NCHANGE flag of P2 (NB: P2 not P5) is set, then the row change count is incremented (otherwise not).</source>
          <target state="translated">Если установлен флаг OPFLAG_NCHANGE P2 (NB:P2,а не P5),то увеличивается счетчик изменения строк (в противном случае-нет).</target>
        </trans-unit>
        <trans-unit id="8006bf0580f0ceee7abfbb502ff0bc2738a32586" translate="yes" xml:space="preserve">
          <source>If the OPFLAG_NCHANGE flag of P5 is set, then the row change count is incremented (otherwise not). If the OPFLAG_LASTROWID flag of P5 is set, then rowid is stored for subsequent return by the sqlite3_last_insert_rowid() function (otherwise it is unmodified).</source>
          <target state="translated">Если установлен флаг OPFLAG_NCHANGE в P5,то увеличивается счетчик изменения строк (в противном случае-нет).Если установлен флаг OPFLAG_LASTROWID P5,то счетчик rowid сохраняется для последующего возврата функцией sqlite3_last_insert_rowid()(в противном случае он немодифицируется).</target>
        </trans-unit>
        <trans-unit id="0464f564c819708fc95ba0ca873e884f00c0c5ec" translate="yes" xml:space="preserve">
          <source>If the OPFLAG_SAVEPOSITION bit of the P5 parameter is set, then the cursor will be left pointing at either the next or the previous record in the table. If it is left pointing at the next record, then the next &lt;a href=&quot;opcode#Next&quot;&gt;Next&lt;/a&gt; instruction will be a no-op. As a result, in this case it is ok to delete a record from within a &lt;a href=&quot;opcode#Next&quot;&gt;Next&lt;/a&gt; loop. If OPFLAG_SAVEPOSITION bit of P5 is clear, then the cursor will be left in an undefined state.</source>
          <target state="translated">Если бит OPFLAG_SAVEPOSITION параметра P5 установлен, то курсор останется указывающим либо на следующую, либо на предыдущую запись в таблице. Если он остается указывающим на следующую запись, то следующая инструкция &lt;a href=&quot;opcode#Next&quot;&gt;Next не&lt;/a&gt; будет выполняться. В результате в этом случае можно удалить запись из цикла &lt;a href=&quot;opcode#Next&quot;&gt;Next&lt;/a&gt; . Если бит OPFLAG_SAVEPOSITION P5 сброшен, курсор останется в неопределенном состоянии.</target>
        </trans-unit>
        <trans-unit id="b8443bd622375a798ed2a10b2bb936621afb5e73" translate="yes" xml:space="preserve">
          <source>If the OPFLAG_USESEEKRESULT flag of P5 is set, the implementation might run faster by avoiding an unnecessary seek on cursor P1. However, the OPFLAG_USESEEKRESULT flag must only be set if there have been no prior seeks on the cursor or if the most recent seek used a key equal to P3.</source>
          <target state="translated">Если установлен флаг OPFLAG_USESEEKRESULT в P5,то реализация может работать быстрее,избегая лишнего поиска по курсору P1.Однако,флаг OPFLAG_USESEEKRESULT должен быть установлен только в том случае,если на курсоре не было предыдущего поиска,или если в последнем поиске использовался ключ,равный P3.</target>
        </trans-unit>
        <trans-unit id="24d1994d6156f999d1ee517ed391edb59d48c618" translate="yes" xml:space="preserve">
          <source>If the OPFLAG_USESEEKRESULT flag of P5 is set, the implementation might run faster by avoiding an unnecessary seek on cursor P1. However, the OPFLAG_USESEEKRESULT flag must only be set if there have been no prior seeks on the cursor or if the most recent seek used a key equivalent to P2.</source>
          <target state="translated">Если установлен флаг OPFLAG_USESEEKRESULT в P5,то реализация может работать быстрее,избегая лишнего поиска по курсору P1.Однако,флаг OPFLAG_USESEEKRESULT должен быть установлен только в том случае,если на курсоре не было предыдущего поиска,или если в последнем поиске использовался ключ,эквивалентный P2.</target>
        </trans-unit>
        <trans-unit id="1f2be7bea7738f3621eca4267ce81f09d41a2e23" translate="yes" xml:space="preserve">
          <source>If the ORDER BY expression is a constant integer K then the expression is considered an alias for the K-th column of the result set (columns are numbered from left to right starting with 1).</source>
          <target state="translated">Если выражение ORDER BY является постоянным целым числом K,то это выражение считается псевдонимом для K-го столбца результирующего множества (столбцы нумеруются слева направо,начиная с 1).</target>
        </trans-unit>
        <trans-unit id="54b7818868eb0e39bd8ddbed56195f5499a4600b" translate="yes" xml:space="preserve">
          <source>If the ORDER BY expression is an identifier that corresponds to the alias of one of the output columns, then the expression is considered an alias for that column.</source>
          <target state="translated">Если выражение ORDER BY является идентификатором,соответствующим псевдониму одного из выходных столбцов,то это выражение считается псевдонимом этого столбца.</target>
        </trans-unit>
        <trans-unit id="00fdbe0ee21cda19b4a8ae7897474539b1f0a75c" translate="yes" xml:space="preserve">
          <source>If the ORDER BY expression is assigned a collation sequence using the postfix &lt;a href=&quot;lang_expr#collateop&quot;&gt;COLLATE operator&lt;/a&gt;, then the specified collation sequence is used.</source>
          <target state="translated">Если выражению ORDER BY назначена последовательность сопоставления с помощью постфиксного &lt;a href=&quot;lang_expr#collateop&quot;&gt;оператора COLLATE&lt;/a&gt; , то используется указанная последовательность сопоставления.</target>
        </trans-unit>
        <trans-unit id="d77a3e5eca6240aa4cf73a2d563a4460d778268d" translate="yes" xml:space="preserve">
          <source>If the P1 cursor must be pointing to a valid row (not a NULL row) of a real table, not a pseudo-table.</source>
          <target state="translated">Если курсор P1 должен указывать на действительную строку (не NULL строку)реальной таблицы,а не на псевдо-таблицу.</target>
        </trans-unit>
        <trans-unit id="1f5366d1e68bed932cc9eadcf38bc5c4aed05e24" translate="yes" xml:space="preserve">
          <source>If the P1 index entry is greater than or equal to the key value then jump to P2. Otherwise fall through to the next instruction.</source>
          <target state="translated">Если значение индекса P1 больше или равно ключевому значению,то переходите к P2.В противном случае переходите к следующей инструкции.</target>
        </trans-unit>
        <trans-unit id="eb12e9cd16de01f1875169ba7dbce89a734843ad" translate="yes" xml:space="preserve">
          <source>If the P1 index entry is greater than the key value then jump to P2. Otherwise fall through to the next instruction.</source>
          <target state="translated">Если значение индекса P1 больше,чем ключевое значение,то переходите к P2.В противном случае переходите к следующей инструкции.</target>
        </trans-unit>
        <trans-unit id="dbe830f25814f54ccec56a9eb14db5b310130922" translate="yes" xml:space="preserve">
          <source>If the P1 index entry is less than or equal to the key value then jump to P2. Otherwise fall through to the next instruction.</source>
          <target state="translated">Если значение индекса P1 меньше или равно ключевому значению,то переходите к P2.В противном случае переходите к следующей инструкции.</target>
        </trans-unit>
        <trans-unit id="a25915e27b156d98cb891f738fe575b0c439ae6a" translate="yes" xml:space="preserve">
          <source>If the P1 index entry is less than the key value then jump to P2. Otherwise fall through to the next instruction.</source>
          <target state="translated">Если значение индекса P1 меньше,чем ключевое значение,то переходите к P2.В противном случае переходите к следующей инструкции.</target>
        </trans-unit>
        <trans-unit id="64d6010c68c3d803b2d20f7d66e38f73be2fb061" translate="yes" xml:space="preserve">
          <source>If the P1 value is non-zero, then also set the MEM_Cleared flag so that NULL values will not compare equal even if SQLITE_NULLEQ is set on &lt;a href=&quot;opcode#Ne&quot;&gt;Ne&lt;/a&gt; or &lt;a href=&quot;opcode#Eq&quot;&gt;Eq&lt;/a&gt;.</source>
          <target state="translated">Если значение P1 не равно нулю, тогда также установите флаг MEM_Cleared, чтобы значения NULL не сравнивались равными, даже если SQLITE_NULLEQ установлен на &lt;a href=&quot;opcode#Ne&quot;&gt;Ne&lt;/a&gt; или &lt;a href=&quot;opcode#Eq&quot;&gt;Eq&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f14a9a47b078e93cd304b6691cdab49407396c8d" translate="yes" xml:space="preserve">
          <source>If the P3 value is non-zero, then the table referred to must be an intkey table (an SQL table, not an index). In this case the row change count is incremented by the number of rows in the table being cleared. If P3 is greater than zero, then the value stored in register P3 is also incremented by the number of rows in the table being cleared.</source>
          <target state="translated">Если значение P3 ненулевое,то рассматриваемая таблица должна быть таблицей intkey (таблица SQL,а не индекс).В этом случае счетчик изменений строк увеличивается на количество очищаемых строк таблицы.Если P3 больше нуля,то значение,хранящееся в регистре P3,также инкрементируется на количество строк в очищаемой таблице.</target>
        </trans-unit>
        <trans-unit id="5877a66b1cea7b0ea64daa7c24ed48ab6bbcee07" translate="yes" xml:space="preserve">
          <source>If the PRIMARY KEY of a WITHOUT ROWID tables uses the same columns with the same collating sequence more than once, then the second and subsequent occurrences of that column in the PRIMARY KEY definition are ignored. For example, the following CREATE TABLE statements all specify the same table, which will have the exact same representation on disk:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8742c4d987b7b8bb8b01f7cdaee658b0bce0f67" translate="yes" xml:space="preserve">
          <source>If the REINDEX keyword is followed by a collation-sequence name, then all indices in all attached databases that use the named collation sequences are recreated.</source>
          <target state="translated">Если за ключевым словом REINDEX следует имя последовательности сверки,то все индексы во всех подключенных базах данных,использующих именованные последовательности сверки,воссоздаются.</target>
        </trans-unit>
        <trans-unit id="89611a3566f7e2d206b997930c668d8b59f61d02" translate="yes" xml:space="preserve">
          <source>If the REINDEX keyword is not followed by a collation-sequence or database object identifier, then all indices in all attached databases are rebuilt.</source>
          <target state="translated">Если за ключевым словом REINDEX не следует сопоставление-последовательность или идентификатор объекта базы данных,то все индексы во всех прикрепленных базах данных перестраиваются.</target>
        </trans-unit>
        <trans-unit id="95360c5e4a315542249137c79e8a2d6b511f7fdc" translate="yes" xml:space="preserve">
          <source>If the SELECT statement is &lt;b&gt;a non-aggregate query&lt;/b&gt;, then each expression in the result expression list is evaluated for each row in the dataset filtered by the WHERE clause.</source>
          <target state="translated">Если оператор SELECT является &lt;b&gt;неагрегатным запросом&lt;/b&gt; , то каждое выражение в списке выражений результата оценивается для каждой строки в наборе данных, отфильтрованной с помощью предложения WHERE.</target>
        </trans-unit>
        <trans-unit id="869026a04188f9191fbf03ed77ea46ac1ecc8cb4" translate="yes" xml:space="preserve">
          <source>If the SELECT statement is &lt;b&gt;an aggregate query with a GROUP BY&lt;/b&gt; clause, then each of the expressions specified as part of the GROUP BY clause is evaluated for each row of the dataset. Each row is then assigned to a &quot;group&quot; based on the results; rows for which the results of evaluating the GROUP BY expressions are the same get assigned to the same group. For the purposes of grouping rows, NULL values are considered equal. The usual rules for &lt;a href=&quot;datatype3#collation&quot;&gt;selecting a collation sequence&lt;/a&gt; with which to compare text values apply when evaluating expressions in a GROUP BY clause. The expressions in the GROUP BY clause do &lt;em&gt;not&lt;/em&gt; have to be expressions that appear in the result. The expressions in a GROUP BY clause may not be aggregate expressions.</source>
          <target state="translated">Если оператор SELECT является &lt;b&gt;агрегатным запросом с предложением GROUP BY&lt;/b&gt; , то каждое из выражений, указанных как часть предложения GROUP BY, оценивается для каждой строки набора данных. Каждая строка затем назначается &amp;laquo;группе&amp;raquo; на основе результатов; строки, для которых результаты вычисления выражений GROUP BY одинаковы, назначаются одной и той же группе. В целях группировки строк значения NULL считаются равными. Обычные правила &lt;a href=&quot;datatype3#collation&quot;&gt;выбора последовательности сортировки&lt;/a&gt; для сравнения текстовых значений применяются при оценке выражений в предложении GROUP BY. Выражения в предложении GROUP BY &lt;em&gt;не&lt;/em&gt; обязательно должны быть выражениями, которые появляются в результате. Выражения в предложении GROUP BY не могут быть агрегатными выражениями.</target>
        </trans-unit>
        <trans-unit id="5f32b910ff370c514af729f0255dcd885c666376" translate="yes" xml:space="preserve">
          <source>If the SELECT statement is &lt;b&gt;an aggregate query without a GROUP BY&lt;/b&gt; clause, then each aggregate expression in the result-set is evaluated once across the entire dataset. Each non-aggregate expression in the result-set is evaluated once for an arbitrarily selected row of the dataset. The same arbitrarily selected row is used for each non-aggregate expression. Or, if the dataset contains zero rows, then each non-aggregate expression is evaluated against a row consisting entirely of NULL values.</source>
          <target state="translated">Если оператор SELECT является &lt;b&gt;агрегатным запросом без предложения GROUP BY&lt;/b&gt; , то каждое агрегатное выражение в наборе результатов оценивается один раз для всего набора данных. Каждое неагрегатное выражение в наборе результатов оценивается один раз для произвольно выбранной строки набора данных. Одна и та же произвольно выбранная строка используется для каждого неагрегированного выражения. Или, если набор данных содержит нулевые строки, то каждое неагрегированное выражение оценивается по строке, полностью состоящей из значений NULL.</target>
        </trans-unit>
        <trans-unit id="14209330d1f571e7543dcd8d5633bd2d841dd6e1" translate="yes" xml:space="preserve">
          <source>If the SELECT statement specified as part of the CREATE VIRTUAL TABLE command returns five columns, then the final column is used for application context only. Swarmvtab does not use this value at all, except that it is passed after &amp;lt;database-name&amp;gt; to both the openclose and missing functions, if specified. In other words, instead of invoking the functions as described above, if the &quot;context&quot; column is present swarmvtab instead invokes:</source>
          <target state="translated">Если оператор SELECT, указанный как часть команды CREATE VIRTUAL TABLE, возвращает пять столбцов, то последний столбец используется только для контекста приложения. Swarmvtab вообще не использует это значение, за исключением того, что оно передается после &amp;lt;database-name&amp;gt; как функциям openclose, так и отсутствующим функциям, если они указаны. Другими словами, вместо вызова функций, как описано выше, если присутствует столбец &amp;laquo;context&amp;raquo;, swarmvtab вместо этого вызывает:</target>
        </trans-unit>
        <trans-unit id="40411dedc1ef7864197c263597ddfac1b246cd97" translate="yes" xml:space="preserve">
          <source>If the SQL COMMIT command turns autocommit on and the autocommit logic then tries to commit change but fails because some other process is holding a SHARED lock, then autocommit is turned back off automatically. This allows the user to retry the COMMIT at a later time after the SHARED lock has had an opportunity to clear.</source>
          <target state="translated">Если команда SQL COMMIT включает автокоммитацию и логика автокоммитации пытается зафиксировать изменение,но не удается,так как какой-то другой процесс держит блокировку SHARED,то автокоммитация автоматически отключается.Это позволяет пользователю повторить попытку COMMIT позже,после того,как блокировка SHARED получила возможность очиститься.</target>
        </trans-unit>
        <trans-unit id="507b41df5b9644d0a599bc2c2ba64c3ea6d21fd9" translate="yes" xml:space="preserve">
          <source>If the SQL statement being executed returns any data, then &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ROW&lt;/a&gt; is returned each time a new row of data is ready for processing by the caller. The values may be accessed using the &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;column access functions&lt;/a&gt;. sqlite3_step() is called again to retrieve the next row of data.</source>
          <target state="translated">Если выполняемый оператор SQL возвращает какие-либо данные, то &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ROW&lt;/a&gt; возвращается каждый раз, когда новая строка данных готова для обработки вызывающей стороной. Доступ к значениям можно получить с помощью &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;функций доступа&lt;/a&gt; к столбцам . sqlite3_step () вызывается снова, чтобы получить следующую строку данных.</target>
        </trans-unit>
        <trans-unit id="ae2787ab5fa2a6425b73b07a4b0ad6b9f341262a" translate="yes" xml:space="preserve">
          <source>If the SQL statement being executed returns any data, then &lt;a href=&quot;../rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt; is returned each time a new row of data is ready for processing by the caller. The values may be accessed using the &lt;a href=&quot;column_blob&quot;&gt;column access functions&lt;/a&gt;. sqlite3_step() is called again to retrieve the next row of data.</source>
          <target state="translated">Если выполняемый оператор SQL возвращает какие-либо данные, то &lt;a href=&quot;../rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt; возвращается каждый раз, когда новая строка данных готова для обработки вызывающей стороной. Доступ к значениям можно получить с помощью &lt;a href=&quot;column_blob&quot;&gt;функций доступа&lt;/a&gt; к столбцам . sqlite3_step () вызывается снова, чтобы получить следующую строку данных.</target>
        </trans-unit>
        <trans-unit id="95d391fa1b14c12c13b7ff2232dd79f1ad704028" translate="yes" xml:space="preserve">
          <source>If the SQL statement does not currently point to a valid row, or if the column index is out of range, the result is undefined. These routines may only be called when the most recent call to &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; has returned &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ROW&lt;/a&gt; and neither &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset()&lt;/a&gt; nor &lt;a href=&quot;#sqlite3_finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt; have been called subsequently. If any of these routines are called after &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset()&lt;/a&gt; or &lt;a href=&quot;#sqlite3_finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt; or after &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; has returned something other than &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ROW&lt;/a&gt;, the results are undefined. If &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; or &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset()&lt;/a&gt; or &lt;a href=&quot;#sqlite3_finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt; are called from a different thread while any of these routines are pending, then the results are undefined.</source>
          <target state="translated">Если оператор SQL в настоящий момент не указывает на допустимую строку или индекс столбца выходит за пределы допустимого диапазона, результат не определен. Эти подпрограммы могут быть вызваны только тогда, когда последний вызов &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step ()&lt;/a&gt; вернул &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ROW,&lt;/a&gt; и ни &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset (),&lt;/a&gt; ни &lt;a href=&quot;#sqlite3_finalize&quot;&gt;sqlite3_finalize ()&lt;/a&gt; не были вызваны впоследствии. Если какая-либо из этих подпрограмм &lt;a href=&quot;#sqlite3_reset&quot;&gt;вызывается&lt;/a&gt; после sqlite3_reset () или &lt;a href=&quot;#sqlite3_finalize&quot;&gt;sqlite3_finalize ()&lt;/a&gt; или после того, как &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step ()&lt;/a&gt; вернула что-то, отличное от &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ROW&lt;/a&gt; , результаты не определены. Если &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step ()&lt;/a&gt; или &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset ()&lt;/a&gt; или &lt;a href=&quot;#sqlite3_finalize&quot;&gt;sqlite3_finalize ()&lt;/a&gt;вызываются из другого потока, пока какая-либо из этих подпрограмм ожидает выполнения, то результаты не определены.</target>
        </trans-unit>
        <trans-unit id="34c305f0b8de32e5d504a58326a82216502c31ad" translate="yes" xml:space="preserve">
          <source>If the SQL statement does not currently point to a valid row, or if the column index is out of range, the result is undefined. These routines may only be called when the most recent call to &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; has returned &lt;a href=&quot;../rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt; and neither &lt;a href=&quot;reset&quot;&gt;sqlite3_reset()&lt;/a&gt; nor &lt;a href=&quot;finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt; have been called subsequently. If any of these routines are called after &lt;a href=&quot;reset&quot;&gt;sqlite3_reset()&lt;/a&gt; or &lt;a href=&quot;finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt; or after &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; has returned something other than &lt;a href=&quot;../rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt;, the results are undefined. If &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; or &lt;a href=&quot;reset&quot;&gt;sqlite3_reset()&lt;/a&gt; or &lt;a href=&quot;finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt; are called from a different thread while any of these routines are pending, then the results are undefined.</source>
          <target state="translated">Если оператор SQL в настоящий момент не указывает на допустимую строку или индекс столбца выходит за пределы допустимого диапазона, результат не определен. Эти подпрограммы могут быть вызваны только тогда, когда последний вызов &lt;a href=&quot;step&quot;&gt;sqlite3_step ()&lt;/a&gt; вернул &lt;a href=&quot;../rescode#row&quot;&gt;SQLITE_ROW,&lt;/a&gt; и ни &lt;a href=&quot;reset&quot;&gt;sqlite3_reset (),&lt;/a&gt; ни &lt;a href=&quot;finalize&quot;&gt;sqlite3_finalize ()&lt;/a&gt; не были вызваны впоследствии. Если какая-либо из этих подпрограмм &lt;a href=&quot;reset&quot;&gt;вызывается&lt;/a&gt; после sqlite3_reset () или &lt;a href=&quot;finalize&quot;&gt;sqlite3_finalize ()&lt;/a&gt; или после того, как &lt;a href=&quot;step&quot;&gt;sqlite3_step ()&lt;/a&gt; вернула что-то, отличное от &lt;a href=&quot;../rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt; , результаты не определены. Если &lt;a href=&quot;step&quot;&gt;sqlite3_step ()&lt;/a&gt; или &lt;a href=&quot;reset&quot;&gt;sqlite3_reset ()&lt;/a&gt; или &lt;a href=&quot;finalize&quot;&gt;sqlite3_finalize ()&lt;/a&gt;вызываются из другого потока, пока какая-либо из этих подпрограмм ожидает выполнения, то результаты не определены.</target>
        </trans-unit>
        <trans-unit id="975432fbe3b7571414ef3444c9bae0dbbb675815" translate="yes" xml:space="preserve">
          <source>If the SQLITE_DESERIALIZE_FREEONCLOSE bit is set in F, then SQLite will invoke sqlite3_free() on the serialization buffer when the database connection closes. If the SQLITE_DESERIALIZE_RESIZEABLE bit is set, then SQLite will try to increase the buffer size using sqlite3_realloc64() if writes on the database cause it to grow larger than M bytes.</source>
          <target state="translated">Если бит SQLITE_DESERIALIZE_FREEONCLOSE установлен в F,то при закрытии соединения с БД SQLite будет вызывать sqlite3_free()в буфере сериализации.Если бит SQLITE_DESERIALIZE_RESIZEABLE установлен,то SQLite будет пытаться увеличить размер буфера,используя sqlite3_realloc64(),если запись в БД приведет к его росту больше M байт.</target>
        </trans-unit>
        <trans-unit id="ea23bbe6e0f5cd400c470a465a873018f1aa3b8b" translate="yes" xml:space="preserve">
          <source>If the SQLITE_JUMPIFNULL bit of P5 is set and either reg(P1) or reg(P3) is NULL then the take the jump. If the SQLITE_JUMPIFNULL bit is clear then fall through if either operand is NULL.</source>
          <target state="translated">Если установлен бит SQLITE_JUMPIFNULL от P5 и либо reg(P1),либо reg(P3)равен NULL,то прыжок выполняется.Если бит SQLITE_JUMPIFNULL чист,то прыжок выполняется,если любой из операндов NULL.</target>
        </trans-unit>
        <trans-unit id="d13a5c515dea25bad07a7535880df286b04090a5" translate="yes" xml:space="preserve">
          <source>If the SQLite library is compiled without the NDEBUG preprocessor macro, then the PRAGMA &lt;a href=&quot;pragma#pragma_vdbe_trace&quot;&gt;vdbe_trace &lt;/a&gt; causes the VDBE to trace the execution of programs. Though this feature was originally intended for testing and debugging, it can also be useful in learning about how the VDBE operates. Use &quot;&lt;code&gt;PRAGMA vdbe_trace=ON;&lt;/code&gt;&quot; to turn tracing on and &quot;&lt;code&gt;PRAGMA vdbe_trace=OFF&lt;/code&gt;&quot; to turn tracing back off. Like this:</source>
          <target state="translated">Если библиотека SQLite скомпилирована без макроса препроцессора NDEBUG, то PRAGMA &lt;a href=&quot;pragma#pragma_vdbe_trace&quot;&gt;vdbe_trace&lt;/a&gt; заставляет VDBE отслеживать выполнение программ. Хотя эта функция изначально предназначалась для тестирования и отладки, она также может быть полезна при изучении того, как работает VDBE. Используйте &amp;laquo; &lt;code&gt;PRAGMA vdbe_trace=ON;&lt;/code&gt; &amp;raquo;, чтобы включить трассировку, и &amp;laquo; &lt;code&gt;PRAGMA vdbe_trace=OFF&lt;/code&gt; &amp;raquo;, чтобы отключить трассировку. Как это:</target>
        </trans-unit>
        <trans-unit id="4b9cda344fb3698660c6374cdcb25b1c3d461a5e" translate="yes" xml:space="preserve">
          <source>If the UNIQUE keyword appears between CREATE and INDEX then duplicate index entries are not allowed. Any attempt to insert a duplicate entry will result in an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b55abf3573b260c179e3130856801dc205be5f3" translate="yes" xml:space="preserve">
          <source>If the UNIQUE keyword appears between CREATE and INDEX then duplicate index entries are not allowed. Any attempt to insert a duplicate entry will result in an error. For the purposes of unique indices, all NULL values are considered different from all other NULL values and are thus unique. This is one of the two possible interpretations of the SQL-92 standard (the language in the standard is ambiguous) and is the interpretation followed by PostgreSQL, MySQL, Firebird, and Oracle. Informix and Microsoft SQL Server follow the other interpretation of the standard.</source>
          <target state="translated">Если между CREATE и INDEX появляется ключевое слово UNIQUE,то дублирование записей индекса не допускается.Любая попытка вставить дубликат записи приведет к ошибке.Для уникальных индексов все NULL-значения считаются отличными от всех остальных NULL-значений и,таким образом,являются уникальными.Это одна из двух возможных интерпретаций стандарта SQL-92 (язык в стандарте неоднозначный)и является интерпретацией,за которой следуют PostgreSQL,MySQL,Firebird и Oracle.Информмикс и Microsoft SQL Server следуют другой интерпретации стандарта.</target>
        </trans-unit>
        <trans-unit id="302753955d8021d9d751890a4a62678a7bd1dc4c" translate="yes" xml:space="preserve">
          <source>If the UPDATE operation is attempted, but SQLite returns SQLITE_CONSTRAINT, the conflict-handler function is invoked with &lt;a href=&quot;#SQLITE_CHANGESET_CONFLICT&quot;&gt;SQLITE_CHANGESET_CONSTRAINT&lt;/a&gt; passed as the second argument. This includes the case where the UPDATE operation is attempted after an earlier call to the conflict handler function returned &lt;a href=&quot;#SQLITE_CHANGESET_ABORT&quot;&gt;SQLITE_CHANGESET_REPLACE&lt;/a&gt;.</source>
          <target state="translated">Если выполняется попытка операции UPDATE, но SQLite возвращает SQLITE_CONSTRAINT, вызывается функция обработчика конфликтов с &lt;a href=&quot;#SQLITE_CHANGESET_CONFLICT&quot;&gt;SQLITE_CHANGESET_CONSTRAINT,&lt;/a&gt; переданным в качестве второго аргумента. Это включает случай, когда операция UPDATE выполняется после того, как предыдущий вызов функции обработчика конфликтов вернул &lt;a href=&quot;#SQLITE_CHANGESET_ABORT&quot;&gt;SQLITE_CHANGESET_REPLACE&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="40c8985574cc4136a7a40f15001ace597cd448e0" translate="yes" xml:space="preserve">
          <source>If the UPDATE operation is attempted, but SQLite returns SQLITE_CONSTRAINT, the conflict-handler function is invoked with &lt;a href=&quot;c_changeset_conflict&quot;&gt;SQLITE_CHANGESET_CONSTRAINT&lt;/a&gt; passed as the second argument. This includes the case where the UPDATE operation is attempted after an earlier call to the conflict handler function returned &lt;a href=&quot;c_changeset_abort&quot;&gt;SQLITE_CHANGESET_REPLACE&lt;/a&gt;.</source>
          <target state="translated">Если выполняется попытка операции UPDATE, но SQLite возвращает SQLITE_CONSTRAINT, вызывается функция обработчика конфликтов с &lt;a href=&quot;c_changeset_conflict&quot;&gt;SQLITE_CHANGESET_CONSTRAINT,&lt;/a&gt; переданным в качестве второго аргумента. Это включает случай, когда операция UPDATE выполняется после того, как предыдущий вызов функции обработчика конфликтов вернул &lt;a href=&quot;c_changeset_abort&quot;&gt;SQLITE_CHANGESET_REPLACE&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="751229ce68d5f9fb206ae67bb99718de4be423dd" translate="yes" xml:space="preserve">
          <source>If the UPDATE statement does not have a WHERE clause, all rows in the table are modified by the UPDATE. Otherwise, the UPDATE affects only those rows for which the WHERE clause &lt;a href=&quot;lang_expr#booleanexpr&quot;&gt;boolean expression is true&lt;/a&gt;. It is not an error if the WHERE clause does not evaluate to true for any row in the table - this just means that the UPDATE statement affects zero rows.</source>
          <target state="translated">Если оператор UPDATE не имеет предложения WHERE, все строки в таблице изменяются с помощью UPDATE. В противном случае UPDATE влияет только на те строки, для которых &lt;a href=&quot;lang_expr#booleanexpr&quot;&gt;истинно логическое выражение&lt;/a&gt; предложения WHERE . Не является ошибкой, если предложение WHERE не оценивается как истинное для какой-либо строки в таблице - это просто означает, что оператор UPDATE влияет на нулевые строки.</target>
        </trans-unit>
        <trans-unit id="074562fe8dfabc7ba122942fddf559f05fa48e31" translate="yes" xml:space="preserve">
          <source>If the UPDATE statement has no ORDER BY clause, then all rows that would be updated in the absence of the LIMIT clause are assembled in an arbitrary order before applying the LIMIT and OFFSET clauses to determine which are actually updated.</source>
          <target state="translated">Если утверждение UPDATE не имеет пункта ORDER BY,то все строки,которые были бы обновлены при отсутствии пункта LIMIT,собираются в произвольном порядке перед применением пунктов LIMIT и OFFSET для определения того,какие из них действительно обновлены.</target>
        </trans-unit>
        <trans-unit id="0ee1b94b95429e744f462704efa364a50f2413f6" translate="yes" xml:space="preserve">
          <source>If the WAL-index is implemented as a memory-mapped file and that file is read-only to the first thread to connect, then that thread creates an private heap-memory ersazt WAL-index and runs the recovery routine to populate that private WAL-index. The same data results, but it is held privately rather that being written into the public shared memory area.</source>
          <target state="translated">Если WAL-индекс реализован в виде файла,отображенного на карте памяти,и этот файл доступен только для чтения первому подключенному потоку,то этот поток создает WAL-индекс приватной кучи памяти и запускает процедуру восстановления для заполнения этого приватного WAL-индекса.В результате получаются те же самые данные,но они хранятся конфиденциально,а не записываются в общедоступную общую область памяти.</target>
        </trans-unit>
        <trans-unit id="7648c2d70dafce18f6cb4ef634247a503d61eeca" translate="yes" xml:space="preserve">
          <source>If the WHERE clause evaluates to FALSE, then skip the steps that follow and continue to the next record.</source>
          <target state="translated">Если пункт ГДЕ оценивает FALSE,пропустите следующие шаги и перейдите к следующей записи.</target>
        </trans-unit>
        <trans-unit id="37f61285fabc2a1caf8acf5c9c00c9ccc80b5f28" translate="yes" xml:space="preserve">
          <source>If the WHERE clause is not present, all records in the table are deleted. If a WHERE clause is supplied, then only those rows for which the WHERE clause &lt;a href=&quot;lang_expr#booleanexpr&quot;&gt;boolean expression&lt;/a&gt; is true are deleted. Rows for which the expression is false or NULL are retained.</source>
          <target state="translated">Если предложение WHERE отсутствует, все записи в таблице удаляются. Если предоставляется предложение WHERE, то удаляются только те строки, для которых &lt;a href=&quot;lang_expr#booleanexpr&quot;&gt;логическое выражение&lt;/a&gt; предложения WHERE истинно. Строки, для которых выражение является ложным или NULL, сохраняются.</target>
        </trans-unit>
        <trans-unit id="7ecdfb78c909bf7386760f4b8a9af44a0acb2a2c" translate="yes" xml:space="preserve">
          <source>If the WHERE clause of a query contains an OR expression, then SQLite might use the &lt;a href=&quot;queryplanner#or_in_where&quot;&gt;&quot;OR by union&quot;&lt;/a&gt; strategy (also known as the &lt;a href=&quot;optoverview#or_opt&quot;&gt;OR optimization&lt;/a&gt;). In this case there will be single top-level record for the search, with two sub-records, one for each index:</source>
          <target state="translated">Если предложение WHERE запроса содержит выражение OR, тогда SQLite может использовать стратегию &lt;a href=&quot;queryplanner#or_in_where&quot;&gt;&amp;laquo;OR by union&amp;raquo;&lt;/a&gt; (также известную как &lt;a href=&quot;optoverview#or_opt&quot;&gt;оптимизация OR&lt;/a&gt; ). В этом случае для поиска будет одна запись верхнего уровня с двумя вложенными записями, по одной для каждого индекса:</target>
        </trans-unit>
        <trans-unit id="66d534e3ba541f4a816044bc7bb6de32d19f621c" translate="yes" xml:space="preserve">
          <source>If the Y parameter to sqlite3_free_filename(Y) is anything other than a NULL pointer or a pointer previously acquired from sqlite3_create_filename(), then bad things such as heap corruption or segfaults may occur. The value Y should be used again after sqlite3_free_filename(Y) has been called. This means that if the &lt;a href=&quot;#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen()&lt;/a&gt; method of a VFS has been called using Y, then the corresponding [sqlite3_module.xClose() method should also be invoked prior to calling sqlite3_free_filename(Y).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47f803875c1a08bebb885c914c92a3d72ff50a92" translate="yes" xml:space="preserve">
          <source>If the Y parameter to sqlite3_free_filename(Y) is anything other than a NULL pointer or a pointer previously acquired from sqlite3_create_filename(), then bad things such as heap corruption or segfaults may occur. The value Y should be used again after sqlite3_free_filename(Y) has been called. This means that if the &lt;a href=&quot;vfs#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen()&lt;/a&gt; method of a VFS has been called using Y, then the corresponding [sqlite3_module.xClose() method should also be invoked prior to calling sqlite3_free_filename(Y).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74877c4dea96c98f4b3c0b669711d0dd7770d2b9" translate="yes" xml:space="preserve">
          <source>If the _HAVE_SQLITE_CONFIG_H macro is defined then the SQLite source code will attempt to #include a file named &quot;config.h&quot;. The &quot;config.h&quot; file usually contains other configuration options, especially &quot;HAVE_</source>
          <target state="translated">Если задан макрос _HAVE_SQLITE_CONFIG_H,то исходный код SQLite попытается #включить файл с именем &quot;config.h&quot;.Файл &quot;config.h&quot; обычно содержит другие опции конфигурации,в частности,&quot;HAVE_</target>
        </trans-unit>
        <trans-unit id="558abcd908b311140ea78da82869118d13cb3c75" translate="yes" xml:space="preserve">
          <source>If the action code is &lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;SQLITE_READ&lt;/a&gt; and the callback returns &lt;a href=&quot;#SQLITE_DENY&quot;&gt;SQLITE_IGNORE&lt;/a&gt; then the &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; statement is constructed to substitute a NULL value in place of the table column that would have been read if &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; had been returned. The &lt;a href=&quot;#SQLITE_DENY&quot;&gt;SQLITE_IGNORE&lt;/a&gt; return can be used to deny an untrusted user access to individual columns of a table. When a table is referenced by a &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; but no column values are extracted from that table (for example in a query like &quot;SELECT count(*) FROM tab&quot;) then the &lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;SQLITE_READ&lt;/a&gt; authorizer callback is invoked once for that table with a column name that is an empty string. If the action code is &lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;SQLITE_DELETE&lt;/a&gt; and the callback returns &lt;a href=&quot;#SQLITE_DENY&quot;&gt;SQLITE_IGNORE&lt;/a&gt; then the &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; operation proceeds but the &lt;a href=&quot;lang_delete#truncateopt&quot;&gt;truncate optimization&lt;/a&gt; is disabled and all rows are deleted individually.</source>
          <target state="translated">Если код действия - &lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;SQLITE_READ,&lt;/a&gt; а обратный вызов возвращает &lt;a href=&quot;#SQLITE_DENY&quot;&gt;SQLITE_IGNORE,&lt;/a&gt; тогда &lt;a href=&quot;#sqlite3_stmt&quot;&gt;подготовленный операторный&lt;/a&gt; оператор создается для замены значения NULL вместо столбца таблицы, которое было бы прочитано, если бы был возвращен &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; . &lt;a href=&quot;#SQLITE_DENY&quot;&gt;SQLITE_IGNORE&lt;/a&gt; возвращение может быть использовано для отказа ненадежного доступа пользователей к отдельным колонкам таблицы. Когда на таблицу ссылается команда &lt;a href=&quot;lang_select&quot;&gt;SELECT,&lt;/a&gt; но значения столбцов не извлекаются из этой таблицы (например, в запросе типа &amp;laquo;SELECT count (*) FROM tab&amp;raquo;), тогда &lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;обратный&lt;/a&gt; вызов авторизатора SQLITE_READ вызывается один раз для этой таблицы с именем столбца, которое это пустая строка. Если код действия - &lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;SQLITE_DELETE&lt;/a&gt;и обратный вызов возвращает &lt;a href=&quot;#SQLITE_DENY&quot;&gt;SQLITE_IGNORE,&lt;/a&gt; тогда операция &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; продолжается, но &lt;a href=&quot;lang_delete#truncateopt&quot;&gt;оптимизация усечения&lt;/a&gt; отключена, и все строки удаляются по отдельности.</target>
        </trans-unit>
        <trans-unit id="551e501bb088fee5fee1641a8f77e7fc3633f5dd" translate="yes" xml:space="preserve">
          <source>If the action code is &lt;a href=&quot;c_alter_table&quot;&gt;SQLITE_READ&lt;/a&gt; and the callback returns &lt;a href=&quot;c_deny&quot;&gt;SQLITE_IGNORE&lt;/a&gt; then the &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; statement is constructed to substitute a NULL value in place of the table column that would have been read if &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; had been returned. The &lt;a href=&quot;c_deny&quot;&gt;SQLITE_IGNORE&lt;/a&gt; return can be used to deny an untrusted user access to individual columns of a table. When a table is referenced by a &lt;a href=&quot;../lang_select&quot;&gt;SELECT&lt;/a&gt; but no column values are extracted from that table (for example in a query like &quot;SELECT count(*) FROM tab&quot;) then the &lt;a href=&quot;c_alter_table&quot;&gt;SQLITE_READ&lt;/a&gt; authorizer callback is invoked once for that table with a column name that is an empty string. If the action code is &lt;a href=&quot;c_alter_table&quot;&gt;SQLITE_DELETE&lt;/a&gt; and the callback returns &lt;a href=&quot;c_deny&quot;&gt;SQLITE_IGNORE&lt;/a&gt; then the &lt;a href=&quot;../lang_delete&quot;&gt;DELETE&lt;/a&gt; operation proceeds but the &lt;a href=&quot;../lang_delete#truncateopt&quot;&gt;truncate optimization&lt;/a&gt; is disabled and all rows are deleted individually.</source>
          <target state="translated">Если код действия - &lt;a href=&quot;c_alter_table&quot;&gt;SQLITE_READ,&lt;/a&gt; а обратный вызов возвращает &lt;a href=&quot;c_deny&quot;&gt;SQLITE_IGNORE,&lt;/a&gt; тогда &lt;a href=&quot;stmt&quot;&gt;подготовленный операторный&lt;/a&gt; оператор создается для замены значения NULL вместо столбца таблицы, которое было бы прочитано, если бы был возвращен &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; . &lt;a href=&quot;c_deny&quot;&gt;SQLITE_IGNORE&lt;/a&gt; возвращение может быть использовано для отказа ненадежного доступа пользователей к отдельным колонкам таблицы. Когда на таблицу ссылается команда &lt;a href=&quot;../lang_select&quot;&gt;SELECT,&lt;/a&gt; но значения столбцов не извлекаются из этой таблицы (например, в запросе типа &amp;laquo;SELECT count (*) FROM tab&amp;raquo;), тогда &lt;a href=&quot;c_alter_table&quot;&gt;обратный&lt;/a&gt; вызов авторизатора SQLITE_READ вызывается один раз для этой таблицы с именем столбца, которое это пустая строка. Если код действия - &lt;a href=&quot;c_alter_table&quot;&gt;SQLITE_DELETE&lt;/a&gt;и обратный вызов возвращает &lt;a href=&quot;c_deny&quot;&gt;SQLITE_IGNORE,&lt;/a&gt; тогда операция &lt;a href=&quot;../lang_delete&quot;&gt;DELETE&lt;/a&gt; продолжается, но &lt;a href=&quot;../lang_delete#truncateopt&quot;&gt;оптимизация усечения&lt;/a&gt; отключена, и все строки удаляются по отдельности.</target>
        </trans-unit>
        <trans-unit id="bd1e313db1648e3d841b56f1eba1325f9492fb26" translate="yes" xml:space="preserve">
          <source>If the application does not use triggers or views, consider disabling the unused capabilities with:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e48946c22fc154fe87cb537c121e425dbb9574d0" translate="yes" xml:space="preserve">
          <source>If the application does not use triggers or views, then disable the unused capabilities using:</source>
          <target state="translated">Если приложение не использует триггеры или просмотры,отключите неиспользуемые возможности:</target>
        </trans-unit>
        <trans-unit id="f5d26d8716b0cdd9f988973fac2e73b815006603" translate="yes" xml:space="preserve">
          <source>If the application does use triggers or views, then use queries to scan the &lt;a href=&quot;fileformat2#sqlite_master&quot;&gt;sqlite_master&lt;/a&gt; table to verify that the triggers and views found there are expected, that there are no surplus triggers or views, existing triggers and views have not been tampered with, and that no existing ordinary tables have been replaced by malicious views.</source>
          <target state="translated">Если приложение действительно использует триггеры или представления, используйте запросы для сканирования таблицы &lt;a href=&quot;fileformat2#sqlite_master&quot;&gt;sqlite_master,&lt;/a&gt; чтобы убедиться, что найденные там триггеры и представления являются ожидаемыми, что нет лишних триггеров или представлений, существующие триггеры и представления не были изменены и что никакие существующие обычные таблицы не были заменены вредоносными представлениями.</target>
        </trans-unit>
        <trans-unit id="0aef3c759a1be5c730a8586e6ee0c4911bb88637" translate="yes" xml:space="preserve">
          <source>If the application includes any &lt;a href=&quot;appfunc&quot;&gt;custom SQL functions&lt;/a&gt; or &lt;a href=&quot;vtab#customvtab&quot;&gt;custom virtual tables&lt;/a&gt; that have side effects or that might leak privileged information, then the application should use one or more of the techniques below to prevent a maliciously crafted database schema from surreptitiously running those SQL functions and/or virtual tables for nefarious purposes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2469e0f7ca599347e4594642b1d8b0b3f0287081" translate="yes" xml:space="preserve">
          <source>If the application invokes &lt;a href=&quot;c3ref/file_control&quot;&gt;sqlite3_file_control&lt;/a&gt;(&lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlpersistwal&quot;&gt;SQLITE_FCNTL_PERSIST_WAL&lt;/a&gt;) on the database connection prior to closing, then the final checkpoint is still run but the WAL and WAL-index files are not deleted as they normally would be. This leaves the database in a state that allows other processes without write permission on the database, WAL, or WAL-index files to open the database read-only. If the WAL and WAL-index files are missing, then a process that lacks permission to create and initialize those files will not be able to open the database, unless the database is designated as immutable using the &lt;a href=&quot;uri#uriimmutable&quot;&gt;immutable query parameter&lt;/a&gt;.</source>
          <target state="translated">Если приложение вызывает &lt;a href=&quot;c3ref/file_control&quot;&gt;sqlite3_file_control&lt;/a&gt; ( &lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlpersistwal&quot;&gt;SQLITE_FCNTL_PERSIST_WAL&lt;/a&gt; ) в соединении с базой данных перед закрытием, то последняя контрольная точка все еще выполняется, но файлы WAL и WAL-index не удаляются, как обычно. Это оставляет базу данных в состоянии, позволяющем другим процессам без разрешения на запись в файлы базы данных, WAL или WAL-index файлы открывать базу данных только для чтения. Если файлы WAL и WAL-index отсутствуют, то процесс, у которого нет разрешения на создание и инициализацию этих файлов, не сможет открыть базу данных, если база данных не обозначена как неизменяемая с помощью параметра &lt;a href=&quot;uri#uriimmutable&quot;&gt;неизменяемого запроса&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0623d9575995bdb9d6c267b0da83f975d16d83ea" translate="yes" xml:space="preserve">
          <source>If the application is designed to manage data in small pieces, then the database should never contain any large strings or BLOBs and hence element 1 above should not be a factor. If the database does contain large strings or BLOBs, they should be read using &lt;a href=&quot;c3ref/blob&quot;&gt;incremental BLOB I/O&lt;/a&gt; and rows that contain the large strings or BLOBs should never be update by any means other than &lt;a href=&quot;c3ref/blob&quot;&gt;incremental BLOB I/O&lt;/a&gt;. Otherwise, the &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; routine will need to read the entire row into contiguous memory at some point, and that will involve at least one large memory allocation.</source>
          <target state="translated">Если приложение предназначено для управления данными небольшими частями, то база данных никогда не должна содержать больших строк или больших двоичных объектов, и, следовательно, элемент 1 выше не должен быть фактором. Если база данных содержит большие строки или большие двоичные объекты, их следует читать с использованием &lt;a href=&quot;c3ref/blob&quot;&gt;инкрементного ввода-вывода&lt;/a&gt; больших двоичных объектов, а строки, содержащие большие строки или большие двоичные объекты, никогда не должны обновляться никакими средствами, кроме &lt;a href=&quot;c3ref/blob&quot;&gt;инкрементального ввода-вывода&lt;/a&gt; больших двоичных объектов . В противном случае подпрограмме &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step ()&lt;/a&gt; в какой-то момент потребуется прочитать всю строку в непрерывную память, что потребует как минимум одного выделения большой памяти.</target>
        </trans-unit>
        <trans-unit id="d0ebb1eaae39f6046644fb7a5c8e50db080966a3" translate="yes" xml:space="preserve">
          <source>If the application or host computer crashes before the transaction completes, then the rollback journal or write-ahead log contains information needed to restore the main database file to a consistent state. When a rollback journal or write-ahead log contains information necessary for recovering the state of the database, they are called a &quot;hot journal&quot; or &quot;hot WAL file&quot;. Hot journals and WAL files are only a factor during error recovery scenarios and so are uncommon, but they are part of the state of an SQLite database and so cannot be ignored. This document defines the format of a rollback journal and the write-ahead log file, but the focus is on the main database file.</source>
          <target state="translated">Если приложение или хост-компьютер выходит из строя до завершения транзакции,то журнал отката или записи вперед содержит информацию,необходимую для восстановления основного файла базы данных в стабильное состояние.Когда журнал отката или записи содержит информацию,необходимую для восстановления состояния БД,они называются &quot;горячим журналом&quot; или &quot;горячим файлом WAL&quot;.Горячие журналы и файлы WAL являются лишь фактором при сценарии восстановления ошибок и поэтому встречаются редко,но они являются частью состояния базы данных SQLite и поэтому не могут быть проигнорированы.Данный документ определяет формат журнала отката и файла журнала-записи,но основное внимание уделяется главному файлу базы данных.</target>
        </trans-unit>
        <trans-unit id="2a5d41f54973dce5874420b1200abe91d1314dc8" translate="yes" xml:space="preserve">
          <source>If the application uses &lt;a href=&quot;c3ref/create_function&quot;&gt;application-defined SQL functions&lt;/a&gt; that have side effects, then it is recommended to set the &lt;a href=&quot;c3ref/c_deterministic&quot;&gt;SQLITE_DIRECTONLY&lt;/a&gt; flag on those SQL functions to prevent them from being used inside triggers and views. To illustrate the importance of this flag, consider an application that implements an SQL function &quot;send_money(...)&quot;. Without the SQLITE_DIRECTONLY flag, an attacker might be able to add a trigger or view that uses that custom function, then trick a high-privilege application to run an otherwise harmless query that invokes that malicious trigger or view. The SQLITE_DIRECTONLY flag prevents the attack by requiring the &quot;send_money()&quot; function to be invoked directly by the application, rather than indirectly through a trigger or view.</source>
          <target state="translated">Если приложение использует &lt;a href=&quot;c3ref/create_function&quot;&gt;определяемые приложением функции SQL,&lt;/a&gt; которые имеют побочные эффекты, рекомендуется установить флаг &lt;a href=&quot;c3ref/c_deterministic&quot;&gt;SQLITE_DIRECTONLY&lt;/a&gt; для этих функций SQL, чтобы предотвратить их использование внутри триггеров и представлений. Чтобы проиллюстрировать важность этого флага, рассмотрим приложение, которое реализует функцию SQL send_money (...). Без флага SQLITE_DIRECTONLY злоумышленник может добавить триггер или представление, использующее эту настраиваемую функцию, а затем обмануть приложение с высокими привилегиями, чтобы запустить безвредный запрос, который вызывает этот вредоносный триггер или представление. Флаг SQLITE_DIRECTONLY предотвращает атаку, требуя, чтобы функция send_money () вызывалась непосредственно приложением, а не косвенно через триггер или представление.</target>
        </trans-unit>
        <trans-unit id="d6f9cd1b9ea5044b899607d0f8509b7399b72066" translate="yes" xml:space="preserve">
          <source>If the application wanted to keep all content in memory, it could continue reading and parsing the other pages using a background thread after drawing the first page. Or, since reading from SQLite is so efficient, the application might instead choose to reduce its memory footprint and only keep a single slide in memory at a time. Or maybe it keeps the current slide and the next slide in memory, to facility rapid transitions to the next slide.</source>
          <target state="translated">Если бы приложение хотело сохранить все содержимое в памяти,оно могло бы продолжить чтение и разбор других страниц с помощью фонового потока после отрисовки первой страницы.Или,так как чтение из SQLite настолько эффективно,приложение могло бы вместо этого сократить объем своей памяти и хранить в ней только один слайд за раз.А может быть,оно хранит текущий слайд и следующий слайд в памяти,чтобы подсистемные быстрые переходы к следующему слайду.</target>
        </trans-unit>
        <trans-unit id="8569a113bc3212a8fdd578bf6c990f890a161761" translate="yes" xml:space="preserve">
          <source>If the argument N is positive then the suggested cache size is set to N. If the argument N is negative, then the number of cache pages is adjusted to be a number of pages that would use approximately abs(N*1024) bytes of memory based on the current page size. SQLite remembers the number of pages in the page cache, not the amount of memory used. So if you set the cache size using a negative number and subsequently change the page size (using the &lt;a href=&quot;pragma#pragma_page_size&quot;&gt;PRAGMA page_size&lt;/a&gt; command) then the maximum amount of cache memory will go up or down in proportion to the change in page size.</source>
          <target state="translated">Если аргумент N положителен, то предлагаемый размер кэша установлен на N. Если аргумент N отрицательный, то количество страниц кэша корректируется так, чтобы соответствовать количеству страниц, которые будут использовать приблизительно абс (N * 1024) байтов памяти. на основе текущего размера страницы. SQLite запоминает количество страниц в кеше страниц, а не объем используемой памяти. Таким образом, если вы установите размер кеша с помощью отрицательного числа и впоследствии измените размер страницы (с помощью команды &lt;a href=&quot;pragma#pragma_page_size&quot;&gt;PRAGMA page_size&lt;/a&gt; ), то максимальный объем кэш-памяти будет увеличиваться или уменьшаться пропорционально изменению размера страницы.</target>
        </trans-unit>
        <trans-unit id="333007bde9d13022c1e70f3f252829b77ea3504a" translate="yes" xml:space="preserve">
          <source>If the argument N is zero then the soft heap limit is disabled.</source>
          <target state="translated">Если аргумент N равен нулю,то лимит мягкой кучи отключается.</target>
        </trans-unit>
        <trans-unit id="0910062f14fed63da9341471516f0b8c2feb398e" translate="yes" xml:space="preserve">
          <source>If the argument X to json(X) contains JSON objects with duplicate labels, then it is undefined whether or not the duplicates are preserved. The current implementation preserves duplicates. However, future enhancements to this routine may choose to silently remove duplicates.</source>
          <target state="translated">Если аргумент X to json(X)содержит JSON-объекты с дубликатами меток,то неизвестно,сохраняются ли дубликаты или нет.Текущая реализация сохраняет дубликаты.Однако,будущие усовершенствования этой рутины могут выбрать бесшумное удаление дубликатов.</target>
        </trans-unit>
        <trans-unit id="6f833aefc23dc66bc8a11fd873780dad93c32799" translate="yes" xml:space="preserve">
          <source>If the argument is an empty string then the authorizer is disabled. If the argument is omitted, then the current authorizer is returned.</source>
          <target state="translated">Если аргумент является пустой строкой,то авторизатор отключается.Если аргумент опущен,то возвращается текущий авторизатор.</target>
        </trans-unit>
        <trans-unit id="db2e11d8e987617a2ede3ca5cb77cc0207ab30da" translate="yes" xml:space="preserve">
          <source>If the argument to %Q is a null pointer then the output is an unquoted &quot;NULL&quot;. In other words, a null pointer generates an SQL NULL, and a non-null pointer generates a valid SQL string literal. If the argument to %q is a null pointer then no output is generated. Thus a null-pointer to %q is the same as an empty string.</source>
          <target state="translated">Если аргумент %Q является нулевым указателем,то выводится без кавычек &quot;NULL&quot;.Другими словами,нулевой указатель генерирует SQL NULL,а ненулевой-действительный строковый литерал SQL.Если аргумент %q является нулевым указателем,то вывод не производится.Таким образом,нулевой указатель на %q является тем же самым,что и пустая строка.</target>
        </trans-unit>
        <trans-unit id="34bfefe0d198d1d0315cf64a45912620ff3af0d6" translate="yes" xml:space="preserve">
          <source>If the argument to &lt;a href=&quot;pragma#pragma_cache_size&quot;&gt;PRAGMA cache_size&lt;/a&gt; is negative N, that means to use approximately -1024*N bytes of memory for the page cache regardless of the page size.</source>
          <target state="translated">Если аргумент &lt;a href=&quot;pragma#pragma_cache_size&quot;&gt;PRAGMA cache_size&lt;/a&gt; имеет отрицательное значение N, это означает использование приблизительно -1024 * N байтов памяти для кэша страниц независимо от размера страницы.</target>
        </trans-unit>
        <trans-unit id="ad1260c6e1a01baa74d5f905fe5850603affd484" translate="yes" xml:space="preserve">
          <source>If the argument to sqlite3_mutex_enter(), sqlite3_mutex_try(), or sqlite3_mutex_leave() is a NULL pointer, then all three routines behave as no-ops.</source>
          <target state="translated">Если аргумент sqlite3_mutex_enter(),sqlite3_mutex_try()или sqlite3_mutex_leave()является указателем NULL,то все три подпрограммы ведут себя как no-ops.</target>
        </trans-unit>
        <trans-unit id="0142caf16fb3155af68268c72b44fbf8e770bbff" translate="yes" xml:space="preserve">
          <source>If the argument to sqlite3_mutex_held() is a NULL pointer then the routine should return 1. This seems counter-intuitive since clearly the mutex cannot be held if it does not exist. But the reason the mutex does not exist is because the build is not using mutexes. And we do not want the assert() containing the call to sqlite3_mutex_held() to fail, so a non-zero return is the appropriate thing to do. The sqlite3_mutex_notheld() interface should also return 1 when given a NULL pointer.</source>
          <target state="translated">Если аргумент sqlite3_mutex_held()является указателем NULL,то рутина должна вернуть 1.Это кажется контр-интуитивным,так как очевидно,что мьютекс не может удерживаться,если его не существует.Но причина,по которой мьютекс не существует,в том,что сборка не использует мьютекс.И мы не хотим,чтобы функция assert(),содержащая вызов sqlite3_mutex_held(),вышла из строя,так что ненулевое возвращение-это то,что нужно.Интерфейс sqlite3_mutex_notheld()также должен возвращать 1 при указателе NULL.</target>
        </trans-unit>
        <trans-unit id="a14ce7fd473c10953375f9ccbf76e06b28005ef4" translate="yes" xml:space="preserve">
          <source>If the array variable name is omitted or is the empty string, then the value of each column is stored in a variable with the same name as the column itself. For example:</source>
          <target state="translated">Если имя переменной массива опущено или является пустой строкой,то значение каждого столбца хранится в переменной с тем же именем,что и сам столбец.Например:</target>
        </trans-unit>
        <trans-unit id="ac696fda1c1264eced84b7c7d2919bb500892965" translate="yes" xml:space="preserve">
          <source>If the attempt to insert the row fails because of some other constraint violation (e.g. NOT NULL or UNIQUE), the conflict handler function is invoked with the second argument set to &lt;a href=&quot;#SQLITE_CHANGESET_CONFLICT&quot;&gt;SQLITE_CHANGESET_CONSTRAINT&lt;/a&gt;. This includes the case where the INSERT operation is re-attempted because an earlier call to the conflict handler function returned &lt;a href=&quot;#SQLITE_CHANGESET_ABORT&quot;&gt;SQLITE_CHANGESET_REPLACE&lt;/a&gt;.</source>
          <target state="translated">Если попытка вставить строку не удалась из-за какого-либо другого нарушения ограничения (например, NOT NULL или UNIQUE), вызывается функция обработчика конфликтов со вторым аргументом, установленным в &lt;a href=&quot;#SQLITE_CHANGESET_CONFLICT&quot;&gt;SQLITE_CHANGESET_CONSTRAINT&lt;/a&gt; . Это включает случай, когда операция INSERT &lt;a href=&quot;#SQLITE_CHANGESET_ABORT&quot;&gt;повторяется,&lt;/a&gt; потому что более ранний вызов функции обработчика конфликтов вернул SQLITE_CHANGESET_REPLACE .</target>
        </trans-unit>
        <trans-unit id="00b4296a5ab760c82790fc716c15427ea1f6520d" translate="yes" xml:space="preserve">
          <source>If the attempt to insert the row fails because of some other constraint violation (e.g. NOT NULL or UNIQUE), the conflict handler function is invoked with the second argument set to &lt;a href=&quot;c_changeset_conflict&quot;&gt;SQLITE_CHANGESET_CONSTRAINT&lt;/a&gt;. This includes the case where the INSERT operation is re-attempted because an earlier call to the conflict handler function returned &lt;a href=&quot;c_changeset_abort&quot;&gt;SQLITE_CHANGESET_REPLACE&lt;/a&gt;.</source>
          <target state="translated">Если попытка вставить строку не удалась из-за какого-либо другого нарушения ограничения (например, NOT NULL или UNIQUE), вызывается функция обработчика конфликтов со вторым аргументом, установленным в &lt;a href=&quot;c_changeset_conflict&quot;&gt;SQLITE_CHANGESET_CONSTRAINT&lt;/a&gt; . Это включает случай, когда операция INSERT &lt;a href=&quot;c_changeset_abort&quot;&gt;повторяется,&lt;/a&gt; потому что более ранний вызов функции обработчика конфликтов вернул SQLITE_CHANGESET_REPLACE .</target>
        </trans-unit>
        <trans-unit id="1a0b7bf9240c877d42c55de96b224187eca54a50" translate="yes" xml:space="preserve">
          <source>If the attempt to insert the row fails because the database already contains a row with the same primary key values, the conflict handler function is invoked with the second argument set to &lt;a href=&quot;#SQLITE_CHANGESET_CONFLICT&quot;&gt;SQLITE_CHANGESET_CONFLICT&lt;/a&gt;.</source>
          <target state="translated">Если попытка вставить строку не удалась, потому что база данных уже содержит строку с &lt;a href=&quot;#SQLITE_CHANGESET_CONFLICT&quot;&gt;такими&lt;/a&gt; же значениями первичного ключа, вызывается функция обработчика конфликтов со вторым аргументом, установленным на SQLITE_CHANGESET_CONFLICT .</target>
        </trans-unit>
        <trans-unit id="86e563d45d385632baebf3e72388be8c4af6aec3" translate="yes" xml:space="preserve">
          <source>If the attempt to insert the row fails because the database already contains a row with the same primary key values, the conflict handler function is invoked with the second argument set to &lt;a href=&quot;c_changeset_conflict&quot;&gt;SQLITE_CHANGESET_CONFLICT&lt;/a&gt;.</source>
          <target state="translated">Если попытка вставить строку не удалась, потому что база данных уже содержит строку с &lt;a href=&quot;c_changeset_conflict&quot;&gt;такими&lt;/a&gt; же значениями первичного ключа, вызывается функция обработчика конфликтов со вторым аргументом, установленным на SQLITE_CHANGESET_CONFLICT .</target>
        </trans-unit>
        <trans-unit id="3629ea18c991de1dc5f5b9e0680718c68964bd44" translate="yes" xml:space="preserve">
          <source>If the bClear argument is non-zero, then the auxiliary data is cleared (set to NULL) before this function returns. In this case the xDelete, if any, is not invoked.</source>
          <target state="translated">Если аргумент bClear ненулевой,то перед возвращением этой функции вспомогательные данные очищаются (устанавливаются в NULL).В этом случае xDelete,если он есть,не вызывается.</target>
        </trans-unit>
        <trans-unit id="85be6aa821286c3a809817d29ac82866a6650696" translate="yes" xml:space="preserve">
          <source>If the backup process is restarted frequently enough it may never run to completion and the backupDb() function may never return.</source>
          <target state="translated">Если процесс резервного копирования достаточно часто перезапускается,то он может никогда не завершиться,а функция backupDb()может никогда не вернуться.</target>
        </trans-unit>
        <trans-unit id="ed3ecd64439c51685da70c45077d54474b903f89" translate="yes" xml:space="preserve">
          <source>If the base expression is NULL then the result of the CASE is always the result of evaluating the ELSE expression if it exists, or NULL if it does not.</source>
          <target state="translated">Если базовое выражение NULL,то результатом CASE всегда является результат вычисления выражения ELSE,если оно существует,или NULL,если нет.</target>
        </trans-unit>
        <trans-unit id="8a427aa0dc34d2b046c1ad51ad7573c594257eb3" translate="yes" xml:space="preserve">
          <source>If the base window has an ORDER BY clause, it is copied into the new window. In this case the new window must not specify an ORDER BY clause. If the base window has no ORDER BY clause, one may be specified as part of the new window definition.</source>
          <target state="translated">Если базовое окно имеет пункт ORDER BY,то оно копируется в новое окно.В этом случае новое окно не должно содержать пункта ORDER BY.Если базовое окно не имеет пункта ORDER BY,то его можно указать в определении нового окна.</target>
        </trans-unit>
        <trans-unit id="119dee4cbf58f5993be5ffddf2563e1e23c3d8e2" translate="yes" xml:space="preserve">
          <source>If the blob handle being closed was opened for read-write access, and if the database is in auto-commit mode and there are no other open read-write blob handles or active write statements, the current transaction is committed. If an error occurs while committing the transaction, an error code is returned and the transaction rolled back.</source>
          <target state="translated">Если закрываемый блоб-хэндл был открыт для доступа на чтение-запись,а база данных находится в режиме автокомитации и нет других открытых блоб-хэндлов на чтение-запись или активных заявлений на запись,то текущая транзакция фиксируется.Если при фиксации транзакции происходит ошибка,то возвращается код ошибки и транзакция откатывается.</target>
        </trans-unit>
        <trans-unit id="a888511d0d42c7a009b52c11f52254e39a8e8777" translate="yes" xml:space="preserve">
          <source>If the blocked connection is attempting to obtain a write-lock on a shared-cache table, and more than one other connection currently holds a read-lock on the same table, then SQLite arbitrarily selects one of the other connections to use as the blocking connection.</source>
          <target state="translated">Если заблокированное соединение пытается получить блокировку записи на таблице с общим кэшем,и в настоящее время более одного соединения имеет блокировку чтения на той же таблице,то SQLite произвольно выбирает одно из других соединений для использования в качестве блокирующего соединения.</target>
        </trans-unit>
        <trans-unit id="b15e015a6e8222ac8277a814fcfbbc84b5b7b2fa" translate="yes" xml:space="preserve">
          <source>If the branch instruction that implements the &quot;c!=0&quot; test on line 58 is changed into a no-op, then the while-loop will loop forever and the test suite will fail with a time-out. But if that branch is changed into an unconditional jump, then the hash function will always return 0. The problem is that 0 is a valid hash. A hash function that always returns 0 still works in the sense that SQLite still always gets the correct answer. The table-name hash table degenerates into a linked-list and so the table-name lookups that occur while parsing SQL statements might be a little slower, but the end result will be the same.</source>
          <target state="translated">Если инструкция ветки,реализующей тест &quot;c!=0&quot; на 58-й строке,будет изменена на no-op,то цикл while-loop зациклится навсегда,и тестовый набор выйдет из строки с тайм-аутом.Но если эта ветка изменится на безусловный скачок,то хэш-функция всегда будет возвращать 0.Проблема в том,что 0-это действительный хэш.Хэш-функция,которая всегда возвращает 0,по-прежнему работает в том смысле,что SQLite всегда получает правильный ответ.Хэш-таблица с именами таблиц вырождается в линк-лист,и поэтому поиск имен таблиц,происходящий при разборе SQL-запросов,может быть немного медленнее,но конечный результат будет тот же самый.</target>
        </trans-unit>
        <trans-unit id="d10a175cfd1fe16985e295daacc2dcfb3f2982ad" translate="yes" xml:space="preserve">
          <source>If the buffer contains a patchset, then all prior calls to this function on the same changegroup object must also have specified patchsets. Or, if the buffer contains a changeset, so must have the earlier calls to this function. Otherwise, SQLITE_ERROR is returned and no changes are added to the changegroup.</source>
          <target state="translated">Если буфер содержит патчсет,то все предыдущие вызовы этой функции на одном и том же объекте группы изменений также должны иметь заданные патчсеты.Или,если буфер содержит changeset,то все предыдущие обращения к этой функции должны быть также указаны.В противном случае возвращается SQLITE_ERROR и никаких изменений в группу изменений не добавляется.</target>
        </trans-unit>
        <trans-unit id="5cba5e39badf94f78fab97af6a07c73e6243cd28" translate="yes" xml:space="preserve">
          <source>If the busy callback is NULL, then &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY&lt;/a&gt; is returned immediately upon encountering the lock. If the busy callback is not NULL, then the callback might be invoked with two arguments.</source>
          <target state="translated">Если обратный вызов занятости равен NULL, то &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY&lt;/a&gt; возвращается сразу после обнаружения блокировки. Если обратный вызов занятости не равен NULL, обратный вызов может быть вызван с двумя аргументами.</target>
        </trans-unit>
        <trans-unit id="5b0bd17ec528127c481fd60daa34e2af13ea7150" translate="yes" xml:space="preserve">
          <source>If the busy callback is NULL, then &lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; is returned immediately upon encountering the lock. If the busy callback is not NULL, then the callback might be invoked with two arguments.</source>
          <target state="translated">Если обратный вызов занятости равен NULL, то &lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; возвращается сразу после обнаружения блокировки. Если обратный вызов занятости не равен NULL, обратный вызов может быть вызван с двумя аргументами.</target>
        </trans-unit>
        <trans-unit id="afcbf1f3e790adb1bb6040c89a071eb5f4f5a2b5" translate="yes" xml:space="preserve">
          <source>If the busy method is invoked without an argument, the name of the callback procedure last set by the busy method is returned. If no callback procedure has been set, an empty string is returned.</source>
          <target state="translated">Если метод &quot;занято&quot; вызывается без аргумента,возвращается имя процедуры обратного вызова,последнее установленное методом &quot;занято&quot;.Если ни одна из процедур обратного вызова не установлена,возвращается пустая строка.</target>
        </trans-unit>
        <trans-unit id="85f5b0357119cb8e1c6a774de7f6ae30085546fa" translate="yes" xml:space="preserve">
          <source>If the cache validate procedure prescribed by H35040 is required and does not prove that the</source>
          <target state="translated">Если требуется процедура проверки кэша,предписанная в H35040,и не доказывает,что</target>
        </trans-unit>
        <trans-unit id="854ac2efa118a1d9433a97bc97dd8176f442561c" translate="yes" xml:space="preserve">
          <source>If the call to xAccess() required by H35140 fails (due to an IO error or similar), then SQLite shall abandon the attempt to open a</source>
          <target state="translated">Если вызов xAccess(),требуемый в H35140,не удастся (из-за ошибки ввода-вывода или подобной),то SQLite откажется от попытки открыть a</target>
        </trans-unit>
        <trans-unit id="1c9becc9db0bbc14b6323875b3f39aa5c2a244e7" translate="yes" xml:space="preserve">
          <source>If the call to xAccess() required by H35490 fails (due to an IO or other internal VFS error), then SQLite shall abandon the attempt to open a</source>
          <target state="translated">Если вызов xAccess(),требуемый в H35490,не удастся (из-за ошибки IO или другой внутренней VFS),то SQLite откажется от попытки открыть a</target>
        </trans-unit>
        <trans-unit id="7bd0a091025aae3680b1db643d16d28c98cc6e9b" translate="yes" xml:space="preserve">
          <source>If the call to xAccess() required by H35490 reveals that the journal file is no longer present in the file system, then SQLite shall abandon the attempt to open a</source>
          <target state="translated">Если при вызове xAccess(),требуемом H35490,обнаруживается,что файл журнала больше не присутствует в файловой системе,то SQLite должен отказаться от попытки открыть a</target>
        </trans-unit>
        <trans-unit id="3c3c8cf623e8c157f82c9c8bd8de3ce49f6292d0" translate="yes" xml:space="preserve">
          <source>If the call to xCheckReservedLock() required by H35160 fails (due to an IO or other internal VFS error), then SQLite shall abandon the attempt to open a</source>
          <target state="translated">Если вызов xCheckReservedLock(),требуемый в H35160,не удастся (из-за ошибки IO или другой внутренней VFS),то SQLite откажется от попытки открыть a</target>
        </trans-unit>
        <trans-unit id="527cca95e4fd8fdc84a2ca6b5f00a7e854482d28" translate="yes" xml:space="preserve">
          <source>If the call to xCheckReservedLock() required by H35160 indicates that some other</source>
          <target state="translated">Если вызов xCheckReservedLock(),требуемый H35160,указывает,что какой-то другой</target>
        </trans-unit>
        <trans-unit id="b6b7e886a7c9cbfdadb1dc23e73d315693f496ee" translate="yes" xml:space="preserve">
          <source>If the call to xDelete() required by H35450 fails (due to an IO or other internal VFS error), then SQLite shall abandon the attempt to open a</source>
          <target state="translated">Если вызов xDelete(),требуемый в H35450,не удастся (из-за ошибки IO или другой внутренней VFS),то SQLite откажется от попытки открыть a</target>
        </trans-unit>
        <trans-unit id="5af5d373c56bb9dcd62ea184e1e76437bf4a9601" translate="yes" xml:space="preserve">
          <source>If the call to xFileSize() required by H35450 fails (due to an IO or other internal VFS error), then SQLite shall abandon the attempt to open a</source>
          <target state="translated">Если вызов xFileSize(),требуемый в H35450,не удастся (из-за ошибки IO или другой внутренней VFS),то SQLite откажется от попытки открыть a</target>
        </trans-unit>
        <trans-unit id="2a548d9a4e673897d73f6b03d7eb848a11645c48" translate="yes" xml:space="preserve">
          <source>If the call to xOpen() required by H35440 fails (due to an IO or other internal VFS error), then SQLite shall abandon the attempt to open a</source>
          <target state="translated">Если вызов xOpen(),требуемый в H35440,не удастся (из-за ошибки IO или другой внутренней VFS),то SQLite откажется от попытки открыть a</target>
        </trans-unit>
        <trans-unit id="d1ec650a833c11cb6d8b04d5f0bcc10f45ba6aa9" translate="yes" xml:space="preserve">
          <source>If the callback function returns any value other than SQLITE_OK, the query is abandoned and the xQueryPhrase function returns immediately. If the returned value is SQLITE_DONE, xQueryPhrase returns SQLITE_OK. Otherwise, the error code is propagated upwards.</source>
          <target state="translated">Если функция обратного вызова возвращает любое значение,отличное от SQLITE_OK,то запрос прекращается и функция xQueryPhrase немедленно возвращается.Если возвращаемое значение является SQLITE_DONE,функция xQueryPhrase возвращает SQLITE_OK.В противном случае код ошибки передается вверх.</target>
        </trans-unit>
        <trans-unit id="e7031b92fb19c04c6b57152812c2809849a4f000" translate="yes" xml:space="preserve">
          <source>If the callback function to &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec()&lt;/a&gt; returns non-zero, then sqlite3_exec() will return SQLITE_ABORT.</source>
          <target state="translated">Если функция обратного вызова &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec ()&lt;/a&gt; возвращает ненулевое значение, тогда sqlite3_exec () вернет SQLITE_ABORT.</target>
        </trans-unit>
        <trans-unit id="a386306ee9feeed2835e0b935d9f3858fdfe7719" translate="yes" xml:space="preserve">
          <source>If the change to table X also affects other tables or indexes or triggers are views within schema, then run &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; statements to modify those other tables indexes and views too. For example, if the name of a column changes, all FOREIGN KEY constraints, triggers, indexes, and views that refer to that column must be modified.</source>
          <target state="translated">Если изменение в таблице X также влияет на другие таблицы или индексы, или триггеры являются представлениями в схеме, запустите операторы &lt;a href=&quot;lang_update&quot;&gt;UPDATE,&lt;/a&gt; чтобы также изменить индексы и представления этих других таблиц. Например, если имя столбца изменяется, необходимо изменить все ограничения FOREIGN KEY, триггеры, индексы и представления, которые ссылаются на этот столбец.</target>
        </trans-unit>
        <trans-unit id="4f32e1ca273326c7edb692e7f8fb897873c86b6d" translate="yes" xml:space="preserve">
          <source>If the columns of your result set are named by AS clauses, then SQLite is guaranteed to use the identifier to the right of the AS keyword as the column name. If the result set does not use an AS clause, then SQLite is free to name the column anything it wants. See the &lt;a href=&quot;c3ref/column_name&quot;&gt;sqlite3_column_name()&lt;/a&gt; documentation for further information.</source>
          <target state="translated">Если столбцы вашего результирующего набора названы предложениями AS, то SQLite гарантированно использует идентификатор справа от ключевого слова AS в качестве имени столбца. Если в результирующем наборе не используется предложение AS, SQLite может дать столбцу любое имя. Дополнительную информацию см. В документации &lt;a href=&quot;c3ref/column_name&quot;&gt;sqlite3_column_name ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2f6ac289e0c179705fc9860a15b31aba8aa6dfe9" translate="yes" xml:space="preserve">
          <source>If the compression method for the record is either 0 or 8 (see below), then the uncompressed data associated with the zip file entry. Or, if the compression method is not 0 or 8, this column contains a NULL value.</source>
          <target state="translated">Если метод сжатия для записи 0 или 8 (см.ниже),то несжатые данные,связанные с записью в zip-файле.Или,если метод сжатия не равен 0 или 8,то этот столбец содержит значение NULL.</target>
        </trans-unit>
        <trans-unit id="6d7fff8b9b0e80fbe64f6ffbfb79c99106754efa" translate="yes" xml:space="preserve">
          <source>If the content is compressed, then such an &lt;a href=&quot;sqlar&quot;&gt;SQLite Archive&lt;/a&gt; database is &lt;a href=&quot;affcase1#smaller&quot;&gt;the same size&lt;/a&gt; (&amp;plusmn;1%) as an equivalent ZIP archive, and it has the advantage of being able to update individual &quot;files&quot; without rewriting the entire document.</source>
          <target state="translated">Если содержимое сжато, то такая база данных &lt;a href=&quot;sqlar&quot;&gt;SQLite Archive&lt;/a&gt; имеет &lt;a href=&quot;affcase1#smaller&quot;&gt;тот же размер&lt;/a&gt; (&amp;plusmn; 1%), что и эквивалентный ZIP-архив, и имеет то преимущество, что она может обновлять отдельные &amp;laquo;файлы&amp;raquo; без перезаписи всего документа.</target>
        </trans-unit>
        <trans-unit id="07d4949504c6ebefef1a44e834288b1c17ef2c29" translate="yes" xml:space="preserve">
          <source>If the content of a subquery might need to be visited more than once, then the use of a co-routine is undesirable, as the co-routine would then have to compute the data more than once. And if the subquery cannot be flattened, that means the subquery must be manifested into a transient table.</source>
          <target state="translated">Если содержание подзапроса может потребовать посещения более одного раза,то использование ко-рутины нежелательно,так как в этом случае ко-рутине придется вычислять данные более одного раза.А если подзапрос не может быть сплющен,то это означает,что подзапрос должен быть отображен в переходной таблице.</target>
        </trans-unit>
        <trans-unit id="c4de8e7a63ccfd940999297f77703800e91edb69" translate="yes" xml:space="preserve">
          <source>If the content option is used along with the languageid option, then the named languageid column must exist in the content= table (subject to the usual rules - if a query never needs to read the content table then this restriction does not apply).</source>
          <target state="translated">Если опция content используется вместе с опцией languageid,то в таблице content=должен существовать столбец с именем languageid (при условии соблюдения обычных правил-если запрос никогда не должен читать таблицу содержимого,то это ограничение не применяется).</target>
        </trans-unit>
        <trans-unit id="69c4116a662051610d482a3763e629de02d91b0e" translate="yes" xml:space="preserve">
          <source>If the coroutine that is launched by this instruction ends with &lt;a href=&quot;opcode#Yield&quot;&gt;Yield&lt;/a&gt; or &lt;a href=&quot;opcode#Return&quot;&gt;Return&lt;/a&gt; then continue to the next instruction. But if the coroutine launched by this instruction ends with &lt;a href=&quot;opcode#EndCoroutine&quot;&gt;EndCoroutine&lt;/a&gt;, then jump to P2 rather than continuing with the next instruction.</source>
          <target state="translated">Если сопрограмма, запускаемая этой инструкцией, заканчивается на &lt;a href=&quot;opcode#Yield&quot;&gt;Yield&lt;/a&gt; или &lt;a href=&quot;opcode#Return&quot;&gt;Return,&lt;/a&gt; переходите к следующей инструкции. Но если сопрограмма, запущенная этой инструкцией, заканчивается на &lt;a href=&quot;opcode#EndCoroutine&quot;&gt;EndCoroutine&lt;/a&gt; , то переходите к P2, а не продолжайте выполнение следующей инструкции.</target>
        </trans-unit>
        <trans-unit id="d90236a26f30bb94fe93491f2ee7d8229a45dcb7" translate="yes" xml:space="preserve">
          <source>If the covering index is used for the scan, the &quot;fruit&quot; column will appear naturally in the correct order, but when there are two or more rows with the same fruit, the price might be out of order. When this occurs, SQLite does many small sorts, one sort for each distinct value of fruit, rather than one large sort. Figure 22 below illustrates the concept.</source>
          <target state="translated">Если для сканирования используется индекс покрытия,столбец &quot;фрукты&quot; будет выглядеть естественно в правильном порядке,но при наличии двух или более строк с одним и тем же фруктом,цена может быть не в порядке.Когда это происходит,SQLite делает много маленьких сортов,один сорт для каждого отдельного значения фруктов,а не один большой сорт.Рисунок 22 ниже иллюстрирует эту концепцию.</target>
        </trans-unit>
        <trans-unit id="9c6f80849dfd69b57ae6014cb409620e08c9388e" translate="yes" xml:space="preserve">
          <source>If the current statement is not inside an explicit transaction (a &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt;/&lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt;/&lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt; block), then an implicit transaction is committed as soon as the statement has finished executing. In this case deferred constraints behave the same as immediate constraints.</source>
          <target state="translated">Если текущий оператор не находится внутри явной транзакции (блок &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt; / &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; / &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt; ), то неявная транзакция фиксируется, как только оператор завершает выполнение. В этом случае отложенные ограничения ведут себя так же, как немедленные ограничения.</target>
        </trans-unit>
        <trans-unit id="392488489ea8e86894e96e98c9d528e435e44b99" translate="yes" xml:space="preserve">
          <source>If the current version of SQLite is 3.8.2 or greater, the estimatedRows field may be set to an estimate of the number of rows returned by the proposed query plan. If this value is not explicitly set, the default estimate of 25 rows is used.</source>
          <target state="translated">Если текущая версия SQLite 3.8.2 или выше,поле estimatedRows может быть установлено на оценку количества строк,возвращаемых предлагаемым планом запроса.Если это значение явно не задано,используется оценка по умолчанию из 25 строк.</target>
        </trans-unit>
        <trans-unit id="d14a622439a8b842f388bc686b9c68da678476ab" translate="yes" xml:space="preserve">
          <source>If the current version of SQLite is 3.9.0 or greater, the idxFlags field may be set to SQLITE_INDEX_SCAN_UNIQUE to indicate that the virtual table will return only zero or one rows given the input constraints. Additional bits of the idxFlags field might be understood in later versions of SQLite.</source>
          <target state="translated">Если текущая версия SQLite 3.9.0 или выше,поле idxFlags может быть установлено в SQLITE_INDEX_SCAN_UNIQUE для указания,что виртуальная таблица будет возвращать только ноль или одну строку с учетом ограничений по вводу.Дополнительные биты поля idxFlags могут быть поняты в более поздних версиях SQLite.</target>
        </trans-unit>
        <trans-unit id="7ead26894e06c87e567f28556505a47feb41761a" translate="yes" xml:space="preserve">
          <source>If the cursor P1 is already opened on an ephemeral table, the table is cleared (all content is erased).</source>
          <target state="translated">Если курсор P1 уже открыт на эфемерной таблице,то таблица очищается (все содержимое стирается).</target>
        </trans-unit>
        <trans-unit id="4895543ee94b53e62d72914bc8c347747fb66179" translate="yes" xml:space="preserve">
          <source>If the cursor P1 was opened using the OPFLAG_SEEKEQ flag, then this opcode will always land on a record that equally equals the key, or else jump immediately to P2. When the cursor is OPFLAG_SEEKEQ, this opcode must be followed by an &lt;a href=&quot;opcode#IdxGE&quot;&gt;IdxGE&lt;/a&gt; opcode with the same arguments. The &lt;a href=&quot;opcode#IdxGE&quot;&gt;IdxGE&lt;/a&gt; opcode will be skipped if this opcode succeeds, but the &lt;a href=&quot;opcode#IdxGE&quot;&gt;IdxGE&lt;/a&gt; opcode will be used on subsequent loop iterations.</source>
          <target state="translated">Если курсор P1 был открыт с использованием флага OPFLAG_SEEKEQ, то этот код операции всегда будет попадать на запись, которая в равной степени равна ключу, или же сразу перейти к P2. Когда курсор - OPFLAG_SEEKEQ, за этим кодом операции должен следовать код операции &lt;a href=&quot;opcode#IdxGE&quot;&gt;IdxGE&lt;/a&gt; с теми же аргументами. Код операции &lt;a href=&quot;opcode#IdxGE&quot;&gt;IdxGE&lt;/a&gt; будет пропущен, если этот код операции завершится успешно, но код операции &lt;a href=&quot;opcode#IdxGE&quot;&gt;IdxGE&lt;/a&gt; будет использоваться в последующих итерациях цикла.</target>
        </trans-unit>
        <trans-unit id="77bb6e8019c4e57a173df053565a659dee60ffeb" translate="yes" xml:space="preserve">
          <source>If the cursor P1 was opened using the OPFLAG_SEEKEQ flag, then this opcode will always land on a record that equally equals the key, or else jump immediately to P2. When the cursor is OPFLAG_SEEKEQ, this opcode must be followed by an &lt;a href=&quot;opcode#IdxLE&quot;&gt;IdxLE&lt;/a&gt; opcode with the same arguments. The &lt;a href=&quot;opcode#IdxLE&quot;&gt;IdxLE&lt;/a&gt; opcode will be skipped if this opcode succeeds, but the &lt;a href=&quot;opcode#IdxLE&quot;&gt;IdxLE&lt;/a&gt; opcode will be used on subsequent loop iterations.</source>
          <target state="translated">Если курсор P1 был открыт с использованием флага OPFLAG_SEEKEQ, то этот код операции всегда будет попадать на запись, которая в равной степени равна ключу, или же сразу перейти к P2. Когда курсор - OPFLAG_SEEKEQ, за этим кодом операции должен следовать код операции &lt;a href=&quot;opcode#IdxLE&quot;&gt;IdxLE&lt;/a&gt; с теми же аргументами. Код операции &lt;a href=&quot;opcode#IdxLE&quot;&gt;IdxLE&lt;/a&gt; будет пропущен, если этот код операции завершится успешно, но код операции &lt;a href=&quot;opcode#IdxLE&quot;&gt;IdxLE&lt;/a&gt; будет использоваться в последующих итерациях цикла.</target>
        </trans-unit>
        <trans-unit id="6654fbd1f580e1606c2cb7ef134e0a96bcfe4a7c" translate="yes" xml:space="preserve">
          <source>If the cursor P1 was opened using the OPFLAG_SEEKEQ flag, then this opcode will either land on a record that exactly matches the key, or else it will cause a jump to P2. When the cursor is OPFLAG_SEEKEQ, this opcode must be followed by an &lt;a href=&quot;opcode#IdxLE&quot;&gt;IdxLE&lt;/a&gt; opcode with the same arguments. The &lt;a href=&quot;opcode#IdxGE&quot;&gt;IdxGE&lt;/a&gt; opcode will be skipped if this opcode succeeds, but the &lt;a href=&quot;opcode#IdxGE&quot;&gt;IdxGE&lt;/a&gt; opcode will be used on subsequent loop iterations. The OPFLAG_SEEKEQ flags is a hint to the btree layer to say that this is an equality search.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5226a8f5df78028a70c1168477ceda8c9db8705" translate="yes" xml:space="preserve">
          <source>If the cursor P1 was opened using the OPFLAG_SEEKEQ flag, then this opcode will either land on a record that exactly matches the key, or else it will cause a jump to P2. When the cursor is OPFLAG_SEEKEQ, this opcode must be followed by an &lt;a href=&quot;opcode#IdxLE&quot;&gt;IdxLE&lt;/a&gt; opcode with the same arguments. The &lt;a href=&quot;opcode#IdxGT&quot;&gt;IdxGT&lt;/a&gt; opcode will be skipped if this opcode succeeds, but the &lt;a href=&quot;opcode#IdxGT&quot;&gt;IdxGT&lt;/a&gt; opcode will be used on subsequent loop iterations. The OPFLAG_SEEKEQ flags is a hint to the btree layer to say that this is an equality search.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c34174e24836739ad2de38f328a95e6bd8361fd" translate="yes" xml:space="preserve">
          <source>If the database connection is associated with unfinalized prepared statements or unfinished sqlite3_backup objects then sqlite3_close() will leave the database connection open and return &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY&lt;/a&gt;. If sqlite3_close_v2() is called with unfinalized prepared statements and/or unfinished sqlite3_backups, then the database connection becomes an unusable &quot;zombie&quot; which will automatically be deallocated when the last prepared statement is finalized or the last sqlite3_backup is finished. The sqlite3_close_v2() interface is intended for use with host languages that are garbage collected, and where the order in which destructors are called is arbitrary.</source>
          <target state="translated">Если соединение с базой данных связано с незавершенными подготовленными операторами или незавершенными объектами sqlite3_backup, тогда sqlite3_close () оставит соединение с базой данных открытым и вернет &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY&lt;/a&gt; . Если sqlite3_close_v2 () вызывается с незавершенными подготовленными операторами и / или незавершенными sqlite3_backups, то соединение с базой данных становится непригодным для использования &amp;laquo;зомби&amp;raquo;, которое автоматически освобождается, когда последний подготовленный оператор завершен или последний sqlite3_backup завершен. Интерфейс sqlite3_close_v2 () предназначен для использования с хост-языками, которые собирают мусор, и где порядок, в котором вызываются деструкторы, произвольный.</target>
        </trans-unit>
        <trans-unit id="6a86fbb2e17cc862733085ba2da83a55d59e3eb0" translate="yes" xml:space="preserve">
          <source>If the database connection is associated with unfinalized prepared statements or unfinished sqlite3_backup objects then sqlite3_close() will leave the database connection open and return &lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;. If sqlite3_close_v2() is called with unfinalized prepared statements and/or unfinished sqlite3_backups, then the database connection becomes an unusable &quot;zombie&quot; which will automatically be deallocated when the last prepared statement is finalized or the last sqlite3_backup is finished. The sqlite3_close_v2() interface is intended for use with host languages that are garbage collected, and where the order in which destructors are called is arbitrary.</source>
          <target state="translated">Если соединение с базой данных связано с незавершенными подготовленными операторами или незавершенными объектами sqlite3_backup, тогда sqlite3_close () оставит соединение с базой данных открытым и вернет &lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; . Если sqlite3_close_v2 () вызывается с незавершенными подготовленными операторами и / или незавершенными sqlite3_backups, то соединение с базой данных становится непригодным для использования &amp;laquo;зомби&amp;raquo;, которое автоматически освобождается, когда последний подготовленный оператор завершен или последний sqlite3_backup завершен. Интерфейс sqlite3_close_v2 () предназначен для использования с хост-языками, которые собирают мусор, и где порядок, в котором вызываются деструкторы, произвольный.</target>
        </trans-unit>
        <trans-unit id="fb1362fb98673ef522db1a6a32001f7f2b59540f" translate="yes" xml:space="preserve">
          <source>If the database connection is newly opened, make sure it has read the database schema by preparing then discarding some query against the database, or calling sqlite3_table_column_metadata(), ignoring any errors. This step is only necessary if the application desires to keep the database in WAL mode after the reset if it was in WAL mode before the reset.</source>
          <target state="translated">Если соединение с БД только что открыто,убедитесь,что оно прочитало схему БД,подготовив затем отбрасывающий какой-нибудь запрос к БД,или вызовите sqlite3_table_column_metadata(),проигнорировав все ошибки.Этот шаг необходим только в том случае,если приложение после сброса хочет сохранить базу данных в режиме WAL,если до сброса она была в режиме WAL.</target>
        </trans-unit>
        <trans-unit id="1e3e236bab50bdd2cf247016c21c0818a0ad15df" translate="yes" xml:space="preserve">
          <source>If the database file has aliases (hard or soft links) and the file is opened by a different alias than the one used to create the journal, then the journal will not be found. To avoid this problem, you should not create links to SQLite database files.</source>
          <target state="translated">Если в файле базы данных есть псевдонимы (жесткие или мягкие ссылки)и файл открывается под другим псевдонимом,отличным от псевдонима,который использовался при создании журнала,то журнал не будет найден.Чтобы избежать этой проблемы,не следует создавать ссылки на файлы базы данных SQLite.</target>
        </trans-unit>
        <trans-unit id="b5462897225632e86adf2dda0274ca8b010e12de" translate="yes" xml:space="preserve">
          <source>If the database schema changes, instead of returning &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_SCHEMA&lt;/a&gt; as it always used to do, &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; will automatically recompile the SQL statement and try to run it again. As many as &lt;a href=&quot;compile#max_schema_retry&quot;&gt;SQLITE_MAX_SCHEMA_RETRY&lt;/a&gt; retries will occur before sqlite3_step() gives up and returns an error.</source>
          <target state="translated">Если схема базы данных изменяется, вместо того, чтобы возвращать &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_SCHEMA,&lt;/a&gt; как всегда, &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step ()&lt;/a&gt; автоматически перекомпилирует оператор SQL и попытается запустить его снова. Целых &lt;a href=&quot;compile#max_schema_retry&quot;&gt;SQLITE_MAX_SCHEMA_RETRY&lt;/a&gt; повторы будут происходить до sqlite3_step () дает и возвращает ошибку.</target>
        </trans-unit>
        <trans-unit id="589bc4cd8d0a621a42dc8c997193ae6380bd4790" translate="yes" xml:space="preserve">
          <source>If the database schema changes, instead of returning &lt;a href=&quot;../rescode#schema&quot;&gt;SQLITE_SCHEMA&lt;/a&gt; as it always used to do, &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; will automatically recompile the SQL statement and try to run it again. As many as &lt;a href=&quot;../compile#max_schema_retry&quot;&gt;SQLITE_MAX_SCHEMA_RETRY&lt;/a&gt; retries will occur before sqlite3_step() gives up and returns an error.</source>
          <target state="translated">Если схема базы данных изменяется, вместо того, чтобы возвращать &lt;a href=&quot;../rescode#schema&quot;&gt;SQLITE_SCHEMA,&lt;/a&gt; как всегда, &lt;a href=&quot;step&quot;&gt;sqlite3_step ()&lt;/a&gt; автоматически перекомпилирует оператор SQL и попытается запустить его снова. Целых &lt;a href=&quot;../compile#max_schema_retry&quot;&gt;SQLITE_MAX_SCHEMA_RETRY&lt;/a&gt; повторы будут происходить до sqlite3_step () дает и возвращает ошибку.</target>
        </trans-unit>
        <trans-unit id="66c44f3be0c0d8ad85eed52612c2f2c579f73474" translate="yes" xml:space="preserve">
          <source>If the database schema contains foreign key errors that require looking at more than one table definition to identify, then those errors are not detected when the tables are created. Instead, such errors prevent the application from preparing SQL statements that modify the content of the child or parent tables in ways that use the foreign keys. Errors reported when content is changed are &quot;DML errors&quot; and errors reported when the schema is changed are &quot;DDL errors&quot;. So, in other words, misconfigured foreign key constraints that require looking at both the child and parent are DML errors. The English language error message for foreign key DML errors is usually &quot;foreign key mismatch&quot; but can also be &quot;no such table&quot; if the parent table does not exist. Foreign key DML errors are reported if:</source>
          <target state="translated">Если схема БД содержит ошибки с посторонними ключами,для идентификации которых требуется просмотреть более одного определения таблиц,то при создании таблиц эти ошибки не обнаруживаются.Вместо этого такие ошибки не позволяют приложению подготовить SQL-запросы,которые изменяют содержимое дочерних или родительских таблиц таким образом,что в них используются посторонние ключи.Ошибки,сообщаемые при изменении содержимого,являются &quot;DML-ошибками&quot;,а ошибки,сообщаемые при изменении схемы,являются &quot;DDL-ошибками&quot;.Другими словами,неправильно настроенные ограничения по внешним ключам,требующие рассмотрения как дочерних,так и родительских таблиц,являются ошибками DML.Англоязычное сообщение об ошибках DML с иностранными ключами обычно является &quot;несоответствием иностранного ключа&quot;,но может быть и &quot;нет такой таблицы&quot;,если родительская таблица не существует.Ошибки DML иностранного ключа сообщаются,если:</target>
        </trans-unit>
        <trans-unit id="8302ec0e25c3b92c0aa14eef9d1503f836a94585" translate="yes" xml:space="preserve">
          <source>If the declared type contains the string &quot;INT&quot; then it is assigned INTEGER affinity.</source>
          <target state="translated">Если объявленный тип содержит строку &quot;INT&quot;,то ему присваивается сродство INTEGER.</target>
        </trans-unit>
        <trans-unit id="9bb6b49e698e48cc0bb2b3442b91fd7f7d66dd5e" translate="yes" xml:space="preserve">
          <source>If the declared type for a column contains any of the strings &quot;REAL&quot;, &quot;FLOA&quot;, or &quot;DOUB&quot; then the column has REAL affinity.</source>
          <target state="translated">Если объявленный тип столбца содержит какую-либо из строк &quot;REAL&quot;,&quot;FLOA&quot; или &quot;DOUB&quot;,то столбец имеет РЕАЛЬНОЕ сродство.</target>
        </trans-unit>
        <trans-unit id="f28b903cf6eed2606240e84c579a7053774d3dee" translate="yes" xml:space="preserve">
          <source>If the declared type for a column contains the string &quot;BLOB&quot; or if no type is specified then the column has affinity BLOB.</source>
          <target state="translated">Если объявленный тип для столбца содержит строку &quot;BLOB&quot; или если тип не указан,то столбец имеет сродство BLOB.</target>
        </trans-unit>
        <trans-unit id="ee88c791daf6e99faa6560e540692aa5bc2c800f" translate="yes" xml:space="preserve">
          <source>If the declared type of the column contains any of the strings &quot;CHAR&quot;, &quot;CLOB&quot;, or &quot;TEXT&quot; then that column has TEXT affinity. Notice that the type VARCHAR contains the string &quot;CHAR&quot; and is thus assigned TEXT affinity.</source>
          <target state="translated">Если объявленный тип столбца содержит какую-либо из строк &quot;CHAR&quot;,&quot;CLOB&quot; или &quot;TEXT&quot;,то этот столбец имеет сродство к TEXT.Обратите внимание,что тип VARCHAR содержит строку &quot;CHAR&quot; и поэтому имеет сродство к TEXT.</target>
        </trans-unit>
        <trans-unit id="de0d2c280ce73b7cd6a79e09cb8d9ab5ce1c8380" translate="yes" xml:space="preserve">
          <source>If the default entry point &quot;sqlite3_extension_init&quot; is not present in the loadable extension, also try an entry point &quot;sqlite3_X_init&quot; where &quot;X&quot; is based on the shared library filename. This allows every extension to have a different entry point, which allows them to be statically linked with no code changes.</source>
          <target state="translated">Если в загружаемом расширении нет точки входа по умолчанию &quot;sqlite3_extension_init&quot;,попробуйте также точку входа &quot;sqlite3_X_init&quot;,где &quot;X&quot; основывается на имени файла общей библиотеки.Это позволяет каждому расширению иметь свою точку входа,что позволяет статически связывать их без изменения кода.</target>
        </trans-unit>
        <trans-unit id="2f1570bf7cd89b0efb998b886e0a28b989f79bba" translate="yes" xml:space="preserve">
          <source>If the default value of a column is CURRENT_TIME, CURRENT_DATE or CURRENT_TIMESTAMP, then the value used in the new row is a text representation of the current UTC date and/or time. For CURRENT_TIME, the format of the value is &quot;HH:MM:SS&quot;. For CURRENT_DATE, &quot;YYYY-MM-DD&quot;. The format for CURRENT_TIMESTAMP is &quot;YYYY-MM-DD HH:MM:SS&quot;.</source>
          <target state="translated">Если значением столбца по умолчанию является CURRENT_TIME,CURRENT_DATE или CURRENT_TIMESTAMP,то значение,используемое в новой строке,является текстовым представлением текущей UTC даты и/или времени.Для столбца CURRENT_TIME формат значения &quot;HH:MM:SS&quot;.Для CURRENT_DATE,&quot;YYYY-MM-DD&quot;.Формат для CURRENT_TIMESTAMP &quot;ГГГГ-ММ-ДД ЧЧ:ММ:СС&quot;.</target>
        </trans-unit>
        <trans-unit id="763669d7f38746d95d771edeb8a196a32d9d9e41" translate="yes" xml:space="preserve">
          <source>If the default value of a column is an expression in parentheses, then the expression is evaluated once for each row inserted and the results used in the new row.</source>
          <target state="translated">Если значение столбца по умолчанию является выражением в круглых скобках,то это выражение оценивается один раз для каждой вставленной строки и результатов,используемых в новой строке.</target>
        </trans-unit>
        <trans-unit id="f9fe1ed106b11da1d5f4cf451a970a2b10eba0b4" translate="yes" xml:space="preserve">
          <source>If the default value of the column is a constant NULL, text, blob or signed-number value, then that value is used directly in the new row.</source>
          <target state="translated">Если значение столбца по умолчанию является константным NULL,текстовым,блочным или знаковым,то это значение используется непосредственно в новой строке.</target>
        </trans-unit>
        <trans-unit id="6072ed5efdb78dd0e13242a8b605916b880d7376" translate="yes" xml:space="preserve">
          <source>If the detail option is set to &lt;b&gt;column&lt;/b&gt;, then for each term the FTS index records the rowid and column number only, omitting the term offset information. This results in the following restrictions:</source>
          <target state="translated">Если параметр детализации установлен на &lt;b&gt;столбец&lt;/b&gt; , то для каждого термина индекс FTS записывает только идентификатор строки и номер столбца, опуская информацию о смещении термина. Это приводит к следующим ограничениям:</target>
        </trans-unit>
        <trans-unit id="e6f14be9765a087a59fad069383360a3c524d64a" translate="yes" xml:space="preserve">
          <source>If the detail option is set to &lt;b&gt;none&lt;/b&gt;, then for each term the FTS index records just the rowid is stored. Both column and offset information are omitted. As well as the restrictions itemized above for detail=column mode, this imposes the following extra limitations:</source>
          <target state="translated">Если для параметра детализации установлено значение &amp;laquo; &lt;b&gt;Нет&amp;raquo;&lt;/b&gt; , то для каждого термина в индексе FTS сохраняется только идентификатор строки. Информация о столбцах и смещении опускается. Помимо ограничений, перечисленных выше для режима detail = column, это накладывает следующие дополнительные ограничения:</target>
        </trans-unit>
        <trans-unit id="c0b004cd1f197d0bb3d8b70f7d3071c3e7d65b08" translate="yes" xml:space="preserve">
          <source>If the file-size is not zero bytes and the page cache does not contain valid data for the first page of the database, then the data for the first page must be read from the database.</source>
          <target state="translated">Если размер файла не нулевой байт и кэш страниц не содержит достоверных данных для первой страницы базы данных,то данные для первой страницы должны быть прочитаны из базы данных.</target>
        </trans-unit>
        <trans-unit id="7d40fd66a8466c922e947b1b7af920a75a0b5408" translate="yes" xml:space="preserve">
          <source>If the filename argument to the shell is a ZIP archive rather than an SQLite database, then the shell automatically opens that ZIP archive using the &lt;a href=&quot;zipfile&quot;&gt;Zipfile virtual table&lt;/a&gt;.</source>
          <target state="translated">Если аргументом имени файла для оболочки является ZIP-архив, а не база данных SQLite, то оболочка автоматически открывает этот ZIP-архив с &lt;a href=&quot;zipfile&quot;&gt;помощью виртуальной таблицы Zipfile&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ae3dbad88e43cb04cd5afd00c461d318a7360e00" translate="yes" xml:space="preserve">
          <source>If the filename is &quot;:memory:&quot;, then a private, temporary in-memory database is created for the connection. This in-memory database will vanish when the database connection is closed. Future versions of SQLite might make use of additional special filenames that begin with the &quot;:&quot; character. It is recommended that when a database filename actually does begin with a &quot;:&quot; character you should prefix the filename with a pathname such as &quot;./&quot; to avoid ambiguity.</source>
          <target state="translated">Если имя файла &quot;:memory:&quot;,то для соединения создается личная,временная БД в памяти.Эта БД внутренней памяти исчезнет,когда соединение с БД будет закрыто.В будущих версиях SQLite могут использоваться дополнительные специальные имена файлов,начинающиеся со знака &quot;:&quot;.Рекомендуется,чтобы в случае,когда имя файла БД действительно начинается со знака &quot;:&quot;,во избежание двусмысленности,имя файла должно начинаться со знака &quot;./&quot;.</target>
        </trans-unit>
        <trans-unit id="62f7e60cb107b276af1d9e468c997800e50e0c47" translate="yes" xml:space="preserve">
          <source>If the filename is an empty string, then a private, temporary on-disk database will be created. This private database will be automatically deleted as soon as the database connection is closed.</source>
          <target state="translated">Если имя файла-пустая строка,то будет создана приватная,временная база данных на диске.Эта приватная БД будет автоматически удалена,как только будет закрыто соединение с БД.</target>
        </trans-unit>
        <trans-unit id="e090a4024fb7e0384c6590b18fdaa1dae521998f" translate="yes" xml:space="preserve">
          <source>If the filename pointer returned by this routine is not NULL, then it can be used as the filename input parameter to these routines:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32dd493cb01796f1b19bb91ce938cad16395b6df" translate="yes" xml:space="preserve">
          <source>If the final parameter to sqlite3_create_function_v2() or sqlite3_create_window_function() is not NULL, then it is destructor for the application data pointer. The destructor is invoked when the function is deleted, either by being overloaded or when the database connection closes. The destructor is also invoked if the call to sqlite3_create_function_v2() fails. When the destructor callback is invoked, it is passed a single argument which is a copy of the application data pointer which was the fifth parameter to sqlite3_create_function_v2().</source>
          <target state="translated">Если конечный параметр sqlite3_create_function_v2()или sqlite3_create_window_function()не NULL,то он является деструктором для указателя на данные приложения.Деструктор вызывается при удалении функции,либо при перегрузке,либо при закрытии соединения с БД.Деструктор вызывается также при неудачном вызове sqlite3_create_function_v2().При вызове деструктора ему передается единственный аргумент-копия указателя на данные приложения,который был пятым параметром sqlite3_create_function_v2().</target>
        </trans-unit>
        <trans-unit id="a0307f53fcf484b466b65b063fa221cd6f594f91" translate="yes" xml:space="preserve">
          <source>If the first character of the &quot;.output&quot; or &quot;.once&quot; filename is a pipe symbol (&quot;|&quot;) then the remaining characters are treated as a command and the output is sent to that command. This makes it easy to pipe the results of a query into some other process. For example, the &quot;open -f&quot; command on a Mac opens a text editor to display the content that it reads from standard input. So to see the results of a query in a text editor, one could type:</source>
          <target state="translated">Если первый символ имени файла &quot;.output&quot; или &quot;.once&quot; является символом трубы (&quot;|&quot;),то остальные символы рассматриваются как команда,и выходные данные отправляются в эту команду.Это облегчает передачу результатов запроса в какой-то другой процесс.Например,команда &quot;open -f&quot; на Mac открывает текстовый редактор для отображения содержимого,которое он читает со стандартного входа.Таким образом,чтобы увидеть результаты запроса в текстовом редакторе,можно набирать текст:</target>
        </trans-unit>
        <trans-unit id="f6248b44ea5d1fc55c81c80463d285a1931abd4d" translate="yes" xml:space="preserve">
          <source>If the flags parameter is non-zero, then the BLOB is opened for read and write access. If the flags parameter is zero, the BLOB is opened for read-only access.</source>
          <target state="translated">Если параметр флагов ненулевой,то BLOB открывается для доступа на чтение и запись.Если параметр флагов равен нулю,то BLOB открывается для доступа только на чтение.</target>
        </trans-unit>
        <trans-unit id="42e53a5898ca221d8e5453208404df16340c520e" translate="yes" xml:space="preserve">
          <source>If the frame type is RANGE or GROUPS, then rows with the same values for all ORDER BY expressions are considered &quot;peers&quot;. Or, if there are no ORDER BY terms, all rows are peers. Peers are always within the same frame.</source>
          <target state="translated">Если тип кадра-RANGE или GROUPS,то строки с одинаковыми значениями для всех выражений ORDER BY считаются &quot;ровными&quot;.Или,если нет терминов ORDER BY,все строки считаются одноранговыми.Пэры всегда находятся в одном и том же кадре.</target>
        </trans-unit>
        <trans-unit id="4aa0a21905f32bbcafa3289b7a629a809ef523ab" translate="yes" xml:space="preserve">
          <source>If the full-text index is consistent with the contents of the table, the INSERT used to invoke the integrity-check command succeeds. Or, if any discrepancy is found, it fails with an &lt;a href=&quot;rescode#corrupt_vtab&quot;&gt;SQLITE_CORRUPT_VTAB&lt;/a&gt; error.</source>
          <target state="translated">Если полнотекстовый индекс соответствует содержимому таблицы, INSERT, используемый для вызова команды проверки целостности, завершается успешно. Или, если обнаруживается какое-либо несоответствие, он завершается ошибкой &lt;a href=&quot;rescode#corrupt_vtab&quot;&gt;SQLITE_CORRUPT_VTAB&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f22af0b11cea33d685991d206d7069a56eda1b2e" translate="yes" xml:space="preserve">
          <source>If the function is registered using the sqlite3_collation_needed() API, then it is passed the names of undefined collation sequences as strings encoded in UTF-8. If sqlite3_collation_needed16() is used, the names are passed as UTF-16 in machine native byte order. A call to either function replaces the existing collation-needed callback.</source>
          <target state="translated">Если функция регистрируется с помощью sqlite3_collation_need()API,то ей передаются имена неопределенных последовательностей сравнения в виде строк в кодировке UTF-8.Если используется sqlite3_collation_need16(),то имена передаются в формате UTF-16 в машинном родном порядке байт.Вызов любой из функций заменяет существующий обратный вызов,связанный с необходимостью сверки.</target>
        </trans-unit>
        <trans-unit id="6a62bcf0e73dbd9b64d823a84e324e7b03ef33b0" translate="yes" xml:space="preserve">
          <source>If the hard upper bound on mmap_size is non-zero at compilation time, it may still be reduced or zeroed at start-time using the &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmmapsize&quot;&gt;SQLITE_CONFIG_MMAP_SIZE&lt;/a&gt;,X,Y) interface. The X and Y parameters must both be 64-bit signed integers. The X parameter is the default mmap_size of the process and the Y is the new hard upper bound. The hard upper bound cannot be increased above its compile-time setting using &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmmapsize&quot;&gt;SQLITE_CONFIG_MMAP_SIZE&lt;/a&gt; but it can be reduced or zeroed.</source>
          <target state="translated">Если жесткая верхняя граница mmap_size не равна нулю во время компиляции, она все равно может быть уменьшена или обнулена во время запуска с помощью интерфейса &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt; ( &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmmapsize&quot;&gt;SQLITE_CONFIG_MMAP_SIZE&lt;/a&gt; , X, Y). Параметры X и Y должны быть 64-битными целыми числами со знаком. Параметр X - это размер mmap_size по умолчанию для процесса, а Y - новая жесткая верхняя граница. Жесткая верхняя граница не может быть увеличена выше ее настройки времени компиляции с помощью &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmmapsize&quot;&gt;SQLITE_CONFIG_MMAP_SIZE,&lt;/a&gt; но ее можно уменьшить или обнулить.</target>
        </trans-unit>
        <trans-unit id="7e3c788b80a3fc760cf36b37df86e977c5bf4e82" translate="yes" xml:space="preserve">
          <source>If the initial value of register P1 is less than 1, then the value is unchanged and control passes through to the next instruction.</source>
          <target state="translated">Если начальное значение регистра P1 меньше 1,то значение остается неизменным и управление переходит к следующей команде.</target>
        </trans-unit>
        <trans-unit id="c6c2836bf573a577c3b9e85be740fd6180f2bc75" translate="yes" xml:space="preserve">
          <source>If the insert operation would cause the uniqueness constraint identified by the conflict-target clause to fail, then the insert is omitted and either the DO NOTHING or DO UPDATE operation is performed instead. In the case of a multi-row insert, this decision is made separately for each row of the insert.</source>
          <target state="translated">Если операция вставки приведет к неудаче ограничения уникальности,идентифицируемого конфликтным пунктом,то вставка опускается,и вместо нее выполняется либо операция DO NOTHING,либо операция DO UPDATE.В случае многорядной вставки это решение принимается отдельно для каждой строки вставки.</target>
        </trans-unit>
        <trans-unit id="94f24cffd74c8aa91288ff50b98f2890c0c1dd37" translate="yes" xml:space="preserve">
          <source>If the integrity_check pragma finds problems, strings are returned (as multiple rows with a single column per row) which describe the problems. Pragma integrity_check will return at most</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5cd79e7c31e9806cd77deff0cb0e96d9ab910562" translate="yes" xml:space="preserve">
          <source>If the iterator points to a valid DELETE or UPDATE entry, the &lt;a href=&quot;session/sqlite3changeset_old&quot;&gt;sqlite3changeset_old()&lt;/a&gt; API may be used to obtain the old.* values within the change payload.</source>
          <target state="translated">Если итератор указывает на допустимую запись DELETE или UPDATE, API &lt;a href=&quot;session/sqlite3changeset_old&quot;&gt;sqlite3changeset_old ()&lt;/a&gt; может использоваться для получения старых значений. * В полезных данных изменения.</target>
        </trans-unit>
        <trans-unit id="b3c7141c41f848703cade5e408485ed848edf925" translate="yes" xml:space="preserve">
          <source>If the iterator points to a valid INSERT or UPDATE entry, the &lt;a href=&quot;session/sqlite3changeset_new&quot;&gt;sqlite3changeset_new()&lt;/a&gt; API may be used to obtain the new.* values within the change payload.</source>
          <target state="translated">Если итератор указывает на допустимую запись INSERT или UPDATE, API &lt;a href=&quot;session/sqlite3changeset_new&quot;&gt;sqlite3changeset_new ()&lt;/a&gt; может использоваться для получения новых значений. * В полезных данных изменения.</target>
        </trans-unit>
        <trans-unit id="27b2873f49d5b86c6645b602757d6284a617e429" translate="yes" xml:space="preserve">
          <source>If the iterator points to a valid entry, the &lt;a href=&quot;session/sqlite3changeset_op&quot;&gt;sqlite3changeset_op()&lt;/a&gt; API may be used to determine the type of change (INSERT, UPDATE or DELETE) that the iterator points to. Additionally, the same API can be used to obtain the name of the table the change applies to and its expected number of columns and primary key columns.</source>
          <target state="translated">Если итератор указывает на допустимую запись, API &lt;a href=&quot;session/sqlite3changeset_op&quot;&gt;sqlite3changeset_op ()&lt;/a&gt; может использоваться для определения типа изменения (INSERT, UPDATE или DELETE), на которое указывает итератор. Кроме того, тот же API можно использовать для получения имени таблицы, к которой применяется изменение, и ожидаемого количества столбцов и столбцов первичного ключа.</target>
        </trans-unit>
        <trans-unit id="b7875cd04c26b022cfa813504a6e1447dc659fda" translate="yes" xml:space="preserve">
          <source>If the join between the target table and the FROM clause results in multiple output rows for the same target table row, then only one of those output rows is used for updating the target table. The output row selected is arbitrary and might change from one release of SQLite to the next, or from one run to the next.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e43f90e3097e7ba0e1ecf1e86b3e41e586eb695" translate="yes" xml:space="preserve">
          <source>If the join-operator is &quot;CROSS JOIN&quot;, &quot;INNER JOIN&quot;, &quot;JOIN&quot; or a comma (&quot;,&quot;) and there is no ON or USING clause, then the result of the join is simply the cartesian product of the left and right-hand datasets. If join-operator does have ON or USING clauses, those are handled according to the following bullet points:</source>
          <target state="translated">Если оператор соединения-&quot;CROSS JOIN&quot;,&quot;INNER JOIN&quot;,&quot;JOIN&quot; или запятая (&quot;,&quot;)и нет пункта ON или USING,то результатом соединения является просто картезианное произведение левого и правого наборов данных.Если оператор соединения имеет пункты ВКЛ.или ИСПОЛЬЗОВАНИЕ,то они обрабатываются в соответствии со следующими пунктами:</target>
        </trans-unit>
        <trans-unit id="e1fb18a5273cd27a264734974f9f02d1710aa767" translate="yes" xml:space="preserve">
          <source>If the join-operator is a &quot;LEFT JOIN&quot; or &quot;LEFT OUTER JOIN&quot;, then after the ON or USING filtering clauses have been applied, an extra row is added to the output for each row in the original left-hand input dataset that corresponds to no rows at all in the composite dataset (if any). The added rows contain NULL values in the columns that would normally contain values copied from the right-hand input dataset.</source>
          <target state="translated">Если объединенный оператор-это &quot;ЛЕВОЕ СОЕДИНЕНИЕ&quot; или &quot;ВЛЕВОЕ СОЕДИНЕНИЕ&quot;,то после применения положений фильтрации ON или USING к выводу добавляется дополнительная строка для каждой строки в исходном левом входном наборе данных,которая вообще не соответствует ни одной строке в составном наборе данных (если таковой имеется).Добавленные строки содержат NULL-значения в столбцах,которые обычно содержат значения,скопированные из правого входного набора данных.</target>
        </trans-unit>
        <trans-unit id="76658faf4e1e99248322d20ab1af06451a7269ae" translate="yes" xml:space="preserve">
          <source>If the json_remove(X) function is called with no path arguments, then it returns the input X reformatted, with excess whitespace removed.</source>
          <target state="translated">Если функция json_remove(X)вызывается без аргументов пути,то она возвращает вход X в переформатированном виде,с удалением лишних пробелов.</target>
        </trans-unit>
        <trans-unit id="b094bdd6dfc46d4028fcd23aee2c781ab15d0c15" translate="yes" xml:space="preserve">
          <source>If the last client using the database shuts down cleanly by calling &lt;a href=&quot;c3ref/close&quot;&gt;sqlite3_close()&lt;/a&gt;, then a &lt;a href=&quot;wal#ckpt&quot;&gt;checkpoint&lt;/a&gt; is run automatically in order to transfer all information from the wal file over into the main database, and both the shm file and the wal file are unlinked. Thus, when the database is not in use by any client, it is usually the case that only the main database file exists on disk. However, if the last client did not call &lt;a href=&quot;c3ref/close&quot;&gt;sqlite3_close()&lt;/a&gt; before it shut down, or if the last client to disconnect was a read-only client, then the final cleanup operation does not occur and the shm and wal files may still exist on disk even when the database is not in use.</source>
          <target state="translated">Если последний клиент, использующий базу данных, завершает работу без ошибок, вызывая &lt;a href=&quot;c3ref/close&quot;&gt;sqlite3_close ()&lt;/a&gt; , то автоматически запускается &lt;a href=&quot;wal#ckpt&quot;&gt;контрольная точка&lt;/a&gt; , чтобы передать всю информацию из файла wal в основную базу данных, при этом файлы shm и wal не связаны. Таким образом, когда база данных не используется ни одним клиентом, обычно на диске существует только основной файл базы данных. Однако, если последний клиент не вызвал &lt;a href=&quot;c3ref/close&quot;&gt;sqlite3_close ()&lt;/a&gt; перед завершением работы или если последний отключившийся клиент был клиентом только для чтения, то окончательная операция очистки не выполняется, и файлы shm и wal могут все еще существовать на диске. даже если база данных не используется.</target>
        </trans-unit>
        <trans-unit id="4f7a9d6c2807cb225b7b7ab46b05552f481cc42e" translate="yes" xml:space="preserve">
          <source>If the last connection to a database crashed, then the first new connection to open the database will start a recovery process. An exclusive lock is held during recovery. So if a third database connection tries to jump in and query while the second connection is running recovery, the third connection will get an &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; error.</source>
          <target state="translated">Если последнее соединение с базой данных разорвалось, то при первом новом соединении для открытия базы данных будет запущен процесс восстановления. Во время восстановления удерживается эксклюзивная блокировка. Таким образом, если третье соединение с базой данных попытается подключиться и запросить, пока второе соединение выполняет восстановление, третье соединение получит ошибку &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="37b7298e57bd67e9cd0305c3baee9cc81b8dbc9d" translate="yes" xml:space="preserve">
          <source>If the lastname and firstname on the bottom row of the previous screen are bound to ?1 and ?2, then the query above computes the next 7 rows. And, assuming there is an appropriate index, it does so very efficiently &amp;mdash; much more efficiently than OFFSET.</source>
          <target state="translated">Если фамилия и имя в нижней строке предыдущего экрана привязаны к? 1 и? 2, то приведенный выше запрос вычисляет следующие 7 строк. И, если есть соответствующий индекс, он делает это очень эффективно - намного эффективнее, чем OFFSET.</target>
        </trans-unit>
        <trans-unit id="4e01c1ab95f2a00094ec0341f6411fa5bdba3e3d" translate="yes" xml:space="preserve">
          <source>If the library is not configured for UTF-8 and the Tcl library is one of the newer ones that uses UTF-8 internally, then a conversion from UTF-8 to iso8859 and back again is done inside the TCL interface.</source>
          <target state="translated">Если библиотека не настроена на UTF-8,а библиотека Tcl является одной из новых,использующих UTF-8 внутри,то внутри TCL-интерфейса выполняется преобразование из UTF-8 в iso8859 и обратно.</target>
        </trans-unit>
        <trans-unit id="e9f32c50cc50b5c20674f65e05651f4083f0b21f" translate="yes" xml:space="preserve">
          <source>If the locking mode is EXCLUSIVE when first entering &lt;a href=&quot;wal&quot;&gt;WAL journal mode&lt;/a&gt;, then the locking mode cannot be changed to NORMAL until after exiting WAL journal mode. If the locking mode is NORMAL when first entering WAL journal mode, then the locking mode can be changed between NORMAL and EXCLUSIVE and back again at any time and without needing to exit WAL journal mode.</source>
          <target state="translated">Если режим блокировки ИСКЛЮЧИТЕЛЬНЫЙ при первом входе в &lt;a href=&quot;wal&quot;&gt;режим журнала WAL&lt;/a&gt; , то режим блокировки не может быть изменен на НОРМАЛЬНЫЙ до выхода из режима журнала WAL. Если режим блокировки - НОРМАЛЬНЫЙ при первом входе в режим журнала WAL, то режим блокировки можно изменить с НОРМАЛЬНЫЙ на ИСКЛЮЧИТЕЛЬНЫЙ и обратно в любое время и без необходимости выхода из режима журнала WAL.</target>
        </trans-unit>
        <trans-unit id="4d5f5f76a7fce4a19ed7250628145b10beef7a78" translate="yes" xml:space="preserve">
          <source>If the matchable phrase in the FTS query is restricted to matching data in a specified FTS table column, then only phrase matches that occur within that column are considered.</source>
          <target state="translated">Если совпадающая фраза в запросе FTS ограничивается совпадающими данными в указанном столбце таблицы FTS,то учитываются только совпадающие фразы,встречающиеся внутри этого столбца.</target>
        </trans-unit>
        <trans-unit id="e74ad1dee292520ae801328610398f65c1bd2944" translate="yes" xml:space="preserve">
          <source>If the memory allocation subsystems within SQLite are configured for breakdown-free operation but the actual memory usage exceeds design limits set by the &lt;a href=&quot;malloc#nofrag&quot;&gt;Robson proof&lt;/a&gt;, SQLite will usually continue to operate normally. The &lt;a href=&quot;malloc#pagecache&quot;&gt;pagecache memory allocator&lt;/a&gt; and the &lt;a href=&quot;malloc#lookaside&quot;&gt;lookaside memory allocator&lt;/a&gt; automatically failover to the &lt;a href=&quot;malloc#memsys5&quot;&gt;memsys5&lt;/a&gt; general-purpose memory allocator. And it is usually the case that the &lt;a href=&quot;malloc#memsys5&quot;&gt;memsys5&lt;/a&gt; memory allocator will continue to function without fragmentation even if &lt;b&gt;M&lt;/b&gt; and/or &lt;b&gt;n&lt;/b&gt; exceeds the limits imposed by the &lt;a href=&quot;malloc#nofrag&quot;&gt;Robson proof&lt;/a&gt;. The &lt;a href=&quot;malloc#nofrag&quot;&gt;Robson proof&lt;/a&gt; shows that it is possible for a memory allocation to break down and fail in this circumstance, but such a failure requires an especially despicable sequence of allocations and deallocations - a sequence that SQLite has never been observed to follow. So in practice it is usually the case that the limits imposed by Robson can be exceeded by a considerable margin with no ill effect.</source>
          <target state="translated">Если подсистемы распределения памяти в SQLite настроены на бесперебойную работу, но фактическое использование памяти превышает проектные ограничения, установленные &lt;a href=&quot;malloc#nofrag&quot;&gt;доказательством Робсона&lt;/a&gt; , SQLite обычно продолжит работать в обычном режиме. &lt;a href=&quot;malloc#pagecache&quot;&gt;Распределитель кэша страниц памяти&lt;/a&gt; и &lt;a href=&quot;malloc#lookaside&quot;&gt;распределение памяти Lookaside&lt;/a&gt; автоматически переключения на &lt;a href=&quot;malloc#memsys5&quot;&gt;memsys5&lt;/a&gt; общего назначение распределителя памяти. И обычно бывает, что &lt;a href=&quot;malloc#memsys5&quot;&gt;распределитель&lt;/a&gt; памяти memsys5 будет продолжать работать без фрагментации, даже если &lt;b&gt;M&lt;/b&gt; и / или &lt;b&gt;n&lt;/b&gt; превышают ограничения, налагаемые &lt;a href=&quot;malloc#nofrag&quot;&gt;доказательством Робсона&lt;/a&gt; . &lt;a href=&quot;malloc#nofrag&quot;&gt;Robson доказательство&lt;/a&gt;показывает, что в этом случае возможен сбой при выделении памяти, но такой сбой требует особенно презренной последовательности выделения и освобождения памяти - последовательности, которой SQLite никогда не наблюдал. Таким образом, на практике обычно бывает так, что ограничения, налагаемые Робсоном, могут быть превышены со значительным запасом без каких-либо негативных последствий.</target>
        </trans-unit>
        <trans-unit id="ccc13fed0f9a7a53b6beaefda251b5fe55a5b377" translate="yes" xml:space="preserve">
          <source>If the missing function returns an error, then the database is not opened and the error returned to the user. If an openclose function is configured, then a &quot;close&quot; invocation is issued at this point to match the earlier &quot;open&quot;. The following pseudo-code illustrates the procedure used by a swarmvtab instance with both missing and openclose functions configured when a component database is opened.</source>
          <target state="translated">Если отсутствующая функция возвращает ошибку,то база данных не открывается,а ошибка возвращается пользователю.Если сконфигурирована функция openclose,то в этот момент выдается запрос на &quot;закрытие&quot;,совпадающий с более ранним &quot;открытым&quot;.Следующий псевдокод иллюстрирует процедуру,используемую экземпляром swarmvtab,в котором при открытии компонентной базы данных настроены как отсутствующие,так и открытые функции.</target>
        </trans-unit>
        <trans-unit id="da30913cd33d5b91e0a650b018579fde9dd09c23" translate="yes" xml:space="preserve">
          <source>If the most recent call to &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step(S)&lt;/a&gt; for the &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; S indicated an error, then &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset(S)&lt;/a&gt; returns an appropriate &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt;.</source>
          <target state="translated">Если последний вызов &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step (S)&lt;/a&gt; для &lt;a href=&quot;#sqlite3_stmt&quot;&gt;подготовленного оператора&lt;/a&gt; S указал на ошибку, то &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset (S)&lt;/a&gt; вернет соответствующий &lt;a href=&quot;rescode&quot;&gt;код ошибки&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="40013c6ef594b13a3f8340842450df9d33bd6702" translate="yes" xml:space="preserve">
          <source>If the most recent call to &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step(S)&lt;/a&gt; for the &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; S returned &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ROW&lt;/a&gt; or &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_DONE&lt;/a&gt;, or if &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step(S)&lt;/a&gt; has never before been called on S, then &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset(S)&lt;/a&gt; returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt;.</source>
          <target state="translated">Если последний вызов &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step (S)&lt;/a&gt; для &lt;a href=&quot;#sqlite3_stmt&quot;&gt;подготовленного оператора&lt;/a&gt; S вернул &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ROW&lt;/a&gt; или &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_DONE&lt;/a&gt; , или если &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step (S)&lt;/a&gt; никогда ранее не вызывался на S, то &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset (S)&lt;/a&gt; возвращает &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0cc58a427f7c8746f7e6e3f5425c1b7c73b16876" translate="yes" xml:space="preserve">
          <source>If the most recent call to &lt;a href=&quot;step&quot;&gt;sqlite3_step(S)&lt;/a&gt; for the &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; S indicated an error, then &lt;a href=&quot;reset&quot;&gt;sqlite3_reset(S)&lt;/a&gt; returns an appropriate &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt;.</source>
          <target state="translated">Если последний вызов &lt;a href=&quot;step&quot;&gt;sqlite3_step (S)&lt;/a&gt; для &lt;a href=&quot;stmt&quot;&gt;подготовленного оператора&lt;/a&gt; S указал на ошибку, то &lt;a href=&quot;reset&quot;&gt;sqlite3_reset (S)&lt;/a&gt; вернет соответствующий &lt;a href=&quot;../rescode&quot;&gt;код ошибки&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="36afaf441091086a1762a1226de0f8218bd283bf" translate="yes" xml:space="preserve">
          <source>If the most recent call to &lt;a href=&quot;step&quot;&gt;sqlite3_step(S)&lt;/a&gt; for the &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; S returned &lt;a href=&quot;../rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt; or &lt;a href=&quot;../rescode#done&quot;&gt;SQLITE_DONE&lt;/a&gt;, or if &lt;a href=&quot;step&quot;&gt;sqlite3_step(S)&lt;/a&gt; has never before been called on S, then &lt;a href=&quot;reset&quot;&gt;sqlite3_reset(S)&lt;/a&gt; returns &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;.</source>
          <target state="translated">Если последний вызов &lt;a href=&quot;step&quot;&gt;sqlite3_step (S)&lt;/a&gt; для &lt;a href=&quot;stmt&quot;&gt;подготовленного оператора&lt;/a&gt; S вернул &lt;a href=&quot;../rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt; или &lt;a href=&quot;../rescode#done&quot;&gt;SQLITE_DONE&lt;/a&gt; , или если &lt;a href=&quot;step&quot;&gt;sqlite3_step (S)&lt;/a&gt; никогда ранее не вызывался на S, то &lt;a href=&quot;reset&quot;&gt;sqlite3_reset (S)&lt;/a&gt; возвращает &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bd08063b2d67d7c5aa3fda6b30f29f4f613d2690" translate="yes" xml:space="preserve">
          <source>If the most recent sqlite3_* API call associated with &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; D failed, then the sqlite3_errcode(D) interface returns the numeric &lt;a href=&quot;rescode&quot;&gt;result code&lt;/a&gt; or &lt;a href=&quot;rescode#extrc&quot;&gt;extended result code&lt;/a&gt; for that API call. The sqlite3_extended_errcode() interface is the same except that it always returns the &lt;a href=&quot;rescode#extrc&quot;&gt;extended result code&lt;/a&gt; even when extended result codes are disabled.</source>
          <target state="translated">Если последний вызов API sqlite3_ *, связанный с &lt;a href=&quot;#sqlite3&quot;&gt;подключением&lt;/a&gt; D к базе данных , завершился неудачно, то интерфейс sqlite3_errcode (D) возвращает числовой &lt;a href=&quot;rescode&quot;&gt;код результата&lt;/a&gt; или &lt;a href=&quot;rescode#extrc&quot;&gt;расширенный код результата&lt;/a&gt; для этого вызова API. Интерфейс sqlite3_extended_errcode () такой же, за исключением того, что он всегда возвращает &lt;a href=&quot;rescode#extrc&quot;&gt;расширенный код результата,&lt;/a&gt; даже если расширенные коды результатов отключены.</target>
        </trans-unit>
        <trans-unit id="02b382e95c5f6b3f587125cf8455da646274a1ae" translate="yes" xml:space="preserve">
          <source>If the most recent sqlite3_* API call associated with &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; D failed, then the sqlite3_errcode(D) interface returns the numeric &lt;a href=&quot;../rescode&quot;&gt;result code&lt;/a&gt; or &lt;a href=&quot;../rescode#extrc&quot;&gt;extended result code&lt;/a&gt; for that API call. The sqlite3_extended_errcode() interface is the same except that it always returns the &lt;a href=&quot;../rescode#extrc&quot;&gt;extended result code&lt;/a&gt; even when extended result codes are disabled.</source>
          <target state="translated">Если последний вызов API sqlite3_ *, связанный с &lt;a href=&quot;sqlite3&quot;&gt;подключением&lt;/a&gt; D к базе данных , завершился неудачно, то интерфейс sqlite3_errcode (D) возвращает числовой &lt;a href=&quot;../rescode&quot;&gt;код результата&lt;/a&gt; или &lt;a href=&quot;../rescode#extrc&quot;&gt;расширенный код результата&lt;/a&gt; для этого вызова API. Интерфейс sqlite3_extended_errcode () такой же, за исключением того, что он всегда возвращает &lt;a href=&quot;../rescode#extrc&quot;&gt;расширенный код результата,&lt;/a&gt; даже если расширенные коды результатов отключены.</target>
        </trans-unit>
        <trans-unit id="5550b629f440ed23b3241e812f943180a93fdc19" translate="yes" xml:space="preserve">
          <source>If the nByte argument is negative, then zSql is read up to the first zero terminator. If nByte is positive, then it is the number of bytes read from zSql. If nByte is zero, then no prepared statement is generated. If the caller knows that the supplied string is nul-terminated, then there is a small performance advantage to passing an nByte parameter that is the number of bytes in the input string</source>
          <target state="translated">Если аргумент nByte отрицательный,то zSql считывается до первого нулевого терминатора.Если nByte положительный,то это количество байт,считанных из zSql.Если nByte равен нулю,то подготовленный оператор не генерируется.Если вызывающий абонент знает,что поставляемая строка является нуль-терминированной,то есть небольшое преимущество в производительности при передаче параметра nByte-это количество байт во входной строке</target>
        </trans-unit>
        <trans-unit id="e34afe39a4a88dd3fd33f4104d3959b3a21962af" translate="yes" xml:space="preserve">
          <source>If the name of the database is an empty string, open a new database in a temporary file that is automatically deleted when the database is closed.</source>
          <target state="translated">Если имя БД пустая строка,откройте новую БД во временном файле,который автоматически удаляется при закрытии БД.</target>
        </trans-unit>
        <trans-unit id="4c3da3e28f6b46a881fb905c79f9b554244037e3" translate="yes" xml:space="preserve">
          <source>If the new changeset contains changes to a table that is already present in the changegroup, then the number of columns and the position of the primary key columns for the table must be consistent. If this is not the case, this function fails with SQLITE_SCHEMA. If the input changeset appears to be corrupt and the corruption is detected, SQLITE_CORRUPT is returned. Or, if an out-of-memory condition occurs during processing, this function returns SQLITE_NOMEM. In all cases, if an error occurs the final contents of the changegroup is undefined.</source>
          <target state="translated">Если новый changeset содержит изменения в таблице,которая уже присутствует в группе изменений,то количество столбцов и положение столбцов первичного ключа для таблицы должно быть одинаковым.Если это не так,то данная функция не работает с SQLITE_SCHEMA.Если входной changeset окажется поврежденным и будет обнаружено повреждение,возвращается SQLITE_CORRUPT.Или,если во время обработки происходит состояние вне памяти,данная функция возвращает SQLITE_NOMEM.Во всех случаях,при возникновении ошибки,окончательное содержимое группы изменений не определено.</target>
        </trans-unit>
        <trans-unit id="96ca16b2fc66ae0f3d6b77a841fb9c9703e99865" translate="yes" xml:space="preserve">
          <source>If the new changeset contains changes to a table that is already present in the changegroup, then the number of columns and the position of the primary key columns for the table must be consistent. If this is not the case, this function fails with SQLITE_SCHEMA. If the input changeset appears to be corrupt and the corruption is detected, SQLITE_CORRUPT is returned. Or, if an out-of-memory condition occurs during processing, this function returns SQLITE_NOMEM. In all cases, if an error occurs the state of the final contents of the changegroup is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27ef56041d2d705e25a721ff1b854e81e350859e" translate="yes" xml:space="preserve">
          <source>If the new limit is a negative number, the limit is unchanged. For each limit category SQLITE_LIMIT_</source>
          <target state="translated">Если новый предел является отрицательным числом,то предел остается неизменным.Для каждой предельной категории SQLITE_LIMIT_</target>
        </trans-unit>
        <trans-unit id="dbc989a098eb2be336e5500ea022b41d17fc93aa" translate="yes" xml:space="preserve">
          <source>If the number of output rows is K, then the time needed to sort is proportional to KlogK. If K is small, the sorting time is usually not a factor, but in a query such as the above where K==N, the time needed to sort can be much greater than the time needed to do a full table scan. Furthermore, the entire output is accumulated in temporary storage (which might be either in main memory or on disk, depending on various compile-time and run-time settings) which can mean that a lot of temporary storage is required to complete the query.</source>
          <target state="translated">Если количество выходных строк равно K,то время,необходимое для сортировки,пропорционально KlogK.Если K небольшое,то время сортировки обычно не является фактором,но в запросе,таком как выше,где K==N,время,необходимое для сортировки,может быть намного больше,чем время,необходимое для выполнения полного сканирования таблицы.Более того,весь вывод накапливается во временном хранилище (которое может быть как в оперативной памяти,так и на диске,в зависимости от различных настроек времени компиляции и времени выполнения),что может означать,что для завершения запроса требуется много временного хранилища.</target>
        </trans-unit>
        <trans-unit id="c9314fcd77821589cea840c1fc80043331e7d710" translate="yes" xml:space="preserve">
          <source>If the operating system does not support sleep requests with millisecond time resolution, then the time will be rounded up to the nearest second. The number of milliseconds of sleep actually requested from the operating system is returned.</source>
          <target state="translated">Если операционная система не поддерживает запросы &quot;сна&quot; с миллисекундным разрешением по времени,то время будет округлено до ближайшей секунды.Количество миллисекунд сна фактически запросил от операционной системы возвращается.</target>
        </trans-unit>
        <trans-unit id="13ac5ae90471727393e9b13c70a7b1b4bc52ca60" translate="yes" xml:space="preserve">
          <source>If the operating system returns an I/O error while attempting to obtain a certain lock on shared memory in &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt; then SQLite might fail to reset its cache, which could lead to database corruption if subsequent writes are attempted.</source>
          <target state="translated">Если операционная система возвращает ошибку ввода-вывода при попытке получить определенную блокировку разделяемой памяти в &lt;a href=&quot;wal&quot;&gt;режиме WAL,&lt;/a&gt; тогда SQLite может не сбросить свой кэш, что может привести к повреждению базы данных при попытке последующей записи.</target>
        </trans-unit>
        <trans-unit id="cdf4bb4c410d8ce86d8512a4260a05ff5271bb95" translate="yes" xml:space="preserve">
          <source>If the operation is successful, SQLITE_OK is returned. Otherwise, an SQLite error code. In this case, if argument pzErrMsg is not NULL, *pzErrMsg may be set to point to a buffer containing an English language error message. It is the responsibility of the caller to free this buffer using sqlite3_free().</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="387f85a0f9d5d2d59fdee2093a34c406de18ba33" translate="yes" xml:space="preserve">
          <source>If the operation successful, SQLITE_OK is returned. Otherwise, an SQLite error code. In this case, if argument pzErrMsg is not NULL, *pzErrMsg may be set to point to a buffer containing an English language error message. It is the responsibility of the caller to free this buffer using sqlite3_free().</source>
          <target state="translated">Если операция прошла успешно,возвращается SQLITE_OK.В противном случае-код ошибки SQLite.В этом случае,если аргумент pzErrMsg не NULL,*pzErrMsg может быть установлен как указание на буфер,содержащий сообщение об ошибке английского языка.В обязанности вызывающего абонента входит освобождение этого буфера с помощью sqlite3_free().</target>
        </trans-unit>
        <trans-unit id="64ab9d2da26c1826cadd00ea1395a9af67e21893" translate="yes" xml:space="preserve">
          <source>If the optional ESCAPE clause is present, then the expression following the ESCAPE keyword must evaluate to a string consisting of a single character. This character may be used in the LIKE pattern to include literal percent or underscore characters. The escape character followed by a percent symbol (%), underscore (_), or a second instance of the escape character itself matches a literal percent symbol, underscore, or a single escape character, respectively.</source>
          <target state="translated">Если присутствует необязательная клаузула ESCAPE,то выражение,следующее за ключевым словом ESCAPE,должно оцениваться до строки,состоящей из одного символа.Этот символ может быть использован в шаблоне LIKE для включения буквенных процентов или символов подчеркивания.Экранирующий символ,за которым следует символ процента (%),символ подчёркивания (_)или второй экземпляр самого экранирующего символа,соответствует буквальному символу процента,символу подчёркивания или единичному экранирующему символу,соответственно.</target>
        </trans-unit>
        <trans-unit id="3874cddaea0653331a0794c8eb1dd76401bd55b2" translate="yes" xml:space="preserve">
          <source>If the optional IF NOT EXISTS clause is present and another index with the same name already exists, then this command becomes a no-op.</source>
          <target state="translated">Если присутствует необязательное условие &quot;IF NOT EXISTS&quot; и уже существует другой индекс с тем же именем,то эта команда становится &quot;no-op&quot;.</target>
        </trans-unit>
        <trans-unit id="65cace3a0d2d4d6370079a8ce7f587fee8e20bbc" translate="yes" xml:space="preserve">
          <source>If the outer query is an aggregate, then the subquery may not contain ORDER BY.</source>
          <target state="translated">Если внешний запрос является агрегированным,то подзапрос может не содержать ЗАКАЗАТЕЛЬСТВА BY.</target>
        </trans-unit>
        <trans-unit id="0b950d8e0107ea7fe292918a7624ecc4c5105550" translate="yes" xml:space="preserve">
          <source>If the outer query is part of a compound select, then the subquery may not have a LIMIT clause.</source>
          <target state="translated">Если внешний запрос является частью составного выбора,то в подзапросе может отсутствовать пункт LIMIT.</target>
        </trans-unit>
        <trans-unit id="9ec4e583fb2aac08c6ef7929f12a08ccd0d23acd" translate="yes" xml:space="preserve">
          <source>If the output parameters (ppRebase) and (pnRebase) are non-NULL and the input is a changeset (not a patchset), then sqlite3changeset_apply_v2() may set (*ppRebase) to point to a &quot;rebase&quot; that may be used with the sqlite3_rebaser APIs buffer before returning. In this case (*pnRebase) is set to the size of the buffer in bytes. It is the responsibility of the caller to eventually free any such buffer using sqlite3_free(). The buffer is only allocated and populated if one or more conflicts were encountered while applying the patchset. See comments surrounding the sqlite3_rebaser APIs for further details.</source>
          <target state="translated">Если выходные параметры (ppRebase)и (pnRebase)не NULL,а входной является changeset (не patchset),то sqlite3changeset_apply_v2()может установить (*ppRebase),чтобы указать на &quot;rebase&quot;,которая может быть использована с буфером sqlite3_rebaser API перед возвращением.В этом случае (*pnRebase)устанавливается размер буфера в байтах.В обязанности вызывающего абонента входит в конечном итоге освободить любой такой буфер с помощью функции sqlite3_free().Буфер выделяется и заполняется только в том случае,если при применении патчсета возник один или несколько конфликтов.Подробности см.в комментариях,окружающих sqlite3_rebaser API.</target>
        </trans-unit>
        <trans-unit id="e9ff399a5e615a33dc8fa9681024351734065387" translate="yes" xml:space="preserve">
          <source>If the parameter is a positive value, B-tree structures are only eligible for merging if one of the following is true:</source>
          <target state="translated">Если параметр является положительным значением,то B-деревянные структуры могут быть объединены только в том случае,если одно из следующих значений верно:</target>
        </trans-unit>
        <trans-unit id="60b6cd8e8d3dd19980d55457d739967fca11e05a" translate="yes" xml:space="preserve">
          <source>If the parameter is named, then its name appears in P4. The P4 value is used by sqlite3_bind_parameter_name().</source>
          <target state="translated">Если параметр имеет имя,то его имя отображается в P4.Значение P4 используется функцией sqlite3_bind_parameter_name().</target>
        </trans-unit>
        <trans-unit id="b51f3bd8d197cc75de48b64a5587d9918566615a" translate="yes" xml:space="preserve">
          <source>If the parameter is negative, and there are B-tree structures on more than one level within the FTS index, all B-tree structures are assigned to the same level before the merge operation is commenced. Additionally, if the parameter is negative, the value of the usermerge configuration option is not respected - as few as two b-trees from the same level may be merged together.</source>
          <target state="translated">Если параметр отрицательный и в индексе FTS имеются B-деревянные структуры более чем на одном уровне,то перед началом операции слияния всем B-деревянным структурам присваивается один и тот же уровень.Дополнительно,если параметр отрицательный,значение параметра &quot;Конфигурация пользователя&quot; не соблюдается-всего лишь два b-дерева одного уровня могут быть объединены вместе.</target>
        </trans-unit>
        <trans-unit id="ff1e8b8711836cc88e8f7bc11a03808c27d6ff91" translate="yes" xml:space="preserve">
          <source>If the paths are sorted using the BINARY collation sequence, then the overflow pages associated with a cell will appear earlier in the sort-order than its child page:</source>
          <target state="translated">Если пути отсортированы с использованием последовательности сопоставления BINARY,то страницы переполнения,связанные с ячейкой,появятся раньше в сортировочном порядке,чем ее дочерняя страница:</target>
        </trans-unit>
        <trans-unit id="e58cd97227118f50b919227b576a1a6d96943367" translate="yes" xml:space="preserve">
          <source>If the process that wants to write is unable to obtain a RESERVED lock, it must mean that another process already has a RESERVED lock. In that case, the write attempt fails and returns SQLITE_BUSY.</source>
          <target state="translated">Если процесс,который хочет произвести запись,не может получить блокировку RESERVED,это должно означать,что другой процесс уже имеет блокировку RESERVED.В этом случае попытка записи завершается неудачно и возвращается SQLITE_BUSY.</target>
        </trans-unit>
        <trans-unit id="406129ab5d2092b3ea22acba195d09ec62e01cc6" translate="yes" xml:space="preserve">
          <source>If the progress callback returns non-zero, the operation is interrupted. This feature can be used to implement a &quot;Cancel&quot; button on a GUI progress dialog box.</source>
          <target state="translated">Если при обратном вызове прогресса возвращается ненулевое значение,операция прерывается.Эта функция может быть использована для реализации кнопки &quot;Отмена&quot; в диалоговом окне прогресса графического интерфейса.</target>
        </trans-unit>
        <trans-unit id="ab297d564d935b4268428b382c93fe0d78c1a7ca" translate="yes" xml:space="preserve">
          <source>If the query contains an ORDER BY clause or a GROUP BY clause or if the query uses the DISTINCT keyword then it is advantageous to select a path through the graph that causes rows to naturally appear in sorted order, so that no separate sorting step is required. Automatic elimination of ORDER BY clauses can make a large performance difference, so this is another factor that needs to be considered in a complete implementation.</source>
          <target state="translated">Если запрос содержит пункт ORDER BY или GROUP BY,или если запрос использует ключевое слово DISTINCT,то выгодно выбрать путь через график,из-за которого строки будут естественно выглядеть в отсортированном порядке,так что отдельный шаг сортировки не требуется.Автоматическое устранение пункта ORDER BY может привести к большой разнице в производительности,поэтому это еще один фактор,который необходимо учитывать в полной реализации.</target>
        </trans-unit>
        <trans-unit id="4359b51a903396b955ce1a84240a1385d5c4cd97" translate="yes" xml:space="preserve">
          <source>If the query runs to completion without incident, SQLITE_OK is returned. Or, if some error occurs before the query completes or is aborted by the callback, an SQLite error code is returned.</source>
          <target state="translated">Если запрос выполняется без инцидентов,возвращается SQLITE_OK.Или,если какая-то ошибка возникает до завершения запроса или прерывается обратным вызовом,возвращается код ошибки SQLite.</target>
        </trans-unit>
        <trans-unit id="78d49d24ce74dae451d0ef728d6bf465dbd467e9" translate="yes" xml:space="preserve">
          <source>If the reason for writing to the database file is because the memory cache was full, then the writer will not commit right away. Instead, the writer might continue to make changes to other pages. Before subsequent changes are written to the database file, the rollback journal must be flushed to disk again. Note also that the EXCLUSIVE lock that the writer obtained in order to write to the database initially must be held until all changes are committed. That means that no other processes are able to access the database from the time the memory cache first spills to disk until the transaction commits.</source>
          <target state="translated">Если причина записи в файл базы данных заключается в том,что кэш памяти был переполнен,то запись не будет произведена сразу.Вместо этого пишущий может продолжать вносить изменения в другие страницы.Перед тем,как последующие изменения будут записаны в файл базы данных,журнал отката должен быть снова промыт на диск.Обратите также внимание,что полученная записывающим устройством для записи в базу данных ЭКСКЛЮЗИВНАЯ БЛОКИРОВКА должна удерживаться до тех пор,пока все изменения не будут зафиксированы.Это означает,что никакие другие процессы не смогут получить доступ к базе данных с момента первого пролития кэша памяти на диск до фиксации транзакции.</target>
        </trans-unit>
        <trans-unit id="f4de1a28535def0f53f335b0aa1ec084bfb958b6" translate="yes" xml:space="preserve">
          <source>If the record contains fewer than P2 fields, then extract a NULL. Or, if the P4 argument is a P4_MEM use the value of the P4 argument as the result.</source>
          <target state="translated">Если запись содержит меньше полей P2,извлеките NULL.Или,если аргумент P4 является P4_MEM,используйте в качестве результата значение аргумента P4.</target>
        </trans-unit>
        <trans-unit id="a233c4347f5d21c12355351382fcf901413d7e49" translate="yes" xml:space="preserve">
          <source>If the recovered database schema already contains a table named &quot;lost_and_found&quot;, the &quot;.recover&quot; command uses the name &quot;lost_and_found0&quot;. If the name &quot;lost_and_found0&quot; is also already taken, &quot;lost_and_found1&quot;, and so on. The default name &quot;lost_and_found&quot; may be overridden by invoking &quot;.recover&quot; with the --lost-and-found switch. For example, to have the output script call the table &quot;orphaned_rows&quot;:</source>
          <target state="translated">Если восстановленная схема БД уже содержит таблицу с именем &quot;lost_and_found&quot;,то команда &quot;.recovery&quot; использует имя &quot;lost_and_found0&quot;.Если имя &quot;lost_and_found0&quot; также уже взято,&quot;lost_and_found1&quot; и т.п.Имя по умолчанию &quot;lost_and_found&quot; можно переопределить,вызвав &quot;.recovery&quot; с помощью переключателя --lost-and-found.Например,чтобы выходной скрипт вызвал таблицу &quot;orphaned_rows&quot;:</target>
        </trans-unit>
        <trans-unit id="872cffdf6d4bf05d01de18a6904e492aef161446" translate="yes" xml:space="preserve">
          <source>If the requested page is already in the page cache, then the page cache implementation must return a pointer to the page buffer with its content intact. If the requested page is not already in the cache, then the cache implementation should use the value of the createFlag parameter to help it determined what action to take:</source>
          <target state="translated">Если запрашиваемая страница уже находится в кэше страниц,то реализация кэша страниц должна возвращать указатель на буфер страниц,содержимое которого не повреждено.Если запрашиваемой страницы еще нет в кэше,то реализация в кэше должна использовать значение параметра createFlag,чтобы помочь ей определить,какие действия необходимо предпринять:</target>
        </trans-unit>
        <trans-unit id="db0bc69173aefab4964d855c64d49581690da543" translate="yes" xml:space="preserve">
          <source>If the result is a BLOB or UTF-16 string then the sqlite3_column_bytes16() routine returns the number of bytes in that BLOB or string. If the result is a UTF-8 string, then sqlite3_column_bytes16() converts the string to UTF-16 and then returns the number of bytes. If the result is a numeric value then sqlite3_column_bytes16() uses &lt;a href=&quot;#sqlite3_mprintf&quot;&gt;sqlite3_snprintf()&lt;/a&gt; to convert that value to a UTF-16 string and returns the number of bytes in that string. If the result is NULL, then sqlite3_column_bytes16() returns zero.</source>
          <target state="translated">Если результатом является строка BLOB или UTF-16, тогда процедура sqlite3_column_bytes16 () возвращает количество байтов в этом BLOB или строке. Если результатом является строка UTF-8, то sqlite3_column_bytes16 () преобразует строку в UTF-16, а затем возвращает количество байтов. Если результатом является числовое значение, то sqlite3_column_bytes16 () использует &lt;a href=&quot;#sqlite3_mprintf&quot;&gt;sqlite3_snprintf ()&lt;/a&gt; для преобразования этого значения в строку UTF-16 и возвращает количество байтов в этой строке. Если результат равен NULL, то sqlite3_column_bytes16 () возвращает ноль.</target>
        </trans-unit>
        <trans-unit id="3b44d7bd1746ffad7cf756ce26aeea67c4d49e66" translate="yes" xml:space="preserve">
          <source>If the result is a BLOB or UTF-16 string then the sqlite3_column_bytes16() routine returns the number of bytes in that BLOB or string. If the result is a UTF-8 string, then sqlite3_column_bytes16() converts the string to UTF-16 and then returns the number of bytes. If the result is a numeric value then sqlite3_column_bytes16() uses &lt;a href=&quot;mprintf&quot;&gt;sqlite3_snprintf()&lt;/a&gt; to convert that value to a UTF-16 string and returns the number of bytes in that string. If the result is NULL, then sqlite3_column_bytes16() returns zero.</source>
          <target state="translated">Если результатом является строка BLOB или UTF-16, тогда процедура sqlite3_column_bytes16 () возвращает количество байтов в этом BLOB или строке. Если результатом является строка UTF-8, то sqlite3_column_bytes16 () преобразует строку в UTF-16, а затем возвращает количество байтов. Если результатом является числовое значение, то sqlite3_column_bytes16 () использует &lt;a href=&quot;mprintf&quot;&gt;sqlite3_snprintf ()&lt;/a&gt; для преобразования этого значения в строку UTF-16 и возвращает количество байтов в этой строке. Если результат равен NULL, то sqlite3_column_bytes16 () возвращает ноль.</target>
        </trans-unit>
        <trans-unit id="5a04fb4ab27b4007fb1a3789b739c65a862ccba9" translate="yes" xml:space="preserve">
          <source>If the result is a BLOB or UTF-8 string then the sqlite3_column_bytes() routine returns the number of bytes in that BLOB or string. If the result is a UTF-16 string, then sqlite3_column_bytes() converts the string to UTF-8 and then returns the number of bytes. If the result is a numeric value then sqlite3_column_bytes() uses &lt;a href=&quot;#sqlite3_mprintf&quot;&gt;sqlite3_snprintf()&lt;/a&gt; to convert that value to a UTF-8 string and returns the number of bytes in that string. If the result is NULL, then sqlite3_column_bytes() returns zero.</source>
          <target state="translated">Если результатом является строка BLOB или UTF-8, тогда процедура sqlite3_column_bytes () возвращает количество байтов в этом BLOB или строке. Если результатом является строка UTF-16, то sqlite3_column_bytes () преобразует строку в UTF-8, а затем возвращает количество байтов. Если результатом является числовое значение, то sqlite3_column_bytes () использует &lt;a href=&quot;#sqlite3_mprintf&quot;&gt;sqlite3_snprintf ()&lt;/a&gt; для преобразования этого значения в строку UTF-8 и возвращает количество байтов в этой строке. Если результат NULL, то sqlite3_column_bytes () возвращает ноль.</target>
        </trans-unit>
        <trans-unit id="97aa0401915ee07da3fcfb4b2dd9b95ffff68377" translate="yes" xml:space="preserve">
          <source>If the result is a BLOB or UTF-8 string then the sqlite3_column_bytes() routine returns the number of bytes in that BLOB or string. If the result is a UTF-16 string, then sqlite3_column_bytes() converts the string to UTF-8 and then returns the number of bytes. If the result is a numeric value then sqlite3_column_bytes() uses &lt;a href=&quot;mprintf&quot;&gt;sqlite3_snprintf()&lt;/a&gt; to convert that value to a UTF-8 string and returns the number of bytes in that string. If the result is NULL, then sqlite3_column_bytes() returns zero.</source>
          <target state="translated">Если результатом является строка BLOB или UTF-8, тогда процедура sqlite3_column_bytes () возвращает количество байтов в этом BLOB или строке. Если результатом является строка UTF-16, то sqlite3_column_bytes () преобразует строку в UTF-8, а затем возвращает количество байтов. Если результатом является числовое значение, то sqlite3_column_bytes () использует &lt;a href=&quot;mprintf&quot;&gt;sqlite3_snprintf ()&lt;/a&gt; для преобразования этого значения в строку UTF-8 и возвращает количество байтов в этой строке. Если результат NULL, то sqlite3_column_bytes () возвращает ноль.</target>
        </trans-unit>
        <trans-unit id="cce95bf5c0bc98e89e8fc40f80872857badf8433" translate="yes" xml:space="preserve">
          <source>If the result is a BLOB or a TEXT string, then the sqlite3_column_bytes() or sqlite3_column_bytes16() interfaces can be used to determine the size of that BLOB or string.</source>
          <target state="translated">Если результат-BLOB или TEXT строка,то интерфейсы sqlite3_column_bytes()или sqlite3_column_bytes16()могут быть использованы для определения размера этого BLOB или строки.</target>
        </trans-unit>
        <trans-unit id="fd9c1a162239f42f97865bf762c6375eed8fe6fe" translate="yes" xml:space="preserve">
          <source>If the result is a general expression, not a just the name of a source table column, then the name of the result is a copy of the expression text.</source>
          <target state="translated">Если результат является общим выражением,а не просто именем столбца исходной таблицы,то именем результата является копия текста выражения.</target>
        </trans-unit>
        <trans-unit id="57f0dbb6f6834911f1360c14b63d681228556516" translate="yes" xml:space="preserve">
          <source>If the result set of a query is empty, then by default &lt;b&gt;sqlite_get_table&lt;/b&gt; will set nrow to 0 and leave its result parameter is set to NULL. But if the EMPTY_RESULT_CALLBACKS pragma is ON then the result parameter is initialized to the names of the columns only. For example, consider this query which has an empty result set:</source>
          <target state="translated">Если набор результатов запроса пуст, то по умолчанию &lt;b&gt;sqlite_get_table&lt;/b&gt; установит nrow в 0 и оставит его параметр результата равным NULL. Но если прагма EMPTY_RESULT_CALLBACKS включена, то параметр результата инициализируется только именами столбцов. Например, рассмотрим этот запрос с пустым набором результатов:</target>
        </trans-unit>
        <trans-unit id="d816ce55af3aa1bc324149c293eb2742dfc0c53d" translate="yes" xml:space="preserve">
          <source>If the right-hand side of an IN operator can be list of values as in the following:</source>
          <target state="translated">Если с правой стороны оператора IN можно перечислить значения,как показано ниже:</target>
        </trans-unit>
        <trans-unit id="b287ebc787ae1fe1352a6696e98abccff05e37e6" translate="yes" xml:space="preserve">
          <source>If the row comes from a WITHOUT ROWID table, this column contains NULL. Otherwise, it contains the 64-bit integer rowid value for the row.</source>
          <target state="translated">Если строка берется из таблицы БЕЗ КОЛИЧЕСТВА,то этот столбец содержит NULL.В противном случае она содержит 64-битное целое значение rowid для строки.</target>
        </trans-unit>
        <trans-unit id="489be44720b2f1c706095444d825988cba31b9db" translate="yes" xml:space="preserve">
          <source>If the row that a BLOB handle points to is modified by an &lt;a href=&quot;../lang_update&quot;&gt;UPDATE&lt;/a&gt;, &lt;a href=&quot;../lang_delete&quot;&gt;DELETE&lt;/a&gt;, or by &lt;a href=&quot;../lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt; side-effects then the BLOB handle is marked as &quot;expired&quot;. This is true if any column of the row is changed, even a column other than the one the BLOB handle is open on. Calls to &lt;a href=&quot;blob_read&quot;&gt;sqlite3_blob_read()&lt;/a&gt; and &lt;a href=&quot;blob_write&quot;&gt;sqlite3_blob_write()&lt;/a&gt; for an expired BLOB handle fail with a return code of &lt;a href=&quot;../rescode#abort&quot;&gt;SQLITE_ABORT&lt;/a&gt;. Changes written into a BLOB prior to the BLOB expiring are not rolled back by the expiration of the BLOB. Such changes will eventually commit if the transaction continues to completion.</source>
          <target state="translated">Если строка, на которую указывает дескриптор BLOB, изменена побочными эффектами &lt;a href=&quot;../lang_update&quot;&gt;UPDATE&lt;/a&gt; , &lt;a href=&quot;../lang_delete&quot;&gt;DELETE&lt;/a&gt; или &lt;a href=&quot;../lang_conflict&quot;&gt;ON CONFLICT,&lt;/a&gt; то дескриптор BLOB помечается как &amp;laquo;просроченный&amp;raquo;. Это верно, если любой столбец строки изменяется, даже если столбец отличается от того, в котором открыт дескриптор BLOB. Вызовы &lt;a href=&quot;blob_read&quot;&gt;sqlite3_blob_read ()&lt;/a&gt; и &lt;a href=&quot;blob_write&quot;&gt;sqlite3_blob_write ()&lt;/a&gt; для истекшего дескриптора BLOB &lt;a href=&quot;../rescode#abort&quot;&gt;завершаются&lt;/a&gt; ошибкой с кодом возврата SQLITE_ABORT . Изменения, записанные в BLOB до истечения срока действия BLOB, не откатываются по истечении срока действия BLOB. Такие изменения в конечном итоге будут зафиксированы, если транзакция продолжит завершаться.</target>
        </trans-unit>
        <trans-unit id="855918a93d6aa4472f75825b61dee9d03ea7eab1" translate="yes" xml:space="preserve">
          <source>If the row that a BLOB handle points to is modified by an &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;, &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt;, or by &lt;a href=&quot;lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt; side-effects then the BLOB handle is marked as &quot;expired&quot;. This is true if any column of the row is changed, even a column other than the one the BLOB handle is open on. Calls to &lt;a href=&quot;#sqlite3_blob_read&quot;&gt;sqlite3_blob_read()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_blob_write&quot;&gt;sqlite3_blob_write()&lt;/a&gt; for an expired BLOB handle fail with a return code of &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ABORT&lt;/a&gt;. Changes written into a BLOB prior to the BLOB expiring are not rolled back by the expiration of the BLOB. Such changes will eventually commit if the transaction continues to completion.</source>
          <target state="translated">Если строка, на которую указывает дескриптор BLOB, изменена побочными эффектами &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; , &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; или &lt;a href=&quot;lang_conflict&quot;&gt;ON CONFLICT,&lt;/a&gt; то дескриптор BLOB помечается как &amp;laquo;просроченный&amp;raquo;. Это верно, если любой столбец строки изменяется, даже если столбец отличается от того, в котором открыт дескриптор BLOB. Вызовы &lt;a href=&quot;#sqlite3_blob_read&quot;&gt;sqlite3_blob_read ()&lt;/a&gt; и &lt;a href=&quot;#sqlite3_blob_write&quot;&gt;sqlite3_blob_write ()&lt;/a&gt; для истекшего дескриптора BLOB &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;завершаются&lt;/a&gt; ошибкой с кодом возврата SQLITE_ABORT . Изменения, записанные в BLOB до истечения срока действия BLOB, не откатываются по истечении срока действия BLOB. Такие изменения в конечном итоге будут зафиксированы, если транзакция продолжит завершаться.</target>
        </trans-unit>
        <trans-unit id="5ad667b790a078db1e6c6968fc928120e549e94b" translate="yes" xml:space="preserve">
          <source>If the same database is being read and written using two different &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt; (two different &lt;a href=&quot;c3ref/sqlite3&quot;&gt;sqlite3&lt;/a&gt; objects returned by separate calls to &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt;) and the two database connections do not have a &lt;a href=&quot;sharedcache&quot;&gt;shared cache&lt;/a&gt;, then the reader is only able to see complete committed transactions from the writer. Partial changes by the writer that have not been committed are invisible to the reader. This is true regardless of whether the two database connections are in the same thread, in different threads of the same process, or in different processes. This is the usual and expected behavior for SQL database systems.</source>
          <target state="translated">Если одна и та же база данных читается и записывается с использованием двух разных &lt;a href=&quot;c3ref/sqlite3&quot;&gt;соединений с базой данных&lt;/a&gt; (два разных объекта &lt;a href=&quot;c3ref/sqlite3&quot;&gt;sqlite3,&lt;/a&gt; возвращаемых отдельными вызовами &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open ()&lt;/a&gt; ), и два соединения с базой данных не имеют &lt;a href=&quot;sharedcache&quot;&gt;общего кеша&lt;/a&gt; , то читатель может видеть только полностью зафиксированные транзакции от писателя. Частичные изменения, внесенные автором, которые не были зафиксированы, невидимы для читателя. Это верно независимо от того, находятся ли два соединения с базой данных в одном потоке, в разных потоках одного и того же процесса или в разных процессах. Это обычное и ожидаемое поведение для систем баз данных SQL.</target>
        </trans-unit>
        <trans-unit id="2e0132de71fd47828befdd8cddea786393211a76" translate="yes" xml:space="preserve">
          <source>If the savepoint-name in a RELEASE command does not match any savepoint currently in the transaction stack, then no savepoints are released, the database is unchanged, and the RELEASE command returns an error.</source>
          <target state="translated">Если имя точки сохранения в команде RELEASE не совпадает ни с одной точкой сохранения,находящейся в стеке транзакций,то точки сохранения не освобождаются,база данных остается неизменной,а команда RELEASE возвращает ошибку.</target>
        </trans-unit>
        <trans-unit id="0e8e411b07fe2c001323f612676b1abf9cd50210" translate="yes" xml:space="preserve">
          <source>If the second parameter (zDbName) does not match the name of any open database file, then SQLITE_ERROR is returned. This error code is not remembered and will not be recalled by &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errcode()&lt;/a&gt; or &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errmsg()&lt;/a&gt;. The underlying xFileControl method might also return SQLITE_ERROR. There is no way to distinguish between an incorrect zDbName and an SQLITE_ERROR return from the underlying xFileControl method.</source>
          <target state="translated">Если второй параметр (zDbName) не соответствует имени какого-либо открытого файла базы данных, возвращается SQLITE_ERROR. Этот код ошибки не запоминается и не вызывается &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errcode ()&lt;/a&gt; или &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errmsg ()&lt;/a&gt; . Базовый метод xFileControl также может возвращать SQLITE_ERROR. Невозможно отличить неправильное имя zDbName от возврата SQLITE_ERROR из базового метода xFileControl.</target>
        </trans-unit>
        <trans-unit id="0a6c4ada949c40cb1aa6d07b25694fd6c11c1796" translate="yes" xml:space="preserve">
          <source>If the second parameter (zDbName) does not match the name of any open database file, then SQLITE_ERROR is returned. This error code is not remembered and will not be recalled by &lt;a href=&quot;errcode&quot;&gt;sqlite3_errcode()&lt;/a&gt; or &lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg()&lt;/a&gt;. The underlying xFileControl method might also return SQLITE_ERROR. There is no way to distinguish between an incorrect zDbName and an SQLITE_ERROR return from the underlying xFileControl method.</source>
          <target state="translated">Если второй параметр (zDbName) не соответствует имени какого-либо открытого файла базы данных, возвращается SQLITE_ERROR. Этот код ошибки не запоминается и не вызывается &lt;a href=&quot;errcode&quot;&gt;sqlite3_errcode ()&lt;/a&gt; или &lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg ()&lt;/a&gt; . Базовый метод xFileControl также может возвращать SQLITE_ERROR. Невозможно отличить неправильное имя zDbName от возврата SQLITE_ERROR из базового метода xFileControl.</target>
        </trans-unit>
        <trans-unit id="b78c0101bf92e2df502819dbd3877a0d27dbb142" translate="yes" xml:space="preserve">
          <source>If the size of a potentially hot journal file is revealed to be greater than zero bytes by a query required by H35450, then SQLite shall attempt to upgrade the</source>
          <target state="translated">Если по запросу,требуемому H35450,размер потенциально горячего файла журнала окажется больше нуля байт,то SQLite должен попытаться обновить</target>
        </trans-unit>
        <trans-unit id="84a94aa97953d8f31911d07edfb705a8ac22630d" translate="yes" xml:space="preserve">
          <source>If the size of a potentially hot journal file is revealed to be zero bytes by a query required by H35450, then SQLite shall close the file handle opened on the journal file and delete the journal file using a call to the VFS xDelete() method. In this case SQLite shall conclude that there is no</source>
          <target state="translated">Если по запросу H35450 размер потенциально горячего файла журнала будет равен нулю байт,то SQLite должен закрыть файловый handle,открытый на файле журнала,и удалить файл журнала с помощью вызова метода VFS xDelete().В этом случае SQLite должен сделать вывод,что нет никакого</target>
        </trans-unit>
        <trans-unit id="8775f72effd63665f56849704eebc4e3eb03a777" translate="yes" xml:space="preserve">
          <source>If the specific value bound to &lt;a href=&quot;../lang_expr#varparam&quot;&gt;host parameter&lt;/a&gt; in the WHERE clause might influence the choice of query plan for a statement, then the statement will be automatically recompiled, as if there had been a schema change, on the first &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; call following any change to the &lt;a href=&quot;bind_blob&quot;&gt;bindings&lt;/a&gt; of that &lt;a href=&quot;../lang_expr#varparam&quot;&gt;parameter&lt;/a&gt;. The specific value of WHERE-clause &lt;a href=&quot;../lang_expr#varparam&quot;&gt;parameter&lt;/a&gt; might influence the choice of query plan if the parameter is the left-hand side of a &lt;a href=&quot;../lang_expr#like&quot;&gt;LIKE&lt;/a&gt; or &lt;a href=&quot;../lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; operator or if the parameter is compared to an indexed column and the &lt;a href=&quot;../compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt; compile-time option is enabled.</source>
          <target state="translated">Если конкретное значение, привязанное к &lt;a href=&quot;../lang_expr#varparam&quot;&gt;параметру хоста&lt;/a&gt; в предложении WHERE, может повлиять на выбор плана запроса для оператора, тогда оператор будет автоматически перекомпилирован, как если бы произошло изменение схемы, при первом вызове &lt;a href=&quot;step&quot;&gt;sqlite3_step ()&lt;/a&gt; после любого изменения. к &lt;a href=&quot;bind_blob&quot;&gt;привязкам&lt;/a&gt; этого &lt;a href=&quot;../lang_expr#varparam&quot;&gt;параметра&lt;/a&gt; . Конкретное значение WHERE придаточного &lt;a href=&quot;../lang_expr#varparam&quot;&gt;параметра&lt;/a&gt; может повлиять на выбор плана запроса , если параметр является левая сторона &lt;a href=&quot;../lang_expr#like&quot;&gt;LIKE&lt;/a&gt; или &lt;a href=&quot;../lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; оператора или если параметр сравнивается с индексированного столбца и &lt;a href=&quot;../compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt; опции компиляции включена.</target>
        </trans-unit>
        <trans-unit id="44b5aede3751869315efb1ad0c6228b799d6377d" translate="yes" xml:space="preserve">
          <source>If the specific value bound to &lt;a href=&quot;lang_expr#varparam&quot;&gt;host parameter&lt;/a&gt; in the WHERE clause might influence the choice of query plan for a statement, then the statement will be automatically recompiled, as if there had been a schema change, on the first &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; call following any change to the &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;bindings&lt;/a&gt; of that &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameter&lt;/a&gt;. The specific value of WHERE-clause &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameter&lt;/a&gt; might influence the choice of query plan if the parameter is the left-hand side of a &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; or &lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; operator or if the parameter is compared to an indexed column and the &lt;a href=&quot;compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt; compile-time option is enabled.</source>
          <target state="translated">Если конкретное значение, привязанное к &lt;a href=&quot;lang_expr#varparam&quot;&gt;параметру хоста&lt;/a&gt; в предложении WHERE, может повлиять на выбор плана запроса для оператора, тогда оператор будет автоматически перекомпилирован, как если бы произошло изменение схемы, при первом вызове &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step ()&lt;/a&gt; после любого изменения. к &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;привязкам&lt;/a&gt; этого &lt;a href=&quot;lang_expr#varparam&quot;&gt;параметра&lt;/a&gt; . Конкретное значение WHERE придаточного &lt;a href=&quot;lang_expr#varparam&quot;&gt;параметра&lt;/a&gt; может повлиять на выбор плана запроса , если параметр является левая сторона &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; или &lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; оператора или если параметр сравнивается с индексированного столбца и &lt;a href=&quot;compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt; опции компиляции включена.</target>
        </trans-unit>
        <trans-unit id="a67ab94a492111af2ad307d63a14eece5d2506a2" translate="yes" xml:space="preserve">
          <source>If the specific value bound to a &lt;a href=&quot;../lang_expr#varparam&quot;&gt;host parameter&lt;/a&gt; in the WHERE clause might influence the choice of query plan for a statement, then the statement will be automatically recompiled, as if there had been a schema change, on the first &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; call following any change to the &lt;a href=&quot;bind_blob&quot;&gt;bindings&lt;/a&gt; of that &lt;a href=&quot;../lang_expr#varparam&quot;&gt;parameter&lt;/a&gt;. The specific value of a WHERE-clause &lt;a href=&quot;../lang_expr#varparam&quot;&gt;parameter&lt;/a&gt; might influence the choice of query plan if the parameter is the left-hand side of a &lt;a href=&quot;../lang_expr#like&quot;&gt;LIKE&lt;/a&gt; or &lt;a href=&quot;../lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; operator or if the parameter is compared to an indexed column and the &lt;a href=&quot;../compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt; compile-time option is enabled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1532d90d6e0b3047b8c2ebb4f13faa142948903d" translate="yes" xml:space="preserve">
          <source>If the specific value bound to a &lt;a href=&quot;lang_expr#varparam&quot;&gt;host parameter&lt;/a&gt; in the WHERE clause might influence the choice of query plan for a statement, then the statement will be automatically recompiled, as if there had been a schema change, on the first &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; call following any change to the &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;bindings&lt;/a&gt; of that &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameter&lt;/a&gt;. The specific value of a WHERE-clause &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameter&lt;/a&gt; might influence the choice of query plan if the parameter is the left-hand side of a &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; or &lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; operator or if the parameter is compared to an indexed column and the &lt;a href=&quot;compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt; compile-time option is enabled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e1ce97d9fc0705c3229e21c8809d3855d59efd3" translate="yes" xml:space="preserve">
          <source>If the specified column is &quot;rowid&quot;, &quot;oid&quot; or &quot;_rowid_&quot; and the table is not a &lt;a href=&quot;../withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; table and an &lt;a href=&quot;../lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; column has been explicitly declared, then the output parameters are set for the explicitly declared column. If there is no &lt;a href=&quot;../lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; column, then the outputs for the &lt;a href=&quot;../lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; are set as follows:</source>
          <target state="translated">Если указанный столбец - &amp;laquo;rowid&amp;raquo;, &amp;laquo;oid&amp;raquo; или &amp;laquo;_rowid_&amp;raquo;, и таблица не является таблицей &lt;a href=&quot;../withoutrowid&quot;&gt;БЕЗ ROWID&lt;/a&gt; и столбец &lt;a href=&quot;../lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; был явно объявлен, то выходные параметры устанавливаются для явно объявленного столбца. Если столбец &lt;a href=&quot;../lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY отсутствует&lt;/a&gt; , то выходы для &lt;a href=&quot;../lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; устанавливаются следующим образом:</target>
        </trans-unit>
        <trans-unit id="8f350a11b8322175a383ceadb167cdbb00955970" translate="yes" xml:space="preserve">
          <source>If the specified column is &quot;rowid&quot;, &quot;oid&quot; or &quot;_rowid_&quot; and the table is not a &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; table and an &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; column has been explicitly declared, then the output parameters are set for the explicitly declared column. If there is no &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; column, then the outputs for the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; are set as follows:</source>
          <target state="translated">Если указанный столбец - &amp;laquo;rowid&amp;raquo;, &amp;laquo;oid&amp;raquo; или &amp;laquo;_rowid_&amp;raquo;, и таблица не является таблицей &lt;a href=&quot;withoutrowid&quot;&gt;БЕЗ ROWID&lt;/a&gt; и столбец &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; был явно объявлен, то выходные параметры устанавливаются для явно объявленного столбца. Если столбец &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY отсутствует&lt;/a&gt; , то выходы для &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; устанавливаются следующим образом:</target>
        </trans-unit>
        <trans-unit id="f3164e0e380d4749ee94c4239d71835f6ebe7294" translate="yes" xml:space="preserve">
          <source>If the specified compress or uncompress functions do not exist, the table may still be created. An error is not returned until the FTS4 table is read (if the uncompress function does not exist) or written (if it is the compress function that does not exist).</source>
          <target state="translated">Если указанные функции сжатия или разжатия отсутствуют,таблица все равно может быть создана.Ошибка не возвращается до тех пор,пока не будет прочитана таблица FTS4 (если функция компрессии не существует)или не будет записана (если функция компрессии не существует).</target>
        </trans-unit>
        <trans-unit id="63eb5c5c72bb1ff543038003d7ef2fd45c2837fe" translate="yes" xml:space="preserve">
          <source>If the specified table is actually a view, an &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; is returned.</source>
          <target state="translated">Если указанная таблица на самом деле является представлением, возвращается &lt;a href=&quot;../rescode&quot;&gt;код ошибки&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ce9d8284bfd79645e82900ecac60c2249827b2a4" translate="yes" xml:space="preserve">
          <source>If the specified table is actually a view, an &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; is returned.</source>
          <target state="translated">Если указанная таблица на самом деле является представлением, возвращается &lt;a href=&quot;rescode&quot;&gt;код ошибки&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7fece2731796046aa37a6f47896457da35d0048d" translate="yes" xml:space="preserve">
          <source>If the specified value is an integer (or text that looks like an integer), it is inserted verbatim. If the value is not a valid UNIX mode, some programs may behave unexpectedly when extracting files from the archive.</source>
          <target state="translated">Если указанное значение является целым числом (или текстом,который выглядит как целое число),то оно вставляется дословно.Если значение не является действительным в UNIX-режиме,некоторые программы могут вести себя неожиданно при извлечении файлов из архива.</target>
        </trans-unit>
        <trans-unit id="e4f3a6c8e56d6f7f8102c0223dc18717b78218c4" translate="yes" xml:space="preserve">
          <source>If the specified view cannot be found and the IF EXISTS clause is not present, it is an error. If the specified view cannot be found and an IF EXISTS clause is present in the DROP VIEW statement, then the statement is a no-op.</source>
          <target state="translated">Если указанный вид не может быть найден и отсутствует пункт IF EXISTS,это является ошибкой.Если указанный вид не может быть найден и в заявлении DROP VIEW присутствует оговорка IF EXISTS,то это заявление недействительно.</target>
        </trans-unit>
        <trans-unit id="90a8c9a64f685446aa6aabbcaddc7d44c89fc5a1" translate="yes" xml:space="preserve">
          <source>If the sqlite3_vtab_nochange(X) routine is called within the &lt;a href=&quot;../vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt; method of a &lt;a href=&quot;../vtab&quot;&gt;virtual table&lt;/a&gt;, then it returns true if and only if the column is being fetched as part of an UPDATE operation during which the column value will not change. Applications might use this to substitute a return value that is less expensive to compute and that the corresponding &lt;a href=&quot;../vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; method understands as a &quot;no-change&quot; value.</source>
          <target state="translated">Если процедура sqlite3_vtab_nochange (X) вызывается в методе &lt;a href=&quot;../vtab#xcolumn&quot;&gt;xColumn &lt;/a&gt;&lt;a href=&quot;../vtab&quot;&gt;виртуальной таблицы&lt;/a&gt; , то она возвращает истину тогда и только тогда, когда столбец извлекается как часть операции UPDATE, во время которой значение столбца не изменится. Приложения могут использовать это для замены возвращаемого значения, которое менее затратно для вычисления и которое соответствующий метод &lt;a href=&quot;../vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; понимает как значение &quot;без изменений&quot;.</target>
        </trans-unit>
        <trans-unit id="589f84e6663e321a54522d9b6141cb9b22a8427e" translate="yes" xml:space="preserve">
          <source>If the sqlite3_vtab_nochange(X) routine is called within the &lt;a href=&quot;vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt; method of a &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt;, then it returns true if and only if the column is being fetched as part of an UPDATE operation during which the column value will not change. Applications might use this to substitute a return value that is less expensive to compute and that the corresponding &lt;a href=&quot;vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; method understands as a &quot;no-change&quot; value.</source>
          <target state="translated">Если процедура sqlite3_vtab_nochange (X) вызывается в методе &lt;a href=&quot;vtab#xcolumn&quot;&gt;xColumn &lt;/a&gt;&lt;a href=&quot;vtab&quot;&gt;виртуальной таблицы&lt;/a&gt; , то она возвращает истину тогда и только тогда, когда столбец извлекается как часть операции UPDATE, во время которой значение столбца не изменится. Приложения могут использовать это для замены возвращаемого значения, которое менее затратно для вычисления и которое соответствующий метод &lt;a href=&quot;vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; понимает как значение &quot;без изменений&quot;.</target>
        </trans-unit>
        <trans-unit id="aeaddc8619c2a7f7c9c53fa9fbcf5b7907cc4bc7" translate="yes" xml:space="preserve">
          <source>If the sqlite_stat1.idx column is NULL, then the sqlite_stat1.stat column contains a single integer which is the approximate number of rows in the table identified by sqlite_stat1.tbl. If the sqlite_stat1.idx column is the same as the sqlite_stat1.tbl column, then the table is a &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; table and the sqlite_stat1.stat field contains information about the index btree that implements the WITHOUT ROWID table.</source>
          <target state="translated">Если столбец sqlite_stat1.idx имеет значение NULL, тогда столбец sqlite_stat1.stat содержит одно целое число, которое представляет собой приблизительное количество строк в таблице, идентифицированной sqlite_stat1.tbl. Если столбец sqlite_stat1.idx совпадает со столбцом sqlite_stat1.tbl, то это таблица &lt;a href=&quot;withoutrowid&quot;&gt;БЕЗ ROWID,&lt;/a&gt; а поле sqlite_stat1.stat содержит информацию об индексном btree, который реализует таблицу БЕЗ ROWID.</target>
        </trans-unit>
        <trans-unit id="7ef8812fff06e258ef45bbe3080d7b83145fdfcb" translate="yes" xml:space="preserve">
          <source>If the sub-query is a compound SELECT, then</source>
          <target state="translated">Если подзапрос является составным SELECT,тогда</target>
        </trans-unit>
        <trans-unit id="95d8d057928b20b8273091a81f8f75e5dc26f5b2" translate="yes" xml:space="preserve">
          <source>If the sub-query is a compound select, then all terms of the ORDER by clause of the parent must be simple references to columns of the sub-query.</source>
          <target state="translated">Если подзапрос является составным выбором,то все условия ЗАПРОСА по пункту родительского должны быть простыми ссылками на столбцы подзапроса.</target>
        </trans-unit>
        <trans-unit id="cfa26eb2d70555062705f5059521f66db3517508" translate="yes" xml:space="preserve">
          <source>If the sub-query is a compound select, then it must not use an ORDER BY clause.</source>
          <target state="translated">Если подзапрос является составным выбором,то он не должен использовать пункт ЗАКАЗАТЬ ПО ЗАКАЗЧИКУ.</target>
        </trans-unit>
        <trans-unit id="a41d547f4cfa21fa6c9e383332bb2ccbe73488d1" translate="yes" xml:space="preserve">
          <source>If the subquery is the right operand of a LEFT JOIN then</source>
          <target state="translated">Если подзапрос является правильным операндом ЛЕВОГО СОВЕТА,тогда</target>
        </trans-unit>
        <trans-unit id="9251592b196cd1f8e1c4b9db367256eca51eaf76" translate="yes" xml:space="preserve">
          <source>If the subquery uses LIMIT then the outer query may not have a WHERE clause.</source>
          <target state="translated">Если в подзапросе используется LIMIT,то внешний запрос может не иметь пункта WHERE.</target>
        </trans-unit>
        <trans-unit id="3915c5066778c0e52bdae49ad9f9428a2640f7be" translate="yes" xml:space="preserve">
          <source>If the subquery uses LIMIT, then the outer query may not be DISTINCT.</source>
          <target state="translated">Если в подзапросе используется LIMIT,то внешний запрос может не быть DISTINCT.</target>
        </trans-unit>
        <trans-unit id="3ca99915e9f2329a546bdb9b1fd10bf3cea382c2" translate="yes" xml:space="preserve">
          <source>If the table has 32 or fewer columns, a single unsigned integer is output for each phrase in the query. The least significant bit of the integer is set if the phrase appears at least once in column 0. The second least significant bit is set if the phrase appears once or more in column 1. And so on.</source>
          <target state="translated">Если в таблице 32 или меньше столбцов,то для каждой фразы в запросе выводится одно неподписанное целое число.Наименьший знаковый бит целого числа задается,если фраза хотя бы раз появляется в столбце 0.Второй наименьший значащий бит задается,если фраза появляется хотя бы один раз или несколько раз в столбце 1.И так далее.</target>
        </trans-unit>
        <trans-unit id="721c91e5cd9182aa981b27d672f91c90481093e6" translate="yes" xml:space="preserve">
          <source>If the table has more than 32 columns, an extra integer is added to the output of each phrase for each extra 32 columns or part thereof. Integers corresponding to the same phrase are clumped together. For example, if a table with 45 columns is queried for two phrases, 4 integers are output. The first corresponds to phrase 0 and columns 0-31 of the table. The second integer contains data for phrase 0 and columns 32-44, and so on.</source>
          <target state="translated">Если таблица содержит более 32 столбцов,то при выводе каждой фразы для каждого лишнего 32 столбца или его части добавляется дополнительное целое число.Целые числа,соответствующие одной и той же фразе,суммируются.Например,если для двух фраз опрашивается таблица,содержащая 45 столбцов,то на выходе получается 4 целых числа.Первое соответствует фразе 0 и столбцам 0-31 таблицы.Второе целое число содержит данные для фразы 0 и столбцов 32-44 и так далее.</target>
        </trans-unit>
        <trans-unit id="dd1a6a322a6da8501607606cd285b56e7643fea3" translate="yes" xml:space="preserve">
          <source>If the table is also a contentless table, the xInstCount, xInst, xPhraseFirst and xPhraseNext APIs behave as if the current row contains no phrase matches at all (i.e. xInstCount() returns 0).</source>
          <target state="translated">Если таблица также является безразличной,то API xInstCount,xInst,xPhraseFirst и xPhraseNext ведут себя так,как если бы текущая строка не содержала фразовых совпадений вообще (т.е.xInstCount()возвращает 0).</target>
        </trans-unit>
        <trans-unit id="6fe44f3588c5a2857dcbb9370708a1c62e0664e1" translate="yes" xml:space="preserve">
          <source>If the table is also a contentless table, the xPhraseFirstColumn and xPhraseNextColumn APIs behave as if the current row contains no phrase matches at all (i.e. xPhraseFirstColumn() sets the iterator to EOF).</source>
          <target state="translated">Если таблица также является бесконкурентной,то API xPhraseFirstColumn и xPhraseNextColumn ведут себя так,как если бы текущая строка не содержала фразовых совпадений вообще (т.е.xPhraseFirstColumn()устанавливает итератор в EOF).</target>
        </trans-unit>
        <trans-unit id="8fa583fa8336ae813a54303aa49ca52aa9df3514" translate="yes" xml:space="preserve">
          <source>If the tables are not compatible, SQLITE_SCHEMA is returned. If the tables are compatible but do not have any PRIMARY KEY columns, it is not an error but no changes are added to the session object. As with other session APIs, tables without PRIMARY KEYs are simply ignored.</source>
          <target state="translated">Если таблицы не совместимы,возвращается SQLITE_SCHEMA.Если таблицы совместимы,но не имеют колонок PRIMARY KEY,это не является ошибкой,но в объект сессии не добавляются никакие изменения.Как и в случае с другими API сессий,таблицы без PRIMARY KEY просто игнорируются.</target>
        </trans-unit>
        <trans-unit id="39d5998574043194036193b1ccfe1d960d708066" translate="yes" xml:space="preserve">
          <source>If the target database table has an INTEGER PRIMARY KEY, it is not possible to insert a NULL value into the IPK column. Attempting to do so results in an SQLITE_MISMATCH error.</source>
          <target state="translated">Если целевая таблица БД имеет INTEGER PRIMARY KEY,то в столбец IPK невозможно вставить NULL-значение.Попытка сделать это приводит к ошибке SQLITE_MISMATCH.</target>
        </trans-unit>
        <trans-unit id="9c95a9c982f66790e65014b945cf26e39c71b898" translate="yes" xml:space="preserve">
          <source>If the target database table is a virtual table or a table that has no PRIMARY KEY declaration, the data_% table must also contain a column named &quot;rbu_rowid&quot;. The rbu_rowid column is mapped to the tables &lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt;. For example, if the target database contains either of the following:</source>
          <target state="translated">Если целевая таблица базы данных является виртуальной таблицей или таблицей, не имеющей объявления PRIMARY KEY, таблица data_% также должна содержать столбец с именем &amp;laquo;rbu_rowid&amp;raquo;. Столбец rbu_rowid отображается в таблицы &lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt; . Например, если целевая база данных содержит одно из следующего:</target>
        </trans-unit>
        <trans-unit id="fbd25358ffefdc6dc4f80487cafab05d3b5b26ee" translate="yes" xml:space="preserve">
          <source>If the target database table is a virtual table or a table with no PRIMARY KEY, the rbu_control value should not include a character corresponding to the rbu_rowid value. For example, this:</source>
          <target state="translated">Если целевая таблица БД является виртуальной таблицей или таблицей без PRIMARY KEY,то значение rbu_control не должно включать символ,соответствующий значению rbu_rowid.Например,это:</target>
        </trans-unit>
        <trans-unit id="01af3a5676cb2f1557deacfea75c22d3ec69c112" translate="yes" xml:space="preserve">
          <source>If the text fragment does not begin at the start of a column value, the &quot;ellipses&quot; text is prepended to it.</source>
          <target state="translated">Если фрагмент текста не начинается с начала значения колонки,то к нему добавляется текст &quot;эллипсов&quot;.</target>
        </trans-unit>
        <trans-unit id="c5699be55281fc6c124864de2ed79fa2e78862fa" translate="yes" xml:space="preserve">
          <source>If the text fragment does not finish at the end of a column value, the &quot;ellipses&quot; text is appended to it.</source>
          <target state="translated">Если фрагмент текста не заканчивается в конце значения колонки,к нему добавляется текст &quot;эллипс&quot;.</target>
        </trans-unit>
        <trans-unit id="9b02a2cc603460380751e873e7881c3872500434" translate="yes" xml:space="preserve">
          <source>If the third parameter (the pointer to the sqlite3_module object) is NULL then no new module is create and any existing modules with the same name are dropped.</source>
          <target state="translated">Если третий параметр (указатель на объект sqlite3_module)равен NULL,то новый модуль не создается и все существующие модули с таким же именем отбрасываются.</target>
        </trans-unit>
        <trans-unit id="1fb42f686bdf0ae2d9460cba55a33f179256de59" translate="yes" xml:space="preserve">
          <source>If the two snapshot handles are not associated with the same database file, the result of the comparison is undefined.</source>
          <target state="translated">Если два дескриптора снимка не связаны с одним и тем же файлом базы данных,результат сравнения будет неопределен.</target>
        </trans-unit>
        <trans-unit id="e40d631505df75eada1d7356f623733efe0e7e84" translate="yes" xml:space="preserve">
          <source>If the value N is out of range or if the N-th parameter is nameless, then NULL is returned. The returned string is always in UTF-8 encoding even if the named parameter was originally specified as UTF-16 in &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16_v2()&lt;/a&gt;, or &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16_v3()&lt;/a&gt;.</source>
          <target state="translated">Если значение N выходит за пределы допустимого диапазона или если N-й параметр не имеет имени, возвращается NULL. Возвращаемая строка всегда имеет кодировку UTF-8, даже если названный параметр изначально был указан как UTF-16 в &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16 ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16_v2 ()&lt;/a&gt; или &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16_v3 ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="345b60970d744b5b63e874a6cd2300d092b35eca" translate="yes" xml:space="preserve">
          <source>If the value N is out of range or if the N-th parameter is nameless, then NULL is returned. The returned string is always in UTF-8 encoding even if the named parameter was originally specified as UTF-16 in &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16()&lt;/a&gt;, &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16_v2()&lt;/a&gt;, or &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16_v3()&lt;/a&gt;.</source>
          <target state="translated">Если значение N выходит за пределы допустимого диапазона или если N-й параметр не имеет имени, возвращается NULL. Возвращаемая строка всегда имеет кодировку UTF-8, даже если названный параметр изначально был указан как UTF-16 в &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16 ()&lt;/a&gt; , &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16_v2 ()&lt;/a&gt; или &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16_v3 ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d68928282b4992ea60ac59e231acaeb89700dde0" translate="yes" xml:space="preserve">
          <source>If the value being substituted is larger than the width, then full value is added to the output. In other words, the width is the minimum width of the value as it is rendered in the output.</source>
          <target state="translated">Если заменяемое значение больше ширины,то на выходе добавляется полное значение.Другими словами,ширина-это минимальная ширина значения в том виде,в каком оно выводится на выходе.</target>
        </trans-unit>
        <trans-unit id="c4b0ded1a1deef22b5fab46f3c6efeda2921b5b8" translate="yes" xml:space="preserve">
          <source>If the value of</source>
          <target state="translated">Если значение</target>
        </trans-unit>
        <trans-unit id="6f9d3eb4af97233320c8cb8d005d76e733f1eb82" translate="yes" xml:space="preserve">
          <source>If the value of a path/value pair is an SQLite TEXT value, then it is normally inserted as a quoted JSON string, even if the string looks like valid JSON. However, if the value is the result of another json1 function (such as &lt;a href=&quot;json1#jmini&quot;&gt;json()&lt;/a&gt; or &lt;a href=&quot;json1#jarray&quot;&gt;json_array()&lt;/a&gt; or &lt;a href=&quot;json1#jobj&quot;&gt;json_object()&lt;/a&gt;) then it is interpreted as JSON and is inserted as JSON retaining all of its substructure.</source>
          <target state="translated">Если значение пары путь / значение является значением SQLite TEXT, то оно обычно вставляется как строка JSON в кавычках, даже если строка выглядит как действительный JSON. Однако, если значение является результатом другой функции json1 (например, &lt;a href=&quot;json1#jmini&quot;&gt;JSON ()&lt;/a&gt; или &lt;a href=&quot;json1#jarray&quot;&gt;json_array ()&lt;/a&gt; или &lt;a href=&quot;json1#jobj&quot;&gt;json_object ()&lt;/a&gt; ) , то он интерпретируется как JSON и вставляется в JSON сохраняя все ее подструктуры.</target>
        </trans-unit>
        <trans-unit id="b32ac49b143ce73b794453377ce559efe5961df7" translate="yes" xml:space="preserve">
          <source>If the value of the zString variable is NULL, the generated SQL will look like the following:</source>
          <target state="translated">Если значение переменной zString равно NULL,то сгенерированный SQL будет выглядеть следующим образом:</target>
        </trans-unit>
        <trans-unit id="8161ccbb4f6a18f526e60b92f180512b88485f22" translate="yes" xml:space="preserve">
          <source>If the values &quot;inserted&quot; into the text columns as part of a 'delete' command are not the same as those currently stored within the table, the results may be unpredictable.</source>
          <target state="translated">Если значения,&quot;вставленные&quot; в текстовые столбцы в рамках команды &quot;удалить&quot;,не совпадают с теми,которые хранятся в данный момент в таблице,то результаты могут быть непредсказуемыми.</target>
        </trans-unit>
        <trans-unit id="59bbe3f4e62b07925a07b5a183754aca1009b0a0" translate="yes" xml:space="preserve">
          <source>If the variable does not have a bytearray representation, then &quot;@&quot; works just like &quot;$&quot;. Note that &quot;:&quot; works like &quot;$&quot; in all cases so the following is another way to express the same statement:</source>
          <target state="translated">Если переменная не имеет представления в байтереях,то &quot;@&quot; работает точно так же,как и &quot;$&quot;.Обратите внимание,что &quot;:&quot; во всех случаях работает как &quot;$&quot;,так что следующий способ выразить то же самое утверждение-это другой способ:</target>
        </trans-unit>
        <trans-unit id="967912701ccde0cf6890cfdea463d69721e44f33" translate="yes" xml:space="preserve">
          <source>If the virtual machine is unable to open the database file because it is locked by another thread or process, &lt;b&gt;sqlite_step&lt;/b&gt; will return SQLITE_BUSY. The calling function should do some other activity, or sleep, for a short amount of time to give the lock a chance to clear, then invoke &lt;b&gt;sqlite_step&lt;/b&gt; again. This can be repeated as many times as desired.</source>
          <target state="translated">Если виртуальной машине не &lt;b&gt;удается&lt;/b&gt; открыть файл базы данных, потому что он заблокирован другим потоком или процессом, &lt;b&gt;sqlite_step&lt;/b&gt; вернет SQLITE_BUSY. Вызывающая функция должна выполнить какое-то другое действие или засыпать на короткое время, чтобы дать блокировке возможность сбросить, а затем снова вызвать &lt;b&gt;sqlite_step&lt;/b&gt; . Это можно повторять сколько угодно раз.</target>
        </trans-unit>
        <trans-unit id="d0cab5be9268823b532780f4620139e0b2493eda" translate="yes" xml:space="preserve">
          <source>If the virtual table contains one or more rows that match the search criteria, then the cursor must be left point at the first row. Subsequent calls to &lt;a href=&quot;vtab#xeof&quot;&gt;xEof&lt;/a&gt; must return false (zero). If there are no rows match, then the cursor must be left in a state that will cause the &lt;a href=&quot;vtab#xeof&quot;&gt;xEof&lt;/a&gt; to return true (non-zero). The SQLite engine will use the &lt;a href=&quot;vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt; and &lt;a href=&quot;vtab#xrowid&quot;&gt;xRowid&lt;/a&gt; methods to access that row content. The &lt;a href=&quot;vtab#xnext&quot;&gt;xNext&lt;/a&gt; method will be used to advance to the next row.</source>
          <target state="translated">Если виртуальная таблица содержит одну или несколько строк, соответствующих критериям поиска, то курсор должен находиться в левой точке первой строки. Последующие вызовы &lt;a href=&quot;vtab#xeof&quot;&gt;xEof&lt;/a&gt; должны возвращать false (ноль). Если совпадений строк нет, курсор необходимо оставить в состоянии, при котором &lt;a href=&quot;vtab#xeof&quot;&gt;xEof&lt;/a&gt; вернет истину (ненулевое значение). Механизм SQLite будет использовать методы &lt;a href=&quot;vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt; и &lt;a href=&quot;vtab#xrowid&quot;&gt;xRowid&lt;/a&gt; для доступа к содержимому этой строки. Метод &lt;a href=&quot;vtab#xnext&quot;&gt;xNext&lt;/a&gt; будет использоваться для перехода к следующей строке.</target>
        </trans-unit>
        <trans-unit id="ad0d9be234c914ee5ff307719c3b70dd43c84d33" translate="yes" xml:space="preserve">
          <source>If the virtual table will output rows in the order specified by the ORDER BY clause, then the orderByConsumed flag may be set to true. If the output is not automatically in the correct order then orderByConsumed must be left in its default false setting. This will indicate to the SQLite core that it will need to do a separate sorting pass over the data after it comes out of the virtual table.</source>
          <target state="translated">Если виртуальная таблица будет выводить строки в порядке,указанном в пункте ORDER BY,то флаг orderByConsumed может быть установлен в true.Если вывод не происходит автоматически в правильном порядке,то флаг OrderByConsumed должен быть оставлен в его настройках по умолчанию false.Это укажет ядру SQLite на то,что после выхода из виртуальной таблицы необходимо будет выполнить отдельную сортировку данных.</target>
        </trans-unit>
        <trans-unit id="40852f77f22b22d25b15aa100b0b83a4fb17d34c" translate="yes" xml:space="preserve">
          <source>If the width is a single &quot;*&quot; character instead of a number, then the actual width value is read as an integer from the argument list. If the value read is negative, then the absolute value is used for the width and the value is left-justified as if the &quot;-&quot; flag were present.</source>
          <target state="translated">Если ширина является одним символом &quot;*&quot;,а не числом,то фактическое значение ширины считывается как целое число из списка аргументов.Если прочитанное значение отрицательное,то для ширины используется абсолютное значение,а значение левое-как если бы присутствовал флаг &quot;-&quot;.</target>
        </trans-unit>
        <trans-unit id="5f665397e9a7b0fe05142c4eb0f952c2d738840c" translate="yes" xml:space="preserve">
          <source>If the xAccess() query required by H35490 reveals that the journal file is still present in the file system, then SQLite shall conclude that the journal file is a</source>
          <target state="translated">Если запрос xAccess(),требуемый H35490,покажет,что файл журнала все еще присутствует в файловой системе,то SQLite сделает вывод,что файл журнала это</target>
        </trans-unit>
        <trans-unit id="2ece4dc60c85bd0f6370651e04aa59f231e6a232" translate="yes" xml:space="preserve">
          <source>If the xColumn method implementation calls none of the functions above, then the value of the column defaults to an SQL NULL.</source>
          <target state="translated">Если реализация метода xColumn не вызывает ни одной из вышеперечисленных функций,то значение столбца по умолчанию равно SQL NULL.</target>
        </trans-unit>
        <trans-unit id="df9512eb02b352fc76419bfac69b024afe92a594" translate="yes" xml:space="preserve">
          <source>If the xCreate method is omitted (left as a NULL pointer) then the virtual table is an &lt;a href=&quot;vtab#epoonlyvtab&quot;&gt;eponymous-only virtual table&lt;/a&gt;. New instances of the virtual table cannot be created using &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; and the virtual table can only be used via its module name. Note that SQLite versions prior to 3.9.0 (2015-10-14) do not understand eponymous-only virtual tables and will segfault if an attempt is made to &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; on an eponymous-only virtual table because the xCreate method was not checked for null.</source>
          <target state="translated">Если метод xCreate опущен (оставлен как NULL-указатель), тогда виртуальная таблица является &lt;a href=&quot;vtab#epoonlyvtab&quot;&gt;одноименной виртуальной таблицей&lt;/a&gt; . Новые экземпляры виртуальной таблицы не могут быть созданы с помощью &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE,&lt;/a&gt; а виртуальная таблица может использоваться только через ее имя модуля. Обратите внимание, что версии SQLite до 3.9.0 (2015-10-14) не понимают виртуальные таблицы только с одноименными именами и будут иметь segfault, если будет сделана попытка &lt;a href=&quot;lang_createvtab&quot;&gt;СОЗДАТЬ ВИРТУАЛЬНУЮ&lt;/a&gt; ТАБЛИЦУ в виртуальной таблице только с одноименным именем, поскольку метод xCreate не был проверен. для null.</target>
        </trans-unit>
        <trans-unit id="2621a8e3fdadffc723f38e49d09955e1039ab97f" translate="yes" xml:space="preserve">
          <source>If the xCreate method is the exact same pointer as the &lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; method, that indicates that the virtual table does not need to initialize backing store. Such a virtual table can be used as an &lt;a href=&quot;vtab#epovtab&quot;&gt;eponymous virtual table&lt;/a&gt; or as a named virtual table using &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; or both.</source>
          <target state="translated">Если метод xCreate - это тот же указатель, что и метод &lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; , это означает, что виртуальной таблице не требуется инициализировать резервное хранилище. Такую виртуальную таблицу можно использовать как &lt;a href=&quot;vtab#epovtab&quot;&gt;одноименную виртуальную таблицу&lt;/a&gt; или как именованную виртуальную таблицу с помощью &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; или обоих.</target>
        </trans-unit>
        <trans-unit id="1ea6013e86112c06dab3e4770a560b43808bcc0c" translate="yes" xml:space="preserve">
          <source>If the xEntryPoint routine encounters an error, it should make *pzErrMsg point to an appropriate error message (obtained from &lt;a href=&quot;#sqlite3_mprintf&quot;&gt;sqlite3_mprintf()&lt;/a&gt;) and return an appropriate &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt;. SQLite ensures that *pzErrMsg is NULL before calling the xEntryPoint(). SQLite will invoke &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free()&lt;/a&gt; on *pzErrMsg after xEntryPoint() returns. If any xEntryPoint() returns an error, the &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open16()&lt;/a&gt;, or &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; call that provoked the xEntryPoint() will fail.</source>
          <target state="translated">Если подпрограмма xEntryPoint обнаруживает ошибку, она должна указать * pzErrMsg на соответствующее сообщение об ошибке (полученное из &lt;a href=&quot;#sqlite3_mprintf&quot;&gt;sqlite3_mprintf ()&lt;/a&gt; ) и вернуть соответствующий &lt;a href=&quot;rescode&quot;&gt;код ошибки&lt;/a&gt; . SQLite гарантирует, что * pzErrMsg имеет значение NULL перед вызовом xEntryPoint (). SQLite вызовет &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free ()&lt;/a&gt; на * pzErrMsg после возврата xEntryPoint (). Если какой-либо xEntryPoint () возвращает ошибку, вызов &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open16 ()&lt;/a&gt; или &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2 ()&lt;/a&gt; , вызвавший xEntryPoint (), завершится ошибкой.</target>
        </trans-unit>
        <trans-unit id="f84dff46c33beaf54e0ca4079880cc37a3fce130" translate="yes" xml:space="preserve">
          <source>If the xEntryPoint routine encounters an error, it should make *pzErrMsg point to an appropriate error message (obtained from &lt;a href=&quot;mprintf&quot;&gt;sqlite3_mprintf()&lt;/a&gt;) and return an appropriate &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt;. SQLite ensures that *pzErrMsg is NULL before calling the xEntryPoint(). SQLite will invoke &lt;a href=&quot;free&quot;&gt;sqlite3_free()&lt;/a&gt; on *pzErrMsg after xEntryPoint() returns. If any xEntryPoint() returns an error, the &lt;a href=&quot;open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;open&quot;&gt;sqlite3_open16()&lt;/a&gt;, or &lt;a href=&quot;open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; call that provoked the xEntryPoint() will fail.</source>
          <target state="translated">Если подпрограмма xEntryPoint обнаруживает ошибку, она должна указать * pzErrMsg на соответствующее сообщение об ошибке (полученное из &lt;a href=&quot;mprintf&quot;&gt;sqlite3_mprintf ()&lt;/a&gt; ) и вернуть соответствующий &lt;a href=&quot;../rescode&quot;&gt;код ошибки&lt;/a&gt; . SQLite гарантирует, что * pzErrMsg имеет значение NULL перед вызовом xEntryPoint (). SQLite вызовет &lt;a href=&quot;free&quot;&gt;sqlite3_free ()&lt;/a&gt; на * pzErrMsg после возврата xEntryPoint (). Если какой-либо xEntryPoint () возвращает ошибку, вызов &lt;a href=&quot;open&quot;&gt;sqlite3_open ()&lt;/a&gt; , &lt;a href=&quot;open&quot;&gt;sqlite3_open16 ()&lt;/a&gt; или &lt;a href=&quot;open&quot;&gt;sqlite3_open_v2 ()&lt;/a&gt; , вызвавший xEntryPoint (), завершится ошибкой.</target>
        </trans-unit>
        <trans-unit id="74fa84b64e4977d1c29908e0f6708d6d082c0af7" translate="yes" xml:space="preserve">
          <source>If the xUpdate method is performing an UPDATE, then &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_nochange(X)&lt;/a&gt; can be used to discover which columns of the virtual table were actually modified by the UPDATE statement. The &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_nochange(X)&lt;/a&gt; interface returns true for columns that do not change. On every UPDATE, SQLite will first invoke &lt;a href=&quot;vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt; separately for each unchanging column in the table to obtain the value for that column. The &lt;a href=&quot;vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt; method can check to see if the column is unchanged at the SQL level by invoking &lt;a href=&quot;c3ref/vtab_nochange&quot;&gt;sqlite3_vtab_nochange()&lt;/a&gt;. If &lt;a href=&quot;vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt; sees that the column is not being modified, it should return without setting a result using one of the &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_xxxxx()&lt;/a&gt; interfaces. Only in that case &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_nochange()&lt;/a&gt; will be true within the xUpdate method. If &lt;a href=&quot;vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt; does invoke one or more &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_xxxxx()&lt;/a&gt; interfaces, then SQLite understands that as a change in the value of the column and the &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_nochange()&lt;/a&gt; call for that column within xUpdate will return false.</source>
          <target state="translated">Если метод xUpdate выполняет UPDATE, то &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_nochange (X)&lt;/a&gt; может использоваться для обнаружения столбцов виртуальной таблицы, которые были фактически изменены оператором UPDATE. Интерфейс &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_nochange (X)&lt;/a&gt; возвращает значение true для столбцов, которые не меняются. При каждом ОБНОВЛЕНИИ SQLite сначала будет вызывать &lt;a href=&quot;vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt; отдельно для каждого неизменного столбца в таблице, чтобы получить значение для этого столбца. Метод &lt;a href=&quot;vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt; может проверить, не изменился ли столбец на уровне SQL, вызвав &lt;a href=&quot;c3ref/vtab_nochange&quot;&gt;sqlite3_vtab_nochange ()&lt;/a&gt; . Если &lt;a href=&quot;vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt; видит, что столбец не изменяется, он должен вернуться без установки результата с помощью одного из &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_xxxxx ()&lt;/a&gt;интерфейсы. Только в этом случае &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_nochange ()&lt;/a&gt; будет истинным в методе xUpdate. Если &lt;a href=&quot;vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt; вызывает один или несколько интерфейсов &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_xxxxx ()&lt;/a&gt; , то SQLite понимает это как изменение значения столбца и вызов &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_nochange ()&lt;/a&gt; для этого столбца в xUpdate вернет false.</target>
        </trans-unit>
        <trans-unit id="7b85064db380f0c3b1175d1e7fe24a5bdf881bd8" translate="yes" xml:space="preserve">
          <source>If the xUpdate method violates some constraint of the virtual table (including, but not limited to, attempting to store a value of the wrong datatype, attempting to store a value that is too large or too small, or attempting to change a read-only value) then the xUpdate must fail with an appropriate &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt;.</source>
          <target state="translated">Если метод xUpdate нарушает какое-либо ограничение виртуальной таблицы (включая, помимо прочего, попытку сохранить значение неправильного типа данных, попытку сохранить слишком большое или слишком маленькое значение или попытаться изменить значение только для чтения) value), то xUpdate должен завершиться ошибкой с соответствующим &lt;a href=&quot;rescode&quot;&gt;кодом&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9a7985513fccd145b507f142e6f37dfce68e7177" translate="yes" xml:space="preserve">
          <source>If the zString variable holds text like &quot;Hello&quot;, then this statement will work just fine. But suppose the user enters a string like &quot;Hi y'all!&quot;. The SQL statement generated reads as follows:</source>
          <target state="translated">Если переменная zString содержит текст типа &quot;Hello&quot;,то это утверждение будет работать просто отлично.Но допустим,что пользователь вводит строку типа &quot;Привет всем!&quot;.Сгенерированный SQL-оператор выглядит следующим образом:</target>
        </trans-unit>
        <trans-unit id="38c9c0042a5b1d208534216bf07dfb6099f9ebb4" translate="yes" xml:space="preserve">
          <source>If there are many client programs sending SQL to the same database over a network, then use a client/server database engine instead of SQLite. SQLite will work over a network filesystem, but because of the latency associated with most network filesystems, performance will not be great. Also, file locking logic is buggy in many network filesystem implementations (on both Unix and Windows). If file locking does not work correctly, two or more clients might try to modify the same part of the same database at the same time, resulting in corruption. Because this problem results from bugs in the underlying filesystem implementation, there is nothing SQLite can do to prevent it.</source>
          <target state="translated">Если существует много клиентских программ,посылающих SQL в одну и ту же базу данных по сети,то используйте движок клиент/сервер базы данных вместо SQLite.SQLite будет работать через сетевую файловую систему,но из-за задержек,связанных с большинством сетевых файловых систем,производительность будет не очень высокой.Кроме того,во многих реализациях сетевых файловых систем (как на Unix,так и на Windows)логика блокировки файлов является ошибочной.Если блокировка файлов работает некорректно,два или более клиента могут попытаться изменить одну и ту же часть одной и той же базы данных одновременно,что приведет к ее повреждению.Так как эта проблема возникает из-за ошибок в базовой файловой системе,SQLite ничего не может сделать для ее предотвращения.</target>
        </trans-unit>
        <trans-unit id="36f4c3a2fda5cf31617c5fabae95e90bafd39057" translate="yes" xml:space="preserve">
          <source>If there are multiple (hard or symbolic) links to a database file, the journal will be created using the name of the link through which the file was opened. If a crash occurs and the database is opened again using a different link, the hot journal will not be located and no rollback will occur.</source>
          <target state="translated">Если существует несколько (жестких или символических)ссылок на файл базы данных,то журнал будет создан по имени ссылки,через которую был открыт файл.Если произойдет сбой и база данных будет открыта снова по другой ссылке,то горячий журнал не будет расположен и отката не произойдет.</target>
        </trans-unit>
        <trans-unit id="11044e3b942016886a776e1bab1892306cb966d9" translate="yes" xml:space="preserve">
          <source>If there are still more pages to copy from database pDb, then the function sleeps for 250 milliseconds (using the &lt;a href=&quot;c3ref/sleep&quot;&gt;sqlite3_sleep()&lt;/a&gt; utility) and then returns to step 2.</source>
          <target state="translated">Если есть еще несколько страниц для копирования из базы данных pDb, функция отключается на 250 миллисекунд (с помощью утилиты &lt;a href=&quot;c3ref/sleep&quot;&gt;sqlite3_sleep ()&lt;/a&gt; ), а затем возвращается к шагу 2.</target>
        </trans-unit>
        <trans-unit id="afce5a653d0b42c7793177067bc50ad86675aae0" translate="yes" xml:space="preserve">
          <source>If there exists an index that maps the &quot;two&quot; column of the &quot;examp&quot; table into integers, then SQLite will use that index to find the integer keys of all rows in examp that have a value of 50 for column two, or all rows that are less than 50, etc. But the following queries cannot use the index:</source>
          <target state="translated">Если существует индекс,который отображает столбец &quot;два&quot; таблицы &quot;экзамен&quot; на целые числа,то SQLite будет использовать этот индекс для поиска целых ключей всех строк экзамена,которые имеют значение 50 для столбца &quot;два&quot;,или всех строк,которые имеют значение менее 50,и т.д.Но следующие запросы не могут использовать индекс:</target>
        </trans-unit>
        <trans-unit id="856948c8edddeced0c9cafe3bd0f42f4ee0fc501" translate="yes" xml:space="preserve">
          <source>If there has been one or more REPLACE resolutions on a key, it is rebased according to a REPLACE.</source>
          <target state="translated">Если существовала одна или более резолюций РЕПЛАКЕ по ключу,то она пересматривается в соответствии с РЕПЛАКЕ.</target>
        </trans-unit>
        <trans-unit id="4dc77fa5e92703a982360848038ee795cce33659" translate="yes" xml:space="preserve">
          <source>If there have been no REPLACE resolutions on a key, then the local changeset is rebased according to the most recent of the OMIT resolutions.</source>
          <target state="translated">Если не было резолюций REPLACE по какому-либо ключу,то локальный changeset пересматривается в соответствии с самыми последними резолюциями OMIT.</target>
        </trans-unit>
        <trans-unit id="b7ee1d4caced0cc280acbdfbbd3da7974e0aedc7" translate="yes" xml:space="preserve">
          <source>If there is a USING clause then each of the column names specified must exist in the datasets to both the left and right of the join-operator. For each pair of named columns, the expression &quot;lhs.X = rhs.X&quot; is evaluated for each row of the cartesian product as a &lt;a href=&quot;lang_expr#booleanexpr&quot;&gt;boolean expression&lt;/a&gt;. Only rows for which all such expressions evaluates to true are included from the result set. When comparing values as a result of a USING clause, the normal rules for handling affinities, collation sequences and NULL values in comparisons apply. The column from the dataset on the left-hand side of the join-operator is considered to be on the left-hand side of the comparison operator (=) for the purposes of collation sequence and affinity precedence.</source>
          <target state="translated">Если есть предложение USING, то каждое из указанных имен столбцов должно существовать в наборах данных как слева, так и справа от оператора соединения. Для каждой пары именованных столбцов выражение &amp;laquo;lhs.X = rhs.X&amp;raquo; оценивается для каждой строки декартова произведения как &lt;a href=&quot;lang_expr#booleanexpr&quot;&gt;логическое выражение&lt;/a&gt; . Из набора результатов включаются только строки, для которых все такие выражения имеют значение true. При сравнении значений в результате предложения USING применяются обычные правила обработки аффинностей, последовательностей сопоставления и значений NULL в сравнениях. Столбец из набора данных в левой части оператора соединения считается находящимся в левой части оператора сравнения (=) в целях последовательности сортировки и приоритета сродства.</target>
        </trans-unit>
        <trans-unit id="d234388212b95e999640f17f4b156605cf6f600f" translate="yes" xml:space="preserve">
          <source>If there is already a read transaction open when this function is invoked, then the same read transaction remains open (on the same database snapshot) if SQLITE_ERROR, SQLITE_BUSY or SQLITE_ERROR_SNAPSHOT is returned. If another error code - for example SQLITE_PROTOCOL or an SQLITE_IOERR error code - is returned, then the final state of the read transaction is undefined. If SQLITE_OK is returned, then the read transaction is now open on database snapshot P.</source>
          <target state="translated">Если при вызове этой функции уже была открыта прочитанная транзакция,то при возвращении SQLITE_ERROR,SQLITE_BUSY или SQLITE_ERROR_SNAPSHOT та же самая прочитанная транзакция остается открытой (на том же снимке базы данных).Если возвращается другой код ошибки-например,SQLITE_PROTOCOL или код ошибки SQLITE_IOERR,то конечное состояние прочитанной транзакции является неопределенным.Если возвращается SQLITE_OK,то прочитанная транзакция теперь открыта на снимке P базы данных.</target>
        </trans-unit>
        <trans-unit id="b3ba606d14be7904e644a6f345ba54604a8e5ba7" translate="yes" xml:space="preserve">
          <source>If there is already an auxiliary data pointer when this function is invoked, then it is replaced by the new pointer. If an xDelete callback was specified along with the original pointer, it is invoked at this point.</source>
          <target state="translated">Если при вызове этой функции уже имеется вспомогательный указатель на данные,то он заменяется на новый указатель.Если указатель xDelete был указан вместе с исходным указателем,то он вызывается в этот момент.</target>
        </trans-unit>
        <trans-unit id="7d3f7f6da384d18458af17b6bbb473e63bd6c0a4" translate="yes" xml:space="preserve">
          <source>If there is an AS clause on the result, then the name of the column is the right-hand side of the AS clause.</source>
          <target state="translated">Если в результате имеется оговорка об АО,то название столбца-правая часть оговорки об АО.</target>
        </trans-unit>
        <trans-unit id="ea4985ea47701fb618426a82280d62d99731524f" translate="yes" xml:space="preserve">
          <source>If there is an ON clause then the ON expression is evaluated for each row of the cartesian product as a &lt;a href=&quot;lang_expr#booleanexpr&quot;&gt;boolean expression&lt;/a&gt;. Only rows for which the expression evaluates to true are included from the dataset.</source>
          <target state="translated">Если есть предложение ON, то выражение ON оценивается для каждой строки декартова произведения как &lt;a href=&quot;lang_expr#booleanexpr&quot;&gt;логическое выражение&lt;/a&gt; . Из набора данных включаются только строки, для которых выражение оценивается как истинное.</target>
        </trans-unit>
        <trans-unit id="2e70dfed6b6c48ce8dce24e64f939fa0229381a9" translate="yes" xml:space="preserve">
          <source>If there is no compatible table, it is not an error, but none of the changes associated with the table are applied. A warning message is issued via the sqlite3_log() mechanism with the error code SQLITE_SCHEMA. At most one such warning is issued for each table in the changeset.</source>
          <target state="translated">Если нет совместимой таблицы,это не ошибка,но ни одно из изменений,связанных с таблицей,не применяется.Предупреждение выдается через механизм sqlite3_log()с кодом ошибки SQLITE_SCHEMA.Максимум одно такое предупреждение выдается для каждой таблицы в changeset.</target>
        </trans-unit>
        <trans-unit id="8b1f218c8fcc4cd8280015ffb23038ba539a45b9" translate="yes" xml:space="preserve">
          <source>If there is no index named</source>
          <target state="translated">Если нет индекса с именем</target>
        </trans-unit>
        <trans-unit id="5f851a7381e365ca34ec1852c08b2f940f8860fc" translate="yes" xml:space="preserve">
          <source>If there is no selftest table, the &quot;.selftest&quot; command runs &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt;.</source>
          <target state="translated">Если таблицы самопроверки нет, команда &quot;.selftest&quot; запускает &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA Integrity_check&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c042772d4bc73bd02a9ce067deaf034251147e0f" translate="yes" xml:space="preserve">
          <source>If there is only a single table or subquery in the FROM clause, then the input data used by the SELECT statement is the contents of the named table. If there is more than one table or subquery in FROM clause then the contents of all tables and/or subqueries are joined into a single dataset for the simple SELECT statement to operate on. Exactly how the data is combined depends on the specific &lt;a href=&quot;syntax/join-operator&quot;&gt;join-operator&lt;/a&gt; and &lt;a href=&quot;syntax/join-constraint&quot;&gt;join-constraint&lt;/a&gt; used to connect the tables or subqueries together.</source>
          <target state="translated">Если в предложении FROM есть только одна таблица или подзапрос, то входные данные, используемые оператором SELECT, являются содержимым указанной таблицы. Если в предложении FROM есть более одной таблицы или подзапроса, то содержимое всех таблиц и / или подзапросов объединяется в один набор данных для работы с простым оператором SELECT. Точно , как данные объединяются , зависят от конкретного &lt;a href=&quot;syntax/join-operator&quot;&gt;нарисуйте оператор&lt;/a&gt; и &lt;a href=&quot;syntax/join-constraint&quot;&gt;нарисуйте ограничение&lt;/a&gt; , используемое для подключения таблиц или подзапросов вместе.</target>
        </trans-unit>
        <trans-unit id="4c64aa9b4e57f38edc6d2ba80d1689a5d372c4ee" translate="yes" xml:space="preserve">
          <source>If these routines are called from within the different thread than the one containing the application-defined function that received the &lt;a href=&quot;#sqlite3_context&quot;&gt;sqlite3_context&lt;/a&gt; pointer, the results are undefined.</source>
          <target state="translated">Если эти подпрограммы вызываются из другого потока, чем тот, который содержит определяемую приложением функцию, получившую указатель &lt;a href=&quot;#sqlite3_context&quot;&gt;sqlite3_context&lt;/a&gt; , результаты не определены.</target>
        </trans-unit>
        <trans-unit id="cd8848554ca2d7f3d01b722c239f1dc6287ba93f" translate="yes" xml:space="preserve">
          <source>If these routines are called from within the different thread than the one containing the application-defined function that received the &lt;a href=&quot;context&quot;&gt;sqlite3_context&lt;/a&gt; pointer, the results are undefined.</source>
          <target state="translated">Если эти подпрограммы вызываются из другого потока, чем тот, который содержит определяемую приложением функцию, получившую указатель &lt;a href=&quot;context&quot;&gt;sqlite3_context&lt;/a&gt; , результаты не определены.</target>
        </trans-unit>
        <trans-unit id="915164f8017ef4e64adbf0d45fa62da4e11e9b32" translate="yes" xml:space="preserve">
          <source>If this C-preprocessor macro disables the &quot;deferred token&quot; optimization in &lt;a href=&quot;fts3#fts4&quot;&gt;FTS4&lt;/a&gt;. The &quot;deferred token&quot; optimization avoids loading massive posting lists for terms that are in most documents of the collection and instead simply scans for those tokens in the document source. &lt;a href=&quot;fts3#fts4&quot;&gt;FTS4&lt;/a&gt; should get exactly the same answer both with and without this optimization.</source>
          <target state="translated">Если этот макрос препроцессора C отключает оптимизацию &amp;laquo;отложенного токена&amp;raquo; в &lt;a href=&quot;fts3#fts4&quot;&gt;FTS4&lt;/a&gt; . Оптимизация &amp;laquo;отложенного токена&amp;raquo; позволяет избежать загрузки массивных списков рассылки для терминов, которые присутствуют в большинстве документов коллекции, а вместо этого просто сканирует эти токены в источнике документа. &lt;a href=&quot;fts3#fts4&quot;&gt;FTS4&lt;/a&gt; должен получить точно такой же ответ как с этой оптимизацией, так и без нее .</target>
        </trans-unit>
        <trans-unit id="ae29c8f0136956324cb9875e314002993d7a9c98" translate="yes" xml:space="preserve">
          <source>If this C-preprocessor macro is defined and if the xDeviceCharacteristics method of &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object for a database file reports (via one of the &lt;a href=&quot;c3ref/c_iocap_atomic&quot;&gt;SQLITE_IOCAP_ATOMIC&lt;/a&gt; bits) that the filesystem supports atomic writes and if a transaction involves a change to only a single page of the database file, then the transaction commits with just a single write request of a single page of the database and no rollback journal is created or written. On filesystems that support atomic writes, this optimization can result in significant speed improvements for small updates. However, few filesystems support this capability and the code paths that check for this capability slow down write performance on systems that lack atomic write capability, so this feature is disabled by default.</source>
          <target state="translated">Если этот макрос препроцессора C определен и если метод xDeviceCharacteristics объекта &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; для файла базы данных сообщает (через один из битов &lt;a href=&quot;c3ref/c_iocap_atomic&quot;&gt;SQLITE_IOCAP_ATOMIC&lt;/a&gt; ), что файловая система поддерживает атомарные записи, и если транзакция включает изменение только одной страницы базы данных файла, то транзакция фиксируется с помощью всего одного запроса на запись одной страницы базы данных, и журнал отката не создается и не записывается. В файловых системах, поддерживающих атомарную запись, эта оптимизация может привести к значительному увеличению скорости небольших обновлений. Однако немногие файловые системы поддерживают эту возможность, а пути кода, которые проверяют эту возможность, снижают производительность записи в системах, в которых отсутствует возможность атомарной записи, поэтому эта функция по умолчанию отключена.</target>
        </trans-unit>
        <trans-unit id="f74239b5b9713fd263bba27dcb07765bb74b0239" translate="yes" xml:space="preserve">
          <source>If this C-preprocessor macro is defined, directory syncs are disabled. SQLite typically attempts to sync the parent directory when a file is deleted to ensure the directory entries are updated immediately on disk.</source>
          <target state="translated">Если данный макрос C-препроцессора определен,синхронизация каталогов отключается.SQLite обычно пытается синхронизировать родительский каталог при удалении файла,чтобы обеспечить немедленное обновление записей каталога на диске.</target>
        </trans-unit>
        <trans-unit id="5737b83035ce500dcfa496d2b2b66e0845cad862" translate="yes" xml:space="preserve">
          <source>If this C-preprocessor macro is defined, large file support is disabled.</source>
          <target state="translated">Если данный макрос C-препроцессора определен,то поддержка больших файлов отключается.</target>
        </trans-unit>
        <trans-unit id="262e2217c94b5b2f3ea64e55aebf18183a8f388a" translate="yes" xml:space="preserve">
          <source>If this C-preprocessor macro is defined, the &lt;a href=&quot;fts3#unicode61&quot;&gt;unicode61&lt;/a&gt; tokenizer in &lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt; is omitted from the build and is unavailable to applications.</source>
          <target state="translated">Если этот макрос препроцессора C определен, &lt;a href=&quot;fts3#unicode61&quot;&gt;токенизатор&lt;/a&gt; unicode61 в &lt;a href=&quot;fts3&quot;&gt;FTS3 не&lt;/a&gt; включается в сборку и недоступен для приложений.</target>
        </trans-unit>
        <trans-unit id="39617688d9840b06235bc5d306b07bb0ba889ba9" translate="yes" xml:space="preserve">
          <source>If this C-preprocessor macro is defined, then extra code is included that allows SQLite to function on a filesystem that only support 8+3 filenames. If the value of this macro is 1, then the default behavior is to continue to use long filenames and to only use 8+3 filenames if the database connection is opened using &lt;a href=&quot;uri&quot;&gt;URI filenames&lt;/a&gt; with the &quot;&lt;code&gt;8_3_names=1&lt;/code&gt;&quot; query parameter. If the value of this macro is 2, then the use of 8+3 filenames becomes the default but may be disabled on using the &lt;code&gt;8_3_names=0&lt;/code&gt; query parameter.</source>
          <target state="translated">Если этот макрос препроцессора C определен, то включается дополнительный код, который позволяет SQLite работать в файловой системе, которая поддерживает только 8 + 3 имен файлов. Если значение этого макроса равно 1, то поведение по умолчанию - продолжать использовать длинные имена файлов и использовать только 8 + 3 имен файлов, если соединение с базой данных открывается с использованием &lt;a href=&quot;uri&quot;&gt;имен файлов URI&lt;/a&gt; с параметром запроса &amp;laquo; &lt;code&gt;8_3_names=1&lt;/code&gt; &amp;raquo;. Если значение этого макроса равно 2, то использование 8 + 3 имен файлов становится значением по умолчанию, но может быть отключено с помощью параметра запроса &lt;code&gt;8_3_names=0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ad3d89f2752a79cf47c58e04a726219583d11898" translate="yes" xml:space="preserve">
          <source>If this SELECT returns any rows at all, then SQLite concludes that deleting the row from the parent table would violate the foreign key constraint and returns an error. Similar queries may be run if the content of the parent key is modified or a new row is inserted into the parent table. If these queries cannot use an index, they are forced to do a linear scan of the entire child table. In a non-trivial database, this may be prohibitively expensive.</source>
          <target state="translated">Если этот SELECT возвращает какие-то строки вообще,то SQLite приходит к выводу,что удаление строки из родительской таблицы нарушит ограничение постороннего ключа и возвращает ошибку.Аналогичные запросы могут быть выполнены,если содержимое родительского ключа изменено или в родительскую таблицу вставлена новая строка.Если эти запросы не могут использовать индекс,они вынуждены выполнять линейное сканирование всей дочерней таблицы.В нетривиальной базе данных это может оказаться непомерно дорогостоящим.</target>
        </trans-unit>
        <trans-unit id="1a76560d5f1317c75f52d66cf33f56778e31d3b4" translate="yes" xml:space="preserve">
          <source>If this expression returns a non-zero value N, then there exists an embedded NUL at the N-th character position. Thus to count the number fo rows that contain embedded NUL characters:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f0db89932b716eb4d510a7bedc168db8c08402a" translate="yes" xml:space="preserve">
          <source>If this extension is compiled with -DSQLITE_CKSUMVFS_STATIC and statically linked against the application, initialize it using a single API call as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8ee4bc759bb4de0d55341a4133e995c0e985e4b" translate="yes" xml:space="preserve">
          <source>If this extension is compiled with the SQLITE_ENABLE_ICU pre-processor symbol defined, then there exists a built-in tokenizer named &quot;icu&quot; implemented using the ICU library. The first argument passed to the xCreate() method (see fts3_tokenizer.h) of this tokenizer may be an ICU locale identifier. For example &quot;tr_TR&quot; for Turkish as used in Turkey, or &quot;en_AU&quot; for English as used in Australia. For example:</source>
          <target state="translated">Если данное расширение скомпилировано с определенным символом препроцессора SQLITE_ENABLE_ICU,то существует встроенный токенайзер с именем &quot;icu&quot;,реализованный с помощью библиотеки ICU.Первым аргументом,переданным в метод xCreate()(см.fts3_tokenizer.h)этого токенайзера,может быть идентификатор локали ICU.Например,&quot;tr_TR&quot; для турецкого языка,используемого в Турции,или &quot;en_AU&quot; для английского языка,используемого в Австралии.Например:</target>
        </trans-unit>
        <trans-unit id="d023458a29576f7575443a7b9afec6275af3fcf1" translate="yes" xml:space="preserve">
          <source>If this function is called when the iterator does not point to a valid entry, SQLITE_MISUSE is returned and the output variables zeroed. Otherwise, SQLITE_OK is returned and the output variables populated as described above.</source>
          <target state="translated">Если эта функция вызывается,когда итератор не указывает на действительную запись,возвращается SQLITE_MISUSE и обнуляются выходные переменные.В противном случае возвращается SQLITE_OK и выходные переменные заполняются,как описано выше.</target>
        </trans-unit>
        <trans-unit id="575c4fba56a8b3b5c139b07c2f0bb05a15bdbd1b" translate="yes" xml:space="preserve">
          <source>If this function needs to obtain extra database locks before dirty pages can be flushed to disk, it does so. If those locks cannot be obtained immediately and there is a busy-handler callback configured, it is invoked in the usual manner. If the required lock still cannot be obtained, then the database is skipped and an attempt made to flush any dirty pages belonging to the next (if any) database. If any databases are skipped because locks cannot be obtained, but no other error occurs, this function returns SQLITE_BUSY.</source>
          <target state="translated">Если этой функции необходимо получить дополнительные блокировки базы данных до того,как грязные страницы могут быть записаны на диск,она делает это.Если эти блокировки не могут быть получены немедленно и настроен обратный вызов обработчика,то он вызывается обычным образом.Если необходимая блокировка все еще не может быть получена,то база данных пропускается и делается попытка смыть любые грязные страницы,принадлежащие следующей (если таковая имеется)базе данных.Если какие-либо базы данных пропускаются из-за невозможности получения блокировок,но других ошибок не происходит,данная функция возвращает SQLITE_BUSY.</target>
        </trans-unit>
        <trans-unit id="4a59fbb2ab0548034e0f0c93999e3d83e86e0a83" translate="yes" xml:space="preserve">
          <source>If this global variable is made to point to a string which is the name of a folder (a.k.a. directory), then all database files specified with a relative pathname and created or accessed by SQLite when using a built-in windows &lt;a href=&quot;#sqlite3_vfs&quot;&gt;VFS&lt;/a&gt; will be assumed to be relative to that directory. If this variable is a NULL pointer, then SQLite assumes that all database files specified with a relative pathname are relative to the current directory for the process. Only the windows VFS makes use of this global variable; it is ignored by the unix VFS.</source>
          <target state="translated">Если эта глобальная переменная указывает на строку, которая является именем папки (также известной как каталог), тогда все файлы базы данных, указанные с относительным путем и созданные или доступные SQLite при использовании встроенной Windows &lt;a href=&quot;#sqlite3_vfs&quot;&gt;VFS,&lt;/a&gt; будут считаться относиться к этому каталогу. Если эта переменная является указателем NULL, то SQLite предполагает, что все файлы базы данных, указанные с относительным путем, относятся к текущему каталогу для процесса. Только Windows VFS использует эту глобальную переменную; он игнорируется UNIX VFS.</target>
        </trans-unit>
        <trans-unit id="84ebd8e9c186529f8ee21c34bc9c7d688ed08739" translate="yes" xml:space="preserve">
          <source>If this global variable is made to point to a string which is the name of a folder (a.k.a. directory), then all database files specified with a relative pathname and created or accessed by SQLite when using a built-in windows &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; will be assumed to be relative to that directory. If this variable is a NULL pointer, then SQLite assumes that all database files specified with a relative pathname are relative to the current directory for the process. Only the windows VFS makes use of this global variable; it is ignored by the unix VFS.</source>
          <target state="translated">Если эта глобальная переменная указывает на строку, которая является именем папки (также известной как каталог), тогда все файлы базы данных, указанные с относительным путем и созданные или доступные SQLite при использовании встроенной Windows &lt;a href=&quot;vfs&quot;&gt;VFS,&lt;/a&gt; будут считаться относиться к этому каталогу. Если эта переменная является указателем NULL, то SQLite предполагает, что все файлы базы данных, указанные с относительным путем, относятся к текущему каталогу для процесса. Только Windows VFS использует эту глобальную переменную; он игнорируется UNIX VFS.</target>
        </trans-unit>
        <trans-unit id="ae61adf99b3e9cfc86e28932de2b54c5d4c9e28e" translate="yes" xml:space="preserve">
          <source>If this global variable is made to point to a string which is the name of a folder (a.k.a. directory), then all temporary files created by SQLite when using a built-in &lt;a href=&quot;#sqlite3_vfs&quot;&gt;VFS&lt;/a&gt; will be placed in that directory. If this variable is a NULL pointer, then SQLite performs a search for an appropriate temporary file directory.</source>
          <target state="translated">Если эта глобальная переменная указывает на строку, которая является именем папки (также известной как каталог), тогда все временные файлы, созданные SQLite при использовании встроенной &lt;a href=&quot;#sqlite3_vfs&quot;&gt;VFS,&lt;/a&gt; будут помещены в этот каталог. Если эта переменная является указателем NULL, то SQLite выполняет поиск соответствующего временного каталога файлов.</target>
        </trans-unit>
        <trans-unit id="2fef70c16016d67dc3025afd347c1e52be3b317a" translate="yes" xml:space="preserve">
          <source>If this global variable is made to point to a string which is the name of a folder (a.k.a. directory), then all temporary files created by SQLite when using a built-in &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; will be placed in that directory. If this variable is a NULL pointer, then SQLite performs a search for an appropriate temporary file directory.</source>
          <target state="translated">Если эта глобальная переменная указывает на строку, которая является именем папки (также известной как каталог), тогда все временные файлы, созданные SQLite при использовании встроенной &lt;a href=&quot;vfs&quot;&gt;VFS,&lt;/a&gt; будут помещены в этот каталог. Если эта переменная является указателем NULL, то SQLite выполняет поиск соответствующего временного каталога файлов.</target>
        </trans-unit>
        <trans-unit id="377f589c93b8d1620f4832f74e589324c623fda3" translate="yes" xml:space="preserve">
          <source>If this interface is invoked outside the context of an xConnect or xCreate virtual table method then the behavior is undefined.</source>
          <target state="translated">Если этот интерфейс вызывается вне контекста метода xConnect или xCreate виртуальной таблицы,то поведение не определено.</target>
        </trans-unit>
        <trans-unit id="16ae3ddca07ff1751105a0aea6145c79101d244a" translate="yes" xml:space="preserve">
          <source>If this macro is defined to a positive integer</source>
          <target state="translated">Если этот макрос определен в положительное целое число</target>
        </trans-unit>
        <trans-unit id="5cc647c8428edf625b094fb0de5d9a7c439f06d1" translate="yes" xml:space="preserve">
          <source>If this macro is defined, then the special &quot;$</source>
          <target state="translated">Если этот макрос определен,то специальный &quot;$</target>
        </trans-unit>
        <trans-unit id="53c0130971cedde038e298ffc488f5a86580ab11" translate="yes" xml:space="preserve">
          <source>If this option is defined, SQLite's built-in date and time manipulation functions are omitted. Specifically, the SQL functions julianday(), date(), time(), datetime() and strftime() are not available. The default column values CURRENT_TIME, CURRENT_DATE and CURRENT_TIMESTAMP are still available.</source>
          <target state="translated">Если эта опция определена,то встроенные в SQLite функции манипулирования датой и временем опускаются.В частности,функции SQL julianday(),date(),time(),datetime()и strftime()недоступны.Значения столбцов по умолчанию CURRENT_TIME,CURRENT_DATE и CURRENT_TIMESTAMP все еще доступны.</target>
        </trans-unit>
        <trans-unit id="3a2de06267117d8a8013c26631a2b4a79f2165b1" translate="yes" xml:space="preserve">
          <source>If this option is defined, the library cannot create or write to databases that support &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum&lt;/a&gt;. Executing a &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;PRAGMA auto_vacuum&lt;/a&gt; statement is not an error (since unknown PRAGMAs are silently ignored), but does not return a value or modify the auto-vacuum flag in the database file. If a database that supports auto-vacuum is opened by a library compiled with this option, it is automatically opened in read-only mode.</source>
          <target state="translated">Если этот параметр определен, библиотека не может создавать или записывать в базы данных, поддерживающие &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum&lt;/a&gt; . Выполнение оператора &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;PRAGMA auto_vacuum&lt;/a&gt; не является ошибкой (поскольку неизвестные PRAGMA автоматически игнорируются), но не возвращает значение и не изменяет флаг автоматического вакуумирования в файле базы данных. Если база данных, поддерживающая автоматический вакуум, открывается библиотекой, скомпилированной с этим параметром, она автоматически открывается в режиме только для чтения.</target>
        </trans-unit>
        <trans-unit id="0d1cff91ceb786cc24acfd1c107d786b9aaa0367" translate="yes" xml:space="preserve">
          <source>If this option is defined, then &lt;a href=&quot;foreignkeys&quot;&gt;foreign key constraint&lt;/a&gt; syntax is not recognized.</source>
          <target state="translated">Если этот параметр определен, то синтаксис &lt;a href=&quot;foreignkeys&quot;&gt;ограничения внешнего ключа&lt;/a&gt; не распознается.</target>
        </trans-unit>
        <trans-unit id="6e68b63912f5ef9b57357a53a1d6030e0a438ede" translate="yes" xml:space="preserve">
          <source>If this option is defined, then &lt;a href=&quot;gencol&quot;&gt;generated column&lt;/a&gt; syntax is not recognized.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de1fe97e82a4364864c18ee6d16ca1ab17fe291c" translate="yes" xml:space="preserve">
          <source>If this option is defined, then it must also be defined when using the &lt;a href=&quot;lemon&quot;&gt;Lemon parser generator&lt;/a&gt; tool to generate a parse.c file. Because of this, this option may only be used when the library is built from source, not from the &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt; or from the collection of pre-packaged C files provided for non-Unix like platforms on the website.</source>
          <target state="translated">Если этот параметр определен, то он также должен быть определен при использовании инструмента &lt;a href=&quot;lemon&quot;&gt;генератора синтаксического анализатора Lemon&lt;/a&gt; для создания файла parse.c. Из-за этого этот параметр может использоваться только в том случае, если библиотека построена из исходного кода, а не из &lt;a href=&quot;amalgamation&quot;&gt;объединения&lt;/a&gt; или коллекции предварительно упакованных файлов C, предоставленных на веб-сайте для платформ, отличных от Unix.</target>
        </trans-unit>
        <trans-unit id="391001eddc6a6f9380d8efca6c5990bffd30c02d" translate="yes" xml:space="preserve">
          <source>If this option is enabled, then the alloca() memory allocator will be used in a few situations where it is appropriate. This results in a slightly smaller and faster binary. The SQLITE_USE_ALLOCA compile-time only only works, of course, on systems that support alloca().</source>
          <target state="translated">Если эта опция включена,то аллокатор памяти alloca()будет использоваться в нескольких ситуациях,когда это уместно.В результате получается немного меньший по размеру и более быстрый двоичный файл.Время компиляции SQLITE_USE_ALLOCA работает,конечно,только на системах,поддерживающих функцию alloca().</target>
        </trans-unit>
        <trans-unit id="0a7cb0c994326370629ee23298fc6078fa599fa4" translate="yes" xml:space="preserve">
          <source>If this option is enabled, then the alloca() memory allocator will be used in a few situations where it is appropriate. This results in a slightly smaller and faster binary. The SQLITE_USE_ALLOCA compile-time only works, of course, on systems that support alloca().</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e396be7869391838487d1744007a3e656f8af09d" translate="yes" xml:space="preserve">
          <source>If this option is passed a non-zero argument, the &quot;.expert&quot; command generates similar data distribution statistics for all indexes considered based on PERCENT percent of the rows currently stored in each database table. For databases with unusual data distributions, this may lead to better index recommendations, particularly if the application intends to run ANALYZE.</source>
          <target state="translated">Если этот параметр передан ненулевым аргументом,то команда &quot;.эксперт&quot; генерирует аналогичную статистику распределения данных по всем рассматриваемым индексам на основе PERCENT процентов строк,хранящихся в настоящее время в каждой таблице БД.Для БД с необычными распределениями данных это может привести к улучшению рекомендаций по индексам,особенно если приложение намерено запустить ANALYZE.</target>
        </trans-unit>
        <trans-unit id="84432c7bc70fca55a254f66874dd4bc62fe9abea" translate="yes" xml:space="preserve">
          <source>If this option is present, then SQLite will use the isnan() function from the system math library. This is an alias for the &lt;a href=&quot;compile#isnan&quot;&gt;HAVE_ISNAN&lt;/a&gt; configuration option.</source>
          <target state="translated">Если эта опция присутствует, SQLite будет использовать функцию isnan () из системной математической библиотеки. Это псевдоним для &lt;a href=&quot;compile#isnan&quot;&gt;параметра&lt;/a&gt; конфигурации HAVE_ISNAN .</target>
        </trans-unit>
        <trans-unit id="8be490fe1c118ec4e22a3ceeab9a17451a39a86c" translate="yes" xml:space="preserve">
          <source>If this option is present, then the built-in &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; operator will be case sensitive. This same effect can be achieved at run-time using the &lt;a href=&quot;pragma#pragma_case_sensitive_like&quot;&gt;case_sensitive_like pragma&lt;/a&gt;.</source>
          <target state="translated">Если этот параметр присутствует, то встроенный оператор &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; будет чувствителен к регистру. &lt;a href=&quot;pragma#pragma_case_sensitive_like&quot;&gt;Того&lt;/a&gt; же эффекта можно достичь во время выполнения с помощью прагмы case_sensitive_like .</target>
        </trans-unit>
        <trans-unit id="ada121bcb0877b4a8c48986ff56dc5ba81d63e98" translate="yes" xml:space="preserve">
          <source>If this routine has not been previously called or if the previous call had N less than one or a NULL pointer for P, then the PRNG is seeded using randomness obtained from the xRandomness method of the default &lt;a href=&quot;#sqlite3_vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object. If the previous call to this routine had an N of 1 or more and a non-NULL P then the pseudo-randomness is generated internally and without recourse to the &lt;a href=&quot;#sqlite3_vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; xRandomness method.</source>
          <target state="translated">Если эта процедура ранее не вызывалась или если в предыдущем вызове было N меньше единицы или указатель NULL для P, то PRNG заполняется с использованием случайности, полученной из метода xRandomness объекта &lt;a href=&quot;#sqlite3_vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; по умолчанию . Если предыдущий вызов этой подпрограммы имел N равное 1 или более и отличное от NULL P, тогда псевдослучайность генерируется внутренне и без обращения к методу &lt;a href=&quot;#sqlite3_vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; xRandomness.</target>
        </trans-unit>
        <trans-unit id="37bc48a662f5023c1e8434007284ca1643b9979a" translate="yes" xml:space="preserve">
          <source>If this routine has not been previously called or if the previous call had N less than one or a NULL pointer for P, then the PRNG is seeded using randomness obtained from the xRandomness method of the default &lt;a href=&quot;vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object. If the previous call to this routine had an N of 1 or more and a non-NULL P then the pseudo-randomness is generated internally and without recourse to the &lt;a href=&quot;vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; xRandomness method.</source>
          <target state="translated">Если эта процедура ранее не вызывалась или если в предыдущем вызове было N меньше единицы или указатель NULL для P, то PRNG заполняется с использованием случайности, полученной из метода xRandomness объекта &lt;a href=&quot;vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; по умолчанию . Если предыдущий вызов этой подпрограммы имел N равное 1 или более и отличное от NULL P, тогда псевдослучайность генерируется внутренне и без обращения к методу &lt;a href=&quot;vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; xRandomness.</target>
        </trans-unit>
        <trans-unit id="7e75d3fd5002bfcaea7e83bd9fd2a7a917209184" translate="yes" xml:space="preserve">
          <source>If this value is returned, any changes applied so far are rolled back and the call to sqlite3changeset_apply() returns SQLITE_ABORT.</source>
          <target state="translated">Если это значение возвращается,то все изменения,примененные до сих пор,откатываются,и вызов sqlite3changeset_apply()возвращает SQLITE_ABORT.</target>
        </trans-unit>
        <trans-unit id="aefcb4f212e79bade6ab9e99069db614c4e4b2ca" translate="yes" xml:space="preserve">
          <source>If tracing is enabled (by the sqlite3_trace()) interface, then the UTF-8 string contained in P4 is emitted on the trace callback. Or if P4 is blank, use the string returned by sqlite3_sql().</source>
          <target state="translated">Если трассировка включена (по интерфейсу sqlite3_trace()),то при обратном вызове трассы излучается строка UTF-8,содержащаяся в P4.Или,если P4 пустая,используйте строку,возвращаемую функцией sqlite3_sql().</target>
        </trans-unit>
        <trans-unit id="3f4fc8020e070710f30d36574cc04f57550a8abc" translate="yes" xml:space="preserve">
          <source>If two database connections shared the same cache and the reader has enabled the &lt;a href=&quot;pragma#pragma_read_uncommitted&quot;&gt;read_uncommitted pragma&lt;/a&gt;, then the reader will be able to see changes made by the writer before the writer transaction commits. The combined use of &lt;a href=&quot;sharedcache&quot;&gt;shared cache mode&lt;/a&gt; and the &lt;a href=&quot;pragma#pragma_read_uncommitted&quot;&gt;read_uncommitted pragma&lt;/a&gt; is the only way that one database connection can see uncommitted changes on a different database connection. In all other circumstances, separate database connections are completely isolated from one another.</source>
          <target state="translated">Если два соединения с базой данных совместно используют один и тот же кеш и читатель включил &lt;a href=&quot;pragma#pragma_read_uncommitted&quot;&gt;прагму read_uncommitted&lt;/a&gt; , то читатель сможет увидеть изменения, сделанные писателем, до того, как транзакция записи будет зафиксирована. Комбинированное использование режима &lt;a href=&quot;sharedcache&quot;&gt;общего кэша&lt;/a&gt; и &lt;a href=&quot;pragma#pragma_read_uncommitted&quot;&gt;прагмы read_uncommitted&lt;/a&gt; - единственный способ, которым одно соединение с базой данных может видеть незафиксированные изменения в другом соединении с базой данных. Во всех остальных случаях отдельные соединения с базой данных полностью изолированы друг от друга.</target>
        </trans-unit>
        <trans-unit id="b41151cd8ed57f8a05f71e68d3e6f727b509adc0" translate="yes" xml:space="preserve">
          <source>If two or more distinct but shareable in-memory databases are needed in a single process, then the &lt;a href=&quot;uri#coreqp&quot;&gt;mode=memory&lt;/a&gt; query parameter can be used with a &lt;a href=&quot;uri&quot;&gt;URI filename&lt;/a&gt; to create a named in-memory database:</source>
          <target state="translated">Если в одном процессе требуются две или более отдельных, но совместно используемых баз данных в &lt;a href=&quot;uri#coreqp&quot;&gt;памяти, то&lt;/a&gt; параметр запроса mode = memory можно использовать с &lt;a href=&quot;uri&quot;&gt;именем URI&lt;/a&gt; для создания именованной базы данных в памяти:</target>
        </trans-unit>
        <trans-unit id="7c051c04a74b426b583f6b46003048b9ec27b20e" translate="yes" xml:space="preserve">
          <source>If two or more threads call one or more &lt;a href=&quot;#sqlite3_column_database_name&quot;&gt;column metadata interfaces&lt;/a&gt; for the same &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; and result column at the same time then the results are undefined.</source>
          <target state="translated">Если два или более потока вызывают один или несколько &lt;a href=&quot;#sqlite3_column_database_name&quot;&gt;интерфейсов метаданных столбца&lt;/a&gt; для одного и того же &lt;a href=&quot;#sqlite3_stmt&quot;&gt;подготовленного оператора&lt;/a&gt; и столбца результатов одновременно, то результаты не определены.</target>
        </trans-unit>
        <trans-unit id="3f3b1a7191faa957bd4b9a2df637334c8be60539" translate="yes" xml:space="preserve">
          <source>If two or more threads call one or more &lt;a href=&quot;column_database_name&quot;&gt;column metadata interfaces&lt;/a&gt; for the same &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; and result column at the same time then the results are undefined.</source>
          <target state="translated">Если два или более потока вызывают один или несколько &lt;a href=&quot;column_database_name&quot;&gt;интерфейсов метаданных столбца&lt;/a&gt; для одного и того же &lt;a href=&quot;stmt&quot;&gt;подготовленного оператора&lt;/a&gt; и столбца результатов одновременно, то результаты не определены.</target>
        </trans-unit>
        <trans-unit id="f59e0a816231da9addc2b58ecf1aebf4318f03f1" translate="yes" xml:space="preserve">
          <source>If two or more threads call one or more of these routines against the same prepared statement and column at the same time then the results are undefined.</source>
          <target state="translated">Если два или более потока одновременно вызывают одну или несколько этих процедур против одного и того же подготовленного оператора и столбца,то результаты не определяются.</target>
        </trans-unit>
        <trans-unit id="47c7553b72e9db086338dfa731f7055b973ce5ac" translate="yes" xml:space="preserve">
          <source>If two processes have open connections to the same database file and one process closes its connection, unlinks the file, then creates a new database file in its place with the same name and reopens the new file, then the two processes will be talking to different database files with the same name. (Note that this is only possible on Posix and Posix-like systems that permit a file to be unlinked while it is still open for reading and writing. Windows does not allow this to occur.) Since rollback journals and WAL files are based on the name of the database file, the two different database files will share the same rollback journal or WAL file. A rollback or recovery for one of the databases might use content from the other database, resulting in corruption. A similar problem occurs if a database file is renamed while it is opened and a new file is created with the old name.</source>
          <target state="translated">Если два процесса имеют открытые соединения с одним и тем же файлом базы данных,и один процесс закрывает свое соединение,разрывает связь с файлом,затем создает на своем месте новый файл базы данных с тем же именем и открывает новый файл заново,то эти два процесса будут говорить с разными файлами базы данных с тем же именем.(Обратите внимание,что это возможно только в Posix и Posix-подобных системах,которые позволяют разорвать связь с файлом,пока он еще открыт для чтения и записи.Windows не разрешает этого).Поскольку журналы отката и файлы WAL основаны на имени файла базы данных,два разных файла базы данных будут иметь один и тот же журнал отката или файл WAL.При откате или восстановлении одной из баз данных может использоваться содержимое другой базы данных,что приведет к ее повреждению.Аналогичная проблема возникает,если при открытии файл базы данных переименовывается и создается новый файл со старым именем.</target>
        </trans-unit>
        <trans-unit id="0f73506a4d083541e30151f33df9ff76bf05c8d1" translate="yes" xml:space="preserve">
          <source>If using the MATCH or = operators, the expression to the left of the MATCH operator is usually the name of the FTS5 table (the exception is when &lt;a href=&quot;fts5#fts5_column_filters&quot;&gt;specifying a column-filter&lt;/a&gt;). The expression on the right must be a text value specifying the term to search for. For the table-valued function syntax, the term to search for is specified as the first table argument. For example:</source>
          <target state="translated">При использовании операторов MATCH или = выражение слева от оператора MATCH обычно является именем таблицы FTS5 (за исключением случая, когда &lt;a href=&quot;fts5#fts5_column_filters&quot;&gt;указывается фильтр столбца&lt;/a&gt; ). Выражение справа должно быть текстовым значением, определяющим термин для поиска. Для синтаксиса возвращающей табличное значение функции термин для поиска указывается как первый аргумент таблицы. Например:</target>
        </trans-unit>
        <trans-unit id="10c759f053d61c7e03ff959d29d1e1974783d209" translate="yes" xml:space="preserve">
          <source>If using the MinGW compiler, the command-line is this:</source>
          <target state="translated">При использовании компилятора MinGW командная строка такая:</target>
        </trans-unit>
        <trans-unit id="06877745f4f906674e7afae07a31cb3adf870f29" translate="yes" xml:space="preserve">
          <source>If using the amalgamation autoconf based build system, setting the CPPFLAGS environment variable while running the 'configure' script is an easy way to set these macros. For example, the following command:</source>
          <target state="translated">При использовании системы сборки на основе автоконверсии слияния,настройка переменной окружения CPPFLAGS во время выполнения сценария 'configure' является простым способом установки этих макросов.Например,следующая команда:</target>
        </trans-unit>
        <trans-unit id="c06d03a70a5b876ea7069032c87d9367a09e46c5" translate="yes" xml:space="preserve">
          <source>If when you try to load your library you get back an error message that says &quot;mach-o, but wrong architecture&quot; then you might need to add command-line options &quot;-arch i386&quot; or &quot;arch x86_64&quot; to gcc, depending on how your application is built.</source>
          <target state="translated">Если при попытке загрузить библиотеку вы получите сообщение об ошибке &quot;mach-o,but wrong architecture&quot;,то вам может потребоваться добавить в gcc опции командной строки &quot;-arch i386&quot; или &quot;arch x86_64&quot;,в зависимости от того,как собирается ваше приложение.</target>
        </trans-unit>
        <trans-unit id="7cf9b897ab48ed18b82e59ac2a561abc36b27d81" translate="yes" xml:space="preserve">
          <source>If while attempting to detect a</source>
          <target state="translated">Если при попытке обнаружить</target>
        </trans-unit>
        <trans-unit id="56ea56ee57997f44a3b4181f1b3a8efe3168e325" translate="yes" xml:space="preserve">
          <source>If xBestIndex returns &lt;a href=&quot;rescode#constraint&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt;, that does not indicate an error. Rather, SQLITE_CONSTRAINT indicates that the particular combination of input parameters specified should not be used in the query plan. The SQLITE_CONSTRAINT return is useful for &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued functions&lt;/a&gt; that have required parameters. If the aConstraint[].usable field is false for one of the required parameter, then the xBestIndex method should return SQLITE_CONSTRAINT.</source>
          <target state="translated">Если xBestIndex возвращает &lt;a href=&quot;rescode#constraint&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt; , это не указывает на ошибку. Скорее, SQLITE_CONSTRAINT указывает, что конкретная указанная комбинация входных параметров не должна использоваться в плане запроса. Возвращаемый результат SQLITE_CONSTRAINT полезен для возвращающих &lt;a href=&quot;vtab#tabfunc2&quot;&gt;табличное значение функций&lt;/a&gt; , имеющих обязательные параметры. Если поле aConstraint []. Usable равно false для одного из обязательных параметров, то метод xBestIndex должен вернуть SQLITE_CONSTRAINT.</target>
        </trans-unit>
        <trans-unit id="f2ddd15ff69a5ac03ff2cdad02ade0037f75db16" translate="yes" xml:space="preserve">
          <source>If xRead() returns SQLITE_IOERR_SHORT_READ it must also fill in the unread portions of the buffer with zeros. A VFS that fails to zero-fill short reads might seem to work. However, failure to zero-fill short reads will eventually lead to database corruption.</source>
          <target state="translated">Если xRead()возвращает SQLITE_IOERR_SHORT_READ,то она также должна заполнить нулями непрочитанные части буфера.Может показаться,что VFS,которая не заполняет нулями короткие чтения,работает.Однако,неудача с заполнением нуля при коротком чтении в конечном итоге приведет к повреждению базы данных.</target>
        </trans-unit>
        <trans-unit id="406e06acbef99d386159c93608eee295bbb8911c" translate="yes" xml:space="preserve">
          <source>If you &lt;a href=&quot;lang_expr#castexpr&quot;&gt;CAST&lt;/a&gt; a string into a BLOB, then the entire length of the string is shown. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c77d01ec7cf778a68ddf7a39c6762175e2b9a47" translate="yes" xml:space="preserve">
          <source>If you abuse the library by trying to call &lt;b&gt;sqlite_step&lt;/b&gt; inappropriately it will attempt return SQLITE_MISUSE. This can happen if you call sqlite_step() on the same virtual machine at the same time from two or more threads or if you call sqlite_step() again after it returned SQLITE_DONE or SQLITE_ERROR or if you pass in an invalid virtual machine pointer to sqlite_step(). You should not depend on the SQLITE_MISUSE return code to indicate an error. It is possible that a misuse of the interface will go undetected and result in a program crash. The SQLITE_MISUSE is intended as a debugging aid only - to help you detect incorrect usage prior to a mishap. The misuse detection logic is not guaranteed to work in every case.</source>
          <target state="translated">Если вы злоупотребляете библиотекой, пытаясь вызвать &lt;b&gt;sqlite_step&lt;/b&gt; ненадлежащим образом, она попытается вернуть SQLITE_MISUSE. Это может произойти, если вы вызываете sqlite_step () на той же виртуальной машине одновременно из двух или более потоков, или если вы вызываете sqlite_step () снова после того, как он вернул SQLITE_DONE или SQLITE_ERROR, или если вы передали неверный указатель виртуальной машины на sqlite_step ( ). Вы не должны полагаться на код возврата SQLITE_MISUSE, чтобы указать на ошибку. Возможно, неправильное использование интерфейса останется незамеченным и приведет к сбою программы. SQLITE_MISUSE предназначен только для помощи при отладке - чтобы помочь вам обнаружить неправильное использование до возникновения сбоя. Не гарантируется, что логика обнаружения неправильного использования будет работать во всех случаях.</target>
        </trans-unit>
        <trans-unit id="873a7faf9a3abe0d1c1b374fb25f49d1d975c393" translate="yes" xml:space="preserve">
          <source>If you append the character '*' to the end of the pattern, then a prefix search is performed. For example:</source>
          <target state="translated">При добавлении символа &quot;*&quot; в конец шаблона выполняется поиск префикса.Например:</target>
        </trans-unit>
        <trans-unit id="feb267998fb090ad7c9de72555f7d36aa562a1a7" translate="yes" xml:space="preserve">
          <source>If you are a &quot;rustacean&quot; and feel that Rust already meets the preconditions listed above, and that SQLite should be recoded in Rust, then you are welcomed and encouraged to contact the SQLite developers privately and argue your case.</source>
          <target state="translated">Если вы являетесь &quot;рустаком&quot; и считаете,что Rust уже удовлетворяет вышеперечисленным условиям,и что SQLite должен быть перекодирован в Rust,то мы приглашаем вас связаться с разработчиками SQLite в частном порядке и оспорить вашу версию.</target>
        </trans-unit>
        <trans-unit id="abe76df81a0ba114f6ec2f514aa5a8bd31614980" translate="yes" xml:space="preserve">
          <source>If you are a devoted Git user, you can still easily access SQLite. This section gives some hints on how to do so.</source>
          <target state="translated">Если вы являетесь преданным пользователем Git'а,то вы всё равно можете легко получить доступ к SQLite.В этом разделе даны некоторые подсказки,как это сделать.</target>
        </trans-unit>
        <trans-unit id="b343ba4a7d7f527696dab2d0f4840db430c944d2" translate="yes" xml:space="preserve">
          <source>If you are an SQLite user whose has stumbled over some quirk of SQLite that is not mentioned here, please send us an email so that we can document the problem.</source>
          <target state="translated">Если вы являетесь пользователем SQLite,который наткнулся на какую-то причуду SQLite,которая здесь не упоминается,пожалуйста,отправьте нам письмо по электронной почте,чтобы мы могли задокументировать проблему.</target>
        </trans-unit>
        <trans-unit id="5de71147613f21cf2bdcb3bcc197abf7747cdeb4" translate="yes" xml:space="preserve">
          <source>If you are using separate source files, name all of the source files instead of just the two amalgamation source files. Once this is done, commit your changes as follows:</source>
          <target state="translated">Если вы используете отдельные исходные файлы,назовите все исходные файлы вместо двух исходных файлов слияния.После этого зафиксируйте свои изменения следующим образом:</target>
        </trans-unit>
        <trans-unit id="4850a90372994c2a6bc8e2907d79c1145e74bbe1" translate="yes" xml:space="preserve">
          <source>If you delete a lot of data and want to shrink the database file, run the &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; command. VACUUM will reconstruct the database from scratch. This will leave the database with an empty free-list and a file that is minimal in size. Note, however, that the VACUUM can take some time to run and it can use up to twice as much temporary disk space as the original file while it is running.</source>
          <target state="translated">Если вы удаляете много данных и хотите сжать файл базы данных, запустите команду &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; . VACUUM восстановит базу данных с нуля. В результате в базе данных останется пустой список свободных мест и файл минимального размера. Обратите внимание, однако, что для запуска VACUUM может потребоваться некоторое время, и он может использовать в два раза больше временного дискового пространства, чем исходный файл, пока он работает.</target>
        </trans-unit>
        <trans-unit id="5f248ef1c5726530e6b14bd3353f02b25fd1dbc4" translate="yes" xml:space="preserve">
          <source>If you delete the</source>
          <target state="translated">Если вы удалите</target>
        </trans-unit>
        <trans-unit id="45dba72fc49e11d88cfbda6839af5580be8953a7" translate="yes" xml:space="preserve">
          <source>If you do not have a backup, recovery is very difficult. You might be able to find partial string data in a binary dump of the raw database file. Recovering numeric data might also be possible given special tools, though to our knowledge no such tools exist. SQLite is sometimes compiled with the &lt;a href=&quot;compile#secure_delete&quot;&gt;SQLITE_SECURE_DELETE&lt;/a&gt; option which overwrites all deleted content with zeros. If that is the case then recovery is clearly impossible. Recovery is also impossible if you have run &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; since the data was deleted. If SQLITE_SECURE_DELETE is not used and VACUUM has not been run, then some of the deleted content might still be in the database file, in areas marked for reuse. But, again, there exist no procedures or tools that we know of to help you recover that data.</source>
          <target state="translated">Если у вас нет резервной копии, восстановление очень сложно. Возможно, вы сможете найти частичные строковые данные в двоичном дампе необработанного файла базы данных. Восстановление числовых данных также возможно с помощью специальных инструментов, хотя, насколько нам известно, таких инструментов не существует. SQLite иногда компилируется с параметром &lt;a href=&quot;compile#secure_delete&quot;&gt;SQLITE_SECURE_DELETE,&lt;/a&gt; который перезаписывает все удаленное содержимое нулями. Если это так, то восстановление явно невозможно. Восстановление также невозможно, если вы запустили &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; после удаления данных. Если SQLITE_SECURE_DELETE не используется и VACUUM не был запущен, то часть удаленного содержимого может все еще находиться в файле базы данных в областях, отмеченных для повторного использования. Но, опять же, не существует известных нам процедур или инструментов, которые помогли бы вам восстановить эти данные.</target>
        </trans-unit>
        <trans-unit id="6123d0cbcd49adc87278ebf33c0308d19e13c18e" translate="yes" xml:space="preserve">
          <source>If you do not want to use your web browser to view the new check-in, you can get some information from the command-line using commands like these:</source>
          <target state="translated">Если вы не хотите использовать веб-браузер для просмотра новой регистрации,вы можете получить некоторую информацию из командной строки,используя такие команды:</target>
        </trans-unit>
        <trans-unit id="165e1548a7d4a581b8c9984a9f7ab5cdc62be5bb" translate="yes" xml:space="preserve">
          <source>If you do this immediately after creating a new database file, before anything else has been written into the file, then that might be all that you need to do. Otherwise, the API call above should be followed by:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8e5a488a0f9459d060660cf0d22bea3c48ed8ca" translate="yes" xml:space="preserve">
          <source>If you feel that you need dynamic pointer type strings in your application, that is a strong indicator that you are misusing the pointer-passing interface. Your intended use may be unsafe. Please rethink your design. Determine if you really need to be passing pointers through SQL in the first place. Or perhaps find a different mechanism other than the pointer-passing interfaces described by this article.</source>
          <target state="translated">Если вы чувствуете,что вам нужны строки динамического типа указателя в вашем приложении,то это сильный индикатор того,что вы злоупотребляете интерфейсом обхода указателя.Ваше предполагаемое использование может быть небезопасным.Пожалуйста,переосмыслите свой дизайн.Определите,действительно ли вам нужно передавать указатели через SQL в первую очередь.Или,возможно,найти другой механизм,отличный от описанных в этой статье интерфейсов обхода указателей.</target>
        </trans-unit>
        <trans-unit id="88a9f11dc162c0fbb6ecd06e339a9fb7195e5fab" translate="yes" xml:space="preserve">
          <source>If you find errors in either the documentation or the code, feel free to fix them and/or contact the author at &lt;a href=&quot;mailto:drh@hwaci.com&quot;&gt;drh@hwaci.com&lt;/a&gt;. Your bug fixes or suggestions are always welcomed.</source>
          <target state="translated">Если вы обнаружите ошибки в документации или коде, не стесняйтесь исправлять их и / или свяжитесь с автором по адресу &lt;a href=&quot;mailto:drh@hwaci.com&quot;&gt;drh@hwaci.com&lt;/a&gt; . Мы всегда приветствуем ваши исправления ошибок или предложения.</target>
        </trans-unit>
        <trans-unit id="888116b604c695e34258cc3ceb95b003a7ab4815" translate="yes" xml:space="preserve">
          <source>If you have a backup copy of your database file, recover the information from your backup.</source>
          <target state="translated">Если у вас есть резервная копия файла базы данных,восстановите информацию из резервной копии.</target>
        </trans-unit>
        <trans-unit id="882c38087164067f62c9c7b1c8a9cb99d1dcf2ef" translate="yes" xml:space="preserve">
          <source>If you have a database of large BLOBs, do you get better read performance when you store the complete BLOB content directly in the database or is it faster to store each BLOB in a separate file and store just the corresponding filename in the database?</source>
          <target state="translated">Если у вас есть база данных больших BLOB,вы получаете лучшую производительность чтения,когда вы храните полный BLOB-контент непосредственно в базе данных или быстрее хранить каждый BLOB в отдельном файле и хранить только соответствующее имя файла в базе данных?</target>
        </trans-unit>
        <trans-unit id="763f3c8f82a8dbfe2292008ca244c1681fbd52b1" translate="yes" xml:space="preserve">
          <source>If you have a script and you want to start debugging at some point half-way through that script, simply set a breakpoint in gdb (or whatever debugger you are using) on the test_breakpoint() function, and add a &quot;.breakpoint&quot; command where you want to stop. When you reach that first breakpoint, set whatever additional breakpoints are variable traces you need.</source>
          <target state="translated">Если у вас есть скрипт и вы хотите начать отладку в какой-то момент на полпути через этот скрипт,просто установите точку останова в gdb (или любом другом отладчике,который вы используете)на функции test_breakpoint(),и добавьте команду &quot;.breakpoint&quot;,где вы хотите остановиться.Когда вы достигнете этой первой точки останова,установите все дополнительные точки останова,которые являются переменными трассами,которые вам нужны.</target>
        </trans-unit>
        <trans-unit id="a1693c0c5d23752d02c6e3b93f043c8eb31a26df" translate="yes" xml:space="preserve">
          <source>If you have done any assembly language programming or have worked with any kind of abstract machine before, all of these details should be familiar to you. So let's jump right in and start looking as some code.</source>
          <target state="translated">Если вы уже занимались программированием на любом языке ассемблера или работали с любым типом абстрактной машины,все эти детали должны быть вам знакомы.Так что давайте сразу перейдём и начнем искать какой-нибудь код.</target>
        </trans-unit>
        <trans-unit id="ec726a0b109ca2b2f984dbfe63a95238609005d5" translate="yes" xml:space="preserve">
          <source>If you intend to use this virtual table in cooperation with an &lt;a href=&quot;fts3#fts4&quot;&gt;FTS4&lt;/a&gt; table (for spelling correction of search terms) then you might extract the vocabulary using an &lt;a href=&quot;fts3#fts4aux&quot;&gt;fts4aux&lt;/a&gt; table:</source>
          <target state="translated">Если вы намереваетесь использовать эту виртуальную таблицу вместе с таблицей &lt;a href=&quot;fts3#fts4&quot;&gt;FTS4&lt;/a&gt; (для исправления орфографии поисковых терминов), вы можете извлечь словарь с помощью таблицы &lt;a href=&quot;fts3#fts4aux&quot;&gt;fts4aux&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="20f09458f074cbdfa69a4cd879b9a24a9c5ffaed" translate="yes" xml:space="preserve">
          <source>If you made NL to CR-NL line ending changes or space to tab indentation changes in the original baseline, make the same changes to the new source file.</source>
          <target state="translated">Если вы внесли изменения в конец строки NL-CR-NL или в исходный исходный файл с отступом в виде пробела до отступов табуляции,сделайте те же изменения в новом исходном файле.</target>
        </trans-unit>
        <trans-unit id="6938d0165858c470278846efb2784fece3e6d115" translate="yes" xml:space="preserve">
          <source>If you need an exact answer, you should not use binary64 floating-point values, in SQLite or in any other product. This is not an SQLite limitation. It is a mathematical limitation inherent in the design of floating-point numbers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e4831ba155a21bf312a9328909ee6b27a5a08fb" translate="yes" xml:space="preserve">
          <source>If you need to verify that the SQLite source code that you have is authentic and has not been modified in any way (perhaps by an adversary) that can be done using a few simple command-line tools. At the root of the SQLite source tree is a file named &quot;manifest&quot;. The manifest file contains the name of every other file in the source tree together with either a SHA1 or SHA3-256 hash for that file. (SHA1 is used for older files and SHA3-256 for newer files.) You can write a script to extract these hashes and verify them against the source code files. The hash name for the check-in is just the SHA3-256 hash of the &quot;manifest&quot; file itself.</source>
          <target state="translated">Если вам необходимо убедиться,что исходный код SQLite,который у вас есть,подлинный и не был изменен каким-либо образом (возможно,противником),это можно сделать с помощью нескольких простых инструментов командной строки.В корне дерева исходных текстов SQLite находится файл с именем &quot;манифест&quot;.Файл-манифест содержит имя каждого другого файла в дереве исходных текстов вместе с хэшем SHA1 или SHA3-256 для этого файла.(SHA1 используется для старых файлов,а SHA3-256-для более новых.)Вы можете написать скрипт для извлечения этих хэшей и сверки их с файлами исходного кода.Хэш-имя для регистрации-это просто хэш SHA3-256 самого &quot;манифеста&quot; файла.</target>
        </trans-unit>
        <trans-unit id="a95dfc6dc355d4bcfc654c806aedf507385d37e3" translate="yes" xml:space="preserve">
          <source>If you notice new CVEs associated with SQLite that are not in the table below, please bring them to the attention of the developers on the &lt;a href=&quot;https://sqlite.org/forum/about&quot;&gt;SQLite Forum&lt;/a&gt; so they can be added.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="397118cfe02899896d93de7bdac7c4252da15fbe" translate="yes" xml:space="preserve">
          <source>If you really need to update an R-Tree based on complex queries against the same R-Tree, it is best to run the complex queries first and store the results in a temporary table, then update the R-Tree based on the values stored in the temporary table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5df7ef5af012df18a05531f4528bcf648f59acb3" translate="yes" xml:space="preserve">
          <source>If you remember nothing else about floating-point values, please don't forget this one key idea.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13da8fa523e1031c91ec41d25db356602a2c65ba" translate="yes" xml:space="preserve">
          <source>If you specify a column a width of 0, then the column width is automatically adjusted to be the maximum of three numbers: 10, the width of the header, and the width of the first row of data. This makes the column width self-adjusting. The default width setting for every column is this auto-adjusting 0 value.</source>
          <target state="translated">Если вы укажете столбец шириной 0,то ширина столбца будет автоматически подогнана под максимум три числа:10,ширина заголовка и ширина первого ряда данных.Это делает ширину столбца самонастраивающейся.По умолчанию для каждого столбца устанавливается значение 0.</target>
        </trans-unit>
        <trans-unit id="473942d6eb4b318988fc65567c504fbaea4558ae" translate="yes" xml:space="preserve">
          <source>If you use version 2.6.0 or later of the library to open a database file that was originally created by version 2.5.6 or earlier, an attempt to rebuild the database into the new format will occur automatically. This can take some time for a large database. (Allow 1 or 2 seconds per megabyte of database under Unix - longer under Windows.) This format conversion is irreversible. It is &lt;strong&gt;strongly&lt;/strong&gt; suggested that you make a backup copy of older database files prior to opening them with version 2.6.0 or later of the library, in case there are errors in the format conversion logic.</source>
          <target state="translated">Если вы используете версию 2.6.0 или новее библиотеки, чтобы открыть файл базы данных, который был первоначально создан версией 2.5.6 или более ранней, попытка перестроить базу данных в новый формат будет произведена автоматически. Для большой базы данных это может занять некоторое время. (Разрешите 1 или 2 секунды на мегабайт базы данных под Unix - дольше под Windows.) Это преобразование формата необратимо. Он &lt;strong&gt;настоятельно&lt;/strong&gt; рекомендуется сделать резервную копию старых файлов базы данных до их открытия с версией 2.6.0 или более поздней версией библиотеки, в случае , если есть ошибки в логике преобразования формата.</target>
        </trans-unit>
        <trans-unit id="57f756e359121a9c945b91158a295a20dd82b0db" translate="yes" xml:space="preserve">
          <source>If you want to configure the new project, type:</source>
          <target state="translated">Если вы хотите настроить новый проект,напечатайте:</target>
        </trans-unit>
        <trans-unit id="bda3419a07a7eb3933cb5a599b2b66398d9d3b26" translate="yes" xml:space="preserve">
          <source>If you want to know how the SQLite library works internally, you need to begin with a solid understanding of the Virtual Database Engine or VDBE. The VDBE occurs right in the middle of the processing stream (see the &lt;a href=&quot;arch&quot;&gt;architecture diagram&lt;/a&gt;) and so it seems to touch most parts of the library. Even parts of the code that do not directly interact with the VDBE are usually in a supporting role. The VDBE really is the heart of SQLite.</source>
          <target state="translated">Если вы хотите узнать, как работает библиотека SQLite внутри, вам нужно начать с твердого понимания Virtual Database Engine или VDBE. VDBE находится прямо в середине потока обработки (см. &lt;a href=&quot;arch&quot;&gt;Диаграмму архитектуры&lt;/a&gt; ), и поэтому кажется, что он затрагивает большинство частей библиотеки. Даже части кода, которые напрямую не взаимодействуют с VDBE, обычно играют вспомогательную роль. VDBE действительно является сердцем SQLite.</target>
        </trans-unit>
        <trans-unit id="45ef57f77f1b898b089bfb8776638647a0457adc" translate="yes" xml:space="preserve">
          <source>If you want to use a keyword as a name, you need to quote it. There are four ways of quoting keywords in SQLite:</source>
          <target state="translated">Если вы хотите использовать ключевое слово в качестве имени,вы должны процитировать его.В SQLite существует четыре способа цитирования ключевых слов:</target>
        </trans-unit>
        <trans-unit id="33c132e45cdeb83d38d9892ca9d1c9494534573d" translate="yes" xml:space="preserve">
          <source>If you will be opening multiple database connections in your application, rather than invoking the extension entry points for each database connection separately, you might want to consider using the &lt;a href=&quot;c3ref/auto_extension&quot;&gt;sqlite3_auto_extension()&lt;/a&gt; interface to register your extensions and to cause them to be automatically started as each database connection is opened. You only have to register each extension once, and you can do so near the beginning of your main() routine. Using the &lt;a href=&quot;c3ref/auto_extension&quot;&gt;sqlite3_auto_extension()&lt;/a&gt; interface to register your extensions makes your extensions work as if they were built into the core SQLite - they automatically exist whenever you open a new database connection without needing to be initialized. Just be sure to complete any configuration you need to accomplish using &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config()&lt;/a&gt; before registering your extensions, since the &lt;a href=&quot;c3ref/auto_extension&quot;&gt;sqlite3_auto_extension()&lt;/a&gt; interface implicitly calls &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_initialize()&lt;/a&gt;.</source>
          <target state="translated">Если вы будете открывать несколько подключений к базе данных в своем приложении, а не вызывать точки входа расширения для каждого подключения к базе данных отдельно, вы можете рассмотреть возможность использования интерфейса &lt;a href=&quot;c3ref/auto_extension&quot;&gt;sqlite3_auto_extension ()&lt;/a&gt; для регистрации ваших расширений и их автоматического запуска при каждом запуске. соединение с базой данных открыто. Вам нужно зарегистрировать каждое расширение только один раз, и вы можете сделать это в начале вашей процедуры main (). Использование интерфейса &lt;a href=&quot;c3ref/auto_extension&quot;&gt;sqlite3_auto_extension ()&lt;/a&gt; для регистрации ваших расширений заставляет ваши расширения работать так, как если бы они были встроены в ядро ​​SQLite - они автоматически существуют, когда вы открываете новое соединение с базой данных, без необходимости инициализации. Просто убедитесь, что вы выполнили все необходимые настройки, используя&lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config ()&lt;/a&gt; перед регистрацией ваших расширений, поскольку интерфейс &lt;a href=&quot;c3ref/auto_extension&quot;&gt;sqlite3_auto_extension ()&lt;/a&gt; неявно вызывает &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_initialize ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c2a19b719f76f7faa9b10e93907a0fe776f85db7" translate="yes" xml:space="preserve">
          <source>If your data will grow to a size that you are uncomfortable or unable to fit into a single disk file, then you should select a solution other than SQLite. SQLite supports databases up to 140 terabytes in size, assuming you can find a disk drive and filesystem that will support 140-terabyte files. Even so, when the size of the content looks like it might creep into the terabyte range, it would be good to consider a centralized client/server database.</source>
          <target state="translated">Если ваши данные вырастут до размера,который вам неудобен или не сможет поместиться в одном дисковом файле,то вам следует выбрать решение,отличное от SQLite.SQLite поддерживает базы данных размером до 140 терабайт,предполагая,что вы сможете найти дисковый накопитель и файловую систему,которая будет поддерживать файлы размером 140 терабайт.Но даже в этом случае,когда размер содержимого выглядит так,как будто оно может просочиться в терабайтный диапазон,было бы неплохо рассмотреть возможность использования централизованной клиентской/серверной базы данных.</target>
        </trans-unit>
        <trans-unit id="22b27cadfcf6135e72ec61c4781266a907795c13" translate="yes" xml:space="preserve">
          <source>If your data will grow to a size that you are uncomfortable or unable to fit into a single disk file, then you should select a solution other than SQLite. SQLite supports databases up to 281 terabytes in size, assuming you can find a disk drive and filesystem that will support 281-terabyte files. Even so, when the size of the content looks like it might creep into the terabyte range, it would be good to consider a centralized client/server database.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8bce6edf7a889c813c03d5b445472e1ddc49ad2" translate="yes" xml:space="preserve">
          <source>If your system defines a custom OS interface for SQLite or if you were using the undocumented &lt;b&gt;sqlite3_os_switch()&lt;/b&gt; interface, then you will need to make modifications in order to upgrade to SQLite version 3.5.0. This may seem painful at first glance. But as you look more closely, you will probably discover that your changes are made smaller and easier to understand and manage by the new SQLite interface. It is likely that your changes will now also work seamlessly with the SQLite amalgamation. You will no longer need to make any changes to the code SQLite source code. All of your changes can be effected by application code and you can link against a standard, unmodified version of the SQLite amalgamation. Furthermore, the OS interface layer, which was formerly undocumented, is now an officially support interface for SQLite. So you have some assurance that this will be a one-time change and that your new backend will continue to work in future versions of SQLite.</source>
          <target state="translated">Если ваша система определяет пользовательский интерфейс ОС для SQLite или если вы использовали недокументированный &lt;b&gt;sqlite3_os_switch ()&lt;/b&gt;интерфейс, то вам нужно будет внести изменения, чтобы перейти на SQLite версии 3.5.0. На первый взгляд это может показаться болезненным. Но если вы присмотритесь более внимательно, вы, вероятно, обнаружите, что ваши изменения стали меньше и легче для понимания и управления с помощью нового интерфейса SQLite. Вполне вероятно, что ваши изменения теперь также будут работать без проблем с объединением SQLite. Вам больше не нужно будет вносить какие-либо изменения в исходный код SQLite. Все ваши изменения могут быть выполнены с помощью кода приложения, и вы можете ссылаться на стандартную немодифицированную версию объединения SQLite. Кроме того, уровень интерфейса ОС, который ранее не был документирован, теперь официально поддерживает интерфейс SQLite.Таким образом, у вас есть некоторая уверенность в том, что это будет разовое изменение и что ваш новый бэкэнд будет продолжать работать в будущих версиях SQLite.</target>
        </trans-unit>
        <trans-unit id="4d01491e7aaf0e3b7eeb3d6755bf0ba092a441ec" translate="yes" xml:space="preserve">
          <source>If zipfile() is invoked with 2 arguments, then the entry added to the archive is equivalent to that added by inserting the same two values into the &quot;name&quot; and &quot;data&quot; columns of a zipfile virtual table, with all other values set to NULL. If invoked with 4 arguments, it is equivalent to inserting the 4 values into the &quot;name&quot;, &quot;mode&quot;, &quot;mtime&quot; and &quot;data&quot; columns. In other words, the following pairs of queries are equivalent:</source>
          <target state="translated">Если zipfile()вызывается с 2 аргументами,то добавляемая в архив запись эквивалентна добавленной,путем вставки тех же двух значений в столбцы &quot;имя&quot; и &quot;данные&quot; виртуальной таблицы zipfile,при этом все остальные значения устанавливаются в NULL.При вызове с 4 аргументами,это эквивалентно вставке 4-х значений в столбцы &quot;имя&quot;,&quot;режим&quot;,&quot;время&quot; и &quot;данные&quot;.Другими словами,следующие пары запросов эквивалентны:</target>
        </trans-unit>
        <trans-unit id="d49c9a42ebbe9cba3927bb51a35d92fe353713e9" translate="yes" xml:space="preserve">
          <source>If, as part of the</source>
          <target state="translated">если в рамках</target>
        </trans-unit>
        <trans-unit id="1b931ae5cbce5d6c96daf33260c2b72ee5539dbd" translate="yes" xml:space="preserve">
          <source>If, while opening a</source>
          <target state="translated">Если,открывая</target>
        </trans-unit>
        <trans-unit id="f48c9c6740ea7cbd9ee32d778ecff2f9da591ab1" translate="yes" xml:space="preserve">
          <source>IfNoHope</source>
          <target state="translated">IfNoHope</target>
        </trans-unit>
        <trans-unit id="0d430ae72e07c71cbfc6aac6b856ba69c4a14902" translate="yes" xml:space="preserve">
          <source>IfNot</source>
          <target state="translated">IfNot</target>
        </trans-unit>
        <trans-unit id="f975ef3b4d80471cd49ea9ce8bd7a669078224d8" translate="yes" xml:space="preserve">
          <source>IfNotOpen</source>
          <target state="translated">IfNotOpen</target>
        </trans-unit>
        <trans-unit id="d2a091305f84e463b224fd2549c504926b658103" translate="yes" xml:space="preserve">
          <source>IfNotZero</source>
          <target state="translated">IfNotZero</target>
        </trans-unit>
        <trans-unit id="8ea5813d833284a6b426730c347d4a031b76be44" translate="yes" xml:space="preserve">
          <source>IfNullRow</source>
          <target state="translated">IfNullRow</target>
        </trans-unit>
        <trans-unit id="7661d111573d853c18bf38582f4762e932f703e7" translate="yes" xml:space="preserve">
          <source>IfPos</source>
          <target state="translated">IfPos</target>
        </trans-unit>
        <trans-unit id="a6bb95ea00b2b20f56a2debeb7afeb897471ef50" translate="yes" xml:space="preserve">
          <source>IfSmaller</source>
          <target state="translated">IfSmaller</target>
        </trans-unit>
        <trans-unit id="91d8cebb7b70f29e3262ce44bfc944c449089a8d" translate="yes" xml:space="preserve">
          <source>Ignore extra whitespace at the end of of &quot;.&quot; commands in the shell.</source>
          <target state="translated">Игнорируйте лишние пробелы в конце команд &quot;...&quot; в оболочке.</target>
        </trans-unit>
        <trans-unit id="d609bda3312485a36bcab24d9a33ae880a4d9c03" translate="yes" xml:space="preserve">
          <source>Immediately after an iterator is created by sqlite3changeset_start(), it does not point to any change in the changeset. Assuming the changeset is not empty, the first call to this function advances the iterator to point to the first change in the changeset. Each subsequent call advances the iterator to point to the next change in the changeset (if any). If no error occurs and the iterator points to a valid change after a call to sqlite3changeset_next() has advanced it, SQLITE_ROW is returned. Otherwise, if all changes in the changeset have already been visited, SQLITE_DONE is returned.</source>
          <target state="translated">Сразу после создания итератора функцией sqlite3changeset_start(),он не указывает на какое-либо изменение в changeset.Предполагая,что changeset не пустой,первый вызов этой функции перемещает итератор на указание на первое изменение в changeset.Каждый последующий вызов перемещает итератор на указание на следующее изменение в changesetе (если таковое имеется).Если ошибки не происходит и итератор указывает на действительное изменение после того,как вызов sqlite3changeset_next()продвинул его,возвращается SQLITE_ROW.В противном случае,если все изменения в changeset уже были посещены,возвращается SQLITE_DONE.</target>
        </trans-unit>
        <trans-unit id="49deaa07b4de652a28623d07d5618cb8f1e55666" translate="yes" xml:space="preserve">
          <source>Immediately following the wal-header are zero or more frames. Each frame consists of a 24-byte frame-header followed by a</source>
          <target state="translated">Сразу же после колонтитула стоят нулевые и более рамки.Каждая рама состоит из 24-байтового заголовка рамы,за которым следует</target>
        </trans-unit>
        <trans-unit id="efc77ef3528cb380e78002c642146ddfcb72a6c8" translate="yes" xml:space="preserve">
          <source>Implement a procedure that calls &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register()&lt;/a&gt; and passes it a pointer to the &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; structure from the previous step. This procedure is probably the only exported symbol in the source file that implements your VFS.</source>
          <target state="translated">Реализуйте процедуру, которая вызывает &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register ()&lt;/a&gt; и передает ей указатель на структуру &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; из предыдущего шага. Эта процедура, вероятно, является единственным экспортируемым символом в исходном файле, который реализует вашу VFS.</target>
        </trans-unit>
        <trans-unit id="5f991f27713d088110dc4560a5b48613a2e55fa7" translate="yes" xml:space="preserve">
          <source>Implement the &quot;LIMIT ... OFFSET ...&quot; clause on SELECT statements.</source>
          <target state="translated">Выполнить пункт &quot;ОГРАНИЧЕНИЕ...ОТКЛЮЧЕНИЕ...&quot; в отношении заявлений об отборе.</target>
        </trans-unit>
        <trans-unit id="cb1780300fa34dfe12b3de8afb5a8d426d248748" translate="yes" xml:space="preserve">
          <source>Implement the methods required by the &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object.</source>
          <target state="translated">Реализуйте методы, необходимые для объекта &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="edbf1d07115719c5c7e93d86f1046b341948dbde" translate="yes" xml:space="preserve">
          <source>Implement the other methods required by &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;.</source>
          <target state="translated">Реализуйте другие методы, требуемые &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a8b02a72a8b5be24e42656704837d215920a00aa" translate="yes" xml:space="preserve">
          <source>Implement the xOpen method that opens a file and populates an &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; object, including setting pMethods to point to the &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object from the previous step.</source>
          <target state="translated">Реализуйте метод xOpen, который открывает файл и заполняет объект &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; , включая установку pMethods так, чтобы он указывал на объект &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; из предыдущего шага.</target>
        </trans-unit>
        <trans-unit id="87cdff8728ab99514f76ab384b99b3f529310cf0" translate="yes" xml:space="preserve">
          <source>Implementation Limits For SQLite</source>
          <target state="translated">Пределы внедрения для SQLite</target>
        </trans-unit>
        <trans-unit id="32808d9f543dc0758af6de0786717c61ede1f9c3" translate="yes" xml:space="preserve">
          <source>Implementations of aggregate SQL functions use this routine to allocate memory for storing their state.</source>
          <target state="translated">Введение агрегированных SQL-функций использует эту рутину для выделения памяти для хранения их состояния.</target>
        </trans-unit>
        <trans-unit id="7165ad4b3d6ce30cae4f1408c3a0f8924f93a699" translate="yes" xml:space="preserve">
          <source>Implementing a custom auxiliary function is similar to implementing a &lt;a href=&quot;appfunc&quot;&gt;scalar SQL function&lt;/a&gt;. The implementation should be a C function of type fts5_extension_function, defined as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4018bcd662e8105cb957cfc5a507fd128f58cc71" translate="yes" xml:space="preserve">
          <source>Implementing a custom auxiliary function is similar to implementing a &lt;a href=&quot;c3ref/create_function&quot;&gt;scalar SQL function&lt;/a&gt;. The implementation should be a C function of type fts5_extension_function, defined as follows:</source>
          <target state="translated">Реализация пользовательской вспомогательной функции аналогична реализации &lt;a href=&quot;c3ref/create_function&quot;&gt;скалярной функции SQL&lt;/a&gt; . Реализация должна быть функцией C типа fts5_extension_function, определенной следующим образом:</target>
        </trans-unit>
        <trans-unit id="cf816f713b7837e18241382d77dfd40a1b6bacf3" translate="yes" xml:space="preserve">
          <source>Implicit versus explicit transactions</source>
          <target state="translated">Неявные и явные сделки</target>
        </trans-unit>
        <trans-unit id="2f1059e48758f0fdc4ddd1f86b6fae46066d008b" translate="yes" xml:space="preserve">
          <source>Important bug fix: the IN operator was not working if either the left-hand or right-hand side was derived from an INTEGER PRIMARY KEY.</source>
          <target state="translated">Важное исправление:оператор IN не работал,если левая или правая сторона была получена от INTEGER PRIMARY KEY.</target>
        </trans-unit>
        <trans-unit id="a0fe78ecda103e8930771647f6dec46b0b349000" translate="yes" xml:space="preserve">
          <source>Impose A Limit On Heap Size</source>
          <target state="translated">Предельный размер кучи.</target>
        </trans-unit>
        <trans-unit id="ed65a595437d44d40ac23326bd1b47c2bed21cbd" translate="yes" xml:space="preserve">
          <source>Imposter Tables</source>
          <target state="translated">Импосферные столы</target>
        </trans-unit>
        <trans-unit id="8bd676db829fa1254e9904aed550e4eaa10267fe" translate="yes" xml:space="preserve">
          <source>Imposter tables are intended for analysis and debugging only. This is not a feature that most application developers should understand or even know about. Imposter tables are for experts only.</source>
          <target state="translated">Таблицы импостеров предназначены только для анализа и отладки.Это не та особенность,которую большинство разработчиков приложений должны понимать и даже знать.Таблицы импостеров предназначены только для экспертов.</target>
        </trans-unit>
        <trans-unit id="310974bd6288a19d56c62511f50674a5f6b79b46" translate="yes" xml:space="preserve">
          <source>Improper use of imposter tables can cause index corruption, though any corruption created this way can be fixed by running &lt;a href=&quot;lang_reindex&quot;&gt;REINDEX&lt;/a&gt;.</source>
          <target state="translated">Неправильное использование таблиц-самозванцев может вызвать повреждение индекса, хотя любое повреждение, созданное таким образом, можно исправить, запустив &lt;a href=&quot;lang_reindex&quot;&gt;REINDEX&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7cc4395a9bbe14f613da8e2834455cc8120ab269" translate="yes" xml:space="preserve">
          <source>Improve the &lt;a href=&quot;optoverview#omitnoopjoin&quot;&gt;omit-left-join optimization&lt;/a&gt; so that it works in cases where the right-hand table is UNIQUE but not necessarily NOT NULL.</source>
          <target state="translated">Улучшите &lt;a href=&quot;optoverview#omitnoopjoin&quot;&gt;оптимизацию опускания-левого соединения,&lt;/a&gt; чтобы она работала в тех случаях, когда правая таблица является УНИКАЛЬНОЙ, но не обязательно НЕ ПУСТОЙ.</target>
        </trans-unit>
        <trans-unit id="15dafad2713cbb23a2ff9f35c0397160bab08c72" translate="yes" xml:space="preserve">
          <source>Improve the &lt;a href=&quot;optoverview#pushdown&quot;&gt;push-down optimization&lt;/a&gt; so that it works for many LEFT JOINs.</source>
          <target state="translated">Улучшите &lt;a href=&quot;optoverview#pushdown&quot;&gt;оптимизацию push-down,&lt;/a&gt; чтобы она работала для многих LEFT JOIN.</target>
        </trans-unit>
        <trans-unit id="115d57ca1c0c67b9c62b8627805bc54cd437ed61" translate="yes" xml:space="preserve">
          <source>Improve the format of the &lt;a href=&quot;eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; raw output, so that it gives better information about the query plan and about the relationships between the various components of the plan.</source>
          <target state="translated">Улучшите формат необработанных выходных данных &lt;a href=&quot;eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; , чтобы он давал лучшую информацию о плане запроса и о взаимосвязях между различными компонентами плана.</target>
        </trans-unit>
        <trans-unit id="14bd38dceda1ed2c01f162d1f3444a0f4f8b3ecd" translate="yes" xml:space="preserve">
          <source>Improve the performance of fts3/4 queries that use the OR operator and at least one auxiliary fts function.</source>
          <target state="translated">Улучшите производительность запросов fts3/4,использующих оператор &quot;ИЛИ&quot; и хотя бы одну вспомогательную функцию fts.</target>
        </trans-unit>
        <trans-unit id="b9c8f318457693f2fa88c903d8d43102377e8c69" translate="yes" xml:space="preserve">
          <source>Improve the performance of the &lt;a href=&quot;lang_corefunc#replace&quot;&gt;replace() SQL function&lt;/a&gt; for cases where there are many substitutions on megabyte-sized strings, in an attempt to avoid OSSFuzz timeouts during testing. Check-in &lt;a href=&quot;https://www.sqlite.org/src/info/fab2c2b07b5d3&quot;&gt;fab2c2b07b5d3&lt;/a&gt;</source>
          <target state="translated">Повысьте производительность &lt;a href=&quot;lang_corefunc#replace&quot;&gt;SQL-функции replace ()&lt;/a&gt; для случаев, когда есть много замен в строках размером в мегабайт, чтобы избежать тайм-аутов OSSFuzz во время тестирования. Заезд &lt;a href=&quot;https://www.sqlite.org/src/info/fab2c2b07b5d3&quot;&gt;fab2c2b07b5d3&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="018ed5007819cc6bdecc581d33162266f7dd3fe7" translate="yes" xml:space="preserve">
          <source>Improved Concurrency</source>
          <target state="translated">Улучшенная конвертируемость</target>
        </trans-unit>
        <trans-unit id="072e9878a7002455b6aee44f48f435995e934eb5" translate="yes" xml:space="preserve">
          <source>Improved Concurrency.</source>
          <target state="translated">Улучшенная конвертируемость.</target>
        </trans-unit>
        <trans-unit id="fd596055fe2374f07cb22e2ed1eddaf72d523d42" translate="yes" xml:space="preserve">
          <source>Improved accuracy of floating-point conversions using &quot;long double&quot;.</source>
          <target state="translated">Повышенная точность преобразования с плавающей точкой с использованием &quot;long double&quot;.</target>
        </trans-unit>
        <trans-unit id="93fc56155be2598f9cbcf49e841b4a0140cf2c72" translate="yes" xml:space="preserve">
          <source>Improved algorithm for running queries with both an ORDER BY and a LIMIT where only the inner-most loop naturally generates rows in the correct order.</source>
          <target state="translated">Улучшенный алгоритм выполнения запросов как с ЗАКАЗОМ BY,так и с ОГРАНИЧЕНИЕМ,где только самый внутренний цикл естественным образом генерирует строки в правильном порядке.</target>
        </trans-unit>
        <trans-unit id="b070ecb9dcd3bd88a65a96d0f66e5d97c46345dc" translate="yes" xml:space="preserve">
          <source>Improved concurrency.</source>
          <target state="translated">Улучшенное совпадение.</target>
        </trans-unit>
        <trans-unit id="9f23829b58c284f668ccf3661f99fc3dbbec1e58" translate="yes" xml:space="preserve">
          <source>Improved crash-robustness: write the database page size into the rollback journal header.</source>
          <target state="translated">Улучшенная отказоустойчивость:запишите размер страницы базы данных в заголовок журнала отката.</target>
        </trans-unit>
        <trans-unit id="7321289816f2bf6478248e1de203f755159291e2" translate="yes" xml:space="preserve">
          <source>Improved de-quoting of column names for &lt;a href=&quot;lang_createtable#createtabas&quot;&gt;CREATE TABLE AS&lt;/a&gt; statements with an aggregate query on the right-hand side.</source>
          <target state="translated">Улучшено исключение кавычек в именах столбцов для операторов &lt;a href=&quot;lang_createtable#createtabas&quot;&gt;CREATE TABLE AS&lt;/a&gt; с помощью агрегированного запроса справа.</target>
        </trans-unit>
        <trans-unit id="bf0fc640800a9514f6d8718203e257a7690d605b" translate="yes" xml:space="preserve">
          <source>Improved error detection of misused aggregate functions.</source>
          <target state="translated">Улучшенное обнаружение ошибок при неправильном использовании функций агрегата.</target>
        </trans-unit>
        <trans-unit id="10bc21bc5dd5e57a67add58ea3202819c9a3c931" translate="yes" xml:space="preserve">
          <source>Improved error messages for &quot;foreign key mismatch&quot; showing the names of the two tables involved.</source>
          <target state="translated">Улучшенные сообщения об ошибках &quot;несовпадение посторонних ключей&quot;,показывающие имена двух задействованных таблиц.</target>
        </trans-unit>
        <trans-unit id="90dbb37d863c75537960cc5646693be15d517e85" translate="yes" xml:space="preserve">
          <source>Improved error messages for invalid boolean arguments to dot-commands in the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt;.</source>
          <target state="translated">Улучшены сообщения об ошибках для недопустимых логических аргументов для точечных команд в &lt;a href=&quot;cli&quot;&gt;оболочке командной строки&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b0dec14662a3a9f70430b0cb1619e2a60b783318" translate="yes" xml:space="preserve">
          <source>Improved error messages in the &lt;a href=&quot;rtree&quot;&gt;RTREE&lt;/a&gt; extension.</source>
          <target state="translated">Улучшены сообщения об ошибках в расширении &lt;a href=&quot;rtree&quot;&gt;RTREE&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2c62ff1f4b8293cf16ee945ea648937c03b9bc58" translate="yes" xml:space="preserve">
          <source>Improved fuzz-testing of database files, with fixes for problems found.</source>
          <target state="translated">Улучшено нечеткое тестирование файлов базы данных,с исправлениями найденных проблем.</target>
        </trans-unit>
        <trans-unit id="26cc1d230c175a8810d6dd909c46be8d110c203b" translate="yes" xml:space="preserve">
          <source>Improved name resolution for deeply nested queries.</source>
          <target state="translated">Улучшенное разрешение имен для глубоко вложенных запросов.</target>
        </trans-unit>
        <trans-unit id="d3565d7b7ed6ef82845a8772788a705a908dc7c3" translate="yes" xml:space="preserve">
          <source>Improved optimization of &lt;a href=&quot;lang_expr#castexpr&quot;&gt;CAST&lt;/a&gt; operators.</source>
          <target state="translated">Улучшена оптимизация операторов &lt;a href=&quot;lang_expr#castexpr&quot;&gt;CAST&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a23eee66d3ed2b6341f9511337eea95095e21556" translate="yes" xml:space="preserve">
          <source>Improved optimization of AND and OR operators when one or the other operand is a constant.</source>
          <target state="translated">Улучшенная оптимизация операторов AND и OR,когда тот или иной операнд является константой.</target>
        </trans-unit>
        <trans-unit id="524c0e2c2353a4bf3f7178e269f56a6cac4ecf9b" translate="yes" xml:space="preserve">
          <source>Improved optimization of ORDER BY clauses on compound queries.</source>
          <target state="translated">Улучшена оптимизация пунктов ORDER BY по сложным запросам.</target>
        </trans-unit>
        <trans-unit id="af8c59932cd987b7607835b656e726f3dcea902b" translate="yes" xml:space="preserve">
          <source>Improved optimization of aggregate subqueries contained within an aggregate query.</source>
          <target state="translated">Улучшена оптимизация совокупных подзапросов,содержащихся в совокупном запросе.</target>
        </trans-unit>
        <trans-unit id="d664cf7cb7a8aa891620cace778bbb7e18301125" translate="yes" xml:space="preserve">
          <source>Improved optimization of queries containing aggregate min() or max().</source>
          <target state="translated">Улучшена оптимизация запросов,содержащих aggregate min()или max().</target>
        </trans-unit>
        <trans-unit id="aa1222b8dcd6d3acb1bb29b90eb9192b7d6106ad" translate="yes" xml:space="preserve">
          <source>Improved performance of queries like &quot;SELECT min(x) FROM t WHERE y IN (?,?,?)&quot; assuming an index on t(x,y).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84a557fad116fe49221d1a9424a92f1e575e49e1" translate="yes" xml:space="preserve">
          <source>Improved performance of queries with many OR-connected terms in the WHERE clause that can all be indexed.</source>
          <target state="translated">Улучшена производительность запросов с большим количеством ИЛИ-связанных терминов в пункте WHERE,которые все могут быть проиндексированы.</target>
        </trans-unit>
        <trans-unit id="fc268c97ccbef9521d6905694e7c21645578065f" translate="yes" xml:space="preserve">
          <source>Improved pthreads detection in configure scripts.</source>
          <target state="translated">Усовершенствованное обнаружение потоков в скриптах конфигураций.</target>
        </trans-unit>
        <trans-unit id="17ac50232b81e80729264e903268e1bebc9e53d7" translate="yes" xml:space="preserve">
          <source>Improved query plan optimization when the DISTINCT keyword is present.</source>
          <target state="translated">Улучшена оптимизация плана запроса при наличии ключевого слова DISTINCT.</target>
        </trans-unit>
        <trans-unit id="59b96d30821cc9cbdef8a394c82f7fd97d223fd7" translate="yes" xml:space="preserve">
          <source>Improved resistance against goofy query planner decisions caused by incomplete or incorrect modifications to the &lt;a href=&quot;fileformat2#stat1tab&quot;&gt;sqlite_stat1&lt;/a&gt; table by the application.</source>
          <target state="translated">Повышена устойчивость к ошибочным решениям планировщика запросов, вызванным неполными или неправильными изменениями таблицы &lt;a href=&quot;fileformat2#stat1tab&quot;&gt;sqlite_stat1&lt;/a&gt; приложением.</target>
        </trans-unit>
        <trans-unit id="6b8ef39e97edafb5ec621a586930697f00cfaa0e" translate="yes" xml:space="preserve">
          <source>Improved response to out-of-memory errors</source>
          <target state="translated">Улучшенная реакция на ошибки вне памяти</target>
        </trans-unit>
        <trans-unit id="5ae15f37694ee149c6eea70b18fae46fd07528e4" translate="yes" xml:space="preserve">
          <source>Improved robustness against corrupt database files.</source>
          <target state="translated">Улучшенная устойчивость к поврежденным файлам базы данных.</target>
        </trans-unit>
        <trans-unit id="166028811fd163330b2455278e9c44de42779fbe" translate="yes" xml:space="preserve">
          <source>Improved support for Cygwin.</source>
          <target state="translated">Улучшенная поддержка Cygwin.</target>
        </trans-unit>
        <trans-unit id="4c53e2cba5a1410927dfe514c0901b0fd71f140c" translate="yes" xml:space="preserve">
          <source>Improved support for using the STDCALL calling convention in winsqlite3.dll.</source>
          <target state="translated">Улучшена поддержка использования соглашения об использовании STDCALL-вызовов в winsqlite3.dll.</target>
        </trans-unit>
        <trans-unit id="92763dc3583bdd282b9026c7f80e9e51775413fc" translate="yes" xml:space="preserve">
          <source>Improved syntax error messages in the parser</source>
          <target state="translated">Улучшенные сообщения об ошибках синтаксиса в синтаксическом анализаторе</target>
        </trans-unit>
        <trans-unit id="35f950df2561f1db8f684a7b33f41fde15c8c04c" translate="yes" xml:space="preserve">
          <source>Improved test coverage</source>
          <target state="translated">Улучшенное тестовое покрытие</target>
        </trans-unit>
        <trans-unit id="6fb91ee1a232fc876617f991f25282c326c1cf11" translate="yes" xml:space="preserve">
          <source>Improved test coverage. Fixed a few obscure bugs found by the improved tests.</source>
          <target state="translated">Улучшенное тестовое покрытие.Исправлено несколько непонятных ошибок,найденных в улучшенных тестах.</target>
        </trans-unit>
        <trans-unit id="5177fb86b97cfe6466bc589640835c3dab84ade3" translate="yes" xml:space="preserve">
          <source>Improved the cost estimation for an index scan which includes a WHERE clause that can be partially or fully evaluated using columns in the index and without having to do a table lookup. This fixes a performance regression that occurred for some obscure queries following the ORDER BY LIMIT optimization introduced in &lt;a href=&quot;#version_3_12_0&quot;&gt;version 3.12.0&lt;/a&gt;.</source>
          <target state="translated">Улучшена оценка стоимости сканирования индекса, которая включает предложение WHERE, которое можно частично или полностью оценить с помощью столбцов в индексе и без необходимости выполнять поиск в таблице. Это устраняет &lt;a href=&quot;#version_3_12_0&quot;&gt;снижение&lt;/a&gt; производительности, которое произошло для некоторых неясных запросов после оптимизации ORDER BY LIMIT, представленной в версии 3.12.0 .</target>
        </trans-unit>
        <trans-unit id="9737446abc238ba64625d047b10e2ea194379924" translate="yes" xml:space="preserve">
          <source>Improved the query planner so that the &lt;a href=&quot;optoverview#or_opt&quot;&gt;OR optimization&lt;/a&gt; can be used on &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt; even if one or more of the disjuncts use the &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt;, &lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt;, &lt;a href=&quot;lang_expr#regexp&quot;&gt;REGEXP&lt;/a&gt;, &lt;a href=&quot;lang_expr#match&quot;&gt;MATCH&lt;/a&gt; operators.</source>
          <target state="translated">Улучшен планировщик запросов, так что &lt;a href=&quot;optoverview#or_opt&quot;&gt;оптимизацию OR&lt;/a&gt; можно использовать для &lt;a href=&quot;vtab&quot;&gt;виртуальных таблиц,&lt;/a&gt; даже если один или несколько дизъюнктов используют &lt;a href=&quot;lang_expr#regexp&quot;&gt;операторы &lt;/a&gt;&lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; , &lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; , REGEXP , &lt;a href=&quot;lang_expr#match&quot;&gt;MATCH&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7c7991b90a25fa494ea7173ba16f41d0e843c78b" translate="yes" xml:space="preserve">
          <source>Improved the windows VFS to better defend against interference from anti-virus software.</source>
          <target state="translated">Улучшены окна VFS для лучшей защиты от помех от антивирусного программного обеспечения.</target>
        </trans-unit>
        <trans-unit id="6c9542942225b685370a9ff791f1911ab55a40d4" translate="yes" xml:space="preserve">
          <source>Improved tracing and debugging facilities in the Windows &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;.</source>
          <target state="translated">Улучшенные средства трассировки и отладки в Windows &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c1ee9a0442382c4cebcfe1b576c0d1fff396e4cb" translate="yes" xml:space="preserve">
          <source>Improved unicode filename handling in the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; on Windows.</source>
          <target state="translated">Улучшена обработка файлов Unicode в &lt;a href=&quot;cli&quot;&gt;оболочке командной строки&lt;/a&gt; в Windows.</target>
        </trans-unit>
        <trans-unit id="09e6f225ca0ca885645a927e0763b14b484dc7f0" translate="yes" xml:space="preserve">
          <source>Improvements and bug-fixes in support for &lt;a href=&quot;compile#omit_floating_point&quot;&gt;SQLITE_OMIT_FLOATING_POINT&lt;/a&gt;.</source>
          <target state="translated">Улучшения и исправления ошибок в поддержке &lt;a href=&quot;compile#omit_floating_point&quot;&gt;SQLITE_OMIT_FLOATING_POINT&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c4b534f7c6c26f504f16d9c38af50fef3ae45002" translate="yes" xml:space="preserve">
          <source>Improvements to &quot;dot-command&quot; handling in the &lt;a href=&quot;cli&quot;&gt;Command Line Interface&lt;/a&gt;.</source>
          <target state="translated">Улучшения в обработке &quot;точечных команд&quot; в &lt;a href=&quot;cli&quot;&gt;интерфейсе командной строки&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="47099268e1cc1a7d37272d0a960d324c9d2e5b20" translate="yes" xml:space="preserve">
          <source>Improvements to &lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt;.</source>
          <target state="translated">Улучшения в &lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="18fe2fab208a9bdfd95bd5b0724b7f338ba76be8" translate="yes" xml:space="preserve">
          <source>Improvements to cost estimates for the &lt;a href=&quot;optoverview#skipscan&quot;&gt;skip-scan optimization&lt;/a&gt;.</source>
          <target state="translated">Улучшения в оценке затрат для &lt;a href=&quot;optoverview#skipscan&quot;&gt;оптимизации пропуска сканирования&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f56d95c4feb425fac688efbe211f20dca39f2585" translate="yes" xml:space="preserve">
          <source>Improvements to rounding behavior, so that the results of rounding binary numbers using the &lt;a href=&quot;lang_corefunc#round&quot;&gt;round()&lt;/a&gt; function are closer to what people who are used to thinking in decimal actually expect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5353c2af79675cc29c5733088967c970c2cbd2d3" translate="yes" xml:space="preserve">
          <source>Improvements to test coverage, other minor bugs fixed, memory leaks plugged, code refactored and/or recommended in places for easier reading.</source>
          <target state="translated">Улучшения в тестировании покрытия,исправлены другие незначительные ошибки,устранена утечка памяти,код восстановлен и/или рекомендован в местах для более легкого чтения.</target>
        </trans-unit>
        <trans-unit id="1672d028ed8042c2cdc755bd4feb4bfb1a305542" translate="yes" xml:space="preserve">
          <source>Improvements to the &quot;.help&quot; command.</source>
          <target state="translated">Улучшения в команде &quot;.help&quot;.</target>
        </trans-unit>
        <trans-unit id="9829e00db8ef5babdf62ad53520c9aed14ba5d0e" translate="yes" xml:space="preserve">
          <source>Improvements to the &quot;PRAGMA integrity_check&quot; command</source>
          <target state="translated">Улучшения команды &quot;PRAGMA integrity_check&quot;.</target>
        </trans-unit>
        <trans-unit id="e5c25ee1584b55a6798dccb371f9de65d6e26320" translate="yes" xml:space="preserve">
          <source>Improvements to the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt;:</source>
          <target state="translated">Улучшения &lt;a href=&quot;cli&quot;&gt;оболочки командной строки&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="7bd7a08c86f6e2927260bf75b7f206267bdb5a66" translate="yes" xml:space="preserve">
          <source>Improvements to the &lt;a href=&quot;cli#recover&quot;&gt;.recover dot-command&lt;/a&gt; in the &lt;a href=&quot;cli&quot;&gt;CLI&lt;/a&gt; so that it recovers more content from corrupt database files.</source>
          <target state="translated">Усовершенствования &lt;a href=&quot;cli#recover&quot;&gt;команды точки .recover&lt;/a&gt; в &lt;a href=&quot;cli&quot;&gt;интерфейсе &lt;/a&gt;командной строки, чтобы она восстанавливала больше содержимого из поврежденных файлов базы данных.</target>
        </trans-unit>
        <trans-unit id="56bedeb29e748e173925f592478fb7224bd2a9a7" translate="yes" xml:space="preserve">
          <source>Improvements to the &lt;a href=&quot;fts3#*fts4automergecmd&quot;&gt;automerge command&lt;/a&gt; of &lt;a href=&quot;fts3#fts4&quot;&gt;FTS4&lt;/a&gt; to better control the index size for a full-text index that is subject to a large number of updates.</source>
          <target state="translated">Улучшения в &lt;a href=&quot;fts3#*fts4automergecmd&quot;&gt;команду automerge&lt;/a&gt; из &lt;a href=&quot;fts3#fts4&quot;&gt;FTS4&lt;/a&gt; , чтобы лучше контролировать размер индекса для полнотекстового индекса , который является предметом большого количества обновлений.</target>
        </trans-unit>
        <trans-unit id="4f8a0d7434e9fa0e3d93bd594ec2f731beeeee4c" translate="yes" xml:space="preserve">
          <source>Improvements to the &lt;a href=&quot;optoverview&quot;&gt;query planner&lt;/a&gt;:</source>
          <target state="translated">Улучшения в &lt;a href=&quot;optoverview&quot;&gt;планировщике запросов&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="64a384308e143ce85fad7f48be7bf89bd88826a0" translate="yes" xml:space="preserve">
          <source>Improvements to the &lt;a href=&quot;syntaxdiagrams&quot;&gt;syntax bubble diagrams&lt;/a&gt;</source>
          <target state="translated">Улучшения &lt;a href=&quot;syntaxdiagrams&quot;&gt;синтаксических пузырьковых диаграмм&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="444f392b3ac06b6a270033461a34681437b33fc9" translate="yes" xml:space="preserve">
          <source>Improvements to the Makefiles and build scripts used by VisualStudio.</source>
          <target state="translated">Усовершенствования Makefiles и скриптов сборки,используемых VisualStudio.</target>
        </trans-unit>
        <trans-unit id="187c307e740f14eb7715914261b63385a7891140" translate="yes" xml:space="preserve">
          <source>Improvements to the amalgamation generator script so that all symbols are prefixed with either SQLITE_PRIVATE or SQLITE_API.</source>
          <target state="translated">Улучшен скрипт генератора слияний,так что все символы префиксованы либо SQLITE_PRIVATE,либо SQLITE_API.</target>
        </trans-unit>
        <trans-unit id="8487f548381bd47de49bbe554c9e3c26fcef5a1f" translate="yes" xml:space="preserve">
          <source>Improvements to the comments in the VDBE byte-code display when running &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt;.</source>
          <target state="translated">Улучшения комментариев в отображении байтового кода VDBE при запуске &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e6a8494de38f18f2b5e148ff117a682e5366a648" translate="yes" xml:space="preserve">
          <source>Improvements to the effectiveness and accuracy of the &lt;a href=&quot;lang_corefunc#likelihood&quot;&gt;likelihood()&lt;/a&gt;, &lt;a href=&quot;lang_corefunc#likely&quot;&gt;likely()&lt;/a&gt;, and &lt;a href=&quot;lang_corefunc#unlikely&quot;&gt;unlikely()&lt;/a&gt; SQL hint functions.</source>
          <target state="translated">Повышение эффективности и точности подсказок SQL-функций &lt;a href=&quot;lang_corefunc#likelihood&quot;&gt;правдоподобия ()&lt;/a&gt; , &lt;a href=&quot;lang_corefunc#likely&quot;&gt;вероятно ()&lt;/a&gt; и &lt;a href=&quot;lang_corefunc#unlikely&quot;&gt;маловероятно ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fb078db70835b73a43d340944c34ddf931e04436" translate="yes" xml:space="preserve">
          <source>Improvements to the handling of CSV inputs in the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt;</source>
          <target state="translated">Улучшения обработки входных данных CSV в &lt;a href=&quot;cli&quot;&gt;оболочке командной строки.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="35621122cb25f12ea29297b200f9cd7f54653df0" translate="yes" xml:space="preserve">
          <source>Improvements to the query planner so that it makes better estimates of plan costs and hence does a better job of choosing the right plan, especially when &lt;a href=&quot;compile#enable_stat2&quot;&gt;SQLITE_ENABLE_STAT2&lt;/a&gt; is used.</source>
          <target state="translated">Улучшения в планировщике запросов, чтобы он лучше оценивал плановые затраты и, следовательно, лучше справлялся с выбором правильного плана, особенно при использовании &lt;a href=&quot;compile#enable_stat2&quot;&gt;SQLITE_ENABLE_STAT2&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b56408ef9cd6514cec8e529db1c7c154a8214dac" translate="yes" xml:space="preserve">
          <source>Improvements to the windows makefiles and build processes.</source>
          <target state="translated">Улучшения в создании оконных файлов и процессах сборки.</target>
        </trans-unit>
        <trans-unit id="01c7395c54005792d7fd39d556adb0b44131f473" translate="yes" xml:space="preserve">
          <source>In &quot;column&quot; mode (and also in &quot;box&quot;, &quot;table&quot;, and &quot;markdown&quot; modes) the width of columns adjusts automatically. But you can override this, providing a minimum width for each column using the &quot;.width&quot; command. The arguments to &quot;.width&quot; are integers which are the minimum number of spaces to devote to each column. Negative numbers mean right-justify. Thus:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b24a3b4f842f4beb9d0cf338bd2105050638be32" translate="yes" xml:space="preserve">
          <source>In &quot;line&quot; mode, each column in a row of the database is shown on a line by itself. Each line consists of the column name, an equal sign and the column data. Successive records are separated by a blank line. Here is an example of line mode output:</source>
          <target state="translated">В режиме &quot;строка&quot; каждый столбец в строке БД отображается на строке сам по себе.Каждая строка состоит из названия столбца,знака равенства и данных столбца.Последующие записи разделены пустой строкой.Приведем пример вывода в &quot;строчном&quot; режиме:</target>
        </trans-unit>
        <trans-unit id="ba464cb54f172ce24a6d088a3cb06af2c611f784" translate="yes" xml:space="preserve">
          <source>In &quot;quote&quot; mode, the output is formatted as SQL literals. Strings are enclosed in single-quotes and internal single-quotes are escaped by doubling. Blobs are displayed in hexadecimal blob literal notation (Ex: x'abcd'). Numbers are displayed as ASCII text and NULL values are shown as &quot;NULL&quot;. All columns are separated from each other by a comma (or whatever alternative character is selected using &quot;.separator&quot;).</source>
          <target state="translated">В режиме &quot;кавычки&quot; вывод форматируется как SQL-литералы.Строки заключены в одинарные кавычки,а внутренние одинарные кавычки экранированы удвоением.Капли выводятся в шестнадцатеричной блочной литературной нотации (Ex:x'abcd').Цифры отображаются в виде ASCII текста,а NULL значения отображаются в виде &quot;NULL&quot;.Все столбцы отделены друг от друга запятой (или любым другим альтернативным символом,выбранным с помощью &quot;.разделителя&quot;).</target>
        </trans-unit>
        <trans-unit id="e70135d1b4c87e02724b6a6725f67c0cdcedb6a8" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;../wal&quot;&gt;WAL mode&lt;/a&gt;, multiple &lt;a href=&quot;sqlite3&quot;&gt;database connections&lt;/a&gt; that are open on the same database file can each be reading a different historical version of the database file. When a &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; begins a read transaction, that connection sees an unchanging copy of the database as it existed for the point in time when the transaction first started. Subsequent changes to the database from other connections are not seen by the reader until a new read transaction is started.</source>
          <target state="translated">В &lt;a href=&quot;../wal&quot;&gt;режиме WAL&lt;/a&gt; несколько &lt;a href=&quot;sqlite3&quot;&gt;соединений с базой данных&lt;/a&gt; , открытых для одного и того же файла базы данных, могут читать разные исторические версии файла базы данных. Когда &lt;a href=&quot;sqlite3&quot;&gt;соединение&lt;/a&gt; с базой данных начинает транзакцию чтения, это соединение видит неизменную копию базы данных в том виде, в котором она существовала на момент первого запуска транзакции. Последующие изменения в базе данных из других подключений не видны читателю, пока не будет запущена новая транзакция чтения.</target>
        </trans-unit>
        <trans-unit id="545faac3a749c9fbe686ac2c42b0a8ce0746bb4b" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;https://sqlite.org/releaselog/3_5_0.html&quot;&gt;version 3.5.0&lt;/a&gt; (2007-09-04), shared-cache mode was modified so that the same cache can be shared across an entire process rather than just within a single thread. Prior to this change, there were restrictions on passing database connections between threads. Those restrictions were dropped in 3.5.0 update. This document describes shared-cache mode as of version 3.5.0.</source>
          <target state="translated">В &lt;a href=&quot;https://sqlite.org/releaselog/3_5_0.html&quot;&gt;версии 3.5.0&lt;/a&gt; (2007-09-04) режим общего кэша был изменен таким образом, что один и тот же кеш может использоваться для всего процесса, а не только в пределах одного потока. До этого изменения существовали ограничения на передачу соединений с базой данных между потоками. Эти ограничения были сняты в обновлении 3.5.0. В этом документе описан режим общего кэша версии 3.5.0.</target>
        </trans-unit>
        <trans-unit id="8b22aada76f514795f041039b72ce60807690314" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode=TRUNCATE&lt;/a&gt; mode, call fsync() immediately after truncating the journal file to ensure that the transaction is durable across a power loss.</source>
          <target state="translated">В режиме &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode = TRUNCATE&lt;/a&gt; вызовите fsync () сразу после усечения файла журнала, чтобы гарантировать, что транзакция будет устойчивой при потере питания.</target>
        </trans-unit>
        <trans-unit id="b06cad3e4dffb16827f43add94eb56f4465695b9" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;sharedcache&quot;&gt;shared cache mode&lt;/a&gt;, attempting to attach the same database file more than once results in an error.</source>
          <target state="translated">В &lt;a href=&quot;sharedcache&quot;&gt;режиме общего кеша&lt;/a&gt; попытка подключить один и тот же файл базы данных более одного раза приводит к ошибке.</target>
        </trans-unit>
        <trans-unit id="9f41922c2aa21a0c294b4cbf9d4bf48e3b8e9e1c" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt;, if a writer crashes and leaves the &lt;a href=&quot;walformat#shm&quot;&gt;shm file&lt;/a&gt; in an inconsistent state, subsequent transactions are now able to recover the shm file even if there are active read transactions. Before this enhancement, shm file recovery that scenario would result in an &lt;a href=&quot;rescode#protocol&quot;&gt;SQLITE_PROTOCOL&lt;/a&gt; error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d45c296410a6677088e7e7ac84b1e93a1f22edc" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt;, multiple &lt;a href=&quot;#sqlite3&quot;&gt;database connections&lt;/a&gt; that are open on the same database file can each be reading a different historical version of the database file. When a &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; begins a read transaction, that connection sees an unchanging copy of the database as it existed for the point in time when the transaction first started. Subsequent changes to the database from other connections are not seen by the reader until a new read transaction is started.</source>
          <target state="translated">В &lt;a href=&quot;wal&quot;&gt;режиме WAL&lt;/a&gt; несколько &lt;a href=&quot;#sqlite3&quot;&gt;соединений с базой данных&lt;/a&gt; , открытых для одного и того же файла базы данных, могут читать разные исторические версии файла базы данных. Когда &lt;a href=&quot;#sqlite3&quot;&gt;соединение&lt;/a&gt; с базой данных начинает транзакцию чтения, это соединение видит неизменную копию базы данных в том виде, в котором она существовала на момент первого запуска транзакции. Последующие изменения в базе данных из других подключений не видны читателю, пока не будет запущена новая транзакция чтения.</target>
        </trans-unit>
        <trans-unit id="ddd420dd1a1ef7aee27736d7c043708aacde1ceb" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;wal&quot;&gt;WAL&lt;/a&gt; mode when synchronous is NORMAL (1), the WAL file is synchronized before each &lt;a href=&quot;wal#ckpt&quot;&gt;checkpoint&lt;/a&gt; and the database file is synchronized after each completed &lt;a href=&quot;wal#ckpt&quot;&gt;checkpoint&lt;/a&gt; and the WAL file header is synchronized when a WAL file begins to be reused after a checkpoint, but no sync operations occur during most transactions. With synchronous=FULL in WAL mode, an additional sync operation of the WAL file happens after each transaction commit. The extra WAL sync following each transaction help ensure that transactions are durable across a power loss. Transactions are consistent with or without the extra syncs provided by synchronous=FULL. If durability is not a concern, then synchronous=NORMAL is normally all one needs in WAL mode.</source>
          <target state="translated">В режиме &lt;a href=&quot;wal&quot;&gt;WAL,&lt;/a&gt; когда синхронный - NORMAL (1), файл WAL синхронизируется перед каждой &lt;a href=&quot;wal#ckpt&quot;&gt;контрольной точкой,&lt;/a&gt; а файл базы данных синхронизируется после каждой завершенной &lt;a href=&quot;wal#ckpt&quot;&gt;контрольной точки,&lt;/a&gt; а заголовок файла WAL синхронизируется, когда файл WAL начинает повторно использоваться после контрольной точки, но нет операции синхронизации происходят во время большинства транзакций. При synchronous = FULL в режиме WAL дополнительная операция синхронизации файла WAL происходит после каждой фиксации транзакции. Дополнительная синхронизация WAL после каждой транзакции помогает гарантировать долговечность транзакций при отключении питания. Транзакции согласуются с дополнительными синхронизациями, обеспечиваемыми параметром synchronous = FULL, или без них. Если долговечность не имеет значения, то в режиме WAL обычно достаточно synchronous = NORMAL.</target>
        </trans-unit>
        <trans-unit id="5a4b7cd3ba1686efa11d9b9c015db21adcf22977" translate="yes" xml:space="preserve">
          <source>In CHECK constraints of a table definition.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1207ec4eb27468881c3e5a75c509547ec16346af" translate="yes" xml:space="preserve">
          <source>In DDL</source>
          <target state="translated">В ЦБТ</target>
        </trans-unit>
        <trans-unit id="06bb676fb43ba64638eb5aba12a8d226fa52bf86" translate="yes" xml:space="preserve">
          <source>In DEFAULT constraints of a table definition.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fc22d3edb7a25933470b0fc98cd018feb112e2e" translate="yes" xml:space="preserve">
          <source>In DML</source>
          <target state="translated">В DML</target>
        </trans-unit>
        <trans-unit id="805c25b267572c14bae2116b6611f039f1f80c5c" translate="yes" xml:space="preserve">
          <source>In I/O error tests, after the I/O error simulation failure mechanism is disabled, the database is examined using &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt; to make sure that the I/O error has not introduced database corruption.</source>
          <target state="translated">В тестах ошибок ввода-вывода после того, как механизм сбоя моделирования ошибок ввода-вывода отключен, база данных проверяется с помощью &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integration_check,&lt;/a&gt; чтобы убедиться, что ошибка ввода-вывода не привела к повреждению базы данных.</target>
        </trans-unit>
        <trans-unit id="0f2cfcdcfc92b4b01bee8dec645ecb5ceaaa8098" translate="yes" xml:space="preserve">
          <source>In Lemon, the tokenizer calls the parser. Yacc operates the other way around, with the parser calling the tokenizer. The Lemon approach is reentrant and threadsafe, whereas Yacc uses global variables and is therefore neither. Reentrancy is especially important for SQLite since some SQL statements make recursive calls to the parser. For example, when parsing a CREATE TABLE statement, SQLite invokes the parser recursively to generate an INSERT statement to make a new entry in the &lt;a href=&quot;fileformat2#sqlite_master&quot;&gt;sqlite_master&lt;/a&gt; table.</source>
          <target state="translated">В Lemon токенизатор вызывает парсер. Yacc работает наоборот, парсер вызывает токенизатор. Подход Lemon является реентерабельным и потокобезопасным, тогда как Yacc использует глобальные переменные и поэтому ни то, ни другое. Повторный вход особенно важен для SQLite, поскольку некоторые операторы SQL рекурсивно обращаются к синтаксическому анализатору. Например, при синтаксическом анализе оператора CREATE TABLE SQLite рекурсивно вызывает синтаксический анализатор для генерации оператора INSERT для создания новой записи в таблице &lt;a href=&quot;fileformat2#sqlite_master&quot;&gt;sqlite_master&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d3369588aeb6a765cf20a5709a06e66a042c401f" translate="yes" xml:space="preserve">
          <source>In NORMAL locking-mode (the default unless overridden at compile-time using &lt;a href=&quot;compile#default_locking_mode&quot;&gt;SQLITE_DEFAULT_LOCKING_MODE&lt;/a&gt;), a database connection unlocks the database file at the conclusion of each read or write transaction. When the locking-mode is set to EXCLUSIVE, the database connection never releases file-locks. The first time the database is read in EXCLUSIVE mode, a shared lock is obtained and held. The first time the database is written, an exclusive lock is obtained and held.</source>
          <target state="translated">В НОРМАЛЬНОМ режиме блокировки (по умолчанию, если он не переопределен во время компиляции с помощью &lt;a href=&quot;compile#default_locking_mode&quot;&gt;SQLITE_DEFAULT_LOCKING_MODE&lt;/a&gt; ), соединение с базой данных разблокирует файл базы данных при завершении каждой транзакции чтения или записи. Когда для режима блокировки установлено значение EXCLUSIVE, соединение с базой данных никогда не снимает блокировки файлов. При первом чтении базы данных в ЭКСКЛЮЗИВНОМ режиме получается и удерживается разделяемая блокировка. При первой записи в базу данных получается и удерживается исключительная блокировка.</target>
        </trans-unit>
        <trans-unit id="f8c693ba3fad2e1d7df97dd42327c19b66a284bb" translate="yes" xml:space="preserve">
          <source>In SQLite</source>
          <target state="translated">В SQLite</target>
        </trans-unit>
        <trans-unit id="e298a84cbd8720f440fc21a95dd67ebcefa40857" translate="yes" xml:space="preserve">
          <source>In SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_10_0.html&quot;&gt;version 3.10.0&lt;/a&gt; (2016-01-06) and later, the colUsed field is available to indicate which fields of the virtual table are actually used by the statement being prepared. If the lowest bit of colUsed is set, that means that the first column is used. The second lowest bit corresponds to the second column. And so forth. If the most significant bit of colUsed is set, that means that one or more columns other than the first 63 columns are used. If column usage information is needed by the &lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter&lt;/a&gt; method, then the required bits must be encoded into either the idxNum or idxStr output fields.</source>
          <target state="translated">В SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_10_0.html&quot;&gt;версии 3.10.0&lt;/a&gt; (2016-01-06) и более поздних версиях доступно поле colUsed, чтобы указать, какие поля виртуальной таблицы фактически используются подготавливаемым оператором. Если установлен младший бит colUsed, это означает, что используется первый столбец. Второй младший бит соответствует второму столбцу. И так далее. Если установлен самый старший бит colUsed, это означает, что используются один или несколько столбцов, кроме первых 63 столбцов. Если методу &lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter&lt;/a&gt; требуется информация об использовании столбца , то требуемые биты должны быть закодированы в выходные поля idxNum или idxStr.</target>
        </trans-unit>
        <trans-unit id="828bdde156beec9d0455bf5a047ac9dedf77b343" translate="yes" xml:space="preserve">
          <source>In SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_28_0.html&quot;&gt;version 3.28.0&lt;/a&gt; (2019-04-16), windows function support was extended to include the EXCLUDE clause, GROUPS frame types, window chaining, and support for &quot;&amp;lt;expr&amp;gt; PRECEDING&quot; and &quot;&amp;lt;expr&amp;gt; FOLLOWING&quot; boundaries in RANGE frames.</source>
          <target state="translated">В SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_28_0.html&quot;&gt;версии 3.28.0&lt;/a&gt; (2019-04-16) поддержка функций Windows была расширена за счет включения предложения EXCLUDE, типов фреймов GROUPS, цепочки окон и поддержки границ &amp;laquo;&amp;lt;expr&amp;gt; PRECEDING&amp;raquo; и &amp;laquo;&amp;lt;expr&amp;gt; FOLLOWING&amp;raquo; в ДИАПАЗОН кадров.</target>
        </trans-unit>
        <trans-unit id="7a9dbb486e8961eb98612eeeff0292e2cdc9f06c" translate="yes" xml:space="preserve">
          <source>In SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_6_23_1.html&quot;&gt;version 3.6.23.1&lt;/a&gt; (2010-03-26) and earlier, &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; used to always return &lt;a href=&quot;rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt; if it was invoked again after returning anything other than &lt;a href=&quot;rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt; without an intervening call to &lt;a href=&quot;c3ref/reset&quot;&gt;sqlite3_reset()&lt;/a&gt;. This caused problems on some poorly written smartphone applications which did not correctly handle the &lt;a href=&quot;rescode#locked&quot;&gt;SQLITE_LOCKED&lt;/a&gt; and &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; error returns. Rather than fix the many defective smartphone applications, the behavior of SQLite was changed in 3.6.23.2 to automatically reset the prepared statement. But that changed caused issues in other improperly implemented applications that were actually looking for an &lt;a href=&quot;rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt; return to terminate their query loops. (Anytime an application gets an SQLITE_MISUSE error code from SQLite, that means the application is misusing the SQLite interface and is thus incorrectly implemented.) The SQLITE_OMIT_AUTORESET interface was added to SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_5.html&quot;&gt;version 3.7.5&lt;/a&gt; (2011-02-01) in an effort to get all of the (broken) applications to work again without having to actually fix the applications.</source>
          <target state="translated">В &lt;a href=&quot;https://sqlite.org/releaselog/3_6_23_1.html&quot;&gt;версии&lt;/a&gt; SQLite 3.6.23.1 (2010-03-26) и ранее &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step ()&lt;/a&gt; всегда возвращал &lt;a href=&quot;rescode#misuse&quot;&gt;SQLITE_MISUSE,&lt;/a&gt; если он был вызван снова после возврата чего-либо, кроме &lt;a href=&quot;rescode#row&quot;&gt;SQLITE_ROW,&lt;/a&gt; без промежуточного вызова &lt;a href=&quot;c3ref/reset&quot;&gt;sqlite3_reset ()&lt;/a&gt; . Это вызывало проблемы в некоторых плохо написанных приложениях для смартфонов, которые некорректно обрабатывали &lt;a href=&quot;rescode#locked&quot;&gt;ошибки SQLITE_LOCKED&lt;/a&gt; и &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; . Вместо исправления многих дефектных приложений для смартфонов в 3.6.23.2 было изменено поведение SQLite для автоматического сброса подготовленного оператора. Но это изменение вызвало проблемы в других неправильно реализованных приложениях, которые фактически искали &lt;a href=&quot;rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt;вернуться, чтобы завершить цикл запросов. (Каждый раз, когда приложение получает код ошибки SQLITE_MISUSE от SQLite, это означает, что приложение неправильно использует интерфейс SQLite и, таким образом, неправильно реализовано.) Интерфейс SQLITE_OMIT_AUTORESET был добавлен в SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_5.html&quot;&gt;версии 3.7.5&lt;/a&gt; (01.02.2011) в попытке исправить заставить все (сломанные) приложения снова работать без необходимости исправлять приложения.</target>
        </trans-unit>
        <trans-unit id="ae75dbb8c6b830d21fb52ab24e85cf97f8c0d055" translate="yes" xml:space="preserve">
          <source>In SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_0.html&quot;&gt;version 3.8.0&lt;/a&gt; (2013-08-26) and later, an &lt;a href=&quot;rescode#warning_autoindex&quot;&gt;SQLITE_WARNING_AUTOINDEX&lt;/a&gt; message is sent to the &lt;a href=&quot;errlog&quot;&gt;error log&lt;/a&gt; every time a statement is prepared that uses an automatic index. Application developers can and should use these warnings to identify the need for new persistent indices in the schema.</source>
          <target state="translated">В SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_0.html&quot;&gt;версии 3.8.0&lt;/a&gt; (2013-08-26) и более поздних &lt;a href=&quot;rescode#warning_autoindex&quot;&gt;версий&lt;/a&gt; сообщение SQLITE_WARNING_AUTOINDEX отправляется в &lt;a href=&quot;errlog&quot;&gt;журнал ошибок&lt;/a&gt; каждый раз, когда подготавливается инструкция, использующая автоматический индекс. Разработчики приложений могут и должны использовать эти предупреждения для определения потребности в новых постоянных индексах в схеме.</target>
        </trans-unit>
        <trans-unit id="311b836bebf13bf229bfb5d427d7d61edb397191" translate="yes" xml:space="preserve">
          <source>In SQLite Version 3</source>
          <target state="translated">В SQLite версии 3</target>
        </trans-unit>
        <trans-unit id="44b0d77bd3716352e42cf5f2569dabd7987b859f" translate="yes" xml:space="preserve">
          <source>In SQLite version 2</source>
          <target state="translated">В SQLite версии 2</target>
        </trans-unit>
        <trans-unit id="ab1b358df4951321dec42436274a7fc7055620c8" translate="yes" xml:space="preserve">
          <source>In SQLite version 2, if many processes are reading from the database, it might be the case that there is never a time when there are no active readers. And if there is always at least one read lock on the database, no process would ever be able to make changes to the database because it would be impossible to acquire a write lock. This situation is called &lt;em&gt;writer starvation&lt;/em&gt;.</source>
          <target state="translated">В SQLite версии 2, если многие процессы читают из базы данных, может случиться так, что никогда не бывает времени, когда нет активных читателей. И если в базе данных всегда есть хотя бы одна блокировка чтения, ни один процесс никогда не сможет внести изменения в базу данных, потому что было бы невозможно получить блокировку записи. Эта ситуация называется &lt;em&gt;писательским голодом&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="0e7545ebfe6eb34f26f31fe8304f6f550663c8e8" translate="yes" xml:space="preserve">
          <source>In SQLite version 3, the sqlite3_exec routine is just a wrapper around calls to the prepared statement interface.</source>
          <target state="translated">В SQLite версии 3 рутина sqlite3_exec-это просто обёртка вокруг вызовов подготовленного интерфейса оператора.</target>
        </trans-unit>
        <trans-unit id="e7a56207acc60b29c6f42211f54c5ca8f6e54fa3" translate="yes" xml:space="preserve">
          <source>In SQLite version 3.0, the rowid is a 64-bit signed integer. This is an expansion of SQLite version 2.8 which only permitted rowids of 32-bits.</source>
          <target state="translated">В SQLite версии 3.0 rowid представляет собой 64-битное целое число с цифровой подписью.Это расширение SQLite версии 2.8,которое разрешает использовать только рядки из 32 бит.</target>
        </trans-unit>
        <trans-unit id="eade6a0b14d85e68f1dde5969cd3e571c5e3e4f6" translate="yes" xml:space="preserve">
          <source>In SQLite version 3.5.0 and 3.5.1, it was possible to define the SQLITE_OMIT_MEMORY_ALLOCATION which would cause the built-in implementation of these routines to be omitted. That capability is no longer provided. Only built-in memory allocators can be used.</source>
          <target state="translated">В SQLite версий 3.5.0 и 3.5.1 можно было определить SQLITE_OMIT_MEMORY_ALLOCATION,что приведет к тому,что встроенная реализация этих подпрограмм будет опущена.Эта возможность больше не предоставляется.Можно использовать только встроенные аллокаторы памяти.</target>
        </trans-unit>
        <trans-unit id="7278a0046b6c686e7491a606645054d45ac6a9da" translate="yes" xml:space="preserve">
          <source>In SQLite versions 3.3.0 through 3.4.2 when shared-cache mode is enabled, a database connection may only be used by the thread that called &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt; to create it. And a connection could only share cache with another connection in the same thread. These restrictions were dropped beginning with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_5_0.html&quot;&gt;version 3.5.0&lt;/a&gt; (2007-09-04).</source>
          <target state="translated">В версиях SQLite с 3.3.0 по 3.4.2, когда включен режим общего кэша, соединение с базой данных может использоваться только тем потоком, который вызвал &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open ()&lt;/a&gt; для его создания. И соединение могло совместно использовать кеш только с другим соединением в том же потоке. Эти ограничения были сняты, начиная с &lt;a href=&quot;https://sqlite.org/releaselog/3_5_0.html&quot;&gt;версии&lt;/a&gt; SQLite 3.5.0 (2007-09-04).</target>
        </trans-unit>
        <trans-unit id="4af0e6be92f4dba4280a2c7e3664bbca74929393" translate="yes" xml:space="preserve">
          <source>In SQLite, a column with type INTEGER PRIMARY KEY is an alias for the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt; (except in &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables) which is always a 64-bit signed integer.</source>
          <target state="translated">В SQLite столбец с типом INTEGER PRIMARY KEY является псевдонимом для &lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt; (кроме таблиц &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; ), который всегда является 64-битным целым числом со знаком .</target>
        </trans-unit>
        <trans-unit id="d48f1e4d1dbe48d61b2a0bc14d1d629523402032" translate="yes" xml:space="preserve">
          <source>In SQLite, a database object (a table, index, trigger or view) is identified by the name of the object and the name of the database that it resides in. Database objects may reside in the main database, the temp database, or in an &lt;a href=&quot;lang_attach&quot;&gt;attached database&lt;/a&gt;.</source>
          <target state="translated">В SQLite объект базы данных (таблица, индекс, триггер или представление) идентифицируется по имени объекта и имени базы данных, в которой он находится. Объекты базы данных могут находиться в основной базе данных, временной базе данных или в &lt;a href=&quot;lang_attach&quot;&gt;прилагается база данных&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5d037fc285a8e821543df8fc13d9f7837388fd3a" translate="yes" xml:space="preserve">
          <source>In SQLite, table rows normally have a 64-bit signed integer &lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt; which is unique among all rows in the same table. (&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables are the exception.)</source>
          <target state="translated">В SQLite строки таблицы обычно имеют 64-разрядное целое число со &lt;a href=&quot;lang_createtable#rowid&quot;&gt;знаком ROWID,&lt;/a&gt; которое уникально среди всех строк в одной таблице. ( &lt;a href=&quot;withoutrowid&quot;&gt;Исключение составляют&lt;/a&gt; таблицы БЕЗ ROWID .)</target>
        </trans-unit>
        <trans-unit id="fe38d7c32db7d9028a7337d49fe5d30adb864ee5" translate="yes" xml:space="preserve">
          <source>In SQLite, the answer to the previous question is &quot;no&quot;. For testing purposes, the SQLite source code defines macros called ALWAYS() and NEVER(). The ALWAYS() macro surrounds conditions which are expected to always evaluate as true and NEVER() surrounds conditions that are always evaluated to false. These macros serve as comments to indicate that the conditions are defensive code. In release builds, these macros are pass-throughs:</source>
          <target state="translated">В SQLite ответ на предыдущий вопрос-&quot;нет&quot;.Для тестовых целей в исходном коде SQLite определены макросы с именами ALWAYS()и NEVER().Макрос ALWAYS()окружает условия,которые,как ожидается,всегда будут оцениваться как true и NEVER()окружает условия,которые всегда будут оцениваться как false.Эти макросы служат комментариями,указывающими на то,что условия являются защитным кодом.В сборках релизов эти макросы являются проходными:</target>
        </trans-unit>
        <trans-unit id="f43676df6968c4bb63677e4842db7886283fb3e7" translate="yes" xml:space="preserve">
          <source>In SQLite, the presence of assert(X) means that the developers have a proof that X is always true. Readers can depend upon X being true to help them reason about the code. An assert(X) is a strong statement about the truth of X. There is no doubt.</source>
          <target state="translated">В SQLite наличие assert(X)означает,что у разработчиков есть доказательство того,что X всегда верен.Читатели могут полагаться на то,что X верен,чтобы помочь им рассуждать о коде.Утверждение(X)является сильным утверждением об истинности Х.Нет никаких сомнений.</target>
        </trans-unit>
        <trans-unit id="afc867db69a6f0ff03a7d5c74a860a19b5e1f763" translate="yes" xml:space="preserve">
          <source>In WAL mode, changes to the database are detected using the wal-index and so the change counter is not needed. Hence, the change counter might not be incremented on each transaction in WAL mode.</source>
          <target state="translated">В режиме WAL изменения в базе данных определяются с помощью wal-index,поэтому счетчик изменений не нужен.Следовательно,в режиме WAL счетчик изменений может не увеличиваться на каждую транзакцию.</target>
        </trans-unit>
        <trans-unit id="56b4d5a656b5f1cb948b72fc909adc62f6fce99b" translate="yes" xml:space="preserve">
          <source>In a &lt;a href=&quot;lang_select#compound&quot;&gt;compound SELECT&lt;/a&gt; statement, all ORDER BY expressions are handled as aliases for one of the result columns of the compound. If an ORDER BY expression is not an integer alias, then SQLite searches the left-most SELECT in the compound for a result column that matches either the second or third rules above. If a match is found, the search stops and the expression is handled as an alias for the result column that it has been matched against. Otherwise, the next SELECT to the right is tried, and so on. If no matching expression can be found in the result columns of any constituent SELECT, it is an error. Each term of the ORDER BY clause is processed separately and may be matched against result columns from different SELECT statements in the compound.</source>
          <target state="translated">В &lt;a href=&quot;lang_select#compound&quot;&gt;составном операторе SELECT&lt;/a&gt; все выражения ORDER BY обрабатываются как псевдонимы для одного из столбцов результата составного. Если выражение ORDER BY не является целочисленным псевдонимом, то SQLite ищет в крайнем левом SELECT в соединении столбец результата, который соответствует второму или третьему правилу выше. Если совпадение найдено, поиск останавливается, и выражение обрабатывается как псевдоним для столбца результатов, с которым оно было сопоставлено. В противном случае выполняется попытка следующего выбора справа и так далее. Если в столбцах результатов какого-либо составного SELECT не может быть найдено ни одного соответствующего выражения, это является ошибкой. Каждый член предложения ORDER BY обрабатывается отдельно и может сравниваться с столбцами результатов из разных операторов SELECT в составе.</target>
        </trans-unit>
        <trans-unit id="7e23feed60f0ebed492861c5dd540e487916faa3" translate="yes" xml:space="preserve">
          <source>In a &lt;a href=&quot;lang_select#compound&quot;&gt;compound SELECT&lt;/a&gt; statement, only the last or right-most &lt;a href=&quot;lang_select#simpleselect&quot;&gt;simple SELECT&lt;/a&gt; may have an ORDER BY clause. That ORDER BY clause will apply across all elements of the compound. If the right-most element of a &lt;a href=&quot;lang_select#compound&quot;&gt;compound SELECT&lt;/a&gt; is a &lt;a href=&quot;lang_select#values&quot;&gt;VALUES&lt;/a&gt; clause, then no ORDER BY clause is allowed on that statement.</source>
          <target state="translated">В &lt;a href=&quot;lang_select#compound&quot;&gt;составном операторе SELECT&lt;/a&gt; только последний или самый правый &lt;a href=&quot;lang_select#simpleselect&quot;&gt;простой SELECT&lt;/a&gt; может иметь предложение ORDER BY. Предложение ORDER BY будет применяться ко всем элементам соединения. Если крайний правый элемент &lt;a href=&quot;lang_select#compound&quot;&gt;составного SELECT&lt;/a&gt; является предложением &lt;a href=&quot;lang_select#values&quot;&gt;VALUES&lt;/a&gt; , то предложение ORDER BY для этого оператора не допускается.</target>
        </trans-unit>
        <trans-unit id="60dd93ddbe8f5275cb023ced823e2e72128039a2" translate="yes" xml:space="preserve">
          <source>In a &lt;a href=&quot;lang_select#compound&quot;&gt;compound SELECT&lt;/a&gt;, only the last or right-most &lt;a href=&quot;lang_select#simpleselect&quot;&gt;simple SELECT&lt;/a&gt; may contain a LIMIT clause. In a &lt;a href=&quot;lang_select#compound&quot;&gt;compound SELECT&lt;/a&gt;, the LIMIT clause applies to the entire compound, not just the final SELECT. If the right-most &lt;a href=&quot;lang_select#simpleselect&quot;&gt;simple SELECT&lt;/a&gt; is a &lt;a href=&quot;lang_select#values&quot;&gt;VALUES clause&lt;/a&gt; then no LIMIT clause is allowed.</source>
          <target state="translated">В &lt;a href=&quot;lang_select#compound&quot;&gt;составном SELECT&lt;/a&gt; только последний или самый правый &lt;a href=&quot;lang_select#simpleselect&quot;&gt;простой SELECT&lt;/a&gt; может содержать предложение LIMIT. В &lt;a href=&quot;lang_select#compound&quot;&gt;составном SELECT&lt;/a&gt; предложение LIMIT применяется ко всему составному, а не только к окончательному SELECT. Если самый правый &lt;a href=&quot;lang_select#simpleselect&quot;&gt;простой SELECT&lt;/a&gt; является предложением &lt;a href=&quot;lang_select#values&quot;&gt;VALUES,&lt;/a&gt; то предложение LIMIT не допускается.</target>
        </trans-unit>
        <trans-unit id="4a8149bd98030a655ea899de201ec17546792e89" translate="yes" xml:space="preserve">
          <source>In a CASE with a base expression, the base expression is evaluated just once and the result is compared against the evaluation of each WHEN expression from left to right. The result of the CASE expression is the evaluation of the THEN expression that corresponds to the first WHEN expression for which the comparison is true. Or, if none of the WHEN expressions evaluate to a value equal to the base expression, the result of evaluating the ELSE expression, if any. If there is no ELSE expression and none of the WHEN expressions produce a result equal to the base expression, the overall result is NULL.</source>
          <target state="translated">В CASE с базовым выражением,базовое выражение оценивается всего один раз,и результат сравнивается с оценкой каждого выражения КОГДА слева направо.Результатом выражения CASE является оценка выражения THEN,которое соответствует первому выражению WHEN,для которого сравнение истинно.Или,если ни одно из выражений WHEN не оценивается до значения,равного базовому выражению,результат оценки выражения ELSE,если таковое имеется.Если отсутствует выражение ELSE и ни одно из выражений WHEN не дает результата,равного базовому выражению,то общий результат равен NULL.</target>
        </trans-unit>
        <trans-unit id="9908cac3e7af8453ade042a08abc46157b47dbc8" translate="yes" xml:space="preserve">
          <source>In a CASE without a base expression, each WHEN expression is evaluated and the result treated as a boolean, starting with the leftmost and continuing to the right. The result of the CASE expression is the evaluation of the THEN expression that corresponds to the first WHEN expression that evaluates to true. Or, if none of the WHEN expressions evaluate to true, the result of evaluating the ELSE expression, if any. If there is no ELSE expression and none of the WHEN expressions are true, then the overall result is NULL.</source>
          <target state="translated">В CASE без базового выражения,каждое КОГДА выражение оценивается и результат обрабатывается как булев,начиная с самого левого и заканчивая самым правым.Результатом выражения CASE является оценка выражения THEN,которое соответствует первому выражению WHEN,оцениваемому до истины.Или,если ни одно из выражений КОГДА не оценивается до истины,результатом оценки выражения ELSE,если таковое имеется.Если отсутствует выражение ELSE и ни одно из выражений WHEN не соответствует true,то общий результат будет NULL.</target>
        </trans-unit>
        <trans-unit id="6181d4389ce1218d0117e383d6876208b5204220" translate="yes" xml:space="preserve">
          <source>In a compound SELECT, all the constituent SELECTs must return the same number of result columns. As the components of a compound SELECT must be simple SELECT statements, they may not contain &lt;a href=&quot;lang_select#orderby&quot;&gt;ORDER BY&lt;/a&gt; or &lt;a href=&quot;lang_select#limitoffset&quot;&gt;LIMIT&lt;/a&gt; clauses. &lt;a href=&quot;lang_select#orderby&quot;&gt;ORDER BY&lt;/a&gt; and &lt;a href=&quot;lang_select#limitoffset&quot;&gt;LIMIT&lt;/a&gt; clauses may only occur at the end of the entire compound SELECT, and then only if the final element of the compound is not a &lt;a href=&quot;lang_select#values&quot;&gt;VALUES&lt;/a&gt; clause.</source>
          <target state="translated">В составном SELECT все составляющие SELECT должны возвращать одинаковое количество столбцов результатов. Поскольку компоненты составного SELECT должны быть простыми операторами SELECT, они не могут содержать предложений &lt;a href=&quot;lang_select#orderby&quot;&gt;ORDER BY&lt;/a&gt; или &lt;a href=&quot;lang_select#limitoffset&quot;&gt;LIMIT&lt;/a&gt; . &lt;a href=&quot;lang_select#orderby&quot;&gt;Предложения ORDER BY&lt;/a&gt; и &lt;a href=&quot;lang_select#limitoffset&quot;&gt;LIMIT&lt;/a&gt; могут встречаться только в конце всего составного SELECT и только тогда, если последний элемент составного элемента не является предложением &lt;a href=&quot;lang_select#values&quot;&gt;VALUES&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="78d71ac8fe601725ccb2ce14d7f5ff1b4e551c1c" translate="yes" xml:space="preserve">
          <source>In a custom format defined by the RBU application.</source>
          <target state="translated">В пользовательском формате,определенном приложением RBU.</target>
        </trans-unit>
        <trans-unit id="c01843d896cd964dc56835ee2c755615d047e3ab" translate="yes" xml:space="preserve">
          <source>In a database that uses ptrmap pages, all pages at locations identified by the computation in the previous paragraph must be ptrmap page and no other page may be a ptrmap page. Except, if the byte-lock page happens to fall on the same page number as a ptrmap page, then the ptrmap is moved to the following page for that one case.</source>
          <target state="translated">В базе данных,использующей ptrmap-страницы,все страницы в местах,определенных расчетами в предыдущем параграфе,должны быть ptrmap-страницами,и никакая другая страница не может быть ptrmap-страницей.За исключением случая,когда страница байт-блока случайно попадает на тот же номер страницы,что и ptrmap-страница,то для этого случая ptrmap перемещается на следующую страницу.</target>
        </trans-unit>
        <trans-unit id="27e8a07a53d50d810a0832f44496263b4918565d" translate="yes" xml:space="preserve">
          <source>In a database with ptrmap pages, the first ptrmap page is page 2. A ptrmap page consists of an array of 5-byte entries. Let J be the number of 5-byte entries that will fit in the usable space of a page. (In other words, J=U/5.) The first ptrmap page will contain back pointer information for pages 3 through J+2, inclusive. The second pointer map page will be on page J+3 and that ptrmap page will provide back pointer information for pages J+4 through 2*J+3 inclusive. And so forth for the entire database file.</source>
          <target state="translated">В базе данных с ptrmap-страницами первая ptrmap-страница-это страница 2.Страница ptrmap состоит из массива записей размером 5 байт.Пусть J-это количество 5-байтовых записей,которое поместится в используемое пространство страницы.(Другими словами,J=U/5.)Первая ptrmap-страница будет содержать информацию об указателе обратного хода для страниц от 3 до J+2 включительно.Вторая страница карты-индикатора будет находиться на странице J+3,а эта страница ptrmap будет содержать информацию об обратном указателе для страниц от J+4 до 2*J+3 включительно.И так далее для всего файла базы данных.</target>
        </trans-unit>
        <trans-unit id="413d5f86aecfe4e03a70ec087a2506b07314a985" translate="yes" xml:space="preserve">
          <source>In a general query, dependencies need not be on a single loop, and hence the matrix of dependencies might not be representable as a graph. For example, one of the WHERE clause constraints might be S.a=L.b+P.c, implying that the S loop must be an inner loop of both L and P. Such dependencies cannot be drawn as a graph since there is no way for an arc to originate at two or more nodes at once.</source>
          <target state="translated">В общем запросе,зависимости не обязательно должны быть на одном цикле,и,следовательно,матрица зависимостей может быть не представлена в виде графика.Например,одним из ограничений выражения WHERE может быть S.a=L.b+P.c,что означает,что цикл S должен быть внутренним циклом как L,так и P.Такие зависимости не могут быть построены как граф,т.к.не существует возможности возникновения дуги сразу в двух и более узлах.</target>
        </trans-unit>
        <trans-unit id="3cba367e5a45e9ef327972801946d29ebc579596" translate="yes" xml:space="preserve">
          <source>In a join, two or more tables are combined to generate a single result. The result table consists of every possible combination of rows from the tables being joined. The easiest and most natural way to implement this is with nested loops.</source>
          <target state="translated">В объединении две или более таблиц объединяются для получения одного результата.Таблица результатов состоит из всех возможных комбинаций строк соединяемых таблиц.Самый простой и естественный способ реализовать это-с помощью вложенных петель.</target>
        </trans-unit>
        <trans-unit id="ea43a43981be0da7d2383a4a8fa8f578ad332998" translate="yes" xml:space="preserve">
          <source>In a more complete build, SQLite also uses library routines like malloc() and free() and operating system interfaces for opening, reading, writing, and closing files. But even then, the number of dependencies is very small. Other &quot;modern&quot; language, in contrast, often require multi-megabyte runtimes loaded with thousands and thousands of interfaces.</source>
          <target state="translated">В более полной сборке SQLite также использует библиотечные подпрограммы,такие как malloc()и free(),и интерфейсы операционной системы для открытия,чтения,записи и закрытия файлов.Но даже в этом случае количество зависимостей очень мало.Другой &quot;современный&quot; язык,напротив,часто требует многомегабайтных запусков,загруженных тысячами и тысячами интерфейсов.</target>
        </trans-unit>
        <trans-unit id="84d7fa8dbd084f79299c977c5d7f182884242ce4" translate="yes" xml:space="preserve">
          <source>In a multi-threaded application, access to the &lt;a href=&quot;c3ref/mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt; is serialized if and only if &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmemstatus&quot;&gt;SQLITE_CONFIG_MEMSTATUS&lt;/a&gt; is enabled. If &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmemstatus&quot;&gt;SQLITE_CONFIG_MEMSTATUS&lt;/a&gt; is disabled then the methods in &lt;a href=&quot;c3ref/mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt; must take care of their own serialization needs.</source>
          <target state="translated">В многопоточном приложении доступ к &lt;a href=&quot;c3ref/mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt; сериализуется тогда и только тогда, &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmemstatus&quot;&gt;когда&lt;/a&gt; включен SQLITE_CONFIG_MEMSTATUS . Если &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmemstatus&quot;&gt;SQLITE_CONFIG_MEMSTATUS&lt;/a&gt; отключен, методы в &lt;a href=&quot;c3ref/mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt; должны позаботиться о своих собственных потребностях в сериализации.</target>
        </trans-unit>
        <trans-unit id="f07ff4f6d979804b51470d547e3016d910de27f0" translate="yes" xml:space="preserve">
          <source>In a multithreaded environment, SQLite uses mutexes to serialize access to shared resources. The mutex subsystem is only required for applications that access SQLite from multiple threads. For single-threaded applications, or applications which only call SQLite from a single thread, the mutex subsystem can be completely disabled by recompiling with the following option:</source>
          <target state="translated">В многопоточной среде SQLite использует мьютексы для сериализации доступа к общим ресурсам.Подсистема мьютекса требуется только для приложений,которые получают доступ к SQLite из нескольких потоков.Для однопоточных приложений или приложений,которые обращаются к SQLite только из одного потока,подсистема мьютекса может быть полностью отключена путем перекомпиляции со следующей опцией:</target>
        </trans-unit>
        <trans-unit id="4d4533ee698cc81c52715976a896f4db12f7a8cf" translate="yes" xml:space="preserve">
          <source>In a normal index, there is a one-to-one mapping between rows in a table and entries in each index associated with that table. However, in a &lt;a href=&quot;partialindex&quot;&gt;partial index&lt;/a&gt;, the index b-tree only contains entries corresponding to table rows for which the WHERE clause expression on the CREATE INDEX statement is true. Corresponding rows in the index and table b-trees share the same rowid or primary key values and contain the same value for all indexed columns.</source>
          <target state="translated">В нормальном индексе существует взаимно однозначное соответствие между строками в таблице и записями в каждом индексе, связанном с этой таблицей. Однако в &lt;a href=&quot;partialindex&quot;&gt;частичном индексе&lt;/a&gt; b-дерево индекса содержит только записи, соответствующие строкам таблицы, для которых выражение предложения WHERE в операторе CREATE INDEX истинно. Соответствующие строки в b-деревьях индекса и таблицы имеют одинаковые идентификаторы строки или значения первичного ключа и содержат одно и то же значение для всех индексированных столбцов.</target>
        </trans-unit>
        <trans-unit id="ce9e9da4042a8b1a6fff277efdbca241b2bb44b8" translate="yes" xml:space="preserve">
          <source>In a prefix search, the matchlen is the number of characters in the string that match against the prefix. For a non-prefix search, this is the same as length(word).</source>
          <target state="translated">При поиске с префиксом,matchlen-это количество символов в строке,которые совпадают с префиксом.Для не префиксного поиска это то же самое,что и длина(слово).</target>
        </trans-unit>
        <trans-unit id="540eb7e11b15dfedf16222538153a627d93ae118" translate="yes" xml:space="preserve">
          <source>In a well-formed sqlite_stat3 table, the samples for any single index must appear in the same order that they occur in the index. In other words, if the entry with left-most column S1 is earlier in the index b-tree than the entry with left-most column S2, then in the sqlite_stat3 table, sample S1 must have a smaller rowid than sample S2.</source>
          <target state="translated">В хорошо сформированной таблице sqlite_stat3 выборки для любого отдельного индекса должны располагаться в том же порядке,в котором они встречаются в индексе.Другими словами,если запись с крайним левым столбцом S1 в дереве индексов b раньше,чем запись с крайним левым столбцом S2,то в таблице sqlite_stat3 выборка S1 должна иметь меньший ряд,чем выборка S2.</target>
        </trans-unit>
        <trans-unit id="471a1674cd89ff60cc26aaa2e09dcb5715c114d4" translate="yes" xml:space="preserve">
          <source>In a well-formed sqlite_stat4 table, the samples for any single index must appear in the same order that they occur in the index. In other words, if entry S1 is earlier in the index b-tree than entry S2, then in the sqlite_stat4 table, sample S1 must have a smaller rowid than sample S2.</source>
          <target state="translated">В хорошо сформированной таблице sqlite_stat4 выборки для любого отдельного индекса должны располагаться в том же порядке,в котором они встречаются в индексе.Другими словами,если запись S1 в дереве индексов b раньше,чем запись S2,то в таблице sqlite_stat4 выборка S1 должна иметь меньший ряд,чем выборка S2.</target>
        </trans-unit>
        <trans-unit id="211f3f65b2d350ffdf823361c3c94beeb6b3685e" translate="yes" xml:space="preserve">
          <source>In addition to &quot;supporting&quot; SQLite through the year 2050, the developers also promise to keep the SQLite &lt;a href=&quot;cintro&quot;&gt;C-language API&lt;/a&gt; and &lt;a href=&quot;fileformat2&quot;&gt;on-disk format&lt;/a&gt; fully backwards compatible. This means that application written to use SQLite today should be able to link against and use future versions of SQLite released decades in the future.</source>
          <target state="translated">Помимо &amp;laquo;поддержки&amp;raquo; SQLite до 2050 года, разработчики также обещают сохранить полную обратную совместимость &lt;a href=&quot;cintro&quot;&gt;API языка C&lt;/a&gt; SQLite и &lt;a href=&quot;fileformat2&quot;&gt;дискового формата&lt;/a&gt; . Это означает, что приложение, написанное для использования SQLite сегодня, должно иметь возможность связываться с будущими версиями SQLite, выпущенными через десятилетия, и использовать их.</target>
        </trans-unit>
        <trans-unit id="2d62e10830dbc04e04eb1ce98ea4d36c1849dd6d" translate="yes" xml:space="preserve">
          <source>In addition to WHERE clause constraints, the SQLite core also tells the xBestIndex method about the ORDER BY clause. (In an aggregate query, the SQLite core might put in GROUP BY clause information in place of the ORDER BY clause information, but this fact should not make any difference to the xBestIndex method.) If all terms of the ORDER BY clause are columns in the virtual table, then nOrderBy will be the number of terms in the ORDER BY clause and the aOrderBy[] array will identify the column for each term in the order by clause and whether or not that column is ASC or DESC.</source>
          <target state="translated">В дополнение к ограничениям пункта WHERE,ядро SQLite также сообщает метод xBestIndex об оговорке ORDER BY.(В совокупном запросе ядро SQLite может поместить информацию из пункта GROUP BY вместо информации из пункта ORDER BY,но этот факт не должен иметь никакого отношения к методу xBestIndex).Если все термины в пункте ORDER BY являются столбцами в виртуальной таблице,то nOrderBy будет числом терминов в пункте ORDER BY,а массив aOrderBy[]будет идентифицировать столбец для каждого термина в порядке следования по пунктам и будет ли этот столбец ASC или DESC.</target>
        </trans-unit>
        <trans-unit id="ae32760f149e6ccbf9d662c3e5f266d79f8381ea" translate="yes" xml:space="preserve">
          <source>In addition to being a result code, the SQLITE_ABORT value is also used as a &lt;a href=&quot;c3ref/c_fail&quot;&gt;conflict resolution mode&lt;/a&gt; returned from the &lt;a href=&quot;c3ref/vtab_on_conflict&quot;&gt;sqlite3_vtab_on_conflict()&lt;/a&gt; interface.</source>
          <target state="translated">Помимо того, что это код результата, значение SQLITE_ABORT также используется в качестве &lt;a href=&quot;c3ref/c_fail&quot;&gt;режима разрешения конфликтов,&lt;/a&gt; возвращаемого интерфейсом &lt;a href=&quot;c3ref/vtab_on_conflict&quot;&gt;sqlite3_vtab_on_conflict ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7bf173fd8743d9addd4d23da77cbd1023dcac612" translate="yes" xml:space="preserve">
          <source>In addition to locking this byte, a connection running &lt;a href=&quot;walformat#recovery&quot;&gt;recovery&lt;/a&gt; also gets an exclusive lock on all other WAL locks except for WAL_READ_LOCK(0).</source>
          <target state="translated">Помимо блокировки этого байта, соединение, выполняющее &lt;a href=&quot;walformat#recovery&quot;&gt;восстановление,&lt;/a&gt; также получает эксклюзивную блокировку всех других блокировок WAL, кроме WAL_READ_LOCK (0).</target>
        </trans-unit>
        <trans-unit id="cb3414acfc85a9001c1b555d3204dd8c38c36eeb" translate="yes" xml:space="preserve">
          <source>In addition to making SQLite easier to incorporate into other projects, the amalgamation also makes it run faster. Many compilers are able to do additional optimizations on code when it is contained with in a single translation unit such as it is in the amalgamation. We have measured performance improvements of between 5 and 10% when we use the amalgamation to compile SQLite rather than individual source files. The downside of this is that the additional optimizations often take the form of function inlining which tends to make the size of the resulting binary image larger.</source>
          <target state="translated">Помимо того,что слияние облегчает интеграцию SQLite в другие проекты,оно также ускоряет его работу.Многие компиляторы могут выполнять дополнительные оптимизации кода,когда он содержится в единице трансляции,например,в слиянии.Мы измерили прирост производительности от 5 до 10% при использовании слияния для компиляции SQLite,а не отдельных исходных файлов.Недостатком этого является то,что дополнительные оптимизации часто принимают форму встраивания функции,которая,как правило,увеличивает размер получаемого двоичного изображения.</target>
        </trans-unit>
        <trans-unit id="dc82fe62c10524b3d4ccdfbeed7cfd03442b0fdf" translate="yes" xml:space="preserve">
          <source>In addition to providing built-in &quot;simple&quot;, &quot;porter&quot; and (possibly) &quot;icu&quot; and &quot;unicode61&quot; tokenizers, FTS provides an interface for applications to implement and register custom tokenizers written in C. The interface used to create a new tokenizer is defined and described in the fts3_tokenizer.h source file.</source>
          <target state="translated">В дополнение к встроенным &quot;простым&quot;,&quot;porter&quot; и (возможно)&quot;icu&quot; и &quot;unicode61&quot; токенайзерам,FTS предоставляет интерфейс для приложений,реализующих и регистрирующих пользовательские токенайзеры,написанные на C.Интерфейс,используемый для создания нового токенайзера,определен и описан в исходном файле fts3_tokenizer.h.</target>
        </trans-unit>
        <trans-unit id="96c71370cd3f6550d6c5dcd90baa2ddaf820ea27" translate="yes" xml:space="preserve">
          <source>In addition to reading and writing SQLite database files, the &lt;b&gt;sqlite3&lt;/b&gt; program will also read and write ZIP archives. Simply specify a ZIP archive filename in place of an SQLite database filename on the initial command line, or in the &quot;.open&quot; command, and &lt;b&gt;sqlite3&lt;/b&gt; will automatically detect that the file is a ZIP archive instead of an SQLite database and will open it as such. This works regardless of file suffix. So you can open JAR, DOCX, and ODP files and any other file format that is really a ZIP archive and SQLite will read it for you.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73759a104c50187a5dc43c3f84c36657f75e9027" translate="yes" xml:space="preserve">
          <source>In addition to the four main test harnesses, there several other small programs that implement specialized tests.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ffa68d498101dd69c9fe08bfcd580625d879a08" translate="yes" xml:space="preserve">
          <source>In addition to the incompatible changes listed above, SQLite version 3.6.0 adds the following backwards compatible changes and enhancements:</source>
          <target state="translated">В дополнение к вышеперечисленным несовместимым изменениям,в SQLite версии 3.6.0 добавлены следующие изменения и улучшения с обратной совместимостью:</target>
        </trans-unit>
        <trans-unit id="8f29eabb94163c908fdf9ce75645a4e743012d26" translate="yes" xml:space="preserve">
          <source>In addition to the official repositories, the developers typically keep complete clones of all software on their personal machines. And there are uncountable clones scattered about the internet.</source>
          <target state="translated">В дополнение к официальным репозиториям разработчики обычно хранят на своих персональных машинах полные клоны всего программного обеспечения.И есть неисчислимые клоны,разбросанные по интернету.</target>
        </trans-unit>
        <trans-unit id="7d07efab2f131a863a93f94a25375b6ef4bc7a4a" translate="yes" xml:space="preserve">
          <source>In addition to the primary vdbe.c source code file, there are other helper code files in the source tree, all of whose names begin with &quot;vdbe&quot; - short for &quot;Virtual DataBase Engine&quot;.</source>
          <target state="translated">Кроме основного файла исходного кода vdbe.c,в дереве исходных текстов есть и другие файлы справочного кода,все названия которых начинаются с &quot;vdbe&quot;-сокращение от &quot;Virtual DataBase Engine&quot;.</target>
        </trans-unit>
        <trans-unit id="e225e51508417bb108b16321c68b3adb1795c7b9" translate="yes" xml:space="preserve">
          <source>In addition to the required flags, the following optional flags are also supported:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77b9657ef03e307e851c2e7bae3bdd3ad8613131" translate="yes" xml:space="preserve">
          <source>In addition to the tables, indexes, views, and triggers created by the application and/or the developer using CREATE statements SQL, the sqlite_master table may contain zero or more entries for</source>
          <target state="translated">В дополнение к таблицам,индексам,представлениям и триггерам,созданным приложением и/или разработчиком с помощью SQL-запросов CREATE,таблица sqlite_master может содержать ноль и более записей для</target>
        </trans-unit>
        <trans-unit id="52a812fb18ec964152fad4865c6ca9189ffdf18b" translate="yes" xml:space="preserve">
          <source>In addition to the tables, indexes, views, and triggers created by the application and/or the developer using CREATE statements SQL, the sqlite_schema table may contain zero or more entries for</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a409c2d7a3384bc3f57eb2c0537e46f7868645bd" translate="yes" xml:space="preserve">
          <source>In addition to the three major test harnesses, there several other small programs that implement specialized tests.</source>
          <target state="translated">В дополнение к трем основным тестовым жгутам существует еще несколько небольших программ,реализующих специализированные тесты.</target>
        </trans-unit>
        <trans-unit id="0718e6fdf0cd1e299f6d920f46595f0908dd4b09" translate="yes" xml:space="preserve">
          <source>In addition, there are some defined constants:</source>
          <target state="translated">Кроме того,существуют определенные константы:</target>
        </trans-unit>
        <trans-unit id="fbb8e299adb3ff32a155642d73390e9d9fa9566c" translate="yes" xml:space="preserve">
          <source>In all of the above, if F is not the name of a database, journal or WAL filename passed into the VFS from the SQLite core and F is not the return value from &lt;a href=&quot;#sqlite3_db_filename&quot;&gt;sqlite3_db_filename()&lt;/a&gt;, then the result is undefined and is likely a memory access violation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a6f4780ac68779fff537a2221e3188df1c6d53f" translate="yes" xml:space="preserve">
          <source>In all of the above, if F is not the name of a database, journal or WAL filename passed into the VFS from the SQLite core and F is not the return value from &lt;a href=&quot;db_filename&quot;&gt;sqlite3_db_filename()&lt;/a&gt;, then the result is undefined and is likely a memory access violation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="650bcf7f3c9667b8bca2e9d81188fd4ca62bdf99" translate="yes" xml:space="preserve">
          <source>In all of the full-text queries above, the right-hand operand of the MATCH operator is a string consisting of a single term. In this case, the MATCH expression evaluates to true for all documents that contain one or more instances of the specified word (&quot;sqlite&quot;, &quot;search&quot; or &quot;database&quot;, depending on which example you look at). Specifying a single term as the right-hand operand of the MATCH operator results in the simplest and most common type of full-text query possible. However more complicated queries are possible, including phrase searches, term-prefix searches and searches for documents containing combinations of terms occurring within a defined proximity of each other. The various ways in which the full-text index may be queried are &lt;a href=&quot;fts3#full_text_index_queries&quot;&gt;described below&lt;/a&gt;.</source>
          <target state="translated">Во всех полнотекстовых запросах выше правый операнд оператора MATCH представляет собой строку, состоящую из одного члена. В этом случае выражение MATCH оценивается как истинное для всех документов, содержащих один или несколько экземпляров указанного слова (&amp;laquo;sqlite&amp;raquo;, &amp;laquo;поиск&amp;raquo; или &amp;laquo;база данных&amp;raquo;, в зависимости от того, какой пример вы смотрите). Указание одного члена в качестве правого операнда оператора MATCH приводит к простейшему и наиболее распространенному типу полнотекстового запроса. Однако возможны более сложные запросы, включая поиск по фразам, поиск по префиксу терминов и поиск документов, содержащих комбинации терминов, встречающиеся в определенной близости друг от друга. Ниже &lt;a href=&quot;fts3#full_text_index_queries&quot;&gt;описаны&lt;/a&gt; различные способы запроса полнотекстового индекса .</target>
        </trans-unit>
        <trans-unit id="fec3ea71809f1fd12bdd320ecfb2400479f6f909" translate="yes" xml:space="preserve">
          <source>In all of the write tests, it is important to disable anti-virus software prior to running the direct-to-disk performance tests. We found that anti-virus software slows down direct-to-disk by an order of magnitude whereas it impacts SQLite writes very little. This is probably due to the fact that direct-to-disk changes thousands of separate files which all need to be checked by anti-virus, whereas SQLite writes only changes the single database file.</source>
          <target state="translated">Во всех тестах на запись важно отключить антивирусное программное обеспечение перед запуском тестов производительности непосредственно на диск.Мы обнаружили,что антивирусные программы замедляют прямую запись на диск на порядок,в то время как SQLite записывает очень мало.Вероятно,это связано с тем,что при прямой записи на диск изменяются тысячи отдельных файлов,которые необходимо проверить антивирусом,в то время как SQLite записывает только один файл базы данных.</target>
        </trans-unit>
        <trans-unit id="19fd1c2e26ad6ba4190cb1ba85655e3d415fb1a9" translate="yes" xml:space="preserve">
          <source>In all other cases this function returns SQLITE_MISUSE.</source>
          <target state="translated">Во всех остальных случаях эта функция возвращает SQLITE_MISUSE.</target>
        </trans-unit>
        <trans-unit id="a9b1d686d80c16cbd892850ec817e33e118fdb64" translate="yes" xml:space="preserve">
          <source>In all the examples above, there has only been a single SELECT statement. If a query contains sub-selects, those are shown as being children of the outer SELECT. For example:</source>
          <target state="translated">Во всех приведенных выше примерах было только одно утверждение SELECT.Если запрос содержит подвыборки,то они отображаются как дочерние элементы внешнего SELECT.Например:</target>
        </trans-unit>
        <trans-unit id="c9c18ce865540a24f1f5ee5d4ef74324465c3e44" translate="yes" xml:space="preserve">
          <source>In an &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; statement, a list of column names can be set to a row value of the same size.</source>
          <target state="translated">В операторе &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; список имен столбцов может быть установлен равным значению строки того же размера.</target>
        </trans-unit>
        <trans-unit id="34ecd17e630ff3ecf740af54bcb0cb9af6e271db" translate="yes" xml:space="preserve">
          <source>In an expression used as part of an &lt;a href=&quot;expridx&quot;&gt;expression index&lt;/a&gt;.</source>
          <target state="translated">В выражении, используемом как часть &lt;a href=&quot;expridx&quot;&gt;индекса выражения&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="68e31982331dd4f44aeeef7efedd25a5db6a0a14" translate="yes" xml:space="preserve">
          <source>In an index on a WITHOUT ROWID table, if a column of the PRIMARY KEY is also a column in the index and has a matching collating sequence, then the indexed column is not repeated in the table-key suffix on the end of the index record. As an example, consider the following SQL:</source>
          <target state="translated">В индексе в таблице БЕЗ РАЗРЕШЕНИЯ,если столбец PRIMARY KEY также является столбцом в индексе и имеет совпадающую коллизионную последовательность,то проиндексированный столбец не повторяется в суффиксе ключа таблицы в конце записи индекса.В качестве примера рассмотрим следующий SQL:</target>
        </trans-unit>
        <trans-unit id="b98eca53cbed3b51f01e882fbf03443737203ad3" translate="yes" xml:space="preserve">
          <source>In an interior b-tree page, the pointers and keys logically alternate with a pointer on both ends. (The previous sentence is to be understood conceptually - the actual layout of the keys and pointers within the page is more complicated and will be described in the sequel.) All keys within the same page are unique and are logically organized in ascending order from left to right. (Again, this ordering is logical, not physical. The actual location of keys within the page is arbitrary.) For any key X, pointers to the left of a X refer to b-tree pages on which all keys are less than or equal to X. Pointers to the right of X refer to pages where all keys are greater than X.</source>
          <target state="translated">Внутри страницы из b-дерева указатели и клавиши логически чередуются с указателем на обоих концах.(Предыдущее предложение следует понимать концептуально-фактическое расположение клавиш и указателей внутри страницы сложнее и будет описано в продолжении).Все клавиши внутри одной страницы уникальны и логически организованы в порядке возрастания слева направо.(Опять же,это упорядочение логично,а не физически.Реальное расположение ключей внутри страницы является произвольным).Для любого ключа X указатели слева от X относятся к страницам b-дерева,на которых все ключи меньше или равны X.Указатели справа от X относятся к страницам,на которых все ключи больше X.</target>
        </trans-unit>
        <trans-unit id="39488c0191328e370ea86a4f1833476c2e9dc423" translate="yes" xml:space="preserve">
          <source>In an ordinary SQLite table, the PRIMARY KEY is really just a &lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE&lt;/a&gt; index. The key used to look up records on disk is the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;. The special &quot;&lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;&quot; column type in ordinary SQLite tables causes the column to be an alias for the rowid, and so an INTEGER PRIMARY KEY is a true PRIMARY KEY. But any other kind of PRIMARY KEYs, including &quot;INT PRIMARY KEY&quot; are just unique indexes in an ordinary rowid table.</source>
          <target state="translated">В обычной таблице SQLite PRIMARY KEY - это просто &lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;УНИКАЛЬНЫЙ&lt;/a&gt; индекс. Ключ, используемый для поиска записей на диске, - это &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; . Специальный тип столбца &amp;laquo; &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; &amp;raquo; в обычных таблицах SQLite заставляет столбец быть псевдонимом для rowid, и поэтому INTEGER PRIMARY KEY является истинным PRIMARY KEY. Но любые другие типы PRIMARY KEY, включая INT PRIMARY KEY, являются просто уникальными индексами в обычной таблице rowid.</target>
        </trans-unit>
        <trans-unit id="2602231eda03cd82b0bfe3849f20e2339713b36f" translate="yes" xml:space="preserve">
          <source>In any aggregate function that takes a single argument, that argument can be preceded by the keyword DISTINCT. In such cases, duplicate elements are filtered before being passed into the aggregate function. For example, the function &quot;count(distinct X)&quot; will return the number of distinct values of column X instead of the total number of non-null values in column X.</source>
          <target state="translated">В любой совокупной функции,которая принимает один аргумент,этому аргументу может предшествовать ключевое слово DISTINCT.В таких случаях дублирующие элементы фильтруются перед передачей в агрегатную функцию.Например,функция &quot;count(distinct X)&quot; вернет количество отдельных значений в столбце X вместо общего количества ненулевых значений в столбце X.</target>
        </trans-unit>
        <trans-unit id="15eb51d3758bed15da54f5c0830882a735d49cb2" translate="yes" xml:space="preserve">
          <source>In any database file that contains ptrmap pages, all b-tree root pages must come before any non-root b-tree page, cell payload overflow page, or freelist page. This restriction ensures that a root page will never be moved during an auto-vacuum or incremental-vacuum. The auto-vacuum logic does not know how to update the root_page field of the sqlite_master table and so it is necessary to prevent root pages from being moved during an auto-vacuum in order to preserve the integrity of the sqlite_master table. Root pages are moved to the beginning of the database file by the CREATE TABLE, CREATE INDEX, DROP TABLE, and DROP INDEX operations.</source>
          <target state="translated">В любом файле базы данных,содержащем ptrmap-страницы,все b-деревянные корневые страницы должны находиться перед любой не корневой b-деревянной страницей,страницей переполнения ячеек или страницей фрилиста.Это ограничение гарантирует,что корневая страница никогда не будет перемещена во время автоматического вакуума или инкрементального вакуума.Логика авто-вакуума не знает,как обновить поле root_page таблицы sqlite_master,поэтому необходимо предотвратить перемещение корневых страниц во время авто-вакуума,чтобы сохранить целостность таблицы sqlite_master.Корневые страницы перемещаются в начало файла базы данных с помощью операций CREATE TABLE,CREATE INDEX,DROP TABLE и DROP INDEX.</target>
        </trans-unit>
        <trans-unit id="d9bc87111dc7feda77c011e8d21c00fc7e80e539" translate="yes" xml:space="preserve">
          <source>In any database file that contains ptrmap pages, all b-tree root pages must come before any non-root b-tree page, cell payload overflow page, or freelist page. This restriction ensures that a root page will never be moved during an auto-vacuum or incremental-vacuum. The auto-vacuum logic does not know how to update the root_page field of the sqlite_schema table and so it is necessary to prevent root pages from being moved during an auto-vacuum in order to preserve the integrity of the sqlite_schema table. Root pages are moved to the beginning of the database file by the CREATE TABLE, CREATE INDEX, DROP TABLE, and DROP INDEX operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="016fc239bf2f87e674a823e588afff2d09643b5a" translate="yes" xml:space="preserve">
          <source>In automatic EXPLAIN QUERY PLAN mode, the shell automatically runs a separate EXPLAIN QUERY PLAN query for each statement you enter and displays the result before actually running the query. Use the &quot;.eqp off&quot; command to turn automatic EXPLAIN QUERY PLAN mode back off.</source>
          <target state="translated">В автоматическом режиме EXPLAIN QUERY PLAN оболочка автоматически выполняет отдельный запрос EXPLAIN QUERY PLAN для каждого введенного вами запроса и отображает результат до фактического выполнения запроса.Используйте команду &quot;.eqp off&quot;,чтобы выключить автоматический режим EXPLAIN QUERY PLAN.</target>
        </trans-unit>
        <trans-unit id="a0296b5facf2017142e185ec710adebd650dd374" translate="yes" xml:space="preserve">
          <source>In batch-mode operation, where an FTS table is initially built up using a large number of INSERT operations, then queried repeatedly without further changes, it is often a good idea to run &quot;optimize&quot; after the last INSERT and before the first query.</source>
          <target state="translated">В пакетном режиме,когда таблица FTS изначально строится с использованием большого количества операций INSERT,а затем многократно опрашивается без дальнейших изменений,часто бывает хорошей идеей запустить &quot;оптимизацию&quot; после последнего INSERT и перед первым запросом.</target>
        </trans-unit>
        <trans-unit id="0f704787571a999cc9c3b84bb71144a5bcf64e37" translate="yes" xml:space="preserve">
          <source>In both cases, the split amalgamation can be obtained by substituting &quot;sqlite3-all.c&quot; for &quot;sqlite3.c&quot; as the make target.</source>
          <target state="translated">В обоих случаях дробное слияние можно получить,заменив &quot;sqlite3-all.c&quot; на &quot;sqlite3.c&quot; в качестве целевого показателя.</target>
        </trans-unit>
        <trans-unit id="fc2950d0c83c287a896b8aadaea3a0c15a77bfa3" translate="yes" xml:space="preserve">
          <source>In brief, sqlite3_wal_checkpoint(D,X) causes the content in the &lt;a href=&quot;../wal&quot;&gt;write-ahead log&lt;/a&gt; for database X on &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; D to be transferred into the database file and for the write-ahead log to be reset. See the &lt;a href=&quot;../wal#ckpt&quot;&gt;checkpointing&lt;/a&gt; documentation for addition information.</source>
          <target state="translated">Вкратце, sqlite3_wal_checkpoint (D, X) заставляет содержимое &lt;a href=&quot;../wal&quot;&gt;журнала упреждающей записи&lt;/a&gt; для базы данных X при &lt;a href=&quot;sqlite3&quot;&gt;подключении&lt;/a&gt; к базе данных D переноситься в файл базы данных и сбрасывать журнал упреждающей записи. Дополнительную информацию см. В документации по &lt;a href=&quot;../wal#ckpt&quot;&gt;контрольным точкам&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="05e7a053b7377f3e594b4b5661cacef3a8037473" translate="yes" xml:space="preserve">
          <source>In brief, sqlite3_wal_checkpoint(D,X) causes the content in the &lt;a href=&quot;wal&quot;&gt;write-ahead log&lt;/a&gt; for database X on &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; D to be transferred into the database file and for the write-ahead log to be reset. See the &lt;a href=&quot;wal#ckpt&quot;&gt;checkpointing&lt;/a&gt; documentation for addition information.</source>
          <target state="translated">Вкратце, sqlite3_wal_checkpoint (D, X) заставляет содержимое &lt;a href=&quot;wal&quot;&gt;журнала упреждающей записи&lt;/a&gt; для базы данных X при &lt;a href=&quot;#sqlite3&quot;&gt;подключении&lt;/a&gt; к базе данных D переноситься в файл базы данных и сбрасывать журнал упреждающей записи. Дополнительную информацию см. В документации по &lt;a href=&quot;wal#ckpt&quot;&gt;контрольным точкам&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9c00ece9c1ea98470c62a3e9e8dcd9514aa371cf" translate="yes" xml:space="preserve">
          <source>In brief, the CPU performance of SQLite is measured as follows:</source>
          <target state="translated">Вкратце,производительность процессора SQLite измеряется следующим образом:</target>
        </trans-unit>
        <trans-unit id="9e64879e9d401b77adebcff06d6d47d07d757ab4" translate="yes" xml:space="preserve">
          <source>In cases where it is complicated, the complications in applying a changeset lie in conflict resolution. Refer to the API documentation linked above for details.</source>
          <target state="translated">В тех случаях,когда это сложно,сложности в применении изменений заключаются в урегулировании конфликтов.Подробности см.в документации по API,ссылки на которую приведены выше.</target>
        </trans-unit>
        <trans-unit id="0d808e9f43de5ebbcabce2337be4b9dd05f38065" translate="yes" xml:space="preserve">
          <source>In cases where two or more phrase instances overlap (share one or more tokens in common), a single open and close marker is inserted for each set of overlapping phrases. For example:</source>
          <target state="translated">В случаях,когда два или более фразовых экземпляра перекрываются (совместно используют один или несколько маркеров),для каждого набора перекрывающихся фраз вставляется один маркер &quot;Открыть&quot; и &quot;Закрыть&quot;.Например:</target>
        </trans-unit>
        <trans-unit id="c541beea5651ea9308221a19ef6bad8134493156" translate="yes" xml:space="preserve">
          <source>In column mode, each record is shown on a separate line with the data aligned in columns. For example:</source>
          <target state="translated">В режиме столбцов каждая запись отображается отдельной строкой с данными,выровненными по столбцам.Например:</target>
        </trans-unit>
        <trans-unit id="27dcedbb38ae9d16b71fde759bf65bb67ce0f587" translate="yes" xml:space="preserve">
          <source>In common use, SQLite databases tend to range in size from a few kilobytes to a few gigabytes, though terabyte-size SQLite databases are known to exist in production.</source>
          <target state="translated">При обычном использовании базы данных SQLite имеют тенденцию варьироваться в размерах от нескольких килобайт до нескольких гигабайт,хотя известно,что базы данных SQLite размером в терабайт существуют в производстве.</target>
        </trans-unit>
        <trans-unit id="15ec9746d32bfb65e8d0e42717374e59fcc87690" translate="yes" xml:space="preserve">
          <source>In contrast, Fossil is a single standalone binary which is installed by putting it on $PATH. That one binary contains all the functionality of core Git and also GitHub and/or GitLab. It manages a community server with wiki, bug tracking, and forums, provides packaged downloads for consumers, login managements, and so forth, with no extra software required.</source>
          <target state="translated">Напротив,ископаемое-это одиночный бинарный файл,который устанавливается,ставя его на $PATH.Этот бинарный файл содержит все функциональные возможности ядра Git,а также GitHub и/или GitLab.Он управляет сервером сообщества с wiki,отслеживанием ошибок и форумами,обеспечивает пакетную загрузку для потребителей,управление входом в систему и т.д.,не требуя дополнительного программного обеспечения.</target>
        </trans-unit>
        <trans-unit id="a51fb2bb312c4e04f9b038dff963c7e47c882987" translate="yes" xml:space="preserve">
          <source>In contrast, Fossil users only need to think about their working directory and the check-in they are working on. That is 60% less distraction. Every developer has a finite number of brain-cycles. Fossil requires fewer brain-cycles to operate, thus freeing up intellectual resources to focus on the software under development.</source>
          <target state="translated">В отличие от этого,пользователям,использующим ископаемые,нужно только подумать о своем рабочем каталоге и регистрации,над которой они работают.Это на 60% меньше отвлекает.У каждого разработчика есть ограниченное количество мозговых циклов.Ископаемым требуется меньше &quot;мозговых циклов&quot;,чтобы работать,высвобождая тем самым интеллектуальные ресурсы,чтобы сосредоточиться на разрабатываемом программном обеспечении.</target>
        </trans-unit>
        <trans-unit id="0fcdb16d38afda3fa9a7a2e8625220ffc33d6191" translate="yes" xml:space="preserve">
          <source>In either case, if performance problems do arise in an SQLite application those problems can often be resolved by adding one or two &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt; statements to the schema or perhaps running &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; one time and without having to touch a single line of application code. But if a performance problem comes up in a custom or pile-of-files format, the fix will often require extensive changes to application code to add and maintain new indices or to extract information using different algorithms.</source>
          <target state="translated">В любом случае, если в приложении SQLite действительно возникают проблемы с производительностью, эти проблемы часто можно решить, добавив в схему один или два оператора &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt; или, возможно, запустив &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; один раз и без необходимости касаться ни одной строчки кода приложения. Но если проблема с производительностью возникает в пользовательском формате или в формате кучи файлов, исправление часто потребует значительных изменений в коде приложения для добавления и поддержки новых индексов или для извлечения информации с использованием других алгоритмов.</target>
        </trans-unit>
        <trans-unit id="25aa68ecfd2b0c4f0ec2db607f906e4651bce4ef" translate="yes" xml:space="preserve">
          <source>In every case, the pager cache size was adjusted to keep the amount of cache memory at about 2MB. For example, a 2000 page cache was used for 1024 byte pages and a 31 page cache was used for 65536 byte pages. The BLOB values were read in a random order.</source>
          <target state="translated">В каждом случае размер кэш-памяти пейджера регулировался таким образом,чтобы объем кэш-памяти составлял около 2 Мб.Например,кэш 2000 страниц был использован для 1024 байтных страниц,а кэш 31 страницы-для 65536 байтных страниц.BLOB-значения читались в случайном порядке.</target>
        </trans-unit>
        <trans-unit id="cf40b39d63a8fb0ce771e83c7921ec57173f92f8" translate="yes" xml:space="preserve">
          <source>In extreme cases, consider compiling SQLite with the &lt;a href=&quot;compile#enable_memsys5&quot;&gt;-DSQLITE_ENABLE_MEMSYS5&lt;/a&gt; option and then providing SQLite with a fixed chunk of memory to use as its heap via the &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigheap&quot;&gt;SQLITE_CONFIG_HEAP&lt;/a&gt;) interface. This will prevent malicious SQL from executing a denial-of-service attack by using an excessive amount of memory. If (say) 5 MB of memory is provided for SQLite to use, once that much has been consumed, SQLite will start returning SQLITE_NOMEM errors, rather than soaking up memory needed by other parts of the application. This also sandboxes SQLite's memory so that a write-after-free error in some other part of the application will not cause problems for SQLite, or vice versa.</source>
          <target state="translated">В крайних случаях рассмотрите возможность компиляции SQLite с параметром &lt;a href=&quot;compile#enable_memsys5&quot;&gt;-DSQLITE_ENABLE_MEMSYS5,&lt;/a&gt; а затем предоставления SQLite фиксированного фрагмента памяти для использования в качестве кучи через интерфейс &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt; ( &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigheap&quot;&gt;SQLITE_CONFIG_HEAP&lt;/a&gt; ). Это предотвратит выполнение вредоносным SQL-кодом атаки отказа в обслуживании с использованием чрезмерного объема памяти. Если (скажем) 5 МБ памяти предоставлено для использования SQLite, как только эта большая часть будет израсходована, SQLite начнет возвращать ошибки SQLITE_NOMEM вместо того, чтобы поглощать память, необходимую для других частей приложения. Это также изолирует память SQLite, чтобы ошибка записи после освобождения в какой-либо другой части приложения не вызывала проблем для SQLite и наоборот.</target>
        </trans-unit>
        <trans-unit id="b60127a70276716ca6ce96b164af1caff22c34ff" translate="yes" xml:space="preserve">
          <source>In fairness to PostgreSQL, it started thrashing on this test. A knowledgeable administrator might be able to get PostgreSQL to run a lot faster here by tweaking and tuning the server a little.</source>
          <target state="translated">Честно говоря,PostgreSQL начал &quot;морочить голову&quot; на этом тесте.Знающий администратор мог бы заставить PostgreSQL работать здесь намного быстрее,немного отрегулировав и настроив сервер.</target>
        </trans-unit>
        <trans-unit id="776b2a0854afad2e6c812aae004c09f148d516c9" translate="yes" xml:space="preserve">
          <source>In fairness, having a built-in implementation of printf() also comes with some disadvantages. To wit:</source>
          <target state="translated">Справедливости ради следует отметить,что наличие встроенной реализации функции printf()также имеет некоторые недостатки.В частности:</target>
        </trans-unit>
        <trans-unit id="c2fda1dfe98bf18ac7aa5572676942f62e5e1fe2" translate="yes" xml:space="preserve">
          <source>In first form, if the main database has already been created, then this pragma returns the text encoding used by the main database, one of 'UTF-8', 'UTF-16le' (little-endian UTF-16 encoding) or 'UTF-16be' (big-endian UTF-16 encoding). If the main database has not already been created, then the value returned is the text encoding that will be used to create the main database, if it is created by this session.</source>
          <target state="translated">В первой форме,если основная БД уже создана,то эта прагма возвращает текстовую кодировку,используемую основной БД,одну из 'UTF-8','UTF-16le' (little-endian UTF-16 encoding)или 'UTF-16be' (big-endian UTF-16 encoding).Если основная БД еще не создана,то возвращаемым значением будет текстовая кодировка,которая будет использована для создания основной БД,если она будет создана данной сессией.</target>
        </trans-unit>
        <trans-unit id="b4265b09e5ee96a8a7b2a30c889a0bcc8a3fb773" translate="yes" xml:space="preserve">
          <source>In formats 4, 7, and 10, the fractional seconds value SS.SSS can have one or more digits following the decimal point. Exactly three digits are shown in the examples because only the first three digits are significant to the result, but the input string can have fewer or more than three digits and the date/time functions will still operate correctly. Similarly, format 12 is shown with 10 significant digits, but the date/time functions will really accept as many or as few digits as are necessary to represent the Julian day number.</source>
          <target state="translated">В форматах 4,7 и 10 значение SS.SSS в дробных секундах может иметь одну или несколько цифр после запятой.Точно три цифры показаны в примерах,потому что только первые три цифры имеют значение для результата,но входная строка может иметь меньше или больше трех цифр,и функции даты/времени все равно будут работать корректно.Аналогично,формат 12 показан с 10 значащими цифрами,но функции даты/времени действительно будут принимать столько или столько цифр,сколько необходимо для представления юлианского номера дня.</target>
        </trans-unit>
        <trans-unit id="af29b68f8112f5b3ba3c7546feb616bd5c5cfef7" translate="yes" xml:space="preserve">
          <source>In formats 5 through 7, the &quot;T&quot; is a literal character separating the date and the time, as required by &lt;a href=&quot;http://www.w3c.org/TR/NOTE-datetime&quot;&gt;ISO-8601&lt;/a&gt;. Formats 8 through 10 that specify only a time assume a date of 2000-01-01. Format 11, the string 'now', is converted into the current date and time as obtained from the xCurrentTime method of the &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object in use. The 'now' argument to date and time functions always returns exactly the same value for multiple invocations within the same &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; call. &lt;a href=&quot;http://en.wikipedia.org/wiki/Coordinated_Universal_Time&quot;&gt;Universal Coordinated Time (UTC)&lt;/a&gt; is used. Format 12 is the &lt;a href=&quot;http://en.wikipedia.org/wiki/Julian_day&quot;&gt;Julian day number&lt;/a&gt; expressed as a floating point value.</source>
          <target state="translated">В форматах с 5 по 7 буква &amp;laquo;T&amp;raquo; - это буквальный символ, разделяющий дату и время, в соответствии с требованиями &lt;a href=&quot;http://www.w3c.org/TR/NOTE-datetime&quot;&gt;ISO-8601&lt;/a&gt; . Форматы с 8 по 10, которые определяют только время, предполагают дату 2000-01-01. Формат 11, строка &amp;laquo;сейчас&amp;raquo;, преобразуется в текущую дату и время, получаемые из метода xCurrentTime используемого объекта &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; . Аргумент &amp;laquo;сейчас&amp;raquo; для функций даты и времени всегда возвращает одно и то же значение для нескольких вызовов в рамках одного и того же вызова &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step ()&lt;/a&gt; . Используется &lt;a href=&quot;http://en.wikipedia.org/wiki/Coordinated_Universal_Time&quot;&gt;универсальное координированное время (UTC)&lt;/a&gt; . Формат 12 - это &lt;a href=&quot;http://en.wikipedia.org/wiki/Julian_day&quot;&gt;число дней&lt;/a&gt; по юлианскому календарю, выраженное как значение с плавающей запятой.</target>
        </trans-unit>
        <trans-unit id="f289b58633d51c42244b9615eefef812e48059b3" translate="yes" xml:space="preserve">
          <source>In general, you can do anything with a &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; that can be done with an ordinary table, except that you cannot create indices or triggers on a virtual table. Some virtual table implementations might impose additional restrictions. For example, many virtual tables are read-only.</source>
          <target state="translated">В общем, вы можете делать с &lt;a href=&quot;vtab&quot;&gt;виртуальной таблицей все,&lt;/a&gt; что можно сделать с обычной таблицей, за исключением того, что вы не можете создавать индексы или триггеры для виртуальной таблицы. Некоторые реализации виртуальных таблиц могут налагать дополнительные ограничения. Например, многие виртуальные таблицы доступны только для чтения.</target>
        </trans-unit>
        <trans-unit id="eeca88e5ce04c05464f766d95ff0eeb5cfc7eabb" translate="yes" xml:space="preserve">
          <source>In hindsight, we should not have tried to make SQLite accept MySQL 3.x syntax, and should have never allowed double-quoted string literals. However, there are countless applications that make use of double-quoted string literals and so we continue to support that capability to avoid breaking legacy.</source>
          <target state="translated">Оглядываясь назад,мы не должны были пытаться заставить SQLite принять синтаксис MySQL 3.x,и никогда не должны были допускать использования строковых литералов в двойных кавычках.Однако,существует бесчисленное множество приложений,использующих строковые литералы в двойных кавычках,и поэтому мы продолжаем поддерживать эту возможность,чтобы не нарушить наследие.</target>
        </trans-unit>
        <trans-unit id="5bb614f9a4728b882cfa854761e8ce05293a6c53" translate="yes" xml:space="preserve">
          <source>In in TRIGGERSs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc71bff31ad5848828d3dd9115d5b5dfb6294eb3" translate="yes" xml:space="preserve">
          <source>In in VIEWs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3caa4201cfb419be724f72954ef422185458de8" translate="yes" xml:space="preserve">
          <source>In its default configuration, SQLite API routines return one of 30 integer &lt;a href=&quot;../rescode&quot;&gt;result codes&lt;/a&gt;. However, experience has shown that many of these result codes are too coarse-grained. They do not provide as much information about problems as programmers might like. In an effort to address this, newer versions of SQLite (version 3.3.8 2006-10-09 and later) include support for additional result codes that provide more detailed information about errors. These &lt;a href=&quot;../rescode#extrc&quot;&gt;extended result codes&lt;/a&gt; are enabled or disabled on a per database connection basis using the &lt;a href=&quot;extended_result_codes&quot;&gt;sqlite3_extended_result_codes()&lt;/a&gt; API. Or, the extended code for the most recent error can be obtained using &lt;a href=&quot;errcode&quot;&gt;sqlite3_extended_errcode()&lt;/a&gt;.</source>
          <target state="translated">В своей конфигурации по умолчанию процедуры API SQLite возвращают один из 30 целочисленных &lt;a href=&quot;../rescode&quot;&gt;кодов результата&lt;/a&gt; . Однако опыт показал, что многие из этих результирующих кодов слишком грубые. Они не предоставляют столько информации о проблемах, сколько хотелось бы программистам. Чтобы решить эту проблему, новые версии SQLite (версия 3.3.8 2006-10-09 и более поздние) включают поддержку дополнительных кодов результатов, которые предоставляют более подробную информацию об ошибках. Эти &lt;a href=&quot;../rescode#extrc&quot;&gt;расширенные коды результатов&lt;/a&gt; включаются или выключаются для каждого соединения с базой данных с помощью API &lt;a href=&quot;extended_result_codes&quot;&gt;sqlite3_extended_result_codes ()&lt;/a&gt; . Или расширенный код последней ошибки можно получить с помощью &lt;a href=&quot;errcode&quot;&gt;sqlite3_extended_errcode ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3039a66b6632d9561c27b79f80cd7bfba4d1c329" translate="yes" xml:space="preserve">
          <source>In its default configuration, SQLite API routines return one of 30 integer &lt;a href=&quot;rescode&quot;&gt;result codes&lt;/a&gt;. However, experience has shown that many of these result codes are too coarse-grained. They do not provide as much information about problems as programmers might like. In an effort to address this, newer versions of SQLite (version 3.3.8 2006-10-09 and later) include support for additional result codes that provide more detailed information about errors. These &lt;a href=&quot;rescode#extrc&quot;&gt;extended result codes&lt;/a&gt; are enabled or disabled on a per database connection basis using the &lt;a href=&quot;#sqlite3_extended_result_codes&quot;&gt;sqlite3_extended_result_codes()&lt;/a&gt; API. Or, the extended code for the most recent error can be obtained using &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_extended_errcode()&lt;/a&gt;.</source>
          <target state="translated">В своей конфигурации по умолчанию процедуры API SQLite возвращают один из 30 целочисленных &lt;a href=&quot;rescode&quot;&gt;кодов результата&lt;/a&gt; . Однако опыт показал, что многие из этих результирующих кодов слишком грубые. Они не предоставляют столько информации о проблемах, сколько хотелось бы программистам. Чтобы решить эту проблему, новые версии SQLite (версия 3.3.8 2006-10-09 и более поздние) включают поддержку дополнительных кодов результатов, которые предоставляют более подробную информацию об ошибках. Эти &lt;a href=&quot;rescode#extrc&quot;&gt;расширенные коды результатов&lt;/a&gt; включаются или выключаются для каждого соединения с базой данных с помощью API &lt;a href=&quot;#sqlite3_extended_result_codes&quot;&gt;sqlite3_extended_result_codes ()&lt;/a&gt; . Или расширенный код последней ошибки можно получить с помощью &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_extended_errcode ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c851426635cb37e8f1ffc6284cb9e22ec511a9f4" translate="yes" xml:space="preserve">
          <source>In keeping with the pile-of-files theme, OpenDocument stores all slide content in a single big XML file named &quot;content.xml&quot;. LibreOffice reads and parses this entire file just to display the first slide. LibreOffice also seems to read all images into memory as well, which makes sense seeing as when the user does &quot;File/Save&quot; it is going to have to write them all back out again, even though none of them changed. The net effect is that start-up is slow. Double-clicking an OpenDocument file brings up a progress bar rather than the first slide. This results in a bad user experience. The situation grows ever more annoying as the document size increases.</source>
          <target state="translated">В соответствии с темой &quot;куча файлов&quot;,OpenDocument хранит все содержимое слайдов в одном большом XML файле под названием &quot;content.xml&quot;.LibreOffice читает и анализирует весь этот файл только для отображения первого слайда.LibreOffice также,кажется,читает все изображения в память,что имеет смысл,так как когда пользователь делает &quot;Файл/Сохранить&quot;,ему придется записать их все обратно,несмотря на то,что ни одно из них не изменилось.Совокупный эффект заключается в том,что запуск происходит медленно.Двойной щелчок на файле OpenDocument приводит к появлению индикатора прогресса,а не первого слайда.Это приводит к плохим результатам работы пользователя.Ситуация становится все более раздражающей с увеличением размера документа.</target>
        </trans-unit>
        <trans-unit id="c55972e777545acb2431d05db4c4023b23be4d2b" translate="yes" xml:space="preserve">
          <source>In many cases, method (1) above is the best approach. It does not add extra data to the FTS index or require FTS5 to query for multiple terms, so it is efficient in terms of disk space and query speed. However, it does not support prefix queries very well. If, as suggested above, the token &quot;first&quot; is substituted for &quot;1st&quot; by the tokenizer, then the query:</source>
          <target state="translated">Во многих случаях лучшим подходом является метод (1),описанный выше.Он не добавляет дополнительные данные в индекс FTS и не требует от FTS5 запроса на несколько терминов,поэтому он эффективен с точки зрения дискового пространства и скорости запроса.Однако он не очень хорошо поддерживает префиксные запросы.Если,как предлагалось выше,токен &quot;первый&quot; заменяется токеном &quot;первый&quot; на токенайзер,то запрос:</target>
        </trans-unit>
        <trans-unit id="5d477280cde1f0cb61a1a86eeb18153043aeb432" translate="yes" xml:space="preserve">
          <source>In most SQL databases, if you have a &lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE&lt;/a&gt;, &lt;a href=&quot;lang_createtable#notnullconst&quot;&gt;NOT NULL&lt;/a&gt;, or &lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK&lt;/a&gt; constraint on a table and you try to do an &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; or &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; that violates the constraint, the database will abort the operation in progress, back out any prior changes associated with the same UPDATE or INSERT statement, and return an error. This is the default behavior of SQLite, though SQLite also allows one to define alternative ways for dealing with constraint violations. This article describes those alternatives and how to use them.</source>
          <target state="translated">В большинстве баз данных SQL, если у вас есть ограничение &lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE&lt;/a&gt; , &lt;a href=&quot;lang_createtable#notnullconst&quot;&gt;NOT NULL&lt;/a&gt; или &lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK&lt;/a&gt; для таблицы и вы пытаетесь выполнить &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; или &lt;a href=&quot;lang_insert&quot;&gt;INSERT,&lt;/a&gt; который нарушает ограничение, база данных прервет текущую операцию, отменив все предыдущие изменения, связанные с тот же оператор UPDATE или INSERT и возвращает ошибку. Это поведение SQLite по умолчанию, хотя SQLite также позволяет определять альтернативные способы работы с нарушениями ограничений. В этой статье описаны эти альтернативы и их использование.</target>
        </trans-unit>
        <trans-unit id="a92a8e52f2222eb943cf97b12f1b58ee960571a6" translate="yes" xml:space="preserve">
          <source>In most SQL implementations, output columns of an aggregate query may only reference aggregate functions or columns named in the GROUP BY clause. It does not make good sense to reference an ordinary column in an aggregate query because each output row might be composed from two or more rows in the input table(s).</source>
          <target state="translated">В большинстве реализаций SQL,выходные столбцы агрегированного запроса могут ссылаться только на агрегированные функции или столбцы,названные в пункте GROUP BY.Не имеет смысла ссылаться на обычный столбец в совокупном запросе,потому что каждая выходная строка может состоять из двух или более строк во входной таблице (таблицах).</target>
        </trans-unit>
        <trans-unit id="ebf21aed9282198e08f544c4b59f1cde35658d89" translate="yes" xml:space="preserve">
          <source>In most applications, the database page cache subsystem within SQLite uses more dynamically allocated memory than all other parts of SQLite combined. It is not unusual to see the database page cache consume over 10 times more memory than the rest of SQLite combined.</source>
          <target state="translated">В большинстве приложений подсистема кэширования страниц базы данных внутри SQLite использует больше динамически выделяемой памяти,чем все остальные части SQLite вместе взятые.Нет ничего необычного в том,что кэш страниц БД потребляет в 10 раз больше памяти,чем остальные части SQLite вместе взятые.</target>
        </trans-unit>
        <trans-unit id="ea5d93a0bdef6b6a869ec9bc6ec20416d6dd4af5" translate="yes" xml:space="preserve">
          <source>In most applications, the number of columns is small - a few dozen. There are places in the SQLite code generator that use algorithms that are O(N&amp;sup2;) where N is the number of columns. So if you redefine SQLITE_MAX_COLUMN to be a really huge number and you generate SQL that uses a large number of columns, you may find that &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; runs slowly.</source>
          <target state="translated">В большинстве приложений количество столбцов невелико - несколько десятков. В генераторе кода SQLite есть места, в которых используются алгоритмы O (N&amp;sup2;), где N - количество столбцов. Поэтому, если вы переопределите SQLITE_MAX_COLUMN, чтобы оно было действительно огромным числом, и сгенерировали SQL, который использует большое количество столбцов, вы можете обнаружить, что &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; работает медленно.</target>
        </trans-unit>
        <trans-unit id="5715db4d1b11556e8f8726b68f211a79da84d8fd" translate="yes" xml:space="preserve">
          <source>In most cases, UNIQUE and PRIMARY KEY constraints are implemented by creating a unique index in the database. (The exceptions are &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; and PRIMARY KEYs on &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables.) Hence, the following schemas are logically equivalent:</source>
          <target state="translated">В большинстве случаев ограничения UNIQUE и PRIMARY KEY реализуются путем создания уникального индекса в базе данных. (Исключениями являются &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; и PRIMARY KEY в таблицах &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; .) Следовательно, следующие схемы логически эквивалентны:</target>
        </trans-unit>
        <trans-unit id="5a1cd73f371732c3b6f817956ff2682bb7f1000a" translate="yes" xml:space="preserve">
          <source>In most cases, you will want to supplement the basic commands above with &lt;a href=&quot;compile&quot;&gt;compile-time options&lt;/a&gt; appropriate for your application. Commonly used compile-time options include:</source>
          <target state="translated">В большинстве случаев вы захотите дополнить приведенные выше базовые команды &lt;a href=&quot;compile&quot;&gt;параметрами времени компиляции,&lt;/a&gt; подходящими для вашего приложения. Обычно используемые параметры времени компиляции включают:</target>
        </trans-unit>
        <trans-unit id="97ef5a309f4aafbcba4ef803b72a915f31e696d6" translate="yes" xml:space="preserve">
          <source>In most contexts, the special &quot;rowid&quot; column of normal tables can also be called &quot;oid&quot; or &quot;_rowid_&quot;. However, only &quot;rowid&quot; works as the keyword in the CREATE TABLE statement.</source>
          <target state="translated">В большинстве контекстов специальный столбец &quot;rowid&quot; обычных таблиц также может называться &quot;oid&quot; или &quot;_rowid_&quot;.Однако,только &quot;rowid&quot; работает в качестве ключевого слова в операторе CREATE TABLE.</target>
        </trans-unit>
        <trans-unit id="08bdbf2096af9fe45fd4ac595bd3e0c7bb6e8da7" translate="yes" xml:space="preserve">
          <source>In most other SQL database engines the datatype is associated with the table column that holds the data - with the data container. In SQLite 3.0, the datatype is associated with the data itself, not with its container. &lt;a href=&quot;http://www.paulgraham.com/&quot;&gt;Paul Graham&lt;/a&gt; in his book</source>
          <target state="translated">В большинстве других механизмов баз данных SQL тип данных связан со столбцом таблицы, в котором хранятся данные, - с контейнером данных. В SQLite 3.0 тип данных связан с самими данными, а не с их контейнером. &lt;a href=&quot;http://www.paulgraham.com/&quot;&gt;Пол Грэм&lt;/a&gt; в своей книге</target>
        </trans-unit>
        <trans-unit id="9b4441386a86e2d230e048847afd960634eadb47" translate="yes" xml:space="preserve">
          <source>In normal cases, new content is appended to the WAL file until the WAL file accumulates about 1000 pages (and is thus about 4MB in size) at which point a checkpoint is automatically run and the WAL file is recycled. The checkpoint does not normally truncate the WAL file (unless the &lt;a href=&quot;pragma#pragma_journal_size_limit&quot;&gt;journal_size_limit pragma&lt;/a&gt; is set). Instead, it merely causes SQLite to start overwriting the WAL file from the beginning. This is done because it is normally faster to overwrite an existing file than to append. When the last connection to a database closes, that connection does one last checkpoint and then deletes the WAL and its associated shared-memory file, to clean up the disk.</source>
          <target state="translated">В обычных случаях новое содержимое добавляется к файлу WAL до тех пор, пока файл WAL не накапливает около 1000 страниц (и, таким образом, имеет размер около 4 МБ), после чего автоматически запускается контрольная точка, а файл WAL повторно используется. Контрольная точка обычно не &lt;a href=&quot;pragma#pragma_journal_size_limit&quot;&gt;усекает&lt;/a&gt; файл WAL (если не установлена ​​прагма journal_size_limit ). Вместо этого он просто заставляет SQLite начать перезапись файла WAL с самого начала. Это сделано потому, что обычно быстрее перезаписать существующий файл, чем добавить. Когда последнее соединение с базой данных закрывается, это соединение выполняет одну последнюю контрольную точку, а затем удаляет WAL и связанный с ним файл общей памяти для очистки диска.</target>
        </trans-unit>
        <trans-unit id="9b10dbf3c620afa11c457409454feda884f8c775" translate="yes" xml:space="preserve">
          <source>In older versions of SQLite, shared cache mode could not be used together with virtual tables. This restriction was removed in SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_6_17.html&quot;&gt;version 3.6.17&lt;/a&gt; (2009-08-10).</source>
          <target state="translated">В более старых версиях SQLite режим общего кэша нельзя было использовать вместе с виртуальными таблицами. Это ограничение было снято в SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_6_17.html&quot;&gt;версии 3.6.17&lt;/a&gt; ( 10.08.2009 ).</target>
        </trans-unit>
        <trans-unit id="c0ec8617fee4e8f946bad89174a49f940e3f428d" translate="yes" xml:space="preserve">
          <source>In one test that indexed a large set of emails (1636 MiB on disk), the FTS index was 743 MiB on disk with detail=full, 340 MiB with detail=column and 134 MiB with detail=none.</source>
          <target state="translated">В одном тесте,который индексировал большой набор электронных сообщений (1636 Мб на диске),индекс FTS составлял 743 Мб на диске с detail=full,340 Мб с detail=column и 134 Мб с detail=none.</target>
        </trans-unit>
        <trans-unit id="79708a29f43e4b6af877ac3750b35c58a6cfa4a6" translate="yes" xml:space="preserve">
          <source>In order for an application to &lt;a href=&quot;fts5#extending_fts5&quot;&gt;add new extensions to FTS5&lt;/a&gt;, such as new tokenizers, the application needs a pointer to the &quot;fts5_api&quot; object.</source>
          <target state="translated">Чтобы приложение &lt;a href=&quot;fts5#extending_fts5&quot;&gt;могло добавлять новые расширения в FTS5&lt;/a&gt; , такие как новые токенизаторы, приложению необходим указатель на объект &amp;laquo;fts5_api&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="28a836bfad6faf09ee027032e5467aeee1a64f66" translate="yes" xml:space="preserve">
          <source>In order for the OR-by-UNION technique shown above to be useful, there must be an index available that helps resolve every OR-connected term in the WHERE clause. If even a single OR-connected term is not indexed, then a full table scan would have to be done in order to find the rowids generated by the one term, and if SQLite has to do a full table scan, it might as well do it on the original table and get all of the results in a single pass without having to mess with union operations and follow-on binary searches.</source>
          <target state="translated">Для того,чтобы показанная выше техника &quot;по ИЛИ&quot; была полезной,должен быть доступен индекс,помогающий разрешить каждый ИЛИ-связанный термин в пункте ГДЕ.Если даже один термин,связанный с оператором &quot;OR&quot;,не индексируется,то необходимо выполнить полное сканирование таблицы,чтобы найти строки,сгенерированные одним термином,а если SQLite должен выполнить полное сканирование таблицы,то он может сделать это и на исходной таблице и получить все результаты за один проход,не связываясь с операциями объединения и последующим бинарным поиском.</target>
        </trans-unit>
        <trans-unit id="eb3713c378b1d1ce3d9a0c47d48cd2eaea6cff83" translate="yes" xml:space="preserve">
          <source>In order to allow multiple threads to use the same database connection at the same time, SQLite must make extensive use of mutexes. And for this reason a new mutex subsystem as been added. The mutex subsystem as the following interface:</source>
          <target state="translated">Для того чтобы несколько потоков могли использовать одно и то же подключение к базе данных одновременно,SQLite должен широко использовать мьютексы.И по этой причине была добавлена новая подсистема мьютексов.Подсистема мьютекса в качестве интерфейса:</target>
        </trans-unit>
        <trans-unit id="2b5d71d84c9eba5a8b5eeb690db9b2671be986f0" translate="yes" xml:space="preserve">
          <source>In order to avoid this problem, instead of a single large buffer, input is passed to a streaming API functions by way of a callback function that the sessions module invokes to incrementally request input data as it is required. In all cases, a pair of API function parameters such as</source>
          <target state="translated">Чтобы избежать этой проблемы,вместо одного большого буфера,вход передаётся в потоковое API-функции посредством функции обратного вызова,которую модуль сеансов вызывает для инкрементального запроса входных данных по мере необходимости.Во всех случаях пара параметров функции API,таких как</target>
        </trans-unit>
        <trans-unit id="4b125f2963fbbbf781a2aacf5295274d0ac9b884" translate="yes" xml:space="preserve">
          <source>In order to calculate a documents score, the full-text query is separated into its component phrases. The bm25 score for document</source>
          <target state="translated">Для вычисления оценки документов полнотекстовый запрос разделяется на составляющие его фразы.Оценка bm25 для документа</target>
        </trans-unit>
        <trans-unit id="7154e5ea3dd269ef8c7a3c815659cc160be40ee6" translate="yes" xml:space="preserve">
          <source>In order to change the mapping of the rank column for a single query, a term similar to either of the following is added to the WHERE clause of a query:</source>
          <target state="translated">Чтобы изменить отображение рангового столбца для одного запроса,в выражение WHERE запроса добавляется термин,аналогичный одному из следующих:</target>
        </trans-unit>
        <trans-unit id="2abb792779e09d00b7b2cceff1ab43c73c0ae359" translate="yes" xml:space="preserve">
          <source>In order to create an FTS4 table that does not store a copy of the indexed documents at all, the content option should be set to an empty string. For example, the following SQL creates such an FTS4 table with three columns - &quot;a&quot;, &quot;b&quot;, and &quot;c&quot;:</source>
          <target state="translated">Для создания таблицы FTS4,в которой вообще не хранится копия проиндексированных документов,параметр содержимого должен быть установлен в пустую строку.Например,следующий SQL создает такую таблицу FTS4 с тремя столбцами-&quot;a&quot;,&quot;b&quot; и &quot;c&quot;:</target>
        </trans-unit>
        <trans-unit id="dfa1c414109c4c2ee027ceb1647c28553c0a4044" translate="yes" xml:space="preserve">
          <source>In order to create or modify an existing zip file, a &quot;zipfile&quot; virtual table must be created in the database schema. The CREATE VIRTUAL TABLE statement expects a path to the zip file as its only argument. For example, to write to zip file &quot;test.zip&quot; in the current directory, a zipfile table may be created using:</source>
          <target state="translated">Для того,чтобы создать или изменить существующий zip-файл,в схеме базы данных должна быть создана виртуальная таблица &quot;zip-файл&quot;.Оператор CREATE VIRTUAL TABLE ожидает в качестве единственного аргумента путь к zip-файлу.Например,для записи в zip-файл &quot;test.zip&quot; в текущем каталоге можно создать zip-таблицу:</target>
        </trans-unit>
        <trans-unit id="46eb456df96a41735386e11e34c4d6e23c625078" translate="yes" xml:space="preserve">
          <source>In order to determine whether or not the database file has changed, SQLite uses a counter in the database header (in bytes 24 through 27) which is incremented during every change operation. SQLite saves a copy of this counter prior to releasing its database lock. Then after acquiring the next database lock it compares the saved counter value against the current counter value and erases the cache if the values are different, or reuses the cache if they are the same.</source>
          <target state="translated">Для того чтобы определить,изменился ли файл базы данных,SQLite использует счетчик в заголовке базы данных (в байтах с 24 по 27),который инкрементируется при каждой операции изменения.SQLite сохраняет копию этого счетчика до освобождения блокировки базы данных.Затем после получения следующей блокировки базы данных он сравнивает сохраненное значение счетчика с текущим значением счетчика и стирает кэш,если значения отличаются,или повторно использует кэш,если они совпадают.</target>
        </trans-unit>
        <trans-unit id="c5338f8b41864bbeb0f4c2c2e58a285f7e7a5717" translate="yes" xml:space="preserve">
          <source>In order to gain experience with the main ideas surrounding asynchronous IO, this implementation is deliberately kept simple. Additional capabilities may be added in the future.</source>
          <target state="translated">Для того,чтобы получить опыт работы с основными идеями,окружающими асинхронный ввод-вывод,эта реализация намеренно поддерживается простой.Дополнительные возможности могут быть добавлены в будущем.</target>
        </trans-unit>
        <trans-unit id="a809ecf69a6ad9ffe3bc78cfb9dbeacb5971a731" translate="yes" xml:space="preserve">
          <source>In order to guarantee that database files are always consistent, SQLite will occasionally ask the operating system to flush all pending writes to persistent storage then wait for that flush to complete. This is accomplished using the &lt;code&gt;fsync()&lt;/code&gt; system call under unix and &lt;code&gt;FlushFileBuffers()&lt;/code&gt; under Windows. We call this flush of pending writes a &quot;sync&quot;.</source>
          <target state="translated">Чтобы гарантировать, что файлы базы данных всегда согласованы, SQLite иногда запрашивает операционную систему сбросить все ожидающие записи в постоянное хранилище, а затем ждать завершения этой очистки. Это достигается с помощью системного вызова &lt;code&gt;fsync()&lt;/code&gt; в unix и &lt;code&gt;FlushFileBuffers()&lt;/code&gt; в Windows. Мы называем этот сброс отложенных записей &quot;синхронизацией&quot;.</target>
        </trans-unit>
        <trans-unit id="78171183b8bae18fcaabb772e335a2f85feaf3a5" translate="yes" xml:space="preserve">
          <source>In order to maintain backwards compatibility, this setting is ON by default. There are advantages to turning it off, and most applications will be unaffected if it is turned off. For that reason, all applications are encouraged to switch this setting off on every database connection as soon as that connection is opened.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d3d52a785446942df482ef9658c77840bb31674" translate="yes" xml:space="preserve">
          <source>In order to maintain full backwards compatibility for legacy applications, the URI filename capability is disabled by default. URI filenames can be enabled or disabled using the &lt;a href=&quot;compile#use_uri&quot;&gt;SQLITE_USE_URI=1&lt;/a&gt; or &lt;a href=&quot;compile#use_uri&quot;&gt;SQLITE_USE_URI=0&lt;/a&gt; compile-time options. The compile-time setting for URI filenames can be changed at start-time using the &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfiguri&quot;&gt;SQLITE_CONFIG_URI&lt;/a&gt;,1) or &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfiguri&quot;&gt;SQLITE_CONFIG_URI&lt;/a&gt;,0) configuration calls. Regardless of the compile-time or start-time settings, URI filenames can be enabled for individual database connections by including the &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_URI&lt;/a&gt; bit in the set of bits passed as the F parameter to &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2(N,P,F,V)&lt;/a&gt;.</source>
          <target state="translated">Чтобы поддерживать полную обратную совместимость для устаревших приложений, возможность использования имени файла URI по умолчанию отключена. Имена файлов URI могут быть включены или отключены с помощью параметров времени &lt;a href=&quot;compile#use_uri&quot;&gt;компиляции SQLITE_USE_URI = 1&lt;/a&gt; или &lt;a href=&quot;compile#use_uri&quot;&gt;SQLITE_USE_URI = 0&lt;/a&gt; . Настройка времени компиляции для имен файлов URI может быть изменена во время запуска с помощью вызовов конфигурации &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt; ( &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfiguri&quot;&gt;SQLITE_CONFIG_URI&lt;/a&gt; , 1) или &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt; ( &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfiguri&quot;&gt;SQLITE_CONFIG_URI&lt;/a&gt; , 0). Независимо от настроек времени компиляции или времени начала, имена файлов URI можно включить для отдельных подключений к базе данных, включив бит &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_URI&lt;/a&gt; в набор битов, переданных в качестве параметра F в &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2 (N, P, F, V)&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="ee9ce9696c9f5b398459fe9fa5003d871b602ba2" translate="yes" xml:space="preserve">
          <source>In order to maximize compatibility between SQLite and other database engines, and so that the example above will work on SQLite as it does on other SQL database engines, SQLite supports the concept of &quot;type affinity&quot; on columns. The type affinity of a column is the recommended type for data stored in that column. The important idea here is that the type is recommended, not required. Any column can still store any type of data. It is just that some columns, given the choice, will prefer to use one storage class over another. The preferred storage class for a column is called its &quot;affinity&quot;.</source>
          <target state="translated">Для обеспечения максимальной совместимости между SQLite и другими движками баз данных,а также для того,чтобы приведенный выше пример работал на SQLite так же,как он работает на других движках баз данных SQL,SQLite поддерживает концепцию &quot;сродства по типам&quot; на столбцах.Сродство к типу столбца является рекомендуемым типом для данных,хранящихся в этом столбце.Важной идеей здесь является то,что тип рекомендуется,а не требуется.Любой столбец может хранить данные любого типа.Просто некоторые столбцы,при наличии выбора,предпочтут использовать один класс хранения,а не другой.Предпочтительный для столбца класс хранения называется его &quot;родством&quot;.</target>
        </trans-unit>
        <trans-unit id="c4c58e4d4912a4704b0cbb27832e1afdc4578e5c" translate="yes" xml:space="preserve">
          <source>In order to port SQLite to a new operating system - an operating system not supported by default - the application must provide...</source>
          <target state="translated">Для того чтобы перенести SQLite на новую операционную систему-операционную систему,не поддерживаемую по умолчанию-приложение должно предоставить...</target>
        </trans-unit>
        <trans-unit id="9139039adfb729ff69195002226ce412be58a20b" translate="yes" xml:space="preserve">
          <source>In order to prevent the number of b-trees in the database from becoming too large (slowing down queries), smaller b-trees are periodically merged into single larger b-trees containing the same data. By default, this happens automatically within INSERT, UPDATE or DELETE statements that modify the full-text index. The 'automerge' parameter determines how many smaller b-trees are merged together at a time. Setting it to a small value can speed up queries (as they have to query and merge the results from fewer b-trees), but can also slow down writing to the database (as each INSERT, UPDATE or DELETE statement has to do more work as part of the automatic merging process).</source>
          <target state="translated">Для того чтобы количество b-деревьев в БД не становилось слишком большим (замедление запросов),меньшие b-деревьи периодически объединяются в одни более крупные b-деревьи,содержащие одни и те же данные.По умолчанию это происходит автоматически в операторах INSERT,UPDATE или DELETE,которые изменяют полнотекстовый индекс.Параметр 'automerge' определяет,сколько меньших b-деревьев объединяется одновременно.Установка небольшого значения может не только ускорить запросы (так как они должны запрашивать и объединять результаты из меньшего количества b-деревьев),но и замедлить запись в базу данных (так как каждый оператор INSERT,UPDATE или DELETE должен выполнять больше работы в рамках автоматического объединения).</target>
        </trans-unit>
        <trans-unit id="3d48be902e74206d36d33669d85fb41c800c7878" translate="yes" xml:space="preserve">
          <source>In order to provide portability between across operating systems, SQLite uses abstract object called the &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;. Each VFS provides methods for opening, read, writing, and closing files on disk, and for other OS-specific task such as finding the current time, or obtaining randomness to initialize the built-in pseudo-random number generator. SQLite currently provides VFSes for unix (in the &lt;a href=&quot;https://sqlite.org/src/file/src/os_unix.c&quot;&gt;os_unix.c&lt;/a&gt; file) and Windows (in the &lt;a href=&quot;https://sqlite.org/src/file/src/os_win.c&quot;&gt;os_win.c&lt;/a&gt; file).</source>
          <target state="translated">Чтобы обеспечить переносимость между операционными системами, SQLite использует абстрактный объект, называемый &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; . Каждая VFS предоставляет методы для открытия, чтения, записи и закрытия файлов на диске, а также для других задач, специфичных для ОС, таких как определение текущего времени или получение случайности для инициализации встроенного генератора псевдослучайных чисел. В настоящее время SQLite предоставляет VFS для unix (в файле &lt;a href=&quot;https://sqlite.org/src/file/src/os_unix.c&quot;&gt;os_unix.c&lt;/a&gt; ) и Windows (в файле &lt;a href=&quot;https://sqlite.org/src/file/src/os_win.c&quot;&gt;os_win.c&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="31ad990efe0b69348774fca33a1caeca8003e9e6" translate="yes" xml:space="preserve">
          <source>In order to rebase a local changeset, the remote changeset must first be applied to the local database using sqlite3changeset_apply_v2() and the buffer of rebase information captured. Then:</source>
          <target state="translated">Для того,чтобы выполнить ребейсинг локального changeset,необходимо сначала применить удаленный changeset к локальной базе данных с помощью sqlite3changeset_apply_v2()и перехватить буфер информации о ребейсинге.Затем:</target>
        </trans-unit>
        <trans-unit id="aa098185ca802c3d4bb821bfd07089d8121f87d8" translate="yes" xml:space="preserve">
          <source>In order to return data from the database to the user, for example as the results of a SELECT query, SQLite must at some point read data from the database file. Usually, data is read from the database file in aligned blocks of</source>
          <target state="translated">Чтобы вернуть данные из БД пользователю,например,как результаты SELECT-запроса,SQLite должен в какой-то момент прочитать данные из файла БД.Обычно данные считываются из файла базы данных в выровненных блоках из</target>
        </trans-unit>
        <trans-unit id="fbe7b2f0d6747492938cc0cedd14f11e91e462ca" translate="yes" xml:space="preserve">
          <source>In order to save space, this backing table may be omitted by setting the columnsize option to zero. For example:</source>
          <target state="translated">Чтобы сэкономить место,эту таблицу подложек можно опустить,установив опцию размера колонки на ноль.Например:</target>
        </trans-unit>
        <trans-unit id="1dc49d196adf92707040503b638c58b0d1b51283" translate="yes" xml:space="preserve">
          <source>In order to succeed, the database connection must not be in &lt;a href=&quot;#sqlite3_get_autocommit&quot;&gt;autocommit mode&lt;/a&gt; when &lt;a href=&quot;#sqlite3_snapshot_open&quot;&gt;sqlite3_snapshot_open(D,S,P)&lt;/a&gt; is called. If there is already a read transaction open on schema S, then the database handle must have no active statements (SELECT statements that have been passed to sqlite3_step() but not sqlite3_reset() or sqlite3_finalize()). SQLITE_ERROR is returned if either of these conditions is violated, or if schema S does not exist, or if the snapshot object is invalid.</source>
          <target state="translated">Для успешного выполнения соединение с базой данных не должно находиться в &lt;a href=&quot;#sqlite3_get_autocommit&quot;&gt;режиме &lt;/a&gt;&lt;a href=&quot;#sqlite3_snapshot_open&quot;&gt;автоматической &lt;/a&gt;фиксации при вызове sqlite3_snapshot_open (D, S, P) . Если в схеме S уже открыта транзакция чтения, то дескриптор базы данных не должен иметь активных операторов (операторы SELECT, которые были переданы в sqlite3_step (), но не в sqlite3_reset () или sqlite3_finalize ()). SQLITE_ERROR возвращается, если любое из этих условий нарушено, или если схема S не существует, или если объект моментального снимка недействителен.</target>
        </trans-unit>
        <trans-unit id="4bcc91176e8c72eef945e65a5e94e40093e70723" translate="yes" xml:space="preserve">
          <source>In order to succeed, the database connection must not be in &lt;a href=&quot;get_autocommit&quot;&gt;autocommit mode&lt;/a&gt; when &lt;a href=&quot;snapshot_open&quot;&gt;sqlite3_snapshot_open(D,S,P)&lt;/a&gt; is called. If there is already a read transaction open on schema S, then the database handle must have no active statements (SELECT statements that have been passed to sqlite3_step() but not sqlite3_reset() or sqlite3_finalize()). SQLITE_ERROR is returned if either of these conditions is violated, or if schema S does not exist, or if the snapshot object is invalid.</source>
          <target state="translated">Для успешного выполнения соединение с базой данных не должно находиться в &lt;a href=&quot;get_autocommit&quot;&gt;режиме &lt;/a&gt;&lt;a href=&quot;snapshot_open&quot;&gt;автоматической &lt;/a&gt;фиксации при вызове sqlite3_snapshot_open (D, S, P) . Если в схеме S уже открыта транзакция чтения, то дескриптор базы данных не должен иметь активных операторов (операторы SELECT, которые были переданы в sqlite3_step (), но не в sqlite3_reset () или sqlite3_finalize ()). SQLITE_ERROR возвращается, если любое из этих условий нарушено, или если схема S не существует, или если объект моментального снимка недействителен.</target>
        </trans-unit>
        <trans-unit id="3885c40685a2b0fc9bd29a3371e31ed82a66178a" translate="yes" xml:space="preserve">
          <source>In order to use FTS5 instead of FTS3 or FTS4, applications usually require minimal modifications. Most of these fall into three categories - changes required to the CREATE VIRTUAL TABLE statement used to create the FTS table, changes required to SELECT queries used to execute queries against the table, and changes required to applications that use &lt;a href=&quot;fts3#snippet&quot;&gt;FTS auxiliary functions&lt;/a&gt;.</source>
          <target state="translated">Чтобы использовать FTS5 вместо FTS3 или FTS4, приложения обычно требуют минимальных изменений. Большинство из них делятся на три категории: изменения, необходимые для оператора CREATE VIRTUAL TABLE, используемого для создания таблицы FTS, изменения, необходимые для запросов SELECT, используемых для выполнения запросов к таблице, и изменения, необходимые для приложений, использующих &lt;a href=&quot;fts3#snippet&quot;&gt;вспомогательные функции FTS&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="362a80a01b0db13fb3dac03d2ae8d3c5e2853e16" translate="yes" xml:space="preserve">
          <source>In order to use foreign key constraints in SQLite, the library must be compiled with neither &lt;a href=&quot;compile#omit_foreign_key&quot;&gt;SQLITE_OMIT_FOREIGN_KEY&lt;/a&gt; or &lt;a href=&quot;compile#omit_trigger&quot;&gt;SQLITE_OMIT_TRIGGER&lt;/a&gt; defined. If SQLITE_OMIT_TRIGGER is defined but SQLITE_OMIT_FOREIGN_KEY is not, then SQLite behaves as it did prior to &lt;a href=&quot;https://sqlite.org/releaselog/3_6_19.html&quot;&gt;version 3.6.19&lt;/a&gt; (2009-10-14) - foreign key definitions are parsed and may be queried using &lt;a href=&quot;pragma#pragma_foreign_key_list&quot;&gt;PRAGMA foreign_key_list&lt;/a&gt;, but foreign key constraints are not enforced. The &lt;a href=&quot;pragma#pragma_foreign_keys&quot;&gt;PRAGMA foreign_keys&lt;/a&gt; command is a no-op in this configuration. If OMIT_FOREIGN_KEY is defined, then foreign key definitions cannot even be parsed (attempting to specify a foreign key definition is a syntax error).</source>
          <target state="translated">Чтобы использовать ограничения внешнего ключа в SQLite, библиотека должна быть скомпилирована без определения &lt;a href=&quot;compile#omit_foreign_key&quot;&gt;SQLITE_OMIT_FOREIGN_KEY&lt;/a&gt; или &lt;a href=&quot;compile#omit_trigger&quot;&gt;SQLITE_OMIT_TRIGGER&lt;/a&gt; . Если SQLITE_OMIT_TRIGGER определен, а SQLITE_OMIT_FOREIGN_KEY - нет, то SQLite ведет себя так же, как и до &lt;a href=&quot;https://sqlite.org/releaselog/3_6_19.html&quot;&gt;версии 3.6.19&lt;/a&gt; (2009-10-14) - определения внешних ключей анализируются и могут запрашиваться с помощью &lt;a href=&quot;pragma#pragma_foreign_key_list&quot;&gt;PRAGMA foreign_key_list&lt;/a&gt; , но ограничения внешнего ключа не применяются. Команда &lt;a href=&quot;pragma#pragma_foreign_keys&quot;&gt;PRAGMA foreign_keys&lt;/a&gt; не работает в этой конфигурации. Если определен OMIT_FOREIGN_KEY, определения внешнего ключа не могут быть даже проанализированы (попытка указать определение внешнего ключа является синтаксической ошибкой).</target>
        </trans-unit>
        <trans-unit id="2a10b918ff09134ab69409cf683db7b4a9557318" translate="yes" xml:space="preserve">
          <source>In order to use this command to delete a row, the text value 'delete' must be inserted into the special column with the same name as the table. The rowid of the row to delete is inserted into the rowid column. The values inserted into the other columns must match the values currently stored in the table. For example:</source>
          <target state="translated">Для того,чтобы использовать эту команду для удаления строки,текстовое значение 'delete' должно быть вставлено в специальный столбец с тем же именем,что и таблица.В колонку вставляется шрифт удаляемой строки.Значения,вставленные в другие колонки,должны совпадать со значениями,хранящимися в таблице в данный момент.Например:</target>
        </trans-unit>
        <trans-unit id="18acf9de092948631a77a8a7268e93e0863d7575" translate="yes" xml:space="preserve">
          <source>In ordinary indexes, there is exactly one entry in the index for every row in the table. In partial indexes, only some subset of the rows in the table have corresponding index entries. For example, a partial index might omit entries for which the column being indexed is NULL. When used judiciously, partial indexes can result in smaller database files and improvements in both query and write performance.</source>
          <target state="translated">В обычных индексах на каждую строку таблицы приходится ровно одна запись.В частичных индексах только некоторые подмножества строк таблицы имеют соответствующие записи индекса.Например,в частичном индексе могут опускаться записи,для которых столбец индексируемого столбца является NULL.При разумном использовании частичные индексы могут привести к уменьшению файлов базы данных и улучшению производительности как при запросах,так и при записи.</target>
        </trans-unit>
        <trans-unit id="2aff0a10aa915dae8ca55cc20203451ac3b580cc" translate="yes" xml:space="preserve">
          <source>In other words, an SQLite database can do everything that a pile-of-files or wrapped pile-of-files format can do, plus much more, and with greater lucidity. An SQLite database is a more versatile container than key/value filesystem or a ZIP archive. (For a detailed example, see the &lt;a href=&quot;affcase1&quot;&gt;OpenOffice case study&lt;/a&gt; essay.)</source>
          <target state="translated">Другими словами, база данных SQLite может делать все, что могут делать форматы стопки файлов или обернутой стопки файлов, а также многое другое и с большей ясностью. База данных SQLite - более универсальный контейнер, чем файловая система ключ / значение или ZIP-архив. (Подробный пример см. В эссе с &lt;a href=&quot;affcase1&quot;&gt;тематическим исследованием OpenOffice&lt;/a&gt; .)</target>
        </trans-unit>
        <trans-unit id="a0407b322bda5c84932b9210d6c9dd55dfaff1cd" translate="yes" xml:space="preserve">
          <source>In other words, if X begins a write transaction using &lt;a href=&quot;lang_transaction#immediate&quot;&gt;BEGIN IMMEDIATE&lt;/a&gt; then issues one or more &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;, &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt;, and/or &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; statements, then those changes are visible to subsequent &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statements that are evaluated in database connection X. &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statements on a different database connection Y will show no changes until the X transaction commits. But &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statements in X will show the changes prior to the commit.</source>
          <target state="translated">Другими словами, если X начинает транзакцию записи с помощью &lt;a href=&quot;lang_transaction#immediate&quot;&gt;BEGIN IMMEDIATE,&lt;/a&gt; затем выдает один или несколько операторов &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; , &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; и / или &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; , тогда эти изменения видны последующим &lt;a href=&quot;lang_select&quot;&gt;операторам SELECT&lt;/a&gt; , которые оцениваются в соединении X с базой данных. Операторы &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; на другом соединение с базой данных Y не будет показывать никаких изменений, пока транзакция X не будет зафиксирована. Но &lt;a href=&quot;lang_select&quot;&gt;операторы SELECT&lt;/a&gt; в X покажут изменения до фиксации.</target>
        </trans-unit>
        <trans-unit id="b76e19862dad40faf099a9e663056c35b57f6bbd" translate="yes" xml:space="preserve">
          <source>In other words, make the same sqlite3_test_control() call except change the last two parameters to zero.</source>
          <target state="translated">Другими словами,сделать один и тот же вызов sqlite3_test_control(),за исключением изменения двух последних параметров на ноль.</target>
        </trans-unit>
        <trans-unit id="a943abceb2efdd003ead8aa4530811df4446fd2f" translate="yes" xml:space="preserve">
          <source>In other words, opening and using a database file that has two or more names results in behavior that is undefined and probably undesirable.</source>
          <target state="translated">Другими словами,открытие и использование файла базы данных,который имеет два или более имени,приводит к поведению,которое является неопределенным и,возможно,нежелательным.</target>
        </trans-unit>
        <trans-unit id="5f5d40599d0989dfe7615dba1f4690adcb6d4ca6" translate="yes" xml:space="preserve">
          <source>In other words, powersafe overwrite means that there is no &quot;collateral damage&quot; when a power loss occurs while writing. Only those bytes actually being written might be damaged.</source>
          <target state="translated">Другими словами,безопасная перезапись означает,что нет &quot;сопутствующих повреждений&quot;,когда происходит потеря мощности во время записи.Повреждения могут быть нанесены только тем байтам,которые действительно были записаны.</target>
        </trans-unit>
        <trans-unit id="ebd1e3e7febed4c7b9b73c22b3802bc322206c02" translate="yes" xml:space="preserve">
          <source>In other words, since 2004 all SQLite releases have been backwards compatible, though not necessarily forwards compatible.</source>
          <target state="translated">Другими словами,с 2004 года все выпуски SQLite имеют обратную совместимость,хотя и не обязательно обратную.</target>
        </trans-unit>
        <trans-unit id="1f360548804fb547b2c55aa98cf2f1549c641a34" translate="yes" xml:space="preserve">
          <source>In other words, the session extension provides a facility for SQLite database files that is similar to the unix &lt;a href=&quot;https://en.wikipedia.org/wiki/Patch_(Unix)&quot;&gt;patch&lt;/a&gt; utility program, or to the &quot;merge&quot; capabilities of version control systems such as &lt;a href=&quot;https://www.fossil-scm.org/&quot;&gt;Fossil&lt;/a&gt;, &lt;a href=&quot;https://git-scm.com&quot;&gt;Git&lt;/a&gt;, or &lt;a href=&quot;http://www.mercurial-scm.org/&quot;&gt;Mercurial&lt;/a&gt;.</source>
          <target state="translated">Другими словами, расширение сеанса предоставляет возможность для файлов базы данных SQLite, аналогичную служебной программе &lt;a href=&quot;https://en.wikipedia.org/wiki/Patch_(Unix)&quot;&gt;патча&lt;/a&gt; unix , или возможности &amp;laquo;слияния&amp;raquo; систем контроля версий, таких как &lt;a href=&quot;https://www.fossil-scm.org/&quot;&gt;Fossil&lt;/a&gt; , &lt;a href=&quot;https://git-scm.com&quot;&gt;Git&lt;/a&gt; или &lt;a href=&quot;http://www.mercurial-scm.org/&quot;&gt;Mercurial&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c9d46649fb7fd18d588f4a5f73a3e3c10dcafa53" translate="yes" xml:space="preserve">
          <source>In other words, unlinking or renaming an open database file results in behavior that is undefined and probably undesirable.</source>
          <target state="translated">Другими словами,развязывание или переименование открытого файла базы данных приводит к поведению,которое является неопределенным и,возможно,нежелательным.</target>
        </trans-unit>
        <trans-unit id="a8fad5ad802fc08a8688a68301e637bb10e07021" translate="yes" xml:space="preserve">
          <source>In other words, you should call sqlite3_column_text(), sqlite3_column_blob(), or sqlite3_column_text16() first to force the result into the desired format, then invoke sqlite3_column_bytes() or sqlite3_column_bytes16() to find the size of the result. Do not mix calls to sqlite3_column_text() or sqlite3_column_blob() with calls to sqlite3_column_bytes16(), and do not mix calls to sqlite3_column_text16() with calls to sqlite3_column_bytes().</source>
          <target state="translated">Другими словами,сначала нужно вызвать sqlite3_column_text(),sqlite3_column_blob()или sqlite3_column_text16(),чтобы форсировать результат в нужный формат,затем вызвать sqlite3_column_bytes()или sqlite3_column_bytes16(),чтобы найти размер результата.Не смешивайте вызовы sqlite3_column_text()или sqlite3_column_blob()с вызовами sqlite3_column_bytes16()и не смешивайте вызовы sqlite3_column_text16()с вызовами sqlite3_column_bytes().</target>
        </trans-unit>
        <trans-unit id="456e92a6a9d74515a6d36409e4455702906122d6" translate="yes" xml:space="preserve">
          <source>In practical terms, what the powersafe write property means is that when the disk controller detects an impending power loss, it finishes writing whatever sector it is working on prior to parking the heads. It means that individual sector writes will complete once started, even if there is a power loss.</source>
          <target state="translated">С практической точки зрения,свойство записи Powersafe означает,что когда контроллер диска обнаруживает грозящую потерю мощности,он заканчивает запись в любом секторе,над которым он работает,до того,как головки будут поставлены на стоянку.Это означает,что запись отдельного сектора будет завершена после начала,даже если произойдет потеря питания.</target>
        </trans-unit>
        <trans-unit id="9fe8084319ab239e87ac8042e3d629376c48f43e" translate="yes" xml:space="preserve">
          <source>In practice, metadata is preserved between function calls for function parameters that are compile-time constants, including literal values and &lt;a href=&quot;../lang_expr#varparam&quot;&gt;parameters&lt;/a&gt; and expressions composed from the same.</source>
          <target state="translated">На практике метаданные сохраняются между вызовами функций для параметров функции, которые являются константами времени компиляции, включая литеральные значения, &lt;a href=&quot;../lang_expr#varparam&quot;&gt;параметры&lt;/a&gt; и выражения, составленные из них.</target>
        </trans-unit>
        <trans-unit id="553ff79ef31136314c6f3a02cf8b8c9de3d93346" translate="yes" xml:space="preserve">
          <source>In practice, metadata is preserved between function calls for function parameters that are compile-time constants, including literal values and &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameters&lt;/a&gt; and expressions composed from the same.</source>
          <target state="translated">На практике метаданные сохраняются между вызовами функций для параметров функции, которые являются константами времени компиляции, включая литеральные значения, &lt;a href=&quot;lang_expr#varparam&quot;&gt;параметры&lt;/a&gt; и выражения, составленные из них.</target>
        </trans-unit>
        <trans-unit id="235238a95713f71f096fe2094b1d8d70514424be" translate="yes" xml:space="preserve">
          <source>In precompiled SQLite libraries available on the website, the Unix versions are compiled with THREADSAFE turned off but the Windows versions are compiled with THREADSAFE turned on. If you need something different that this you will have to recompile.</source>
          <target state="translated">В прекомпилированных SQLite библиотеках,доступных на сайте,версии Unix компилируются с выключенным THREADSAFE,а версии Windows компилируются с включенным THREADSAFE.Если вам нужно что-то другое,то вам придется это перекомпилировать.</target>
        </trans-unit>
        <trans-unit id="49d7b0c7067454bf2994ce5482f78c23710e1d3a" translate="yes" xml:space="preserve">
          <source>In prior discussion, it was assumed that each SQL statement is prepared once, evaluated, then destroyed. However, SQLite allows the same &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; to be evaluated multiple times. This is accomplished using the following routines:</source>
          <target state="translated">В предыдущем обсуждении предполагалось, что каждый оператор SQL готовится один раз, оценивается, а затем уничтожается. Однако SQLite позволяет выполнять многократную оценку одного и того же &lt;a href=&quot;c3ref/stmt&quot;&gt;подготовленного оператора&lt;/a&gt; . Это достигается с помощью следующих процедур:</target>
        </trans-unit>
        <trans-unit id="86c3b83aa53c8f50b7b8f707247a7f27be6c0dc8" translate="yes" xml:space="preserve">
          <source>In processing the query above, SQLite invokes the sumint callbacks as follows:</source>
          <target state="translated">При обработке вышеприведенного запроса SQLite вызывает обратные вызовы суммирования следующим образом:</target>
        </trans-unit>
        <trans-unit id="59cf5532e18c9ee34b181fd5de97a560addf74bf" translate="yes" xml:space="preserve">
          <source>In queries that are driven by a &lt;a href=&quot;partialindex&quot;&gt;partial index&lt;/a&gt;, avoid unnecessary tests of the constraint named in the WHERE clause of the partial index, since we know that constraint must always be true.</source>
          <target state="translated">В запросах, управляемых &lt;a href=&quot;partialindex&quot;&gt;частичным индексом&lt;/a&gt; , избегайте ненужных проверок ограничения, указанного в предложении WHERE частичного индекса, поскольку мы знаем, что это ограничение всегда должно быть истинным.</target>
        </trans-unit>
        <trans-unit id="82246b58b2662ec98735d83b367a59b70f82fb40" translate="yes" xml:space="preserve">
          <source>In rollback mode, SQLite implements isolation by locking the database file and preventing any reads by other database connections while each write transaction is underway. Readers can be be active at the beginning of a write, before any content is flushed to disk and while all changes are still held in the writer's private memory space. But before any changes are made to the database file on disk, all readers must be (temporally) expelled in order to give the writer exclusive access to the database file. Hence, readers are prohibited from seeing incomplete transactions by virtue of being locked out of the database while the transaction is being written to disk. Only after the transaction is completely written and synced to disk and commits are the readers allowed back into the database. Hence readers never get a chance to see partially written changes.</source>
          <target state="translated">В режиме отката SQLite реализует изоляцию,блокируя файл базы данных и предотвращая чтение другими соединениями к БД во время выполнения каждой транзакции записи.Читатели могут быть активны в начале записи,до того,как любое содержимое будет записано на диск,и в то время,как все изменения все еще хранятся в личном пространстве памяти записывающего устройства.Но перед тем,как внести какие-либо изменения в файл базы данных на диске,все читатели должны быть (временно)исключены,чтобы дать записывающему устройству эксклюзивный доступ к файлу базы данных.Следовательно,читателям запрещается видеть незавершенные транзакции в силу того,что во время записи транзакции на диск они заблокированы от БД.Только после того,как транзакция полностью записана и синхронизирована с диском и коммитами,читателям разрешается вернуться обратно в БД.Таким образом,читатели никогда не смогут увидеть частично записанные изменения.</target>
        </trans-unit>
        <trans-unit id="068d2699f531d0825115d300a0cccce10e48a71e" translate="yes" xml:space="preserve">
          <source>In spite of the disadvantages, the developers believe that having a built-in printf() implementation inside of SQLite is a net positive.</source>
          <target state="translated">Несмотря на недостатки,разработчики считают,что наличие встроенной реализации printf()внутри SQLite является положительным моментом.</target>
        </trans-unit>
        <trans-unit id="cf039b1afa32ebe62123ae1292d3fdd466d22e3b" translate="yes" xml:space="preserve">
          <source>In step 2 of the procedure above, the database file is not locked before it is read from. This is the only exception to the locking rules described in section</source>
          <target state="translated">На втором шаге процедуры,описанной выше,файл базы данных не блокируется перед его считыванием.Это единственное исключение из правил блокировки,описанных в разделе</target>
        </trans-unit>
        <trans-unit id="8ea8892717935eea12390eaf98af13ff334785db" translate="yes" xml:space="preserve">
          <source>In summary then, any query with aggregate functions is implemented by two loops. The first loop scans the input table and computes aggregate information into buckets and the second loop scans through all the buckets to compute the final result.</source>
          <target state="translated">Таким образом,любой запрос с агрегатными функциями реализуется двумя циклами.Первый цикл сканирует входную таблицу и вычисляет агрегированную информацию в ведра,а второй цикл сканирует все ведра,чтобы вычислить конечный результат.</target>
        </trans-unit>
        <trans-unit id="2fe8cccc0c3831ee16f379b0a96fc3ebe090262e" translate="yes" xml:space="preserve">
          <source>In summary, the claim of this essay is that using SQLite as a container for an application file format like OpenDocument and storing lots of smaller objects in that container works out much better than using a ZIP archive holding a few larger objects. To wit:</source>
          <target state="translated">Подводя итог,можно сказать,что использование SQLite в качестве контейнера для файла приложения в формате типа OpenDocument и хранение в этом контейнере множества более мелких объектов получается гораздо лучше,чем использование ZIP-архива,содержащего несколько более крупных объектов.В частности:</target>
        </trans-unit>
        <trans-unit id="14368b74fc6cabbc46f6b11af62f68ec319ac0f1" translate="yes" xml:space="preserve">
          <source>In support of the &lt;a href=&quot;testing#mcdc&quot;&gt;100% MC/DC testing&lt;/a&gt; goal for SQLite, the parser code generated by Lemon has no unreachable branches, and contains extra (compile-time selected) instrumentation useful for measuring test coverage.</source>
          <target state="translated">В поддержку цели &lt;a href=&quot;testing#mcdc&quot;&gt;100% тестирования MC / DC&lt;/a&gt; для SQLite, код парсера, сгенерированный Lemon, не имеет недостижимых ветвей и содержит дополнительные (выбранные во время компиляции) инструменты, полезные для измерения покрытия тестами.</target>
        </trans-unit>
        <trans-unit id="aad3b77ed5e3adba0d4656a1d99071301ddd4bc1" translate="yes" xml:space="preserve">
          <source>In the &quot;fossil delta&quot; format - the format used for blob deltas by the &lt;a href=&quot;http://fossil-scm.org&quot;&gt;Fossil source-code management system&lt;/a&gt;, or</source>
          <target state="translated">В формате &amp;laquo;fossil delta&amp;raquo; - формат, используемый для дельт blob системой управления &lt;a href=&quot;http://fossil-scm.org&quot;&gt;исходным кодом Fossil&lt;/a&gt; , или</target>
        </trans-unit>
        <trans-unit id="30519768573ed5dd959ec460751bfce418bf4435" translate="yes" xml:space="preserve">
          <source>In the &quot;without ANALYZE&quot; case on the left, the NN algorithm chooses loop P (PLINK) as the outer loop because 4.9 is less than 5.2, resulting in path P-T which is algorithm-1. NN only looks at the single best choice at each step so it completely misses the fact that 5.2+4.4 makes a slightly cheaper plan than 4.9+4.8. But the N3 algorithm keeps track of the 5 best paths for a 2-way join, so it ends up selecting path T-P because of its slightly lower overall cost. Path T-P is algorithm-2.</source>
          <target state="translated">В случае &quot;без АНАЛЫЗА&quot; слева алгоритм NN выбирает петлю P (PLINK)в качестве внешней петли,так как 4.9 меньше 5.2,в результате чего получается путь P-T,который является алгоритмом-1.NN смотрит только на единственный лучший выбор на каждом шаге,поэтому полностью пропускает тот факт,что 5.2+4.4 делает план чуть дешевле,чем 4.9+4.8.Но алгоритм N3 отслеживает 5 лучших путей для 2-х стороннего соединения,поэтому в итоге выбирает путь T-P из-за его немного меньшей общей стоимости.Путь T-P-это алгоритм-2.</target>
        </trans-unit>
        <trans-unit id="88edd036016e74b41ab30f363489bc8baf2ff243" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;carray&quot;&gt;CARRAY extension&lt;/a&gt;, the application needs to tell the extension the location of a C-language array that contains the data for the table-valued function that the extension implements.</source>
          <target state="translated">В &lt;a href=&quot;carray&quot;&gt;расширении CARRAY&lt;/a&gt; приложению необходимо сообщить расширению расположение массива на языке C, который содержит данные для возвращающей табличное значение функции, которую реализует расширение.</target>
        </trans-unit>
        <trans-unit id="0673453ee376202611f58f23515a709feb8d4034" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt;, enhance the &quot;.mode&quot; command so that it restores the default column and row separators for modes &quot;line&quot;, &quot;list&quot;, &quot;column&quot;, and &quot;tcl&quot;.</source>
          <target state="translated">В &lt;a href=&quot;cli&quot;&gt;оболочке командной строки&lt;/a&gt; улучшите команду &amp;laquo;.mode&amp;raquo;, чтобы она восстанавливала разделители столбцов и строк по умолчанию для режимов &amp;laquo;строка&amp;raquo;, &amp;laquo;список&amp;raquo;, &amp;laquo;столбец&amp;raquo; и &amp;laquo;tcl&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="c5b3d2f7e7ec64c2ea66a15e4b9de436ddc07a10" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt; extension, the &lt;a href=&quot;fts3#full_text_index_queries&quot;&gt;MATCH operator&lt;/a&gt; (which does the full-text search) needs to communicate details of matching entries to the &lt;a href=&quot;fts3#snippet&quot;&gt;snippet()&lt;/a&gt;, &lt;a href=&quot;fts3#offsets&quot;&gt;offsets()&lt;/a&gt;, and &lt;a href=&quot;fts3#matchinfo&quot;&gt;matchinfo()&lt;/a&gt; functions so that those functions can convert the details of the match into useful output.</source>
          <target state="translated">В &lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt; выдвижении, &lt;a href=&quot;fts3#full_text_index_queries&quot;&gt;оператор MATCH&lt;/a&gt; (который делает полнотекстовой поиск) необходимо сообщить информацию о записи соответствия для &lt;a href=&quot;fts3#snippet&quot;&gt;сниппета ()&lt;/a&gt; , &lt;a href=&quot;fts3#offsets&quot;&gt;зачеты ()&lt;/a&gt; , и &lt;a href=&quot;fts3#matchinfo&quot;&gt;MatchInfo ()&lt;/a&gt; функции , так что эти функции могут преобразовать детали матча в полезный результат.</target>
        </trans-unit>
        <trans-unit id="7f5a2150475db6cefe817c8c9175290580ea2ad7" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;json1&quot;&gt;JSON extension&lt;/a&gt;, fix the JSON validator so that it correctly rejects invalid backslash escapes within strings.</source>
          <target state="translated">В &lt;a href=&quot;json1&quot;&gt;расширении JSON&lt;/a&gt; исправьте валидатор JSON, чтобы он правильно отклонял недопустимые escape-символы обратной косой черты в строках.</target>
        </trans-unit>
        <trans-unit id="29cf2e016ded4e45037d7dd8bd42e21681c156af" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;rbu&quot;&gt;RBU extension&lt;/a&gt;, add extra sync operations to avoid the possibility of corruption following a power failure.</source>
          <target state="translated">В &lt;a href=&quot;rbu&quot;&gt;расширении RBU&lt;/a&gt; добавьте дополнительные операции синхронизации, чтобы избежать возможности повреждения после сбоя питания.</target>
        </trans-unit>
        <trans-unit id="11f2b4a17490be52b1b76c1ff6aa70a95cb65d46" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;rtree&quot;&gt;RTREE&lt;/a&gt; extension, when rounding 64-bit floating point numbers to 32-bit for storage, always round in a direction that causes the bounding box to get larger.</source>
          <target state="translated">В расширении &lt;a href=&quot;rtree&quot;&gt;RTREE&lt;/a&gt; при округлении 64-битных чисел с плавающей запятой до 32-битных для хранения всегда округляйте в направлении, при котором ограничивающая рамка увеличивается.</target>
        </trans-unit>
        <trans-unit id="240fef4158af161eb22e60a820c151dc84eafe1e" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;tclsqlite&quot;&gt;TCL Interface&lt;/a&gt;, add the -uri option to the &quot;sqlite3&quot; TCL command used for creating new database connection objects.</source>
          <target state="translated">В &lt;a href=&quot;tclsqlite&quot;&gt;интерфейсе TCL&lt;/a&gt; добавьте параметр -uri к команде TCL sqlite3, используемой для создания новых объектов подключения к базе данных.</target>
        </trans-unit>
        <trans-unit id="156e69c7f61ba1dcce1a1142af151766e801c151" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;tclsqlite&quot;&gt;TCL language interface&lt;/a&gt;, &quot;@variable&quot; instead of &quot;$variable&quot; always binds as a blob.</source>
          <target state="translated">В &lt;a href=&quot;tclsqlite&quot;&gt;интерфейсе языка TCL&lt;/a&gt; &amp;laquo;@variable&amp;raquo; вместо &amp;laquo;$ variable&amp;raquo; всегда привязывается как blob.</target>
        </trans-unit>
        <trans-unit id="7ed9b7e87f45e28428e0b4c11b7a622203b8e9d6" translate="yes" xml:space="preserve">
          <source>In the BLOB output, you can clearly see the NUL character as the 4th character in the 7-character string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3bfa67674bb524ce3387e6563f15051a77fe593" translate="yes" xml:space="preserve">
          <source>In the C programming language where &lt;b&gt;&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;&lt;/b&gt; and &lt;b&gt;&lt;code&gt;||&lt;/code&gt;&lt;/b&gt; are &quot;short-circuit&quot; operators, MC/DC and branch coverage are very nearly the same thing. The primary difference is in boolean vector tests. One can test for any of several bits in bit-vector and still obtain 100% branch test coverage even though the second element of MC/DC - the requirement that each condition in a decision take on every possible outcome - might not be satisfied.</source>
          <target state="translated">В языке программирования C где &lt;b&gt; &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; &lt;/b&gt; и &lt;b&gt; &lt;code&gt;||&lt;/code&gt; &lt;/b&gt; являются операторами &quot;короткого замыкания&quot;, MC / DC и покрытие филиалов - это почти одно и то же. Основное отличие заключается в тестах логических векторов. Можно протестировать любой из нескольких битов в битовом векторе и при этом получить 100% тестовое покрытие ветвления, даже если второй элемент MC / DC - требование, чтобы каждое условие в решении принимало все возможные результаты, - может не выполняться.</target>
        </trans-unit>
        <trans-unit id="a49a291dae627f989ba703462ee2c7e1bcc8b060" translate="yes" xml:space="preserve">
          <source>In the C programming language, it is very easy to write code that has &quot;undefined&quot; or &quot;implementation defined&quot; behavior. That means that the code might work during development, but then give a different answer on a different system, or when recompiled using different compiler options. Examples of undefined and implementation-defined behavior in ANSI C include:</source>
          <target state="translated">В языке программирования Си очень легко написать код,имеющий поведение &quot;неопределенное&quot; или &quot;реализация определена&quot;.Это означает,что код может работать в процессе разработки,но затем дать другой ответ на другой системе,или при перекомпиляции с использованием разных опций компилятора.Примеры неопределенного и реализованно-определенного поведения в ANSI C включают в себя:</target>
        </trans-unit>
        <trans-unit id="c817a7331349197e219cdd351370db507b5f89c0" translate="yes" xml:space="preserve">
          <source>In the COPY command, backslash can now be used to escape a newline.</source>
          <target state="translated">В команде COPY обратный слеш теперь может быть использован для выхода из новой строки.</target>
        </trans-unit>
        <trans-unit id="cb9f3cc234a2699a8be8b939bc81e4cd1e3c8028" translate="yes" xml:space="preserve">
          <source>In the Fossil full-text search system, documents that participate in the full-text search (wiki pages, tickets, check-ins, documentation files, etc) are tracked by a table called &quot;ftsdocs&quot; (&lt;u&gt;f&lt;/u&gt;ull &lt;u&gt;t&lt;/u&gt;ext &lt;u&gt;s&lt;/u&gt;earch &lt;u&gt;doc&lt;/u&gt;ument&lt;u&gt;s&lt;/u&gt;). As new documents are added to the repository, they are not indexed right away. Indexing is deferred until there is a search request. The ftsdocs table contains an &quot;idxed&quot; field which is true if the document has been indexed and false if not.</source>
          <target state="translated">В системе полнотекстового поиска Fossil документы, которые участвуют в полнотекстовом поиске (вики-страницы, билеты, чекины, файлы документации и т. Д.), Отслеживаются таблицей под названием &quot;ftsdocs&quot; ( &lt;u&gt;f&lt;/u&gt; ull &lt;u&gt;t&lt;/u&gt; ext &lt;u&gt;s&lt;/u&gt; earch &lt;u&gt;doc&lt;/u&gt; ument &lt;u&gt;s&lt;/u&gt; ). При добавлении новых документов в репозиторий они не индексируются сразу. Индексирование откладывается до тех пор, пока не поступит поисковый запрос. Таблица ftsdocs содержит поле idxed, которое истинно, если документ был проиндексирован, и false, если нет.</target>
        </trans-unit>
        <trans-unit id="54570b346f4d608f2bbac12e4181cf27370c513d" translate="yes" xml:space="preserve">
          <source>In the SQL statement text input to &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; and its variants, literals may be replaced by a &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameter&lt;/a&gt; that matches one of following templates:</source>
          <target state="translated">При вводе текста оператора SQL в &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; и его варианты литералы могут быть заменены &lt;a href=&quot;lang_expr#varparam&quot;&gt;параметром,&lt;/a&gt; который соответствует одному из следующих шаблонов:</target>
        </trans-unit>
        <trans-unit id="2d198fd96a87b68a84840a27e15d7192fd58115f" translate="yes" xml:space="preserve">
          <source>In the SQL statement text input to &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; and its variants, literals may be replaced by a &lt;a href=&quot;../lang_expr#varparam&quot;&gt;parameter&lt;/a&gt; that matches one of following templates:</source>
          <target state="translated">При вводе текста оператора SQL в &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; и его варианты литералы могут быть заменены &lt;a href=&quot;../lang_expr#varparam&quot;&gt;параметром,&lt;/a&gt; который соответствует одному из следующих шаблонов:</target>
        </trans-unit>
        <trans-unit id="0bfef1786d8548ec0f82e3f4f67466b9d9c84839" translate="yes" xml:space="preserve">
          <source>In the TCL test harness, the crash simulation is done in a separate process. The main testing process spawns a child process which runs some SQLite operation and randomly crashes somewhere in the middle of a write operation. A special &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; randomly reorders and corrupts the unsynchronized write operations to simulate the effect of buffered filesystems. After the child dies, the original test process opens and reads the test database and verifies that the changes attempted by the child either completed successfully or else were completely rolled back. The &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;integrity_check&lt;/a&gt;&lt;a href=&quot;pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt; is used to make sure no database corruption occurs.</source>
          <target state="translated">В тестовой программе TCL моделирование сбоя выполняется в отдельном процессе. Основной процесс тестирования порождает дочерний процесс, который запускает некоторую операцию SQLite и случайным образом дает сбой где-то в середине операции записи. Специальная &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; случайным образом переупорядочивает и искажает несинхронизированные операции записи, чтобы имитировать эффект буферизованных файловых систем. После смерти ребенка открывается исходный процесс тестирования, который считывает тестовую базу данных и проверяет, что изменения, предпринятые дочерним элементом, были выполнены успешно или были полностью отменены. &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;Integrity_check &lt;/a&gt;&lt;a href=&quot;pragma#syntax&quot;&gt;ПРАГМА&lt;/a&gt; используется , чтобы убедиться , не происходит повреждения базы данных.</target>
        </trans-unit>
        <trans-unit id="2e83d8a255a88980125401cd881c484a48bd6dc6" translate="yes" xml:space="preserve">
          <source>In the TPC-H Q8 query, the setup costs are all negligible, all dependencies are between individual nodes, and there is no ORDER BY, GROUP BY, or DISTINCT clause. So for TPC-H Q8, the graph above is a reasonable representation of what needs to be computed. The general case involves a lot of extra complication, which for clarity is neglected in the remainder of this article.</source>
          <target state="translated">В запросе TPC-H Q8 все затраты на настройку ничтожно малы,все зависимости находятся между отдельными узлами,и нет пункта ORDER BY,GROUP BY или DISTINCT.Поэтому для TPC-H Q8 вышеприведенный график является разумным представлением того,что должно быть вычислено.Общий случай связан с множеством дополнительных осложнений,которые для ясности пренебрегаются в оставшейся части статьи.</target>
        </trans-unit>
        <trans-unit id="9f3539e13c22fa6c6ec2b58a1ccd7e90a2d77370" translate="yes" xml:space="preserve">
          <source>In the WHERE clause of a &lt;a href=&quot;partialindex&quot;&gt;partial index&lt;/a&gt;.</source>
          <target state="translated">В предложении WHERE &lt;a href=&quot;partialindex&quot;&gt;частичного индекса&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2ff78c844bf874e8944245ab0f90e378a482a538" translate="yes" xml:space="preserve">
          <source>In the WHERE clause of a partial index.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6311a2e6a2d0640df13bf33c58d5ba4044c66ce" translate="yes" xml:space="preserve">
          <source>In the Windows OS driver, reacquire a SHARED lock if an attempt to acquire an EXCLUSIVE lock fails. Ticket #2354</source>
          <target state="translated">В драйвере ОС Windows снова запросите блокировку SHARED,если попытка получить блокировку EXCLUSIVE не удалась.Билет № 2354</target>
        </trans-unit>
        <trans-unit id="c812acc1f415592dcfc5eeb302d23caa6a39526f" translate="yes" xml:space="preserve">
          <source>In the above paragraph, the term &quot;equal&quot; means equal when values are compared using the rules &lt;a href=&quot;datatype3#comparisons&quot;&gt;specified here&lt;/a&gt;. The following clarifications apply:</source>
          <target state="translated">В вышеприведенном абзаце термин &amp;laquo;равно&amp;raquo; означает равенство, когда значения сравниваются с использованием &lt;a href=&quot;datatype3#comparisons&quot;&gt;указанных здесь&lt;/a&gt; правил . Применяются следующие пояснения:</target>
        </trans-unit>
        <trans-unit id="94f9ba60d2631df2a644921fed4cce7a6456d2d7" translate="yes" xml:space="preserve">
          <source>In the above,</source>
          <target state="translated">В вышеизложенном,</target>
        </trans-unit>
        <trans-unit id="441e596237bc1ae031cea29bc5e12b44c88ed81c" translate="yes" xml:space="preserve">
          <source>In the above, &amp;lt;content&amp;gt; is replaced by the name of the content table. By default, &amp;lt;content_rowid&amp;gt; is replaced by the literal text &quot;rowid&quot;. Or, if the &quot;content_rowid&quot; option is set within the CREATE VIRTUAL TABLE statement, by the value of that option. &amp;lt;cols&amp;gt; is replaced by a comma-separated list of the FTS5 table column names. For example:</source>
          <target state="translated">В приведенном выше примере &amp;lt;content&amp;gt; заменяется именем таблицы содержимого. По умолчанию &amp;lt;content_rowid&amp;gt; заменяется буквальным текстом &amp;laquo;rowid&amp;raquo;. Или, если параметр content_rowid установлен в операторе CREATE VIRTUAL TABLE, по значению этой опции. &amp;lt;cols&amp;gt; заменяется списком разделенных запятыми имен столбцов таблицы FTS5. Например:</target>
        </trans-unit>
        <trans-unit id="a2464dd3bf1c506de33685f476dfeec6d3c9f83a" translate="yes" xml:space="preserve">
          <source>In the above, the user creates the database schema (a single table - &quot;x1&quot;), and then uses the &quot;.expert&quot; command to analyze a query, in this case &quot;SELECT * FROM x1 WHERE a=? AND b&amp;gt;?&quot;. The shell tool recommends that the user create a new index (index &quot;x1_idx_000123a7&quot;) and outputs the plan that the query would use in &lt;a href=&quot;eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; format. The user then creates an index with an equivalent schema and runs the analysis on the same query again. This time the shell tool does not recommend any new indexes, and outputs the plan that SQLite will use for the query given the existing indexes.</source>
          <target state="translated">В приведенном выше примере пользователь создает схему базы данных (одна таблица - &amp;laquo;x1&amp;raquo;), а затем использует команду &amp;laquo;.expert&amp;raquo; для анализа запроса, в данном случае &amp;laquo;SELECT * FROM x1 WHERE a =? AND b&amp;gt;? &quot;. Инструмент оболочки рекомендует пользователю создать новый индекс (индекс &amp;laquo;x1_idx_000123a7&amp;raquo;) и вывести план, который будет использовать запрос, в формате &lt;a href=&quot;eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; . Затем пользователь создает индекс с эквивалентной схемой и снова запускает анализ того же запроса. На этот раз инструмент оболочки не рекомендует никаких новых индексов и выводит план, который SQLite будет использовать для запроса с учетом существующих индексов.</target>
        </trans-unit>
        <trans-unit id="c0edb5d51a3281366e0040cd06804f7b08ee3eaa" translate="yes" xml:space="preserve">
          <source>In the argments to &quot;rtree&quot; in the CREATE VIRTUAL TABLE statement, the names of the columns are taken from the first token of each argument. All subsequent tokens within each argument are silently ignored. This means, for example, that if you try to give a column a &lt;a href=&quot;datatype3#affinity&quot;&gt;type affinity&lt;/a&gt; or add a constraint such as UNIQUE or NOT NULL or DEFAULT to a column, those extra tokens are accepted as valid, but they do not change the behavior of the rtree. In an RTREE virtual table, the first column always has a &lt;a href=&quot;datatype3#affinity&quot;&gt;type affinity&lt;/a&gt; of INTEGER and all other data columns have a &lt;a href=&quot;datatype3#affinity&quot;&gt;type affinity&lt;/a&gt; of NUMERIC.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94df2ec8cdab4e4a1c3463eb8499a5bac9b92ebf" translate="yes" xml:space="preserve">
          <source>In the call above, pBuf is a pointer to a large, contiguous chunk of memory space that SQLite will use to satisfy all of its memory allocation needs. pBuf might point to a static array or it might be memory obtained from some other application-specific mechanism. szBuf is an integer that is the number of bytes of memory space pointed to by pBuf. mnReq is another integer that is the minimum size of an allocation. Any call to &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc(N)&lt;/a&gt; where N is less than mnReq will be rounded up to mnReq. mnReq must be a power of two. We shall see later that the mnReq parameter is important in reducing the value of &lt;b&gt;n&lt;/b&gt; and hence the minimum memory size requirement in the &lt;a href=&quot;malloc#nofrag&quot;&gt;Robson proof&lt;/a&gt;.</source>
          <target state="translated">В приведенном выше вызове pBuf - это указатель на большой непрерывный кусок пространства памяти, который SQLite будет использовать для удовлетворения всех своих потребностей в распределении памяти. pBuf может указывать на статический массив или это может быть память, полученная из какого-либо другого механизма, специфичного для приложения. szBuf - это целое число, которое представляет собой количество байтов пространства памяти, на которое указывает pBuf. mnReq - еще одно целое число, которое представляет собой минимальный размер выделения. Любой вызов &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc (N),&lt;/a&gt; где N меньше mnReq, будет округлен до mnReq. mnReq должно быть степенью двойки. Позже мы увидим, что параметр mnReq важен для уменьшения значения &lt;b&gt;n&lt;/b&gt; и, следовательно, минимального требования к размеру памяти в &lt;a href=&quot;malloc#nofrag&quot;&gt;доказательстве Робсона&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="90165ee71034491a4c0d9359bc73082f9488de28" translate="yes" xml:space="preserve">
          <source>In the call above, pMem is a pointer to an &lt;a href=&quot;c3ref/mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt; object that defines the interface to the application-specific memory allocator. The &lt;a href=&quot;c3ref/mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt; object is really just a structure containing pointers to functions to implement the various memory allocation primitives.</source>
          <target state="translated">В приведенном выше вызове pMem - это указатель на объект &lt;a href=&quot;c3ref/mem_methods&quot;&gt;sqlite3_mem_methods,&lt;/a&gt; который определяет интерфейс к распределителю памяти для конкретного приложения. Объект &lt;a href=&quot;c3ref/mem_methods&quot;&gt;sqlite3_mem_methods на&lt;/a&gt; самом деле представляет собой просто структуру, содержащую указатели на функции для реализации различных примитивов распределения памяти.</target>
        </trans-unit>
        <trans-unit id="c159dc37c192a0696adfe0ed4e91dc6c74c10ae1" translate="yes" xml:space="preserve">
          <source>In the call sqlite3_vtab_config(D,C,...) the D parameter is the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; in which the virtual table is being created and which is passed in as the first argument to the &lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; or &lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; method that is invoking sqlite3_vtab_config(). The C parameter is one of the &lt;a href=&quot;#SQLITE_VTAB_CONSTRAINT_SUPPORT&quot;&gt;virtual table configuration options&lt;/a&gt;. The presence and meaning of parameters after C depend on which &lt;a href=&quot;#SQLITE_VTAB_CONSTRAINT_SUPPORT&quot;&gt;virtual table configuration option&lt;/a&gt; is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b10e05d68bb770ad4b44c8424ff81a8fc9e69978" translate="yes" xml:space="preserve">
          <source>In the call sqlite3_vtab_config(D,C,...) the D parameter is the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; in which the virtual table is being created and which is passed in as the first argument to the &lt;a href=&quot;../vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; or &lt;a href=&quot;../vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; method that is invoking sqlite3_vtab_config(). The C parameter is one of the &lt;a href=&quot;c_vtab_constraint_support&quot;&gt;virtual table configuration options&lt;/a&gt;. The presence and meaning of parameters after C depend on which &lt;a href=&quot;c_vtab_constraint_support&quot;&gt;virtual table configuration option&lt;/a&gt; is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="890332a4e5fd5b1fbcf7ece72dd3f24eeb42de4e" translate="yes" xml:space="preserve">
          <source>In the case of &lt;a href=&quot;expridx&quot;&gt;indexes on expressions&lt;/a&gt;, whenever the word &quot;column&quot; is used in the foregoing text, one can substitute &quot;indexed expression&quot; (meaning a copy of the expression that appears in the &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt; statement) and everything will work the same.</source>
          <target state="translated">В случае &lt;a href=&quot;expridx&quot;&gt;индексов в выражениях&lt;/a&gt; , всякий раз, когда в предыдущем тексте используется слово &amp;laquo;столбец&amp;raquo;, можно заменить &amp;laquo;индексированное выражение&amp;raquo; (что означает копию выражения, которое появляется в операторе &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt; ), и все будет работать так же.</target>
        </trans-unit>
        <trans-unit id="d6023ff2ef6625bf825c5177040f5f9d0c7e6eaa" translate="yes" xml:space="preserve">
          <source>In the case of sqlite3changeset_start_strm(), the xInput callback may be invoked by the sessions module at any point during the lifetime of the iterator. If such an xInput callback returns an error, the iterator enters an error state, whereby all subsequent calls to iterator functions immediately fail with the same error code as returned by xInput.</source>
          <target state="translated">В случае функции sqlite3changeset_start_strm()модуль сеансов может вызывать обратный вызов xInput в любой момент времени жизни итератора.Если такой обратный вызов xInput возвращает ошибку,то итератор входит в состояние ошибки,при котором все последующие вызовы итератора сразу же заканчиваются неудачей с тем же самым кодом ошибки,который возвращает xInput.</target>
        </trans-unit>
        <trans-unit id="2c842ccec3d83bffac0868a71bae98e55882c42d" translate="yes" xml:space="preserve">
          <source>In the cases above, the values returned by the function affects the information stored in the database file. The values of functions in CHECK constraints determines which entries are valid for a table, and functions in the WHERE clause of a partial index or in an index on an expression compute values stored in the index b-tree. If any of these functions later returns a different value, then the database might no longer be well-formed. Hence, to avoid database corruption, only deterministic functions can be used in the contexts above.</source>
          <target state="translated">В вышеперечисленных случаях возвращаемые функцией значения влияют на информацию,хранящуюся в файле базы данных.Значения функций в ограничениях CHECK определяют,какие записи действительны для таблицы,а функции в пункте WHERE частичного индекса или в индексе на выражении вычисляют значения,хранящиеся в b-дереве индекса.Если какая-либо из этих функций в дальнейшем вернет другое значение,то БД может оказаться плохо сформированной.Следовательно,чтобы избежать повреждения базы данных,в вышеприведённых контекстах можно использовать только детерминистические функции.</target>
        </trans-unit>
        <trans-unit id="212f1ca207fd318cb7601421ea08bad1d38b37aa" translate="yes" xml:space="preserve">
          <source>In the command-line shell, use popen() instead of fopen() if the first character of the argument to the &quot;.output&quot; command is &quot;|&quot;.</source>
          <target state="translated">В оболочке командной строки используйте popen()вместо fopen(),если первым символом аргумента в команде &quot;.output&quot; является &quot;|&quot;.</target>
        </trans-unit>
        <trans-unit id="bd2d277ff0771ee506fb5065fe7a06ad8e377ea0" translate="yes" xml:space="preserve">
          <source>In the current implementation of SQLite, the SQL parser only works with UTF-8 text. So if you supply UTF-16 text it will be converted. This is just an implementation issue and there is nothing to prevent future versions of SQLite from parsing UTF-16 encoded SQL natively.</source>
          <target state="translated">В текущей реализации SQLite парсер SQL работает только с UTF-8 текстом.Поэтому при поставке текста в кодировке UTF-16 он будет конвертирован.Это просто проблема реализации и ничто не мешает будущим версиям SQLite самостоятельно разобрать SQL в кодировке UTF-16.</target>
        </trans-unit>
        <trans-unit id="2904f602a19479b220a87ade171425cb57484f61" translate="yes" xml:space="preserve">
          <source>In the current implementation, a table is analyzed if and only if all of the following are true:</source>
          <target state="translated">В текущей реализации таблица анализируется,если и только если все нижеследующее верно:</target>
        </trans-unit>
        <trans-unit id="f2454c76bf66b1405ea30b83fd1ca60a2a98f0ef" translate="yes" xml:space="preserve">
          <source>In the current implementation, the update hook is not invoked when conflicting rows are deleted because of an &lt;a href=&quot;../lang_conflict&quot;&gt;ON CONFLICT REPLACE&lt;/a&gt; clause. Nor is the update hook invoked when rows are deleted using the &lt;a href=&quot;../lang_delete#truncateopt&quot;&gt;truncate optimization&lt;/a&gt;. The exceptions defined in this paragraph might change in a future release of SQLite.</source>
          <target state="translated">В текущей реализации ловушка обновления не вызывается при удалении конфликтующих строк из-за предложения &lt;a href=&quot;../lang_conflict&quot;&gt;ON CONFLICT REPLACE&lt;/a&gt; . Также не вызывается ловушка обновления, когда строки удаляются с использованием &lt;a href=&quot;../lang_delete#truncateopt&quot;&gt;оптимизации усечения&lt;/a&gt; . Исключения, определенные в этом абзаце, могут измениться в будущих версиях SQLite.</target>
        </trans-unit>
        <trans-unit id="fb481751cd63e35f2d57a7f24a37356fd4bf25b0" translate="yes" xml:space="preserve">
          <source>In the current implementation, the update hook is not invoked when conflicting rows are deleted because of an &lt;a href=&quot;lang_conflict&quot;&gt;ON CONFLICT REPLACE&lt;/a&gt; clause. Nor is the update hook invoked when rows are deleted using the &lt;a href=&quot;lang_delete#truncateopt&quot;&gt;truncate optimization&lt;/a&gt;. The exceptions defined in this paragraph might change in a future release of SQLite.</source>
          <target state="translated">В текущей реализации ловушка обновления не вызывается при удалении конфликтующих строк из-за предложения &lt;a href=&quot;lang_conflict&quot;&gt;ON CONFLICT REPLACE&lt;/a&gt; . Также не вызывается ловушка обновления, когда строки удаляются с использованием &lt;a href=&quot;lang_delete#truncateopt&quot;&gt;оптимизации усечения&lt;/a&gt; . Исключения, определенные в этом абзаце, могут измениться в будущих версиях SQLite.</target>
        </trans-unit>
        <trans-unit id="6c3c5dcd56d182703694f79901fe613441a9864b" translate="yes" xml:space="preserve">
          <source>In the current row, the number of times the phrase appears in the column.</source>
          <target state="translated">В текущей строке количество раз,когда фраза появляется в столбце.</target>
        </trans-unit>
        <trans-unit id="cee9466acdd5b62aa76761a9bf112fbd7910b30a" translate="yes" xml:space="preserve">
          <source>In the definitions of generated columns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3116d32ea608324199d5e0469ef8b030b799865" translate="yes" xml:space="preserve">
          <source>In the diagram at the right, we show that the information that was held in user space is cleared when the lock is released. This used to be literally true for older versions of SQLite. But more recent versions of SQLite keep the user space information in memory in case it might be needed again at the start of the next transaction. It is cheaper to reuse information that is already in local memory than to transfer the information back from the operating system disk cache or to read it off of the disk drive again. Prior to reusing the information in user space, we must first reacquire the shared lock and then we have to check to make sure that no other process modified the database file while we were not holding a lock. There is a counter in the first page of the database that is incremented every time the database file is modified. We can find out if another process has modified the database by checking that counter. If the database was modified, then the user space cache must be cleared and reread. But it is commonly the case that no changes have been made and the user space cache can be reused for a significant performance savings.</source>
          <target state="translated">На диаграмме справа мы показываем,что информация,которая хранилась в пользовательском пространстве,очищается,когда замок освобождается.Раньше это было буквально так для старых версий SQLite.Но в более поздних версиях SQLite информация о пользовательском пространстве хранится в памяти на тот случай,если она может понадобиться снова при запуске следующей транзакции.Дешевле повторно использовать информацию,уже находящуюся в локальной памяти,чем переносить ее обратно из дискового кэша операционной системы или снова считывать с диска.Прежде чем повторно использовать информацию в пользовательском пространстве,мы должны сначала запросить общую блокировку,а затем проверить,чтобы убедиться,что никакой другой процесс не изменил файл базы данных в то время,когда у нас не было блокировки.На первой странице базы данных есть счетчик,который инкрементируется каждый раз,когда файл базы данных изменяется.Мы можем узнать,изменил ли другой процесс базу данных,проверив этот счетчик.Если база данных была изменена,то кэш пользовательского пространства должен быть очищен и перечитан.Но обычно так и бывает,что никаких изменений не было сделано,и кэш пользовательского пространства может быть использован повторно для значительной экономии производительности.</target>
        </trans-unit>
        <trans-unit id="bc4afe67e993812e607ae27c7ab087c30151c22e" translate="yes" xml:space="preserve">
          <source>In the diagram, each of the 8 tables in the FROM clause of the query is identified by a large circle with the label of the FROM-clause term: N2, S, L, P, O, C, N1 and R. The arcs in the graph represent the estimated cost of computing each term assuming that the origin of the arc is in an outer loop. For example, the cost of running the S loop as an inner loop to L is 2.30 whereas the cost of running the S loop as an outer loop to L is 9.17.</source>
          <target state="translated">На диаграмме каждая из 8 таблиц в выражении FROM запроса идентифицируется большим кружком с пометкой термина FROM-clause:N2,S,L,P,O,C,N1 и R.Дуги на графике представляют собой расчетную стоимость вычисления каждого члена в предположении,что начало дуги находится во внешней петле.Например,стоимость прогона петли S как внутренней петли на L равна 2,30,в то время как стоимость прогона петли S как внешней петли на L равна 9,17.</target>
        </trans-unit>
        <trans-unit id="395caf8810d6babac050840aec487ecca9bbc4bd" translate="yes" xml:space="preserve">
          <source>In the event of an operating system or power failure, the various combinations of file-system software and storage hardware available provide varying levels of guarantee as to the integrity of the data written to the file system just before or during the failure. The exact combination of IO operations that SQLite is required to perform in order to safely modify a database file depend on the exact characteristics of the target platform.</source>
          <target state="translated">В случае сбоя операционной системы или электропитания,различные комбинации доступного программного обеспечения файловой системы и аппаратного обеспечения хранения обеспечивают различные уровни гарантии целостности данных,записанных в файловую систему непосредственно перед или во время сбоя.Точная комбинация операций ввода-вывода,которую SQLite должен выполнить для того,чтобы безопасно модифицировать файл базы данных,зависит от точных характеристик целевой платформы.</target>
        </trans-unit>
        <trans-unit id="fbf76308006177e994e0ad525f9e6c338bce580b" translate="yes" xml:space="preserve">
          <source>In the example above, all the rows for each partition are grouped together in the final output. This is because the PARTITION BY clause is a prefix of the ORDER BY clause on the overall query. But that does not have to be the case. A partition can be composed of rows scattered about haphazardly within the result set. For example:</source>
          <target state="translated">В приведенном выше примере все строки для каждого раздела сгруппированы вместе в итоговом выводе.Это происходит потому,что пункт PARTITION BY является префиксом пункта ORDER BY в общем запросе.Но это не обязательно должно быть так.Раздел может состоять из строк,разбросанных беспорядочно в пределах результирующего множества.Например:</target>
        </trans-unit>
        <trans-unit id="5cf1e8a43e9d63b712df3d7090fc5c9414ccb7c0" translate="yes" xml:space="preserve">
          <source>In the example above, each triple identifies the location of a token instance by rowid, column number (columns are numbered sequentially starting at 0 from left to right) and position within the column value (the first token in a column value is 0, the second is 1, and so on). Using this index, FTS5 is able to provide timely answers to queries such as &quot;the set of all documents that contain the token 'A'&quot;, or &quot;the set of all documents that contain the sequence 'Y Z'&quot;. The list of instances associated with a single token is called an &quot;instance-list&quot;.</source>
          <target state="translated">В приведенном выше примере каждая тройка определяет местоположение экземпляра токена по rowid,номеру столбца (столбцы нумеруются последовательно,начиная с 0 слева направо)и позиции внутри значения столбца (первая токен в значении столбца-0,вторая-1 и т.д.).Используя этот индекс,FTS5 способен давать своевременные ответы на запросы,такие как &quot;набор всех документов,содержащих маркер 'A'&quot;,или &quot;набор всех документов,содержащих последовательность 'Y Z'&quot;.Список экземпляров,связанных с одним токеном,называется &quot;instance-list&quot;.</target>
        </trans-unit>
        <trans-unit id="6670429b3f62749505c4b98851abdba99076dc7b" translate="yes" xml:space="preserve">
          <source>In the example above, if most purchase orders do not have a &quot;parent&quot; purchase order, then most parent_po values will be NULL. That means only a small subset of the rows in the purchaseorder table will be indexed. Hence the index will take up much less space. And changes to the original purchaseorder table will run faster since the po_parent index only needs to be updated for those exceptional rows where parent_po is not NULL. But the index is still useful for querying. In particular, if one wants to know all &quot;children&quot; of a particular purchase order &quot;?1&quot;, the query would be:</source>
          <target state="translated">В приведенном выше примере,если большинство ордеров на покупку не имеют &quot;родительского&quot; ордера на покупку,то большинство значений параметра parent_po будет иметь значение NULL.Это означает,что будет проиндексировано только небольшое подмножество строк в таблице ордеров на покупку.Следовательно,индекс займет намного меньше места.А изменения в исходной таблице заказов на покупку будут выполняться быстрее,так как индекс po_parent нужно обновлять только для тех исключительных строк,где parent_po не NULL.Но индекс все равно полезен для запросов.В частности,если нужно знать все &quot;дочерние элементы&quot; конкретного заказа на покупку &quot;?1&quot;,то запрос будет:</target>
        </trans-unit>
        <trans-unit id="093d39a0dc19bc985afaed609f6ca65b1771f970" translate="yes" xml:space="preserve">
          <source>In the example above, the &quot;.header on&quot; line causes column labels to be printed as the first row of output. This means that the first row of the resulting CSV file will contain column labels. If column labels are not desired, set &quot;.header off&quot; instead. (The &quot;.header off&quot; setting is the default and can be omitted if the headers have not been previously turned on.)</source>
          <target state="translated">В приведенном выше примере,строка &quot;.header on&quot; (заголовок включен)вызывает печать меток столбцов как первой строки вывода.Это означает,что первая строка результирующего CSV-файла будет содержать метки столбцов.Если метки столбцов не нужны,установите &quot;.header off&quot; вместо этого.(Настройка &quot;.header off&quot; (Выключение заголовков)является настройкой по умолчанию и может быть опущена,если заголовки ранее не были включены).</target>
        </trans-unit>
        <trans-unit id="19c364b4c4bd5bb78a54b1baeb3476ed5a370176" translate="yes" xml:space="preserve">
          <source>In the example above, the &quot;.headers on&quot; line causes column labels to be printed as the first row of output. This means that the first row of the resulting CSV file will contain column labels. If column labels are not desired, set &quot;.headers off&quot; instead. (The &quot;.headers off&quot; setting is the default and can be omitted if the headers have not been previously turned on.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10cd93c52fe5f9cca786dee67c9404fab91f9de8" translate="yes" xml:space="preserve">
          <source>In the example above, the window frame consists of all rows between the previous row (&quot;1 PRECEDING&quot;) and the following row (&quot;1 FOLLOWING&quot;), inclusive, where rows are sorted according to the ORDER BY clause in the window-defn (in this case &quot;ORDER BY a&quot;). For example, the frame for the row with (a=3) consists of rows (2, 'B', 'two'), (3, 'C', 'three') and (4, 'D', 'one'). The result of group_concat(b, '.') for that row is therefore 'B.C.D'.</source>
          <target state="translated">В приведенном выше примере рамка окна состоит из всех строк между предыдущей строкой (&quot;1 ПОКАЗАТЕЛЬСТВО&quot;)и следующей строкой (&quot;1 ПОКАЗАТЕЛЬСТВО&quot;),включительно,где строки отсортированы в соответствии с пунктом &quot;ЗАКАЗАТЕЛЬСТВО ПО&quot; в окне-дефне (в данном случае &quot;ЗАКАЗАТЕЛЬСТВО ПО а&quot;).Например,рамка для строки с (a=3)состоит из строк (2,'B','два'),(3,'C','три')и (4,'D','один').Результат group_concat(b,'.')для этой строки,таким образом,является 'B.C.D'.</target>
        </trans-unit>
        <trans-unit id="b3d6a23d97e4594c0776e73b100f4f0f95f7c245" translate="yes" xml:space="preserve">
          <source>In the example queries above, every row of the table being queried must be loaded off of the disk and examined, even if only a small percentage of the rows end up in the result. This can take a long time on a big table. To speed things up, SQLite can use an index.</source>
          <target state="translated">В приведенных выше примерах запросов каждая строка опрашиваемой таблицы должна быть загружена с диска и рассмотрена,даже если в результате будет получен лишь небольшой процент строк.Это может занять много времени на большой таблице.Для ускорения работы SQLite может использовать индекс.</target>
        </trans-unit>
        <trans-unit id="097fb65fd13aa3cb8c9440796ac79504d1b2d367" translate="yes" xml:space="preserve">
          <source>In the example, instead of a single sort of 7 elements, there are 5 sorts of one-element each and 1 sort of 2 elements for the case of fruit=='Orange'.</source>
          <target state="translated">В примере,вместо одного вида из 7 элементов,есть 5 видов по одному элементу и 1 вид из 2 элементов для случая фрукта==&quot;Оранжевый&quot;.</target>
        </trans-unit>
        <trans-unit id="28b65ff31e772aaf95fd7eecfcefa7c33d5a2c49" translate="yes" xml:space="preserve">
          <source>In the example, the values in the &quot;term&quot; column are all lower case, even though they were inserted into table &quot;ft&quot; in mixed case. This is because an fts4aux table contains the terms as extracted from the document text by the &lt;a href=&quot;fts3#tokenizer&quot;&gt;tokenizer&lt;/a&gt;. In this case, since table &quot;ft&quot; uses the &lt;a href=&quot;fts3#tokenizer&quot;&gt;simple tokenizer&lt;/a&gt;, this means all terms have been folded to lower case. Also, there is (for example) no row with column &quot;term&quot; set to &quot;apple&quot; and column &quot;col&quot; set to 1. Since there are no instances of the term &quot;apple&quot; in column 1, no row is present in the fts4aux table.</source>
          <target state="translated">В этом примере значения в столбце &amp;laquo;term&amp;raquo; все в нижнем регистре, даже если они были вставлены в таблицу &amp;laquo;ft&amp;raquo; в смешанном регистре. Это связано с тем, что таблица fts4aux содержит термины, извлеченные из текста документа &lt;a href=&quot;fts3#tokenizer&quot;&gt;токенизатором&lt;/a&gt; . В этом случае, поскольку в таблице ft используется &lt;a href=&quot;fts3#tokenizer&quot;&gt;простой токенизатор&lt;/a&gt; , это означает, что все термины были свернуты в нижний регистр. Кроме того, (например) нет строки со столбцом &quot;term&quot;, установленным на &quot;яблоко&quot;, и столбцом &quot;col&quot;, установленным на 1. Поскольку в столбце 1 нет экземпляров термина &quot;apple&quot;, в столбце нет строки. таблица fts4aux.</target>
        </trans-unit>
        <trans-unit id="4d08492de7be0204d6bca6b75942d78b6a5e659c" translate="yes" xml:space="preserve">
          <source>In the examples above,</source>
          <target state="translated">В примерах выше,</target>
        </trans-unit>
        <trans-unit id="de880219c17c8178404452e7a6a65a0e25a5ab03" translate="yes" xml:space="preserve">
          <source>In the examples above, the APPCOST table would be interrogated to find the edit distance coefficients. It is the presence of the &quot;edit_cost_table=&quot; parameter to the spellfix1 module name that causes editdist3() to be used in place of the built-in edit distance function. If APPCOST is an empty string, then the built-in Wagner edit-distance function is used.</source>
          <target state="translated">В приведенных выше примерах таблица APPCOST будет опрашиваться для нахождения коэффициентов расстояния редактирования.Именно наличие параметра &quot;edit_cost_table=&quot; к имени модуля spellfix1 приводит к тому,что вместо встроенной функции расстояния редактирования используется editdist3().Если APPCOST является пустой строкой,то используется встроенная функция расстояния редактирования Вагнера.</target>
        </trans-unit>
        <trans-unit id="2400a1ee49a9dce2718b34cdfc5c379cec93c638" translate="yes" xml:space="preserve">
          <source>In the expression of a &lt;a href=&quot;gencol&quot;&gt;generated column&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3adc83f3d79277fad8353d570dcfc825d479731" translate="yes" xml:space="preserve">
          <source>In the expression of a &lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK constraint&lt;/a&gt;.</source>
          <target state="translated">В выражении &lt;a href=&quot;lang_createtable#ckconst&quot;&gt;ограничения CHECK&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1dc67cb87d0120f285414b41e4beb1e776521f83" translate="yes" xml:space="preserve">
          <source>In the expression part of an index on an expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ff8ef765e12ede160f30458a862b4edd37cec09" translate="yes" xml:space="preserve">
          <source>In the extreme case where the columns being indexed cover all columns of the PRIMARY KEY, the index will consist of only the columns being indexed. The ex25acde example above demonstrates this. Each entry in the ex25acde index consists of only the columns a, c, d, and e, in that order.</source>
          <target state="translated">В крайнем случае,когда индексируемые столбцы охватывают все столбцы PRIMARY KEY,индекс будет состоять только из индексируемых столбцов.Пример ex25acde,приведенный выше,демонстрирует это.Каждая запись в индексе ex25acde состоит только из столбцов a,c,d и e в этом порядке.</target>
        </trans-unit>
        <trans-unit id="f9d2f7bcd7e33c3c61f03684e92a0123ee2c50c1" translate="yes" xml:space="preserve">
          <source>In the first case, when the table does not previously exist, the table is automatically created and the content of the first row of the input CSV file is used to determine the name of all the columns in the table. In other words, if the table does not previously exist, the first row of the CSV file is interpreted to be column names and the actual data starts on the second row of the CSV file.</source>
          <target state="translated">В первом случае,когда таблица ранее не существовала,таблица создается автоматически и содержимое первой строки входного CSV-файла используется для определения имени всех столбцов таблицы.Другими словами,если таблица ранее не существовала,первая строка CSV-файла интерпретируется как имена столбцов,а фактические данные начинаются со второй строки CSV-файла.</target>
        </trans-unit>
        <trans-unit id="8cfb2ab353eeb9931ea61c166eef50db11918f37" translate="yes" xml:space="preserve">
          <source>In the following example, the window frame for each row consists of all rows from the current row to the end of the set, where rows are sorted according to &quot;ORDER BY a&quot;.</source>
          <target state="translated">В следующем примере оконная рамка для каждой строки состоит из всех строк от текущей строки до конца набора,где строки отсортированы в соответствии с &quot;ORDER BY a&quot;.</target>
        </trans-unit>
        <trans-unit id="ad3b432372161232b364559d85e3c83dbfa80ec8" translate="yes" xml:space="preserve">
          <source>In the following query, the optimizer is free to reorder the tables of FROM clause anyway it sees fit:</source>
          <target state="translated">В следующем запросе оптимизатор может свободно переупорядочивать таблицы из пункта FROM,как ему заблагорассудится:</target>
        </trans-unit>
        <trans-unit id="213dce290e5c56de530174ae284660516d8c6333" translate="yes" xml:space="preserve">
          <source>In the future, this option may also disable other floating point functionality, for example the &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_double()&lt;/a&gt;, &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_double()&lt;/a&gt;, &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_double()&lt;/a&gt; and &lt;a href=&quot;c3ref/column_blob&quot;&gt;sqlite3_column_double()&lt;/a&gt; API functions.</source>
          <target state="translated">В будущем эта опция может также отключить другие функции с плавающей запятой, например , &lt;a href=&quot;c3ref/bind_blob&quot;&gt;функции&lt;/a&gt; API &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_double ()&lt;/a&gt; , sqlite3_bind_double () , &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_double ()&lt;/a&gt; и &lt;a href=&quot;c3ref/column_blob&quot;&gt;sqlite3_column_double ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="dfaedc6be2b7553cc537d3ce90c362a4be2c9a84" translate="yes" xml:space="preserve">
          <source>In the latter query, the query plan must be &lt;a href=&quot;#option2&quot;&gt;option 2&lt;/a&gt;. Note that you must use the keyword &quot;CROSS&quot; in order to disable the table reordering optimization; INNER JOIN, NATURAL JOIN, JOIN, and other similar combinations work just like a comma join in that the optimizer is free to reorder tables as it sees fit. (Table reordering is also disabled on an outer join, but that is because outer joins are not associative or commutative. Reordering tables in OUTER JOIN changes the result.)</source>
          <target state="translated">В последнем запросе план запроса должен быть &lt;a href=&quot;#option2&quot;&gt;вариантом 2&lt;/a&gt; . Обратите внимание, что вы должны использовать ключевое слово &amp;laquo;CROSS&amp;raquo;, чтобы отключить оптимизацию переупорядочения таблицы; INNER JOIN, NATURAL JOIN, JOIN и другие подобные комбинации работают так же, как соединение через запятую, в том смысле, что оптимизатор может изменять порядок таблиц по своему усмотрению. (Переупорядочение таблиц также отключено для внешнего соединения, но это потому, что внешние соединения не являются ассоциативными или коммутативными. Изменение порядка таблиц во OUTER JOIN меняет результат.)</target>
        </trans-unit>
        <trans-unit id="db1ceb5581cb83e63561f68248a7b5044a5f4d90" translate="yes" xml:space="preserve">
          <source>In the legacy interface, the return value will be either &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY&lt;/a&gt;, &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_DONE&lt;/a&gt;, &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ROW&lt;/a&gt;, &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt;, or &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_MISUSE&lt;/a&gt;. With the &quot;v2&quot; interface, any of the other &lt;a href=&quot;rescode&quot;&gt;result codes&lt;/a&gt; or &lt;a href=&quot;rescode#extrc&quot;&gt;extended result codes&lt;/a&gt; might be returned as well.</source>
          <target state="translated">В устаревшем интерфейсе возвращаемое значение будет либо &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY&lt;/a&gt; , &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_DONE&lt;/a&gt; , &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ROW&lt;/a&gt; , &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt; или &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_MISUSE&lt;/a&gt; . С интерфейсом &amp;laquo;v2&amp;raquo; также могут быть возвращены любые другие &lt;a href=&quot;rescode&quot;&gt;коды результатов&lt;/a&gt; или &lt;a href=&quot;rescode#extrc&quot;&gt;расширенные коды результатов&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c4f1e2e6a1b6e2882af269cc303fc56c8348c472" translate="yes" xml:space="preserve">
          <source>In the legacy interface, the return value will be either &lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;, &lt;a href=&quot;../rescode#done&quot;&gt;SQLITE_DONE&lt;/a&gt;, &lt;a href=&quot;../rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt;, &lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt;, or &lt;a href=&quot;../rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt;. With the &quot;v2&quot; interface, any of the other &lt;a href=&quot;../rescode&quot;&gt;result codes&lt;/a&gt; or &lt;a href=&quot;../rescode#extrc&quot;&gt;extended result codes&lt;/a&gt; might be returned as well.</source>
          <target state="translated">В устаревшем интерфейсе возвращаемое значение будет либо &lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; , &lt;a href=&quot;../rescode#done&quot;&gt;SQLITE_DONE&lt;/a&gt; , &lt;a href=&quot;../rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt; , &lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt; или &lt;a href=&quot;../rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt; . С интерфейсом &amp;laquo;v2&amp;raquo; также могут быть возвращены любые другие &lt;a href=&quot;../rescode&quot;&gt;коды результатов&lt;/a&gt; или &lt;a href=&quot;../rescode#extrc&quot;&gt;расширенные коды результатов&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3e24ef81342a9cacce2edb83f3edc5fc97054dd2" translate="yes" xml:space="preserve">
          <source>In the previous query the fruit='Peach' constraint narrowed the result down to a single row. But the same technique works even if multiple rows are obtained. Suppose we looked up the price of Oranges instead of Peaches:</source>
          <target state="translated">В предыдущем запросе ограничение fruit='Peach' сузило результат до одной строки.Но та же самая техника работает,даже если получено несколько строк.Предположим,мы посмотрели вверх цену &quot;Апельсинов&quot;,а не &quot;Персиков&quot;:</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
