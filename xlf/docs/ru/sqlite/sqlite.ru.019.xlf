<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="sqlite">
    <body>
      <group id="sqlite">
        <trans-unit id="59ef232ad2a9a13529bf5e89145da92a1a6319d6" translate="yes" xml:space="preserve">
          <source>Type affinity</source>
          <target state="translated">Типовое сходство</target>
        </trans-unit>
        <trans-unit id="38895187a3c7e29b6f02e06c184834c7180dd221" translate="yes" xml:space="preserve">
          <source>Typical output from a single TH3 test program run looks like this:</source>
          <target state="translated">Типичный вывод из одного запуска TH3 тестовой программы выглядит следующим образом:</target>
        </trans-unit>
        <trans-unit id="8711d8537a2bf9829ad98f22b75b8b8dc119969c" translate="yes" xml:space="preserve">
          <source>UNBOUNDED</source>
          <target state="translated">UNBOUNDED</target>
        </trans-unit>
        <trans-unit id="363cb5cb9b015bf8fe75ee8f6f3ad675ca5618cc" translate="yes" xml:space="preserve">
          <source>UNION</source>
          <target state="translated">UNION</target>
        </trans-unit>
        <trans-unit id="e0f0a7115a4e0b11973725c719a99090b1a2caa7" translate="yes" xml:space="preserve">
          <source>UNION ALL ... UNION ALL SELECT</source>
          <target state="translated">ЮНИОН ВСЕ ...ОБЪЕДИНЕНИЕ ВСЕХ ИЗБРАННЫХ</target>
        </trans-unit>
        <trans-unit id="2ef896dc8994d71c3776f028df0d2a89b61b4550" translate="yes" xml:space="preserve">
          <source>UNION, UNION ALL, INTERSECT, and EXCEPT</source>
          <target state="translated">ЮНИОН,ЮНИОН ВСЕ,ВНЕШНИЙ и ИСКЛЮЧИТЕЛЬНИЙ</target>
        </trans-unit>
        <trans-unit id="c9e6a29d14f3f27cd2ee75b65407552ad50a3078" translate="yes" xml:space="preserve">
          <source>UNIQUE</source>
          <target state="translated">UNIQUE</target>
        </trans-unit>
        <trans-unit id="841c884fb288309550412babe47484ff0e3745f9" translate="yes" xml:space="preserve">
          <source>UNIQUE, CHECK, and NOT NULL constraint errors</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ead37d8578ae9705f3d87c1d034addd810cd1ed" translate="yes" xml:space="preserve">
          <source>UNIX mode, as returned by stat(2) for the zip file record (an integer). This identifies the type of record (file, directory or symbolic link), and the associated user/group/all permissions.</source>
          <target state="translated">Режим UNIX,возвращаемый статистикой (2)для записи zip-файла (целое число).Это определяет тип записи (файл,каталог или символическая ссылка),а также связанные с ней права пользователя/группы/все права доступа.</target>
        </trans-unit>
        <trans-unit id="f6fee659655c0db9d5b27d3ee09d34358c974b03" translate="yes" xml:space="preserve">
          <source>UNLOCKED</source>
          <target state="translated">UNLOCKED</target>
        </trans-unit>
        <trans-unit id="d272346adafef58007de20094d2f682eb2fe1bd2" translate="yes" xml:space="preserve">
          <source>UNSIGNED BIG INT</source>
          <target state="translated">НЕПОДПИСАННЫЙ КРУПНЫЙ БИЗНЕС</target>
        </trans-unit>
        <trans-unit id="52c6c1812015585dc1092393a1f244f60d68c60a" translate="yes" xml:space="preserve">
          <source>UPDATE</source>
          <target state="translated">UPDATE</target>
        </trans-unit>
        <trans-unit id="688e558eee1d1bb512a94d0cc620288bf7d472f2" translate="yes" xml:space="preserve">
          <source>UPDATE And DELETE Statements</source>
          <target state="translated">УПДАТА И УДАЛИТЫ Заявления</target>
        </trans-unit>
        <trans-unit id="49a16f1602f22a2ff3d079003de17960196cd62b" translate="yes" xml:space="preserve">
          <source>UPDATE Changes</source>
          <target state="translated">ОБНОВЛЕНИЕ Изменения</target>
        </trans-unit>
        <trans-unit id="bf53a6aae01db9b5dad497a7e025817f66502008" translate="yes" xml:space="preserve">
          <source>UPDATE and DELETE statements work similarly.</source>
          <target state="translated">UPDATE и DELETE заявления работают одинаково.</target>
        </trans-unit>
        <trans-unit id="1c9d5c3eed910621fdbd8231e3b605e82a063d04" translate="yes" xml:space="preserve">
          <source>UPDATE statements work very much like DELETE statements except that instead of deleting the record they replace it with a new one. Consider this example:</source>
          <target state="translated">Операторы UPDATE очень похожи на операторы DELETE за исключением того,что вместо удаления записи они заменяют ее новой.Рассмотрим этот пример:</target>
        </trans-unit>
        <trans-unit id="23f1f94678733621721dfbd9281a151e75fd39b3" translate="yes" xml:space="preserve">
          <source>UPDATE t1 SET b = 'v2' WHERE a=1;</source>
          <target state="translated">UPDATE t1 SET b='v2' Где a=1;</target>
        </trans-unit>
        <trans-unit id="9d1ad45a1d025bcccb63dad4f87235cf205b5b63" translate="yes" xml:space="preserve">
          <source>UPDATE t1 SET b=b*2 WHERE a&amp;gt;=0 AND a&amp;lt;10;</source>
          <target state="translated">ОБНОВЛЕНИЕ t1 SET b = b * 2 ГДЕ a&amp;gt; = 0 И a &amp;lt;10;</target>
        </trans-unit>
        <trans-unit id="7bc4a22623437c880e8e4324cc657c00abd18be7" translate="yes" xml:space="preserve">
          <source>UPDATE t1 SET b=b*2 WHERE a&amp;gt;=10 AND a&amp;lt;20;</source>
          <target state="translated">ОБНОВЛЕНИЕ t1 SET b = b * 2 ГДЕ a&amp;gt; = 10 И a &amp;lt;20;</target>
        </trans-unit>
        <trans-unit id="69fa4f2a787b8c6d32fe94ec05425d1fb170202e" translate="yes" xml:space="preserve">
          <source>UPDATE t1 SET b=b*2 WHERE a&amp;gt;=9980 AND a&amp;lt;9990;</source>
          <target state="translated">ОБНОВЛЕНИЕ t1 SET b = b * 2 ГДЕ a&amp;gt; = 9980 И a &amp;lt;9990;</target>
        </trans-unit>
        <trans-unit id="bd6a359ea6d6ffa5fa77996361d46448cd59ce9f" translate="yes" xml:space="preserve">
          <source>UPDATE t1 SET b=b*2 WHERE a&amp;gt;=9990 AND a&amp;lt;10000;</source>
          <target state="translated">ОБНОВЛЕНИЕ t1 SET b = b * 2 ГДЕ a&amp;gt; = 9990 И a &amp;lt;10000;</target>
        </trans-unit>
        <trans-unit id="0afa724368a197872d6c5ffb446fe74a06bc33c2" translate="yes" xml:space="preserve">
          <source>UPDATE t2 SET b=121928 WHERE a=2;</source>
          <target state="translated">UPDATE t2 SET b=121928 Где a=2;</target>
        </trans-unit>
        <trans-unit id="3526291b0bb67daddf75ff2b44713d0b345a7083" translate="yes" xml:space="preserve">
          <source>UPDATE t2 SET b=347393 WHERE a=25000;</source>
          <target state="translated">UPDATE t2 SET b=347393 Где a=25000;</target>
        </trans-unit>
        <trans-unit id="1e3a05f35bab1c3145c54848bb462d616f180f96" translate="yes" xml:space="preserve">
          <source>UPDATE t2 SET b=35065 WHERE a=24999;</source>
          <target state="translated">UPDATE t2 SET b=35065 Где a=24999;</target>
        </trans-unit>
        <trans-unit id="83da842c2149e8d92733fb66a7c52922e2a8bb02" translate="yes" xml:space="preserve">
          <source>UPDATE t2 SET b=468026 WHERE a=1;</source>
          <target state="translated">UPDATE t2 SET b=468026 Где a=1;</target>
        </trans-unit>
        <trans-unit id="abe0aeef0bc8c95cf7dba0b992e2c26051c0fbd4" translate="yes" xml:space="preserve">
          <source>UPDATE t2 SET c='one hundred forty eight thousand three hundred eighty two' WHERE a=1;</source>
          <target state="translated">UPDATE t2 SET c='сто сорок восемь тысяч триста восемьдесят два' Где a=1;</target>
        </trans-unit>
        <trans-unit id="2e646600f6e7b2bb70471ce989105819d65503b9" translate="yes" xml:space="preserve">
          <source>UPDATE t2 SET c='three hundred eighty three thousand ninety nine' WHERE a=24999;</source>
          <target state="translated">UPDATE t2 SET c='триста восемьдесят три тысячи девяносто девять' Где a=24999;</target>
        </trans-unit>
        <trans-unit id="24be2b2373e2e643ec5af7225d298b219c086994" translate="yes" xml:space="preserve">
          <source>UPDATE t2 SET c='three hundred sixty six thousand five hundred two' WHERE a=2;</source>
          <target state="translated">UPDATE t2 SET c='триста шестьдесят шесть тысяч пятьсот два Где a=2;</target>
        </trans-unit>
        <trans-unit id="317adbaa4dc2a3c2843d99c6771359a7f0624c58" translate="yes" xml:space="preserve">
          <source>UPDATE t2 SET c='two hundred fifty six thousand eight hundred thirty' WHERE a=25000;</source>
          <target state="translated">UPDATE t2 SET c='двести пятьдесят шесть тысяч восемьсот тридцать Где a=25000;</target>
        </trans-unit>
        <trans-unit id="c55112b254b71dd5f11927b24c53d183f3ed4118" translate="yes" xml:space="preserve">
          <source>UPSERT</source>
          <target state="translated">UPSERT</target>
        </trans-unit>
        <trans-unit id="6eee69d236c66ab4ffc25696fb830833cbb3fd3c" translate="yes" xml:space="preserve">
          <source>UPSERT does not currently work for &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt;.</source>
          <target state="translated">UPSERT в настоящее время не работает с &lt;a href=&quot;vtab&quot;&gt;виртуальными таблицами&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1c2066bfe0e8babe467800cce0c33996ece301c4" translate="yes" xml:space="preserve">
          <source>UPSERT is a special syntax addition to &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; that causes the INSERT to behave as an &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; or a no-op if the INSERT would violate a uniqueness constraint. UPSERT is not standard SQL. UPSERT in SQLite follows the syntax established by PostgreSQL. UPSERT syntax was added to SQLite with version 3.24.0 (2018-06-04).</source>
          <target state="translated">UPSERT - это специальное синтаксическое дополнение к &lt;a href=&quot;lang_insert&quot;&gt;INSERT,&lt;/a&gt; которое заставляет INSERT вести себя как &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; или бездействовать, если INSERT нарушит ограничение уникальности. UPSERT - это не стандартный SQL. UPSERT в SQLite следует синтаксису, установленному PostgreSQL. Синтаксис UPSERT был добавлен в SQLite с версией 3.24.0 (2018-06-04).</target>
        </trans-unit>
        <trans-unit id="095b20b5d88a77f400266be9db4f8fd23dca8121" translate="yes" xml:space="preserve">
          <source>URI Filenames</source>
          <target state="translated">Фильмы URI</target>
        </trans-unit>
        <trans-unit id="6b3e19882ec7248890e4c5d13ea994d174863955" translate="yes" xml:space="preserve">
          <source>URI filename examples</source>
          <target state="translated">примеры файлов URI</target>
        </trans-unit>
        <trans-unit id="5e847e5e42eefec738b40d802039de3c59cd0211" translate="yes" xml:space="preserve">
          <source>URI filenames</source>
          <target state="translated">имена файлов URI</target>
        </trans-unit>
        <trans-unit id="bcc83fb4f795835fa81fea70c5b7f4ce3da5fb80" translate="yes" xml:space="preserve">
          <source>URI filenames are parsed according to RFC 3986. If the URI contains an authority, then it must be either an empty string or the string &quot;localhost&quot;. If the authority is not an empty string or &quot;localhost&quot;, an error is returned to the caller. The fragment component of a URI, if present, is ignored.</source>
          <target state="translated">Фильмы URI анализируются в соответствии с RFC 3986.Если URI содержит авторизацию,то это должна быть либо пустая строка,либо строка &quot;localhost&quot;.Если авторизация не пустая строка или &quot;localhost&quot;,то вызывающему абоненту возвращается ошибка.Компонент фрагмента URI,если он присутствует,игнорируется.</target>
        </trans-unit>
        <trans-unit id="f52fa99533bd53d2651964895f6aead88e88448d" translate="yes" xml:space="preserve">
          <source>URI filenames in sqlite3_open()</source>
          <target state="translated">Имена файлов URI в sqlite3_open()</target>
        </trans-unit>
        <trans-unit id="26ed4ff394970482b699209414b942167f2dd638" translate="yes" xml:space="preserve">
          <source>URI hexadecimal escape sequences (%HH) are supported within the path and query components of a URI. A hexadecimal escape sequence consists of a percent sign - &quot;%&quot; - followed by exactly two hexadecimal digits specifying an octet value. Before the path or query components of a URI filename are interpreted, they are encoded using UTF-8 and all hexadecimal escape sequences replaced by a single byte containing the corresponding octet. If this process generates an invalid UTF-8 encoding, the results are undefined.</source>
          <target state="translated">Поддерживаются шестнадцатиричные экранирующие последовательности (%HH)URI внутри компонентов пути и запроса URI.Шестнадцатеричная экранирующая последовательность состоит из знака процента-&quot;%&quot;,за которым следуют ровно две шестнадцатеричные цифры,указывающие на значение октета.Перед интерпретацией пути или компонента запроса имени файла URI они кодируются с помощью UTF-8,а все шестнадцатеричные экранирующие последовательности заменяются одним байтом,содержащим соответствующий октет.Если при этом процесс генерирует некорректную кодировку UTF-8,то результаты будут неопределенны.</target>
        </trans-unit>
        <trans-unit id="40da99c368fe0d628f9b0dcc937070f1edfd1b1f" translate="yes" xml:space="preserve">
          <source>URIs are processed as UTF8 text. The filename argument sqlite3_open16() is converted from UTF16 native byte order into UTF8 prior to processing.</source>
          <target state="translated">URI обрабатываются как UTF8 текст.Аргумент имени файла sqlite3_open16()перед обработкой преобразуется из нативного порядка байт UTF16 в UTF8.</target>
        </trans-unit>
        <trans-unit id="41b3da30e1707f2b0bc331e3534b952825349eed" translate="yes" xml:space="preserve">
          <source>USB flash memory sticks seem to be especially pernicious liars regarding sync requests. One can easily see this by committing a large transaction to an SQLite database on a USB memory stick. The COMMIT command will return relatively quickly, indicating that the memory stick has told the operating system and the operating system has told SQLite that all content is safely in persistent storage, and yet the LED on the end of the memory stick will continue flashing for several more seconds. Pulling out the memory stick while the LED is still flashing will frequently result in database corruption.</source>
          <target state="translated">Флеш-карты памяти USB кажутся особенно губительными лжецами в отношении запросов синхронизации.В этом легко убедиться,совершив большую транзакцию к базе данных SQLite на USB-флешке.Команда COMMIT вернётся относительно быстро,указывая на то,что карта памяти сказала операционной системе,а операционная система сказала SQLite,что всё содержимое надёжно находится в постоянном хранилище,и всё же светодиод на конце карты памяти продолжит мигать ещё несколько секунд.Вытягивание карты памяти в то время,когда светодиод все еще мигает,часто приводит к повреждению базы данных.</target>
        </trans-unit>
        <trans-unit id="b0138e4f9dc0aacc367a1f86d8e4506b943320e8" translate="yes" xml:space="preserve">
          <source>USING</source>
          <target state="translated">USING</target>
        </trans-unit>
        <trans-unit id="4a2b12a8f9db417e4cc5f36a3e1c2fec1469fe7f" translate="yes" xml:space="preserve">
          <source>UTC timestamp, in seconds since the UNIX epoch (an integer).</source>
          <target state="translated">UTC метка времени,в секундах от эпохи UNIX (целое число).</target>
        </trans-unit>
        <trans-unit id="28ef7752ac0283beed8e66a2b5b204db183549fd" translate="yes" xml:space="preserve">
          <source>Unallocated space</source>
          <target state="translated">нераспределённая площадь</target>
        </trans-unit>
        <trans-unit id="b0b4a5a01660223c1f1c6d19e4a89997fe5e3325" translate="yes" xml:space="preserve">
          <source>Unary &quot;-&quot;</source>
          <target state="translated">Унарный &quot;-&quot;</target>
        </trans-unit>
        <trans-unit id="6bfa68ac4d2f61f36caa0def08a4a0095686e16a" translate="yes" xml:space="preserve">
          <source>Undefined BEFORE trigger behavior</source>
          <target state="translated">Неопределенное поведение триггера</target>
        </trans-unit>
        <trans-unit id="9e37e5dd8e036cac3e0f290adf0e16da58e3ffe8" translate="yes" xml:space="preserve">
          <source>Undefined behavior checks</source>
          <target state="translated">Проверки неопределённого поведения</target>
        </trans-unit>
        <trans-unit id="79dfa4a9456d7e99f2303579887d4ea94c961a44" translate="yes" xml:space="preserve">
          <source>Under Unix, an &lt;b&gt;sqlite*&lt;/b&gt; pointer should not be carried across a &lt;b&gt;fork()&lt;/b&gt; system call into the child process. The child process should open its own copy of the database after the &lt;b&gt;fork()&lt;/b&gt;.</source>
          <target state="translated">В Unix указатель &lt;b&gt;sqlite *&lt;/b&gt; не должен переноситься через системный вызов &lt;b&gt;fork ()&lt;/b&gt; в дочерний процесс. Дочерний процесс должен открыть свою собственную копию базы данных после &lt;b&gt;fork ()&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="7887974e08825eb481696126029ce641dab388bf" translate="yes" xml:space="preserve">
          <source>Under Unix, you should not carry an open SQLite database across a fork() system call into the child process.</source>
          <target state="translated">В Unix не следует переносить открытую базу данных SQLite через системный вызов fork()в дочерний процесс.</target>
        </trans-unit>
        <trans-unit id="d2245919272810b035145426205e128fae32a19a" translate="yes" xml:space="preserve">
          <source>Under most circumstances, the original LIKE or GLOB operator is still tested against each input row even if the virtual terms are used to constrain an index. This is because we do not know what additional constraints may be imposed by characters to the right of the</source>
          <target state="translated">В большинстве случаев,исходный оператор LIKE или GLOB все еще тестируется на каждой входной строке,даже если виртуальные термины используются для ограничения индекса.Это связано с тем,что мы не знаем,какие дополнительные ограничения могут быть наложены символами справа от поля</target>
        </trans-unit>
        <trans-unit id="0aafde4f0303b5c58e56ca1461baa83fd0408041" translate="yes" xml:space="preserve">
          <source>Unfortunately, SQLite contains many branch instructions that help the code run faster without changing the output. Such branches generate false-positives during mutation testing. As an example, consider the following &lt;a href=&quot;https://www.sqlite.org/src/artifact/55b5fb474?ln=55-62&quot;&gt;hash function&lt;/a&gt; used to accelerate table-name lookup:</source>
          <target state="translated">К сожалению, SQLite содержит множество инструкций ветвления, которые помогают коду работать быстрее без изменения вывода. Такие ветви генерируют ложноположительные результаты при тестировании на мутации. В качестве примера рассмотрим следующую &lt;a href=&quot;https://www.sqlite.org/src/artifact/55b5fb474?ln=55-62&quot;&gt;хеш-функцию,&lt;/a&gt; используемую для ускорения поиска имени таблицы:</target>
        </trans-unit>
        <trans-unit id="0c6793d3cab2ac8df02302e6322b00044082495f" translate="yes" xml:space="preserve">
          <source>Unfortunately, algorithm-2 is slower than algorithm-1 in this application.</source>
          <target state="translated">К сожалению,алгоритм-2 в этом приложении работает медленнее алгоритма-1.</target>
        </trans-unit>
        <trans-unit id="fcfb2377607479ca817d6a09b03610de66f64da2" translate="yes" xml:space="preserve">
          <source>Unfortunately, even though virtual tables are ignored by default, any &lt;a href=&quot;fts3#*shadowtab&quot;&gt;underlying database tables&lt;/a&gt; that they create in order to store data within the database are not, and &lt;a href=&quot;sqldiff&quot;&gt;sqldiff&lt;/a&gt; will include add these to any RBU database. For this reason, users attempting to use sqldiff to create RBU updates to apply to target databases with one or more virtual tables will likely have to run sqldiff using the --table option separately for each table to update in the target database.</source>
          <target state="translated">К сожалению, даже несмотря на то, что виртуальные таблицы по умолчанию игнорируются, любые &lt;a href=&quot;fts3#*shadowtab&quot;&gt;базовые таблицы базы данных,&lt;/a&gt; которые они создают для хранения данных в базе данных, нет, и &lt;a href=&quot;sqldiff&quot;&gt;sqldiff&lt;/a&gt; будет добавлять их в любую базу данных RBU. По этой причине пользователям, пытающимся использовать sqldiff для создания обновлений RBU для применения к целевым базам данных с одной или несколькими виртуальными таблицами, скорее всего, придется запускать sqldiff с параметром --table отдельно для каждой таблицы, подлежащей обновлению в целевой базе данных.</target>
        </trans-unit>
        <trans-unit id="c58a4f6c2a537b213079cd1adcaa6b2001643e9a" translate="yes" xml:space="preserve">
          <source>Unfortunately, most consumer-grade mass storage devices lie about syncing. Disk drives will report that content is safely on persistent media as soon as it reaches the track buffer and before actually being written to oxide. This makes the disk drives seem to operate faster (which is vitally important to the manufacturer so that they can show good benchmark numbers in trade magazines). And in fairness, the lie normally causes no harm, as long as there is no power loss or hard reset prior to the track buffer actually being written to oxide. But if a power loss or hard reset does occur, and if that results in content that was written after a sync reaching oxide while content written before the sync is still in a track buffer, then database corruption can occur.</source>
          <target state="translated">К сожалению,большинство устройств хранения данных потребительского класса лгут о синхронизации.Дисковые накопители сообщают,что содержимое находится в безопасности на постоянном носителе,как только оно попадает в буфер дорожек,и перед тем,как оно действительно записывается в оксид.Это делает дисковые накопители более быстрыми в работе (что жизненно важно для производителя,чтобы они могли показывать хорошие эталонные номера в торговых журналах).И,справедливости ради,ложь,как правило,не причиняет вреда,если нет потери питания или жесткого сброса до того,как трековый буфер действительно записывается в оксидное состояние.Но если потеря питания или жесткий сброс все же произойдет,и если в результате этого содержимое,записанное после синхронизации,достигнет оксида,в то время как содержимое,записанное до синхронизации,все еще находится в буфере трека,то может произойти повреждение базы данных.</target>
        </trans-unit>
        <trans-unit id="af520d1880e5ee3cdc82e50d4d1525585fc7beb9" translate="yes" xml:space="preserve">
          <source>Unfortunately, the NGQP caused a performance regression in Fossil.</source>
          <target state="translated">К сожалению,NGQP вызвал регрессию производительности в ископаемом.</target>
        </trans-unit>
        <trans-unit id="7536fed3548161a0855cd29750230303476e4484" translate="yes" xml:space="preserve">
          <source>Unfortunately, the no-limits policy has been shown to create problems. Because the upper bounds were not well defined, they were not tested, and bugs (including possible security exploits) were often found when pushing SQLite to extremes. For this reason, newer versions of SQLite have well-defined limits and those limits are tested as part of the &lt;a href=&quot;testing&quot;&gt;test suite&lt;/a&gt;.</source>
          <target state="translated">К сожалению, политика без ограничений создает проблемы. Поскольку верхние границы не были четко определены, они не тестировались, а при доведении SQLite до крайностей часто обнаруживались ошибки (включая возможные уязвимости безопасности). По этой причине более новые версии SQLite имеют четко определенные ограничения, и эти ограничения тестируются как часть &lt;a href=&quot;testing&quot;&gt;набора тестов&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="154cee1be1782349508f9f52cb47759ac0528fca" translate="yes" xml:space="preserve">
          <source>Unfortunately, the no-limits policy has been shown to create problems. Because the upper bounds were not well defined, they were not tested, and bugs were often found when pushing SQLite to extremes. For this reason, versions of SQLite since about release 3.5.8 (2008-04-16) have well-defined limits, and those limits are tested as part of the &lt;a href=&quot;testing&quot;&gt;test suite&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9809fad4d13ccafd43c46a06696bc5f74c1752de" translate="yes" xml:space="preserve">
          <source>Unfortunately, the query plan computed by NN for TPC-H Q8 is not optimal. The plan computed using NN is R-N1-N2-S-C-O-L-P with a cost of 36.92. The notation in the previous sentence means that the R table is run in the outer loop, N1 is in the next inner loop, N2 is in the third loop, and so forth down to P which is in the inner-most loop. The shortest path through the graph (as found via exhaustive search) is P-L-O-C-N1-R-S-N2 with a cost of 27.38. The difference might not seem like much, but remember that the costs are logarithmic, so the shortest path is nearly 750 times faster than that path found using the NN heuristic.</source>
          <target state="translated">К сожалению,план запросов,вычисленный NN для TPC-H Q8,не является оптимальным.План,вычисленный с помощью NN,является R-N1-N2-S-C-O-L-P со стоимостью 36.92.Нотация в предыдущем предложении означает,что R-таблица выполняется во внешнем цикле,N1-во внутреннем,N2-в третьем,и т.д.до P,которая находится во внутреннем-крайнем цикле.Самый короткий путь через график (найденный с помощью исчерпывающего поиска)-P-L-O-C-N1-R-S-N2 со стоимостью 27,38.Разница может показаться небольшой,но помните,что затраты логарифмические,поэтому самый короткий путь почти в 750 раз быстрее,чем тот,который был найден с помощью эвристики NN.</target>
        </trans-unit>
        <trans-unit id="12b20c37115e65b5f7d7e36cc94465f524bad30b" translate="yes" xml:space="preserve">
          <source>Uniform Resource Identifiers</source>
          <target state="translated">Унифицированные идентификаторы ресурсов</target>
        </trans-unit>
        <trans-unit id="77df08227da6ac685804effa87058e13d84c4065" translate="yes" xml:space="preserve">
          <source>Unique constraint</source>
          <target state="translated">Уникальное ограничение</target>
        </trans-unit>
        <trans-unit id="aa980d194e964e7fb7f97273f5336434b107da41" translate="yes" xml:space="preserve">
          <source>Unique index</source>
          <target state="translated">Единый индекс</target>
        </trans-unit>
        <trans-unit id="7157e0defd66f64a5eef1f6b25ed305c7ea76e58" translate="yes" xml:space="preserve">
          <source>Unix builds come with multiple built-in VFSes. The default VFS for unix is called &quot;unix&quot; and is used in most applications. Other VFSes that might be found in unix (depending on compile-time options) include:</source>
          <target state="translated">Unix сборки поставляются с несколькими встроенными VFS.Стандартная VFS для unix называется &quot;unix&quot; и используется в большинстве приложений.К другим VFS,которые могут быть найдены в unix (в зависимости от времени компиляции),относятся:</target>
        </trans-unit>
        <trans-unit id="fc9481ccc42310377001eaf4b65f0ba7f43291d9" translate="yes" xml:space="preserve">
          <source>Unless</source>
          <target state="translated">Unless</target>
        </trans-unit>
        <trans-unit id="e08358316619a161ecbcf33073f1d600c7a3d1d8" translate="yes" xml:space="preserve">
          <source>Unless SQLite is running in &quot;auto_vacuum=FULL&quot; mode, when a large amount of data is deleted from the database file it leaves behind empty space, or &quot;free&quot; database pages. This means the database file might be larger than strictly necessary. Running VACUUM to rebuild the database reclaims this space and reduces the size of the database file.</source>
          <target state="translated">Если только SQLite не запущен в режиме &quot;auto_vacuum=FULL&quot;,то при удалении большого объема данных из файла базы данных он оставляет за собой пустое место,или &quot;свободные&quot; страницы базы данных.Это означает,что файл базы данных может быть больше,чем необходимо.Запуск VACUUM для восстановления базы данных восстанавливает это пространство и уменьшает размер файла базы данных.</target>
        </trans-unit>
        <trans-unit id="0e73f60b051af43064d6e0d8d691c92bf067b075" translate="yes" xml:space="preserve">
          <source>Unless a specific tokenizer is specified as part of the CREATE VIRTUAL TABLE statement used to create the FTS table, the default tokenizer, &quot;simple&quot;, is used. The simple tokenizer extracts tokens from a document or basic FTS full-text query according to the following rules:</source>
          <target state="translated">Если в операторе CREATE VIRTUAL TABLE,используемом для создания таблицы FTS,не указан конкретный токенайзер,то по умолчанию используется &quot;простой&quot; токенайзер.Простой токенайзер извлекает маркеры из документа или основного полнотекстового запроса FTS в соответствии со следующими правилами:</target>
        </trans-unit>
        <trans-unit id="5fdc85037d052204b60739c85a692574cdca8812" translate="yes" xml:space="preserve">
          <source>Unless deadlock is detected (see below), sqlite3_unlock_notify() always returns SQLITE_OK.</source>
          <target state="translated">Если не обнаружен тупик (см.ниже),sqlite3_unlock_notify()всегда возвращает SQLITE_OK.</target>
        </trans-unit>
        <trans-unit id="7c4feec28833f0a64ab53ef0f49205604d9d8edc" translate="yes" xml:space="preserve">
          <source>Unless it is a CREATE TABLE ... AS SELECT statement, a CREATE TABLE includes one or more &lt;a href=&quot;syntax/column-def&quot;&gt;column definitions&lt;/a&gt;, optionally followed by a list of &lt;a href=&quot;syntax/table-constraint&quot;&gt;table constraints&lt;/a&gt;. Each column definition consists of the name of the column, optionally followed by the declared type of the column, then one or more optional &lt;a href=&quot;syntax/column-constraint&quot;&gt;column constraints&lt;/a&gt;. Included in the definition of &quot;column constraints&quot; for the purposes of the previous statement are the COLLATE and DEFAULT clauses, even though these are not really constraints in the sense that they do not restrict the data that the table may contain. The other constraints - NOT NULL, CHECK, UNIQUE, PRIMARY KEY and FOREIGN KEY constraints - impose restrictions on the table data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="318eb4656e47b06b6ea5260cd43d217bcb29a47f" translate="yes" xml:space="preserve">
          <source>Unless it is a CREATE TABLE ... AS SELECT statement, a CREATE TABLE includes one or more &lt;a href=&quot;syntax/column-def&quot;&gt;column definitions&lt;/a&gt;, optionally followed by a list of &lt;a href=&quot;syntax/table-constraint&quot;&gt;table constraints&lt;/a&gt;. Each column definition consists of the name of the column, optionally followed by the declared type of the column, then one or more optional &lt;a href=&quot;syntax/column-constraint&quot;&gt;column constraints&lt;/a&gt;. Included in the definition of &quot;column constraints&quot; for the purposes of the previous statement are the COLLATE and DEFAULT clauses, even though these are not really constraints in the sense that they do not restrict the data that the table may contain. The other constraints - NOT NULL, CHECK, UNIQUE, PRIMARY KEY and FOREIGN KEY constraints - impose restrictions on the tables data, and are are described under &lt;a href=&quot;lang_createtable#constraints&quot;&gt;SQL Data Constraints&lt;/a&gt; below.</source>
          <target state="translated">Если это не оператор CREATE TABLE ... AS SELECT, CREATE TABLE включает одно или несколько &lt;a href=&quot;syntax/column-def&quot;&gt;определений столбцов&lt;/a&gt; , за которыми необязательно следует список &lt;a href=&quot;syntax/table-constraint&quot;&gt;ограничений таблицы&lt;/a&gt; . Каждое определение столбца состоит из имени столбца, за которым может следовать объявленный тип столбца, а затем одно или несколько дополнительных &lt;a href=&quot;syntax/column-constraint&quot;&gt;ограничений столбца&lt;/a&gt; . В определение &amp;laquo;ограничений столбца&amp;raquo; для целей предыдущего оператора включены предложения COLLATE и DEFAULT, хотя на самом деле они не являются ограничениями в том смысле, что они не ограничивают данные, которые может содержать таблица. Другие ограничения - NOT NULL, CHECK, UNIQUE, PRIMARY KEY и FOREIGN KEY - накладывают ограничения на данные таблиц и описаны в разделе &lt;a href=&quot;lang_createtable#constraints&quot;&gt;Ограничения данных SQL.&lt;/a&gt; ниже.</target>
        </trans-unit>
        <trans-unit id="1c00ba237aa117de710c9323f816c96f6ada7a01" translate="yes" xml:space="preserve">
          <source>Unless it returns SQLITE_MISUSE, the sqlite3_wal_checkpoint_v2() interface sets the error information that is queried by &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errcode()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errmsg()&lt;/a&gt;.</source>
          <target state="translated">Если он не возвращает SQLITE_MISUSE, интерфейс sqlite3_wal_checkpoint_v2 () устанавливает информацию об ошибке, которую запрашивают &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errcode ()&lt;/a&gt; и &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errmsg ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4e06b73ee3affa8214cc1405f997b2bb6e5fc2af" translate="yes" xml:space="preserve">
          <source>Unless it returns SQLITE_MISUSE, the sqlite3_wal_checkpoint_v2() interface sets the error information that is queried by &lt;a href=&quot;errcode&quot;&gt;sqlite3_errcode()&lt;/a&gt; and &lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg()&lt;/a&gt;.</source>
          <target state="translated">Если он не возвращает SQLITE_MISUSE, интерфейс sqlite3_wal_checkpoint_v2 () устанавливает информацию об ошибке, которую запрашивают &lt;a href=&quot;errcode&quot;&gt;sqlite3_errcode ()&lt;/a&gt; и &lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4591266e2017f729f7aff5d0aced794f6644a4c3" translate="yes" xml:space="preserve">
          <source>Unless it returns SQLITE_MISUSE, this function sets the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; error code and message accessible via &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errcode()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errmsg()&lt;/a&gt; and related functions.</source>
          <target state="translated">Если она не возвращает SQLITE_MISUSE, эта функция устанавливает код ошибки &lt;a href=&quot;#sqlite3&quot;&gt;подключения&lt;/a&gt; к базе данных и сообщение, доступное через &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errcode ()&lt;/a&gt; и &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errmsg ()&lt;/a&gt; и связанные с ними функции.</target>
        </trans-unit>
        <trans-unit id="0e4971f6a57c5c65a9a1ae31e9cf2a3e92d4934e" translate="yes" xml:space="preserve">
          <source>Unless it returns SQLITE_MISUSE, this function sets the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; error code and message accessible via &lt;a href=&quot;errcode&quot;&gt;sqlite3_errcode()&lt;/a&gt; and &lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg()&lt;/a&gt; and related functions.</source>
          <target state="translated">Если она не возвращает SQLITE_MISUSE, эта функция устанавливает код ошибки &lt;a href=&quot;sqlite3&quot;&gt;подключения&lt;/a&gt; к базе данных и сообщение, доступное через &lt;a href=&quot;errcode&quot;&gt;sqlite3_errcode ()&lt;/a&gt; и &lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg ()&lt;/a&gt; и связанные с ними функции.</target>
        </trans-unit>
        <trans-unit id="b37e8216d0e44ec2efee716d4c9dd7d3e0183bf7" translate="yes" xml:space="preserve">
          <source>Unless the &lt;a href=&quot;optoverview#flattening&quot;&gt;flattening optimization&lt;/a&gt; is applied, if a subquery appears in the FROM clause of a SELECT statement, SQLite can either run the subquery and stores the results in a temporary table, or it can run the subquery as a co-routine. The following query is an example of the latter. The subquery is run by a co-routine. The outer query blocks whenever it needs another row of input from the subquery. Control switches to the co-routine which produces the desired output row, then control switches back to the main routine which continues processing.</source>
          <target state="translated">Если не применяется &lt;a href=&quot;optoverview#flattening&quot;&gt;оптимизация сглаживания&lt;/a&gt; , если подзапрос появляется в предложении FROM оператора SELECT, SQLite может либо запустить подзапрос и сохранить результаты во временной таблице, либо запустить подзапрос как сопрограмму. Следующий запрос является примером последнего. Подзапрос выполняется совместной процедурой. Внешний запрос блокируется всякий раз, когда ему нужна другая строка ввода из подзапроса. Управление переключается на совместную процедуру, которая создает желаемую строку вывода, затем управление переключается обратно на основную процедуру, которая продолжает обработку.</target>
        </trans-unit>
        <trans-unit id="6debb16b797e55251f765dccb022c7b2f7c44222" translate="yes" xml:space="preserve">
          <source>Unlike most SQL databases, SQLite does not restrict the type of data that may be inserted into a column based on the columns declared type. Instead, SQLite uses &lt;a href=&quot;datatype3&quot;&gt;dynamic typing&lt;/a&gt;. The declared type of a column is used to determine the &lt;a href=&quot;datatype3#affinity&quot;&gt;affinity&lt;/a&gt; of the column only.</source>
          <target state="translated">В отличие от большинства баз данных SQL, SQLite не ограничивает тип данных, которые могут быть вставлены в столбец, на основе объявленного типа столбца. Вместо этого SQLite использует &lt;a href=&quot;datatype3&quot;&gt;динамическую типизацию&lt;/a&gt; . Объявленный тип столбца используется только для определения &lt;a href=&quot;datatype3#affinity&quot;&gt;сродства&lt;/a&gt; столбца.</target>
        </trans-unit>
        <trans-unit id="8fc35fdda18e32589afbc6422311960ed986aa1d" translate="yes" xml:space="preserve">
          <source>Unlike most other SQL implementations, SQLite does not have a separate BOOLEAN data type. Instead, TRUE and FALSE are (normally) represented as integers 1 and 0, respectively. This does not seem to cause many problems, as we seldom get complaints about it. But it is important to recognize.</source>
          <target state="translated">В отличие от большинства других реализаций SQL,SQLite не имеет отдельного типа данных BOOLEAN.Вместо этого,TRUE и FALSE (обычно)представляются в виде целых чисел 1 и 0 соответственно.Похоже,что это не вызывает много проблем,так как мы редко получаем жалобы на это.Но это важно понимать.</target>
        </trans-unit>
        <trans-unit id="19f905f254ee85ddda7a69f550a125cf0e71bdf9" translate="yes" xml:space="preserve">
          <source>Unlike option values and column names, SQL text literals intended as tokenizers must be quoted using single quote characters. For example:</source>
          <target state="translated">В отличие от значений опций и имен столбцов,текстовые литералы SQL,предназначенные в качестве токенов,должны цитироваться с использованием одинарных символов кавычек.Например:</target>
        </trans-unit>
        <trans-unit id="4a575ebe60947d8ad09098452667c713c7ab1bb2" translate="yes" xml:space="preserve">
          <source>Unlike ordinary functions, window functions cannot use the DISTINCT keyword. Also, Window functions may only appear in the result set and in the ORDER BY clause of a SELECT statement.</source>
          <target state="translated">В отличие от обычных функций,оконные функции не могут использовать ключевое слово DISTINCT.Кроме того,функции окон могут появляться только в наборе результатов и в пункте ORDER BY оператора SELECT.</target>
        </trans-unit>
        <trans-unit id="2f67d962c33cac256671fd15a0b1070b30d60167" translate="yes" xml:space="preserve">
          <source>Unlike other OMIT options which make the SQLite library smaller, this option actually increases the size of SQLite and makes it run a little slower. Only use this option if SQLite is being built for an embedded target that does not support WSD.</source>
          <target state="translated">В отличие от других опций OMIT,которые делают библиотеку SQLite меньше,эта опция фактически увеличивает размер SQLite и делает его работу немного медленнее.Используйте эту опцию только в том случае,если SQLite собирается для встроенной цели,которая не поддерживает WSD.</target>
        </trans-unit>
        <trans-unit id="0fc95e0cae6fea6934c86fc94073155aecd6590f" translate="yes" xml:space="preserve">
          <source>Unlike the other journaling modes, &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode=WAL&lt;/a&gt; is persistent. If a process sets WAL mode, then closes and reopens the database, the database will come back in WAL mode. In contrast, if a process sets (for example) PRAGMA journal_mode=TRUNCATE and then closes and reopens the database will come back up in the default rollback mode of DELETE rather than the previous TRUNCATE setting.</source>
          <target state="translated">В отличие от других режимов &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;ведения журнала&lt;/a&gt; , PRAGMA journal_mode = WAL является постоянным. Если процесс устанавливает режим WAL, а затем закрывает и снова открывает базу данных, база данных возвращается в режим WAL. Напротив, если процесс устанавливает (например) PRAGMA journal_mode = TRUNCATE, а затем закрывается и повторно открывается, база данных возвращается в режим отката по умолчанию DELETE, а не в предыдущей настройке TRUNCATE.</target>
        </trans-unit>
        <trans-unit id="3542ed2ff90a29869b311f3e2e4680675b20b4a0" translate="yes" xml:space="preserve">
          <source>Unlike the rollback journals, the master journal does not contain any original database page content. Instead, the master journal contains the full pathnames for rollback journals for every database that is participating in the transaction.</source>
          <target state="translated">В отличие от журналов отката,основной журнал не содержит оригинального содержимого страниц базы данных.Вместо этого,основной журнал содержит полные патнамы откатных журналов для каждой базы данных,участвующей в транзакции.</target>
        </trans-unit>
        <trans-unit id="3dcad4a4f47bac4601655442badbb882f7ce80cb" translate="yes" xml:space="preserve">
          <source>Unlike the rollback journals, the super-journal does not contain any original database page content. Instead, the super-journal contains the full pathnames for rollback journals for every database that is participating in the transaction.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02b418069c25f685f24a747aa6e2e42a4b27661e" translate="yes" xml:space="preserve">
          <source>Unlike the xFilter argument, xConflict may not be passed NULL. The results of passing anything other than a valid function pointer as the xConflict argument are undefined.</source>
          <target state="translated">В отличие от аргумента xFilter,xConflict не может быть передан NULL.Результаты передачи в качестве аргумента xConflict чего-либо,кроме действительного указателя на функцию,неопределенны.</target>
        </trans-unit>
        <trans-unit id="8cc38ff6e04932db1753dbe47e43a46b66cca7d3" translate="yes" xml:space="preserve">
          <source>Unlinked database files</source>
          <target state="translated">Несвязанные файлы базы данных</target>
        </trans-unit>
        <trans-unit id="2e66bd886206de5f2b17ce23c8df1ed8d25d65b5" translate="yes" xml:space="preserve">
          <source>Unlock Notification</source>
          <target state="translated">Уведомление о разблокировке</target>
        </trans-unit>
        <trans-unit id="1129dcb047456b603be7d9e26492484e1ef87d61" translate="yes" xml:space="preserve">
          <source>Unlock the btree to which cursor P1 is pointing so that it can be written by other cursors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc88710cf7a309e590112924b4f0f18efd64749f" translate="yes" xml:space="preserve">
          <source>Unnecessary OP_IsNull, OP_Affinity, and OP_MustBeInt VDBE opcodes are suppressed</source>
          <target state="translated">Ненужные опкоды OP_INull,OP_Affinity и OP_MustBeInt VDBE подавляются.</target>
        </trans-unit>
        <trans-unit id="b028e3e382d48044cb8ac6852f58d5f9280df947" translate="yes" xml:space="preserve">
          <source>Unpinning a database page.</source>
          <target state="translated">Вывод страницы базы данных.</target>
        </trans-unit>
        <trans-unit id="4d158e591edd9ba39fa4326da9d09c5874218ca5" translate="yes" xml:space="preserve">
          <source>Unregister a VFS with the sqlite3_vfs_unregister() interface. If the default VFS is unregistered, another VFS is chosen as the default. The choice for the new VFS is arbitrary.</source>
          <target state="translated">Отменить регистрацию VFS с помощью интерфейса sqlite3_vfs_unregister().Если VFS по умолчанию незарегистрирована,то по умолчанию выбирается другая VFS.Выбор для новой VFS является произвольным.</target>
        </trans-unit>
        <trans-unit id="ef3bbadff8cc850c1a14d5bac3c132d39dd7aef1" translate="yes" xml:space="preserve">
          <source>Unsigned integer counter, incremented with each transaction</source>
          <target state="translated">Беззнаковый целочисленный счетчик,инкрементированный с каждой транзакцией</target>
        </trans-unit>
        <trans-unit id="3c2ab651c10dcd781af9d81861dc05c7e00cd0e4" translate="yes" xml:space="preserve">
          <source>Unused bytes of on the current page or btree</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ae451c5b9e60f30746c607b23e33192b93fe52d" translate="yes" xml:space="preserve">
          <source>Unused padding space. Must be zero.</source>
          <target state="translated">Неиспользованная набивка.Должно быть,ноль.</target>
        </trans-unit>
        <trans-unit id="e3a057d9b649ee6d00a614b6de91fb18fda426f0" translate="yes" xml:space="preserve">
          <source>Unused pages in the database file are stored on a freelist. The 4-byte big-endian integer at offset 32 stores the page number of the first page of the freelist, or zero if the freelist is empty. The 4-byte big-endian integer at offset 36 stores stores the total number of pages on the freelist.</source>
          <target state="translated">Неиспользованные страницы в файле базы данных хранятся во фрилисте.4-байтовое big-endian-целое число со смещением 32 хранит номер первой страницы фрилиста,или ноль,если фрилист пуст.4-байтовое биг-ендианское целое число со смещением 36 хранит общее количество страниц во фрилисте.</target>
        </trans-unit>
        <trans-unit id="533ec3a09a391d616af998c213244ec0a1e5a3cc" translate="yes" xml:space="preserve">
          <source>Unused space reserved for further expansion.</source>
          <target state="translated">Неиспользованное пространство зарезервировано для дальнейшего расширения.</target>
        </trans-unit>
        <trans-unit id="c494dd09b1047ff61f225fbdc40bf010e62739a8" translate="yes" xml:space="preserve">
          <source>Unused space set aside for 8 file locks.</source>
          <target state="translated">Неиспользованное пространство отведено под 8 файловых замков.</target>
        </trans-unit>
        <trans-unit id="6ccb1ae240f52b5b4ac6a0a3624ae84ecc9e72d1" translate="yes" xml:space="preserve">
          <source>Up to 32K columns in a table and unlimited rows</source>
          <target state="translated">До 32K столбцов в таблице и неограниченное количество строк</target>
        </trans-unit>
        <trans-unit id="6b12c595d758d017b4f8b2df393f1e4bc59a0386" translate="yes" xml:space="preserve">
          <source>Up to 64-way joins</source>
          <target state="translated">До 64-сторонних соединений</target>
        </trans-unit>
        <trans-unit id="cb305c54c2dd32659178ffaaae86eb202de286b0" translate="yes" xml:space="preserve">
          <source>Upcoming maintenance releases announced on the sqlite-users and sqlite-dev &lt;a href=&quot;https://sqlite.org/support.html#mailinglists&quot;&gt;mailing lists&lt;/a&gt; about two weeks prior to the anticipated release. Approximately one week prior to release, the lead developer declares &quot;pencils down&quot; after which only bug-fix check-ins are allowed on trunk. A new &lt;a href=&quot;https://sqlite.org/checklists&quot;&gt;release checklist&lt;/a&gt; is created and updated as needed. As items of the checklist are verified, they are checked off and turn green. The release occurs when all elements of the checklist are green. That process normally takes about a week.</source>
          <target state="translated">О предстоящих выпусках обслуживания объявлено в &lt;a href=&quot;https://sqlite.org/support.html#mailinglists&quot;&gt;списках рассылки&lt;/a&gt; sqlite-users и sqlite-dev примерно за две недели до ожидаемого выпуска. Примерно за неделю до выпуска ведущий разработчик объявляет &amp;laquo;карандаш вниз&amp;raquo;, после чего в основной ветке разрешены только исправления ошибок. Контрольный &lt;a href=&quot;https://sqlite.org/checklists&quot;&gt;список&lt;/a&gt; новой версии создается и обновляется по мере необходимости. По мере проверки элементов контрольного списка они отключаются и становятся зелеными. Выпуск происходит, когда все элементы контрольного списка становятся зелеными. Обычно этот процесс занимает около недели.</target>
        </trans-unit>
        <trans-unit id="8621615ea5e13954070618a81964dc62abe12dff" translate="yes" xml:space="preserve">
          <source>Update 2003-07-13:</source>
          <target state="translated">Обновление 2003-07-13:</target>
        </trans-unit>
        <trans-unit id="e6d951c5abc007e402d1496a11b3024eba850b99" translate="yes" xml:space="preserve">
          <source>Update cygwin interfaces to omit deprecated API calls.</source>
          <target state="translated">Обновите интерфейсы cygwin,чтобы исключить устаревшие вызовы API.</target>
        </trans-unit>
        <trans-unit id="f8692a500a2140ecfbdf4ae0b2b2fa362f3e4d18" translate="yes" xml:space="preserve">
          <source>Update on 2018-11-24: This section was important when the NGQP was new. But five years have elapsed, the NGQP has been deployed successfully to billions of devices, and everyone has upgraded. The upgrade hazard has vanished. This section is retained for historical reference only. Modern reads can skip ahead to the &lt;a href=&quot;queryplanner-ng#howtofix&quot;&gt;query planner checklist&lt;/a&gt;.</source>
          <target state="translated">Обновление от 24.11.2018: этот раздел был важен, когда NGQP был новым. Но прошло пять лет, NGQP был успешно развернут на миллиардах устройств, и все обновились. Опасность обновления исчезла. Этот раздел сохранен только для исторической справки. При современном чтении можно сразу перейти к &lt;a href=&quot;queryplanner-ng#howtofix&quot;&gt;контрольному списку планировщика запросов&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f7a5f87f2cf88e6e7e5e6ca7b270c03397b5d3d9" translate="yes" xml:space="preserve">
          <source>Update or delete the row in the parent table,</source>
          <target state="translated">Обновить или удалить строку в родительской таблице,</target>
        </trans-unit>
        <trans-unit id="eadf20cb1fcf64b516be4d0e9aca0f806ea0946c" translate="yes" xml:space="preserve">
          <source>Update the &quot;.import&quot; command in the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; to support multi-line fields and correct RFC-4180 quoting and to issue warning and/or error messages if the input text is not strictly RFC-4180 compliant.</source>
          <target state="translated">Обновите команду &amp;laquo;.import&amp;raquo; в &lt;a href=&quot;cli&quot;&gt;оболочке командной строки&lt;/a&gt; для поддержки многострочных полей и исправления цитирования RFC-4180, а также для выдачи предупреждений и / или сообщений об ошибках, если вводимый текст не строго соответствует RFC-4180.</target>
        </trans-unit>
        <trans-unit id="95e555f2b3f8baa46d6d1c3fa11a385e51f02eb2" translate="yes" xml:space="preserve">
          <source>Update the &lt;a href=&quot;rtree&quot;&gt;R-Tree extension&lt;/a&gt; to make use of the enhanced virtual table interface.</source>
          <target state="translated">Обновите &lt;a href=&quot;rtree&quot;&gt;расширение R-Tree,&lt;/a&gt; чтобы использовать расширенный интерфейс виртуальной таблицы.</target>
        </trans-unit>
        <trans-unit id="afd4ef5f9984771affe8a02ef21dc1f52c746e3a" translate="yes" xml:space="preserve">
          <source>Update the NULL-handling documentation.</source>
          <target state="translated">Обновите документацию по NULL-обработке.</target>
        </trans-unit>
        <trans-unit id="8eb7bca41bb60469d609f31a7c94a8af987dd0b7" translate="yes" xml:space="preserve">
          <source>Update the _FILE_OFFSET_BITS macro so that builds work again on QNX.</source>
          <target state="translated">Обновите макрос _FILE_OFFSET_BITS так,чтобы сборка снова работала на QNX.</target>
        </trans-unit>
        <trans-unit id="83db802c5575f2f5c375cb1b62089d3a370412c6" translate="yes" xml:space="preserve">
          <source>Update the banner on the command-line shell to alert novice users when they are using an ephemeral in-memory database.</source>
          <target state="translated">Обновите баннер в командной строке оболочки,чтобы предупреждать начинающих пользователей,когда они используют эфемерную базу данных in-memory.</target>
        </trans-unit>
        <trans-unit id="5deccb253aff130770ec3068052cf362ce9ebe27" translate="yes" xml:space="preserve">
          <source>Update the built-in &lt;a href=&quot;fts3&quot;&gt;FTS3/FTS4&lt;/a&gt; and &lt;a href=&quot;rtree&quot;&gt;RTREE&lt;/a&gt; virtual tables to support &lt;a href=&quot;lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt; clauses and &lt;a href=&quot;lang_replace&quot;&gt;REPLACE&lt;/a&gt;.</source>
          <target state="translated">Обновите встроенные виртуальные таблицы &lt;a href=&quot;fts3&quot;&gt;FTS3 / FTS4&lt;/a&gt; и &lt;a href=&quot;rtree&quot;&gt;RTREE&lt;/a&gt; для поддержки предложений &lt;a href=&quot;lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt; и &lt;a href=&quot;lang_replace&quot;&gt;REPLACE&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b504122b8dfef94ab33eb2666fd1889d16053291" translate="yes" xml:space="preserve">
          <source>Update the text of error messages returned by &lt;a href=&quot;c3ref/errcode&quot;&gt;sqlite3_errmsg()&lt;/a&gt; for some error codes.</source>
          <target state="translated">Обновите текст сообщений об ошибках, возвращаемых &lt;a href=&quot;c3ref/errcode&quot;&gt;sqlite3_errmsg (),&lt;/a&gt; для некоторых кодов ошибок.</target>
        </trans-unit>
        <trans-unit id="f19ef97f712dc9336cd9881c1cc678760d93cdf8" translate="yes" xml:space="preserve">
          <source>Update: As of SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_29_0.html&quot;&gt;version 3.29.0&lt;/a&gt; (2019-07-10) the use of AFL has been superceded by the new &lt;a href=&quot;testing#dbsqlfuzz&quot;&gt;dbsqlfuzz&lt;/a&gt; fuzzer described below.</source>
          <target state="translated">Обновление: Начиная с &lt;a href=&quot;https://sqlite.org/releaselog/3_29_0.html&quot;&gt;версии&lt;/a&gt; SQLite 3.29.0 (10.07.2019) использование AFL было &lt;a href=&quot;testing#dbsqlfuzz&quot;&gt;заменено&lt;/a&gt; новым фаззером dbsqlfuzz, описанным ниже.</target>
        </trans-unit>
        <trans-unit id="c202e0c1d72e2322ab1803ee32b5877979d2de60" translate="yes" xml:space="preserve">
          <source>Update: New measurements for SQLite version 3.19.0 (2017-05-22) show that SQLite is about &lt;a href=&quot;fasterthanfs&quot;&gt;35% faster&lt;/a&gt; than direct disk I/O for both reads and writes of 10KB blobs.</source>
          <target state="translated">Обновление: новые измерения для SQLite версии 3.19.0 (2017-05-22) показывают, что SQLite примерно на &lt;a href=&quot;fasterthanfs&quot;&gt;35% быстрее,&lt;/a&gt; чем прямой дисковый ввод-вывод как для чтения, так и для записи больших двоичных объектов размером 10 КБ.</target>
        </trans-unit>
        <trans-unit id="a960dbfb2b124d6ed06bf7e934a25380bb894d60" translate="yes" xml:space="preserve">
          <source>Update: The &lt;a href=&quot;lang_vacuum#vacuuminto&quot;&gt;VACUUM INTO&lt;/a&gt; command introduced in SQLite version 3.27.0 (2019-02-07) can serve as an alternative to the backup API.</source>
          <target state="translated">Обновление: команда &lt;a href=&quot;lang_vacuum#vacuuminto&quot;&gt;VACUUM INTO,&lt;/a&gt; представленная в SQLite версии 3.27.0 (2019-02-07), может служить альтернативой API резервного копирования.</target>
        </trans-unit>
        <trans-unit id="ae9f91d2ff06391addf58fdcc8dd4af3777ab8ac" translate="yes" xml:space="preserve">
          <source>Updated the &quot;unix-dotfile&quot; &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; to use locking directories with mkdir() and rmdir() instead of locking files with open() and unlink().</source>
          <target state="translated">Обновлена &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; &quot;unix-dotfile&quot;, чтобы использовать директории блокировки с помощью mkdir () и rmdir () вместо блокировки файлов с помощью open () и unlink ().</target>
        </trans-unit>
        <trans-unit id="9ecd4cacc54f9eb845eb05b8c1cec0b8deaabeb2" translate="yes" xml:space="preserve">
          <source>Updated the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; so that it can be built using &lt;a href=&quot;compile#omit_floating_point&quot;&gt;SQLITE_OMIT_FLOATING_POINT&lt;/a&gt; and &lt;a href=&quot;compile#omit_autoinit&quot;&gt;SQLITE_OMIT_AUTOINIT&lt;/a&gt;.</source>
          <target state="translated">Обновлена &lt;a href=&quot;cli&quot;&gt;оболочка командной строки,&lt;/a&gt; чтобы ее можно было построить с использованием &lt;a href=&quot;compile#omit_floating_point&quot;&gt;SQLITE_OMIT_FLOATING_POINT&lt;/a&gt; и &lt;a href=&quot;compile#omit_autoinit&quot;&gt;SQLITE_OMIT_AUTOINIT&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ae68475963e11d8ffb9d1743f7f05f6343c16e81" translate="yes" xml:space="preserve">
          <source>Updated the &lt;a href=&quot;nulls&quot;&gt;NULL-handling document&lt;/a&gt;.</source>
          <target state="translated">Обновлен &lt;a href=&quot;nulls&quot;&gt;документ с обработкой NULL&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2cc8e0782c7a9b456827f5ac2f3deff6afb93a61" translate="yes" xml:space="preserve">
          <source>Updated the documentation for due to the above change.</source>
          <target state="translated">Обновлена документация в связи с вышеуказанными изменениями.</target>
        </trans-unit>
        <trans-unit id="e10ae62e4bb036329cb9ea0d831ba16069afdf6b" translate="yes" xml:space="preserve">
          <source>Updates to &lt;a href=&quot;c3ref/stmt_readonly&quot;&gt;sqlite3_stmt_readonly()&lt;/a&gt; so that its result is well-defined for all prepared statements and so that it works with &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt;.</source>
          <target state="translated">Обновления &lt;a href=&quot;c3ref/stmt_readonly&quot;&gt;sqlite3_stmt_readonly ()&lt;/a&gt; , так что результат хорошо определены для всех подготовленных заявлений и так , что он работает с &lt;a href=&quot;lang_vacuum&quot;&gt;ВАКУУМОМ&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="611a149936e51e86e5dc517a30918e94113a5c96" translate="yes" xml:space="preserve">
          <source>Updates to comments and documentation.</source>
          <target state="translated">Обновления к комментариям и документации.</target>
        </trans-unit>
        <trans-unit id="5cd9f8d0a6523c89d101b12728ca830f506daa93" translate="yes" xml:space="preserve">
          <source>Updates to the FAQ</source>
          <target state="translated">Обновления в FAQ</target>
        </trans-unit>
        <trans-unit id="225b3af8e67127ee3d34043567f27a4b206ed152" translate="yes" xml:space="preserve">
          <source>Updates to the co-hosted &lt;a href=&quot;lemon&quot;&gt;Lemon LALR(1) parser generator&lt;/a&gt;. (These updates did not affect SQLite.)</source>
          <target state="translated">Обновления совместно размещенного &lt;a href=&quot;lemon&quot;&gt;генератора синтаксического анализатора Lemon LALR (1)&lt;/a&gt; . (Эти обновления не повлияли на SQLite.)</target>
        </trans-unit>
        <trans-unit id="5ff086f286850610a359720beb1814b02bde490c" translate="yes" xml:space="preserve">
          <source>Updates to the man page</source>
          <target state="translated">Обновления на странице man</target>
        </trans-unit>
        <trans-unit id="0b579189066ad6233ab9a30e75015931b715153e" translate="yes" xml:space="preserve">
          <source>Upgrade to an</source>
          <target state="translated">Обновление до</target>
        </trans-unit>
        <trans-unit id="fa23bdbf593290f21c99984edfe7206d0b3f48ab" translate="yes" xml:space="preserve">
          <source>Upgraded the &lt;a href=&quot;c3ref/uri_boolean&quot;&gt;sqlite3_uri_parameter()&lt;/a&gt; function so that it works with the rollback journal or WAL filename in addition to the database filename.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54e621618c30d2d51e0e7eb2f7c9980b70d460c6" translate="yes" xml:space="preserve">
          <source>Upgrading SQLite, Backwards Compatibility</source>
          <target state="translated">Обновление SQLite,обратная совместимость</target>
        </trans-unit>
        <trans-unit id="f63424e9ccf9758aa115a08c1ca29da89505f175" translate="yes" xml:space="preserve">
          <source>Upgrading to an Exclusive Lock</source>
          <target state="translated">Обновление до эксклюзивного замка</target>
        </trans-unit>
        <trans-unit id="0b7b831bc0dc4db0969e61d108d5ed08e60a2a5a" translate="yes" xml:space="preserve">
          <source>Usable size</source>
          <target state="translated">Полезный размер</target>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="translated">Usage</target>
        </trans-unit>
        <trans-unit id="f7d660e7e185b02ed0b42d1ed9b98bb6209a9521" translate="yes" xml:space="preserve">
          <source>Use &quot;&lt;code&gt;#include &amp;lt;sqlite3ext.h&amp;gt;&lt;/code&gt;&quot; at the top of your source code files instead of &quot;&lt;code&gt;#include &amp;lt;sqlite3.h&amp;gt;&lt;/code&gt;&quot;.</source>
          <target state="translated">Используйте &quot; &lt;code&gt;#include &amp;lt;sqlite3ext.h&amp;gt;&lt;/code&gt; &quot; в верхней части файлов исходного кода вместо &quot; &lt;code&gt;#include &amp;lt;sqlite3.h&amp;gt;&lt;/code&gt; &quot;.</target>
        </trans-unit>
        <trans-unit id="62e753b43ef69616b1563515522f39fb45747e31" translate="yes" xml:space="preserve">
          <source>Use &quot;trunk&quot; for</source>
          <target state="translated">Используйте &quot;багажник&quot; для</target>
        </trans-unit>
        <trans-unit id="237aa140efed61c820a219860ca38adb64fb7ec3" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;lang_corefunc#replace&quot;&gt;replace()&lt;/a&gt; instead of &lt;a href=&quot;lang_corefunc#char&quot;&gt;char()&lt;/a&gt; for escaping newline and carriage-return characters embedded in strings in the .dump output from the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt;.</source>
          <target state="translated">Используйте &lt;a href=&quot;lang_corefunc#replace&quot;&gt;replace ()&lt;/a&gt; вместо &lt;a href=&quot;lang_corefunc#char&quot;&gt;char ()&lt;/a&gt; для экранирования символов новой строки и возврата каретки, встроенных в строки в выводе .dump из &lt;a href=&quot;cli&quot;&gt;оболочки командной строки&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c7a8d415f6b6311567858afd10504aff2606d36c" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt;, &lt;a href=&quot;lang_createtrigger&quot;&gt;CREATE TRIGGER&lt;/a&gt;, and &lt;a href=&quot;lang_createview&quot;&gt;CREATE VIEW&lt;/a&gt; to reconstruct indexes, triggers, and views associated with table X. Perhaps use the old format of the triggers, indexes, and views saved from step 3 above as a guide, making changes as appropriate for the alteration.</source>
          <target state="translated">Используйте &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt; , &lt;a href=&quot;lang_createtrigger&quot;&gt;CREATE TRIGGER&lt;/a&gt; и &lt;a href=&quot;lang_createview&quot;&gt;CREATE VIEW&lt;/a&gt; для восстановления индексов, триггеров и представлений, связанных с таблицей X. Возможно, используйте старый формат триггеров, индексов и представлений, сохраненных с шага 3 выше, в качестве руководства, внося необходимые изменения для переделка.</target>
        </trans-unit>
        <trans-unit id="536befb3634409293843309bd592f3735064b803" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; to construct a new table &quot;new_X&quot; that is in the desired revised format of table X. Make sure that the name &quot;new_X&quot; does not collide with any existing table name, of course.</source>
          <target state="translated">Используйте &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; для создания новой таблицы &amp;laquo;new_X&amp;raquo;, которая находится в желаемом измененном формате таблицы X. Конечно, убедитесь, что имя &amp;laquo;new_X&amp;raquo; не конфликтует с каким-либо существующим именем таблицы.</target>
        </trans-unit>
        <trans-unit id="4324752dc06a9ac4571627fdbc5052d079c7ceec" translate="yes" xml:space="preserve">
          <source>Use a &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt; statement to create a new index on one or more expressions just like you would to create an index on columns. The only difference is that expressions are listed as the elements to be indexed rather than column names.</source>
          <target state="translated">Используйте оператор &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX,&lt;/a&gt; чтобы создать новый индекс для одного или нескольких выражений, как если бы вы создавали индекс для столбцов. Единственное отличие состоит в том, что выражения указываются как элементы для индексации, а не как имена столбцов.</target>
        </trans-unit>
        <trans-unit id="7496f7181dc9302ddc248c78082db1a132361364" translate="yes" xml:space="preserve">
          <source>Use a negative column width for right-justified columns.</source>
          <target state="translated">Для правого столбца используйте отрицательную ширину столбца.</target>
        </trans-unit>
        <trans-unit id="5ed5b81249d213d275afc651f4e6fd002e1e541a" translate="yes" xml:space="preserve">
          <source>Use a separate mutex on every inode in the unix &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;, rather than a single mutex shared among them all, for slightly better concurrency in multi-threaded environments.</source>
          <target state="translated">Используйте отдельный мьютекс для каждого inode в unix &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; , а не один мьютекс, общий для всех, для немного лучшего параллелизма в многопоточных средах.</target>
        </trans-unit>
        <trans-unit id="de146a75582fa0d61aaa74e50c8ce2d58d1921c8" translate="yes" xml:space="preserve">
          <source>Use an index to satisfy an IS NULL operator in the WHERE clause</source>
          <target state="translated">Использование индекса для удовлетворения оператора IS NULL в пункте WHERE</target>
        </trans-unit>
        <trans-unit id="6bdba762bb27236a6cb868fd917b885a3fb66243" translate="yes" xml:space="preserve">
          <source>Use compiler built-ins __builtin_sub_overflow(), __builtin_add_overflow(), and __builtin_mul_overflow() when available. (All compiler built-ins can be omitted with the &lt;a href=&quot;compile#disable_intrinsic&quot;&gt;SQLITE_DISABLE_INTRINSIC&lt;/a&gt; compile-time option.)</source>
          <target state="translated">Используйте встроенные функции компилятора __builtin_sub_overflow (), __builtin_add_overflow () и __builtin_mul_overflow (), если они доступны. (Все встроенные &lt;a href=&quot;compile#disable_intrinsic&quot;&gt;компоненты&lt;/a&gt; компилятора могут быть опущены с помощью параметра времени компиляции SQLITE_DISABLE_INTRINSIC .)</target>
        </trans-unit>
        <trans-unit id="137cf73aa42452fce0415a41813408b4501767a7" translate="yes" xml:space="preserve">
          <source>Use either disk or memory storage for temporary files as determined by the &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; compile-time parameter.</source>
          <target state="translated">Используйте диск или память для временных файлов, как определено параметром времени компиляции &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2af669874066cde2346e922c573e9e835ac690a1" translate="yes" xml:space="preserve">
          <source>Use fdatasync() instead of fsync() where possible in order to speed up commits slightly</source>
          <target state="translated">Используйте fdatasync()вместо fsync(),где это возможно,чтобы немного ускорить коммиты.</target>
        </trans-unit>
        <trans-unit id="50f06d5432236287d8673fac9ba31c9f7a72e979" translate="yes" xml:space="preserve">
          <source>Use files by default but allow the &lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;PRAGMA temp_store&lt;/a&gt; command to override</source>
          <target state="translated">Использовать файлы по умолчанию, но разрешить команде &lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;PRAGMA temp_store&lt;/a&gt; переопределить</target>
        </trans-unit>
        <trans-unit id="263a25f617f6abfd3d532ea4693a64ebfdbddfbe" translate="yes" xml:space="preserve">
          <source>Use heap space instead of stack space for large buffers in the pager - useful on embedded platforms with stack-space limitations.</source>
          <target state="translated">Использовать пространство кучи вместо пространства стека для больших буферов на пейджере-полезно на встраиваемых платформах с ограничениями по стековому пространству.</target>
        </trans-unit>
        <trans-unit id="3a48cc9a1a2d824c57ec5e25aeb6cff31334d1e8" translate="yes" xml:space="preserve">
          <source>Use indices to help with GLOB expressions and LIKE expressions too when the case_sensitive_like pragma is enabled</source>
          <target state="translated">Используйте индексы для помощи с GLOB-выражениями и LIKE-выражениями тоже,когда включена прагма типа case_sensitive_like</target>
        </trans-unit>
        <trans-unit id="bc1fcae1e921cce9fd520fbec66677338b3c72ed" translate="yes" xml:space="preserve">
          <source>Use less memory by not remembering CHECK constraints on read-only database connections.</source>
          <target state="translated">Используйте меньше памяти,не запоминая ограничения CHECK на подключения к БД только для чтения.</target>
        </trans-unit>
        <trans-unit id="0f855b65765fc8c17befd3c681198b2b5b5c7616" translate="yes" xml:space="preserve">
          <source>Use memmove() instead of memcpy() when moving between memory regions that might overlap. Ticket #2334</source>
          <target state="translated">Используйте memmove()вместо memcpy()при перемещении между областями памяти,которые могут перекрываться.Тикет #2334</target>
        </trans-unit>
        <trans-unit id="469854fc5e213a56cb9e96864bf70b794360aa2e" translate="yes" xml:space="preserve">
          <source>Use memory by default but allow the &lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;PRAGMA temp_store&lt;/a&gt; command to override</source>
          <target state="translated">Использовать память по умолчанию, но разрешить команде &lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;PRAGMA temp_store&lt;/a&gt; переопределить</target>
        </trans-unit>
        <trans-unit id="48a8e3645a8edde160a5adbd651d1d588f3d82af" translate="yes" xml:space="preserve">
          <source>Use of the CROSS keyword in a join turns off the table reordering optimization</source>
          <target state="translated">Использование ключевого слова CROSS в соединении отключает оптимизацию переупорядочивания таблицы</target>
        </trans-unit>
        <trans-unit id="4efb979f35de88aa03beb8b52191a1054ccebd97" translate="yes" xml:space="preserve">
          <source>Use single-quotes, not double-quotes, around string literals in SQL. This is what the SQL standard requires. Your WHERE clause expression should read: &lt;code&gt;column1='column1'&lt;/code&gt;</source>
          <target state="translated">Используйте одинарные, а не двойные кавычки вокруг строковых литералов в SQL. Это то, что требует стандарт SQL. Ваше выражение предложения WHERE должно читать: &lt;code&gt;column1='column1'&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dc43b1a2c6a31ffdd8561f57d1fbf734126319be" translate="yes" xml:space="preserve">
          <source>Use sqlite3_mprintf() instead of strdup() to avoid libc dependencies</source>
          <target state="translated">Используйте sqlite3_mprintf()вместо strdup(),чтобы избежать зависимостей libc.</target>
        </trans-unit>
        <trans-unit id="b154d5767d626fe947b811cbac8223761d775253" translate="yes" xml:space="preserve">
          <source>Use the &quot;.dump&quot; command to convert the entire contents of a database into a single ASCII text file. This file can be converted back into a database by piping it back into &lt;b&gt;sqlite3&lt;/b&gt;.</source>
          <target state="translated">Используйте команду &amp;laquo;.dump&amp;raquo; для преобразования всего содержимого базы данных в один текстовый файл ASCII. Этот файл можно преобразовать обратно в базу данных, вернув его в &lt;b&gt;sqlite3&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="031acdfcfcb7c6ac30666a1a6360f5fb4b5b9407" translate="yes" xml:space="preserve">
          <source>Use the &quot;.import&quot; command to import CSV (comma separated value) data into an SQLite table. The &quot;.import&quot; command takes two arguments which are the name of the disk file from which CSV data is to be read and the name of the SQLite table into which the CSV data is to be inserted.</source>
          <target state="translated">С помощью команды &quot;.import&quot; импортируйте данные в формате CSV (значение,разделенное запятыми)в таблицу SQLite.Команда &quot;.import&quot; принимает два аргумента:имя дискового файла,из которого должны быть прочитаны данные CSV,и имя таблицы SQLite,в которую должны быть вставлены данные CSV.</target>
        </trans-unit>
        <trans-unit id="1514a3f709961a8c5a81dddff2a1805d46c2a271" translate="yes" xml:space="preserve">
          <source>Use the &quot;.separator&quot; dot command to change the separator. For example, to change the separator to a comma and a space, you could do this:</source>
          <target state="translated">Для изменения разделителя используйте точечную команду &quot;.разделитель&quot;.Например,чтобы изменить разделитель на запятую и пробел,можно сделать это:</target>
        </trans-unit>
        <trans-unit id="7e3a1db63b5ffcfa0304033285d6169940ca5e9f" translate="yes" xml:space="preserve">
          <source>Use the &quot;&lt;code&gt;fossil ui&lt;/code&gt;&quot; command from within the ~/sqlite checkout to bring up a local copy of the website.</source>
          <target state="translated">Используйте команду &amp;laquo; &lt;code&gt;fossil ui&lt;/code&gt; &amp;raquo; из ~ / sqlite checkout, чтобы открыть локальную копию веб-сайта.</target>
        </trans-unit>
        <trans-unit id="2314ee65a646ac667a54b17ec0394586fd245f83" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;#sqlite3_blob_bytes&quot;&gt;sqlite3_blob_bytes()&lt;/a&gt; interface to determine the size of the opened blob. The size of a blob may not be changed by this interface. Use the &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; SQL command to change the size of a blob.</source>
          <target state="translated">Используйте интерфейс &lt;a href=&quot;#sqlite3_blob_bytes&quot;&gt;sqlite3_blob_bytes (),&lt;/a&gt; чтобы определить размер открытого большого двоичного объекта. Этот интерфейс не может изменять размер большого двоичного объекта. Используйте команду &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; SQL, чтобы изменить размер большого двоичного объекта.</target>
        </trans-unit>
        <trans-unit id="36f9cf35dec4a270350f0bd2263a94cc3699ef47" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;blob_bytes&quot;&gt;sqlite3_blob_bytes()&lt;/a&gt; interface to determine the size of the opened blob. The size of a blob may not be changed by this interface. Use the &lt;a href=&quot;../lang_update&quot;&gt;UPDATE&lt;/a&gt; SQL command to change the size of a blob.</source>
          <target state="translated">Используйте интерфейс &lt;a href=&quot;blob_bytes&quot;&gt;sqlite3_blob_bytes (),&lt;/a&gt; чтобы определить размер открытого большого двоичного объекта. Этот интерфейс не может изменять размер большого двоичного объекта. Используйте команду &lt;a href=&quot;../lang_update&quot;&gt;UPDATE&lt;/a&gt; SQL, чтобы изменить размер большого двоичного объекта.</target>
        </trans-unit>
        <trans-unit id="bd4ed3d4650cd4e7bc264eb1acc9e459a702bd1f" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE&lt;/a&gt; compile-time parameter to selected the threading mode. If no &lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE&lt;/a&gt; compile-time parameter is present, then serialized mode is used. This can be made explicit with &lt;a href=&quot;compile#threadsafe&quot;&gt;-DSQLITE_THREADSAFE=1&lt;/a&gt;. With &lt;a href=&quot;compile#threadsafe&quot;&gt;-DSQLITE_THREADSAFE=0&lt;/a&gt; the threading mode is single-thread. With &lt;a href=&quot;compile#threadsafe&quot;&gt;-DSQLITE_THREADSAFE=2&lt;/a&gt; the threading mode is multi-thread.</source>
          <target state="translated">Используйте параметр &lt;a href=&quot;compile#threadsafe&quot;&gt;времени&lt;/a&gt; компиляции SQLITE_THREADSAFE, чтобы выбрать режим потоковой передачи. Если параметр времени компиляции &lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE&lt;/a&gt; отсутствует, используется сериализованный режим. Это можно сделать явным с &lt;a href=&quot;compile#threadsafe&quot;&gt;-DSQLITE_THREADSAFE = 1&lt;/a&gt; . С &lt;a href=&quot;compile#threadsafe&quot;&gt;-DSQLITE_THREADSAFE = 0&lt;/a&gt; режим потоковой передачи является однопоточным. С &lt;a href=&quot;compile#threadsafe&quot;&gt;-DSQLITE_THREADSAFE = 2&lt;/a&gt; режим многопоточности.</target>
        </trans-unit>
        <trans-unit id="274f4747a1320d774731188d128cb3683b032794" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;optoverview#like_opt&quot;&gt;LIKE optimization&lt;/a&gt; even if the right-hand side string contains no wildcards.</source>
          <target state="translated">Используйте &lt;a href=&quot;optoverview#like_opt&quot;&gt;оптимизацию LIKE,&lt;/a&gt; даже если правая строка не содержит подстановочных знаков.</target>
        </trans-unit>
        <trans-unit id="1f4e51240cb42418de496e090c0f24ccbb024987" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;pragma#pragma_trusted_schema&quot;&gt;PRAGMA trusted_schema=OFF&lt;/a&gt; SQL statement to disable trusted schema. This has the same effect as the previous bullet, but does not require the use of C-code and hence can be performed in programs written in another programming language and that do not have access SQLite C-language APIs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5308e85c61acbd7495be650845b12311f9dc3964" translate="yes" xml:space="preserve">
          <source>Use the &lt;b&gt;sqlite_open&lt;/b&gt; function to open an existing SQLite database or to create a new SQLite database. The first argument is the database name. The second argument is intended to signal whether the database is going to be used for reading and writing or just for reading. But in the current implementation, the second argument to &lt;b&gt;sqlite_open&lt;/b&gt; is ignored. The third argument is a pointer to a string pointer. If the third argument is not NULL and an error occurs while trying to open the database, then an error message will be written to memory obtained from malloc() and *errmsg will be made to point to this error message. The calling function is responsible for freeing the memory when it has finished with it.</source>
          <target state="translated">Используйте функцию &lt;b&gt;sqlite_open,&lt;/b&gt; чтобы открыть существующую базу данных SQLite или создать новую базу данных SQLite. Первый аргумент - это имя базы данных. Второй аргумент предназначен для обозначения того, будет ли база данных использоваться для чтения и записи или только для чтения. Но в текущей реализации второй аргумент &lt;b&gt;sqlite_open&lt;/b&gt; игнорируется. Третий аргумент - указатель на указатель строки. Если третий аргумент не равен NULL и при попытке открыть базу данных возникает ошибка, то в память будет записано сообщение об ошибке, полученное из malloc (), и * errmsg будет указывать на это сообщение об ошибке. Вызывающая функция отвечает за освобождение памяти по завершении работы с ней.</target>
        </trans-unit>
        <trans-unit id="c6d46e33d7807116ac9add91d72550fca2ffbf23" translate="yes" xml:space="preserve">
          <source>Use the WHERE clause to reduce the size of a materialized VIEW in an UPDATE or DELETE statement. (Optimization)</source>
          <target state="translated">Используйте пункт ГДЕ для уменьшения размера материализованного VIEW в заявлении UPDATE или DELETE.(Оптимизация)</target>
        </trans-unit>
        <trans-unit id="efe8cfb25313b8ffdcda22d1d22b3397432240d2" translate="yes" xml:space="preserve">
          <source>Use the correct affinity for columns of automatic indexes. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/7ffd1ca1d2ad4ec&quot;&gt;7ffd1ca1d2ad4ec&lt;/a&gt;.</source>
          <target state="translated">Используйте правильную привязку для столбцов автоматических индексов. Билет &lt;a href=&quot;https://www.sqlite.org/src/info/7ffd1ca1d2ad4ec&quot;&gt;7ffd1ca1d2ad4ec&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4d6f456699b36362dd68589f9f76baf09757ec2f" translate="yes" xml:space="preserve">
          <source>Use the decimal_cmp(A,B) to compare two decimal values. The result will be negative, zero, or positive if A is less than, equal to, or greater than B, respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8484df7605c1331750609f898da67fe4dcaeabf" translate="yes" xml:space="preserve">
          <source>Use the macro SQLITE_PRIVATE (defaulting to &quot;static&quot;) on all internal functions in the amalgamation.</source>
          <target state="translated">Используйте макрос SQLITE_PRIVATE (по умолчанию-&quot;статический&quot;)для всех внутренних функций в слиянии.</target>
        </trans-unit>
        <trans-unit id="bc78bf67fa7d6c1c485c06940843c7741c22f19b" translate="yes" xml:space="preserve">
          <source>Use the new &lt;a href=&quot;c3ref/blob_reopen&quot;&gt;sqlite3_blob_reopen()&lt;/a&gt; interface to improve the performance of FTS.</source>
          <target state="translated">Используйте новый интерфейс &lt;a href=&quot;c3ref/blob_reopen&quot;&gt;sqlite3_blob_reopen (),&lt;/a&gt; чтобы повысить производительность FTS.</target>
        </trans-unit>
        <trans-unit id="3b2244da3774583cbb3fc1a48e72dfd44d3ab95d" translate="yes" xml:space="preserve">
          <source>Use the normal SQLite API to read and write to databases via the asynchronous IO VFS.</source>
          <target state="translated">Используйте обычный SQLite API для чтения и записи в базы данных через асинхронную IO VFS.</target>
        </trans-unit>
        <trans-unit id="26f92b5c0905f544db1bb7d8ca5ebd0ed63e16d8" translate="yes" xml:space="preserve">
          <source>Use the resulting &quot;kvtest&quot; program to generate a test database with 100,000 random uncompressible blobs, each with a random size between 8,000 and 12,000 bytes using a command like this:</source>
          <target state="translated">Используйте полученную программу &quot;kvtest&quot; для создания тестовой базы данных со 100,000 случайными несжимаемыми блоками,каждый из которых имеет случайный размер от 8,000 до 12,000 байт,с помощью такой команды:</target>
        </trans-unit>
        <trans-unit id="7834abce7ece24f8701462e346703566e2de3e27" translate="yes" xml:space="preserve">
          <source>Use the schema-defined &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt; instead of the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; to pair rows in the source and destination database. (See additional explanation below.)</source>
          <target state="translated">Используйте &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY,&lt;/a&gt; определенный схемой, вместо &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; для пары строк в исходной и целевой базе данных. (См. Дополнительное объяснение ниже.)</target>
        </trans-unit>
        <trans-unit id="02df1e951c416cb903ab43afc2694bfdea186be2" translate="yes" xml:space="preserve">
          <source>Use the strcspn() C-library routine to speed up the LIKE and GLOB operators.</source>
          <target state="translated">Используйте C-библиотечную рутину strcspn()для ускорения работы операторов LIKE и GLOB.</target>
        </trans-unit>
        <trans-unit id="f1f443135d8d6987de124f0e64e3f9227d9a5c27" translate="yes" xml:space="preserve">
          <source>Use the transitive property to try to propagate constant values within the WHERE clause. For example, convert &quot;a=99 AND b=a&quot; into &quot;a=99 AND b=99&quot;.</source>
          <target state="translated">Используйте переходное свойство,чтобы попытаться распространить постоянные значения в пределах пункта WHERE.Например,преобразовать &quot;a=99 И b=a&quot; в &quot;a=99 И b=99&quot;.</target>
        </trans-unit>
        <trans-unit id="0ea0700fa56071e98d4cc761a6e621b61eff1903" translate="yes" xml:space="preserve">
          <source>Use the unicode API in Windows</source>
          <target state="translated">Используйте API Юникод в Windows</target>
        </trans-unit>
        <trans-unit id="97776a8d79289b0d1017fb264bc954bd7ad83946" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#aggregate-function-invocation&quot;&gt;aggregate-function-invocation&lt;/a&gt;&lt;a href=&quot;#attach-stmt&quot;&gt;attach-stmt&lt;/a&gt;&lt;a href=&quot;#column-constraint&quot;&gt;column-constraint&lt;/a&gt;&lt;a href=&quot;#compound-select-stmt&quot;&gt;compound-select-stmt&lt;/a&gt;&lt;a href=&quot;#create-index-stmt&quot;&gt;create-index-stmt&lt;/a&gt;&lt;a href=&quot;#create-trigger-stmt&quot;&gt;create-trigger-stmt&lt;/a&gt;&lt;a href=&quot;#delete-stmt&quot;&gt;delete-stmt&lt;/a&gt;&lt;a href=&quot;#delete-stmt-limited&quot;&gt;delete-stmt-limited&lt;/a&gt;&lt;a href=&quot;#factored-select-stmt&quot;&gt;factored-select-stmt&lt;/a&gt;&lt;a href=&quot;#filter-clause&quot;&gt;filter-clause&lt;/a&gt;&lt;a href=&quot;#frame-spec&quot;&gt;frame-spec&lt;/a&gt;&lt;a href=&quot;#indexed-column&quot;&gt;indexed-column&lt;/a&gt;&lt;a href=&quot;#insert-stmt&quot;&gt;insert-stmt&lt;/a&gt;&lt;a href=&quot;#join-constraint&quot;&gt;join-constraint&lt;/a&gt;&lt;a href=&quot;#ordering-term&quot;&gt;ordering-term&lt;/a&gt;&lt;a href=&quot;#over-clause&quot;&gt;over-clause&lt;/a&gt;&lt;a href=&quot;#result-column&quot;&gt;result-column&lt;/a&gt;&lt;a href=&quot;#select-core&quot;&gt;select-core&lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt&lt;/a&gt;&lt;a href=&quot;#simple-function-invocation&quot;&gt;simple-function-invocation&lt;/a&gt;&lt;a href=&quot;#simple-select-stmt&quot;&gt;simple-select-stmt&lt;/a&gt;&lt;a href=&quot;#table-constraint&quot;&gt;table-constraint&lt;/a&gt;&lt;a href=&quot;#table-or-subquery&quot;&gt;table-or-subquery&lt;/a&gt;&lt;a href=&quot;#update-stmt&quot;&gt;update-stmt&lt;/a&gt;&lt;a href=&quot;#update-stmt-limited&quot;&gt;update-stmt-limited&lt;/a&gt;&lt;a href=&quot;#upsert-clause&quot;&gt;upsert-clause&lt;/a&gt;&lt;a href=&quot;#window-defn&quot;&gt;window-defn&lt;/a&gt;&lt;a href=&quot;#window-function-invocation&quot;&gt;window-function-invocation&lt;/a&gt;</source>
          <target state="translated">Используется: &lt;a href=&quot;#aggregate-function-invocation&quot;&gt;вызовом &lt;/a&gt;&lt;a href=&quot;#attach-stmt&quot;&gt;- &lt;/a&gt;агрегатной-функцией attach-stmt &lt;a href=&quot;#column-constraint&quot;&gt;ограничение &lt;/a&gt;- столбца &lt;a href=&quot;#compound-select-stmt&quot;&gt;составным-select-stmt &lt;/a&gt;&lt;a href=&quot;#create-index-stmt&quot;&gt;create-index-stmt &lt;/a&gt;&lt;a href=&quot;#create-trigger-stmt&quot;&gt;create-trigger-stmt &lt;/a&gt;&lt;a href=&quot;#delete-stmt&quot;&gt;delete-stmt &lt;/a&gt;&lt;a href=&quot;#delete-stmt-limited&quot;&gt;delete-stmt-limited &lt;/a&gt;&lt;a href=&quot;#factored-select-stmt&quot;&gt;factored-select-stmt &lt;/a&gt;&lt;a href=&quot;#filter-clause&quot;&gt;filter-clause &lt;/a&gt;&lt;a href=&quot;#frame-spec&quot;&gt;frame-spec &lt;/a&gt;&lt;a href=&quot;#indexed-column&quot;&gt;indexed- столбец &lt;/a&gt;&lt;a href=&quot;#insert-stmt&quot;&gt;insert-stmt &lt;/a&gt;&lt;a href=&quot;#join-constraint&quot;&gt;join-constraint &lt;/a&gt;&lt;a href=&quot;#ordering-term&quot;&gt;упорядочивающий термин &lt;/a&gt;&lt;a href=&quot;#over-clause&quot;&gt;over-clause &lt;/a&gt;&lt;a href=&quot;#result-column&quot;&gt;столбец результата &lt;/a&gt;&lt;a href=&quot;#select-core&quot;&gt;select-core &lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt &lt;/a&gt;&lt;a href=&quot;#simple-function-invocation&quot;&gt;вызов &lt;/a&gt;&lt;a href=&quot;#simple-select-stmt&quot;&gt;простой- &lt;/a&gt;функции simple-select-stmt &lt;a href=&quot;#table-constraint&quot;&gt;table-constraint &lt;/a&gt;&lt;a href=&quot;#table-or-subquery&quot;&gt;table-or-subquery &lt;/a&gt;&lt;a href=&quot;#update-stmt&quot;&gt;update-stmt &lt;/a&gt;&lt;a href=&quot;#update-stmt-limited&quot;&gt;update-stmt-limited &lt;/a&gt;&lt;a href=&quot;#upsert-clause&quot;&gt;upsert- предложение &lt;/a&gt;&lt;a href=&quot;#window-defn&quot;&gt;window-defn вызов &lt;/a&gt;&lt;a href=&quot;#window-function-invocation&quot;&gt;-функции-окна&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f3cfe8ec4e623b595e4ac50171983c062621b492" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#aggregate-function-invocation&quot;&gt;aggregate-function-invocation&lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;#window-function-invocation&quot;&gt;window-function-invocation&lt;/a&gt;</source>
          <target state="translated">Используется: &lt;a href=&quot;#aggregate-function-invocation&quot;&gt;агрегатно-функция-вызов &lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;ехрг &lt;/a&gt;&lt;a href=&quot;#window-function-invocation&quot;&gt;оконной функции-вызов&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9fa16a928ddc1dc237caf8ee5a2f33829abb8c95" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#alter-table-stmt&quot;&gt;alter-table-stmt&lt;/a&gt;&lt;a href=&quot;#create-table-stmt&quot;&gt;create-table-stmt&lt;/a&gt;</source>
          <target state="translated">Используется: &lt;a href=&quot;#alter-table-stmt&quot;&gt;alter-table-stmt &lt;/a&gt;&lt;a href=&quot;#create-table-stmt&quot;&gt;create-table-stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7605fd600c574fecb47de09ab5decde53c108336" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#column-constraint&quot;&gt;column-constraint&lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;</source>
          <target state="translated">Используется: &lt;a href=&quot;#expr&quot;&gt;выражение &lt;/a&gt;&lt;a href=&quot;#column-constraint&quot;&gt;-ограничение столбца&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a9d132b987e9571018a10419466ce9e4241f4144" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#column-constraint&quot;&gt;column-constraint&lt;/a&gt;&lt;a href=&quot;#pragma-value&quot;&gt;pragma-value&lt;/a&gt;&lt;a href=&quot;#type-name&quot;&gt;type-name&lt;/a&gt;</source>
          <target state="translated">Используется: &lt;a href=&quot;#column-constraint&quot;&gt;ограничение &lt;/a&gt;&lt;a href=&quot;#pragma-value&quot;&gt;- &lt;/a&gt;столбца, прагма-значение, &lt;a href=&quot;#type-name&quot;&gt;имя &lt;/a&gt;- типа</target>
        </trans-unit>
        <trans-unit id="6859f1dc44376fa95c8d38fdf3b6141e03d2c1ae" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#column-constraint&quot;&gt;column-constraint&lt;/a&gt;&lt;a href=&quot;#table-constraint&quot;&gt;table-constraint&lt;/a&gt;</source>
          <target state="translated">Используется: &lt;a href=&quot;#column-constraint&quot;&gt;ограничение &lt;/a&gt;&lt;a href=&quot;#table-constraint&quot;&gt;- &lt;/a&gt;столбца ограничение- таблица</target>
        </trans-unit>
        <trans-unit id="a380af02d8c9c93f329808cab4b27595f6a4a3c5" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#column-def&quot;&gt;column-def&lt;/a&gt;</source>
          <target state="translated">Используется: &lt;a href=&quot;#column-def&quot;&gt;column-def&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d289a73c451effafc4667d2bf1f3b0e030afac60" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#column-def&quot;&gt;column-def&lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;</source>
          <target state="translated">Используется: &lt;a href=&quot;#column-def&quot;&gt;column-def &lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a431a18a7738c53de3472c652954e2bc59958670" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#common-table-expression&quot;&gt;common-table-expression&lt;/a&gt;&lt;a href=&quot;#create-table-stmt&quot;&gt;create-table-stmt&lt;/a&gt;&lt;a href=&quot;#create-trigger-stmt&quot;&gt;create-trigger-stmt&lt;/a&gt;&lt;a href=&quot;#create-view-stmt&quot;&gt;create-view-stmt&lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;#insert-stmt&quot;&gt;insert-stmt&lt;/a&gt;&lt;a href=&quot;#sql-stmt&quot;&gt;sql-stmt&lt;/a&gt;&lt;a href=&quot;#table-or-subquery&quot;&gt;table-or-subquery&lt;/a&gt;&lt;a href=&quot;#with-clause&quot;&gt;with-clause&lt;/a&gt;</source>
          <target state="translated">Используется: &lt;a href=&quot;#common-table-expression&quot;&gt;common-table-expression &lt;/a&gt;&lt;a href=&quot;#create-table-stmt&quot;&gt;create-table-stmt &lt;/a&gt;&lt;a href=&quot;#create-trigger-stmt&quot;&gt;create-trigger-stmt &lt;/a&gt;&lt;a href=&quot;#create-view-stmt&quot;&gt;create-view-stmt &lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;#insert-stmt&quot;&gt;insert-stmt &lt;/a&gt;&lt;a href=&quot;#sql-stmt&quot;&gt;sql-stmt &lt;/a&gt;&lt;a href=&quot;#table-or-subquery&quot;&gt;table-or-subquery &lt;/a&gt;&lt;a href=&quot;#with-clause&quot;&gt;with-clause&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="224be4c1f3c548d22132987eb2bf278a86171468" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#compound-select-stmt&quot;&gt;compound-select-stmt&lt;/a&gt;&lt;a href=&quot;#delete-stmt&quot;&gt;delete-stmt&lt;/a&gt;&lt;a href=&quot;#delete-stmt-limited&quot;&gt;delete-stmt-limited&lt;/a&gt;&lt;a href=&quot;#factored-select-stmt&quot;&gt;factored-select-stmt&lt;/a&gt;&lt;a href=&quot;#insert-stmt&quot;&gt;insert-stmt&lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt&lt;/a&gt;&lt;a href=&quot;#simple-select-stmt&quot;&gt;simple-select-stmt&lt;/a&gt;&lt;a href=&quot;#update-stmt&quot;&gt;update-stmt&lt;/a&gt;&lt;a href=&quot;#update-stmt-limited&quot;&gt;update-stmt-limited&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abb141b71ecdf70ef024445a846b6364ea02ee67" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#compound-select-stmt&quot;&gt;compound-select-stmt&lt;/a&gt;&lt;a href=&quot;#delete-stmt-limited&quot;&gt;delete-stmt-limited&lt;/a&gt;&lt;a href=&quot;#factored-select-stmt&quot;&gt;factored-select-stmt&lt;/a&gt;&lt;a href=&quot;#over-clause&quot;&gt;over-clause&lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt&lt;/a&gt;&lt;a href=&quot;#simple-select-stmt&quot;&gt;simple-select-stmt&lt;/a&gt;&lt;a href=&quot;#update-stmt-limited&quot;&gt;update-stmt-limited&lt;/a&gt;&lt;a href=&quot;#window-defn&quot;&gt;window-defn&lt;/a&gt;</source>
          <target state="translated">Используется: &lt;a href=&quot;#compound-select-stmt&quot;&gt;complex-select-stmt &lt;/a&gt;&lt;a href=&quot;#delete-stmt-limited&quot;&gt;delete-stmt-limited &lt;/a&gt;&lt;a href=&quot;#factored-select-stmt&quot;&gt;factored-select-stmt &lt;/a&gt;&lt;a href=&quot;#over-clause&quot;&gt;over-clause &lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt &lt;/a&gt;&lt;a href=&quot;#simple-select-stmt&quot;&gt;simple-select-stmt &lt;/a&gt;&lt;a href=&quot;#update-stmt-limited&quot;&gt;update-stmt-limited &lt;/a&gt;&lt;a href=&quot;#window-defn&quot;&gt;window-defn&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ab6cea255f6025204d21b009964174b973b40cd6" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#compound-select-stmt&quot;&gt;compound-select-stmt&lt;/a&gt;&lt;a href=&quot;#factored-select-stmt&quot;&gt;factored-select-stmt&lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt&lt;/a&gt;&lt;a href=&quot;#simple-select-stmt&quot;&gt;simple-select-stmt&lt;/a&gt;</source>
          <target state="translated">Используется: &lt;a href=&quot;#compound-select-stmt&quot;&gt;complex-select-stmt &lt;/a&gt;&lt;a href=&quot;#factored-select-stmt&quot;&gt;factored-select-stmt &lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt &lt;/a&gt;&lt;a href=&quot;#simple-select-stmt&quot;&gt;simple-select-stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c9a35f3e8899c13b9a454dc09b2554a9fc11894f" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#compound-select-stmt&quot;&gt;compound-select-stmt&lt;/a&gt;&lt;a href=&quot;#factored-select-stmt&quot;&gt;factored-select-stmt&lt;/a&gt;&lt;a href=&quot;#simple-select-stmt&quot;&gt;simple-select-stmt&lt;/a&gt;</source>
          <target state="translated">Используется: &lt;a href=&quot;#compound-select-stmt&quot;&gt;complex-select-stmt &lt;/a&gt;&lt;a href=&quot;#factored-select-stmt&quot;&gt;factored-select-stmt &lt;/a&gt;&lt;a href=&quot;#simple-select-stmt&quot;&gt;simple-select-stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="56b558cf19b1f43efb09e7c3cf6f834bdf6f9e08" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#create-index-stmt&quot;&gt;create-index-stmt&lt;/a&gt;&lt;a href=&quot;#table-constraint&quot;&gt;table-constraint&lt;/a&gt;&lt;a href=&quot;#upsert-clause&quot;&gt;upsert-clause&lt;/a&gt;</source>
          <target state="translated">Используется: &lt;a href=&quot;#create-index-stmt&quot;&gt;create-index-stmt &lt;/a&gt;&lt;a href=&quot;#table-constraint&quot;&gt;table-constraint &lt;/a&gt;&lt;a href=&quot;#upsert-clause&quot;&gt;upsert-clause&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3ed338e20414f7c9ffcbc59e0281f80cccd5a763" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#create-table-stmt&quot;&gt;create-table-stmt&lt;/a&gt;</source>
          <target state="translated">Используется: &lt;a href=&quot;#create-table-stmt&quot;&gt;create-table-stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6b50a14ac773fa0a58261d63783e57e4cbe15c68" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#create-trigger-stmt&quot;&gt;create-trigger-stmt&lt;/a&gt;&lt;a href=&quot;#sql-stmt&quot;&gt;sql-stmt&lt;/a&gt;</source>
          <target state="translated">Используется: &lt;a href=&quot;#create-trigger-stmt&quot;&gt;create-trigger-stmt &lt;/a&gt;&lt;a href=&quot;#sql-stmt&quot;&gt;sql-stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ed0705dac87c2b47586b5a816bab059a80c3dff1" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#delete-stmt&quot;&gt;delete-stmt&lt;/a&gt;&lt;a href=&quot;#delete-stmt-limited&quot;&gt;delete-stmt-limited&lt;/a&gt;&lt;a href=&quot;#insert-stmt&quot;&gt;insert-stmt&lt;/a&gt;&lt;a href=&quot;#update-stmt&quot;&gt;update-stmt&lt;/a&gt;&lt;a href=&quot;#update-stmt-limited&quot;&gt;update-stmt-limited&lt;/a&gt;</source>
          <target state="translated">Используется: &lt;a href=&quot;#delete-stmt&quot;&gt;delete-stmt &lt;/a&gt;&lt;a href=&quot;#delete-stmt-limited&quot;&gt;delete-stmt-limited &lt;/a&gt;&lt;a href=&quot;#insert-stmt&quot;&gt;insert-stmt &lt;/a&gt;&lt;a href=&quot;#update-stmt&quot;&gt;update-stmt &lt;/a&gt;&lt;a href=&quot;#update-stmt-limited&quot;&gt;update-stmt-limited&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fed14e0505bafc78d4d9d690a2b7426f9c8198b2" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#delete-stmt&quot;&gt;delete-stmt&lt;/a&gt;&lt;a href=&quot;#delete-stmt-limited&quot;&gt;delete-stmt-limited&lt;/a&gt;&lt;a href=&quot;#update-stmt&quot;&gt;update-stmt&lt;/a&gt;&lt;a href=&quot;#update-stmt-limited&quot;&gt;update-stmt-limited&lt;/a&gt;</source>
          <target state="translated">Используется: &lt;a href=&quot;#delete-stmt&quot;&gt;delete-stmt &lt;/a&gt;&lt;a href=&quot;#delete-stmt-limited&quot;&gt;delete-stmt-limited &lt;/a&gt;&lt;a href=&quot;#update-stmt&quot;&gt;update-stmt &lt;/a&gt;&lt;a href=&quot;#update-stmt-limited&quot;&gt;update-stmt-limited&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a021ee5a9dccd79e0bc3acd62766c09cd9fb8cae" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;</source>
          <target state="translated">Используется: &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="082ab3c78daf3f012c8a8cd5f4c53643a071209a" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#factored-select-stmt&quot;&gt;factored-select-stmt&lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt&lt;/a&gt;</source>
          <target state="translated">Используется: &lt;a href=&quot;#factored-select-stmt&quot;&gt;factored-select-stmt &lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="09a6e3cc1f24c34ba4f2a0f20d3c51dbe35db3c3" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#insert-stmt&quot;&gt;insert-stmt&lt;/a&gt;</source>
          <target state="translated">Используется: &lt;a href=&quot;#insert-stmt&quot;&gt;insert-stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="97d8dfd0bb5c0f6552eb23078a3e1e860cc9a6c3" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#join-clause&quot;&gt;join-clause&lt;/a&gt;</source>
          <target state="translated">Используется: &lt;a href=&quot;#join-clause&quot;&gt;join-clause&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ed8783360dda42990afd13092353a2478b98c818" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#join-clause&quot;&gt;join-clause&lt;/a&gt;&lt;a href=&quot;#select-core&quot;&gt;select-core&lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt&lt;/a&gt;</source>
          <target state="translated">Используется: &lt;a href=&quot;#join-clause&quot;&gt;join-clause &lt;/a&gt;&lt;a href=&quot;#select-core&quot;&gt;select-core &lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7c4cd678b8b993f3438c0117dedb1f0fd21e9e1b" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#join-clause&quot;&gt;join-clause&lt;/a&gt;&lt;a href=&quot;#select-core&quot;&gt;select-core&lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt&lt;/a&gt;&lt;a href=&quot;#update-stmt&quot;&gt;update-stmt&lt;/a&gt;&lt;a href=&quot;#update-stmt-limited&quot;&gt;update-stmt-limited&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9af677aaf273d3f1f76df6b503b77ba2fd60bed2" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#over-clause&quot;&gt;over-clause&lt;/a&gt;&lt;a href=&quot;#window-defn&quot;&gt;window-defn&lt;/a&gt;</source>
          <target state="translated">Используется: &lt;a href=&quot;#over-clause&quot;&gt;over-clause &lt;/a&gt;&lt;a href=&quot;#window-defn&quot;&gt;window-defn&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8079f3adf01a444617315e6ee69c27b2f0e4367b" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#pragma-stmt&quot;&gt;pragma-stmt&lt;/a&gt;</source>
          <target state="translated">Используется: &lt;a href=&quot;#pragma-stmt&quot;&gt;pragma-stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="80938cb5970c9483ff312171cb2cce6f1c888a48" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#recursive-cte&quot;&gt;recursive-cte&lt;/a&gt;&lt;a href=&quot;#with-clause&quot;&gt;with-clause&lt;/a&gt;</source>
          <target state="translated">Используется: &lt;a href=&quot;#recursive-cte&quot;&gt;recursive-cte &lt;/a&gt;&lt;a href=&quot;#with-clause&quot;&gt;with-clause&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5ae852a57048a30f81de513ccc896f0c0dd648fe" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#select-core&quot;&gt;select-core&lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt&lt;/a&gt;</source>
          <target state="translated">Используется: &lt;a href=&quot;#select-core&quot;&gt;select-core &lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d3f7cbedd2f19d68e5c65e3a5494b079eb45e6d0" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#select-core&quot;&gt;select-core&lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt&lt;/a&gt;&lt;a href=&quot;#table-or-subquery&quot;&gt;table-or-subquery&lt;/a&gt;</source>
          <target state="translated">Используется: &lt;a href=&quot;#select-core&quot;&gt;select-core &lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt &lt;/a&gt;&lt;a href=&quot;#table-or-subquery&quot;&gt;table-or-subquery&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="589e0a5319c833b4b7bc5d107ed94b7fe1c7d8cd" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#select-core&quot;&gt;select-core&lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt&lt;/a&gt;&lt;a href=&quot;#table-or-subquery&quot;&gt;table-or-subquery&lt;/a&gt;&lt;a href=&quot;#update-stmt&quot;&gt;update-stmt&lt;/a&gt;&lt;a href=&quot;#update-stmt-limited&quot;&gt;update-stmt-limited&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35ea943fa5a24500d0b2de81bfcae0c263e9c947" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#select-core&quot;&gt;select-core&lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt&lt;/a&gt;&lt;a href=&quot;#window-function-invocation&quot;&gt;window-function-invocation&lt;/a&gt;</source>
          <target state="translated">Используется: &lt;a href=&quot;#select-core&quot;&gt;select-core &lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt &lt;/a&gt;&lt;a href=&quot;#window-function-invocation&quot;&gt;window-function-invocation&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f6ef1477fa5df999acf552fb4e67164b37b0a48f" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#sql-stmt&quot;&gt;sql-stmt&lt;/a&gt;</source>
          <target state="translated">Используется: &lt;a href=&quot;#sql-stmt&quot;&gt;sql-stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b6d1945ca75963e8557621ed71f512d0d1f8a13e" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#sql-stmt-list&quot;&gt;sql-stmt-list&lt;/a&gt;</source>
          <target state="translated">Используется: &lt;a href=&quot;#sql-stmt-list&quot;&gt;sql-stmt-list&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1042aa6c3f092cc75f0c8a676be3f2d32a0e48e0" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#update-stmt&quot;&gt;update-stmt&lt;/a&gt;&lt;a href=&quot;#update-stmt-limited&quot;&gt;update-stmt-limited&lt;/a&gt;&lt;a href=&quot;#upsert-clause&quot;&gt;upsert-clause&lt;/a&gt;</source>
          <target state="translated">Используется: &lt;a href=&quot;#update-stmt&quot;&gt;update-stmt &lt;/a&gt;&lt;a href=&quot;#update-stmt-limited&quot;&gt;update-stmt-limited &lt;/a&gt;&lt;a href=&quot;#upsert-clause&quot;&gt;upsert-clause&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a1f1be8756f8f6e3850d5a9e7441499016850919" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;aggregate-function-invocation&quot;&gt;aggregate-function-invocation&lt;/a&gt;&lt;a href=&quot;attach-stmt&quot;&gt;attach-stmt&lt;/a&gt;&lt;a href=&quot;column-constraint&quot;&gt;column-constraint&lt;/a&gt;&lt;a href=&quot;compound-select-stmt&quot;&gt;compound-select-stmt&lt;/a&gt;&lt;a href=&quot;create-index-stmt&quot;&gt;create-index-stmt&lt;/a&gt;&lt;a href=&quot;create-trigger-stmt&quot;&gt;create-trigger-stmt&lt;/a&gt;&lt;a href=&quot;delete-stmt&quot;&gt;delete-stmt&lt;/a&gt;&lt;a href=&quot;delete-stmt-limited&quot;&gt;delete-stmt-limited&lt;/a&gt;&lt;a href=&quot;factored-select-stmt&quot;&gt;factored-select-stmt&lt;/a&gt;&lt;a href=&quot;filter-clause&quot;&gt;filter-clause&lt;/a&gt;&lt;a href=&quot;frame-spec&quot;&gt;frame-spec&lt;/a&gt;&lt;a href=&quot;indexed-column&quot;&gt;indexed-column&lt;/a&gt;&lt;a href=&quot;insert-stmt&quot;&gt;insert-stmt&lt;/a&gt;&lt;a href=&quot;join-constraint&quot;&gt;join-constraint&lt;/a&gt;&lt;a href=&quot;ordering-term&quot;&gt;ordering-term&lt;/a&gt;&lt;a href=&quot;over-clause&quot;&gt;over-clause&lt;/a&gt;&lt;a href=&quot;result-column&quot;&gt;result-column&lt;/a&gt;&lt;a href=&quot;select-core&quot;&gt;select-core&lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt&lt;/a&gt;&lt;a href=&quot;simple-function-invocation&quot;&gt;simple-function-invocation&lt;/a&gt;&lt;a href=&quot;simple-select-stmt&quot;&gt;simple-select-stmt&lt;/a&gt;&lt;a href=&quot;table-constraint&quot;&gt;table-constraint&lt;/a&gt;&lt;a href=&quot;table-or-subquery&quot;&gt;table-or-subquery&lt;/a&gt;&lt;a href=&quot;update-stmt&quot;&gt;update-stmt&lt;/a&gt;&lt;a href=&quot;update-stmt-limited&quot;&gt;update-stmt-limited&lt;/a&gt;&lt;a href=&quot;upsert-clause&quot;&gt;upsert-clause&lt;/a&gt;&lt;a href=&quot;window-defn&quot;&gt;window-defn&lt;/a&gt;&lt;a href=&quot;window-function-invocation&quot;&gt;window-function-invocation&lt;/a&gt;</source>
          <target state="translated">Используется: &lt;a href=&quot;aggregate-function-invocation&quot;&gt;вызовом &lt;/a&gt;&lt;a href=&quot;attach-stmt&quot;&gt;- &lt;/a&gt;агрегатной-функцией attach-stmt &lt;a href=&quot;column-constraint&quot;&gt;ограничение &lt;/a&gt;- столбца &lt;a href=&quot;compound-select-stmt&quot;&gt;составным-select-stmt &lt;/a&gt;&lt;a href=&quot;create-index-stmt&quot;&gt;create-index-stmt &lt;/a&gt;&lt;a href=&quot;create-trigger-stmt&quot;&gt;create-trigger-stmt &lt;/a&gt;&lt;a href=&quot;delete-stmt&quot;&gt;delete-stmt &lt;/a&gt;&lt;a href=&quot;delete-stmt-limited&quot;&gt;delete-stmt-limited &lt;/a&gt;&lt;a href=&quot;factored-select-stmt&quot;&gt;factored-select-stmt &lt;/a&gt;&lt;a href=&quot;filter-clause&quot;&gt;filter-clause &lt;/a&gt;&lt;a href=&quot;frame-spec&quot;&gt;frame-spec &lt;/a&gt;&lt;a href=&quot;indexed-column&quot;&gt;indexed- столбец &lt;/a&gt;&lt;a href=&quot;insert-stmt&quot;&gt;insert-stmt &lt;/a&gt;&lt;a href=&quot;join-constraint&quot;&gt;join-constraint &lt;/a&gt;&lt;a href=&quot;ordering-term&quot;&gt;упорядочивающий термин &lt;/a&gt;&lt;a href=&quot;over-clause&quot;&gt;over-clause &lt;/a&gt;&lt;a href=&quot;result-column&quot;&gt;столбец результата &lt;/a&gt;&lt;a href=&quot;select-core&quot;&gt;select-core &lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt &lt;/a&gt;&lt;a href=&quot;simple-function-invocation&quot;&gt;вызов &lt;/a&gt;&lt;a href=&quot;simple-select-stmt&quot;&gt;простой- &lt;/a&gt;функции simple-select-stmt &lt;a href=&quot;table-constraint&quot;&gt;table-constraint &lt;/a&gt;&lt;a href=&quot;table-or-subquery&quot;&gt;table-or-subquery &lt;/a&gt;&lt;a href=&quot;update-stmt&quot;&gt;update-stmt &lt;/a&gt;&lt;a href=&quot;update-stmt-limited&quot;&gt;update-stmt-limited &lt;/a&gt;&lt;a href=&quot;upsert-clause&quot;&gt;upsert- предложение &lt;/a&gt;&lt;a href=&quot;window-defn&quot;&gt;window-defn вызов &lt;/a&gt;&lt;a href=&quot;window-function-invocation&quot;&gt;-функции-окна&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8dba34c5ead7ae94617f98c7cde1dd99c8cf20f1" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;aggregate-function-invocation&quot;&gt;aggregate-function-invocation&lt;/a&gt;&lt;a href=&quot;expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;window-function-invocation&quot;&gt;window-function-invocation&lt;/a&gt;</source>
          <target state="translated">Используется: &lt;a href=&quot;aggregate-function-invocation&quot;&gt;агрегатно-функция-вызов &lt;/a&gt;&lt;a href=&quot;expr&quot;&gt;ехрг &lt;/a&gt;&lt;a href=&quot;window-function-invocation&quot;&gt;оконной функции-вызов&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="307e140208125cd798472be7cbdee684ec27af23" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;alter-table-stmt&quot;&gt;alter-table-stmt&lt;/a&gt;&lt;a href=&quot;create-table-stmt&quot;&gt;create-table-stmt&lt;/a&gt;</source>
          <target state="translated">Используется: &lt;a href=&quot;alter-table-stmt&quot;&gt;alter-table-stmt &lt;/a&gt;&lt;a href=&quot;create-table-stmt&quot;&gt;create-table-stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c5caeae659f486a37e2e78f0f36394d00574f259" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;column-constraint&quot;&gt;column-constraint&lt;/a&gt;&lt;a href=&quot;expr&quot;&gt;expr&lt;/a&gt;</source>
          <target state="translated">Используется: &lt;a href=&quot;expr&quot;&gt;выражение &lt;/a&gt;&lt;a href=&quot;column-constraint&quot;&gt;-ограничение столбца&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a86521d0d079a24ae129812150a3753aecda3e41" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;column-constraint&quot;&gt;column-constraint&lt;/a&gt;&lt;a href=&quot;pragma-value&quot;&gt;pragma-value&lt;/a&gt;&lt;a href=&quot;type-name&quot;&gt;type-name&lt;/a&gt;</source>
          <target state="translated">Используется: &lt;a href=&quot;column-constraint&quot;&gt;ограничение &lt;/a&gt;&lt;a href=&quot;pragma-value&quot;&gt;- &lt;/a&gt;столбца, прагма-значение, &lt;a href=&quot;type-name&quot;&gt;имя &lt;/a&gt;- типа</target>
        </trans-unit>
        <trans-unit id="4797572b6c11d132a08e6eb97c1346965d8c3891" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;column-constraint&quot;&gt;column-constraint&lt;/a&gt;&lt;a href=&quot;table-constraint&quot;&gt;table-constraint&lt;/a&gt;</source>
          <target state="translated">Используется: &lt;a href=&quot;column-constraint&quot;&gt;ограничение &lt;/a&gt;&lt;a href=&quot;table-constraint&quot;&gt;- &lt;/a&gt;столбца ограничение- таблица</target>
        </trans-unit>
        <trans-unit id="530c72cf587d62fa294e2381602271f96f0f96d7" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;column-def&quot;&gt;column-def&lt;/a&gt;</source>
          <target state="translated">Используется: &lt;a href=&quot;column-def&quot;&gt;column-def&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bae571e21875de9dbe7973158d01f4c614d8c361" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;column-def&quot;&gt;column-def&lt;/a&gt;&lt;a href=&quot;expr&quot;&gt;expr&lt;/a&gt;</source>
          <target state="translated">Используется: &lt;a href=&quot;column-def&quot;&gt;column-def &lt;/a&gt;&lt;a href=&quot;expr&quot;&gt;expr&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d621ef2d30a77aac0f67e4cb22f0496953330ae4" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;common-table-expression&quot;&gt;common-table-expression&lt;/a&gt;&lt;a href=&quot;create-table-stmt&quot;&gt;create-table-stmt&lt;/a&gt;&lt;a href=&quot;create-trigger-stmt&quot;&gt;create-trigger-stmt&lt;/a&gt;&lt;a href=&quot;create-view-stmt&quot;&gt;create-view-stmt&lt;/a&gt;&lt;a href=&quot;expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;insert-stmt&quot;&gt;insert-stmt&lt;/a&gt;&lt;a href=&quot;sql-stmt&quot;&gt;sql-stmt&lt;/a&gt;&lt;a href=&quot;table-or-subquery&quot;&gt;table-or-subquery&lt;/a&gt;&lt;a href=&quot;with-clause&quot;&gt;with-clause&lt;/a&gt;</source>
          <target state="translated">Используется: &lt;a href=&quot;common-table-expression&quot;&gt;common-table-expression &lt;/a&gt;&lt;a href=&quot;create-table-stmt&quot;&gt;create-table-stmt &lt;/a&gt;&lt;a href=&quot;create-trigger-stmt&quot;&gt;create-trigger-stmt &lt;/a&gt;&lt;a href=&quot;create-view-stmt&quot;&gt;create-view-stmt &lt;/a&gt;&lt;a href=&quot;expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;insert-stmt&quot;&gt;insert-stmt &lt;/a&gt;&lt;a href=&quot;sql-stmt&quot;&gt;sql-stmt &lt;/a&gt;&lt;a href=&quot;table-or-subquery&quot;&gt;table-or-subquery &lt;/a&gt;&lt;a href=&quot;with-clause&quot;&gt;with-clause&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7999cb7cebc65a8fd79ca0339c4bb490ea515b01" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;compound-select-stmt&quot;&gt;compound-select-stmt&lt;/a&gt;&lt;a href=&quot;delete-stmt&quot;&gt;delete-stmt&lt;/a&gt;&lt;a href=&quot;delete-stmt-limited&quot;&gt;delete-stmt-limited&lt;/a&gt;&lt;a href=&quot;factored-select-stmt&quot;&gt;factored-select-stmt&lt;/a&gt;&lt;a href=&quot;insert-stmt&quot;&gt;insert-stmt&lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt&lt;/a&gt;&lt;a href=&quot;simple-select-stmt&quot;&gt;simple-select-stmt&lt;/a&gt;&lt;a href=&quot;update-stmt&quot;&gt;update-stmt&lt;/a&gt;&lt;a href=&quot;update-stmt-limited&quot;&gt;update-stmt-limited&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0856e25a6da8ebb570311e60dcc92e62c9700b8" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;compound-select-stmt&quot;&gt;compound-select-stmt&lt;/a&gt;&lt;a href=&quot;delete-stmt-limited&quot;&gt;delete-stmt-limited&lt;/a&gt;&lt;a href=&quot;factored-select-stmt&quot;&gt;factored-select-stmt&lt;/a&gt;&lt;a href=&quot;over-clause&quot;&gt;over-clause&lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt&lt;/a&gt;&lt;a href=&quot;simple-select-stmt&quot;&gt;simple-select-stmt&lt;/a&gt;&lt;a href=&quot;update-stmt-limited&quot;&gt;update-stmt-limited&lt;/a&gt;&lt;a href=&quot;window-defn&quot;&gt;window-defn&lt;/a&gt;</source>
          <target state="translated">Используется: &lt;a href=&quot;compound-select-stmt&quot;&gt;complex-select-stmt &lt;/a&gt;&lt;a href=&quot;delete-stmt-limited&quot;&gt;delete-stmt-limited &lt;/a&gt;&lt;a href=&quot;factored-select-stmt&quot;&gt;factored-select-stmt &lt;/a&gt;&lt;a href=&quot;over-clause&quot;&gt;over-clause &lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt &lt;/a&gt;&lt;a href=&quot;simple-select-stmt&quot;&gt;simple-select-stmt &lt;/a&gt;&lt;a href=&quot;update-stmt-limited&quot;&gt;update-stmt-limited &lt;/a&gt;&lt;a href=&quot;window-defn&quot;&gt;window-defn&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="21f8541c9dc2a69fa16cf43b335b7b363315d397" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;compound-select-stmt&quot;&gt;compound-select-stmt&lt;/a&gt;&lt;a href=&quot;factored-select-stmt&quot;&gt;factored-select-stmt&lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt&lt;/a&gt;&lt;a href=&quot;simple-select-stmt&quot;&gt;simple-select-stmt&lt;/a&gt;</source>
          <target state="translated">Используется: &lt;a href=&quot;compound-select-stmt&quot;&gt;complex-select-stmt &lt;/a&gt;&lt;a href=&quot;factored-select-stmt&quot;&gt;factored-select-stmt &lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt &lt;/a&gt;&lt;a href=&quot;simple-select-stmt&quot;&gt;simple-select-stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4ab6ebc8f279a3034f0fdb604843d248415ee1bf" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;compound-select-stmt&quot;&gt;compound-select-stmt&lt;/a&gt;&lt;a href=&quot;factored-select-stmt&quot;&gt;factored-select-stmt&lt;/a&gt;&lt;a href=&quot;simple-select-stmt&quot;&gt;simple-select-stmt&lt;/a&gt;</source>
          <target state="translated">Используется: &lt;a href=&quot;compound-select-stmt&quot;&gt;complex-select-stmt &lt;/a&gt;&lt;a href=&quot;factored-select-stmt&quot;&gt;factored-select-stmt &lt;/a&gt;&lt;a href=&quot;simple-select-stmt&quot;&gt;simple-select-stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a9b73b88651ef8bf860289b6de3757bded750bc5" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;create-index-stmt&quot;&gt;create-index-stmt&lt;/a&gt;&lt;a href=&quot;table-constraint&quot;&gt;table-constraint&lt;/a&gt;&lt;a href=&quot;upsert-clause&quot;&gt;upsert-clause&lt;/a&gt;</source>
          <target state="translated">Используется: &lt;a href=&quot;create-index-stmt&quot;&gt;create-index-stmt &lt;/a&gt;&lt;a href=&quot;table-constraint&quot;&gt;table-constraint &lt;/a&gt;&lt;a href=&quot;upsert-clause&quot;&gt;upsert-clause&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f17754185255593ea4e239b7777c291185f4d22a" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;create-table-stmt&quot;&gt;create-table-stmt&lt;/a&gt;</source>
          <target state="translated">Используется: &lt;a href=&quot;create-table-stmt&quot;&gt;create-table-stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1250d862d07127e87b9840caf01bde3487514be4" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;create-trigger-stmt&quot;&gt;create-trigger-stmt&lt;/a&gt;&lt;a href=&quot;sql-stmt&quot;&gt;sql-stmt&lt;/a&gt;</source>
          <target state="translated">Используется: &lt;a href=&quot;create-trigger-stmt&quot;&gt;create-trigger-stmt &lt;/a&gt;&lt;a href=&quot;sql-stmt&quot;&gt;sql-stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7ffe5f5730adb72eee0e8790e0d4f442453ca532" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;delete-stmt&quot;&gt;delete-stmt&lt;/a&gt;&lt;a href=&quot;delete-stmt-limited&quot;&gt;delete-stmt-limited&lt;/a&gt;&lt;a href=&quot;insert-stmt&quot;&gt;insert-stmt&lt;/a&gt;&lt;a href=&quot;update-stmt&quot;&gt;update-stmt&lt;/a&gt;&lt;a href=&quot;update-stmt-limited&quot;&gt;update-stmt-limited&lt;/a&gt;</source>
          <target state="translated">Используется: &lt;a href=&quot;delete-stmt&quot;&gt;delete-stmt &lt;/a&gt;&lt;a href=&quot;delete-stmt-limited&quot;&gt;delete-stmt-limited &lt;/a&gt;&lt;a href=&quot;insert-stmt&quot;&gt;insert-stmt &lt;/a&gt;&lt;a href=&quot;update-stmt&quot;&gt;update-stmt &lt;/a&gt;&lt;a href=&quot;update-stmt-limited&quot;&gt;update-stmt-limited&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b346b7bdc3d0ceef5715a064d5778a794c30fe18" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;delete-stmt&quot;&gt;delete-stmt&lt;/a&gt;&lt;a href=&quot;delete-stmt-limited&quot;&gt;delete-stmt-limited&lt;/a&gt;&lt;a href=&quot;update-stmt&quot;&gt;update-stmt&lt;/a&gt;&lt;a href=&quot;update-stmt-limited&quot;&gt;update-stmt-limited&lt;/a&gt;</source>
          <target state="translated">Используется: &lt;a href=&quot;delete-stmt&quot;&gt;delete-stmt &lt;/a&gt;&lt;a href=&quot;delete-stmt-limited&quot;&gt;delete-stmt-limited &lt;/a&gt;&lt;a href=&quot;update-stmt&quot;&gt;update-stmt &lt;/a&gt;&lt;a href=&quot;update-stmt-limited&quot;&gt;update-stmt-limited&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ecd461adaec5db6b876f0dff52c7be72090d1b14" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;expr&quot;&gt;expr&lt;/a&gt;</source>
          <target state="translated">Используется: &lt;a href=&quot;expr&quot;&gt;expr&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1d46198801b0b7bba9815dc12e4cdb3e29b72db5" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;factored-select-stmt&quot;&gt;factored-select-stmt&lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt&lt;/a&gt;</source>
          <target state="translated">Используется: &lt;a href=&quot;factored-select-stmt&quot;&gt;factored-select-stmt &lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="79c1bf6cb1bf604130309cdb21b4f8fbff437aa3" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;insert-stmt&quot;&gt;insert-stmt&lt;/a&gt;</source>
          <target state="translated">Используется: &lt;a href=&quot;insert-stmt&quot;&gt;insert-stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9892cdf8b7abbe2222939b3dd694fd626893c60f" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;join-clause&quot;&gt;join-clause&lt;/a&gt;</source>
          <target state="translated">Используется: &lt;a href=&quot;join-clause&quot;&gt;join-clause&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b8026c06ece9d695e8c405568f97c947f459d098" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;join-clause&quot;&gt;join-clause&lt;/a&gt;&lt;a href=&quot;select-core&quot;&gt;select-core&lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt&lt;/a&gt;</source>
          <target state="translated">Используется: &lt;a href=&quot;join-clause&quot;&gt;join-clause &lt;/a&gt;&lt;a href=&quot;select-core&quot;&gt;select-core &lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e21ce3a84da1747a72ee6509dcd2b66aa22588d4" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;join-clause&quot;&gt;join-clause&lt;/a&gt;&lt;a href=&quot;select-core&quot;&gt;select-core&lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt&lt;/a&gt;&lt;a href=&quot;update-stmt&quot;&gt;update-stmt&lt;/a&gt;&lt;a href=&quot;update-stmt-limited&quot;&gt;update-stmt-limited&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9280252176a18a8cad0168e3316dcfbe48390b81" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;over-clause&quot;&gt;over-clause&lt;/a&gt;&lt;a href=&quot;window-defn&quot;&gt;window-defn&lt;/a&gt;</source>
          <target state="translated">Используется: &lt;a href=&quot;over-clause&quot;&gt;over-clause &lt;/a&gt;&lt;a href=&quot;window-defn&quot;&gt;window-defn&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="98a46233f40109c7b176062c4c3a604629e49ee7" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;pragma-stmt&quot;&gt;pragma-stmt&lt;/a&gt;</source>
          <target state="translated">Используется: &lt;a href=&quot;pragma-stmt&quot;&gt;pragma-stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b50593211eada2909f681edc15211383687e61a9" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;recursive-cte&quot;&gt;recursive-cte&lt;/a&gt;&lt;a href=&quot;with-clause&quot;&gt;with-clause&lt;/a&gt;</source>
          <target state="translated">Используется: &lt;a href=&quot;recursive-cte&quot;&gt;recursive-cte &lt;/a&gt;&lt;a href=&quot;with-clause&quot;&gt;with-clause&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="36f9352a3528ee1d344ab047f86be842bf862c8a" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;select-core&quot;&gt;select-core&lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt&lt;/a&gt;</source>
          <target state="translated">Используется: &lt;a href=&quot;select-core&quot;&gt;select-core &lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7939044785ba0a8ca2c0b2b3b645bfec873f9c5c" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;select-core&quot;&gt;select-core&lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt&lt;/a&gt;&lt;a href=&quot;table-or-subquery&quot;&gt;table-or-subquery&lt;/a&gt;</source>
          <target state="translated">Используется: &lt;a href=&quot;select-core&quot;&gt;select-core &lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt &lt;/a&gt;&lt;a href=&quot;table-or-subquery&quot;&gt;table-or-subquery&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8113b13214eea91b3a3368ba7da6ad54a4268b3b" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;select-core&quot;&gt;select-core&lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt&lt;/a&gt;&lt;a href=&quot;table-or-subquery&quot;&gt;table-or-subquery&lt;/a&gt;&lt;a href=&quot;update-stmt&quot;&gt;update-stmt&lt;/a&gt;&lt;a href=&quot;update-stmt-limited&quot;&gt;update-stmt-limited&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bcd5b650bb8cb46f8defc106f0dfcc99d5b051cd" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;select-core&quot;&gt;select-core&lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt&lt;/a&gt;&lt;a href=&quot;window-function-invocation&quot;&gt;window-function-invocation&lt;/a&gt;</source>
          <target state="translated">Используется: &lt;a href=&quot;select-core&quot;&gt;select-core &lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt &lt;/a&gt;&lt;a href=&quot;window-function-invocation&quot;&gt;window-function-invocation&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b4594a38d58964e1e237c00459543be8431bc246" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;sql-stmt&quot;&gt;sql-stmt&lt;/a&gt;</source>
          <target state="translated">Используется: &lt;a href=&quot;sql-stmt&quot;&gt;sql-stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="35b40c8cd50b969bfb81394dd732cd863e0cd4d1" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;sql-stmt-list&quot;&gt;sql-stmt-list&lt;/a&gt;</source>
          <target state="translated">Используется: &lt;a href=&quot;sql-stmt-list&quot;&gt;sql-stmt-list&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b23afd53b16f293ca94992760b0d75920c0db155" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;update-stmt&quot;&gt;update-stmt&lt;/a&gt;&lt;a href=&quot;update-stmt-limited&quot;&gt;update-stmt-limited&lt;/a&gt;&lt;a href=&quot;upsert-clause&quot;&gt;upsert-clause&lt;/a&gt;</source>
          <target state="translated">Используется: &lt;a href=&quot;update-stmt&quot;&gt;update-stmt &lt;/a&gt;&lt;a href=&quot;update-stmt-limited&quot;&gt;update-stmt-limited &lt;/a&gt;&lt;a href=&quot;upsert-clause&quot;&gt;upsert-clause&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="83a28142d94277b9f824e8d439d35c64935809cf" translate="yes" xml:space="preserve">
          <source>User Data For Functions</source>
          <target state="translated">Данные пользователя для функций</target>
        </trans-unit>
        <trans-unit id="f87f9bec30fa447642063fa0c8666b7e8eb0bcd7" translate="yes" xml:space="preserve">
          <source>User defined functions can be created using the following routine:</source>
          <target state="translated">Определенные пользователем функции могут быть созданы с помощью следующей рутины:</target>
        </trans-unit>
        <trans-unit id="444756f6f1895c936bb10bab307f679e2df66fa7" translate="yes" xml:space="preserve">
          <source>User-definable text collating sequences.</source>
          <target state="translated">Определяемая пользователем текстовая подборка последовательностей.</target>
        </trans-unit>
        <trans-unit id="41cabf87c0640a35632815a9c1c75379f4b103ed" translate="yes" xml:space="preserve">
          <source>User-defined Collating Sequences</source>
          <target state="translated">Определяемые пользователем последовательности коллекционирования</target>
        </trans-unit>
        <trans-unit id="679b4a0d57b60e54b747cb9aacd21774ca84d965" translate="yes" xml:space="preserve">
          <source>User-defined aggregate window functions may be created using the &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_window_function&lt;/a&gt;() API. Implementing an aggregate window function is very similar to an ordinary aggregate function. Any user-defined aggregate window function may also be used as an ordinary aggregate. To implement a user-defined aggregate window function the application must supply four callback functions:</source>
          <target state="translated">Определяемые пользователем агрегированные оконные функции могут быть созданы с использованием API &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_window_function&lt;/a&gt; (). Реализация агрегатной оконной функции очень похожа на обычную агрегатную функцию. Любая определяемая пользователем агрегатная оконная функция также может использоваться как обычная агрегатная функция. Для реализации определяемой пользователем функции агрегированного окна приложение должно предоставить четыре функции обратного вызова:</target>
        </trans-unit>
        <trans-unit id="8cb5450ed96e61339c7346965130b897dcacb151" translate="yes" xml:space="preserve">
          <source>User-defined text collating sequences.</source>
          <target state="translated">Определенные пользователем текстовые коллекционные последовательности.</target>
        </trans-unit>
        <trans-unit id="e6d26b2d97c6ea4098987a42caa6c50e042619be" translate="yes" xml:space="preserve">
          <source>Uses 9% fewer CPU cycles. (See the &lt;a href=&quot;cpu&quot;&gt;CPU performance measurement&lt;/a&gt; report for details on how this performance increase was computed.)</source>
          <target state="translated">Использует на 9% меньше циклов ЦП. (См. Отчет об &lt;a href=&quot;cpu&quot;&gt;измерении производительности ЦП&lt;/a&gt; для получения подробной информации о том, как было вычислено это увеличение производительности.)</target>
        </trans-unit>
        <trans-unit id="d0301d0d4694000bac42286a893da835217aae2d" translate="yes" xml:space="preserve">
          <source>Uses compiler built-ins (ex: __builtin_bswap32() or _byteswap_ulong()) for byteswapping when available.</source>
          <target state="translated">Использует сборки компилятора (например:__builtin_bswap32()или _byteswap_ulong())для подмены байт,когда это возможно.</target>
        </trans-unit>
        <trans-unit id="f10225b09b2eddd2b69fc1125f1e8c1790100225" translate="yes" xml:space="preserve">
          <source>Uses the &lt;a href=&quot;c3ref/blob&quot;&gt;sqlite3_blob&lt;/a&gt; key/value access object instead of SQL for pulling content out of R-Tree nodes</source>
          <target state="translated">Использует объект доступа ключ / значение &lt;a href=&quot;c3ref/blob&quot;&gt;sqlite3_blob&lt;/a&gt; вместо SQL для извлечения содержимого из узлов R-Tree</target>
        </trans-unit>
        <trans-unit id="bf6a8d8b0b161f49ba5a16ea51a640dcb0e4cfe4" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode=OFF&lt;/a&gt; or &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode=MEMORY&lt;/a&gt; and taking an application crash in the middle of a write transaction.</source>
          <target state="translated">Использование &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode = OFF&lt;/a&gt; или &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode = MEMORY&lt;/a&gt; и сбой приложения в середине транзакции записи.</target>
        </trans-unit>
        <trans-unit id="1020c3daf5ee3d9c72ef57a803c58bd0586e47f7" translate="yes" xml:space="preserve">
          <source>Using CREATE or DROP to create or destroy a table or index is really the same as doing an INSERT or DELETE from the special &quot;sqlite_master&quot; table, at least from the point of view of the VDBE. The sqlite_master table is a special table that is automatically created for every SQLite database. It looks like this:</source>
          <target state="translated">Использование CREATE или DROP для создания или уничтожения таблицы или индекса на самом деле то же самое,что и выполнение INSERT или DELETE из специальной таблицы &quot;sqlite_master&quot;,по крайней мере,с точки зрения VDBE.Таблица sqlite_master-это специальная таблица,которая автоматически создается для каждой базы данных SQLite.Это выглядит следующим образом:</target>
        </trans-unit>
        <trans-unit id="4d2637c8d86cb85da8f8da94256a0cdc80d9b4c2" translate="yes" xml:space="preserve">
          <source>Using DDL or DML SQL statements, SQLite users may modify the contents and size of a database file. Exactly how changes to the logical database are translated to modifications to the database file is described in</source>
          <target state="translated">Используя SQL-операторы DDL или DML,пользователи SQLite могут изменять содержимое и размер файла базы данных.Точно как изменения в логической БД транслируются в модификации файла БД описано в разделе</target>
        </trans-unit>
        <trans-unit id="435c55e01cffb5570c6c79cda02f466b6061178b" translate="yes" xml:space="preserve">
          <source>Using Idx2 instead of Idx1 causes SQLite to examine a different set of rows, but it gets the same answer in the end (which is very important - remember that indices should never change the answer, only help SQLite to get to the answer more quickly) and it does the same amount of work. So the Idx2 index did not help performance in this case.</source>
          <target state="translated">Использование Idx2 вместо Idx1 заставляет SQLite исследовать другой набор строк,но в итоге он получает тот же ответ (что очень важно-помните,что индексы никогда не должны менять ответ,только помогают SQLite быстрее добраться до ответа)и делает тот же объем работы.Поэтому индекс Idx2 в данном случае не помог в работе.</target>
        </trans-unit>
        <trans-unit id="c7fd16dcb5fbd84cb48400bd250b2f97394100cb" translate="yes" xml:space="preserve">
          <source>Using Indexes To Speed Searching</source>
          <target state="translated">Использование индексов для быстрого поиска</target>
        </trans-unit>
        <trans-unit id="9f210fd1e7b63cdc7dd0138afd84809f14583a65" translate="yes" xml:space="preserve">
          <source>Using SELECT Statements As Terms In An Expression</source>
          <target state="translated">Использование выражений SELECT как терминов в выражении</target>
        </trans-unit>
        <trans-unit id="97437976ebeb573c52b13ddfd438d2c91bf1893b" translate="yes" xml:space="preserve">
          <source>Using SQLite In Multi-Threaded Applications</source>
          <target state="translated">Использование SQLite в многопоточных приложениях</target>
        </trans-unit>
        <trans-unit id="307f31c1c11aebab82631ac4f8b0ab54eca6e078" translate="yes" xml:space="preserve">
          <source>Using a MATCH operator in the WHERE clause of a SELECT statement, or</source>
          <target state="translated">Использование MATCH-оператора в пункте WHERE заявления SELECT,или</target>
        </trans-unit>
        <trans-unit id="3e68860fe2d2ad5dc9651e317f240eed014363dc" translate="yes" xml:space="preserve">
          <source>Using a built-in printf() implementation means that SQLite has one fewer dependency on the host environment, making it more portable.</source>
          <target state="translated">Использование встроенной реализации printf()означает,что SQLite имеет на одну зависимость меньше от хостового окружения,что делает его более портативным.</target>
        </trans-unit>
        <trans-unit id="c90117e39221737f02ea3e7e44c49c43210beeb3" translate="yes" xml:space="preserve">
          <source>Using a database file with 8+3 filenames in some cases while in other cases using long filenames is equivalent to &lt;a href=&quot;howtocorrupt#delhotjrnl&quot;&gt;deleting a hot journal&lt;/a&gt;.</source>
          <target state="translated">Использование файла базы данных с 8 + 3 именами в некоторых случаях, в то время как в других случаях использование длинных имен файлов эквивалентно &lt;a href=&quot;howtocorrupt#delhotjrnl&quot;&gt;удалению горячего журнала&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8fb331fbfc19c9ad94dbe708335967012f83cb31" translate="yes" xml:space="preserve">
          <source>Using a dataset of American place names (derived from &lt;a href=&quot;http://geonames.usgs.gov/domestic/download_data.htm&quot;&gt;http://geonames.usgs.gov/domestic/download_data.htm&lt;/a&gt;) the query above returns 20 results beginning with:</source>
          <target state="translated">Используя набор данных американских географических названий (полученных из &lt;a href=&quot;http://geonames.usgs.gov/domestic/download_data.htm&quot;&gt;http://geonames.usgs.gov/domestic/download_data.htm&lt;/a&gt; ), приведенный выше запрос возвращает 20 результатов, начиная с:</target>
        </trans-unit>
        <trans-unit id="cced5340290d93733d759f1a49ce8d467995399f" translate="yes" xml:space="preserve">
          <source>Using a single query such as the above, the application obtains a list of the slideIds for all slides in the presentation. The application then queries for the content of the first slide, and parses and displays that content, as before.</source>
          <target state="translated">Используя один запрос,подобный вышеуказанному,приложение получает список слайдов для всех слайдов в презентации.Затем приложение запрашивает содержимое первого слайда,разбирает и отображает его,как и прежде.</target>
        </trans-unit>
        <trans-unit id="7dd3bf0fc645009566609bccf3a14f62d35a3f59" translate="yes" xml:space="preserve">
          <source>Using an equals (&quot;=&quot;) operator in the WHERE clause of a SELECT statement, or</source>
          <target state="translated">Использование оператора equals (&quot;=&quot;)в пункте WHERE оператора SELECT,или</target>
        </trans-unit>
        <trans-unit id="23bf7370fe569447da050d73459abb59d1093647" translate="yes" xml:space="preserve">
          <source>Using an ordinary disk file to provide shared memory has the disadvantage that it might actually do unnecessary disk I/O by writing the shared memory to disk. However, the developers do not think this is a major concern since the wal-index rarely exceeds 32 KiB in size and is never synced. Furthermore, the wal-index backing file is deleted when the last database connection disconnects, which often prevents any real disk I/O from ever happening.</source>
          <target state="translated">Использование обычного дискового файла для обеспечения общей памяти имеет недостаток,заключающийся в том,что он может на самом деле делать ненужные дисковые операции ввода/вывода,записывая общую память на диск.Однако разработчики не считают это серьезной проблемой,так как размер wal-index редко превышает 32 KiB и никогда не синхронизируется.Более того,файл поддержки wal-index удаляется при разрыве последнего соединения с базой данных,что часто предотвращает любой реальный ввод/вывод с диска.</target>
        </trans-unit>
        <trans-unit id="314bb9e64d758d2b63c2c5acc0e1727dc6e61abf" translate="yes" xml:space="preserve">
          <source>Using an unnamed subquery in a FROM clause would cause a segfault.</source>
          <target state="translated">Использование неназванного подзапроса в пункте FROM приведет к сегрегации.</target>
        </trans-unit>
        <trans-unit id="9766cdfa57f62810ee226e9c3deec347064cc20b" translate="yes" xml:space="preserve">
          <source>Using gcov (or similar) to show that every branch instruction is taken at least once in both directions is good measure of test suite quality. But even better is showing that every branch instruction makes a difference in the output. In other words, we want to show not only that every branch instruction both jumps and falls through but also that every branch is doing useful work and that the test suite is able to detect and verify that work. When a branch is found that does not make a difference in the output, that suggests that the code associated the branch can be removed (reducing the size of the library and perhaps making it run faster) or that the test suite is inadequately testing the feature that the branch implements.</source>
          <target state="translated">Использование gcov (или аналогичного)для того,чтобы показать,что каждая инструкция по ветке выполняется хотя бы один раз в обоих направлениях,является хорошей мерой качества тестового набора.Но ещё лучше показать,что каждая инструкция ветки имеет значение для вывода.Другими словами,мы хотим показать не только то,что каждая инструкция ответвления как прыгает,так и падает,но и то,что каждое ответвление выполняет полезную работу и что набор тестов способен обнаружить и проверить эту работу.Когда обнаруживается ответвление,которое не имеет разницы в выводах,это говорит о том,что код,связанный с ответвлением,может быть удалён (уменьшив размер библиотеки и,возможно,заставив её работать быстрее),или что набор тестов неадекватно тестирует возможность,реализованную в ответвлении.</target>
        </trans-unit>
        <trans-unit id="db5729475276e1f07562cb2df1e724ad2371713c" translate="yes" xml:space="preserve">
          <source>Using one particular subset of the available TH3 test modules (the &quot;cov1&quot; tests) SQLite obtained &lt;a href=&quot;testing#coverage&quot;&gt;100% branch test coverage&lt;/a&gt; and 100% &lt;a href=&quot;testing#mcdc&quot;&gt;MC/DC&lt;/a&gt; as measured by &lt;a href=&quot;http://gcc.gnu.org/onlinedocs/gcc/Gcov.html&quot;&gt;gcov&lt;/a&gt; on Linux x86 and x86_64 hardware. All releases of SQLite since &lt;a href=&quot;https://sqlite.org/releaselog/3_6_17.html&quot;&gt;version 3.6.17&lt;/a&gt; (2009-08-10) have been tested to this standard. The SQLite developers are committed to maintaining 100% branch coverage and MC/DC for all future releases of SQLite.</source>
          <target state="translated">Используя одно конкретное подмножество доступных тестовых модулей TH3 (тесты &amp;laquo;cov1&amp;raquo;), SQLite получил &lt;a href=&quot;testing#coverage&quot;&gt;100% тестовое покрытие ветвей&lt;/a&gt; и 100% &lt;a href=&quot;testing#mcdc&quot;&gt;MC / DC,&lt;/a&gt; как измерено &lt;a href=&quot;http://gcc.gnu.org/onlinedocs/gcc/Gcov.html&quot;&gt;gcov&lt;/a&gt; на оборудовании Linux x86 и x86_64. Все выпуски SQLite, начиная с &lt;a href=&quot;https://sqlite.org/releaselog/3_6_17.html&quot;&gt;версии 3.6.17&lt;/a&gt; ( 10.08.2009 ), были протестированы на соответствие этому стандарту. Разработчики SQLite стремятся поддерживать 100% покрытие ветвей и MC / DC для всех будущих выпусков SQLite.</target>
        </trans-unit>
        <trans-unit id="9270ae0408b0c691c7bbd964a691a187fe62e891" translate="yes" xml:space="preserve">
          <source>Using subtypes to identify valid pointers prevented the WebSQL exploit. But it turned out to be an incomplete solution.</source>
          <target state="translated">Использование подтипов для идентификации действительных указателей препятствовало использованию эксплойта WebSQL.Но это оказалось неполным решением.</target>
        </trans-unit>
        <trans-unit id="4b795c9ed4e93bd126c1058e30a1d247be674aba" translate="yes" xml:space="preserve">
          <source>Using the &lt;a href=&quot;fts3#*fts4content&quot;&gt;FTS4 content option&lt;/a&gt; and failing to manually keep the content in sync with the FTS4 inverted indices.</source>
          <target state="translated">Использование &lt;a href=&quot;fts3#*fts4content&quot;&gt;опции контента FTS4&lt;/a&gt; и невозможность вручную синхронизировать контент с инвертированными индексами FTS4.</target>
        </trans-unit>
        <trans-unit id="c352b493b2f0901876aea8d20656c0d87ef6b6a9" translate="yes" xml:space="preserve">
          <source>Using the N+1 Query pattern in Fossil does not harm the application. But the N+1 Query pattern does have benefits. For one, the section of the code that creates the timeline query can be completely separate from the section that prepares each timeline entry for display. This provides a separation of responsibility that helps keep the code simple and easy to maintain. Secondly, the information needed for display, and the queries needed to extract that information, vary according to what type of objects to be shown. Check-ins need one set of queries. Tickets need another set of queries. Wiki pages need a different query. And so forth. By implementing these queries on-demand and in the part of the code dealing with the various entities, there is further separation of responsibility and simplification of the overall code base.</source>
          <target state="translated">Использование шаблона N+1 &quot;Запрос&quot; в &quot;Ископаемом&quot; не наносит вреда приложению.Но шаблон N+1 &quot;Запрос&quot; имеет свои преимущества.Во-первых,секция кода,которая создает запрос на временную шкалу,может быть полностью отделена от секции,которая подготавливает каждую запись на временной шкале для отображения.Это обеспечивает разделение ответственности,которое помогает поддерживать код простым и легким в обслуживании.Во-вторых,информация,необходимая для отображения,и запросы,необходимые для извлечения этой информации,варьируются в зависимости от типа отображаемых объектов.Проверки требуют одного набора запросов.Тикеты нуждаются в другом наборе запросов.Вики-страницам нужен другой запрос.И так далее.Реализуя эти запросы по требованию и в части кода,имеющей дело с различными сущностями,происходит дальнейшее разделение ответственности и упрощение общей базы кода.</target>
        </trans-unit>
        <trans-unit id="ed8c795d039e297badfdb934d5dad24eb9711fc6" translate="yes" xml:space="preserve">
          <source>Using the SQLite Online Backup API</source>
          <target state="translated">Использование API SQLite Online Backup</target>
        </trans-unit>
        <trans-unit id="702c33598d91f7511e11baf351b09ecd585c68e7" translate="yes" xml:space="preserve">
          <source>Using the VFS xAccess() method, SQLite queries the file-system to see if the journal file associated with the database exists. If it does not, then there is no hot-journal file.</source>
          <target state="translated">Используя метод VFS xAccess(),SQLite запрашивает файловую систему,чтобы проверить,существует ли файл журнала,связанный с базой данных.Если нет,то горячий файл журнала отсутствует.</target>
        </trans-unit>
        <trans-unit id="15a6ded3b6ea323ecf5d8ed10a9908901c0cf29c" translate="yes" xml:space="preserve">
          <source>Using the memcpy() function on overlapping buffers.</source>
          <target state="translated">Использование функции memcpy()на перекрывающихся буферах.</target>
        </trans-unit>
        <trans-unit id="0ff71664481484af5340c1f4f2d1ad694ff3ab5e" translate="yes" xml:space="preserve">
          <source>Using the new Idx2 index on &quot;state&quot;, SQLite has another option for lookup up the price of California oranges: it can look up every row that contains fruit from California and filter out those rows that are not oranges.</source>
          <target state="translated">Используя новый индекс Idx2 в &quot;состоянии&quot;,SQLite имеет еще один вариант поиска цены калифорнийских апельсинов:он может искать вверх каждую строку,содержащую фрукты из Калифорнии,и отфильтровывать те строки,которые не являются апельсинами.</target>
        </trans-unit>
        <trans-unit id="fcde00cc70debec35832ff9273a06512f95fa039" translate="yes" xml:space="preserve">
          <source>Using the sqlite3_unlock_notify() API</source>
          <target state="translated">Использование API sqlite3_unlock_notify()</target>
        </trans-unit>
        <trans-unit id="08fc370c39b7ca0e2248cedd981f211b8dabd8d8" translate="yes" xml:space="preserve">
          <source>Using the two routines above, it is simple for applications to insert new records into or extract existing records from an SQLite Archive. Insert a new into an SQLite Archive using code like this:</source>
          <target state="translated">Используя две вышеописанные процедуры,приложениям достаточно просто вставлять новые записи или извлекать существующие записи из архива SQLite.Вставьте новую запись в SQLite Archive,используя такой код:</target>
        </trans-unit>
        <trans-unit id="5881634960ec51d660f927c3ca27237c1640f650" translate="yes" xml:space="preserve">
          <source>Using the virtual table interface, new entries may be added to a zip archive by inserting new rows into the virtual table. Entries may be removed by deleting rows or modified by updating them.</source>
          <target state="translated">Используя интерфейс виртуальной таблицы,новые записи могут быть добавлены в zip-архив путем вставки новых строк в виртуальную таблицу.Записи могут быть удалены путем удаления строк или изменены путем их обновления.</target>
        </trans-unit>
        <trans-unit id="e7f12616ba6b09fc33431b9c20577f960596b4bb" translate="yes" xml:space="preserve">
          <source>Using the xFileSize() method of the file-handle opened on the database file, SQLite checks if the database file is 0 bytes in size. If it is, the journal file is not considered to be a</source>
          <target state="translated">Используя метод xFileSize()файла-ручки,открываемого в файле базы данных,SQLite проверяет,не имеет ли размер файла базы данных 0 байт.Если да,то файл журнала не считается</target>
        </trans-unit>
        <trans-unit id="18744e7331495a3e5c139b339aa5a7dcf1c94f70" translate="yes" xml:space="preserve">
          <source>Usually (the exceptions are &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; tables and &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables) a PRIMARY KEY in an SQLite table is really the same as a UNIQUE constraint. Due to an historical oversight, the column values of such a PRIMARY KEY are allowed to be NULL. This is a bug, but by the time the problem was discovered there where so many databases in circulation that depended on the bug that the decision was made to support the bugging behavior moving forward.</source>
          <target state="translated">Обычно (исключения - &lt;a href=&quot;lang_createtable#rowid&quot;&gt;это&lt;/a&gt; таблицы INTEGER PRIMARY KEY и таблицы &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; ) PRIMARY KEY в таблице SQLite действительно совпадает с ограничением UNIQUE. Из-за исторического недосмотра значения столбца такого PRIMARY KEY могут быть NULL. Это ошибка, но к тому времени, когда проблема была обнаружена там, где в обращении было так много баз данных, которые зависели от ошибки, было принято решение поддерживать поведение ошибки в дальнейшем.</target>
        </trans-unit>
        <trans-unit id="f79481390537aded0fd54463773aac91edd4e79c" translate="yes" xml:space="preserve">
          <source>Usually only a subset of the pages in the database file are read. In this example we are showing three pages out of eight being read. In a typical application, a database will have thousands of pages and a query will normally only touch a small percentage of those pages.</source>
          <target state="translated">Обычно читается только подмножество страниц в файле базы данных.В данном примере мы показываем три страницы из восьми прочитанных.В типичном приложении база данных будет содержать тысячи страниц,и запрос обычно касается только небольшого процента этих страниц.</target>
        </trans-unit>
        <trans-unit id="27499120d97c0cbd6ba1013d6ea9b6e679141d60" translate="yes" xml:space="preserve">
          <source>Usually the b-trees for tables and indexes are slightly different. A table b-tree contains a 64-bit integer key and arbitrary data. The 64-bit integer key is the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt;. Index b-trees contain an arbitrary binary key and no data. So table b-trees and index b-trees are not directly compatible.</source>
          <target state="translated">Обычно b-деревья для таблиц и индексов немного отличаются. B-дерево таблицы содержит 64-битный целочисленный ключ и произвольные данные. 64-битный целочисленный ключ - это &lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt; . Индексные b-деревья содержат произвольный двоичный ключ и не содержат данных. Таким образом, b-деревья таблиц и b-деревья индексов не совместимы напрямую.</target>
        </trans-unit>
        <trans-unit id="63880029448f25d934c11aa39c24fad9c0bb97f6" translate="yes" xml:space="preserve">
          <source>Usually, a new</source>
          <target state="translated">Обычно,новый</target>
        </trans-unit>
        <trans-unit id="251e8707bded33b5cb244d2e22971c5ac18fc6ad" translate="yes" xml:space="preserve">
          <source>Usually, an &lt;a href=&quot;fts3&quot;&gt;FTS3 or FTS4&lt;/a&gt; table is an example of a virtual table with a rowid that works like a PRIMARY KEY. So, for the following FTS4 tables:</source>
          <target state="translated">Обычно &lt;a href=&quot;fts3&quot;&gt;таблица FTS3 или FTS4&lt;/a&gt; является примером виртуальной таблицы с rowid, которая работает как PRIMARY KEY. Итак, для следующих таблиц FTS4:</target>
        </trans-unit>
        <trans-unit id="016fa908ece58367a08159cc60971094eae348ed" translate="yes" xml:space="preserve">
          <source>Usually, it does not matter if the page-sizes of the source database and the destination database are different before the contents of the destination are overwritten. The page-size of the destination database is simply changed as part of the backup operation. The exception is if the destination database happens to be an in-memory database. In this case, if the page sizes are not the same at the start of the backup operation, then the operation fails with an SQLITE_READONLY error. Unfortunately, this could occur when loading a database image from a file into an in-memory database using function loadOrSaveDb().</source>
          <target state="translated">Обычно не имеет значения,различаются ли размеры страниц исходной и целевой базы данных до того,как содержимое назначения будет перезаписано.Размер страниц целевой базы данных просто изменяется в процессе резервного копирования.Исключение составляют случаи,когда база данных получателя оказывается базой данных in-memory.В этом случае,если размеры страниц в начале операции резервного копирования не совпадают,то операция завершится неудачей с ошибкой SQLITE_READONLY.К сожалению,это может произойти при загрузке образа БД из файла в БД in-memory с помощью функции loadOrSaveDb().</target>
        </trans-unit>
        <trans-unit id="6590aa5b903de1376b91e1364c96b7ab1602da04" translate="yes" xml:space="preserve">
          <source>Usually, no data is actually written to the database file until the user commits the active</source>
          <target state="translated">Обычно никакие данные не записываются в файл базы данных до тех пор,пока пользователь не зафиксирует active</target>
        </trans-unit>
        <trans-unit id="5bf501f181ccf2cf7d7e6317299b267cead1ee47" translate="yes" xml:space="preserve">
          <source>Usually, output parameter *piPhrase is set to the phrase number, *piCol to the column in which it occurs and *piOff the token offset of the first token of the phrase. Returns SQLITE_OK if successful, or an error code (i.e. SQLITE_NOMEM) if an error occurs.</source>
          <target state="translated">Обычно выходной параметр *piPhrase задается номером фразы,*piCol-столбцом,в котором она встречается,и *piOff-смещением лексемы первой лексемы фразы.Возвращает SQLITE_OK в случае успеха или код ошибки (т.е.SQLITE_NOMEM)в случае возникновения ошибки.</target>
        </trans-unit>
        <trans-unit id="4375ef1d6cde5037d03b8ccb25b702b95cd0734d" translate="yes" xml:space="preserve">
          <source>Usually, the default mutex implementations provided by SQLite are sufficient, however the application has the option of substituting a custom implementation for specialized deployments or systems for which SQLite does not provide a suitable implementation. In this case, the application creates and populates an instance of this structure to pass to sqlite3_config() along with the &lt;a href=&quot;#sqliteconfigmutex&quot;&gt;SQLITE_CONFIG_MUTEX&lt;/a&gt; option. Additionally, an instance of this structure can be used as an output variable when querying the system for the current mutex implementation, using the &lt;a href=&quot;#sqliteconfiggetmutex&quot;&gt;SQLITE_CONFIG_GETMUTEX&lt;/a&gt; option.</source>
          <target state="translated">Обычно реализаций мьютексов по умолчанию, предоставляемых SQLite, достаточно, однако приложение имеет возможность заменить специализированные развертывания или системы, для которых SQLite не предоставляет подходящей реализации, специальной реализацией. В этом случае приложение создает и заполняет экземпляр этой структуры для передачи в sqlite3_config () вместе с параметром &lt;a href=&quot;#sqliteconfigmutex&quot;&gt;SQLITE_CONFIG_MUTEX&lt;/a&gt; . Кроме того, экземпляр этой структуры может использоваться в качестве выходной переменной при запросе системы на предмет текущей реализации мьютекса с помощью параметра &lt;a href=&quot;#sqliteconfiggetmutex&quot;&gt;SQLITE_CONFIG_GETMUTEX&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d9cb5f2ee721a0e054d3593ea56d06ca4f711a8d" translate="yes" xml:space="preserve">
          <source>Usually, the default mutex implementations provided by SQLite are sufficient, however the application has the option of substituting a custom implementation for specialized deployments or systems for which SQLite does not provide a suitable implementation. In this case, the application creates and populates an instance of this structure to pass to sqlite3_config() along with the &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigmutex&quot;&gt;SQLITE_CONFIG_MUTEX&lt;/a&gt; option. Additionally, an instance of this structure can be used as an output variable when querying the system for the current mutex implementation, using the &lt;a href=&quot;c_config_covering_index_scan#sqliteconfiggetmutex&quot;&gt;SQLITE_CONFIG_GETMUTEX&lt;/a&gt; option.</source>
          <target state="translated">Обычно реализаций мьютексов по умолчанию, предоставляемых SQLite, достаточно, однако приложение имеет возможность заменить специализированные развертывания или системы, для которых SQLite не предоставляет подходящей реализации, специальной реализацией. В этом случае приложение создает и заполняет экземпляр этой структуры для передачи в sqlite3_config () вместе с параметром &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigmutex&quot;&gt;SQLITE_CONFIG_MUTEX&lt;/a&gt; . Кроме того, экземпляр этой структуры может использоваться в качестве выходной переменной при запросе системы на предмет текущей реализации мьютекса с помощью параметра &lt;a href=&quot;c_config_covering_index_scan#sqliteconfiggetmutex&quot;&gt;SQLITE_CONFIG_GETMUTEX&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f67d8e98eea6d06da4e67ed9ebc795e5c21c27d3" translate="yes" xml:space="preserve">
          <source>Usually, the parent key of a foreign key constraint is the primary key of the parent table. If they are not the primary key, then the parent key columns must be collectively subject to a UNIQUE constraint or have a UNIQUE index. If the parent key columns have a UNIQUE index, then that index must use the collation sequences that are specified in the CREATE TABLE statement for the parent table. For example,</source>
          <target state="translated">Обычно родительский ключ ограничения по внешнему ключу является первичным ключом в родительской таблице.Если они не являются первичным ключом,то столбцы родительского ключа должны совместно подчиняться ограничению UNIQUE или иметь UNIQUE-индекс.Если столбцы родительского ключа имеют UNIQUE-индекс,то этот индекс должен использовать последовательности колонок,которые заданы в операторе CREATE TABLE для родительской таблицы.Например,</target>
        </trans-unit>
        <trans-unit id="6dab9ce5b9389cc793db1ee13d4fd8a8749eccd9" translate="yes" xml:space="preserve">
          <source>Usually, the sessions module encloses all operations performed by a single call to apply_v2() or apply_v2_strm() in a &lt;a href=&quot;../lang_savepoint&quot;&gt;SAVEPOINT&lt;/a&gt;. The SAVEPOINT is committed if the changeset or patchset is successfully applied, or rolled back if an error occurs. Specifying this flag causes the sessions module to omit this savepoint. In this case, if the caller has an open transaction or savepoint when apply_v2() is called, it may revert the partially applied changeset by rolling it back.</source>
          <target state="translated">Обычно модуль сеансов включает все операции, выполняемые одним вызовом apply_v2 () или apply_v2_strm (), в &lt;a href=&quot;../lang_savepoint&quot;&gt;SAVEPOINT&lt;/a&gt; . SAVEPOINT фиксируется, если набор изменений или набор исправлений успешно применен, или откатывается, если возникает ошибка. Установка этого флага заставляет модуль сеансов пропускать эту точку сохранения. В этом случае, если вызывающий имеет открытую транзакцию или точку сохранения при вызове apply_v2 (), он может отменить частично примененный набор изменений, откатив его.</target>
        </trans-unit>
        <trans-unit id="651dad2d1a7cdde77afe8c8f6efa3556819be19f" translate="yes" xml:space="preserve">
          <source>Usually, the sessions module encloses all operations performed by a single call to apply_v2() or apply_v2_strm() in a &lt;a href=&quot;lang_savepoint&quot;&gt;SAVEPOINT&lt;/a&gt;. The SAVEPOINT is committed if the changeset or patchset is successfully applied, or rolled back if an error occurs. Specifying this flag causes the sessions module to omit this savepoint. In this case, if the caller has an open transaction or savepoint when apply_v2() is called, it may revert the partially applied changeset by rolling it back.</source>
          <target state="translated">Обычно модуль сеансов включает все операции, выполняемые одним вызовом apply_v2 () или apply_v2_strm (), в &lt;a href=&quot;lang_savepoint&quot;&gt;SAVEPOINT&lt;/a&gt; . SAVEPOINT фиксируется, если набор изменений или набор исправлений успешно применен, или откатывается, если возникает ошибка. Установка этого флага заставляет модуль сеансов пропускать эту точку сохранения. В этом случае, если вызывающий имеет открытую транзакцию или точку сохранения при вызове apply_v2 (), он может отменить частично примененный набор изменений, откатив его.</target>
        </trans-unit>
        <trans-unit id="a7c5b3a786dedb589ca7dfd4119dc946fad418cc" translate="yes" xml:space="preserve">
          <source>Usually, when a database in wal mode is closed or detached from a database handle, SQLite checks if this will mean that there are now no connections at all to the database. If so, it performs a checkpoint operation before closing the connection. This option may be used to override this behaviour. The first parameter passed to this operation is an integer - positive to disable checkpoints-on-close, or zero (the default) to enable them, and negative to leave the setting unchanged. The second parameter is a pointer to an integer into which is written 0 or 1 to indicate whether checkpoints-on-close have been disabled - 0 if they are not disabled, 1 if they are.</source>
          <target state="translated">Обычно,когда БД в режиме wal закрыта или отсоединена от дескриптора БД,SQLite проверяет,не будет ли это означать,что теперь нет никаких подключений к БД.Если да,то перед закрытием соединения он выполняет операцию на контрольной точке.Эта опция может быть использована для переопределения такого поведения.Первый параметр,передаваемый для этой операции-целое число-положительное,чтобы отключить контрольные точки-on-close,или нулевое (по умолчанию),чтобы включить их,и отрицательное,чтобы оставить настройку без изменений.Второй параметр-указатель на целое число,в которое записано 0 или 1,чтобы указать,были ли отключены контрольно-пропускные пункты-on-close-0,если они не отключены,1,если отключены.</target>
        </trans-unit>
        <trans-unit id="18fdc5ee8b1f8fba8dabaa933373c0483ab7fad7" translate="yes" xml:space="preserve">
          <source>Utilities</source>
          <target state="translated">Utilities</target>
        </trans-unit>
        <trans-unit id="998ce99ff7bc11e5fda480fd5bfcbe7172fa1458" translate="yes" xml:space="preserve">
          <source>Utter only truth from heart and mouth.</source>
          <target state="translated">Только абсолютная правда от сердца и изо рта.</target>
        </trans-unit>
        <trans-unit id="0a83488e309bcd16565cc48e7357404309c680f8" translate="yes" xml:space="preserve">
          <source>VACUUM</source>
          <target state="translated">VACUUM</target>
        </trans-unit>
        <trans-unit id="338c2017b922c8c778a643c9a2bb9bb0d159e34d" translate="yes" xml:space="preserve">
          <source>VACUUM INTO</source>
          <target state="translated">ВАКУМ ИНТО</target>
        </trans-unit>
        <trans-unit id="204b6e5828ce2852bf6877318b1361fbae1e4020" translate="yes" xml:space="preserve">
          <source>VACUUM uses a temporary file in the official TEMP folder, not in the same directory as the original database</source>
          <target state="translated">VACUUM использует временный файл в официальной папке TEMP,а не в той же директории,что и исходная база данных.</target>
        </trans-unit>
        <trans-unit id="eba0ca62d23c0aa5d1fd44639bb5b08cca16a456" translate="yes" xml:space="preserve">
          <source>VACUUM with an INTO clause</source>
          <target state="translated">VACUUM с пунктом INTO</target>
        </trans-unit>
        <trans-unit id="b3cba55338b3625665f9ea5a7e33ff9db26da1af" translate="yes" xml:space="preserve">
          <source>VALUES</source>
          <target state="translated">VALUES</target>
        </trans-unit>
        <trans-unit id="3893415f582da8528cfdc804ac3bee7e25a15ab1" translate="yes" xml:space="preserve">
          <source>VALUES clause</source>
          <target state="translated">оговорка о ЦЕННОСТЯХ</target>
        </trans-unit>
        <trans-unit id="2010132ce9d7ecb7ffcd8583e46eb6830b5b89ee" translate="yes" xml:space="preserve">
          <source>VARCHAR(255)</source>
          <target state="translated">VARCHAR(255)</target>
        </trans-unit>
        <trans-unit id="8e2934685262dc368f8941746e5ac5ff58123235" translate="yes" xml:space="preserve">
          <source>VARYING CHARACTER(255)</source>
          <target state="translated">РАЗЛИЧНЫЙ ХАРАКТЕР(255)</target>
        </trans-unit>
        <trans-unit id="efde179e9b49292e75991e12678580f142a070e1" translate="yes" xml:space="preserve">
          <source>VBegin</source>
          <target state="translated">VBegin</target>
        </trans-unit>
        <trans-unit id="d0eedafb13c92d47b81b7b056def9e323b6e493c" translate="yes" xml:space="preserve">
          <source>VColumn</source>
          <target state="translated">VColumn</target>
        </trans-unit>
        <trans-unit id="f84b9b0948754b7d110e0815c9837bdc1fddebe7" translate="yes" xml:space="preserve">
          <source>VCreate</source>
          <target state="translated">VCreate</target>
        </trans-unit>
        <trans-unit id="91b564dbaa1169fe6e48962a34cffa4f703f0be0" translate="yes" xml:space="preserve">
          <source>VDestroy</source>
          <target state="translated">VDestroy</target>
        </trans-unit>
        <trans-unit id="b33892fbddeffc3368077b4904ad0b3d562a7312" translate="yes" xml:space="preserve">
          <source>VERSION</source>
          <target state="translated">VERSION</target>
        </trans-unit>
        <trans-unit id="9913e8aa2ef97f43053931ebe92afe906139c950" translate="yes" xml:space="preserve">
          <source>VFS</source>
          <target state="translated">VFS</target>
        </trans-unit>
        <trans-unit id="e0bba973b3126bd49629e5735098909a83c37fb8" translate="yes" xml:space="preserve">
          <source>VFS Adaptor Related Assumptions</source>
          <target state="translated">Допущения,связанные с VFS адаптером</target>
        </trans-unit>
        <trans-unit id="0427fe52d1301f469be76b38e86110229024c26c" translate="yes" xml:space="preserve">
          <source>VFS shim</source>
          <target state="translated">шайба VFS</target>
        </trans-unit>
        <trans-unit id="42c3d050c1ab4fc79ee66e794588a38879f87c59" translate="yes" xml:space="preserve">
          <source>VFilter</source>
          <target state="translated">VFilter</target>
        </trans-unit>
        <trans-unit id="0fa2ff5785952199b4086a34e015d691fb6f638e" translate="yes" xml:space="preserve">
          <source>VIEW</source>
          <target state="translated">VIEW</target>
        </trans-unit>
        <trans-unit id="d1ea68c099681d5006dd208d2e34db6600ee8c5a" translate="yes" xml:space="preserve">
          <source>VIEWs in SQLite are read-only. You may not execute a DELETE, INSERT, or UPDATE statement on a view. But you can create a trigger that fires on an attempt to DELETE, INSERT, or UPDATE a view and do what you need in the body of the trigger.</source>
          <target state="translated">VIEWs в SQLite доступны только для чтения.Вы не можете выполнять операторы DELETE,INSERT или UPDATE на просмотре.Но вы можете создать триггер,который будет срабатывать при попытке DELETE,INSERT или UPDATE представления и делать все,что вам нужно в теле триггера.</target>
        </trans-unit>
        <trans-unit id="5fe4dd429e7ca82543f447d5b6e37edc0b0211f3" translate="yes" xml:space="preserve">
          <source>VIRTUAL</source>
          <target state="translated">VIRTUAL</target>
        </trans-unit>
        <trans-unit id="b9de5e41c6dc887dbc8f743605405fee0be8e279" translate="yes" xml:space="preserve">
          <source>VNext</source>
          <target state="translated">VNext</target>
        </trans-unit>
        <trans-unit id="348f1db286c8e9b47c43f2f013b0dd88171bf692" translate="yes" xml:space="preserve">
          <source>VOpen</source>
          <target state="translated">VOpen</target>
        </trans-unit>
        <trans-unit id="9741852a241ce6064f8f2d351b08520dd5847d98" translate="yes" xml:space="preserve">
          <source>VRename</source>
          <target state="translated">VRename</target>
        </trans-unit>
        <trans-unit id="4bce4ebd3cc132100d6cc36475c7b1294f94edb7" translate="yes" xml:space="preserve">
          <source>VUpdate</source>
          <target state="translated">VUpdate</target>
        </trans-unit>
        <trans-unit id="5fe15df2c7882707d49fdc0903788dfd022b02ca" translate="yes" xml:space="preserve">
          <source>Vacuum</source>
          <target state="translated">Vacuum</target>
        </trans-unit>
        <trans-unit id="27b07b92ebcc99b13cdafff029c3e3d22606bada" translate="yes" xml:space="preserve">
          <source>Vacuum the entire database P1. P1 is 0 for &quot;main&quot;, and 2 or more for an attached database. The &quot;temp&quot; database may not be vacuumed.</source>
          <target state="translated">Вакуумируйте всю базу данных P1.P1 равен 0 для &quot;основного&quot;,а 2 и более для подключенного банка данных.База данных &quot;Температура&quot; не может быть вакуумирована.</target>
        </trans-unit>
        <trans-unit id="0819f8114e772508968d8c091f0521044cadc7f0" translate="yes" xml:space="preserve">
          <source>Valgrind analysis</source>
          <target state="translated">анализ Вальгранда</target>
        </trans-unit>
        <trans-unit id="4869177d0c589735a7d4b9114f8982fe5d26f899" translate="yes" xml:space="preserve">
          <source>Value is a BLOB that is (N-12)/2 bytes in length.</source>
          <target state="translated">Значение-это BLOB,длина которого (N-12)/2 байта.</target>
        </trans-unit>
        <trans-unit id="5d5aa2bdd2060b855e479d53c2581cc8223ca5a6" translate="yes" xml:space="preserve">
          <source>Value is a NULL.</source>
          <target state="translated">Значение-NULL.</target>
        </trans-unit>
        <trans-unit id="c499129fd21c535eaa7f12c5970a992328cc9e08" translate="yes" xml:space="preserve">
          <source>Value is a big-endian 16-bit twos-complement integer.</source>
          <target state="translated">Значение представляет собой биг-ендианское 16-битное двухкомпонентное целое число.</target>
        </trans-unit>
        <trans-unit id="e70cb145efe11c54bff7a396cfac28a6df7474e8" translate="yes" xml:space="preserve">
          <source>Value is a big-endian 24-bit twos-complement integer.</source>
          <target state="translated">Значение представляет собой биг-ендианское 24-битное двойное целое число.</target>
        </trans-unit>
        <trans-unit id="5e8e5ccfe7344d0d3d0abc79f36a5fdb932a3b7c" translate="yes" xml:space="preserve">
          <source>Value is a big-endian 32-bit twos-complement integer.</source>
          <target state="translated">Значение представляет собой биг-ендианское 32-битное двойное целое число.</target>
        </trans-unit>
        <trans-unit id="b3f234aeea73b3135246f413e61277eaccb53eb8" translate="yes" xml:space="preserve">
          <source>Value is a big-endian 48-bit twos-complement integer.</source>
          <target state="translated">Значение представляет собой биг-ендианское 48-битное двойное целое число.</target>
        </trans-unit>
        <trans-unit id="af2248db1aa0f6b54f70fbd4bad24187360977fd" translate="yes" xml:space="preserve">
          <source>Value is a big-endian 64-bit twos-complement integer.</source>
          <target state="translated">Значение представляет собой 64-битное биг-ендианское целое число двойного сложения.</target>
        </trans-unit>
        <trans-unit id="ae871c1581e8a49ebac1c7419a009e8fb57a2d5e" translate="yes" xml:space="preserve">
          <source>Value is a big-endian IEEE 754-2008 64-bit floating point number.</source>
          <target state="translated">Значение-это биг-ендианское IEEE 754-2008 64-битное число с плавающей точкой.</target>
        </trans-unit>
        <trans-unit id="02f41d10900d18e2f000b1b5a2e593cf69aeca4b" translate="yes" xml:space="preserve">
          <source>Value is a string in the &lt;a href=&quot;fileformat2#enc&quot;&gt;text encoding&lt;/a&gt; and (N-13)/2 bytes in length. The nul terminator is not stored.</source>
          <target state="translated">Значение представляет собой строку в &lt;a href=&quot;fileformat2#enc&quot;&gt;текстовой кодировке длиной&lt;/a&gt; (N-13) / 2 байта. Нулевой терминатор не сохраняется.</target>
        </trans-unit>
        <trans-unit id="d4c71d03558220fa7cbe0d35d7582077b87759fd" translate="yes" xml:space="preserve">
          <source>Value is an 8-bit twos-complement integer.</source>
          <target state="translated">Значение представляет собой 8-битное двойное целое число.</target>
        </trans-unit>
        <trans-unit id="21a8bbbdb0477e77f764478e79099dc10eca1b5a" translate="yes" xml:space="preserve">
          <source>Value is the integer 0. (Only available for &lt;a href=&quot;fileformat2#schemaformat&quot;&gt;schema format&lt;/a&gt; 4 and higher.)</source>
          <target state="translated">Значение - целое число 0. (Доступно только для &lt;a href=&quot;fileformat2#schemaformat&quot;&gt;формата схемы&lt;/a&gt; 4 и выше.)</target>
        </trans-unit>
        <trans-unit id="4b218cb556caba65180a69703c18a8657584030f" translate="yes" xml:space="preserve">
          <source>Value is the integer 1. (Only available for &lt;a href=&quot;fileformat2#schemaformat&quot;&gt;schema format&lt;/a&gt; 4 and higher.)</source>
          <target state="translated">Значение - целое число 1. (Доступно только для &lt;a href=&quot;fileformat2#schemaformat&quot;&gt;формата схемы&lt;/a&gt; 4 и выше.)</target>
        </trans-unit>
        <trans-unit id="b1564f6b1512cbfa3cfcebc9a5badb6b239954f1" translate="yes" xml:space="preserve">
          <source>Values</source>
          <target state="translated">Values</target>
        </trans-unit>
        <trans-unit id="b74a3f9a59a12c1f692032bcd73742874ff821bd" translate="yes" xml:space="preserve">
          <source>Values for sqlite3session_config()</source>
          <target state="translated">Значения для sqlite3session_config()</target>
        </trans-unit>
        <trans-unit id="bc12625ab4c97d74dcdc9d561aba55de6f3648e6" translate="yes" xml:space="preserve">
          <source>Values for sqlite3session_config().</source>
          <target state="translated">Значения для sqlite3session_config().</target>
        </trans-unit>
        <trans-unit id="21fb70cd308e717f82d11db0a79a04443511207e" translate="yes" xml:space="preserve">
          <source>Values of N between 100 and 1000 are recommended. Or, to disable the analysis limit, causing ANALYZE to do a complete scan of each index, set the analysis limit to 0. The default value for the analysis limit is 0 for backwards compatibility.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b975fa21a49b294e75ba8fe14419189c4abab11" translate="yes" xml:space="preserve">
          <source>Values stored in unindexed columns are not eligible to match MATCH operators. They do not influence the results of the offsets() or matchinfo() auxiliary functions. Nor will the snippet() function ever return a snippet based on a value stored in an unindexed column.</source>
          <target state="translated">Значения,сохраненные в неиндексированных столбцах,не могут совпадать с MATCH-операторами.Они не влияют на результаты работы вспомогательных функций offsets()или matchinfo().Функция snippet()также никогда не вернет сниппет на основе значения,хранящегося в неиндексированной колонке.</target>
        </trans-unit>
        <trans-unit id="c15b50c2bdb6ec892f0c03794f814403120328ad" translate="yes" xml:space="preserve">
          <source>Values that may be passed as the second argument to a conflict-handler.</source>
          <target state="translated">Ценности,которые могут быть переданы в качестве второго аргумента конфликтологу.</target>
        </trans-unit>
        <trans-unit id="19de69cb601f53a4ea7af22a65c71ae63251365c" translate="yes" xml:space="preserve">
          <source>Variable</source>
          <target state="translated">Variable</target>
        </trans-unit>
        <trans-unit id="51a317c7ddc79a1154219a293b13d3647c7088e1" translate="yes" xml:space="preserve">
          <source>Various bug fixes and documentation updates.</source>
          <target state="translated">Различные исправления ошибок и обновления документации.</target>
        </trans-unit>
        <trans-unit id="d5f06a4766a5315e31c33eb58743a7e83afa9adb" translate="yes" xml:space="preserve">
          <source>Various bug fixes and optimizations</source>
          <target state="translated">Различные исправления и оптимизации</target>
        </trans-unit>
        <trans-unit id="85d7c8482bd4c4d0eab034cc91f2ea5f21b20d90" translate="yes" xml:space="preserve">
          <source>Various bug fixes in the &lt;a href=&quot;sqldiff&quot;&gt;sqldiff&lt;/a&gt; tool.</source>
          <target state="translated">Различные исправления ошибок в инструменте &lt;a href=&quot;sqldiff&quot;&gt;sqldiff&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ecec24b66500dbd17ba7725547d5521b2d6d2040" translate="yes" xml:space="preserve">
          <source>Various code refactorizations for performance</source>
          <target state="translated">Различные рефакторизации кода для повышения производительности</target>
        </trans-unit>
        <trans-unit id="85976ded19739ce2942c54c82204b742186a7556" translate="yes" xml:space="preserve">
          <source>Various compiler compatibility fixes.</source>
          <target state="translated">Различные исправления совместимости компилятора.</target>
        </trans-unit>
        <trans-unit id="ab65a12d6caf25bdc60a4edee517dc1ebef7b909" translate="yes" xml:space="preserve">
          <source>Various improvements in how the query planner uses &lt;a href=&quot;fileformat2#stat4tab&quot;&gt;sqlite_stat4&lt;/a&gt; information to estimate plan costs.</source>
          <target state="translated">Различные улучшения в том, как планировщик запросов использует информацию &lt;a href=&quot;fileformat2#stat4tab&quot;&gt;sqlite_stat4&lt;/a&gt; для оценки плановых затрат.</target>
        </trans-unit>
        <trans-unit id="03823e5b502773a079a3bee8b39ca22cddaecb57" translate="yes" xml:space="preserve">
          <source>Various minor bug and documentation typo fixes and performance enhancements.</source>
          <target state="translated">Различные незначительные исправления ошибок и опечаток документации,а также повышение производительности.</target>
        </trans-unit>
        <trans-unit id="10b44287786294b34c89472b1d33c638e18576ac" translate="yes" xml:space="preserve">
          <source>Various minor bug fixes</source>
          <target state="translated">Различные мелкие исправления ошибок</target>
        </trans-unit>
        <trans-unit id="3f779a48c89979c93ac37abe87c5a7687464bc7d" translate="yes" xml:space="preserve">
          <source>Various minor bug fixes and documentation enhancements.</source>
          <target state="translated">Различные незначительные исправления ошибок и улучшения документации.</target>
        </trans-unit>
        <trans-unit id="4847f53fde0fb417d8d4a76ab68b44562fd9a573" translate="yes" xml:space="preserve">
          <source>Various minor bug fixes and performance enhancements.</source>
          <target state="translated">Различные незначительные исправления ошибок и улучшения производительности.</target>
        </trans-unit>
        <trans-unit id="95ba96bcd2bbb545050ce738d48cb5ec939831b2" translate="yes" xml:space="preserve">
          <source>Various minor bug fixes including fixes for tickets &lt;a href=&quot;https://www.sqlite.org/src/info/8f157e8010b22af0&quot;&gt;8f157e8010b22af0&lt;/a&gt;, &lt;a href=&quot;https://www.sqlite.org/src/info/9fb26d37cefaba40&quot;&gt;9fb26d37cefaba40&lt;/a&gt;, &lt;a href=&quot;https://www.sqlite.org/src/info/e367f31901ea8700&quot;&gt;e367f31901ea8700&lt;/a&gt;, &lt;a href=&quot;https://www.sqlite.org/src/info/b706351ce2ecf59a&quot;&gt;b706351ce2ecf59a&lt;/a&gt;, &lt;a href=&quot;https://www.sqlite.org/src/info/7c6d876f84e6e7e2&quot;&gt;7c6d876f84e6e7e2&lt;/a&gt;, and &lt;a href=&quot;https://www.sqlite.org/src/info/c8d3b9f0a750a529&quot;&gt;c8d3b9f0a750a529&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d9299a31e992a8798950b9ee230e2efd3cac0b2" translate="yes" xml:space="preserve">
          <source>Various minor bug fixes.</source>
          <target state="translated">Различные мелкие исправления ошибок.</target>
        </trans-unit>
        <trans-unit id="2514c8b40a668dc1475dfd0f9f137b0141e179e2" translate="yes" xml:space="preserve">
          <source>Various performance improvements.</source>
          <target state="translated">Различные улучшения производительности.</target>
        </trans-unit>
        <trans-unit id="6342eea4c52b8714f01d87ea8795935f65636135" translate="yes" xml:space="preserve">
          <source>Verify that an Abort can happen. Assert if an Abort at this point might cause database corruption. This opcode only appears in debugging builds.</source>
          <target state="translated">Убедитесь,что аборт может произойти.Убедитесь,что Отмена в данный момент может привести к повреждению базы данных.Этот опкод появляется только в отладочных сборках.</target>
        </trans-unit>
        <trans-unit id="0e121d547f14e098984e65cce93a4f32d31bdccc" translate="yes" xml:space="preserve">
          <source>Version 1.0.X of SQLite used the GDBM library as its backend interface to the disk. Beginning in version 2.0.0, GDBM was replaced by a custom B-Tree library written especially for SQLite. The new B-Tree backend is twice as fast as GDBM, supports atomic commits and rollback, and stores an entire database in a single disk file instead using a separate file for each table as GDBM does. The two file formats are not even remotely similar.</source>
          <target state="translated">Версия 1.0.X SQLite использовала библиотеку GDBM в качестве бэкенд-интерфейса к диску.Начиная с версии 2.0.0,GDBM была заменена на пользовательскую библиотеку B-Tree,написанную специально для SQLite.Новый бэкенд B-Tree вдвое быстрее GDBM,поддерживает атомарные коммиты и откат,а также хранит всю базу данных в одном дисковом файле вместо этого,используя отдельный файл для каждой таблицы,как это делает GDBM.Эти два формата файлов даже удаленно не похожи.</target>
        </trans-unit>
        <trans-unit id="15147c06759c9052778bf2211d35cc6a76e87f68" translate="yes" xml:space="preserve">
          <source>Version 2.2.0 and later of the library will automatically detect when it is reading a 2.1.x database and will disable the new INTEGER PRIMARY KEY feature. In other words, version 2.2.x is backwards compatible to version 2.1.x. But version 2.1.x is not forward compatible with version 2.2.x. If you try to open a 2.2.x database with an older 2.1.x library and that database contains an INTEGER PRIMARY KEY, you will likely get a coredump. If the database schema does not contain any INTEGER PRIMARY KEYs, then the version 2.1.x and version 2.2.x database files will be identical and completely interchangeable.</source>
          <target state="translated">Версия 2.2.0 и более поздние версии библиотеки автоматически обнаруживает при чтении базы данных 2.1.x и отключает новую функцию INTEGER PRIMARY KEY.Другими словами,версия 2.2.x является обратно совместимой с версией 2.1.x.Но версия 2.1.x не является обратно совместимой с версией 2.2.x.Если вы попытаетесь открыть базу данных 2.2.x со старой библиотекой 2.1.x и эта база данных содержит INTEGER PRIMARY KEY,вы,скорее всего,получите ядро.Если схема БД не содержит ключей INTEGER PRIMARY KEY,то файлы БД версии 2.1.x и 2.2.x будут идентичны и полностью взаимозаменяемы.</target>
        </trans-unit>
        <trans-unit id="0117d508d1c578c143be74741c597fcb4aa7a934" translate="yes" xml:space="preserve">
          <source>Version 2.6.0 or later of the library cannot open read-only database files from version 2.5.6 or earlier, since read-only files cannot be upgraded to the new format.</source>
          <target state="translated">Библиотека версии 2.6.0 или более поздней не может открывать файлы БД только для чтения,начиная с версии 2.5.6 или более ранней,так как файлы только для чтения не могут быть обновлены до нового формата.</target>
        </trans-unit>
        <trans-unit id="b22eaca7a28d27b61c642146bfe60e035fc837b9" translate="yes" xml:space="preserve">
          <source>Version 2.8.0 introduces a change to the format of the rollback journal file. The main database file format is unchanged. Versions 2.7.6 and earlier can read and write 2.8.0 databases and vice versa. Version 2.8.0 can rollback a transaction that was started by version 2.7.6 and earlier. But version 2.7.6 and earlier cannot rollback a transaction started by version 2.8.0 or later.</source>
          <target state="translated">Версия 2.8.0 вносит изменения в формат файла журнала отката.Основной формат файла базы данных остается неизменным.Версии 2.7.6 и более ранние могут читать и записывать базы данных 2.8.0 и наоборот.Версия 2.8.0 может откатывать транзакцию,которая была запущена версией 2.7.6 и более ранней.Однако версии 2.7.6 и более ранние версии не могут откатить транзакцию,начатую версией 2.8.0 или более поздней.</target>
        </trans-unit>
        <trans-unit id="5ab1c612d2172f97ee17ccb094511130795e0e49" translate="yes" xml:space="preserve">
          <source>Version 3.0.0 is a major upgrade for SQLite that incorporates support for UTF-16, BLOBs, and a more compact encoding that results in database files that are typically 25% to 50% smaller. The new file format is very different and is completely incompatible with the version 2 file format.</source>
          <target state="translated">Версия 3.0.0 является основным обновлением для SQLite,которое включает поддержку UTF-16,BLOB и более компактную кодировку,в результате чего файлы базы данных обычно на 25%-50% меньше.Новый формат файлов сильно отличается и полностью несовместим с форматом файлов версии 2.</target>
        </trans-unit>
        <trans-unit id="560474f7906b0238187c7f7b7f4ee43ef0381a4c" translate="yes" xml:space="preserve">
          <source>Version 3.10.0 introduced a case-folding bug in the &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; operator which is fixed by this patch release. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/80369eddd5c94&quot;&gt;80369eddd5c94&lt;/a&gt;.</source>
          <target state="translated">Версия 3.10.0 представила ошибку сворачивания регистра в операторе &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE,&lt;/a&gt; которая исправлена ​​этим выпуском исправления. Билет &lt;a href=&quot;https://www.sqlite.org/src/info/80369eddd5c94&quot;&gt;80369eddd5c94&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="09330c4007db255bbeea2ef8f69d34761c5d8efc" translate="yes" xml:space="preserve">
          <source>Version 3.5.0 of SQLite changes the behavior of a few APIs in ways that are technically incompatible. However, these APIs are seldom used and even when they are used it is difficult to imagine a scenario where the change might break something. The changes actually makes these interface much more useful and powerful.</source>
          <target state="translated">Версия 3.5.0 SQLite изменяет поведение нескольких API технически несовместимыми способами.Однако,эти API используются редко,и даже когда они используются,трудно представить себе сценарий,в котором изменение может что-то сломать.Изменения на самом деле делают эти интерфейсы намного более полезными и мощными.</target>
        </trans-unit>
        <trans-unit id="621e552e91497473887ee98c411a17ae0c22faad" translate="yes" xml:space="preserve">
          <source>Version Change</source>
          <target state="translated">Смена версии</target>
        </trans-unit>
        <trans-unit id="57c774f0b39c0a5a2da04603c552cf0b2e97f635" translate="yes" xml:space="preserve">
          <source>Version Numbers in SQLite</source>
          <target state="translated">Номера версий в SQLite</target>
        </trans-unit>
        <trans-unit id="92c5569b77b82f07b395294f1952d2ab591b5725" translate="yes" xml:space="preserve">
          <source>Version method</source>
          <target state="translated">Версионный метод</target>
        </trans-unit>
        <trans-unit id="12b0595bc53b8fdea788b66adfb5e6aeb225a99c" translate="yes" xml:space="preserve">
          <source>Versioning of the SQLite source code has transitioned from CVS to &lt;a href=&quot;http://www.fossil-scm.org/&quot;&gt;Fossil&lt;/a&gt;.</source>
          <target state="translated">Управление версиями исходного кода SQLite переведено с CVS на &lt;a href=&quot;http://www.fossil-scm.org/&quot;&gt;Fossil&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9b36ebe549ad7e57c9fee50024e4b91ba9111a84" translate="yes" xml:space="preserve">
          <source>Very few CVEs written about SQLite are real vulnerabilities in the sense that they do not give any new capabilities to an attacker. Consider:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a826473d10edb3f601f04f14066361f0f7573c3" translate="yes" xml:space="preserve">
          <source>Via the &lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_mprintf()&lt;/a&gt; and &lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_vmprintf()&lt;/a&gt; interfaces, the built-in printf() implementation supports the ability to render an arbitrary-length string into a memory buffer obtained from &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc64()&lt;/a&gt;. This is safer and less error prone than trying to precompute an upper size limit on the result string, allocate an appropriately sized buffer, and then calling snprintf().</source>
          <target state="translated">Через интерфейсы &lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_mprintf ()&lt;/a&gt; и &lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_vmprintf ()&lt;/a&gt; встроенная реализация printf () поддерживает возможность рендеринга строки произвольной длины в буфер памяти, полученный из &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc64 ()&lt;/a&gt; . Это более безопасно и менее подвержено ошибкам, чем попытки предварительно вычислить верхний предел размера для строки результата, выделить буфер подходящего размера и затем вызвать snprintf ().</target>
        </trans-unit>
        <trans-unit id="7661d9e884510184f3115feaa61daa7fb90ab554" translate="yes" xml:space="preserve">
          <source>Virtual File System Objects</source>
          <target state="translated">Объекты виртуальной файловой системы</target>
        </trans-unit>
        <trans-unit id="0f4f4c40c9b657d040c9a5a3549b3c5d32fbc234" translate="yes" xml:space="preserve">
          <source>Virtual Table Configuration Options</source>
          <target state="translated">Опции конфигурации виртуальной таблицы</target>
        </trans-unit>
        <trans-unit id="57189223b1eb8b14988a31c1f5a4ff48cc80e85d" translate="yes" xml:space="preserve">
          <source>Virtual Table Constraint Operator Codes</source>
          <target state="translated">Коды операторов ограничения виртуальной таблицы</target>
        </trans-unit>
        <trans-unit id="d3cabefe217e8ae9513576669d0630c721003893" translate="yes" xml:space="preserve">
          <source>Virtual Table Cursor Object</source>
          <target state="translated">Объект виртуального столового курсора</target>
        </trans-unit>
        <trans-unit id="02d05d9b66c15b554ca60cadbe6ddd8d5a77642f" translate="yes" xml:space="preserve">
          <source>Virtual Table Indexing Information</source>
          <target state="translated">Виртуальная таблица Индексирование Информация</target>
        </trans-unit>
        <trans-unit id="80548cb099ad243dfef606537d8cb425cbe7b21c" translate="yes" xml:space="preserve">
          <source>Virtual Table Instance Object</source>
          <target state="translated">Объект виртуальной табличной инстанции</target>
        </trans-unit>
        <trans-unit id="681b6ef1224b6badb83f1618372bb0a3a5b7009a" translate="yes" xml:space="preserve">
          <source>Virtual Table Interface Configuration</source>
          <target state="translated">Конфигурация интерфейса виртуального стола</target>
        </trans-unit>
        <trans-unit id="b4e32b4e8d0ccc9df7f37bef23928bcdb8c21a47" translate="yes" xml:space="preserve">
          <source>Virtual Table Mechanism</source>
          <target state="translated">Механизм виртуального стола</target>
        </trans-unit>
        <trans-unit id="c7613e2461269638f02a689a01bdfb20ef96932a" translate="yes" xml:space="preserve">
          <source>Virtual Table Object</source>
          <target state="translated">Объект виртуальной таблицы</target>
        </trans-unit>
        <trans-unit id="6fb2f6d632c98f78eae8aef07afc99de73e44e98" translate="yes" xml:space="preserve">
          <source>Virtual Table Scan Flags</source>
          <target state="translated">Флаги сканирования виртуальной таблицы</target>
        </trans-unit>
        <trans-unit id="c6305adeaa93ffb40a0b3ae2ce131299d686cab8" translate="yes" xml:space="preserve">
          <source>Virtual machine stores 64-bit integer and floating point constants in binary instead of text for a performance boost.</source>
          <target state="translated">Для повышения производительности виртуальная машина хранит 64-битные целочисленные константы и константы с плавающей точкой в двоичном виде,а не в текстовом.</target>
        </trans-unit>
        <trans-unit id="a4369e3d1e48bcfd676b740e0d14b603ed7287ae" translate="yes" xml:space="preserve">
          <source>Virtual table implementations are allowed to set the &lt;a href=&quot;#sqlite3_index_info&quot;&gt;sqlite3_index_info&lt;/a&gt;.idxFlags field to some combination of these bits.</source>
          <target state="translated">Реализациям виртуальных таблиц разрешено устанавливать в поле &lt;a href=&quot;#sqlite3_index_info&quot;&gt;sqlite3_index_info&lt;/a&gt; .idxFlags некоторую комбинацию этих битов.</target>
        </trans-unit>
        <trans-unit id="7e7d9ed7bcb125e908a8e59f746fb86a62ee768a" translate="yes" xml:space="preserve">
          <source>Virtual table implementations are allowed to set the &lt;a href=&quot;index_info&quot;&gt;sqlite3_index_info&lt;/a&gt;.idxFlags field to some combination of these bits.</source>
          <target state="translated">Реализациям виртуальных таблиц разрешено устанавливать в поле &lt;a href=&quot;index_info&quot;&gt;sqlite3_index_info&lt;/a&gt; .idxFlags некоторую комбинацию этих битов.</target>
        </trans-unit>
        <trans-unit id="1e1224e431f5f3956505068b6d1ec8eea58f8cfc" translate="yes" xml:space="preserve">
          <source>Virtual table implementations that are required to handle OR REPLACE must do so within the &lt;a href=&quot;../vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; method. If a call to the &lt;a href=&quot;vtab_on_conflict&quot;&gt;sqlite3_vtab_on_conflict()&lt;/a&gt; function indicates that the current ON CONFLICT policy is REPLACE, the virtual table implementation should silently replace the appropriate rows within the xUpdate callback and return SQLITE_OK. Or, if this is not possible, it may return SQLITE_CONSTRAINT, in which case SQLite falls back to OR ABORT constraint handling.</source>
          <target state="translated">Реализации виртуальных таблиц, которые требуются для обработки OR REPLACE, должны делать это в методе &lt;a href=&quot;../vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; . Если вызов &lt;a href=&quot;vtab_on_conflict&quot;&gt;функции sqlite3_vtab_on_conflict ()&lt;/a&gt; указывает, что текущая политика ON CONFLICT - REPLACE, реализация виртуальной таблицы должна автоматически заменить соответствующие строки в обратном вызове xUpdate и вернуть SQLITE_OK. Или, если это невозможно, он может вернуть SQLITE_CONSTRAINT, и в этом случае SQLite вернется к обработке ограничения OR ABORT.</target>
        </trans-unit>
        <trans-unit id="6fd2d8e7bee948b9df988a6ac379b263c059c2c5" translate="yes" xml:space="preserve">
          <source>Virtual table implementations that are required to handle OR REPLACE must do so within the &lt;a href=&quot;vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; method. If a call to the &lt;a href=&quot;#sqlite3_vtab_on_conflict&quot;&gt;sqlite3_vtab_on_conflict()&lt;/a&gt; function indicates that the current ON CONFLICT policy is REPLACE, the virtual table implementation should silently replace the appropriate rows within the xUpdate callback and return SQLITE_OK. Or, if this is not possible, it may return SQLITE_CONSTRAINT, in which case SQLite falls back to OR ABORT constraint handling.</source>
          <target state="translated">Реализации виртуальных таблиц, которые требуются для обработки OR REPLACE, должны делать это в методе &lt;a href=&quot;vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; . Если вызов &lt;a href=&quot;#sqlite3_vtab_on_conflict&quot;&gt;функции sqlite3_vtab_on_conflict ()&lt;/a&gt; указывает, что текущая политика ON CONFLICT - REPLACE, реализация виртуальной таблицы должна автоматически заменить соответствующие строки в обратном вызове xUpdate и вернуть SQLITE_OK. Или, если это невозможно, он может вернуть SQLITE_CONSTRAINT, и в этом случае SQLite вернется к обработке ограничения OR ABORT.</target>
        </trans-unit>
        <trans-unit id="81aaad6c6dfb9299173befc645c959005f239f65" translate="yes" xml:space="preserve">
          <source>Virtual table implementations will normally subclass this structure to add additional private and implementation-specific fields. The nRef field is used internally by the SQLite core and should not be altered by the virtual table implementation. The virtual table implementation may pass error message text to the core by putting an error message string in zErrMsg. Space to hold this error message string must be obtained from an SQLite memory allocation function such as &lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_mprintf()&lt;/a&gt; or &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc()&lt;/a&gt;. Prior to assigning a new value to zErrMsg, the virtual table implementation must free any preexisting content of zErrMsg using &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_free()&lt;/a&gt;. Failure to do this will result in a memory leak. The SQLite core will free and zero the content of zErrMsg when it delivers the error message text to the client application or when it destroys the virtual table. The virtual table implementation only needs to worry about freeing the zErrMsg content when it overwrites the content with a new, different error message.</source>
          <target state="translated">Реализации виртуальных таблиц обычно создают подклассы этой структуры для добавления дополнительных частных и зависящих от реализации полей. Поле nRef используется внутри ядра SQLite и не должно изменяться реализацией виртуальной таблицы. Реализация виртуальной таблицы может передавать текст сообщения об ошибке в ядро, помещая строку сообщения об ошибке в zErrMsg. Пространство для хранения этой строки сообщения об ошибке должно быть получено из функции выделения памяти SQLite, такой как &lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_mprintf ()&lt;/a&gt; или &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc ()&lt;/a&gt; . Перед присвоением нового значения zErrMsg реализация виртуальной таблицы должна освободить любое ранее существовавшее содержимое zErrMsg с помощью &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_free ()&lt;/a&gt;. Несоблюдение этого правила приведет к утечке памяти. Ядро SQLite освободит и обнулит содержимое zErrMsg при доставке текста сообщения об ошибке в клиентское приложение или при уничтожении виртуальной таблицы. Реализации виртуальной таблицы нужно беспокоиться только об освобождении содержимого zErrMsg, когда оно перезаписывает содержимое новым, другим сообщением об ошибке.</target>
        </trans-unit>
        <trans-unit id="40dd4a6572104b0d97f5845a7aa00abca493ea5c" translate="yes" xml:space="preserve">
          <source>Virtual tables</source>
          <target state="translated">Виртуальные таблицы</target>
        </trans-unit>
        <trans-unit id="9c69270878a43f4468e25b3717d6b2598ec3353a" translate="yes" xml:space="preserve">
          <source>Virtual tables are ignored by default by sqldiff. However, it is possible to explicitly create an RBU data_% table for a virtual table that features a rowid that functions like a primary key using a command such as:</source>
          <target state="translated">Виртуальные таблицы по умолчанию игнорируются sqldiff.Тем не менее,можно явно создать таблицу RBU data_% для виртуальной таблицы,которая имеет рядковый ключ,который функционирует как первичный ключ,используя команду типа:</target>
        </trans-unit>
        <trans-unit id="4cb343842b9377b7930027e69fe1b4b95ab0bc54" translate="yes" xml:space="preserve">
          <source>Virtual tables can provide alternative implementations of functions using the &lt;a href=&quot;../vtab#xfindfunction&quot;&gt;xFindFunction&lt;/a&gt; method of the &lt;a href=&quot;module&quot;&gt;virtual table module&lt;/a&gt;. But global versions of those functions must exist in order to be overloaded.</source>
          <target state="translated">Виртуальные таблицы могут предоставлять альтернативные реализации функций с использованием метода &lt;a href=&quot;../vtab#xfindfunction&quot;&gt;xFindFunction &lt;/a&gt;&lt;a href=&quot;module&quot;&gt;модуля виртуальной таблицы&lt;/a&gt; . Но глобальные версии этих функций должны существовать, чтобы их можно было перегружать.</target>
        </trans-unit>
        <trans-unit id="ea35a0ae0128b32ea2712f75cfcca274a0e301d3" translate="yes" xml:space="preserve">
          <source>Virtual tables can provide alternative implementations of functions using the &lt;a href=&quot;vtab#xfindfunction&quot;&gt;xFindFunction&lt;/a&gt; method of the &lt;a href=&quot;#sqlite3_module&quot;&gt;virtual table module&lt;/a&gt;. But global versions of those functions must exist in order to be overloaded.</source>
          <target state="translated">Виртуальные таблицы могут предоставлять альтернативные реализации функций с использованием метода &lt;a href=&quot;vtab#xfindfunction&quot;&gt;xFindFunction &lt;/a&gt;&lt;a href=&quot;#sqlite3_module&quot;&gt;модуля виртуальной таблицы&lt;/a&gt; . Но глобальные версии этих функций должны существовать, чтобы их можно было перегружать.</target>
        </trans-unit>
        <trans-unit id="17882224a33603a1de5faab8a2a01eaa906c2eb6" translate="yes" xml:space="preserve">
          <source>Virtual tables for which the &quot;rowid&quot; column does not function like a primary key value cannot be updated using RBU.</source>
          <target state="translated">Виртуальные таблицы,для которых столбец &quot;rowid&quot; не работает как значение первичного ключа,не могут быть обновлены с помощью RBU.</target>
        </trans-unit>
        <trans-unit id="d97bfa2f28319cd6ae1be60d2bddfa72a278a536" translate="yes" xml:space="preserve">
          <source>Virtual tables methods can set an error message by assigning a string obtained from &lt;a href=&quot;#sqlite3_mprintf&quot;&gt;sqlite3_mprintf()&lt;/a&gt; to zErrMsg. The method should take care that any prior string is freed by a call to &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free()&lt;/a&gt; prior to assigning a new string to zErrMsg. After the error message is delivered up to the client application, the string will be automatically freed by sqlite3_free() and the zErrMsg field will be zeroed.</source>
          <target state="translated">Методы виртуальных таблиц могут установить сообщение об ошибке, назначив строку, полученную из &lt;a href=&quot;#sqlite3_mprintf&quot;&gt;sqlite3_mprintf (),&lt;/a&gt; в zErrMsg. Метод должен позаботиться о том, чтобы любая предыдущая строка была освобождена вызовом &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free ()&lt;/a&gt; до присвоения новой строки zErrMsg. После того как сообщение об ошибке будет доставлено клиентскому приложению, строка будет автоматически освобождена функцией sqlite3_free (), а поле zErrMsg будет обнулено.</target>
        </trans-unit>
        <trans-unit id="f460e6a98df6a13dcf481c34d0a877733d497773" translate="yes" xml:space="preserve">
          <source>Virtual tables methods can set an error message by assigning a string obtained from &lt;a href=&quot;mprintf&quot;&gt;sqlite3_mprintf()&lt;/a&gt; to zErrMsg. The method should take care that any prior string is freed by a call to &lt;a href=&quot;free&quot;&gt;sqlite3_free()&lt;/a&gt; prior to assigning a new string to zErrMsg. After the error message is delivered up to the client application, the string will be automatically freed by sqlite3_free() and the zErrMsg field will be zeroed.</source>
          <target state="translated">Методы виртуальных таблиц могут установить сообщение об ошибке, назначив строку, полученную из &lt;a href=&quot;mprintf&quot;&gt;sqlite3_mprintf (),&lt;/a&gt; в zErrMsg. Метод должен позаботиться о том, чтобы любая предыдущая строка была освобождена вызовом &lt;a href=&quot;free&quot;&gt;sqlite3_free ()&lt;/a&gt; до присвоения новой строки zErrMsg. После того как сообщение об ошибке будет доставлено клиентскому приложению, строка будет автоматически освобождена функцией sqlite3_free (), а поле zErrMsg будет обнулено.</target>
        </trans-unit>
        <trans-unit id="8dd3e411a2cd1cd0400ed8b91a5e2884ea85bf05" translate="yes" xml:space="preserve">
          <source>Virtual terms are used for analysis only and do not cause any byte-code to be generated. If both virtual terms end up being used as constraints on an index, then the original BETWEEN term is omitted and the corresponding test is not performed on input rows. Thus if the BETWEEN term ends up being used as an index constraint no tests are ever performed on that term. On the other hand, the virtual terms themselves never causes tests to be performed on input rows. Thus if the BETWEEN term is not used as an index constraint and instead must be used to test input rows, the</source>
          <target state="translated">Виртуальные термины используются только для анализа и не вызывают генерации байт-кода.Если оба виртуальных термина в конечном итоге используются в качестве ограничений на индекс,то исходный BETWEEN-термин опускается,и соответствующий тест не выполняется на входных строках.Таким образом,если BETWEEN-термин в конечном итоге используется в качестве ограничения индекса,то ни один из тестов никогда не выполняется на этом термине.С другой стороны,сами по себе виртуальные термины никогда не заставляют выполнять тесты на входных строках.Таким образом,если BETWEEN-термин не используется в качестве ограничения индекса,а должен использоваться для тестирования входных строк,то для проверки входных строк выполняется тест</target>
        </trans-unit>
        <trans-unit id="69180499c91410d16271921874ed2a25a5b8ba2f" translate="yes" xml:space="preserve">
          <source>Visit the sick.</source>
          <target state="translated">Навестить больных.</target>
        </trans-unit>
        <trans-unit id="c18668323ee175259b4d33e74c3e8421bb9608b5" translate="yes" xml:space="preserve">
          <source>Vulnerabilities</source>
          <target state="translated">Vulnerabilities</target>
        </trans-unit>
        <trans-unit id="63fbb3bb789b808aff0169713cbc7f0fe8b26b33" translate="yes" xml:space="preserve">
          <source>WAL Frame Header Format</source>
          <target state="translated">Формат заголовка рамы стены</target>
        </trans-unit>
        <trans-unit id="744e2e67c24aa24ef2724e0cca0702b0e396b77b" translate="yes" xml:space="preserve">
          <source>WAL Header Format</source>
          <target state="translated">Формат заголовка стены</target>
        </trans-unit>
        <trans-unit id="06c6d5627eae51ea8b07e45901c927d0fff1639e" translate="yes" xml:space="preserve">
          <source>WAL backwards compatibility</source>
          <target state="translated">обратная совместимость с WAL</target>
        </trans-unit>
        <trans-unit id="7f3d7dac78ce17ee863e11b29dd77ba4c3b844b1" translate="yes" xml:space="preserve">
          <source>WAL checksum algorithm</source>
          <target state="translated">алгоритм контрольной суммы WAL</target>
        </trans-unit>
        <trans-unit id="43394fc5704020bd91d68a3ea6cb25e34c7a31ef" translate="yes" xml:space="preserve">
          <source>WAL concurrency</source>
          <target state="translated">согласованность действий WAL</target>
        </trans-unit>
        <trans-unit id="52a8587a456d98f221f4f9bce63c226fcda62f9a" translate="yes" xml:space="preserve">
          <source>WAL file</source>
          <target state="translated">файл WAL</target>
        </trans-unit>
        <trans-unit id="50ce9ea412cfc1994dee0ce8829cf26ea47867fa" translate="yes" xml:space="preserve">
          <source>WAL format</source>
          <target state="translated">формат WAL</target>
        </trans-unit>
        <trans-unit id="2c59f37be8a8a85d4967e8d84ff245b823d2c3d3" translate="yes" xml:space="preserve">
          <source>WAL is significantly faster in most scenarios.</source>
          <target state="translated">Стена значительно быстрее в большинстве сценариев.</target>
        </trans-unit>
        <trans-unit id="df48eb81aeb4b91265bedea157514a68984a16d8" translate="yes" xml:space="preserve">
          <source>WAL might be very slightly slower (perhaps 1% or 2% slower) than the traditional rollback-journal approach in applications that do mostly reads and seldom write.</source>
          <target state="translated">WAL может быть очень немного медленнее (возможно,на 1% или 2% медленнее),чем традиционный подход отката журнала в приложениях,которые в основном читают и редко пишут.</target>
        </trans-unit>
        <trans-unit id="4a97139b7e130c0c8a433bdf669136c84f9136b7" translate="yes" xml:space="preserve">
          <source>WAL mode permits simultaneous readers and writers. It can do this because changes do not overwrite the original database file, but rather go into the separate write-ahead log file. That means that readers can continue to read the old, original, unaltered content from the original database file at the same time that the writer is appending to the write-ahead log. In &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt;, SQLite exhibits &quot;snapshot isolation&quot;. When a read transaction starts, that reader continues to see an unchanging &quot;snapshot&quot; of the database file as it existed at the moment in time when the read transaction started. Any write transactions that commit while the read transaction is active are still invisible to the read transaction, because the reader is seeing a snapshot of database file from a prior moment in time.</source>
          <target state="translated">Режим WAL позволяет одновременно читать и писать. Это возможно, потому что изменения не перезаписывают исходный файл базы данных, а скорее помещаются в отдельный файл журнала упреждающей записи. Это означает, что читатели могут продолжать читать старый, исходный, неизмененный контент из исходного файла базы данных в то же время, когда писатель добавляет в журнал упреждающей записи. В &lt;a href=&quot;wal&quot;&gt;режиме WAL&lt;/a&gt; SQLite демонстрирует &amp;laquo;изоляцию моментальных снимков&amp;raquo;. Когда начинается транзакция чтения, этот читатель продолжает видеть неизменный &amp;laquo;моментальный снимок&amp;raquo; файла базы данных в том виде, в котором он существовал в момент начала транзакции чтения. Любые транзакции записи, которые фиксируются, пока транзакция чтения активна, по-прежнему невидимы для транзакции чтения, потому что читатель видит моментальный снимок файла базы данных за предыдущий момент времени.</target>
        </trans-unit>
        <trans-unit id="cd8ce3e93d7ff89ed9c8371ea6e45fd8f37cf883" translate="yes" xml:space="preserve">
          <source>WAL mode with synchronous NORMAL,</source>
          <target state="translated">Режим WAL с синхронным НОРМАЛЬНЫМ,</target>
        </trans-unit>
        <trans-unit id="02d4a388313bcdd7b2c200b7ae8c4e65a2674e7c" translate="yes" xml:space="preserve">
          <source>WAL normally requires that the &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; support shared-memory primitives. (Exception: &lt;a href=&quot;wal#noshm&quot;&gt;WAL without shared memory&lt;/a&gt;) The built-in unix and windows VFSes support this but third-party extension VFSes for custom operating systems might not.</source>
          <target state="translated">WAL обычно требует, чтобы &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; поддерживала примитивы разделяемой памяти. (Исключение: &lt;a href=&quot;wal#noshm&quot;&gt;WAL без разделяемой памяти&lt;/a&gt; ) Встроенные виртуальные файловые системы UNIX и Windows поддерживают это, но сторонние расширения VFS для пользовательских операционных систем могут не поддерживать.</target>
        </trans-unit>
        <trans-unit id="773f18c2587f00153abb58a02a9105f99addd056" translate="yes" xml:space="preserve">
          <source>WAL provides more concurrency as readers do not block writers and a writer does not block readers. Reading and writing can proceed concurrently.</source>
          <target state="translated">WAL обеспечивает большее совпадение,так как читатели не блокируют программы записи,а программа записи не блокирует программы чтения.Чтение и запись могут осуществляться одновременно.</target>
        </trans-unit>
        <trans-unit id="c92f6b05049160f00dd8c3ee0f71a3f765656c3a" translate="yes" xml:space="preserve">
          <source>WAL read algorithm</source>
          <target state="translated">алгоритм считывания WAL</target>
        </trans-unit>
        <trans-unit id="ea6e19418d259cb4081e953d6c25797fc3b82935" translate="yes" xml:space="preserve">
          <source>WAL reset</source>
          <target state="translated">сброс стены</target>
        </trans-unit>
        <trans-unit id="ba93da00cc71fcc3b4f076052eaeb32eb6b9800c" translate="yes" xml:space="preserve">
          <source>WAL uses many fewer fsync() operations and is thus less vulnerable to problems on systems where the fsync() system call is broken.</source>
          <target state="translated">WAL использует гораздо меньше операций fsync()и,таким образом,менее уязвим к проблемам на системах,где системный вызов fsync()нарушен.</target>
        </trans-unit>
        <trans-unit id="935e3aae9a4d9f6fb670dd29df8a280f6a07053c" translate="yes" xml:space="preserve">
          <source>WAL without shared memory</source>
          <target state="translated">WAL без общей памяти</target>
        </trans-unit>
        <trans-unit id="c5c7bca44dc98aebaf5146b41dc5aa511b8a8aa6" translate="yes" xml:space="preserve">
          <source>WAL-Index Header Details</source>
          <target state="translated">Детали заголовка WAL-индекса</target>
        </trans-unit>
        <trans-unit id="e370010e43949311e2b789c1fcb72213cd69886b" translate="yes" xml:space="preserve">
          <source>WAL-Index Header Divisions</source>
          <target state="translated">Заголовочные отделы Стены-Индекса</target>
        </trans-unit>
        <trans-unit id="738cab6ddeb95b98c824e2fa6c01b30e9dcb5952" translate="yes" xml:space="preserve">
          <source>WAL-Index Locks Controlled By xShmLock()</source>
          <target state="translated">Замки WAL-Index управляемые xShmLock()</target>
        </trans-unit>
        <trans-unit id="f9538dc159e3d4ee9069c606e83b7a548fc2f640" translate="yes" xml:space="preserve">
          <source>WAL-index format</source>
          <target state="translated">WAL-индексный формат</target>
        </trans-unit>
        <trans-unit id="bfa5d0e78b2dc4651911fcb18213d8d8bcf10c94" translate="yes" xml:space="preserve">
          <source>WAL-mode File Format</source>
          <target state="translated">WAL-режим Формат файла</target>
        </trans-unit>
        <trans-unit id="de71e324c9bcbf886760fa79f3cdf3359f06f756" translate="yes" xml:space="preserve">
          <source>WAL-mode crash recovery</source>
          <target state="translated">восстановление после аварийного WAL-режима</target>
        </trans-unit>
        <trans-unit id="f45f2752fdcaf800e0a1910433e500b6102d9c5c" translate="yes" xml:space="preserve">
          <source>WAL-mode locks</source>
          <target state="translated">WAL-режимные замки</target>
        </trans-unit>
        <trans-unit id="0e94e9cb4190e9d9687693e4eaf1537e92418a3d" translate="yes" xml:space="preserve">
          <source>WAL-mode read blocking</source>
          <target state="translated">блокировка чтения в режиме WAL</target>
        </trans-unit>
        <trans-unit id="b20f2962509be83b4058f80a47d244e5b11196b8" translate="yes" xml:space="preserve">
          <source>WAL_CKPT_LOCK</source>
          <target state="translated">WAL_CKPT_LOCK</target>
        </trans-unit>
        <trans-unit id="7d8dca53c800f5b912f5029eb6c49020dba95f10" translate="yes" xml:space="preserve">
          <source>WAL_READ_LOCK(0)</source>
          <target state="translated">WAL_READ_LOCK(0)</target>
        </trans-unit>
        <trans-unit id="182225568ec6a131ef84113496e8619eaa0d74bc" translate="yes" xml:space="preserve">
          <source>WAL_READ_LOCK(1)</source>
          <target state="translated">WAL_READ_LOCK(1)</target>
        </trans-unit>
        <trans-unit id="e7da30047a308b88f352a994772f05755945376a" translate="yes" xml:space="preserve">
          <source>WAL_READ_LOCK(2)</source>
          <target state="translated">WAL_READ_LOCK(2)</target>
        </trans-unit>
        <trans-unit id="af1d79e6c2231524894cbc98a7822ed397be08ea" translate="yes" xml:space="preserve">
          <source>WAL_READ_LOCK(3)</source>
          <target state="translated">WAL_READ_LOCK(3)</target>
        </trans-unit>
        <trans-unit id="33fe625c4da68b4d223dd3cf41bf33912b01d2d2" translate="yes" xml:space="preserve">
          <source>WAL_READ_LOCK(4)</source>
          <target state="translated">WAL_READ_LOCK(4)</target>
        </trans-unit>
        <trans-unit id="5e15c21a39d31cebadee8ce801a0923d71efe684" translate="yes" xml:space="preserve">
          <source>WAL_RECOVER_LOCK</source>
          <target state="translated">WAL_RECOVER_LOCK</target>
        </trans-unit>
        <trans-unit id="97bb53df8b738f49899ec6f8612f4070a67257d9" translate="yes" xml:space="preserve">
          <source>WAL_WRITE_LOCK</source>
          <target state="translated">WAL_WRITE_LOCK</target>
        </trans-unit>
        <trans-unit id="962a5cebdb56ec36c6dbf4d84e53c7c677fcc3ab" translate="yes" xml:space="preserve">
          <source>WARNING/TODO: This function currently assumes that the input is a valid changeset. If it is not, the results are undefined.</source>
          <target state="translated">ПРЕДУПРЕЖДЕНИЕ/ДЕЙСТВИЕ:Эта функция в настоящее время предполагает,что вход является допустимым набором изменений.Если это не так,результаты не будут определены.</target>
        </trans-unit>
        <trans-unit id="66428bb1d785a8e164fb6679f1dcee0c10acabb5" translate="yes" xml:space="preserve">
          <source>WARNING: If this macro is defined, it will not be possible to open a database for which the schema contains VIEW objects.</source>
          <target state="translated">ПРЕДУПРЕЖДЕНИЕ:Если данный макрос определен,то открыть базу данных,для которой в схеме содержатся объекты VIEW,будет невозможно.</target>
        </trans-unit>
        <trans-unit id="e3eafa40a094c805daed78cdb48c723e5b81b9a1" translate="yes" xml:space="preserve">
          <source>WHEN</source>
          <target state="translated">WHEN</target>
        </trans-unit>
        <trans-unit id="1c255b91e71a2fddc2e75f8455387053d412a4c1" translate="yes" xml:space="preserve">
          <source>WHERE</source>
          <target state="translated">WHERE</target>
        </trans-unit>
        <trans-unit id="cfda4d41a395db406982a11851ae2e1bfcf9956d" translate="yes" xml:space="preserve">
          <source>WHERE clause</source>
          <target state="translated">ГДЕ оговорка</target>
        </trans-unit>
        <trans-unit id="f21acb9f8ec93625bf5c0906f54fc785624f93c0" translate="yes" xml:space="preserve">
          <source>WHERE clause constraints that are connected by OR instead of AND can be handled in two different ways. If a term consists of multiple subterms containing a common column name and separated by OR, like this:</source>
          <target state="translated">Где ограничения по пунктам,которые связаны ИЛИ,а не ИЛИ,могут быть обработаны двумя различными способами.Если термин состоит из нескольких подзаголовков,содержащих общее имя столбца и разделенных по принципу &quot;ИЛИ&quot;,то подобным образом:</target>
        </trans-unit>
        <trans-unit id="1e47856edce4197b9e0ea412ab9daf0c805ed99c" translate="yes" xml:space="preserve">
          <source>WHERE clause expressions using BETWEEN and OR are now candidates for optimization</source>
          <target state="translated">Где выражения из пунктов,использующие BETWEEN и OR,теперь являются кандидатами на оптимизацию</target>
        </trans-unit>
        <trans-unit id="201f5bdde79034efdfb90c4b9a48c56dd51af9e1" translate="yes" xml:space="preserve">
          <source>WINDOW</source>
          <target state="translated">WINDOW</target>
        </trans-unit>
        <trans-unit id="7913945997a369e8ea6004dfc36b2844dceea418" translate="yes" xml:space="preserve">
          <source>WITH</source>
          <target state="translated">WITH</target>
        </trans-unit>
        <trans-unit id="9ced6ee9ff3324806557c62b472be54adbd37321" translate="yes" xml:space="preserve">
          <source>WITH clause</source>
          <target state="translated">С оговоркой</target>
        </trans-unit>
        <trans-unit id="56fbadc8d9764a70500cf87f645a8260e6c6c396" translate="yes" xml:space="preserve">
          <source>WITHOUT</source>
          <target state="translated">WITHOUT</target>
        </trans-unit>
        <trans-unit id="80ce6a3273f099b101fd71e15344b4ac7f67fb42" translate="yes" xml:space="preserve">
          <source>WITHOUT ROWID is found only in SQLite and is not compatible with any other SQL database engine, as far as we know. In an elegant system, all tables would behave as WITHOUT ROWID tables even without the WITHOUT ROWID keyword. However, when SQLite was first designed, it used only integer &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowids&lt;/a&gt; for row keys to simplify the implementation. This approach worked well for many years. But as the demands on SQLite grew, the need for tables in which the PRIMARY KEY really did correspond to the underlying row key grew more acute. The WITHOUT ROWID concept was added in order to meet that need without breaking backwards compatibility with the billions of SQLite databases already in use at the time (circa 2013).</source>
          <target state="translated">БЕЗ ROWID встречается только в SQLite и, насколько нам известно, несовместим с другими механизмами баз данных SQL. В элегантной системе все таблицы будут вести себя как таблицы WITHOUT ROWID даже без ключевого слова WITHOUT ROWID. Однако, когда SQLite был впервые разработан, он использовал только целочисленные &lt;a href=&quot;lang_createtable#rowid&quot;&gt;идентификаторы&lt;/a&gt; строк для ключей строк, чтобы упростить реализацию. Этот подход хорошо работал много лет. Но по мере роста требований к SQLite потребность в таблицах, в которых PRIMARY KEY действительно соответствовала базовому ключу строки, становилась все более острой. Концепция БЕЗ ROWID была добавлена ​​для удовлетворения этой потребности без нарушения обратной совместимости с миллиардами баз данных SQLite, которые уже использовались в то время (около 2013 г.).</target>
        </trans-unit>
        <trans-unit id="468208bc9196912bc7723c91a3fae9cc04615357" translate="yes" xml:space="preserve">
          <source>WITHOUT ROWID tables will work correctly (that is to say, they provide the correct answer) for tables with a single INTEGER PRIMARY KEY. However, ordinary rowid tables will run faster in that case. Hence, it is good design to avoid creating WITHOUT ROWID tables with single-column PRIMARY KEYs of type INTEGER.</source>
          <target state="translated">БЕЗ ROWID таблицы будут работать правильно (то есть давать правильный ответ)для таблиц с одним INTEGER PRIMARY KEY.Однако,обычные таблицы rowid в этом случае будут работать быстрее.Следовательно,хорошая конструкция позволяет избежать создания таблиц БЕЗ КОЛЬЦОВЫХ СТОЛбцов с одностолбцовым PRIMARY KEY типа INTEGER.</target>
        </trans-unit>
        <trans-unit id="a47008723e245eb9b8569a96c7a79d51a50cb56f" translate="yes" xml:space="preserve">
          <source>WITHOUT ROWID tables work best when individual rows are not too large. A good rule-of-thumb is that the average size of a single row in a WITHOUT ROWID table should be less than about 1/20th the size of a database page. That means that rows should not contain more than about 50 bytes each for a 1KiB page size or about 200 bytes each for 4KiB page size. WITHOUT ROWID tables will work (in the sense that they get the correct answer) for arbitrarily large rows - up to 2GB in size - but traditional rowid tables tend to work faster for large row sizes. This is because rowid tables are implemented as &lt;a href=&quot;fileformat2#btree&quot;&gt;B*-Trees&lt;/a&gt; where all content is stored in the leaves of the tree, whereas WITHOUT ROWID tables are implemented using ordinary B-Trees with content stored on both leaves and intermediate nodes. Storing content in intermediate nodes mean that each intermediate node entry takes up more space on the page and thus reduces the fan-out, increasing the search cost.</source>
          <target state="translated">Таблицы БЕЗ ROWID работают лучше всего, когда отдельные строки не слишком велики. Хорошее практическое правило состоит в том, что средний размер одной строки в таблице БЕЗ ROWID должен быть меньше примерно 1/20 размера страницы базы данных. Это означает, что строки не должны содержать более 50 байтов каждая для размера страницы 1 КБ или около 200 байтов каждая для размера страницы 4 КБ. Таблицы БЕЗ ROWID будут работать (в том смысле, что они получают правильный ответ) для произвольно больших строк - размером до 2 ГБ, - но традиционные таблицы rowid, как правило, работают быстрее для строк большого размера. Это потому, что таблицы &lt;a href=&quot;fileformat2#btree&quot;&gt;rowid&lt;/a&gt; реализованы как B * -Treesгде весь контент хранится в листьях дерева, тогда как таблицы БЕЗ ROWID реализованы с использованием обычных B-деревьев с содержимым, хранящимся как на листьях, так и на промежуточных узлах. Хранение контента в промежуточных узлах означает, что каждая запись промежуточного узла занимает больше места на странице и, таким образом, уменьшает разветвление, увеличивая стоимость поиска.</target>
        </trans-unit>
        <trans-unit id="88d3b9ec414c3ffacd30f5fa1e3b51d5e7c1696c" translate="yes" xml:space="preserve">
          <source>WITHOUT ROWID virtual table</source>
          <target state="translated">Виртуальный стол БЕЗ РОУДА</target>
        </trans-unit>
        <trans-unit id="bff1c33df73d6a6c2b628488a2bcad9b0fe90c82" translate="yes" xml:space="preserve">
          <source>Wait for the rolled back changes to be written onto persistent storage. This protects the integrity of the database in case another power failure or crash occurs.</source>
          <target state="translated">Подождите,пока откатные изменения не будут записаны на постоянное хранилище.Это защищает целостность базы данных в случае очередного сбоя или отключения электропитания.</target>
        </trans-unit>
        <trans-unit id="dd9635431d3610b419ecc620dedbc828ed50792c" translate="yes" xml:space="preserve">
          <source>Was generated by this script:</source>
          <target state="translated">был сгенерирован этим скриптом:</target>
        </trans-unit>
        <trans-unit id="637f65e1bae93912cb8bee734b406fd7ee161d5f" translate="yes" xml:space="preserve">
          <source>We also run SQLite using &lt;a href=&quot;http://valgrind.org&quot;&gt;Valgrind&lt;/a&gt; on Linux and verify that it detects no problems.</source>
          <target state="translated">Мы также запускаем SQLite с помощью &lt;a href=&quot;http://valgrind.org&quot;&gt;Valgrind&lt;/a&gt; в Linux и проверяем, что он не обнаруживает проблем.</target>
        </trans-unit>
        <trans-unit id="2bac0ed4b37946dad20096d0b073432309bee989" translate="yes" xml:space="preserve">
          <source>We are aware of no other</source>
          <target state="translated">Мы не знаем ни о каком другом</target>
        </trans-unit>
        <trans-unit id="c52eb400cd855fce10ed2a5a6e3b50ba60a61275" translate="yes" xml:space="preserve">
          <source>We are told that in some flash memory controllers the wear-leveling logic can cause random filesystem damage if power is interrupted during a write. This can manifest, for example, as random changes in the middle of a file that was not even open at the time of the power loss. So, for example, a device would be writing content into an MP3 file in flash memory when a power loss occurs, and that could result in an SQLite database being corrupted even though the database was not even in use at the time of the power loss.</source>
          <target state="translated">Нам говорят,что в некоторых контроллерах флэш-памяти логика выравнивания износа может привести к случайному повреждению файловой системы,если питание прерывается во время записи.Это может проявляться,например,в виде случайных изменений в середине файла,который даже не был открыт в момент отключения питания.Так,например,устройство будет записывать содержимое MP3 файла во флэш-память при отключении питания,что может привести к повреждению базы данных SQLite,даже если эта база данных не использовалась на момент отключения питания.</target>
        </trans-unit>
        <trans-unit id="3cba495c2a4fa9e3aad438fbdcf0294c4dcb9df3" translate="yes" xml:space="preserve">
          <source>We assume that disk is written in chunks which we call a &quot;sector&quot;. It is not possible to modify any part of the disk smaller than a sector. To change a part of the disk smaller than a sector, you have to read in the full sector that contains the part you want to change, make the change, then write back out the complete sector.</source>
          <target state="translated">Мы предполагаем,что диск записывается кусочками,которые мы называем &quot;сектором&quot;.Невозможно модифицировать какую-либо часть диска размером меньше сектора.Чтобы изменить часть диска,меньшую сектора,вы должны прочитать в полном секторе,который содержит часть,которую вы хотите изменить,сделать изменение,а затем записать обратно весь сектор.</target>
        </trans-unit>
        <trans-unit id="6dd2d15ae4f93de39a47cf41448e74b994733012" translate="yes" xml:space="preserve">
          <source>We begin with a problem that can be solved using a VDBE program that is only a few instructions long. Suppose we have an SQL table that was created like this:</source>
          <target state="translated">Мы начинаем с проблемы,которая может быть решена с помощью программы VDBE,которая представляет собой всего лишь несколько инструкций.Предположим,что у нас есть таблица SQL,которая была создана таким образом:</target>
        </trans-unit>
        <trans-unit id="db9e6f9dd85fc9f8e31996438093b69f82ad2ed0" translate="yes" xml:space="preserve">
          <source>We begin with an overview of the steps SQLite takes in order to perform an atomic commit of a transaction against a single database file. The details of file formats used to guard against damage from power failures and techniques for performing an atomic commit across multiple databases are discussed in later sections.</source>
          <target state="translated">Мы начнем с обзора шагов,которые предпринимает SQLite для выполнения атомарной фиксации транзакции в одном файле базы данных.Подробности форматов файлов,используемых для защиты от повреждений при отключении электропитания,а также методы выполнения атомарного коммита в нескольких базах данных будут рассмотрены в последующих разделах.</target>
        </trans-unit>
        <trans-unit id="38bf89df215372375d066b70f4b36998e95fafff" translate="yes" xml:space="preserve">
          <source>We believe that most modern disk drives implement atomic sector writes. When power is lost, the drive uses energy stored in capacitors and/or the angular momentum of the disk platter to provide power to complete any operation in progress. Nevertheless, there are so many layers in between the write system call and the on-board disk drive electronics that we take the safe approach in both Unix and w32 VFS implementations and assume that sector writes are not atomic. On the other hand, device manufacturers with more control over their filesystems might want to consider enabling the atomic write property of xDeviceCharacteristics if their hardware really does do atomic writes.</source>
          <target state="translated">Мы считаем,что большинство современных дисковых накопителей реализуют атомную запись.При потере мощности диск использует энергию,накопленную в конденсаторах и/или угловой момент дисковой тарелки,для обеспечения питания,чтобы завершить любую выполняемую операцию.Тем не менее,между системным вызовом записи и встроенной электроникой дискового накопителя существует так много уровней,что мы используем безопасный подход в реализации Unix и w32 VFS и предполагаем,что запись по секторам не является атомарной.С другой стороны,производители устройств,имеющие больший контроль над своими файловыми системами,возможно,захотят рассмотреть возможность включения атомарной записи свойств xDeviceCharacteristics,если их аппаратура действительно делает атомарную запись.</target>
        </trans-unit>
        <trans-unit id="586e6ff48cacbcb2ddee486b19c44489728dbf7f" translate="yes" xml:space="preserve">
          <source>We call custom modifications to the SQLite source code that are held for the use of a single application a &quot;private branch&quot;. When a private branch becomes necessary, the application developer must take on the task of keeping the private branch in synchronization with the public SQLite sources. This is tedious. It can also be tricky, since while the SQLite file format and published interfaces are very stable, the internal implementation of SQLite changes quite rapidly. Hundreds or thousands of lines of code might change for any given SQLite point release.</source>
          <target state="translated">Пользовательские модификации исходного кода SQLite,проводимые для использования одного приложения,мы называем &quot;частной веткой&quot;.Когда возникает необходимость в использовании &quot;приватной ветки&quot;,разработчик приложения должен взять на себя задачу сохранения приватной ветки в синхронизации с общедоступными исходными текстами SQLite.Это утомительно.Это тоже может быть непросто,т.к.в то время как формат файла SQLite и опубликованные интерфейсы очень стабильны,внутренняя реализация SQLite меняется достаточно быстро.Сотни и тысячи строк кода могут измениться для любого выпуска SQLite.</target>
        </trans-unit>
        <trans-unit id="2cfeb2a347fa38b180ceb6f0fe6a37a3de052a3a" translate="yes" xml:space="preserve">
          <source>We call this kind of index usage a &quot;skip-scan&quot; because the database engine is basically doing a full scan of the index but it optimizes the scan (making it less than &quot;full&quot;) by occasionally skipping ahead to the next candidate value.</source>
          <target state="translated">Мы называем этот вид использования индекса &quot;пропущенным сканированием&quot;,потому что движок базы данных,по сути,выполняет полное сканирование индекса,но оптимизирует сканирование (делая его менее чем &quot;полным&quot;),время от времени пропуская вперед значение следующего кандидата.</target>
        </trans-unit>
        <trans-unit id="d8c54ecc5dbd9d71e35248692355648775c7c06a" translate="yes" xml:space="preserve">
          <source>We can see the VDBE program that SQLite uses to implement this INSERT using the &lt;b&gt;sqlite&lt;/b&gt; command-line utility. First start up &lt;b&gt;sqlite&lt;/b&gt; on a new, empty database, then create the table. Next change the output format of &lt;b&gt;sqlite&lt;/b&gt; to a form that is designed to work with VDBE program dumps by entering the &quot;.explain&quot; command. Finally, enter the [INSERT] statement shown above, but precede the [INSERT] with the special keyword [EXPLAIN]. The [EXPLAIN] keyword will cause &lt;b&gt;sqlite&lt;/b&gt; to print the VDBE program rather than execute it. We have:</source>
          <target state="translated">Мы можем увидеть программу VDBE, которую SQLite использует для реализации этого INSERT с помощью утилиты командной строки &lt;b&gt;sqlite&lt;/b&gt; . Сначала запустите &lt;b&gt;sqlite&lt;/b&gt; в новой пустой базе данных, затем создайте таблицу. Затем измените выходной формат &lt;b&gt;sqlite&lt;/b&gt; на форму, предназначенную для работы с дампами программы VDBE, введя команду &quot;.explain&quot;. Наконец, введите показанный выше оператор [INSERT], но перед [INSERT] укажите специальное ключевое слово [EXPLAIN]. Ключевое слово [EXPLAIN] заставит &lt;b&gt;sqlite&lt;/b&gt; печатать программу VDBE, а не выполнять ее. У нас есть:</target>
        </trans-unit>
        <trans-unit id="ec7be355019068bf92f7d741482fdf6ee1c56c3e" translate="yes" xml:space="preserve">
          <source>We can see the process in action in the following query:</source>
          <target state="translated">Мы можем увидеть процесс в действии в следующем запросе:</target>
        </trans-unit>
        <trans-unit id="a73853b7ca854f99ebc56a8da7248062e4f92563" translate="yes" xml:space="preserve">
          <source>We deduce the following rules of thumb from the matrix above:</source>
          <target state="translated">Из приведенной выше матрицы мы выведем следующие правила:</target>
        </trans-unit>
        <trans-unit id="84f5304369a052a144aa55c526df651c94e44de3" translate="yes" xml:space="preserve">
          <source>We emphasis that most applications are well-served by the built-in default implementations of the SQLite interface subsystems. Developers are encouraged to use the default built-in implementations whenever possible and to build SQLite without any special compile-time options or parameters. However, some highly specialized applications may benefit from substituting or modifying one or more of these built-in SQLite interface subsystems. Or, if SQLite is used on an operating system other than Unix (Linux or Mac OS X), Windows (Win32 or WinCE), or OS/2 then none of the interface subsystems that come built into SQLite will work and the application will need to provide alternative implementations suitable for the target platform.</source>
          <target state="translated">Мы подчеркиваем,что большинство приложений хорошо обслуживаются встроенными реализациями подсистем интерфейса SQLite по умолчанию.Разработчикам рекомендуется по мере возможности использовать встроенные реализации по умолчанию и строить SQLite без каких-либо специальных опций времени компиляции или параметров.Однако некоторые узкоспециализированные приложения могут выиграть от замены или модификации одной или нескольких из этих встроенных подсистем интерфейса SQLite.Или,если SQLite используется на операционной системе,отличной от Unix (Linux или Mac OS X),Windows (Win32 или WinCE)или OS/2,то ни одна из встроенных в SQLite подсистем интерфейса не будет работать,и приложению необходимо будет предоставить альтернативные реализации,подходящие для целевой платформы.</target>
        </trans-unit>
        <trans-unit id="6885829b70a7aa6d03abf4dbc376f359d84e8896" translate="yes" xml:space="preserve">
          <source>We emphasize again that these steps are not intended to be the only acceptable method for maintaining private branch. This approach is one of many. Use this document as a baseline for preparing project-specific procedures. Do not be afraid to experiment.</source>
          <target state="translated">Мы еще раз подчеркиваем,что эти шаги не предназначены для того,чтобы быть единственным приемлемым методом поддержания частного сектора.Такой подход является одним из многих.Используйте этот документ в качестве основы для подготовки процедур по конкретным проектам.Не бойтесь экспериментировать.</target>
        </trans-unit>
        <trans-unit id="55e740e8153135385200d1c2a44c0a166232d431" translate="yes" xml:space="preserve">
          <source>We have received reports of implementations of both Windows network filesystems and NFS in which locking was subtly broken. We can not verify these reports, but as locking is difficult to get right on a network filesystem we have no reason to doubt them. You are advised to avoid using SQLite on a network filesystem in the first place, since performance will be slow. But if you must use a network filesystem to store SQLite database files, consider using a secondary locking mechanism to prevent simultaneous writes to the same database even if the native filesystem locking mechanism malfunctions.</source>
          <target state="translated">Мы получили сообщения о реализации как сетевых файловых систем Windows,так и NFS,в которых блокировка была тонко нарушена.Мы не можем проверить эти сообщения,но так как блокировку трудно получить прямо на сетевой файловой системе,у нас нет причин сомневаться в них.Рекомендуется в первую очередь избегать использования SQLite на сетевой файловой системе,так как производительность будет медленной.Но если вы должны использовать сетевую файловую систему для хранения файлов базы данных SQLite,рассмотрите возможность использования вторичного механизма блокировки для предотвращения одновременной записи в одну и ту же базу данных,даже если собственный механизм блокировки файловой системы не работает.</target>
        </trans-unit>
        <trans-unit id="e3e45a07ed13dbd9549a67862a5bea3d84d72898" translate="yes" xml:space="preserve">
          <source>We have seen multiple cases where a file descriptor was open on a file, then that file descriptor was closed and reopened on an SQLite database. Later, some other thread continued to write into the old file descriptor, not realizing that the original file had been closed already. But because the file descriptor had been reopened by SQLite, the information that was intended to go into the original file ended up overwriting parts of the SQLite database, leading to corruption of the database.</source>
          <target state="translated">Мы видели несколько случаев,когда дескриптор файла был открыт на файле,затем этот дескриптор был закрыт и снова открыт на базе данных SQLite.Позже какой-то другой поток продолжил запись в старый файловый дескриптор,не понимая,что исходный файл уже был закрыт.Но поскольку дескриптор файла был повторно открыт SQLite,информация,которая предназначалась для входа в исходный файл,заканчивалась перезаписью частей базы данных SQLite,что приводило к повреждению базы данных.</target>
        </trans-unit>
        <trans-unit id="776084395b585bc0c28bd248aca15b6e574ec177" translate="yes" xml:space="preserve">
          <source>We here restate and amplify the previous sentence for emphasis: All changes within a single transaction in SQLite either occur completely or not at all, even if the act of writing the change out to the disk is interrupted by</source>
          <target state="translated">Мы здесь переформулируем и усиливаем предыдущее предложение для акцентирования:Все изменения в пределах одной транзакции в SQLite происходят либо полностью,либо вообще не происходят,даже если акт записи изменения на диск прерывается посредством</target>
        </trans-unit>
        <trans-unit id="285d3238c6a1bf77e9e62067e7f260bf0b08d8c7" translate="yes" xml:space="preserve">
          <source>We know of no way to use the standard library printf() C interface to implement the &lt;a href=&quot;lang_corefunc#printf&quot;&gt;printf() SQL function&lt;/a&gt; feature of SQLite. The built-in printf() implementation can be easily adapted to that task, however.</source>
          <target state="translated">Мы не знаем способа использовать интерфейс стандартной библиотеки printf () C для реализации &lt;a href=&quot;lang_corefunc#printf&quot;&gt;функции printf () SQL&lt;/a&gt; в SQLite. Однако встроенная реализация printf () может быть легко адаптирована к этой задаче.</target>
        </trans-unit>
        <trans-unit id="e3b0138457bb49851f251d195b698d479cac5033" translate="yes" xml:space="preserve">
          <source>We make a distinction between a &quot;file format&quot; and an &quot;application format&quot;. A file format is used to store a single object. So, for example, a GIF or JPEG file stores a single image, and an XHTML file stores text, so those are &quot;file formats&quot; and not &quot;application formats&quot;. An EPUB file, in contrast, stores both text and images (as contained XHTML and GIF/JPEG files) and so it is considered an &quot;application format&quot;. This article is about &quot;application formats&quot;.</source>
          <target state="translated">Мы различаем &quot;формат файла&quot; и &quot;формат приложения&quot;.Формат файла используется для хранения одного объекта.Так,например,в файле GIF или JPEG хранится одно изображение,а в файле XHTML-текст,поэтому это &quot;форматы файлов&quot;,а не &quot;форматы приложений&quot;.Файл EPUB,напротив,хранит и текст,и изображения (как содержащиеся в файлах XHTML и GIF/JPEG),поэтому он считается &quot;форматом приложения&quot;.Данная статья посвящена &quot;форматам приложений&quot;.</target>
        </trans-unit>
        <trans-unit id="8909441e4d410050a1ceb2a957053ae17d1136a8" translate="yes" xml:space="preserve">
          <source>We propose to use the &lt;a href=&quot;http://www.fossil-scm.org&quot;&gt;fossil software configuration management&lt;/a&gt; system to set up two branches. One branch (the &quot;public branch&quot; or &quot;trunk&quot;) contains the published SQLite sources and the other branch is the private branch which contains the code that is customized for the project. Whenever a new public release of SQLite is made, that release is added to the public branch and then the changes are merged into the private branch.</source>
          <target state="translated">Мы предлагаем использовать систему &lt;a href=&quot;http://www.fossil-scm.org&quot;&gt;управления конфигурацией программного обеспечения fossil&lt;/a&gt; для создания двух филиалов. Одна ветвь (&amp;laquo;общедоступная ветвь&amp;raquo; или &amp;laquo;ствол&amp;raquo;) содержит опубликованные исходные коды SQLite, а другая ветвь - это частная ветвь, содержащая код, настроенный для проекта. Каждый раз, когда создается новый общедоступный выпуск SQLite, этот выпуск добавляется в общедоступную ветку, а затем изменения объединяются в частную ветвь.</target>
        </trans-unit>
        <trans-unit id="cdfe5941cfa327faeee1a3aa77e06f6d937ec10c" translate="yes" xml:space="preserve">
          <source>We say that a system has the powersafe overwrite property if the following statement is true:</source>
          <target state="translated">Мы говорим,что система имеет право на безопасную перезапись,если следующее утверждение верно:</target>
        </trans-unit>
        <trans-unit id="5b1e50114d6654d737309df661bca3d508073d97" translate="yes" xml:space="preserve">
          <source>We say that algorithm-1 is &quot;faster&quot;, but this is not strictly true. Algorithm-1 is faster in common repositories, but it is possible to construct a repository in which every check-in is on a different uniquely-named branch and all check-ins are children of the root check-in. In that case, TAGXREF_I1 would become more selective than PLINK_I1 and algorithm-2 really would be the faster choice. However such repositories are very unlikely to appear in practice and so hard-coding the loop nested order using the CROSS JOIN syntax is a reasonable solution to the problem in this case.</source>
          <target state="translated">Мы говорим,что алгоритм-1 &quot;быстрее&quot;,но это не совсем верно.Алгоритм-1 быстрее в обычных репозиториях,но можно построить репозиторий,в котором каждая регистрация происходит на другой одноименной ветке,и все регистрации являются дочерними процессами регистрации корня.В этом случае TAGXREF_I1 станет более избирательным,чем PLINK_I1,и алгоритм-2 действительно будет более быстрым выбором.Однако такие репозитории вряд ли появятся на практике,поэтому жесткое кодирование порядка вложенности циклов с использованием синтаксиса CROSS JOIN является разумным решением проблемы в данном случае.</target>
        </trans-unit>
        <trans-unit id="4ae339abf0ab672c65bdd6ccb60aabe5af32c503" translate="yes" xml:space="preserve">
          <source>We suspect that a common failure mode for SQLite recovery happens like this: A power failure occurs. After power is restored, a well-meaning user or system administrator begins looking around on the disk for damage. They see their database file named &quot;important.data&quot;. This file is perhaps familiar to them. But after the crash, there is also a hot journal named &quot;important.data-journal&quot;. The user then deletes the hot journal, thinking that they are helping to cleanup the system. We know of no way to prevent this other than user education.</source>
          <target state="translated">Мы подозреваем,что обычный режим отказа для восстановления SQLite происходит именно так:Происходит сбой электропитания.После восстановления питания благонамеренный пользователь или системный администратор начинает осматривать диск на предмет повреждений.Они видят файл своей базы данных под названием &quot;важные.данные&quot;.Возможно,этот файл им знаком.Но после аварии есть и горячий журнал под названием &quot;important.data-journal&quot;.Затем пользователь удаляет горячий журнал,думая,что он помогает очистить систему.Мы не знаем другого способа предотвратить это,кроме как обучение пользователя.</target>
        </trans-unit>
        <trans-unit id="00a0dbc2ebcd051c964b8bf428dbc0b4e94c1fd5" translate="yes" xml:space="preserve">
          <source>We want to know the twenty most recent ancestors in time (out of the thousands and thousands of ancestors in the whole DAG) for checkin &quot;@BASELINE&quot;. (A query similar to this is used by the &lt;a href=&quot;http://www.fossil-scm.org/&quot;&gt;Fossil&lt;/a&gt; VCS to show the N most recent ancestors of a check. For example: &lt;a href=&quot;http://www.sqlite.org/src/timeline?p=trunk&amp;amp;n=30&quot;&gt;http://www.sqlite.org/src/timeline?p=trunk&amp;amp;n=30&lt;/a&gt;.)</source>
          <target state="translated">Мы хотим вовремя узнать двадцать самых последних предков (из тысяч и тысяч предков во всем DAG) для проверки &amp;laquo;@BASELINE&amp;raquo;. (Подобный запрос используется &lt;a href=&quot;http://www.fossil-scm.org/&quot;&gt;Fossil&lt;/a&gt; VCS, чтобы показать N самых последних предков проверки. Например: &lt;a href=&quot;http://www.sqlite.org/src/timeline?p=trunk&amp;amp;n=30&quot;&gt;http://www.sqlite.org/src/timeline?p=trunk&amp;amp;n=30&lt;/a&gt; .)</target>
        </trans-unit>
        <trans-unit id="351c0b2917fd27c07d1575c325d6c434bf485fe8" translate="yes" xml:space="preserve">
          <source>Website Keyword Index</source>
          <target state="translated">Индекс ключевых слов сайта</target>
        </trans-unit>
        <trans-unit id="856955a1acaac17d20fdfd7478c48b194daa4307" translate="yes" xml:space="preserve">
          <source>Well-commented source code with &lt;a href=&quot;testing#coverage&quot;&gt;100% branch test coverage&lt;/a&gt;.</source>
          <target state="translated">Хорошо прокомментированный исходный код со &lt;a href=&quot;testing#coverage&quot;&gt;100% тестовым покрытием веток&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0fd93ad7c9151c213e1c81e636ad41e187dfdf3a" translate="yes" xml:space="preserve">
          <source>What If OpenDocument Used SQLite?</source>
          <target state="translated">Что делать,если OpenDocument использует SQLite?</target>
        </trans-unit>
        <trans-unit id="d1c91decdb314d1f98700dd1bdf20618d03adb15" translate="yes" xml:space="preserve">
          <source>What Is An Application File Format?</source>
          <target state="translated">Что такое формат файла заявки?</target>
        </trans-unit>
        <trans-unit id="8eafc9293497bf8d5a3b149b033e2c04c50289e4" translate="yes" xml:space="preserve">
          <source>What datatypes does SQLite support?</source>
          <target state="translated">Какие типы данных поддерживает SQLite?</target>
        </trans-unit>
        <trans-unit id="7ca20dfb510b956d12b7de007ce4f96db962811f" translate="yes" xml:space="preserve">
          <source>What harm could come of that, you ask? The SQLite developers (including this author) wondered the same thing. But then security researchers pointed out that knowledge of pointers can help attackers to circumvent address-space randomization defenses. This is called a &quot;pointer leak&quot;. A pointer leak is not itself a vulnerability, but it can aid an attacker in effectively exploiting other vulnerabilities.</source>
          <target state="translated">Какой вред это может нанести,спрашиваешь? Разработчики SQLite (в том числе и этот автор)задались тем же вопросом.Но потом исследователи безопасности обратили внимание на то,что знание указателей может помочь злоумышленникам обойти защиту адресного пространства от рандомизации.Это называется &quot;утечка указателя&quot;.Утечка указателя сама по себе не является уязвимостью,но может помочь злоумышленнику эффективно использовать другие уязвимости.</target>
        </trans-unit>
        <trans-unit id="09ddbcfffc504cb584adaf832caf679c81ed102d" translate="yes" xml:space="preserve">
          <source>What is an SQLITE_CORRUPT error? What does it mean for the database to be &quot;malformed&quot;? Why am I getting this error?</source>
          <target state="translated">Что такое ошибка SQLITE_CORRUPT? Что значит &quot;некорректная&quot; база данных? Почему я получаю эту ошибку?</target>
        </trans-unit>
        <trans-unit id="e5264a2f32d0c974ba717f0941d074614666d5ea" translate="yes" xml:space="preserve">
          <source>What is an SQLITE_SCHEMA error, and why am I getting one?</source>
          <target state="translated">Что такое ошибка SQLITE_SCHEMA,и почему я ее получаю?</target>
        </trans-unit>
        <trans-unit id="cb018b89b59e298a68db86ff80fc9eea140ccdd3" translate="yes" xml:space="preserve">
          <source>What is the Export Control Classification Number (ECCN) for SQLite?</source>
          <target state="translated">Что такое номер классификации экспортного контроля (ECCN)для SQLite?</target>
        </trans-unit>
        <trans-unit id="61fca1595cf614e3a194bfd194191403183b57e8" translate="yes" xml:space="preserve">
          <source>What is the maximum size of a VARCHAR in SQLite?</source>
          <target state="translated">Каков максимальный размер VARCHAR в SQLite?</target>
        </trans-unit>
        <trans-unit id="e213b22ce22925686c52aad4a90dd069f0962434" translate="yes" xml:space="preserve">
          <source>What is the total size of all files in the archive whose names end in &quot;.h&quot; or &quot;.cpp&quot;?</source>
          <target state="translated">Каков общий размер всех файлов в архиве,имена которых заканчиваются на &quot;.h&quot; или &quot;.cpp&quot;?</target>
        </trans-unit>
        <trans-unit id="3888afad2b88cfc56a74bc460d038e108bfb5e98" translate="yes" xml:space="preserve">
          <source>What others say about Fossil and Git</source>
          <target state="translated">Что другие говорят об ископаемых и Гитах</target>
        </trans-unit>
        <trans-unit id="f9f3ab382e9485e7278404c856bf161ccd6b2df4" translate="yes" xml:space="preserve">
          <source>What percentage of the files are compressed by less than 25%?</source>
          <target state="translated">Какой процент файлов сжат менее чем на 25%?</target>
        </trans-unit>
        <trans-unit id="b5461625f1011b3e4b6508b082fdfa963ef833c0" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; is used to prepare a statement, the statement might be re-prepared during &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; due to a schema change. Hence, the application should ensure that the correct authorizer callback remains in place during the &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt;.</source>
          <target state="translated">Когда &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; используется для подготовки оператора, оператор может быть повторно подготовлен во время &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step ()&lt;/a&gt; из-за изменения схемы. Следовательно, приложение должно гарантировать, что правильный обратный вызов авторизатора остается на месте во время &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="78fe376fe612030dba8e993e1e6346105acb51d4" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;PRAGMA locking_mode=EXCLUSIVE&lt;/a&gt; (exclusive locking mode) is set, only a single client is allowed to have the database open at one time. Since only a single client can use the database, the shm file is omitted. The single client uses a buffer in heap memory as a substitute for the memory-mapped shm file.</source>
          <target state="translated">Когда &lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;PRAGMA lock_mode = EXCLUSIVE&lt;/a&gt; (монопольный режим блокировки) установлен, только одному клиенту разрешено иметь базу данных открытой одновременно. Поскольку базу данных может использовать только один клиент, файл shm не указывается. Единственный клиент использует буфер в динамической памяти вместо отображенного в память файла shm.</target>
        </trans-unit>
        <trans-unit id="9abb811ba43f82c87eea517150f407f49b9906ac" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; is used to prepare a statement, the statement might be re-prepared during &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; due to a schema change. Hence, the application should ensure that the correct authorizer callback remains in place during the &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt;.</source>
          <target state="translated">Когда &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; используется для подготовки оператора, оператор может быть повторно подготовлен во время &lt;a href=&quot;step&quot;&gt;sqlite3_step ()&lt;/a&gt; из-за изменения схемы. Следовательно, приложение должно гарантировать, что правильный обратный вызов авторизатора остается на месте во время &lt;a href=&quot;step&quot;&gt;sqlite3_step ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c3c4a10f39f154fb9afe1cc905a05f1b736c3877" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;uri&quot;&gt;URI filenames&lt;/a&gt; are used, the &quot;cache&quot; query parameter can be used to specify whether or not the database will use shared cache. Use &quot;cache=shared&quot; to enable shared cache and &quot;cache=private&quot; to disable shared cache. The ability to use URI query parameters to specify the cache sharing behavior of a database connection allows cache sharing to be controlled in &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; statements. For example:</source>
          <target state="translated">Когда &lt;a href=&quot;uri&quot;&gt;используются имена файлов URI,&lt;/a&gt; можно использовать параметр запроса cache, чтобы указать, будет ли база данных использовать общий кеш. Используйте cache = shared, чтобы включить общий кеш, и cache = private, чтобы отключить общий кеш. Возможность использовать параметры запроса URI для указания поведения совместного использования кеша при подключении к базе данных позволяет управлять совместным использованием кеша в операторах &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; . Например:</target>
        </trans-unit>
        <trans-unit id="b0e9fc2254d872ac23aeae318057b6aa62d769dc" translate="yes" xml:space="preserve">
          <source>When &lt;b&gt;sqlite_step&lt;/b&gt; returns SQLITE_DONE or SQLITE_ERROR, the *pN and *pazColName values are set to the number of columns in the result set and to the names of the columns, just as they are for an SQLITE_ROW return. This allows the calling code to find the number of result columns and the column names and datatypes even if the result set is empty. The *pazValue parameter is always set to NULL when the return codes is SQLITE_DONE or SQLITE_ERROR. If the SQL being executed is a statement that does not return a result (such as an INSERT or an UPDATE) then *pN will be set to zero and *pazColName will be set to NULL.</source>
          <target state="translated">Когда &lt;b&gt;sqlite_step&lt;/b&gt; возвращает SQLITE_DONE или SQLITE_ERROR, значения * pN и * pazColName устанавливаются равными количеству столбцов в результирующем наборе и именам столбцов, как и для возврата SQLITE_ROW. Это позволяет вызывающему коду находить количество столбцов результатов, имена столбцов и типы данных, даже если набор результатов пуст. Параметр * pazValue всегда имеет значение NULL, если коды возврата - SQLITE_DONE или SQLITE_ERROR. Если выполняемый SQL является оператором, который не возвращает результат (например, INSERT или UPDATE), то * pN будет установлено в ноль, а * pazColName будет установлено в NULL.</target>
        </trans-unit>
        <trans-unit id="a738765e6d76b084ca79459e28b3c9bfca412130" translate="yes" xml:space="preserve">
          <source>When I want to see what has been happening on SQLite (or any of about a dozen other projects that I work on) I visit the &lt;a href=&quot;https://sqlite.org/src/timeline&quot;&gt;timeline&lt;/a&gt; and in a single screen I can see a quick summary of all the latest changes, on all branches. In a few clicks, I can drill down to see as much detail as I want. I can even do this from a phone.</source>
          <target state="translated">Когда я хочу увидеть, что происходит в SQLite (или в любом из примерно десятка других проектов, над которыми я работаю), я захожу на &lt;a href=&quot;https://sqlite.org/src/timeline&quot;&gt;временную шкалу&lt;/a&gt; и на одном экране я могу увидеть краткую сводку всех последних изменений во всех ветвях. За несколько щелчков мышью я могу развернуть, чтобы увидеть столько деталей, сколько мне нужно. Я могу это делать даже с телефона.</target>
        </trans-unit>
        <trans-unit id="3038431e6823ccdef12d1f539d0c61f30867d530" translate="yes" xml:space="preserve">
          <source>When RAISE(IGNORE) is called, the remainder of the current trigger program, the statement that caused the trigger program to execute and any subsequent trigger programs that would have been executed are abandoned. No database changes are rolled back. If the statement that caused the trigger program to execute is itself part of a trigger program, then that trigger program resumes execution at the beginning of the next step.</source>
          <target state="translated">При вызове RAISE(IGNORE)отбрасывается оставшаяся часть текущей триггерной программы,заявление,вызвавшее выполнение триггерной программы,и любые последующие триггерные программы,которые должны были бы быть выполнены.Никакие изменения в базе данных не откатываются.Если оператор,вызвавший выполнение триггерной программы,сам является частью триггерной программы,то эта триггерная программа возобновляет выполнение в начале следующего шага.</target>
        </trans-unit>
        <trans-unit id="3b714e2ab0d85ccd85c4bb15bba20b0ece19aa26" translate="yes" xml:space="preserve">
          <source>When SQLITE_ENABLE_SORTER_REFERENCES is enabled, the records passed to the sorter often contain only a &lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt; value. Such records are much smaller. This means the sorter has much less &quot;payload&quot; to deal with and can run faster. After sorting has occurred, the ROWID is used to look up the output column values in the original table. That requires another search into the table, and could potentially result in a slowdown. Or, it might be a performance win, depending on how large the values are.</source>
          <target state="translated">Когда SQLITE_ENABLE_SORTER_REFERENCES включен, записи, передаваемые сортировщику, часто содержат только значение &lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt; . Таких записей намного меньше. Это означает, что у сортировщика гораздо меньше &amp;laquo;полезной нагрузки&amp;raquo; и он может работать быстрее. После того, как сортировка произведена, ROWID используется для поиска значений выходных столбцов в исходной таблице. Это требует еще одного поиска в таблице и потенциально может привести к замедлению. Или это может быть выигрыш в производительности, в зависимости от того, насколько велики значения.</target>
        </trans-unit>
        <trans-unit id="22e2481654b7e499f20f0d8a14ccb29b23b47522" translate="yes" xml:space="preserve">
          <source>When SQLite calls the xTruncate() method, the cache must discard all existing cache entries with page numbers (keys) greater than or equal to the value of the iLimit parameter passed to xTruncate(). If any of these pages are pinned, they are implicitly unpinned, meaning that they can be safely discarded.</source>
          <target state="translated">Когда SQLite вызывает метод xTruncate(),кэш должен отбрасывать все существующие записи в кэше с номерами страниц (ключами)больше или равными значению параметра iLimit,переданного в xTruncate().Если какая-либо из этих страниц будет пинкирована,то она неявно распечатывается,что означает,что ее можно безопасно отбросить.</target>
        </trans-unit>
        <trans-unit id="35ff55b55b3144279fa7594a0e19885043618a48" translate="yes" xml:space="preserve">
          <source>When SQLite compares two strings, it uses a collating sequence or collating function (two words for the same thing) to determine which string is greater or if the two strings are equal. SQLite has three built-in collating functions: BINARY, NOCASE, and RTRIM.</source>
          <target state="translated">Когда SQLite сравнивает две строки,он использует коллекционную последовательность или коллекционную функцию (два слова для одного и того же),чтобы определить,какая строка больше или равны ли две строки.В SQLite есть три встроенные функции коллатинга:BINARY,NOCASE и RTRIM.</target>
        </trans-unit>
        <trans-unit id="df3602b4706fda192f1a7fee5a1fd5a14d6046e0" translate="yes" xml:space="preserve">
          <source>When SQLite has been compiled with SQLITE_THREADSAFE=1 or SQLITE_THREADSAFE=2 then the &lt;a href=&quot;threadsafe&quot;&gt;threading mode&lt;/a&gt; can be altered at run-time using the &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config()&lt;/a&gt; interface together with one of these verbs:</source>
          <target state="translated">Когда SQLite был скомпилирован с SQLITE_THREADSAFE = 1 или SQLITE_THREADSAFE = 2, то &lt;a href=&quot;threadsafe&quot;&gt;режим потоковой передачи&lt;/a&gt; можно изменить во время выполнения с помощью интерфейса &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config ()&lt;/a&gt; вместе с одним из этих глаголов:</target>
        </trans-unit>
        <trans-unit id="447f302ea851392a6eb166989220e6263326e6b8" translate="yes" xml:space="preserve">
          <source>When SQLite invokes the xSync() method of an &lt;a href=&quot;#sqlite3_io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object it uses a combination of these integer values as the second argument.</source>
          <target state="translated">Когда SQLite вызывает метод xSync () объекта &lt;a href=&quot;#sqlite3_io_methods&quot;&gt;sqlite3_io_methods,&lt;/a&gt; он использует комбинацию этих целочисленных значений в качестве второго аргумента.</target>
        </trans-unit>
        <trans-unit id="68d87b5a5c9475d95e19a08651c92859f1a25fae" translate="yes" xml:space="preserve">
          <source>When SQLite invokes the xSync() method of an &lt;a href=&quot;io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object it uses a combination of these integer values as the second argument.</source>
          <target state="translated">Когда SQLite вызывает метод xSync () объекта &lt;a href=&quot;io_methods&quot;&gt;sqlite3_io_methods,&lt;/a&gt; он использует комбинацию этих целочисленных значений в качестве второго аргумента.</target>
        </trans-unit>
        <trans-unit id="d35292160ae7a274b67325cfcd829f7632f2415b" translate="yes" xml:space="preserve">
          <source>When SQLite is compiled with the &lt;a href=&quot;compile#debug&quot;&gt;SQLITE_DEBUG&lt;/a&gt; compile-time option, extra &lt;a href=&quot;pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt; commands are available that are useful for debugging and for exploring the operation of the VDBE. For example the &lt;a href=&quot;pragma#pragma_vdbe_trace&quot;&gt;vdbe_trace&lt;/a&gt; pragma can be enabled to cause a disassembly of each VDBE opcode to be printed on standard output as the opcode is executed. These debugging pragmas include:</source>
          <target state="translated">Когда SQLite скомпилирован с параметром &lt;a href=&quot;compile#debug&quot;&gt;времени&lt;/a&gt; компиляции &lt;a href=&quot;pragma#syntax&quot;&gt;SQLITE_DEBUG&lt;/a&gt; , доступны дополнительные команды PRAGMA , которые полезны для отладки и исследования работы VDBE. Например, прагма &lt;a href=&quot;pragma#pragma_vdbe_trace&quot;&gt;vdbe_trace&lt;/a&gt; может быть включена для того, чтобы дизассемблированный код операции VDBE выводился на стандартный вывод при выполнении кода операции. Эти прагмы отладки включают:</target>
        </trans-unit>
        <trans-unit id="c9b995e894f1bbf11af15b50811aafd3b796ef85" translate="yes" xml:space="preserve">
          <source>When SQLite is compiled with the &lt;a href=&quot;compile#enable_memsys5&quot;&gt;SQLITE_ENABLE_MEMSYS5&lt;/a&gt; option, an alternative memory allocator that does not use malloc() is included in the build. The SQLite developers refer to this alternative memory allocator as &quot;memsys5&quot;. Even when it is included in the build, memsys5 is disabled by default. To enable memsys5, the application must invoke the following SQLite interface at start-time:</source>
          <target state="translated">Когда SQLite компилируется с параметром &lt;a href=&quot;compile#enable_memsys5&quot;&gt;SQLITE_ENABLE_MEMSYS5,&lt;/a&gt; в сборку включается альтернативный распределитель памяти, который не использует malloc (). Разработчики SQLite называют этот альтернативный распределитель памяти &amp;laquo;memsys5&amp;raquo;. Даже когда он включен в сборку, memsys5 по умолчанию отключен. Чтобы включить memsys5, приложение должно во время запуска вызывать следующий интерфейс SQLite:</target>
        </trans-unit>
        <trans-unit id="84ef8ebae9f557b2e5ae28bc7ed5746f2af208db" translate="yes" xml:space="preserve">
          <source>When SQLite is compiled with the SQLITE_MUTEX_APPDEF=1 option, it completely omits the implementation of its &lt;a href=&quot;c3ref/mutex_alloc&quot;&gt;mutex primitive functions&lt;/a&gt;. But the SQLite library still attempts to call these functions where necessary, so the application must itself implement the &lt;a href=&quot;c3ref/mutex_alloc&quot;&gt;mutex primitive functions&lt;/a&gt; and link them together with SQLite.</source>
          <target state="translated">Когда SQLite компилируется с опцией SQLITE_MUTEX_APPDEF = 1, он полностью пропускает реализацию своих &lt;a href=&quot;c3ref/mutex_alloc&quot;&gt;примитивных функций мьютекса&lt;/a&gt; . Но библиотека SQLite по-прежнему пытается вызывать эти функции там, где это необходимо, поэтому приложение должно само реализовывать &lt;a href=&quot;c3ref/mutex_alloc&quot;&gt;примитивные функции мьютекса&lt;/a&gt; и связывать их вместе с SQLite.</target>
        </trans-unit>
        <trans-unit id="7f137b8f0298a3c2c2e18d67228fddc4346fc04c" translate="yes" xml:space="preserve">
          <source>When SQLite is ported to new operating systems (operating systems other than Unix, Windows, and OS/2 for which ports are provided together with the core) two new functions, &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_os_init()&lt;/a&gt; and &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_os_end()&lt;/a&gt;, must be provided as part of the port.</source>
          <target state="translated">Когда SQLite переносится на новые операционные системы (операционные системы, отличные от Unix, Windows и OS / 2, для которых порты предоставляются вместе с ядром), две новые функции, &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_os_init ()&lt;/a&gt; и &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_os_end ()&lt;/a&gt; , должны быть предоставлены как часть порт.</target>
        </trans-unit>
        <trans-unit id="07b5adba013870fc7dc891a2821a51ae6a59171f" translate="yes" xml:space="preserve">
          <source>When SQLite tries to access a file that is locked by another process, the default behavior is to return SQLITE_BUSY. You can adjust this behavior from C code using the &lt;a href=&quot;c3ref/busy_handler&quot;&gt;sqlite3_busy_handler()&lt;/a&gt; or &lt;a href=&quot;c3ref/busy_timeout&quot;&gt;sqlite3_busy_timeout()&lt;/a&gt; API functions.</source>
          <target state="translated">Когда SQLite пытается получить доступ к файлу, заблокированному другим процессом, по умолчанию возвращается SQLITE_BUSY. Вы можете настроить это поведение из кода C с помощью функций API &lt;a href=&quot;c3ref/busy_handler&quot;&gt;sqlite3_busy_handler ()&lt;/a&gt; или &lt;a href=&quot;c3ref/busy_timeout&quot;&gt;sqlite3_busy_timeout ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="77327b5e49ebfcc1acf07f15eb4bc6a41abc04ea" translate="yes" xml:space="preserve">
          <source>When SQLite tries to open a database and finds that it is locked, it can optionally delay for a short while and try to open the file again. This process repeats until the query times out and SQLite returns a failure. The timeout is adjustable. It is set to 0 by default so that if the database is locked, the SQL statement fails immediately. But you can use the &quot;timeout&quot; method to change the timeout value to a positive number. For example:</source>
          <target state="translated">Когда SQLite пытается открыть базу данных и обнаруживает,что она заблокирована,он может опционально отложить это на некоторое время и попытаться открыть файл снова.Этот процесс повторяется до тех пор,пока запрос не завершится тайм-аутом и SQLite не вернет ошибку.Таймаут можно регулировать.По умолчанию он установлен на 0,так что если база данных заблокирована,SQL-оператор сразу же дает сбой.Но вы можете использовать метод &quot;таймаут&quot;,чтобы изменить значение таймаута на положительное число.Например:</target>
        </trans-unit>
        <trans-unit id="a804ec7f0a4b84d1b0a408e0b54447cf6ce4d1f8" translate="yes" xml:space="preserve">
          <source>When SQLite version 2.7.0 or later opens a 2.6.3 or earlier database, it assumes all columns of all tables have type &quot;numeric&quot;. For 2.7.0 and later databases, columns have type &quot;text&quot; if their datatype string contains the substrings &quot;char&quot; or &quot;clob&quot; or &quot;blob&quot; or &quot;text&quot;. Otherwise they are of type &quot;numeric&quot;.</source>
          <target state="translated">Когда SQLite версии 2.7.0 или более поздней версии открывает БД 2.6.3 или более ранней версии,предполагается,что все столбцы всех таблиц имеют тип &quot;числовой&quot;.Для баз данных версии 2.7.0 и выше колонки имеют тип &quot;text&quot;,если в их строке типа данных присутствуют подстроки &quot;char&quot; или &quot;clob&quot;,или &quot;blob&quot;,или &quot;text&quot;.В противном случае они имеют тип &quot;цифровой&quot;.</target>
        </trans-unit>
        <trans-unit id="a13408a2bfc81e3d04562db93d8a2fee6642da62" translate="yes" xml:space="preserve">
          <source>When SQLite was first being developed, Java was a young and immature language. C++ was older, but was undergoing such growing pains that it was difficult to find any two C++ compilers that worked the same way. So C was definitely a better choice back when SQLite was first being developed. The situation is less stark now, but there is little to no benefit in recoding SQLite at this point.</source>
          <target state="translated">Когда SQLite только разрабатывался,Java был молодым и незрелым языком.Си++был старше,но испытывал такие растущие трудности,что было трудно найти два одинаковых компилятора Си++.Так что Си был определенно лучшим выбором еще в то время,когда SQLite только разрабатывался.Сейчас ситуация менее разительная,но в перекодировке SQLite на данный момент нет никакой пользы.</target>
        </trans-unit>
        <trans-unit id="dd3d6234851cf7360a0faea15fc7c5c549469738" translate="yes" xml:space="preserve">
          <source>When a</source>
          <target state="translated">Когда</target>
        </trans-unit>
        <trans-unit id="b177e9320f32426fce848e5e150f059f226858de" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE&lt;/a&gt; or &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt; constraint violation occurs, the REPLACE algorithm deletes pre-existing rows that are causing the constraint violation prior to inserting or updating the current row and the command continues executing normally. If a &lt;a href=&quot;lang_createtable#notnullconst&quot;&gt;NOT NULL&lt;/a&gt; constraint violation occurs, the REPLACE conflict resolution replaces the NULL value with the default value for that column, or if the column has no default value, then the ABORT algorithm is used. If a &lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK constraint&lt;/a&gt; or &lt;a href=&quot;foreignkeys&quot;&gt;foreign key constraint&lt;/a&gt; violation occurs, the REPLACE conflict resolution algorithm works like ABORT.</source>
          <target state="translated">Когда происходит нарушение ограничения &lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE&lt;/a&gt; или &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt; , алгоритм REPLACE удаляет ранее существовавшие строки, которые вызывают нарушение ограничения, до вставки или обновления текущей строки, и команда продолжает выполняться в обычном режиме. Если происходит нарушение ограничения &lt;a href=&quot;lang_createtable#notnullconst&quot;&gt;NOT NULL&lt;/a&gt; , разрешение конфликта REPLACE заменяет значение NULL значением по умолчанию для этого столбца, или, если столбец не имеет значения по умолчанию, используется алгоритм ABORT. Если происходит &lt;a href=&quot;lang_createtable#ckconst&quot;&gt;ограничение CHECK&lt;/a&gt; или ограничение &lt;a href=&quot;foreignkeys&quot;&gt;внешнего ключа&lt;/a&gt; , алгоритм разрешения конфликтов REPLACE работает как ABORT.</target>
        </trans-unit>
        <trans-unit id="e40cfe4f4a2672a463b5e9153a546fd55dd2ffa8" translate="yes" xml:space="preserve">
          <source>When a UNIQUE constraint violation occurs, the pre-existing row that caused the constraint violation is removed prior to inserting or updating the current row. Thus the insert or update always occurs. The command continues executing normally. No error is returned.</source>
          <target state="translated">Когда происходит нарушение ограничения UNIQUE,предыдущая строка,которая вызвала нарушение ограничения,удаляется перед тем,как вставить или обновить текущую строку.Таким образом,всегда происходит вставка или обновление.Команда продолжает выполняться нормально.Ошибка не возвращается.</target>
        </trans-unit>
        <trans-unit id="f0f8ec6207370b712331444906a15edac7bd9982" translate="yes" xml:space="preserve">
          <source>When a WAL mode database is in active use, all three of the above files usually exist. Except, the Wal-Index file is omitted if &lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;exclusive locking mode&lt;/a&gt; is set.</source>
          <target state="translated">Когда база данных в режиме WAL активно используется, обычно существуют все три вышеуказанных файла. За исключением того, что файл Wal-Index опускается, если установлен &lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;эксклюзивный режим блокировки&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="88f7d29bc8b807cc4618404ebf6e68af0b14195c" translate="yes" xml:space="preserve">
          <source>When a blocking connection's transaction is concluded, there may be more than one blocked connection that has registered for an unlock-notify callback. If two or more such blocked connections have specified the same callback function, then instead of invoking the callback function multiple times, it is invoked once with the set of void* context pointers specified by the blocked connections bundled together into an array. This gives the application an opportunity to prioritize any actions related to the set of unblocked database connections.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eda8b145f23c6a0bb85ff0a12c0706d7475482c1" translate="yes" xml:space="preserve">
          <source>When a blocking connections transaction is concluded, there may be more than one blocked connection that has registered for an unlock-notify callback. If two or more such blocked connections have specified the same callback function, then instead of invoking the callback function multiple times, it is invoked once with the set of void* context pointers specified by the blocked connections bundled together into an array. This gives the application an opportunity to prioritize any actions related to the set of unblocked database connections.</source>
          <target state="translated">При заключении сделки по блокировке соединений может быть более одного заблокированного соединения,которое зарегистрировалось для обратного вызова уведомления о разблокировке.Если два или более таких заблокированных соединения указали одну и ту же функцию обратного вызова,то вместо многократного вызова функции обратного вызова она вызывается один раз с набором контекстных указателей void*,указанных заблокированными соединениями,объединенными в массив.Это дает приложению возможность установить приоритет любых действий,связанных с набором незаблокированных соединений с БД.</target>
        </trans-unit>
        <trans-unit id="b1623124138a1a453c5d32a837bf66762d013ccd" translate="yes" xml:space="preserve">
          <source>When a call to &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; returns SQLITE_LOCKED, it is almost always appropriate to call sqlite3_unlock_notify(). There is however, one exception. When executing a &quot;DROP TABLE&quot; or &quot;DROP INDEX&quot; statement, SQLite checks if there are any currently executing SELECT statements that belong to the same connection. If there are, SQLITE_LOCKED is returned. In this case there is no &quot;blocking connection&quot;, so invoking sqlite3_unlock_notify() results in the unlock-notify callback being invoked immediately. If the application then re-attempts the &quot;DROP TABLE&quot; or &quot;DROP INDEX&quot; query, an infinite loop might be the result.</source>
          <target state="translated">Когда вызов &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step ()&lt;/a&gt; возвращает SQLITE_LOCKED, почти всегда целесообразно вызывать sqlite3_unlock_notify (). Однако есть одно исключение. При выполнении оператора &amp;laquo;DROP TABLE&amp;raquo; или &amp;laquo;DROP INDEX&amp;raquo; SQLite проверяет, есть ли какие-либо выполняющиеся в данный момент операторы SELECT, принадлежащие тому же соединению. Если есть, возвращается SQLITE_LOCKED. В этом случае нет &amp;laquo;блокирующего соединения&amp;raquo;, поэтому вызов sqlite3_unlock_notify () приводит к немедленному вызову обратного вызова unlock-notify. Если приложение затем повторно попытается выполнить запрос &amp;laquo;DROP TABLE&amp;raquo; или &amp;laquo;DROP INDEX&amp;raquo;, результатом может быть бесконечный цикл.</target>
        </trans-unit>
        <trans-unit id="96fd9fb18740d68a037d0a53dc8f7e543ce5815d" translate="yes" xml:space="preserve">
          <source>When a call to &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; returns SQLITE_LOCKED, it is almost always appropriate to call sqlite3_unlock_notify(). There is however, one exception. When executing a &quot;DROP TABLE&quot; or &quot;DROP INDEX&quot; statement, SQLite checks if there are any currently executing SELECT statements that belong to the same connection. If there are, SQLITE_LOCKED is returned. In this case there is no &quot;blocking connection&quot;, so invoking sqlite3_unlock_notify() results in the unlock-notify callback being invoked immediately. If the application then re-attempts the &quot;DROP TABLE&quot; or &quot;DROP INDEX&quot; query, an infinite loop might be the result.</source>
          <target state="translated">Когда вызов &lt;a href=&quot;step&quot;&gt;sqlite3_step ()&lt;/a&gt; возвращает SQLITE_LOCKED, почти всегда целесообразно вызывать sqlite3_unlock_notify (). Однако есть одно исключение. При выполнении оператора &amp;laquo;DROP TABLE&amp;raquo; или &amp;laquo;DROP INDEX&amp;raquo; SQLite проверяет, есть ли какие-либо выполняющиеся в данный момент операторы SELECT, принадлежащие тому же соединению. Если есть, возвращается SQLITE_LOCKED. В этом случае нет &amp;laquo;блокирующего соединения&amp;raquo;, поэтому вызов sqlite3_unlock_notify () приводит к немедленному вызову обратного вызова unlock-notify. Если приложение затем повторно попытается выполнить запрос &amp;laquo;DROP TABLE&amp;raquo; или &amp;laquo;DROP INDEX&amp;raquo;, результатом может быть бесконечный цикл.</target>
        </trans-unit>
        <trans-unit id="4b27c6df7f370b95df53fb6af6deaef3ac0ea82c" translate="yes" xml:space="preserve">
          <source>When a changeset or patchset is applied to a database, an attempt is made to insert a new row for each INSERT change, remove a row for each DELETE change and modify a row for each UPDATE change. If the target database is in the same state as the original database that the changeset was recorded on, this is a simple matter. However, if the contents of the target database is not in exactly this state, conflicts can occur when applying the changeset or patchset.</source>
          <target state="translated">Когда changeset или patchset применяется к базе данных,делается попытка вставить новую строку для каждого изменения INSERT,удалить строку для каждого изменения DELETE и изменить строку для каждого изменения UPDATE.Если целевая база данных находится в том же состоянии,что и исходная база данных,в которую был записан changeset,то это простой вопрос.Однако,если содержимое целевой базы данных находится не в таком состоянии,могут возникнуть конфликты при применении changeset или patchset.</target>
        </trans-unit>
        <trans-unit id="af13c24a93516a02da3d5819b6d5ee382b394c0c" translate="yes" xml:space="preserve">
          <source>When a checkpoint runs, if it sees a lock on WAL_READ_LOCK(N), then it must not move WAL content into the main database for more than the first read-mark[N] frames. Were it to do so, it would overwrite content that the process holding the lock was expecting to be able to read out of the main database file. A consequence of if this is that f the WAL file contains more than read-mark[N] frames (if mxFrame&amp;gt;read-mark[N] for any read-mark for which WAL_READ_LOCK(N) is held by another process), then the checkpoint cannot run to completion.</source>
          <target state="translated">При запуске контрольной точки, если она видит блокировку WAL_READ_LOCK (N), то она не должна перемещать содержимое WAL в основную базу данных более чем на первые [N] фреймов с меткой чтения. Если бы это было сделано, он бы перезаписал содержимое, которое процесс, удерживающий блокировку, ожидал, что он сможет прочитать из основного файла базы данных. Следствием этого является то, что если файл WAL содержит больше, чем метка чтения [N] кадров (если mxFrame&amp;gt; метка чтения [N] для любой метки чтения, для которой WAL_READ_LOCK (N) удерживается другим процессом), то тогда контрольная точка не может работать до завершения.</target>
        </trans-unit>
        <trans-unit id="483ce2f4112b751479cd3313b5725fa8eedbb3fc" translate="yes" xml:space="preserve">
          <source>When a configuration option is set, sqlite3_config() returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt;. If the option is unknown or SQLite is unable to set the option then this routine returns a non-zero &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt;.</source>
          <target state="translated">Если установлен параметр конфигурации, sqlite3_config () возвращает &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; . Если параметр неизвестен или SQLite не может установить его, эта процедура возвращает ненулевой &lt;a href=&quot;rescode&quot;&gt;код ошибки&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="42a829c41f1de7dff832e7bd4aea25619f81edf9" translate="yes" xml:space="preserve">
          <source>When a configuration option is set, sqlite3_config() returns &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;. If the option is unknown or SQLite is unable to set the option then this routine returns a non-zero &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt;.</source>
          <target state="translated">Если установлен параметр конфигурации, sqlite3_config () возвращает &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; . Если параметр неизвестен или SQLite не может установить его, эта процедура возвращает ненулевой &lt;a href=&quot;../rescode&quot;&gt;код ошибки&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5ec6b6ac63fbc35d1df0b3e9fb9cdbeeef10333e" translate="yes" xml:space="preserve">
          <source>When a connection (known as the blocked connection) fails to obtain a shared-cache lock and SQLITE_LOCKED is returned to the caller, the identity of the database connection (the blocking connection) that has locked the required resource is stored internally. After an application receives an SQLITE_LOCKED error, it may call the sqlite3_unlock_notify() method with the blocked connection handle as the first argument to register for a callback that will be invoked when the blocking connections current transaction is concluded. The callback is invoked from within the &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step&lt;/a&gt; or &lt;a href=&quot;#sqlite3_close&quot;&gt;sqlite3_close&lt;/a&gt; call that concludes the blocking connection's transaction.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a34b978574691e0c575f3f24ebbf266179b4d2f" translate="yes" xml:space="preserve">
          <source>When a connection (known as the blocked connection) fails to obtain a shared-cache lock and SQLITE_LOCKED is returned to the caller, the identity of the database connection (the blocking connection) that has locked the required resource is stored internally. After an application receives an SQLITE_LOCKED error, it may call the sqlite3_unlock_notify() method with the blocked connection handle as the first argument to register for a callback that will be invoked when the blocking connections current transaction is concluded. The callback is invoked from within the &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step&lt;/a&gt; or &lt;a href=&quot;#sqlite3_close&quot;&gt;sqlite3_close&lt;/a&gt; call that concludes the blocking connections transaction.</source>
          <target state="translated">Когда соединение (известное как заблокированное соединение) не может получить блокировку общего кэша и вызывающему объекту возвращается SQLITE_LOCKED, идентификатор соединения с базой данных (блокирующее соединение), которое заблокировало требуемый ресурс, сохраняется внутри. После того, как приложение получает ошибку SQLITE_LOCKED, оно может вызвать метод sqlite3_unlock_notify () с дескриптором заблокированного соединения в качестве первого аргумента для регистрации для обратного вызова, который будет вызываться при завершении текущей транзакции блокирующих соединений. Обратный вызов вызывается из вызова &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step&lt;/a&gt; или &lt;a href=&quot;#sqlite3_close&quot;&gt;sqlite3_close,&lt;/a&gt; который завершает транзакцию блокировки соединений.</target>
        </trans-unit>
        <trans-unit id="58820b450842a3b35138dd7706fb343d060de1de" translate="yes" xml:space="preserve">
          <source>When a connection (known as the blocked connection) fails to obtain a shared-cache lock and SQLITE_LOCKED is returned to the caller, the identity of the database connection (the blocking connection) that has locked the required resource is stored internally. After an application receives an SQLITE_LOCKED error, it may call the sqlite3_unlock_notify() method with the blocked connection handle as the first argument to register for a callback that will be invoked when the blocking connections current transaction is concluded. The callback is invoked from within the &lt;a href=&quot;step&quot;&gt;sqlite3_step&lt;/a&gt; or &lt;a href=&quot;close&quot;&gt;sqlite3_close&lt;/a&gt; call that concludes the blocking connection's transaction.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7b71c21ec59e3320b31da28e6f5087ad7dce22a" translate="yes" xml:space="preserve">
          <source>When a connection (known as the blocked connection) fails to obtain a shared-cache lock and SQLITE_LOCKED is returned to the caller, the identity of the database connection (the blocking connection) that has locked the required resource is stored internally. After an application receives an SQLITE_LOCKED error, it may call the sqlite3_unlock_notify() method with the blocked connection handle as the first argument to register for a callback that will be invoked when the blocking connections current transaction is concluded. The callback is invoked from within the &lt;a href=&quot;step&quot;&gt;sqlite3_step&lt;/a&gt; or &lt;a href=&quot;close&quot;&gt;sqlite3_close&lt;/a&gt; call that concludes the blocking connections transaction.</source>
          <target state="translated">Когда соединение (известное как заблокированное соединение) не может получить блокировку общего кэша и вызывающему объекту возвращается SQLITE_LOCKED, идентификатор соединения с базой данных (блокирующее соединение), которое заблокировало требуемый ресурс, сохраняется внутри. После того, как приложение получает ошибку SQLITE_LOCKED, оно может вызвать метод sqlite3_unlock_notify () с дескриптором заблокированного соединения в качестве первого аргумента для регистрации для обратного вызова, который будет вызываться при завершении текущей транзакции блокирующих соединений. Обратный вызов вызывается из вызова &lt;a href=&quot;step&quot;&gt;sqlite3_step&lt;/a&gt; или &lt;a href=&quot;close&quot;&gt;sqlite3_close,&lt;/a&gt; который завершает транзакцию блокировки соединений.</target>
        </trans-unit>
        <trans-unit id="2d95de74c44ccc79daba549c33cfe91ac9ee60b3" translate="yes" xml:space="preserve">
          <source>When a connection holds a shared lock on WAL_READ_LOCK(N), that is a promise by the connection that it will use the WAL and not the database file for any database pages that are modified by the first read-mark[N] entries in the WAL. The read-mark[0] is always zero. If a connection holds a shared lock on WAL_READ_LOCK(0), that means the connection expects to be able to ignore the WAL and read any content it wants from the main database. If N&amp;gt;0 then the connection is free to use more of the WAL file beyond read-mark[N] if it wants to, up to the first mxFrame frames. But when a connection holds a shared lock on WAL_READ_LOCK(0), that is a promise that it will never read content from the WAL and will acquire all content directly from the main database.</source>
          <target state="translated">Когда соединение удерживает разделяемую блокировку на WAL_READ_LOCK (N), это обещание соединения, что оно будет использовать WAL, а не файл базы данных для любых страниц базы данных, которые изменяются первой меткой чтения [N] записей в WAL. Метка чтения [0] всегда равна нулю. Если соединение удерживает разделяемую блокировку на WAL_READ_LOCK (0), это означает, что соединение ожидает, что сможет игнорировать WAL и читать любой контент, который он хочет, из основной базы данных. Если N&amp;gt; 0, то соединение может использовать больше файла WAL за пределами метки чтения [N], если оно того хочет, вплоть до первых кадров mxFrame. Но когда соединение удерживает разделяемую блокировку на WAL_READ_LOCK (0), это обещание, что оно никогда не будет читать контент из WAL и получит весь контент непосредственно из основной базы данных.</target>
        </trans-unit>
        <trans-unit id="e114c32681a6d0ab6fee9545fa50582f6c054845" translate="yes" xml:space="preserve">
          <source>When a connection is holding a SHARED lock on the main database, that will prevent any other connection from acquiring the EXCLUSIVE lock, which in turn prevents the WAL-index and WAL files from being deleted out from under other users, and prevents a transition out of WAL-mode while other users are accessing the database in WAL-mode.</source>
          <target state="translated">Когда соединение держит блокировку SHARED на основной БД,это предотвращает любое другое соединение от получения блокировки EXCLUSIVE,что в свою очередь предотвращает удаление WAL-индексов и WAL-файлов из-под других пользователей,а также предотвращает выход из WAL-режима,когда другие пользователи получают доступ к БД в WAL-режиме.</target>
        </trans-unit>
        <trans-unit id="12c1255cc9a16f21fccefe2ac6a059ed783c7d20" translate="yes" xml:space="preserve">
          <source>When a connection using asynchronous IO begins a database transaction, the database is locked immediately. However the lock is not released until after all relevant operations in the write-queue have been flushed to disk. This means (for example) that the database may remain locked for some time after a &quot;&lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt;&quot; or &quot;&lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt;&quot; is issued.</source>
          <target state="translated">Когда соединение с использованием асинхронного ввода-вывода начинает транзакцию базы данных, база данных немедленно блокируется. Однако блокировка не снимается до тех пор, пока все соответствующие операции в очереди записи не будут сброшены на диск. Это означает (например), что база данных может оставаться заблокированной в течение некоторого времени после выдачи &amp;laquo; &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; &amp;raquo; или &amp;laquo; &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt; &amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="ddb7b3f482852f424ece2e0896d73a04a9d957e4" translate="yes" xml:space="preserve">
          <source>When a constraint violation occurs, an immediate ROLLBACK occurs, thus ending the current transaction, and the command aborts with a return code of SQLITE_CONSTRAINT. If no transaction is active (other than the implied transaction that is created on every command) then this algorithm works the same as ABORT.</source>
          <target state="translated">Когда происходит нарушение ограничения,немедленно происходит ROLLBACK,тем самым завершая текущую транзакцию,и команда прерывается с кодом возврата SQLITE_CONSTRAINT.Если ни одна транзакция не активна (кроме подразумеваемой транзакции,которая создается по каждой команде),то данный алгоритм работает так же,как и ABORT.</target>
        </trans-unit>
        <trans-unit id="933e3d0ae1663c35b2ff70117a98cacf0e4923d6" translate="yes" xml:space="preserve">
          <source>When a constraint violation occurs, the command aborts with a return code SQLITE_CONSTRAINT. But any changes to the database that the command made prior to encountering the constraint violation are preserved and are not backed out. For example, if an UPDATE statement encountered a constraint violation on the 100th row that it attempts to update, then the first 99 row changes are preserved but change to rows 100 and beyond never occur.</source>
          <target state="translated">При нарушении ограничения команда прерывается с кодом возврата SQLITE_CONSTRAINT.Однако любые изменения в БД,которые команда произвела до появления нарушения ограничения,сохраняются и не отступают.Например,если оператор UPDATE столкнулся с нарушением ограничения на 100-й строке,которую он пытается обновить,то первые 99 изменений в строке сохраняются,но изменение на 100-й строке и более никогда не происходит.</target>
        </trans-unit>
        <trans-unit id="6397f8d4479c4b84e08676c10c54e0afd51f843f" translate="yes" xml:space="preserve">
          <source>When a constraint violation occurs, the command backs out any prior changes it might have made and aborts with a return code of SQLITE_CONSTRAINT. But no ROLLBACK is executed so changes from prior commands within the same transaction are preserved. This is the default behavior for SQLite.</source>
          <target state="translated">Когда происходит нарушение ограничения,команда отбрасывает все предыдущие изменения,которые она могла внести,и прерывает их с помощью кода возврата SQLITE_CONSTRAINT.Но ROLLBACK не выполняется,поэтому изменения из предыдущих команд в той же самой транзакции сохраняются.Это поведение по умолчанию для SQLite.</target>
        </trans-unit>
        <trans-unit id="39dcfeb5298d9a69a9dfd10b897e4e703da8e46b" translate="yes" xml:space="preserve">
          <source>When a constraint violation occurs, the one row that contains the constraint violation is not inserted or changed. But the command continues executing normally. Other rows before and after the row that contained the constraint violation continue to be inserted or updated normally. No error is returned.</source>
          <target state="translated">Когда происходит нарушение ограничения,единственная строка,которая содержит нарушение ограничения,не вставляется и не изменяется.Однако команда продолжает выполняться нормально.Остальные строки до и после строки,содержащей нарушение ограничения,продолжают нормально вставляться или обновляться.Ошибка не возвращается.</target>
        </trans-unit>
        <trans-unit id="d77ac0a4b71596448d90ef0386a9797d90b3dad6" translate="yes" xml:space="preserve">
          <source>When a database connection closes (via &lt;a href=&quot;c3ref/close&quot;&gt;sqlite3_close()&lt;/a&gt; or &lt;a href=&quot;c3ref/close&quot;&gt;sqlite3_close_v2()&lt;/a&gt;), an attempt is made to acquire SQLITE_LOCK_EXCLUSIVE. If this attempt is successful, that means the connection that is closing is the last connection to the database. In that case, it is desirable to clean up the WAL and WAL-index files, so the closing connection runs a &lt;a href=&quot;wal#ckpt&quot;&gt;checkpoint&lt;/a&gt; (while holding SQLITE_LOCK_EXCLUSIVE) and the deletes both the WAL and WAL-index files. The SQLITE_LOCK_EXCLUSIVE is not released until after both the WAL and WAL-index files have been deleted.</source>
          <target state="translated">Когда соединение с базой данных закрывается (через &lt;a href=&quot;c3ref/close&quot;&gt;sqlite3_close ()&lt;/a&gt; или &lt;a href=&quot;c3ref/close&quot;&gt;sqlite3_close_v2 ()&lt;/a&gt; ), предпринимается попытка получить SQLITE_LOCK_EXCLUSIVE. Если эта попытка успешна, это означает, что закрывающееся соединение является последним подключением к базе данных. В этом случае желательно очистить файлы индекса WAL и WAL, чтобы закрывающее соединение запускало &lt;a href=&quot;wal#ckpt&quot;&gt;контрольную точку&lt;/a&gt; (с сохранением SQLITE_LOCK_EXCLUSIVE) и удаляло файлы индекса WAL и WAL. SQLITE_LOCK_EXCLUSIVE не освобождается до тех пор, пока не будут удалены файлы WAL и WAL-index.</target>
        </trans-unit>
        <trans-unit id="20a6ff534ce9652a9eda05b6d0935e6cf08856e6" translate="yes" xml:space="preserve">
          <source>When a directory is inserted, if the &quot;name&quot; value does not end with a '/' character, the zipfile module appends one. This is necessary for compatibility with other programs (most notably &quot;info-zip&quot;) that manipulate zip archives.</source>
          <target state="translated">При вставке каталога,если значение &quot;name&quot; не заканчивается символом '/',zip-файловый модуль добавляет его.Это необходимо для совместимости с другими программами (особенно с &quot;info-zip&quot;),которые работают с zip-архивами.</target>
        </trans-unit>
        <trans-unit id="26801f7dad030d0d12374b8b8d55040830791b46" translate="yes" xml:space="preserve">
          <source>When a file-handle open on a database file is unlocked, if the</source>
          <target state="translated">Когда файл-ручка,открытая в файле базы данных,разблокирована,если</target>
        </trans-unit>
        <trans-unit id="70b05b0c4ad89d4e7f94cf5e4dedf4b6997bc209" translate="yes" xml:space="preserve">
          <source>When a function uses a column from a virtual table as its first argument, this method is called to see if the virtual table would like to overload the function. The first three parameters are inputs: the virtual table, the number of arguments to the function, and the name of the function. If no overloading is desired, this method returns 0. To overload the function, this method writes the new function implementation into *pxFunc and writes user data into *ppArg and returns either 1 or a number between &lt;a href=&quot;c3ref/c_index_constraint_eq&quot;&gt;SQLITE_INDEX_CONSTRAINT_FUNCTION&lt;/a&gt; and 255.</source>
          <target state="translated">Когда функция использует столбец из виртуальной таблицы в качестве первого аргумента, этот метод вызывается, чтобы узнать, не хочет ли виртуальная таблица перегрузить функцию. Первые три параметра - это входные данные: виртуальная таблица, количество аргументов функции и имя функции. Если перегрузка не требуется, этот метод возвращает 0. Для перегрузки функции этот метод записывает новую реализацию функции в * pxFunc и записывает данные пользователя в * ppArg и возвращает либо 1, либо число от &lt;a href=&quot;c3ref/c_index_constraint_eq&quot;&gt;SQLITE_INDEX_CONSTRAINT_FUNCTION&lt;/a&gt; до 255.</target>
        </trans-unit>
        <trans-unit id="8365620f1c717c4826d64a41ab8d38dd2fc7b98d" translate="yes" xml:space="preserve">
          <source>When a new</source>
          <target state="translated">Когда новый</target>
        </trans-unit>
        <trans-unit id="699fe2196c054a2761ad370d04849c2f40137718" translate="yes" xml:space="preserve">
          <source>When a new database is created, SQLite assigns a page size to the database based on platform and filesystem. For many years, the default page size was almost always 1024 bytes, but beginning with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_12_0.html&quot;&gt;version 3.12.0&lt;/a&gt; (2016-03-29), the default page size increased to 4096. The default page size is recommended for most applications.</source>
          <target state="translated">Когда создается новая база данных, SQLite назначает размер страницы для базы данных в зависимости от платформы и файловой системы. В течение многих лет размер страницы по умолчанию почти всегда составлял 1024 байта, но, начиная с &lt;a href=&quot;https://sqlite.org/releaselog/3_12_0.html&quot;&gt;версии&lt;/a&gt; SQLite 3.12.0 (2016-03-29), размер страницы по умолчанию увеличился до 4096. Размер страницы по умолчанию рекомендуется для большинства приложений.</target>
        </trans-unit>
        <trans-unit id="45fd9923f092fbfb6768ecc3efe603fb1851939b" translate="yes" xml:space="preserve">
          <source>When a new database page is appended to a database file, there is no requirement to add a record to the</source>
          <target state="translated">Когда новая страница базы данных добавляется к файлу базы данных,нет необходимости добавлять запись к</target>
        </trans-unit>
        <trans-unit id="b08473c5ea155814010ebff8331980504b3653e4" translate="yes" xml:space="preserve">
          <source>When a new file is created, most desktop operating systems (Windows, Linux, Mac OS X) will not actually write anything to disk. The new file is created in the operating systems disk cache only. The file is not created on mass storage until sometime later, when the operating system has a spare moment. This creates the impression to users that I/O is happening much faster than is possible when doing real disk I/O. We illustrate this idea in the diagram to the right by showing that the new rollback journal appears in the operating system disk cache only and not on the disk itself.</source>
          <target state="translated">Когда создается новый файл,большинство настольных операционных систем (Windows,Linux,Mac OS X)на самом деле ничего не записывают на диск.Новый файл создается только в дисковом кэше операционных систем.Файл создается на массовом хранении только через некоторое время,когда у операционной системы есть свободный момент.Это создает у пользователей впечатление,что ввод/вывод происходит намного быстрее,чем это возможно при выполнении реального дискового ввода/вывода.Мы иллюстрируем эту идею на диаграмме справа,показывая,что новый журнал отката появляется только в дисковом кэше операционной системы,а не на самом диске.</target>
        </trans-unit>
        <trans-unit id="0a07f6d8079bf577cb3fe5588a8b9770dc9fc5d1" translate="yes" xml:space="preserve">
          <source>When a new row is inserted into an SQLite table, the ROWID can either be specified as part of the INSERT statement or it can be assigned automatically by the database engine. To specify a ROWID manually, just include it in the list of values to be inserted. For example:</source>
          <target state="translated">Когда новая строка вставляется в таблицу SQLite,ROWID может быть либо указан как часть оператора INSERT,либо назначен автоматически движком базы данных.Чтобы указать ROWID вручную,просто включите его в список значений для вставки.Например:</target>
        </trans-unit>
        <trans-unit id="0f0ce235c557e884c10fe9cff8d86b46112c91c8" translate="yes" xml:space="preserve">
          <source>When a process wants to change a database file (and it is not in &lt;a href=&quot;wal&quot;&gt;WAL&lt;/a&gt; mode), it first records the original unchanged database content in a &lt;em&gt;rollback journal&lt;/em&gt;. The rollback journal is an ordinary disk file that is always located in the same directory or folder as the database file and has the same name as the database file with the addition of a &lt;code&gt;-journal&lt;/code&gt; suffix. The rollback journal also records the initial size of the database so that if the database file grows it can be truncated back to its original size on a rollback.</source>
          <target state="translated">Когда процесс хочет изменить файл базы данных (а он не находится в режиме &lt;a href=&quot;wal&quot;&gt;WAL&lt;/a&gt; ), он сначала записывает исходное неизмененное содержимое базы данных в &lt;em&gt;журнал отката&lt;/em&gt; . Журнал отката - это обычный дисковый файл, который всегда находится в том же каталоге или папке, что и файл базы данных, и имеет то же имя, что и файл базы данных, с добавлением суффикса &lt;code&gt;-journal&lt;/code&gt; . В журнале отката также записывается начальный размер базы данных, поэтому, если файл базы данных увеличивается, его можно обрезать до исходного размера при откате.</target>
        </trans-unit>
        <trans-unit id="4bd80d03aa6d2b960c4978ddc8751bef460c3fb0" translate="yes" xml:space="preserve">
          <source>When a process wants to read from a database file, it followed the following sequence of steps:</source>
          <target state="translated">Когда процесс хочет читать из файла базы данных,он выполняет следующую последовательность шагов:</target>
        </trans-unit>
        <trans-unit id="577306227dff9ce8975b3fcaaa51b9a6b5656983" translate="yes" xml:space="preserve">
          <source>When a read operation begins on a WAL-mode database, it first remembers the location of the last valid commit record in the WAL. Call this point the &quot;end mark&quot;. Because the WAL can be growing and adding new commit records while various readers connect to the database, each reader can potentially have its own end mark. But for any particular reader, the end mark is unchanged for the duration of the transaction, thus ensuring that a single read transaction only sees the database content as it existed at a single point in time.</source>
          <target state="translated">Когда начинается операция чтения в базе данных WAL-режима,она сначала запоминает местоположение последней действительной записи фиксации в WAL.Назовите эту точку &quot;конечной меткой&quot;.Поскольку WAL может расти и добавлять новые записи фиксации,в то время как различные читатели подключаются к базе данных,каждый читатель потенциально может иметь свою собственную конечную метку.Но для любого конкретного читателя конечный знак остается неизменным на протяжении всей транзакции,обеспечивая таким образом,что одна прочитанная транзакция видит только содержимое базы данных в том виде,в каком оно существовало в одной точке.</target>
        </trans-unit>
        <trans-unit id="6c0dd2ac1af5d6880101af98898ac515a0c331fe" translate="yes" xml:space="preserve">
          <source>When a reader needs a page of content, it first checks the WAL to see if that page appears there, and if so it pulls in the last copy of the page that occurs in the WAL prior to the reader's end mark. If no copy of the page exists in the WAL prior to the reader's end mark, then the page is read from the original database file. Readers can exist in separate processes, so to avoid forcing every reader to scan the entire WAL looking for pages (the WAL file can grow to multiple megabytes, depending on how often checkpoints are run), a data structure called the &quot;wal-index&quot; is maintained in shared memory which helps readers locate pages in the WAL quickly and with a minimum of I/O. The wal-index greatly improves the performance of readers, but the use of shared memory means that all readers must exist on the same machine. This is why the write-ahead log implementation will not work on a network filesystem.</source>
          <target state="translated">Когда читателю нужна страница контента,он сначала проверяет WAL,не появляется ли эта страница там,и если появляется,то тянет за собой последнюю копию страницы,которая появляется в WAL перед отметкой конца читателя.Если до отметки конца читателя в WAL нет ни одной копии страницы,то эта страница считывается из исходного файла базы данных.Считыватели могут существовать в отдельных процессах,поэтому,чтобы не заставлять каждое считывающее устройство сканировать весь WAL в поисках страниц (файл WAL может вырасти до нескольких мегабайт,в зависимости от того,как часто выполняются контрольно-пропускные пункты),в общей памяти поддерживается структура данных,называемая &quot;wal-index&quot;,которая помогает считывающим устройствам быстро и с минимальным количеством операций ввода-вывода определять местонахождение страниц в WAL.Wal-index значительно повышает производительность считывателей,но использование общей памяти означает,что все считыватели должны существовать на одной машине.Вот почему реализация записи в журнал не будет работать на сетевой файловой системе.</target>
        </trans-unit>
        <trans-unit id="730f5bd701321fbbb693ce5b184d905999894efe" translate="yes" xml:space="preserve">
          <source>When a row is deleted from an external content FTS4 table, FTS4 needs to retrieve the column values of the row being deleted from the content table. This is so that FTS4 can update the full-text index entries for each token that occurs within the deleted row to indicate that row has been deleted. If the content table row cannot be found, or if it contains values inconsistent with the contents of the FTS index, the results can be difficult to predict. The FTS index may be left containing entries corresponding to the deleted row, which can lead to seemingly nonsensical results being returned by subsequent SELECT queries. The same applies when a row is updated, as internally an UPDATE is the same as a DELETE followed by an INSERT.</source>
          <target state="translated">Когда строка удаляется из таблицы внешнего содержимого FTS4,FTS4 должна получить значения столбцов удаляемой строки из таблицы содержимого.Это делается для того,чтобы FTS4 могла обновлять записи полнотекстового индекса для каждого маркера,находящегося внутри удаленной строки,чтобы указывать на то,что строка была удалена.Если строка таблицы содержимого не может быть найдена,или если она содержит значения,несовместимые с содержимым индекса FTS,результаты может быть трудно предсказать.Индекс FTS может быть оставлен с записями,соответствующими удаленной строке,что может привести к тому,что последующие SELECT-запросы будут возвращать на первый взгляд бессмысленные результаты.То же самое относится и к обновлению строки,так как внутренне UPDATE-это то же самое,что DELETE,за которым следует INSERT.</target>
        </trans-unit>
        <trans-unit id="c5bdbf38f9947ad2a93dddd10975fb895dc64e45" translate="yes" xml:space="preserve">
          <source>When a schema change occurs that requires a prepared statement to be reparsed and reprepared, that event is logged with the error code SQLITE_SCHEMA. The reparse and reprepare is normally automatic (assuming that &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; has been used to prepared the statements originally, which is recommended) and so these logging events are normally the only way to know that reprepares are taking place.</source>
          <target state="translated">Когда происходит изменение схемы, которое требует повторного анализа и повторного сопоставления подготовленного оператора, это событие регистрируется с кодом ошибки SQLITE_SCHEMA. Повторная обработка и повторная подготовка обычно выполняются автоматически (при условии, что &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; была использована для первоначальной подготовки операторов, что рекомендуется), и поэтому эти события регистрации обычно являются единственным способом узнать, что происходит повторное сравнение.</target>
        </trans-unit>
        <trans-unit id="19333c5294fb7ef73ead50d971608427e5e277b4" translate="yes" xml:space="preserve">
          <source>When a search request occurs and pending documents are indexed for the first time, the ftsdocs table must be updated by setting the idxed column to true and also filling in several other columns with information pertinent to the search. That other information is obtained from a join. The query is this:</source>
          <target state="translated">При возникновении поискового запроса и при первом индексировании отложенных документов таблица ftsdocs должна быть обновлена путем установки значения idxed в столбце true,а также путем заполнения нескольких других столбцов информацией,относящейся к поиску.Эта другая информация получается из соединения.Запрос такой:</target>
        </trans-unit>
        <trans-unit id="5a34c7922c5247a2a858115497a487644ed495d8" translate="yes" xml:space="preserve">
          <source>When a session object is disabled (see the &lt;a href=&quot;#sqlite3session_enable&quot;&gt;sqlite3session_enable()&lt;/a&gt; API), it does not accumulate records when rows are inserted, updated or deleted. This may appear to have some counter-intuitive effects if a single row is written to more than once during a session. For example, if a row is inserted while a session object is enabled, then later deleted while the same session object is disabled, no INSERT record will appear in the changeset, even though the delete took place while the session was disabled. Or, if one field of a row is updated while a session is disabled, and another field of the same row is updated while the session is enabled, the resulting changeset will contain an UPDATE change that updates both fields.</source>
          <target state="translated">Когда объект сеанса отключен (см. API &lt;a href=&quot;#sqlite3session_enable&quot;&gt;sqlite3session_enable ()&lt;/a&gt; ), он не накапливает записи при вставке, обновлении или удалении строк. Может показаться, что это имеет некоторые нелогичные эффекты, если одна строка записывается более одного раза за сеанс. Например, если строка вставляется, когда объект сеанса включен, а затем удаляется, когда тот же объект сеанса отключен, запись INSERT не появится в наборе изменений, даже если удаление произошло, когда сеанс был отключен. Или, если одно поле строки обновляется, пока сеанс отключен, а другое поле той же строки обновляется, пока сеанс включен, результирующий набор изменений будет содержать изменение UPDATE, которое обновляет оба поля.</target>
        </trans-unit>
        <trans-unit id="4f45d6d9d609e68af4097ec8d881bf58ab9f2d1b" translate="yes" xml:space="preserve">
          <source>When a session object is disabled (see the &lt;a href=&quot;sqlite3session_enable&quot;&gt;sqlite3session_enable()&lt;/a&gt; API), it does not accumulate records when rows are inserted, updated or deleted. This may appear to have some counter-intuitive effects if a single row is written to more than once during a session. For example, if a row is inserted while a session object is enabled, then later deleted while the same session object is disabled, no INSERT record will appear in the changeset, even though the delete took place while the session was disabled. Or, if one field of a row is updated while a session is disabled, and another field of the same row is updated while the session is enabled, the resulting changeset will contain an UPDATE change that updates both fields.</source>
          <target state="translated">Когда объект сеанса отключен (см. API &lt;a href=&quot;sqlite3session_enable&quot;&gt;sqlite3session_enable ()&lt;/a&gt; ), он не накапливает записи при вставке, обновлении или удалении строк. Может показаться, что это имеет некоторые нелогичные эффекты, если одна строка записывается более одного раза за сеанс. Например, если строка вставляется, когда объект сеанса включен, а затем удаляется, когда тот же объект сеанса отключен, запись INSERT не появится в наборе изменений, даже если удаление произошло, когда сеанс был отключен. Или, если одно поле строки обновляется, пока сеанс отключен, а другое поле той же строки обновляется, пока сеанс включен, результирующий набор изменений будет содержать изменение UPDATE, которое обновляет оба поля.</target>
        </trans-unit>
        <trans-unit id="0c5e9130632720140f5680108f22eb0b1e949a18" translate="yes" xml:space="preserve">
          <source>When a string containing SQL statements is to be evaluated it is first sent to the tokenizer. The tokenizer breaks the SQL text into tokens and hands those tokens one by one to the parser. The tokenizer is hand-coded in the file</source>
          <target state="translated">Когда строка,содержащая SQL-операторы,должна быть обработана,она сначала отправляется в токенайзер.Токенайзер разбивает SQL-текст на токены и передает эти токены один за другим парсеру.Токенайзер вручную кодируется в файл.</target>
        </trans-unit>
        <trans-unit id="784cd84ee25201af9adae4be302f69e70ce7fa77" translate="yes" xml:space="preserve">
          <source>When a subquery is implemented as a co-routine, byte-code is generated to implement the subquery as if it were a standalone query, except instead of returning rows of results back to the application, the co-routine yields control back to the caller after each row is computed. The caller can then use that one computed row as part of its computation, then invoke the co-routine again when it is ready for the next row.</source>
          <target state="translated">Когда подзапрос реализован в виде корутины,для реализации подзапроса генерируется байтовый код,как если бы это был отдельный запрос,за исключением того,что вместо возврата строк результатов обратно в приложение,корутина возвращает управление вызывающему абоненту после вычисления каждой строки.Затем вызывающий абонент может использовать эту вычисленную строку как часть своего вычисления,а затем снова вызывать сорутийную маршрутизацию,когда она будет готова для следующей строки.</target>
        </trans-unit>
        <trans-unit id="de44a27c9eba79e888eaebdda88d807698edb9ba" translate="yes" xml:space="preserve">
          <source>When a subquery occurs in the FROM clause of a SELECT, the simplest behavior is to evaluate the subquery into a transient table, then run the outer SELECT against the transient table. But such a plan can be suboptimal since the transient table will not have any indices and the outer query (which is likely a join) will be forced to do a full table scan on the transient table.</source>
          <target state="translated">Когда подзапрос возникает в пункте FROM SELECT,простейшим поведением является оценка подзапроса в переходную таблицу,а затем выполнение внешнего SELECT против переходной таблицы.Но такой план может быть неоптимальным,так как переходная таблица не будет иметь никаких индексов,а внешний запрос (который,скорее всего,является соединением)будет вынужден выполнить полное сканирование таблицы переходных процессов.</target>
        </trans-unit>
        <trans-unit id="e127ffb4e1dc5538bc1d8c98212bc64075d04dc4" translate="yes" xml:space="preserve">
          <source>When a users query on the FTS table requires a column value other than docid, FTS attempts to read the requested value from the corresponding column of the row in the content table with a rowid value equal to the current FTS docid. Only the subset of content-table columns duplicated in the FTS/34 table declaration can be queried for - to retrieve values from any other columns the content table must be queried directly. Or, if such a row cannot be found in the content table, a NULL value is used instead. For example:</source>
          <target state="translated">Когда пользовательский запрос к таблице FTS требует значение столбца,отличное от docid,FTS пытается прочитать запрошенное значение из соответствующего столбца строки в таблице содержимого со значением строки,равным текущему докиду FTS.Только подмножество столбцов таблицы содержимого,дублированных в декларации таблицы FTS/34,может быть запрошено-для получения значений из любых других столбцов таблица содержимого должна быть запрошена напрямую.Или,если такая строка не может быть найдена в таблице содержимого,вместо нее используется NULL-значение.Например:</target>
        </trans-unit>
        <trans-unit id="923cfb28292cf33d9bcc64415e1180bd974cc8fa" translate="yes" xml:space="preserve">
          <source>When a writer is ready to commit its changes, it executes the following steps:</source>
          <target state="translated">Когда писатель готов к фиксации своих изменений,он выполняет следующие действия:</target>
        </trans-unit>
        <trans-unit id="90c74b5a55e525d529484d187152a575e9bdd449" translate="yes" xml:space="preserve">
          <source>When a writer wants to &lt;a href=&quot;fileformat2#walreset&quot;&gt;reset the WAL&lt;/a&gt;, it must ensure that there are no locks on WAL_READ_LOCK(N) for N&amp;gt;0 because such locks indicate that some other connection is still using the current WAL file and a &lt;a href=&quot;fileformat2#walreset&quot;&gt;WAL reset&lt;/a&gt; would delete content out from those other connections. It is ok for a &lt;a href=&quot;fileformat2#walreset&quot;&gt;WAL reset&lt;/a&gt; to occur if other connections are holding WAL_READ_LOCK(0) because by holding WAL_READ_LOCK(0), those other connections are promising not to use any content from the WAL.</source>
          <target state="translated">Когда писатель хочет &lt;a href=&quot;fileformat2#walreset&quot;&gt;сбросить WAL&lt;/a&gt; , он должен убедиться, что нет блокировок WAL_READ_LOCK (N) для N&amp;gt; 0, потому что такие блокировки указывают, что какое-то другое соединение все еще использует текущий файл &lt;a href=&quot;fileformat2#walreset&quot;&gt;WAL, и сброс WAL&lt;/a&gt; удалит содержимое из те другие связи. &lt;a href=&quot;fileformat2#walreset&quot;&gt;Сброс WAL&lt;/a&gt; возможен, если другие соединения удерживают WAL_READ_LOCK (0), потому что, удерживая WAL_READ_LOCK (0), эти другие соединения обещают не использовать какой-либо контент из WAL.</target>
        </trans-unit>
        <trans-unit id="7d5748b3589eba141bc319d180f2ba5724a213ca" translate="yes" xml:space="preserve">
          <source>When all of the recommended compile-time options above are used, the SQLite library will be approximately 3% smaller and use about 5% fewer CPU cycles. So these options do not make a huge difference. But in some design situations, every little bit helps.</source>
          <target state="translated">При использовании всех рекомендованных выше вариантов времени компиляции библиотека SQLite будет примерно на 3% меньше и будет использовать примерно на 5% меньше процессорных циклов.Таким образом,эти опции не имеют большой разницы.Но в некоторых дизайнерских ситуациях,каждая мелочь помогает.</target>
        </trans-unit>
        <trans-unit id="07429870ba57300bd363c85117e03fbff3fb9b62" translate="yes" xml:space="preserve">
          <source>When all processing is complete, &lt;b&gt;sqlite_step&lt;/b&gt; will return either SQLITE_DONE or SQLITE_ERROR. SQLITE_DONE indicates that the statement completed successfully and SQLITE_ERROR indicates that there was a run-time error. (The details of the error are obtained from &lt;b&gt;sqlite_finalize&lt;/b&gt;.) It is a misuse of the library to attempt to call &lt;b&gt;sqlite_step&lt;/b&gt; again after it has returned SQLITE_DONE or SQLITE_ERROR.</source>
          <target state="translated">Когда вся обработка завершена, &lt;b&gt;sqlite_step&lt;/b&gt; вернет либо SQLITE_DONE, либо SQLITE_ERROR. SQLITE_DONE указывает, что инструкция завершена успешно, а SQLITE_ERROR указывает, что произошла ошибка времени выполнения. (Подробная информация об ошибке получена из &lt;b&gt;sqlite_finalize&lt;/b&gt; .) Попытка повторно вызвать &lt;b&gt;sqlite_step&lt;/b&gt; после того, как она вернула SQLITE_DONE или SQLITE_ERROR, является неправильным использованием библиотеки .</target>
        </trans-unit>
        <trans-unit id="9464a70b807f00dabcb5c4da75acd44d0a619fea" translate="yes" xml:space="preserve">
          <source>When all the INSERTs are put in a transaction, SQLite no longer has to close and reopen the database or invalidate its cache between each statement. It also does not have to do any fsync()s until the very end. When unshackled in this way, SQLite is much faster than either PostgreSQL and MySQL.</source>
          <target state="translated">Когда все INSERT помещаются в транзакцию,SQLite больше не должен закрывать и открывать базу данных заново или аннулировать ее кэш между каждым оператором.Он также не должен делать никаких fsync()s до самого конца.При такой разблокировке SQLite намного быстрее,чем PostgreSQL и MySQL.</target>
        </trans-unit>
        <trans-unit id="83a11d4701cb9320d2bf4587af27d26604be7f83" translate="yes" xml:space="preserve">
          <source>When an FTS table accumulates 16 b-tree segments at the same level, the next INSERT into that table will cause all 16 segments to be merged into a single b-tree segment at the next higher level. The effect of these level merges is that most INSERTs into an FTS table are very fast and take minimal memory, but an occasional INSERT is slow and generates a large transaction because of the need to do merging. This results in &quot;spiky&quot; performance of INSERTs.</source>
          <target state="translated">Когда в таблице ФСТ накапливается 16 b-деревянных сегментов на одном уровне,следующий INSERT в эту таблицу приведет к тому,что все 16 сегментов будут объединены в один b-деревянный сегмент на следующем более высоком уровне.Эффект от слияния этих уровней заключается в том,что большинство INSERT в таблицу FTS очень быстрые и занимают минимальную память,но иногда INSERT медленный и генерирует большую транзакцию из-за необходимости делать слияние.Это приводит к &quot;шипиковой&quot; производительности INSERT.</target>
        </trans-unit>
        <trans-unit id="c3b65790b6c542323caaa50e227caf3d370e16fb" translate="yes" xml:space="preserve">
          <source>When an FTS5 table uses the custom tokenizer, the FTS5 core calls xCreate() once to create a tokenizer, then xTokenize() zero or more times to tokenize strings, then xDelete() to free any resources allocated by xCreate(). More specifically:</source>
          <target state="translated">Когда таблица FTS5 использует пользовательский токенайзер,ядро FTS5 один раз вызывает xCreate()для создания токенайзера,затем xTokenize()ноль или больше раз для токенирования строк,затем xDelete()для освобождения любых ресурсов,выделенных xCreate().Более конкретно:</target>
        </trans-unit>
        <trans-unit id="09202e860e734da0abbd632a5204a2fbedb299ae" translate="yes" xml:space="preserve">
          <source>When an FTS5 virtual table is created in a database, between 3 and 5 real tables are created in the database. These are known as &quot;&lt;a href=&quot;vtab#xshadowname&quot;&gt;shadow tables&lt;/a&gt;&quot;, and are used by the virtual table module to store persistent data. They should not be accessed directly by the user. Many other virtual table modules, including &lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt; and &lt;a href=&quot;rtree&quot;&gt;rtree&lt;/a&gt;, also create and use shadow tables.</source>
          <target state="translated">Когда виртуальная таблица FTS5 создается в базе данных, в базе данных создается от 3 до 5 реальных таблиц. Они известны как &amp;laquo; &lt;a href=&quot;vtab#xshadowname&quot;&gt;теневые таблицы&lt;/a&gt; &amp;raquo; и используются модулем виртуальных таблиц для хранения постоянных данных. Пользователь не должен обращаться к ним напрямую. Многие другие модули виртуальных таблиц, включая &lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt; и &lt;a href=&quot;rtree&quot;&gt;rtree&lt;/a&gt; , также создают и используют теневые таблицы.</target>
        </trans-unit>
        <trans-unit id="8a38c7dc316e7e37718537bdea61961f91a6e323" translate="yes" xml:space="preserve">
          <source>When an SQL program is submitted to SQLite, the first step is to split the source text into &quot;tokens&quot;. A token might be:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b898f19b28eed6509a35351ba88f244733f8458f" translate="yes" xml:space="preserve">
          <source>When an applicable constraint violation occurs, the ABORT resolution algorithm aborts the current SQL statement with an SQLITE_CONSTRAINT error and backs out any changes made by the current SQL statement; but changes caused by prior SQL statements within the same transaction are preserved and the transaction remains active. This is the default behavior and the behavior specified by the SQL standard.</source>
          <target state="translated">Когда происходит соответствующее нарушение ограничения,алгоритм разрешения ABORT прерывает текущий SQL-оператор с ошибкой SQLITE_CONSTRAINT и отменяет все изменения,сделанные текущим SQL-оператором;но изменения,вызванные предыдущими SQL-операторами в рамках той же самой транзакции,сохраняются,и транзакция остается активной.Это поведение по умолчанию и поведение,определяемое стандартом SQL.</target>
        </trans-unit>
        <trans-unit id="58bad3c331711aff15946bd280d303d43eef796f" translate="yes" xml:space="preserve">
          <source>When an applicable constraint violation occurs, the FAIL resolution algorithm aborts the current SQL statement with an SQLITE_CONSTRAINT error. But the FAIL resolution does not back out prior changes of the SQL statement that failed nor does it end the transaction. For example, if an UPDATE statement encountered a constraint violation on the 100th row that it attempts to update, then the first 99 row changes are preserved but changes to rows 100 and beyond never occur.</source>
          <target state="translated">Когда происходит соответствующее нарушение ограничения,алгоритм разрешения FAIL прерывает текущий SQL-оператор с ошибкой SQLITE_CONSTRAINT.Но разрешение FAIL не отбрасывает предыдущие изменения SQL-оператора,которые не удалось выполнить,и не завершает транзакцию.Например,если оператор UPDATE столкнулся с нарушением ограничения на 100-й строке,которую он пытается обновить,то первые 99 изменений строки сохраняются,но изменения в 100-й строке и выше никогда не происходят.</target>
        </trans-unit>
        <trans-unit id="1b4aa81c65115bc42996b729bd361c5c8fafeff0" translate="yes" xml:space="preserve">
          <source>When an applicable constraint violation occurs, the IGNORE resolution algorithm skips the one row that contains the constraint violation and continues processing subsequent rows of the SQL statement as if nothing went wrong. Other rows before and after the row that contained the constraint violation are inserted or updated normally. No error is returned for uniqueness, NOT NULL, and UNIQUE constraint errors when the IGNORE conflict resolution algorithm is used. However, the IGNORE conflict resolution algorithm works like ABORT for &lt;a href=&quot;foreignkeys&quot;&gt;foreign key constraint&lt;/a&gt; errors.</source>
          <target state="translated">Когда происходит применимое нарушение ограничения, алгоритм разрешения IGNORE пропускает одну строку, которая содержит нарушение ограничения, и продолжает обработку последующих строк оператора SQL, как если бы ничего не произошло. Другие строки до и после строки, содержащей нарушение ограничения, вставляются или обновляются обычным образом. При использовании алгоритма разрешения конфликтов IGNORE ошибка не возвращается для ошибок ограничения уникальности, NOT NULL и UNIQUE. Однако алгоритм разрешения конфликтов IGNORE работает как ABORT для ошибок &lt;a href=&quot;foreignkeys&quot;&gt;ограничения внешнего ключа&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a5ad08c0ccf1a58d1c588bdc448e26465adfe8be" translate="yes" xml:space="preserve">
          <source>When an applicable constraint violation occurs, the ROLLBACK resolution algorithm aborts the current SQL statement with an SQLITE_CONSTRAINT error and rolls back the current transaction. If no transaction is active (other than the implied transaction that is created on every command) then the ROLLBACK resolution algorithm works the same as the ABORT algorithm.</source>
          <target state="translated">Когда происходит соответствующее нарушение ограничения,алгоритм разрешения ROLLBACK прерывает текущий SQL-оператор с ошибкой SQLITE_CONSTRAINT и откатывает текущую транзакцию.Если ни одна транзакция не активна (кроме подразумеваемой транзакции,которая создается по каждой команде),то алгоритм разрешения ROLLBACK работает так же,как и алгоритм ABORT.</target>
        </trans-unit>
        <trans-unit id="df9a570011a02f30ad10c7c02dfbae7f79c1d8bc" translate="yes" xml:space="preserve">
          <source>When an attempt is made to read the 100 byte</source>
          <target state="translated">При попытке прочитать 100-байт</target>
        </trans-unit>
        <trans-unit id="e571fd87d73f16df54e68558314d212f85e9756b" translate="yes" xml:space="preserve">
          <source>When an error occurs, &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; will return one of the detailed &lt;a href=&quot;rescode&quot;&gt;error codes&lt;/a&gt; or &lt;a href=&quot;rescode#extrc&quot;&gt;extended error codes&lt;/a&gt;. The legacy behavior was that &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; would only return a generic &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt; result code and the application would have to make a second call to &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset()&lt;/a&gt; in order to find the underlying cause of the problem. With the &quot;v2&quot; prepare interfaces, the underlying reason for the error is returned immediately.</source>
          <target state="translated">При возникновении ошибки &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step ()&lt;/a&gt; вернет один из подробных &lt;a href=&quot;rescode&quot;&gt;кодов ошибок&lt;/a&gt; или &lt;a href=&quot;rescode#extrc&quot;&gt;расширенных кодов ошибок&lt;/a&gt; . Унаследованное поведение заключалось в том, что &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step ()&lt;/a&gt; возвращал только общий &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;результирующий&lt;/a&gt; код SQLITE_ERROR, и приложению пришлось бы сделать второй вызов &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset ()&lt;/a&gt; , чтобы найти основную причину проблемы. С интерфейсами подготовки &quot;v2&quot; основная причина ошибки возвращается немедленно.</target>
        </trans-unit>
        <trans-unit id="ccab92f3619cb54ee4858ee94848a4ee81189c29" translate="yes" xml:space="preserve">
          <source>When an error occurs, &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; will return one of the detailed &lt;a href=&quot;../rescode&quot;&gt;error codes&lt;/a&gt; or &lt;a href=&quot;../rescode#extrc&quot;&gt;extended error codes&lt;/a&gt;. The legacy behavior was that &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; would only return a generic &lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt; result code and the application would have to make a second call to &lt;a href=&quot;reset&quot;&gt;sqlite3_reset()&lt;/a&gt; in order to find the underlying cause of the problem. With the &quot;v2&quot; prepare interfaces, the underlying reason for the error is returned immediately.</source>
          <target state="translated">При возникновении ошибки &lt;a href=&quot;step&quot;&gt;sqlite3_step ()&lt;/a&gt; вернет один из подробных &lt;a href=&quot;../rescode&quot;&gt;кодов ошибок&lt;/a&gt; или &lt;a href=&quot;../rescode#extrc&quot;&gt;расширенных кодов ошибок&lt;/a&gt; . Унаследованное поведение заключалось в том, что &lt;a href=&quot;step&quot;&gt;sqlite3_step ()&lt;/a&gt; возвращал только общий &lt;a href=&quot;../rescode#error&quot;&gt;результирующий&lt;/a&gt; код SQLITE_ERROR, и приложению пришлось бы сделать второй вызов &lt;a href=&quot;reset&quot;&gt;sqlite3_reset ()&lt;/a&gt; , чтобы найти основную причину проблемы. С интерфейсами подготовки &quot;v2&quot; основная причина ошибки возвращается немедленно.</target>
        </trans-unit>
        <trans-unit id="5d56e138a3f9cc682aa13f997335180c0fb3034f" translate="yes" xml:space="preserve">
          <source>When an expression is a simple reference to a column of a real table (not a &lt;a href=&quot;lang_createview&quot;&gt;VIEW&lt;/a&gt; or subquery) then the expression has the same affinity as the table column.</source>
          <target state="translated">Если выражение представляет собой простую ссылку на столбец реальной таблицы (не &lt;a href=&quot;lang_createview&quot;&gt;VIEW&lt;/a&gt; или подзапрос), тогда выражение имеет такое же сходство, как и столбец таблицы.</target>
        </trans-unit>
        <trans-unit id="6e0bc34d56cd507e6524dea6d88364c2053501fb" translate="yes" xml:space="preserve">
          <source>When an in-memory database is named in this way, it will only share its cache with another connection that uses exactly the same name.</source>
          <target state="translated">Когда база данных in-memory названа таким образом,она будет делиться своим кэшем только с другим соединением,которое использует точно такое же имя.</target>
        </trans-unit>
        <trans-unit id="a4bc24ec2391f7a4a80ebd40d7eacec7ec5836a6" translate="yes" xml:space="preserve">
          <source>When an index contains all of the data needed for a query and when the original table never needs to be consulted, we call that index a &quot;covering index&quot;.</source>
          <target state="translated">Когда индекс содержит все данные,необходимые для запроса,и когда исходная таблица никогда не нуждается в консультациях,мы называем этот индекс &quot;охватывающим индексом&quot;.</target>
        </trans-unit>
        <trans-unit id="82ebd13a345482eaf43922980ab28662ac5f3021" translate="yes" xml:space="preserve">
          <source>When an unlock-notify callback is registered, the application provides a single void* pointer that is passed to the callback when it is invoked. However, the signature of the callback function allows SQLite to pass it an array of void* context pointers. The first argument passed to an unlock-notify callback is a pointer to an array of void* pointers, and the second is the number of entries in the array.</source>
          <target state="translated">При регистрации обратного вызова с уведомлением о разблокировке приложение предоставляет единственный указатель void*,который передается обратному вызову при его вызове.Однако сигнатура функции обратного вызова позволяет SQLite передать ему массив указателей на контекст void*.Первый аргумент,передаваемый для обратного вызова unlock-уведомления-указатель на массив указателей void*,а второй-количество записей в массиве.</target>
        </trans-unit>
        <trans-unit id="52b75d8996a29266548750270878024301ed32e8" translate="yes" xml:space="preserve">
          <source>When attempting to open a file, the SQLITE_NOTADB error indicates that the file being opened does not appear to be an SQLite database file.</source>
          <target state="translated">При попытке открыть файл ошибка SQLITE_NOTADB указывает на то,что открываемый файл не является файлом базы данных SQLite.</target>
        </trans-unit>
        <trans-unit id="9105d0e8a7ab7b349bd2fbe878c8275b8882d52a" translate="yes" xml:space="preserve">
          <source>When both the SQLite core and the &lt;a href=&quot;cli&quot;&gt;Command Line Interface&lt;/a&gt; (CLI) are both compiled with this option, then the CLI provides an extra command named &quot;.iotrace&quot; that provides a low-level log of I/O activity. This option is experimental and may be discontinued in a future release.</source>
          <target state="translated">Когда и ядро ​​SQLite, и &lt;a href=&quot;cli&quot;&gt;интерфейс командной строки&lt;/a&gt; (CLI) скомпилированы с этой опцией, тогда CLI предоставляет дополнительную команду с именем &amp;laquo;.iotrace&amp;raquo;, которая обеспечивает низкоуровневый журнал операций ввода-вывода. Этот вариант является экспериментальным и может быть прекращен в будущем выпуске.</target>
        </trans-unit>
        <trans-unit id="36f9015046bd06c8d94d98831683d6a650fd53ca" translate="yes" xml:space="preserve">
          <source>When building the &lt;a href=&quot;cli&quot;&gt;CLI&lt;/a&gt;, it is helpful, but not required, to have the following third-party libraries on hand:</source>
          <target state="translated">При создании &lt;a href=&quot;cli&quot;&gt;интерфейса командной строки&lt;/a&gt; полезно, но не обязательно, иметь под рукой следующие сторонние библиотеки:</target>
        </trans-unit>
        <trans-unit id="ba9eeb759b581addc9af410a4bf9f2616522ac5b" translate="yes" xml:space="preserve">
          <source>When building with MSVC on Windows systems, one can put the zlib source code in the compat/zlib subdirectory of the source tree and then add the USE_ZLIB=1 option to the nmake command to cause the The Makefile.msc to automatically build and use an appropriate zlib library implementation.</source>
          <target state="translated">При сборке с помощью MSVC на Windows-системах можно поместить исходный код zlib в подкаталог compat/zlib дерева исходных текстов,а затем добавить опцию USE_ZLIB=1 в команду nmake,чтобы заставить Makefile.msc автоматически собрать и использовать соответствующую реализацию библиотеки zlib.</target>
        </trans-unit>
        <trans-unit id="e30f7cd9c75ce2c6c161c9108a391a6b6c55986e" translate="yes" xml:space="preserve">
          <source>When casting a BLOB value to INTEGER, the value is first converted to TEXT.</source>
          <target state="translated">При литье BLOB-значения в INTEGER,значение сначала конвертируется в TEXT.</target>
        </trans-unit>
        <trans-unit id="5c0c597294629f9542feb4df0871368a01531b6a" translate="yes" xml:space="preserve">
          <source>When casting a BLOB value to a REAL, the value is first converted to TEXT.</source>
          <target state="translated">При литье BLOB-значения в REAL,значение сначала конвертируется в TEXT.</target>
        </trans-unit>
        <trans-unit id="5067d93cc1cb86aa6af9bcf672584d0b1585ff55" translate="yes" xml:space="preserve">
          <source>When casting a TEXT value to INTEGER, the longest possible prefix of the value that can be interpreted as an integer number is extracted from the TEXT value and the remainder ignored. Any leading spaces in the TEXT value when converting from TEXT to INTEGER are ignored. If there is no prefix that can be interpreted as an integer number, the result of the conversion is 0. If the prefix integer is greater than +9223372036854775807 then the result of the cast is exactly +9223372036854775807. Similarly, if the prefix integer is less than -9223372036854775808 then the result of the cast is exactly -9223372036854775808.</source>
          <target state="translated">При приведении значения TEXT к INTEGER из значения TEXT извлекается самый длинный префикс значения,который может быть интерпретирован как целое число,а остаток игнорируется.Любые опережающие пробелы в значении TEXT при преобразовании из TEXT в INTEGER игнорируются.Если нет префикса,который может быть интерпретирован как целое число,то результат преобразования равен 0.Если префиксное целое число больше +9223372036854775807,то результат преобразования точно равен +9223372036854775807.Аналогично,если целое префиксное число меньше чем -9223372036854775808,то результат кастинга будет точно -9223372036854775808.</target>
        </trans-unit>
        <trans-unit id="65da0fa3bb91d9ed81f980bbc2df26063662f53c" translate="yes" xml:space="preserve">
          <source>When casting a TEXT value to REAL, the longest possible prefix of the value that can be interpreted as a real number is extracted from the TEXT value and the remainder ignored. Any leading spaces in the TEXT value are ignored when converging from TEXT to REAL. If there is no prefix that can be interpreted as a real number, the result of the conversion is 0.0.</source>
          <target state="translated">При приведении значения TEXT к REAL из значения TEXT извлекается самый длинный префикс значения,который может быть интерпретирован как вещественное число,а остаток игнорируется.Любые опережающие пробелы в значении TEXT игнорируются при конвергенции из TEXT в REAL.Если префикс,который может быть интерпретирован как вещественное число,отсутствует,то результат конвертации равен 0.0.</target>
        </trans-unit>
        <trans-unit id="46e82821742f6cd2f96bd6126debacd8be0bdcfb" translate="yes" xml:space="preserve">
          <source>When casting to INTEGER, if the text looks like a floating point value with an exponent, the exponent will be ignored because it is no part of the integer prefix. For example, &quot;(CAST '123e+5' AS INTEGER)&quot; results in 123, not in 12300000.</source>
          <target state="translated">При приведении к INTEGER,если текст выглядит как значение с плавающей точкой с экспонентом,то экспонент будет проигнорирован,так как он не является частью целочисленного префикса.Например,&quot;(CAST '123e+5' AS INTEGER)&quot; приводит к 123,а не к 12300000.</target>
        </trans-unit>
        <trans-unit id="39d5e03e61b6bf8d9e7be24acbf923224eccdb8e" translate="yes" xml:space="preserve">
          <source>When checking for the WHERE-clause push-down optimization, verify that all terms of the compound inner SELECT are non-aggregate, not just the last term. Fix for ticket &lt;a href=&quot;https://www.sqlite.org/src/info/f7f8c97e97597&quot;&gt;f7f8c97e97597&lt;/a&gt;.</source>
          <target state="translated">При проверке оптимизации с расширением предложения WHERE убедитесь, что все члены составного внутреннего SELECT не агрегированы, а не только последний член. Исправление для билета &lt;a href=&quot;https://www.sqlite.org/src/info/f7f8c97e97597&quot;&gt;f7f8c97e97597&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="95988d2f9a83f35536e66d62cf26515907b72996" translate="yes" xml:space="preserve">
          <source>When compared with SQLite's built-in VACUUM command, RBU Vacuum has the following limitations:</source>
          <target state="translated">По сравнению со встроенной в SQLite командой VACUUM,RBU Vacuum имеет следующие ограничения:</target>
        </trans-unit>
        <trans-unit id="71ec8021f2a78c2f5787e61e104c092e2cf0b2cc" translate="yes" xml:space="preserve">
          <source>When comparing a base expression against a WHEN expression, the same collating sequence, affinity, and NULL-handling rules apply as if the base expression and WHEN expression are respectively the left- and right-hand operands of an</source>
          <target state="translated">При сравнении базового выражения с выражением &quot;КОГДА&quot; применяются одни и те же правила коллидирования последовательности,сродства и NULL-обработки,как если бы базовое выражение и выражение &quot;КОГДА&quot; были соответственно левым и правым операндами операнда</target>
        </trans-unit>
        <trans-unit id="8a8e8bf765d052cbbdbda4e8360051200aec0343" translate="yes" xml:space="preserve">
          <source>When comparing text values, the &lt;a href=&quot;datatype3#collation&quot;&gt;collating sequence&lt;/a&gt; associated with the parent key column is always used.</source>
          <target state="translated">При сравнении текстовых значений всегда используется &lt;a href=&quot;datatype3#collation&quot;&gt;последовательность сортировки,&lt;/a&gt; связанная с родительским ключевым столбцом.</target>
        </trans-unit>
        <trans-unit id="8bd6464f68b9918a029c67f18300aa6bddf2bf88" translate="yes" xml:space="preserve">
          <source>When comparing values, if the parent key column has an &lt;a href=&quot;datatype3#affinity&quot;&gt;affinity&lt;/a&gt;, then that affinity is applied to the child key value before the comparison is performed.</source>
          <target state="translated">При сравнении значений, если столбец родительского ключа имеет &lt;a href=&quot;datatype3#affinity&quot;&gt;сходство&lt;/a&gt; , то это соответствие применяется к значению дочернего ключа перед выполнением сравнения.</target>
        </trans-unit>
        <trans-unit id="8a8c1f258ce77d3b0b1a04487b470e53840cc8d0" translate="yes" xml:space="preserve">
          <source>When compiled with &lt;a href=&quot;compile#debug&quot;&gt;SQLITE_DEBUG&lt;/a&gt;, SQLite includes routines that will print out various internal parse tree structures as ASCII-art graphs. This can be very useful in a debugging in order to understand the variables that SQLite is working with.</source>
          <target state="translated">При компиляции с &lt;a href=&quot;compile#debug&quot;&gt;SQLITE_DEBUG&lt;/a&gt; SQLite включает в себя процедуры, которые будут распечатывать различные внутренние структуры дерева синтаксического анализа в виде графов в стиле ASCII. Это может быть очень полезно при отладке, чтобы понять переменные, с которыми работает SQLite.</target>
        </trans-unit>
        <trans-unit id="b440573f54c675131665957f45fa09226296363a" translate="yes" xml:space="preserve">
          <source>When compiling with this option, it will normally be necessary to add a linker option to include the zlib library in the build. Normal this option is &quot;-lz&quot; but might be different on different systems.</source>
          <target state="translated">При компиляции с этой опцией обычно будет необходимо добавить опцию компоновщика для включения библиотеки zlib в сборку.Обычно эта опция &quot;-lz&quot;,но на разных системах может быть разной.</target>
        </trans-unit>
        <trans-unit id="c300eac9b0ba20d1c5f0548bea68bd1985408338" translate="yes" xml:space="preserve">
          <source>When computing the cost of the &lt;a href=&quot;optoverview#skipscan&quot;&gt;skip-scan optimization&lt;/a&gt;, take into account the fact that multiple seeks are required.</source>
          <target state="translated">При расчете стоимости &lt;a href=&quot;optoverview#skipscan&quot;&gt;оптимизации пропуска сканирования учитывайте&lt;/a&gt; тот факт, что требуется несколько поисков.</target>
        </trans-unit>
        <trans-unit id="0f31671e641184fdff6ce2920c28181e45773893" translate="yes" xml:space="preserve">
          <source>When confronted with OR-connected terms in a WHERE clause, SQLite examines each OR term separately and tries to use an index to find the rowids associated with each term. It then takes the union of the resulting rowid sets to find the end result. The following figure illustrates this process:</source>
          <target state="translated">При столкновении с терминами,связанными с символом &quot;ИЛИ&quot; в выражении &quot;ГДЕ&quot;,SQLite рассматривает каждый термин &quot;ИЛИ&quot; отдельно и пытается использовать индекс для поиска строк,связанных с каждым термином.Затем он берет объединение полученных наборов шрифтов,чтобы найти конечный результат.Следующий рисунок иллюстрирует этот процесс:</target>
        </trans-unit>
        <trans-unit id="80acebb0e2681ada8eda5ed06d14fb5c6e654492" translate="yes" xml:space="preserve">
          <source>When content is deleted from an SQLite database, pages that are no longer used are added to a free list and are reused to hold content added by subsequent inserts. A bug in SQLite that was present in version 3.6.16 through 3.7.2 might cause pages to go missing out of the free list when &lt;a href=&quot;pragma#pragma_incremental_vacuum&quot;&gt;incremental_vacuum&lt;/a&gt; was used. This would not cause data loss. But it would result in the database file being larger than necessary. And it would cause the &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;integrity_check pragma&lt;/a&gt; to report pages missing from the free list.</source>
          <target state="translated">Когда контент удаляется из базы данных SQLite, страницы, которые больше не используются, добавляются в свободный список и повторно используются для хранения контента, добавленного последующими вставками. Ошибка в SQLite, которая присутствовала в версиях с 3.6.16 по 3.7.2, могла приводить к пропаданию страниц из списка свободных при использовании &lt;a href=&quot;pragma#pragma_incremental_vacuum&quot;&gt;incremental_vacuum&lt;/a&gt; . Это не приведет к потере данных. Но это приведет к тому, что файл базы данных будет больше, чем необходимо. И это приведет к тому, что &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;прагма Integrity_check&lt;/a&gt; сообщит о страницах, отсутствующих в свободном списке.</target>
        </trans-unit>
        <trans-unit id="ec68acb5aee4ac70ffc0e427ed46e7978d7d9aaa" translate="yes" xml:space="preserve">
          <source>When content is deleted from an SQLite database, the content is not usually erased but rather the space used to hold the content is marked as being available for reuse. This can allow deleted content to be recovered by a hacker or by forensic analysis. Running VACUUM will clean the database of all traces of deleted content, thus preventing an adversary from recovering deleted content. Using VACUUM in this way is an alternative to setting &lt;a href=&quot;pragma#pragma_secure_delete&quot;&gt;PRAGMA secure_delete=ON&lt;/a&gt;.</source>
          <target state="translated">Когда контент удаляется из базы данных SQLite, он обычно не стирается, а пространство, используемое для хранения контента, помечается как доступное для повторного использования. Это может позволить восстановить удаленный контент хакером или с помощью судебно-медицинской экспертизы. Запуск VACUUM очистит базу данных от всех следов удаленного контента, тем самым не дав злоумышленнику возможности восстановить удаленный контент. Использование VACUUM таким образом является альтернативой установке &lt;a href=&quot;pragma#pragma_secure_delete&quot;&gt;PRAGMA secure_delete = ON&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3ef3b5e9abd6cdd13cd5d387ea4a3c929af66232" translate="yes" xml:space="preserve">
          <source>When converting BLOB to TEXT, use the text encoding of the main database. Ticket #2349</source>
          <target state="translated">При преобразовании BLOB в TEXT используйте текстовую кодировку основной БД.Билет № 2349</target>
        </trans-unit>
        <trans-unit id="114a59b6e420f398fe8acae2dbbd380f2c338748" translate="yes" xml:space="preserve">
          <source>When creating a new database file during &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; on unix systems, SQLite will try to set the permissions of the new database file to match the existing file &quot;</source>
          <target state="translated">При создании нового файла базы данных во время &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2 ()&lt;/a&gt; в системах unix SQLite попытается установить разрешения для нового файла базы данных в соответствии с существующим файлом &quot;</target>
        </trans-unit>
        <trans-unit id="bb5190d7ef1fca8d42df7043f112c5cb64984b8e" translate="yes" xml:space="preserve">
          <source>When creating new user-defined SQL functions and collating sequences, each function or collating sequence can specify if it works with UTF-8, UTF-16be, or UTF-16le. Separate implementations can be registered for each encoding. If an SQL function or collating sequence is required but a version for the current text encoding is not available, then the text is automatically converted. As before, this conversion takes computation time, so programmers are advised to pick a single encoding and stick with it in order to minimize the amount of unnecessary format juggling.</source>
          <target state="translated">При создании новых пользовательских SQL-функций и коллекционировании последовательностей каждая функция или коллекционирующая последовательность может указать,работает ли она с UTF-8,UTF-16be или UTF-16le.Для каждой кодировки могут быть зарегистрированы отдельные реализации.Если требуется SQL-функция или коллекционная последовательность,но версия для текущей текстовой кодировки недоступна,то текст автоматически преобразуется.Как и раньше,такое преобразование занимает время вычислений,поэтому программистам рекомендуется выбрать одну кодировку и придерживаться ее,чтобы свести к минимуму количество ненужного жонглирования форматом.</target>
        </trans-unit>
        <trans-unit id="6a02367c161ead06f619b074aecd9b89d2c0cc40" translate="yes" xml:space="preserve">
          <source>When data is appended to the end of the rollback journal, SQLite normally makes the pessimistic assumption that the file is first extended with invalid &quot;garbage&quot; data and that afterwards the correct data replaces the garbage. In other words, SQLite assumes that the file size is increased first and then afterwards the content is written into the file. If a power failure occurs after the file size has been increased but before the file content has been written, the rollback journal can be left containing garbage data. If after power is restored, another SQLite process sees the rollback journal containing the garbage data and tries to roll it back into the original database file, it might copy some of the garbage into the database file and thus corrupt the database file.</source>
          <target state="translated">Когда данные добавляются в конец журнала отката,SQLite обычно делает пессимистическое предположение,что файл сначала расширяется недействительными &quot;мусорными&quot; данными,а затем правильные данные заменяют мусор.Другими словами,SQLite предполагает,что размер файла сначала увеличивается,а затем содержимое записывается в файл.Если после увеличения размера файла,но до записи содержимого в него,происходит сбой питания,то журнал отката можно оставить с мусорными данными.Если после восстановления питания другой процесс SQLite увидит журнал отката,содержащий мусорные данные,и попытается откатить его обратно в исходный файл БД,он может скопировать часть мусора в файл БД и тем самым испортить файл БД.</target>
        </trans-unit>
        <trans-unit id="6e1728b3880c31067245341a957998cb64468579" translate="yes" xml:space="preserve">
          <source>When database corruption is detected, an SQLITE_CORRUPT error logger callback is invoked. As with I/O errors, the error message text contains the line number in the original source code where the error was first detected.</source>
          <target state="translated">При обнаружении повреждения базы данных вызывается обратный вызов логгера ошибок SQLITE_CORRUPT.Как и в случае с ошибками ввода/вывода,текст сообщения об ошибке содержит номер строки в исходном коде,где ошибка была впервые обнаружена.</target>
        </trans-unit>
        <trans-unit id="5ec353b1e7bb6a3ecdd47f7ae7473e801761839f" translate="yes" xml:space="preserve">
          <source>When dates are stored this way, row value comparisons provide a convenient way to compare dates:</source>
          <target state="translated">Когда даты хранятся таким образом,сравнение значений строк обеспечивает удобный способ сравнения дат:</target>
        </trans-unit>
        <trans-unit id="db590fa9b88387884339466c341a1e3e6a784a7d" translate="yes" xml:space="preserve">
          <source>When debugging the &lt;a href=&quot;opcode&quot;&gt;bytecode&lt;/a&gt; generator, it is often useful to know where a particular opcode is being generated. To find this easily, run the script in a debugger. Set a breakpoint on the &quot;test_addoptrace&quot; routine. Then run the &quot;PRAGMA vdbe_addoptrace=ON;&quot; followed by the SQL statement in question. Each opcode will be displayed as it is appended to the VDBE program, and the breakpoint will fire immediately thereafter. Step until reaching the opcode then look backwards in the stack to see where and how it was generated.</source>
          <target state="translated">При отладке генератора &lt;a href=&quot;opcode&quot;&gt;байт-кода&lt;/a&gt; часто бывает полезно знать, где генерируется конкретный код операции. Чтобы легко это найти, запустите сценарий в отладчике. Установите точку останова на подпрограмме test_addoptrace. Затем запустите &quot;PRAGMA vdbe_addoptrace = ON;&quot; за которым следует рассматриваемый оператор SQL. Каждый код операции будет отображаться так, как он добавлен к программе VDBE, и точка останова сработает сразу после этого. Шагайте до достижения кода операции, затем посмотрите назад в стеке, чтобы увидеть, где и как он был сгенерирован.</target>
        </trans-unit>
        <trans-unit id="d36e8b2fe095f3dcf16b488533e2eea81261ce34" translate="yes" xml:space="preserve">
          <source>When deciding between two plans with the same estimated cost, bias the selection toward the one that does not use the sorter.</source>
          <target state="translated">При выборе между двумя планами с одинаковой оценочной стоимостью,смещение выбора в сторону того,который не использует сортировщик.</target>
        </trans-unit>
        <trans-unit id="bf93f718a16c4baf24f9f9cd0779c38e6d7918df" translate="yes" xml:space="preserve">
          <source>When defined, this C-preprocessor macro activates extra code that attempts to detect misuse of the SQLite API, such as passing in NULL pointers to required parameters or using objects after they have been destroyed.</source>
          <target state="translated">При задании этого макроса C-препроцессор активирует дополнительный код,который пытается обнаружить злоупотребление SQLite API,например,передачу в NULL указателей на требуемые параметры или использование объектов после их уничтожения.</target>
        </trans-unit>
        <trans-unit id="1548f1f2e91ad07dfb5ee921f08a77e6a373fb3e" translate="yes" xml:space="preserve">
          <source>When defining a TEMP trigger on a non-TEMP table, it is important to specify the database holding the non-TEMP table. For example, in the following statement, it is important to say &quot;main.tab1&quot; instead of just &quot;tab1&quot;:</source>
          <target state="translated">При определении триггера TEMP на таблице,отличной от TEMP,важно указать БД,содержащую таблицу,отличную от TEMP.Например,в следующем утверждении важно сказать &quot;main.tab1&quot;,а не просто &quot;tab1&quot;:</target>
        </trans-unit>
        <trans-unit id="08cdbd4cf4d969a92be0666ae36716558d90ece0" translate="yes" xml:space="preserve">
          <source>When doing DELETE and UPDATE, the library used to write the record numbers of records to be deleted or updated into a temporary file. This is changed so that the record numbers are held in memory.</source>
          <target state="translated">При выполнении DELETE и UPDATE библиотека записывает во временный файл номера записей,которые необходимо удалить или обновить.Это изменяется таким образом,что номера записей хранятся в памяти.</target>
        </trans-unit>
        <trans-unit id="3cda947ba0235d70ea9379c938638b6e342ed7b3" translate="yes" xml:space="preserve">
          <source>When doing an indexed lookup of a row, the usual procedure is to do a binary search on the index to find the index entry, then extract the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; from the index and use that &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; to do a binary search on the original table. Thus a typical indexed lookup involves two binary searches. If, however, all columns that were to be fetched from the table are already available in the index itself, SQLite will use the values contained in the index and will never look up the original table row. This saves one binary search for each row and can make many queries run twice as fast.</source>
          <target state="translated">При индексированном поиске строки обычная процедура состоит в том, чтобы выполнить двоичный поиск по индексу, чтобы найти запись индекса, затем извлечь &lt;a href=&quot;lang_createtable#rowid&quot;&gt;идентификатор строки&lt;/a&gt; из индекса и использовать этот &lt;a href=&quot;lang_createtable#rowid&quot;&gt;идентификатор строки&lt;/a&gt; для выполнения двоичного поиска в исходной таблице. Таким образом, типичный индексированный поиск включает два бинарных поиска. Если, однако, все столбцы, которые должны быть извлечены из таблицы, уже доступны в самом индексе, SQLite будет использовать значения, содержащиеся в индексе, и никогда не будет искать исходную строку таблицы. Это позволяет сэкономить один бинарный поиск для каждой строки и может ускорить выполнение многих запросов в два раза.</target>
        </trans-unit>
        <trans-unit id="9904bf6d42a19655ef67955a4a94073b0eae876b" translate="yes" xml:space="preserve">
          <source>When doing an insert without a rowid (argc&amp;gt;1, argv[1] is an SQL NULL), on a virtual table that uses ROWID (but not on a &lt;a href=&quot;vtab#worid&quot;&gt;WITHOUT ROWID virtual table&lt;/a&gt;), the implementation must set *pRowid to the rowid of the newly inserted row; this will become the value returned by the &lt;a href=&quot;c3ref/last_insert_rowid&quot;&gt;sqlite3_last_insert_rowid()&lt;/a&gt; function. Setting this value in all the other cases is a harmless no-op; the SQLite engine ignores the *pRowid return value if argc==1 or argv[1] is not an SQL NULL.</source>
          <target state="translated">При выполнении вставки без идентификатора строки (argc&amp;gt; 1, argv [1] - это SQL NULL) в виртуальной таблице, которая использует ROWID (но не в &lt;a href=&quot;vtab#worid&quot;&gt;виртуальной таблице БЕЗ ROWID&lt;/a&gt; ), реализация должна установить * pRowid равным идентификатору строки вновь вставленная строка; это станет значением, возвращаемым функцией &lt;a href=&quot;c3ref/last_insert_rowid&quot;&gt;sqlite3_last_insert_rowid ()&lt;/a&gt; . Установка этого значения во всех остальных случаях безобидна; механизм SQLite игнорирует возвращаемое значение * pRowid, если argc == 1 или argv [1] не является SQL NULL.</target>
        </trans-unit>
        <trans-unit id="1c8dd9af0591131c94abbb3f55e35333a90c2bb5" translate="yes" xml:space="preserve">
          <source>When enabled, this PRAGMA causes many &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statements without an ORDER BY clause to emit their results in the reverse order from what they normally would. This can help debug applications that are making invalid assumptions about the result order. The reverse_unordered_selects pragma works for most SELECT statements, however the query planner may sometimes choose an algorithm that is not easily reversed, in which case the output will appear in the same order regardless of the reverse_unordered_selects setting.</source>
          <target state="translated">При включении эта PRAGMA заставляет многие &lt;a href=&quot;lang_select&quot;&gt;операторы SELECT&lt;/a&gt; без предложения ORDER BY выдавать свои результаты в порядке, обратном тому, что они обычно делали бы. Это может помочь отладить приложения, которые делают неверные предположения о порядке результатов. Прагма reverse_unordered_selects работает для большинства операторов SELECT, однако планировщик запросов может иногда выбирать алгоритм, который нелегко изменить, и в этом случае выходные данные будут отображаться в том же порядке, независимо от параметра reverse_unordered_selects.</target>
        </trans-unit>
        <trans-unit id="17ef63392395a1e6663e404dcadfba942c11b299" translate="yes" xml:space="preserve">
          <source>When faced with a choice of two or more indices, SQLite tries to estimate the total amount of work needed to perform the query using each option. It then selects the option that gives the least estimated work.</source>
          <target state="translated">Столкнувшись с выбором двух и более индексов,SQLite пытается оценить общий объем работ,необходимых для выполнения запроса,используя каждый из вариантов.Затем он выбирает тот вариант,который дает наименьшую оценку работы.</target>
        </trans-unit>
        <trans-unit id="393ffe20ba1bb6822b853fbdd74f36cd0864d018" translate="yes" xml:space="preserve">
          <source>When files opened with the asynchronous VFS are read from (using the vfs xRead() method), the data is read from the file on disk and the write-queue, so that from the point of view of the vfs reader the xWrite() appears to have already completed.</source>
          <target state="translated">При считывании файлов,открытых с помощью асинхронной VFS (с помощью метода vfs xRead()),данные считываются из файла на диске и записываются на диск,так что с точки зрения читателя vfs xWrite()кажется уже завершенной.</target>
        </trans-unit>
        <trans-unit id="c7d3d8950c12709e47c72758e22cf2a9146592d1" translate="yes" xml:space="preserve">
          <source>When generating individual loops for each ORed term of an OR scan, move any constant WHERE expressions outside of the loop, as is done for top-level loops.</source>
          <target state="translated">При генерации отдельных циклов для каждого срока сканирования &quot;ИЛИ&quot;,перемещайте любые константные выражения &quot;ГДЕ&quot; за пределы цикла,как это делается для циклов верхнего уровня.</target>
        </trans-unit>
        <trans-unit id="509726027c6ee1ed12b9f77062dac2b144897c56" translate="yes" xml:space="preserve">
          <source>When grouping values with the GROUP BY clause values with different storage classes are considered distinct, except for INTEGER and REAL values which are considered equal if they are numerically equal. No affinities are applied to any values as the result of a GROUP by clause.</source>
          <target state="translated">При группировке значений с пунктом GROUP BY значения с разными классами хранения считаются разными,за исключением значений INTEGER и REAL,которые считаются равными,если они численно равны.К каким-либо значениям в результате пункта GROUP BY не применяется никакого сходства.</target>
        </trans-unit>
        <trans-unit id="f5be44df47344688e11692055f71bde95bd3d10c" translate="yes" xml:space="preserve">
          <source>When implementing the compress and uncompress functions it is important to pay attention to data types. Specifically, when a user reads a value from a compressed FTS table, the value returned by FTS is exactly the same as the value returned by the uncompress function, including the data type. If that data type is not the same as the data type of the original value as passed to the compress function (for example if the uncompress function is returning BLOB when compress was originally passed TEXT), then the users query may not function as expected.</source>
          <target state="translated">При реализации функций сжатия и разжатия важно обращать внимание на типы данных.В частности,когда пользователь считывает значение из сжатой таблицы FTS,возвращаемое FTS значение в точности совпадает со значением,возвращаемым функцией компрессии,включая тип данных.Если этот тип данных не совпадает с типом данных исходного значения,переданного функции компрессии (например,если функция распаковки возвращает BLOB,когда компрессия была изначально передана TEXT),то пользовательский запрос может работать не так,как ожидалось.</target>
        </trans-unit>
        <trans-unit id="9aa85d5d53872aab853201ddf44e7a88440d444e" translate="yes" xml:space="preserve">
          <source>When in active use, the state of a WAL mode database is described by three separate files:</source>
          <target state="translated">При активном использовании состояние базы данных режима WAL описывается тремя отдельными файлами:</target>
        </trans-unit>
        <trans-unit id="2d85294d594836a84f09ae35993c5315f3443a88" translate="yes" xml:space="preserve">
          <source>When information is deleted from an SQLite database, the pages used to hold the deleted information are added to a &quot;&lt;a href=&quot;fileformat2#freelist&quot;&gt;freelist&lt;/a&gt;&quot;. Subsequent inserts will draw pages off of this freelist rather than expanding the database file.</source>
          <target state="translated">Когда информация удаляется из базы данных SQLite, страницы, используемые для хранения удаленной информации, добавляются в &amp;laquo;список &lt;a href=&quot;fileformat2#freelist&quot;&gt;фрилансеров&lt;/a&gt; &amp;raquo;. Последующие вставки будут вытягивать страницы из этого списка свободных страниц, а не расширять файл базы данных.</target>
        </trans-unit>
        <trans-unit id="e58c2028dd3a68f355f0f948fe1f1f5ac6f262b7" translate="yes" xml:space="preserve">
          <source>When initially opened, the cursor is in an undefined state. The SQLite core will invoke the &lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter&lt;/a&gt; method on the cursor prior to any attempt to position or read from the cursor.</source>
          <target state="translated">При первом открытии курсор находится в неопределенном состоянии. Ядро SQLite вызовет метод &lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter&lt;/a&gt; для курсора перед любой попыткой позиционирования или чтения с курсора.</target>
        </trans-unit>
        <trans-unit id="4ec1014aface212f1273d4c0983ab7820ffd9ca0" translate="yes" xml:space="preserve">
          <source>When inserting an explicit NULL into an INTEGER PRIMARY KEY, convert the NULL value into a unique key automatically.</source>
          <target state="translated">При вставке явного значения NULL в ключ INTEGER PRIMARY KEY автоматически преобразуйте значение NULL в уникальный ключ.</target>
        </trans-unit>
        <trans-unit id="643f10feaaa38e7180b2d82bb59e6a7c32281c82" translate="yes" xml:space="preserve">
          <source>When looking for memory allocation problems (memory leaks, use-after-free errors, buffer overflows, etc) it is sometimes useful to disable the &lt;a href=&quot;malloc#lookaside&quot;&gt;lookaside memory allocator&lt;/a&gt; then run the test under valgrind or MSAN or some other heap memory debugging tool. The lookaside memory allocator can be disabled at start-time using the &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfiglookaside&quot;&gt;SQLITE_CONFIG_LOOKASIDE&lt;/a&gt; interface. The &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; will use that interface to disable lookaside if it is started with the &quot;--lookaside 0 0&quot; command line option.</source>
          <target state="translated">При поиске проблем с распределением памяти (утечки памяти, ошибки использования после освобождения, переполнение буфера и т. Д.) Иногда полезно отключить &lt;a href=&quot;malloc#lookaside&quot;&gt;резервный распределитель памяти, а&lt;/a&gt; затем запустить тест под valgrind или MSAN или каким-либо другим инструментом отладки памяти кучи. Дополнительный распределитель памяти можно отключить во время запуска с &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfiglookaside&quot;&gt;помощью&lt;/a&gt; интерфейса SQLITE_CONFIG_LOOKASIDE . &lt;a href=&quot;cli&quot;&gt;Оболочка командной строки&lt;/a&gt; будет использовать этот интерфейс , чтобы отключить ассоциативный , если он запускается с &amp;laquo;--lookaside 0 0&amp;raquo; опцией командной строки.</target>
        </trans-unit>
        <trans-unit id="42fe685cb985a24b50ac506fdd29223838c245b8" translate="yes" xml:space="preserve">
          <source>When measuring test coverage, these macros are defined to be constant truth values so that they do not generate assembly language branch instructions, and hence do not come into play when calculating the branch coverage:</source>
          <target state="translated">При измерении тестового покрытия эти макросы определяются как постоянные значения истины,чтобы они не генерировали инструкций ассемблерных языковых ветвей и,следовательно,не вступали в игру при вычислении покрытия ветви:</target>
        </trans-unit>
        <trans-unit id="37b8b518e60139042da23ec309a2db4382dae010" translate="yes" xml:space="preserve">
          <source>When more than two tables are joined together as part of a FROM clause, the join operations are processed in order from left to right. In other words, the FROM clause (A join-op-1 B join-op-2 C) is computed as ((A join-op-1 B) join-op-2 C).</source>
          <target state="translated">При объединении более чем двух таблиц в рамках пункта FROM операции объединения обрабатываются по порядку слева направо.Другими словами,выражение FROM (A join-op-1 B join-op-2 C)вычисляется как ((A join-op-1 B)join-op-2 C).</target>
        </trans-unit>
        <trans-unit id="87981e247df4872c2958ce96479f7f548dab13e8" translate="yes" xml:space="preserve">
          <source>When multiple database connections share the same cache, changing the secure-delete flag on one database connection changes it for them all.</source>
          <target state="translated">Когда несколько подключений к БД используют один и тот же кэш,изменение флага secure-delete на одном подключении к БД меняет его для всех.</target>
        </trans-unit>
        <trans-unit id="cff16baa2216647f9ba74dc7c006fb34b16c7df6" translate="yes" xml:space="preserve">
          <source>When multiple database files are involved in a transaction, each database has its own rollback journal and each database is locked separately. The diagram at the right shows a scenario where three different database files have been modified within one transaction. The situation at this step is analogous to the single-file transaction scenario at &lt;a href=&quot;#section_3_6&quot;&gt;step 3.6&lt;/a&gt;. Each database file has a reserved lock. For each database, the original content of pages that are being changed have been written into the rollback journal for that database, but the content of the journals have not yet been flushed to disk. No changes have been made to the database file itself yet, though presumably there are changes being held in user memory.</source>
          <target state="translated">Когда в транзакции задействовано несколько файлов базы данных, каждая база данных имеет собственный журнал отката, и каждая база данных блокируется отдельно. На диаграмме справа показан сценарий, в котором три разных файла базы данных были изменены в рамках одной транзакции. Ситуация на этом шаге аналогична сценарию однофайловой транзакции на &lt;a href=&quot;#section_3_6&quot;&gt;шаге 3.6&lt;/a&gt; . Каждый файл базы данных имеет зарезервированную блокировку. Для каждой базы данных исходное содержимое изменяемых страниц было записано в журнал отката для этой базы данных, но содержимое журналов еще не было сброшено на диск. В сам файл базы данных еще не было внесено никаких изменений, хотя, по-видимому, изменения сохраняются в пользовательской памяти.</target>
        </trans-unit>
        <trans-unit id="594f4bededce2bfb4a7467d0259050d544509cc0" translate="yes" xml:space="preserve">
          <source>When mxFrame field is zero, it indicates that the WAL is empty and that all content should be obtained directly from the database file.</source>
          <target state="translated">Когда поле mxFrame равно нулю,это означает,что WAL пуст и все содержимое должно быть получено непосредственно из файла базы данных.</target>
        </trans-unit>
        <trans-unit id="1e88c1e1b6e3eb28ff7f2a97dc557877c5de44f1" translate="yes" xml:space="preserve">
          <source>When mxFrame is equal to &lt;a href=&quot;walformat#nbackfill&quot;&gt;nBackfill&lt;/a&gt;, that indicates that all content in the WAL has been written back into the database. In that case, all content can be read directly from the database. Furthermore, the next writer is free to &lt;a href=&quot;fileformat2#walreset&quot;&gt;reset the WAL&lt;/a&gt; if no other connections hold locks on WAL_READ_LOCK(N) for N&amp;gt;0.</source>
          <target state="translated">Когда mxFrame равно &lt;a href=&quot;walformat#nbackfill&quot;&gt;nBackfill&lt;/a&gt; , это означает, что все содержимое WAL было записано обратно в базу данных. В этом случае весь контент можно будет прочитать прямо из базы данных. Более того, следующий писатель может &lt;a href=&quot;fileformat2#walreset&quot;&gt;сбросить WAL,&lt;/a&gt; если никакие другие соединения не удерживают блокировки WAL_READ_LOCK (N) для N&amp;gt; 0.</target>
        </trans-unit>
        <trans-unit id="4d7dccde63e1547be27c7ca87cdd1931b0750828" translate="yes" xml:space="preserve">
          <source>When new tables are created using CREATE TABLE ... AS SELECT ... the datatype of the columns is the simplified SQLite datatype (TEXT, INT, REAL, NUMERIC, or BLOB) instead of a copy of the original datatype from the source table.</source>
          <target state="translated">При создании новых таблиц с помощью CREATE TABLE ...AS SELECT ...тип данных столбцов-упрощенный тип данных SQLite (TEXT,INT,REAL,NUMERIC или BLOB)вместо копии оригинального типа данных из исходной таблицы.</target>
        </trans-unit>
        <trans-unit id="a55aa5700dcf1b282b21e4844d72874dc0872eb0" translate="yes" xml:space="preserve">
          <source>When no appropriate indices are available, a query with an ORDER BY clause must be sorted as a separate step. Consider this query:</source>
          <target state="translated">При отсутствии соответствующих индексов запрос с пунктом &quot;ЗАКАЗАТЬ ПО&quot; должен быть отсортирован как отдельный шаг.Рассмотрим этот запрос:</target>
        </trans-unit>
        <trans-unit id="390a0c90ac5f7c87fa004dbc08670c0d9227649a" translate="yes" xml:space="preserve">
          <source>When no indices are available to aid the evaluation of a query, SQLite might create an automatic index that lasts only for the duration of a single SQL statement. Since the cost of constructing the automatic index is O(NlogN) (where N is the number of entries in the table) and the cost of doing a full table scan is only O(N), an automatic index will only be created if SQLite expects that the lookup will be run more than logN times during the course of the SQL statement. Consider an example:</source>
          <target state="translated">Когда нет индексов,которые могли бы помочь в оценке запроса,SQLite может создать автоматический индекс,который будет длиться только в течение одного SQL-запроса.Так как стоимость построения автоматического индекса-O(NlogN)(где N-количество записей в таблице),а стоимость выполнения полного сканирования таблицы-только O(N),автоматический индекс будет создан только в том случае,если SQLite ожидает,что во время выполнения SQL-оператора поиск будет выполняться больше,чем logN раз.Рассмотрим пример:</target>
        </trans-unit>
        <trans-unit id="540aa517907a8d449dfe0e0b35e5509aa40924c4" translate="yes" xml:space="preserve">
          <source>When one of RAISE(ROLLBACK,...), RAISE(ABORT,...) or RAISE(FAIL,...) is called during trigger-program execution, the specified &lt;a href=&quot;lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt; processing is performed and the current query terminates. An error code of &lt;a href=&quot;rescode#constraint&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt; is returned to the application, along with the specified error message.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e54fe7f1e563760a880b88a508db483dfbb6a4e" translate="yes" xml:space="preserve">
          <source>When one of RAISE(ROLLBACK,...), RAISE(ABORT,...) or RAISE(FAIL,...) is called during trigger-program execution, the specified &lt;a href=&quot;lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt; processing is performed the current query terminates. An error code of &lt;a href=&quot;rescode#constraint&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt; is returned to the application, along with the specified error message.</source>
          <target state="translated">Когда во время выполнения программы-триггера вызывается один из RAISE (ROLLBACK, ...), RAISE (ABORT, ...) или RAISE (FAIL, ...), выполняется указанная обработка &lt;a href=&quot;lang_conflict&quot;&gt;ON CONFLICT,&lt;/a&gt; текущий запрос завершается. В &lt;a href=&quot;rescode#constraint&quot;&gt;приложение&lt;/a&gt; возвращается код ошибки SQLITE_CONSTRAINT вместе с указанным сообщением об ошибке.</target>
        </trans-unit>
        <trans-unit id="01227fb935ccfc1f5f31820ba60592508e753c65" translate="yes" xml:space="preserve">
          <source>When opening a file, if the command-line client discovers that the file is ZIP archive instead of an SQLite database, it actually opens an &lt;a href=&quot;inmemorydb&quot;&gt;in-memory database&lt;/a&gt; and then in that in-memory database it creates an instance of the &lt;a href=&quot;zipfile&quot;&gt;Zipfile virtual table&lt;/a&gt; that is attached to the ZIP archive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4362aeea9635659d5b4cd64a35ff28fb52ad1831" translate="yes" xml:space="preserve">
          <source>When operating in &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt;, all SQLite database connections associated with the same database file need to share some memory that is used as an index for the WAL file. In most implementations, this shared memory is implemented by calling mmap() on a file created for this sole purpose: the shared-memory file. The shared-memory file, if it exists, is located in the same directory as the database file and has the same name as the database file except with the 4 characters &quot;&lt;b&gt;-shm&lt;/b&gt;&quot; appended. Shared memory files only exist while running in WAL mode.</source>
          <target state="translated">При работе в &lt;a href=&quot;wal&quot;&gt;режиме WAL&lt;/a&gt; все подключения к базе данных SQLite, связанные с одним и тем же файлом базы данных, должны совместно использовать некоторую память, которая используется в качестве индекса для файла WAL. В большинстве реализаций эта общая память реализуется путем вызова mmap () для файла, созданного для этой единственной цели: файла с общей памятью. Файл с общей памятью, если он существует, находится в том же каталоге, что и файл базы данных, и имеет то же имя, что и файл базы данных, за исключением добавления четырех символов &amp;laquo; &lt;b&gt;-shm&lt;/b&gt; &amp;raquo;. Файлы с общей памятью существуют только при работе в режиме WAL.</target>
        </trans-unit>
        <trans-unit id="6bb4007f1d52b792a142259284926e062c686eaf" translate="yes" xml:space="preserve">
          <source>When optimized for size, the whole SQLite library with everything enabled is &lt;a href=&quot;footprint&quot;&gt;less than 500KiB in size&lt;/a&gt; (as measured on an ix86 using the &quot;size&quot; utility from the GNU compiler suite.) Unneeded features can be disabled at compile-time to further reduce the size of the library to under 300KiB if desired.</source>
          <target state="translated">При оптимизации по размеру вся библиотека SQLite со всем включенным имеет &lt;a href=&quot;footprint&quot;&gt;размер менее 500 КБ&lt;/a&gt; (по измерениям на ix86 с использованием утилиты size из пакета компиляторов GNU). Ненужные функции можно отключить во время компиляции, чтобы еще больше уменьшить при желании размер библиотеки не должен превышать 300 КБ.</target>
        </trans-unit>
        <trans-unit id="36556333a18e7240b5e2f86d71ec1605e3df5074" translate="yes" xml:space="preserve">
          <source>When porting SQLite to a new operating system, it is usually necessary to completely replace the built-in mutex subsystem with an alternative built around the mutex primitives of the new operating system. This is accomplished by compiling SQLite with the following option:</source>
          <target state="translated">При портировании SQLite на новую операционную систему,как правило,необходимо полностью заменить встроенную подсистему мьютекса альтернативой,построенной вокруг примитивов мьютекса новой операционной системы.Это достигается компиляцией SQLite со следующей опцией:</target>
        </trans-unit>
        <trans-unit id="ef28302f8a0daea79bec53d89c73ea8d20c2af92" translate="yes" xml:space="preserve">
          <source>When processing a &lt;b&gt;DELETE&lt;/b&gt; change, the following conflicts may be detected:</source>
          <target state="translated">При обработке изменения &lt;b&gt;DELETE&lt;/b&gt; могут быть обнаружены следующие конфликты:</target>
        </trans-unit>
        <trans-unit id="feb3e5a5d3242cd110b456009cbca7b6fb677c07" translate="yes" xml:space="preserve">
          <source>When processing a SELECT (or other) statement, SQLite may retrieve data from database tables in a variety of ways. It may scan through all the records in a table (a full-table scan), scan a contiguous subset of the records in a table based on the rowid index, scan a contiguous subset of the entries in a database &lt;a href=&quot;lang_createtable&quot;&gt;index&lt;/a&gt;, or use a combination of the above strategies in a single scan. The various ways in which SQLite may retrieve data from a table or index are described in detail &lt;a href=&quot;queryplanner#searching&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">При обработке оператора SELECT (или другого) SQLite может извлекать данные из таблиц базы данных различными способами. Он может сканировать все записи в таблице (сканирование всей таблицы), сканировать непрерывное подмножество записей в таблице на основе индекса rowid, сканировать непрерывное подмножество записей в &lt;a href=&quot;lang_createtable&quot;&gt;индексе&lt;/a&gt; базы данных или использовать комбинацию из вышеперечисленных стратегий за одно сканирование. Различные способы , в которых SQLite может извлекать данные из таблицы или индекса подробно описаны &lt;a href=&quot;queryplanner#searching&quot;&gt;здесь&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1e6fe17803083dfa07e4b417bb2b4cf1a4c64242" translate="yes" xml:space="preserve">
          <source>When processing an &lt;b&gt;INSERT&lt;/b&gt; change, the following conflicts can occur:</source>
          <target state="translated">При обработке изменения &lt;b&gt;INSERT&lt;/b&gt; могут возникнуть следующие конфликты:</target>
        </trans-unit>
        <trans-unit id="22eb80162f6ab8bb9c9904d675b35465735f18b1" translate="yes" xml:space="preserve">
          <source>When processing an &lt;b&gt;UPDATE&lt;/b&gt; change, the following conflicts may be detected:</source>
          <target state="translated">При обработке изменения &lt;b&gt;UPDATE&lt;/b&gt; могут быть обнаружены следующие конфликты:</target>
        </trans-unit>
        <trans-unit id="96dc4d2d808bddd461eb35740cb2e242c1a91b3e" translate="yes" xml:space="preserve">
          <source>When processing queries that feature more than one token, FTS5 is sometimes able to determine that the query can be answered by inspecting a subset of a large instance-list. FTS3/4 almost always has to traverse entire instance-lists.</source>
          <target state="translated">При обработке запросов с несколькими маркерами FTS5 иногда может определить,что на запрос можно ответить,просмотрев подмножество большого списка экземпляров.FTS3/4 почти всегда приходится просматривать целые списки экземпляров.</target>
        </trans-unit>
        <trans-unit id="b4456c24b4cd85849eb2f816e79572b467a2fc07" translate="yes" xml:space="preserve">
          <source>When query results are sorted by an ORDER BY clause, values with storage class NULL come first, followed by INTEGER and REAL values interspersed in numeric order, followed by TEXT values in collating sequence order, and finally BLOB values in memcmp() order. No storage class conversions occur before the sort.</source>
          <target state="translated">Когда результаты запроса сортируются по пункту ORDER BY,сначала идут значения с классом хранения NULL,затем значения INTEGER и REAL,перемежающиеся в числовом порядке,затем значения TEXT в порядке объединения последовательностей,и,наконец,BLOB-значения в порядке memcmp().Перед сортировкой не происходит никакого преобразования классов хранения.</target>
        </trans-unit>
        <trans-unit id="e91e22fc8ff638a8787ffecd5d5f0df9da8787f3" translate="yes" xml:space="preserve">
          <source>When required to</source>
          <target state="translated">Когда требуется</target>
        </trans-unit>
        <trans-unit id="78c613e6d682faec6496ee4d9048bbcfd6d7d464" translate="yes" xml:space="preserve">
          <source>When required to append a</source>
          <target state="translated">Когда требуется добавить</target>
        </trans-unit>
        <trans-unit id="798519ed2b08664b52737ffba7c81753837b1259" translate="yes" xml:space="preserve">
          <source>When required to append a new database page to the database file, SQLite shall create a new</source>
          <target state="translated">При необходимости добавить в файл базы данных новую страницу базы данных,SQLite создаст новую</target>
        </trans-unit>
        <trans-unit id="6dcc88fffc3fe69f52028c8e6091eebcfd48e874" translate="yes" xml:space="preserve">
          <source>When required to attempt to detect a</source>
          <target state="translated">Когда требуется попытаться обнаружить</target>
        </trans-unit>
        <trans-unit id="82187b34c5d14ea3c6cc853ad766ba3268f5b299" translate="yes" xml:space="preserve">
          <source>When required to end a</source>
          <target state="translated">Когда требуется закончить</target>
        </trans-unit>
        <trans-unit id="baf01cea17946b2cb417992fd85480056f55712b" translate="yes" xml:space="preserve">
          <source>When required to modify the contents of an existing database page that existed and was not a</source>
          <target state="translated">Когда требуется изменить содержимое существующей страницы базы данных,которая существовала и не являлась</target>
        </trans-unit>
        <trans-unit id="ea12960936b78c03e66e4654443a0f13383a7001" translate="yes" xml:space="preserve">
          <source>When required to modify the contents of an existing database page, SQLite shall update the cached version of the database page content stored as part of the</source>
          <target state="translated">При необходимости изменения содержимого существующей страницы базы данных SQLite обновляет кэшированную версию содержимого страницы базы данных,которая хранится в составе</target>
        </trans-unit>
        <trans-unit id="72b58d5840f56734164db642d70a3df517a5e160" translate="yes" xml:space="preserve">
          <source>When required to open a</source>
          <target state="translated">Когда требуется открыть</target>
        </trans-unit>
        <trans-unit id="202f6940a3123823f29cdd85bae8600a952bce22" translate="yes" xml:space="preserve">
          <source>When required to perform</source>
          <target state="translated">Когда требуется выполнить</target>
        </trans-unit>
        <trans-unit id="49e57edc72b2554b07e6deee46ce3f790b869e23" translate="yes" xml:space="preserve">
          <source>When required to purge a</source>
          <target state="translated">Когда требуется очистить</target>
        </trans-unit>
        <trans-unit id="96b4b0dc1d589faf2e657c0bc5a3a75b7b82c7c8" translate="yes" xml:space="preserve">
          <source>When required to truncate (remove) a database page that existed and was not a</source>
          <target state="translated">Когда требуется усечь (удалить)страницу базы данных,которая существовала и не являлась</target>
        </trans-unit>
        <trans-unit id="24c9b9293e0d1ee15b7fdaf8a59c9a8d10fd1c44" translate="yes" xml:space="preserve">
          <source>When required to truncate a database page from the end of the database file, SQLite shall discard the associated</source>
          <target state="translated">При необходимости усечения страницы базы данных с конца файла базы данных,SQLite отбрасывает ассоциированные</target>
        </trans-unit>
        <trans-unit id="150a8fe0ea2f86237f4f58257c9a767ee7e2a25a" translate="yes" xml:space="preserve">
          <source>When required to upgrade to an</source>
          <target state="translated">Когда требуется перейти на</target>
        </trans-unit>
        <trans-unit id="fcba2e5b4c05a2548f809c299faee545560dd767" translate="yes" xml:space="preserve">
          <source>When running in shared-cache mode, a database operation may fail with an &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_LOCKED&lt;/a&gt; error if the required locks on the shared-cache or individual tables within the shared-cache cannot be obtained. See &lt;a href=&quot;sharedcache&quot;&gt;SQLite Shared-Cache Mode&lt;/a&gt; for a description of shared-cache locking. This API may be used to register a callback that SQLite will invoke when the connection currently holding the required lock relinquishes it. This API is only available if the library was compiled with the &lt;a href=&quot;compile#enable_unlock_notify&quot;&gt;SQLITE_ENABLE_UNLOCK_NOTIFY&lt;/a&gt; C-preprocessor symbol defined.</source>
          <target state="translated">При работе в режиме общего кэша операция с базой данных может завершиться ошибкой &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_LOCKED,&lt;/a&gt; если невозможно получить требуемые блокировки общего кэша или отдельных таблиц в общем кэше. См. В разделе &lt;a href=&quot;sharedcache&quot;&gt;Режим общего кэша SQLite&lt;/a&gt; описание блокировки общего кэша. Этот API может использоваться для регистрации обратного вызова, который SQLite будет вызывать, когда соединение, в настоящее время удерживающее требуемую блокировку, отказывается от него. Этот API доступен только в том случае, если библиотека была скомпилирована с определенным символом &lt;a href=&quot;compile#enable_unlock_notify&quot;&gt;SQLITE_ENABLE_UNLOCK_NOTIFY&lt;/a&gt; C-препроцессора.</target>
        </trans-unit>
        <trans-unit id="b02906105894d89f6847bc0868bb9a109b4e3e2a" translate="yes" xml:space="preserve">
          <source>When running in shared-cache mode, a database operation may fail with an &lt;a href=&quot;../rescode#locked&quot;&gt;SQLITE_LOCKED&lt;/a&gt; error if the required locks on the shared-cache or individual tables within the shared-cache cannot be obtained. See &lt;a href=&quot;../sharedcache&quot;&gt;SQLite Shared-Cache Mode&lt;/a&gt; for a description of shared-cache locking. This API may be used to register a callback that SQLite will invoke when the connection currently holding the required lock relinquishes it. This API is only available if the library was compiled with the &lt;a href=&quot;../compile#enable_unlock_notify&quot;&gt;SQLITE_ENABLE_UNLOCK_NOTIFY&lt;/a&gt; C-preprocessor symbol defined.</source>
          <target state="translated">При работе в режиме общего кэша операция с базой данных может завершиться ошибкой &lt;a href=&quot;../rescode#locked&quot;&gt;SQLITE_LOCKED,&lt;/a&gt; если невозможно получить требуемые блокировки общего кэша или отдельных таблиц в общем кэше. См. В разделе &lt;a href=&quot;../sharedcache&quot;&gt;Режим общего кэша SQLite&lt;/a&gt; описание блокировки общего кэша. Этот API может использоваться для регистрации обратного вызова, который SQLite будет вызывать, когда соединение, в настоящее время удерживающее требуемую блокировку, отказывается от него. Этот API доступен только в том случае, если библиотека была скомпилирована с определенным символом &lt;a href=&quot;../compile#enable_unlock_notify&quot;&gt;SQLITE_ENABLE_UNLOCK_NOTIFY&lt;/a&gt; C-препроцессора.</target>
        </trans-unit>
        <trans-unit id="2af0cef1a0b15f9849e9b4a326164320a983e665" translate="yes" xml:space="preserve">
          <source>When running on QNX, it is recommended that &lt;a href=&quot;mmap&quot;&gt;memory-mapped I/O&lt;/a&gt; never be used. Furthermore, to use &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt;, it is recommended that applications employ the &lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;exclusive locking mode&lt;/a&gt; in order to use &lt;a href=&quot;wal#noshm&quot;&gt;WAL without shared memory&lt;/a&gt;.</source>
          <target state="translated">При работе в QNX рекомендуется никогда не использовать &lt;a href=&quot;mmap&quot;&gt;ввод-вывод с отображением памяти&lt;/a&gt; . Кроме того, для использования &lt;a href=&quot;wal&quot;&gt;режима WAL&lt;/a&gt; рекомендуется, чтобы приложения использовали режим &lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;монопольной блокировки&lt;/a&gt; , чтобы использовать &lt;a href=&quot;wal#noshm&quot;&gt;WAL без разделяемой памяти&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d6885131949093b9f2e26719d9e197b2addf166d" translate="yes" xml:space="preserve">
          <source>When safe append semantics are indicated for a filesystem, SQLite always stores the special value of -1 for the page count in the header of the rollback journal. The -1 page count value tells any process attempting to rollback the journal that the number of pages in the journal should be computed from the journal size. This -1 value is never changed. So that when a commit occurs, we save a single flush operation and a sector write of the first page of the journal file. Furthermore, when a cache spill occurs we no longer need to append a new journal header to the end of the journal; we can simply continue appending new pages to the end of the existing journal.</source>
          <target state="translated">При указании семантики безопасных приложений для файловой системы SQLite всегда сохраняет в заголовке журнала отката специальное значение -1 для подсчета страниц.Значение -1 для счетчика страниц говорит любому процессу,пытающемуся откатить журнал,что количество страниц в журнале должно вычисляться из размера журнала.Это значение -1 никогда не меняется.Таким образом,при фиксации мы сохраняем одну операцию флеша и запись сектора первой страницы файла журнала.Кроме того,когда происходит утечка кэша,нам больше не нужно добавлять новый заголовок журнала в конец журнала,мы можем просто продолжать добавлять новые страницы в конец существующего журнала.</target>
        </trans-unit>
        <trans-unit id="c52209ae5a29283cfe5cb3dad1ce0ecd4b45279f" translate="yes" xml:space="preserve">
          <source>When sector writes are atomic and the page size of a database is the same as a sector size, and when there is a database change that only touches a single database page, then SQLite skips the whole journaling and syncing process and simply writes the modified page directly into the database file. The change counter in the first page of the database file is modified separately since no harm is done if power is lost before the change counter can be updated.</source>
          <target state="translated">Когда записи секторов атомарные и размер страницы базы данных равен размеру сектора,а когда происходит изменение базы данных,касающееся только одной страницы базы данных,то SQLite пропускает весь процесс протоколирования и синхронизации и просто записывает измененную страницу непосредственно в файл базы данных.Счётчик изменений на первой странице файла базы данных изменяется отдельно,так как при потере питания до обновления счётчика изменений не причиняется никакого вреда.</target>
        </trans-unit>
        <trans-unit id="340896b0a1241236bc1bf669ed9b704188faab52" translate="yes" xml:space="preserve">
          <source>When selecting the order of tables in a join, SQLite uses an efficient polynomial-time algorithm. Because of this, SQLite is able to plan queries with 50- or 60-way joins in a matter of microseconds</source>
          <target state="translated">При выборе порядка расположения таблиц в соединении SQLite использует эффективный алгоритм полиномиального времени.Благодаря этому,SQLite может планировать запросы с 50-или 60-путевыми соединениями за микросекунды.</target>
        </trans-unit>
        <trans-unit id="1aebe3c7de990f7af4ad0100f2e7e450c502bae1" translate="yes" xml:space="preserve">
          <source>When set to the value &quot;fts3&quot;, the matchinfo option reduces the amount of information stored by FTS4 with the consequence that the &quot;l&quot; option of &lt;a href=&quot;fts3#matchinfo&quot;&gt;matchinfo()&lt;/a&gt; is no longer available.</source>
          <target state="translated">Если установлено значение &amp;laquo;fts3&amp;raquo;, опция matchinfo уменьшает объем информации, хранимой FTS4, в результате чего опция &amp;laquo;l&amp;raquo; функции &lt;a href=&quot;fts3#matchinfo&quot;&gt;matchinfo ()&lt;/a&gt; больше не доступна.</target>
        </trans-unit>
        <trans-unit id="637783b2ffcae0b4a42a6035522c7dbcf1ec705e" translate="yes" xml:space="preserve">
          <source>When specifying insert mode, you have to give an extra argument which is the name of the table to be inserted into. For example:</source>
          <target state="translated">При указании режима вставки необходимо указать дополнительный аргумент-имя таблицы,в которую будет вставлена таблица.Например:</target>
        </trans-unit>
        <trans-unit id="1b258d1afb6dda622a0743a2a73308bdb7445718" translate="yes" xml:space="preserve">
          <source>When sqlite3_backup_step() has returned &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_DONE&lt;/a&gt;, or when the application wishes to abandon the backup operation, the application should destroy the &lt;a href=&quot;#sqlite3_backup&quot;&gt;sqlite3_backup&lt;/a&gt; by passing it to sqlite3_backup_finish(). The sqlite3_backup_finish() interfaces releases all resources associated with the &lt;a href=&quot;#sqlite3_backup&quot;&gt;sqlite3_backup&lt;/a&gt; object. If sqlite3_backup_step() has not yet returned &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_DONE&lt;/a&gt;, then any active write-transaction on the destination database is rolled back. The &lt;a href=&quot;#sqlite3_backup&quot;&gt;sqlite3_backup&lt;/a&gt; object is invalid and may not be used following a call to sqlite3_backup_finish().</source>
          <target state="translated">Когда sqlite3_backup_step () вернула &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_DONE&lt;/a&gt; или когда приложение желает отказаться от операции резервного копирования, приложение должно уничтожить &lt;a href=&quot;#sqlite3_backup&quot;&gt;sqlite3_backup&lt;/a&gt; , передав его sqlite3_backup_finish (). Интерфейсы sqlite3_backup_finish () освобождают все ресурсы, связанные с объектом &lt;a href=&quot;#sqlite3_backup&quot;&gt;sqlite3_backup&lt;/a&gt; . Если sqlite3_backup_step () еще не вернул &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_DONE&lt;/a&gt; , то любая активная транзакция записи в целевой базе данных откатывается. Объект &lt;a href=&quot;#sqlite3_backup&quot;&gt;sqlite3_backup&lt;/a&gt; недействителен и не может использоваться после вызова sqlite3_backup_finish ().</target>
        </trans-unit>
        <trans-unit id="ff3c33367e6881dcf5fe599ab4cc7d4d94774505" translate="yes" xml:space="preserve">
          <source>When sqlite3_backup_step() has returned &lt;a href=&quot;../rescode#done&quot;&gt;SQLITE_DONE&lt;/a&gt;, or when the application wishes to abandon the backup operation, the application should destroy the &lt;a href=&quot;backup&quot;&gt;sqlite3_backup&lt;/a&gt; by passing it to sqlite3_backup_finish(). The sqlite3_backup_finish() interfaces releases all resources associated with the &lt;a href=&quot;backup&quot;&gt;sqlite3_backup&lt;/a&gt; object. If sqlite3_backup_step() has not yet returned &lt;a href=&quot;../rescode#done&quot;&gt;SQLITE_DONE&lt;/a&gt;, then any active write-transaction on the destination database is rolled back. The &lt;a href=&quot;backup&quot;&gt;sqlite3_backup&lt;/a&gt; object is invalid and may not be used following a call to sqlite3_backup_finish().</source>
          <target state="translated">Когда sqlite3_backup_step () вернула &lt;a href=&quot;../rescode#done&quot;&gt;SQLITE_DONE&lt;/a&gt; или когда приложение желает отказаться от операции резервного копирования, приложение должно уничтожить &lt;a href=&quot;backup&quot;&gt;sqlite3_backup&lt;/a&gt; , передав его sqlite3_backup_finish (). Интерфейсы sqlite3_backup_finish () освобождают все ресурсы, связанные с объектом &lt;a href=&quot;backup&quot;&gt;sqlite3_backup&lt;/a&gt; . Если sqlite3_backup_step () еще не вернул &lt;a href=&quot;../rescode#done&quot;&gt;SQLITE_DONE&lt;/a&gt; , то любая активная транзакция записи в целевой базе данных откатывается. Объект &lt;a href=&quot;backup&quot;&gt;sqlite3_backup&lt;/a&gt; недействителен и не может использоваться после вызова sqlite3_backup_finish ().</target>
        </trans-unit>
        <trans-unit id="f11c5f277ff9a9bea3d1538e42d008cd96e6371c" translate="yes" xml:space="preserve">
          <source>When synchronous is FULL (2), the SQLite database engine will use the xSync method of the &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; to ensure that all content is safely written to the disk surface prior to continuing. This ensures that an operating system crash or power failure will not corrupt the database. FULL synchronous is very safe, but it is also slower. FULL is the most commonly used synchronous setting when not in &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt;.</source>
          <target state="translated">Когда для параметра synchronous установлено значение FULL (2), ядро ​​базы данных SQLite будет использовать метод xSync &lt;a href=&quot;vfs&quot;&gt;VFS,&lt;/a&gt; чтобы обеспечить безопасную запись всего содержимого на поверхность диска перед продолжением. Это гарантирует, что сбой операционной системы или сбой питания не повредят базу данных. ПОЛНЫЙ синхронный режим очень безопасен, но он также медленнее. FULL - это наиболее часто используемая синхронная настройка, когда не в &lt;a href=&quot;wal&quot;&gt;режиме WAL&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="43aa9a49bc45ba6ec32647dc1c08a8d6748123c3" translate="yes" xml:space="preserve">
          <source>When synchronous is NORMAL (1), the SQLite database engine will still sync at the most critical moments, but less often than in FULL mode. There is a very small (though non-zero) chance that a power failure at just the wrong time could corrupt the database in &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;journal_mode&lt;/a&gt;=DELETE on an older filesystem. &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt; is safe from corruption with synchronous=NORMAL, and probably DELETE mode is safe too on modern filesystems. WAL mode is always consistent with synchronous=NORMAL, but WAL mode does lose durability. A transaction committed in WAL mode with synchronous=NORMAL might roll back following a power loss or system crash. Transactions are durable across application crashes regardless of the synchronous setting or journal mode. The synchronous=NORMAL setting is a good choice for most applications running in &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt;.</source>
          <target state="translated">Когда синхронный - НОРМАЛЬНЫЙ (1), ядро ​​базы данных SQLite будет синхронизироваться в самые критические моменты, но реже, чем в ПОЛНОМ режиме. Существует очень малая (хотя и &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;отличная&lt;/a&gt; от нуля) вероятность того, что сбой питания в неподходящее время может повредить базу данных в journal_mode = DELETE в более старой файловой системе. &lt;a href=&quot;wal&quot;&gt;Режим WAL&lt;/a&gt;защищен от повреждения с помощью synchronous = NORMAL, и, вероятно, режим DELETE также безопасен для современных файловых систем. Режим WAL всегда соответствует параметру synchronous = NORMAL, но режим WAL теряет устойчивость. Транзакция, зафиксированная в режиме WAL с синхронным = NORMAL, может откатиться после потери питания или сбоя системы. Транзакции устойчивы к сбоям приложений независимо от синхронной настройки или режима журнала. Параметр synchronous = NORMAL является хорошим выбором для большинства приложений, работающих в &lt;a href=&quot;wal&quot;&gt;режиме WAL&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1221ac9ca537e39eaf7a9c102f123b50e4ccafe2" translate="yes" xml:space="preserve">
          <source>When the &quot;write_version&quot; value of the database header is larger than what the library understands, make the database read-only instead of unreadable.</source>
          <target state="translated">Когда значение &quot;write_version&quot; в заголовке БД больше,чем понимает библиотека,сделайте БД не читаемой,а доступной только для чтения.</target>
        </trans-unit>
        <trans-unit id="14c5bdcdfec2d165a19969db87c59339f98d6d50" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;#eval&quot;&gt;eval method&lt;/a&gt; sees a named SQL parameter such as &quot;$abc&quot; or &quot;:def&quot; or &quot;@ghi&quot; in an SQL statement, it tries to look up a TCL variable with the same name, and it binds the value of that TCL variable to the SQL parameter. If no such TCL variable exists, the default behavior is to bind an SQL NULL value to the parameter. However, if a bind_fallback proc is specified, then that proc is invoked with the name of the SQL parameter and the return value from the proc is bound to the SQL parameter. Or if the proc returns an error, then the SQL statement aborts with that error. If the proc returns with some code other than TCL_OK or TCL_ERROR, then the SQL parameter is bound to NULL, as it would be by default.</source>
          <target state="translated">Когда &lt;a href=&quot;#eval&quot;&gt;метод eval&lt;/a&gt; видит именованный параметр SQL, такой как &amp;laquo;$ abc&amp;raquo; или &amp;laquo;: def&amp;raquo; или &amp;laquo;@ghi&amp;raquo; в операторе SQL, он пытается найти переменную TCL с тем же именем и связывает значение этого Переменная TCL в параметр SQL. Если такой переменной TCL не существует, поведение по умолчанию - привязать значение SQL NULL к параметру. Однако, если указан процесс bind_fallback, то этот процесс вызывается с именем параметра SQL, а возвращаемое значение процедуры связывается с параметром SQL. Или, если процедура возвращает ошибку, оператор SQL прерывается с этой ошибкой. Если процедура возвращается с каким-то кодом, отличным от TCL_OK или TCL_ERROR, тогда параметр SQL привязан к NULL, как это было бы по умолчанию.</target>
        </trans-unit>
        <trans-unit id="e9681f846afb85497f8c3e1e346505a1d05e091c" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;lang_aggfunc#maxggunc&quot;&gt;min()&lt;/a&gt; or &lt;a href=&quot;lang_aggfunc#minggunc&quot;&gt;max()&lt;/a&gt; aggregate functions are used in an aggregate query, all bare columns in the result set take values from the input row which also contains the minimum or maximum. So in the query above, the value of the &quot;b&quot; column in the output will be the value of the &quot;b&quot; column in the input row that has the largest &quot;c&quot; value. There is still an ambiguity if two or more of the input rows have the same minimum or maximum value or if the query contains more than one min() and/or max() aggregate function. Only the built-in &lt;a href=&quot;lang_aggfunc#minggunc&quot;&gt;min()&lt;/a&gt; and &lt;a href=&quot;lang_aggfunc#maxggunc&quot;&gt;max()&lt;/a&gt; functions work this way.</source>
          <target state="translated">Когда агрегатные функции &lt;a href=&quot;lang_aggfunc#maxggunc&quot;&gt;min ()&lt;/a&gt; или &lt;a href=&quot;lang_aggfunc#minggunc&quot;&gt;max ()&lt;/a&gt; используются в агрегатном запросе, все пустые столбцы в наборе результатов принимают значения из входной строки, которая также содержит минимум или максимум. Таким образом, в приведенном выше запросе значение столбца &amp;laquo;b&amp;raquo; в выходных данных будет значением столбца &amp;laquo;b&amp;raquo; во входной строке, имеющего наибольшее значение &amp;laquo;c&amp;raquo;. По-прежнему существует неоднозначность, если две или более входных строк имеют одинаковое минимальное или максимальное значение или если запрос содержит более одной агрегатной функции min () и / или max (). Так работают только встроенные функции &lt;a href=&quot;lang_aggfunc#minggunc&quot;&gt;min ()&lt;/a&gt; и &lt;a href=&quot;lang_aggfunc#maxggunc&quot;&gt;max ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="56141e1c0fb6b7c512062b7753a9277ae3973fa7" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; statement to which the UPSERT is attached takes its values from a &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statement, there is a potential parsing ambiguity. The parser might not be able to tell if the &quot;ON&quot; keyword is introducing the UPSERT or if it is the ON clause of a join. To work around this, the SELECT statement should always include a WHERE clause, even if that WHERE clause is just &quot;WHERE true&quot;.</source>
          <target state="translated">Когда оператор &lt;a href=&quot;lang_insert&quot;&gt;INSERT,&lt;/a&gt; к которому присоединен UPSERT, берет свои значения из &lt;a href=&quot;lang_select&quot;&gt;оператора SELECT&lt;/a&gt; , существует потенциальная двусмысленность синтаксического анализа. Синтаксический анализатор может быть не в состоянии определить, вводит ли ключевое слово &amp;laquo;ON&amp;raquo; UPSERT или это предложение ON соединения. Чтобы обойти это, оператор SELECT всегда должен включать предложение WHERE, даже если это предложение WHERE просто &amp;laquo;WHERE true&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="9d27fd39dc19689d64d7d12f5a355d4c7bb83355" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statement that implements a &lt;a href=&quot;lang_createview&quot;&gt;VIEW&lt;/a&gt; or FROM-clause subquery is a &lt;a href=&quot;lang_select#compound&quot;&gt;compound SELECT&lt;/a&gt; then the affinity of each supposed column of the VIEW or subquery will be the affinity of the corresponding result column for one of the individual SELECT statements that make up the compound. However, it is indeterminate which of the SELECT statements will be used to determine affinity. Different constituent SELECT statements might be used to determine affinity at different times during query evaluation. Best practice is to avoid mixing affinities in a compound SELECT.</source>
          <target state="translated">Когда &lt;a href=&quot;lang_select&quot;&gt;оператор SELECT&lt;/a&gt; , реализующий подзапрос &lt;a href=&quot;lang_createview&quot;&gt;VIEW&lt;/a&gt; или FROM-clause, является &lt;a href=&quot;lang_select#compound&quot;&gt;составным SELECT,&lt;/a&gt; то сродство каждого предполагаемого столбца VIEW или подзапроса будет сродством соответствующего столбца результатов для одного из отдельных операторов SELECT, составляющих состав . Однако неясно, какой из операторов SELECT будет использоваться для определения сродства. Различные составляющие инструкции SELECT могут использоваться для определения сходства в разное время во время оценки запроса. Лучшая практика - избегать смешивания аффинностей в составном SELECT.</target>
        </trans-unit>
        <trans-unit id="06ddddedda26385f60e680a5388eae9aa1b1f989" translate="yes" xml:space="preserve">
          <source>When the D parameter is not NULL, that means that ownership of the pointer is being transferred to SQLite. SQLite will take responsibility for freeing resources associated with the pointer when it has finished using the pointer. If the D parameter is NULL, that means that ownership of the pointer remains with the caller and the caller is responsible for disposing of the pointer.</source>
          <target state="translated">Когда параметр D не NULL,это означает,что право собственности на указатель передается SQLite.SQLite возьмет на себя ответственность за освобождение ресурсов,связанных с указателем,после того,как он закончит использование указателя.Если параметр D равен NULL,это означает,что право собственности на указатель остается за вызывающим абонентом и он отвечает за утилизацию указателя.</target>
        </trans-unit>
        <trans-unit id="821f9322e2541019ba56eda61e1f81487c5db2ed" translate="yes" xml:space="preserve">
          <source>When the EXPLAIN keyword appears by itself it causes the statement to behave as a query that returns the sequence of &lt;a href=&quot;opcode&quot;&gt;virtual machine instructions&lt;/a&gt; it would have used to execute the command had the EXPLAIN keyword not been present. When the EXPLAIN QUERY PLAN phrase appears, the statement returns high-level information regarding the query plan that would have been used.</source>
          <target state="translated">Когда ключевое слово EXPLAIN появляется само по себе, оно заставляет оператор вести себя как запрос, который возвращает последовательность &lt;a href=&quot;opcode&quot;&gt;инструкций виртуальной машины,&lt;/a&gt; которые он использовал бы для выполнения команды, если бы ключевое слово EXPLAIN не присутствовало. Когда появляется фраза EXPLAIN QUERY PLAN, оператор возвращает высокоуровневую информацию о плане запроса, который мог бы использоваться.</target>
        </trans-unit>
        <trans-unit id="0322a186c7875e9599006050d189bbd4680c31ba" translate="yes" xml:space="preserve">
          <source>When the ORDER BY clause is omitted from the recursive-select, the queue behaves as a FIFO, which results in a breadth-first search.</source>
          <target state="translated">Когда пункт ORDER BY опущен из рекурсивного выбора,очередь ведет себя как FIFO,что приводит к первому широте поиска.</target>
        </trans-unit>
        <trans-unit id="6f6a426144bea68a6a8caf2439e46959412cc8bf" translate="yes" xml:space="preserve">
          <source>When the PRAGMA vdbe_trace=ON is set, correctly print the P3 operand value when it is a pointer to a structure rather than a pointer to a string.</source>
          <target state="translated">Когда установлена PRAGMA vdbe_trace=ON,правильно выведите значение операнда P3,когда он является указателем на структуру,а не на строку.</target>
        </trans-unit>
        <trans-unit id="de58aafb2b793ff0f7f439bee5ca0476571bc42c" translate="yes" xml:space="preserve">
          <source>When the Query Planner Stability Guarantee (QPSG) is enabled SQLite will always pick the same query plan for any given SQL statement as long as:</source>
          <target state="translated">При включенной Гарантии Стабильности Планировщика Запросов (QPSG)SQLite всегда будет выбирать один и тот же план запроса для любого заданного SQL-запроса до тех пор,пока он включен:</target>
        </trans-unit>
        <trans-unit id="ea89f7d473effa3c1f787520608ed6a1d3dd75bc" translate="yes" xml:space="preserve">
          <source>When the REPLACE conflict resolution strategy deletes rows in order to satisfy a constraint, &lt;a href=&quot;lang_createtrigger&quot;&gt;delete triggers&lt;/a&gt; fire if and only if &lt;a href=&quot;pragma#pragma_recursive_triggers&quot;&gt;recursive triggers&lt;/a&gt; are enabled.</source>
          <target state="translated">Когда стратегия разрешения конфликтов REPLACE удаляет строки, чтобы удовлетворить ограничение, &lt;a href=&quot;lang_createtrigger&quot;&gt;триггеры удаления срабатывают&lt;/a&gt; тогда и только тогда, когда включены &lt;a href=&quot;pragma#pragma_recursive_triggers&quot;&gt;рекурсивные триггеры&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4ca0d858dd9858ff95b9e784a094d5524fe9f00c" translate="yes" xml:space="preserve">
          <source>When the SQLITE_ENABLE_UNKNOWN_SQL_FUNCTION compile-time option is activated, SQLite will suppress &quot;unknown function&quot; errors when running an &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt; or &lt;a href=&quot;eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt;. Instead of throwing an error, SQLite will insert a substitute no-op function named &quot;unknown()&quot;. The substitution of &quot;unknown()&quot; in place of unrecognized functions only occurs on &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt; and &lt;a href=&quot;eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt;, not on ordinary statements.</source>
          <target state="translated">Когда параметр времени компиляции SQLITE_ENABLE_UNKNOWN_SQL_FUNCTION активирован, SQLite будет подавлять ошибки &amp;laquo;неизвестная функция&amp;raquo; при запуске &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt; или &lt;a href=&quot;eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; . Вместо выдачи ошибки SQLite вставит заменяющую функцию без операции с именем &amp;laquo;unknown ()&amp;raquo;. Замена неизвестных функций на &amp;laquo;unknown ()&amp;raquo; происходит только в &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt; и &lt;a href=&quot;eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; , но не в обычных операторах.</target>
        </trans-unit>
        <trans-unit id="18d1211c78f050ab2271d9386344a3bea2c6f673" translate="yes" xml:space="preserve">
          <source>When the SQLITE_SYNC_DATAONLY flag is used, it means that the sync operation only needs to flush data to mass storage. Inode information need not be flushed. If the lower four bits of the flag equal SQLITE_SYNC_NORMAL, that means to use normal fsync() semantics. If the lower four bits equal SQLITE_SYNC_FULL, that means to use Mac OS X style fullsync instead of fsync().</source>
          <target state="translated">При использовании флага SQLITE_SYNC_DATAONLY это означает,что операция синхронизации требует только промывки данных на массовое хранение.Входная информация не нуждается в промывке.Если нижние четыре бита флага равны SQLITE_SYNC_NORMAL,это означает использование обычной семантики fsync().Если нижние четыре бита равны SQLITE_SYNC_FULL,это означает использование стиля Mac OS X fullsync вместо fsync().</target>
        </trans-unit>
        <trans-unit id="985e39e22f124ec3b4d15128274a9355a9afbb19" translate="yes" xml:space="preserve">
          <source>When the WHERE is omitted from a DELETE statement and the table being deleted has no triggers, SQLite uses an optimization to erase the entire table content without having to visit each row of the table individually. This &quot;truncate&quot; optimization makes the delete run much faster. Prior to SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_6_5.html&quot;&gt;version 3.6.5&lt;/a&gt; (2008-11-12), the truncate optimization also meant that the &lt;a href=&quot;c3ref/changes&quot;&gt;sqlite3_changes()&lt;/a&gt; and &lt;a href=&quot;c3ref/total_changes&quot;&gt;sqlite3_total_changes()&lt;/a&gt; interfaces and the &lt;a href=&quot;pragma#pragma_count_changes&quot;&gt;count_changes pragma&lt;/a&gt; will not actually return the number of deleted rows. That problem has been fixed as of &lt;a href=&quot;https://sqlite.org/releaselog/3_6_5.html&quot;&gt;version 3.6.5&lt;/a&gt; (2008-11-12).</source>
          <target state="translated">Когда WHERE опущен в инструкции DELETE и удаляемая таблица не имеет триггеров, SQLite использует оптимизацию для стирания всего содержимого таблицы без необходимости посещать каждую строку таблицы по отдельности. Эта оптимизация &amp;laquo;усечения&amp;raquo; значительно ускоряет процесс удаления. До версии SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_6_5.html&quot;&gt;3.6.5&lt;/a&gt; (2008-11-12) оптимизация усечения также означала, что интерфейсы &lt;a href=&quot;c3ref/changes&quot;&gt;sqlite3_changes ()&lt;/a&gt; и &lt;a href=&quot;c3ref/total_changes&quot;&gt;sqlite3_total_changes ()&lt;/a&gt; и &lt;a href=&quot;pragma#pragma_count_changes&quot;&gt;прагма count_changes&lt;/a&gt; фактически не возвращали количество удаленных строк. Эта проблема исправлена ​​в &lt;a href=&quot;https://sqlite.org/releaselog/3_6_5.html&quot;&gt;версии 3.6.5&lt;/a&gt; (2008-11-12).</target>
        </trans-unit>
        <trans-unit id="ed1319f0bc1a6521bcf2196280e7316235700141" translate="yes" xml:space="preserve">
          <source>When the above CREATE VIRTUAL TABLE statement is executed, swarmvtab binds the text value &quot;/home/user/app/databases/&quot; to the :dir parameter of the SQL statement before executing it.</source>
          <target state="translated">При выполнении вышеуказанного оператора CREATE VIRTUAL TABLE,swarmvtab привязывает текстовое значение &quot;/home/user/app/databases/&quot; к параметру :dir оператора SQL перед его выполнением.</target>
        </trans-unit>
        <trans-unit id="af84afd9d831ba7532e3be1008b7a2fa2d6de72c" translate="yes" xml:space="preserve">
          <source>When the auto-vacuum mode is 1 or &quot;full&quot;, the freelist pages are moved to the end of the database file and the database file is truncated to remove the freelist pages at every transaction commit. Note, however, that auto-vacuum only truncates the freelist pages from the file. Auto-vacuum does not defragment the database nor repack individual database pages the way that the &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; command does. In fact, because it moves pages around within the file, auto-vacuum can actually make fragmentation worse.</source>
          <target state="translated">Когда режим автоматического вакуумирования равен 1 или &amp;laquo;полный&amp;raquo;, страницы списка свободных страниц перемещаются в конец файла базы данных, а файл базы данных усекается для удаления страниц списка свободных страниц при каждой фиксации транзакции. Обратите внимание, однако, что автоматическая очистка только усекает страницы списка фрилансеров из файла. Автоматический вакуум не дефрагментирует базу данных и не переупаковывает отдельные страницы базы данных, как это делает команда &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; . Фактически, поскольку он перемещает страницы внутри файла, автоматическая очистка может усугубить фрагментацию.</target>
        </trans-unit>
        <trans-unit id="ef4d832eb7039ef85ce7ded8003003dd3cc72641" translate="yes" xml:space="preserve">
          <source>When the auto_vacuum pragma is invoked with no arguments, it returns the current auto_vacuum mode.</source>
          <target state="translated">Когда прагма auto_vacuum вызывается без аргументов,она возвращает текущий режим auto_vacuum.</target>
        </trans-unit>
        <trans-unit id="f2ce457b213b80c33d7ab3d10e7347a9c292b2e3" translate="yes" xml:space="preserve">
          <source>When the callback is invoked, the first argument passed is a copy of the second argument to sqlite3_collation_needed() or sqlite3_collation_needed16(). The second argument is the database connection. The third argument is one of &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF8&lt;/a&gt;, &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16BE&lt;/a&gt;, or &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16LE&lt;/a&gt;, indicating the most desirable form of the collation sequence function required. The fourth parameter is the name of the required collation sequence.</source>
          <target state="translated">Когда вызывается обратный вызов, первый переданный аргумент является копией второго аргумента для sqlite3_collation_needed () или sqlite3_collation_needed16 (). Второй аргумент - это соединение с базой данных. Третий аргумент - это один из &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF8&lt;/a&gt; , &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16BE&lt;/a&gt; или &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16LE&lt;/a&gt; , указывающий на наиболее желательную форму требуемой функции последовательности сортировки. Четвертый параметр - это имя требуемой последовательности сортировки.</target>
        </trans-unit>
        <trans-unit id="7ee3c7dd196b6cbe2c4c2e3d7d3e7a9d7a6a2b67" translate="yes" xml:space="preserve">
          <source>When the callback is invoked, the first argument passed is a copy of the second argument to sqlite3_collation_needed() or sqlite3_collation_needed16(). The second argument is the database connection. The third argument is one of &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF8&lt;/a&gt;, &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16BE&lt;/a&gt;, or &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16LE&lt;/a&gt;, indicating the most desirable form of the collation sequence function required. The fourth parameter is the name of the required collation sequence.</source>
          <target state="translated">Когда вызывается обратный вызов, первый переданный аргумент является копией второго аргумента для sqlite3_collation_needed () или sqlite3_collation_needed16 (). Второй аргумент - это соединение с базой данных. Третий аргумент - это один из &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF8&lt;/a&gt; , &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16BE&lt;/a&gt; или &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16LE&lt;/a&gt; , указывающий на наиболее желательную форму требуемой функции последовательности сортировки. Четвертый параметр - это имя требуемой последовательности сортировки.</target>
        </trans-unit>
        <trans-unit id="f0027db967a591c65d48dbd0afc84a797aef3887" translate="yes" xml:space="preserve">
          <source>When the callback returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt;, that means the operation requested is ok. When the callback returns &lt;a href=&quot;#SQLITE_DENY&quot;&gt;SQLITE_DENY&lt;/a&gt;, the &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; or equivalent call that triggered the authorizer will fail with an error message explaining that access is denied.</source>
          <target state="translated">Когда обратный вызов возвращает &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; , это означает, что запрошенная операция в порядке. Когда обратный вызов возвращает &lt;a href=&quot;#SQLITE_DENY&quot;&gt;SQLITE_DENY&lt;/a&gt; , вызов &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; или эквивалентный вызов, запускающий авторизатор, завершится ошибкой с сообщением об ошибке, объясняющим, что доступ запрещен.</target>
        </trans-unit>
        <trans-unit id="1bae5c6c86ffd7028029909efdc71f4e4f816633" translate="yes" xml:space="preserve">
          <source>When the callback returns &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;, that means the operation requested is ok. When the callback returns &lt;a href=&quot;c_deny&quot;&gt;SQLITE_DENY&lt;/a&gt;, the &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; or equivalent call that triggered the authorizer will fail with an error message explaining that access is denied.</source>
          <target state="translated">Когда обратный вызов возвращает &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; , это означает, что запрошенная операция в порядке. Когда обратный вызов возвращает &lt;a href=&quot;c_deny&quot;&gt;SQLITE_DENY&lt;/a&gt; , вызов &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; или эквивалентный вызов, запускающий авторизатор, завершится ошибкой с сообщением об ошибке, объясняющим, что доступ запрещен.</target>
        </trans-unit>
        <trans-unit id="2fc4782b077cfef78fd1da131f206927c4488a10" translate="yes" xml:space="preserve">
          <source>When the command-line shell and the core SQLite library are both compiled with &lt;a href=&quot;compile#debug&quot;&gt;SQLITE_DEBUG&lt;/a&gt; and SQLITE_ENABLE_SELECTTRACE and SQLITE_ENABLE_WHERETRACE, then the shell has two commands used to turn on debugging facilities for the most intricate parts of the code generator - the logic dealing with SELECT statements and WHERE clauses, respectively. The &quot;.selecttrace&quot; and &quot;.wheretrace&quot; commands each take a numeric argument which can be expressed in hexadecimal. Each bit turns on various parts of debugging. Values of &quot;0xfff&quot; and &quot;0xff&quot; are commonly used. Use an argument of &quot;0&quot; to turn all tracing output back off.</source>
          <target state="translated">Когда оболочка командной строки и основная библиотека SQLite скомпилированы с помощью &lt;a href=&quot;compile#debug&quot;&gt;SQLITE_DEBUG&lt;/a&gt; и SQLITE_ENABLE_SELECTTRACE и SQLITE_ENABLE_WHERETRACE, оболочка имеет две команды, используемые для включения средств отладки для наиболее сложных частей генератора кода - логики, связанной с операторами SELECT и WHERE соответственно. Каждая из команд &quot;.selecttrace&quot; и &quot;.wheretrace&quot; принимает числовой аргумент, который может быть выражен в шестнадцатеричном формате. Каждый бит включает различные части отладки. Обычно используются значения &amp;laquo;0xfff&amp;raquo; и &amp;laquo;0xff&amp;raquo;. Используйте аргумент &amp;laquo;0&amp;raquo;, чтобы отключить все выходные данные трассировки.</target>
        </trans-unit>
        <trans-unit id="b723658445ef923fc3e6ed08d931b577b65bc748" translate="yes" xml:space="preserve">
          <source>When the commit hook callback routine returns zero, the &lt;a href=&quot;../lang_transaction&quot;&gt;COMMIT&lt;/a&gt; operation is allowed to continue normally. If the commit hook returns non-zero, then the &lt;a href=&quot;../lang_transaction&quot;&gt;COMMIT&lt;/a&gt; is converted into a &lt;a href=&quot;../lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt;. The rollback hook is invoked on a rollback that results from a commit hook returning non-zero, just as it would be with any other rollback.</source>
          <target state="translated">Когда процедура обратного вызова ловушки фиксации возвращает ноль, операция &lt;a href=&quot;../lang_transaction&quot;&gt;COMMIT&lt;/a&gt; может продолжаться в обычном режиме. Если ловушка фиксации возвращает ненулевое значение, то &lt;a href=&quot;../lang_transaction&quot;&gt;COMMIT&lt;/a&gt; преобразуется в &lt;a href=&quot;../lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt; . Ловушка отката вызывается при откате, который возникает из-за того, что ловушка фиксации возвращает ненулевое значение, как и при любом другом откате.</target>
        </trans-unit>
        <trans-unit id="cc0bc375382d425cd0a289c0d31fef27fb453ac2" translate="yes" xml:space="preserve">
          <source>When the commit hook callback routine returns zero, the &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; operation is allowed to continue normally. If the commit hook returns non-zero, then the &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; is converted into a &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt;. The rollback hook is invoked on a rollback that results from a commit hook returning non-zero, just as it would be with any other rollback.</source>
          <target state="translated">Когда процедура обратного вызова ловушки фиксации возвращает ноль, операция &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; может продолжаться в обычном режиме. Если ловушка фиксации возвращает ненулевое значение, то &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; преобразуется в &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt; . Ловушка отката вызывается при откате, который возникает из-за того, что ловушка фиксации возвращает ненулевое значение, как и при любом другом откате.</target>
        </trans-unit>
        <trans-unit id="ebd93d5d1aa49a1f19ce4e8d40b4dcf35920ce66" translate="yes" xml:space="preserve">
          <source>When the defer_foreign_keys &lt;a href=&quot;pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt; is on, enforcement of all &lt;a href=&quot;foreignkeys&quot;&gt;foreign key constraints&lt;/a&gt; is delayed until the outermost transaction is committed. The defer_foreign_keys pragma defaults to OFF so that foreign key constraints are only deferred if they are created as &quot;DEFERRABLE INITIALLY DEFERRED&quot;. The defer_foreign_keys pragma is automatically switched off at each COMMIT or ROLLBACK. Hence, the defer_foreign_keys pragma must be separately enabled for each transaction. This pragma is only meaningful if foreign key constraints are enabled, of course.</source>
          <target state="translated">Когда defer_foreign_keys PRAGMA &lt;a href=&quot;pragma#syntax&quot;&gt;включен&lt;/a&gt; , применение всех &lt;a href=&quot;foreignkeys&quot;&gt;ограничений внешнего ключа&lt;/a&gt; откладывается до тех пор, пока не будет зафиксирована самая внешняя транзакция. Прагма defer_foreign_keys по умолчанию выключена, так что ограничения внешнего ключа откладываются только в том случае, если они созданы как &amp;laquo;ОТЛОЖЕННЫЙ НАЧАЛЬНО ОТЛОЖЕННЫЙ&amp;raquo;. Прагма defer_foreign_keys автоматически отключается при каждом COMMIT или ROLLBACK. Следовательно, прагма defer_foreign_keys должна быть включена отдельно для каждой транзакции. Эта прагма имеет смысл только в том случае, если, конечно, включены ограничения внешнего ключа.</target>
        </trans-unit>
        <trans-unit id="f4cc14d79785a0eab23a6d9f7db6c91e125bbb70" translate="yes" xml:space="preserve">
          <source>When the end-user executes a DML or DDL SQL statement to modify the database schema or content, SQLite is required to update the database file image to reflect the new database state. This involves modifying the content of, appending or truncating one of more database file pages. Instead of modifying the database file directly using the VFS interface, changes are first buffered within the</source>
          <target state="translated">Когда конечный пользователь выполняет оператор DML или DDL SQL для изменения схемы или содержимого базы данных,SQLite требуется обновить образ файла базы данных,чтобы отразить новое состояние базы данных.Это включает в себя изменение содержимого,добавление или усечение одной из страниц файла БД.Вместо того,чтобы модифицировать файл базы данных напрямую с помощью интерфейса VFS,изменения сначала буферизируются внутри файла</target>
        </trans-unit>
        <trans-unit id="e72b791ecc5f4b31b8f87177039bb7c97a3857b6" translate="yes" xml:space="preserve">
          <source>When the languageid option is present, it specifies the name of another &lt;a href=&quot;vtab#hiddencol&quot;&gt;hidden column&lt;/a&gt; that is added to the FTS4 table and which is used to specify the language stored in each row of the FTS4 table. The name of the languageid hidden column must be distinct from all other column names in the FTS4 table. Example:</source>
          <target state="translated">Если присутствует параметр languageid, он указывает имя другого &lt;a href=&quot;vtab#hiddencol&quot;&gt;скрытого столбца,&lt;/a&gt; который добавляется в таблицу FTS4 и используется для указания языка, хранящегося в каждой строке таблицы FTS4. Имя скрытого столбца languageid должно отличаться от имен всех других столбцов в таблице FTS4. Пример:</target>
        </trans-unit>
        <trans-unit id="b1e38f0c1dabd3714310eefb8d8a6cff4de89d44" translate="yes" xml:space="preserve">
          <source>When the languageid option is used, SQLite invokes the xLanguageid() on the sqlite3_tokenizer_module object immediately after the object is created in order to pass in the language id that the tokenizer should use. The xLanguageid() method will never be called more than once for any single tokenizer object. The fact that different languages might be tokenized differently is one reason why no single FTS query can return rows with different languageid values.</source>
          <target state="translated">При использовании опции languageid SQLite вызывает функцию xLanguageid()на объекте sqlite3_tokenizer_module сразу после создания объекта для передачи идентификатора языка,который должен использоваться токенайзером.Метод xLanguageid()никогда не будет вызываться более одного раза ни для одного объекта токенайзера.Тот факт,что разные языки могут быть токенированы по-разному,является одной из причин,по которой ни один запрос FTS не может вернуть строки с разными значениями языка.</target>
        </trans-unit>
        <trans-unit id="9aa0a1cde451597b6df45b6c556052ff5eb9c927" translate="yes" xml:space="preserve">
          <source>When the last connection to a particular database is closing, that connection will acquire an exclusive lock for a short time while it cleans up the WAL and shared-memory files. If a second database tries to open and query the database while the first connection is still in the middle of its cleanup process, the second connection might get an &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; error.</source>
          <target state="translated">Когда последнее соединение с конкретной базой данных закрывается, это соединение на короткое время получает эксклюзивную блокировку, пока очищаются файлы WAL и разделяемой памяти. Если вторая база данных пытается открыть и запросить базу данных, в то время как первое соединение все еще находится в середине процесса очистки, второе соединение может получить ошибку &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="721a001d639a4fa0bf082ab41646b624fe82e4a7" translate="yes" xml:space="preserve">
          <source>When the legacy_file_format pragma is issued with no argument, it returns the setting of the flag. This pragma does &lt;u&gt;not&lt;/u&gt; tell which file format the current database is using; it tells what format will be used by any newly created databases.</source>
          <target state="translated">Когда прагма legacy_file_format выдается без аргументов, она возвращает установку флага. Эта прагма &lt;u&gt;не&lt;/u&gt; сообщает, какой формат файла использует текущая база данных; он сообщает, какой формат будет использоваться новыми базами данных.</target>
        </trans-unit>
        <trans-unit id="6a4f25a9dc00e5fa108cea204a933cd9b0d930ee" translate="yes" xml:space="preserve">
          <source>When the locking_mode pragma specifies a particular database, for example:</source>
          <target state="translated">Например,когда прагма lock_mode задает определенную БД:</target>
        </trans-unit>
        <trans-unit id="65958bd909cd29c71d7062800a7ff7cb762631b5" translate="yes" xml:space="preserve">
          <source>When the name of the database file handed to &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt; or to &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; is an empty string, then a new temporary file is created to hold the database.</source>
          <target state="translated">Когда имя файла базы данных, переданного &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open ()&lt;/a&gt; или &lt;a href=&quot;lang_attach&quot;&gt;ATTACH,&lt;/a&gt; является пустой строкой, тогда создается новый временный файл для хранения базы данных.</target>
        </trans-unit>
        <trans-unit id="a5261e01bfb3de59bf05674e0d1d120422019175" translate="yes" xml:space="preserve">
          <source>When the original content of a database page is written into the rollback journal (as shown in &lt;a href=&quot;#section_3_5&quot;&gt;section 3.5&lt;/a&gt;), SQLite always writes a complete sector of data, even if the page size of the database is smaller than the sector size. Historically, the sector size in SQLite has been hard coded to 512 bytes and since the minimum page size is also 512 bytes, this has never been an issue. But beginning with SQLite version 3.3.14, it is possible for SQLite to use mass storage devices with a sector size larger than 512 bytes. So, beginning with version 3.3.14, whenever any page within a sector is written into the journal file, all pages in that same sector are stored with it.</source>
          <target state="translated">Когда исходное содержимое страницы базы данных записывается в журнал отката (как показано в &lt;a href=&quot;#section_3_5&quot;&gt;разделе 3.5&lt;/a&gt; ), SQLite всегда записывает полный сектор данных, даже если размер страницы базы данных меньше, чем размер сектора. Исторически размер сектора в SQLite был жестко задан как 512 байт, а поскольку минимальный размер страницы также составляет 512 байт, это никогда не было проблемой. Но, начиная с версии SQLite 3.3.14, SQLite может использовать запоминающие устройства с размером сектора больше 512 байт. Итак, начиная с версии 3.3.14, всякий раз, когда какая-либо страница в секторе записывается в файл журнала, все страницы этого же сектора сохраняются вместе с ним.</target>
        </trans-unit>
        <trans-unit id="24eb3cec7d166e89084624729f4f076ba57699a6" translate="yes" xml:space="preserve">
          <source>When the payload of a b-tree cell is too large for the b-tree page, the surplus is spilled onto overflow pages. Overflow pages form a linked list. The first four bytes of each overflow page are a big-endian integer which is the page number of the next page in the chain, or zero for the final page in the chain. The fifth byte through the last usable byte are used to hold overflow content.</source>
          <target state="translated">Когда полезная нагрузка ячейки b-дерева слишком велика для страницы b-дерева,излишек проливается на переполненные страницы.Страницы переполнения образуют связанный список.Первые четыре байта каждой страницы переполнения представляют собой крупно-сменное целое число,которое является номером следующей страницы в цепочке,или нолью для последней страницы в цепочке.Пятый байт через последний используемый байт используется для хранения содержимого переполнения.</target>
        </trans-unit>
        <trans-unit id="7a9dfbcbb999703cb3d0ac4b512f0bf41cd8632a" translate="yes" xml:space="preserve">
          <source>When the private repository is created by cloning, incorporating new public SQLite releases becomes much easier too. To pull in all of the latest changes from the public SQLite repository, simply move into the open check-out and do:</source>
          <target state="translated">Когда частный репозиторий создается путем клонирования,включать новые публичные выпуски SQLite тоже становится намного проще.Чтобы извлечь все последние изменения из публичного репозитория SQLite,просто перейдите в открытый режим извлечения и сделайте это:</target>
        </trans-unit>
        <trans-unit id="5be9656f401ac8804b83b6da6efba9e4ec09be72" translate="yes" xml:space="preserve">
          <source>When the result of a sub-select is a scalar, a single private memory cell can be used, as shown in the previous example. But when the result of a sub-select is a vector, such as when the sub-select is the right-hand operand of IN or NOT IN, a different approach is needed. In this case, the result of the sub-select is stored in a transient table and the contents of that table are tested using the Found or NotFound operators. Consider this example:</source>
          <target state="translated">Когда результатом подвыбора является скаляр,можно использовать одну личную ячейку памяти,как показано в предыдущем примере.Но когда результатом суб-выбора является вектор,например,когда суб-выбор является правым операндом IN или NOT IN,нужен другой подход.В этом случае результат подвыбора сохраняется в переходной таблице,а содержимое этой таблицы проверяется с помощью операторов Found или NotFound.Рассмотрим этот пример:</target>
        </trans-unit>
        <trans-unit id="7f4bad19a801621b1eda251a27bffb8486beb1b2" translate="yes" xml:space="preserve">
          <source>When the serialized &lt;a href=&quot;../threadsafe&quot;&gt;threading mode&lt;/a&gt; is in use, it might be the case that a second error occurs on a separate thread in between the time of the first error and the call to these interfaces. When that happens, the second error will be reported since these interfaces always report the most recent result. To avoid this, each thread can obtain exclusive use of the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; D by invoking &lt;a href=&quot;mutex_alloc&quot;&gt;sqlite3_mutex_enter&lt;/a&gt;(&lt;a href=&quot;db_mutex&quot;&gt;sqlite3_db_mutex&lt;/a&gt;(D)) before beginning to use D and invoking &lt;a href=&quot;mutex_alloc&quot;&gt;sqlite3_mutex_leave&lt;/a&gt;(&lt;a href=&quot;db_mutex&quot;&gt;sqlite3_db_mutex&lt;/a&gt;(D)) after all calls to the interfaces listed here are completed.</source>
          <target state="translated">Когда используется &lt;a href=&quot;../threadsafe&quot;&gt;режим&lt;/a&gt; сериализованного потока , может случиться так, что вторая ошибка произойдет в отдельном потоке между моментом первой ошибки и вызовом этих интерфейсов. Когда это произойдет, будет сообщено о второй ошибке, поскольку эти интерфейсы всегда сообщают самый последний результат. Чтобы избежать этого, каждый поток может получить эксклюзивное использование &lt;a href=&quot;sqlite3&quot;&gt;соединения&lt;/a&gt; D с базой данных , вызвав &lt;a href=&quot;mutex_alloc&quot;&gt;sqlite3_mutex_enter&lt;/a&gt; ( &lt;a href=&quot;db_mutex&quot;&gt;sqlite3_db_mutex&lt;/a&gt; (D)) перед началом использования D и вызвав &lt;a href=&quot;mutex_alloc&quot;&gt;sqlite3_mutex_leave&lt;/a&gt; ( &lt;a href=&quot;db_mutex&quot;&gt;sqlite3_db_mutex&lt;/a&gt; (D)) после того, как все вызовы интерфейсов, перечисленных здесь, завершены.</target>
        </trans-unit>
        <trans-unit id="6ad35aaaabcdc79e64145d3f60787d98e09a5e23" translate="yes" xml:space="preserve">
          <source>When the serialized &lt;a href=&quot;threadsafe&quot;&gt;threading mode&lt;/a&gt; is in use, it might be the case that a second error occurs on a separate thread in between the time of the first error and the call to these interfaces. When that happens, the second error will be reported since these interfaces always report the most recent result. To avoid this, each thread can obtain exclusive use of the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; D by invoking &lt;a href=&quot;#sqlite3_mutex_alloc&quot;&gt;sqlite3_mutex_enter&lt;/a&gt;(&lt;a href=&quot;#sqlite3_db_mutex&quot;&gt;sqlite3_db_mutex&lt;/a&gt;(D)) before beginning to use D and invoking &lt;a href=&quot;#sqlite3_mutex_alloc&quot;&gt;sqlite3_mutex_leave&lt;/a&gt;(&lt;a href=&quot;#sqlite3_db_mutex&quot;&gt;sqlite3_db_mutex&lt;/a&gt;(D)) after all calls to the interfaces listed here are completed.</source>
          <target state="translated">Когда используется &lt;a href=&quot;threadsafe&quot;&gt;режим&lt;/a&gt; сериализованного потока , может случиться так, что вторая ошибка произойдет в отдельном потоке между моментом первой ошибки и вызовом этих интерфейсов. Когда это произойдет, будет сообщено о второй ошибке, поскольку эти интерфейсы всегда сообщают самый последний результат. Чтобы избежать этого, каждый поток может получить эксклюзивное использование &lt;a href=&quot;#sqlite3&quot;&gt;соединения&lt;/a&gt; D с базой данных , вызвав &lt;a href=&quot;#sqlite3_mutex_alloc&quot;&gt;sqlite3_mutex_enter&lt;/a&gt; ( &lt;a href=&quot;#sqlite3_db_mutex&quot;&gt;sqlite3_db_mutex&lt;/a&gt; (D)) перед началом использования D и вызвав &lt;a href=&quot;#sqlite3_mutex_alloc&quot;&gt;sqlite3_mutex_leave&lt;/a&gt; ( &lt;a href=&quot;#sqlite3_db_mutex&quot;&gt;sqlite3_db_mutex&lt;/a&gt; (D)) после того, как все вызовы интерфейсов, перечисленных здесь, завершены.</target>
        </trans-unit>
        <trans-unit id="ae5d894865b3485bb3f0df9031d208d9c0c832c5" translate="yes" xml:space="preserve">
          <source>When the size of payload for a cell exceeds a certain threshold (to be defined later) then only the first few bytes of the payload are stored on the b-tree page and the balance is stored in a linked list of content overflow pages.</source>
          <target state="translated">Когда размер полезного груза для ячейки превышает определенный порог (будет определено позже),на странице b-дерева сохраняются только первые несколько байт полезного груза,а остаток хранится в связанном со ссылкой списке страниц переполнения контента.</target>
        </trans-unit>
        <trans-unit id="959baafa9a7af49bb6654912e390fd8adf72f9f7" translate="yes" xml:space="preserve">
          <source>When the steps above are used, SQLite will shorten filename extensions by only using the last 3 characters of the extension. Thus, for example, a file that would normally be called &quot;&lt;code&gt;app.db-journal&lt;/code&gt;&quot; is shortened to just &quot;&lt;code&gt;app.nal&lt;/code&gt;&quot;. Similarly, &quot;&lt;code&gt;app.db-wal&lt;/code&gt;&quot; will become &quot;&lt;code&gt;app.wal&lt;/code&gt;&quot; and &quot;&lt;code&gt;app.db-shm&lt;/code&gt;&quot; becomes &quot;&lt;code&gt;app.shm&lt;/code&gt;&quot;.</source>
          <target state="translated">При выполнении описанных выше шагов SQLite сокращает расширения имен файлов, используя только последние 3 символа расширения. Так, например, файл, который обычно называется &amp;laquo; &lt;code&gt;app.db-journal&lt;/code&gt; &amp;raquo;, сокращается до &amp;laquo; &lt;code&gt;app.nal&lt;/code&gt; &amp;raquo;. Точно так же &amp;laquo; &lt;code&gt;app.db-wal&lt;/code&gt; &amp;raquo; станет &amp;laquo; &lt;code&gt;app.wal&lt;/code&gt; &amp;raquo;, а &amp;laquo; &lt;code&gt;app.db-shm&lt;/code&gt; &amp;raquo; станет &amp;laquo; &lt;code&gt;app.shm&lt;/code&gt; &amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="d643d5a9185e437164a5f2a6216624f98b3e6f19" translate="yes" xml:space="preserve">
          <source>When the temp_store_directory setting is changed, all existing temporary tables, indices, triggers, and viewers in the database connection that issued the pragma are immediately deleted. In practice, temp_store_directory should be set immediately after the first database connection for a process is opened. If the temp_store_directory is changed for one database connection while other database connections are open in the same process, then the behavior is undefined and probably undesirable.</source>
          <target state="translated">При изменении настройки директории temp_store_немедленно удаляются все существующие временные таблицы,индексы,триггеры и вьюверы в подключении к БД,выпустившие прагму.На практике каталог temp_store_store_должен быть установлен сразу после открытия первого подключения к БД для процесса.Если каталог temp_store_store_изменяется для одного подключения к БД,в то время как другие подключения к БД открываются в том же процессе,то поведение является неопределенным и,возможно,нежелательным.</target>
        </trans-unit>
        <trans-unit id="343b5a2825eceb4a3f5768433d668b582d6b47c5" translate="yes" xml:space="preserve">
          <source>When the unlock-notify callback is invoked, which may be before the thread that called &lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify()&lt;/a&gt; begins waiting for the asynchronous signal, it does the following:</source>
          <target state="translated">Когда вызывается обратный вызов unlock-notify, что может происходить до того, как поток, &lt;a href=&quot;c3ref/unlock_notify&quot;&gt;вызвавший sqlite3_unlock_notify (),&lt;/a&gt; начинает ждать асинхронного сигнала, он выполняет следующие действия:</target>
        </trans-unit>
        <trans-unit id="b97add61bb2e4ac375ed3ff0cd6f248d8d0b370d" translate="yes" xml:space="preserve">
          <source>When the unlock-notify callback is issued, it is issued from within a call to sqlite3_step() (or sqlite3_close()) associated with the blocking connection. It is illegal to invoke any sqlite3_XXX() API functions from within an unlock-notify callback. The expected use is that the unlock-notify callback will signal some other waiting thread or schedule some action to take place later.</source>
          <target state="translated">При получении обратного вызова уведомления о разблокировке он выдается изнутри вызова sqlite3_step()(или sqlite3_close()),связанного с блокирующим соединением.Незаконно вызывать какие-либо API-функции sqlite3_XXX()из обратного вызова уведомления о разблокировке.Предполагается,что вызов уведомления о разблокировке будет сигнализировать о каком-либо другом ожидающем потоке или запланирует какое-либо действие,которое произойдет позже.</target>
        </trans-unit>
        <trans-unit id="c2be91d4a681af8f031fb2096b9f2fe184670aea" translate="yes" xml:space="preserve">
          <source>When the user does a &quot;File/Save&quot;, instead of overwriting the modified slides, the application can now make new entries in the SLIDE table for just those slides that have been added or altered. Then it creates a new entry in the VERSION table containing the revised manifest.</source>
          <target state="translated">Когда пользователь делает &quot;Файл/Сохранить&quot;,вместо перезаписи измененных слайдов,приложение теперь может делать новые записи в таблице SLIDE только для тех слайдов,которые были добавлены или изменены.Затем оно создает новую запись в таблице VERSION,содержащую измененный манифест.</target>
        </trans-unit>
        <trans-unit id="f5e82ec54c65035c07f8ba3e1f179ebb03a74e94" translate="yes" xml:space="preserve">
          <source>When the user presses the Undo button, invoke undo::undo. Invoke undo::redo when the user presses the Redo button.</source>
          <target state="translated">Когда пользователь нажимает кнопку Отменить,вызывает команду Отменить::Отменить.Спровоцировать undo::redo,когда пользователь нажимает кнопку Redo.</target>
        </trans-unit>
        <trans-unit id="1add060c475b241a7872da34e121430f601e3935" translate="yes" xml:space="preserve">
          <source>When the user scrolls down, the application needs to find the second set of 7 entries. One way to do this is to use the OFFSET clause:</source>
          <target state="translated">Когда пользователь прокручивает вниз,приложение должно найти второй набор из 7 записей.Одним из способов сделать это является использование пункта OFFSET:</target>
        </trans-unit>
        <trans-unit id="591f64272639e3cef4d6af5b9d0166c866e319e8" translate="yes" xml:space="preserve">
          <source>When the value of auto-vacuum is 2 or &quot;incremental&quot; then the additional information needed to do auto-vacuuming is stored in the database file but auto-vacuuming does not occur automatically at each commit as it does with auto_vacuum=full. In incremental mode, the separate &lt;a href=&quot;pragma#pragma_incremental_vacuum&quot;&gt;incremental_vacuum&lt;/a&gt; pragma must be invoked to cause the auto-vacuum to occur.</source>
          <target state="translated">Когда значение авто-вакуума равно 2 или &amp;laquo;инкрементный&amp;raquo;, тогда дополнительная информация, необходимая для выполнения автоматического вакуумирования, сохраняется в файле базы данных, но автоматическое очищение не происходит автоматически при каждой фиксации, как это происходит с auto_vacuum = full. В инкрементном режиме должна быть вызвана отдельная директива &lt;a href=&quot;pragma#pragma_incremental_vacuum&quot;&gt;incremental_vacuum,&lt;/a&gt; чтобы вызвать автоматический вакуум.</target>
        </trans-unit>
        <trans-unit id="681fab88c0ae33e7ccdb7976051e9eb1cbf3ae58" translate="yes" xml:space="preserve">
          <source>When the value returned to V is a string, space to hold that string is managed by the prepared statement S and will be automatically freed when S is finalized.</source>
          <target state="translated">Когда возвращаемое в V значение является строкой,пробел для удержания этой строки управляется подготовленным оператором S и автоматически освобождается,когда S заканчивается.</target>
        </trans-unit>
        <trans-unit id="676274b5ee061976c65b6934ef4f5a4fbd2b341f" translate="yes" xml:space="preserve">
          <source>When the wait_for_unlock_notify() thread is ready to begin waiting for the unlock-notify callback to arrive, it:</source>
          <target state="translated">Когда поток wait_for_unlock_notify()готов начать ожидание обратного вызова unlock-notify(),он:</target>
        </trans-unit>
        <trans-unit id="10e245699dbb244b04267cf604539f618d05ec7d" translate="yes" xml:space="preserve">
          <source>When there are &lt;a href=&quot;lang_attach&quot;&gt;attached databases&lt;/a&gt; and no database is specified in the pragma, all databases have their secure-delete setting altered. The secure-delete setting for newly attached databases is the setting of the main database at the time the ATTACH command is evaluated.</source>
          <target state="translated">Когда есть &lt;a href=&quot;lang_attach&quot;&gt;присоединенные базы данных&lt;/a&gt; и в прагме не указана никакая база данных, для всех баз данных изменяется настройка безопасного удаления. Параметр безопасного удаления для вновь подключенных баз данных - это параметр основной базы данных во время выполнения команды ATTACH.</target>
        </trans-unit>
        <trans-unit id="0e9e3d42daf92400d82986bf5b6a37eceed3828b" translate="yes" xml:space="preserve">
          <source>When this C-preprocessor macro is defined, SQLite includes some additional APIs that provide convenient access to meta-data about tables and queries. The APIs that are enabled by this option are:</source>
          <target state="translated">При задании этого макроса C-препроцессора в SQLite появились дополнительные API,обеспечивающие удобный доступ к мета-данным о таблицах и запросах.В качестве API,которые включены в эту опцию,можно назвать следующие:</target>
        </trans-unit>
        <trans-unit id="80b17e344d3336c6d06fda5d24a646acabeba334" translate="yes" xml:space="preserve">
          <source>When this function is called, the requested changeset is created using both the accumulated records and the current contents of the database file. Specifically:</source>
          <target state="translated">При вызове этой функции запрашиваемый набор изменений создается с использованием как накопленных записей,так и текущего содержимого файла базы данных.В частности:</target>
        </trans-unit>
        <trans-unit id="bb6586ef4ac72fe83222f833701701fa936feb91" translate="yes" xml:space="preserve">
          <source>When this is defined, the library does not respect the special database name &quot;:memory:&quot; (normally used to create an &lt;a href=&quot;inmemorydb&quot;&gt;in-memory database&lt;/a&gt;). If &quot;:memory:&quot; is passed to &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open16()&lt;/a&gt;, or &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;, a file with this name will be opened or created.</source>
          <target state="translated">Когда это определено, библиотека не уважает специальное имя базы данных &quot;: memory:&quot; (обычно используется для создания &lt;a href=&quot;inmemorydb&quot;&gt;базы данных в памяти&lt;/a&gt; ). Если &quot;: memory:&quot; передается в &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open ()&lt;/a&gt; , &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open16 ()&lt;/a&gt; или &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2 ()&lt;/a&gt; , файл с этим именем будет открыт или создан.</target>
        </trans-unit>
        <trans-unit id="9dadcf039e49017d2804dcadcaa92a2ed3ad29c4" translate="yes" xml:space="preserve">
          <source>When this is done, no disk file is opened. Instead, a new database is created purely in memory. The database ceases to exist as soon as the database connection is closed. Every :memory: database is distinct from every other. So, opening two database connections each with the filename &quot;:memory:&quot; will create two independent in-memory databases.</source>
          <target state="translated">После этого ни один из дисковых файлов не будет открыт.Вместо этого создается новая база данных исключительно в памяти.БД перестает существовать,как только закрывается соединение с БД.Каждая :память:БД отличается друг от друга.Таким образом,открытие двух соединений с БД,каждое с именем файла &quot;:memory:&quot;,создаст две независимые БД в памяти.</target>
        </trans-unit>
        <trans-unit id="3c612857bb421bf9acf60c3aa66716a6889b3ef9" translate="yes" xml:space="preserve">
          <source>When this option is defined in the &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt;, the &lt;a href=&quot;geopoly&quot;&gt;Geopoly extension&lt;/a&gt; is included in the build.</source>
          <target state="translated">Когда этот параметр определен в &lt;a href=&quot;amalgamation&quot;&gt;объединении&lt;/a&gt; , в &lt;a href=&quot;geopoly&quot;&gt;сборку включается расширение Geopoly&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="63b0e43097f54c25e3fe1c915efb4112c36433a7" translate="yes" xml:space="preserve">
          <source>When this option is defined in the &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt;, the &lt;a href=&quot;json1&quot;&gt;JSON SQL functions&lt;/a&gt; are added to the build automatically.</source>
          <target state="translated">Когда этот параметр определен в &lt;a href=&quot;amalgamation&quot;&gt;объединении&lt;/a&gt; , функции &lt;a href=&quot;json1&quot;&gt;JSON SQL&lt;/a&gt; добавляются в сборку автоматически.</target>
        </trans-unit>
        <trans-unit id="e638c666c14acfed829f561f8cba0197feda3c02" translate="yes" xml:space="preserve">
          <source>When this option is defined in the &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt;, version 3 of the full-text search engine is added to the build automatically.</source>
          <target state="translated">Когда этот параметр определен в &lt;a href=&quot;amalgamation&quot;&gt;объединении&lt;/a&gt; , версия 3 движка полнотекстового поиска добавляется в сборку автоматически.</target>
        </trans-unit>
        <trans-unit id="4a19c3b55092d529dbfec770d25a58e2ca349990" translate="yes" xml:space="preserve">
          <source>When this option is defined in the &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt;, versions 3 and 4 of the full-text search engine is added to the build automatically.</source>
          <target state="translated">Когда этот параметр определен в &lt;a href=&quot;amalgamation&quot;&gt;объединении&lt;/a&gt; , версии 3 и 4 системы полнотекстового поиска добавляются в сборку автоматически.</target>
        </trans-unit>
        <trans-unit id="818c376822c0fec952ac59c4332327f0b7edf7db" translate="yes" xml:space="preserve">
          <source>When this option is defined in the &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt;, versions 5 of the full-text search engine (&lt;a href=&quot;fts5&quot;&gt;fts5&lt;/a&gt;) is added to the build automatically.</source>
          <target state="translated">Когда этот параметр определен в &lt;a href=&quot;amalgamation&quot;&gt;объединении&lt;/a&gt; , версии 5 системы полнотекстового поиска ( &lt;a href=&quot;fts5&quot;&gt;fts5&lt;/a&gt; ) добавляются в сборку автоматически.</target>
        </trans-unit>
        <trans-unit id="6540ae2c93aba220c991dfe94132dd0f63e59810" translate="yes" xml:space="preserve">
          <source>When this option is defined, an optimization that accelerates counting all entries in a table (in other words, an optimization that helps &quot;SELECT count(*) FROM table&quot; run faster) is omitted.</source>
          <target state="translated">Когда эта опция определена,оптимизация,которая ускоряет подсчет всех записей в таблице (другими словами,оптимизация,которая помогает &quot;SELECT count(*)FROM table&quot; работать быстрее)опускается.</target>
        </trans-unit>
        <trans-unit id="53f492f476a20550a057a12a97c6de3049506d26" translate="yes" xml:space="preserve">
          <source>When this option is defined, it is not possible to specify a blob in an SQL statement using the X'ABCD' syntax.</source>
          <target state="translated">Когда эта опция определена,невозможно указать блок в SQL операторе,используя синтаксис X'ABCD'.</target>
        </trans-unit>
        <trans-unit id="afad8ea069f34c202a3e893171214a5aee9a0bc0" translate="yes" xml:space="preserve">
          <source>When this option is defined, the &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE&lt;/a&gt; command is not included in the library. Executing an &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE&lt;/a&gt; statement causes a parse error.</source>
          <target state="translated">Когда этот параметр определен, команда &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE&lt;/a&gt; не включается в библиотеку. Выполнение оператора &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE&lt;/a&gt; вызывает ошибку синтаксического анализа.</target>
        </trans-unit>
        <trans-unit id="523431ac75b0212a06c55ac385d13beeedacb305" translate="yes" xml:space="preserve">
          <source>When this option is defined, the &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; command is omitted from the build.</source>
          <target state="translated">Когда этот параметр определен, команда &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE не&lt;/a&gt; включается в сборку.</target>
        </trans-unit>
        <trans-unit id="594c7ba3832aba3180a92cd74c6f75ba44ce7aaf" translate="yes" xml:space="preserve">
          <source>When this option is defined, the &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; and &lt;a href=&quot;lang_detach&quot;&gt;DETACH&lt;/a&gt; commands are omitted from the build.</source>
          <target state="translated">Когда этот параметр определен, команды &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; и &lt;a href=&quot;lang_detach&quot;&gt;DETACH не&lt;/a&gt; включаются в сборку.</target>
        </trans-unit>
        <trans-unit id="8c1b711bd5c9246457da19791ca7b6dcb97ca5d2" translate="yes" xml:space="preserve">
          <source>When this option is defined, the &lt;a href=&quot;lang_reindex&quot;&gt;REINDEX&lt;/a&gt; command is not included in the library. Executing a &lt;a href=&quot;lang_reindex&quot;&gt;REINDEX&lt;/a&gt; statement causes a parse error.</source>
          <target state="translated">Когда этот параметр определен, команда &lt;a href=&quot;lang_reindex&quot;&gt;REINDEX&lt;/a&gt; не включается в библиотеку. Выполнение оператора &lt;a href=&quot;lang_reindex&quot;&gt;REINDEX&lt;/a&gt; вызывает ошибку синтаксического анализа.</target>
        </trans-unit>
        <trans-unit id="d2955f48905e9a8f58404484936cbf538b367034" translate="yes" xml:space="preserve">
          <source>When this option is defined, the &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; command is not included in the library. Executing a &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; statement causes a parse error.</source>
          <target state="translated">Когда этот параметр определен, команда &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; не включается в библиотеку. Выполнение оператора &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; вызывает ошибку синтаксического анализа.</target>
        </trans-unit>
        <trans-unit id="f189302742f5abf29172e2258e929a776e965db1" translate="yes" xml:space="preserve">
          <source>When this option is present, content contained in &lt;a href=&quot;fileformat2#ovflpgs&quot;&gt;overflow pages&lt;/a&gt; of the database file is read directly from disk, bypassing the &lt;a href=&quot;c3ref/pcache_methods2&quot;&gt;page cache&lt;/a&gt;, during read transactions. In applications that do a lot of reads of large BLOBs, this option might improve read performance.</source>
          <target state="translated">Когда этот параметр присутствует, содержимое, содержащееся на &lt;a href=&quot;fileformat2#ovflpgs&quot;&gt;страницах переполнения&lt;/a&gt; файла базы данных, читается непосредственно с диска, минуя &lt;a href=&quot;c3ref/pcache_methods2&quot;&gt;кеш страницы&lt;/a&gt; , во время транзакций чтения. В приложениях, которые выполняют много операций чтения больших двоичных объектов, этот параметр может повысить производительность чтения.</target>
        </trans-unit>
        <trans-unit id="05b6e594e4163ec73c013e9bc0bd201fec26dfcd" translate="yes" xml:space="preserve">
          <source>When this pragma is on, and the &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigdefensive&quot;&gt;SQLITE_DBCONFIG_DEFENSIVE&lt;/a&gt; flag is off, then the &lt;a href=&quot;fileformat2#sqlite_master&quot;&gt;sqlite_master&lt;/a&gt; table can be changed using ordinary &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;, &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;, and &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; statements. &lt;b&gt;Warning:&lt;/b&gt; misuse of this pragma can easily result in a &lt;a href=&quot;howtocorrupt#cfgerr&quot;&gt;corrupt database file&lt;/a&gt;.</source>
          <target state="translated">Когда эта прагма &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigdefensive&quot;&gt;включена&lt;/a&gt; , а флаг SQLITE_DBCONFIG_DEFENSIVE выключен, таблица &lt;a href=&quot;fileformat2#sqlite_master&quot;&gt;sqlite_master&lt;/a&gt; может быть изменена с помощью обычных операторов &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; , &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; и &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; . &lt;b&gt;Предупреждение:&lt;/b&gt; неправильное использование этой прагмы может легко привести к &lt;a href=&quot;howtocorrupt#cfgerr&quot;&gt;повреждению файла базы данных&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="155915a2fa0e144a28d6f3909aae6b1d4f21b4e3" translate="yes" xml:space="preserve">
          <source>When this pragma is on, and the &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigdefensive&quot;&gt;SQLITE_DBCONFIG_DEFENSIVE&lt;/a&gt; flag is off, then the &lt;a href=&quot;schematab&quot;&gt;sqlite_schema&lt;/a&gt; table can be changed using ordinary &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;, &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;, and &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; statements. &lt;b&gt;Warning:&lt;/b&gt; misuse of this pragma can easily result in a &lt;a href=&quot;howtocorrupt#cfgerr&quot;&gt;corrupt database file&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c24dad918c280682da96633e2cfedee92e2eb063" translate="yes" xml:space="preserve">
          <source>When three or more simple SELECTs are connected into a compound SELECT, they group from left to right. In other words, if &quot;A&quot;, &quot;B&quot; and &quot;C&quot; are all simple SELECT statements, (A op B op C) is processed as ((A op B) op C).</source>
          <target state="translated">Когда три или более простых SELECT соединены в составной SELECT,они группируются слева направо.Другими словами,если &quot;A&quot;,&quot;B&quot; и &quot;C&quot; являются простыми операторами SELECT,(A op B op C)обрабатываются как ((A op B)op C).</target>
        </trans-unit>
        <trans-unit id="356d225c15feaa12023968822303a920dbc04787" translate="yes" xml:space="preserve">
          <source>When to use WITHOUT ROWID</source>
          <target state="translated">Когда использовать БЕЗ СЕЙЧАСА.</target>
        </trans-unit>
        <trans-unit id="dde1df06f3e28fa2c213af6dc7ee811081acdcc1" translate="yes" xml:space="preserve">
          <source>When two BLOB values are compared, the result is determined using memcmp().</source>
          <target state="translated">При сравнении двух BLOB-значений результат определяется с помощью функции memcmp().</target>
        </trans-unit>
        <trans-unit id="3b7477ad4142a17a91342e502a66554eeeaf182c" translate="yes" xml:space="preserve">
          <source>When two or more connections access the same database in shared-cache mode, read and write (shared and exclusive) locks on individual tables are used to ensure that concurrently executing transactions are kept isolated. Before writing to a table, a write (exclusive) lock must be obtained on that table. Before reading, a read (shared) lock must be obtained. A connection releases all held table locks when it concludes its transaction. If a connection cannot obtain a required lock, then the call to &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; returns SQLITE_LOCKED.</source>
          <target state="translated">Когда два или более соединения обращаются к одной и той же базе данных в режиме общего кэша, используются блокировки чтения и записи (общие и исключительные) для отдельных таблиц, чтобы гарантировать изоляцию одновременно выполняющихся транзакций. Перед записью в таблицу необходимо получить (исключительную) блокировку записи для этой таблицы. Перед чтением необходимо получить блокировку чтения (разделяемую). После завершения транзакции соединение снимает все удерживаемые блокировки таблицы. Если соединение не может получить требуемую блокировку, тогда вызов &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step ()&lt;/a&gt; возвращает SQLITE_LOCKED.</target>
        </trans-unit>
        <trans-unit id="384b14b240303a8eaa803ae4a95a246eb3eb3a95" translate="yes" xml:space="preserve">
          <source>When two or more connections use a shared-cache, locks are used to serialize concurrent access attempts on a per-table basis. Tables support two types of locks, &quot;read-locks&quot; and &quot;write-locks&quot;. Locks are granted to connections - at any one time, each database connection has either a read-lock, write-lock or no lock on each database table.</source>
          <target state="translated">Когда два или более соединения используют общий кэш,блокировки используются для сериализации попыток одновременного доступа на каждый стол.Таблицы поддерживают два типа блокировок:&quot;чтение-блокировка&quot; и &quot;запись-блокировка&quot;.Замки предоставляются подключениям-в любое время каждое подключение к БД имеет либо &quot;read-lock&quot;,либо &quot;write-lock&quot;,либо не имеет блокировки на каждую таблицу БД.</target>
        </trans-unit>
        <trans-unit id="9ef3f52e6658347244503cf695a84d552443a0f6" translate="yes" xml:space="preserve">
          <source>When unlocking, the same SHARED or EXCLUSIVE flag must be supplied as was given on the corresponding lock.</source>
          <target state="translated">При разблокировке должен быть поставлен тот же флаг ШАРАНС или ЭКСКЛЮЗИВ,который был указан на соответствующем замке.</target>
        </trans-unit>
        <trans-unit id="c942e92dfd8f19ebf7cd74cbba74f891e087e57f" translate="yes" xml:space="preserve">
          <source>When updating the database file, SQLite always makes a copy of the page content into heap memory before modifying the page. This is necessary for two reasons. First, changes to the database are not supposed to be visible to other processes until after the transaction commits and so the changes must occur in private memory. Second, SQLite uses a read-only memory map to prevent stray pointers in the application from overwriting and corrupting the database file.</source>
          <target state="translated">При обновлении файла базы данных SQLite всегда делает копию содержимого страницы в памяти кучи перед ее модификацией.Это необходимо по двум причинам.Во-первых,изменения в БД должны быть видны другим процессам только после фиксации транзакции,поэтому изменения должны происходить в частной памяти.Во-вторых,SQLite использует карту памяти,доступную только для чтения,чтобы предотвратить перезапись и повреждение файла БД блуждающими указателями в приложении.</target>
        </trans-unit>
        <trans-unit id="321ab4dcceec298b077cdbf468b4b448206d5be8" translate="yes" xml:space="preserve">
          <source>When used in the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt;, the SQLITE_ENABLE_UNKNOWN_SQL_FUNCTION feature allows SQL text that contains application-defined functions to be pasted into the shell for analysis and debugging without having to create and load an extension that implements the application-defined functions.</source>
          <target state="translated">При использовании в &lt;a href=&quot;cli&quot;&gt;оболочке командной&lt;/a&gt; строки функция SQLITE_ENABLE_UNKNOWN_SQL_FUNCTION позволяет вставлять текст SQL, содержащий определяемые приложением функции, в оболочку для анализа и отладки без необходимости создавать и загружать расширение, реализующее определяемые приложением функции.</target>
        </trans-unit>
        <trans-unit id="4fb531d1e034498892c1e8ba5b02ac3bc138fb71" translate="yes" xml:space="preserve">
          <source>When using &lt;a href=&quot;mmap&quot;&gt;memory-mapped I/O&lt;/a&gt; map the database file read-only so that stray pointers and/or array overruns in the application cannot accidentally modify the database file.</source>
          <target state="translated">При использовании &lt;a href=&quot;mmap&quot;&gt;отображения ввода-вывода с&lt;/a&gt; отображением памяти отобразите файл базы данных только для чтения, чтобы случайные указатели и / или переполнения массива в приложении не могли случайно изменить файл базы данных.</target>
        </trans-unit>
        <trans-unit id="6bcae413d7ef24ed4791d379c4695938ecb30984" translate="yes" xml:space="preserve">
          <source>When using FTS4, specifying a column name that contains an &quot;=&quot; character and is not either a &quot;tokenize=*&quot; specification or a recognized FTS4 option is an error. With FTS3, the first token in the unrecognized directive is interpreted as a column name. Similarly, specifying multiple &quot;tokenize=*&quot; directives in a single table declaration is an error when using FTS4, whereas the second and subsequent &quot;tokenize=*&quot; directives are interpreted as column names by FTS3. For example:</source>
          <target state="translated">При использовании FTS4 указание имени столбца,содержащего символ &quot;=&quot; и не являющегося ни спецификацией &quot;tokenize=*&quot;,ни распознанной опцией FTS4,является ошибкой.В FTS3 первый маркер в нераспознанной директиве интерпретируется как имя столбца.Аналогично,указание нескольких директив &quot;tokenize=*&quot; в декларации одной таблицы является ошибкой при использовании FTS4,в то время как вторая и последующие директивы &quot;tokenize=*&quot; интерпретируются FTS3 как имена столбцов.Например:</target>
        </trans-unit>
        <trans-unit id="a2854ef2a0e9879ca0973bfbdbeb94518a7782b5" translate="yes" xml:space="preserve">
          <source>When using SQLite as a shared library, an application can test to see whether or not mutexes have been disabled using the &lt;a href=&quot;c3ref/threadsafe&quot;&gt;sqlite3_threadsafe()&lt;/a&gt; API. Applications that link against SQLite at run-time and use SQLite from multiple threads should probably check this API to make sure they did not accidentally get linked against a version of the SQLite library that has its mutexes disabled. Single-threaded applications will, of course, work correctly regardless of whether or not SQLite is configured to be threadsafe, though they will be a little bit faster when using versions of SQLite with mutexes disabled.</source>
          <target state="translated">При использовании SQLite в качестве разделяемой библиотеки приложение может проверить, отключены ли мьютексы, с помощью API &lt;a href=&quot;c3ref/threadsafe&quot;&gt;sqlite3_threadsafe ()&lt;/a&gt; . Приложения, которые связываются с SQLite во время выполнения и используют SQLite из нескольких потоков, вероятно, должны проверить этот API, чтобы убедиться, что они случайно не связаны с версией библиотеки SQLite, в которой отключены мьютексы. Однопоточные приложения, конечно, будут работать правильно, независимо от того, настроен ли SQLite как потокобезопасный, хотя они будут немного быстрее при использовании версий SQLite с отключенными мьютексами.</target>
        </trans-unit>
        <trans-unit id="baabf02615564e01474304f4466f9fe87599218a" translate="yes" xml:space="preserve">
          <source>When using an index on an expression, try to use expression values already available in the index, rather than loading the original columns and recomputing the expression.</source>
          <target state="translated">При использовании индекса в выражении постарайтесь использовать значения выражений,уже имеющихся в индексе,а не загружать исходные столбцы и не перевычислять выражение.</target>
        </trans-unit>
        <trans-unit id="468b6859516cde0950db73781d0176e06ba0111f" translate="yes" xml:space="preserve">
          <source>When using methods (2) or (3), it is important that the tokenizer only provide synonyms when tokenizing document text (method (2)) or query text (method (3)), not both. Doing so will not cause any errors, but is inefficient.</source>
          <target state="translated">При использовании методов (2)или (3)важно,чтобы токенайзер предоставлял синонимы только при токенировании текста документа (метод (2))или текста запроса (метод (3)),а не и того,и другого.Это не приведет к ошибкам,но неэффективно.</target>
        </trans-unit>
        <trans-unit id="88fac7db3e9db07076df4610515cb23f9340b834" translate="yes" xml:space="preserve">
          <source>When using the enhanced query syntax, parenthesis may be used to override the default precedence of the various operators. For example:</source>
          <target state="translated">При использовании расширенного синтаксиса запроса,скобки могут быть использованы для переопределения приоритета по умолчанию различных операторов.Например:</target>
        </trans-unit>
        <trans-unit id="1505c3324cb54c87924929ab65d11580dc89a0fd" translate="yes" xml:space="preserve">
          <source>When wrongful thoughts come into your heart, dash them against Christ immediately.</source>
          <target state="translated">Когда в твоё сердце приходят противоправные мысли,сразу же бросай их против Христа.</target>
        </trans-unit>
        <trans-unit id="5d95aef3b20c2c80bafbf5f8ecbb1090e555f684" translate="yes" xml:space="preserve">
          <source>When xSavepoint(X,N) is invoked, that is a signal to the virtual table X that it should save its current state as savepoint N. A subsequent call to xRollbackTo(X,R) means that the state of the virtual table should return to what it was when xSavepoint(X,R) was last called. The call to xRollbackTo(X,R) will invalidate all savepoints with N&amp;gt;R; none of the invalided savepoints will be rolled back or released without first being reinitialized by a call to xSavepoint(). A call to xRelease(X,M) invalidates all savepoints where N&amp;gt;=M.</source>
          <target state="translated">Когда вызывается xSavepoint (X, N), это сигнал виртуальной таблице X о том, что она должна сохранить свое текущее состояние как точку сохранения N. Последующий вызов xRollbackTo (X, R) означает, что состояние виртуальной таблицы должно вернуть к тому, что было при последнем вызове xSavepoint (X, R). Вызов xRollbackTo (X, R) сделает недействительными все точки сохранения с N&amp;gt; R; ни одна из недействительных точек сохранения не будет отменена или освобождена без предварительной повторной инициализации с помощью вызова xSavepoint (). Вызов xRelease (X, M) делает недействительными все точки сохранения, где N&amp;gt; = M.</target>
        </trans-unit>
        <trans-unit id="d7bf837f933ca19d45d60aebd942c6f51001215f" translate="yes" xml:space="preserve">
          <source>When you change the cache size using the cache_size pragma, the change only endures for the current session. The cache size reverts to the default value when the database is closed and reopened.</source>
          <target state="translated">Когда вы изменяете размер кэша с помощью прагмы cache_size,изменение длится только в течение текущего сеанса.Размер кэша возвращается к значению по умолчанию,когда база данных закрывается и открывается заново.</target>
        </trans-unit>
        <trans-unit id="b0e87a05754f1ec62d9fdd0b9342f0b467aa6d5b" translate="yes" xml:space="preserve">
          <source>When you do an insert into a table that does not have an INTEGER PRIMARY KEY column, or if the table does have an INTEGER PRIMARY KEY but the value for that column is not specified in the VALUES clause of the insert, then the key is automatically generated. You can find the value of the key for the most recent INSERT statement using the &lt;b&gt;sqlite_last_insert_rowid&lt;/b&gt; API function.</source>
          <target state="translated">Когда вы выполняете вставку в таблицу, в которой нет столбца INTEGER PRIMARY KEY, или если таблица имеет INTEGER PRIMARY KEY, но значение для этого столбца не указано в предложении VALUES вставки, то ключ автоматически генерируется. Вы можете найти значение ключа для последнего оператора INSERT с помощью &lt;b&gt;функции&lt;/b&gt; API &lt;b&gt;sqlite_last_insert_rowid&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="4e2ed89fd7ed9aabab05210ebf19395404532e3b" translate="yes" xml:space="preserve">
          <source>When you have a SQL script that you are debugging or trying to understand, it is often useful to run it in the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; with the &quot;.eqp full&quot; setting. When &quot;.eqp&quot; is set to FULL, the shell automatically shows the &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt; and &lt;a href=&quot;eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; output for each command prior to actually running that command.</source>
          <target state="translated">Когда у вас есть сценарий SQL, который вы отлаживаете или пытаетесь понять, часто бывает полезно запустить его в &lt;a href=&quot;cli&quot;&gt;оболочке командной строки&lt;/a&gt; с параметром &amp;laquo;.eqp full&amp;raquo;. Когда для &quot;.eqp&quot; установлено значение FULL, оболочка автоматически показывает выходные данные &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt; и &lt;a href=&quot;eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; для каждой команды до ее фактического выполнения.</target>
        </trans-unit>
        <trans-unit id="9a469065895a09048073186621e6fa156f1d430f" translate="yes" xml:space="preserve">
          <source>Whenever a &lt;a href=&quot;../pragma#syntax&quot; id=&quot;sqlitefcntlpragma&quot;&gt;PRAGMA&lt;/a&gt; statement is parsed, an &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlpragma&quot;&gt;SQLITE_FCNTL_PRAGMA&lt;/a&gt; file control is sent to the open &lt;a href=&quot;file&quot;&gt;sqlite3_file&lt;/a&gt; object corresponding to the database file to which the pragma statement refers. The argument to the &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlpragma&quot;&gt;SQLITE_FCNTL_PRAGMA&lt;/a&gt; file control is an array of pointers to strings (char**) in which the second element of the array is the name of the pragma and the third element is the argument to the pragma or NULL if the pragma has no argument. The handler for an &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlpragma&quot;&gt;SQLITE_FCNTL_PRAGMA&lt;/a&gt; file control can optionally make the first element of the char** argument point to a string obtained from &lt;a href=&quot;mprintf&quot;&gt;sqlite3_mprintf()&lt;/a&gt; or the equivalent and that string will become the result of the pragma or the error message if the pragma fails. If the &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlpragma&quot;&gt;SQLITE_FCNTL_PRAGMA&lt;/a&gt; file control returns &lt;a href=&quot;../rescode#notfound&quot;&gt;SQLITE_NOTFOUND&lt;/a&gt;, then normal &lt;a href=&quot;../pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt; processing continues. If the &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlpragma&quot;&gt;SQLITE_FCNTL_PRAGMA&lt;/a&gt; file control returns &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;, then the parser assumes that the VFS has handled the PRAGMA itself and the parser generates a no-op prepared statement if result string is NULL, or that returns a copy of the result string if the string is non-NULL. If the &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlpragma&quot;&gt;SQLITE_FCNTL_PRAGMA&lt;/a&gt; file control returns any result code other than &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; or &lt;a href=&quot;../rescode#notfound&quot;&gt;SQLITE_NOTFOUND&lt;/a&gt;, that means that the VFS encountered an error while handling the &lt;a href=&quot;../pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt; and the compilation of the PRAGMA fails with an error. The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlpragma&quot;&gt;SQLITE_FCNTL_PRAGMA&lt;/a&gt; file control occurs at the beginning of pragma statement analysis and so it is able to override built-in &lt;a href=&quot;../pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt; statements.</source>
          <target state="translated">При каждом &lt;a href=&quot;../pragma#syntax&quot; id=&quot;sqlitefcntlpragma&quot;&gt;анализе&lt;/a&gt; оператора &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlpragma&quot;&gt;PRAGMA&lt;/a&gt; файл управления SQLITE_FCNTL_PRAGMA отправляется открытому объекту &lt;a href=&quot;file&quot;&gt;sqlite3_file,&lt;/a&gt; соответствующему файлу базы данных, на который ссылается оператор pragma. Аргументом для &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlpragma&quot;&gt;файлового элемента&lt;/a&gt; управления SQLITE_FCNTL_PRAGMA является массив указателей на строки (char **), в котором второй элемент массива - это имя прагмы, а третий элемент - аргумент прагмы или NULL, если прагма не имеет аргумент. Обработчик для &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlpragma&quot;&gt;файлового элемента&lt;/a&gt; управления SQLITE_FCNTL_PRAGMA может дополнительно сделать первый элемент аргумента char **, указывающий на строку, полученную из &lt;a href=&quot;mprintf&quot;&gt;sqlite3_mprintf ()&lt;/a&gt;или эквивалент, и эта строка станет результатом прагмы или сообщения об ошибке, если прагма не сработает. Если &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlpragma&quot;&gt;SQLITE_FCNTL_PRAGMA&lt;/a&gt; управления файлами возвращает &lt;a href=&quot;../rescode#notfound&quot;&gt;SQLITE_NOTFOUND&lt;/a&gt; , то нормальная &lt;a href=&quot;../pragma#syntax&quot;&gt;ПРАГМА&lt;/a&gt; обработка продолжается. Если &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlpragma&quot;&gt;SQLITE_FCNTL_PRAGMA&lt;/a&gt; управление возвращается файл &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; , то парсер предполагает , что VFS обработал сам ПРАГМА и анализатор генерирует не-оп подготовленное заявление , если строка результата является NULL, или что возвращает копию строки результата , если строка не является -НОЛЬ. Если файловый элемент управления &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlpragma&quot;&gt;SQLITE_FCNTL_PRAGMA&lt;/a&gt; возвращает любой код результата, отличный от &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; или &lt;a href=&quot;../rescode#notfound&quot;&gt;SQLITE_NOTFOUND&lt;/a&gt;, это означает, что VFS обнаружила ошибку при обработке &lt;a href=&quot;../pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt; и компиляция PRAGMA завершилась ошибкой. Управление файлом &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlpragma&quot;&gt;SQLITE_FCNTL_PRAGMA&lt;/a&gt; происходит в начале анализа инструкций &lt;a href=&quot;../pragma#syntax&quot;&gt;прагмы,&lt;/a&gt; поэтому он может переопределить встроенные операторы PRAGMA .</target>
        </trans-unit>
        <trans-unit id="4f29909c26f83db47f3f77fe2f91d6b21b9cfb6d" translate="yes" xml:space="preserve">
          <source>Whenever a &lt;a href=&quot;pragma#syntax&quot; id=&quot;sqlitefcntlpragma&quot;&gt;PRAGMA&lt;/a&gt; statement is parsed, an &lt;a href=&quot;#sqlitefcntlpragma&quot;&gt;SQLITE_FCNTL_PRAGMA&lt;/a&gt; file control is sent to the open &lt;a href=&quot;#sqlite3_file&quot;&gt;sqlite3_file&lt;/a&gt; object corresponding to the database file to which the pragma statement refers. The argument to the &lt;a href=&quot;#sqlitefcntlpragma&quot;&gt;SQLITE_FCNTL_PRAGMA&lt;/a&gt; file control is an array of pointers to strings (char**) in which the second element of the array is the name of the pragma and the third element is the argument to the pragma or NULL if the pragma has no argument. The handler for an &lt;a href=&quot;#sqlitefcntlpragma&quot;&gt;SQLITE_FCNTL_PRAGMA&lt;/a&gt; file control can optionally make the first element of the char** argument point to a string obtained from &lt;a href=&quot;#sqlite3_mprintf&quot;&gt;sqlite3_mprintf()&lt;/a&gt; or the equivalent and that string will become the result of the pragma or the error message if the pragma fails. If the &lt;a href=&quot;#sqlitefcntlpragma&quot;&gt;SQLITE_FCNTL_PRAGMA&lt;/a&gt; file control returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOTFOUND&lt;/a&gt;, then normal &lt;a href=&quot;pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt; processing continues. If the &lt;a href=&quot;#sqlitefcntlpragma&quot;&gt;SQLITE_FCNTL_PRAGMA&lt;/a&gt; file control returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt;, then the parser assumes that the VFS has handled the PRAGMA itself and the parser generates a no-op prepared statement if result string is NULL, or that returns a copy of the result string if the string is non-NULL. If the &lt;a href=&quot;#sqlitefcntlpragma&quot;&gt;SQLITE_FCNTL_PRAGMA&lt;/a&gt; file control returns any result code other than &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; or &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOTFOUND&lt;/a&gt;, that means that the VFS encountered an error while handling the &lt;a href=&quot;pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt; and the compilation of the PRAGMA fails with an error. The &lt;a href=&quot;#sqlitefcntlpragma&quot;&gt;SQLITE_FCNTL_PRAGMA&lt;/a&gt; file control occurs at the beginning of pragma statement analysis and so it is able to override built-in &lt;a href=&quot;pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt; statements.</source>
          <target state="translated">При каждом &lt;a href=&quot;pragma#syntax&quot; id=&quot;sqlitefcntlpragma&quot;&gt;анализе&lt;/a&gt; оператора &lt;a href=&quot;#sqlitefcntlpragma&quot;&gt;PRAGMA&lt;/a&gt; файл управления SQLITE_FCNTL_PRAGMA отправляется открытому объекту &lt;a href=&quot;#sqlite3_file&quot;&gt;sqlite3_file,&lt;/a&gt; соответствующему файлу базы данных, на который ссылается оператор pragma. Аргументом для &lt;a href=&quot;#sqlitefcntlpragma&quot;&gt;файлового элемента&lt;/a&gt; управления SQLITE_FCNTL_PRAGMA является массив указателей на строки (char **), в котором второй элемент массива - это имя прагмы, а третий элемент - аргумент прагмы или NULL, если прагма не имеет аргумент. Обработчик для &lt;a href=&quot;#sqlitefcntlpragma&quot;&gt;файлового элемента&lt;/a&gt; управления SQLITE_FCNTL_PRAGMA может дополнительно сделать первый элемент аргумента char **, указывающий на строку, полученную из &lt;a href=&quot;#sqlite3_mprintf&quot;&gt;sqlite3_mprintf ()&lt;/a&gt;или эквивалент, и эта строка станет результатом прагмы или сообщения об ошибке, если прагма не сработает. Если &lt;a href=&quot;#sqlitefcntlpragma&quot;&gt;SQLITE_FCNTL_PRAGMA&lt;/a&gt; управления файлами возвращает &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOTFOUND&lt;/a&gt; , то нормальная &lt;a href=&quot;pragma#syntax&quot;&gt;ПРАГМА&lt;/a&gt; обработка продолжается. Если &lt;a href=&quot;#sqlitefcntlpragma&quot;&gt;SQLITE_FCNTL_PRAGMA&lt;/a&gt; управление возвращается файл &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; , то парсер предполагает , что VFS обработал сам ПРАГМА и анализатор генерирует не-оп подготовленное заявление , если строка результата является NULL, или что возвращает копию строки результата , если строка не является -НОЛЬ. Если файловый элемент управления &lt;a href=&quot;#sqlitefcntlpragma&quot;&gt;SQLITE_FCNTL_PRAGMA&lt;/a&gt; возвращает любой код результата, отличный от &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; или &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOTFOUND&lt;/a&gt;, это означает, что VFS обнаружила ошибку при обработке &lt;a href=&quot;pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt; и компиляция PRAGMA завершилась ошибкой. Управление файлом &lt;a href=&quot;#sqlitefcntlpragma&quot;&gt;SQLITE_FCNTL_PRAGMA&lt;/a&gt; происходит в начале анализа инструкций &lt;a href=&quot;pragma#syntax&quot;&gt;прагмы,&lt;/a&gt; поэтому он может переопределить встроенные операторы PRAGMA .</target>
        </trans-unit>
        <trans-unit id="7da0d908dd494a51e46851fa8be237351c85f11a" translate="yes" xml:space="preserve">
          <source>Whenever a bug is reported against SQLite, that bug is not considered fixed until new test cases that would exhibit the bug have been added to either the TCL or TH3 test suites. Over the years, this has resulted in thousands and thousands of new tests. These regression tests ensure that bugs that have been fixed in the past are not reintroduced into future versions of SQLite.</source>
          <target state="translated">Всякий раз,когда поступает сообщение об ошибке в SQLite,эта ошибка не считается исправленной до тех пор,пока новые тестовые случаи,в которых была бы обнаружена ошибка,не будут добавлены в наборы тестов TCL или TH3.С годами это привело к тысячам и тысячам новых тестов.Эти регрессионные тесты гарантируют,что ошибки,которые были исправлены в прошлом,не будут повторно внедрены в будущие версии SQLite.</target>
        </trans-unit>
        <trans-unit id="33e01584f09cbc3030c7fddae4886376aff67c9e" translate="yes" xml:space="preserve">
          <source>Whenever a database is opened, the entire schema is scanned and parsed and a parse tree for the schema is held in memory. That means that database connection startup time and initial memory usage is proportional to the size of the schema.</source>
          <target state="translated">Всякий раз,когда открывается база данных,сканируется и анализируется вся схема,а в памяти хранится дерево разбора схемы.Это означает,что время запуска соединения с БД и начальное использование памяти пропорционально размеру схемы.</target>
        </trans-unit>
        <trans-unit id="497ecda91e171119dde556e568de3183a8cb8f6e" translate="yes" xml:space="preserve">
          <source>Whenever a row in the parent table of a foreign key constraint is deleted, or when the values stored in the parent key column or columns are modified, the logical sequence of events is:</source>
          <target state="translated">Всякий раз,когда строка в родительской таблице ограничения постороннего ключа удаляется,или когда изменяются значения,хранящиеся в столбце или столбцах родительского ключа,логическая последовательность событий:</target>
        </trans-unit>
        <trans-unit id="0a37cacf0c7e51e3db57f63b99d51f003b150071" translate="yes" xml:space="preserve">
          <source>Whenever a write operation occurs, the writer checks how much progress the checkpointer has made, and if the entire WAL has been transferred into the database and synced and if no readers are making use of the WAL, then the writer will rewind the WAL back to the beginning and start putting new transactions at the beginning of the WAL. This mechanism prevents a WAL file from growing without bound.</source>
          <target state="translated">Всякий раз,когда происходит операция записи,пишущий проверяет,насколько успешно работает контрольный указатель,и если весь WAL был перенесен в базу данных и синхронизирован,и если ни один из читателей не использует WAL,то пишущий перемотает WAL обратно в начало и начнет ставить новые транзакции в начало WAL.Этот механизм предотвращает рост файла WAL без привязки.</target>
        </trans-unit>
        <trans-unit id="343d6f171b30e5570b4ea710189ea4bcc234b168" translate="yes" xml:space="preserve">
          <source>Whenever another row of result data is available, &lt;b&gt;sqlite_step&lt;/b&gt; will return SQLITE_ROW. The row data is stored in an array of pointers to strings and the 2nd parameter is made to point to this array.</source>
          <target state="translated">Всякий раз, когда доступна другая строка данных результата, &lt;b&gt;sqlite_step&lt;/b&gt; вернет SQLITE_ROW. Данные строки хранятся в массиве указателей на строки, а второй параметр указывает на этот массив.</target>
        </trans-unit>
        <trans-unit id="be09d2acec84e8312793d7710565bb42fe503a39" translate="yes" xml:space="preserve">
          <source>Whenever comparing SQLite to other SQL database engines like SQL Server, PostgreSQL, MySQL, or Oracle, it is important first of all to realize that SQLite is not intended as a replacement or competitor to any of those systems. SQLite is &lt;a href=&quot;serverless&quot;&gt;serverless&lt;/a&gt;. There is no separate server process that manages the database. An application interacts with the database engine using function calls, not by sending messages to a separate process or thread.</source>
          <target state="translated">Каждый раз, сравнивая SQLite с другими механизмами баз данных SQL, такими как SQL Server, PostgreSQL, MySQL или Oracle, важно прежде всего понимать, что SQLite не предназначен в качестве замены или конкурента какой-либо из этих систем. SQLite &lt;a href=&quot;serverless&quot;&gt;бессерверный&lt;/a&gt; . Нет отдельного серверного процесса, который управляет базой данных. Приложение взаимодействует с ядром базы данных с помощью вызовов функций, а не путем отправки сообщений в отдельный процесс или поток.</target>
        </trans-unit>
        <trans-unit id="17a11b6e3fb65c86a99e26ed1e561497e95a4bf4" translate="yes" xml:space="preserve">
          <source>Whenever the database schema changes, prepared statements are automatically reprepared to accommodate the new schema. There is a race condition here in that if one thread is constantly changing the schema, another thread might spin on reparses and repreparations of a prepared statement and never get any real work done. This parameter prevents an infinite loop by forcing the spinning thread to give up after a fixed number of attempts at recompiling the prepared statement. The default setting is 50 which is more than adequate for most applications.</source>
          <target state="translated">Всякий раз,когда изменяется схема базы данных,подготовленные ведомости автоматически переподготавливаются с учетом новой схемы.Здесь существует состояние гонки,при котором,если один поток постоянно изменяет схему,то другой поток может вращаться на репозиториях и репликах подготовленного утверждения и никогда не получит реальной работы.Этот параметр предотвращает бесконечный цикл,заставляя вращающийся поток сдаваться после фиксированного количества попыток перекомпиляции подготовленного оператора.Параметр по умолчанию равен 50,что более чем адекватно для большинства приложений.</target>
        </trans-unit>
        <trans-unit id="5bd2a09557636d477221b6346f70a36e1b45532a" translate="yes" xml:space="preserve">
          <source>Where &quot;column&quot; is a column in the virtual table, OP is an operator like &quot;=&quot; or &quot;&amp;lt;&quot;, and EXPR is an arbitrary expression. So, for example, if the WHERE clause contained a term like this:</source>
          <target state="translated">Где &amp;laquo;столбец&amp;raquo; - это столбец в виртуальной таблице, OP - это оператор типа &amp;laquo;=&amp;raquo; или &amp;laquo;&amp;lt;&amp;raquo;, а EXPR - произвольное выражение. Так, например, если предложение WHERE содержало такой термин:</target>
        </trans-unit>
        <trans-unit id="43f8cd7ec518821d99337a406b14b6ad25458172" translate="yes" xml:space="preserve">
          <source>Where &amp;lt;tokenizer-name&amp;gt; is &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameter&lt;/a&gt; to which a string is bound using &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_text()&lt;/a&gt; where the string identifies the tokenizer and &amp;lt;sqlite3_tokenizer_module ptr&amp;gt; is a &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameter&lt;/a&gt; to which a BLOB is bound using &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_blob()&lt;/a&gt; where the value of the BLOB is a pointer to an sqlite3_tokenizer_module structure. If the second argument is present, it is registered as tokenizer &amp;lt;tokenizer-name&amp;gt; and a copy of it returned. If only one argument is passed, a pointer to the tokenizer implementation currently registered as &amp;lt;tokenizer-name&amp;gt; is returned, encoded as a blob. Or, if no such tokenizer exists, an SQL exception (error) is raised.</source>
          <target state="translated">Где &amp;lt;tokenizer-name&amp;gt; - это &lt;a href=&quot;lang_expr#varparam&quot;&gt;параметр,&lt;/a&gt; к которому строка привязывается с помощью &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_text (),&lt;/a&gt; где строка идентифицирует токенизатор, а &amp;lt;sqlite3_tokenizer_module ptr&amp;gt; - это &lt;a href=&quot;lang_expr#varparam&quot;&gt;параметр,&lt;/a&gt; к которому привязывается BLOB с помощью &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_blob (),&lt;/a&gt; где значение BLOB - это указатель на структуру sqlite3_tokenizer_module. Если присутствует второй аргумент, он регистрируется как tokenizer &amp;lt;tokenizer-name&amp;gt; и возвращается его копия. Если передан только один аргумент, возвращается указатель на реализацию токенизатора, в настоящее время зарегистрированную как &amp;lt;имя-токенизатора&amp;gt;, в кодировке как большой двоичный объект. Или, если такого токенизатора не существует, возникает исключение (ошибка) SQL.</target>
        </trans-unit>
        <trans-unit id="fe664b79065efef56eb19d94f1c82054f533c78c" translate="yes" xml:space="preserve">
          <source>Where VERSION can be a branch name (like &quot;trunk&quot; or &quot;session&quot;) to get the latest check-in on a specific branch, or VERSION can be a SHA1 hash or a prefix of a SHA1 hash for a specific check-in, or VERSION can be a tag such as &quot;version-3.8.8&quot;. Every time you run &quot;fossil update&quot; it will automatically reach out to the original repository at http://www.sqlite.org/cgi/src to obtain new check-ins that might have been made by others since your previous update.</source>
          <target state="translated">Где VERSION может быть именем ответвления (например,&quot;ствол&quot; или &quot;сессия&quot;)для получения последней регистрации в определённом ответвлении,или VERSION может быть хэшем SHA1 или префиксом хэша SHA1 для определённой регистрации,или VERSION может быть тегом,например,&quot;версия-3.8.8&quot;.Каждый раз,когда вы запускаете &quot;fossil update&quot;,он автоматически обращается к исходному репозиторию по адресу http://www.sqlite.org/cgi/src для получения новых регистраций,которые могли быть сделаны другими пользователями со времени вашего предыдущего обновления.</target>
        </trans-unit>
        <trans-unit id="62f2d871248b60ca56135b923987b70f9385647b" translate="yes" xml:space="preserve">
          <source>Where this ends up causing problems is when developers do some initial coding work using SQLite and get their application working, but then try to convert to another database like PostgreSQL or SQL Server for deployment. If the application is initially taking advantage of SQLite's flexible typing, then it will fail when moved to another database that uses a more rigid and unforgiving type enforcement policy.</source>
          <target state="translated">Когда это приводит к проблемам,разработчики выполняют некоторую начальную работу по кодированию с помощью SQLite и заставляют свое приложение работать,а затем пытаются преобразовать его в другую базу данных,такую как PostgreSQL или SQL Server,для развертывания.Если приложение изначально использует преимущества гибкого набора текста в SQLite,то при переходе на другую БД,использующую более жесткую и непрощающую политику набора текста,оно терпит неудачу.</target>
        </trans-unit>
        <trans-unit id="c5d4b5d864c31b29da8aa7f64d89028ed5c76cfd" translate="yes" xml:space="preserve">
          <source>Whether it is parsing document or query text, any call to xToken that specifies a</source>
          <target state="translated">Будь то анализ документа или текст запроса,любой вызов xToken,который указывает на</target>
        </trans-unit>
        <trans-unit id="79b58773d42ad0674454e81345e3b00864854d60" translate="yes" xml:space="preserve">
          <source>Whether or not &quot;char&quot; variables are signed or unsigned.</source>
          <target state="translated">Подписанные или неподписанные переменные &quot;char&quot;.</target>
        </trans-unit>
        <trans-unit id="927824fe8759e5b1e1a630b01c62f6b1e890e24a" translate="yes" xml:space="preserve">
          <source>Whether or not an error occurs when it is opened, resources associated with the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; handle should be released by passing it to &lt;a href=&quot;#sqlite3_close&quot;&gt;sqlite3_close()&lt;/a&gt; when it is no longer required.</source>
          <target state="translated">Независимо от того, возникает ли ошибка при открытии, ресурсы, связанные с дескриптором &lt;a href=&quot;#sqlite3&quot;&gt;соединения&lt;/a&gt; с базой данных, должны быть освобождены путем передачи его в &lt;a href=&quot;#sqlite3_close&quot;&gt;sqlite3_close (),&lt;/a&gt; когда он больше не требуется.</target>
        </trans-unit>
        <trans-unit id="568677ded3b331843b99c68cc439cfb12004ddef" translate="yes" xml:space="preserve">
          <source>Whether or not an error occurs when it is opened, resources associated with the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; handle should be released by passing it to &lt;a href=&quot;close&quot;&gt;sqlite3_close()&lt;/a&gt; when it is no longer required.</source>
          <target state="translated">Независимо от того, возникает ли ошибка при открытии, ресурсы, связанные с дескриптором &lt;a href=&quot;sqlite3&quot;&gt;соединения&lt;/a&gt; с базой данных, должны быть освобождены путем передачи его в &lt;a href=&quot;close&quot;&gt;sqlite3_close (),&lt;/a&gt; когда он больше не требуется.</target>
        </trans-unit>
        <trans-unit id="bb05885439d11af94b4bcc3db20e0753f97a131e" translate="yes" xml:space="preserve">
          <source>Whether or not an index or &lt;a href=&quot;optoverview#autoindex&quot;&gt;automatic index&lt;/a&gt; is used.</source>
          <target state="translated">Независимо от того, используется ли индекс или &lt;a href=&quot;optoverview#autoindex&quot;&gt;автоматический индекс&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="35e3585051eb4909e3fe069dd52d9c306b089c84" translate="yes" xml:space="preserve">
          <source>Whether or not the &lt;a href=&quot;queryplanner#covidx&quot;&gt;covering index&lt;/a&gt; optimization applies.</source>
          <target state="translated">Независимо от того или нет &lt;a href=&quot;queryplanner#covidx&quot;&gt;покрытия индекса&lt;/a&gt; применяется оптимизация.</target>
        </trans-unit>
        <trans-unit id="3f452c9d36fa06b25992734adfdfc328c0c7c82f" translate="yes" xml:space="preserve">
          <source>Whether or not the backup process is restarted as a result of writes to the source database mid-backup, the user can be sure that when the backup operation is completed the backup database contains a consistent and up-to-date snapshot of the original. However:</source>
          <target state="translated">Независимо от того,будет ли процесс резервного копирования перезапущен в результате записи в исходную базу данных в середине резервного копирования,пользователь может быть уверен,что после завершения операции резервного копирования база данных содержит последовательный и актуальный снимок исходной базы данных.Однако:</target>
        </trans-unit>
        <trans-unit id="805314d6ba3c8452666efff3bc4e2e9c11e54c17" translate="yes" xml:space="preserve">
          <source>Whether the table is a &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; table.</source>
          <target state="translated">Является ли таблица таблицей &lt;a href=&quot;withoutrowid&quot;&gt;БЕЗ ROWID&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="15cc066f01fd0a8910ef52b96a08c5f23129c75a" translate="yes" xml:space="preserve">
          <source>Which module, FTS3 or FTS4, should you use in your application? FTS4 is sometimes significantly faster than FTS3, even orders of magnitude faster depending on the query, though in the common case the performance of the two modules is similar. FTS4 also offers the enhanced &lt;a href=&quot;fts3#matchinfo&quot;&gt;matchinfo()&lt;/a&gt; outputs which can be useful in ranking the results of a &lt;a href=&quot;fts3#full_text_index_queries&quot;&gt;MATCH&lt;/a&gt; operation. On the other hand, in the absence of a &lt;a href=&quot;fts3#fts4matchinfo&quot;&gt;matchinfo=fts3&lt;/a&gt; directive FTS4 requires a little more disk space than FTS3, though only a percent of two in most cases.</source>
          <target state="translated">Какой модуль, FTS3 или FTS4, следует использовать в своем приложении? FTS4 иногда значительно быстрее, чем FTS3, даже на несколько порядков быстрее в зависимости от запроса, хотя в общем случае производительность двух модулей схожа. FTS4 также предлагает расширенные &lt;a href=&quot;fts3#matchinfo&quot;&gt;выходные данные matchinfo (),&lt;/a&gt; которые могут быть полезны при ранжировании результатов операции &lt;a href=&quot;fts3#full_text_index_queries&quot;&gt;MATCH&lt;/a&gt; . С другой стороны, в отсутствие директивы &lt;a href=&quot;fts3#fts4matchinfo&quot;&gt;matchinfo = fts3 для&lt;/a&gt; FTS4 требуется немного больше дискового пространства, чем для FTS3, хотя в большинстве случаев это всего лишь процент от двух.</target>
        </trans-unit>
        <trans-unit id="1eaf1dfe15540108a1d6bb4cc98824a6bb754fe0" translate="yes" xml:space="preserve">
          <source>Which of those columns are PRIMARY KEY columns.</source>
          <target state="translated">Какая из этих колонок-колонка PRIMARY KEY.</target>
        </trans-unit>
        <trans-unit id="2bf977231fee9d5a01c1d56cb42302f6abc78241" translate="yes" xml:space="preserve">
          <source>Which of those columns make up the tables PRIMARY KEY.</source>
          <target state="translated">Какие из этих столбцов составляют столы ПРИМАРИ КЕЙ.</target>
        </trans-unit>
        <trans-unit id="65190c6c06c3156a5ce50576cd97088b8788cba3" translate="yes" xml:space="preserve">
          <source>Which terms of the WHERE clause are used for indexing.</source>
          <target state="translated">Какие термины пункта WHERE используются для индексирования.</target>
        </trans-unit>
        <trans-unit id="7d607a9e2bbeeff588fac8037da7b126ad5bde90" translate="yes" xml:space="preserve">
          <source>Which works out to be:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5778f90619b883572d8c026a15fd3403dfe6662c" translate="yes" xml:space="preserve">
          <source>While SQL is a programming language, it is different from other programming languages like C, Javascript, Python, or Go in that SQL is a &lt;a href=&quot;https://en.wikipedia.org/wiki/Declarative_programming&quot;&gt;declarative language&lt;/a&gt; where the others are &lt;a href=&quot;https://en.wikipedia.org/wiki/Imperative_programming&quot;&gt;imperative languages&lt;/a&gt;. This is an important difference that has implications for the design of the compiler used to translate program source text into an executable format. However, those details should not detract from the fact that SQL is really just another programming language.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ada2cef428bad4df299c966d8cc7b1305373853" translate="yes" xml:space="preserve">
          <source>While a &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; is open on a WAL-mode database, SQLite maintains an extra journal file called a &quot;Write Ahead Log&quot; or &quot;WAL File&quot;. The name of this file on disk is usually the name of the database file with an extra &quot;&lt;code&gt;-wal&lt;/code&gt;&quot; suffix, though different naming rules may apply if SQLite is compiled with &lt;a href=&quot;compile#enable_8_3_names&quot;&gt;SQLITE_ENABLE_8_3_NAMES&lt;/a&gt;.</source>
          <target state="translated">Пока &lt;a href=&quot;c3ref/sqlite3&quot;&gt;соединение&lt;/a&gt; с базой данных открыто для базы данных в режиме WAL, SQLite поддерживает дополнительный файл журнала, называемый &amp;laquo;Журнал предварительной записи&amp;raquo; или &amp;laquo;Файл WAL&amp;raquo;. Имя этого файла на диске обычно является именем файла базы данных с дополнительным суффиксом &amp;laquo; &lt;code&gt;-wal&lt;/code&gt; &amp;raquo;, хотя могут применяться другие правила именования, если SQLite скомпилирован с &lt;a href=&quot;compile#enable_8_3_names&quot;&gt;SQLITE_ENABLE_8_3_NAMES&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d7e2ba9f3191758fdb3ad9b114fa10eb9a4ed3b0" translate="yes" xml:space="preserve">
          <source>While a read transaction is active, any changes to the database that are implemented by separate database connections will not be seen by the database connection that started the read transaction. If database connection X is holding a read transaction, it is possible that some other database connection Y might change the content of the database while X's transaction is still open, however X will not be able to see those changes until after the transaction ends. While its read transaction is active, X will continue to see an historic snapshot of the database prior to the changes implemented by Y.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ffdc80fe0f26846179a6aaa2eb484325f365e70" translate="yes" xml:space="preserve">
          <source>While a read transaction is active, any changes to the database that are implemented by separate database connections will not be seen by the database connection that started the read transaction. If database connection X is holding a read transaction, it is possible that some other database connection Y might change the content of the database while X's transaction is still open, however X will not be able to see those changes until after the transaction ends. While its read transaction is active, X will continue to see an historic snapshot the database prior to the changes implemented by Y.</source>
          <target state="translated">В то время как прочитанная транзакция активна,любые изменения в БД,которые осуществляются отдельными подключениями к БД,не будут видны подключениям к БД,которые запустили прочитанную транзакцию.Если соединение с базой данных X содержит прочитанную транзакцию,возможно,что какое-то другое соединение с базой данных Y может изменить содержимое базы данных,в то время как транзакция X все еще открыта,однако X не сможет увидеть эти изменения до окончания транзакции.В то время как прочитанная транзакция активна,X будет продолжать видеть исторический снимок базы данных до изменений,выполненных Y.</target>
        </trans-unit>
        <trans-unit id="3fc81a6b9eff77dec03d524ff1a744befb138ec8" translate="yes" xml:space="preserve">
          <source>While compiling a single SQL query, the SQLite core might call xBestIndex multiple times with different settings in &lt;a href=&quot;c3ref/index_info&quot;&gt;sqlite3_index_info&lt;/a&gt;. The SQLite core will then select the combination that appears to give the best performance.</source>
          <target state="translated">При компиляции одного SQL-запроса ядро ​​SQLite может вызывать xBestIndex несколько раз с разными настройками в &lt;a href=&quot;c3ref/index_info&quot;&gt;sqlite3_index_info&lt;/a&gt; . Затем ядро ​​SQLite выберет комбинацию, которая, по всей видимости, обеспечивает наилучшую производительность.</target>
        </trans-unit>
        <trans-unit id="d6f8e366ea836d249425f55c0048ab7dd0869350" translate="yes" xml:space="preserve">
          <source>While fuzz testing and 100% MC/DC testing are in tension, they are not completely at cross-purposes. The fact that the SQlite test suite does test to 100% MC/DC means that when fuzzers do find problems, those problems can be fixed quickly and with little risk of introducing new errors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84aa771f4f176659ae1924e0a87ff5ad8203b073" translate="yes" xml:space="preserve">
          <source>While opening a</source>
          <target state="translated">При открытии</target>
        </trans-unit>
        <trans-unit id="9b36f93bab56bb7da15a9179ec0943945f846c1b" translate="yes" xml:space="preserve">
          <source>While performing</source>
          <target state="translated">В процессе выполнения</target>
        </trans-unit>
        <trans-unit id="96921c80759d36f4a04b6a82e193c5ddf054ac5c" translate="yes" xml:space="preserve">
          <source>While the original idea being CVEs is sound, the current processes for creating and managing CVEs are inadequate. There are countless grey-hat hackers running fuzzers against a wide-variety of open-source software products (SQLite as well as many others) and writing up CVEs against any problems they find. The grey-hats are rewarded, sometimes with prestige and sometimes financially, by the number and severity of the CVEs they write. This incentive results in a proliferation of CVEs which are often not well-vetted and which can have exaggerated impact claims. The quality-control procedures for CVEs are unable to cope with this flood of inputs, making it difficult to correct exaggerated, misleading, omitted, or inaccurate claims.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a93a15284084502a7f86f4c9b90c793ee720848" translate="yes" xml:space="preserve">
          <source>While the queue is not empty:</source>
          <target state="translated">Пока очередь не пуста:</target>
        </trans-unit>
        <trans-unit id="31d87d7be7b237cc74cece1001ddf141c8c0c304" translate="yes" xml:space="preserve">
          <source>Whitespace and comment tokens are discarded. All other tokens are fed into an &lt;a href=&quot;https://en.wikipedia.org/wiki/LALR_parser&quot;&gt;LALR(1) Parser&lt;/a&gt; that analysis the structure of the input program and generates an &lt;a href=&quot;https://en.wikipedia.org/wiki/Abstract_syntax_tree&quot;&gt;Abstract Syntax Tree (AST)&lt;/a&gt; for the input program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b875e5298cf6263e72c1bc4d0e00a3e4a13f0a5d" translate="yes" xml:space="preserve">
          <source>Whitespace or comments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d2467596fdde02a218277dc3baed1d04b31fd9e" translate="yes" xml:space="preserve">
          <source>Why ALTER TABLE is so difficult</source>
          <target state="translated">Почему АЛЬТЕР-ТАБЛИЦА так сложна</target>
        </trans-unit>
        <trans-unit id="a66e4df98a00d586d77ff8cbda05b1bb33741627" translate="yes" xml:space="preserve">
          <source>Why ALTER TABLE is such a problem for SQLite</source>
          <target state="translated">Почему ALTER TABLE-это такая проблема для SQLite?</target>
        </trans-unit>
        <trans-unit id="51671cd80abfeae9d7b51e113f2b9ee1f5d2c38e" translate="yes" xml:space="preserve">
          <source>Why Is SQLite Coded In C</source>
          <target state="translated">Почему SQLite закодирован на C</target>
        </trans-unit>
        <trans-unit id="a50fb31b169e8e4d9b4a6643f7f8608e036bc60b" translate="yes" xml:space="preserve">
          <source>Why SQLite Does Not Use Git</source>
          <target state="translated">Почему SQLite не использует Git</target>
        </trans-unit>
        <trans-unit id="cf48c0996bab18f4950cd87af9617143917f12a9" translate="yes" xml:space="preserve">
          <source>Why didn't the legacy query planner choose algorithm-2? Easy: because the NN algorithm never even considered algorithm-2. Graphs of the planning problem look like this:</source>
          <target state="translated">Почему старый планировщик запросов не выбрал алгоритм-2? Легко:потому что алгоритм NN даже не рассматривал алгоритм-2.Графики проблемы планирования выглядят так:</target>
        </trans-unit>
        <trans-unit id="f9ddc1f9321acc62d313f21bd009fd732a7ca677" translate="yes" xml:space="preserve">
          <source>Why does ROUND(9.95,1) return 9.9 instead of 10.0? Shouldn't 9.95 round up?</source>
          <target state="translated">Почему ROUND(9,95,1)возвращает 9,9 вместо 10,0? Разве 9,95 не должно округляться?</target>
        </trans-unit>
        <trans-unit id="cf08e93e3998487d5a4514d0ec927b65fe1810fa" translate="yes" xml:space="preserve">
          <source>Why does SQLite have its own private built-in printf() implementation? Why not use the printf() implementation from the standard C library? Several reasons:</source>
          <target state="translated">Почему SQLite имеет свою собственную частную встроенную реализацию printf()? Почему бы не использовать реализацию printf()из стандартной библиотеки C? Несколько причин:</target>
        </trans-unit>
        <trans-unit id="1ec9acf7734149243e8c44660fc685f0eb23a630" translate="yes" xml:space="preserve">
          <source>Why doesn't SQLite allow me to use '0' and '0.0' as the primary key on two different rows of the same table?</source>
          <target state="translated">Почему SQLite не позволяет мне использовать '0' и '0.0' в качестве первичного ключа на двух разных строках одной и той же таблицы?</target>
        </trans-unit>
        <trans-unit id="02275b1d64f346b7ea26ca7a800967bbade4e5f6" translate="yes" xml:space="preserve">
          <source>Win32 Directory Types</source>
          <target state="translated">Типы каталогов Win32</target>
        </trans-unit>
        <trans-unit id="0463d1ccc9613d5098c42774fc7e43131ce95d1e" translate="yes" xml:space="preserve">
          <source>Win32 Specific Interface</source>
          <target state="translated">Специфический интерфейс Win32</target>
        </trans-unit>
        <trans-unit id="f8b7523500f54721211a692b3d6b968bab3101a5" translate="yes" xml:space="preserve">
          <source>Win32 native memory allocator</source>
          <target state="translated">аллокатор native memory Win32</target>
        </trans-unit>
        <trans-unit id="68fe8f958724479a101c0326f7607d389d321758" translate="yes" xml:space="preserve">
          <source>Window Functions</source>
          <target state="translated">Оконные функции</target>
        </trans-unit>
        <trans-unit id="7973e6ebbc857b7bb0de6b349ffa9e99bc62f773" translate="yes" xml:space="preserve">
          <source>Window chaining</source>
          <target state="translated">Привязка к окну</target>
        </trans-unit>
        <trans-unit id="99565b4d7904c206a1623d09463276b2f7b9b151" translate="yes" xml:space="preserve">
          <source>Window chaining is a shorthand that allows one window to be defined in terms of another. Specifically, the shorthand allows the new window to implicitly copy the PARTITION BY and optionally ORDER BY clauses of the base window. For example, in the following:</source>
          <target state="translated">Цепочки окон-это сокращение,позволяющее определить одно окно в терминах другого.В частности,это сокращение позволяет новому окну неявно скопировать УЧАСТНИК ПО и,опционально,ЗАПРЕЩИТЬ ПО клаузулам базового окна.Например,в следующем:</target>
        </trans-unit>
        <trans-unit id="34aa1477a928d2146e07a6620c66855ebe78ae81" translate="yes" xml:space="preserve">
          <source>Window function support was first added to SQLite with release &lt;a href=&quot;https://sqlite.org/releaselog/3_25_0.html&quot;&gt;version 3.25.0&lt;/a&gt; (2018-09-15). The SQLite developers used the &lt;a href=&quot;http://www.postgresql.org&quot;&gt;PostgreSQL&lt;/a&gt; window function documentation as their primary reference for how window functions ought to behave. Many test cases have been run against PostgreSQL to ensure that window functions operate the same way in both SQLite and PostgreSQL.</source>
          <target state="translated">Поддержка оконных функций впервые была добавлена ​​в SQLite в &lt;a href=&quot;https://sqlite.org/releaselog/3_25_0.html&quot;&gt;версии 3.25.0&lt;/a&gt; (2018-09-15). Разработчики SQLite использовали документацию по оконным функциям &lt;a href=&quot;http://www.postgresql.org&quot;&gt;PostgreSQL в&lt;/a&gt; качестве основного справочника о том, как должны себя вести оконные функции. Для PostgreSQL было выполнено множество тестовых примеров, чтобы убедиться, что оконные функции работают одинаково как в SQLite, так и в PostgreSQL.</target>
        </trans-unit>
        <trans-unit id="cec65d78532248828b5443e4752a3df7fc4931aa" translate="yes" xml:space="preserve">
          <source>Window functions</source>
          <target state="translated">Функции окон</target>
        </trans-unit>
        <trans-unit id="b37157f249f48370ca58b2cacca1806dc4feec9b" translate="yes" xml:space="preserve">
          <source>Window functions are distinguished from other SQL functions by the presence of an OVER clause. If a function has an OVER clause, then it is a window function. If it lacks an OVER clause, then it is an ordinary aggregate or scalar function. Window functions might also have a FILTER clause in between the function and the OVER clause.</source>
          <target state="translated">Функции окон отличаются от других SQL-функций наличием пункта OVER.Если функция имеет условие OVER,то это функция окна.Если в ней отсутствует условие OVER,то это обычная агрегатная или скалярная функция.Функции окна также могут иметь условие FILTER между функцией и условием OVER.</target>
        </trans-unit>
        <trans-unit id="768669bfb2a31bdc0b9e7999f08750dacabe9b82" translate="yes" xml:space="preserve">
          <source>Window functions come in two varieties: &lt;a href=&quot;windowfunctions#aggwinfunc&quot;&gt;aggregate window functions&lt;/a&gt; and &lt;a href=&quot;windowfunctions#builtins&quot;&gt;built-in window functions&lt;/a&gt;. Every aggregate window function can also work as a ordinary aggregate function, simply by omitting the OVER and FILTER clauses. Furthermore, all of the built-in &lt;a href=&quot;lang_aggfunc&quot;&gt;aggregate functions&lt;/a&gt; of SQLite can be used as an aggregate window function by adding an appropriate OVER clause. Applications can register new aggregate window functions using the &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_window_function()&lt;/a&gt; interface. The built-in window functions, however, require special-case handling in the query planner and hence new window functions that exhibit the exceptional properties found in the built-in window functions cannot be added by the application.</source>
          <target state="translated">Оконные функции бывают двух видов: &lt;a href=&quot;windowfunctions#aggwinfunc&quot;&gt;агрегированные оконные функции&lt;/a&gt; и &lt;a href=&quot;windowfunctions#builtins&quot;&gt;встроенные оконные функции&lt;/a&gt; . Каждая агрегатная оконная функция может также работать как обычная агрегатная функция, просто опуская предложения OVER и FILTER. Более того, все встроенные &lt;a href=&quot;lang_aggfunc&quot;&gt;агрегатные функции&lt;/a&gt; SQLite можно использовать как агрегатную оконную функцию, добавив соответствующее предложение OVER. Приложения могут регистрировать новые агрегированные оконные функции с помощью интерфейса &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_window_function ()&lt;/a&gt; . Однако встроенные оконные функции требуют специальной обработки в планировщике запросов, и, следовательно, новые оконные функции, которые демонстрируют исключительные свойства, обнаруженные во встроенных оконных функциях, не могут быть добавлены приложением.</target>
        </trans-unit>
        <trans-unit id="b69a0cc5bc93433662122b7ab877cc01de2fc8c1" translate="yes" xml:space="preserve">
          <source>Windows DLL exports symbols Tclsqlite_Init and Sqlite_Init</source>
          <target state="translated">Windows DLL экспортирует символы Tclsqlite_Init и Sqlite_Init</target>
        </trans-unit>
        <trans-unit id="a3320dd4ff96aeb28c32b1c618d2fdc870a0f410" translate="yes" xml:space="preserve">
          <source>Windows builds also come with multiple built-in VFSes. The default Windows VFS is called &quot;win32&quot; and is used in most applications. Other VFSes that might be found on windows builds include:</source>
          <target state="translated">Кроме того,сборки для Windows поставляются с несколькими встроенными VFS.По умолчанию Windows VFS называется &quot;win32&quot; и используется в большинстве приложений.Другие VFS,которые могут быть найдены на сборках Windows,включают в себя:</target>
        </trans-unit>
        <trans-unit id="84eca34acba80a1cc2933e50280e69e2f20b7bbc" translate="yes" xml:space="preserve">
          <source>Windows is unable to truncate a memory-mapped file. Hence, on Windows, if an operation such as &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; or &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum&lt;/a&gt; tries to reduce the size of a memory-mapped database file, the size reduction attempt will silently fail, leaving unused space at the end of the database file. No data is lost due to this problem, and the unused space will be reused again the next time the database grows. However if a version of SQLite prior to 3.7.0 runs &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt; on such a database, it will (incorrectly) report database corruption due to the unused space at the end. Or if a version of SQLite prior to 3.7.0 writes to the database while it still has unused space at the end, it may make that unused space inaccessible and unavailable for reuse until after the next &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt;.</source>
          <target state="translated">Windows не может усечь файл с отображением в память. Следовательно, в Windows, если операция, такая как &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; или &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum,&lt;/a&gt; пытается уменьшить размер файла базы данных с отображением в память, попытка уменьшения размера автоматически завершится ошибкой, оставив неиспользуемое пространство в конце файла базы данных. Из-за этой проблемы данные не теряются, а неиспользуемое пространство будет повторно использовано при следующем увеличении базы данных. Однако, если версия SQLite до 3.7.0 запускает &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;проверку целостности PRAGMA&lt;/a&gt; для такой базы данных, она (неправильно) сообщит о повреждении базы данных из-за неиспользуемого пространства в конце. Или, если версия SQLite до 3.7.0 записывает в базу данных, в то время как в конце еще есть неиспользуемое пространство, это может сделать это неиспользуемое пространство недоступным и недоступным для повторного использования до следующего&lt;a href=&quot;lang_vacuum&quot;&gt;ВАКУУМ&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3b7712d1cb131a2adfefe7d588175fadb48dafa7" translate="yes" xml:space="preserve">
          <source>Windows only: Open the file &quot;data.db&quot; on fred's desktop on drive C:. Note that the %20 escaping in this example is not strictly necessary - space characters can be used literally in URI filenames.</source>
          <target state="translated">Только для Windows:Откройте файл &quot;data.db&quot; на рабочем столе Фред на диске C:.Обратите внимание,что экранирование %20 в этом примере не является строго необходимым-пробелы могут быть использованы буквально в именах файлов URI.</target>
        </trans-unit>
        <trans-unit id="31aeba611599f329aa343c65bc0c86921ffe7f9d" translate="yes" xml:space="preserve">
          <source>Windows users can double-click on the &lt;b&gt;sqlite3.exe&lt;/b&gt; icon to cause the command-line shell to pop-up a terminal window running SQLite. However, because double-clicking starts the sqlite3.exe without command-line arguments, no database file will have been specified, so SQLite will use a temporary database that is deleted when the session exits. To use a persistent disk file as the database, enter the &quot;.open&quot; command immediately after the terminal window starts up:</source>
          <target state="translated">Пользователи Windows могут дважды щелкнуть значок &lt;b&gt;sqlite3.exe,&lt;/b&gt; чтобы оболочка командной строки &lt;b&gt;открыла&lt;/b&gt; окно терминала с запущенным SQLite. Однако, поскольку двойной щелчок запускает sqlite3.exe без аргументов командной строки, файл базы данных не будет указан, поэтому SQLite будет использовать временную базу данных, которая удаляется при выходе из сеанса. Чтобы использовать файл постоянного диска в качестве базы данных, введите команду &amp;laquo;.open&amp;raquo; сразу после запуска окна терминала:</target>
        </trans-unit>
        <trans-unit id="46ae0e9a494aaadddce1ec0fa75065f4b23d237d" translate="yes" xml:space="preserve">
          <source>With SQLite (but not any other SQL implementation that we know of) if an aggregate query contains a single min() or max() function, then the values of columns used in the output are taken from the row where the min() or max() value was achieved. If two or more rows have the same min() or max() value, then the columns values will be chosen arbitrarily from one of those rows.</source>
          <target state="translated">При использовании SQLite (но не любой другой известной нам SQL реализации),если агрегированный запрос содержит одну функцию min()или max(),то значения столбцов,используемые в выводе,берутся из строки,где было достигнуто значение min()или max().Если две или более строк имеют одно и то же значение min()или max(),то значения столбцов будут выбираться произвольно из одной из этих строк.</target>
        </trans-unit>
        <trans-unit id="72d650183743377687d259d65b2b0b1477f3b0e4" translate="yes" xml:space="preserve">
          <source>With a covering index, SQLite can simply walk the index from one end to the other and deliver the output in time proportional to N and without having allocate a large buffer to hold the result set.</source>
          <target state="translated">С индексом покрытия SQLite может просто ходить по индексу от одного конца к другому и доставлять вывод во времени пропорционально N и без выделения большого буфера для хранения результирующего множества.</target>
        </trans-unit>
        <trans-unit id="ffbb132debbaa76f4f42bce9a72aacb1ba449100" translate="yes" xml:space="preserve">
          <source>With a single allocation size, the &lt;b&gt;n&lt;/b&gt; parameter in the &lt;a href=&quot;malloc#nofrag&quot;&gt;Robson proof&lt;/a&gt; is 1, and the total memory space required by the allocator (&lt;b&gt;N&lt;/b&gt;) is exactly equal to maximum memory used (&lt;b&gt;M&lt;/b&gt;). No additional memory is required to cover fragmentation overhead, thus reducing memory requirements. This is particularly important for the page cache memory since the page cache constitutes the largest component of the memory needs of SQLite.</source>
          <target state="translated">При единственном размере распределения параметр &lt;b&gt;n&lt;/b&gt; в &lt;a href=&quot;malloc#nofrag&quot;&gt;доказательстве Робсона&lt;/a&gt; равен 1, а общий объем памяти, необходимый распределителю ( &lt;b&gt;N&lt;/b&gt; ), в точности равен максимальному используемому объему памяти ( &lt;b&gt;M&lt;/b&gt; ). Никакой дополнительной памяти для покрытия накладных расходов на фрагментацию не требуется, что снижает требования к памяти. Это особенно важно для кеш-памяти страниц, поскольку кэш страниц составляет самый большой компонент потребностей SQLite в памяти.</target>
        </trans-unit>
        <trans-unit id="a552e4d61e6c98e72a1a99aa574976a695fc5369" translate="yes" xml:space="preserve">
          <source>With asynchronous I/O, write requests are handled by a separate thread running in the background. This means that the thread that initiates a database write does not have to wait for (sometimes slow) disk I/O to occur. The write seems to happen very quickly, though in reality it is happening at its usual slow pace in the background.</source>
          <target state="translated">При асинхронном вводе/выводе запросы на запись обрабатываются отдельным потоком,работающим в фоновом режиме.Это означает,что потоку,инициирующему запись в БД,не нужно ждать (иногда медленного)дискового ввода/вывода.Похоже,что запись происходит очень быстро,хотя в действительности она происходит с обычной медленной скоростью в фоновом режиме.</target>
        </trans-unit>
        <trans-unit id="ab9e7dc76b3ad69724eb79aea2faff0ba6d5b557" translate="yes" xml:space="preserve">
          <source>With client/server databases like PostgreSQL or Oracle, users and developers tend to think of the database as a service or a &quot;node&quot;, not as an object. This is because the database content is spread out across multiple files on the server, or possibly across multiple servers in a service cluster. One cannot point to a single file or even a single directory and say &quot;this is the database&quot;.</source>
          <target state="translated">В случае с клиентскими/серверными базами данных,такими как PostgreSQL или Oracle,пользователи и разработчики склонны думать о базе данных как о сервисе или &quot;узле&quot;,а не как об объекте.Это происходит потому,что содержимое базы данных распределено по нескольким файлам на сервере или,возможно,по нескольким серверам в кластере услуг.Нельзя указать на один файл или даже на одну директорию и сказать &quot;это база данных&quot;.</target>
        </trans-unit>
        <trans-unit id="9f913fbcf0e843248e92480f5555045919a3653f" translate="yes" xml:space="preserve">
          <source>With one exception noted below, if a rowid table has a primary key that consists of a single column and the declared type of that column is &quot;INTEGER&quot; in any mixture of upper and lower case, then the column becomes an alias for the rowid. Such a column is usually referred to as an &quot;integer primary key&quot;. A PRIMARY KEY column only becomes an integer primary key if the declared type name is exactly &quot;INTEGER&quot;. Other integer type names like &quot;INT&quot; or &quot;BIGINT&quot; or &quot;SHORT INTEGER&quot; or &quot;UNSIGNED INTEGER&quot; causes the primary key column to behave as an ordinary table column with integer &lt;a href=&quot;datatype3#affinity&quot;&gt;affinity&lt;/a&gt; and a unique index, not as an alias for the rowid.</source>
          <target state="translated">За одним исключением, отмеченным ниже, если таблица rowid имеет первичный ключ, который состоит из одного столбца, и объявленный тип этого столбца - &amp;laquo;INTEGER&amp;raquo; в любом сочетании верхнего и нижнего регистра, тогда столбец становится псевдонимом для rowid. Такой столбец обычно называют &amp;laquo;целочисленным первичным ключом&amp;raquo;. Столбец PRIMARY KEY становится целочисленным первичным ключом только в том случае, если объявленное имя типа точно &quot;INTEGER&quot;. Другие имена целочисленных типов, такие как &amp;laquo;INT&amp;raquo;, &amp;laquo;BIGINT&amp;raquo;, &amp;laquo;SHORT INTEGER&amp;raquo; или &amp;laquo;UNSIGNED INTEGER&amp;raquo;, заставляют столбец первичного ключа вести себя как обычный столбец таблицы с целочисленным &lt;a href=&quot;datatype3#affinity&quot;&gt;сродством&lt;/a&gt; и уникальным индексом, а не как псевдоним для rowid.</target>
        </trans-unit>
        <trans-unit id="6d08bbd760872d68db33d3c86cf4e679c7a2ebc9" translate="yes" xml:space="preserve">
          <source>With release 3.8.0 (2013-08-26), the SQLite query planner was reimplemented as the &lt;a href=&quot;queryplanner-ng&quot;&gt;Next Generation Query Planner&lt;/a&gt; or &quot;NGQP&quot;. All of the features, techniques, and algorithms described in this document are applicable to both the pre-3.8.0 legacy query planner and to the NGQP. For further information on how the NGQP differs from the legacy query planner, see the &lt;a href=&quot;queryplanner-ng&quot;&gt;detailed description of the NGQP&lt;/a&gt;.</source>
          <target state="translated">В выпуске 3.8.0 (2013-08-26) планировщик запросов SQLite был переопределен как &lt;a href=&quot;queryplanner-ng&quot;&gt;Планировщик запросов следующего поколения&lt;/a&gt; или &amp;laquo;NGQP&amp;raquo;. Все функции, методы и алгоритмы, описанные в этом документе, применимы как к устаревшему планировщику запросов до 3.8.0, так и к NGQP. Для получения дополнительной информации о том, чем NGQP отличается от прежнего планировщика запросов, см. &lt;a href=&quot;queryplanner-ng&quot;&gt;Подробное описание NGQP&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d1d01005af669e498a6d79c05e376c2142afd701" translate="yes" xml:space="preserve">
          <source>With some (arbitrary) data, such a table might be logically stored on disk as shown in figure 1:</source>
          <target state="translated">При наличии некоторых (произвольных)данных такая таблица может логически храниться на диске,как показано на рисунке 1:</target>
        </trans-unit>
        <trans-unit id="fd1021b066f8f1badfb5950e8af5b888b38dc724" translate="yes" xml:space="preserve">
          <source>With source code files in the working directory, a DLL can be generated using MSVC with the following command:</source>
          <target state="translated">При наличии файлов с исходным кодом в рабочей директории,DLL может быть сгенерирована с помощью MSVC следующей командой:</target>
        </trans-unit>
        <trans-unit id="0f39e53b1be71b4fb78a20a47e590c12ddf0bcbb" translate="yes" xml:space="preserve">
          <source>With such a schema, the application would no longer need to make periodic backups of the unsaved changes to a separate file to avoid lost work in the event of a crash. Instead, a special &quot;pending&quot; version could be allocated and unsaved changes could be written into the pending version. Because only changes would need to be written, not the entire document, saving the pending changes would only involve writing a few kilobytes of content, not multiple megabytes, and would take milliseconds instead of seconds, and so it could be done frequently and silently in the background. Then when a crash occurs and the user reboots, all (or almost all) of their work is retained. If the user decides to discard unsaved changes, they simply go back to the previous version.</source>
          <target state="translated">При такой схеме приложению больше не нужно будет делать периодические резервные копии несохраненных изменений в отдельном файле,чтобы избежать потери работы в случае аварии.Вместо этого можно было бы выделить специальную &quot;отложенную&quot; версию и записать несохраненные изменения в отложенную версию.Поскольку нужно будет записывать только изменения,а не весь документ,сохранение отложенных изменений будет включать только запись нескольких килобайт содержимого,а не нескольких мегабайт,и займет миллисекунды,а не секунды,поэтому это можно делать часто и тихо в фоновом режиме.Затем,когда происходит сбой и пользователь перезагружается,вся (или почти вся)его работа сохраняется.Если пользователь решает отказаться от несохраненных изменений,он просто возвращается к предыдущей версии.</target>
        </trans-unit>
        <trans-unit id="1152f09445e7a27bd0f86b5f6b1e7dc6ef22ecb9" translate="yes" xml:space="preserve">
          <source>With synchronous OFF (0), SQLite continues without syncing as soon as it has handed data off to the operating system. If the application running SQLite crashes, the data will be safe, but the database &lt;a href=&quot;howtocorrupt#cfgerr&quot;&gt;might become corrupted&lt;/a&gt; if the operating system crashes or the computer loses power before that data has been written to the disk surface. On the other hand, commits can be orders of magnitude faster with synchronous OFF.</source>
          <target state="translated">При синхронном отключении (0) SQLite продолжает работу без синхронизации, как только данные передаются операционной системе. Если приложение, работающее под управлением SQLite, выйдет из строя, данные будут в безопасности, но база данных &lt;a href=&quot;howtocorrupt#cfgerr&quot;&gt;может быть повреждена,&lt;/a&gt; если произойдет сбой операционной системы или отключение питания компьютера до того, как эти данные будут записаны на поверхность диска. С другой стороны, при синхронном отключении коммиты могут выполняться на несколько порядков быстрее.</target>
        </trans-unit>
        <trans-unit id="6e05518cdffbac366023e6a7a1a6316fad89e6a6" translate="yes" xml:space="preserve">
          <source>With the Idx3 index on both columns that are constrained by the WHERE clause, SQLite can do a single binary search against Idx3 to find the one rowid for California oranges, then do a single binary search to find the price for that item in the original table. There are no dead-ends and no wasted binary searches. This is a more efficient query.</source>
          <target state="translated">С помощью индекса Idx3 в обоих столбцах,которые ограничены пунктом WHERE,SQLite может выполнить один бинарный поиск по Idx3,чтобы найти один ряд для калифорнийских апельсинов,а затем выполнить один бинарный поиск,чтобы найти цену для этого товара в оригинальной таблице.Не существует тупиков и бесполезного бинарного поиска.Это более эффективный запрос.</target>
        </trans-unit>
        <trans-unit id="d0ccef83367809507d68fd8adf10ab43756d4053" translate="yes" xml:space="preserve">
          <source>With the following provisos, each series of tokens in the FTS table that matches one of the matchable phrases in the query expression is known as a &quot;phrase match&quot;:</source>
          <target state="translated">При следующих оговорках каждая серия маркеров в таблице FTS,совпадающая с одной из совпадающих фраз в выражении запроса,известна как &quot;фраза,совпадающая&quot;:</target>
        </trans-unit>
        <trans-unit id="6be83cc240990bde696822c8c968c954935effd4" translate="yes" xml:space="preserve">
          <source>With the schema above, a statement of the form:</source>
          <target state="translated">С приведенной выше схемой,заявление формы:</target>
        </trans-unit>
        <trans-unit id="ce7e1668aa6ca5e4002b24e2ec5db69485e9af33" translate="yes" xml:space="preserve">
          <source>With this pattern, the overall system is still client/server: clients send requests to the server and get back replies over the network. But instead of sending generic SQL and getting back raw table content, the client requests and server responses are high-level and application-specific. The server translates requests into multiple SQL queries, gathers the results, does post-processing, filtering, and analysis, then constructs a high-level reply containing only the essential information.</source>
          <target state="translated">При такой схеме система в целом остается клиентом/сервером:клиенты посылают запросы на сервер и получают обратные ответы по сети.Но вместо того,чтобы посылать общий SQL и получать обратно необработанное табличное содержимое,запросы клиентов и ответы сервера являются высокоуровневыми и зависят от конкретного приложения.Сервер транслирует запросы в несколько SQL-запросов,собирает результаты,выполняет постобработку,фильтрацию и анализ,а затем строит ответ высокого уровня,содержащий только существенную информацию.</target>
        </trans-unit>
        <trans-unit id="a6cde545c87cfe9cdf5083a11aa7253d12946e88" translate="yes" xml:space="preserve">
          <source>With this table, the statement</source>
          <target state="translated">С этой таблицей,заявление</target>
        </trans-unit>
        <trans-unit id="e3d30043cb29ededf7f5c7d45d7c85af41b7ac41" translate="yes" xml:space="preserve">
          <source>With this trigger installed, executing the statement:</source>
          <target state="translated">При установленном триггере выполняется утверждение:</target>
        </trans-unit>
        <trans-unit id="b738f8fb3971eaf9d8b4464f7e01335910aa51fd" translate="yes" xml:space="preserve">
          <source>With tracing mode on, the VDBE prints each instruction prior to executing it. After the instruction is executed, the top few entries in the stack are displayed. The stack display is omitted if the stack is empty.</source>
          <target state="translated">При включенном режиме трассировки VDBE распечатывает каждую инструкцию перед ее выполнением.После выполнения команды отображаются несколько верхних записей в стеке.Отображение стопки опускается,если стопка пуста.</target>
        </trans-unit>
        <trans-unit id="bdf14e9c4b4688dcd43209a6bc661b4142ea27d9" translate="yes" xml:space="preserve">
          <source>With two exceptions, a</source>
          <target state="translated">За двумя исключениями,а</target>
        </trans-unit>
        <trans-unit id="bb5693991e33e1156b62932972a48bb594da454a" translate="yes" xml:space="preserve">
          <source>Within a changeset generated by this function, all changes related to a single table are grouped together. In other words, when iterating through a changeset or when applying a changeset to a database, all changes related to a single table are processed before moving on to the next table. Tables are sorted in the same order in which they were attached (or auto-attached) to the sqlite3_session object. The order in which the changes related to a single table are stored is undefined.</source>
          <target state="translated">В наборе изменений,генерируемых этой функцией,все изменения,связанные с одной таблицей,группируются вместе.Другими словами,при итерации через changeset или при применении changeset к БД все изменения,связанные с одной таблицей,обрабатываются перед переходом к следующей таблице.Таблицы сортируются в том же порядке,в котором они были прикреплены (или автоматически прикреплены)к объекту sqlite3_session.Порядок хранения изменений,связанных с одной таблицей,не определен.</target>
        </trans-unit>
        <trans-unit id="e69d76786ab7b8d267ef6f99888893212d52b234" translate="yes" xml:space="preserve">
          <source>Within a single database connection X, a SELECT statement always sees all changes to the database that are completed prior to the start of the SELECT statement, whether committed or uncommitted. And the SELECT statement obviously does not see any changes that occur after the SELECT statement completes. But what about changes that occur while the SELECT statement is running? What if a SELECT statement is started and the &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; interface steps through roughly half of its output, then some &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; statements are run by the application that modify the table that the SELECT statement is reading, then more calls to &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; are made to finish out the SELECT statement? Will the later steps of the SELECT statement see the changes made by the UPDATE or not? The answer is that this behavior is undefined. In particular, whether or not the SELECT statement sees the concurrent changes depends on which release of SQLite is running, the schema of the database file, whether or not &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; has been run, and the details of the query. In some cases, it might depend on the content of the database file, too. There is no good way to know whether or not a SELECT statement will see changes that were made to the database by the same database connection after the SELECT statement was started. And hence, developers should diligently avoid writing applications that make assumptions about what will occur in that circumstance.</source>
          <target state="translated">В пределах одного соединения с базой данных X оператор SELECT всегда видит все изменения в базе данных, которые были завершены до начала оператора SELECT, независимо от того, зафиксированы они или нет. И оператор SELECT, очевидно, не видит никаких изменений, которые происходят после завершения оператора SELECT. Но как насчет изменений, которые происходят во время выполнения оператора SELECT? Что делать, если запускается оператор SELECT и интерфейс &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step ()&lt;/a&gt; проходит примерно половину своего вывода, тогда некоторые операторы &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; запускаются приложением, которое изменяет таблицу, которую читает оператор SELECT, а затем больше вызовов &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step ()&lt;/a&gt;сделаны для завершения оператора SELECT? Увидят ли последующие шаги оператора SELECT изменения, внесенные UPDATE, или нет? Ответ в том, что это поведение не определено. В частности, то, видит ли оператор SELECT одновременные изменения, зависит от того, какой выпуск SQLite запущен, от схемы файла базы данных, от того, был ли &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; запущен, и от деталей запроса. В некоторых случаях это может также зависеть от содержимого файла базы данных. Нет хорошего способа узнать, увидит ли оператор SELECT изменения, которые были внесены в базу данных тем же соединением с базой данных после запуска оператора SELECT. И поэтому разработчики должны старательно избегать написания приложений, которые делают предположения о том, что произойдет в этих обстоятельствах.</target>
        </trans-unit>
        <trans-unit id="f64c1e27b35be2c65501356f86b040f4e01382a8" translate="yes" xml:space="preserve">
          <source>Within a trigger program each INSERT, UPDATE and DELETE statement sets the value returned by sqlite3_changes() upon completion as normal. Of course, this value will not include any changes performed by sub-triggers, as the sqlite3_changes() value will be saved and restored after each sub-trigger has run.</source>
          <target state="translated">В триггерной программе каждый оператор INSERT,UPDATE и DELETE устанавливает значение,возвращаемое функцией sqlite3_changes()по завершении работы в нормальном режиме.Конечно,в это значение не будут вноситься никакие изменения,выполняемые субтриггерами,так как значение sqlite3_changes()будет сохранено и восстановлено после выполнения каждого субтриггера.</target>
        </trans-unit>
        <trans-unit id="a4a4a7b77632610d5c03098170087135a035d198" translate="yes" xml:space="preserve">
          <source>Within an FTS expression a &lt;b&gt;string&lt;/b&gt; may be specified in one of two ways:</source>
          <target state="translated">В выражении FTS &lt;b&gt;строка&lt;/b&gt; может быть указана одним из двух способов:</target>
        </trans-unit>
        <trans-unit id="b69cb3df5f10a8834e6c84cc69fe995f5e513c1e" translate="yes" xml:space="preserve">
          <source>Within an interior b-tree page, each key and the pointer to its immediate left are combined into a structure called a &quot;cell&quot;. The right-most pointer is held separately. A leaf b-tree page has no pointers, but it still uses the cell structure to hold keys for index b-trees or keys and content for table b-trees. Data is also contained in the cell.</source>
          <target state="translated">Внутри внутренней страницы из дерева b каждая клавиша и указатель на нее слева объединяются в структуру,называемую &quot;ячейкой&quot;.Самый правый указатель удерживается отдельно.Листовая b-деревовидная страница не имеет указателей,но все же она использует структуру ячеек для хранения ключей для индексных b-деревьев или ключей и содержимого таблицы b-деревьев.Данные также содержатся в ячейке.</target>
        </trans-unit>
        <trans-unit id="e7e979d6674438107ff98232bc172bfe9db221b4" translate="yes" xml:space="preserve">
          <source>Within the &lt;a href=&quot;../vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; method of a &lt;a href=&quot;../vtab&quot;&gt;virtual table&lt;/a&gt;, the sqlite3_value_nochange(X) interface returns true if and only if the column corresponding to X is unchanged by the UPDATE operation that the xUpdate method call was invoked to implement and if and the prior &lt;a href=&quot;../vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt; method call that was invoked to extracted the value for that column returned without setting a result (probably because it queried &lt;a href=&quot;vtab_nochange&quot;&gt;sqlite3_vtab_nochange()&lt;/a&gt; and found that the column was unchanging). Within an &lt;a href=&quot;../vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; method, any value for which sqlite3_value_nochange(X) is true will in all other respects appear to be a NULL value. If sqlite3_value_nochange(X) is invoked anywhere other than within an &lt;a href=&quot;../vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; method call for an UPDATE statement, then the return value is arbitrary and meaningless.</source>
          <target state="translated">В методе &lt;a href=&quot;../vtab#xupdate&quot;&gt;xUpdate &lt;/a&gt;&lt;a href=&quot;../vtab&quot;&gt;виртуальной таблицы&lt;/a&gt; интерфейс sqlite3_value_nochange (X) возвращает true тогда и только тогда, когда столбец, соответствующий X, не изменился операцией UPDATE, для реализации которой был вызван вызов метода xUpdate, и если и предыдущий &lt;a href=&quot;../vtab#xcolumn&quot;&gt;вызов&lt;/a&gt; метода xColumn, который был вызван для извлечения значения для этого столбца, возвращенного без установки результата (вероятно, потому, что он запросил &lt;a href=&quot;vtab_nochange&quot;&gt;sqlite3_vtab_nochange ()&lt;/a&gt; и обнаружил, что столбец не изменился). В методе &lt;a href=&quot;../vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; любое значение, для которого sqlite3_value_nochange (X) истинно, во всех других отношениях будет отображаться как значение NULL. Если sqlite3_value_nochange (X) вызывается где угодно, кроме&lt;a href=&quot;../vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt;вызов метода для оператора UPDATE, то возвращаемое значение будет произвольным и бессмысленным.</target>
        </trans-unit>
        <trans-unit id="6789b1bae7cd2bb76c0159019d7d9fbb4d93f85d" translate="yes" xml:space="preserve">
          <source>Within the &lt;a href=&quot;vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; method of a &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt;, the sqlite3_value_nochange(X) interface returns true if and only if the column corresponding to X is unchanged by the UPDATE operation that the xUpdate method call was invoked to implement and if and the prior &lt;a href=&quot;vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt; method call that was invoked to extracted the value for that column returned without setting a result (probably because it queried &lt;a href=&quot;#sqlite3_vtab_nochange&quot;&gt;sqlite3_vtab_nochange()&lt;/a&gt; and found that the column was unchanging). Within an &lt;a href=&quot;vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; method, any value for which sqlite3_value_nochange(X) is true will in all other respects appear to be a NULL value. If sqlite3_value_nochange(X) is invoked anywhere other than within an &lt;a href=&quot;vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; method call for an UPDATE statement, then the return value is arbitrary and meaningless.</source>
          <target state="translated">В методе &lt;a href=&quot;vtab#xupdate&quot;&gt;xUpdate &lt;/a&gt;&lt;a href=&quot;vtab&quot;&gt;виртуальной таблицы&lt;/a&gt; интерфейс sqlite3_value_nochange (X) возвращает true тогда и только тогда, когда столбец, соответствующий X, не изменился операцией UPDATE, для реализации которой был вызван вызов метода xUpdate, и если и предыдущий &lt;a href=&quot;vtab#xcolumn&quot;&gt;вызов&lt;/a&gt; метода xColumn, который был вызван для извлечения значения для этого столбца, возвращенного без установки результата (вероятно, потому, что он запросил &lt;a href=&quot;#sqlite3_vtab_nochange&quot;&gt;sqlite3_vtab_nochange ()&lt;/a&gt; и обнаружил, что столбец не изменился). В методе &lt;a href=&quot;vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; любое значение, для которого sqlite3_value_nochange (X) истинно, во всех других отношениях будет отображаться как значение NULL. Если sqlite3_value_nochange (X) вызывается где угодно, кроме &lt;a href=&quot;vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt;вызов метода для оператора UPDATE, то возвращаемое значение будет произвольным и бессмысленным.</target>
        </trans-unit>
        <trans-unit id="51af27804794d9726418547af1ae4968a5ef7a8d" translate="yes" xml:space="preserve">
          <source>Within this document, the term</source>
          <target state="translated">В рамках данного документа термин</target>
        </trans-unit>
        <trans-unit id="2abd7cfa8c19071145244fc329440378e98735a8" translate="yes" xml:space="preserve">
          <source>Within this document, the term &lt;b&gt;&lt;i&gt;non-writable dirty page&lt;/i&gt;&lt;/b&gt; is used specifically to refer to a</source>
          <target state="translated">В этом документе термин &quot; &lt;b&gt;&lt;i&gt;грязная страница без возможности записи&quot;&lt;/i&gt;&lt;/b&gt; используется специально для обозначения</target>
        </trans-unit>
        <trans-unit id="9c7aa2ef11bbb00024927734567cd7e8fb651be6" translate="yes" xml:space="preserve">
          <source>Within your application, call the procedure implemented in the last step above as part of your initialization process before any database connections are opened.</source>
          <target state="translated">Внутри вашего приложения вызовите процедуру,реализованную на последнем шаге выше в рамках процесса инициализации,прежде чем будут открыты какие-либо подключения к БД.</target>
        </trans-unit>
        <trans-unit id="d2b321aabd394218d6d71b6b8d179118941b9c02" translate="yes" xml:space="preserve">
          <source>Without the master journal, the transaction commit on a multi-database transaction would be atomic for each database individually, but it would not be atomic across all databases. In other words, if the commit were interrupted in the middle by a crash or power loss, then the changes to one of the databases might complete while the changes to another database might roll back. The master journal causes all changes in all databases to either rollback or commit together.</source>
          <target state="translated">Без основного журнала фиксация транзакции в многобазовой транзакции была бы атомарной для каждой базы данных в отдельности,но она не была бы атомарной для всех баз данных.Другими словами,если бы коммит был прерван посередине из-за аварии или потери питания,то изменения в одной из баз данных могли бы завершиться,в то время как изменения в другой базе данных могли бы откатиться назад.Основной журнал приводит к тому,что все изменения во всех базах данных либо откатываются,либо фиксируются вместе.</target>
        </trans-unit>
        <trans-unit id="7c3fafa3b408ed62c81a7e1dcfba262f7d167cb3" translate="yes" xml:space="preserve">
          <source>Without the super-journal, the transaction commit on a multi-database transaction would be atomic for each database individually, but it would not be atomic across all databases. In other words, if the commit were interrupted in the middle by a crash or power loss, then the changes to one of the databases might complete while the changes to another database might roll back. The super-journal causes all changes in all databases to either rollback or commit together.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6dd78a3d415f93746301f9a57f0de1998136848" translate="yes" xml:space="preserve">
          <source>Words beginning with &quot;wr&quot; versus &quot;r&quot;: write vs. rite</source>
          <target state="translated">Слова,начинающиеся с &quot;wr&quot; против &quot;r&quot;:&quot;write vs.rite&quot;.</target>
        </trans-unit>
        <trans-unit id="87bffc88b4c4749365cee3251faa81be81f0ebe9" translate="yes" xml:space="preserve">
          <source>Work around a C-preprocessor macro conflict that breaks the build for some configurations with Microsoft Visual Studio.</source>
          <target state="translated">Работать вокруг C-препроцессорного конфликта макросов,который разбивает сборку для некоторых конфигураций с Microsoft Visual Studio.</target>
        </trans-unit>
        <trans-unit id="50aee533edd4e21305ef90f99451cd9467951df2" translate="yes" xml:space="preserve">
          <source>Work around a GCC optimizer bug (for gcc 4.2.1 on MacOS 10.7) that caused the &lt;a href=&quot;rtree&quot;&gt;R-Tree extension&lt;/a&gt; to compute incorrect results when compiled with -O3.</source>
          <target state="translated">Обходите ошибку оптимизатора GCC (для gcc 4.2.1 в MacOS 10.7), из &lt;a href=&quot;rtree&quot;&gt;-за которой расширение R-Tree&lt;/a&gt; вычисляло неверные результаты при компиляции с -O3.</target>
        </trans-unit>
        <trans-unit id="dfd059bf7f3cb496ecc6f63b39e721653d7d6b6d" translate="yes" xml:space="preserve">
          <source>Work around a bug in the optimizer in the VisualStudio-2012 compiler that causes invalid code to be generated when compiling SQLite on ARM.</source>
          <target state="translated">Поработайте над ошибкой в оптимизаторе в компиляторе VisualStudio-2012,которая приводит к генерации недействительного кода при компиляции SQLite на ARM.</target>
        </trans-unit>
        <trans-unit id="05fe4e3a69bacc20ca972b8ceb1bc5a0e767ed20" translate="yes" xml:space="preserve">
          <source>Work around a sign-extension bug in the optimizer of the HP C compiler on HP/UX. &lt;a href=&quot;https://www.sqlite.org/src/fdiff?sbs=1&amp;amp;v1=869c95b0fc73026d&amp;amp;v2=232c242a0ccb3d67&quot;&gt;(details)&lt;/a&gt;</source>
          <target state="translated">Обходите ошибку расширения знака в оптимизаторе компилятора HP C в HP / UX. &lt;a href=&quot;https://www.sqlite.org/src/fdiff?sbs=1&amp;amp;v1=869c95b0fc73026d&amp;amp;v2=232c242a0ccb3d67&quot;&gt;(Подробнее)&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0f7e0b96e4d5af469559bc4b5418e841b0585e67" translate="yes" xml:space="preserve">
          <source>Work around a win2k problem so that SQLite can use single-character database file names</source>
          <target state="translated">Поработайте над проблемой win2k,чтобы SQLite мог использовать односимвольные имена файлов базы данных.</target>
        </trans-unit>
        <trans-unit id="620ea823b219e2193e9c0c9d76d068c0c91681bb" translate="yes" xml:space="preserve">
          <source>Work around an optimizer bug in the MSVC compiler when targeting ARM.</source>
          <target state="translated">Обойти ошибку оптимизатора в компиляторе MSVC при нацеливании на ARM.</target>
        </trans-unit>
        <trans-unit id="c7a3e9e586b4abc65bd66b99ca41670f3c121bb4" translate="yes" xml:space="preserve">
          <source>Work-around for &lt;a href=&quot;http://gcc.gnu.org/bugzilla/show_bug.cgi?id=32575&quot;&gt;GCC bug 32575&lt;/a&gt;.</source>
          <target state="translated">Работа вокруг для &lt;a href=&quot;http://gcc.gnu.org/bugzilla/show_bug.cgi?id=32575&quot;&gt;GCC ошибки 32575&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cebdf47773b9831e663aaa2b137f8c46c76becbf" translate="yes" xml:space="preserve">
          <source>Would be rewritten using query flattening as:</source>
          <target state="translated">Будет переписано с использованием сглаживания запросов как:</target>
        </trans-unit>
        <trans-unit id="adefeee85f8390b904f622c9dadd9084253d11b9" translate="yes" xml:space="preserve">
          <source>Wrap SQL output in a single large transaction</source>
          <target state="translated">Обертка SQL-вывода в одну большую транзакцию</target>
        </trans-unit>
        <trans-unit id="a38083e109d2e7a4d69cbaa3489444f640acbb5f" translate="yes" xml:space="preserve">
          <source>Write Data Into A BLOB Incrementally</source>
          <target state="translated">Запись данных в BLOB инкрементально</target>
        </trans-unit>
        <trans-unit id="d7f59c7d18e98edd2a33e30c67d681015a12865e" translate="yes" xml:space="preserve">
          <source>Write P4 on the statement trace output if statement tracing is enabled.</source>
          <target state="translated">Если трассировка операторов включена,запишите P4 на вывод трассы оператора.</target>
        </trans-unit>
        <trans-unit id="01ecf2ccbe2bc061336d1857718a14b0b49fee20" translate="yes" xml:space="preserve">
          <source>Write Programs That Use SQLite</source>
          <target state="translated">Пишите программы,использующие SQLite.</target>
        </trans-unit>
        <trans-unit id="57477c30051b84c96ed41136ab16ff89bef76c1e" translate="yes" xml:space="preserve">
          <source>Write Transactions</source>
          <target state="translated">Пишите Операции</target>
        </trans-unit>
        <trans-unit id="7792ea49e68a0636ee3df8abc86c43dc971f4500" translate="yes" xml:space="preserve">
          <source>Write a NULL into registers P2. If P3 greater than P2, then also write NULL into register P3 and every register in between P2 and P3. If P3 is less than P2 (typically P3 is zero) then only register P2 is set to NULL.</source>
          <target state="translated">Запишите NULL в регистр P2.Если P3 больше чем P2,то также запишите NULL в регистр P3 и каждый регистр между P2 и P3.Если P3 меньше,чем P2 (обычно P3 равен нулю),то только регистр P2 установлен в NULL.</target>
        </trans-unit>
        <trans-unit id="4b067f7f133cef5bf8ac788b6955ee101e88869d" translate="yes" xml:space="preserve">
          <source>Write a string containing the final journal-mode to register P2.</source>
          <target state="translated">Запишите строку,содержащую финальный режим журнала для регистрации P2.</target>
        </trans-unit>
        <trans-unit id="b758b03a1915378a4790dfdd86b8e50a7bacf82d" translate="yes" xml:space="preserve">
          <source>Write all necessary methods.</source>
          <target state="translated">Напишите все необходимые методы.</target>
        </trans-unit>
        <trans-unit id="96dcd721393f2668fc3f8e665d514a96620cfebb" translate="yes" xml:space="preserve">
          <source>Write all page modifications currently held in memory out to the original database disk file.</source>
          <target state="translated">Записывайте все изменения страниц,которые в настоящее время хранятся в памяти,в исходный файл на диске базы данных.</target>
        </trans-unit>
        <trans-unit id="1687a8d3ed30cb7eb791ed33a931d8ace68eaab0" translate="yes" xml:space="preserve">
          <source>Write an entry into the table of cursor P1. A new entry is created if it doesn't already exist or the data for an existing entry is overwritten. The data is the value MEM_Blob stored in register number P2. The key is stored in register P3. The key must be a MEM_Int.</source>
          <target state="translated">Запишите запись в таблицу курсора P1.Новая запись создается,если ее еще нет или данные для существующей записи перезаписываются.Данные-это значение MEM_Blob,записанное в регистре под номером P2.Ключ хранится в регистре P3.Ключ должен быть MEM_Int.</target>
        </trans-unit>
        <trans-unit id="d5c23fb528e11a09e4afc8b5a2e279f79a841784" translate="yes" xml:space="preserve">
          <source>Write into register P2 an integer which is the last entry in the record at the end of the index key pointed to by cursor P1. This integer should be the rowid of the table entry to which this index entry points.</source>
          <target state="translated">Запишите в регистр P2 целое число,которое является последней записью в записи в конце индексного ключа,на который указывает курсор P1.Это целое число должно быть строкой записи таблицы,на которую указывает эта запись индекса.</target>
        </trans-unit>
        <trans-unit id="845ccbd564d152c911058efd13330cea72170f39" translate="yes" xml:space="preserve">
          <source>Write into register P2 the complete row content for the row at which cursor P1 is currently pointing. There is no interpretation of the data. It is just copied onto the P2 register exactly as it is found in the database file.</source>
          <target state="translated">Запишите в регистр P2 полное содержимое строки для строки,на которую в данный момент наведен курсор P1.Нет никакой интерпретации данных.Просто скопируйте их в регистр P2 в точности так,как они есть в файле базы данных.</target>
        </trans-unit>
        <trans-unit id="d4da38aa74dee90d46d653efba3b56536b2cc5d2" translate="yes" xml:space="preserve">
          <source>Write into register P2 the current sorter data for sorter cursor P1. Then clear the column header cache on cursor P3.</source>
          <target state="translated">Запишите в регистр P2 текущие данные сортировщика для курсора сортировщика P1.Затем очистить кэш заголовков столбцов на курсоре P3.</target>
        </trans-unit>
        <trans-unit id="4e60b462188e6078fccee2b0f7f0c97876c061b9" translate="yes" xml:space="preserve">
          <source>Write performance measurements were made by replacing (overwriting) an entire blob with a different blob. All of the blobs in these experiment are random and incompressible. Because writes are so much slower than reads, only 10,000 of the 100,000 blobs in the database are replaced. The blobs to be replaced are selected at random and are in no particular order.</source>
          <target state="translated">Замена (перезапись)целого кадра на другой капля была произведена путем измерения производительности.Все капли в этом эксперименте случайны и несжимаемы.Поскольку записи происходят намного медленнее,чем чтение,из 100 000 блоков в базе данных заменено только 10 000.Заменяемые капли выбираются случайным образом и не имеют особого порядка.</target>
        </trans-unit>
        <trans-unit id="97d379c9ca883f0cc777a01b05087d4f85759f23" translate="yes" xml:space="preserve">
          <source>Write the current address onto register P1 and then jump to address P2.</source>
          <target state="translated">Запишите текущий адрес в регистр P1,а затем перейдите на адрес P2.</target>
        </trans-unit>
        <trans-unit id="b9ace1191ba47c3313a30683407724719ddd8866" translate="yes" xml:space="preserve">
          <source>Write the current number of pages in database P1 to memory cell P2.</source>
          <target state="translated">Запишите текущее количество страниц в базу данных P1 в ячейку памяти P2.</target>
        </trans-unit>
        <trans-unit id="91954b8458d0e00b292061c02fc82b69cf42b6c1" translate="yes" xml:space="preserve">
          <source>Write the integer value P3 into cookie number P2 of database P1. P2==1 is the schema version. P2==2 is the database format. P2==3 is the recommended pager cache size, and so forth. P1==0 is the main database file and P1==1 is the database file used to store temporary tables.</source>
          <target state="translated">Запишите целое значение P3 в куки-номер P2 базы данных P1.P2==1-версия схемы.P2==2-формат БД.P2==3-рекомендуемый размер кэша пейджера и так далее.P1==0-основной файл БД,а P1==1-файл БД,используемый для хранения временных таблиц.</target>
        </trans-unit>
        <trans-unit id="4f557ab176f965a00361710b6f978bd703c87e93" translate="yes" xml:space="preserve">
          <source>Write the name of the master journal into all individual journals (in space set aside for that purpose in the headers of the individual journals) and flush the contents of the individual journals to disk and wait for those changes to reach the disk surface.</source>
          <target state="translated">Запишите имя главного журнала во все отдельные журналы (в отведенном для этого месте в заголовках отдельных журналов)и промойте содержимое отдельных журналов на диск и дождитесь,пока эти изменения достигнут поверхности диска.</target>
        </trans-unit>
        <trans-unit id="461c6fd84d21b2e1e58564d3f66dc64dc514f582" translate="yes" xml:space="preserve">
          <source>Write the name of the super-journal into all individual journals (in space set aside for that purpose in the headers of the individual journals) and flush the contents of the individual journals to disk and wait for those changes to reach the disk surface.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7664f788d5d10d956cebf109c73130c0a103849" translate="yes" xml:space="preserve">
          <source>Write transactions are very fast since they only involve writing the content once (versus twice for rollback-journal transactions) and because the writes are all sequential. Further, syncing the content to the disk is not required, as long as the application is willing to sacrifice durability following a power loss or hard reboot. (Writers sync the WAL on every transaction commit if &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous&lt;/a&gt; is set to FULL but omit this sync if &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous&lt;/a&gt; is set to NORMAL.)</source>
          <target state="translated">Транзакции записи выполняются очень быстро, поскольку они включают только однократную запись содержимого (по сравнению с двукратной записью транзакций журнала отката) и поскольку все записи являются последовательными. Кроме того, синхронизация содержимого с диском не требуется, если приложение готово пожертвовать долговечностью после потери питания или жесткой перезагрузки. (Писатели синхронизируют WAL при каждой фиксации транзакции, если &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous&lt;/a&gt; установлен на FULL, но пропускают эту синхронизацию, если &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous&lt;/a&gt; установлен на NORMAL.)</target>
        </trans-unit>
        <trans-unit id="9df19c54f436b6a77ec7817a689a3cb7a8863393" translate="yes" xml:space="preserve">
          <source>Write-Ahead Log Commit Hook</source>
          <target state="translated">Write-Ahead Log Commit Hook</target>
        </trans-unit>
        <trans-unit id="7012a3c8e49b82c45441c8c9cad604aa604cafd1" translate="yes" xml:space="preserve">
          <source>Write-Ahead Logging</source>
          <target state="translated">Запись в журнал</target>
        </trans-unit>
        <trans-unit id="0e7776631ee4a8b853c6c06ce06a6006cefcda96" translate="yes" xml:space="preserve">
          <source>Write-ahead Log (WAL) files</source>
          <target state="translated">Файлы протокола записи (WAL)</target>
        </trans-unit>
        <trans-unit id="e1b6c7d9217381e4c29658c4e3841e70686fb388" translate="yes" xml:space="preserve">
          <source>Writer starvation</source>
          <target state="translated">Писательский голод</target>
        </trans-unit>
        <trans-unit id="e447e06606fdc13a8e426bfdd192c63a84795c86" translate="yes" xml:space="preserve">
          <source>Writers merely append new content to the end of the WAL file. Because writers do nothing that would interfere with the actions of readers, writers and readers can run at the same time. However, since there is only one WAL file, there can only be one writer at a time.</source>
          <target state="translated">Писатели просто добавляют новое содержимое в конец файла WAL.Потому что писатели не делают ничего,что мешало бы действиям читателей,писатели и читатели могут запускаться одновременно.Однако,поскольку существует только один файл WAL,одновременно может работать только один пишущий файл.</target>
        </trans-unit>
        <trans-unit id="51a81481b69a429427cf443afa9b0e120124c1b5" translate="yes" xml:space="preserve">
          <source>Writes are slower. On all systems, using both direct I/O and SQLite, write performance is between 5 and 15 times slower than reads.</source>
          <target state="translated">Писания медленнее.На всех системах,использующих как прямой ввод-вывод,так и SQLite,производительность записи в 5-15 раз медленнее чтения.</target>
        </trans-unit>
        <trans-unit id="a90f9ae1890da2882ef529c18fb80a5589473876" translate="yes" xml:space="preserve">
          <source>Writes to an in-memory source database, or writes to a file-based source database by an external process or thread using a database connection other than pDb are significantly more expensive than writes made to a file-based source database using pDb (as the entire backup operation must be restarted in the former two cases).</source>
          <target state="translated">Запись в исходную базу данных in-memory или запись в файловую исходную базу данных с помощью внешнего процесса или потока,использующего соединение с базой данных,отличное от pDb,значительно дороже,чем запись в файловую исходную базу данных с помощью pDb (так как вся операция резервного копирования должна быть перезапущена в двух предыдущих случаях).</target>
        </trans-unit>
        <trans-unit id="347af0bc198470df77e05081b38d5bcb19f95263" translate="yes" xml:space="preserve">
          <source>Writes to the &lt;a href=&quot;../dbpage&quot;&gt;sqlite_dbpage&lt;/a&gt; virtual table.</source>
          <target state="translated">Записывает в виртуальную таблицу &lt;a href=&quot;../dbpage&quot;&gt;sqlite_dbpage&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="caebec0b3978142dd7d784c5a70a27f827c0fc87" translate="yes" xml:space="preserve">
          <source>Writes to the &lt;a href=&quot;dbpage&quot;&gt;sqlite_dbpage&lt;/a&gt; virtual table.</source>
          <target state="translated">Записывает в виртуальную таблицу &lt;a href=&quot;dbpage&quot;&gt;sqlite_dbpage&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9e632869f49afb8aba3986c578bc41023c0edd69" translate="yes" xml:space="preserve">
          <source>Writing Data</source>
          <target state="translated">Запись данных</target>
        </trans-unit>
        <trans-unit id="46bd9ed0bb52c21d70902da8961ddf970beec522" translate="yes" xml:space="preserve">
          <source>Writing a Journal Header</source>
          <target state="translated">Написание заголовка журнала</target>
        </trans-unit>
        <trans-unit id="563ef87c29c874b30c909b9cb710bc0c375b3734" translate="yes" xml:space="preserve">
          <source>Writing a good query planner is more art than science. The query planner must work with incomplete information. It cannot determine how long any particular plan will take without actually running that plan. So when comparing two or more plans to figure out which is &quot;best&quot;, the query planner has to make some guesses and assumptions and those guesses and assumptions will sometimes be wrong. A good query planner is one that will find the correct solution often enough that application programmers rarely need to get involved.</source>
          <target state="translated">Написание хорошего планировщика запросов-это больше искусство,чем наука.Планировщик запросов должен работать с неполной информацией.Он не может определить,сколько времени займет какой-либо конкретный план,не выполнив его на самом деле.Поэтому при сравнении двух или более планов,чтобы выяснить,какой из них &quot;лучший&quot;,планировщик запросов должен сделать некоторые догадки и предположения,и эти догадки и предположения иногда будут неверными.Хороший планировщик запросов-это такой планировщик,который достаточно часто находит правильное решение,в которое прикладным программистам редко приходится вмешиваться.</target>
        </trans-unit>
        <trans-unit id="0cde81e7d9009da11d97881af257b1563f71fbed" translate="yes" xml:space="preserve">
          <source>Writing the code for a new VFS involves constructing a subclass for the &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object and then registering that VFS object using a call to &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register()&lt;/a&gt;. The VFS implementation also provides subclasses for &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; and &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; but those objects are not registered directly with SQLite. Instead, the &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; object is returned from the xOpen method of &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; and the &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; object points to an instance of the &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object.</source>
          <target state="translated">Написание кода для новой VFS включает в себя создание подкласса для объекта &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs,&lt;/a&gt; а затем регистрацию этого объекта VFS с помощью вызова &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register ()&lt;/a&gt; . Реализация VFS также предоставляет подклассы для &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; и &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods,&lt;/a&gt; но эти объекты не регистрируются напрямую в SQLite. Вместо этого объект &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; возвращается из метода xOpen &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs,&lt;/a&gt; а объект &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; указывает на экземпляр объекта &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7fdb521941b3e5056a81c587e69b7f19860828e9" translate="yes" xml:space="preserve">
          <source>Written in ANSI-C. &lt;a href=&quot;tclsqlite&quot;&gt;TCL bindings&lt;/a&gt; included. Bindings for dozens of other languages available separately.</source>
          <target state="translated">Написано в ANSI-C. &lt;a href=&quot;tclsqlite&quot;&gt;Привязки TCL&lt;/a&gt; включены. Привязки для десятков других языков доступны отдельно.</target>
        </trans-unit>
        <trans-unit id="c032adc1ff629c9b66f22749ad667e6beadf144b" translate="yes" xml:space="preserve">
          <source>X</source>
          <target state="translated">X</target>
        </trans-unit>
        <trans-unit id="ab87b9a32f29182878ebb3a6891a6c4a1092d9ec" translate="yes" xml:space="preserve">
          <source>X is U-35 for table btree leaf pages or ((U-12)*64/255)-23 for index pages.</source>
          <target state="translated">X равно U-35 для табличных btree листовых страниц или ((U-12)*64/255)-23 для индексных страниц.</target>
        </trans-unit>
        <trans-unit id="a43e2726d178277e17345f240dc4baecfd6ece05" translate="yes" xml:space="preserve">
          <source>XLS - Microsoft Excel Spreadsheet</source>
          <target state="translated">XLS-электронная таблица Microsoft Excel</target>
        </trans-unit>
        <trans-unit id="23eb4d3f4155395a74e9d534f97ff4c1908f5aac" translate="yes" xml:space="preserve">
          <source>Y</source>
          <target state="translated">Y</target>
        </trans-unit>
        <trans-unit id="d3f8f7b810c4b08f0b4ac4e47fdf8d265a10d869" translate="yes" xml:space="preserve">
          <source>YYYY-MM-DD</source>
          <target state="translated">YYYY-MM-DD</target>
        </trans-unit>
        <trans-unit id="52249b595b705e3022543f7da9fd802190e92e98" translate="yes" xml:space="preserve">
          <source>YYYY-MM-DD HH:MM</source>
          <target state="translated">ГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГ...</target>
        </trans-unit>
        <trans-unit id="5d7d8fa1d70072dde246c61070188c4587305f0a" translate="yes" xml:space="preserve">
          <source>YYYY-MM-DD HH:MM:SS</source>
          <target state="translated">ГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГ.ГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГГ.</target>
        </trans-unit>
        <trans-unit id="c73c8c3ce69182be88dad37758ba32a3fc0f8563" translate="yes" xml:space="preserve">
          <source>YYYY-MM-DD HH:MM:SS.SSS</source>
          <target state="translated">ЙЫЙ-ММ-ДДД HH:MM:SS.SSS</target>
        </trans-unit>
        <trans-unit id="5397e0583f14f6c88de06b1ef28f460a1fb5b0ae" translate="yes" xml:space="preserve">
          <source>Yes</source>
          <target state="translated">Yes</target>
        </trans-unit>
        <trans-unit id="5374d3a8e418edba680d4a07da2c6ab36a4e8962" translate="yes" xml:space="preserve">
          <source>Yes. SQLite is in the &lt;a href=&quot;https://sqlite.org/copyright.html&quot;&gt;public domain&lt;/a&gt;. No claim of ownership is made to any part of the code. You can do anything you want with it.</source>
          <target state="translated">Да. SQLite находится в &lt;a href=&quot;https://sqlite.org/copyright.html&quot;&gt;открытом доступе&lt;/a&gt; . Никакие претензии на право собственности не предъявляются к какой-либо части кода. Вы можете делать с ним все, что хотите.</target>
        </trans-unit>
        <trans-unit id="33b0fd0f74faa27daf44c1c690d408e467aa0dd1" translate="yes" xml:space="preserve">
          <source>Yield</source>
          <target state="translated">Yield</target>
        </trans-unit>
        <trans-unit id="84033aeb092c1214f0c2cb3aece38e6ba6958175" translate="yes" xml:space="preserve">
          <source>Yields 20 results beginning with:</source>
          <target state="translated">Дает 20 результатов,начиная с:</target>
        </trans-unit>
        <trans-unit id="0e3a778de9e9a5f44253370ab8c9e4efcbf47122" translate="yes" xml:space="preserve">
          <source>You can access the ROWID of an SQLite table using one of the special column names ROWID, _ROWID_, or OID. Except if you declare an ordinary table column to use one of those special names, then the use of that name will refer to the declared column not to the internal ROWID.</source>
          <target state="translated">Вы можете получить доступ к ROWID таблицы SQLite,используя одно из специальных названий колонок ROWID,_ROWID_или OID.За исключением случаев,когда вы объявляете обычную колонку таблицы для использования одного из этих специальных имён,то использование этого имени будет относиться к объявленной колонке,а не к внутреннему ROWID.</target>
        </trans-unit>
        <trans-unit id="f9617c865e05039ea284590d342ff395b566aa5e" translate="yes" xml:space="preserve">
          <source>You can add new custom &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt;, &lt;a href=&quot;datatype3#collation&quot;&gt;collating sequences&lt;/a&gt;, &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt;, and &lt;a href=&quot;vfs&quot;&gt;VFSes&lt;/a&gt; to the command-line shell at run-time using the &quot;.load&quot; command. First, convert the extension in to a DLL or shared library (as described in the &lt;a href=&quot;loadext&quot;&gt;Run-Time Loadable Extensions&lt;/a&gt; document) then type:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="766fd041e7449721a800b8d56d1a550c8e84e175" translate="yes" xml:space="preserve">
          <source>You can add new custom &lt;a href=&quot;c3ref/create_function&quot;&gt;application-defined SQL functions&lt;/a&gt;, &lt;a href=&quot;datatype3#collation&quot;&gt;collating sequences&lt;/a&gt;, &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt;, and &lt;a href=&quot;vfs&quot;&gt;VFSes&lt;/a&gt; to the command-line shell at run-time using the &quot;.load&quot; command. First, convert the extension in to a DLL or shared library (as described in the &lt;a href=&quot;loadext&quot;&gt;Run-Time Loadable Extensions&lt;/a&gt; document) then type:</source>
          <target state="translated">Вы можете добавить новые пользовательские &lt;a href=&quot;c3ref/create_function&quot;&gt;определяемые приложением функции SQL&lt;/a&gt; , &lt;a href=&quot;datatype3#collation&quot;&gt;последовательности сортировки&lt;/a&gt; , &lt;a href=&quot;vtab&quot;&gt;виртуальные таблицы&lt;/a&gt; и &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; в оболочку командной строки во время выполнения с помощью команды &amp;laquo;.load&amp;raquo;. Сначала преобразуйте расширение в DLL или общую библиотеку (как описано в документе &amp;laquo; &lt;a href=&quot;loadext&quot;&gt;Загружаемые расширения времени выполнения&amp;raquo;&lt;/a&gt; ), затем введите:</target>
        </trans-unit>
        <trans-unit id="f503e6243f11ce8864a2a2815733bb53ffb62dce" translate="yes" xml:space="preserve">
          <source>You can also process the results of a query one row at a time by specifying the name of an array variable and a script following the SQL code. For each row of the query result, the values of all columns will be inserted into the array variable and the script will be executed. For instance:</source>
          <target state="translated">Также можно обрабатывать результаты запроса по одной строке за раз,указав имя переменной массива и скрипт,следуя SQL-коду.Для каждой строки результата запроса значения всех столбцов будут вставлены в переменную массива и выполнен скрипт.Например:</target>
        </trans-unit>
        <trans-unit id="cff814001d9391d1134a9599b4429c6538fee547" translate="yes" xml:space="preserve">
          <source>You can also provide the virtual table with a &quot;rank&quot; for each word. The &quot;rank&quot; is an estimate of how common the word is. Larger numbers mean the word is more common. If you omit the rank when populating the table, then a rank of 1 is assumed. But if you have rank information, you can supply it and the virtual table will show a slight preference for selecting more commonly used terms. To populate the rank from an fts4aux table &quot;search_aux&quot; do something like this:</source>
          <target state="translated">Вы также можете предоставить виртуальную таблицу с &quot;рангом&quot; для каждого слова.Звание&quot;-это оценка того,насколько распространено это слово.Большие числа означают,что слово более распространено.Если при заполнении таблицы опустить &quot;ранг&quot;,то предполагается,что это слово имеет ранг 1.Но если у вас есть информация о ранге,вы можете ее предоставить,и в виртуальной таблице будет показано небольшое предпочтение при выборе более распространенных терминов.Для заполнения ранга из таблицы fts4aux &quot;search_aux&quot; сделайте что-нибудь подобное:</target>
        </trans-unit>
        <trans-unit id="adf32fc901d0b3c9c4d8f663c01fbe75c182af0b" translate="yes" xml:space="preserve">
          <source>You can also request a reverse-order sort like this:</source>
          <target state="translated">Вы также можете запросить сортировку по обратному заказу,как этот:</target>
        </trans-unit>
        <trans-unit id="6faf0acbd59c9b880e0b1c9b8cab39235a6257e9" translate="yes" xml:space="preserve">
          <source>You can call your project anything you like. The &quot;&lt;code&gt;.fossil&lt;/code&gt;&quot; suffix is optional. For this document, we will continue to call the project &quot;&lt;code&gt;private-project.fossil&lt;/code&gt;&quot;. Note that &lt;code&gt;private-project.fossil&lt;/code&gt; is an ordinary disk file (actually an SQLite database) that will contain your complete project history. You can make a backup of the project simply by making a copy of that one file.</source>
          <target state="translated">Вы можете называть свой проект как угодно. &lt;code&gt;.fossil&lt;/code&gt; &amp;laquo; .fossil &amp;raquo; указывать не обязательно. В этом документе мы продолжим называть проект &amp;laquo; &lt;code&gt;private-project.fossil&lt;/code&gt; &amp;raquo;. Обратите внимание, что &lt;code&gt;private-project.fossil&lt;/code&gt; - это обычный дисковый файл (фактически база данных SQLite), который будет содержать полную историю вашего проекта. Вы можете сделать резервную копию проекта, просто сделав копию этого файла.</target>
        </trans-unit>
        <trans-unit id="a7e393b006953ea5c66642b8797a473726aa00ab" translate="yes" xml:space="preserve">
          <source>You can have multiple checkouts of the same project if you want. And you can &quot;clone&quot; the repository to different machines so that multiple developers can use it. See the fossil website for further information.</source>
          <target state="translated">При желании вы можете иметь несколько проверок одного и того же проекта.И вы можете &quot;клонировать&quot; хранилище на разные машины,чтобы его могли использовать несколько разработчиков.Дополнительную информацию смотрите на сайте &quot;Ископаемые&quot;.</target>
        </trans-unit>
        <trans-unit id="0eaaecfbb43e45dd392f3506c8da0516ce5d97d1" translate="yes" xml:space="preserve">
          <source>You can run the &quot;info&quot; command again to verify that you are on the private branch. To go back to the public branch, type:</source>
          <target state="translated">Вы можете запустить команду &quot;info&quot; еще раз,чтобы проверить,что вы находитесь в частной ветке.Чтобы вернуться в публичную ветку,введите:</target>
        </trans-unit>
        <trans-unit id="445e03eebf2a496b04ef2b41a7e5575686b7c24c" translate="yes" xml:space="preserve">
          <source>You can see how SQLite constructs nested loops in the following example:</source>
          <target state="translated">Вы можете посмотреть,как SQLite строит вложенные циклы в следующем примере:</target>
        </trans-unit>
        <trans-unit id="64e589fcb69790fd074e7b79362cd1b733d9786f" translate="yes" xml:space="preserve">
          <source>You can use &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt; to do a thorough but time intensive test of the database integrity.</source>
          <target state="translated">Вы можете использовать &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA Integrity_check&lt;/a&gt; для тщательного, но трудоемкого тестирования целостности базы данных.</target>
        </trans-unit>
        <trans-unit id="89132b9f9cffd74c2cdc7fb086ca8110533325a1" translate="yes" xml:space="preserve">
          <source>You can use &lt;a href=&quot;pragma#pragma_quick_check&quot;&gt;PRAGMA quick_check&lt;/a&gt; to do a faster but less thorough test of the database integrity.</source>
          <target state="translated">Вы можете использовать &lt;a href=&quot;pragma#pragma_quick_check&quot;&gt;PRAGMA quick_check&lt;/a&gt; для более быстрой, но менее тщательной проверки целостности базы данных.</target>
        </trans-unit>
        <trans-unit id="322edc4ffe1c2dcc35efd77efa0d7e1857777962" translate="yes" xml:space="preserve">
          <source>You can use the &quot;.mode&quot; dot command to switch between these output formats. &amp;gt;The default output mode is &quot;list&quot;. In list mode, each row of a query result is written on one line of output and each column within that row is separated by a specific separator string. The default separator is a pipe symbol (&quot;|&quot;). List mode is especially useful when you are going to send the output of a query to another program (such as AWK) for additional processing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e92aed886574f82b46aed1073eadf0a43514f93b" translate="yes" xml:space="preserve">
          <source>You cannot &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt;, &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;, or &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; a view. Views are read-only in SQLite. However, in many cases you can use an &lt;a href=&quot;lang_createtrigger#instead_of_trigger&quot;&gt;INSTEAD OF trigger&lt;/a&gt; on the view to accomplish the same thing. Views are removed with the &lt;a href=&quot;lang_dropview&quot;&gt;DROP VIEW&lt;/a&gt; command.</source>
          <target state="translated">Вы не можете &lt;a href=&quot;lang_delete&quot;&gt;УДАЛИТЬ&lt;/a&gt; , &lt;a href=&quot;lang_insert&quot;&gt;ВСТАВИТЬ&lt;/a&gt; или &lt;a href=&quot;lang_update&quot;&gt;ОБНОВИТЬ&lt;/a&gt; представление. Представления в SQLite доступны только для чтения. Однако во многих случаях вы можете использовать &lt;a href=&quot;lang_createtrigger#instead_of_trigger&quot;&gt;триггер INSTEAD OF&lt;/a&gt; в представлении, чтобы выполнить то же самое. Виды удаляются с помощью команды &lt;a href=&quot;lang_dropview&quot;&gt;DROP VIEW&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e3029ec6343085341759c5984c721d08ac8eda9c" translate="yes" xml:space="preserve">
          <source>You lose Durability with asynchronous I/O, but you still retain the other parts of ACID: Atomic, Consistent, and Isolated. Many applications get along fine without the Durability.</source>
          <target state="translated">Вы теряете Долговечность с асинхронным вводом/выводом,но при этом сохраняете остальные части ACID:Атомную,Последовательную и Изолированную.Многие приложения прекрасно уживаются без Долговечности.</target>
        </trans-unit>
        <trans-unit id="2edf5e92e2eb8b4ae5fa4b416e11d2c19ee0f6b2" translate="yes" xml:space="preserve">
          <source>You may want to add additional compiler options, of course, according to the needs of your project.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4dd05146b6c50e8243d5d884c39ba78d8eacc3ab" translate="yes" xml:space="preserve">
          <source>You might also want to implement your new virtual table as a &lt;a href=&quot;c3ref/load_extension&quot;&gt;loadable extension&lt;/a&gt;.</source>
          <target state="translated">Вы также можете реализовать свою новую виртуальную таблицу как &lt;a href=&quot;c3ref/load_extension&quot;&gt;загружаемое расширение&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5967e28677480dfa358973a1823f7ea8ef646b1f" translate="yes" xml:space="preserve">
          <source>You might also want to implement your new virtual table as a &lt;a href=&quot;loadext&quot;&gt;loadable extension&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af0efe31561de911c0e8b4a9d062c5a0f356df3b" translate="yes" xml:space="preserve">
          <source>You should not assume that a CVE about SQLite contains authoritative information. CVEs often contain inaccuracies. The SQLite developers have attempted to add clarifications and corrections to CVEs about SQLite, but without success.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bedd0d05da99d3f3471d33a570e1e743621d6387" translate="yes" xml:space="preserve">
          <source>You will be prompted for a check-in comment. Say whatever you like. After the commit completes, your baseline will be part of the repository. The following command, if you like, to see this on the &quot;timeline&quot;:</source>
          <target state="translated">Вам будет предложено оставить комментарий к регистрации.Говорите,что хотите.После завершения коммита ваша базовая информация станет частью репозитория.Следующая команда,если вы хотите,чтобы это было видно на &quot;временной шкале&quot;:</target>
        </trans-unit>
        <trans-unit id="fd47b0381210b18fb651f05af57837f2ec742bdf" translate="yes" xml:space="preserve">
          <source>You will be prompted once again to enter a commit describing your changes. Then the commit will occur. The commit creates a new checkin in the repository that corresponds to circle (3) in the diagram above.</source>
          <target state="translated">Вам снова будет предложено ввести фиксацию,описывающую ваши изменения.Затем произойдет фиксация.Фиксация создаёт в хранилище новую регистрацию,которая соответствует кругу (3)на диаграмме выше.</target>
        </trans-unit>
        <trans-unit id="d5cd5e33edb7ba1f8da45a2c106b29f5d941a815" translate="yes" xml:space="preserve">
          <source>You will do well to customize the name of your entry point to correspond to the name of the shared library you will be generating, rather than using the generic &quot;sqlite3_extension_init&quot; name. Giving your extension a custom entry point name will enable you to statically link two or more extensions into the same program without a linker conflict, if you later decide to use static linking rather than run-time linking. If your shared library ends up being named &quot;YourCode.so&quot; or &quot;YourCode.dll&quot; or &quot;YourCode.dylib&quot; as shown in the compiler examples above, then the correct entry point name would be &quot;sqlite3_yourcode_init&quot;.</source>
          <target state="translated">Вам будет удобно настроить имя вашей точки входа,чтобы оно соответствовало названию разделяемой библиотеки,которую вы будете генерировать,вместо того,чтобы использовать общее &quot;sqlite3_extension_init&quot; имя.Придание вашему расширению пользовательского имени точки входа позволит вам статически связывать два или более расширения в одну и ту же программу без конфликта компоновщиков,если позже вы решите использовать статическое линковочное соединение,а не компоновку во время выполнения.Если ваша разделяемая библиотека получит имя &quot;YourCode.so&quot; или &quot;YourCode.dll&quot; или &quot;YourCode.dylib&quot;,как показано в примерах компилятора выше,то правильным именем точки входа будет &quot;sqlite3_yourcode_init&quot;.</target>
        </trans-unit>
        <trans-unit id="7ea7cb4b66409b042916564a60165ee172534600" translate="yes" xml:space="preserve">
          <source>You will notice that there is no &quot;sort&quot; box anywhere in the above diagram. The ORDER BY clause of the query has become a no-op. No sorting has to be done here because the output order is by the state column and the state column also happens to be the first column after the fruit column in the index. So, if we scan entries of the index that have the same value for the fruit column from top to bottom, those index entries are guaranteed to be ordered by the state column.</source>
          <target state="translated">Вы заметите,что нигде на вышеприведенной диаграмме нет поля &quot;сортировка&quot;.Фраза &quot;ЗАКАЗАТЬ ПО&quot; в запросе превратилась в точку &quot;нет&quot;.Здесь сортировка не требуется,так как порядок вывода осуществляется по столбцу состояния,а столбец состояния также оказывается первым столбцом после столбца фруктов в индексе.Таким образом,если мы просканируем сверху вниз записи индекса,которые имеют одинаковое значение для столбца фруктов,то эти записи индекса гарантированно будут упорядочены по столбцу состояния.</target>
        </trans-unit>
        <trans-unit id="909f99a779adb66a76fc53ab56c7dd1caf35d0fd" translate="yes" xml:space="preserve">
          <source>Z</source>
          <target state="translated">Z</target>
        </trans-unit>
        <trans-unit id="de7c952ac8080a02c7ac9ceb0a498a6696e8a4ba" translate="yes" xml:space="preserve">
          <source>ZIP Archive (using &lt;a href=&quot;zipfile&quot;&gt;zipfile&lt;/a&gt;)</source>
          <target state="translated">ZIP-архив (с использованием &lt;a href=&quot;zipfile&quot;&gt;zip-файла&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="aed9db86a6be4caef2cf6fe06f1642f420130c81" translate="yes" xml:space="preserve">
          <source>ZIP Archive (using Info-ZIP 3.0)</source>
          <target state="translated">ZIP-архив (с использованием Info-ZIP 3.0)</target>
        </trans-unit>
        <trans-unit id="02df620236f2819dde38ac784010df88429081e2" translate="yes" xml:space="preserve">
          <source>Zero Scan-Status Counters</source>
          <target state="translated">Счетчики нулевого статуса сканирования</target>
        </trans-unit>
        <trans-unit id="1c76cf24ab11047f65399e2ad41b068487b4d36e" translate="yes" xml:space="preserve">
          <source>Zero all &lt;a href=&quot;#sqlite3_stmt_scanstatus&quot;&gt;sqlite3_stmt_scanstatus()&lt;/a&gt; related event counters.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_stmt_scanstatus&quot;&gt;Обнулить&lt;/a&gt; все счетчики событий, связанных с sqlite3_stmt_scanstatus () .</target>
        </trans-unit>
        <trans-unit id="0189ea1500b8f88a4d451f2fe03811a0d2084600" translate="yes" xml:space="preserve">
          <source>Zero all &lt;a href=&quot;stmt_scanstatus&quot;&gt;sqlite3_stmt_scanstatus()&lt;/a&gt; related event counters.</source>
          <target state="translated">&lt;a href=&quot;stmt_scanstatus&quot;&gt;Обнулить&lt;/a&gt; все счетчики событий, связанных с sqlite3_stmt_scanstatus () .</target>
        </trans-unit>
        <trans-unit id="3ab2b2e76dc0457f3573e771bc76b7e1dc6d462e" translate="yes" xml:space="preserve">
          <source>Zero or more changesets (or patchsets) are added to the object by calling sqlite3changegroup_add().</source>
          <target state="translated">Ноль или больше изменяемых наборов (или патчсетов)добавляются к объекту с помощью вызова sqlite3changegroup_add().</target>
        </trans-unit>
        <trans-unit id="ec69186fcac6fdc7aea5f5bb931cc915fc4d16f5" translate="yes" xml:space="preserve">
          <source>Zero or more escape sequences of the form &quot;&lt;b&gt;%&lt;i&gt;HH&lt;/i&gt;&lt;/b&gt;&quot; (where &lt;b&gt;&lt;i&gt;H&lt;/i&gt;&lt;/b&gt; represents any hexadecimal digit) can occur in the path, query string, or fragment.</source>
          <target state="translated">В пути, строке запроса или фрагменте могут встречаться ноль или более управляющих последовательностей формы &amp;laquo; &lt;b&gt;% &lt;i&gt;HH&lt;/i&gt;&lt;/b&gt; &amp;raquo; (где &lt;b&gt;&lt;i&gt;H&lt;/i&gt;&lt;/b&gt; представляет собой любую шестнадцатеричную цифру).</target>
        </trans-unit>
        <trans-unit id="de6b47760256c38c352e812a03525532f246ee01" translate="yes" xml:space="preserve">
          <source>Zero or more of the following constants can be OR-ed together for the F argument to &lt;a href=&quot;#sqlite3_serialize&quot;&gt;sqlite3_serialize(D,S,P,F)&lt;/a&gt;.</source>
          <target state="translated">Ноль или несколько следующих констант могут быть объединены &lt;a href=&quot;#sqlite3_serialize&quot;&gt;оператором&lt;/a&gt; ИЛИ для аргумента F для sqlite3_serialize (D, S, P, F) .</target>
        </trans-unit>
        <trans-unit id="9f8269aa118af918f1a488e66741b01a907d6b33" translate="yes" xml:space="preserve">
          <source>Zero or more of the following constants can be OR-ed together for the F argument to &lt;a href=&quot;serialize&quot;&gt;sqlite3_serialize(D,S,P,F)&lt;/a&gt;.</source>
          <target state="translated">Ноль или несколько следующих констант могут быть объединены &lt;a href=&quot;serialize&quot;&gt;оператором&lt;/a&gt; ИЛИ для аргумента F для sqlite3_serialize (D, S, P, F) .</target>
        </trans-unit>
        <trans-unit id="38a2e2f1db1e01b0a7b783b044e5fd65c8987a39" translate="yes" xml:space="preserve">
          <source>Zero or more term-offset lists. A term-offset list is present for each column of the FTS virtual table that contains the term. A term-offset list consists of the following:</source>
          <target state="translated">Ноль или более списков смещения сроков.Для каждого столбца виртуальной таблицы FTS,содержащего термин,присутствует термин-сопоставительный список.Сменный список состоит из следующего:</target>
        </trans-unit>
        <trans-unit id="2515b49203ae7509e436f1b0d49f1c8ee6f4b1c9" translate="yes" xml:space="preserve">
          <source>Zero-Configuration</source>
          <target state="translated">Zero-Configuration</target>
        </trans-unit>
        <trans-unit id="eb706c03a671590ecb5597ee5876c02079a3bb36" translate="yes" xml:space="preserve">
          <source>Zipfile is included in most builds of the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt;.</source>
          <target state="translated">Zipfile включен в большинство сборок &lt;a href=&quot;cli&quot;&gt;оболочки командной строки&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="17013934d72000f10774f09cdfd9e948aabb0622" translate="yes" xml:space="preserve">
          <source>[+-]HH:MM</source>
          <target state="translated">[+-]HH:MM</target>
        </trans-unit>
        <trans-unit id="41cd6acf1ea38a1aa799ac385ce472b7a37c5a7c" translate="yes" xml:space="preserve">
          <source>[Top]</source>
          <target state="translated">[Top]</target>
        </trans-unit>
        <trans-unit id="6eb6de05767c9dc240cdb86a107e8527d6654c55" translate="yes" xml:space="preserve">
          <source>]&quot;.</source>
          <target state="translated">]&quot;.</target>
        </trans-unit>
        <trans-unit id="86f7e437faa5a7fce15d1ddcb9eaeaea377667b8" translate="yes" xml:space="preserve">
          <source>a</source>
          <target state="translated">a</target>
        </trans-unit>
        <trans-unit id="c8cfbdcc11a659b37fda2e901e339fc12d9d6f46" translate="yes" xml:space="preserve">
          <source>a file causes all modifications to the file up until that point to be committed to persistent storage.</source>
          <target state="translated">файл вызывает все изменения в файле вплоть до этого момента,чтобы зафиксировать их в постоянном хранилище.</target>
        </trans-unit>
        <trans-unit id="99cb3c351b6439359c3dacbec2f049764ce3028c" translate="yes" xml:space="preserve">
          <source>a journal file may contain. Following the</source>
          <target state="translated">файл журнала может содержать.После</target>
        </trans-unit>
        <trans-unit id="5cc80862da2aa33790fc037208b79509f1c557d6" translate="yes" xml:space="preserve">
          <source>a power failure.</source>
          <target state="translated">сбой электропитания.</target>
        </trans-unit>
        <trans-unit id="2d1a9beeff6f7710a34b3c2405a0c15a35e9231d" translate="yes" xml:space="preserve">
          <source>a program crash,</source>
          <target state="translated">сбой программы,</target>
        </trans-unit>
        <trans-unit id="044751c5b1c31e8b348678fdf3c4db6f20debbf5" translate="yes" xml:space="preserve">
          <source>a working VFS implementation.</source>
          <target state="translated">работающая VFS реализация.</target>
        </trans-unit>
        <trans-unit id="b66efa612eeb7d14f8d4f699c7f42ef4efb2b728" translate="yes" xml:space="preserve">
          <source>a working memory allocation subsystem (assuming it lacks malloc() in its standard library), and</source>
          <target state="translated">подсистему выделения рабочей памяти (предполагая,что в ее стандартной библиотеке отсутствует malloc()),и</target>
        </trans-unit>
        <trans-unit id="f0125a8f48ac7cbf3a0fa6f9e607bcb1e7c92c25" translate="yes" xml:space="preserve">
          <source>a working mutex subsystem (but only if it is multithreaded),</source>
          <target state="translated">работающая подсистема мьютекса (но только если она многопоточная),</target>
        </trans-unit>
        <trans-unit id="2708db21dcd7430a52e6469ee28e1cfe107f6d3c" translate="yes" xml:space="preserve">
          <source>a&amp;gt;b &amp;amp;&amp;amp; c!=25</source>
          <target state="translated">a&amp;gt; b &amp;amp;&amp;amp; c! = 25</target>
        </trans-unit>
        <trans-unit id="4df530c1726c0c2dee72ae091abc6bd6366e8d88" translate="yes" xml:space="preserve">
          <source>a&amp;gt;b &amp;amp;&amp;amp; c==25</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c52869f9771a308e55286d56b7765c30b708737a" translate="yes" xml:space="preserve">
          <source>a&amp;gt;b &amp;amp;&amp;amp; c==25 =b&amp;gt;</source>
          <target state="translated">а&amp;gt; b &amp;amp;&amp;amp; c == 25 = b&amp;gt;</target>
        </trans-unit>
        <trans-unit id="5ba16853ba475b847e9429658486a0e661f3bc0e" translate="yes" xml:space="preserve">
          <source>a&amp;lt;=b</source>
          <target state="translated">a&amp;lt;=b</target>
        </trans-unit>
        <trans-unit id="9e998d733fc47f01798c218ccb15b1375f8ca7c0" translate="yes" xml:space="preserve">
          <source>aAtomically releases the mutex and begins waiting for the asynchronous signal. When the signal arrives, continue.</source>
          <target state="translated">aAtomically освобождает мьютекс и начинает ждать асинхронного сигнала.Когда сигнал поступает,продолжайте.</target>
        </trans-unit>
        <trans-unit id="d068232ae7c98b60d3a07f78329a8f8cd2f26cec" translate="yes" xml:space="preserve">
          <source>aCksum</source>
          <target state="translated">aCksum</target>
        </trans-unit>
        <trans-unit id="a28254579c1920fcb23f28e750841b8ea01ece0f" translate="yes" xml:space="preserve">
          <source>aFrameCksum</source>
          <target state="translated">aFrameCksum</target>
        </trans-unit>
        <trans-unit id="8c9e7345f56d0515bc5b2a5a870c41d7b20d851a" translate="yes" xml:space="preserve">
          <source>aSalt</source>
          <target state="translated">aSalt</target>
        </trans-unit>
        <trans-unit id="b61646f016483b318b49a910668a966b6ce09ede" translate="yes" xml:space="preserve">
          <source>abort</source>
          <target state="translated">abort</target>
        </trans-unit>
        <trans-unit id="3e0d398e9ad5183bd74b0f22b3607f6d2d47ead6" translate="yes" xml:space="preserve">
          <source>abort() if X is false</source>
          <target state="translated">abort()if X is false</target>
        </trans-unit>
        <trans-unit id="c9f50c848be6913a38840cd508defd4c03582b92" translate="yes" xml:space="preserve">
          <source>abort() if X is true</source>
          <target state="translated">abort()if X is true</target>
        </trans-unit>
        <trans-unit id="f486f320564a8de306d258d39e1ac70a94dc6b0b" translate="yes" xml:space="preserve">
          <source>abs()</source>
          <target state="translated">abs()</target>
        </trans-unit>
        <trans-unit id="175250e2ace0eb1ce52a755c70fb5f1e848bdc1d" translate="yes" xml:space="preserve">
          <source>abs(X)</source>
          <target state="translated">abs(X)</target>
        </trans-unit>
        <trans-unit id="34eb4c4ef005207e8b8f916b9f1fffacccd6945e" translate="yes" xml:space="preserve">
          <source>action</source>
          <target state="translated">action</target>
        </trans-unit>
        <trans-unit id="e026c9e0723fb491279a1eff3c805402a81d6cd2" translate="yes" xml:space="preserve">
          <source>ad hoc</source>
          <target state="translated">в отдельном случае</target>
        </trans-unit>
        <trans-unit id="3cfcd3a79bc61923da5dfbb696d2409e4b2955e4" translate="yes" xml:space="preserve">
          <source>added to the journal file since the header was written.</source>
          <target state="translated">добавлен в файл журнала с момента написания заголовка.</target>
        </trans-unit>
        <trans-unit id="e62854369199d65b6a66cd90fe8203ac4d5be26c" translate="yes" xml:space="preserve">
          <source>advanced</source>
          <target state="translated">advanced</target>
        </trans-unit>
        <trans-unit id="9fca44c2ac1801310ef43bc3ad99ef04caf5190c" translate="yes" xml:space="preserve">
          <source>against the next row in the partition. Or, if there is no next row (because the current row is the last), NULL.</source>
          <target state="translated">к следующей строке раздела.Или,если нет следующей строки (потому что текущая строка-последняя),NULL.</target>
        </trans-unit>
        <trans-unit id="fc7e290f7ebb032393569e65485ec8d9e70de97a" translate="yes" xml:space="preserve">
          <source>against the previous row in the partition. Or, if there is no previous row (because the current row is the first), NULL.</source>
          <target state="translated">против предыдущего ряда в разделе.Или,если нет предыдущей строки (потому что текущая строка является первой),NULL.</target>
        </trans-unit>
        <trans-unit id="deb7d98201c161da24f10c309ec91b3c307e1924" translate="yes" xml:space="preserve">
          <source>against the row</source>
          <target state="translated">в ряд</target>
        </trans-unit>
        <trans-unit id="bccf7370fc6bc7e65ebb00bcd447b407dc6e3ec1" translate="yes" xml:space="preserve">
          <source>aggregate functions</source>
          <target state="translated">совокупные функции</target>
        </trans-unit>
        <trans-unit id="c0b3f3a802faf343304cca8929b77fc1f241297f" translate="yes" xml:space="preserve">
          <source>aggregate-function-invocation</source>
          <target state="translated">aggregate-function-invocation</target>
        </trans-unit>
        <trans-unit id="17422272e67559a3f7043ba681f79c857b96e811" translate="yes" xml:space="preserve">
          <source>aggregate-function-invocation:</source>
          <target state="translated">aggregate-function-invocation:</target>
        </trans-unit>
        <trans-unit id="0ce6198cbd869f28abe7f6b1573ce0dca8a6170f" translate="yes" xml:space="preserve">
          <source>aligned offset. If the</source>
          <target state="translated">выровненное смещение.Если</target>
        </trans-unit>
        <trans-unit id="82f012d8e89e96e64b5b43b4004cf3ddd68b00da" translate="yes" xml:space="preserve">
          <source>aligned offset. To achieve this, unused space may be left between the start of the second and subsequent</source>
          <target state="translated">выровненное смещение.Для этого можно оставить неиспользованное пространство между началом второго и последующими</target>
        </trans-unit>
        <trans-unit id="d87c448044defb778f33158d8ccf94a20531d600" translate="yes" xml:space="preserve">
          <source>all</source>
          <target state="translated">all</target>
        </trans-unit>
        <trans-unit id="e5a003eeac959723c3ac098ade590d12e2399fce" translate="yes" xml:space="preserve">
          <source>all compound operators must be UNION ALL, and</source>
          <target state="translated">все операторы комплекса должны быть ВСЕМ ЮНИОНОМ,и</target>
        </trans-unit>
        <trans-unit id="00c64f4edd51735ee4805d2cd8ebddb9e26e5786" translate="yes" xml:space="preserve">
          <source>along with a check-sum and some well known values that allow the</source>
          <target state="translated">наряду с контрольной суммой и некоторыми известными значениями,позволяющими</target>
        </trans-unit>
        <trans-unit id="4279d9254704eb29ea44fb0e50a8ddb988cb2a74" translate="yes" xml:space="preserve">
          <source>alter-table-stmt</source>
          <target state="translated">alter-table-stmt</target>
        </trans-unit>
        <trans-unit id="c11a9c425781e80397705cfadef04d01cc8571d9" translate="yes" xml:space="preserve">
          <source>alter-table-stmt:</source>
          <target state="translated">alter-table-stmt:</target>
        </trans-unit>
        <trans-unit id="c3869211fefbf6b6e81eafcd0da03d8e0475ead7" translate="yes" xml:space="preserve">
          <source>always contain NULL values. For detail=none FTS5 tables, there is one row in the fts5vocab table for each unique term/doc combination.</source>
          <target state="translated">всегда содержат NULL-значения.Для таблиц FTS5 Detail=none в таблице fts5vocab имеется одна строка для каждой уникальной комбинации терминов/документов.</target>
        </trans-unit>
        <trans-unit id="78cf975130f01cdd3fb405501316e890ca5febeb" translate="yes" xml:space="preserve">
          <source>always false</source>
          <target state="translated">всегда ложный</target>
        </trans-unit>
        <trans-unit id="6cef04a132263fde51363b40fa3650c95beaa2e8" translate="yes" xml:space="preserve">
          <source>always occurs immediately after</source>
          <target state="translated">всегда происходит сразу после</target>
        </trans-unit>
        <trans-unit id="8d366ac66fb75ef6f601b4c82844cb7dabd40b61" translate="yes" xml:space="preserve">
          <source>always true</source>
          <target state="translated">всегда верно</target>
        </trans-unit>
        <trans-unit id="99d26625ec46b669549bed203aadeeb8e64a4713" translate="yes" xml:space="preserve">
          <source>an operating system crash, or</source>
          <target state="translated">сбой операционной системы,или</target>
        </trans-unit>
        <trans-unit id="e8db58b357be34c74707754f9ca1081a83143c52" translate="yes" xml:space="preserve">
          <source>analysis_limit</source>
          <target state="translated">analysis_limit</target>
        </trans-unit>
        <trans-unit id="1350a1a764c20c868eadef7c58ee7702c2de5903" translate="yes" xml:space="preserve">
          <source>analyze-stmt</source>
          <target state="translated">analyze-stmt</target>
        </trans-unit>
        <trans-unit id="09eeed07e3a7b9306cc98d6241ef6473440a058c" translate="yes" xml:space="preserve">
          <source>analyze-stmt:</source>
          <target state="translated">analyze-stmt:</target>
        </trans-unit>
        <trans-unit id="cffa50a32cb13a240d705317bcec65dd1f31b6ad" translate="yes" xml:space="preserve">
          <source>and</source>
          <target state="translated">and</target>
        </trans-unit>
        <trans-unit id="c6138c4ccbaf04ec977b0820c3026e263f957c37" translate="yes" xml:space="preserve">
          <source>and close the file handle opened on the</source>
          <target state="translated">и закройте файловую рукоятку,открытую на</target>
        </trans-unit>
        <trans-unit id="6a33f8ae1b5e041f1c572480c32c63e5cf451da7" translate="yes" xml:space="preserve">
          <source>and delete the</source>
          <target state="translated">и удалить</target>
        </trans-unit>
        <trans-unit id="b548e44c6b3e17d130e04633195b82b65a7a2d94" translate="yes" xml:space="preserve">
          <source>and must not be rolled back.</source>
          <target state="translated">и не должны откатываться.</target>
        </trans-unit>
        <trans-unit id="9daed09ae8efcee7e50da2fbe84487fe3eebb5b9" translate="yes" xml:space="preserve">
          <source>and optionally a</source>
          <target state="translated">и по желанию</target>
        </trans-unit>
        <trans-unit id="52d79db62a2014940054db6b52cb55b0ffc7318b" translate="yes" xml:space="preserve">
          <source>and query</source>
          <target state="translated">и спрашивать</target>
        </trans-unit>
        <trans-unit id="95a8e5d9020987b9a76b684159376ad45fec7409" translate="yes" xml:space="preserve">
          <source>and read data from a database file.</source>
          <target state="translated">и читать данные из файла базы данных.</target>
        </trans-unit>
        <trans-unit id="8b160fc621bf3b69e2326873b90cc01b0f9a0064" translate="yes" xml:space="preserve">
          <source>and so on. There is no limit to the number of</source>
          <target state="translated">и так далее.Нет никаких ограничений на количество</target>
        </trans-unit>
        <trans-unit id="38d402cb5ba5ced669d83f33b900f232ec58d72a" translate="yes" xml:space="preserve">
          <source>and the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52b8b92104263669b82872f84cf196bc98a98eb5" translate="yes" xml:space="preserve">
          <source>and the UPDATE statement has an ORDER BY clause, then all rows that would be updated in the absence of the LIMIT clause are sorted according to the ORDER BY and the first</source>
          <target state="translated">и утверждение UPDATE имеет пункт ЗАКАЗАТЬ ПО ЗАКАЗЧИКУ,тогда все строки,которые были бы обновлены при отсутствии пункта ОГРАНИЧЕНИЕ,сортируются в соответствии с пунктом ЗАКАЗЧИКА ПО ЗАКАЗЧИКУ и первой строкой</target>
        </trans-unit>
        <trans-unit id="05afb116d83a9696122e3d48be2ae0cf378a78fa" translate="yes" xml:space="preserve">
          <source>and the attempt to gain the</source>
          <target state="translated">и попытка заполучить</target>
        </trans-unit>
        <trans-unit id="968ca042b5e705040bbdcde637032bd9d2191fa8" translate="yes" xml:space="preserve">
          <source>and the conflict resolution is REPLACE, then the INSERT change is removed from the local changeset (it was overridden). Or, if the conflict resolution was &quot;OMIT&quot;, then the local changeset is modified to instead contain:</source>
          <target state="translated">и разрешение конфликта-REPLACE,тогда изменение INSERT удаляется из локального changeset (оно было переопределено).Или,если разрешение конфликта было &quot;OMIT&quot;,то вместо этого локальный changeset изменяется,чтобы содержать:</target>
        </trans-unit>
        <trans-unit id="46ef05dae314b8dc0b295ce6a15936ec49d9c864" translate="yes" xml:space="preserve">
          <source>and the document:</source>
          <target state="translated">и документ:</target>
        </trans-unit>
        <trans-unit id="774d2fc3c7699ba3973db3b85b93a125fa1ced04" translate="yes" xml:space="preserve">
          <source>and the end of the</source>
          <target state="translated">и конец</target>
        </trans-unit>
        <trans-unit id="fb25e092bff28e2eaa8cec1baf32904bb2e25d70" translate="yes" xml:space="preserve">
          <source>and the following statement to be compiled:</source>
          <target state="translated">и следующее заявление,которое должно быть составлено:</target>
        </trans-unit>
        <trans-unit id="0fc5d26e62acc1fc0ed886776026281e0524d63b" translate="yes" xml:space="preserve">
          <source>and the start of the</source>
          <target state="translated">и начало</target>
        </trans-unit>
        <trans-unit id="27af5c77771c98d19d67acedd038a87f8e2d9d7c" translate="yes" xml:space="preserve">
          <source>and the user queries the swarmvtab table for the row with rowid value 25. The swarmvtab table will open database file &quot;test.db3&quot; and read the data to return from table &quot;t1&quot; (as 25 falls within the range of rowids assigned to table &quot;t1&quot; in &quot;test.db3&quot;).</source>
          <target state="translated">и пользователь запрашивает таблицу swarmvtab для строки со значением 25.Таблица swarmvtab откроет файл базы данных &quot;test.db3&quot; и прочитает данные,возвращаемые из таблицы &quot;t1&quot; (так как 25 попадает в диапазон ряд рядков,назначенных таблице &quot;t1&quot; в &quot;test.db3&quot;).</target>
        </trans-unit>
        <trans-unit id="de0be95e333d30a19f869ffbb56d16bebe7fe727" translate="yes" xml:space="preserve">
          <source>and the value of every 200th byte of page data interpreted as an 8-bit unsigned integer, starting with the (</source>
          <target state="translated">и значение каждого 200-го байта данных страницы,интерпретируемого как 8-битное беззнаковое целое число,начинающееся с (</target>
        </trans-unit>
        <trans-unit id="16e461131871bd88245e8305df882aa6184b6089" translate="yes" xml:space="preserve">
          <source>and their accompanying sets of</source>
          <target state="translated">и сопровождающие их комплекты</target>
        </trans-unit>
        <trans-unit id="f26fbdb7a04f5b991f74b3d08c9ab8e827a0dee5" translate="yes" xml:space="preserve">
          <source>and write data to a database file.</source>
          <target state="translated">и записать данные в файл базы данных.</target>
        </trans-unit>
        <trans-unit id="b766070cd38845876a6730a003cdf53665805c86" translate="yes" xml:space="preserve">
          <source>any file within the file system flushes all write operations on all files (not just the</source>
          <target state="translated">любой файл внутри файловой системы промывает все операции записи над всеми файлами (а не только над</target>
        </trans-unit>
        <trans-unit id="86ebc97823e01049b3c5c82c964e3321c30d3460" translate="yes" xml:space="preserve">
          <source>any terms that begin with a specified prefix,</source>
          <target state="translated">любые условия,которые начинаются с указанного префикса,</target>
        </trans-unit>
        <trans-unit id="20446ce193d349d88c1cb603fe2bfda6dd0fed46" translate="yes" xml:space="preserve">
          <source>appears to be an atomic event.</source>
          <target state="translated">похоже на атомное событие.</target>
        </trans-unit>
        <trans-unit id="c0fabcb2564734cccb39fbb1003542faa693274f" translate="yes" xml:space="preserve">
          <source>append a new database page to the database file image, or</source>
          <target state="translated">добавить новую страницу базы данных к изображению файла базы данных,или</target>
        </trans-unit>
        <trans-unit id="569e0c3e863ebdf5f2408ee1670ad397e2af3c31" translate="yes" xml:space="preserve">
          <source>application_id</source>
          <target state="translated">application_id</target>
        </trans-unit>
        <trans-unit id="bc7b492ad938673fdc3f7dd2d39d9a5b1a1313c5" translate="yes" xml:space="preserve">
          <source>are &lt;b&gt;atomic&lt;/b&gt; is the most complex task required of the system. In this case,</source>
          <target state="translated">являются &lt;b&gt;атомарными&lt;/b&gt; - это самая сложная задача, которая требуется от системы. В таком случае,</target>
        </trans-unit>
        <trans-unit id="1657250024276d885f227f57c87321ab8a021f1e" translate="yes" xml:space="preserve">
          <source>are &lt;b&gt;durable&lt;/b&gt; in the face of a system failure, SQLite executes a</source>
          <target state="translated">являются &lt;b&gt;прочным&lt;/b&gt; в условиях отказа системы, SQLite выполняет</target>
        </trans-unit>
        <trans-unit id="97b47e4a3bed52672d52be489b68d62ee41fad83" translate="yes" xml:space="preserve">
          <source>are &lt;b&gt;isolated&lt;/b&gt;, before beginning to modify the contents of the database file to reflect the results of a</source>
          <target state="translated">которые &lt;b&gt;изолированы&lt;/b&gt; , прежде чем начать изменять содержимое файла базы данных , чтобы отразить результаты</target>
        </trans-unit>
        <trans-unit id="d8439b6ce689a8c1e42407d9870989374b7c1510" translate="yes" xml:space="preserve">
          <source>are all fine. The foreign key declared as part of table</source>
          <target state="translated">все в порядке.Иностранный ключ,задекларированный как часть таблицы</target>
        </trans-unit>
        <trans-unit id="1e602c1c2b5b75b949e9cd5732b604bdf14a97ae" translate="yes" xml:space="preserve">
          <source>are applied.</source>
          <target state="translated">применяются.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
