<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="sqlite">
    <body>
      <group id="sqlite">
        <trans-unit id="cae289508ac99f821f2b991e22b21782588d9eaa" translate="yes" xml:space="preserve">
          <source>The algorithm used by the sqlite3_blocking_step() function is as follows:</source>
          <target state="translated">Алгоритм,используемый функцией sqlite3_blocking_step(),следующий:</target>
        </trans-unit>
        <trans-unit id="ce63f03e43853b117cae180b17d7d91a1fc4423c" translate="yes" xml:space="preserve">
          <source>The alternate-form-2 flag is a non-standard extension that appears in no other printf() implementations, as far as we know.</source>
          <target state="translated">Флаг переменной формы-2 является нестандартным расширением,которое,насколько нам известно,не встречается ни в одной другой реализации printf().</target>
        </trans-unit>
        <trans-unit id="28b22ace0382822e0d79f9e1827563fce76153d6" translate="yes" xml:space="preserve">
          <source>The alternative page cache mechanism is an extreme measure that is only needed by the most demanding applications. The built-in page cache is recommended for most uses.</source>
          <target state="translated">Альтернативный механизм кэширования страниц-это крайняя мера,которая нужна только самым требовательным приложениям.Встроенный кэш страниц рекомендуется для большинства приложений.</target>
        </trans-unit>
        <trans-unit id="8b4794d01495b7d8ad2197d5e4f4f33e4044492d" translate="yes" xml:space="preserve">
          <source>The alternative query formulations shown above are conceptual only. SQLite does not really transform the query. The actual query plan is like this: SQLite locates the first possible value for &quot;role&quot;, which it can do by rewinding the &quot;people_idx1&quot; index to the beginning and reading the first record. SQLite stores this first &quot;role&quot; value in an internal variable that we will here call &quot;$role&quot;. Then SQLite runs a query like: &quot;SELECT name FROM people WHERE role=$role AND height&amp;gt;=180&quot;. This query has an equality constraint on the left-most column of the index and so the index can be used to resolve that query. Once that query is finished, SQLite then uses the &quot;people_idx1&quot; index to locate the next value of the &quot;role&quot; column, using code that is logically similar to &quot;SELECT role FROM people WHERE role&amp;gt;$role LIMIT 1&quot;. This new &quot;role&quot; value overwrites the $role variable, and the process repeats until all possible values for &quot;role&quot; have been examined.</source>
          <target state="translated">Показанные выше альтернативные формулировки запросов носят только концептуальный характер. SQLite на самом деле не преобразует запрос. Фактический план запроса выглядит следующим образом: SQLite находит первое возможное значение для &quot;role&quot;, что он может сделать, перемотав индекс &quot;people_idx1&quot; в начало и прочитав первую запись. SQLite сохраняет это первое значение &amp;laquo;роли&amp;raquo; во внутренней переменной, которую мы здесь назовем &amp;laquo;$ role&amp;raquo;. Затем SQLite выполняет запрос типа: &amp;laquo;ВЫБРАТЬ имя ОТ людей, ГДЕ роль = $ роль И высота&amp;gt; = 180&amp;raquo;. Этот запрос имеет ограничение равенства в крайнем левом столбце индекса, поэтому индекс можно использовать для разрешения этого запроса. После завершения этого запроса SQLite затем использует индекс &amp;laquo;people_idx1&amp;raquo; для поиска следующего значения столбца &amp;laquo;role&amp;raquo;, используя код, который логически похож на &amp;laquo;ВЫБЕРИТЕ роль ОТ людей WHERE role&amp;gt; $ role LIMIT 1 &quot;. Это новое значение&quot; role &quot;перезаписывает переменную $ role, и процесс повторяется до тех пор, пока не будут проверены все возможные значения для&quot; role &quot;.</target>
        </trans-unit>
        <trans-unit id="a91f523f7f1e692f775ff82bc9d632716d5637ec" translate="yes" xml:space="preserve">
          <source>The amalgamation and the sqlite3.h header file are available on the &lt;a href=&quot;https://sqlite.org/download.html&quot;&gt;download page&lt;/a&gt; as a file named sqlite-amalgamation-X.zip where the X is replaced by the appropriate version number.</source>
          <target state="translated">Объединение и файл заголовка sqlite3.h доступны на &lt;a href=&quot;https://sqlite.org/download.html&quot;&gt;странице загрузки&lt;/a&gt; в виде файла с именем sqlite-amalgamation-X.zip, где X заменяется соответствующим номером версии.</target>
        </trans-unit>
        <trans-unit id="c0a154d12ef5a44def7683dee324b4a87567d061" translate="yes" xml:space="preserve">
          <source>The amalgamation contains everything you need to integrate SQLite into a larger project. Just copy the amalgamation into your source directory and compile it along with the other C code files in your project. (A &lt;a href=&quot;howtocompile&quot;&gt;more detailed discussion&lt;/a&gt; of the compilation process is available.) You may also want to make use of the &quot;sqlite3.h&quot; header file that defines the programming API for SQLite. The sqlite3.h header file is available separately. The sqlite3.h file is also contained within the amalgamation, in the first few thousand lines. So if you have a copy of sqlite3.c but cannot seem to locate sqlite3.h, you can always regenerate the sqlite3.h by copying and pasting from the amalgamation.</source>
          <target state="translated">Объединение содержит все необходимое для интеграции SQLite в более крупный проект. Просто скопируйте объединение в исходный каталог и скомпилируйте его вместе с другими файлами кода C в своем проекте. ( &lt;a href=&quot;howtocompile&quot;&gt;Более подробное обсуждение&lt;/a&gt; процесса компиляции доступно.) Вы также можете использовать заголовочный файл &amp;laquo;sqlite3.h&amp;raquo;, который определяет программный API для SQLite. Заголовочный файл sqlite3.h доступен отдельно. Файл sqlite3.h также содержится в объединении в первых нескольких тысячах строк. Поэтому, если у вас есть копия sqlite3.c, но вы не можете найти sqlite3.h, вы всегда можете восстановить sqlite3.h путем копирования и вставки из объединения.</target>
        </trans-unit>
        <trans-unit id="c5760ad296baf5ccd7d73666c3833985afa715a2" translate="yes" xml:space="preserve">
          <source>The amount of payload that spills onto overflow pages also depends on the page type. For the following computations, let U be the usable size of a database page, the total page size less the reserved space at the end of each page. And let P be the payload size. In the following, symbol X represents the maximum amount of payload that can be stored directly on the b-tree page without spilling onto an overflow page and symbol M represents the minimum amount of payload that must be stored on the btree page before spilling is allowed.</source>
          <target state="translated">Количество полезной нагрузки,которая проливается на переполненные страницы,также зависит от типа страницы.Для следующих вычислений,пусть U будет полезным размером страницы базы данных,общий размер страницы минус зарезервированное место в конце каждой страницы.И пусть P будет полезным размером.Далее символ X обозначает максимальный размер полезного груза,который может быть сохранен непосредственно на странице b-дерева без проливания на страницу переполнения,а символ M обозначает минимальный размер полезного груза,который должен быть сохранен на странице дерева,прежде чем проливание будет разрешено.</target>
        </trans-unit>
        <trans-unit id="cc7c17ba1fc473503228a1ad5223b1322c93e902" translate="yes" xml:space="preserve">
          <source>The amount of space allocated by sqlite3_aggregate_context(C,N) is determined by the N parameter on first successful call. Changing the value of N in any subsequent call to sqlite3_aggregate_context() within the same aggregate function instance will not resize the memory allocation. Within the xFinal callback, it is customary to set N=0 in calls to sqlite3_aggregate_context(C,N) so that no pointless memory allocations occur.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3035b3f13a8c2eedd1a82b2e759ec82828d6061b" translate="yes" xml:space="preserve">
          <source>The amount of space allocated by sqlite3_aggregate_context(C,N) is determined by the N parameter on first successful call. Changing the value of N in subsequent call to sqlite3_aggregate_context() within the same aggregate function instance will not resize the memory allocation. Within the xFinal callback, it is customary to set N=0 in calls to sqlite3_aggregate_context(C,N) so that no pointless memory allocations occur.</source>
          <target state="translated">Количество пространства,выделяемого sqlite3_aggregate_context(C,N),определяется параметром N при первом успешном вызове.Изменение значения N при последующем вызове на sqlite3_aggregate_context()в пределах одного и того же экземпляра агрегатной функции не приведет к изменению размера выделяемой памяти.Внутри обратного вызова xFinal принято устанавливать значение N=0 при вызове sqlite3_aggregate_context(C,N)так,чтобы не происходило бессмысленного выделения памяти.</target>
        </trans-unit>
        <trans-unit id="48fa74a585edf255bca976e35bf58c2115a55266" translate="yes" xml:space="preserve">
          <source>The android performance numbers for the write experiments are omitted because the performance tests on the Galaxy S3 are so random. Two consecutive runs of the exact same experiment would give wildly different times. And, to be fair, the performance of SQLite on android is slightly slower than writing directly to disk.</source>
          <target state="translated">Номера производительности андроидов для экспериментов по записи опущены,потому что тесты производительности на Galaxy S3 настолько случайны.Два последовательных прогона одного и того же эксперимента дадут дико разное время.И,справедливости ради,производительность SQLite на андроиде несколько медленнее,чем при записи непосредственно на диск.</target>
        </trans-unit>
        <trans-unit id="ba25e29078b648c595b0c513af632a78976e2d1a" translate="yes" xml:space="preserve">
          <source>The application file is portable across all operating systems, 32-bit and 64-bit and big- and little-endian architectures.</source>
          <target state="translated">Файл приложения переносится на все операционные системы,32-битные и 64-битные архитектуры,а также архитектуры big-и little-endian.</target>
        </trans-unit>
        <trans-unit id="553858a0531981a9db580aff8d49f00f4db9f6bc" translate="yes" xml:space="preserve">
          <source>The application has made changes to the &lt;a href=&quot;fts3#*shadowtab&quot;&gt;FTS shadow tables&lt;/a&gt; directly, without using the FTS3/4 virtual table, causing the shadow tables to become out of sync with each other.</source>
          <target state="translated">Приложение внесло изменения в &lt;a href=&quot;fts3#*shadowtab&quot;&gt;теневые таблицы FTS&lt;/a&gt; напрямую, без использования виртуальной таблицы FTS3 / 4, что привело к рассинхронизации теневых таблиц друг с другом.</target>
        </trans-unit>
        <trans-unit id="744b17ec690883f96b76e631855849a6884a7431" translate="yes" xml:space="preserve">
          <source>The application must ensure that the 1st parameter to sqlite3_exec() is a valid and open &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt;.</source>
          <target state="translated">Приложение должно гарантировать, что 1-й параметр sqlite3_exec () является допустимым и открытым &lt;a href=&quot;#sqlite3&quot;&gt;подключением к базе данных&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1a416f0180cf818dc5e0d104e2af8fd17ae77d32" translate="yes" xml:space="preserve">
          <source>The application must ensure that the 1st parameter to sqlite3_exec() is a valid and open &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt;.</source>
          <target state="translated">Приложение должно гарантировать, что 1-й параметр sqlite3_exec () является допустимым и открытым &lt;a href=&quot;sqlite3&quot;&gt;подключением к базе данных&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9dbea7596a56ecae7226dfed468f733b0ebf473a" translate="yes" xml:space="preserve">
          <source>The application must finalize every &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; in order to avoid resource leaks. It is a grievous error for the application to try to use a prepared statement after it has been finalized. Any use of a prepared statement after it has been finalized can result in undefined and undesirable behavior such as segfaults and heap corruption.</source>
          <target state="translated">Приложение должно завершить каждый &lt;a href=&quot;#sqlite3_stmt&quot;&gt;подготовленный оператор&lt;/a&gt; , чтобы избежать утечки ресурсов. Попытка приложения использовать подготовленный оператор после его завершения является серьезной ошибкой. Любое использование подготовленного оператора после его завершения может привести к неопределенному и нежелательному поведению, например, к сбою сегментирования и повреждению кучи.</target>
        </trans-unit>
        <trans-unit id="fb5d8c6646b2fcb9cbadc4a78abf91f82a6d7868" translate="yes" xml:space="preserve">
          <source>The application must finalize every &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; in order to avoid resource leaks. It is a grievous error for the application to try to use a prepared statement after it has been finalized. Any use of a prepared statement after it has been finalized can result in undefined and undesirable behavior such as segfaults and heap corruption.</source>
          <target state="translated">Приложение должно завершить каждый &lt;a href=&quot;stmt&quot;&gt;подготовленный оператор&lt;/a&gt; , чтобы избежать утечки ресурсов. Попытка приложения использовать подготовленный оператор после его завершения является серьезной ошибкой. Любое использование подготовленного оператора после его завершения может привести к неопределенному и нежелательному поведению, например, к сбою сегментирования и повреждению кучи.</target>
        </trans-unit>
        <trans-unit id="99cabfda3eb8aea847c63c772b815f9008f98dc6" translate="yes" xml:space="preserve">
          <source>The application must not close the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; specified by the 1st parameter to sqlite3_exec() while sqlite3_exec() is running.</source>
          <target state="translated">Приложение не должно закрывать &lt;a href=&quot;#sqlite3&quot;&gt;соединение&lt;/a&gt; с базой данных, указанное 1-м параметром sqlite3_exec () во время работы sqlite3_exec ().</target>
        </trans-unit>
        <trans-unit id="0e45e1c6c5dd0bb0af2de4709122fb9b7f5aa23a" translate="yes" xml:space="preserve">
          <source>The application must not close the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; specified by the 1st parameter to sqlite3_exec() while sqlite3_exec() is running.</source>
          <target state="translated">Приложение не должно закрывать &lt;a href=&quot;sqlite3&quot;&gt;соединение&lt;/a&gt; с базой данных, указанное 1-м параметром sqlite3_exec () во время работы sqlite3_exec ().</target>
        </trans-unit>
        <trans-unit id="1ec93d570d3944810e00416d33fc158ef0b8df22" translate="yes" xml:space="preserve">
          <source>The application must not modify the SQL statement text passed into the 2nd parameter of sqlite3_exec() while sqlite3_exec() is running.</source>
          <target state="translated">Приложение не должно модифицировать текст SQL-оператора,переданный во 2-й параметр sqlite3_exec()при запуске sqlite3_exec().</target>
        </trans-unit>
        <trans-unit id="dd08aa5c98a2b87e47c47375f85e57ce41e870bc" translate="yes" xml:space="preserve">
          <source>The application must not read or write any part of a block of memory after it has been released using &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free()&lt;/a&gt; or &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_realloc()&lt;/a&gt;.</source>
          <target state="translated">Приложение не должно читать или записывать какую-либо часть блока памяти после того, как он был освобожден с помощью &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free ()&lt;/a&gt; или &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_realloc ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="04da8df88f025325ec4119082e7436a2ab79cfbf" translate="yes" xml:space="preserve">
          <source>The application must not read or write any part of a block of memory after it has been released using &lt;a href=&quot;free&quot;&gt;sqlite3_free()&lt;/a&gt; or &lt;a href=&quot;free&quot;&gt;sqlite3_realloc()&lt;/a&gt;.</source>
          <target state="translated">Приложение не должно читать или записывать какую-либо часть блока памяти после того, как он был освобожден с помощью &lt;a href=&quot;free&quot;&gt;sqlite3_free ()&lt;/a&gt; или &lt;a href=&quot;free&quot;&gt;sqlite3_realloc ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7136e470c61d513b5e2e7bb04278f687766f03e3" translate="yes" xml:space="preserve">
          <source>The application only has to load the data it needs, rather than reading the entire file and holding a complete parse in memory.</source>
          <target state="translated">Приложение должно загружать только те данные,которые ему нужны,а не читать весь файл и хранить в памяти полный синтаксический анализ.</target>
        </trans-unit>
        <trans-unit id="e521cca41ad74c95daa61ed9901e7bb27bdf7838" translate="yes" xml:space="preserve">
          <source>The application should never invoke either sqlite3_os_init() or sqlite3_os_end() directly. The application should only invoke sqlite3_initialize() and sqlite3_shutdown(). The sqlite3_os_init() interface is called automatically by sqlite3_initialize() and sqlite3_os_end() is called by sqlite3_shutdown(). Appropriate implementations for sqlite3_os_init() and sqlite3_os_end() are built into SQLite when it is compiled for Unix, Windows, or OS/2. When &lt;a href=&quot;../custombuild&quot;&gt;built for other platforms&lt;/a&gt; (using the &lt;a href=&quot;../compile#os_other&quot;&gt;SQLITE_OS_OTHER=1&lt;/a&gt; compile-time option) the application must supply a suitable implementation for sqlite3_os_init() and sqlite3_os_end(). An application-supplied implementation of sqlite3_os_init() or sqlite3_os_end() must return &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; on success and some other &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; upon failure.</source>
          <target state="translated">Приложение никогда не должно напрямую вызывать sqlite3_os_init () или sqlite3_os_end (). Приложение должно вызывать только sqlite3_initialize () и sqlite3_shutdown (). Интерфейс sqlite3_os_init () автоматически вызывается sqlite3_initialize (), а sqlite3_os_end () вызывается sqlite3_shutdown (). Соответствующие реализации для sqlite3_os_init () и sqlite3_os_end () встроены в SQLite, когда он компилируется для Unix, Windows или OS / 2. При &lt;a href=&quot;../compile#os_other&quot;&gt;сборке &lt;/a&gt;&lt;a href=&quot;../custombuild&quot;&gt;для других платформ&lt;/a&gt; (с использованием параметра времени компиляции SQLITE_OS_OTHER = 1 ) приложение должно предоставлять подходящую реализацию для sqlite3_os_init () и sqlite3_os_end (). Поставляемая приложением реализация sqlite3_os_init () или sqlite3_os_end () должна возвращать &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; в случае успеха и некоторые другие&lt;a href=&quot;../rescode&quot;&gt;код ошибки&lt;/a&gt; при сбое.</target>
        </trans-unit>
        <trans-unit id="5f9522c8f8708f8f795d05750d26ac94e862ee81" translate="yes" xml:space="preserve">
          <source>The application should never invoke either sqlite3_os_init() or sqlite3_os_end() directly. The application should only invoke sqlite3_initialize() and sqlite3_shutdown(). The sqlite3_os_init() interface is called automatically by sqlite3_initialize() and sqlite3_os_end() is called by sqlite3_shutdown(). Appropriate implementations for sqlite3_os_init() and sqlite3_os_end() are built into SQLite when it is compiled for Unix, Windows, or OS/2. When &lt;a href=&quot;custombuild&quot;&gt;built for other platforms&lt;/a&gt; (using the &lt;a href=&quot;compile#os_other&quot;&gt;SQLITE_OS_OTHER=1&lt;/a&gt; compile-time option) the application must supply a suitable implementation for sqlite3_os_init() and sqlite3_os_end(). An application-supplied implementation of sqlite3_os_init() or sqlite3_os_end() must return &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; on success and some other &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; upon failure.</source>
          <target state="translated">Приложение никогда не должно напрямую вызывать sqlite3_os_init () или sqlite3_os_end (). Приложение должно вызывать только sqlite3_initialize () и sqlite3_shutdown (). Интерфейс sqlite3_os_init () автоматически вызывается sqlite3_initialize (), а sqlite3_os_end () вызывается sqlite3_shutdown (). Соответствующие реализации для sqlite3_os_init () и sqlite3_os_end () встроены в SQLite, когда он компилируется для Unix, Windows или OS / 2. При &lt;a href=&quot;compile#os_other&quot;&gt;сборке &lt;/a&gt;&lt;a href=&quot;custombuild&quot;&gt;для других платформ&lt;/a&gt; (с использованием параметра времени компиляции SQLITE_OS_OTHER = 1 ) приложение должно предоставлять подходящую реализацию для sqlite3_os_init () и sqlite3_os_end (). Поставляемая приложением реализация sqlite3_os_init () или sqlite3_os_end () должна возвращать &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; в случае успеха и некоторые другие&lt;a href=&quot;rescode&quot;&gt;код ошибки&lt;/a&gt; при сбое.</target>
        </trans-unit>
        <trans-unit id="371b08e858c1c9c61f57bffa9ac30d2c2c9616ae" translate="yes" xml:space="preserve">
          <source>The application wants to prevent other processes from accessing the database file.</source>
          <target state="translated">Приложение хочет предотвратить доступ других процессов к файлу базы данных.</target>
        </trans-unit>
        <trans-unit id="da9edea5d79c9c534eb8f394ef49ec7d996e51c8" translate="yes" xml:space="preserve">
          <source>The application_id PRAGMA is used to query or set the 32-bit signed big-endian &quot;Application ID&quot; integer located at offset 68 into the &lt;a href=&quot;fileformat2#database_header&quot;&gt;database header&lt;/a&gt;. Applications that use SQLite as their &lt;a href=&quot;appfileformat&quot;&gt;application file-format&lt;/a&gt; should set the Application ID integer to a unique integer so that utilities such as &lt;a href=&quot;http://www.darwinsys.com/file/&quot;&gt;file(1)&lt;/a&gt; can determine the specific file type rather than just reporting &quot;SQLite3 Database&quot;. A list of assigned application IDs can be seen by consulting the &lt;a href=&quot;http://www.sqlite.org/src/artifact?ci=trunk&amp;amp;filename=magic.txt&quot;&gt;magic.txt&lt;/a&gt; file in the SQLite source repository.</source>
          <target state="translated">Application_id PRAGMA используется для запроса или установки 32-битного целого числа с прямым порядком байтов со знаком &amp;laquo;ID приложения&amp;raquo;, расположенного по смещению 68 в &lt;a href=&quot;fileformat2#database_header&quot;&gt;заголовке базы данных&lt;/a&gt; . Приложения, которые используют SQLite в качестве своего &lt;a href=&quot;appfileformat&quot;&gt;формата файла приложения,&lt;/a&gt; должны установить целое число Application ID в уникальное целое число, чтобы утилиты, такие как &lt;a href=&quot;http://www.darwinsys.com/file/&quot;&gt;file (1),&lt;/a&gt; могли определять конкретный тип файла, а не просто сообщать &amp;laquo;База данных SQLite3&amp;raquo;. Список присвоенных идентификаторов приложений можно увидеть, &lt;a href=&quot;http://www.sqlite.org/src/artifact?ci=trunk&amp;amp;filename=magic.txt&quot;&gt;обратившись к&lt;/a&gt; файлу magic.txt в исходном репозитории SQLite.</target>
        </trans-unit>
        <trans-unit id="9cc4b4e7374316164e73ee8084ea97ba4afd41e4" translate="yes" xml:space="preserve">
          <source>The application_id PRAGMA is used to query or set the 32-bit signed big-endian &quot;Application ID&quot; integer located at offset 68 into the &lt;a href=&quot;fileformat2#database_header&quot;&gt;database header&lt;/a&gt;. Applications that use SQLite as their &lt;a href=&quot;appfileformat&quot;&gt;application file-format&lt;/a&gt; should set the Application ID integer to a unique integer so that utilities such as &lt;a href=&quot;http://www.darwinsys.com/file/&quot;&gt;file(1)&lt;/a&gt; can determine the specific file type rather than just reporting &quot;SQLite3 Database&quot;. A list of assigned application IDs can be seen by consulting the &lt;a href=&quot;https://www.sqlite.org/src/artifact?ci=trunk&amp;amp;filename=magic.txt&quot;&gt;magic.txt&lt;/a&gt; file in the SQLite source repository.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbebe3f29ae821a203a540ede83fca7a51f6300e" translate="yes" xml:space="preserve">
          <source>The applications using this database are entitled to assume that for each row in the</source>
          <target state="translated">Приложения,использующие эту базу данных,имеют право предполагать,что для каждой строки в</target>
        </trans-unit>
        <trans-unit id="c4abdec20da55bda36a7679394be4f500b633ccf" translate="yes" xml:space="preserve">
          <source>The argc parameter specifies the number of entries in the argv array. The value of argc will be 1 for a pure delete operation or N+2 for an insert or replace or update where N is the number of columns in the table. In the previous sentence, N includes any hidden columns.</source>
          <target state="translated">Параметр argc определяет количество записей в массиве argv.Значение параметра argc будет равно 1 для чистой операции удаления или N+2 для вставки или замены или обновления,где N-количество столбцов в таблице.В предыдущем предложении N включает любые скрытые столбцы.</target>
        </trans-unit>
        <trans-unit id="b66b85dc16bc6667c3624ba8e6f64b24df3ac149" translate="yes" xml:space="preserve">
          <source>The argument N is the maximum number of bytes of the database file that will be accessed using memory-mapped I/O. If N is zero then memory mapped I/O is disabled. If N is negative, then the limit reverts to the default value determined by the most recent &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmmapsize&quot;&gt;SQLITE_CONFIG_MMAP_SIZE&lt;/a&gt;), or to the compile time default determined by &lt;a href=&quot;compile#default_mmap_size&quot;&gt;SQLITE_DEFAULT_MMAP_SIZE&lt;/a&gt; if not start-time limit has been set.</source>
          <target state="translated">Аргумент N - это максимальное количество байтов файла базы данных, к которому будет осуществляться доступ с помощью ввода-вывода с отображением памяти. Если N равно нулю, то ввод-вывод с отображением в память отключен. Если N отрицательно, то ограничение возвращается к значению по умолчанию, определенному самой последней &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt; ( &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmmapsize&quot;&gt;SQLITE_CONFIG_MMAP_SIZE&lt;/a&gt; ), или к &lt;a href=&quot;compile#default_mmap_size&quot;&gt;значению&lt;/a&gt; времени компиляции по умолчанию, определяемому SQLITE_DEFAULT_MMAP_SIZE, если не был установлен предел времени начала.</target>
        </trans-unit>
        <trans-unit id="7500855ec2b0357e501bb580486bc273725ede2e" translate="yes" xml:space="preserve">
          <source>The argument can be either the text of an SQL statement, in which case the bytecode (or tables_used) for that statement is returned, or the argument can be a parameter such as ?1 or $stmt that is later bound to a &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; object using the &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer()&lt;/a&gt; interface. Use a pointer type of &quot;stmt-pointer&quot; for the &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer()&lt;/a&gt; interface.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab61127b621c6e57d8aaaae340d80e94025b5867" translate="yes" xml:space="preserve">
          <source>The argument is a double which is displayed in decimal.</source>
          <target state="translated">Аргумент представляет собой двойной,который отображается в десятичной форме.</target>
        </trans-unit>
        <trans-unit id="7c92aff7ca85efdc01cd4da9e4f23a18dad234e0" translate="yes" xml:space="preserve">
          <source>The argument is a double which is displayed in either normal decimal notation or if the exponent is not close to zero, in exponential notation.</source>
          <target state="translated">Аргументом является двойник,который отображается либо в нормальной десятичной нотации,либо,если экспонента не близка к нулю,в экспоненциальной нотации.</target>
        </trans-unit>
        <trans-unit id="2096ff23b8873f39597795db4f99b816ed776fc9" translate="yes" xml:space="preserve">
          <source>The argument is a double which is displayed in exponential notation. The exponent character is 'e' or 'E' depending on the type.</source>
          <target state="translated">Аргумент представляет собой двойник,который отображается в экспоненциальной нотации.Символом экспоненты является 'e' или 'E' в зависимости от типа.</target>
        </trans-unit>
        <trans-unit id="11129b8da0d471f1bf24142ea87e57c0024e71a8" translate="yes" xml:space="preserve">
          <source>The argument is a pointer to an integer. Nothing is displayed for this substitution type. Instead, the integer to which the argument points is overwritten with the number of characters in the generated string that result from all format symbols to the left of the %n.</source>
          <target state="translated">Аргумент является указателем на целое число.Для данного типа подстановки ничего не отображается.Вместо этого,целое число,на которое указывает аргумент,перезаписывается числом символов в генерируемой строке,которое получается из всех символов формата слева от %n.</target>
        </trans-unit>
        <trans-unit id="e6906c7030bdaf7b36a456360b0fbb4934d1a4ca" translate="yes" xml:space="preserve">
          <source>The argument is a pointer which is displayed as a hexadecimal address. Since the SQL language has no concept of a pointer, the %p substitution for the &lt;a href=&quot;lang_corefunc#printf&quot;&gt;printf() SQL function&lt;/a&gt; works like %x.</source>
          <target state="translated">Аргумент - это указатель, который отображается как шестнадцатеричный адрес. Поскольку в языке SQL отсутствует понятие указателя, подстановка% p для &lt;a href=&quot;lang_corefunc#printf&quot;&gt;функции SQL printf ()&lt;/a&gt; работает как% x.</target>
        </trans-unit>
        <trans-unit id="e27c7fe9a83c9f08bcef3b205174fd7f4958e0c9" translate="yes" xml:space="preserve">
          <source>The argument is a signed integer which is displayed in decimal.</source>
          <target state="translated">Аргумент представляет собой знаковое целое число,которое отображается в десятичной форме.</target>
        </trans-unit>
        <trans-unit id="9b566b967632a4d496722ab350e0797c5b50a8e6" translate="yes" xml:space="preserve">
          <source>The argument is a zero-terminated string that is displayed. For the %z type in C-language interfaces, &lt;a href=&quot;c3ref/free&quot; id=&quot;percentz&quot;&gt;sqlite3_free()&lt;/a&gt; is invoked on the string after it has be copied into the output. The %s and %z substitutions are identical for the SQL printf() function.</source>
          <target state="translated">Аргумент - это отображаемая строка с нулевым символом в конце. Для типа% z в интерфейсах на языке C &lt;a href=&quot;c3ref/free&quot; id=&quot;percentz&quot;&gt;sqlite3_free ()&lt;/a&gt; вызывается в строке после ее копирования в вывод. Подстановки% s и% z идентичны для функции SQL printf ().</target>
        </trans-unit>
        <trans-unit id="fcbbea9fc49916ff3eab8108379983087fe602ea" translate="yes" xml:space="preserve">
          <source>The argument is a zero-terminated string. The string is printed with all single quote (') characters doubled so that the string can safely appear inside an SQL string literal. The %Q substitution type also puts single-quotes on both ends of the substituted string.</source>
          <target state="translated">Аргумент представляет собой нулевую строку.Строка распечатывается с удвоением всех одинарных символов в кавычках ('),чтобы она могла безопасно отображаться внутри строкового SQL-литерала.Тип подстановки %Q также помещает одинарные кавычки на оба конца подставляемой строки.</target>
        </trans-unit>
        <trans-unit id="f7cdf0497339bca82de3b36c80d3d61e29bc5c49" translate="yes" xml:space="preserve">
          <source>The argument is an integer which is displayed in hexadecimal. Lower-case hexadecimal is used for %x and upper-case is used for %X</source>
          <target state="translated">Аргумент представляет собой целое число,которое отображается в шестнадцатеричной системе.Нижний шестнадцатеричный используется для %x,а верхний-для %X.</target>
        </trans-unit>
        <trans-unit id="e8fcc09e116d95e79ec104c4fc555cc628b5c95b" translate="yes" xml:space="preserve">
          <source>The argument is an integer which is displayed in octal.</source>
          <target state="translated">Аргумент представляет собой целое число,которое отображается восьмеричным числом.</target>
        </trans-unit>
        <trans-unit id="544017bf0d02198d9d372e60ce173d51892cc644" translate="yes" xml:space="preserve">
          <source>The argument is an unsigned integer which is displayed in decimal.</source>
          <target state="translated">Аргумент представляет собой беззнаковое целое число,которое отображается в десятичной форме.</target>
        </trans-unit>
        <trans-unit id="5c161c084d3e3e79567bd33437dedcb35b7796bf" translate="yes" xml:space="preserve">
          <source>The argument is the symbolic name for the desired VFS. If the argument is a NULL pointer, then the default VFS is returned. The function returns a pointer to the &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object that implements the VFS. Or it returns a NULL pointer if no object could be found that matched the search criteria.</source>
          <target state="translated">Аргументом является символическое имя желаемой VFS. Если аргумент является указателем NULL, возвращается VFS по умолчанию. Функция возвращает указатель на объект &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; , реализующий VFS. Или он возвращает нулевой указатель, если не удалось найти объект, соответствующий критериям поиска.</target>
        </trans-unit>
        <trans-unit id="850af1642ffa208db124c3d32de875df305d3783" translate="yes" xml:space="preserve">
          <source>The argument to INTO can be a &lt;a href=&quot;uri&quot;&gt;URI filename&lt;/a&gt; if URI filenames are enabled. URL filenames are enabled if any of the following are true:</source>
          <target state="translated">Аргументом INTO может быть &lt;a href=&quot;uri&quot;&gt;имя файла&lt;/a&gt; URI, если имена файлов URI включены. Имена файлов URL включены, если выполняется одно из следующих условий:</target>
        </trans-unit>
        <trans-unit id="5b032a307670cabd16d781ba02c89e270db9d32d" translate="yes" xml:space="preserve">
          <source>The argument to the timeout method is the maximum number of milliseconds to wait for the lock to clear. So in the example above, the maximum delay would be 2 seconds.</source>
          <target state="translated">Аргументом к методу таймаута является максимальное количество миллисекунд ожидания очистки замка.Таким образом,в приведенном выше примере максимальная задержка составит 2 секунды.</target>
        </trans-unit>
        <trans-unit id="6304247ca5d53ec4d2f27644451268a5fc4c44d5" translate="yes" xml:space="preserve">
          <source>The arguments passed to the &quot;tokenchars=&quot; or &quot;separators=&quot; options are case-sensitive. In the example above, specifying that &quot;X&quot; is a separator character does not affect the way &quot;x&quot; is handled.</source>
          <target state="translated">Аргументы,передаваемые в опции &quot;tokenchars=&quot; или &quot;separators=&quot;,чувствительны к регистру.В приведенном выше примере указание,что &quot;X&quot; является символом разделителя,не влияет на способ обработки &quot;x&quot;.</target>
        </trans-unit>
        <trans-unit id="f42ca2142ac7440fc4af993ad46bce7740b98121" translate="yes" xml:space="preserve">
          <source>The arguments to &lt;b&gt;sqlite_busy_handler&lt;/b&gt; are the opaque structure returned from &lt;b&gt;sqlite_open&lt;/b&gt;, a pointer to the busy callback function, and a generic pointer that will be passed as the first argument to the busy callback. When SQLite invokes the busy callback, it sends it three arguments: the generic pointer that was passed in as the third argument to &lt;b&gt;sqlite_busy_handler&lt;/b&gt;, the name of the database table or index that the library is trying to access, and the number of times that the library has attempted to access the database table or index.</source>
          <target state="translated">Аргументами &lt;b&gt;sqlite_busy_handler&lt;/b&gt; являются непрозрачная структура, возвращаемая &lt;b&gt;sqlite_open&lt;/b&gt; , указатель на функцию обратного вызова занятости и общий указатель, который будет передан в качестве первого аргумента обратному вызову занятости. Когда SQLite вызывает обратный вызов занятости, он отправляет ему три аргумента: общий указатель, который был передан в качестве третьего аргумента &lt;b&gt;sqlite_busy_handler&lt;/b&gt; , имя таблицы или индекса базы данных, к которому библиотека пытается получить доступ, и количество раз, когда библиотека попыталась получить доступ к таблице или индексу базы данных.</target>
        </trans-unit>
        <trans-unit id="6fa9f93d8e2b44eeb698d1ed1229d89e77acc71a" translate="yes" xml:space="preserve">
          <source>The argv[0] parameter is the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; of a row in the virtual table to be deleted. If argv[0] is an SQL NULL, then no deletion occurs.</source>
          <target state="translated">Параметр argv [0] - это &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; удаляемой строки в виртуальной таблице. Если argv [0] является SQL NULL, то удаления не происходит.</target>
        </trans-unit>
        <trans-unit id="94f42e72810bd428d0a06485b57a23695591e88c" translate="yes" xml:space="preserve">
          <source>The argv[1] parameter is the rowid of a new row to be inserted into the virtual table. If argv[1] is an SQL NULL, then the implementation must choose a rowid for the newly inserted row. Subsequent argv[] entries contain values of the columns of the virtual table, in the order that the columns were declared. The number of columns will match the table declaration that the &lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; or &lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; method made using the &lt;a href=&quot;c3ref/declare_vtab&quot;&gt;sqlite3_declare_vtab()&lt;/a&gt; call. All hidden columns are included.</source>
          <target state="translated">Параметр argv [1] - это идентификатор новой строки, которая будет вставлена ​​в виртуальную таблицу. Если argv [1] является SQL NULL, тогда реализация должна выбрать rowid для вновь вставленной строки. Последующие записи argv [] содержат значения столбцов виртуальной таблицы в том порядке, в котором столбцы были объявлены. Количество столбцов будет соответствовать объявлению таблицы, которое метод &lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; или &lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; сделал с помощью вызова &lt;a href=&quot;c3ref/declare_vtab&quot;&gt;sqlite3_declare_vtab ()&lt;/a&gt; . Включены все скрытые столбцы.</target>
        </trans-unit>
        <trans-unit id="960c591f856ba7201455da5f944d6e4f1ebae33d" translate="yes" xml:space="preserve">
          <source>The arrows from the small circles labeled with &quot;*&quot; indicate the cost of running each loop with no dependencies. The outer loop must use this *-cost. Inner loops have the option of using the *-cost or a cost assuming one of the other terms is in an outer loop, whichever gives the best result. One can think of the *-costs as a short-hand notation indicating multiple arcs, one from each of the other nodes in the graph. The graph is therefore &quot;complete&quot;, meaning that there are arcs (some explicit and some implied) in both directions between every pair of nodes in the graph.</source>
          <target state="translated">Стрелки из маленьких кружочков,помеченные знаком &quot;*&quot;,указывают на стоимость выполнения каждого цикла без зависимостей.Внешний цикл должен использовать эту *стоимость.Внутренние петли имеют возможность использовать *-cost или стоимость,предполагая,что один из других терминов находится во внешнем петле,в зависимости от того,какой из них дает наилучший результат.Можно думать о *-затратах как о короткой нотации,обозначающей несколько дуг,по одной от каждой из других вершин на графике.Поэтому граф является &quot;полным&quot;,что означает,что между каждой парой вершин графа имеются дуги (некоторые явные и некоторые подразумеваемые)в обоих направлениях.</target>
        </trans-unit>
        <trans-unit id="d6a2923f627b3acd76aca2425895d68fa7fb43f5" translate="yes" xml:space="preserve">
          <source>The assert(X) macro is &lt;a href=&quot;https://en.wikipedia.org/wiki/Assert.h&quot;&gt;part of standard C&lt;/a&gt;, in the &amp;lt;assert.h&amp;gt; header file. SQLite adds three other assert()-like macros named NEVER(X), ALWAYS(X), and testcase(X).</source>
          <target state="translated">Макрос assert (X) является &lt;a href=&quot;https://en.wikipedia.org/wiki/Assert.h&quot;&gt;частью стандартного C&lt;/a&gt; в заголовочном файле &amp;lt;assert.h&amp;gt;. SQLite добавляет три других макроса, подобных assert (), с именами NEVER (X), ALWAYS (X) и testcase (X).</target>
        </trans-unit>
        <trans-unit id="8da4f4835817f9b4a63cc18fb5421f7207d5d808" translate="yes" xml:space="preserve">
          <source>The asynchronous I/O VFS is registered (and unregistered) by calls to the API functions sqlite3async_initialize() and sqlite3async_shutdown(). See section &quot;Compilation and Usage&quot; below for details.</source>
          <target state="translated">Асинхронный ввод/вывод VFS регистрируется (и не регистрируется)вызовами функций API sqlite3async_initialize()и sqlite3async_shutdown().Подробнее см.раздел &quot;Компиляция и использование&quot; ниже.</target>
        </trans-unit>
        <trans-unit id="535287426332e5a1ad8bec16b3d83b02751661a5" translate="yes" xml:space="preserve">
          <source>The asynchronous IO VFS API is described in detail in comments in sqlite3async.h. Using the API usually consists of the following steps:</source>
          <target state="translated">Асинхронный IO VFS API подробно описан в комментариях в sqlite3async.h.Использование API обычно состоит из следующих шагов:</target>
        </trans-unit>
        <trans-unit id="99f2292b58193481d23d957b96b6816c332c0bd5" translate="yes" xml:space="preserve">
          <source>The asynchronous IO extension consists of a single file of C code (sqlite3async.c), and a header file (sqlite3async.h), located in the &lt;a href=&quot;http://www.sqlite.org/src/dir?name=ext/async&quot;&gt; &lt;code&gt;ext/async/&lt;/code&gt; subfolder&lt;/a&gt; of the SQLite source tree, that defines the C API used by applications to activate and control the modules functionality.</source>
          <target state="translated">Асинхронного расширения ввода - вывода состоит из одного файла кода C (sqlite3async.c), и файл заголовка (sqlite3async.h), расположенный в &lt;a href=&quot;http://www.sqlite.org/src/dir?name=ext/async&quot;&gt; &lt;code&gt;ext/async/&lt;/code&gt; &lt;/a&gt; вложенную папку из исходного дерева SQLite, который определяет C API , используемый приложениями для активации и контроля функциональности модулей.</target>
        </trans-unit>
        <trans-unit id="3af3b819095a3c9a894e17624182795ef0341654" translate="yes" xml:space="preserve">
          <source>The asynchronous IO extension consists of a single file of C code (sqlite3async.c), and a header file (sqlite3async.h), located in the &lt;a href=&quot;https://www.sqlite.org/src/dir?name=ext/async&quot;&gt; &lt;code&gt;ext/async/&lt;/code&gt; subfolder&lt;/a&gt; of the SQLite source tree, that defines the C API used by applications to activate and control the modules functionality.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa3d3b11288ba36989fe692263c29b42026caa0f" translate="yes" xml:space="preserve">
          <source>The asynchronous SQLite is just a shade slower than MySQL on this test. (MySQL seems to be especially adept at INSERT...SELECT statements.) The PostgreSQL engine is still thrashing - most of the 61 seconds it used were spent waiting on disk I/O.</source>
          <target state="translated">В этом тесте асинхронный SQLite просто оттенок медленнее,чем MySQL.(Похоже,MySQL особенно хорошо разбирается в выражениях INSERT...SELECT.)Движок PostgreSQL все еще бьется-большинство из 61 секунды,которые он использовал,были потрачены на ожидание дискового ввода/вывода.</target>
        </trans-unit>
        <trans-unit id="09f0791bf3a9c39b17b6897fd1eef3b3d7a8e21f" translate="yes" xml:space="preserve">
          <source>The atomic commit mechanism in SQLite has proven to be robust, but it can be circumvented by a sufficiently creative adversary or a sufficiently broken operating system implementation. This section describes a few of the ways in which an SQLite database might be corrupted by a power failure or system crash. (See also: &lt;a href=&quot;howtocorrupt&quot;&gt;How To Corrupt Your Database Files&lt;/a&gt;.)</source>
          <target state="translated">Механизм атомарной фиксации в SQLite оказался надежным, но его может обойти достаточно изобретательный противник или достаточно неработающая реализация операционной системы. В этом разделе описаны несколько способов, которыми база данных SQLite может быть повреждена из-за сбоя питания или сбоя системы. (См. Также: &lt;a href=&quot;howtocorrupt&quot;&gt;Как испортить файлы базы данных&lt;/a&gt; .)</target>
        </trans-unit>
        <trans-unit id="be392afd276ea778d7374d96f033564d6dcc8ac2" translate="yes" xml:space="preserve">
          <source>The attacker can submit a maliciously crafted database file to the application that the application will then open and query.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4da2591e4ae0c979cba5f61016108bf072266c8" translate="yes" xml:space="preserve">
          <source>The attacker can submit and run arbitrary SQL statements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7497e373861cdeb1f861bd3cb7a15f476a8a4234" translate="yes" xml:space="preserve">
          <source>The author of Lemon and SQLite (Hipp) reports that his C programming skills were greatly enhanced by studying John Ousterhout's original source code to Tcl. Hipp discovered and studied Tcl in 1993. Lemon was written before then, and SQLite afterwards. There is a clear difference in the coding styles of these two products, with SQLite seeming to be cleaner, more readable, and easier to maintain.</source>
          <target state="translated">Автор Lemon и SQLite (Hipp)сообщает,что его навыки программирования на Си были значительно улучшены благодаря изучению оригинального исходного кода Джона Остерхаута (John Ousterhout)на Tcl.Хипп открыл и изучил Tcl в 1993 году.Лемон была написана до этого,а SQLite-после.Существует явная разница в стилях кодирования этих двух продуктов,при этом SQLite кажется более чистым,более читабельным и легким в обслуживании.</target>
        </trans-unit>
        <trans-unit id="b01615602e972abb3c5942edbe63b3d8efbfa2ac" translate="yes" xml:space="preserve">
          <source>The authority may be omitted, may be blank, or may be &quot;&lt;code&gt;localhost&lt;/code&gt;&quot;. Any other authority results in an error. Exception: If SQLite is compiled with &lt;a href=&quot;compile#allow_uri_authority&quot;&gt;SQLITE_ALLOW_URI_AUTHORITY&lt;/a&gt; then any authority value other than &quot;localhost&quot; is passed through to the underlying operating system as a UNC filename.</source>
          <target state="translated">Права доступа могут быть опущены, могут быть пустыми или иметь значение &lt;code&gt;localhost&lt;/code&gt; . Любые другие полномочия приводят к ошибке. Исключение: если SQLite скомпилирован с &lt;a href=&quot;compile#allow_uri_authority&quot;&gt;SQLITE_ALLOW_URI_AUTHORITY,&lt;/a&gt; тогда любое значение полномочий, кроме &amp;laquo;localhost&amp;raquo;, передается в базовую операционную систему как имя UNC-файла.</target>
        </trans-unit>
        <trans-unit id="939e9fe5172b44eee1c6df02720143adc80675d6" translate="yes" xml:space="preserve">
          <source>The authorizer callback must not do anything that will modify the database connection that invoked the authorizer callback. Note that &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; both modify their database connections for the meaning of &quot;modify&quot; in this paragraph.</source>
          <target state="translated">Обратный вызов авторизатора не должен делать ничего, что изменило бы соединение с базой данных, которое вызвало обратный вызов авторизатора. Обратите внимание, что &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; и &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step ()&lt;/a&gt; оба изменяют свои соединения с базой данных для значения слова &amp;laquo;изменить&amp;raquo; в этом абзаце.</target>
        </trans-unit>
        <trans-unit id="cd0b9544f8e0ba2efe9de0f3a90df70febb9c84b" translate="yes" xml:space="preserve">
          <source>The authorizer callback must not do anything that will modify the database connection that invoked the authorizer callback. Note that &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; and &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; both modify their database connections for the meaning of &quot;modify&quot; in this paragraph.</source>
          <target state="translated">Обратный вызов авторизатора не должен делать ничего, что изменило бы соединение с базой данных, которое вызвало обратный вызов авторизатора. Обратите внимание, что &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; и &lt;a href=&quot;step&quot;&gt;sqlite3_step ()&lt;/a&gt; оба изменяют свои соединения с базой данных для значения слова &amp;laquo;изменить&amp;raquo; в этом абзаце.</target>
        </trans-unit>
        <trans-unit id="df84d2005e831c09e4f96777c00aabce6c502fa9" translate="yes" xml:space="preserve">
          <source>The automatic indexing capability can be disabled at run-time using the &lt;a href=&quot;pragma#pragma_automatic_index&quot;&gt;automatic_index pragma&lt;/a&gt;. Automatic indexing is turned on by default, but this can be changed so that automatic indexing is off by default using the &lt;a href=&quot;compile#default_automatic_index&quot;&gt;SQLITE_DEFAULT_AUTOMATIC_INDEX&lt;/a&gt; compile-time option. The ability to create automatic indexes can be completely disabled by compiling with the &lt;a href=&quot;compile#omit_automatic_index&quot;&gt;SQLITE_OMIT_AUTOMATIC_INDEX&lt;/a&gt; compile-time option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="861ac52bff28d8b37d00f46c9e8ab0bcdffeef17" translate="yes" xml:space="preserve">
          <source>The automatic indexing capability can be disabled at run-time using the &lt;a href=&quot;pragma#pragma_automatic_index&quot;&gt;automatic_index pragma&lt;/a&gt;. Automatic indexing is turned on by default, but this can be changed so that automatic indexing is off by default using the &lt;a href=&quot;compile#default_automatic_index&quot;&gt;SQLITE_DEFAULT_AUTOMATIC_INDEX&lt;/a&gt; compile-time option. The ability to create automatic indices can be completely disabled by compiling with the &lt;a href=&quot;compile#omit_automatic_index&quot;&gt;SQLITE_OMIT_AUTOMATIC_INDEX&lt;/a&gt; compile-time option.</source>
          <target state="translated">Возможность автоматического индексирования может быть отключена во время выполнения с помощью &lt;a href=&quot;pragma#pragma_automatic_index&quot;&gt;прагмы automatic_index&lt;/a&gt; . Автоматическое индексирование включено по умолчанию, но это можно изменить, чтобы автоматическое индексирование было отключено по умолчанию с помощью параметра &lt;a href=&quot;compile#default_automatic_index&quot;&gt;времени&lt;/a&gt; компиляции SQLITE_DEFAULT_AUTOMATIC_INDEX . Возможность создания автоматических индексов может быть полностью отключена путем компиляции с параметром &lt;a href=&quot;compile#omit_automatic_index&quot;&gt;времени&lt;/a&gt; компиляции SQLITE_OMIT_AUTOMATIC_INDEX .</target>
        </trans-unit>
        <trans-unit id="ea88f1175fb0f90865a8970907b5e05e253378e5" translate="yes" xml:space="preserve">
          <source>The avg() function returns the average value of all non-NULL</source>
          <target state="translated">Функция avg()возвращает среднее значение всех не-NULL</target>
        </trans-unit>
        <trans-unit id="c29cb183c63bdd561faeb944d923a238a65c8f1b" translate="yes" xml:space="preserve">
          <source>The b-tree algorithm provides key/data storage with unique and ordered keys on page-oriented storage devices. For background information on b-trees, see Knuth, &lt;u&gt;The Art Of Computer Programming&lt;/u&gt;, Volume 3 &quot;Sorting and Searching&quot;, pages 471-479. Two kinds of b-trees are used by SQLite. The algorithm that Knuth calls &quot;B*-Tree&quot; stores all data in the leaves of the tree. SQLite calls this variety of b-tree a &quot;table b-tree&quot;. The algorithm that Knuth calls simply &quot;B-Tree&quot; stores both the key and the data together in both leaves and in interior pages. In the SQLite implementation, the original B-Tree algorithm stores keys only, omitting the data entirely, and is called an &quot;index b-tree&quot;.</source>
          <target state="translated">Алгоритм b-tree обеспечивает хранение ключей / данных с уникальными и упорядоченными ключами на устройствах хранения, ориентированных на страницы. Для получения дополнительной информации о b-деревьях см. Knuth, &lt;u&gt;Искусство компьютерного программирования&lt;/u&gt; , том 3 &amp;laquo;Сортировка и поиск&amp;raquo;, страницы 471-479. SQLite использует два вида b-деревьев. Алгоритм, который Кнут называет &amp;laquo;B * -Tree&amp;raquo;, хранит все данные в листьях дерева. SQLite называет эту разновидность b-дерева &amp;laquo;табличным b-деревом&amp;raquo;. Алгоритм, который Кнут называет просто &amp;laquo;B-Tree&amp;raquo;, хранит ключ и данные вместе как на листьях, так и на внутренних страницах. В реализации SQLite исходный алгоритм B-Tree хранит только ключи, полностью опуская данные, и называется &amp;laquo;индексным b-деревом&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="d112311c7e2ccc4f400060b3e5337023ffd30dd4" translate="yes" xml:space="preserve">
          <source>The b-tree algorithm provides key/data storage with unique and ordered keys on page-oriented storage devices. For background information on b-trees, see Knuth, &lt;u&gt;The Art Of Computer Programming&lt;/u&gt;, Volume 3 &quot;Sorting and Searching&quot;, pages 471-479. Two variants of b-trees are used by SQLite. &quot;Table b-trees&quot; use a 64-bit signed integer key and store all data in the leaves. &quot;Index b-trees&quot; use arbitrary keys and store no data at all.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb8fb65a49101b4953ed3553fa6d2836b2742f88" translate="yes" xml:space="preserve">
          <source>The b-tree page header is 8 bytes in size for leaf pages and 12 bytes for interior pages. All multibyte values in the page header are big-endian. The b-tree page header is composed of the following fields:</source>
          <target state="translated">Размер шапки b-дерева страницы составляет 8 байт для листовых страниц и 12 байт для внутренних страниц.Все многобайтовые значения в заголовке страницы имеют большой размер.Заголовок b-деревянной страницы состоит из следующих полей:</target>
        </trans-unit>
        <trans-unit id="b3cbe5b0fd4215124588bcf352c662cc2398e510" translate="yes" xml:space="preserve">
          <source>The backup API copies the content of one database into another. It is useful either for creating backups of databases or for copying in-memory databases to or from persistent files.</source>
          <target state="translated">API резервного копирования копирует содержимое одной базы данных в другую.Он полезен как для создания резервных копий баз данных,так и для копирования баз данных в памяти в постоянные файлы или из них.</target>
        </trans-unit>
        <trans-unit id="2cf1eb05a922a766ec8d7dd18ed7d6f4aa38bd5f" translate="yes" xml:space="preserve">
          <source>The backupDb() function uses the sqlite3_backup_remaining() and sqlite3_backup_pagecount() functions to report its progress via the user-supplied xProgress() callback. Function sqlite3_backup_remaining() returns the number of pages left to copy and sqlite3_backup_pagecount() returns the total number of pages in the source database (in this case the database opened by pDb). So the percentage completion of the process may be calculated as:</source>
          <target state="translated">Функция backupDb()использует функции sqlite3_backup_remaining()и sqlite3_backup_pagecount()для отчётности о своём прогрессе через пользовательский вызов xProgress().Функция sqlite3_backup_remaining()возвращает количество страниц,оставленных для копирования,а функция sqlite3_backup_pagecount()возвращает общее количество страниц в исходной базе данных (в данном случае в базе данных,открытой с помощью pDb).Таким образом,можно рассчитать процентное завершение процесса как:</target>
        </trans-unit>
        <trans-unit id="6b553d2761ee3fe64acd25548c40d0f8e4d42c23" translate="yes" xml:space="preserve">
          <source>The base window may not specify a frame specification. The frame specification can only be given in the new window specification.</source>
          <target state="translated">В базовом окне может не указываться спецификация рамы.Спецификация рамы может быть указана только в спецификации нового окна.</target>
        </trans-unit>
        <trans-unit id="5c2a91b9a2da4a8d6526f62c2bd849ce606c97d4" translate="yes" xml:space="preserve">
          <source>The basic algorithm for computing the content of the recursive table is as follows:</source>
          <target state="translated">Основной алгоритм вычисления содержания рекурсивной таблицы следующий:</target>
        </trans-unit>
        <trans-unit id="cc257445d9ceee252762e517b278c85329543c96" translate="yes" xml:space="preserve">
          <source>The basic principals described above apply to both ordinary rowid tables and &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables. The only difference is that the rowid column that serves as the key for tables and that appears as the right-most term in indexes is replaced by the PRIMARY KEY.</source>
          <target state="translated">Основные принципы, описанные выше, применимы как к обычным таблицам &lt;a href=&quot;withoutrowid&quot;&gt;rowid, так и к&lt;/a&gt; таблицам БЕЗ ROWID . Единственное отличие состоит в том, что столбец rowid, который служит ключом для таблиц и который появляется как крайний правый термин в индексах, заменяется PRIMARY KEY.</target>
        </trans-unit>
        <trans-unit id="07bf749b7aaedba2ca3c53251a2ebc2903cbff5d" translate="yes" xml:space="preserve">
          <source>The basic procedure above may modified by the following additional rules:</source>
          <target state="translated">Приведенная выше базовая процедура может быть изменена следующими дополнительными правилами:</target>
        </trans-unit>
        <trans-unit id="5580fafc283a76d74ea47e0554226ba42ea5bc40" translate="yes" xml:space="preserve">
          <source>The behavior implemented by the AUTOINCREMENT keyword is subtly different from the default behavior. With AUTOINCREMENT, rows with automatically selected ROWIDs are guaranteed to have ROWIDs that have never been used before by the same table in the same database. And the automatically generated ROWIDs are guaranteed to be monotonically increasing. These are important properties in certain applications. But if your application does not need these properties, you should probably stay with the default behavior since the use of AUTOINCREMENT requires additional work to be done as each row is inserted and thus causes INSERTs to run a little slower.</source>
          <target state="translated">Поведение,реализованное ключевым словом AUTOINCREMENT,тонко отличается от поведения по умолчанию.С помощью AUTOINCREMENT в строках с автоматически выбранными ROWID гарантированно будут ROWID-идентификаторы,которые никогда раньше не использовались одной и той же таблицей в одной и той же базе данных.И автоматически сгенерированные ROWID гарантированно монотонно увеличиваются.Это важные свойства в некоторых приложениях.Но если ваше приложение не нуждается в этих свойствах,вы,вероятно,должны придерживаться поведения по умолчанию,так как использование АВТОИНКРЕМЕНТА требует дополнительной работы,так как каждая строка вставляется и таким образом заставляет INSERT'ы работать немного медленнее.</target>
        </trans-unit>
        <trans-unit id="53ddd9ac28fbcaf8f2c3233a5b531ac7ced77a80" translate="yes" xml:space="preserve">
          <source>The behavior of cache_size with a negative N was different prior to &lt;a href=&quot;https://sqlite.org/releaselog/3_7_10.html&quot;&gt;version 3.7.10&lt;/a&gt; (2012-01-16). In earlier versions, the number of pages in the cache was set to the absolute value of N.</source>
          <target state="translated">Поведение cache_size с отрицательным N отличалось до &lt;a href=&quot;https://sqlite.org/releaselog/3_7_10.html&quot;&gt;версии 3.7.10&lt;/a&gt; (2012-01-16). В более ранних версиях для количества страниц в кэше было установлено абсолютное значение N.</target>
        </trans-unit>
        <trans-unit id="478ce327d17671071ecdc539934c95e63faeda7c" translate="yes" xml:space="preserve">
          <source>The behavior of sqlite3changeset_apply_v2() and its streaming equivalent may be modified by passing a combination of &lt;a href=&quot;#SQLITE_CHANGESETAPPLY_INVERT&quot;&gt;supported flags&lt;/a&gt; as the 9th parameter.</source>
          <target state="translated">Поведение sqlite3changeset_apply_v2 () и его потокового эквивалента можно изменить, передав комбинацию &lt;a href=&quot;#SQLITE_CHANGESETAPPLY_INVERT&quot;&gt;поддерживаемых флагов&lt;/a&gt; в качестве 9-го параметра.</target>
        </trans-unit>
        <trans-unit id="6e75893c7d343c6a289f5aa0da4c1e36a51499e7" translate="yes" xml:space="preserve">
          <source>The behavior of sqlite3changeset_apply_v2() and its streaming equivalent may be modified by passing a combination of &lt;a href=&quot;c_changesetapply_invert&quot;&gt;supported flags&lt;/a&gt; as the 9th parameter.</source>
          <target state="translated">Поведение sqlite3changeset_apply_v2 () и его потокового эквивалента можно изменить, передав комбинацию &lt;a href=&quot;c_changesetapply_invert&quot;&gt;поддерживаемых флагов&lt;/a&gt; в качестве 9-го параметра.</target>
        </trans-unit>
        <trans-unit id="3b226ef505264d45ed6c9760d30054930a97eb46" translate="yes" xml:space="preserve">
          <source>The behavior of sqlite3changeset_start_v2() and its streaming equivalent may be modified by passing a combination of &lt;a href=&quot;#SQLITE_CHANGESETSTART_INVERT&quot;&gt;supported flags&lt;/a&gt; as the 4th parameter.</source>
          <target state="translated">Поведение sqlite3changeset_start_v2 () и его потокового эквивалента можно изменить, передав комбинацию &lt;a href=&quot;#SQLITE_CHANGESETSTART_INVERT&quot;&gt;поддерживаемых флагов&lt;/a&gt; в качестве 4-го параметра.</target>
        </trans-unit>
        <trans-unit id="462fed9af71f32884c9943463dae76b5706b0104" translate="yes" xml:space="preserve">
          <source>The behavior of sqlite3changeset_start_v2() and its streaming equivalent may be modified by passing a combination of &lt;a href=&quot;c_changesetstart_invert&quot;&gt;supported flags&lt;/a&gt; as the 4th parameter.</source>
          <target state="translated">Поведение sqlite3changeset_start_v2 () и его потокового эквивалента можно изменить, передав комбинацию &lt;a href=&quot;c_changesetstart_invert&quot;&gt;поддерживаемых флагов&lt;/a&gt; в качестве 4-го параметра.</target>
        </trans-unit>
        <trans-unit id="0cd600a43e57a68ed3c7e61e8926b28cfcf03236" translate="yes" xml:space="preserve">
          <source>The behaviour described above may be modified slightly by using the &lt;a href=&quot;pragma#pragma_read_uncommitted&quot;&gt;read_uncommitted&lt;/a&gt; pragma to change the isolation level from serialized (the default), to read-uncommitted.</source>
          <target state="translated">Поведение, описанное выше, можно немного изменить, используя прагму &lt;a href=&quot;pragma#pragma_read_uncommitted&quot;&gt;read_uncommitted,&lt;/a&gt; чтобы изменить уровень изоляции с сериализованного (по умолчанию) на чтение-незафиксированный.</target>
        </trans-unit>
        <trans-unit id="d91219df791273fdd065b20fbe3a1ddef8cd79ad" translate="yes" xml:space="preserve">
          <source>The behaviour of queries when a column-filter is specified both as part of the FTS query and by using a column as the LHS of a MATCH operator is slightly different. For a table with columns &quot;a&quot; and &quot;b&quot; and a query similar to:</source>
          <target state="translated">Поведение запросов,когда колонка-фильтр указана как в запросе FTS,так и при использовании колонки в качестве LHS оператора MATCH,несколько отличается.Для таблицы со столбцами &quot;a&quot; и &quot;b&quot; и аналогичного запроса:</target>
        </trans-unit>
        <trans-unit id="1b74d0e5579c64699d464837588df4c3744c10fa" translate="yes" xml:space="preserve">
          <source>The best approach to make reliable backup copies of an SQLite database is to make use of the &lt;a href=&quot;backup&quot;&gt;backup API&lt;/a&gt; that is part of the SQLite library. Failing that, it is safe to make a copy of an SQLite database file as long as there are no transactions in progress by any process. If the previous transaction failed, then it is important that any rollback journal (the &lt;code&gt;*-journal&lt;/code&gt; file) or write-ahead log (the &lt;code&gt;*-wal&lt;/code&gt; file) be copied together with the database file itself.</source>
          <target state="translated">Лучший подход к созданию надежных резервных копий базы данных SQLite - использовать &lt;a href=&quot;backup&quot;&gt;API резервного копирования,&lt;/a&gt; который является частью библиотеки SQLite. В противном случае можно безопасно сделать копию файла базы данных SQLite, если ни один из процессов не выполняет транзакции. Если предыдущая транзакция &lt;code&gt;*-journal&lt;/code&gt; неудачно, важно, чтобы любой журнал отката ( файл * -journal ) или журнал упреждающей записи ( файл &lt;code&gt;*-wal&lt;/code&gt; ) копировались вместе с самим файлом базы данных.</target>
        </trans-unit>
        <trans-unit id="3e4c95bce459286798ea2a27bd9ecd8decb1253c" translate="yes" xml:space="preserve">
          <source>The best feature of SQL (in &lt;u&gt;all&lt;/u&gt; its implementations, not just SQLite) is that it is a</source>
          <target state="translated">Лучшая особенность SQL (во &lt;u&gt;всех&lt;/u&gt; его реализациях, а не только SQLite) заключается в том, что он</target>
        </trans-unit>
        <trans-unit id="0acc0c4a6e57763a2a98687d8dd5dae3b2f9935e" translate="yes" xml:space="preserve">
          <source>The best way to understand how SQL database engines work is to think of SQL as a programming language, not as a &quot;query language&quot;. Each SQL statement is a separate program. Applications construct SQL program source files and send them to the database engine. The database engine compiles the SQL source code into executable form, runs that executable, then sends the result back to the application.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d79f775859b5387594a0b408b014948f69145bb6" translate="yes" xml:space="preserve">
          <source>The binary64 floating-point format uses 64 bits per number. Hence there are 1.845e+19 different possible floating point values. On the other hand there are infinitely many real numbers in the range of 1.7977e+308 and 4.9407e-324. It follows then that binary64 cannot possibly represent all possible real numbers within that range. Approximations are required.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc958ef4fbaadd7154585494d4a1f0d8657cd355" translate="yes" xml:space="preserve">
          <source>The block above uses a shorthand form to create the foreign key constraint. Attaching a &quot;REFERENCES</source>
          <target state="translated">В приведенном выше блоке для создания ограничения по внешнему ключу используется сокращенная форма.Прикрепление &quot;Переопределения</target>
        </trans-unit>
        <trans-unit id="be5a6e82c647cd58e78eb343df366b2a12164999" translate="yes" xml:space="preserve">
          <source>The blockid that corresponds to the leaf node with the largest blockid that belongs to this segment b-tree. Or zero if the entire segment b-tree fits on the root node.</source>
          <target state="translated">Блокада,соответствующая узлу листа с наибольшей блокой,принадлежащей этому сегменту b-дерева.Или ноль,если весь сегмент b-дерева укладывается в корневой узел.</target>
        </trans-unit>
        <trans-unit id="8114ba8fdc8ebfe0e7461c055a0e2fd44faa8a98" translate="yes" xml:space="preserve">
          <source>The blockid that corresponds to the node with the smallest blockid that belongs to this segment b-tree. Or zero if the entire segment b-tree fits on the root node. If it exists, this node is always a leaf node.</source>
          <target state="translated">Блокада,соответствующая узлу с наименьшей блокой,принадлежащей этому сегменту b-дерева.Или ноль,если весь сегмент b-дерева укладывается в корневой узел.Если он существует,то этот узел всегда является узлом листа.</target>
        </trans-unit>
        <trans-unit id="f9a2b7b8a28aace68acd7dc6116c16ed08d188be" translate="yes" xml:space="preserve">
          <source>The boolean identifiers TRUE and FALSE are usually just aliases for the integer values 1 and 0, respectively. However, if TRUE or FALSE occur on the right-hand side of an IS operator, then they form new unary postfix operators &quot;IS TRUE&quot; and &quot;IS FALSE&quot; which test the boolean value of the operand on the left.</source>
          <target state="translated">Булевы идентификаторы TRUE и FALSE обычно являются просто псевдонимами для целочисленных значений 1 и 0 соответственно.Однако,если TRUE или FALSE встречаются справа от оператора IS,то они образуют новые унарные постфиксные операторы &quot;IS TRUE&quot; и &quot;IS FALSE&quot;,которые проверяют булевое значение операнда слева.</target>
        </trans-unit>
        <trans-unit id="cab234605422320bfe969b5533e06293770750e7" translate="yes" xml:space="preserve">
          <source>The boundary between a file format and an application format is fuzzy. This article calls JPEG a file format, but for an image editor, JPEG might be considered the application format. Much depends on context. For this article, let us say that a file format stores a single object and an application format stores many different objects and their relationships to one another.</source>
          <target state="translated">Граница между форматом файла и форматом приложения размыта.В этой статье JPEG называется форматом файла,но для редактора изображений JPEG можно считать форматом приложения.Многое зависит от контекста.Для этой статьи скажем,что формат файла хранит один объект,а формат приложения хранит множество различных объектов и их связи друг с другом.</target>
        </trans-unit>
        <trans-unit id="47707c3fbd653507bcb6765a57019dc2e9df3e77" translate="yes" xml:space="preserve">
          <source>The boundary description &quot;0 PRECEDING&quot; always means the same thing as &quot;CURRENT ROW&quot;.</source>
          <target state="translated">Описание границы &quot;0 ПОКАЗАТЕЛЬСТВА&quot; всегда означает то же самое,что и &quot;CURRENT ROW&quot;.</target>
        </trans-unit>
        <trans-unit id="65e8d52b8ac553953a11325088115a059c247d93" translate="yes" xml:space="preserve">
          <source>The build process makes extensive use of the &lt;a href=&quot;http://www.tcl-lang.org/&quot;&gt;Tcl&lt;/a&gt; scripting language. You will need to have a copy of TCL installed in order for the make targets above to work. Easy-to-use installers can be obtained from &lt;a href=&quot;http://www.tcl-lang.org/&quot;&gt;http://www.tcl-lang.org/&lt;/a&gt;. Many unix workstations have Tcl installed by default.</source>
          <target state="translated">В процессе сборки широко используется язык сценариев &lt;a href=&quot;http://www.tcl-lang.org/&quot;&gt;Tcl&lt;/a&gt; . Вам потребуется установить копию TCL, чтобы указанные выше цели make работали. Простые в использовании установщики можно получить по &lt;a href=&quot;http://www.tcl-lang.org/&quot;&gt;адресу http://www.tcl-lang.org/&lt;/a&gt; . На многих рабочих станциях unix по умолчанию установлен Tcl.</target>
        </trans-unit>
        <trans-unit id="7d4e60a19016fc83307d1ede2e1aa59927cbae39" translate="yes" xml:space="preserve">
          <source>The built-in &lt;a href=&quot;lang_corefunc#iif&quot;&gt;iif(x,y,z) SQL function&lt;/a&gt; is logically equivalent to &quot;CASE WHEN x THEN y ELSE z END&quot;. The iif() function is found in SQL Server and is included in SQLite for compatibility. Some developers prefer the iif() function because it is more concise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c9c97359a7945f825df70e8e7d3bf03b435fc83" translate="yes" xml:space="preserve">
          <source>The built-in &lt;a href=&quot;lang_datefunc&quot;&gt;date and time functions&lt;/a&gt; have been enhanced so that they can be used in &lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK constraints&lt;/a&gt;, in &lt;a href=&quot;expridx&quot;&gt;indexes on expressions&lt;/a&gt;, and in the WHERE clauses of &lt;a href=&quot;partialindex&quot;&gt;partial indexes&lt;/a&gt;, provided that they do not use the 'now', 'localtime', or 'utc' keywords. &lt;a href=&quot;deterministic#dtexception&quot;&gt;More information&lt;/a&gt;.</source>
          <target state="translated">Встроенные &lt;a href=&quot;lang_datefunc&quot;&gt;функции даты и времени&lt;/a&gt; были улучшены, так что их можно использовать в &lt;a href=&quot;lang_createtable#ckconst&quot;&gt;ограничениях CHECK&lt;/a&gt; , в &lt;a href=&quot;expridx&quot;&gt;индексах для выражений&lt;/a&gt; и в предложениях WHERE &lt;a href=&quot;partialindex&quot;&gt;частичных индексов&lt;/a&gt; , при условии, что они не используют 'now', 'localtime', или ключевые слова utc. &lt;a href=&quot;deterministic#dtexception&quot;&gt;Больше информации&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8a2f201a6d744f00508ed72b40ed46b5c83f60f1" translate="yes" xml:space="preserve">
          <source>The built-in &lt;a href=&quot;lang_datefunc&quot;&gt;date and time functions&lt;/a&gt; of SQLite are a special case. These functions are usually considered deterministic. However, if these functions use the string &quot;now&quot; as the date, or if they use the &lt;a href=&quot;lang_datefunc#localtime&quot;&gt;localtime modifier&lt;/a&gt; or the &lt;a href=&quot;lang_datefunc#localtime&quot;&gt;utc modifier&lt;/a&gt;, then they are considered non-deterministic. Because the function inputs are not necessarily known until run-time, the date/time functions will throw an exception if they encounter any of the non-deterministic features in a context where only deterministic functions are allowed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96663fb71968ae34b1131b3cb53ad7ba03319209" translate="yes" xml:space="preserve">
          <source>The built-in &lt;a href=&quot;lang_datefunc&quot;&gt;date and time functions&lt;/a&gt; of SQLite are a special case. These functions are usually considered deterministic. However, if these functions use the string &quot;now&quot; as the date, or if they use the &lt;a href=&quot;lang_datefunc#localtime&quot;&gt;localtime modifier&lt;/a&gt; or the &lt;a href=&quot;lang_datefunc#localtime&quot;&gt;utc modifier&lt;/a&gt;, then they are considered non-deterministic. Because the function inputs are not necessarily known until run-time, the date/time functions will throw an exception if they encounter any of the non-deterministic features in a context where only deterministic functions are allows.</source>
          <target state="translated">Особый случай - встроенные &lt;a href=&quot;lang_datefunc&quot;&gt;функции даты и времени&lt;/a&gt; SQLite. Эти функции обычно считаются детерминированными. Однако, если эти функции используют строку &amp;laquo;сейчас&amp;raquo; в качестве даты, или если они используют &lt;a href=&quot;lang_datefunc#localtime&quot;&gt;модификатор localtime&lt;/a&gt; или &lt;a href=&quot;lang_datefunc#localtime&quot;&gt;модификатор utc&lt;/a&gt; , то они считаются недетерминированными. Поскольку входные данные функции не обязательно известны до времени выполнения, функции даты / времени вызовут исключение, если они обнаружат любую из недетерминированных функций в контексте, где разрешены только детерминированные функции.</target>
        </trans-unit>
        <trans-unit id="adf744ca87e6c1a5f3b9a68b24961edea60809eb" translate="yes" xml:space="preserve">
          <source>The built-in &lt;a href=&quot;lang_datefunc&quot;&gt;date and time functions&lt;/a&gt; of SQLite understand date/times in all of the formats above, and can freely change between them. Which format you use, is entirely up to your application.</source>
          <target state="translated">Встроенные &lt;a href=&quot;lang_datefunc&quot;&gt;функции даты и времени&lt;/a&gt; SQLite понимают дату и время во всех форматах, указанных выше, и могут свободно переключаться между ними. Какой формат вы используете, полностью зависит от вашего приложения.</target>
        </trans-unit>
        <trans-unit id="8a5b38222ac4fb96f9a2b189215735dd804f8b2d" translate="yes" xml:space="preserve">
          <source>The built-in BINARY collation compares strings byte by byte using the memcmp() function from the standard C library.</source>
          <target state="translated">Встроенная функция BINARY сравнивает строки байт за байтом с помощью функции memcmp()из стандартной библиотеки Си.</target>
        </trans-unit>
        <trans-unit id="1b9d8615812e1b5dddaadf330db3704ed6104526" translate="yes" xml:space="preserve">
          <source>The built-in SQLite has compile-time options such as SQLITE_PRINTF_PRECISION_LIMIT that provide defense against denial-of-service attacks for application that expose the printf() functionality to untrusted users.</source>
          <target state="translated">Встроенный SQLite имеет опции времени компиляции,такие как SQLITE_PRINTF_PRECISION_LIMIT,которые обеспечивают защиту от атак типа &quot;отказ в обслуживании&quot; для приложений,которые подвергают функциональность printf()недоверенным пользователям.</target>
        </trans-unit>
        <trans-unit id="55ca16581ef8177476edac12f1cd562f40820547" translate="yes" xml:space="preserve">
          <source>The built-in Wagner edit-distance function with fixed weights can be replaced by the &lt;a href=&quot;spellfix1#editdist3&quot;&gt;editdist3()&lt;/a&gt; edit-distance function with application-defined weights and support for unicode, by specifying the &quot;edit_cost_table=</source>
          <target state="translated">Встроенная функция расстояния редактирования Вагнера с фиксированными весами может быть заменена &lt;a href=&quot;spellfix1#editdist3&quot;&gt;функцией&lt;/a&gt; редактирования расстояния editdist3 () с весами, определяемыми приложением, и поддержкой юникода, указав &quot;edit_cost_table =</target>
        </trans-unit>
        <trans-unit id="919d1860b9bd16d4532d25388f1ffc8375baa209" translate="yes" xml:space="preserve">
          <source>The built-in auxiliary function bm25() returns a real value indicating how well the current row matches the full-text query. The better the match, the numerically smaller the value returned. A query such as the following may be used to return matches in order from best to worst match:</source>
          <target state="translated">Встроенная вспомогательная функция bm25()возвращает реальное значение,указывающее на соответствие текущей строки полнотекстовому запросу.Чем лучше соответствие,тем меньше возвращаемое числовое значение.Для возврата совпадений по порядку от лучшего к худшему может быть использован такой запрос,как следующий:</target>
        </trans-unit>
        <trans-unit id="89afdc49975b5af95582dcbca838ad26684b8aa6" translate="yes" xml:space="preserve">
          <source>The built-in auxiliary functions provided as part of FTS5 are described in the following section. Applications may also implement &lt;a href=&quot;fts5#custom_auxiliary_functions&quot;&gt;custom auxiliary functions in C&lt;/a&gt;.</source>
          <target state="translated">Встроенные дополнительные функции, входящие в состав FTS5, описаны в следующем разделе. Приложения могут также реализовать &lt;a href=&quot;fts5#custom_auxiliary_functions&quot;&gt;пользовательские вспомогательные функции в C&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9249ce5cc7f5a31c9f40d1d2aedadc1d6c797929" translate="yes" xml:space="preserve">
          <source>The built-in functions used to implement LIKE and GLOB must not have been overloaded using the &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt; API.</source>
          <target state="translated">Встроенные функции, используемые для реализации LIKE и GLOB, не должны быть перегружены с помощью API &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="49a23aa1a5c2e20f2c3c4ac966e9783cdfed04b2" translate="yes" xml:space="preserve">
          <source>The built-in memory allocators in SQLite also provide the following additional interfaces:</source>
          <target state="translated">Встроенные аллокаторы памяти в SQLite также предоставляют следующие дополнительные интерфейсы:</target>
        </trans-unit>
        <trans-unit id="4fa083c0cbf6940d57170ea9aa2f51d37713e7a7" translate="yes" xml:space="preserve">
          <source>The built-in min() and max() functions now honor the difference between NUMERIC and TEXT datatypes. Formerly, min() and max() always assumed their arguments were of type NUMERIC.</source>
          <target state="translated">Встроенные функции min()и max()теперь учитывают разницу между типами данных NUMERIC и TEXT.Раньше функции min()и max()всегда предполагали,что их аргументы имеют тип NUMERIC.</target>
        </trans-unit>
        <trans-unit id="09829581870ec4ebe1c207006b15fd18f63554a5" translate="yes" xml:space="preserve">
          <source>The built-in printf() implementation does not handle posix positional referencing modifiers that allow the order of arguments to printf() to be different from the order of the %-substitutions. In the built-in printf(), the order of the arguments must exactly match the order of the %-substitutions.</source>
          <target state="translated">Встроенная реализация printf()не обрабатывает модификаторы позиционирования,которые позволяют порядок аргументов для printf()отличаться от порядка %-замещений.Во встроенной функции printf()порядок аргументов должен точно совпадать с порядком %-замещений.</target>
        </trans-unit>
        <trans-unit id="e86ab3d5db7f0615044de9985403c55275e95eaf" translate="yes" xml:space="preserve">
          <source>The built-in printf() implementation uses extra code space (about 7800 bytes on GCC 5.4 with -Os).</source>
          <target state="translated">Встроенная реализация printf()использует дополнительное кодовое пространство (около 7800 байт на GCC 5.4 с -O).</target>
        </trans-unit>
        <trans-unit id="68470e8ed26cf7ace0d2e09f00b9eab48903fc0b" translate="yes" xml:space="preserve">
          <source>The built-in tokenizers and auxiliary functions described in this document are all implemented using the publicly available API described below.</source>
          <target state="translated">Встроенные токенайзеры и вспомогательные функции,описанные в этом документе,реализованы с использованием общедоступного API,описанного ниже.</target>
        </trans-unit>
        <trans-unit id="9fc396222878f092f3ee1e16fde31353451d89d0" translate="yes" xml:space="preserve">
          <source>The busy callback should not take any actions which modify the database connection that invoked the busy handler. In other words, the busy handler is not reentrant. Any such actions result in undefined behavior.</source>
          <target state="translated">Обратный вызов &quot;занято&quot; не должен предпринимать никаких действий по изменению соединения с БД,вызвавшего обработчик &quot;занято&quot;.Другими словами,обработчик &quot;занят&quot; не является реентерабельным.Любые такие действия приводят к неопределенному поведению.</target>
        </trans-unit>
        <trans-unit id="f4f573b1a486bc41f01b46a6d80d9ecec47641b0" translate="yes" xml:space="preserve">
          <source>The byte offset of the matching term within the column.</source>
          <target state="translated">Смещение байта совпадающего термина внутри столбца.</target>
        </trans-unit>
        <trans-unit id="05f015bc1e7204efce9fc81ea976f5bbb81740a9" translate="yes" xml:space="preserve">
          <source>The byte-order of UTF16 input text is determined by the byte-order mark (BOM, U+FEFF) found in first character, which is removed, or in the absence of a BOM the byte order is the native byte order of the host machine for sqlite3_bind_text16() or the byte order specified in the 6th parameter for sqlite3_bind_text64(). If UTF16 input text contains invalid unicode characters, then SQLite might change those invalid characters into the unicode replacement character: U+FFFD.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f568127fbaa97f70cb703194692bb7bd81d899e" translate="yes" xml:space="preserve">
          <source>The bytecode and tables_used tables are only available if SQLite has been compiled with the &lt;a href=&quot;compile#enable_bytecode_vtab&quot;&gt;-DSQLITE_ENABLE_BYTECODE_VTAB&lt;/a&gt; compile-time option. The &lt;a href=&quot;cli&quot;&gt;CLI&lt;/a&gt; has been compiled that way, and so you can use the standard &lt;a href=&quot;cli&quot;&gt;CLI&lt;/a&gt; as a test platform to experiement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbb76aa2fa15c5bd4f4468b266b4d77ab34c0a75" translate="yes" xml:space="preserve">
          <source>The bytecode engine begins execution on instruction number 0. Execution continues until a &lt;a href=&quot;opcode#Halt&quot;&gt;Halt&lt;/a&gt; instruction is seen, or until the program counter becomes greater than the address of last instruction, or until there is an error. When the bytecode engine halts, all memory that it allocated is released and all database cursors it may have had open are closed. If the execution stopped due to an error, any pending transactions are terminated and changes made to the database are rolled back.</source>
          <target state="translated">Механизм байт-кода начинает выполнение с инструкции номер 0. Выполнение продолжается до тех пор, пока не будет обнаружена инструкция &lt;a href=&quot;opcode#Halt&quot;&gt;Halt&lt;/a&gt; , или пока счетчик программы не станет больше адреса последней инструкции, или пока не возникнет ошибка. Когда механизм байт-кода останавливается, вся выделенная им память освобождается, и все курсоры базы данных, которые он мог открыть, закрываются. Если выполнение остановлено из-за ошибки, все ожидающие транзакции прекращаются, а изменения, внесенные в базу данных, откатываются.</target>
        </trans-unit>
        <trans-unit id="9a6398c9082248055b1fbc77ff5022201f3b1441" translate="yes" xml:space="preserve">
          <source>The bytecode engine has no stack on which to store the return address of a subroutine. Return addresses must be stored in registers. Hence, bytecode subroutines are not reentrant.</source>
          <target state="translated">В движке байткода нет стека,в котором хранился бы адрес возврата подпрограммы.Адреса возвратов должны храниться в регистрах.Следовательно,подпрограммы байткода не являются реентерабельными.</target>
        </trans-unit>
        <trans-unit id="28f086fcda9ebdf902655d03a38811e78fc96fb9" translate="yes" xml:space="preserve">
          <source>The bytecode engine is &lt;u&gt;not&lt;/u&gt; an API of SQLite. Details about the bytecode engine change from one release of SQLite to the next. Applications that use SQLite should not depend on any of the details found in this document.</source>
          <target state="translated">Механизм байт-кода &lt;u&gt;не&lt;/u&gt; является API SQLite. Подробная информация об изменении механизма байт-кода от одного выпуска SQLite к другому. Приложения, использующие SQLite, не должны зависеть от каких-либо деталей, содержащихся в этом документе.</target>
        </trans-unit>
        <trans-unit id="e552468adf820f25d29531e1e14d99733690b86b" translate="yes" xml:space="preserve">
          <source>The bytecode generated by the code generator is called a &quot;&lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt;&quot;. Translating SQL source text into a prepared statement is analogous to converting a C++ program into machine code by invoking gcc or clang. Human-readable source text (SQL or C++) goes in, and a machine readable executable (bytecode or machine code) comes out.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f39ef66488b6211208c988daf5ffcab23760705" translate="yes" xml:space="preserve">
          <source>The bytecode virtual machine is the heart of SQLite. Programmers who want to understand how SQLite operates internally must be familiar with the bytecode engine.</source>
          <target state="translated">Виртуальная машина с байткодом является сердцем SQLite.Программисты,которые хотят понять,как SQLite работает внутри,должны быть знакомы с движком байткода.</target>
        </trans-unit>
        <trans-unit id="efeaf3fe17bdefca5b34d3df41725c68d1db2de0" translate="yes" xml:space="preserve">
          <source>The cFrom and cTo columns show edit transformation strings. Either or both columns may contain more than one character. Or either column (but not both) may hold an empty string. When cFrom is empty, that is the cost of inserting cTo. When cTo is empty, that is the cost of deleting cFrom.</source>
          <target state="translated">В колонках cFrom и cTo показаны строки редактирования трансформации.Любой из столбцов или оба столбца могут содержать более одного символа.Или любой столбец (но не оба)может содержать пустую строку.Когда cFrom пуст,это стоимость вставки cTo.Когда cTo пустая-это стоимость удаления cFrom.</target>
        </trans-unit>
        <trans-unit id="334e7f3d3c0f1d00666221b0f79b06086771f2a0" translate="yes" xml:space="preserve">
          <source>The cache must not perform any reference counting. A single call to xUnpin() unpins the page regardless of the number of prior calls to xFetch().</source>
          <target state="translated">Кэш не должен производить подсчет ссылок.Одиночный вызов xUnpin()распечатывает страницу независимо от количества предыдущих вызовов xFetch().</target>
        </trans-unit>
        <trans-unit id="ba91e47edf5c7de46f6d683125d4647799118c05" translate="yes" xml:space="preserve">
          <source>The cache query parameter determines if the new database is opened using &lt;a href=&quot;sharedcache&quot;&gt;shared cache mode&lt;/a&gt; or with a private cache.</source>
          <target state="translated">Параметр запроса кеша определяет, будет ли открыта новая база данных в &lt;a href=&quot;sharedcache&quot;&gt;режиме общего кэша&lt;/a&gt; или в частном кэше.</target>
        </trans-unit>
        <trans-unit id="3b1d92f7c11891a9dfcf8a02bdb8e1d1b67e45d9" translate="yes" xml:space="preserve">
          <source>The cache sharing mode set by this interface effects all subsequent calls to &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;, and &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open16()&lt;/a&gt;. Existing database connections continue to use the sharing mode that was in effect at the time they were opened.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c24d3d1b52233a8d1d33d1521f0d40a35115941" translate="yes" xml:space="preserve">
          <source>The cache sharing mode set by this interface effects all subsequent calls to &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;, and &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open16()&lt;/a&gt;. Existing database connections continue use the sharing mode that was in effect at the time they were opened.</source>
          <target state="translated">Режим совместного использования кеша, установленный этим интерфейсом, влияет на все последующие вызовы &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2 ()&lt;/a&gt; и &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open16 ()&lt;/a&gt; . Существующие соединения с базой данных продолжают использовать режим общего доступа, который действовал на момент их открытия.</target>
        </trans-unit>
        <trans-unit id="84568a531cbb8fea84a45d0e913a15a98ad6bdd3" translate="yes" xml:space="preserve">
          <source>The cache sharing mode set by this interface effects all subsequent calls to &lt;a href=&quot;open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;, and &lt;a href=&quot;open&quot;&gt;sqlite3_open16()&lt;/a&gt;. Existing database connections continue to use the sharing mode that was in effect at the time they were opened.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f37b504a453065b9fe4d5c4bf29c4836a5d7646e" translate="yes" xml:space="preserve">
          <source>The cache sharing mode set by this interface effects all subsequent calls to &lt;a href=&quot;open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;, and &lt;a href=&quot;open&quot;&gt;sqlite3_open16()&lt;/a&gt;. Existing database connections continue use the sharing mode that was in effect at the time they were opened.</source>
          <target state="translated">Режим совместного использования кеша, установленный этим интерфейсом, влияет на все последующие вызовы &lt;a href=&quot;open&quot;&gt;sqlite3_open ()&lt;/a&gt; , &lt;a href=&quot;open&quot;&gt;sqlite3_open_v2 ()&lt;/a&gt; и &lt;a href=&quot;open&quot;&gt;sqlite3_open16 ()&lt;/a&gt; . Существующие соединения с базой данных продолжают использовать режим общего доступа, который действовал на момент их открытия.</target>
        </trans-unit>
        <trans-unit id="e474b4529162f0cc96b1a00a4049ab5a12dcf32d" translate="yes" xml:space="preserve">
          <source>The cache-flush method &lt;a href=&quot;c3ref/finalize&quot;&gt;finalizes&lt;/a&gt; all prepared statements currently in the cache.</source>
          <target state="translated">Метод cache-flush &lt;a href=&quot;c3ref/finalize&quot;&gt;завершает&lt;/a&gt; все подготовленные операторы, находящиеся в данный момент в кеше.</target>
        </trans-unit>
        <trans-unit id="9d8d3b22c77f42c07d50a96703e45047516a539f" translate="yes" xml:space="preserve">
          <source>The cache_spill pragma enables or disables the ability of the pager to spill dirty cache pages to the database file in the middle of a transaction. Cache_spill is enabled by default and most applications should leave it that way as cache spilling is usually advantageous. However, a cache spill has the side-effect of acquiring an &lt;a href=&quot;lockingv3#excl_lock&quot;&gt;EXCLUSIVE lock&lt;/a&gt; on the database file. Hence, some applications that have large long-running transactions may want to disable cache spilling in order to prevent the application from acquiring an exclusive lock on the database until the moment that the transaction &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt;s.</source>
          <target state="translated">Прагма cache_spill включает или отключает возможность пейджера передавать грязные страницы кэша в файл базы данных в середине транзакции. Cache_spill включен по умолчанию, и большинство приложений должны оставить его таким образом, поскольку проливание кеша обычно является преимуществом. Однако утечка кэша имеет побочный эффект в виде &lt;a href=&quot;lockingv3#excl_lock&quot;&gt;ИСКЛЮЧИТЕЛЬНОЙ блокировки&lt;/a&gt; файла базы данных. Следовательно, некоторые приложения, которые имеют большие длительные транзакции, могут захотеть отключить переполнение кеша, чтобы предотвратить получение приложением монопольной блокировки базы данных до момента, когда транзакция &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; s.</target>
        </trans-unit>
        <trans-unit id="9721a1202302bdb3675cb33fdaf401b47649ef3f" translate="yes" xml:space="preserve">
          <source>The callback function is used to receive the results of a query. A prototype for the callback function is as follows:</source>
          <target state="translated">Функция обратного вызова используется для получения результатов запроса.Прототипом функции обратного вызова является следующий:</target>
        </trans-unit>
        <trans-unit id="dce299de07269b78871b3c034bf37ba0c0271573" translate="yes" xml:space="preserve">
          <source>The callback function registered by sqlite3_profile() is invoked as each SQL statement finishes. The profile callback contains the original statement text and an estimate of wall-clock time of how long that statement took to run. The profile callback time is in units of nanoseconds, however the current implementation is only capable of millisecond resolution so the six least significant digits in the time are meaningless. Future versions of SQLite might provide greater resolution on the profiler callback. Invoking either &lt;a href=&quot;#sqlite3_profile&quot;&gt;sqlite3_trace()&lt;/a&gt; or &lt;a href=&quot;#sqlite3_trace_v2&quot;&gt;sqlite3_trace_v2()&lt;/a&gt; will cancel the profile callback.</source>
          <target state="translated">Функция обратного вызова, зарегистрированная sqlite3_profile (), вызывается после завершения каждого оператора SQL. Обратный вызов профиля содержит исходный текст оператора и приблизительное время выполнения этого оператора. Время обратного вызова профиля выражается в наносекундах, однако текущая реализация допускает только миллисекундное разрешение, поэтому шесть наименьших значащих цифр времени не имеют смысла. В будущих версиях SQLite может быть обеспечено большее разрешение обратного вызова профилировщика. Вызов &lt;a href=&quot;#sqlite3_profile&quot;&gt;sqlite3_trace ()&lt;/a&gt; или &lt;a href=&quot;#sqlite3_trace_v2&quot;&gt;sqlite3_trace_v2 ()&lt;/a&gt; отменит обратный вызов профиля.</target>
        </trans-unit>
        <trans-unit id="a6f29aa702b9f0b66493dfb5e14c2df5fa8051eb" translate="yes" xml:space="preserve">
          <source>The callback function registered by sqlite3_profile() is invoked as each SQL statement finishes. The profile callback contains the original statement text and an estimate of wall-clock time of how long that statement took to run. The profile callback time is in units of nanoseconds, however the current implementation is only capable of millisecond resolution so the six least significant digits in the time are meaningless. Future versions of SQLite might provide greater resolution on the profiler callback. Invoking either &lt;a href=&quot;profile&quot;&gt;sqlite3_trace()&lt;/a&gt; or &lt;a href=&quot;trace_v2&quot;&gt;sqlite3_trace_v2()&lt;/a&gt; will cancel the profile callback.</source>
          <target state="translated">Функция обратного вызова, зарегистрированная sqlite3_profile (), вызывается после завершения каждого оператора SQL. Обратный вызов профиля содержит исходный текст оператора и приблизительное время выполнения этого оператора. Время обратного вызова профиля выражается в наносекундах, однако текущая реализация допускает только миллисекундное разрешение, поэтому шесть наименьших значащих цифр времени не имеют смысла. В будущих версиях SQLite может быть обеспечено большее разрешение обратного вызова профилировщика. Вызов &lt;a href=&quot;profile&quot;&gt;sqlite3_trace ()&lt;/a&gt; или &lt;a href=&quot;trace_v2&quot;&gt;sqlite3_trace_v2 ()&lt;/a&gt; отменит обратный вызов профиля.</target>
        </trans-unit>
        <trans-unit id="6cc8b0e0c1561082e8c35dc0acaf0338a474ad77" translate="yes" xml:space="preserve">
          <source>The callback function registered by sqlite3_trace() is invoked at various times when an SQL statement is being run by &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt;. The sqlite3_trace() callback is invoked with a UTF-8 rendering of the SQL statement text as the statement first begins executing. Additional sqlite3_trace() callbacks might occur as each triggered subprogram is entered. The callbacks for triggers contain a UTF-8 SQL comment that identifies the trigger.</source>
          <target state="translated">Функция обратного вызова, зарегистрированная sqlite3_trace (), вызывается в разное время, когда SQL-оператор выполняется &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step ()&lt;/a&gt; . Обратный вызов sqlite3_trace () вызывается с отрисовкой текста оператора SQL в кодировке UTF-8, когда оператор начинает выполняться первым. Дополнительные обратные вызовы sqlite3_trace () могут возникать при входе в каждую запущенную подпрограмму. Обратные вызовы для триггеров содержат комментарий SQL UTF-8, который идентифицирует триггер.</target>
        </trans-unit>
        <trans-unit id="ce29a09fb52c337eecabbd8bc599ef45377bf00d" translate="yes" xml:space="preserve">
          <source>The callback function registered by sqlite3_trace() is invoked at various times when an SQL statement is being run by &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt;. The sqlite3_trace() callback is invoked with a UTF-8 rendering of the SQL statement text as the statement first begins executing. Additional sqlite3_trace() callbacks might occur as each triggered subprogram is entered. The callbacks for triggers contain a UTF-8 SQL comment that identifies the trigger.</source>
          <target state="translated">Функция обратного вызова, зарегистрированная sqlite3_trace (), вызывается в разное время, когда SQL-оператор выполняется &lt;a href=&quot;step&quot;&gt;sqlite3_step ()&lt;/a&gt; . Обратный вызов sqlite3_trace () вызывается с отрисовкой текста оператора SQL в кодировке UTF-8, когда оператор начинает выполняться первым. Дополнительные обратные вызовы sqlite3_trace () могут возникать при входе в каждую запущенную подпрограмму. Обратные вызовы для триггеров содержат комментарий SQL UTF-8, который идентифицирует триггер.</target>
        </trans-unit>
        <trans-unit id="b2f2fd31e08bf7a8ddd0b8f8f2559aa236b781e8" translate="yes" xml:space="preserve">
          <source>The callback function should normally return 0. If the callback function returns non-zero, the query is immediately aborted and &lt;b&gt;sqlite_exec&lt;/b&gt; will return SQLITE_ABORT.</source>
          <target state="translated">Функция обратного вызова обычно должна возвращать 0. Если функция обратного вызова возвращает ненулевое значение, запрос немедленно прерывается, и &lt;b&gt;sqlite_exec&lt;/b&gt; возвращает SQLITE_ABORT.</target>
        </trans-unit>
        <trans-unit id="2394e983e60bde9a89a8173fd3ab1cfc913e1dc5" translate="yes" xml:space="preserve">
          <source>The callback function should normally return &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt;. If an error code is returned, that error will propagate back up through the SQLite code base to cause the statement that provoked the callback to report an error, though the commit will have still occurred. If the callback returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ROW&lt;/a&gt; or &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_DONE&lt;/a&gt;, or if it returns a value that does not correspond to any valid SQLite error code, the results are undefined.</source>
          <target state="translated">Функция обратного вызова обычно должна возвращать &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; . Если возвращается код ошибки, эта ошибка будет распространяться обратно через базу кода SQLite, чтобы оператор, который спровоцировал обратный вызов, сообщил об ошибке, хотя фиксация все равно произойдет. Если обратный вызов возвращает &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ROW&lt;/a&gt; или &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_DONE&lt;/a&gt; или возвращает значение, не соответствующее какому-либо допустимому коду ошибки SQLite, результаты не определены.</target>
        </trans-unit>
        <trans-unit id="e115553094195c6d671fc1803e4945ba335eedc5" translate="yes" xml:space="preserve">
          <source>The callback function should normally return &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;. If an error code is returned, that error will propagate back up through the SQLite code base to cause the statement that provoked the callback to report an error, though the commit will have still occurred. If the callback returns &lt;a href=&quot;../rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt; or &lt;a href=&quot;../rescode#done&quot;&gt;SQLITE_DONE&lt;/a&gt;, or if it returns a value that does not correspond to any valid SQLite error code, the results are undefined.</source>
          <target state="translated">Функция обратного вызова обычно должна возвращать &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; . Если возвращается код ошибки, эта ошибка будет распространяться обратно через базу кода SQLite, чтобы оператор, который спровоцировал обратный вызов, сообщил об ошибке, хотя фиксация все равно произойдет. Если обратный вызов возвращает &lt;a href=&quot;../rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt; или &lt;a href=&quot;../rescode#done&quot;&gt;SQLITE_DONE&lt;/a&gt; или возвращает значение, не соответствующее какому-либо допустимому коду ошибки SQLite, результаты не определены.</target>
        </trans-unit>
        <trans-unit id="dd2c627a789615e3efe180bdedfefe32d9d62d76" translate="yes" xml:space="preserve">
          <source>The callback function should register the desired collation using &lt;a href=&quot;#sqlite3_create_collation&quot;&gt;sqlite3_create_collation()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_create_collation&quot;&gt;sqlite3_create_collation16()&lt;/a&gt;, or &lt;a href=&quot;#sqlite3_create_collation&quot;&gt;sqlite3_create_collation_v2()&lt;/a&gt;.</source>
          <target state="translated">Функция обратного вызова должна зарегистрировать желаемое сопоставление с помощью &lt;a href=&quot;#sqlite3_create_collation&quot;&gt;sqlite3_create_collation ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_create_collation&quot;&gt;sqlite3_create_collation16 ()&lt;/a&gt; или &lt;a href=&quot;#sqlite3_create_collation&quot;&gt;sqlite3_create_collation_v2 ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c17f517957de57a117a3b4627294584d44e59419" translate="yes" xml:space="preserve">
          <source>The callback function should register the desired collation using &lt;a href=&quot;create_collation&quot;&gt;sqlite3_create_collation()&lt;/a&gt;, &lt;a href=&quot;create_collation&quot;&gt;sqlite3_create_collation16()&lt;/a&gt;, or &lt;a href=&quot;create_collation&quot;&gt;sqlite3_create_collation_v2()&lt;/a&gt;.</source>
          <target state="translated">Функция обратного вызова должна зарегистрировать желаемое сопоставление с помощью &lt;a href=&quot;create_collation&quot;&gt;sqlite3_create_collation ()&lt;/a&gt; , &lt;a href=&quot;create_collation&quot;&gt;sqlite3_create_collation16 ()&lt;/a&gt; или &lt;a href=&quot;create_collation&quot;&gt;sqlite3_create_collation_v2 ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fefabcb34707d427a36b9901ef209a203d46bf9f" translate="yes" xml:space="preserve">
          <source>The callback is invoked by SQLite after the commit has taken place and the associated write-lock on the database released, so the implementation may read, write or &lt;a href=&quot;../wal#ckpt&quot;&gt;checkpoint&lt;/a&gt; the database as required.</source>
          <target state="translated">Обратный вызов вызывается SQLite после совершения фиксации и снятия связанной блокировки записи в базе данных, поэтому реализация может читать, записывать или &lt;a href=&quot;../wal#ckpt&quot;&gt;проверять&lt;/a&gt; базу данных по мере необходимости.</target>
        </trans-unit>
        <trans-unit id="f6c4a8d646e0cbd66ca6c45574aae0dd0351286a" translate="yes" xml:space="preserve">
          <source>The callback is invoked by SQLite after the commit has taken place and the associated write-lock on the database released, so the implementation may read, write or &lt;a href=&quot;wal#ckpt&quot;&gt;checkpoint&lt;/a&gt; the database as required.</source>
          <target state="translated">Обратный вызов вызывается SQLite после совершения фиксации и снятия связанной блокировки записи в базе данных, поэтому реализация может читать, записывать или &lt;a href=&quot;wal#ckpt&quot;&gt;проверять&lt;/a&gt; базу данных по мере необходимости.</target>
        </trans-unit>
        <trans-unit id="facad5f03164aa5e049b3e0fcdccc7d1ce7b086d" translate="yes" xml:space="preserve">
          <source>The callback is invoked every N virtual machine operations, where N is supplied as the second argument to &lt;b&gt;sqlite_progress_handler()&lt;/b&gt;. The third and fourth arguments to &lt;b&gt;sqlite_progress_handler()&lt;/b&gt; are a pointer to the routine to be invoked and a void pointer to be passed as the first argument to it.</source>
          <target state="translated">Обратный вызов вызывается каждые N операций виртуальной машины, где N предоставляется в качестве второго аргумента функции &lt;b&gt;sqlite_progress_handler ()&lt;/b&gt; . Третий и четвертый аргументы &lt;b&gt;sqlite_progress_handler ()&lt;/b&gt; - это указатель на вызываемую процедуру и указатель void, который должен быть передан ей в качестве первого аргумента.</target>
        </trans-unit>
        <trans-unit id="70ae791199d0c0d2e25d25668478f3c97d6fcbcf" translate="yes" xml:space="preserve">
          <source>The callback registered by this function replaces any existing callback registered using &lt;a href=&quot;#sqlite3_wal_hook&quot;&gt;sqlite3_wal_hook()&lt;/a&gt;. Likewise, registering a callback using &lt;a href=&quot;#sqlite3_wal_hook&quot;&gt;sqlite3_wal_hook()&lt;/a&gt; disables the automatic checkpoint mechanism configured by this function.</source>
          <target state="translated">Обратный вызов, зарегистрированный этой функцией, заменяет любой существующий обратный вызов, зарегистрированный с помощью &lt;a href=&quot;#sqlite3_wal_hook&quot;&gt;sqlite3_wal_hook ()&lt;/a&gt; . Точно так же регистрация обратного вызова с помощью &lt;a href=&quot;#sqlite3_wal_hook&quot;&gt;sqlite3_wal_hook ()&lt;/a&gt; отключает механизм автоматической контрольной точки, настроенный этой функцией.</target>
        </trans-unit>
        <trans-unit id="95427739ef742c846008bdf4e9ade466f5ff0b68" translate="yes" xml:space="preserve">
          <source>The callback registered by this function replaces any existing callback registered using &lt;a href=&quot;wal_hook&quot;&gt;sqlite3_wal_hook()&lt;/a&gt;. Likewise, registering a callback using &lt;a href=&quot;wal_hook&quot;&gt;sqlite3_wal_hook()&lt;/a&gt; disables the automatic checkpoint mechanism configured by this function.</source>
          <target state="translated">Обратный вызов, зарегистрированный этой функцией, заменяет любой существующий обратный вызов, зарегистрированный с помощью &lt;a href=&quot;wal_hook&quot;&gt;sqlite3_wal_hook ()&lt;/a&gt; . Точно так же регистрация обратного вызова с помощью &lt;a href=&quot;wal_hook&quot;&gt;sqlite3_wal_hook ()&lt;/a&gt; отключает механизм автоматической контрольной точки, настроенный этой функцией.</target>
        </trans-unit>
        <trans-unit id="af79ec8f0bec910d80bc717aab639238d9ea73fe" translate="yes" xml:space="preserve">
          <source>The caller could distinguish between this special &quot;DROP TABLE|INDEX&quot; case and other cases by using &lt;a href=&quot;rescode#extrc&quot;&gt;extended error codes&lt;/a&gt;. When it is appropriate to call &lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify()&lt;/a&gt;, the extended error code is SQLITE_LOCKED_SHAREDCACHE. Otherwise, in the &quot;DROP TABLE|INDEX&quot; case, it is just plain SQLITE_LOCKED. Another solution might be to limit the number of times that any single query could be reattempted (to say 100). Although this might be less efficient than one might wish, the situation in question is not likely to occur often.</source>
          <target state="translated">Вызывающий может отличить этот специальный случай &amp;laquo;DROP TABLE | INDEX&amp;raquo; от других случаев, используя &lt;a href=&quot;rescode#extrc&quot;&gt;расширенные коды ошибок&lt;/a&gt; . Когда уместно вызвать &lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify ()&lt;/a&gt; , расширенный код ошибки - SQLITE_LOCKED_SHAREDCACHE. В противном случае в случае &quot;DROP TABLE | INDEX&quot; это просто SQLITE_LOCKED. Другим решением может быть ограничение количества повторных попыток выполнения любого отдельного запроса (скажем, 100). Хотя это может быть менее эффективным, чем можно было бы ожидать, рассматриваемая ситуация вряд ли будет возникать часто.</target>
        </trans-unit>
        <trans-unit id="b3f82dd9e0519120922fe3d796ee7df0852a43b3" translate="yes" xml:space="preserve">
          <source>The canonical FTS5 source code consists of a series of *.c and other files in the &quot;ext/fts5&quot; directory of the SQLite source tree. A build process reduces this to just two files - &quot;fts5.c&quot; and &quot;fts5.h&quot; - which may be used to build an SQLite loadable extension.</source>
          <target state="translated">Канонический исходный код FTS5 состоит из серии *.c и других файлов в директории &quot;ext/fts5&quot; исходного дерева SQLite.Процесс сборки сводится к двум файлам-&quot;fts5.c&quot; и &quot;fts5.h&quot;.-которые могут быть использованы для сборки загружаемого расширения SQLite.</target>
        </trans-unit>
        <trans-unit id="821b27603ed5a2bcfa634bb0e0d6241eee07c748" translate="yes" xml:space="preserve">
          <source>The carray() function can be used in the FROM clause of a query. For example, to query two entries from the OBJ table using rowids taken from a C-language array at address $PTR.</source>
          <target state="translated">Функция carray()может быть использована в выражении FROM запроса.Например,для запроса двух записей из OBJ-таблицы можно использовать rowids,взятые из массива на языке C по адресу $PTR.</target>
        </trans-unit>
        <trans-unit id="44fb31ec0ece772e4bff94846b749fc144432db5" translate="yes" xml:space="preserve">
          <source>The carray() function is not compiled into SQLite by default. It is available as a &lt;a href=&quot;loadext&quot;&gt;loadable extension&lt;/a&gt; in the &lt;a href=&quot;https://www.sqlite.org/src/artifact?ci=trunk&amp;amp;filename=ext/misc/carray.c&quot;&gt;ext/misc/carray.c&lt;/a&gt; source file.</source>
          <target state="translated">По умолчанию функция carray () не компилируется в SQLite. Он доступен как &lt;a href=&quot;loadext&quot;&gt;загружаемое расширение&lt;/a&gt; в исходном файле &lt;a href=&quot;https://www.sqlite.org/src/artifact?ci=trunk&amp;amp;filename=ext/misc/carray.c&quot;&gt;ext / misc / carray.c&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6e63d412e430ced0198abd5a08f3353e7c8e954f" translate="yes" xml:space="preserve">
          <source>The carray() function is not compiled into SQLite by default. It is available as a &lt;a href=&quot;loadext&quot;&gt;loadable extension&lt;/a&gt; in the &lt;a href=&quot;https://www.sqlite.org/src/file/ext/misc/carray.c&quot;&gt;ext/misc/carray.c&lt;/a&gt; source file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c196efe3bbb9fab3e53eef891a9efbbc4c9d5551" translate="yes" xml:space="preserve">
          <source>The carray() function takes one, two, or three arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="435764c5d08e172eacd91d4b4315996e3f48003b" translate="yes" xml:space="preserve">
          <source>The carray() function takes two or three arguments. The first argument is a pointer to an array. Since pointer values cannot be specified directly in SQL, the first argument must be a &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameter&lt;/a&gt; that is bound to a pointer value using the &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer()&lt;/a&gt; interface using a pointer-type of &quot;carray&quot;. The second argument is the number of elements in the array. The optional third argument is a string that determines the datatype of the elements in the C-language array. Allowed values for the third argument are:</source>
          <target state="translated">Функция carray () принимает два или три аргумента. Первый аргумент - это указатель на массив. Поскольку значения указателя не могут быть указаны непосредственно в SQL, первый аргумент должен быть &lt;a href=&quot;lang_expr#varparam&quot;&gt;параметром,&lt;/a&gt; который привязан к значению указателя с помощью интерфейса &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer ()&lt;/a&gt; с использованием типа указателя &quot;carray&quot;. Второй аргумент - это количество элементов в массиве. Необязательный третий аргумент - это строка, которая определяет тип данных элементов в массиве языка Си. Допустимые значения для третьего аргумента:</target>
        </trans-unit>
        <trans-unit id="a7781753a10aa9d55edfb4fde889d70df4714233" translate="yes" xml:space="preserve">
          <source>The carray() function was first added to SQLite in version 3.14 (2016-08-08). The sqlite3_carray_bind() interface and the single-argument variant of carray() was added in SQLite version 3.34.0 (2020-12-01).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41b5d7c612b8b2127750760016443da99495e2ab" translate="yes" xml:space="preserve">
          <source>The casual reader is not expected to understand or remember any part of the list above. The point of this list is to demonstrate that the decision of whether or not to flatten a query is complex.</source>
          <target state="translated">От случайного читателя не ожидается,что он поймет или запомнит какую-либо часть вышеприведенного списка.Смысл этого списка состоит в том,чтобы продемонстрировать,что решение о том,сгладить запрос или нет,является сложным.</target>
        </trans-unit>
        <trans-unit id="bcf344511369b084d726030fdafcea463d5dc468" translate="yes" xml:space="preserve">
          <source>The cell content area</source>
          <target state="translated">Область содержимого ячейки</target>
        </trans-unit>
        <trans-unit id="4e5d403004805e89c7f707b8add474e39df5ebd7" translate="yes" xml:space="preserve">
          <source>The cell pointer array</source>
          <target state="translated">Массив указателей ячеек</target>
        </trans-unit>
        <trans-unit id="e6c56d9636275558f42c1d09a95b01d119d13bcb" translate="yes" xml:space="preserve">
          <source>The cell pointer array of a b-tree page immediately follows the b-tree page header. Let K be the number of cells on the btree. The cell pointer array consists of K 2-byte integer offsets to the cell contents. The cell pointers are arranged in key order with left-most cell (the cell with the smallest key) first and the right-most cell (the cell with the largest key) last.</source>
          <target state="translated">Массив указателей ячеек b-деревянной страницы сразу же следует за заголовком b-деревянной страницы.Пусть K будет числом ячеек в btree.Массив указателей ячеек состоит из K 2-байтовых целочисленных смещений к содержимому ячейки.Указатели на ячейки располагаются в порядке следования ключей,самая левая (ячейка с наименьшим ключом)-первая,самая правая (ячейка с наибольшим ключом)-последняя.</target>
        </trans-unit>
        <trans-unit id="1302721086a59f9c1c80a0439335aec4ebc89654" translate="yes" xml:space="preserve">
          <source>The cell_size_check pragma enables or disables additional sanity checking on database b-tree pages as they are initially read from disk. With cell size checking enabled, database corruption is detected earlier and is less likely to &quot;spread&quot;. However, there is a small performance hit for doing the extra checks and so cell size checking is turned off by default.</source>
          <target state="translated">Прагма cells_size_check включает или отключает дополнительную проверку вменяемости на страницах b-дерева базы данных по мере того,как они изначально считываются с диска.При включенной проверке размера ячеек повреждение базы данных обнаруживается раньше и с меньшей вероятностью &quot;распространится&quot;.Однако,для выполнения дополнительных проверок есть небольшое снижение производительности,поэтому проверка размера ячеек по умолчанию отключена.</target>
        </trans-unit>
        <trans-unit id="68b13b4df554f0eca9f783dc081206c3c433b689" translate="yes" xml:space="preserve">
          <source>The cg_anno.tcl script removes extraneous details from the default cachegrind annotation output so that before-and-after reports can be compared using a side-by-side diff to view specific details of how a micro-optimization attempt affected performance.</source>
          <target state="translated">Скрипт cg_anno.tcl удаляет посторонние детали из вывода аннотаций по умолчанию cachegrind,так что до и после отчетов можно сравнить,используя бок о бок,чтобы посмотреть конкретные детали того,как попытка микро-оптимизации повлияла на производительность.</target>
        </trans-unit>
        <trans-unit id="fdc2d39d7bf4988a1e3259d80bd003ba0f7f2a24" translate="yes" xml:space="preserve">
          <source>The change is made by an SQL trigger or foreign key action instead of directly as a result of a users SQL statement.</source>
          <target state="translated">Изменение производится с помощью SQL триггера или действия постороннего ключа,а не непосредственно в результате пользовательского SQL-оператора.</target>
        </trans-unit>
        <trans-unit id="55b6de28efb13f598ab97e8c9b2ad359898d3863" translate="yes" xml:space="preserve">
          <source>The changes must consist of &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;, &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;, and &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; operations only. CREATE and DROP operations are not supported.</source>
          <target state="translated">Изменения должны состоять только из операций &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; , &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; и &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; . Операции CREATE и DROP не поддерживаются.</target>
        </trans-unit>
        <trans-unit id="204b32b2b5c56879d06b01e160a1a35686edf225" translate="yes" xml:space="preserve">
          <source>The changes to locking and concurrency control in SQLite version 3 also introduce some subtle changes in the way transactions work at the SQL language level. By default, SQLite version 3 operates in &lt;em&gt;autocommit&lt;/em&gt; mode. In autocommit mode, all changes to the database are committed as soon as all operations associated with the current database connection complete.</source>
          <target state="translated">Изменения в блокировке и управлении параллелизмом в SQLite версии 3 также вносят некоторые тонкие изменения в способ работы транзакций на уровне языка SQL. По умолчанию SQLite версии 3 работает в режиме &lt;em&gt;автоматической фиксации&lt;/em&gt; . В режиме автоматической фиксации все изменения в базе данных фиксируются, как только завершаются все операции, связанные с текущим подключением к базе данных.</target>
        </trans-unit>
        <trans-unit id="9ec4059d42e348f2d46482a218570373eadf5d72" translate="yes" xml:space="preserve">
          <source>The changes() function returns the number of database rows that were changed or inserted or deleted by the most recently completed INSERT, DELETE, or UPDATE statement, exclusive of statements in lower-level triggers. The changes() SQL function is a wrapper around the &lt;a href=&quot;c3ref/changes&quot;&gt;sqlite3_changes()&lt;/a&gt; C/C++ function and hence follows the same rules for counting changes.</source>
          <target state="translated">Функция changes () возвращает количество строк базы данных, которые были изменены, вставлены или удалены последним завершенным оператором INSERT, DELETE или UPDATE, за исключением операторов в триггерах нижнего уровня. Функция SQL changes () является оболочкой для &lt;a href=&quot;c3ref/changes&quot;&gt;функции sqlite3_changes ()&lt;/a&gt; C / C ++ и, следовательно, следует тем же правилам для подсчета изменений.</target>
        </trans-unit>
        <trans-unit id="a67c4e9392e6b6f9ae02f045b5dfeb70fe9c0330" translate="yes" xml:space="preserve">
          <source>The char(X1,X2,...,XN) function returns a string composed of characters having the unicode code point values of integers X1 through XN, respectively.</source>
          <target state="translated">Функция char(X1,X2,...,XN)возвращает строку,состоящую из символов,имеющих значения точек юникода для целых чисел от X1 до XN,соответственно.</target>
        </trans-unit>
        <trans-unit id="37f1486781d28feebc971db6315e3ab886799387" translate="yes" xml:space="preserve">
          <source>The chart below shows average time to read a blob directly from the filesystem versus the time needed to read the same blob from the SQLite database. The actual timings vary considerably from one system to another (the Ubuntu desktop is much faster than the Galaxy S3 phone, for example). This chart shows the ratio of the times needed to read blobs from a file divided by the time needed to from the database. The left-most column in the chart is the normalized time to read from the database, for reference.</source>
          <target state="translated">На графике ниже показано среднее время чтения блока непосредственно из файловой системы по сравнению со временем,необходимым для чтения того же блока из базы данных SQLite.Фактические тайминги значительно варьируются в зависимости от системы (например,рабочий стол Ubuntu намного быстрее,чем телефон Galaxy S3).Этот график показывает соотношение времени,необходимого для чтения блоков из файла,деленное на время,необходимое для чтения из базы данных.Самый левый столбец диаграммы-это нормализованное время для чтения из базы данных,для справки.</target>
        </trans-unit>
        <trans-unit id="f11b1918c906d3777fe0d3b93cddb4875a03b224" translate="yes" xml:space="preserve">
          <source>The chart below shows data collected using &lt;a href=&quot;https://www.sqlite.org/src/file/test/kvtest.c&quot;&gt;kvtest.c&lt;/a&gt; on five different systems:</source>
          <target state="translated">На диаграмме ниже показаны данные, собранные с помощью &lt;a href=&quot;https://www.sqlite.org/src/file/test/kvtest.c&quot;&gt;kvtest.c&lt;/a&gt; в пяти различных системах:</target>
        </trans-unit>
        <trans-unit id="7328593ed0585c2ca2a1685910b260ca61685e5b" translate="yes" xml:space="preserve">
          <source>The chart below shows the relative size and performance for SQLite as of 2017-10-08 for various compilers and optimization settings as tested on Ubuntu 16.04.3 on x86_64. General observations:</source>
          <target state="translated">На графике ниже показан относительный размер и производительность SQLite по состоянию на 2017-10-08 годы для различных компиляторов и настройки оптимизации,протестированные на Ubuntu 16.04.3 на x86_64.Общие замечания:</target>
        </trans-unit>
        <trans-unit id="3c6947bf2e572c7854301cde9f7c5737935d4086" translate="yes" xml:space="preserve">
          <source>The chart shows that on Windows10, content can be read from the SQLite database about 5 times faster than it can be read directly from disk. On Android, SQLite is only about 35% faster than reading from disk.</source>
          <target state="translated">На графике видно,что в Windows10 контент можно читать из базы данных SQLite примерно в 5 раз быстрее,чем непосредственно с диска.На Android,SQLite всего лишь примерно на 35% быстрее,чем чтение с диска.</target>
        </trans-unit>
        <trans-unit id="4b79be443470ce0f3ea4b17f53ee3e0a63d67172" translate="yes" xml:space="preserve">
          <source>The check-in has a &quot;trunk&quot; tag.</source>
          <target state="translated">На регистрации есть метка &quot;багажник&quot;.</target>
        </trans-unit>
        <trans-unit id="83b47a927090544c586621a60b2916e19fae4550" translate="yes" xml:space="preserve">
          <source>The check-in has a child that has a &quot;trunk&quot; tag.</source>
          <target state="translated">У зарегистрированного ребенка есть метка &quot;багажник&quot;.</target>
        </trans-unit>
        <trans-unit id="62c61bcc8ce340ae3a9c5cbdd0d35b553d2386d8" translate="yes" xml:space="preserve">
          <source>The check-in has a parent that has a &quot;trunk&quot; tag.</source>
          <target state="translated">У регистрации есть родитель,у которого есть тэг &quot;багажник&quot;.</target>
        </trans-unit>
        <trans-unit id="6dad224b0586b91e423315e1a7ef99941945ad20" translate="yes" xml:space="preserve">
          <source>The checksum VFS extension is a &lt;a href=&quot;vfs#shim&quot;&gt;VFS shim&lt;/a&gt; that adds an 8-byte checksum to the end of every page in an SQLite database. The checksum is added as each page is written and verified as each page is read. The checksum is intended to help detect database corruption caused by random bit-flips in the mass storage device.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34c12f92dcc6b984c7dc0650d9da983b05acb095" translate="yes" xml:space="preserve">
          <source>The checksum VFS extension requires SQLite version 3.32.0 (2020-05-22) or later. It will not work with earlier versions of SQLite.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0b70c1c0ff79721dae8d9a4e00e5b929e1563a7" translate="yes" xml:space="preserve">
          <source>The checksum VFS module is a &lt;a href=&quot;loadext&quot;&gt;loadable extension&lt;/a&gt;. It is not included in the &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt;. It must be added to SQLite either at compile-time or at run-time. The source code to the checksum VFS module is in the &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/cksumvfs.c&quot;&gt;ext/misc/cksumvfs.c&lt;/a&gt; source file in the &lt;a href=&quot;https://sqlite.org/src&quot;&gt;SQLite source tree&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b751a07c985fa86fe7c3c40b3bf6704b7852bcb1" translate="yes" xml:space="preserve">
          <source>The checksum algorithm only works for content which is a multiple of 8 bytes in length. In other words, if the inputs are x(0) through x(N) then N must be odd. The checksum algorithm is as follows:</source>
          <target state="translated">Алгоритм контрольной суммы работает только для контента,кратного 8 байтам в длину.Другими словами,если входы x(0)-x(N),то N должно быть нечетным.Алгоритм контрольной суммы следующий:</target>
        </trans-unit>
        <trans-unit id="9654e9833d2bad18eac61dc57f147c1ed15a761f" translate="yes" xml:space="preserve">
          <source>The checksum is an unsigned 32-bit integer computed as follows:</source>
          <target state="translated">Контрольная сумма представляет собой беззнаковое 32-битное целое число,вычисленное следующим образом:</target>
        </trans-unit>
        <trans-unit id="270f933e45ef3250cf9dcd69e18f5fd196bd90a0" translate="yes" xml:space="preserve">
          <source>The checksum is computed by interpreting the input as an even number of unsigned 32-bit integers: x(0) through x(N). The 32-bit integers are big-endian if the magic number in the first 4 bytes of the WAL header is 0x377f0683 and the integers are little-endian if the magic number is 0x377f0682. The checksum values are always stored in the frame header in a big-endian format regardless of which byte order is used to compute the checksum.</source>
          <target state="translated">Контрольная сумма вычисляется путем интерпретации входа как четное число беззнаковых 32-битных целых:x(0)-x(N).32-битные целые числа являются big-endian,если магическое число в первых 4 байтах заголовка WAL равно 0x377f0683,и целые числа являются little-endian,если магическое число равно 0x377f0682.Значения контрольных сумм всегда хранятся в заголовке кадра в big-endian формате,независимо от того,какой порядок байт используется для вычисления контрольной суммы.</target>
        </trans-unit>
        <trans-unit id="cc24b6f9af8e44f6ff2e41a4a1721f4bd21f35c7" translate="yes" xml:space="preserve">
          <source>The checksum value is used to guard against incomplete writes of a journal page record following a power failure. A different random nonce is used each time a transaction is started in order to minimize the risk that unwritten sectors might by chance contain data from the same page that was a part of prior journals. By changing the nonce for each transaction, stale data on disk will still generate an incorrect checksum and be detected with high probability. The checksum only uses a sparse sample of 32-bit words from the data record for performance reasons - design studies during the planning phases of SQLite 3.0.0 showed a significant performance hit in checksumming the entire page.</source>
          <target state="translated">Значение контрольной суммы используется для защиты от неполной записи записи страницы журнала после отключения питания.Каждый раз при запуске транзакции используется другой случайный нон-кум,чтобы минимизировать риск того,что неписаные секторы могут случайно содержать данные с той же самой страницы,которая была частью предыдущих журналов.При изменении нонсе для каждой транзакции залежавшиеся на диске данные все равно будут генерировать некорректную контрольную сумму и с высокой вероятностью будут обнаружены.Контрольная сумма использует только разреженную выборку из 32-битных слов из записи данных из соображений производительности-проектные исследования на этапе планирования SQLite 3.0.0 показали значительное падение производительности при контрольной сумме всей страницы.</target>
        </trans-unit>
        <trans-unit id="3990c0ed7263ce684acb68c345cf784357432dbe" translate="yes" xml:space="preserve">
          <source>The checksum value written to the</source>
          <target state="translated">Значение контрольной суммы,записанной на</target>
        </trans-unit>
        <trans-unit id="77ac1ab95620d7ae472b49582dcc0e306b38c020" translate="yes" xml:space="preserve">
          <source>The checksum values in the final 8 bytes of the frame-header exactly match the checksum computed consecutively on the first 24 bytes of the WAL header and the first 8 bytes and the content of all frames up to and including the current frame.</source>
          <target state="translated">Значения контрольных сумм в последних 8 байтах заголовка кадра точно совпадают с контрольной суммой,вычисленной последовательно на первых 24 байтах заголовка WAL и первых 8 байтах,а также с содержанием всех кадров вплоть до текущего кадра включительно.</target>
        </trans-unit>
        <trans-unit id="6c5140842eec97f2402faa79d3b18bc3769b3084" translate="yes" xml:space="preserve">
          <source>The child table references the primary key of the parent without specifying the primary key columns and the number of primary key columns in the parent do not match the number of child key columns.</source>
          <target state="translated">Дочерняя таблица ссылается на первичный ключ родительского без указания столбцов первичного ключа,а количество столбцов первичного ключа в родительской не совпадает с количеством столбцов дочернего ключа.</target>
        </trans-unit>
        <trans-unit id="cb680522ff952474c4763f726c9755f62f14ba34" translate="yes" xml:space="preserve">
          <source>The circumstances under which SQLite will enforce the heap limits may changes in future releases of SQLite.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da194c4576594e7457a28ceeefa6139ab020edb1" translate="yes" xml:space="preserve">
          <source>The circumstances under which SQLite will enforce the soft heap limit may changes in future releases of SQLite.</source>
          <target state="translated">Обстоятельства,при которых SQLite будет обеспечивать соблюдение лимита мягкой кучи,могут измениться в будущих выпусках SQLite.</target>
        </trans-unit>
        <trans-unit id="61459fdd1646e497264a92192cd0400ff16d21ef" translate="yes" xml:space="preserve">
          <source>The cksumvfs extension implements a new PRAGMA statement that can be used to disable, re-enable, or query the status of checksum verification:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eed6f77a1a12342f6f0e71580e9b4032c3ba5e49" translate="yes" xml:space="preserve">
          <source>The claim of the previous paragraph is extensively checked in the SQLite regression test suite using a special test harness that simulates the effects on a database file of operating system crashes and power failures.</source>
          <target state="translated">Утверждение,содержащееся в предыдущем пункте,подробно проверяется в наборе регрессионных тестов SQLite с использованием специального тестового жгута,который моделирует воздействие на файл базы данных сбоев операционной системы и перебоев в электропитании.</target>
        </trans-unit>
        <trans-unit id="ce6585a17c4368c809080175136a8937ad00861b" translate="yes" xml:space="preserve">
          <source>The coalesce() function returns a copy of its first non-NULL argument, or NULL if all arguments are NULL. Coalesce() must have at least 2 arguments.</source>
          <target state="translated">Функция Coalesce()возвращает копию своего первого не NULL аргумента,или NULL,если все аргументы NULL.Функция Coalesce()должна иметь как минимум 2 аргумента.</target>
        </trans-unit>
        <trans-unit id="f7c2331fa2d3327c8c4beede4ed0b6e31a651048" translate="yes" xml:space="preserve">
          <source>The code above is for the general case. For the special case of an SQLite Archive that only stores uncompressed or uncompressible content (this might come up, for example, in an SQLite Archive that stores only JPEG, GIF, and/or PNG images) then the content can be inserted into and extracted from the database without using the sqlar_compress() and sqlar_uncompress() functions, and the sqlar.c extension is not required.</source>
          <target state="translated">Код выше для общего случая.Для специального случая SQLite Archive,в котором хранится только несжатое или несжимаемое содержимое (это может появиться,например,в SQLite Archive,в котором хранятся только изображения в формате JPEG,GIF и/или PNG),содержимое может быть вставлено и извлечено из базы данных без использования функций sqlar_compress()и sqlar_uncompress(),при этом расширение sqlar.c не является обязательным.</target>
        </trans-unit>
        <trans-unit id="4eb7b1d4fed609f9eafac0ed3cfa712e4a84c44c" translate="yes" xml:space="preserve">
          <source>The code appears stable so we are now calling it &quot;beta&quot;.</source>
          <target state="translated">Код выглядит стабильным,поэтому сейчас мы называем его &quot;бета&quot;.</target>
        </trans-unit>
        <trans-unit id="4dcec88beb123f0b5fcd5b586036ea0a356cf753" translate="yes" xml:space="preserve">
          <source>The code audits used to ensure that memory allocation size computations do not overflow in SQLite are repeated prior to every SQLite release.</source>
          <target state="translated">Аудиты кода,используемые для того,чтобы убедиться,что вычисления объема выделения памяти не переполняются в SQLite,повторяются перед каждым выпуском SQLite.</target>
        </trans-unit>
        <trans-unit id="b0a804ee343680af0bae1b47adaea7bd27c01026" translate="yes" xml:space="preserve">
          <source>The code for the swarmvtab virtual table is found in the ext/misc/unionvtab.c file of the main SQLite source tree. It may be compiled into an SQLite &lt;a href=&quot;loadext&quot;&gt;loadable extension&lt;/a&gt; using a command like:</source>
          <target state="translated">Код виртуальной таблицы swarmvtab находится в файле ext / misc / unionvtab.c основного дерева исходных текстов SQLite. Его можно скомпилировать в &lt;a href=&quot;loadext&quot;&gt;загружаемое расширение&lt;/a&gt; SQLite с помощью такой команды:</target>
        </trans-unit>
        <trans-unit id="429be1d142052bd4928f94110562bdb201e97a74" translate="yes" xml:space="preserve">
          <source>The code for the zipfile module is found in the &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/zipfile.c&quot;&gt;ext/misc/zipfile.c&lt;/a&gt; file of the &lt;a href=&quot;https://sqlite.org/src&quot;&gt;main SQLite source tree&lt;/a&gt;. It may be compiled into an SQLite &lt;a href=&quot;loadext&quot;&gt;loadable extension&lt;/a&gt; using a command like:</source>
          <target state="translated">Код для модуля zipfile находится в файле &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/zipfile.c&quot;&gt;ext / misc / zipfile.c &lt;/a&gt;&lt;a href=&quot;https://sqlite.org/src&quot;&gt;основного дерева исходных &lt;/a&gt;текстов SQLite . Его можно скомпилировать в &lt;a href=&quot;loadext&quot;&gt;загружаемое расширение&lt;/a&gt; SQLite с помощью такой команды:</target>
        </trans-unit>
        <trans-unit id="e9f5bceb13445c13d968dff10e26983b65675c68" translate="yes" xml:space="preserve">
          <source>The code generated in this last example is the same as the previous except for the addition of two conditional jumps used to implement the extra WHERE and HAVING clauses. The WHERE clause is implemented by instructions 9 through 11 in the query loop. The HAVING clause is implemented by instruction 28 through 30 in the output loop.</source>
          <target state="translated">Код,сгенерированный в этом последнем примере,тот же самый,что и в предыдущем,за исключением добавления двух условных переходов,используемых для реализации дополнительных пунктов WHERE и HAVING.В цикле запросов выражение WHERE реализовано командами с 9 по 11.В выходном цикле выражение HAVING реализуется командами с 28 по 30.</target>
        </trans-unit>
        <trans-unit id="ecc7e2ea5797377ee55e53ff370e71d0a0432eb1" translate="yes" xml:space="preserve">
          <source>The code generated to implement this last query is as follows:</source>
          <target state="translated">Ниже приведен код,сгенерированный для реализации этого последнего запроса:</target>
        </trans-unit>
        <trans-unit id="26011ad1079cb8255e24204fff9114945ad7804b" translate="yes" xml:space="preserve">
          <source>The code generator in SQLite processes compound SELECT statements using a recursive algorithm. In order to limit the size of the stack, we therefore limit the number of terms in a compound SELECT. The maximum number of terms is SQLITE_MAX_COMPOUND_SELECT which defaults to 500. We think this is a generous allotment since in practice we almost never see the number of terms in a compound select exceed single digits.</source>
          <target state="translated">Генератор кода в SQLite обрабатывает сложные операторы SELECT,используя рекурсивный алгоритм.Для того,чтобы ограничить размер стека,мы ограничиваем количество терминов в составном SELECT.Максимальное количество терминов-SQLITE_MAX_COMPOUND_SELECT,которое по умолчанию равно 500.Мы считаем это щедрым распределением,так как на практике мы почти никогда не видим,чтобы количество членов в составном отборе превышало одиночные цифры.</target>
        </trans-unit>
        <trans-unit id="0a5ca134725357f1db49cf5e9aed85ae431b52f8" translate="yes" xml:space="preserve">
          <source>The code generator, and especially the logic in &lt;b&gt;where*.c&lt;/b&gt; and in &lt;a href=&quot;https://sqlite.org/src/file/src/select.c&quot;&gt;select.c&lt;/a&gt;, is sometimes called the &lt;a href=&quot;optoverview&quot;&gt;query planner&lt;/a&gt;. For any particular SQL statement, there might be hundreds, thousands, or millions of different algorithms to compute the answer. The query planner is an AI that strives to select the best algorithm from these millions of choices.</source>
          <target state="translated">Генератор кода, и особенно логику в &lt;a href=&quot;https://sqlite.org/src/file/src/select.c&quot;&gt;файлах &lt;/a&gt;&lt;b&gt;where * .c&lt;/b&gt; и select.c , иногда называют &lt;a href=&quot;optoverview&quot;&gt;планировщиком запросов&lt;/a&gt; . Для любого конкретного оператора SQL могут быть сотни, тысячи или миллионы различных алгоритмов вычисления ответа. Планировщик запросов - это ИИ, который стремится выбрать лучший алгоритм из этого миллиона вариантов.</target>
        </trans-unit>
        <trans-unit id="25e3614fe3c2a2058c86f93c8b850392e16eae8c" translate="yes" xml:space="preserve">
          <source>The code in &quot;fts5.c&quot; may then be compiled into a loadable extension or statically linked into an application as described in &lt;a href=&quot;loadext#build&quot;&gt;Compiling Loadable Extensions&lt;/a&gt;. There are two entry points defined, both of which do the same thing:</source>
          <target state="translated">Код в &quot;fts5.c&quot; затем может быть скомпилирован в загружаемое расширение или статически связан с приложением, как описано в &lt;a href=&quot;loadext#build&quot;&gt;разделе &quot;Компиляция загружаемых расширений&quot;&lt;/a&gt; . Определены две точки входа, каждая из которых выполняет одно и то же:</target>
        </trans-unit>
        <trans-unit id="c15d2613b82ac42eff7d51f6a4257bfde77f5feb" translate="yes" xml:space="preserve">
          <source>The code in this article could be improved in at least two ways:</source>
          <target state="translated">Код в этой статье можно было бы улучшить как минимум двумя способами:</target>
        </trans-unit>
        <trans-unit id="81d14a407fed1c180dec58abfdf7e1bfd2ff10aa" translate="yes" xml:space="preserve">
          <source>The code space used by the SQLite library depends on the target platform, the compiler, and optimization settings. These variables also affect performance.</source>
          <target state="translated">Пространство кода,используемое библиотекой SQLite,зависит от целевой платформы,компилятора и настроек оптимизации.Эти переменные также влияют на производительность.</target>
        </trans-unit>
        <trans-unit id="5c4a1121bef63849753648d7ec67f82ac551ebbe" translate="yes" xml:space="preserve">
          <source>The colUsed field indicates which columns of the virtual table may be required by the current scan. Virtual table columns are numbered from zero in the order in which they appear within the CREATE TABLE statement passed to sqlite3_declare_vtab(). For the first 63 columns (columns 0-62), the corresponding bit is set within the colUsed mask if the column may be required by SQLite. If the table has at least 64 columns and any column to the right of the first 63 is required, then bit 63 of colUsed is also set. In other words, column iCol may be required if the expression (colUsed &amp;amp; ((sqlite3_uint64)1 &amp;lt;&amp;lt; (iCol&amp;gt;=63 ? 63 : iCol))) evaluates to non-zero.</source>
          <target state="translated">Поле colUsed указывает, какие столбцы виртуальной таблицы могут потребоваться для текущего сканирования. Столбцы виртуальной таблицы нумеруются с нуля в том порядке, в котором они появляются в операторе CREATE TABLE, переданном в sqlite3_declare_vtab (). Для первых 63 столбцов (столбцы 0-62) соответствующий бит устанавливается в маске colUsed, если столбец может потребоваться SQLite. Если таблица имеет не менее 64 столбцов и требуется любой столбец справа от первых 63, то также устанавливается бит 63 столбца colUsed. Другими словами, столбец iCol может потребоваться, если выражение (colUsed &amp;amp; ((sqlite3_uint64) 1 &amp;lt;&amp;lt; (iCol&amp;gt; = 63? 63: iCol))) оценивается как ненулевое.</target>
        </trans-unit>
        <trans-unit id="cd6add92b1a269fd1ee22788d7c2c68cbcfa3387" translate="yes" xml:space="preserve">
          <source>The collating function callback is invoked with a copy of the pArg application data pointer and with two strings in the encoding specified by the eTextRep argument. The collating function must return an integer that is negative, zero, or positive if the first string is less than, equal to, or greater than the second, respectively. A collating function must always return the same answer given the same inputs. If two or more collating functions are registered to the same collation name (using different eTextRep values) then all must give an equivalent answer when invoked with equivalent strings. The collating function must obey the following properties for all strings A, B, and C:</source>
          <target state="translated">Обратный вызов коллекционной функции вызывается с копией указателя на данные приложения pArg и двумя строками в кодировке,заданной аргументом eTextRep.Функция collating должна возвращать целое число,которое является отрицательным,нулевым или положительным,если первая строка меньше,равна или больше второй соответственно.Коллатирующая функция должна всегда возвращать один и тот же ответ при одних и тех же входах.Если две или более функций объединения зарегистрированы под одним и тем же именем (с использованием разных значений eTextRep),то при вызове с эквивалентными строками все они должны дать эквивалентный ответ.Функция сопоставления должна подчиняться следующим свойствам для всех строк A,B и C:</target>
        </trans-unit>
        <trans-unit id="0a8a7f3b3c83ac2e3d1763414e674a2e2ca29ee7" translate="yes" xml:space="preserve">
          <source>The collating function callback is invoked with a copy of the pArg application data pointer and with two strings in the encoding specified by the eTextRep argument. The two integer parameters to the collating function callback are the length of the two strings, in bytes. The collating function must return an integer that is negative, zero, or positive if the first string is less than, equal to, or greater than the second, respectively. A collating function must always return the same answer given the same inputs. If two or more collating functions are registered to the same collation name (using different eTextRep values) then all must give an equivalent answer when invoked with equivalent strings. The collating function must obey the following properties for all strings A, B, and C:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65d2bfaa5988de22a32b291f24dfa00da4fc2f70" translate="yes" xml:space="preserve">
          <source>The column is identified by the second, third and fourth parameters to this function. The second parameter is either the name of the database (i.e. &quot;main&quot;, &quot;temp&quot;, or an attached database) containing the specified table or NULL. If it is NULL, then all attached databases are searched for the table using the same algorithm used by the database engine to resolve unqualified table references.</source>
          <target state="translated">Колонка идентифицируется по второму,третьему и четвертому параметрам этой функции.Вторым параметром является либо название БД (т.е.&quot;основная&quot;,&quot;временная&quot; или прикрепленная БД),содержащая указанную таблицу,либо NULL.Если это NULL,то все подключенные БД ищут таблицу по тому же алгоритму,который используется движком БД для разрешения неквалифицированных ссылок на таблицы.</target>
        </trans-unit>
        <trans-unit id="7829593889659cca230ab3239645af748546a7d0" translate="yes" xml:space="preserve">
          <source>The column labels that appear on the first two lines of output can be turned on and off using the &quot;.header&quot; dot command. In the examples above, the column labels are on. To turn them off you could do this:</source>
          <target state="translated">Метки столбцов,которые появляются в первых двух строках вывода,могут быть включены и выключены командой &quot;.header&quot; dot.В приведенных выше примерах метки столбцов включены.Для их выключения можно сделать это:</target>
        </trans-unit>
        <trans-unit id="9b37c354a4343966405cb0363479fdc771c7551d" translate="yes" xml:space="preserve">
          <source>The column may not be &lt;a href=&quot;gencol&quot;&gt;GENERATED ALWAYS ... STORED&lt;/a&gt;, though VIRTUAL columns are allowed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71d2d7e1bd431710201b6152bbbf86fa85eac1e5" translate="yes" xml:space="preserve">
          <source>The column may not have a PRIMARY KEY or UNIQUE constraint.</source>
          <target state="translated">Столбец может не иметь ограничения PRIMARY KEY или UNIQUE.</target>
        </trans-unit>
        <trans-unit id="99d848b798067eee9317efc709f08dee3a25b0a8" translate="yes" xml:space="preserve">
          <source>The column may not have a default value of CURRENT_TIME, CURRENT_DATE, CURRENT_TIMESTAMP, or an expression in parentheses.</source>
          <target state="translated">Столбец может не иметь значения по умолчанию CURRENT_TIME,CURRENT_DATE,CURRENT_TIMESTAMP или выражения в круглых скобках.</target>
        </trans-unit>
        <trans-unit id="adb879e73b7d88dc161320c793668864d27ae4e6" translate="yes" xml:space="preserve">
          <source>The column names and definitions for</source>
          <target state="translated">Названия колонок и определения для</target>
        </trans-unit>
        <trans-unit id="b16cccd51ed940f2dd9c18cb3d4d9b130c9ecd9e" translate="yes" xml:space="preserve">
          <source>The column names for the result sets of &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statements have been tweaked in some cases to work more like other SQL database engines.</source>
          <target state="translated">Имена столбцов для наборов результатов &lt;a href=&quot;lang_select&quot;&gt;операторов SELECT&lt;/a&gt; в некоторых случаях были изменены, чтобы они работали как другие механизмы баз данных SQL.</target>
        </trans-unit>
        <trans-unit id="239fe7786e783e697b78c9df7c06b9daecb4d9f7" translate="yes" xml:space="preserve">
          <source>The column names of the virtual table are determined primarily by the &lt;b&gt;schema=&lt;/b&gt; argument. If the &lt;b&gt;schema=&lt;/b&gt; argument is omitted, but &lt;b&gt;header&lt;/b&gt; is true, then the values found in the first line of the CSV file become the column names. If the &lt;b&gt;schema=&lt;/b&gt; argument is omitted and &lt;b&gt;header&lt;/b&gt; is false, then the columns are named &quot;c0&quot;, &quot;c1&quot;, &quot;c2&quot;, and so forth.</source>
          <target state="translated">Имена столбцов виртуальной таблицы определяются главным образом аргументом &lt;b&gt;schema =&lt;/b&gt; . Если аргумент &lt;b&gt;schema =&lt;/b&gt; опущен, но &lt;b&gt;заголовок&lt;/b&gt; верен, тогда значения, найденные в первой строке файла CSV, становятся именами столбцов. Если аргумент &lt;b&gt;schema =&lt;/b&gt; опущен и &lt;b&gt;заголовок&lt;/b&gt; имеет значение false, тогда столбцам будут присвоены имена &amp;laquo;c0&amp;raquo;, &amp;laquo;c1&amp;raquo;, &amp;laquo;c2&amp;raquo; и т. Д.</target>
        </trans-unit>
        <trans-unit id="27cc219896194f2cbf6cb1853331dc30b6f1a32f" translate="yes" xml:space="preserve">
          <source>The column names reported by join subqueries have been modified slightly in order to work more like other database engines. Consider the following query:</source>
          <target state="translated">Имена столбцов,сообщаемые в подзапросах на присоединение,были слегка изменены,чтобы работать как другие движки базы данных.Рассмотрим следующий запрос:</target>
        </trans-unit>
        <trans-unit id="cf988c97f1d408bf1402feb7e21744609abdb492" translate="yes" xml:space="preserve">
          <source>The column number (1 for the second leftmost column, etc.). This field is omitted for any term-offset list associated with column 0.</source>
          <target state="translated">Номер столбца (1 для второго левого столбца и т.д.).Данное поле опускается для любого списка смещений сроков,связанных со столбцом 0.</target>
        </trans-unit>
        <trans-unit id="0d64ee03e40c54227cba3f5e9c70df99b5d87845" translate="yes" xml:space="preserve">
          <source>The column number that the term instance occurs in (0 for the leftmost column of the FTS table, 1 for the next leftmost, etc.).</source>
          <target state="translated">Номер столбца,в котором встречается экземпляр термина (0 для самого левого столбца таблицы FTS,1 для следующего самого левого и т.д.).</target>
        </trans-unit>
        <trans-unit id="0e0d4c37f8f415ca48f1578c5fbfec2c6eeee2e7" translate="yes" xml:space="preserve">
          <source>The column-name list syntax was added in SQLite versions 3.9.0 (2015-10-14).</source>
          <target state="translated">Синтаксис списка имен столбцов был добавлен в версии SQLite 3.9.0 (2015-10-14).</target>
        </trans-unit>
        <trans-unit id="74b05d9163657d39d9cb9b3d5f80884cae70cb2c" translate="yes" xml:space="preserve">
          <source>The columns are provided by the SQLITE_STMT virtual table are summarized by the hypothetical CREATE TABLE statement show here:</source>
          <target state="translated">Столбцы,предоставляемые виртуальной таблицей SQLITE_STMT,суммируются гипотетическим оператором CREATE TABLE,показанным здесь:</target>
        </trans-unit>
        <trans-unit id="99fc02c8d425b8c14b21527882dd349490360fd6" translate="yes" xml:space="preserve">
          <source>The columns referenced in the WHERE clause of a partial index can be any of the columns in the table, not just columns that happen to be indexed. However, it is very common for the WHERE clause expression of a partial index to be a simple expression on the column being indexed. The following is a typical example:</source>
          <target state="translated">Столбцы,на которые делается ссылка в пункте &quot;ГДЕ&quot; частичного индекса,могут быть любыми из столбцов таблицы,а не только столбцами,которые случайно индексируются.Однако очень часто выражение в пункте &quot;ГДЕ&quot; частичного индекса является простым выражением в индексируемом столбце.Ниже приведен типичный пример:</target>
        </trans-unit>
        <trans-unit id="c36ceb732928b62fa9f17cf0516fa8ff6f38d20c" translate="yes" xml:space="preserve">
          <source>The command above created the new branch. But your checkout is still on the trunk - a fact you can see by running the command:</source>
          <target state="translated">Команда,приведенная выше,создала новую ветку.Но ваша проверка всё ещё находится в стволе-факт,который вы можете увидеть,выполнив эту команду:</target>
        </trans-unit>
        <trans-unit id="39e91ef2d072dfac6ebe4c80889ed64220c2f4b1" translate="yes" xml:space="preserve">
          <source>The command above will make a copy of the complete development history of SQLite into the &quot;sqlite.fossil&quot; file on your computer. Making this copy takes about a minute and uses about 32 megabytes of transfer. After making the copy, &quot;open&quot; the repository by typing:</source>
          <target state="translated">Вышеуказанная команда сделает копию полной истории разработки SQLite в файл &quot;sqlite.fossil&quot; на вашем компьютере.Создание этой копии занимает около минуты и использует около 32 мегабайт передачи.После создания копии &quot;откройте&quot; хранилище,набрав соответствующую строку:</target>
        </trans-unit>
        <trans-unit id="4b3dc1d8af5139eaa56167ba29f9c2c18e9d510c" translate="yes" xml:space="preserve">
          <source>The command above writes the output of the query as CSV into a temporary file, invokes the default handler for CSV files (usually the preferred spreadsheet program such as Excel or LibreOffice), then deletes the temporary file. This is essentially a short-hand method of doing the sequence of &quot;.csv&quot;, &quot;.once&quot;, and &quot;.system&quot; commands described above.</source>
          <target state="translated">Команда выше записывает вывод запроса в виде CSV во временный файл,вызывает обработчик по умолчанию для CSV-файлов (обычно это предпочтительная программа для работы с таблицами,например,Excel или LibreOffice),затем удаляет временный файл.По сути,это краткосрочный метод выполнения последовательности команд &quot;.csv&quot;,&quot;.once&quot; и &quot;.system&quot;,описанный выше.</target>
        </trans-unit>
        <trans-unit id="b075c13635ba5e790ee4582ea35e32db5040da00" translate="yes" xml:space="preserve">
          <source>The command returns a new TCL channel for reading or writing to the BLOB. The channel is opened using the underlying &lt;a href=&quot;c3ref/blob_open&quot;&gt;sqlite3_blob_open()&lt;/a&gt; C-language interface. Close the channel using the &lt;b&gt;close&lt;/b&gt; command of TCL.</source>
          <target state="translated">Команда возвращает новый канал TCL для чтения или записи в BLOB. Канал открывается с помощью базового интерфейса &lt;a href=&quot;c3ref/blob_open&quot;&gt;sqlite3_blob_open () на языке&lt;/a&gt; C. Закройте канал, используя команду &lt;b&gt;закрытия&lt;/b&gt; TCL.</target>
        </trans-unit>
        <trans-unit id="988274d0addcbb9018970d10733f7b4052f070a2" translate="yes" xml:space="preserve">
          <source>The command-line shell adds two &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt; that facilitate reading content from a file into a table column, and writing the content of a column into a file, respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a64c0d6110f60679f08571c4a254a77214045a1" translate="yes" xml:space="preserve">
          <source>The command-line shell adds two &lt;a href=&quot;c3ref/create_function&quot;&gt;application-defined SQL functions&lt;/a&gt; that facilitate reading content from a file into a table column, and writing the content of a column into a file, respectively.</source>
          <target state="translated">Оболочка командной строки добавляет две &lt;a href=&quot;c3ref/create_function&quot;&gt;определяемые приложением функции SQL,&lt;/a&gt; которые облегчают чтение содержимого из файла в столбец таблицы и запись содержимого столбца в файл соответственно.</target>
        </trans-unit>
        <trans-unit id="5a15969d303479025517006f69c3c3e87572075f" translate="yes" xml:space="preserve">
          <source>The command-line shell uses the &lt;a href=&quot;zipfile&quot;&gt;Zipfile virtual table&lt;/a&gt; to access ZIP archives. You can see this by running the &quot;.schema&quot; command when a ZIP archive is open:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d792fd30ad98774099bd3871331d49c13f01ab7" translate="yes" xml:space="preserve">
          <source>The commit and rollback hook callbacks are not reentrant. The callback implementation must not do anything that will modify the database connection that invoked the callback. Any actions to modify the database connection must be deferred until after the completion of the &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; call that triggered the commit or rollback hook in the first place. Note that running any other SQL statements, including SELECT statements, or merely calling &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; will modify the database connections for the meaning of &quot;modify&quot; in this paragraph.</source>
          <target state="translated">Обратные вызовы обработчиков фиксации и отката не реентерабельны. Реализация обратного вызова не должна делать ничего, что могло бы изменить соединение с базой данных, вызвавшее обратный вызов. Любые действия по изменению подключения к базе данных должны быть отложены до завершения вызова &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step (),&lt;/a&gt; который в первую очередь инициировал фиксацию или откат. Обратите внимание, что выполнение любых других операторов SQL, включая операторы SELECT, или простой вызов &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; и &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step ()&lt;/a&gt; изменит соединения с базой данных для значения слова &amp;laquo;изменить&amp;raquo; в этом абзаце.</target>
        </trans-unit>
        <trans-unit id="837a3144fbcca3d5f0e20f9cd17c26bc03114566" translate="yes" xml:space="preserve">
          <source>The commit and rollback hook callbacks are not reentrant. The callback implementation must not do anything that will modify the database connection that invoked the callback. Any actions to modify the database connection must be deferred until after the completion of the &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; call that triggered the commit or rollback hook in the first place. Note that running any other SQL statements, including SELECT statements, or merely calling &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; and &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; will modify the database connections for the meaning of &quot;modify&quot; in this paragraph.</source>
          <target state="translated">Обратные вызовы обработчиков фиксации и отката не реентерабельны. Реализация обратного вызова не должна делать ничего, что могло бы изменить соединение с базой данных, вызвавшее обратный вызов. Любые действия по изменению подключения к базе данных должны быть отложены до завершения вызова &lt;a href=&quot;step&quot;&gt;sqlite3_step (),&lt;/a&gt; который в первую очередь инициировал фиксацию или откат. Обратите внимание, что выполнение любых других операторов SQL, включая операторы SELECT, или простой вызов &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; и &lt;a href=&quot;step&quot;&gt;sqlite3_step ()&lt;/a&gt; изменит соединения с базой данных для значения слова &amp;laquo;изменить&amp;raquo; в этом абзаце.</target>
        </trans-unit>
        <trans-unit id="5854e2359472df03b69e7808b8ee34022d4a6816" translate="yes" xml:space="preserve">
          <source>The commit process shown in &lt;a href=&quot;#section_3_0&quot;&gt;section 3.0&lt;/a&gt; assumes that all database changes fit in memory until it is time to commit. This is the common case. But sometimes a larger change will overflow the user-space cache prior to transaction commit. In those cases, the cache must spill to the database before the transaction is complete.</source>
          <target state="translated">Процесс фиксации, показанный в &lt;a href=&quot;#section_3_0&quot;&gt;разделе 3.0,&lt;/a&gt; предполагает, что все изменения базы данных умещаются в памяти, пока не наступит время фиксации. Это обычный случай. Но иногда более крупное изменение приводит к переполнению кеша пользовательского пространства до фиксации транзакции. В таких случаях кэш должен попасть в базу данных до завершения транзакции.</target>
        </trans-unit>
        <trans-unit id="831de8c9305e21ddee6326436c38620139c51d57" translate="yes" xml:space="preserve">
          <source>The common table expression works without having to load an extension. On the other hand, the extension is easier to program and faster.</source>
          <target state="translated">Общее табличное выражение работает без необходимости загрузки расширения.С другой стороны,расширение проще и быстрее программируется.</target>
        </trans-unit>
        <trans-unit id="975322957294bcdde1991bc8533b4c3c42c34fe5" translate="yes" xml:space="preserve">
          <source>The comparison is a sort comparison, so NULLs compare equal, NULLs are less than numbers, numbers are less than strings, and strings are less than blobs.</source>
          <target state="translated">Сравнение представляет собой сортировочное сравнение,поэтому NULLs сравнивают равными,NULLs меньше чем числа,числа меньше чем строки,и строки меньше чем капли.</target>
        </trans-unit>
        <trans-unit id="77fdffaa220770108e157d8f6fdf86e8984310f3" translate="yes" xml:space="preserve">
          <source>The compilation step shown immediately above is merely representative. In a working installation, one would normally want to specify optimization parameters and compile-time switches on the compiler command line.</source>
          <target state="translated">Представленный выше этап компиляции является лишь репрезентативным.В рабочей установке обычно требуется указать параметры оптимизации и ключи времени компиляции в командной строке компилятора.</target>
        </trans-unit>
        <trans-unit id="06859965a5874b48e17ef99de2638103b952d1aa" translate="yes" xml:space="preserve">
          <source>The compile-time options for setting upper bounds are &lt;a href=&quot;limits&quot;&gt;documented separately&lt;/a&gt;. The following is a list of the available settings:</source>
          <target state="translated">Параметры времени компиляции для установки верхних границ &lt;a href=&quot;limits&quot;&gt;документируются отдельно&lt;/a&gt; . Ниже приводится список доступных настроек:</target>
        </trans-unit>
        <trans-unit id="d37610227543b6269c9a6c07ddb9c1381df5a58a" translate="yes" xml:space="preserve">
          <source>The complete state of an SQLite database is usually contained in a single file on disk called the &quot;main database file&quot;.</source>
          <target state="translated">Полное состояние базы данных SQLite обычно содержится в одном файле на диске,называемом &quot;основным файлом базы данных&quot;.</target>
        </trans-unit>
        <trans-unit id="96bf44cd55dc348e4e3f4d568f7843d225f7562d" translate="yes" xml:space="preserve">
          <source>The completion table is designed for interactive use. It will return answers at a speed appropriate for human typing. No effort is made to be unusually efficient, so long as the response time is nearly instantaneous in a user interface.</source>
          <target state="translated">Завершающая таблица предназначена для интерактивного использования.Она будет возвращать ответы со скоростью,подходящей для набора текста человеком.При этом не прилагается никаких усилий для того,чтобы быть необычайно эффективным,при условии,что время ответа практически мгновенно отображается в пользовательском интерфейсе.</target>
        </trans-unit>
        <trans-unit id="d59eec775be7e50d6274c344c801f729c91ab804" translate="yes" xml:space="preserve">
          <source>The completion table is used to implement tab-completion in the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; in conjunction with either the readline or linenoise input line editing packages for unix. See the &lt;a href=&quot;https://sqlite.org/src/file/src/shell.c.in&quot;&gt;https://sqlite.org/src/file/src/shell.c.in&lt;/a&gt; source file for example code. Search for &quot;FROM completion&quot; to find the relevant code sections.</source>
          <target state="translated">Таблица завершения используется для реализации автозавершения табуляции в &lt;a href=&quot;cli&quot;&gt;оболочке командной строки&lt;/a&gt; в сочетании с пакетами редактирования строки ввода readline или Linenoise для unix. Смотрите &lt;a href=&quot;https://sqlite.org/src/file/src/shell.c.in&quot;&gt;https://sqlite.org/src/file/src/shell.c.in&lt;/a&gt; исходный файл для примера кода. Выполните поиск по запросу &amp;laquo;ОТ завершения&amp;raquo;, чтобы найти соответствующие разделы кода.</target>
        </trans-unit>
        <trans-unit id="e034c5722458a4ef5f557863bb00dfc415febe07" translate="yes" xml:space="preserve">
          <source>The completion table might return the same candidate more than once, and it will return candidates in an arbitrary order. The DISTINCT keyword and the ORDER BY in the sample query above are added to make the answers unique and in lexicographical order.</source>
          <target state="translated">Таблица завершения работы может возвращать одного и того же кандидата не один раз,и в ней кандидаты будут возвращаться в произвольном порядке.Ключевое слово &quot;DISTINCT&quot; и &quot;ORDER BY&quot; в приведенном выше примере запроса добавляются для того,чтобы сделать ответы уникальными и в лексикографическом порядке.</target>
        </trans-unit>
        <trans-unit id="7bf1657f4892b438bb6c981746dfe40cd870c0fa" translate="yes" xml:space="preserve">
          <source>The complexity of Git distracts attention from the software under development. A user of Git needs to keep all of the following in mind:</source>
          <target state="translated">Сложность Git'а отвлекает внимание от разрабатываемого программного обеспечения.Пользователь Git'а должен помнить обо всём следующем:</target>
        </trans-unit>
        <trans-unit id="15376f7aadf15df031fa31738229dcbaf3f18c9d" translate="yes" xml:space="preserve">
          <source>The compound SELECT operators UNION, INTERSECT and EXCEPT perform implicit comparisons between values. No affinity is applied to comparison operands for the implicit comparisons associated with UNION, INTERSECT, or EXCEPT - the values are compared as is.</source>
          <target state="translated">Комбинированные операторы SELECT UNION,INTERSECT и EXCEPT выполняют неявное сравнение значений.К операндам сравнения для неявных сравнений,связанных с UNION,INTERSECT или EXCEPT,не применяется никакого сродства-значения сравниваются как есть.</target>
        </trans-unit>
        <trans-unit id="dc11a925c84e89a2d79f62896a81bbc87b31205f" translate="yes" xml:space="preserve">
          <source>The compress and uncompress options allow FTS4 content to be stored in the database in a compressed form. Both options should be set to the name of an SQL scalar function registered using &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt; that accepts a single argument.</source>
          <target state="translated">Параметры сжатия и распаковки позволяют сохранять содержимое FTS4 в базе данных в сжатом виде. Обе опции должны быть установлены на имя скалярной функции SQL, зарегистрированной с помощью &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function (),&lt;/a&gt; которая принимает единственный аргумент.</target>
        </trans-unit>
        <trans-unit id="8f77d8f289ab8ab189cc2f583f00d06f6f32d94d" translate="yes" xml:space="preserve">
          <source>The compress function should return a compressed version of the value passed to it as an argument. Each time data is written to the FTS4 table, each column value is passed to the compress function and the result value stored in the database. The compress function may return any type of SQLite value (blob, text, real, integer or null).</source>
          <target state="translated">Функция компрессии должна возвращать сжатую версию значения,переданного ей в качестве аргумента.Каждый раз,когда данные записываются в таблицу FTS4,значение каждого столбца передается в функцию компрессии,а значение результата сохраняется в базе данных.Функция компрессии может возвращать любое значение SQLite (блочное,текстовое,вещественное,целое или нулевое).</target>
        </trans-unit>
        <trans-unit id="290b0a4fd26e950183bc56ef03571b78a9f077cd" translate="yes" xml:space="preserve">
          <source>The compress option is used to specify the compress function. It is an error to specify a compress function without also specifying an uncompress function. &lt;a href=&quot;fts3#the_compress_and_uncompress_options&quot;&gt;See below&lt;/a&gt; for details.</source>
          <target state="translated">Параметр сжатия используется для указания функции сжатия. Ошибочно указывать функцию сжатия без указания функции распаковки. &lt;a href=&quot;fts3#the_compress_and_uncompress_options&quot;&gt;Подробнее см. Ниже&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5836c13f879c56ed967a4394bb1d7a4816e02cd2" translate="yes" xml:space="preserve">
          <source>The compress=, uncompress= and languageid= options are not available. There is as of yet no equivalent for their functionality.</source>
          <target state="translated">Опции compress=,uncompress=и languageid=недоступны.Пока нет эквивалента их функциональности.</target>
        </trans-unit>
        <trans-unit id="2469db0ecb30ed655de4891189661dea5b883567" translate="yes" xml:space="preserve">
          <source>The compression method used to compress the data (an integer). The value 0 indicates that the data is stored in the zip archive without compression. 8 means the raw deflate algorithm.</source>
          <target state="translated">Метод сжатия,используемый для сжатия данных (целое число).Значение 0 означает,что данные хранятся в zip-архиве без сжатия.8 означает необработанный алгоритм сдувания.</target>
        </trans-unit>
        <trans-unit id="c682ba9f6178606617e01c8b48358fa9163f9c2c" translate="yes" xml:space="preserve">
          <source>The computation of local time depends heavily on the whim of politicians and is thus difficult to get correct for all locales. In this implementation, the standard C library function localtime_r() is used to assist in the calculation of local time. The localtime_r() C function normally only works for years between 1970 and 2037. For dates outside this range, SQLite attempts to map the year into an equivalent year within this range, do the calculation, then map the year back.</source>
          <target state="translated">Расчет местного времени в значительной степени зависит от прихоти политиков и поэтому его трудно скорректировать для всех местностей.В этой реализации для помощи в вычислении локального времени используется стандартная функция библиотеки языка Си localtime_r().Функция localtime_r()C обычно работает только в течение лет между 1970 и 2037 годами.Для дат вне этого диапазона SQLite пытается отобразить год в эквивалентный год в этом диапазоне,выполняет вычисление,а затем отображает год назад.</target>
        </trans-unit>
        <trans-unit id="a84ddecfbfcfd1c573cf704dea12a071acade093" translate="yes" xml:space="preserve">
          <source>The concept of fuzz testing has been around for decades, but fuzz testing was not an effective way to find bugs until 2014 when Michal Zalewski invented the first practical profile-guided fuzzer, &lt;a href=&quot;http://lcamtuf.coredump.cx/afl/&quot;&gt;American Fuzzy Lop&lt;/a&gt; or &quot;AFL&quot;. Unlike prior fuzzers that blindly generate random inputs, AFL instruments the program being tested (by modifying the assembly-language output from the C compiler) and uses that instrumentation to detect when an input causes the program to do something different - to follow a new control path or loop a different number of times. Inputs that provoke new behavior are retained and further mutated. In this way, AFL is able to &quot;discover&quot; new behaviors of the program under test, including behaviors that were never envisioned by the designers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c788bf48ee2358b78bb00bc56b593bb09c394d8" translate="yes" xml:space="preserve">
          <source>The configure script (on unix) automatically detects pread() and pwrite() and sets compile-time options to use those OS interfaces if they are available.</source>
          <target state="translated">Сценарий конфигурации (на unix)автоматически определяет pread()и pwrite()и устанавливает опции времени компиляции для использования этих интерфейсов ОС,если они доступны.</target>
        </trans-unit>
        <trans-unit id="b71509666058777b45e3ddaa4c2923ebc4c7fa2f" translate="yes" xml:space="preserve">
          <source>The configure-make works whether your are building from the canonical sources from the source tree, or from an amalgamated bundle. There are few dependencies. When building from canonical sources, a working &lt;a href=&quot;https://www.tcl.tk/man/tcl8.3/UserCmd/tclsh.htm&quot;&gt;tclsh&lt;/a&gt; is required. If using an amalgamation bundle, all the preprocessing work normally done by tclsh will have already been carried out and only normal build tools are required.</source>
          <target state="translated">Configure-make работает независимо от того, собираете ли вы из канонических источников из дерева исходных текстов или из объединенного пакета. Есть несколько зависимостей. При сборке из канонических источников требуется рабочий &lt;a href=&quot;https://www.tcl.tk/man/tcl8.3/UserCmd/tclsh.htm&quot;&gt;tclsh&lt;/a&gt; . При использовании пакета объединения вся работа по предварительной обработке, обычно выполняемая tclsh, уже будет выполнена, и требуются только обычные инструменты сборки.</target>
        </trans-unit>
        <trans-unit id="8ac9040eb64152e9af693ac6b3d6353d633a032f" translate="yes" xml:space="preserve">
          <source>The conflict handler is invoked with CHANGESET_DATA as the second argument when processing a DELETE or UPDATE change if a row with the required PRIMARY KEY fields is present in the database, but one or more other (non primary-key) fields modified by the update do not contain the expected &quot;before&quot; values.</source>
          <target state="translated">Обработчик конфликтов вызывается со вторым аргументом CHANGESET_DATA при обработке изменения DELETE или UPDATE,если строка с требуемыми полями PRIMARY KEY присутствует в БД,но одно или несколько других (не праймерик)полей,модифицированных обновлением,не содержат ожидаемых значений &quot;до&quot;.</target>
        </trans-unit>
        <trans-unit id="23fc4d91796bed566e82459162cebcab0cf84b45" translate="yes" xml:space="preserve">
          <source>The conflict handler is invoked with CHANGESET_NOTFOUND as the second argument when processing a DELETE or UPDATE change if a row with the required PRIMARY KEY fields is not present in the database.</source>
          <target state="translated">Обработчик конфликтов вызывается со вторым аргументом CHANGESET_NOTFOUND при обработке изменения DELETE или UPDATE,если строка с требуемыми полями PRIMARY KEY отсутствует в БД.</target>
        </trans-unit>
        <trans-unit id="c661dc346561d136d5859295a5527b2af74324a7" translate="yes" xml:space="preserve">
          <source>The conflicting row in this case is the database row with the matching primary key.</source>
          <target state="translated">Конфликтной строкой в данном случае является строка БД с соответствующим первичным ключом.</target>
        </trans-unit>
        <trans-unit id="4298401952abf69332c686d0b1f446ca8e2e6344" translate="yes" xml:space="preserve">
          <source>The conflicting row, in this case, is the database row with the matching primary key.</source>
          <target state="translated">Конфликтная строка в данном случае-это строка базы данных с соответствующим первичным ключом.</target>
        </trans-unit>
        <trans-unit id="ca62ceaf8e4848fb4512d05da76c6a9337ad0aa5" translate="yes" xml:space="preserve">
          <source>The connection checks if a</source>
          <target state="translated">Соединение проверяет</target>
        </trans-unit>
        <trans-unit id="72c42ad2c395427b5b34bc215df721de823e8688" translate="yes" xml:space="preserve">
          <source>The connection checks if the data in the</source>
          <target state="translated">Соединение проверяет данные в</target>
        </trans-unit>
        <trans-unit id="aed384d7e555153a17ceb13abbd6bca15763f13c" translate="yes" xml:space="preserve">
          <source>The content allows the text being indexed to be stored in a separate table distinct from the FTS4 table, or even outside of SQLite.</source>
          <target state="translated">Содержание позволяет хранить индексируемый текст в отдельной таблице,отличной от таблицы FTS4,или даже вне SQLite.</target>
        </trans-unit>
        <trans-unit id="d6e0eda1c9ea11f507c054ff491306a6eca1ff67" translate="yes" xml:space="preserve">
          <source>The content in the sqlite_stat4 table cannot be computed with anything less than a full scan. Hence, if a non-zero analysis limit is specified, the sqlite_stat4 table is not computed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbbe292e23fdc57896771b367c267746f39de5b7" translate="yes" xml:space="preserve">
          <source>The content of P3 registers starting at register P2 form an unpacked index key. This opcode removes that entry from the index opened by cursor P1.</source>
          <target state="translated">Содержимое регистров P3,начиная с регистра P2,образует распакованный индексный ключ.Этот опкод удаляет эту запись из индекса,открытого курсором P1.</target>
        </trans-unit>
        <trans-unit id="53039aadd3f75ae33d382081b8b5f0e6fd60f4d6" translate="yes" xml:space="preserve">
          <source>The content of an R*Tree index is actually stored in three ordinary SQLite tables with names derived from the name of the R*Tree. These three tables are called &quot;&lt;a href=&quot;vtab#xshadowname&quot;&gt;shadow tables&lt;/a&gt;&quot;. This is their schema:</source>
          <target state="translated">Содержимое индекса R * Tree фактически хранится в трех обычных таблицах SQLite с именами, производными от имени R * Tree. Эти три таблицы называются &amp;laquo; &lt;a href=&quot;vtab#xshadowname&quot;&gt;теневыми таблицами&lt;/a&gt; &amp;raquo;. Это их схема:</target>
        </trans-unit>
        <trans-unit id="dd5b1eb070f31c8697b621bf1847b35fb7a8adaf" translate="yes" xml:space="preserve">
          <source>The content of each SQL table row is stored in the database file by first combining the values in the various columns into a byte array in the record format, then storing that byte array as the payload in an entry in the table b-tree. The order of values in the record is the same as the order of columns in the SQL table definition. When an SQL table includes an &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; column (which aliases the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;) then that column appears in the record as a NULL value. SQLite will always use the table b-tree key rather than the NULL value when referencing the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; column.</source>
          <target state="translated">Содержимое каждой строки таблицы SQL сохраняется в файле базы данных путем сначала объединения значений в различных столбцах в массив байтов в формате записи, а затем сохранения этого массива байтов в качестве полезной нагрузки в записи в b-дереве таблицы. Порядок значений в записи такой же, как порядок столбцов в определении таблицы SQL. Когда таблица SQL включает столбец &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; (который является псевдонимом &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; ), этот столбец отображается в записи как значение NULL. При обращении к столбцу &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; SQLite всегда будет использовать ключ b-дерева таблицы, а не значение NULL .</target>
        </trans-unit>
        <trans-unit id="71920b63c9e6445164e490bc0f251a06d6bb693f" translate="yes" xml:space="preserve">
          <source>The content of each rollback journal is flushed to disk both before and after the master journal filename is written into the rollback journal header. It is important to do both of these flushes. Fortunately, the second flush is usually inexpensive since typically only a single page of the journal file (the first page) has changed.</source>
          <target state="translated">Содержимое каждого журнала отката прошивается на диск как до,так и после того,как в заголовок журнала отката записывается имя файла главного журнала.Важно сделать обе эти промывки.К счастью,вторая прошивка обычно недорогая,так как обычно меняется только одна страница файла журнала (первая страница).</target>
        </trans-unit>
        <trans-unit id="2c74d571015e1e1c51708cccb3ac9a7ab08632cc" translate="yes" xml:space="preserve">
          <source>The content of each rollback journal is flushed to disk both before and after the super-journal filename is written into the rollback journal header. It is important to do both of these flushes. Fortunately, the second flush is usually inexpensive since typically only a single page of the journal file (the first page) has changed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39b372f8730aa69db1fd10c964b137259496c534" translate="yes" xml:space="preserve">
          <source>The content of each slide could still be stored as compressed XML. But now each page is stored separately. So when opening a new document, the application could simply run:</source>
          <target state="translated">Содержимое каждого слайда может быть сохранено в виде сжатого XML.Но теперь каждая страница хранится отдельно.Так что при открытии нового документа приложение могло просто запускаться:</target>
        </trans-unit>
        <trans-unit id="ef2de54ba7f62420a379fc46c4ab7cf3080ae413" translate="yes" xml:space="preserve">
          <source>The content of the statistics tables can be queried using &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; and can be changed using the &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt;, &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;, and &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; commands. The &lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt; command works on statistics tables as of SQLite version 3.7.9. (2011-11-01) The &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE&lt;/a&gt; command does not work on statistics tables. Appropriate care should be used when changing the content of the statistics tables as invalid content can cause SQLite to select inefficient query plans. Generally speaking, one should not modify the content of the statistics tables by any mechanism other than invoking the ANALYZE command. See &quot;&lt;a href=&quot;optoverview#manctrl&quot;&gt;Manual Control Of Query Plans Using SQLITE_STAT Tables&lt;/a&gt;&quot; for further information.</source>
          <target state="translated">Содержимое таблиц статистики можно запросить с помощью &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; и изменить с помощью команд &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; , &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; и &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; . Команда &lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt; работает с таблицами статистики, начиная с версии SQLite 3.7.9. (2011-11-01) Команда &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE&lt;/a&gt; не работает с таблицами статистики. При изменении содержимого таблиц статистики следует проявлять соответствующую осторожность, поскольку недопустимое содержимое может привести к тому, что SQLite выберет неэффективные планы запросов. Вообще говоря, не следует изменять содержимое таблиц статистики с помощью какого-либо механизма, кроме вызова команды ANALYZE. См. &amp;laquo; &lt;a href=&quot;optoverview#manctrl&quot;&gt;Ручное управление планами запросов с использованием таблиц SQLITE_STAT&lt;/a&gt; &amp;raquo; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="cb0bc8e6cf7e707512464168a8333cd25f0f7228" translate="yes" xml:space="preserve">
          <source>The content option allows FTS4 to forego storing the text being indexed. The content option can be used in two ways:</source>
          <target state="translated">Опция контента позволяет FTS4 отказаться от хранения индексируемого текста.Опция контента может быть использована двумя способами:</target>
        </trans-unit>
        <trans-unit id="50fd4cd87f476ff7994844fe209f20e1e61a3e92" translate="yes" xml:space="preserve">
          <source>The content table may also be queried as follows:</source>
          <target state="translated">Содержание таблицы также может быть запрошено следующим образом:</target>
        </trans-unit>
        <trans-unit id="43da535bae3bfe186441cea4bad1d427988c63d1" translate="yes" xml:space="preserve">
          <source>The contents of a changeset may be traversed using an iterator created using the &lt;a href=&quot;#sqlite3changeset_start&quot;&gt;sqlite3changeset_start()&lt;/a&gt; API. A changeset may be applied to a database with a compatible schema using the &lt;a href=&quot;#sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply()&lt;/a&gt; API.</source>
          <target state="translated">Содержимое &lt;a href=&quot;#sqlite3changeset_start&quot;&gt;набора&lt;/a&gt; изменений можно просмотреть с помощью итератора, созданного с помощью API sqlite3changeset_start () . Набор изменений можно применить к базе данных с совместимой схемой с помощью API &lt;a href=&quot;#sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d1fc4719b451a2f189cbf09b3af719ceaa1455fd" translate="yes" xml:space="preserve">
          <source>The contents of a changeset may be traversed using an iterator created using the &lt;a href=&quot;sqlite3changeset_start&quot;&gt;sqlite3changeset_start()&lt;/a&gt; API. A changeset may be applied to a database with a compatible schema using the &lt;a href=&quot;sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply()&lt;/a&gt; API.</source>
          <target state="translated">Содержимое &lt;a href=&quot;sqlite3changeset_start&quot;&gt;набора&lt;/a&gt; изменений можно просмотреть с помощью итератора, созданного с помощью API sqlite3changeset_start () . Набор изменений можно применить к базе данных с совместимой схемой с помощью API &lt;a href=&quot;sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="17197a14b8f9ff583e2fbe7ec6a33d12aff2f981" translate="yes" xml:space="preserve">
          <source>The contents of an SQLite database file are formatted as a set of fixed size pages. See</source>
          <target state="translated">Содержимое файла базы данных SQLite отформатировано в виде набора страниц фиксированного размера.См..</target>
        </trans-unit>
        <trans-unit id="6741b03ffce89c3a2ca3addb1cadccc791915ce5" translate="yes" xml:space="preserve">
          <source>The contents of columns qualified with the UNINDEXED column option are not added to the FTS index. This means that for the purposes of MATCH queries and &lt;a href=&quot;fts5#_auxiliary_functions_&quot;&gt;FTS5 auxiliary functions&lt;/a&gt;, the column contains no matchable tokens.</source>
          <target state="translated">Содержимое столбцов, отмеченных параметром UNINDEXED column, не добавляется в индекс FTS. Это означает, что для целей запросов MATCH и &lt;a href=&quot;fts5#_auxiliary_functions_&quot;&gt;вспомогательных функций FTS5&lt;/a&gt; столбец не содержит подходящих токенов.</target>
        </trans-unit>
        <trans-unit id="f4381b2c97365bdc1448864c183789c2d75a4c76" translate="yes" xml:space="preserve">
          <source>The contents of the logical full-text index is found by merging the contents of all segment b-trees. If a term is present in more than one segment b-tree, then it maps to the union of each individual doclist. If, for a single term, the same docid occurs in more than one doclist, then only the doclist that is part of the most recently created segment b-tree is considered valid.</source>
          <target state="translated">Содержимое логического полнотекстового индекса находят путем слияния содержимого всех b-деревьев сегмента.Если термин присутствует более чем в одном сегменте b-дерева,то он сопоставляется с объединением каждого отдельного доклиста.Если в течение одного срока один и тот же доцит встречается более чем в одном докласте,то действительным считается только тот доцит,который входит в состав последнего созданного b-дерева сегмента.</target>
        </trans-unit>
        <trans-unit id="603ef17ea7e8b979fdc97587b739002125ee3a17" translate="yes" xml:space="preserve">
          <source>The contents of the sqlite3_pcache_methods2 structure are copied to an internal buffer by SQLite within the call to &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config&lt;/a&gt;. Hence the application may discard the parameter after the call to &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config()&lt;/a&gt; returns.</source>
          <target state="translated">Содержимое структуры sqlite3_pcache_methods2 копируется во внутренний буфер SQLite при вызове &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config&lt;/a&gt; . Следовательно, приложение может отказаться от параметра после возврата из вызова &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d33c4566f4b0045dff066d31694e73d46d2bf6db" translate="yes" xml:space="preserve">
          <source>The contents of the sqlite3_pcache_methods2 structure are copied to an internal buffer by SQLite within the call to &lt;a href=&quot;config&quot;&gt;sqlite3_config&lt;/a&gt;. Hence the application may discard the parameter after the call to &lt;a href=&quot;config&quot;&gt;sqlite3_config()&lt;/a&gt; returns.</source>
          <target state="translated">Содержимое структуры sqlite3_pcache_methods2 копируется во внутренний буфер SQLite при вызове &lt;a href=&quot;config&quot;&gt;sqlite3_config&lt;/a&gt; . Следовательно, приложение может отказаться от параметра после возврата из вызова &lt;a href=&quot;config&quot;&gt;sqlite3_config ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1e184948fbfc41a2f2c0c14809d37c70c80c03a2" translate="yes" xml:space="preserve">
          <source>The context in which an SQL function executes is stored in an sqlite3_context object. A pointer to an sqlite3_context object is always first parameter to &lt;a href=&quot;#sqlite3_create_function&quot;&gt;application-defined SQL functions&lt;/a&gt;. The application-defined SQL function implementation will pass this pointer through into calls to &lt;a href=&quot;#sqlite3_result_blob&quot;&gt;sqlite3_result()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_aggregate_context&quot;&gt;sqlite3_aggregate_context()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_user_data&quot;&gt;sqlite3_user_data()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_context_db_handle&quot;&gt;sqlite3_context_db_handle()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_get_auxdata&quot;&gt;sqlite3_get_auxdata()&lt;/a&gt;, and/or &lt;a href=&quot;#sqlite3_get_auxdata&quot;&gt;sqlite3_set_auxdata()&lt;/a&gt;.</source>
          <target state="translated">Контекст, в котором выполняется функция SQL, хранится в объекте sqlite3_context. Указатель на объект sqlite3_context всегда является первым параметром для &lt;a href=&quot;#sqlite3_create_function&quot;&gt;определяемых приложением функций SQL&lt;/a&gt; . Реализация определяемой приложением функции SQL передаст этот указатель в вызовы &lt;a href=&quot;#sqlite3_result_blob&quot;&gt;sqlite3_result ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_aggregate_context&quot;&gt;sqlite3_aggregate_context ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_user_data&quot;&gt;sqlite3_user_data ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_context_db_handle&quot;&gt;sqlite3_context_db_handle ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_get_auxdata&quot;&gt;sqlite3_get_auxdata ()&lt;/a&gt; и / или &lt;a href=&quot;#sqlite3_get_auxdata&quot;&gt;sqlite3_set_auxdata ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="eb189ce529b8d7d0045783021bb7d8fd77526437" translate="yes" xml:space="preserve">
          <source>The context in which an SQL function executes is stored in an sqlite3_context object. A pointer to an sqlite3_context object is always first parameter to &lt;a href=&quot;../appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt;. The application-defined SQL function implementation will pass this pointer through into calls to &lt;a href=&quot;result_blob&quot;&gt;sqlite3_result()&lt;/a&gt;, &lt;a href=&quot;aggregate_context&quot;&gt;sqlite3_aggregate_context()&lt;/a&gt;, &lt;a href=&quot;user_data&quot;&gt;sqlite3_user_data()&lt;/a&gt;, &lt;a href=&quot;context_db_handle&quot;&gt;sqlite3_context_db_handle()&lt;/a&gt;, &lt;a href=&quot;get_auxdata&quot;&gt;sqlite3_get_auxdata()&lt;/a&gt;, and/or &lt;a href=&quot;get_auxdata&quot;&gt;sqlite3_set_auxdata()&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53fb8a37d043abdf36747b3ab57dd8a44c62d486" translate="yes" xml:space="preserve">
          <source>The context in which an SQL function executes is stored in an sqlite3_context object. A pointer to an sqlite3_context object is always first parameter to &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt;. The application-defined SQL function implementation will pass this pointer through into calls to &lt;a href=&quot;#sqlite3_result_blob&quot;&gt;sqlite3_result()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_aggregate_context&quot;&gt;sqlite3_aggregate_context()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_user_data&quot;&gt;sqlite3_user_data()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_context_db_handle&quot;&gt;sqlite3_context_db_handle()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_get_auxdata&quot;&gt;sqlite3_get_auxdata()&lt;/a&gt;, and/or &lt;a href=&quot;#sqlite3_get_auxdata&quot;&gt;sqlite3_set_auxdata()&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7c0cad9919ee775dcafe683809a8efa13aeacfd" translate="yes" xml:space="preserve">
          <source>The context in which an SQL function executes is stored in an sqlite3_context object. A pointer to an sqlite3_context object is always first parameter to &lt;a href=&quot;create_function&quot;&gt;application-defined SQL functions&lt;/a&gt;. The application-defined SQL function implementation will pass this pointer through into calls to &lt;a href=&quot;result_blob&quot;&gt;sqlite3_result()&lt;/a&gt;, &lt;a href=&quot;aggregate_context&quot;&gt;sqlite3_aggregate_context()&lt;/a&gt;, &lt;a href=&quot;user_data&quot;&gt;sqlite3_user_data()&lt;/a&gt;, &lt;a href=&quot;context_db_handle&quot;&gt;sqlite3_context_db_handle()&lt;/a&gt;, &lt;a href=&quot;get_auxdata&quot;&gt;sqlite3_get_auxdata()&lt;/a&gt;, and/or &lt;a href=&quot;get_auxdata&quot;&gt;sqlite3_set_auxdata()&lt;/a&gt;.</source>
          <target state="translated">Контекст, в котором выполняется функция SQL, хранится в объекте sqlite3_context. Указатель на объект sqlite3_context всегда является первым параметром для &lt;a href=&quot;create_function&quot;&gt;определяемых приложением функций SQL&lt;/a&gt; . Реализация определяемой приложением функции SQL передаст этот указатель в вызовы &lt;a href=&quot;result_blob&quot;&gt;sqlite3_result ()&lt;/a&gt; , &lt;a href=&quot;aggregate_context&quot;&gt;sqlite3_aggregate_context ()&lt;/a&gt; , &lt;a href=&quot;user_data&quot;&gt;sqlite3_user_data ()&lt;/a&gt; , &lt;a href=&quot;context_db_handle&quot;&gt;sqlite3_context_db_handle ()&lt;/a&gt; , &lt;a href=&quot;get_auxdata&quot;&gt;sqlite3_get_auxdata ()&lt;/a&gt; и / или &lt;a href=&quot;get_auxdata&quot;&gt;sqlite3_set_auxdata ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2dc88bed6dbd7abe62664d54e6bdaf4f83cf04fb" translate="yes" xml:space="preserve">
          <source>The copy is edited to change the branch instruction into either a no-op or an unconditional jump.</source>
          <target state="translated">Копия редактируется,чтобы изменить инструкцию ветки либо на &quot;нет-нет-нет&quot;,либо на &quot;безусловный прыжок&quot;.</target>
        </trans-unit>
        <trans-unit id="cb1935e51d150180f58869cd5c4365f67de7c57a" translate="yes" xml:space="preserve">
          <source>The copy method implements similar functionality to the &lt;b&gt;.import&lt;/b&gt; SQLite shell command.</source>
          <target state="translated">Метод копирования реализует аналогичные функции с &lt;b&gt;командой&lt;/b&gt; оболочки &lt;b&gt;.import&lt;/b&gt; SQLite.</target>
        </trans-unit>
        <trans-unit id="7d3c9b74d67dc166ca8e07aaa910e143f4d6cf96" translate="yes" xml:space="preserve">
          <source>The copy of sqlite3.s is assembled into sqlite3.o then linked again th3.o to generate the &quot;th3&quot; executable.</source>
          <target state="translated">Копия sqlite3.s собирается в sqlite3.o и затем снова связывается th3.o для генерации &quot;th3&quot; исполняемого файла.</target>
        </trans-unit>
        <trans-unit id="b047a98a10f78ed2613ab80ee6fd529ee912f70f" translate="yes" xml:space="preserve">
          <source>The core functions shown below are available by default. &lt;a href=&quot;lang_datefunc&quot;&gt;Date &amp;amp; Time functions&lt;/a&gt;, &lt;a href=&quot;lang_aggfunc&quot;&gt;aggregate functions&lt;/a&gt;, &lt;a href=&quot;windowfunctions#biwinfunc&quot;&gt;window functions&lt;/a&gt;, and &lt;a href=&quot;json1&quot;&gt;JSON functions&lt;/a&gt; are documented separately. An application may define additional functions written in C and added to the database engine using the &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt; API.</source>
          <target state="translated">Показанные ниже основные функции доступны по умолчанию. &lt;a href=&quot;lang_datefunc&quot;&gt;Функции даты и времени&lt;/a&gt; , &lt;a href=&quot;lang_aggfunc&quot;&gt;агрегатные функции&lt;/a&gt; , &lt;a href=&quot;windowfunctions#biwinfunc&quot;&gt;оконные функции&lt;/a&gt; и &lt;a href=&quot;json1&quot;&gt;функции JSON&lt;/a&gt; документируются отдельно. Приложение может определять дополнительные функции, написанные на C и добавленные в ядро ​​базы данных с помощью API &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a7002ce76e139b64c91049472e1737291c84c664" translate="yes" xml:space="preserve">
          <source>The core idea is to create a special table (named &quot;UNDOLOG&quot; in the example) that holds information needed to undo/redo changes to the database. For each class (table) in the database that wants to participate in the undo/redo, triggers are created that cause entries to be made in the UNDOLOG table for each DELETE, INSERT, and UPDATE of the participating class. The UNDOLOG entries consist of ordinary SQL statements the can be played back to reverse the changes.</source>
          <target state="translated">Основная идея заключается в создании специальной таблицы (в примере названной &quot;UNDOLOG&quot;),содержащей информацию,необходимую для отмены/внесения изменений в базу данных.Для каждого класса (таблицы)в БД,который хочет участвовать в отмене/повторжении,создаются триггеры,которые вызывают записи в таблице UNDOLOG для каждого DELETE,INSERT и UPDATE участвующего класса.Записи UNDOLOG состоят из обычных SQL-операторов,которые могут быть воспроизведены для отмены изменений.</target>
        </trans-unit>
        <trans-unit id="b4619c14d9f61ffdd467d39188a12cbd3dab6b8b" translate="yes" xml:space="preserve">
          <source>The core of a SELECT statement is a &quot;simple SELECT&quot; shown by the &lt;a href=&quot;syntax/select-core&quot;&gt;select-core&lt;/a&gt; and &lt;a href=&quot;syntax/simple-select-stmt&quot;&gt;simple-select-stmt&lt;/a&gt; syntax diagrams below. In practice, most SELECT statements are simple SELECT statements.</source>
          <target state="translated">Ядром оператора SELECT является &amp;laquo;простой SELECT&amp;raquo;, показанный синтаксическими диаграммами &lt;a href=&quot;syntax/select-core&quot;&gt;select-core&lt;/a&gt; и &lt;a href=&quot;syntax/simple-select-stmt&quot;&gt;simple-select-stmt&lt;/a&gt; ниже. На практике большинство операторов SELECT являются простыми операторами SELECT.</target>
        </trans-unit>
        <trans-unit id="202f127cc642aea639fbf4c524ee9db3a310c986" translate="yes" xml:space="preserve">
          <source>The core query used to generate the branch timeline is shown below. (Readers are not expected to understand the details of this query. Commentary will follow.)</source>
          <target state="translated">Ниже показан основной запрос,использованный для генерации шкалы времени ветки.(Читатели не должны понимать детали этого запроса.Комментарий последует далее).</target>
        </trans-unit>
        <trans-unit id="ca59f51d09381d1b3447776404c915b9169882ab" translate="yes" xml:space="preserve">
          <source>The core string formatting routine is the sqlite3VXPrintf() function found in the &lt;a href=&quot;https://sqlite.org/src/file/src/printf.c&quot;&gt;printf.c&lt;/a&gt; source file. All the various interfaces invoke (sometimes indirectly) this one core function. The sqlite3VXPrintf() function began as code written by the first author of SQLite (&lt;a href=&quot;https://sqlite.org/crew.html&quot;&gt;Hipp&lt;/a&gt;) when he was a graduate student a Duke University in the late 1980s. Hipp kept this printf() implementation in his personal toolbox until he started working on SQLite in 2000. The code was incorporated into the SQLite source tree on &lt;a href=&quot;https://sqlite.org/src/timeline?c=f9372072a6&quot;&gt;2000-10-08&lt;/a&gt; for SQLite version 1.0.9.</source>
          <target state="translated">Основная процедура форматирования строк - это функция sqlite3VXPrintf (), которая находится в исходном файле &lt;a href=&quot;https://sqlite.org/src/file/src/printf.c&quot;&gt;printf.c&lt;/a&gt; . Все различные интерфейсы вызывают (иногда косвенно) эту одну базовую функцию. Функция sqlite3VXPrintf () началась с кода, написанного первым автором SQLite ( &lt;a href=&quot;https://sqlite.org/crew.html&quot;&gt;Hipp&lt;/a&gt; ), когда он был аспирантом Университета Дьюка в конце 1980-х годов. Хипп хранил эту реализацию printf () в своем личном наборе инструментов до тех пор, пока не начал работать над SQLite в 2000 году. Код был включен в дерево исходных &lt;a href=&quot;https://sqlite.org/src/timeline?c=f9372072a6&quot;&gt;текстов&lt;/a&gt; SQLite 2008-10-08 для SQLite версии 1.0.9.</target>
        </trans-unit>
        <trans-unit id="093b78a42e1ecfed114ac694aeda4be18d47e5e9" translate="yes" xml:space="preserve">
          <source>The cost table can be named anything you want - it does not have to be called &quot;editcost&quot;. And the table can contain additional columns. The only requirement is that the table must contain the four columns show above, with exactly the names shown.</source>
          <target state="translated">Таблицу стоимости можно назвать как угодно-ее не обязательно называть &quot;editcost&quot;.А таблица может содержать дополнительные колонки.Единственное требование-таблица должна содержать четыре столбца,показанные выше,с точно указанными именами.</target>
        </trans-unit>
        <trans-unit id="ab3b915916ad100c2de3d193cbc3d8e54968ac9c" translate="yes" xml:space="preserve">
          <source>The costs are comprised of multiple numbers, not a single number as shown in the graph. SQLite computes several different estimated costs for each loop that apply at different times. For example, there is a &quot;setup&quot; cost that is incurred just once when the query starts. The setup cost is the cost of computing an &lt;a href=&quot;optoverview#autoindex&quot;&gt;automatic index&lt;/a&gt; for a table that does not already have an index. Then there is the cost of running each step of the loop. Finally, there is an estimate of the number rows generated by the loop, which is information needed in estimating the costs of inner loops. Sorting costs may come into play if the query has an ORDER BY clause.</source>
          <target state="translated">Стоимость состоит из нескольких чисел, а не из одного числа, как показано на графике. SQLite вычисляет несколько различных оценочных затрат для каждого цикла, которые применяются в разное время. Например, есть &amp;laquo;затраты на установку&amp;raquo;, которые понесены только один раз при запуске запроса. Стоимость установки - это стоимость вычисления &lt;a href=&quot;optoverview#autoindex&quot;&gt;автоматического индекса&lt;/a&gt; для таблицы, у которой еще нет индекса. Затем идет стоимость выполнения каждого шага цикла. Наконец, есть оценка количества строк, сгенерированных циклом, которая является информацией, необходимой для оценки стоимости внутренних циклов. Затраты на сортировку могут иметь значение, если в запросе есть предложение ORDER BY.</target>
        </trans-unit>
        <trans-unit id="19bc3b9522f26a7b0a814b17b06d2223be3c56f5" translate="yes" xml:space="preserve">
          <source>The count(X) function returns a count of the number of times that</source>
          <target state="translated">Функция count(X)возвращает количество раз,которое</target>
        </trans-unit>
        <trans-unit id="8e9bf7bdd6a7e80adbfe374cd14df21073d0a490" translate="yes" xml:space="preserve">
          <source>The countStep() callback is invoked once for each row in the aggregate. As you can see, the count is incremented if either there are no arguments, or if the one argument is not NULL.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3944d86225bf50f66350ca2264ab4a84abeb87d" translate="yes" xml:space="preserve">
          <source>The cov1 test set used to obtain 100% branch test coverage are only a subset of the tests currently implemented using TH3. New test modules are added on a regular basis.</source>
          <target state="translated">Набор тестов cov1,используемый для получения 100%-ного тестового покрытия ветвей,является лишь подмножеством тестов,реализованных в настоящее время с использованием TH3.Новые тестовые модули добавляются регулярно.</target>
        </trans-unit>
        <trans-unit id="d677c2d682d4dade2e8fc2faf6167d79dbe61f08" translate="yes" xml:space="preserve">
          <source>The crash tests in SQLite have discovered a number of very subtle bugs (now fixed) in the recovery mechanism. Some of these bugs were very obscure and unlikely to have been found using only code inspection and analysis techniques. From this experience, the developers of SQLite feel confident that any other database system that does not use a similar crash test system likely contains undetected bugs that will lead to database corruption following a system crash or power failure.</source>
          <target state="translated">Крэш-тесты в SQLite обнаружили ряд очень тонких ошибок (теперь исправлены)в механизме восстановления.Некоторые из этих ошибок были очень непонятны и вряд ли были найдены с использованием только методов осмотра и анализа кода.Исходя из этого опыта,разработчики SQLite уверены,что любая другая система базы данных,не использующая аналогичную систему краш-тестов,скорее всего,содержит необнаруженные ошибки,которые приведут к повреждению базы данных после сбоя системы или отключения электропитания.</target>
        </trans-unit>
        <trans-unit id="33ac0d26d4e9c7d412c89e095055cacaebdbb563" translate="yes" xml:space="preserve">
          <source>The cumulative distribution. Calculated as</source>
          <target state="translated">Совокупное распределение.Рассчитано как</target>
        </trans-unit>
        <trans-unit id="9f3f4c9ed1a83693cad288a8dbbe975dd262d497" translate="yes" xml:space="preserve">
          <source>The current implementation of SQLite uses only loop joins. That is to say, joins are implemented as nested loops.</source>
          <target state="translated">Текущая реализация SQLite использует только соединения циклов.То есть соединения реализованы как вложенные циклы.</target>
        </trans-unit>
        <trans-unit id="0595dd468ba4f2594b89c18514e0ce47ff0d0c46" translate="yes" xml:space="preserve">
          <source>The current implementation of this JSON library uses a recursive descent parser. In order to avoid using excess stack space, any JSON input that has more than 2000 levels of nesting is considered invalid. Limits on nesting depth are allowed for compatible implementations of JSON by &lt;a href=&quot;https://tools.ietf.org/html/rfc7159#section-9&quot;&gt;RFC-7159 section 9&lt;/a&gt;.</source>
          <target state="translated">Текущая реализация этой библиотеки JSON использует парсер рекурсивного спуска. Чтобы избежать использования лишнего пространства стека, любой ввод JSON с более чем 2000 уровнями вложенности считается недопустимым. Ограничения на глубину вложенности разрешены для совместимых реализаций JSON в &lt;a href=&quot;https://tools.ietf.org/html/rfc7159#section-9&quot;&gt;разделе 9 RFC-7159&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1859423b8976d8bfae8dfc344c1935671c660093" translate="yes" xml:space="preserve">
          <source>The current implementation will only support a string or BLOB length up to 2&lt;small&gt;&lt;sup&gt;31&lt;/sup&gt;&lt;/small&gt;-1 or 2147483647. And some built-in functions such as hex() might fail well before that point. In security-sensitive applications it is best not to try to increase the maximum string and blob length. In fact, you might do well to lower the maximum string and blob length to something more in the range of a few million if that is possible.</source>
          <target state="translated">Текущая реализация будет поддерживать только строку или большой двоичный объект длиной до 2 &lt;small&gt;&lt;sup&gt;31&lt;/sup&gt;&lt;/small&gt; -1 или 2147483647. И некоторые встроенные функции, такие как hex (), могут выйти из строя задолго до этого. В чувствительных к безопасности приложениях лучше не пытаться увеличить максимальную длину строки и большого двоичного объекта. Фактически, вы могли бы поступить правильно, снизив максимальную длину строки и blob до чего-то большего в диапазоне нескольких миллионов, если это возможно.</target>
        </trans-unit>
        <trans-unit id="ce671671108a214d3061700585cfbe08230e46de" translate="yes" xml:space="preserve">
          <source>The current row. For RANGE and GROUPS frame types, peers of the current row are also included in the frame, unless specifically excluded by the EXCLUDE clause. This is true regardless of whether CURRENT ROW is used as the starting or ending frame boundary.</source>
          <target state="translated">Текущий ряд.Для типов кадров RANGE и GROUPS коллеги текущей строки также включаются в кадр,если только это специально не исключено пунктом EXCLUDE.Это справедливо независимо от того,используется ли CURRENT ROW в качестве границы начального или конечного кадра.</target>
        </trans-unit>
        <trans-unit id="bd2930f3fd3f6f19fc9ada96c54055098b67532e" translate="yes" xml:space="preserve">
          <source>The current value of the requested parameter is written into *pCur and the highest instantaneous value is written into *pHiwtr. If the resetFlg is true, then the highest instantaneous value is reset back down to the current value.</source>
          <target state="translated">Текущее значение запрашиваемого параметра записывается в *pCur,а наибольшее мгновенное значение-в *pHiwtr.Если resetFlg верно,то самое большое мгновенное значение сбрасывается назад к текущему значению.</target>
        </trans-unit>
        <trans-unit id="b3c10a59b750c785e72b4dc21d7b05d270490210" translate="yes" xml:space="preserve">
          <source>The current working directory (&quot;.&quot;)</source>
          <target state="translated">Текущая рабочая директория (&quot;.&quot;)</target>
        </trans-unit>
        <trans-unit id="34c8be248703e890d36c7a3af0b628d68ce8275b" translate="yes" xml:space="preserve">
          <source>The current writer concludes its transaction, OR</source>
          <target state="translated">Текущий автор заключает свою сделку,ИЛИ</target>
        </trans-unit>
        <trans-unit id="d429ef679ef6041cdac168ab25fbc584b8f7c9d4" translate="yes" xml:space="preserve">
          <source>The cycle above can be repeated many times. The diagram shows a third SQLite release, 3.6.17 in circle (6). The private branch maintainer can do another merge in order to incorporate the changes moving from (4) to (6) into the private branch, resulting in version (7).</source>
          <target state="translated">Указанный выше цикл можно повторять много раз.На диаграмме показан третий релиз SQLite,3.6.17 в кружке (6).Мейнтейнер частной ветки может провести ещё одно слияние,чтобы включить изменения,переходящие от (4)к (6),в частную ветку,в результате чего получится версия (7).</target>
        </trans-unit>
        <trans-unit id="8810808ac8350e84a24599fba1a1c44e6d0fc9da" translate="yes" xml:space="preserve">
          <source>The cycle counts provided by cachegrind are a good proxy for actual performance, but they are not 100% accurate.</source>
          <target state="translated">Количество циклов,обеспечиваемое кэш-функцией,является хорошим прокси-сервером для фактической производительности,но они не на 100% точны.</target>
        </trans-unit>
        <trans-unit id="fac9319a6ade67af6ca8dc4d7c432433a5c8d584" translate="yes" xml:space="preserve">
          <source>The data and method columns may also be set as described for an INSERT above.</source>
          <target state="translated">Столбцы данных и метода также могут быть установлены,как описано выше для INSERT.</target>
        </trans-unit>
        <trans-unit id="062b3a0f8f6a4c6911f0379b0878b031acaf0a51" translate="yes" xml:space="preserve">
          <source>The data for a table b-tree leaf page and the key of an index b-tree page was characterized above as an arbitrary sequence of bytes. The prior discussion mentioned one key being less than another, but did not define what &quot;less than&quot; meant. The current section will address these omissions.</source>
          <target state="translated">Данные для страницы листа b-дерева таблицы и ключа индексной страницы b-дерева были охарактеризованы выше как произвольная последовательность байтов.В ходе предыдущего обсуждения было упомянуто,что один ключ меньше другого,но не было определено,что означает &quot;меньше&quot;.В настоящем разделе будут рассмотрены эти пропуски.</target>
        </trans-unit>
        <trans-unit id="b9c10539b9c59116b81ff7089713236e6e1327e8" translate="yes" xml:space="preserve">
          <source>The data for rowid tables is stored as a B-Tree structure containing one entry for each table row, using the rowid value as the key. This means that retrieving or sorting records by rowid is fast. Searching for a record with a specific rowid, or for all records with rowids within a specified range is around twice as fast as a similar search made by specifying any other PRIMARY KEY or indexed value.</source>
          <target state="translated">Данные для таблиц rowid хранятся в виде B-дерева структуры,содержащего по одной записи для каждой строки таблицы,используя в качестве ключа значение rowid.Это означает,что поиск или сортировка записей по рядкам происходит быстро.Поиск записи с определенным рядком или всех записей с рядками в указанном диапазоне примерно в два раза быстрее,чем аналогичный поиск,выполненный путем указания любого другого PRIMARY KEY или проиндексированного значения.</target>
        </trans-unit>
        <trans-unit id="8f8b09e33f29c0f7e2cdc53d761f0421d3f8a545" translate="yes" xml:space="preserve">
          <source>The data_% table must have all the same columns as the target table, plus one additional column named &quot;rbu_control&quot;. The data_% table should have no PRIMARY KEY or UNIQUE constraints, but each column should have the same type as the corresponding column in the target database. The rbu_control column should have no type at all. For example, if the target database contains:</source>
          <target state="translated">Таблица data_% должна иметь все те же столбцы,что и целевая таблица,плюс один дополнительный столбец с именем &quot;rbu_control&quot;.Таблица data_% не должна иметь ограничений PRIMARY KEY или UNIQUE,но каждый столбец должен иметь тот же тип,что и соответствующий столбец целевой базы данных.Столбец rbu_control вообще не должен иметь типа.Например,если целевая БД содержит:</target>
        </trans-unit>
        <trans-unit id="17bee7a4a210b94f9cd35ef19e344d890d514950" translate="yes" xml:space="preserve">
          <source>The data_% tables may be created as follows:</source>
          <target state="translated">Таблицы data_% могут быть созданы следующим образом:</target>
        </trans-unit>
        <trans-unit id="d8fc42980131b74512111cf667ced537b6faec1f" translate="yes" xml:space="preserve">
          <source>The data_% tables themselves should have no PRIMARY KEY declarations. However, RBU is more efficient if reading the rows in from each data_% table in &quot;rowid&quot; order is roughly the same as reading them sorted by the PRIMARY KEY of the corresponding target database table. In other words, rows should be sorted using the destination table PRIMARY KEY fields before they are inserted into the data_% tables.</source>
          <target state="translated">Сами таблицы data_% не должны иметь деклараций PRIMARY KEY.Однако RBU более эффективен,если чтение строк в каждой таблице data_% в &quot;рядном&quot; порядке примерно такое же,как и чтение их отсортированных по PRIMARY KEY соответствующей целевой таблицы БД.Другими словами,строки должны быть отсортированы с использованием полей целевой таблицы PRIMARY KEY,прежде чем они будут вставлены в таблицы data_%.</target>
        </trans-unit>
        <trans-unit id="0e861495335228dd9715b8957c822d148379befb" translate="yes" xml:space="preserve">
          <source>The data_ccc table may then be populated as normal with the updates intended for target database table ccc. The same updates will be read by RBU from the data0_ccc_fts view and applied to FTS table ccc_fts. Because &quot;data0_ccc_fts&quot; is smaller than &quot;data_ccc&quot;, the FTS table will be updated first, as required.</source>
          <target state="translated">В этом случае таблица data_ccc может быть заполнена,как обычно,обновлениями,предназначенными для целевой базы данных таблицы ccc.Эти же обновления будут считываться RBU из представления data0_ccc_fts и применяться к таблице FTS ccc_fts.Поскольку &quot;data0_ccc_fts&quot; меньше,чем &quot;data_ccc&quot;,то таблица FTS будет обновляться первой при необходимости.</target>
        </trans-unit>
        <trans-unit id="7a9df4aba808f0f7f287daab1202c053d1ad5c81" translate="yes" xml:space="preserve">
          <source>The database being vacuumed may not be in &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt;.</source>
          <target state="translated">Очищаемая база данных может быть не в &lt;a href=&quot;wal&quot;&gt;режиме WAL&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d1f84e31daf7f78443fa69ada7a9a8e535388ab9" translate="yes" xml:space="preserve">
          <source>The database connection can be changed between full and incremental autovacuum mode at any time. However, changing from &quot;none&quot; to &quot;full&quot; or &quot;incremental&quot; can only occur when the database is new (no tables have yet been created) or by running the &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; command. To change auto-vacuum modes, first use the auto_vacuum pragma to set the new desired mode, then invoke the &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; command to reorganize the entire database file. To change from &quot;full&quot; or &quot;incremental&quot; back to &quot;none&quot; always requires running &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; even on an empty database.</source>
          <target state="translated">Соединение с базой данных можно в любой момент изменить между полным и инкрементным режимом автоочистки. Однако изменение с &amp;laquo;нет&amp;raquo; на &amp;laquo;полную&amp;raquo; или &amp;laquo;инкрементальную&amp;raquo; может происходить только в случае новой базы данных (таблицы еще не созданы) или при выполнении команды &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; . Чтобы изменить режимы автоматического вакуумирования, сначала используйте прагму auto_vacuum, чтобы установить новый желаемый режим, затем вызовите команду &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM,&lt;/a&gt; чтобы реорганизовать весь файл базы данных. Для изменения с &amp;laquo;полного&amp;raquo; или &amp;laquo;инкрементального&amp;raquo; обратно на &amp;laquo;нет&amp;raquo; всегда требуется запускать &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; даже в пустой базе данных.</target>
        </trans-unit>
        <trans-unit id="3e8669da1288d64c48a1d4da77efa2cfbe93e717" translate="yes" xml:space="preserve">
          <source>The database connection is opened using the &lt;a href=&quot;uri#uriimmutable&quot;&gt;immutable query parameter&lt;/a&gt;.</source>
          <target state="translated">Соединение с базой данных открывается с использованием &lt;a href=&quot;uri#uriimmutable&quot;&gt;неизменяемого параметра запроса&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="17dc502f4a596e5beade9b059c41722a7380dd5f" translate="yes" xml:space="preserve">
          <source>The database file format is unchanged for WAL mode. However, the WAL file and the &lt;a href=&quot;walformat#shm&quot;&gt;wal-index&lt;/a&gt; are new concepts and so older versions of SQLite will not know how to recover a crashed SQLite database that was operating in WAL mode when the crash occurred. To prevent older versions of SQLite (prior to version 3.7.0, 2010-07-22) from trying to recover a WAL-mode database (and making matters worse) the database file format version numbers (bytes 18 and 19 in the &lt;a href=&quot;fileformat2#database_header&quot;&gt;database header&lt;/a&gt;) are increased from 1 to 2 in WAL mode. Thus, if an older version of SQLite attempts to connect to an SQLite database that is operating in WAL mode, it will report an error along the lines of &quot;file is encrypted or is not a database&quot;.</source>
          <target state="translated">Формат файла базы данных не изменился для режима WAL. Однако файл WAL и &lt;a href=&quot;walformat#shm&quot;&gt;wal-index&lt;/a&gt; являются новыми концепциями, и поэтому более старые версии SQLite не знают, как восстановить базу данных SQLite, после которой произошел сбой, которая работала в режиме WAL, когда произошел сбой. Чтобы старые версии SQLite (до версии 3.7.0, 2010-07-22) не пытались восстановить базу данных в режиме WAL (что еще хуже), номера версий формата файлов базы данных (байты 18 и 19 в &lt;a href=&quot;fileformat2#database_header&quot;&gt;заголовке базы данных)&lt;/a&gt; ) увеличиваются с 1 до 2 в режиме WAL. Таким образом, если более старая версия SQLite попытается подключиться к базе данных SQLite, которая работает в режиме WAL, она сообщит об ошибке в строке &amp;laquo;файл зашифрован или не является базой данных&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="9c1329ad6c1d5d5a9b13da19601459b465ae67ba" translate="yes" xml:space="preserve">
          <source>The database file format is unchanged.</source>
          <target state="translated">Формат файла базы данных не изменился.</target>
        </trans-unit>
        <trans-unit id="1d07edfc3d0d439a4f2d02bad68d889bf985841b" translate="yes" xml:space="preserve">
          <source>The database file header</source>
          <target state="translated">Заголовок файла базы данных</target>
        </trans-unit>
        <trans-unit id="042540519692f217502c3ae945ec1187e2e057d0" translate="yes" xml:space="preserve">
          <source>The database file is synced to ensure that all updates are stored safely on the persistent media.</source>
          <target state="translated">Файл базы данных синхронизируется для обеспечения безопасного хранения всех обновлений на постоянном носителе.</target>
        </trans-unit>
        <trans-unit id="e23d0cd874d4749bf56cbe1f6d077df68f5dc7f5" translate="yes" xml:space="preserve">
          <source>The database file is unlocked.</source>
          <target state="translated">Файл базы данных разблокирован.</target>
        </trans-unit>
        <trans-unit id="0b3f3d4ba2117afe864ef2e2e3855b3dd6cb1ace" translate="yes" xml:space="preserve">
          <source>The database filename is not allowed to be a symbolic link</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f5b1b36f625c53227300ca5232e63d1f84ef897" translate="yes" xml:space="preserve">
          <source>The database for TEMP tables is not created until it is needed.</source>
          <target state="translated">База данных для таблиц TEMP не создается до тех пор,пока в ней нет необходимости.</target>
        </trans-unit>
        <trans-unit id="0bdbc9610964d617ffff9c05691c3e95d705203e" translate="yes" xml:space="preserve">
          <source>The database handle must not be in &lt;a href=&quot;#sqlite3_get_autocommit&quot;&gt;autocommit mode&lt;/a&gt;.</source>
          <target state="translated">Дескриптор базы данных не должен находиться в &lt;a href=&quot;#sqlite3_get_autocommit&quot;&gt;режиме автоматической фиксации&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="94abbac71c91061eed5db3642683f70b586a784a" translate="yes" xml:space="preserve">
          <source>The database handle must not be in &lt;a href=&quot;get_autocommit&quot;&gt;autocommit mode&lt;/a&gt;.</source>
          <target state="translated">Дескриптор базы данных не должен находиться в &lt;a href=&quot;get_autocommit&quot;&gt;режиме автоматической фиксации&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="915d44defd987e4d007442eec15de7482af138fa" translate="yes" xml:space="preserve">
          <source>The database in which the new table is created. Tables may be created in the main database, the temp database, or in any attached database.</source>
          <target state="translated">БД,в которой создается новая таблица.Таблицы могут создаваться в основной БД,временной БД или в любой присоединенной БД.</target>
        </trans-unit>
        <trans-unit id="f11c35a2d4a1cdd518b7cc45f596b046478c935a" translate="yes" xml:space="preserve">
          <source>The database is modified by the transaction</source>
          <target state="translated">База данных модифицируется транзакцией</target>
        </trans-unit>
        <trans-unit id="a60dcb2504ad2ca1f013e489bb243d5fba664847" translate="yes" xml:space="preserve">
          <source>The database is opened &lt;a href=&quot;../sharedcache&quot;&gt;shared cache&lt;/a&gt; disabled, overriding the default shared cache setting provided by &lt;a href=&quot;enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache()&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4eaa608858923b8628e324d3b5e39f5d6ac0b6e8" translate="yes" xml:space="preserve">
          <source>The database is opened &lt;a href=&quot;../sharedcache&quot;&gt;shared cache&lt;/a&gt; enabled, overriding the default shared cache setting provided by &lt;a href=&quot;enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache()&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="438e6e4f2464e93327c1c43679960b9033bba769" translate="yes" xml:space="preserve">
          <source>The database is opened &lt;a href=&quot;sharedcache&quot;&gt;shared cache&lt;/a&gt; disabled, overriding the default shared cache setting provided by &lt;a href=&quot;#sqlite3_enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache()&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2866aa5f974824c8ab6f079d70d8228fd2d735a8" translate="yes" xml:space="preserve">
          <source>The database is opened &lt;a href=&quot;sharedcache&quot;&gt;shared cache&lt;/a&gt; enabled, overriding the default shared cache setting provided by &lt;a href=&quot;#sqlite3_enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache()&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ca1bec50c05a4f92423e17a029876db2e2195fa" translate="yes" xml:space="preserve">
          <source>The database is opened for reading and writing if possible, or reading only if the file is write protected by the operating system. In either case the database must already exist, otherwise an error is returned.</source>
          <target state="translated">БД по возможности открывается на чтение и запись или на чтение только в том случае,если файл защищен операционной системой от записи.В любом случае банк данных должен уже существовать,в противном случае возвращается ошибка.</target>
        </trans-unit>
        <trans-unit id="9bd4a4b6de8565a3e1cf815b4bc5b9706070cf17" translate="yes" xml:space="preserve">
          <source>The database is opened for reading and writing, and is created if it does not already exist. This is the behavior that is always used for sqlite3_open() and sqlite3_open16().</source>
          <target state="translated">База данных открыта для чтения и записи и создается,если ее еще нет.Именно такое поведение всегда используется для sqlite3_open()и sqlite3_open16().</target>
        </trans-unit>
        <trans-unit id="e33053c4558a1f3729067b3cae6e30d0b922d25b" translate="yes" xml:space="preserve">
          <source>The database is opened in read-only mode. If the database does not already exist, an error is returned.</source>
          <target state="translated">База данных открывается в режиме только для чтения.Если БД еще не существует,возвращается ошибка.</target>
        </trans-unit>
        <trans-unit id="c36f905350b3694fef2e907f7076bd6c0eb07bcf" translate="yes" xml:space="preserve">
          <source>The database may be read but not written. Any number of processes can hold SHARED locks at the same time, hence there can be many simultaneous readers. But no other thread or process is allowed to write to the database file while one or more SHARED locks are active.</source>
          <target state="translated">База данных может быть прочитана,но не записана.Любое количество процессов может содержать одновременно замки SHARED,следовательно,может быть много одновременных считывателей.Но никакому другому потоку или процессу не разрешается записывать в файл базы данных,пока один или несколько замков SHARED активны.</target>
        </trans-unit>
        <trans-unit id="2cc9e66b5c02e09e5ad16f7b64822b0c58495bb9" translate="yes" xml:space="preserve">
          <source>The database page size in bytes, or 1 if the page size is 65536.</source>
          <target state="translated">Размер страницы базы данных в байтах или 1,если размер страницы 65536.</target>
        </trans-unit>
        <trans-unit id="8a5fb001456adc96d15706d6924ffd2f301ed99f" translate="yes" xml:space="preserve">
          <source>The database page size in bytes. Must be a power of two between 512 and 32768 inclusive, or the value 1 representing a page size of 65536.</source>
          <target state="translated">Размер страницы базы данных в байтах.Должно быть два значения мощности между 512 и 32768 включительно,или значение 1,представляющее размер страницы 65536.</target>
        </trans-unit>
        <trans-unit id="960363c84d760f550ea9fae647b23fad91849f93" translate="yes" xml:space="preserve">
          <source>The database schema (in the &lt;a href=&quot;fileformat2#sqlite_master&quot;&gt;sqlite_master&lt;/a&gt; table) is not normally included in the hash, but can be added by the &quot;--schema&quot; option.</source>
          <target state="translated">Схема базы данных (в таблице &lt;a href=&quot;fileformat2#sqlite_master&quot;&gt;sqlite_master&lt;/a&gt; ) обычно не включается в хэш, но может быть добавлена ​​с помощью параметра &amp;laquo;--schema&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="14a6eadb07a326767237571a6c459f7de69f6f90" translate="yes" xml:space="preserve">
          <source>The database schema (in the &lt;a href=&quot;schematab&quot;&gt;sqlite_schema&lt;/a&gt; table) is not normally included in the hash, but can be added by the &quot;--schema&quot; option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8594a821095f6391744d60f5433b9311564cee65" translate="yes" xml:space="preserve">
          <source>The database text encoding. A value of 1 means UTF-8. A value of 2 means UTF-16le. A value of 3 means UTF-16be.</source>
          <target state="translated">Текстовая кодировка базы данных.Значение 1 означает UTF-8.Значение 2 означает UTF-16le.Значение 3 означает UTF-16be.</target>
        </trans-unit>
        <trans-unit id="e0c8f6d94e8860f110aff3d0dcf3dec439a12ec1" translate="yes" xml:space="preserve">
          <source>The database will be opened as an in-memory database. The database is named by the &quot;filename&quot; argument for the purposes of cache-sharing, if shared cache mode is enabled, but the &quot;filename&quot; is otherwise ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d24a19630de1f62dd0aa22d7bd05ac2f4445ed6a" translate="yes" xml:space="preserve">
          <source>The datatype and &lt;a href=&quot;datatype3#collation&quot;&gt;collating sequence&lt;/a&gt; of the generated column are determined only by the datatype and &lt;a href=&quot;lang_createtable#collateclause&quot;&gt;COLLATE clause&lt;/a&gt; on the column definition. The datatype and collating sequence of the GENERATED ALWAYS AS expression have no affect on the datatype and collating sequence of the column itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8474bd3b47622066afeb4b46c5b6be93034d3e7c" translate="yes" xml:space="preserve">
          <source>The datatype of columns now appear in the 4th argument to the callback.</source>
          <target state="translated">Типы данных столбцов теперь появляются в 4-м аргументе к обратному вызову.</target>
        </trans-unit>
        <trans-unit id="aa9bbe0be9ce7cff21329528d0726ee0baa77cf6" translate="yes" xml:space="preserve">
          <source>The date and time functions use a subset of &lt;a href=&quot;http://en.wikipedia.org/wiki/ISO_8601&quot;&gt;IS0-8601&lt;/a&gt; date and time formats. The date() function returns the date in this format: YYYY-MM-DD. The time() function returns the time as HH:MM:SS. The datetime() function returns &quot;YYYY-MM-DD HH:MM:SS&quot;. The julianday() function returns the &lt;a href=&quot;http://en.wikipedia.org/wiki/Julian_day&quot;&gt;Julian day&lt;/a&gt; - the number of days since noon in Greenwich on November 24, 4714 B.C. (&lt;a href=&quot;http://en.wikipedia.org/wiki/Proleptic_Gregorian_calendar&quot;&gt;Proleptic Gregorian calendar&lt;/a&gt;). The strftime() routine returns the date formatted according to the format string specified as the first argument. The format string supports the most common substitutions found in the &lt;a href=&quot;http://opengroup.org/onlinepubs/007908799/xsh/strftime.html&quot;&gt;strftime() function&lt;/a&gt; from the standard C library plus two new substitutions, %f and %J. The following is a complete list of valid strftime() substitutions:</source>
          <target state="translated">Функции даты и времени используют подмножество &lt;a href=&quot;http://en.wikipedia.org/wiki/ISO_8601&quot;&gt;форматов&lt;/a&gt; даты и времени IS0-8601 . Функция date () возвращает дату в следующем формате: ГГГГ-ММ-ДД. Функция time () возвращает время в формате ЧЧ: ММ: СС. Функция datetime () возвращает &amp;laquo;ГГГГ-ММ-ДД ЧЧ: ММ: СС&amp;raquo;. Функция julianday () возвращает &lt;a href=&quot;http://en.wikipedia.org/wiki/Julian_day&quot;&gt;юлианский день&lt;/a&gt; - количество дней с полудня по Гринвичу 24 ноября 4714 г. до н.э. ( &lt;a href=&quot;http://en.wikipedia.org/wiki/Proleptic_Gregorian_calendar&quot;&gt;пролептический григорианский календарь&lt;/a&gt; ). Подпрограмма strftime () возвращает дату, отформатированную в соответствии со строкой формата, указанной в качестве первого аргумента. Строка формата поддерживает наиболее распространенные замены, найденные в функции &lt;a href=&quot;http://opengroup.org/onlinepubs/007908799/xsh/strftime.html&quot;&gt;strftime ()&lt;/a&gt; из стандартной библиотеки C, плюс две новые замены,% f и% J. Ниже приведен полный список допустимых замен strftime ():</target>
        </trans-unit>
        <trans-unit id="c572eaac3cc998a669390ba9b1ca1c2cef313090" translate="yes" xml:space="preserve">
          <source>The date and time functions use a subset of &lt;a href=&quot;https://en.wikipedia.org/wiki/ISO_8601&quot;&gt;IS0-8601&lt;/a&gt; date and time formats. The date() function returns the date in this format: YYYY-MM-DD. The time() function returns the time as HH:MM:SS. The datetime() function returns &quot;YYYY-MM-DD HH:MM:SS&quot;. The julianday() function returns the &lt;a href=&quot;https://en.wikipedia.org/wiki/Julian_day&quot;&gt;Julian day&lt;/a&gt; - the number of days since noon in Greenwich on November 24, 4714 B.C. (&lt;a href=&quot;https://en.wikipedia.org/wiki/Proleptic_Gregorian_calendar&quot;&gt;Proleptic Gregorian calendar&lt;/a&gt;). The strftime() routine returns the date formatted according to the format string specified as the first argument. The format string supports the most common substitutions found in the &lt;a href=&quot;https://opengroup.org/onlinepubs/007908799/xsh/strftime.html&quot;&gt;strftime() function&lt;/a&gt; from the standard C library plus two new substitutions, %f and %J. The following is a complete list of valid strftime() substitutions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41f51b9af9bc71b6bb1cc99119d6849c39b622ad" translate="yes" xml:space="preserve">
          <source>The db parameter is a pointer to the SQLite &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; that is executing the &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; statement. The pAux argument is the copy of the client data pointer that was the fourth argument to the &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module()&lt;/a&gt; or &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module_v2()&lt;/a&gt; call that registered the &lt;a href=&quot;c3ref/module&quot;&gt;virtual table module&lt;/a&gt;. The argv parameter is an array of argc pointers to null terminated strings. The first string, argv[0], is the name of the module being invoked. The module name is the name provided as the second argument to &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module()&lt;/a&gt; and as the argument to the USING clause of the &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; statement that is running. The second, argv[1], is the name of the database in which the new virtual table is being created. The database name is &quot;main&quot; for the primary database, or &quot;temp&quot; for TEMP database, or the name given at the end of the &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; statement for attached databases. The third element of the array, argv[2], is the name of the new virtual table, as specified following the TABLE keyword in the &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; statement. If present, the fourth and subsequent strings in the argv[] array report the arguments to the module name in the &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; statement.</source>
          <target state="translated">Параметр db - это указатель на соединение с &lt;a href=&quot;c3ref/sqlite3&quot;&gt;базой данных&lt;/a&gt; SQLite , которое выполняет оператор &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; . Аргумент pAux - это копия указателя данных клиента, который был четвертым аргументом для вызова &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module ()&lt;/a&gt; или &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module_v2 (),&lt;/a&gt; который зарегистрировал &lt;a href=&quot;c3ref/module&quot;&gt;модуль виртуальной таблицы&lt;/a&gt; . Параметр argv - это массив указателей argc на строки с завершающим нулем. Первая строка argv [0] - это имя вызываемого модуля. Имя модуля - это имя, указанное в качестве второго аргумента &lt;a href=&quot;c3ref/create_module&quot;&gt;функции sqlite3_create_module ()&lt;/a&gt; и в качестве аргумента предложения USING в &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt;заявление, которое выполняется. Второй, argv [1], - это имя базы данных, в которой создается новая виртуальная таблица. Имя базы данных - &amp;laquo;main&amp;raquo; для первичной базы данных или &amp;laquo;temp&amp;raquo; для базы данных TEMP, или имя, указанное в конце оператора &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; для присоединенных баз данных. Третий элемент массива, argv [2], - это имя новой виртуальной таблицы, как указано после ключевого слова &lt;a href=&quot;lang_createvtab&quot;&gt;TABLE в&lt;/a&gt; операторе CREATE VIRTUAL TABLE . Если присутствует, четвертая и последующие строки в массиве argv [] сообщают аргументы имени модуля в операторе &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f728f7217f7fc88bd0e8e8228a6a594400b21afc" translate="yes" xml:space="preserve">
          <source>The dbhash program is implemented by a single file of C-code called &lt;a href=&quot;https://www.sqlite.org/src/artifact?ci=trunk&amp;amp;filename=tool/dbhash.c&quot;&gt;dbhash.c&lt;/a&gt;. To build the dbhash program manually, simply compile the dbhash.c source file and link it against the SQLite library.</source>
          <target state="translated">Программа dbhash реализуется одним файлом C-кода, который называется &lt;a href=&quot;https://www.sqlite.org/src/artifact?ci=trunk&amp;amp;filename=tool/dbhash.c&quot;&gt;dbhash.c&lt;/a&gt; . Чтобы собрать программу dbhash вручную, просто скомпилируйте исходный файл dbhash.c и свяжите его с библиотекой SQLite.</target>
        </trans-unit>
        <trans-unit id="b16703d23a9ca6a2a8cb4ca235cc87a944a6dff5" translate="yes" xml:space="preserve">
          <source>The dbhash.exe Utility Program</source>
          <target state="translated">Полезная программа dbhash.exe.</target>
        </trans-unit>
        <trans-unit id="825612a3619e0d061fa775e13b4301fdfc5c4d06" translate="yes" xml:space="preserve">
          <source>The dbsqlfuzz fuzzer has been so successful at hardening the SQLite code base against malicious attack that it is now considered one of the four primary test harnesses for SQLite.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce23c499eac5efbdaf2dbb036cb7b2ac9a155ffe" translate="yes" xml:space="preserve">
          <source>The dbsqlfuzz fuzzer mutates both the SQL input and the database file at the same time. Dbsqlfuzz uses a custom &lt;a href=&quot;https://github.com/google/fuzzer-test-suite/blob/master/tutorial/structure-aware-fuzzing.md&quot;&gt;Structure-Aware Mutator&lt;/a&gt; on a specialized input file that defines both an input database and SQL text to be run against that database. Because it mutates both the input database and the input SQL at the same time, dbsqlfuzz has been able to find some obscure faults in SQLite that were missed by prior fuzzers that mutated only SQL inputs or only the database file.</source>
          <target state="translated">Фаззер dbsqlfuzz изменяет одновременно входные данные SQL и файл базы данных. Dbsqlfuzz использует настраиваемый &lt;a href=&quot;https://github.com/google/fuzzer-test-suite/blob/master/tutorial/structure-aware-fuzzing.md&quot;&gt;мутатор&lt;/a&gt; с учетом структуры в специализированном входном файле, который определяет как входную базу данных, так и текст SQL, который будет запускаться в этой базе данных. Поскольку он изменяет и входную базу данных, и входной SQL одновременно, dbsqlfuzz смогла найти некоторые неясные ошибки в SQLite, которые были пропущены предыдущими фаззерами, которые мутировали только входные данные SQL или только файл базы данных.</target>
        </trans-unit>
        <trans-unit id="e0f01bd5981d7e05e25eea466d94ddbb29381d04" translate="yes" xml:space="preserve">
          <source>The dbsqlfuzz fuzzer mutates both the SQL input and the database file at the same time. Dbsqlfuzz uses a custom &lt;a href=&quot;https://github.com/google/fuzzer-test-suite/blob/master/tutorial/structure-aware-fuzzing.md&quot;&gt;Structure-Aware Mutator&lt;/a&gt; on a specialized input file that defines both an input database and SQL text to be run against that database. Because it mutates both the input database and the input SQL at the same time, dbsqlfuzz has been able to find some obscure faults in SQLite that were missed by prior fuzzers that mutated only SQL inputs or only the database file. The SQLite developers usually leave an instance or two of dbsqlfuzz running on the latest trunk code of SQLite whenever they are away from the office for an extended period, such as overnight.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bae73cc22154360311af38fab160d5138d312f9" translate="yes" xml:space="preserve">
          <source>The dbstat virtual table is an &lt;a href=&quot;vtab#epovtab&quot;&gt;eponymous virtual table&lt;/a&gt;, meaning that is not necessary to run &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; to create an instance of the dbstat virtual table before using it. The &quot;dbstat&quot; module name can be used as if it were a table name to query the dbstat virtual table directly. For example:</source>
          <target state="translated">Виртуальная таблица dbstat - это &lt;a href=&quot;vtab#epovtab&quot;&gt;одноименная виртуальная таблица&lt;/a&gt; , что означает, что нет необходимости запускать &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; для создания экземпляра виртуальной таблицы dbstat перед ее использованием. Имя модуля &amp;laquo;dbstat&amp;raquo; можно использовать, как если бы это было имя таблицы, для непосредственного запроса виртуальной таблицы dbstat. Например:</target>
        </trans-unit>
        <trans-unit id="e223099b7354d29f8974670689fc48600a955fe9" translate="yes" xml:space="preserve">
          <source>The decimal extension is not (currently) part of the SQLite &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt;. However, it is included in the &lt;a href=&quot;cli&quot;&gt;CLI&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf449afd5954b4d824e05da84c86a3c14eb17489" translate="yes" xml:space="preserve">
          <source>The decimal extension provides arbitrary-precision decimal arithmetic on numbers stored as text strings. Because the numbers are stored to arbitrary precision and as text, no approximations are needed. Computations can be done exactly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e61a5a7c6ccc546025a4d388dfa7ed2605e38bb" translate="yes" xml:space="preserve">
          <source>The decimal_sum(X) function is an aggregate, like the built-in &lt;a href=&quot;lang_aggfunc#sumunc&quot;&gt;sum() aggregate function&lt;/a&gt;, except that decimal_sum() computes its result to arbitrary precision and is therefore precise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efcc1572318b12d880dcf6c5ba6e48d567425a65" translate="yes" xml:space="preserve">
          <source>The decision of whether to implement a FROM-clause subquery as a co-routine or using &lt;a href=&quot;optoverview#flattening&quot;&gt;query flattening&lt;/a&gt; now considers whether the result set of the outer query is &quot;complex&quot; (if it contains functions or expression subqueries). A complex result set biases the decision toward the use of co-routines.</source>
          <target state="translated">Решение о том, реализовать ли подзапрос FROM-clause как сопрограмму или использовать &lt;a href=&quot;optoverview#flattening&quot;&gt;сглаживание запросов,&lt;/a&gt; теперь учитывает, является ли набор результатов внешнего запроса &amp;laquo;сложным&amp;raquo; (если он содержит функции или подзапросы выражений). Сложный набор результатов смещает решение в пользу использования совместных процедур.</target>
        </trans-unit>
        <trans-unit id="ab20325df0acc9b2aa5397a0a5067782536af164" translate="yes" xml:space="preserve">
          <source>The decision of which collating sequence to use is controlled by the COLLATE clause in SQL. A COLLATE clause can occur on a table definition, to define a default collating sequence to a table column, or on field of an index, or in the ORDER BY clause of a SELECT statement. Planned enhancements to SQLite are to include standard CAST() syntax to allow the collating sequence of an expression to be defined.</source>
          <target state="translated">Решение о том,какую коллекционную последовательность использовать,контролируется в SQL с помощью выражения COLLATE.Оговорка COLLATE может встречаться в определении таблицы,в определении коллизионной последовательности по умолчанию к столбцу таблицы,или к полю индекса,или в пункте ORDER BY оператора SELECT.Планируемые усовершенствования SQLite включают стандартный синтаксис CAST(),позволяющий определять коллекционную последовательность выражения.</target>
        </trans-unit>
        <trans-unit id="18e04830dfd2e28b2697cd44ccf76543eadbcceb" translate="yes" xml:space="preserve">
          <source>The declared type of each column in the table.</source>
          <target state="translated">Объявленный тип каждого столбца таблицы.</target>
        </trans-unit>
        <trans-unit id="68032822fa262cd72f80461a11d217079b712edb" translate="yes" xml:space="preserve">
          <source>The default 'crisismerge' value is 16. There is no maximum limit. Attempting to set the 'crisismerge' parameter to a value of 0 or 1 is equivalent to setting it to the default value (16). It is an error to attempt to set the 'crisismerge' option to a negative value.</source>
          <target state="translated">По умолчанию значение 'crisismerge' равно 16.Максимального предела нет.Попытка установить параметр 'crisismerge' на значение 0 или 1 эквивалентна установке его на значение по умолчанию (16).Ошибкой является попытка установить опцию 'crisismerge' в отрицательное значение.</target>
        </trans-unit>
        <trans-unit id="04fcbed48c760da194eb2fb040297255b4fffa15" translate="yes" xml:space="preserve">
          <source>The default &lt;a href=&quot;fileformat2#schemaformat&quot;&gt;schema format number&lt;/a&gt; is changed from 1 to 4. This means that, unless the &lt;a href=&quot;pragma#pragma_legacy_file_format&quot;&gt;PRAGMA legacy_file_format=ON&lt;/a&gt; statement is run, newly created database files will be unreadable by version of SQLite prior to 3.3.0 (2006-01-10). It also means that the &lt;a href=&quot;lang_createindex#descidx&quot;&gt;descending indices&lt;/a&gt; are enabled by default.</source>
          <target state="translated">Номер &lt;a href=&quot;fileformat2#schemaformat&quot;&gt;формата схемы по&lt;/a&gt; умолчанию изменен с 1 на 4. Это означает, что, если не будет &lt;a href=&quot;pragma#pragma_legacy_file_format&quot;&gt;запущен оператор PRAGMA legacy_file_format = ON&lt;/a&gt; , вновь созданные файлы базы данных будут нечитаемыми для версий SQLite до 3.3.0 (2006-01-10). Это также означает, что по умолчанию включены &lt;a href=&quot;lang_createindex#descidx&quot;&gt;нисходящие индексы&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b8d41b5a0a8527b81ce581d5cb059a7a0ef7283f" translate="yes" xml:space="preserve">
          <source>The default &lt;a href=&quot;fileformat2#schemaformat&quot;&gt;schema format number&lt;/a&gt; used by SQLite when creating new database files is set by this macro. The schema formats are all very similar. The difference between formats 1 and 4 is that format 4 understands &lt;a href=&quot;lang_createindex#descidx&quot;&gt;descending indices&lt;/a&gt; and has a tighter encoding for boolean values.</source>
          <target state="translated">Этот макрос устанавливает &lt;a href=&quot;fileformat2#schemaformat&quot;&gt;номер формата схемы по&lt;/a&gt; умолчанию , используемый SQLite при создании новых файлов базы данных. Форматы схемы очень похожи. Разница между форматами 1 и 4 заключается в том, что формат 4 понимает &lt;a href=&quot;lang_createindex#descidx&quot;&gt;убывающие индексы&lt;/a&gt; и имеет более жесткую кодировку для логических значений.</target>
        </trans-unit>
        <trans-unit id="ca0921362c7fa29bf8c96529653cba6ff2aa4225" translate="yes" xml:space="preserve">
          <source>The default MASK is and always shall be 0xfffe. The 0xfffe mask means perform all of the optimizations listed above except Debug Mode. If new optimizations are added in the future that should be off by default, those new optimizations will be given a mask of 0x10000 or larger.</source>
          <target state="translated">МАСКА по умолчанию является и всегда должна быть 0xfffe.Маска 0xfffe означает выполнение всех оптимизаций,перечисленных выше,за исключением Debug Mode.Если в будущем будут добавлены новые оптимизации,которые должны быть выключены по умолчанию,то этим новым оптимизациям будет дана маска 0x10000 или больше.</target>
        </trans-unit>
        <trans-unit id="a903124a6abce3d6d4d4bbe7f6d1f8b599823062" translate="yes" xml:space="preserve">
          <source>The default VFS can be changed by registering or re-registering the VFS using the &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register()&lt;/a&gt; interface with a second parameter of 1. Hence, if a (unix) process wants to always use the &quot;unix-nolock&quot; VFS in place of &quot;unix&quot;, the following code would work:</source>
          <target state="translated">VFS по умолчанию можно изменить путем регистрации или перерегистрации VFS с использованием интерфейса &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register ()&lt;/a&gt; со вторым параметром 1. Следовательно, если процесс (unix) хочет всегда использовать VFS &amp;laquo;unix-nolock&amp;raquo; вместо &amp;laquo; unix &quot;, будет работать следующий код:</target>
        </trans-unit>
        <trans-unit id="c5a51f22fb2e29520e6fcdc862dfe6400d4b2d95" translate="yes" xml:space="preserve">
          <source>The default behavior for a loadable extension is that it is unloaded from process memory when the database connection that originally invoked &lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension()&lt;/a&gt; closes. (In other words, the xDlUnload method of the &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object is called for all extensions when a database connection closes.) However, if the initialization procedure returns &lt;a href=&quot;rescode#ok_load_permanently&quot;&gt;SQLITE_OK_LOAD_PERMANENTLY&lt;/a&gt; instead of SQLITE_OK, then the extension will not be unloaded (xDlClose will not be invoked) and the extension will remain in process memory indefinitely. The SQLITE_OK_LOAD_PERMANENTLY return value is useful for extensions that want to register new &lt;a href=&quot;vfs&quot;&gt;VFSes&lt;/a&gt;.</source>
          <target state="translated">Поведение по умолчанию для загружаемого расширения заключается в том, что оно выгружается из памяти процесса при закрытии соединения с базой данных, которое изначально вызывало &lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension ()&lt;/a&gt; . (Другими словами, метод xDlUnload объекта &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; вызывается для всех расширений при закрытии соединения с базой данных.) Однако, если процедура инициализации возвращает &lt;a href=&quot;rescode#ok_load_permanently&quot;&gt;SQLITE_OK_LOAD_PERMANENTLY&lt;/a&gt; вместо SQLITE_OK, то расширение не будет выгружено (xDlClose не будет вызываться) и расширение останется в памяти процесса на неопределенный срок. Возвращаемое значение SQLITE_OK_LOAD_PERMANENTLY полезно для расширений, которые хотят зарегистрировать новые &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="35fa7584b655adc25cbf99cb25271bb088b3504f" translate="yes" xml:space="preserve">
          <source>The default behavior gives this results:</source>
          <target state="translated">Поведение по умолчанию дает такой результат:</target>
        </trans-unit>
        <trans-unit id="929789505d4e7daeec8d95f7bd37c902d7905d6b" translate="yes" xml:space="preserve">
          <source>The default behavior of assert(X) in standard C is that it is enabled for release builds. This is a reasonable default. However, the SQLite code base has many assert() statements in performance-sensitive areas of the code. Leaving assert(X) turned on causes SQLite to run about three times slower. Also, SQLite strives to provide 100% MC/DC in an as-delivered configuration, which is obviously impossible if assert(X) statements are enabled. For these reasons, assert(X) is a no-op for release builds in SQLite.</source>
          <target state="translated">Поведение по умолчанию assert(X)в стандартном C заключается в том,что он включен для сборки релизов.Это разумное значение по умолчанию.Тем не менее,в коде SQLite есть много операторов assert()в чувствительных к производительности областях кода.Если оставить assert(X)включенным,то SQLite будет работать примерно в три раза медленнее.Кроме того,SQLite стремится предоставлять 100% MC/DC в конфигурации как доставка,что очевидно невозможно,если операторы assert(X)включены.По этим причинам утверждение assert(X)не является опцией для сборки релизов в SQLite.</target>
        </trans-unit>
        <trans-unit id="d9b3b8cc178a304f2169b7fe7ac799ae14ab4502" translate="yes" xml:space="preserve">
          <source>The default behavior of the &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; operator is to ignore case for ASCII characters. Hence, by default &lt;b&gt;'a' LIKE 'A'&lt;/b&gt; is true. The case_sensitive_like pragma installs a new application-defined LIKE function that is either case sensitive or insensitive depending on the value of the case_sensitive_like pragma. When case_sensitive_like is disabled, the default LIKE behavior is expressed. When case_sensitive_like is enabled, case becomes significant. So, for example, &lt;b&gt;'a' LIKE 'A'&lt;/b&gt; is false but &lt;b&gt;'a' LIKE 'a'&lt;/b&gt; is still true.</source>
          <target state="translated">По умолчанию оператор &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; игнорирует регистр символов ASCII. Следовательно, по умолчанию &lt;b&gt;&amp;laquo;A&amp;raquo; LIKE &amp;laquo;A&amp;raquo;&lt;/b&gt; истинно. Прагма case_sensitive_like устанавливает новую определяемую приложением функцию LIKE, которая либо чувствительна к регистру, либо нечувствительна к регистру в зависимости от значения прагмы case_sensitive_like. Когда case_sensitive_like отключен, выражается поведение LIKE по умолчанию. Когда case_sensitive_like включен, регистр становится значимым. Так, например, &lt;b&gt;'a' LIKE 'A'&lt;/b&gt; ложно, но &lt;b&gt;'a' LIKE 'a'&lt;/b&gt; по-прежнему верно.</target>
        </trans-unit>
        <trans-unit id="9edad614da3d9aaf086c0a5c5b068d92a4f96481" translate="yes" xml:space="preserve">
          <source>The default builds for SQLite on Unix, Windows, and OS/2 include a VFS appropriate for the target platform. SQLite builds for other operating systems do not contain a VFS by default, but the application can register one or more at run-time.</source>
          <target state="translated">Стандартные сборки для SQLite на Unix,Windows и OS/2 включают VFS,подходящую для целевой платформы.По умолчанию сборки SQLite для других операционных систем не содержат VFS,но приложение может зарегистрировать одну или более сборок во время выполнения.</target>
        </trans-unit>
        <trans-unit id="6a78f3c92a0ec476b159128dcf1aca02c9237966" translate="yes" xml:space="preserve">
          <source>The default busy callback is NULL.</source>
          <target state="translated">Обратный звонок по умолчанию занят NULL.</target>
        </trans-unit>
        <trans-unit id="a139fc5b0808f70ee2866da438ce9a4197bf896c" translate="yes" xml:space="preserve">
          <source>The default collating function for all strings is BINARY. Alternative collating functions for table columns can be specified in the &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; statement using the COLLATE clause on the &lt;a href=&quot;lang_createtable#tablecoldef&quot;&gt;column definition&lt;/a&gt;. When a column is indexed, the same collating function specified in the &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; statement is used for the column in the index, by default, though this can be overridden using a COLLATE clause in the &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt; statement.</source>
          <target state="translated">Функция сортировки по умолчанию для всех строк - ДВОИЧНАЯ. Альтернативные функции сортировки для столбцов таблицы могут быть указаны в операторе &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; с помощью предложения COLLATE в &lt;a href=&quot;lang_createtable#tablecoldef&quot;&gt;определении столбца&lt;/a&gt; . Когда столбец индексируется, та же функция сортировки, которая указана в операторе &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE,&lt;/a&gt; используется для столбца в индексе по умолчанию, хотя это можно переопределить с помощью предложения COLLATE в операторе &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4196a7b520d0708c2ca6c2f0dd09284b39f44638" translate="yes" xml:space="preserve">
          <source>The default configuration for SQLite works great for most applications. But sometimes developers want to tweak the setup to try to squeeze out a little more performance, or take advantage of some obscure feature.</source>
          <target state="translated">Конфигурация по умолчанию для SQLite отлично работает для большинства приложений.Но иногда разработчикам хочется настроить конфигурацию так,чтобы попытаться выжать немного больше производительности,или воспользоваться какой-нибудь непонятной особенностью.</target>
        </trans-unit>
        <trans-unit id="7f629fe0c846fce25506268b75e0f95dc1a4e2cd" translate="yes" xml:space="preserve">
          <source>The default configuration of SQLite assumes the underlying filesystem supports long filenames.</source>
          <target state="translated">Конфигурация SQLite по умолчанию предполагает,что базовая файловая система поддерживает длинные имена файлов.</target>
        </trans-unit>
        <trans-unit id="f9ca0f7d70101ac90e64f7de1b18481b2e2650e6" translate="yes" xml:space="preserve">
          <source>The default configuration of SQLite only supports case-insensitive comparisons of ASCII characters. The reason for this is that doing full Unicode case-insensitive comparisons and case conversions requires tables and logic that would nearly double the size of the SQLite library. The SQLite developers reason that any application that needs full Unicode case support probably already has the necessary tables and functions and so SQLite should not take up space to duplicate this ability.</source>
          <target state="translated">Конфигурация SQLite по умолчанию поддерживает только регистронезависимые сравнения ASCII-символов.Причина этого заключается в том,что для проведения полных юникодовых нечувствительных к регистру сравнений и регистро-преобразований требуются таблицы и логика,которая почти в два раза больше,чем у библиотеки SQLite.Разработчики SQLite объясняют это тем,что любое приложение,которое нуждается в полной поддержке Unicode case,вероятно,уже имеет необходимые таблицы и функции,и поэтому SQLite не должен занимать место для дублирования этой возможности.</target>
        </trans-unit>
        <trans-unit id="c23763d0cb18af4da83857106ae71fb287c36d2b" translate="yes" xml:space="preserve">
          <source>The default datatype is 'int32'.</source>
          <target state="translated">По умолчанию используется тип данных 'int32'.</target>
        </trans-unit>
        <trans-unit id="57ca93f20ecfcb67f54da8e6ff374c396f410f8d" translate="yes" xml:space="preserve">
          <source>The default deletion cost</source>
          <target state="translated">Стоимость удаления по умолчанию</target>
        </trans-unit>
        <trans-unit id="348ca4d833d68a6b457e44e2f51c5dde36928e20" translate="yes" xml:space="preserve">
          <source>The default directory for temporary files depends on the OS. Some OS interfaces may choose to ignore this variable and place temporary files in some other directory different from the directory specified here. In that sense, this pragma is only advisory.</source>
          <target state="translated">Каталог временных файлов по умолчанию зависит от операционной системы.Некоторые интерфейсы ОС могут игнорировать эту переменную и помещать временные файлы в другую директорию,отличную от указанной здесь.В этом смысле данная прагма является только рекомендательной.</target>
        </trans-unit>
        <trans-unit id="09a19fe31cacf32f0a49986af2b636abaafd7a24" translate="yes" xml:space="preserve">
          <source>The default encoding will be UTF-8 for databases created using sqlite3_open() or sqlite3_open_v2(). The default encoding for databases created using sqlite3_open16() will be UTF-16 in the native byte order.</source>
          <target state="translated">Для баз данных,созданных с помощью sqlite3_open()или sqlite3_open_v2(),кодировкой по умолчанию будет UTF-8.Для баз данных,созданных с помощью sqlite3_open16(),кодировкой по умолчанию будет UTF-16 в родном порядке байт.</target>
        </trans-unit>
        <trans-unit id="93b91496e8c579b792f6528c1582f57d8e5307a9" translate="yes" xml:space="preserve">
          <source>The default file format is now 1.</source>
          <target state="translated">Формат файла по умолчанию теперь 1.</target>
        </trans-unit>
        <trans-unit id="07f52e2687ee82b720aa1390843c77644fb57108" translate="yes" xml:space="preserve">
          <source>The default file format is set by the &lt;a href=&quot;compile#default_file_format&quot;&gt;SQLITE_DEFAULT_FILE_FORMAT&lt;/a&gt; compile-time option.</source>
          <target state="translated">Формат файла по умолчанию устанавливается параметром &lt;a href=&quot;compile#default_file_format&quot;&gt;времени&lt;/a&gt; компиляции SQLITE_DEFAULT_FILE_FORMAT .</target>
        </trans-unit>
        <trans-unit id="cc414446f05fe3ef5190b22cd556bce2036d0102" translate="yes" xml:space="preserve">
          <source>The default frame-spec is:</source>
          <target state="translated">По умолчанию это фрейм-spec:</target>
        </trans-unit>
        <trans-unit id="c9df385f1bced3c35670bbdf7a0e4f5a1cfdb4ca" translate="yes" xml:space="preserve">
          <source>The default implementation stores all statistics in a single table named &quot;&lt;a href=&quot;fileformat2#stat1tab&quot;&gt;sqlite_stat1&lt;/a&gt;&quot;. If SQLite is compiled with the &lt;a href=&quot;compile#enable_stat3&quot;&gt;SQLITE_ENABLE_STAT3&lt;/a&gt; option and without the &lt;a href=&quot;compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt; option, then additional histogram data is collected and stored in &lt;a href=&quot;fileformat2#stat3tab&quot;&gt;sqlite_stat3&lt;/a&gt;. If SQLite is compiled with the &lt;a href=&quot;compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt; option, then additional histogram data is collected and stored in &lt;a href=&quot;fileformat2#stat4tab&quot;&gt;sqlite_stat4&lt;/a&gt;. Older versions of SQLite would make use of the &lt;a href=&quot;fileformat2#stat2tab&quot;&gt;sqlite_stat2&lt;/a&gt; table when compiled with &lt;a href=&quot;compile#enable_stat2&quot;&gt;SQLITE_ENABLE_STAT2&lt;/a&gt; but all recent versions of SQLite ignore the sqlite_stat2 table. Future enhancements may create additional &lt;a href=&quot;fileformat2#intschema&quot;&gt;internal tables&lt;/a&gt; with the same name pattern except with final digit larger than &quot;4&quot;. All of these tables are collectively referred to as &quot;statistics tables&quot;.</source>
          <target state="translated">Реализация по умолчанию хранит всю статистику в одной таблице с именем &amp;laquo; &lt;a href=&quot;fileformat2#stat1tab&quot;&gt;sqlite_stat1&lt;/a&gt; &amp;raquo;. Если SQLite скомпилирован с параметром &lt;a href=&quot;compile#enable_stat3&quot;&gt;SQLITE_ENABLE_STAT3&lt;/a&gt; и без параметра &lt;a href=&quot;compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt; , то дополнительные данные гистограммы собираются и сохраняются в &lt;a href=&quot;fileformat2#stat3tab&quot;&gt;sqlite_stat3&lt;/a&gt; . Если SQLite скомпилирован с опцией &lt;a href=&quot;compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt; , то дополнительные данные гистограммы собираются и сохраняются в &lt;a href=&quot;fileformat2#stat4tab&quot;&gt;sqlite_stat4&lt;/a&gt; . Более старые версии SQLite использовали &lt;a href=&quot;fileformat2#stat2tab&quot;&gt;бы&lt;/a&gt; таблицу sqlite_stat2 при компиляции с &lt;a href=&quot;compile#enable_stat2&quot;&gt;SQLITE_ENABLE_STAT2,&lt;/a&gt; но все последние версии SQLite игнорируют таблицу sqlite_stat2. Будущие улучшения могут создать дополнительные &lt;a href=&quot;fileformat2#intschema&quot;&gt;внутренние таблицы&lt;/a&gt;с тем же шаблоном имени, за исключением последней цифры больше &quot;4&quot;. Все эти таблицы вместе называются &amp;laquo;таблицами статистики&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="2000f471d1e2f9fad888fbe96454c85325906ea0" translate="yes" xml:space="preserve">
          <source>The default implementation stores all statistics in a single table named &quot;&lt;a href=&quot;fileformat2#stat1tab&quot;&gt;sqlite_stat1&lt;/a&gt;&quot;. If SQLite is compiled with the &lt;a href=&quot;compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt; option, then additional histogram data is collected and stored in &lt;a href=&quot;fileformat2#stat4tab&quot;&gt;sqlite_stat4&lt;/a&gt;. Older versions of SQLite would make use of the &lt;a href=&quot;fileformat2#stat2tab&quot;&gt;sqlite_stat2&lt;/a&gt; table or &lt;a href=&quot;fileformat2#stat3tab&quot;&gt;sqlite_stat3&lt;/a&gt; table when compiled with &lt;a href=&quot;compile#enable_stat2&quot;&gt;SQLITE_ENABLE_STAT2&lt;/a&gt; or &lt;a href=&quot;compile#enable_stat3&quot;&gt;SQLITE_ENABLE_STAT3&lt;/a&gt;, but all recent versions of SQLite ignore the sqlite_stat2 and sqlite_stat3 tables. Future enhancements may create additional &lt;a href=&quot;fileformat2#intschema&quot;&gt;internal tables&lt;/a&gt; with the same name pattern except with final digit larger than &quot;4&quot;. All of these tables are collectively referred to as &quot;statistics tables&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92c0ee558e2a1a06a318ed232e40e1c0e6d83d45" translate="yes" xml:space="preserve">
          <source>The default insertion cost</source>
          <target state="translated">Стоимость вставки по умолчанию</target>
        </trans-unit>
        <trans-unit id="44b061817ffc2eb0f5dadec06f4e66f4f81231c2" translate="yes" xml:space="preserve">
          <source>The default locking mechanism used by SQLite on unix platforms is POSIX advisory locking, but there are other options. By selecting an alternative &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; using the &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; interface, an application can make use of other locking protocols that might be more appropriate to certain filesystems. For example, dot-file locking might be select for use in an application that has to run on an NFS filesystem that does not support POSIX advisory locking.</source>
          <target state="translated">Механизм блокировки по умолчанию, используемый SQLite на платформах unix, - это рекомендательная блокировка POSIX, но есть и другие варианты. Выбирая альтернативный &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; с помощью интерфейса &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2 ()&lt;/a&gt; , приложение может использовать другие протоколы блокировки, которые могут быть более подходящими для определенных файловых систем. Например, блокировку точечных файлов можно выбрать для использования в приложении, которое должно работать в файловой системе NFS, не поддерживающей рекомендательную блокировку POSIX.</target>
        </trans-unit>
        <trans-unit id="d9e0888f3707dfa1a041c24c2a5eb623fe8f593b" translate="yes" xml:space="preserve">
          <source>The default locking mechanism used by SQLite on unix platforms is POSIX advisory locking. Unfortunately, POSIX advisory locking has design quirks that make it prone to misuse and failure. In particular, any thread in the same process with a file descriptor that is holding a POSIX advisory lock can override that lock using a different file descriptor. One particularly pernicious problem is that the &lt;code&gt;close()&lt;/code&gt; system call will cancel all POSIX advisory locks on the same file for all threads and all file descriptors in the process.</source>
          <target state="translated">Механизм блокировки по умолчанию, используемый SQLite на платформах unix, - это рекомендательная блокировка POSIX. К сожалению, консультативная блокировка POSIX имеет конструктивные особенности, которые делают ее склонной к неправильному использованию и сбоям. В частности, любой поток в том же процессе с файловым дескриптором, который удерживает консультативную блокировку POSIX, может переопределить эту блокировку, используя другой файловый дескриптор. Одна особенно пагубная проблема заключается в том, что системный вызов &lt;code&gt;close()&lt;/code&gt; отменяет все рекомендательные блокировки POSIX для одного и того же файла для всех потоков и всех файловых дескрипторов в процессе.</target>
        </trans-unit>
        <trans-unit id="07275b3b33b4fa68f4e8147d7f962856df7d7bd0" translate="yes" xml:space="preserve">
          <source>The default lookaside configuration has changed from 100 slots of 1200 bytes each (120KB) to be 40 slots of 1200 bytes each (48KB). This space ends up being allocated as 93 slots of 128 bytes each and 30 slots of 1200 bytes each. So more lookaside slots are available but much less heap space is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e313113e047c2f26bfe18f713c540368922a076" translate="yes" xml:space="preserve">
          <source>The default lookaside configuration, the size of the small-slots, and the details of how heap space is allocated between small-slots and big-slots, are all subject to change from one release to the next.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fdf451db4759c12771bfb1206d604a686ee94bb6" translate="yes" xml:space="preserve">
          <source>The default mapping of the rank column for a table may be modified using the &lt;a href=&quot;fts5#the_rank_configuration_option&quot;&gt;FTS5 rank configuration option&lt;/a&gt;.</source>
          <target state="translated">Отображение по умолчанию столбца ранга для таблицы может быть изменено с помощью &lt;a href=&quot;fts5#the_rank_configuration_option&quot;&gt;опции конфигурации ранга FTS5&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="676ab2fe4bf4ab903767c236b27e9b63051796ee" translate="yes" xml:space="preserve">
          <source>The default maximum trigger recursion depth is 1000.</source>
          <target state="translated">Максимальная глубина рекурсии триггера по умолчанию составляет 1000.</target>
        </trans-unit>
        <trans-unit id="fd5421bb6c7fc35d245339e5557eb27520f8453d" translate="yes" xml:space="preserve">
          <source>The default means that aggregate window functions read all rows from the beginning of the partition up to and including the current row and its peers. This implies that rows that have the same values for all ORDER BY expressions will also have the same value for the result of the window function (as the window frame is the same). For example:</source>
          <target state="translated">По умолчанию функции агрегированного окна считывают все строки от начала раздела до текущей строки и ее ровесников включительно.Это подразумевает,что строки,которые имеют одинаковые значения для всех выражений ORDER BY,будут иметь одинаковое значение и для результата оконной функции (так как рамка окна одна и та же).Например:</target>
        </trans-unit>
        <trans-unit id="2d78a92ed9db0e9db8d034d6998442b87734337c" translate="yes" xml:space="preserve">
          <source>The default mechanism by which SQLite accesses and updates database disk files is the xRead() and xWrite() methods of the &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; VFS object. These methods are typically implemented as &quot;read()&quot; and &quot;write()&quot; system calls which cause the operating system to copy disk content between the kernel buffer cache and user space.</source>
          <target state="translated">Механизм по умолчанию, с помощью которого SQLite получает доступ и обновляет файлы на диске базы данных, - это методы xRead () и xWrite () объекта VFS &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; . Эти методы обычно реализуются как системные вызовы &amp;laquo;read ()&amp;raquo; и &amp;laquo;write ()&amp;raquo;, которые заставляют операционную систему копировать содержимое диска между буферным кешем ядра и пользовательским пространством.</target>
        </trans-unit>
        <trans-unit id="af6b4fd5a17994d4af89bdbebf0e8f01053d45e7" translate="yes" xml:space="preserve">
          <source>The default memory allocation settings in SQLite are appropriate for most applications. However, applications with unusual or particularly strict requirements may want to adjust the configuration to more closely align SQLite to their needs. Both compile-time and start-time configuration options are available.</source>
          <target state="translated">Настройки выделения памяти по умолчанию в SQLite подходят для большинства приложений.Однако приложения с необычными или особо строгими требованиями могут захотеть настроить конфигурацию так,чтобы SQLite более точно соответствовал их потребностям.Доступны опции конфигурации как во время компиляции,так и во время запуска.</target>
        </trans-unit>
        <trans-unit id="62759f30ef7e2768a0dc269d58d4f224a639e96a" translate="yes" xml:space="preserve">
          <source>The default memory allocator is recommended for most applications. If you do not have a compelling need to use an alternative memory allocator, then use the default.</source>
          <target state="translated">Для большинства приложений рекомендуется использовать аллокатор памяти по умолчанию.Если у вас нет необходимости использовать альтернативный аллокатор памяти,то используйте аллокатор по умолчанию.</target>
        </trans-unit>
        <trans-unit id="dcfc21fe3a44b7df155912e662a52083d37f6130" translate="yes" xml:space="preserve">
          <source>The default method by which SQLite implements &lt;a href=&quot;atomiccommit&quot;&gt;atomic commit and rollback&lt;/a&gt; is a &lt;a href=&quot;lockingv3#rollback&quot;&gt;rollback journal&lt;/a&gt;. Beginning with &lt;a href=&quot;https://sqlite.org/releaselog/3_7_0.html&quot;&gt;version 3.7.0&lt;/a&gt; (2010-07-21), a new &quot;Write-Ahead Log&quot; option (hereafter referred to as &quot;WAL&quot;) is available.</source>
          <target state="translated">Метод по умолчанию, с помощью которого SQLite реализует &lt;a href=&quot;atomiccommit&quot;&gt;атомарную фиксацию и откат,&lt;/a&gt; - это &lt;a href=&quot;lockingv3#rollback&quot;&gt;журнал отката&lt;/a&gt; . Начиная с &lt;a href=&quot;https://sqlite.org/releaselog/3_7_0.html&quot;&gt;версии 3.7.0&lt;/a&gt; ( 21.07.2010 ), доступна новая опция &amp;laquo;Журнал упреждающей записи&amp;raquo; (далее &amp;laquo;WAL&amp;raquo;).</target>
        </trans-unit>
        <trans-unit id="03533018c376c706c7055694a5695128f6d5dba9" translate="yes" xml:space="preserve">
          <source>The default mode is serialized.</source>
          <target state="translated">Режим по умолчанию сериализован.</target>
        </trans-unit>
        <trans-unit id="c91c1c07eac44347101354cb661e73cefc49a14a" translate="yes" xml:space="preserve">
          <source>The default numeric file permissions for newly created database files under unix. If not specified, the default is 0644 which means that the files is globally readable but only writable by the creator.</source>
          <target state="translated">Разрешения на использование числовых файлов по умолчанию для вновь создаваемых файлов базы данных в unix.Если не указано,по умолчанию используется значение 0644,что означает,что файлы глобально читаются,но могут быть записаны только их создателем.</target>
        </trans-unit>
        <trans-unit id="b7b908d4b0d2fc05c9ddc3f95f430fcff134a8ed" translate="yes" xml:space="preserve">
          <source>The default operation of edit() is to invoke a text editor. But by using an alternative edit program in the second argument, you can also get it to edit images or other non-text resources. For example, if you want to modify a JPEG image that happens to be stored in a field of a table, you could run:</source>
          <target state="translated">Операция по умолчанию функции edit()заключается в вызове текстового редактора.Но,используя альтернативную программу редактирования во втором аргументе,вы также можете заставить ее редактировать изображения или другие нетекстовые ресурсы.Например,если вы хотите изменить JPEG-изображение,которое случайно хранится в поле таблицы,вы можете запустить его:</target>
        </trans-unit>
        <trans-unit id="56314197173fa9030fb113bbb41424539c87a296" translate="yes" xml:space="preserve">
          <source>The default order of the nested loops in a join is for the left-most table in the FROM clause to form the outer loop and the right-most table to form the inner loop. However, SQLite will nest the loops in a different order if doing so will help it to select better indexes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e15d9f7898bd04fad7c8bec9316feb2b3c4d67cc" translate="yes" xml:space="preserve">
          <source>The default order of the nested loops in a join is for the left-most table in the FROM clause to form the outer loop and the right-most table to form the inner loop. However, SQLite will nest the loops in a different order if doing so will help it to select better indices.</source>
          <target state="translated">Порядок вложенных циклов в соединении по умолчанию следующий:самая левая таблица в пункте FROM-для формирования внешнего цикла,а самая правая таблица-для формирования внутреннего цикла.Тем не менее,SQLite будет вставлять циклы в другом порядке,если это поможет ему выбрать лучшие индексы.</target>
        </trans-unit>
        <trans-unit id="c60124ec3003cce0626fc7fdd9909bdc4316bd6f" translate="yes" xml:space="preserve">
          <source>The default output mode is &quot;list&quot;. In list mode, each row of a query result is written on one line of output and each column within that row is separated by a specific separator string. The default separator is a pipe symbol (&quot;|&quot;). List mode is especially useful when you are going to send the output of a query to another program (such as AWK) for additional processing.</source>
          <target state="translated">Режим вывода по умолчанию-&quot;список&quot;.В режиме списка каждая строка результата запроса записывается в одну строку вывода,а каждый столбец внутри этой строки отделяется определенной строкой разделителя.Разделителем по умолчанию является символ трубы (&quot;|&quot;).Режим списка особенно полезен,когда вы собираетесь отправить результат запроса в другую программу (например,AWK)для дополнительной обработки.</target>
        </trans-unit>
        <trans-unit id="cae14327c7d6852834539912db17ff8fae315187" translate="yes" xml:space="preserve">
          <source>The default output shows the beginning and end of each configuration and test module combination. In the example above &quot;c1&quot; and &quot;64k&quot; are configurations and &quot;pager08&quot;, &quot;build33&quot;, &quot;orderby01&quot;, etc. are test modules. Compile-time and run-time options are available to increase or decrease the amount of output. The output can be increased by showing each test case within each test module. The output can be decreased by degrees: omitting test modules starts and stops, omitting configuration starts and stops, and finally by omitting all output.</source>
          <target state="translated">На выходе по умолчанию отображается начало и конец каждой конфигурации и комбинации тестовых модулей.В примере выше &quot;c1&quot; и &quot;64k&quot;-это конфигурации,а &quot;pager08&quot;,&quot;build33&quot;,&quot;orderby01&quot; и т.д.-тестовые модули.Для увеличения или уменьшения объема выводимых данных доступны опции компиляции и исполнения.Вывод может быть увеличен путем показа каждого тестового случая внутри каждого тестового модуля.Вывод может быть уменьшен на градусы:опускание тестовых модулей запускается и останавливается,опускание конфигурации запускается и останавливается,и,наконец,опускается весь вывод.</target>
        </trans-unit>
        <trans-unit id="81fe79158a35398aa7562b0fca6f1415aa39b894" translate="yes" xml:space="preserve">
          <source>The default page cache implemention does not allocate the full amount of cache memory all at once. Cache memory is allocated in smaller chunks on an as-needed basis. The page_cache setting is a (suggested) upper bound on the amount of memory that the cache can use, not the amount of memory it will use all of the time. This is the behavior of the default page cache implementation, but an &lt;a href=&quot;c3ref/pcache_methods2&quot;&gt;application defined page cache&lt;/a&gt; is free to behave differently if it wants.</source>
          <target state="translated">Реализация кэша страниц по умолчанию не выделяет сразу весь объем кэш-памяти. Кэш-память выделяется меньшими частями по мере необходимости. Параметр page_cache - это (предлагаемая) верхняя граница объема памяти, которую может использовать кеш, а не объем памяти, который он будет использовать все время. Это поведение реализации кеша страниц по умолчанию, но кеш страниц, определенный &lt;a href=&quot;c3ref/pcache_methods2&quot;&gt;приложением,&lt;/a&gt; может вести себя по-другому, если захочет.</target>
        </trans-unit>
        <trans-unit id="fc5d7962d2b50c7baceb7ed65dad81e0058ad64b" translate="yes" xml:space="preserve">
          <source>The default page cache strives more diligently to avoid using memory beyond what is allocated to it by &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt;. Or if using page cache is allocating from the heap, it strives to avoid going over the &lt;a href=&quot;c3ref/hard_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64()&lt;/a&gt;, even if &lt;a href=&quot;compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt; is not set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b40256b332aa600059fdd4657f3e43acb14b4e3d" translate="yes" xml:space="preserve">
          <source>The default page cache strives more diligently to avoid using memory beyond what is allocated to it by &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt;. Or if using page cache is allocating from the heap, it strives to avoid going over the &lt;a href=&quot;c3ref/soft_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64()&lt;/a&gt;, even if &lt;a href=&quot;compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt; is not set.</source>
          <target state="translated">Кэш страниц по умолчанию старается более тщательно избегать использования памяти сверх того, что выделено ему &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt; . Или, если использование кеша страниц выделяется из кучи, он пытается избежать перехода через &lt;a href=&quot;c3ref/soft_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64 ()&lt;/a&gt; , даже если &lt;a href=&quot;compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt; не установлен.</target>
        </trans-unit>
        <trans-unit id="619cdf9a91dcb3b5377126d1f738a21802c8e3aa" translate="yes" xml:space="preserve">
          <source>The default page size on windows is automatically adjusted to match the capabilities of the underlying filesystem.</source>
          <target state="translated">Размер страницы по умолчанию в окнах автоматически настраивается в соответствии с возможностями базовой файловой системы.</target>
        </trans-unit>
        <trans-unit id="df04859a275716c6652a67712d525008dc797ebb" translate="yes" xml:space="preserve">
          <source>The default setting for SQLITE_MAX_COLUMN is 2000. You can change it at compile time to values as large as 32767. On the other hand, many experienced database designers will argue that a well-normalized database will never need more than 100 columns in a table.</source>
          <target state="translated">По умолчанию для SQLITE_MAX_COLUMN установлено значение 2000.Вы можете изменить его во время компиляции на значения до 32767.С другой стороны,многие опытные проектировщики БД будут утверждать,что хорошо нормализованная БД никогда не будет нуждаться более чем в 100 столбцах в таблице.</target>
        </trans-unit>
        <trans-unit id="0506f7d82e65a6fef4e6e411dc34fd230ff22185" translate="yes" xml:space="preserve">
          <source>The default setting for auto-vacuum is 0 or &quot;none&quot;, unless the &lt;a href=&quot;compile#default_autovacuum&quot;&gt;SQLITE_DEFAULT_AUTOVACUUM&lt;/a&gt; compile-time option is used. The &quot;none&quot; setting means that auto-vacuum is disabled. When auto-vacuum is disabled and data is deleted data from a database, the database file remains the same size. Unused database file pages are added to a &quot;&lt;a href=&quot;fileformat2#freelist&quot;&gt;freelist&lt;/a&gt;&quot; and reused for subsequent inserts. So no database file space is lost. However, the database file does not shrink. In this mode the &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; command can be used to rebuild the entire database file and thus reclaim unused disk space.</source>
          <target state="translated">Значение по умолчанию для автоматического вакуумирования - 0 или &amp;laquo;нет&amp;raquo;, если не используется &lt;a href=&quot;compile#default_autovacuum&quot;&gt;параметр времени&lt;/a&gt; компиляции SQLITE_DEFAULT_AUTOVACUUM . Параметр &amp;laquo;Нет&amp;raquo; означает, что автоматический вакуум отключен. Когда автоматический вакуум отключен и данные удаляются из базы данных, файл базы данных остается того же размера. Неиспользуемые страницы файлов базы данных добавляются в &amp;laquo; &lt;a href=&quot;fileformat2#freelist&quot;&gt;свободный&lt;/a&gt; список &amp;raquo; и повторно используются для последующих вставок. Таким образом, файловое пространство базы данных не теряется. Однако файл базы данных не сжимается. В этом режиме команду &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; можно использовать для восстановления всего файла базы данных и, таким образом, освобождения неиспользуемого дискового пространства.</target>
        </trans-unit>
        <trans-unit id="de25e032063f16295b8e77c37d21842694e060fe" translate="yes" xml:space="preserve">
          <source>The default setting for the &lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;temp_store pragma&lt;/a&gt; is 0, which means to following the recommendation of &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; compile-time parameter.</source>
          <target state="translated">Значение по умолчанию для &lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;прагмы temp_store&lt;/a&gt; - 0, что означает выполнение рекомендаций параметра времени компиляции &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d111baa1a5224d066ace9e922bc0723387d0391f" translate="yes" xml:space="preserve">
          <source>The default setting for this pragma is OFF, which means that all references to the table anywhere in the schema are converted to the new name.</source>
          <target state="translated">Параметр по умолчанию для этой прагмы-OFF,что означает,что все ссылки на таблицу в любом месте схемы преобразуются в новое имя.</target>
        </trans-unit>
        <trans-unit id="5060b84cc58c53853f2caf81d58480c0590b9ac5" translate="yes" xml:space="preserve">
          <source>The default setting is 1. Additional information can be found in &lt;a href=&quot;tempfiles#tempstore&quot;&gt;tempfiles.html&lt;/a&gt;.</source>
          <target state="translated">Значение по умолчанию - 1. Дополнительную информацию можно найти в &lt;a href=&quot;tempfiles#tempstore&quot;&gt;tempfiles.html&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4e7fc079075b7fd84d6268869958a93f9d4d68c3" translate="yes" xml:space="preserve">
          <source>The default sorting procedure is to gather all information that will ultimately be output into a &quot;record&quot; and pass that complete record to the sorter. But in some cases, for example if some of the output columns consists of large BLOB values, the size of the each record can be large, which means that the sorter has to either use more memory, and/or write more content to temporary storage.</source>
          <target state="translated">Процедура сортировки по умолчанию заключается в сборе всей информации,которая в конечном итоге будет выведена в &quot;запись&quot; и передаче этой полной записи сортировщику.Но в некоторых случаях,например,если некоторые из выводимых столбцов состоят из больших BLOB-значений,размер каждой записи может быть большим,что означает,что сортировщик должен либо использовать больше памяти,либо записывать больше содержимого во временное хранилище.</target>
        </trans-unit>
        <trans-unit id="6f4517865a59fec2a530bec6db77e7cd99eb8490" translate="yes" xml:space="preserve">
          <source>The default strategy is to allow successive write transactions to grow the WAL until the WAL becomes about 1000 pages in size, then to run a checkpoint operation for each subsequent COMMIT until the WAL is reset to be smaller than 1000 pages. By default, the checkpoint will be run automatically by the same thread that does the COMMIT that pushes the WAL over its size limit. This has the effect of causing most COMMIT operations to be very fast but an occasional COMMIT (those that trigger a checkpoint) to be much slower. If that effect is undesirable, then the application can disable automatic checkpointing and run the periodic checkpoints in a separate thread, or separate process. (Links to commands and interfaces to accomplish this are &lt;a href=&quot;#how_to_checkpoint&quot;&gt;shown below&lt;/a&gt;.)</source>
          <target state="translated">Стратегия по умолчанию - разрешить последовательным транзакциям записи увеличивать WAL до тех пор, пока размер WAL не станет примерно 1000 страниц, а затем выполнять операцию контрольной точки для каждого последующего COMMIT, пока WAL не будет сброшен до менее 1000 страниц. По умолчанию контрольная точка будет запускаться автоматически тем же потоком, который выполняет COMMIT, подталкивающий WAL к пределу размера. Это приводит к тому, что большинство операций COMMIT выполняются очень быстро, а случайные COMMIT (те, которые запускают контрольную точку) намного медленнее. Если этот эффект нежелателен, приложение может отключить автоматическое установление контрольных точек и запускать периодические контрольные точки в отдельном потоке или отдельном процессе. (Ссылки на команды и интерфейсы для этого &lt;a href=&quot;#how_to_checkpoint&quot;&gt;показаны ниже&lt;/a&gt; .)</target>
        </trans-unit>
        <trans-unit id="7aba3882e935c491d72d10d266cb950c10ccee5f" translate="yes" xml:space="preserve">
          <source>The default substitution cost</source>
          <target state="translated">Стоимость замещения по умолчанию</target>
        </trans-unit>
        <trans-unit id="6947c6a992789a324c997f5478292dca047e240d" translate="yes" xml:space="preserve">
          <source>The default synchronous setting is full so the above is what usually happens. However, if the synchronous setting is lowered to &quot;normal&quot;, SQLite only flushes the rollback journal once, after the page count has been written. This carries a risk of corruption because it might happen that the modified (non-zero) page count reaches the disk surface before all of the data does. The data will have been written first, but SQLite assumes that the underlying filesystem can reorder write requests and that the page count can be burned into oxide first even though its write request occurred last. So as a second line of defense, SQLite also uses a 32-bit checksum on every page of data in the rollback journal. This checksum is evaluated for each page during rollback while rolling back a journal as described in &lt;a href=&quot;#section_4_4&quot;&gt;section 4.4&lt;/a&gt;. If an incorrect checksum is seen, the rollback is abandoned. Note that the checksum does not guarantee that the page data is correct since there is a small but finite probability that the checksum might be right even if the data is corrupt. But the checksum does at least make such an error unlikely.</source>
          <target state="translated">По умолчанию синхронная настройка заполнена, поэтому обычно происходит то, что описано выше. Однако, если параметр синхронности понижен до &amp;laquo;нормального&amp;raquo;, SQLite очищает журнал отката только один раз, после того как счетчик страниц был записан. Это несет в себе риск повреждения, потому что может случиться так, что измененное (ненулевое) количество страниц достигнет поверхности диска раньше, чем все данные. Данные будут записаны первыми, но SQLite предполагает, что соответствующая файловая система может переупорядочивать запросы на запись и что счетчик страниц может быть записан в оксид в первую очередь, даже если ее запрос записи был выполнен последним. Таким образом, в качестве второй линии защиты SQLite также использует 32-битную контрольную сумму на каждой странице данных в журнале отката. Эта контрольная сумма оценивается для каждой страницы во время отката при откате журнала, как описано в &lt;a href=&quot;#section_4_4&quot;&gt;разделе 4.4.&lt;/a&gt;. Если обнаружена неверная контрольная сумма, откат прекращается. Обратите внимание, что контрольная сумма не гарантирует правильность данных страницы, поскольку существует небольшая, но конечная вероятность того, что контрольная сумма может быть правильной, даже если данные повреждены. Но контрольная сумма, по крайней мере, делает такую ​​ошибку маловероятной.</target>
        </trans-unit>
        <trans-unit id="095be1a2c22dcc1b72f1d8ee5a80821a8e3ba1f7" translate="yes" xml:space="preserve">
          <source>The default value for SQLITE_PRINTF_PRECISION_LIMIT is 2147483647 (0x7fffffff).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5887e5cef0e652ea249c383a61a9790399db5025" translate="yes" xml:space="preserve">
          <source>The default value for languageid is 0. If an alternative language is specified in WHERE clause constraints, then that alternative is used instead of 0. There can only be a single languageid per query. In other words, the WHERE clause cannot contain a range constraint or IN operator on the languageid.</source>
          <target state="translated">Значение по умолчанию для лингвида равно 0.Если альтернативный язык указан в ограничениях пункта WHERE,то вместо 0 используется этот альтернативный язык.На каждый запрос может быть только один лингвид.Другими словами,выражение WHERE не может содержать ограничение диапазона или оператор IN на языковике.</target>
        </trans-unit>
        <trans-unit id="3d6f85ef321cfdfaecfbd8525333d39487f3c884" translate="yes" xml:space="preserve">
          <source>The default value of a languageid column is 0. Any value inserted into a languageid column is converted to a 32-bit (not 64) signed integer.</source>
          <target state="translated">Значение столбца языка по умолчанию равно 0.Любое значение,вставленное в столбец языка,преобразуется в 32-битное (не 64)подписанное целое число.</target>
        </trans-unit>
        <trans-unit id="0bb45f8540234b96b45cb058d442c35d3ea03bfa" translate="yes" xml:space="preserve">
          <source>The default value of the &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; compile-time parameter is 1, which means to store temporary files on disk but provide the option of overriding the behavior using the &lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;temp_store pragma&lt;/a&gt;.</source>
          <target state="translated">Значение по умолчанию для параметра &lt;a href=&quot;compile#temp_store&quot;&gt;времени&lt;/a&gt; компиляции SQLITE_TEMP_STORE равно 1, что означает хранение временных файлов на диске, но с возможностью переопределения поведения с помощью &lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;прагмы temp_store&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3aae70c9121f536fa334d3f452170e8968ea3458" translate="yes" xml:space="preserve">
          <source>The default value of the usermerge option is 4. The minimum allowed value is 2, and the maximum 16.</source>
          <target state="translated">Значение по умолчанию для опции usermerge-4,минимально допустимое значение-2,максимальное-16.</target>
        </trans-unit>
        <trans-unit id="6973079b710b23783ded0a80f07fc117f677c334" translate="yes" xml:space="preserve">
          <source>The default virtual table (&quot;rtree&quot;) normally stores coordinates as single-precision (4-byte) floating point numbers. If integer coordinates are desired, declare the table using &quot;rtree_i32&quot; instead:</source>
          <target state="translated">В виртуальной таблице по умолчанию (&quot;rtree&quot;)координаты обычно хранятся в виде одноточного (4-байтового)числа с плавающей точкой.Если нужны целые координаты,объявите таблицу,используя &quot;rtree_i32&quot;:</target>
        </trans-unit>
        <trans-unit id="f282a44d7dfb6c6134a7e29df48c07aa44737ff7" translate="yes" xml:space="preserve">
          <source>The demonstration code assumes that the SQLite database is opened used as a database object named &quot;db&quot;.</source>
          <target state="translated">Демонстрационный код предполагает,что БД SQLite открывается и используется как объект БД с именем &quot;db&quot;.</target>
        </trans-unit>
        <trans-unit id="8837968f443dfe5005184f2c6a7e1c74103e5e88" translate="yes" xml:space="preserve">
          <source>The demonstration code below includes a status_refresh method that grays-out or activates the Undo and Redo buttons and menu entries depending on whether or not there is anything to be undone or redone. You will need to redefine this method to control the Undo and Redo buttons in your application.</source>
          <target state="translated">Демонстрационный код ниже включает метод status_refresh,который выделяет серым цветом или активирует кнопки &quot;Отменить&quot; и &quot;Повторно&quot;,а также пункты меню в зависимости от того,есть ли что-то,что нужно отменить или повторить.Вам нужно будет переопределить этот метод,чтобы управлять кнопками Отменить и Повторно в вашем приложении.</target>
        </trans-unit>
        <trans-unit id="e759858c504e056da064aff365282dc111db1fea" translate="yes" xml:space="preserve">
          <source>The depth of recursion for triggers has a hard upper limit set by the &lt;a href=&quot;limits#max_trigger_depth&quot;&gt;SQLITE_MAX_TRIGGER_DEPTH&lt;/a&gt; compile-time option and a run-time limit set by &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimittriggerdepth&quot;&gt;SQLITE_LIMIT_TRIGGER_DEPTH&lt;/a&gt;,...).</source>
          <target state="translated">Глубина рекурсии для триггеров имеет жесткий верхний предел, установленный параметром &lt;a href=&quot;limits#max_trigger_depth&quot;&gt;времени&lt;/a&gt; компиляции SQLITE_MAX_TRIGGER_DEPTH, и предел времени выполнения, установленный &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt; (db, &lt;a href=&quot;c3ref/c_limit_attached#sqlitelimittriggerdepth&quot;&gt;SQLITE_LIMIT_TRIGGER_DEPTH&lt;/a&gt; , ...).</target>
        </trans-unit>
        <trans-unit id="40be115b96b882b5a59636c2c2b3cce3bdbb02d6" translate="yes" xml:space="preserve">
          <source>The descendants of OpenOffice tend to segfault more often than commercial competitors. Perhaps for this reason, the OpenOffice forks make periodic backups of their in-memory documents so that users do not lose all pending edits when the inevitable application crash does occur. This causes frustrating pauses in the application for the few seconds while each backup is being made. After restarting from a crash, the user is presented with a dialog box that walks them through the recovery process. Managing the crash recovery this way involves lots of extra application logic and is generally an annoyance to the user.</source>
          <target state="translated">Потомки OpenOffice чаще,чем коммерческие конкуренты,склонны к сегрегации.Возможно,по этой причине вилки OpenOffice периодически делают резервные копии документов в памяти,чтобы пользователи не теряли все отложенные правки при неизбежном падении приложения.Это приводит к разочаровывающим паузам в работе приложения на несколько секунд во время выполнения каждого резервного копирования.После перезапуска после сбоя у пользователя появляется диалоговое окно,в котором он проходит через процесс восстановления.Управление аварийным восстановлением таким образом включает в себя много дополнительной логики приложения и,как правило,раздражает пользователя.</target>
        </trans-unit>
        <trans-unit id="2a2b8799305e9ca9fdc0f3b11f07bd75b53378d6" translate="yes" xml:space="preserve">
          <source>The designed query interface is:</source>
          <target state="translated">Разработан интерфейс запроса:</target>
        </trans-unit>
        <trans-unit id="85d6b31a6dd13fa4a2b19e14c162e00851337050" translate="yes" xml:space="preserve">
          <source>The detail option may be set to &quot;full&quot; (the default value), &quot;column&quot; or &quot;none&quot;. For example:</source>
          <target state="translated">Опция детализации может быть установлена на &quot;полный&quot; (значение по умолчанию),&quot;столбец&quot; или &quot;нет&quot;.Например:</target>
        </trans-unit>
        <trans-unit id="1de34563fa7a58730a8b8b8a025ab7bdcb0a2940" translate="yes" xml:space="preserve">
          <source>The details of optimizations performed by this pragma are expected to change and improve over time. Applications should anticipate that this pragma will perform new optimizations in future releases.</source>
          <target state="translated">Ожидается,что детали оптимизаций,выполняемых этой прагмой,со временем будут меняться и улучшаться.Приложения должны ожидать,что эта прагма будет выполнять новые оптимизации в будущих релизах.</target>
        </trans-unit>
        <trans-unit id="2ec6e7a356da9ba89cc679a27100e250b07d2b68" translate="yes" xml:space="preserve">
          <source>The details of the behavior of the sqlite3_step() interface depend on whether the statement was prepared using the newer &quot;vX&quot; interfaces &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v3()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16_v3()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16_v2()&lt;/a&gt; or the older legacy interfaces &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16()&lt;/a&gt;. The use of the new &quot;vX&quot; interface is recommended for new applications but the legacy interface will continue to be supported.</source>
          <target state="translated">Подробная информация о поведении интерфейса sqlite3_step () зависит от того, было ли подготовлено заявление с использованием более новых интерфейсы &amp;laquo;Vx&amp;raquo; &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v3 ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16_v3 ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16_v2 ()&lt;/a&gt; или старше устаревшие интерфейсы &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare ()&lt;/a&gt; и &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16 ()&lt;/a&gt; . Для новых приложений рекомендуется использовать новый интерфейс &amp;laquo;vX&amp;raquo;, но старый интерфейс будет по-прежнему поддерживаться.</target>
        </trans-unit>
        <trans-unit id="a66564cccde706fd2f76931336faa29d5380763d" translate="yes" xml:space="preserve">
          <source>The details of the behavior of the sqlite3_step() interface depend on whether the statement was prepared using the newer &quot;vX&quot; interfaces &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v3()&lt;/a&gt;, &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt;, &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16_v3()&lt;/a&gt;, &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16_v2()&lt;/a&gt; or the older legacy interfaces &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; and &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16()&lt;/a&gt;. The use of the new &quot;vX&quot; interface is recommended for new applications but the legacy interface will continue to be supported.</source>
          <target state="translated">Подробная информация о поведении интерфейса sqlite3_step () зависит от того, было ли подготовлено заявление с использованием более новых интерфейсы &amp;laquo;Vx&amp;raquo; &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v3 ()&lt;/a&gt; , &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; , &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16_v3 ()&lt;/a&gt; , &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16_v2 ()&lt;/a&gt; или старше устаревшие интерфейсы &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare ()&lt;/a&gt; и &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16 ()&lt;/a&gt; . Для новых приложений рекомендуется использовать новый интерфейс &amp;laquo;vX&amp;raquo;, но старый интерфейс будет по-прежнему поддерживаться.</target>
        </trans-unit>
        <trans-unit id="d328873bfc7a5d2f8f59abeab740350558a37fbf" translate="yes" xml:space="preserve">
          <source>The details of the effects of the analysis limit described in the previous paragraph are subject to change in future versions of SQLite. But the core idea will remain the same. An analysis limit of N will strive to limit the number of rows visited in each index to approximately N.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47cfb6e87da2bbb4d38b35a83664b9fdcddd81cb" translate="yes" xml:space="preserve">
          <source>The details of the operation codes, their meanings, the parameters they take, and what they do are all subject to change without notice. Unlike most of the SQLite API, this function is not guaranteed to operate consistently from one release to the next.</source>
          <target state="translated">Детали кодов операций,их значения,параметры,которые они принимают,и то,что они делают,могут быть изменены без предварительного уведомления.В отличие от большинства SQLite API,эта функция не гарантированно работает последовательно от одного релиза к другому.</target>
        </trans-unit>
        <trans-unit id="dd71fb5d39136060492d732375a6fec71ebfc8ad" translate="yes" xml:space="preserve">
          <source>The developers are also on the lookout for new ways to optimize the commit mechanism. The current VFS implementations for Unix (Linux and Mac OS X) and Windows make pessimistic assumptions about the behavior of those systems. After consultation with experts on how these systems work, we might be able to relax some of the assumptions on these systems and allow them to run faster. In particular, we suspect that most modern filesystems exhibit the safe append property and that many of them might support atomic sector writes. But until this is known for certain, SQLite will take the conservative approach and assume the worst.</source>
          <target state="translated">Разработчики также находятся в поиске новых способов оптимизации механизма коммитов.Текущие реализации VFS для Unix (Linux и Mac OS X)и Windows делают пессимистические предположения о поведении этих систем.После консультации с экспертами о том,как эти системы работают,мы могли бы ослабить некоторые предположения об этих системах и позволить им работать быстрее.В частности,мы подозреваем,что большинство современных файловых систем обладают свойством безопасного приложения,и что многие из них могут поддерживать атомные записи.Но пока это не станет известно наверняка,SQLite будет придерживаться консервативного подхода и предполагать худшее.</target>
        </trans-unit>
        <trans-unit id="e4066095f770552d7d59a59bea4105aa7d61a017" translate="yes" xml:space="preserve">
          <source>The developers have no editorial influence on the content of CVEs, and they do not like to be controlled by groups in which they have no voice.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cba4f98976654b480368200cf64e4d7ca1caf336" translate="yes" xml:space="preserve">
          <source>The developers of SQLite are confident that it is robust in the face of power failures and system crashes because the automatic test procedures do extensive checks on the ability of SQLite to recover from simulated power loss. We call these the &quot;crash tests&quot;.</source>
          <target state="translated">Разработчики SQLite уверены,что он устойчив к перебоям в электропитании и сбоям системы,потому что процедуры автоматического тестирования делают обширные проверки способности SQLite восстанавливаться после смоделированных потерь электроэнергии.Мы называем это &quot;краш-тестами&quot;.</target>
        </trans-unit>
        <trans-unit id="57e3f42d8aa639c2f77c64f6029c9126e99e122e" translate="yes" xml:space="preserve">
          <source>The developers of SQLite have found that full coverage testing is an extremely effective method for locating and preventing bugs. Because every single branch instruction in SQLite core code is covered by test cases, the developers can be confident that changes made in one part of the code do not have unintended consequences in other parts of the code. The many new features and performance improvements that have been added to SQLite in recent years would not have been possible without the availability full-coverage testing.</source>
          <target state="translated">Разработчики SQLite обнаружили,что тестирование полного покрытия является чрезвычайно эффективным методом локализации и предотвращения ошибок.Поскольку каждая инструкция в основной части кода SQLite покрывается тестовыми случаями,разработчики могут быть уверены,что изменения,внесенные в одну часть кода,не повлекут за собой непредвиденных последствий в других частях кода.Множество новых возможностей и улучшений производительности,которые были добавлены в SQLite в последние годы,были бы невозможны без полноценного тестирования.</target>
        </trans-unit>
        <trans-unit id="c6e54cb667da50110192519bd611d69d7d2d59cd" translate="yes" xml:space="preserve">
          <source>The developers of SQLite intend to support the product through the year 2050. To this end, the source code is carefully documented to promote long-term maintainability. We prefer mature and stable over trendy and cutting-edge.</source>
          <target state="translated">Разработчики SQLite намерены поддерживать продукт до 2050 года.Для этого исходный код тщательно документируется,чтобы обеспечить долгосрочную поддержку.Мы предпочитаем зрелый и стабильный,а не модный и современный.</target>
        </trans-unit>
        <trans-unit id="6b11572798416066a74cf3226912c7c4d4e245c6" translate="yes" xml:space="preserve">
          <source>The developers often do not find out about CVEs until long after the bug is fixed. You can see this by the fact that many CVEs reference the bug fix in their initial report.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa1c82e2078fb346e28f27499859e5261dd7cb0d" translate="yes" xml:space="preserve">
          <source>The diagram above implies that SQLite computes all of the rowids first and then combines them with a union operation before starting to do rowid lookups on the original table. In reality, the rowid lookups are interspersed with rowid computations. SQLite uses one index at a time to find rowids while remembering which rowids it has seen before so as to avoid duplicates. That is just an implementation detail, though. The diagram, while not 100% accurate, provides a good overview of what is happening.</source>
          <target state="translated">Приведенная выше диаграмма подразумевает,что SQLite сначала вычисляет все rowid'ы,а затем комбинирует их с объединенной операцией,прежде чем начать выполнять поиск rowid'ов в исходной таблице.В действительности,поиск рядков чередуется с вычислениями рядков.SQLite использует по одному индексу за раз,чтобы найти рядки,вспоминая,какие рядки он видел раньше,чтобы избежать дубликатов.Однако это всего лишь деталь реализации.Диаграмма,хотя и не на 100% точна,но дает хороший обзор происходящего.</target>
        </trans-unit>
        <trans-unit id="cc06f8d8201603f348e84ed00b97e2bebb250253" translate="yes" xml:space="preserve">
          <source>The diagram at the right illustrates the concept. One begins with a standard SQLite release. For the sake of example, suppose that one intends to create a private branch off of SQLite version 3.6.15. In the diagram this is version (1). The maintainer makes an exact copy of the baseline SQLite into the branch space, shown as version (2). Note that (1) and (2) are exactly the same. Then the maintainer applies the private changes to version (2) resulting in version (3). In other words, version (3) is SQLite version 3.6.15 plus edits.</source>
          <target state="translated">Диаграмма справа иллюстрирует концепцию.Начинается со стандартного релиза SQLite.Для примера предположим,что планируется создать частную ветку от SQLite версии 3.6.15.На диаграмме это версия (1).Сопровождающий делает точную копию базовой ветки SQLite в пространство ветки,показанное как версия (2).Обратите внимание,что (1)и (2)точно совпадают.Затем мейнтейнер применяет частные изменения к версии (2),в результате чего получается версия (3).Другими словами,версия (3)-это версия SQLite 3.6.15 плюс изменения.</target>
        </trans-unit>
        <trans-unit id="7b170d383461e4dd7d9f55e0934f811bdf7d240b" translate="yes" xml:space="preserve">
          <source>The difference between reading from the rank column and using the bm25() function directly within the query is only significant when sorting by the returned value. In this case, using &quot;rank&quot; is faster than using bm25().</source>
          <target state="translated">Разница между чтением из столбца ранга и использованием функции bm25()непосредственно внутри запроса значима только при сортировке по возвращаемому значению.В этом случае использование &quot;rank&quot; происходит быстрее,чем использование bm25().</target>
        </trans-unit>
        <trans-unit id="9a6b573084b906296ca61d103b50efb82fd91899" translate="yes" xml:space="preserve">
          <source>The difference between this option and the 'automerge' option is that when the 'automerge' limit is reached FTS5 only begins to merge the b-trees together. Most of the work is performed as part of subsequent INSERT, UPDATE or DELETE operations. Whereas when the 'crisismerge' limit is reached, the offending b-trees are all merged immediately. This means that an INSERT, UPDATE or DELETE that triggers a crisis-merge may take a long time to complete.</source>
          <target state="translated">Разница между этой опцией и опцией 'automerge' заключается в том,что при достижении лимита 'automerge' FTS5 начинает только слияние b-деревьев.Большая часть работы выполняется в рамках последующих операций INSERT,UPDATE или DELETE.В то время как при достижении лимита &quot;кризисного погружения&quot;,нарушившие лимит b-деревья немедленно сливаются.Это означает,что выполнение операций INSERT,UPDATE или DELETE,вызывающих кризисное погружение,может занять много времени.</target>
        </trans-unit>
        <trans-unit id="6b73e10a6ce3d527b6333ec3f4b76095553830b9" translate="yes" xml:space="preserve">
          <source>The difference is that xConnect is called to establish a new connection to an existing virtual table whereas xCreate is called to create a new virtual table from scratch.</source>
          <target state="translated">Разница заключается в том,что xConnect вызывается для создания нового соединения с существующей виртуальной таблицей,в то время как xCreate вызывается для создания новой виртуальной таблицы с нуля.</target>
        </trans-unit>
        <trans-unit id="2f41e80a4cb41a6cee44f4eaec98226e9c29f84f" translate="yes" xml:space="preserve">
          <source>The differences between a patchset and a changeset are that:</source>
          <target state="translated">Различия между патчсетами и пейджетами заключаются в следующем:</target>
        </trans-unit>
        <trans-unit id="4fa2acc79952a3a20f72fc7c3e0f092b1e96e820" translate="yes" xml:space="preserve">
          <source>The differences between an &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_TEMP_DB&lt;/a&gt; database and an &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_TRANSIENT_DB&lt;/a&gt; database is this: The &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_TEMP_DB&lt;/a&gt; is used for explicitly declared and named TEMP tables (using the CREATE TEMP TABLE syntax) or for named tables in a temporary database that is created by opening a database with a filename that is an empty string. An &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_TRANSIENT_DB&lt;/a&gt; holds a database table that SQLite creates automatically in order to evaluate a subquery or ORDER BY or GROUP BY clause. Both TEMP_DB and TRANSIENT_DB databases are private and are deleted automatically. TEMP_DB databases last for the duration of the database connection. TRANSIENT_DB databases last only for the duration of a single SQL statement.</source>
          <target state="translated">Различия между &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;базой&lt;/a&gt; данных SQLITE_OPEN_TEMP_DB и &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;базой&lt;/a&gt; данных SQLITE_OPEN_TRANSIENT_DB заключаются в следующем: &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_TEMP_DB&lt;/a&gt; используется для явно объявленных и именованных таблиц TEMP (с использованием синтаксиса CREATE TEMP TABLE) или для именованных таблиц во временной базе данных, которая создается путем открытия базы данных с именем файла это пустая строка. &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_TRANSIENT_DB&lt;/a&gt; держит таблицу базы данных, SQLite автоматически создает для того , чтобы оценить подзапрос или ORDER BY или GROUP BY предложения. Обе базы данных TEMP_DB и TRANSIENT_DB являются частными и удаляются автоматически. Базы данных TEMP_DB существуют на время соединения с базой данных. Базы данных TRANSIENT_DB существуют только в течение одного оператора SQL.</target>
        </trans-unit>
        <trans-unit id="ea188c1a8a3d9f0d3afac3d8adfd72df27cd7aa2" translate="yes" xml:space="preserve">
          <source>The direct-to-disk writes are accomplished using fopen()/fwrite()/fclose(). By default, and in all the results shown below, the OS filesystem buffers are never flushed to persistent storage using fsync() or FlushFileBuffers(). In other words, there is no attempt to make the direct-to-disk writes transactional or power-safe. We found that invoking fsync() or FlushFileBuffers() on each file written causes direct-to-disk storage to be about 10 times or more slower than writes to SQLite.</source>
          <target state="translated">Прямая запись на диск выполняется с помощью функции fopen()/fwrite()/fclose().По умолчанию,и во всех результатах,показанных ниже,буферы файловой системы никогда не смываются в постоянное хранилище с помощью fsync()или FlushFileBuffers().Другими словами,нет никаких попыток сделать прямую запись на диск транзакционной или энергобезопасной.Мы обнаружили,что обращение к функциям fsync()или FlushFileBuffers()для каждого записываемого файла приводит к тому,что запись на диск происходит примерно в 10 и более раз медленнее,чем запись на SQLite.</target>
        </trans-unit>
        <trans-unit id="480bdad0842ce92215a602c8e8a2e2ba5036d89a" translate="yes" xml:space="preserve">
          <source>The directory or folder in which temporary files are created is determined by the OS-specific &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;.</source>
          <target state="translated">Каталог или папка, в которых создаются временные файлы, определяется &lt;a href=&quot;vfs&quot;&gt;VFS для&lt;/a&gt; конкретной ОС .</target>
        </trans-unit>
        <trans-unit id="58c1fd9cf0b8fae2622f0a1831b48a0d95eaabc6" translate="yes" xml:space="preserve">
          <source>The directory set by &lt;a href=&quot;pragma#pragma_temp_store_directory&quot;&gt;PRAGMA temp_store_directory&lt;/a&gt; or by the &lt;a href=&quot;c3ref/temp_directory&quot;&gt;sqlite3_temp_directory&lt;/a&gt; global variable</source>
          <target state="translated">Каталог, установленный &lt;a href=&quot;pragma#pragma_temp_store_directory&quot;&gt;PRAGMA temp_store_directory&lt;/a&gt; или глобальной переменной &lt;a href=&quot;c3ref/temp_directory&quot;&gt;sqlite3_temp_directory&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8e347995ace178c5b68534f7a6dde94c35392830" translate="yes" xml:space="preserve">
          <source>The directory used to hold temporary files on unix can now be set using the SQLITE_TMPDIR environment variable, which takes precedence over the TMPDIR environment variable. The &lt;a href=&quot;c3ref/temp_directory&quot;&gt;sqlite3_temp_directory&lt;/a&gt; global variable still has higher precedence than both environment variables, however.</source>
          <target state="translated">Каталог, используемый для хранения временных файлов в unix, теперь может быть установлен с помощью переменной среды SQLITE_TMPDIR, которая имеет приоритет над переменной среды TMPDIR. Однако глобальная переменная &lt;a href=&quot;c3ref/temp_directory&quot;&gt;sqlite3_temp_directory по-&lt;/a&gt; прежнему имеет более высокий приоритет, чем обе переменные среды.</target>
        </trans-unit>
        <trans-unit id="081d4a11583041f4e8625a8cc56c88ce7150faa6" translate="yes" xml:space="preserve">
          <source>The docid value. The first entry in a doclist contains the literal docid value. The first field of each subsequent doclist entry contains the difference between the new docid and the previous one (always a positive number).</source>
          <target state="translated">Докидное значение.Первая запись в доклисте содержит буквальное значение докида.Первое поле каждой последующей записи в доклисте содержит разницу между новым и предыдущим докидом (всегда положительное число).</target>
        </trans-unit>
        <trans-unit id="49e2bf067b92acf951896b04368654ffcd3a3f99" translate="yes" xml:space="preserve">
          <source>The document only describes locking for the older rollback-mode transaction mechanism. Locking for the newer &lt;a href=&quot;wal&quot;&gt;write-ahead log&lt;/a&gt; or &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt; is described separately.</source>
          <target state="translated">В документе описывается блокировка только для более старого механизма транзакций в режиме отката. Блокировка для нового &lt;a href=&quot;wal&quot;&gt;журнала упреждающей записи&lt;/a&gt; или &lt;a href=&quot;wal&quot;&gt;режима WAL&lt;/a&gt; описывается отдельно.</target>
        </trans-unit>
        <trans-unit id="1297878fc527d5d7c17142be2f4f043e484d8aa6" translate="yes" xml:space="preserve">
          <source>The documentation is maintained in separate source repositories on those same servers:</source>
          <target state="translated">Документация хранится в отдельных репозиториях на тех же серверах:</target>
        </trans-unit>
        <trans-unit id="d0017ab9193a6ed1029ad59fab58ce3ec88e592f" translate="yes" xml:space="preserve">
          <source>The documentation sources include documentation text and images with the scripts and makefile needed to construct the SQLite website documentation. This document is contained within the documentation sources. The document sources are kept in a separate repository distinct from the source code. The documentation sources repository is publicly readable.</source>
          <target state="translated">Источниками документации являются текст документации и изображения со скриптами и makefile,необходимые для создания документации сайта SQLite.Этот документ содержится в источниках документации.Исходные тексты документов хранятся в отдельном репозитории,отличном от исходного кода.Репозиторий источников документации является общедоступным для чтения.</target>
        </trans-unit>
        <trans-unit id="278f1b137f0865ba684c7cde1fa14cf1c768e813" translate="yes" xml:space="preserve">
          <source>The documentation system automatically maintains a &lt;a href=&quot;https://sqlite.org/chronology.html&quot;&gt;chronology&lt;/a&gt; of past releases, as well as a &lt;a href=&quot;changes&quot;&gt;complete list of SQLite releases&lt;/a&gt; with change summaries.</source>
          <target state="translated">Система документации автоматически ведет &lt;a href=&quot;https://sqlite.org/chronology.html&quot;&gt;хронологию&lt;/a&gt; прошлых выпусков, а также &lt;a href=&quot;changes&quot;&gt;полный список выпусков SQLite&lt;/a&gt; с описанием изменений.</target>
        </trans-unit>
        <trans-unit id="65988e654b808af94ee6da6f09345ac1241a1ac8" translate="yes" xml:space="preserve">
          <source>The dot-command must be entirely contained on a single input line.</source>
          <target state="translated">Точка-команда должна полностью содержаться в одной строке ввода.</target>
        </trans-unit>
        <trans-unit id="6fcffd0a57b5ba6715e1715a67438a136bebf610" translate="yes" xml:space="preserve">
          <source>The dot-commands are interpreted by the sqlite3.exe command-line program, not by SQLite itself. So none of the dot-commands will work as an argument to SQLite interfaces like &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; or &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec()&lt;/a&gt;.</source>
          <target state="translated">Точечные команды интерпретируются программой командной строки sqlite3.exe, а не самим SQLite. Таким образом, ни одна из точечных команд не будет работать в качестве аргумента для интерфейсов SQLite, таких как &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare ()&lt;/a&gt; или &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="73b101a4a2aed2c88c1089ef5e27eb7bd916289f" translate="yes" xml:space="preserve">
          <source>The downside of automatic incremental merging is that it makes every INSERT, UPDATE, and DELETE operation on an FTS3/4 table run a little slower, since extra time must be used to do the incremental merge. For maximum performance, it is recommended that applications disable automatic incremental merge and instead use the &lt;a href=&quot;fts3#*fts4mergecmd&quot;&gt;&quot;merge&quot; command&lt;/a&gt; in an idle process to keep the inverted indices well merged. But if the structure of an application does not easily allow for idle processes, the use of automatic incremental merge is a very reasonable fallback solution.</source>
          <target state="translated">Обратной стороной автоматического добавочного слияния является то, что при нем каждая операция INSERT, UPDATE и DELETE в таблице FTS3 / 4 выполняется немного медленнее, поскольку для выполнения добавочного слияния требуется дополнительное время. Для максимальной производительности рекомендуется, чтобы приложения отключили автоматическое добавочное слияние и вместо этого использовали команду &lt;a href=&quot;fts3#*fts4mergecmd&quot;&gt;&amp;laquo;слияние&amp;raquo;&lt;/a&gt; в процессе ожидания, чтобы обеспечить хорошее слияние инвертированных индексов. Но если структура приложения не позволяет легко простаивать процессы, использование автоматического добавочного слияния является очень разумным резервным решением.</target>
        </trans-unit>
        <trans-unit id="c77ebced48dfa7e23a77c44a167057f7558d4f17" translate="yes" xml:space="preserve">
          <source>The downside of storing schema a text is that it can make the schema tricky to modify. And for that reason, the ALTER TABLE support in SQLite has traditionally lagged behind other SQL database engines that store their schemas as parsed system tables that are easier to modify.</source>
          <target state="translated">Недостатком хранения схемы в тексте является то,что это может сделать схему хитрой для изменения.И по этой причине поддержка ALTER TABLE в SQLite традиционно отстает от других движков БД SQL,которые хранят свои схемы в виде разобранных системных таблиц,которые легче модифицировать.</target>
        </trans-unit>
        <trans-unit id="1bd6a18e90f1a8ee8256e02fe4825c2a58f166f7" translate="yes" xml:space="preserve">
          <source>The dynamic webpages on the SQLite website are mostly generated by the &lt;a href=&quot;https://www.fossil-scm.org/&quot;&gt;Fossil version control system&lt;/a&gt;. A typical dynamic page would be a timeline such as &lt;a href=&quot;https://www.sqlite.org/src/timeline&quot;&gt;https://www.sqlite.org/src/timeline&lt;/a&gt;. A log of all SQL used by the timeline is shown below.</source>
          <target state="translated">Динамические веб-страницы на веб-сайте SQLite в основном создаются &lt;a href=&quot;https://www.fossil-scm.org/&quot;&gt;системой контроля версий Fossil&lt;/a&gt; . Типичная динамическая страница - это временная шкала, например &lt;a href=&quot;https://www.sqlite.org/src/timeline&quot;&gt;https://www.sqlite.org/src/timeline&lt;/a&gt; . Журнал всего SQL, используемого временной шкалой, показан ниже.</target>
        </trans-unit>
        <trans-unit id="f53c608dfb99715244babeb0f18e6bedb4ce61c6" translate="yes" xml:space="preserve">
          <source>The eTextRep argument determines the encoding of strings passed to the collating function callback, xCallback. The &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16&lt;/a&gt; and &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16_ALIGNED&lt;/a&gt; values for eTextRep force strings to be UTF16 with native byte order. The &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16_ALIGNED&lt;/a&gt; value for eTextRep forces strings to begin on an even byte address.</source>
          <target state="translated">Аргумент eTextRep определяет кодировку строк, передаваемых в функцию обратного вызова функции сортировки, xCallback. Значения &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16&lt;/a&gt; и &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16_ALIGNED&lt;/a&gt; для eTextRep заставляют строки быть UTF16 с собственным порядком байтов. Значение &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16_ALIGNED&lt;/a&gt; для eTextRep заставляет строки начинаться с четного байтового адреса.</target>
        </trans-unit>
        <trans-unit id="1f8a73896c29d2961fd12e3fd13060416db06dbd" translate="yes" xml:space="preserve">
          <source>The eTextRep argument determines the encoding of strings passed to the collating function callback, xCallback. The &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16&lt;/a&gt; and &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16_ALIGNED&lt;/a&gt; values for eTextRep force strings to be UTF16 with native byte order. The &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16_ALIGNED&lt;/a&gt; value for eTextRep forces strings to begin on an even byte address.</source>
          <target state="translated">Аргумент eTextRep определяет кодировку строк, передаваемых в функцию обратного вызова функции сортировки, xCallback. Значения &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16&lt;/a&gt; и &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16_ALIGNED&lt;/a&gt; для eTextRep заставляют строки быть UTF16 с собственным порядком байтов. Значение &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16_ALIGNED&lt;/a&gt; для eTextRep заставляет строки начинаться с четного байтового адреса.</target>
        </trans-unit>
        <trans-unit id="4013154ef9b1afc10a2efd1408a9638085e650fc" translate="yes" xml:space="preserve">
          <source>The eTextRep argument determines the encoding of strings passed to the collating function callback, xCompare. The &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16&lt;/a&gt; and &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16_ALIGNED&lt;/a&gt; values for eTextRep force strings to be UTF16 with native byte order. The &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16_ALIGNED&lt;/a&gt; value for eTextRep forces strings to begin on an even byte address.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7222f354f082d59aa96eba0376b7b091cc4ec0bd" translate="yes" xml:space="preserve">
          <source>The eTextRep argument determines the encoding of strings passed to the collating function callback, xCompare. The &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16&lt;/a&gt; and &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16_ALIGNED&lt;/a&gt; values for eTextRep force strings to be UTF16 with native byte order. The &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16_ALIGNED&lt;/a&gt; value for eTextRep forces strings to begin on an even byte address.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af71ae840c72707272be3031b3c3ee6f45c5d71f" translate="yes" xml:space="preserve">
          <source>The edit distance coefficients are normally read from the APPCOST table once and there after stored in memory. Hence, run-time changes to the APPCOST table will not normally affect the edit distance results. However, inserting the special string 'reset' into the &quot;command&quot; column of the virtual table causes the edit distance coefficients to be reread the APPCOST table. Hence, applications should run a SQL statement similar to the following when changes to the APPCOST table occur:</source>
          <target state="translated">Коэффициенты расстояния редактирования обычно считываются из таблицы APPCOST один раз и туда после сохранения в памяти.Следовательно,изменения во времени выполнения APPCOST таблицы обычно не влияют на результаты расстояния редактирования.Однако,вставка специальной строки &quot;сброс&quot; в столбец &quot;команда&quot; виртуальной таблицы приводит к тому,что коэффициенты расстояния редактирования будут перечитываться из таблицы APPCOST.Следовательно,при изменении таблицы APPCOST приложения должны запускать SQL-оператор,аналогичный приведённому ниже:</target>
        </trans-unit>
        <trans-unit id="49994af0743488763f79d75d2c9c86ebfda2dfb6" translate="yes" xml:space="preserve">
          <source>The edit program can also be used as a viewer, by simply ignoring the return value. For example, to merely look at the image above, you might run:</source>
          <target state="translated">Программа редактирования также может быть использована в качестве программы просмотра,просто игнорируя возвращаемое значение.Например,чтобы просто посмотреть на изображение выше,можно запустить программу:</target>
        </trans-unit>
        <trans-unit id="47a4a763ba31495e47240c644f7558e9498bae30" translate="yes" xml:space="preserve">
          <source>The edit() function can be used to make changes to large text values. For example:</source>
          <target state="translated">Функция edit()может быть использована для внесения изменений в большие текстовые значения.Например:</target>
        </trans-unit>
        <trans-unit id="fd34f0d751c4ddc69b221f64ffd45f8927b66781" translate="yes" xml:space="preserve">
          <source>The editdist3 algorithm is a function that computes the minimum edit distance (a.k.a. the Levenshtein distance) between two input strings. The editdist3 algorithm is a configurable alternative to the default edit distance function of spellfix1. Features of editdist3 include:</source>
          <target state="translated">Алгоритм editdist3-это функция,которая вычисляет минимальное расстояние редактирования (также известное как расстояние Левенштейна)между двумя входными строками.Алгоритм editdist3 является настраиваемой альтернативой стандартной функции расстояния редактирования орфографической ошибки1.К особенностям editdist3 относятся:</target>
        </trans-unit>
        <trans-unit id="870b1bf5bd7c0178ecc9a04d5313cc57bc40b4f1" translate="yes" xml:space="preserve">
          <source>The effects of a &lt;b&gt;truncate file&lt;/b&gt; operation are not assumed to be made persistent until after the corresponding file has been</source>
          <target state="translated">Предполагается, что эффекты операции с &lt;b&gt;файлом усечения&lt;/b&gt; не будут сохраняться до тех пор, пока не будет выполнен соответствующий файл.</target>
        </trans-unit>
        <trans-unit id="393d1077fa976da06b2c81028e0e667751bfce07" translate="yes" xml:space="preserve">
          <source>The empty-result-callbacks flag affects the &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec()&lt;/a&gt; API only. Normally, when the empty-result-callbacks flag is cleared, the callback function supplied to the &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec()&lt;/a&gt; is not invoked for commands that return zero rows of data. When empty-result-callbacks is set in this situation, the callback function is invoked exactly once, with the third parameter set to 0 (NULL). This is to enable programs that use the &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec()&lt;/a&gt; API to retrieve column-names even when a query returns no data.</source>
          <target state="translated">Флаг empty-result-callbacks влияет только на API &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec ()&lt;/a&gt; . Обычно, когда флаг empty-result-callbacks сброшен, функция обратного вызова, предоставленная &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec ()&lt;/a&gt; , не вызывается для команд, возвращающих нулевые строки данных. Когда в этой ситуации заданы обратные вызовы с пустым результатом, функция обратного вызова вызывается ровно один раз, с третьим параметром, установленным в 0 (NULL). Это позволяет программам, использующим API &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec (),&lt;/a&gt; получать имена столбцов, даже если запрос не возвращает данных.</target>
        </trans-unit>
        <trans-unit id="f1a25180fc453bfc9b7157e5b028aa8235fc10f5" translate="yes" xml:space="preserve">
          <source>The end-user executes DML or DDL SQL statements that require the structure of the database file of the database file to be modified. These modifications may be any combination of operations to</source>
          <target state="translated">Конечный пользователь выполняет операторы DML или DDL SQL,которые требуют изменения структуры файла базы данных.Эти изменения могут быть любой комбинацией операций</target>
        </trans-unit>
        <trans-unit id="5b923462226ca9a3f1ea2da34aa276431384d659" translate="yes" xml:space="preserve">
          <source>The ending frame boundary can be omitted (if the BETWEEN and AND keywords that surround the starting frame boundary are also omitted), in which case the ending frame boundary defaults to CURRENT ROW.</source>
          <target state="translated">Граница конечного кадра может быть опущена (если опущены также ключевые слова BETWEEN и AND,окружающие границу начального кадра),в этом случае граница конечного кадра по умолчанию устанавливается в CURRENT ROW.</target>
        </trans-unit>
        <trans-unit id="b26c1d5670afb707a661dd133bd85c139805e555" translate="yes" xml:space="preserve">
          <source>The ending frame boundary may not take a form that appears higher in the above list than the starting frame boundary.</source>
          <target state="translated">Граница заканчивающейся рамки не может иметь форму,которая появляется выше в списке выше,чем граница стартовой рамки.</target>
        </trans-unit>
        <trans-unit id="1133a1a20cf9f9901ca7376082c18ed0b6c4a36d" translate="yes" xml:space="preserve">
          <source>The engine no longer consults the main table if it can get all the information it needs from an index.</source>
          <target state="translated">Двигатель больше не консультируется с основной таблицей,если он может получить всю необходимую информацию из индекса.</target>
        </trans-unit>
        <trans-unit id="b873e4983f185f34587580faeee301ccc43a5a88" translate="yes" xml:space="preserve">
          <source>The enhanced query syntax supports the AND, OR and NOT binary set operators. Each of the two operands to an operator may be a basic FTS query, or the result of another AND, OR or NOT set operation. Operators must be entered using capital letters. Otherwise, they are interpreted as basic term queries instead of set operators.</source>
          <target state="translated">Расширенный синтаксис запросов поддерживает операторы AND,OR и NOT двоичного множества.Каждый из двух операндов к оператору может быть основным запросом FTS или результатом другой операции задания AND,OR или NOT.Операторы должны вводиться с использованием заглавных букв.В противном случае они интерпретируются как основные запросы терминов,а не как заданные операторы.</target>
        </trans-unit>
        <trans-unit id="ec0a2d5aa63b2e3b719340bb237dcfc9aebe4443" translate="yes" xml:space="preserve">
          <source>The entries above might represent (for example) a bounding box around the main office for SQLite.org and bounding box around the 12th Congressional District of North Carolina (prior to the 2011 redistricting) in which SQLite.org was located.</source>
          <target state="translated">Приведенные выше записи могут представлять собой (например)граничное поле вокруг главного офиса для SQLite.org и граничное поле вокруг 12-го округа Конгресса Северной Каролины (до перекрёстка 2011 года),в котором находился SQLite.org.</target>
        </trans-unit>
        <trans-unit id="df23c9e0d03ef84c1b3ecc39ad637f8b14bf70ea" translate="yes" xml:space="preserve">
          <source>The entry point is zProc. zProc may be 0, in which case SQLite will try to come up with an entry point name on its own. It first tries &quot;sqlite3_extension_init&quot;. If that does not work, it constructs a name &quot;sqlite3_X_init&quot; where the X is consists of the lower-case equivalent of all ASCII alphabetic characters in the filename from the last &quot;/&quot; to the first following &quot;.&quot; and omitting any initial &quot;lib&quot;. The sqlite3_load_extension() interface returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; on success and &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt; if something goes wrong. If an error occurs and pzErrMsg is not 0, then the &lt;a href=&quot;#sqlite3_load_extension&quot;&gt;sqlite3_load_extension()&lt;/a&gt; interface shall attempt to fill *pzErrMsg with error message text stored in memory obtained from &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc()&lt;/a&gt;. The calling function should free this memory by calling &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free()&lt;/a&gt;.</source>
          <target state="translated">Точка входа - zProc. zProc может иметь значение 0, и в этом случае SQLite попытается самостоятельно указать имя точки входа. Сначала он пробует sqlite3_extension_init. Если это не сработает, создается имя &amp;laquo;sqlite3_X_init&amp;raquo;, где X состоит из строчных эквивалентов всех буквенных символов ASCII в имени файла от последнего &amp;laquo;/&amp;raquo; до первого следующего &amp;laquo;&amp;raquo;. и опуская любую начальную &quot;lib&quot;. Интерфейс sqlite3_load_extension () возвращает &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; в случае успеха и &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR,&lt;/a&gt; если что-то пойдет не так. Если возникает ошибка и pzErrMsg не равно 0, то интерфейс &lt;a href=&quot;#sqlite3_load_extension&quot;&gt;sqlite3_load_extension ()&lt;/a&gt; должен попытаться заполнить * pzErrMsg текстом сообщения об ошибке, хранящимся в памяти, полученным из &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc ()&lt;/a&gt;. Вызывающая функция должна освободить эту память, вызвав &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4f2e7b718e4064a2f8cc8acbe7a051458f014ce0" translate="yes" xml:space="preserve">
          <source>The entry point is zProc. zProc may be 0, in which case SQLite will try to come up with an entry point name on its own. It first tries &quot;sqlite3_extension_init&quot;. If that does not work, it constructs a name &quot;sqlite3_X_init&quot; where the X is consists of the lower-case equivalent of all ASCII alphabetic characters in the filename from the last &quot;/&quot; to the first following &quot;.&quot; and omitting any initial &quot;lib&quot;. The sqlite3_load_extension() interface returns &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; on success and &lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt; if something goes wrong. If an error occurs and pzErrMsg is not 0, then the &lt;a href=&quot;load_extension&quot;&gt;sqlite3_load_extension()&lt;/a&gt; interface shall attempt to fill *pzErrMsg with error message text stored in memory obtained from &lt;a href=&quot;free&quot;&gt;sqlite3_malloc()&lt;/a&gt;. The calling function should free this memory by calling &lt;a href=&quot;free&quot;&gt;sqlite3_free()&lt;/a&gt;.</source>
          <target state="translated">Точка входа - zProc. zProc может иметь значение 0, и в этом случае SQLite попытается самостоятельно указать имя точки входа. Сначала он пробует sqlite3_extension_init. Если это не сработает, создается имя &amp;laquo;sqlite3_X_init&amp;raquo;, где X состоит из строчных эквивалентов всех буквенных символов ASCII в имени файла от последнего &amp;laquo;/&amp;raquo; до первого следующего &amp;laquo;&amp;raquo;. и опуская любую начальную &quot;lib&quot;. Интерфейс sqlite3_load_extension () возвращает &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; в случае успеха и &lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR,&lt;/a&gt; если что-то пойдет не так. Если возникает ошибка и pzErrMsg не равно 0, то интерфейс &lt;a href=&quot;load_extension&quot;&gt;sqlite3_load_extension ()&lt;/a&gt; должен попытаться заполнить * pzErrMsg текстом сообщения об ошибке, хранящимся в памяти, полученным из &lt;a href=&quot;free&quot;&gt;sqlite3_malloc ()&lt;/a&gt;. Вызывающая функция должна освободить эту память, вызвав &lt;a href=&quot;free&quot;&gt;sqlite3_free ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c3b2f6eda62654fcc0bcaa7e0b88feb088762bb7" translate="yes" xml:space="preserve">
          <source>The error arises because only about the first 15 significant digits of each number are stored accurately, and first the difference between the two numbers being subtracted is in the 16th digit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="456b9f2431df57bc4265718d78e0c8afe5c20d2e" translate="yes" xml:space="preserve">
          <source>The error arises because only about the first 15 significant digits of each number are stored accurately, and the first difference between the two numbers being subtracted is in the 16th digit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40007c6bf4af7619580a2e5c3ec81a4fee4ad813" translate="yes" xml:space="preserve">
          <source>The error code is changed to &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; (instead of &lt;a href=&quot;rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt;) when an attempt is made to &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt; while one or more queries are still pending.</source>
          <target state="translated">Код ошибки изменяется на &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; (вместо &lt;a href=&quot;rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt; ), когда делается попытка &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK,&lt;/a&gt; когда один или несколько запросов все еще ожидают обработки.</target>
        </trans-unit>
        <trans-unit id="2e60aa60ea376ea9ca807c8cc7d0b0b91ec054e5" translate="yes" xml:space="preserve">
          <source>The error codes for SQLite version 3 are unchanged from version 2. They are as follows:</source>
          <target state="translated">Коды ошибок для SQLite версии 3 не изменились по сравнению с версией 2.Они выглядят следующим образом:</target>
        </trans-unit>
        <trans-unit id="2ccece93e5a00d5f5d9d7a6919183b3a66f82129" translate="yes" xml:space="preserve">
          <source>The error logger callback function might look something like this:</source>
          <target state="translated">Функция обратного вызова регистратора ошибок может выглядеть примерно так:</target>
        </trans-unit>
        <trans-unit id="8ad007677ae545b2ad036dc3fbfd526afb2a9647" translate="yes" xml:space="preserve">
          <source>The error logger callback should be treated like a signal handler. The application should save off or otherwise process the error, then return as soon as possible. No other SQLite APIs should be invoked, directly or indirectly, from the error logger. SQLite is &lt;u&gt;not&lt;/u&gt; reentrant through the error logger callback. In particular, the error logger callback is invoked when a memory allocation fails, so it is generally a bad idea to try to allocate memory inside the error logger. Do not even think about trying to store the error message in another SQLite database.</source>
          <target state="translated">Обратный вызов регистратора ошибок следует рассматривать как обработчик сигнала. Приложение должно сохранить или иным образом обработать ошибку, а затем вернуться как можно скорее. Никакие другие API SQLite не должны вызываться прямо или косвенно из регистратора ошибок. SQLite &lt;u&gt;не&lt;/u&gt; поддерживает повторный вход через обратный вызов регистратора ошибок. В частности, обратный вызов регистратора ошибок вызывается при сбое выделения памяти, поэтому, как правило, попытки выделить память внутри регистратора ошибок - плохая идея. Даже не думайте о попытке сохранить сообщение об ошибке в другой базе данных SQLite.</target>
        </trans-unit>
        <trans-unit id="931b7a49e1d266b8f7af8c59c48646cf4fc9a825" translate="yes" xml:space="preserve">
          <source>The error messages that might be sent to the error logger and their exact format is subject to changes from one release to the next. So applications should not depend on any particular error message text formats or error codes. Things do not change capriciously, but they do sometimes changes.</source>
          <target state="translated">Сообщения об ошибках,которые могут быть отправлены в регистратор ошибок,и их точный формат могут изменяться от одного выпуска к другому.Поэтому приложения не должны зависеть от конкретных форматов текстовых сообщений об ошибках или кодов ошибок.Вещи не меняются капризно,но иногда меняются.</target>
        </trans-unit>
        <trans-unit id="6f0f73d0eed4daf2fa7ce504b606f01da04260dc" translate="yes" xml:space="preserve">
          <source>The estimatedCost field should be set to the estimated number of disk access operations required to execute this query against the virtual table. The SQLite core will often call xBestIndex multiple times with different constraints, obtain multiple cost estimates, then choose the query plan that gives the lowest estimate. The SQLite core initializes estimatedCost to a very large value prior to invoking xBestIndex, so if xBestIndex determines that the current combination of parameters is undesirable, it can leave the estimatedCost field unchanged to discourage its use.</source>
          <target state="translated">Поле estimatedCost должно быть установлено в соответствие с предполагаемым количеством операций доступа к диску,необходимых для выполнения этого запроса к виртуальной таблице.Ядро SQLite часто вызывает xBestIndex несколько раз с различными ограничениями,получает несколько оценок стоимости,затем выбирает план запроса,который дает самую низкую оценку.Ядро SQLite инициализирует estimatedCost до очень большого значения перед вызовом xBestIndex,поэтому,если xBestIndex определит,что текущая комбинация параметров является нежелательной,он может оставить поле estimatedCost без изменений,чтобы предотвратить его использование.</target>
        </trans-unit>
        <trans-unit id="9110d26065cfada658af48dd22a731f2e42c4634" translate="yes" xml:space="preserve">
          <source>The estimatedCost value is an estimate of the cost of a particular strategy. A cost of N indicates that the cost of the strategy is similar to a linear scan of an SQLite table with N rows. A cost of log(N) indicates that the expense of the operation is similar to that of a binary search on a unique indexed field of an SQLite table with N rows.</source>
          <target state="translated">Оценочная стоимость представляет собой оценку стоимости конкретной стратегии.Стоимость N указывает на то,что стоимость стратегии аналогична линейному сканированию таблицы SQLite с N строками.Стоимость журнала(N)указывает на то,что стоимость операции аналогична стоимости двоичного поиска по уникальному индексированному полю таблицы SQLite с N строками.</target>
        </trans-unit>
        <trans-unit id="a1d11ebb28b1bb46c038273ece9416f81d29642b" translate="yes" xml:space="preserve">
          <source>The estimatedRows value is an estimate of the number of rows that will be returned by the strategy.</source>
          <target state="translated">Значение estimateRows является оценкой количества строк,которые будут возвращены стратегией.</target>
        </trans-unit>
        <trans-unit id="6e98b869e8e492045895b07f0da4a451a3b65571" translate="yes" xml:space="preserve">
          <source>The exact logic used to determine if a</source>
          <target state="translated">Точная логика,используемая для определения</target>
        </trans-unit>
        <trans-unit id="c7341ca7ddb26c5a501b148a51edcbd920ab7841" translate="yes" xml:space="preserve">
          <source>The exact same source code can be used for both a run-time loadable shared library or DLL and as a module that is statically linked with your application. This provides flexibility and allows you to reuse the same code in different ways.</source>
          <target state="translated">Точно такой же исходный код может быть использован как для загружаемой во время выполнения разделяемой библиотеки или DLL,так и в качестве модуля,статически связанного с вашим приложением.Это обеспечивает гибкость и позволяет повторно использовать один и тот же код различными способами.</target>
        </trans-unit>
        <trans-unit id="51d3ce62c3eb93876d401465d70f8ba808604db2" translate="yes" xml:space="preserve">
          <source>The example above causes the database file named &quot;ex1.db&quot; to be opened and used. The &quot;ex1.db&quot; file is created if it does not previously exist. You might want to use a full pathname to ensure that the file is in the directory that you think it is in. Use forward-slashes as the directory separator character. In other words use &quot;c:/work/ex1.db&quot;, not &quot;c:\work\ex1.db&quot;.</source>
          <target state="translated">В приведенном выше примере открывается и используется файл БД с именем &quot;ex1.db&quot;.Файл &quot;ex1.db&quot; создается,если он ранее не существовал.Возможно,вы захотите использовать полное имя,чтобы убедиться,что файл находится в каталоге,в котором,как вы думаете,он находится.Используйте прямые косые черты в качестве символа разделителя каталогов.Другими словами,используйте &quot;c:/work/ex1.db&quot;,а не &quot;c:\work\ex1.db&quot;.</target>
        </trans-unit>
        <trans-unit id="97b14b6298ce84315e618c11d7722d98fb92421a" translate="yes" xml:space="preserve">
          <source>The example above contains two &quot;SCALAR&quot; subqueries. The subqueries are SCALAR in the sense that they return a single value - a one-row, one-column table. If the actual query returns more than that, then only the first column of the first row is used.</source>
          <target state="translated">Пример выше содержит два подзапроса &quot;SCALAR&quot;.Подзапросы являются SCALAR-ами в том смысле,что они возвращают одно значение-однострочную таблицу с одной колонкой.Если фактический запрос возвращает больше,то используется только первый столбец первой строки.</target>
        </trans-unit>
        <trans-unit id="d7a7c3999051bd06566a95bdd9bc9de8e3e4adaa" translate="yes" xml:space="preserve">
          <source>The example above illustrates the signature of the error logger callback. However, in an embedded application, one usually does not print messages on stderr. Instead, one might store the messages in a preallocated circular buffer where they can be accessed when diagnostic information is needed during debugging. Or perhaps the messages can be sent to &lt;a href=&quot;http://en.wikipedia.org/wiki/Syslog&quot;&gt;Syslog&lt;/a&gt;. Somehow, the messages need to be stored where they are accessible to developers, not displayed to end users.</source>
          <target state="translated">В приведенном выше примере показана подпись обратного вызова регистратора ошибок. Однако во встроенном приложении сообщения на stderr обычно не выводятся. Вместо этого можно сохранить сообщения в заранее выделенном кольцевом буфере, где к ним можно будет получить доступ, когда во время отладки потребуется диагностическая информация. Или, возможно, сообщения можно отправлять в &lt;a href=&quot;http://en.wikipedia.org/wiki/Syslog&quot;&gt;системный журнал&lt;/a&gt; . Каким-то образом сообщения необходимо хранить там, где они доступны разработчикам, а не показывать конечным пользователям.</target>
        </trans-unit>
        <trans-unit id="6fc4d45b4003fc3925ac8f8341dab42290a2d223" translate="yes" xml:space="preserve">
          <source>The example above illustrates the signature of the error logger callback. However, in an embedded application, one usually does not print messages on stderr. Instead, one might store the messages in a preallocated circular buffer where they can be accessed when diagnostic information is needed during debugging. Or perhaps the messages can be sent to &lt;a href=&quot;https://en.wikipedia.org/wiki/Syslog&quot;&gt;Syslog&lt;/a&gt;. Somehow, the messages need to be stored where they are accessible to developers, not displayed to end users.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d307547a7cd9c2e8e0dc86cacf98f3de8afb55c2" translate="yes" xml:space="preserve">
          <source>The example above showed a single &lt;b&gt;filename='thefile.csv'&lt;/b&gt; argument for the CSV virtual table. But other arguments are also possible.</source>
          <target state="translated">В приведенном выше примере показан единственный аргумент &lt;b&gt;filename = 'thefile.csv'&lt;/b&gt; для виртуальной таблицы CSV. Но возможны и другие аргументы.</target>
        </trans-unit>
        <trans-unit id="11a05b76af4570008579a529531a96eb802e047d" translate="yes" xml:space="preserve">
          <source>The example above shows SQLite picking full-table scan will visit all rows in the table. If the query were able to use an index, then the SCAN/SEARCH record would include the name of the index and, for a SEARCH record, an indication of how the subset of rows visited is identified. For example:</source>
          <target state="translated">Приведенный выше пример показывает,что при выборе SQLite полноэкранного сканирования будут посещены все строки таблицы.Если бы запрос мог использовать индекс,то SCAN/SEARCH-запись включала бы имя индекса,а для SEARCH-записи-указание на то,как идентифицируется подмножество посещенных строк.Например:</target>
        </trans-unit>
        <trans-unit id="abd381887f2ea42f76bfd9ebc8b17425d16e2957" translate="yes" xml:space="preserve">
          <source>The example below uses ntile() to divide the six rows into two groups (the ntile(2) call) and into four groups (the ntile(4) call). For ntile(2), there are three rows assigned to each group. For ntile(4), there are two groups of two and two groups of one. The larger groups of two appear first.</source>
          <target state="translated">В приведенном ниже примере используется функция ntile()для разделения шести строк на две группы (вызов ntile(2))и четыре группы (вызов ntile(4)).Для ntile(2)каждой группе назначено по три строки.Для петли(4)имеется две группы по две и две группы по одной.Сначала появляются две большие группы.</target>
        </trans-unit>
        <trans-unit id="c8ad72613a1253e10b2aeefbfa091cedb3448e07" translate="yes" xml:space="preserve">
          <source>The example code below demonstrates the steps involved in capturing a changeset while executing SQL commands. In summary:</source>
          <target state="translated">Приведенный ниже пример кода демонстрирует шаги,связанные с захватом changeset при выполнении SQL-команд.Подводя итог:</target>
        </trans-unit>
        <trans-unit id="cfda7c494f05312b3bf7826ec92aff6df2e44b46" translate="yes" xml:space="preserve">
          <source>The example code below demonstrates the techniques used to iterate through and extract the data related to all changes in a changeset. To summarize:</source>
          <target state="translated">Приведенный ниже пример кода демонстрирует методы,используемые для итерации и извлечения данных,связанных со всеми изменениями в changeset.Подводя итог:</target>
        </trans-unit>
        <trans-unit id="5dde8802fcba008ca09e765d610fcb4f5bf326ca" translate="yes" xml:space="preserve">
          <source>The example code below uses the second of the methods enumerated above - it monitors for changes on all database tables.</source>
          <target state="translated">Приведенный ниже пример кода использует второй из перечисленных выше методов-он отслеживает изменения на всех таблицах БД.</target>
        </trans-unit>
        <trans-unit id="3f036ecd22d9629ed467ac2dbb67b517f12166ad" translate="yes" xml:space="preserve">
          <source>The examples above all use basic full-text term queries as both operands of the set operations demonstrated. Phrase and NEAR queries may also be used, as may the results of other set operations. When more than one set operation is present in an FTS query, the precedence of operators is as follows:</source>
          <target state="translated">В приведенных выше примерах в качестве обоих продемонстрированных операндов множества операций используются базовые полнотекстовые запросы терминов.Могут также использоваться фразовые и NEAR-запросы,а также результаты других операций множества.Когда в запросе ПВТ присутствует несколько множественных операций,приоритет операторов следующий:</target>
        </trans-unit>
        <trans-unit id="1921013ee1678e9933f635ab4c9457e39025bfc3" translate="yes" xml:space="preserve">
          <source>The examples below identify the collating sequences that would be used to determine the results of text comparisons that may be performed by various SQL statements. Note that a text comparison may not be required, and no collating sequence used, in the case of numeric, blob or NULL values.</source>
          <target state="translated">В приведенных ниже примерах определены последовательности сопоставления,которые будут использоваться для определения результатов сопоставления текста,которые могут быть выполнены различными SQL-операторами.Обратите внимание,что текстовое сравнение может не потребоваться,а в случае числовых,блочных или NULL-значений коллекционная последовательность не используется.</target>
        </trans-unit>
        <trans-unit id="367a92feb39a9287f4306f6946c319f7064a8b02" translate="yes" xml:space="preserve">
          <source>The examples in this section all assume that the database is populated as follows:</source>
          <target state="translated">Все примеры в этом разделе предполагают,что БД заполнена следующим образом:</target>
        </trans-unit>
        <trans-unit id="c2bd8a896b6e33422d64448169403c1bc373cf0d" translate="yes" xml:space="preserve">
          <source>The examples in this section all assume the following data:</source>
          <target state="translated">Все примеры в этом разделе предполагают следующие данные:</target>
        </trans-unit>
        <trans-unit id="4d8c3a17bac2c4be1cb9b2d64248454f5513cff9" translate="yes" xml:space="preserve">
          <source>The exception mentioned above is that if the declaration of a column with declared type &quot;INTEGER&quot; includes an &quot;PRIMARY KEY DESC&quot; clause, it does not become an alias for the rowid and is not classified as an integer primary key. This quirk is not by design. It is due to a bug in early versions of SQLite. But fixing the bug could result in backwards incompatibilities. Hence, the original behavior has been retained (and documented) because odd behavior in a corner case is far better than a compatibility break. This means that the following three table declarations all cause the column &quot;x&quot; to be an alias for the rowid (an integer primary key):</source>
          <target state="translated">Исключение,упомянутое выше,состоит в том,что если объявление столбца с объявленным типом &quot;INTEGER&quot; включает в себя выражение &quot;PRIMARY KEY DESC&quot;,то оно не становится псевдонимом для rowid и не классифицируется как целочисленный первичный ключ.Эта причуда не является преднамеренной.Она вызвана ошибкой в ранних версиях SQLite.Но исправление ошибки может привести к обратной несовместимости.Следовательно,первоначальное поведение было сохранено (и задокументировано),потому что странное поведение в угловом случае намного лучше,чем разрыв совместимости.Это означает,что все три нижеследующие декларации таблицы приводят к тому,что столбец &quot;x&quot; является псевдонимом для rowid (целочисленного первичного ключа):</target>
        </trans-unit>
        <trans-unit id="3fca028858f76596a98f86d48ac0ce09545ac4bf" translate="yes" xml:space="preserve">
          <source>The executable format really ends up being just an implementation detail. The key point is that all languages have a compiler step which translates programs into an executable format and a run step that executes the compiled program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f41b51d024f674a1f6149c31aede1e868d7d56cf" translate="yes" xml:space="preserve">
          <source>The existence of a transaction depends on whether or not the rollback journal file exists and the deletion of a file appears to be an atomic operation from the point of view of a user-space process. Therefore, a transaction appears to be an atomic operation.</source>
          <target state="translated">Существование транзакции зависит от того,существует ли файл журнала отката,а удаление файла представляется с точки зрения пользовательского пространства атомарной операцией.Следовательно,транзакция выглядит как атомарная операция.</target>
        </trans-unit>
        <trans-unit id="6021cb5e88d7481ca7795a9ddd0c04e6033fc0e0" translate="yes" xml:space="preserve">
          <source>The existing INSERT is removed from the changegroup. The DELETE is not added.</source>
          <target state="translated">Существующий INSERT удаляется из группы изменений.УДАЛЕНИЕ не добавляется.</target>
        </trans-unit>
        <trans-unit id="4a2b5a6b7a6bdb1833a8cf1e839e065d174385dc" translate="yes" xml:space="preserve">
          <source>The existing UPDATE is replaced by the new DELETE within the changegroup.</source>
          <target state="translated">Существующая UPDATE заменяется новой DELETE в группе изменений.</target>
        </trans-unit>
        <trans-unit id="5c1e2e9de2a17cfdc315c14e1e74a36e45b9c92f" translate="yes" xml:space="preserve">
          <source>The existing UPDATE remains within the changegroup. It is amended so that the accompanying values are as if the row was updated once by the existing change and then again by the new change.</source>
          <target state="translated">Существующая дата UPDATE остается в группе изменений.Она изменяется таким образом,что сопроводительные значения как если бы строка была обновлена один раз существующим изменением,а затем снова новым изменением.</target>
        </trans-unit>
        <trans-unit id="fca9185c8e0eb9e3e49b7068e021cf8a710c066e" translate="yes" xml:space="preserve">
          <source>The explicit COMMIT command runs immediately, even if there are pending &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statements. However, if there are pending write operations, the COMMIT command will fail with an error code &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;.</source>
          <target state="translated">Явная команда COMMIT выполняется немедленно, даже если есть ожидающие &lt;a href=&quot;lang_select&quot;&gt;выполнения&lt;/a&gt; инструкции SELECT . Однако, если есть ожидающие операции записи, команда COMMIT завершится ошибкой с кодом &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e2d16a733bb795b8f24e0161c9bf1e3201567a34" translate="yes" xml:space="preserve">
          <source>The expression &quot;+column&quot; is now considered the same as &quot;column&quot; when computing the collating sequence to use on the expression.</source>
          <target state="translated">Выражение &quot;+столбец&quot; теперь считается таким же,как и &quot;столбец&quot; при вычислении коллатирующей последовательности для использования в выражении.</target>
        </trans-unit>
        <trans-unit id="fee373e0e83d3368c40362493777ab8e984bd97b" translate="yes" xml:space="preserve">
          <source>The expression &quot;a BETWEEN b AND c&quot; is treated as two separate binary comparisons &quot;a &amp;gt;= b AND a &amp;lt;= c&quot;, even if that means different affinities are applied to 'a' in each of the comparisons. Datatype conversions in comparisons of the form &quot;x IN (SELECT y ...)&quot; are handled is if the comparison were really &quot;x=y&quot;. The expression &quot;a IN (x, y, z, ...)&quot; is equivalent to &quot;a = +x OR a = +y OR a = +z OR ...&quot;. In other words, the values to the right of the IN operator (the &quot;x&quot;, &quot;y&quot;, and &quot;z&quot; values in this example) are considered to have no affinity, even if they happen to be column values or CAST expressions.</source>
          <target state="translated">Выражение &amp;laquo;a BETWEEN b AND c&amp;raquo; обрабатывается как два отдельных двоичных сравнения &amp;laquo;a&amp;gt; = b AND a &amp;lt;= c&amp;raquo;, даже если это означает, что к &amp;laquo;a&amp;raquo; в каждом из сравнений применяются разные аффинности. Преобразования типов данных при сравнении формы &amp;laquo;x IN (SELECT y ...)&amp;raquo; обрабатываются, если сравнение действительно было &amp;laquo;x = y&amp;raquo;. Выражение &amp;laquo;a IN (x, y, z, ...)&amp;raquo; эквивалентно &amp;laquo;a = + x OR a = + y OR a = + z OR ...&amp;raquo;. Другими словами, значения справа от оператора IN (значения &amp;laquo;x&amp;raquo;, &amp;laquo;y&amp;raquo; и &amp;laquo;z&amp;raquo; в этом примере) считаются не имеющими сродства, даже если они являются значениями столбцов или выражениями CAST. .</target>
        </trans-unit>
        <trans-unit id="15a424b3e7e4f20cd419dc00af0824f2446f3f50" translate="yes" xml:space="preserve">
          <source>The expression &quot;x BETWEEN y and z&quot; is logically equivalent to two comparisons &quot;x &amp;gt;= y AND x &amp;lt;= z&quot; and works with respect to collating functions as if it were two separate comparisons. The expression &quot;x IN (SELECT y ...)&quot; is handled in the same way as the expression &quot;x = y&quot; for the purposes of determining the collating sequence. The collating sequence used for expressions of the form &quot;x IN (y, z, ...)&quot; is the collating sequence of x.</source>
          <target state="translated">Выражение &amp;laquo;x BETWEEN y and z&amp;raquo; логически эквивалентно двум сравнениям &amp;laquo;x&amp;gt; = y AND x &amp;lt;= z&amp;raquo; и работает в отношении функций сопоставления, как если бы это были два отдельных сравнения. Выражение &amp;laquo;x IN (SELECT y ...)&amp;raquo; обрабатывается таким же образом, как и выражение &amp;laquo;x = y&amp;raquo; для определения последовательности сортировки. Последовательность упорядочения, используемая для выражений вида &amp;laquo;x IN (y, z, ...)&amp;raquo;, является последовательностью упорядочения x.</target>
        </trans-unit>
        <trans-unit id="70c0ccea32ba2d8b128981db932845adc7b90c4c" translate="yes" xml:space="preserve">
          <source>The expression &quot;x BETWEEN y and z&quot; is logically equivalent to two comparisons &quot;x &amp;gt;= y AND x &amp;lt;= z&quot; and works with respect to collating functions as if it were two separate comparisons. The expression &quot;x IN (SELECT y ...)&quot; is handled in the same way as the expression &quot;x = y&quot; for the purposes of determining the collating sequence. The collating sequence used for expressions of the form &quot;x IN (y, z, ...)&quot; is the collating sequence of x. If an explicit collating sequence is required on an IN operator it should be applied to the left operand, like this: &quot;x COLLATE nocase IN (y,z, ...)&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c6d1934b411c6401d1051c4d7453826ea7a9843" translate="yes" xml:space="preserve">
          <source>The expression attached to the optional OFFSET clause that may follow a LIMIT clause must also evaluate to an integer, or a value that can be losslessly converted to an integer. If an expression has an OFFSET clause, then the first M rows are omitted from the result set returned by the SELECT statement and the next N rows are returned, where M and N are the values that the OFFSET and LIMIT clauses evaluate to, respectively. Or, if the SELECT would return less than M+N rows if it did not have a LIMIT clause, then the first M rows are skipped and the remaining rows (if any) are returned. If the OFFSET clause evaluates to a negative value, the results are the same as if it had evaluated to zero.</source>
          <target state="translated">Выражение,приложенное к необязательному пункту OFFSET,которое может следовать за пунктом LIMIT,должно также вычисляться в целое число или в значение,которое может быть без потерь преобразовано в целое число.Если выражение имеет условие OFFSET,то первые M строк опускаются из набора результатов,возвращаемого оператором SELECT,а следующие N строк возвращаются,где M и N-это значения,которые клаузулы OFFSET и LIMIT оценивают соответственно.Или,если SELECT возвращает меньше M+N строк,если в нем нет пункта LIMIT,то пропускаются первые M строк и возвращаются оставшиеся строки (если таковые имеются).Если условие OFFSET оценивает отрицательное значение,результаты будут такими же,как если бы оно оценивалось до нуля.</target>
        </trans-unit>
        <trans-unit id="1cd8c2a06181abbb52fb772c5e4393bf493adec9" translate="yes" xml:space="preserve">
          <source>The expression following the WHERE clause may contain operators, literal values, and names of columns in the table being indexed. The WHERE clause may &lt;em&gt;not&lt;/em&gt; contain subqueries, references to other tables, &lt;a href=&quot;deterministic&quot;&gt;non-deterministic functions&lt;/a&gt;, or &lt;a href=&quot;lang_expr#varparam&quot;&gt;bound parameters&lt;/a&gt;.</source>
          <target state="translated">Выражение, следующее за предложением WHERE, может содержать операторы, буквальные значения и имена столбцов в индексируемой таблице. Предложение WHERE &lt;em&gt;не&lt;/em&gt; может содержать подзапросы, ссылки на другие таблицы, &lt;a href=&quot;deterministic&quot;&gt;недетерминированные функции&lt;/a&gt; или &lt;a href=&quot;lang_expr#varparam&quot;&gt;связанные параметры&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1c1e099acc66b957c91a242e71ab41548df3e15b" translate="yes" xml:space="preserve">
          <source>The expression of a generated column can refer to any of the other declared columns in the table, including other generated columns, as long as the expression does not directly or indirectly refer back to itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4cd71176d0cd745c21cb3b1319609677077ace52" translate="yes" xml:space="preserve">
          <source>The expression of a generated column may not directly reference the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt;, though it can reference the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; column, which is often the same thing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67b0f355cc2989c7cff5a5d8658f4cccd6f86732" translate="yes" xml:space="preserve">
          <source>The expression of a generated column may only reference constant literals and columns within the same row, and may only use scalar &lt;a href=&quot;deterministic&quot;&gt;deterministic functions&lt;/a&gt;. The expression may not use subqueries, aggregate functions, window functions, or table-valued functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3177e05d9fce52b64c04ddd90d24e41132bbd994" translate="yes" xml:space="preserve">
          <source>The expression of a generated column may refer to other generated columns in the same row, but no generated column can depend upon itself, either directly or indirectly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa57007d3af78002775463ea997fdbb172a0c191" translate="yes" xml:space="preserve">
          <source>The extension loading mechanism of SQLite (accessed using the &lt;a href=&quot;lang_corefunc#load_extension&quot;&gt;load_extension()&lt;/a&gt; SQL function) is turned off by default. This is a security precaution. If an application wants to make use of the &lt;a href=&quot;lang_corefunc#load_extension&quot;&gt;load_extension()&lt;/a&gt; function it must first turn the capability on using this method.</source>
          <target state="translated">Механизм загрузки расширений SQLite (доступ к которому осуществляется с помощью функции SQL &lt;a href=&quot;lang_corefunc#load_extension&quot;&gt;load_extension ()&lt;/a&gt; ) по умолчанию отключен. Это мера безопасности. Если приложение хочет использовать &lt;a href=&quot;lang_corefunc#load_extension&quot;&gt;функцию load_extension (),&lt;/a&gt; оно должно сначала включить эту возможность с помощью этого метода.</target>
        </trans-unit>
        <trans-unit id="bbd9a40496de97ba5cfcabba824166980ee9d8c1" translate="yes" xml:space="preserve">
          <source>The extra write overhead prompted a reexamination of assumptions about powersafe overwrite. With modern disk drives, the capacity has become so large and the data density so great that a single sector is very small and writing a single sector takes very little time. We know that disk drives can detect an impending power loss and continue to operate for some small amount of time on residual energy because those drives are able to park their heads before spinning down. And so if an impending power loss is detectable by the disk controller, it seems reasonable that the controller will finish writing whatever sector it is current working on when the imminent power loss is first detected, prior to parking the heads, as long as doing so does not take too long, which it should not with small and dense sectors. Hence it seems reasonable to assume powersafe overwrite for modern disks. Indeed, BerkeleyDB has made this assumption for decades, we are told. Caution is advised though. As Roger Binns noted on the SQLite developers mailing list: &quot;'poorly written' should be the main assumption about drive firmware.&quot;</source>
          <target state="translated">Дополнительные накладные расходы на запись заставили пересмотреть предположения о перезаписи в режиме энергосбережения.С современными дисковыми накопителями емкость стала настолько велика,а плотность данных настолько велика,что один сектор очень мал,а запись одного сектора занимает очень мало времени.Мы знаем,что дисковые накопители могут обнаружить надвигающуюся потерю энергии и продолжать работать в течение некоторого небольшого количества времени на остаточной энергии,потому что эти накопители способны парковать свои головы перед вращением вниз.И поэтому,если предстоящая потеря мощности обнаруживается контроллером диска,кажется разумным,что контроллер закончит запись любого сектора,над которым он работает в данный момент,при первом обнаружении неминуемой потери мощности,до парковки головок,при условии,что это не займет слишком много времени,что не должно происходить при работе с малыми и плотными секторами.Поэтому представляется разумным предположить безопасную для питания перезапись для современных дисков.Действительно,BerkeleyDB делает это предположение на протяжении десятилетий,как нам говорят.Тем не менее,следует быть осторожным.Как отметил Роджер Биннс в списке рассылки разработчиков SQLite:&quot;плохо написанное&quot; должно быть основным предположением о прошивке диска&quot;.</target>
        </trans-unit>
        <trans-unit id="f31765748ec404a72a387c3ce457db0e7fddb3f0" translate="yes" xml:space="preserve">
          <source>The fact that NULLs are distinct for UNIQUE columns but are indistinct for SELECT DISTINCT and UNION continues to be puzzling. It seems that NULLs should be either distinct everywhere or nowhere. And the SQL standards documents suggest that NULLs should be distinct everywhere. Yet as of this writing, no SQL engine tested treats NULLs as distinct in a SELECT DISTINCT statement or in a UNION.</source>
          <target state="translated">Тот факт,что NULLs различаются для столбцов UNIQUE,но неразличимы для SELECT DISTINCT и UNION,продолжает вызывать недоумение.Похоже,что NULLs должны быть либо везде,либо нигде.А в документах по стандартам SQL говорится,что NULL должны быть разными везде.Тем не менее,на момент написания этой статьи ни один SQL-движок,протестированный,не рассматривает NULL как различные в заявлении SELECT DISTINCT или в UNION.</target>
        </trans-unit>
        <trans-unit id="36716fd190ed79338836da067e34479b294afa61" translate="yes" xml:space="preserve">
          <source>The fact that SQLite is embedded and &lt;a href=&quot;serverless&quot;&gt;serverless&lt;/a&gt; instead of being client/server is a feature, not a bug.</source>
          <target state="translated">Тот факт, что SQLite является встроенным и &lt;a href=&quot;serverless&quot;&gt;бессерверным,&lt;/a&gt; а не клиент-серверным, является функцией, а не ошибкой.</target>
        </trans-unit>
        <trans-unit id="893ade2ecf018b089d7d0c2f18f2d37a93397ea0" translate="yes" xml:space="preserve">
          <source>The fifth argument to the BLOB and string binding interfaces is a destructor used to dispose of the BLOB or string after SQLite has finished with it. The destructor is called to dispose of the BLOB or string even if the call to the bind API fails, except the destructor is not called if the third parameter is a NULL pointer or the fourth parameter is negative. If the fifth argument is the special value &lt;a href=&quot;#SQLITE_STATIC&quot;&gt;SQLITE_STATIC&lt;/a&gt;, then SQLite assumes that the information is in static, unmanaged space and does not need to be freed. If the fifth argument has the value &lt;a href=&quot;#SQLITE_STATIC&quot;&gt;SQLITE_TRANSIENT&lt;/a&gt;, then SQLite makes its own private copy of the data immediately, before the sqlite3_bind_*() routine returns.</source>
          <target state="translated">Пятый аргумент интерфейсов привязки BLOB и строки - это деструктор, используемый для удаления BLOB или строки после того, как SQLite завершит работу с ними. Деструктор вызывается для удаления BLOB или строки, даже если вызов API привязки завершается неудачно, за исключением того, что деструктор не вызывается, если третий параметр является указателем NULL или четвертый параметр имеет отрицательное значение. Если пятым аргументом является специальное значение &lt;a href=&quot;#SQLITE_STATIC&quot;&gt;SQLITE_STATIC&lt;/a&gt; , тогда SQLite предполагает, что информация находится в статическом неуправляемом пространстве и не требует освобождения. Если пятый аргумент имеет значение &lt;a href=&quot;#SQLITE_STATIC&quot;&gt;SQLITE_TRANSIENT&lt;/a&gt; , то SQLite создает свою собственную частную копию данных немедленно, до возврата из процедуры sqlite3_bind _ * ().</target>
        </trans-unit>
        <trans-unit id="e68c8434fb7585b2fc0da0f853455aed19727f06" translate="yes" xml:space="preserve">
          <source>The fifth argument to the BLOB and string binding interfaces is a destructor used to dispose of the BLOB or string after SQLite has finished with it. The destructor is called to dispose of the BLOB or string even if the call to the bind API fails, except the destructor is not called if the third parameter is a NULL pointer or the fourth parameter is negative. If the fifth argument is the special value &lt;a href=&quot;c_static&quot;&gt;SQLITE_STATIC&lt;/a&gt;, then SQLite assumes that the information is in static, unmanaged space and does not need to be freed. If the fifth argument has the value &lt;a href=&quot;c_static&quot;&gt;SQLITE_TRANSIENT&lt;/a&gt;, then SQLite makes its own private copy of the data immediately, before the sqlite3_bind_*() routine returns.</source>
          <target state="translated">Пятый аргумент интерфейсов привязки BLOB и строки - это деструктор, используемый для удаления BLOB или строки после того, как SQLite завершит работу с ними. Деструктор вызывается для удаления BLOB или строки, даже если вызов API привязки завершается неудачно, за исключением того, что деструктор не вызывается, если третий параметр является указателем NULL или четвертый параметр имеет отрицательное значение. Если пятым аргументом является специальное значение &lt;a href=&quot;c_static&quot;&gt;SQLITE_STATIC&lt;/a&gt; , тогда SQLite предполагает, что информация находится в статическом неуправляемом пространстве и не требует освобождения. Если пятый аргумент имеет значение &lt;a href=&quot;c_static&quot;&gt;SQLITE_TRANSIENT&lt;/a&gt; , то SQLite создает свою собственную частную копию данных немедленно, до возврата из процедуры sqlite3_bind _ * ().</target>
        </trans-unit>
        <trans-unit id="901b5e438fd14b98c5489ac30117b7e4f79582ec" translate="yes" xml:space="preserve">
          <source>The fifth argument, xCallback, is a pointer to the collating function. Multiple collating functions can be registered using the same name but with different eTextRep parameters and SQLite will use whichever function requires the least amount of data transformation. If the xCallback argument is NULL then the collating function is deleted. When all collating functions having the same name are deleted, that collation is no longer usable.</source>
          <target state="translated">Пятый аргумент,xCallback,это указатель на функцию сравнения.Несколько функций коллатинга могут быть зарегистрированы под одним и тем же именем,но с разными параметрами eTextRep,и SQLite будет использовать ту функцию,которая требует наименьшего объема трансформации данных.Если аргумент xCallback равен NULL,то функция коллатинга удаляется.Когда все функции-компиляторы с одинаковыми именами удаляются,эта компиляция больше не может быть использована.</target>
        </trans-unit>
        <trans-unit id="9b66d05a972406caa6b8e66ca673681eea81f8a6" translate="yes" xml:space="preserve">
          <source>The fifth argument, xCompare, is a pointer to the collating function. Multiple collating functions can be registered using the same name but with different eTextRep parameters and SQLite will use whichever function requires the least amount of data transformation. If the xCompare argument is NULL then the collating function is deleted. When all collating functions having the same name are deleted, that collation is no longer usable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a3d71778e0851af7f19eb98c05ebd04280b893c" translate="yes" xml:space="preserve">
          <source>The fifth parameter is an arbitrary pointer. The implementation of the function can gain access to this pointer using &lt;a href=&quot;#sqlite3_user_data&quot;&gt;sqlite3_user_data()&lt;/a&gt;.</source>
          <target state="translated">Пятый параметр - произвольный указатель. Реализация функции может получить доступ к этому указателю с помощью &lt;a href=&quot;#sqlite3_user_data&quot;&gt;sqlite3_user_data ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8991c375d182bf0ed874e01ceb3c3fba4c90a4d1" translate="yes" xml:space="preserve">
          <source>The fifth parameter is an arbitrary pointer. The implementation of the function can gain access to this pointer using &lt;a href=&quot;user_data&quot;&gt;sqlite3_user_data()&lt;/a&gt;.</source>
          <target state="translated">Пятый параметр - произвольный указатель. Реализация функции может получить доступ к этому указателю с помощью &lt;a href=&quot;user_data&quot;&gt;sqlite3_user_data ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8b5fa94425e25711d656d2caafbaef27474f2b42" translate="yes" xml:space="preserve">
          <source>The file I/O implementation can use the object type flags to change the way it deals with files. For example, an application that does not care about crash recovery or rollback might make the open of a journal file a no-op. Writes to this journal would also be no-ops, and any attempt to read the journal would return SQLITE_IOERR. Or the implementation might recognize that a database file will be doing page-aligned sector reads and writes in a random order and set up its I/O subsystem accordingly.</source>
          <target state="translated">Реализация файлового ввода/вывода может использовать флаги типа объекта для изменения способа работы с файлами.Например,приложение,которое не заботится о восстановлении после сбоя или откате,может сделать открытие файла журнала нерабочим.Запись в этот журнал также была бы no-ops,и любая попытка чтения журнала возвращала бы SQLITE_IOERR.Или же реализация может распознать,что файл базы данных будет выполнять чтение и запись выровненных по страницам секторов в случайном порядке и соответствующим образом настроить свою подсистему ввода/вывода.</target>
        </trans-unit>
        <trans-unit id="2ace627b4eb1891a06a62ee2e61523c0922ec242" translate="yes" xml:space="preserve">
          <source>The file I/O implementation can use the object type flags to changes the way it deals with files. For example, an application that does not care about crash recovery or rollback, might make the open of a journal file a no-op. Writes to this journal are also a no-op. Any attempt to read the journal returns &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt;. Or the implementation might recognize the a database file will be doing page-aligned sector reads and writes in a random order and set up its I/O subsystem accordingly. SQLite might also add one of the following flags to the xOpen method:</source>
          <target state="translated">Реализация файлового ввода-вывода может использовать флаги типа объекта, чтобы изменить способ работы с файлами. Например, приложение, которое не заботится о восстановлении после сбоя или откате, может заблокировать открытие файла журнала. Записи в этот журнал также запрещены. Любая попытка прочитать журнал возвращает &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt; . Или реализация может распознать, что файл базы данных будет выполнять чтение и запись с выравниванием по страницам в произвольном порядке, и соответствующим образом настроить свою подсистему ввода-вывода. SQLite может также добавить один из следующих флагов к методу xOpen:</target>
        </trans-unit>
        <trans-unit id="339116ded6000b1bbd01c16fbc4b426fdbec3ebf" translate="yes" xml:space="preserve">
          <source>The file change counter is a 4-byte big-endian integer at offset 24 that is incremented whenever the database file is unlocked after having been modified. When two or more processes are reading the same database file, each process can detect database changes from other processes by monitoring the change counter. A process will normally want to flush its database page cache when another process modified the database, since the cache has become stale. The file change counter facilitates this.</source>
          <target state="translated">Счетчик изменений файлов представляет собой 4-байтовое биг-ендианное целое число со смещением 24,которое инкрементируется всякий раз,когда файл базы данных разблокирован после его изменения.Когда два или более процесса считывают один и тот же файл базы данных,каждый процесс может обнаружить изменения в базе данных от других процессов,отслеживая счетчик изменений.Обычно процесс хочет очистить кэш страниц базы данных,когда другой процесс изменил базу данных,так как кэш стал черствым.Счетчик изменений файлов облегчает это.</target>
        </trans-unit>
        <trans-unit id="3144a807afc9a81e0cce3e084ad085692d9830bb" translate="yes" xml:space="preserve">
          <source>The file format can be extended in future releases simply by adding new tables and/or column, preserving backwards compatibility.</source>
          <target state="translated">Формат файла может быть расширен в будущих релизах простым добавлением новых таблиц и/или столбцов,сохраняя обратную совместимость.</target>
        </trans-unit>
        <trans-unit id="e6aaed4a8d57b71607b8967869bcc7f23189ec3d" translate="yes" xml:space="preserve">
          <source>The file format for indices was changed slightly in order to work around an inefficiency that can sometimes come up with GDBM when there are large indices having many entries with the same key. ** Incompatible Change **</source>
          <target state="translated">Формат файлов для индексов был несколько изменен,чтобы работать вокруг неэффективности,которая иногда может прийти в голову GDBM,когда есть большие индексы,имеющие много записей с одним и тем же ключом.**Несовместимое изменение</target>
        </trans-unit>
        <trans-unit id="227aafe2527e84f2018568e74a1b6b84889b7a1b" translate="yes" xml:space="preserve">
          <source>The file format write version and file format read version at offsets 18 and 19 are intended to allow for enhancements of the file format in future versions of SQLite. In current versions of SQLite, both of these values are 1 for rollback journalling modes and 2 for &lt;a href=&quot;wal&quot;&gt;WAL&lt;/a&gt; journalling mode. If a version of SQLite coded to the current file format specification encounters a database file where the read version is 1 or 2 but the write version is greater than 2, then the database file must be treated as read-only. If a database file with a read version greater than 2 is encountered, then that database cannot be read or written.</source>
          <target state="translated">Версия для записи формата файла и версия для чтения в формате файла на смещениях 18 и 19 предназначены для улучшения формата файла в будущих версиях SQLite. В текущих версиях SQLite оба эти значения: 1 для режимов журналирования отката и 2 для режима журналирования &lt;a href=&quot;wal&quot;&gt;WAL&lt;/a&gt; . Если версия SQLite, закодированная в соответствии с текущей спецификацией формата файла, встречает файл базы данных, где версия для чтения равна 1 или 2, но версия для записи больше 2, то файл базы данных должен рассматриваться как доступный только для чтения. Если обнаружен файл базы данных с версией чтения больше 2, то эта база данных не может быть прочитана или записана.</target>
        </trans-unit>
        <trans-unit id="57007ced430f8a0cf3127ebbd04af2dceb5d897b" translate="yes" xml:space="preserve">
          <source>The file-handle open on the</source>
          <target state="translated">Ручка-файл открыта на</target>
        </trans-unit>
        <trans-unit id="b75893e55d63ac0a30441dba63c6c7335b33555b" translate="yes" xml:space="preserve">
          <source>The file-system</source>
          <target state="translated">Файловая система</target>
        </trans-unit>
        <trans-unit id="e3cc87e79b2a7545d431775230c50e5146077116" translate="yes" xml:space="preserve">
          <source>The filename can be interpreted as a URI if this flag is set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1f230eea69094b4593dd99813cb077b78f99716" translate="yes" xml:space="preserve">
          <source>The filename for the database to be attached is the value of the expression that occurs before the AS keyword. The filename of the database follows the same semantics as the filename argument to &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt; and &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;; the special name &quot;&lt;a href=&quot;inmemorydb&quot;&gt;:memory:&lt;/a&gt;&quot; results in an &lt;a href=&quot;inmemorydb&quot;&gt;in-memory database&lt;/a&gt; and an empty string results in a new temporary database. The filename argument can be a &lt;a href=&quot;uri&quot;&gt;URI filename&lt;/a&gt; if URI filename processing is enable on the database connection. The default behavior is for URI filenames to be disabled, however that might change in a future release of SQLite, so application developers are advised to plan accordingly.</source>
          <target state="translated">Имя файла для присоединяемой базы данных - это значение выражения, которое стоит перед ключевым словом AS. Имя файла базы данных следует той же семантике, что и аргумент имени файла для &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open ()&lt;/a&gt; и &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2 ()&lt;/a&gt; ; специальное имя &quot; &lt;a href=&quot;inmemorydb&quot;&gt;: memory:&lt;/a&gt; &quot; приводит к &lt;a href=&quot;inmemorydb&quot;&gt;базе данных в памяти,&lt;/a&gt; а пустая строка приводит к новой временной базе данных. Аргументом имени файла может быть &lt;a href=&quot;uri&quot;&gt;имя файла URI,&lt;/a&gt; если обработка имени файла URI включена для соединения с базой данных. По умолчанию имена файлов URI отключены, однако это может измениться в будущих версиях SQLite, поэтому разработчикам приложений рекомендуется планировать соответствующие действия.</target>
        </trans-unit>
        <trans-unit id="f17e1c0d84ff3c2fe25d0856ea88c3fbd19c5fb1" translate="yes" xml:space="preserve">
          <source>The filename in the INTO clause can be an arbitrary SQL expression that evaluates to a string. The file named by the INTO clause must not previously exist, or else it must be an empty file, or the VACUUM INTO command will fail with an error.</source>
          <target state="translated">Имя файла в выражении INTO может быть произвольным SQL выражением,которое вычисляется в строку.Файл,названный с помощью выражения INTO,не должен существовать ранее,иначе он должен быть пустым файлом,иначе команда VACUUM INTO выйдет из строя с ошибкой.</target>
        </trans-unit>
        <trans-unit id="d4df05c7fc29b7702e9fa3ab7eeeb629cbcad3f5" translate="yes" xml:space="preserve">
          <source>The filename returned by this function is the output of the xFullPathname method of the &lt;a href=&quot;../vfs&quot;&gt;VFS&lt;/a&gt;. In other words, the filename will be an absolute pathname, even if the filename used to open the database originally was a URI or relative pathname.</source>
          <target state="translated">Имя файла, возвращаемое этой функцией, является выводом метода xFullPathname &lt;a href=&quot;../vfs&quot;&gt;VFS&lt;/a&gt; . Другими словами, имя файла будет абсолютным путем, даже если имя файла, используемое для открытия базы данных, изначально было URI или относительным путем.</target>
        </trans-unit>
        <trans-unit id="9485b160522d31184c8916615322f5219f0612b8" translate="yes" xml:space="preserve">
          <source>The filename returned by this function is the output of the xFullPathname method of the &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;. In other words, the filename will be an absolute pathname, even if the filename used to open the database originally was a URI or relative pathname.</source>
          <target state="translated">Имя файла, возвращаемое этой функцией, является выводом метода xFullPathname &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; . Другими словами, имя файла будет абсолютным путем, даже если имя файла, используемое для открытия базы данных, изначально было URI или относительным путем.</target>
        </trans-unit>
        <trans-unit id="fc318f399f5ecbc4db919258057f39b26883fdf3" translate="yes" xml:space="preserve">
          <source>The final answer is found by looking for a string with ind==0. If the original sudoku problem did not have a unique solution, then the query will return all possible solutions. If the original problem was unsolvable, then no rows will be returned. In this case, the unique answer is:</source>
          <target state="translated">Окончательный ответ найден путем поиска строки с ind==0.Если оригинальная задача sudoku не имела уникального решения,то запрос вернет все возможные решения.Если оригинальная задача была неразрешимой,то строки возвращаться не будут.В этом случае уникальным ответом будет:</target>
        </trans-unit>
        <trans-unit id="0fa7031611bf07c03077958f2b8ed29a77590306" translate="yes" xml:space="preserve">
          <source>The final argument is an output variable. If successful, (*ppOut) should be set to point to the new tokenizer handle and SQLITE_OK returned. If an error occurs, some value other than SQLITE_OK should be returned. In this case, fts5 assumes that the final value of *ppOut is undefined.</source>
          <target state="translated">Последним аргументом является выходная переменная.В случае успеха (*ppOut)необходимо указать на новый хэндл токенайзера и вернуть SQLITE_OK.В случае ошибки должно быть возвращено некоторое значение,отличное от SQLITE_OK.В этом случае fts5 предполагает,что конечное значение *ppOut не определено.</target>
        </trans-unit>
        <trans-unit id="3adcbd65298a5982e7a64803692e07245861c301" translate="yes" xml:space="preserve">
          <source>The final byte of an encoded FTS varint has its most significant bit cleared. All preceding bytes have the most significant bit set. Data is stored in the remaining seven least significant bits of each byte. The first byte of the encoded representation contains the least significant seven bits of the encoded integer value. The second byte of the encoded representation, if it is present, contains the seven next least significant bits of the integer value, and so on. The following table contains examples of encoded integer values:</source>
          <target state="translated">Последний байт закодированного варинта FTS очищен от наиболее значимого бита.Все предыдущие байты имеют наиболее значащий набор битов.Данные хранятся в оставшихся семи младших битах каждого байта.Первый байт кодированного представления содержит семь младших значащих битов кодированного целого значения.Второй байт кодированного представления,если он присутствует,содержит семь следующих младших значащих битов целого значения и так далее.В следующей таблице приведены примеры кодированных целочисленных значений:</target>
        </trans-unit>
        <trans-unit id="c65b7966b6f5867eece6741b751cabc0c349ca6a" translate="yes" xml:space="preserve">
          <source>The final line of the example (the &quot;.system c:/work/dataout.csv&quot;) has the same effect as double-clicking on the c:/work/dataout.csv file in windows. This will typically bring up a spreadsheet program to display the CSV file.</source>
          <target state="translated">Последняя строка примера (&quot;.system c:/work/dataout.csv&quot;)имеет тот же эффект,что и двойной щелчок на файле c:/work/dataout.csv в окнах.Обычно это вызовет программу электронной таблицы для отображения CSV-файла.</target>
        </trans-unit>
        <trans-unit id="312ab3f0c70e0337ccdf666710177cbb51a2f6d3" translate="yes" xml:space="preserve">
          <source>The final query in the block above may not work as expected. Because the &quot;*&quot; character is inside the double-quotes, it will be passed to the tokenizer, which will likely discard it (or perhaps, depending on the specific tokenizer in use, include it as part of the final token) instead of recognizing it as a special FTS character.</source>
          <target state="translated">Последний запрос в вышеуказанном блоке может работать не так,как ожидалось.Поскольку символ &quot;*&quot; находится внутри двойных кавычек,он будет передан токенайзеру,который,скорее всего,отбросит его (или,возможно,в зависимости от используемого токенайзера,включит его в состав конечной токена),вместо того,чтобы распознавать его как специальный символ FTS.</target>
        </trans-unit>
        <trans-unit id="a564ec7adef18f2e787e1258b9aed3803202963e" translate="yes" xml:space="preserve">
          <source>The final recovery step is to reduce the exclusive lock back to a shared lock. Once this happens, the database is back in the state that it would have been if the aborted transaction had never started. Since all of this recovery activity happens completely automatically and transparently, it appears to the program using SQLite as if the aborted transaction had never begun.</source>
          <target state="translated">Последний шаг восстановления-уменьшение эксклюзивного замка до общего.Как только это происходит,база данных возвращается в то состояние,в котором она была бы,если бы прерванная транзакция никогда не начиналась.Поскольку вся эта деятельность по восстановлению происходит полностью автоматически и прозрачно,программе,использующей SQLite,кажется,что прерванная транзакция никогда не начиналась.</target>
        </trans-unit>
        <trans-unit id="434e32f7c5be2c22a40571665c3031a75ce803d2" translate="yes" xml:space="preserve">
          <source>The final source of large memory allocations is the space to hold the &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statements&lt;/a&gt; that result from compiling complex SQL operations. Ongoing work by the SQLite developers is reducing the amount of space required here. But large and complex queries might still require &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statements&lt;/a&gt; that are several kilobytes in size. The only workaround at the moment is for the application to break complex SQL operations up into two or more smaller and simpler operations contained in separate &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statements&lt;/a&gt;.</source>
          <target state="translated">Последним источником выделения больших объемов памяти является пространство для хранения &lt;a href=&quot;c3ref/stmt&quot;&gt;подготовленных операторов&lt;/a&gt; , являющихся результатом компиляции сложных операций SQL. Продолжающаяся работа разработчиков SQLite сокращает объем требуемого здесь места. Но для больших и сложных запросов все же могут потребоваться &lt;a href=&quot;c3ref/stmt&quot;&gt;подготовленные операторы&lt;/a&gt; размером в несколько килобайт. Единственный обходной путь на данный момент заключается в том, что приложение разбивает сложные операции SQL на две или более более мелких и простых операций, содержащихся в отдельных &lt;a href=&quot;c3ref/stmt&quot;&gt;подготовленных операторах&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2e5be990568c2b06d13617fdb20a3f4473d59b9c" translate="yes" xml:space="preserve">
          <source>The final step in a multi-file commit is to delete the individual rollback journals and drop the exclusive locks on the database files so that other processes can see the changes. This corresponds to &lt;a href=&quot;#section_3_12&quot;&gt;step 3.12&lt;/a&gt; in the single-file commit sequence.</source>
          <target state="translated">Последним шагом в многофайловой фиксации является удаление отдельных журналов отката и снятие монопольных блокировок с файлов базы данных, чтобы другие процессы могли видеть изменения. Это соответствует &lt;a href=&quot;#section_3_12&quot;&gt;шагу 3.12&lt;/a&gt; в последовательности фиксации одного файла.</target>
        </trans-unit>
        <trans-unit id="570119a07afaf61a9f20cf9abd68b217ebf33834" translate="yes" xml:space="preserve">
          <source>The final three arguments passed to the auxiliary function callback are similar to the three arguments passed to the implementation of a scalar SQL function. All arguments except the first passed to the auxiliary function are available to the implementation in the apVal[] array. The implementation should return a result or error via the content handle pCtx.</source>
          <target state="translated">Последние три аргумента,переданные во вспомогательную функцию обратного вызова,аналогичны трем аргументам,переданным в реализацию скалярной SQL-функции.Все аргументы,кроме первого,переданного вспомогательной функции,доступны для реализации в массиве apVal[].Реализация должна возвращать результат или ошибку через хэндл содержимого pCtx.</target>
        </trans-unit>
        <trans-unit id="72acf6716754df5bf7660108439b7caacc7e6afa" translate="yes" xml:space="preserve">
          <source>The first 100 bytes of the database file comprise the database file header. The database file header is divided into fields as shown by the table below. All multibyte fields in the database file header are stored with the most significant byte first (big-endian).</source>
          <target state="translated">Первые 100 байт файла БД составляют заголовок файла БД.Заголовок файла БД разделен на поля,как показано в таблице ниже.Все многобайтовые поля в заголовке файла БД хранятся с самым старшим байтом (big-endian).</target>
        </trans-unit>
        <trans-unit id="7ad8baeb9b6a7d25df8e53c7bba57a3b07d6a12e" translate="yes" xml:space="preserve">
          <source>The first 136 bytes of the shm file are a header. The shm header has three main divisions as follows:</source>
          <target state="translated">Первые 136 байт файла shm-это заголовок.Заголовок шма имеет три основных разделения следующим образом:</target>
        </trans-unit>
        <trans-unit id="32a4d848523b5982a35dd9ccae2a5e300c48ac95" translate="yes" xml:space="preserve">
          <source>The first 8 bytes of the</source>
          <target state="translated">Первые 8 байт</target>
        </trans-unit>
        <trans-unit id="31e639e14579d85dee4c60a5aeaa903eaa1984f2" translate="yes" xml:space="preserve">
          <source>The first argument must be the sqlite3_index_info object that is the first parameter to the xBestIndex() method. The second argument must be an index into the aConstraint[] array belonging to the sqlite3_index_info structure passed to xBestIndex. This function returns a pointer to a buffer containing the name of the collation sequence for the corresponding constraint.</source>
          <target state="translated">Первым аргументом должен быть объект sqlite3_index_info,который является первым параметром метода xBestIndex().Вторым аргументом должен быть индекс в массиве aConstraint[],принадлежащем структуре sqlite3_index_info,переданный xBestIndex.Эта функция возвращает указатель на буфер,содержащий имя последовательности сравнения для соответствующего ограничения.</target>
        </trans-unit>
        <trans-unit id="756a3aef230a7b2fc01840e9c05f1d8a68c861b7" translate="yes" xml:space="preserve">
          <source>The first argument passed should be the database handle to register the extension with. The second and third arguments should both be passed 0.</source>
          <target state="translated">Первым аргументом должен быть хэндл БД для регистрации расширения.Второй и третий аргументы должны быть переданы 0.</target>
        </trans-unit>
        <trans-unit id="7fa580625e479f237836af3af275aa2f6a47351d" translate="yes" xml:space="preserve">
          <source>The first argument passed to an auxiliary function callback is a pointer to a structure containing methods that may be invoked in order to obtain information regarding the current query or row. The second argument is an opaque handle that should be passed as the first argument to any such method invocation. For example, the following auxiliary function definition returns the total number of tokens in all columns of the current row:</source>
          <target state="translated">Первый аргумент,передаваемый на обратный вызов вспомогательной функции-это указатель на структуру,содержащую методы,которые могут быть вызваны для получения информации о текущем запросе или строке.Второй аргумент-непрозрачный хэндл,который должен передаваться в качестве первого аргумента при вызове любого такого метода.Например,следующее определение вспомогательной функции возвращает общее количество лексем во всех столбцах текущей строки:</target>
        </trans-unit>
        <trans-unit id="d4428415829da9afdeca7abddd54df2e62906cce" translate="yes" xml:space="preserve">
          <source>The first argument passed to this function is a copy of the (void*) pointer provided by the application when the fts5_tokenizer object was registered with FTS5 (the third argument to xCreateTokenizer()). The second and third arguments are an array of nul-terminated strings containing the tokenizer arguments, if any, specified following the tokenizer name as part of the CREATE VIRTUAL TABLE statement used to create the FTS5 table.</source>
          <target state="translated">Первый аргумент,передаваемый в эту функцию,является копией указателя (void*),предоставленного приложением при регистрации объекта fts5_tokenizer в FTS5 (третий аргумент в xCreateTokenizer()).Второй и третий аргументы представляют собой массив нуль-терминированных строк,содержащих аргументы токенайзера,если таковые имеются,заданные после имени токенайзера в составе оператора CREATE VIRTUAL TABLE,используемого для создания таблицы FTS5.</target>
        </trans-unit>
        <trans-unit id="3ddc48958f41facca8a1ecdc60ac948a59cb2349" translate="yes" xml:space="preserve">
          <source>The first argument to &lt;a href=&quot;c3ref/declare_vtab&quot;&gt;sqlite3_declare_vtab()&lt;/a&gt; must be the same &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; pointer as the first parameter to this method. The second argument to &lt;a href=&quot;c3ref/declare_vtab&quot;&gt;sqlite3_declare_vtab()&lt;/a&gt; must a zero-terminated UTF-8 string that contains a well-formed &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; statement that defines the columns in the virtual table and their data types. The name of the table in this CREATE TABLE statement is ignored, as are all constraints. Only the column names and datatypes matter. The CREATE TABLE statement string need not to be held in persistent memory. The string can be deallocated and/or reused as soon as the &lt;a href=&quot;c3ref/declare_vtab&quot;&gt;sqlite3_declare_vtab()&lt;/a&gt; routine returns.</source>
          <target state="translated">Первый аргумент &lt;a href=&quot;c3ref/declare_vtab&quot;&gt;sqlite3_declare_vtab ()&lt;/a&gt; должен быть тем же указателем &lt;a href=&quot;c3ref/sqlite3&quot;&gt;соединения с базой данных,&lt;/a&gt; что и первый параметр этого метода. Второй аргумент &lt;a href=&quot;c3ref/declare_vtab&quot;&gt;sqlite3_declare_vtab ()&lt;/a&gt; должен содержать строку UTF-8 с нулевым символом в конце, которая содержит правильно сформированный оператор &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; , определяющий столбцы в виртуальной таблице и их типы данных. Имя таблицы в этом операторе CREATE TABLE игнорируется, как и все ограничения. Имеют значение только имена столбцов и типы данных. Строку оператора CREATE TABLE не обязательно хранить в постоянной памяти. Строку можно освободить и / или использовать повторно, как только процедура &lt;a href=&quot;c3ref/declare_vtab&quot;&gt;sqlite3_declare_vtab ()&lt;/a&gt; вернется.</target>
        </trans-unit>
        <trans-unit id="1aed5522193a69fc6ff8aa89cff3e41266a3f600" translate="yes" xml:space="preserve">
          <source>The first argument to all three special SQL scalar functions must be the &lt;a href=&quot;fts3#hiddencol&quot;&gt;FTS hidden column&lt;/a&gt; of the FTS table that the function is applied to. The &lt;a href=&quot;fts3#hiddencol&quot;&gt;FTS hidden column&lt;/a&gt; is an automatically-generated column found on all FTS tables that has the same name as the FTS table itself. For example, given an FTS table named &quot;mail&quot;:</source>
          <target state="translated">Первым аргументом всех трех специальных скалярных функций SQL должен быть &lt;a href=&quot;fts3#hiddencol&quot;&gt;скрытый столбец&lt;/a&gt; FTS таблицы FTS, к которой применяется функция. &lt;a href=&quot;fts3#hiddencol&quot;&gt;FTS скрытый столбец&lt;/a&gt; является автоматически генерируемый столбец найдены на всех FTS таблиц, имеет такое же имя , как и сама таблица FTS. Например, для таблицы FTS с именем &amp;laquo;mail&amp;raquo;:</target>
        </trans-unit>
        <trans-unit id="952294bca557c59738bac0e545034c52a263067f" translate="yes" xml:space="preserve">
          <source>The first argument to sqlite3_config() is an integer &lt;a href=&quot;#SQLITE_CONFIG_COVERING_INDEX_SCAN&quot;&gt;configuration option&lt;/a&gt; that determines what property of SQLite is to be configured. Subsequent arguments vary depending on the &lt;a href=&quot;#SQLITE_CONFIG_COVERING_INDEX_SCAN&quot;&gt;configuration option&lt;/a&gt; in the first argument.</source>
          <target state="translated">Первый аргумент sqlite3_config () - это целочисленный &lt;a href=&quot;#SQLITE_CONFIG_COVERING_INDEX_SCAN&quot;&gt;параметр конфигурации,&lt;/a&gt; который определяет, какое свойство SQLite нужно настроить. Последующие аргументы меняются в зависимости от параметра &lt;a href=&quot;#SQLITE_CONFIG_COVERING_INDEX_SCAN&quot;&gt;конфигурации&lt;/a&gt; в первом аргументе.</target>
        </trans-unit>
        <trans-unit id="f875f5d7c01e9a29524328575e142babf2bae3ae" translate="yes" xml:space="preserve">
          <source>The first argument to sqlite3_config() is an integer &lt;a href=&quot;c_config_covering_index_scan&quot;&gt;configuration option&lt;/a&gt; that determines what property of SQLite is to be configured. Subsequent arguments vary depending on the &lt;a href=&quot;c_config_covering_index_scan&quot;&gt;configuration option&lt;/a&gt; in the first argument.</source>
          <target state="translated">Первый аргумент sqlite3_config () - это целочисленный &lt;a href=&quot;c_config_covering_index_scan&quot;&gt;параметр конфигурации,&lt;/a&gt; который определяет, какое свойство SQLite нужно настроить. Последующие аргументы меняются в зависимости от параметра &lt;a href=&quot;c_config_covering_index_scan&quot;&gt;конфигурации&lt;/a&gt; в первом аргументе.</target>
        </trans-unit>
        <trans-unit id="3f0ed77e9965fa2c39bb9cbb993108ef55b7d05b" translate="yes" xml:space="preserve">
          <source>The first argument to the busy handler is a copy of the void* pointer which is the third argument to sqlite3_busy_handler(). The second argument to the busy handler callback is the number of times that the busy handler has been invoked previously for the same locking event. If the busy callback returns 0, then no additional attempts are made to access the database and &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY&lt;/a&gt; is returned to the application. If the callback returns non-zero, then another attempt is made to access the database and the cycle repeats.</source>
          <target state="translated">Первый аргумент обработчика занятости - это копия указателя void *, который является третьим аргументом sqlite3_busy_handler (). Второй аргумент обратного вызова обработчика занятости - это количество раз, когда обработчик занятости был вызван ранее для того же события блокировки. Если обратный вызов занятости возвращает 0, то дополнительных попыток доступа к базе данных не &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;делается,&lt;/a&gt; и приложению возвращается SQLITE_BUSY . Если обратный вызов возвращает ненулевое значение, делается еще одна попытка доступа к базе данных, и цикл повторяется.</target>
        </trans-unit>
        <trans-unit id="73aa47dd980f8a887b15a2decc4e912f8fd4e328" translate="yes" xml:space="preserve">
          <source>The first argument to the busy handler is a copy of the void* pointer which is the third argument to sqlite3_busy_handler(). The second argument to the busy handler callback is the number of times that the busy handler has been invoked previously for the same locking event. If the busy callback returns 0, then no additional attempts are made to access the database and &lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; is returned to the application. If the callback returns non-zero, then another attempt is made to access the database and the cycle repeats.</source>
          <target state="translated">Первый аргумент обработчика занятости - это копия указателя void *, который является третьим аргументом sqlite3_busy_handler (). Второй аргумент обратного вызова обработчика занятости - это количество раз, когда обработчик занятости был вызван ранее для того же события блокировки. Если обратный вызов занятости возвращает 0, то дополнительных попыток доступа к базе данных не &lt;a href=&quot;../rescode#busy&quot;&gt;делается,&lt;/a&gt; и приложению возвращается SQLITE_BUSY . Если обратный вызов возвращает ненулевое значение, делается еще одна попытка доступа к базе данных, и цикл повторяется.</target>
        </trans-unit>
        <trans-unit id="395ff21e8cf7b4d90e5bc3764e07164a7c24e72d" translate="yes" xml:space="preserve">
          <source>The first argument to the callback is just a copy of the fourth argument to &lt;b&gt;sqlite_exec&lt;/b&gt; This parameter can be used to pass arbitrary information through to the callback function from client code. The second argument is the number of columns in the query result. The third argument is an array of pointers to strings where each string is a single column of the result for that record. Note that the callback function reports a NULL value in the database as a NULL pointer, which is very different from an empty string. If the i-th parameter is an empty string, we will get:</source>
          <target state="translated">Первый аргумент обратного вызова - это всего лишь копия четвертого аргумента &lt;b&gt;sqlite_exec.&lt;/b&gt; Этот параметр может использоваться для передачи произвольной информации в функцию обратного вызова из клиентского кода. Второй аргумент - это количество столбцов в результате запроса. Третий аргумент - это массив указателей на строки, где каждая строка представляет собой отдельный столбец результата для этой записи. Обратите внимание, что функция обратного вызова сообщает значение NULL в базе данных как указатель NULL, который сильно отличается от пустой строки. Если i-й параметр - пустая строка, мы получим:</target>
        </trans-unit>
        <trans-unit id="19ed31ae74a9a14120db33894759ec36b8a3df0f" translate="yes" xml:space="preserve">
          <source>The first argument to the snippet function must always be the &lt;a href=&quot;fts3#hiddencol&quot;&gt;FTS hidden column&lt;/a&gt; of the FTS table being queried and from which the snippet is to be taken. The &lt;a href=&quot;fts3#hiddencol&quot;&gt;FTS hidden column&lt;/a&gt; is an automatically generated column with the same name as the FTS table itself.</source>
          <target state="translated">Первым аргументом функции фрагмента всегда должен быть &lt;a href=&quot;fts3#hiddencol&quot;&gt;скрытый столбец&lt;/a&gt; FTS запрашиваемой таблицы FTS, из которого должен быть взят фрагмент. &lt;a href=&quot;fts3#hiddencol&quot;&gt;FTS скрыт столбец&lt;/a&gt; является автоматически генерируемый столбец с тем же именем, что и сама таблица FTS.</target>
        </trans-unit>
        <trans-unit id="a3c117d3156af5d9687ce63c9ca2baca71f1029c" translate="yes" xml:space="preserve">
          <source>The first argument to the sqlite3_bind_*() routines is always a pointer to the &lt;a href=&quot;#sqlite3_stmt&quot;&gt;sqlite3_stmt&lt;/a&gt; object returned from &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; or its variants.</source>
          <target state="translated">Первый аргумент подпрограмм sqlite3_bind _ * () всегда является указателем на объект &lt;a href=&quot;#sqlite3_stmt&quot;&gt;sqlite3_stmt,&lt;/a&gt; возвращаемый &lt;a href=&quot;#sqlite3_prepare&quot;&gt;функцией sqlite3_prepare_v2 ()&lt;/a&gt; или ее вариантами.</target>
        </trans-unit>
        <trans-unit id="e62bb2c9601439134c1919cc9d703235a3e8dcf1" translate="yes" xml:space="preserve">
          <source>The first argument to the sqlite3_bind_*() routines is always a pointer to the &lt;a href=&quot;stmt&quot;&gt;sqlite3_stmt&lt;/a&gt; object returned from &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; or its variants.</source>
          <target state="translated">Первый аргумент подпрограмм sqlite3_bind _ * () всегда является указателем на объект &lt;a href=&quot;stmt&quot;&gt;sqlite3_stmt,&lt;/a&gt; возвращаемый &lt;a href=&quot;prepare&quot;&gt;функцией sqlite3_prepare_v2 ()&lt;/a&gt; или ее вариантами.</target>
        </trans-unit>
        <trans-unit id="4376fc02622bfe056753a887d840cb5de850cf76" translate="yes" xml:space="preserve">
          <source>The first argument to the sqlite3session_config() function must be one of the SQLITE_SESSION_CONFIG_XXX constants defined below. The interpretation of the (void*) value passed as the second parameter and the effect of calling this function depends on the value of the first parameter.</source>
          <target state="translated">Первый аргумент функции sqlite3session_config()должен быть одной из констант SQLITE_SESSION_CONFIG_XXX,определенных ниже.Интерпретация значения (void*),переданного в качестве второго параметра,и эффект вызова этой функции зависят от значения первого параметра.</target>
        </trans-unit>
        <trans-unit id="46628205e32bedcd53350a6840ee825a63d42391" translate="yes" xml:space="preserve">
          <source>The first argument to these interfaces is a &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt;. These functions return information about the Nth result column returned by the statement, where N is the second function argument. The left-most column is column 0 for these routines.</source>
          <target state="translated">Первым аргументом для этих интерфейсов является &lt;a href=&quot;#sqlite3_stmt&quot;&gt;подготовленный оператор&lt;/a&gt; . Эти функции возвращают информацию о N-м столбце результата, возвращенном оператором, где N - второй аргумент функции. Самый левый столбец - это столбец 0 для этих подпрограмм.</target>
        </trans-unit>
        <trans-unit id="0f76a71e763d5bd4fbae26e4a6f14b3c938ceb32" translate="yes" xml:space="preserve">
          <source>The first argument to these interfaces is a &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt;. These functions return information about the Nth result column returned by the statement, where N is the second function argument. The left-most column is column 0 for these routines.</source>
          <target state="translated">Первым аргументом для этих интерфейсов является &lt;a href=&quot;stmt&quot;&gt;подготовленный оператор&lt;/a&gt; . Эти функции возвращают информацию о N-м столбце результата, возвращенном оператором, где N - второй аргумент функции. Самый левый столбец - это столбец 0 для этих подпрограмм.</target>
        </trans-unit>
        <trans-unit id="a5ff723764d00dd9ac3f381e3bed0a1f08296ed5" translate="yes" xml:space="preserve">
          <source>The first argument, &quot;db&quot;, is a &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; obtained from a prior successful call to &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; or &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open16()&lt;/a&gt;. The database connection must not have been closed.</source>
          <target state="translated">Первый аргумент, &amp;laquo;db&amp;raquo;, - это &lt;a href=&quot;#sqlite3&quot;&gt;соединение&lt;/a&gt; с базой данных, полученное в результате предыдущего успешного вызова &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2 ()&lt;/a&gt; или &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open16 ()&lt;/a&gt; . Соединение с базой данных не должно быть закрыто.</target>
        </trans-unit>
        <trans-unit id="691e78895187de6910913a151c966bb350230789" translate="yes" xml:space="preserve">
          <source>The first argument, &quot;db&quot;, is a &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; obtained from a prior successful call to &lt;a href=&quot;open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; or &lt;a href=&quot;open&quot;&gt;sqlite3_open16()&lt;/a&gt;. The database connection must not have been closed.</source>
          <target state="translated">Первый аргумент, &amp;laquo;db&amp;raquo;, - это &lt;a href=&quot;sqlite3&quot;&gt;соединение&lt;/a&gt; с базой данных, полученное в результате предыдущего успешного вызова &lt;a href=&quot;open&quot;&gt;sqlite3_open ()&lt;/a&gt; , &lt;a href=&quot;open&quot;&gt;sqlite3_open_v2 ()&lt;/a&gt; или &lt;a href=&quot;open&quot;&gt;sqlite3_open16 ()&lt;/a&gt; . Соединение с базой данных не должно быть закрыто.</target>
        </trans-unit>
        <trans-unit id="5da926bf27ba88ce6fa226bb8489971c4b0badd1" translate="yes" xml:space="preserve">
          <source>The first attempt at closing security gaps in pointer passing was to prevent pointer values from being forged. This was accomplished by having the sender attach a subtype to each pointer using &lt;a href=&quot;c3ref/result_subtype&quot;&gt;sqlite3_result_subtype()&lt;/a&gt; and having the receiver verify that subtype using &lt;a href=&quot;c3ref/value_subtype&quot;&gt;sqlite3_value_subtype()&lt;/a&gt; and reject pointers that had an incorrect subtype. Since there is no way to attach a subtype to a result using pure SQL, this prevents pointers from being forged using SQL. The only way to send a pointer is to use C code. If an attacker can set a subtype, then he is also able to forge a pointer without the help of SQLite.</source>
          <target state="translated">Первой попыткой закрыть бреши в безопасности при передаче указателя было предотвращение подделки значений указателя. Для этого отправитель прикреплял подтип к каждому указателю с помощью &lt;a href=&quot;c3ref/result_subtype&quot;&gt;sqlite3_result_subtype (),&lt;/a&gt; а получатель проверял этот подтип с помощью &lt;a href=&quot;c3ref/value_subtype&quot;&gt;sqlite3_value_subtype ()&lt;/a&gt; и отклонял указатели с неправильным подтипом. Поскольку нет способа присоединить подтип к результату с использованием чистого SQL, это предотвращает подделку указателей с помощью SQL. Единственный способ отправить указатель - использовать код C. Если злоумышленник может установить подтип, он также может подделать указатель без помощи SQLite.</target>
        </trans-unit>
        <trans-unit id="b3f912cc569c0361b5c2cd2202f03f7409e6b0b1" translate="yes" xml:space="preserve">
          <source>The first beta release for SQLite 3.0.</source>
          <target state="translated">Первый бета-релиз для SQLite 3.0.</target>
        </trans-unit>
        <trans-unit id="85577f9e39e1e56bdcef30a17afd1e7fd9d77720" translate="yes" xml:space="preserve">
          <source>The first byte of the header is a flag byte. The least significant bit of the flag byte determines whether the coordinate pairs that follow the header are stored big-endian or little-endian. A value of 0 for the least significant bit means big-endian and a value of 1 means little endian. Other bits of the first byte in the header are reserved for future expansion.</source>
          <target state="translated">Первый байт заголовка-флаг-байт.Наименьший байт флага определяет,хранятся ли пары координат,следующие за заголовком,в big-endian или little-endian.Значение 0 для наименьшего значащего бита означает big-endian,а значение 1 означает little-endian.Остальные биты первого байта в заголовке зарезервированы для будущего расширения.</target>
        </trans-unit>
        <trans-unit id="f63d26f2f4bc609cd955a5edef912da4a0a9006c" translate="yes" xml:space="preserve">
          <source>The first call to &lt;a href=&quot;session/sqlite3changeset_next&quot;&gt;sqlite3changeset_next()&lt;/a&gt; on the iterator moves it to point to the first change in the changeset (or to EOF, if the changeset is completely empty). sqlite3changeset_next() returns SQLITE_ROW if it moves the iterator to point to a valid entry, SQLITE_DONE if it moves the iterator to EOF, or an SQLite error code if an error occurs.</source>
          <target state="translated">Первый вызов &lt;a href=&quot;session/sqlite3changeset_next&quot;&gt;sqlite3changeset_next ()&lt;/a&gt; на итераторе перемещает его так, чтобы он указывал на первое изменение в наборе изменений (или на EOF, если набор изменений полностью пуст). sqlite3changeset_next () возвращает SQLITE_ROW, если он перемещает итератор, чтобы указать на действительную запись, SQLITE_DONE, если он перемещает итератор в EOF, или код ошибки SQLite, если возникает ошибка.</target>
        </trans-unit>
        <trans-unit id="261c910c7fa661af930e1c363bad2fff3671bdea" translate="yes" xml:space="preserve">
          <source>The first call to sqlite3_backup_step() obtains an exclusive lock on the destination file. The exclusive lock is not released until either sqlite3_backup_finish() is called or the backup operation is complete and sqlite3_backup_step() returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_DONE&lt;/a&gt;. Every call to sqlite3_backup_step() obtains a &lt;a href=&quot;lockingv3#shared_lock&quot;&gt;shared lock&lt;/a&gt; on the source database that lasts for the duration of the sqlite3_backup_step() call. Because the source database is not locked between calls to sqlite3_backup_step(), the source database may be modified mid-way through the backup process. If the source database is modified by an external process or via a database connection other than the one being used by the backup operation, then the backup will be automatically restarted by the next call to sqlite3_backup_step(). If the source database is modified by the using the same database connection as is used by the backup operation, then the backup database is automatically updated at the same time.</source>
          <target state="translated">Первый вызов sqlite3_backup_step () обеспечивает монопольную блокировку целевого файла. Эксклюзивная блокировка не снимается до тех пор, пока не будет вызвана sqlite3_backup_finish () или пока не будет завершена операция резервного копирования и sqlite3_backup_step () не вернет &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_DONE&lt;/a&gt; . Каждый вызов sqlite3_backup_step () получает &lt;a href=&quot;lockingv3#shared_lock&quot;&gt;общую блокировку&lt;/a&gt;в исходной базе данных, которая действует на время вызова sqlite3_backup_step (). Поскольку исходная база данных не заблокирована между вызовами sqlite3_backup_step (), исходная база данных может быть изменена в середине процесса резервного копирования. Если исходная база данных изменена внешним процессом или через соединение с базой данных, отличное от того, которое используется операцией резервного копирования, то резервное копирование будет автоматически перезапущено при следующем вызове sqlite3_backup_step (). Если исходная база данных изменяется с использованием того же соединения с базой данных, которое используется при операции резервного копирования, то база данных резервного копирования автоматически обновляется одновременно.</target>
        </trans-unit>
        <trans-unit id="57eb736cb2a536a07c53b0e0f817765662d0da0a" translate="yes" xml:space="preserve">
          <source>The first call to sqlite3_backup_step() obtains an exclusive lock on the destination file. The exclusive lock is not released until either sqlite3_backup_finish() is called or the backup operation is complete and sqlite3_backup_step() returns &lt;a href=&quot;../rescode#done&quot;&gt;SQLITE_DONE&lt;/a&gt;. Every call to sqlite3_backup_step() obtains a &lt;a href=&quot;../lockingv3#shared_lock&quot;&gt;shared lock&lt;/a&gt; on the source database that lasts for the duration of the sqlite3_backup_step() call. Because the source database is not locked between calls to sqlite3_backup_step(), the source database may be modified mid-way through the backup process. If the source database is modified by an external process or via a database connection other than the one being used by the backup operation, then the backup will be automatically restarted by the next call to sqlite3_backup_step(). If the source database is modified by the using the same database connection as is used by the backup operation, then the backup database is automatically updated at the same time.</source>
          <target state="translated">Первый вызов sqlite3_backup_step () обеспечивает монопольную блокировку целевого файла. Эксклюзивная блокировка не снимается до тех пор, пока не будет вызвана sqlite3_backup_finish () или пока не будет завершена операция резервного копирования и sqlite3_backup_step () не вернет &lt;a href=&quot;../rescode#done&quot;&gt;SQLITE_DONE&lt;/a&gt; . Каждый вызов sqlite3_backup_step () получает &lt;a href=&quot;../lockingv3#shared_lock&quot;&gt;общую блокировку&lt;/a&gt;в исходной базе данных, которая действует на время вызова sqlite3_backup_step (). Поскольку исходная база данных не заблокирована между вызовами sqlite3_backup_step (), исходная база данных может быть изменена в середине процесса резервного копирования. Если исходная база данных изменена внешним процессом или через соединение с базой данных, отличное от того, которое используется операцией резервного копирования, то резервное копирование будет автоматически перезапущено при следующем вызове sqlite3_backup_step (). Если исходная база данных изменяется с использованием того же соединения с базой данных, которое используется при операции резервного копирования, то база данных резервного копирования автоматически обновляется одновременно.</target>
        </trans-unit>
        <trans-unit id="878621de1d1518fe649327da44b122a6dcc1e4c1" translate="yes" xml:space="preserve">
          <source>The first code for TH3 was laid down on 2008-09-25. An intense effort over the next 10 months resulted in TH3 achieving 100% MC/DC on 2009-07-25. The TH3 code continues to be improved and expanded.</source>
          <target state="translated">Первый код для TH3 был заложен в 2008-09-25 годах.Интенсивные усилия в течение следующих 10 месяцев привели к тому,что в 2009-07-25 годах TH3 достигла 100% MC/DC.Код TH3 продолжает совершенствоваться и расширяться.</target>
        </trans-unit>
        <trans-unit id="708a1cddc7d07a561f3445a868346de6a13841df" translate="yes" xml:space="preserve">
          <source>The first column is the schema name for the database that contains the tables. Examples: &quot;main&quot;, &quot;zone512&quot;.</source>
          <target state="translated">Первый столбец-это имя схемы БД,содержащей таблицы.Примеры:&quot;главная&quot;,&quot;зона512&quot;.</target>
        </trans-unit>
        <trans-unit id="9814feb56c887ece7381e15fd8887b6ec1a1d8c0" translate="yes" xml:space="preserve">
          <source>The first column of an SQLite R*Tree is similar to an integer primary key column of a normal SQLite table. It may only store a 64-bit signed integer value. Inserting a NULL value into this column causes SQLite to automatically generate a new unique primary key value. If an attempt is made to insert any other non-integer value into this column, the r-tree module silently converts it to an integer before writing it into the database.</source>
          <target state="translated">Первый столбец R*Tree SQLite аналогичен целому столбцу первичного ключа обычной таблицы SQLite.В нем может храниться только 64-битное целое значение,подписанное.Вставка в этот столбец NULL-значения приводит к тому,что SQLite автоматически генерирует новое уникальное значение первичного ключа.При попытке вставить в этот столбец любое другое неинтегрированное значение,модуль r-дерева бесшумно преобразует его в целое число перед записью в БД.</target>
        </trans-unit>
        <trans-unit id="840bd12d54aba66c9e7cdaff39f91dd2e3886bf1" translate="yes" xml:space="preserve">
          <source>The first condition causes all of the trunk check-ins to be displayed and the second and third cause check-ins that merge into or fork from the trunk to also be included. The three conditions are implemented by the three OR-connected EXISTS statements in the WHERE clause of the query. The slowdown that occurred with the NGQP was caused by the second and third conditions. The problem is the same in each, so we will examine just the second one. The subquery of the second condition can be rewritten (with minor and immaterial simplifications) as follows:</source>
          <target state="translated">Первое условие приводит к тому,что отображаются все проверки в стволе,а второе и третье-к тому,что также включаются проверки,которые сливаются в ствол или вилки из него.Эти три условия выполняются тремя операторами &quot;ИЛИ-связанные ВЫХОДЫ&quot; в пункте &quot;ГДЕ&quot; запроса.Замедление,произошедшее с NGQP,вызвано вторым и третьим условиями.Проблема в каждом из них одна и та же,поэтому рассмотрим только второе.Подзапрос второго условия можно переписать (с незначительными и несущественными упрощениями)следующим образом:</target>
        </trans-unit>
        <trans-unit id="4abd9649e552817a07b47b388971861bc70b5489" translate="yes" xml:space="preserve">
          <source>The first eight columns are the address, opcode, and operands for a single &lt;a href=&quot;opcode&quot;&gt;bytecode&lt;/a&gt; in the virtual machine that implements the statement. These columns are the same columns output when using EXPLAIN. The bytecode virtual tables shows all operations in the prepared statement, both the main body of the prepared statement and in subprograms used to implement triggers or foreign key actions. The &quot;subprog&quot; field is NULL for the main body of the prepared statement, or is the trigger name or the string &quot;(FK)&quot; for triggers and foreign key actions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d90855e6a48f657d5fb1f13585eab05ee2b6665" translate="yes" xml:space="preserve">
          <source>The first example above is the preferred definition of the table, of course. All of the examples create a WITHOUT ROWID table with two PRIMARY KEY columns, &quot;a&quot; and &quot;c&quot;, in that order, followed by two data columns &quot;b&quot; and &quot;d&quot;, also in that order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d78f5e7f65436952c61eefc9d02af59c750bcb9f" translate="yes" xml:space="preserve">
          <source>The first five fields of the sqlite3_rtree_query_info structure are identical to the sqlite3_rtree_geometry structure, and have exactly the same meaning. The sqlite3_rtree_query_info structure also contains nCoord and aCoord fields which have the same meaning as the parameter of the same name in the xGeom callback.</source>
          <target state="translated">Первые пять полей структуры sqlite3_rtree_query_info идентичны структуре sqlite3_rtree_geometry и имеют точно такое же значение.Структура sqlite3_rtree_query_info также содержит поля nCoord и aCoord,которые имеют то же значение,что и одноименный параметр в обратном вызове xGeom.</target>
        </trans-unit>
        <trans-unit id="8e073e98c04e5afd81b1a912e72c323c17ce2eb5" translate="yes" xml:space="preserve">
          <source>The first form (with the &quot;VALUES&quot; keyword) creates one or more new rows in an existing table. If the column-name list after table-name is omitted then the number of values inserted into each row must be the same as the number of columns in the table. In this case the result of evaluating the left-most expression from each term of the VALUES list is inserted into the left-most column of each new row, and so forth for each subsequent expression. If a column-name list is specified, then the number of values in each term of the VALUE list must match the number of specified columns. Each of the named columns of the new row is populated with the results of evaluating the corresponding VALUES expression. Table columns that do not appear in the column list are populated with the &lt;a href=&quot;lang_createtable#dfltval&quot;&gt;default column value&lt;/a&gt; (specified as part of the &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; statement), or with NULL if no &lt;a href=&quot;lang_createtable#dfltval&quot;&gt;default value&lt;/a&gt; is specified.</source>
          <target state="translated">Первая форма (с ключевым словом &amp;laquo;VALUES&amp;raquo;) создает одну или несколько новых строк в существующей таблице. Если список имен столбцов после имени таблицы опущен, то количество значений, вставляемых в каждую строку, должно быть таким же, как количество столбцов в таблице. В этом случае результат вычисления самого левого выражения из каждого члена списка VALUES вставляется в крайний левый столбец каждой новой строки и так далее для каждого последующего выражения. Если указан список имен столбцов, то количество значений в каждом термине списка VALUE должно соответствовать количеству указанных столбцов. Каждый из названных столбцов новой строки заполняется результатами вычисления соответствующего выражения VALUES. Столбцы таблицы, которые не отображаются в списке столбцов, заполняются &lt;a href=&quot;lang_createtable#dfltval&quot;&gt;значением столбца&lt;/a&gt; по умолчанию.(указывается как часть оператора &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; ) или с NULL, если &lt;a href=&quot;lang_createtable#dfltval&quot;&gt;значение по умолчанию&lt;/a&gt; не указано.</target>
        </trans-unit>
        <trans-unit id="2570c22a55e27cbe9ad6c1dce2c1cff1bff0c5c4" translate="yes" xml:space="preserve">
          <source>The first form loads the edit distance coefficients from a table called 'TABLENAME'. Any prior coefficients are discarded. So when experimenting with weights and the weight table changes, simply rerun the single-argument form of editdist3() to reload revised coefficients. Note that the edit distance weights used by the editdist3() SQL function are independent from the weights used by the spellfix1 virtual table.</source>
          <target state="translated">Первая форма загружает коэффициенты расстояния редактирования из таблицы под названием 'TABLENAME'.Любые предыдущие коэффициенты отбрасываются.Поэтому,экспериментируя с весами и изменением таблицы весов,просто перезагрузите единственную форму editdist3(),чтобы перезагрузить пересмотренные коэффициенты.Обратите внимание,что веса расстояния редактирования,используемые SQL-функцией editdist3(),не зависят от весов,используемых виртуальной таблицей spellfix1.</target>
        </trans-unit>
        <trans-unit id="7597ee6d3f1982d757a998bf7dd70b5fa125869a" translate="yes" xml:space="preserve">
          <source>The first form of the lag() function returns the result of evaluating expression</source>
          <target state="translated">Первая форма функции lag()возвращает результат вычисления выражения</target>
        </trans-unit>
        <trans-unit id="99435f14d6ece88179aba89152e1459d1e98bf65" translate="yes" xml:space="preserve">
          <source>The first form of the lead() function returns the result of evaluating expression</source>
          <target state="translated">Первая форма функции lead()возвращает результат вычисления выражения</target>
        </trans-unit>
        <trans-unit id="0e38dddff1d9fcb9023e44603abe1408f559a08e" translate="yes" xml:space="preserve">
          <source>The first form of this pragma queries the current journaling mode for</source>
          <target state="translated">Первая форма этой прагмы запрашивает текущий режим протоколирования для</target>
        </trans-unit>
        <trans-unit id="b8118a5225d858802697d63c772d9f2007991455" translate="yes" xml:space="preserve">
          <source>The first four columns a, b, c, and d of the index would be usable since those four columns form a prefix of the index and are all bound by equality constraints.</source>
          <target state="translated">Первые четыре столбца a,b,c и d индекса можно было бы использовать,поскольку эти четыре столбца образуют префикс индекса и все они связаны ограничениями равенства.</target>
        </trans-unit>
        <trans-unit id="4ead6c16538264b763b7c6adde08cc0b22f7c9e0" translate="yes" xml:space="preserve">
          <source>The first group of queries in the log are extracting display options from the &quot;config&quot; and &quot;global_config&quot; tables of the Fossil database. Then there is a single complex query that extracts a list of all elements to be displayed on the timeline. This &quot;timeline&quot; query demonstrates that SQLite can easily process complex relational database queries involving multiple tables, subqueries, and complex WHERE clause constraints, and it can make effective use of indexes to solve the queries with minimal disk I/O.</source>
          <target state="translated">Первая группа запросов в журнале-извлечение опций отображения из таблиц &quot;config&quot; и &quot;global_config&quot; Ископаемой базы данных.Затем идет один сложный запрос,который извлекает список всех элементов для отображения на временной шкале.Этот запрос &quot;timeline&quot; демонстрирует,что SQLite может легко обрабатывать сложные реляционные запросы к БД,включающие в себя несколько таблиц,подзапросов и сложные ограничения по пунктам WHERE,и может эффективно использовать индексы для решения запросов с минимальным количеством дисковых операций ввода-вывода.</target>
        </trans-unit>
        <trans-unit id="4e52fafda10d32765550d3edce2eeda11c3b4ffd" translate="yes" xml:space="preserve">
          <source>The first host parameter has an index of 1, not 0.</source>
          <target state="translated">Первый параметр хоста имеет индекс 1,а не 0.</target>
        </trans-unit>
        <trans-unit id="178a49643c52d6ff462985df8e6c238cfb8ec5cd" translate="yes" xml:space="preserve">
          <source>The first instruction of interest is the &lt;a href=&quot;opcode#AggReset&quot;&gt;AggReset&lt;/a&gt; at 2. The AggReset instruction initializes the set of buckets to be the empty set and specifies the number of memory slots available in each bucket as P2. In this example, each bucket will hold 3 memory slots. It is not obvious, but if you look closely at the rest of the program you can figure out what each of these slots is intended for.</source>
          <target state="translated">Первая интересующая нас инструкция - это &lt;a href=&quot;opcode#AggReset&quot;&gt;AggReset&lt;/a&gt; at 2. Инструкция AggReset инициализирует набор сегментов как пустой набор и указывает количество слотов памяти, доступных в каждом сегменте, как P2. В этом примере каждая корзина будет содержать 3 слота памяти. Это не очевидно, но если вы внимательно посмотрите на остальную часть программы, вы сможете понять, для чего предназначен каждый из этих слотов.</target>
        </trans-unit>
        <trans-unit id="11dcba86733ec3f9c57f212488f98cc390a1b479" translate="yes" xml:space="preserve">
          <source>The first integer in the P4 integer array is the length of the array and does not become part of the permutation.</source>
          <target state="translated">Первое целое число в P4-целом массиве является длиной массива и не становится частью перестановки.</target>
        </trans-unit>
        <trans-unit id="388856185e941f1980f4fd92691075a08784c68c" translate="yes" xml:space="preserve">
          <source>The first line of the script above causes the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; to read and activate the run-time loadable extension for CSV. For an application, the equivalent C-language API is &lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension()&lt;/a&gt;. Observe that the filename extension (ex: &quot;.dll&quot; or &quot;.so&quot; or &quot;.dylib&quot;) is omitted from the extension filename. Omitting the filename extension is not required, but it helps in making the script cross-platform. SQLite will automatically append the appropriate extension.</source>
          <target state="translated">Первая строка приведенного выше сценария заставляет &lt;a href=&quot;cli&quot;&gt;оболочку командной строки&lt;/a&gt; читать и активировать загружаемое расширение времени выполнения для CSV. Для приложения эквивалентным API языка C является &lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension ()&lt;/a&gt; . Обратите внимание, что расширение имени файла (например, &amp;laquo;.dll&amp;raquo;, &amp;laquo;.so&amp;raquo; или &amp;laquo;.dylib&amp;raquo;) опущено в имени файла расширения. Пропускать расширение имени файла не обязательно, но это помогает сделать скрипт кроссплатформенным. SQLite автоматически добавит соответствующее расширение.</target>
        </trans-unit>
        <trans-unit id="75252c48c68a826da51013f5fcc062daddeb6d8f" translate="yes" xml:space="preserve">
          <source>The first of the above that is found to exist and have the write and execute bits set is used. The final &quot;.&quot; fallback is important for some applications that use SQLite inside of chroot jails that do not have the standard temporary file locations available.</source>
          <target state="translated">Используется первый из вышеперечисленных,который существует и имеет набор битов для записи и выполнения.Окончательный &quot;...&quot; откат важен для некоторых приложений,использующих SQLite внутри chroot jails,которые не имеют стандартного расположения временных файлов.</target>
        </trans-unit>
        <trans-unit id="1f9a60bfbed88db253a25c41a987f86e19f4d6aa" translate="yes" xml:space="preserve">
          <source>The first page of a cell payload overflow chain. The page number is the b-tree page that contains the cell whose content has overflowed.</source>
          <target state="translated">Первая страница цепи переполнения ячеек.Номер страницы-это страница b-дерева,содержащая ячейку,содержимое которой переполнилось.</target>
        </trans-unit>
        <trans-unit id="571e717de8bab6f472a3daa4d0e34a129cf9485d" translate="yes" xml:space="preserve">
          <source>The first parameter is a &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt;. If this statement is a &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statement and the Nth column of the returned result set of that &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; is a table column (not an expression or subquery) then the declared type of the table column is returned. If the Nth column of the result set is an expression or subquery, then a NULL pointer is returned. The returned string is always UTF-8 encoded.</source>
          <target state="translated">Первый параметр - это &lt;a href=&quot;#sqlite3_stmt&quot;&gt;подготовленный оператор&lt;/a&gt; . Если этот оператор является &lt;a href=&quot;lang_select&quot;&gt;оператором SELECT,&lt;/a&gt; а N-й столбец возвращенного набора результатов этого &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; является столбцом таблицы (не выражением или подзапросом), то возвращается объявленный тип столбца таблицы. Если N-й столбец набора результатов является выражением или подзапросом, возвращается NULL-указатель. Возвращаемая строка всегда имеет кодировку UTF-8.</target>
        </trans-unit>
        <trans-unit id="2d95d478fea3b8287d0a6628b14c6c99e2b30bf0" translate="yes" xml:space="preserve">
          <source>The first parameter is a &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt;. If this statement is a &lt;a href=&quot;../lang_select&quot;&gt;SELECT&lt;/a&gt; statement and the Nth column of the returned result set of that &lt;a href=&quot;../lang_select&quot;&gt;SELECT&lt;/a&gt; is a table column (not an expression or subquery) then the declared type of the table column is returned. If the Nth column of the result set is an expression or subquery, then a NULL pointer is returned. The returned string is always UTF-8 encoded.</source>
          <target state="translated">Первый параметр - это &lt;a href=&quot;stmt&quot;&gt;подготовленный оператор&lt;/a&gt; . Если этот оператор является &lt;a href=&quot;../lang_select&quot;&gt;оператором SELECT,&lt;/a&gt; а N-й столбец возвращенного набора результатов этого &lt;a href=&quot;../lang_select&quot;&gt;SELECT&lt;/a&gt; является столбцом таблицы (не выражением или подзапросом), то возвращается объявленный тип столбца таблицы. Если N-й столбец набора результатов является выражением или подзапросом, возвращается NULL-указатель. Возвращаемая строка всегда имеет кодировку UTF-8.</target>
        </trans-unit>
        <trans-unit id="c8355444303911368f3db824744273405e752637" translate="yes" xml:space="preserve">
          <source>The first parameter is the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; to which the SQL function is to be added. If an application uses more than one database connection then application-defined SQL functions must be added to each database connection separately.</source>
          <target state="translated">Первый параметр - это &lt;a href=&quot;#sqlite3&quot;&gt;соединение&lt;/a&gt; с базой данных, к которому должна быть добавлена ​​функция SQL. Если приложение использует более одного соединения с базой данных, тогда определяемые приложением функции SQL должны быть добавлены к каждому соединению с базой данных отдельно.</target>
        </trans-unit>
        <trans-unit id="2034bce444668b7bc337245a2c547e0aff9b9fd1" translate="yes" xml:space="preserve">
          <source>The first parameter is the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; to which the SQL function is to be added. If an application uses more than one database connection then application-defined SQL functions must be added to each database connection separately.</source>
          <target state="translated">Первый параметр - это &lt;a href=&quot;sqlite3&quot;&gt;соединение&lt;/a&gt; с базой данных, к которому должна быть добавлена ​​функция SQL. Если приложение использует более одного соединения с базой данных, тогда определяемые приложением функции SQL должны быть добавлены к каждому соединению с базой данных отдельно.</target>
        </trans-unit>
        <trans-unit id="02bbb4f6b68ff55742031c8b1808d80607aaa103" translate="yes" xml:space="preserve">
          <source>The first parameter must be a copy of the &lt;a href=&quot;#sqlite3_context&quot;&gt;SQL function context&lt;/a&gt; that is the first parameter to the xStep or xFinal callback routine that implements the aggregate function.</source>
          <target state="translated">Первый параметр должен быть копией &lt;a href=&quot;#sqlite3_context&quot;&gt;контекста функции SQL,&lt;/a&gt; который является первым параметром процедуры обратного вызова xStep или xFinal, которая реализует агрегатную функцию.</target>
        </trans-unit>
        <trans-unit id="303b1214ac90198e86e2d6fded39de6f12728048" translate="yes" xml:space="preserve">
          <source>The first parameter must be a copy of the &lt;a href=&quot;context&quot;&gt;SQL function context&lt;/a&gt; that is the first parameter to the xStep or xFinal callback routine that implements the aggregate function.</source>
          <target state="translated">Первый параметр должен быть копией &lt;a href=&quot;context&quot;&gt;контекста функции SQL,&lt;/a&gt; который является первым параметром процедуры обратного вызова xStep или xFinal, которая реализует агрегатную функцию.</target>
        </trans-unit>
        <trans-unit id="51bc3b9167a1367dcb303b210930c2e99a40f80a" translate="yes" xml:space="preserve">
          <source>The first parameter passed to the callback function when it is invoked is a copy of the third parameter passed to sqlite3_wal_hook() when registering the callback. The second is a copy of the database handle. The third parameter is the name of the database that was written to - either &quot;main&quot; or the name of an &lt;a href=&quot;../lang_attach&quot;&gt;ATTACH&lt;/a&gt;-ed database. The fourth parameter is the number of pages currently in the write-ahead log file, including those that were just committed.</source>
          <target state="translated">Первый параметр, переданный в функцию обратного вызова при ее вызове, является копией третьего параметра, переданного в sqlite3_wal_hook () при регистрации обратного вызова. Второй - это копия дескриптора базы данных. Третий параметр - это имя базы данных, в которую была произведена запись - либо &amp;laquo;main&amp;raquo;, либо имя базы данных с &lt;a href=&quot;../lang_attach&quot;&gt;функцией ATTACH&lt;/a&gt; . Четвертый параметр - это количество страниц в файле журнала упреждающей записи, включая те, которые были только что зафиксированы.</target>
        </trans-unit>
        <trans-unit id="8448fcb45b7f072723f93590a80d37aef6a727c3" translate="yes" xml:space="preserve">
          <source>The first parameter passed to the callback function when it is invoked is a copy of the third parameter passed to sqlite3_wal_hook() when registering the callback. The second is a copy of the database handle. The third parameter is the name of the database that was written to - either &quot;main&quot; or the name of an &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt;-ed database. The fourth parameter is the number of pages currently in the write-ahead log file, including those that were just committed.</source>
          <target state="translated">Первый параметр, переданный в функцию обратного вызова при ее вызове, является копией третьего параметра, переданного в sqlite3_wal_hook () при регистрации обратного вызова. Второй - это копия дескриптора базы данных. Третий параметр - это имя базы данных, в которую была произведена запись - либо &amp;laquo;main&amp;raquo;, либо имя базы данных с &lt;a href=&quot;lang_attach&quot;&gt;функцией ATTACH&lt;/a&gt; . Четвертый параметр - это количество страниц в файле журнала упреждающей записи, включая те, которые были только что зафиксированы.</target>
        </trans-unit>
        <trans-unit id="114b67e4b3a89669211882b27d3030f929c0b812" translate="yes" xml:space="preserve">
          <source>The first parameter to the authorizer callback is a copy of the third parameter to the sqlite3_set_authorizer() interface. The second parameter to the callback is an integer &lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;action code&lt;/a&gt; that specifies the particular action to be authorized. The third through sixth parameters to the callback are either NULL pointers or zero-terminated strings that contain additional details about the action to be authorized. Applications must always be prepared to encounter a NULL pointer in any of the third through the sixth parameters of the authorization callback.</source>
          <target state="translated">Первый параметр обратного вызова авторизатора - это копия третьего параметра интерфейса sqlite3_set_authorizer (). Второй параметр обратного вызова - это целочисленный &lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;код действия,&lt;/a&gt; который указывает конкретное действие, которое необходимо разрешить. Параметры с третьего по шестой для обратного вызова являются либо указателями NULL, либо строками с нулевым завершением, которые содержат дополнительные сведения о действии, которое необходимо разрешить. Приложения всегда должны быть готовы встретить нулевой указатель в любом из третьего-шестого параметров обратного вызова авторизации.</target>
        </trans-unit>
        <trans-unit id="031900d436ad256c6483a02e204c32e4df2ca84e" translate="yes" xml:space="preserve">
          <source>The first parameter to the authorizer callback is a copy of the third parameter to the sqlite3_set_authorizer() interface. The second parameter to the callback is an integer &lt;a href=&quot;c_alter_table&quot;&gt;action code&lt;/a&gt; that specifies the particular action to be authorized. The third through sixth parameters to the callback are either NULL pointers or zero-terminated strings that contain additional details about the action to be authorized. Applications must always be prepared to encounter a NULL pointer in any of the third through the sixth parameters of the authorization callback.</source>
          <target state="translated">Первый параметр обратного вызова авторизатора - это копия третьего параметра интерфейса sqlite3_set_authorizer (). Второй параметр обратного вызова - это целочисленный &lt;a href=&quot;c_alter_table&quot;&gt;код действия,&lt;/a&gt; который указывает конкретное действие, которое необходимо разрешить. Параметры с третьего по шестой для обратного вызова являются либо указателями NULL, либо строками с нулевым завершением, которые содержат дополнительные сведения о действии, которое необходимо разрешить. Приложения всегда должны быть готовы встретить нулевой указатель в любом из третьего-шестого параметров обратного вызова авторизации.</target>
        </trans-unit>
        <trans-unit id="1622094cd4d4c27ce242fb95c194e4ab11274192" translate="yes" xml:space="preserve">
          <source>The first parameter to these interfaces (hereafter referred to as F) must be one of:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29c4884990e25d1601d544fb2189fcbf8e2210be" translate="yes" xml:space="preserve">
          <source>The first section introduces the concept of an SQL foreign key by example and defines the terminology used for the remainder of the document. Section 2 describes the steps an application must take in order to enable foreign key constraints in SQLite (it is disabled by default). The next section, section 3, describes the indexes that the user must create in order to use foreign key constraints, and those that should be created in order for foreign key constraints to function efficiently. Section 4 describes the advanced foreign key related features supported by SQLite and section 5 describes the way the &lt;a href=&quot;lang_altertable&quot;&gt;ALTER&lt;/a&gt; and &lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt; commands are enhanced to support foreign key constraints. Finally, section 6 enumerates the missing features and limits of the current implementation.</source>
          <target state="translated">Первый раздел представляет концепцию внешнего ключа SQL на примере и определяет терминологию, используемую в оставшейся части документа. В разделе 2 описаны шаги, которые должно предпринять приложение, чтобы включить ограничения внешнего ключа в SQLite (по умолчанию он отключен). В следующем разделе, разделе 3, описаны индексы, которые пользователь должен создать, чтобы использовать ограничения внешнего ключа, и индексы, которые должны быть созданы для эффективного функционирования ограничений внешнего ключа. В разделе 4 описаны расширенные функции, связанные с внешним ключом, поддерживаемые SQLite, а в разделе 5 описывается способ улучшения команд &lt;a href=&quot;lang_altertable&quot;&gt;ALTER&lt;/a&gt; и &lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt; для поддержки ограничений внешнего ключа. Наконец, в разделе 6 перечислены недостающие функции и ограничения текущей реализации.</target>
        </trans-unit>
        <trans-unit id="6abe8a139c8044b273ba74ec6b9c2e3f141ecabe" translate="yes" xml:space="preserve">
          <source>The first set of three values corresponds to the left-most column of the table (column 0) and the left-most matchable phrase in the query (phrase 0). If the table has more than one column, the second set of three values in the output array correspond to phrase 0 and column 1. Followed by phrase 0, column 2 and so on for all columns of the table. And so on for phrase 1, column 0, then phrase 1, column 1 etc. In other words, the data for occurrences of phrase</source>
          <target state="translated">Первый набор из трех значений соответствует самому левому столбцу таблицы (столбец 0)и самому левому совпадению фраз в запросе (фраза 0).Если таблица имеет более одного столбца,то второй набор из трех значений в выходном массиве соответствует фразе 0 и столбцу 1.Далее следует фраза 0,столбец 2 и т.д.для всех столбцов таблицы.И так далее для фразы 1,столбца 0,затем фразы 1,столбца 1 и так далее.Другими словами,данные для вхождения фразы</target>
        </trans-unit>
        <trans-unit id="b88b9c17da99b9d9285ae75db888dfa7bebfc06c" translate="yes" xml:space="preserve">
          <source>The first six interfaces (_blob, _double, _int, _int64, _text, and _text16) each return the value of a result column in a specific data format. If the result column is not initially in the requested format (for example, if the query returns an integer but the sqlite3_column_text() interface is used to extract the value) then an automatic type conversion is performed.</source>
          <target state="translated">Первые шесть интерфейсов (_blob,_double,_int,_int64,_text и _text16)каждый возвращает значение столбца результата в определенном формате данных.Если столбец результата изначально находится не в запрашиваемом формате (например,если запрос возвращает целое число,но для извлечения значения используется интерфейс sqlite3_column_text()),то выполняется автоматическое приведение типа.</target>
        </trans-unit>
        <trans-unit id="02811050bf1b47e5280ac4d9fe5bacd40c6fea46" translate="yes" xml:space="preserve">
          <source>The first six modifiers (1 through 6) simply add the specified amount of time to the date and time specified by the arguments to the left. The 's' character at the end of the modifier names is optional. Note that &quot;&amp;plusmn;NNN months&quot; works by rendering the original date into the YYYY-MM-DD format, adding the &amp;plusmn;NNN to the MM month value, then normalizing the result. Thus, for example, the data 2001-03-31 modified by '+1 month' initially yields 2001-04-31, but April only has 30 days so the date is normalized to 2001-05-01. A similar effect occurs when the original date is February 29 of a leapyear and the modifier is &amp;plusmn;N years where N is not a multiple of four.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67231aa738e6314e6f80285f8fe72b39964cf222" translate="yes" xml:space="preserve">
          <source>The first six modifiers (1 through 6) simply add the specified amount of time to the date and time specified by the preceding timestring and modifiers. The 's' character at the end of the modifier names is optional. Note that &quot;&amp;plusmn;NNN months&quot; works by rendering the original date into the YYYY-MM-DD format, adding the &amp;plusmn;NNN to the MM month value, then normalizing the result. Thus, for example, the data 2001-03-31 modified by '+1 month' initially yields 2001-04-31, but April only has 30 days so the date is normalized to 2001-05-01. A similar effect occurs when the original date is February 29 of a leapyear and the modifier is &amp;plusmn;N years where N is not a multiple of four.</source>
          <target state="translated">Первые шесть модификаторов (с 1 по 6) просто добавляют указанное количество времени к дате и времени, указанным предыдущей временной строкой и модификаторами. Символ 's' в конце имен модификаторов необязателен. Обратите внимание, что &amp;laquo;&amp;plusmn; NNN месяцев&amp;raquo; работает путем преобразования исходной даты в формат ГГГГ-ММ-ДД, добавления &amp;plusmn; NNN к значению месяца ММ и последующей нормализации результата. Так, например, данные 2001-03-31, измененные на &amp;laquo;+1 месяц&amp;raquo;, первоначально дают 2001-04-31, но в апреле есть только 30 дней, поэтому дата нормализуется до 2001-05-01. Аналогичный эффект возникает, когда исходная дата - 29 февраля високосного года, а модификатор - &amp;plusmn; N лет, где N не кратно четырем.</target>
        </trans-unit>
        <trans-unit id="de80fd15e7d30919dde63ea2e434aa9d73b98e29" translate="yes" xml:space="preserve">
          <source>The first step toward dealing with a hot journal is to obtain an exclusive lock on the database file. This prevents two or more processes from trying to rollback the same hot journal at the same time.</source>
          <target state="translated">Первый шаг к работе с горячим журналом-получение эксклюзивной блокировки на файле базы данных.Это не позволяет двум или более процессам пытаться откатить один и тот же &quot;горячий&quot; журнал одновременно.</target>
        </trans-unit>
        <trans-unit id="6d5dce142e8b6c56f2485efc4da630bd41e2b246" translate="yes" xml:space="preserve">
          <source>The first step toward reading from the database file is obtaining a shared lock on the database file. A &quot;shared&quot; lock allows two or more database connections to read from the database file at the same time. But a shared lock prevents another database connection from writing to the database file while we are reading it. This is necessary because if another database connection were writing to the database file at the same time we are reading from the database file, we might read some data before the change and other data after the change. This would make it appear as if the change made by the other process is not atomic.</source>
          <target state="translated">Первый шаг к чтению из файла базы данных-получение общей блокировки на файле базы данных.Общий&quot; замок позволяет одновременно считывать из файла базы данных два или более соединения с БД.Но общий замок не позволяет другому соединению с БД записать в файл БД,пока мы его читаем.Это необходимо,потому что если бы другое подключение к БД записывалось в файл БД в то же самое время,когда мы читаем из файла БД,мы могли бы прочитать некоторые данные до изменения и другие данные после изменения.При этом будет выглядеть так,как будто изменение,сделанное другим процессом,не является атомарным.</target>
        </trans-unit>
        <trans-unit id="728a2c812c40e366db04b46879d8327a7463b66e" translate="yes" xml:space="preserve">
          <source>The first string or bareword in a column declaration is the column name. It is an error to attempt to name an fts5 table column &quot;rowid&quot; or &quot;rank&quot;, or to assign the same name to a column as is used by the table itself. This is not supported.</source>
          <target state="translated">Первая строка или пустое слово в декларации столбца-это имя столбца.Ошибкой является попытка назвать столбец fts5 таблицы &quot;rowid&quot; или &quot;rank&quot;,или присвоить столбцу то же имя,что используется самой таблицей.Это не поддерживается.</target>
        </trans-unit>
        <trans-unit id="15aebb5889bf7eacd8a14d41dd89f37206fa7a06" translate="yes" xml:space="preserve">
          <source>The first subquery above is constant with respect to the outer query. The value for the first subquery can be computed once and then reused for each row of the outer SELECT. The second subquery, however, is &quot;CORRELATED&quot;. The value of the second subquery changes depending on values in the current row of the outer query. Hence, the second subquery must be run once for each output row in the outer SELECT.</source>
          <target state="translated">Первый подзапрос,приведенный выше,является постоянным по отношению к внешнему запросу.Значение для первого подзапроса может быть вычислено один раз,а затем повторно использовано для каждой строки внешнего SELECT.Второй подзапрос,однако,является &quot;ИСПРАВЛЕННЫМ&quot;.Значение второго подзапроса изменяется в зависимости от значений в текущей строке внешнего запроса.Следовательно,второй подзапрос должен быть выполнен один раз для каждой выходной строки внешнего SELECT.</target>
        </trans-unit>
        <trans-unit id="c31bdf542d6f05cfa5241d61c80e5148ec82df02" translate="yes" xml:space="preserve">
          <source>The first term stored on each node (&quot;Term 1&quot; in the figure above) is stored verbatim. Each subsequent term is prefix-compressed with respect to its predecessor. Terms are stored within a page in sorted (memcmp) order.</source>
          <target state="translated">Первый термин,сохраненный в каждом узле (&quot;Термин 1&quot; на рисунке выше),сохраняется дословно.Каждый последующий термин сжимается префиксом по отношению к своему предшественнику.Термины хранятся внутри страницы в отсортированном (в формате memcmp)порядке.</target>
        </trans-unit>
        <trans-unit id="7a099bb22daac790c8e16aa7a285108628e1197d" translate="yes" xml:space="preserve">
          <source>The first thing that happens is that we open the table being indexed for reading. In order to construct an index for a table, we have to know what is in that table. The index has already been opened for writing using cursor 0 by instructions 3 and 4.</source>
          <target state="translated">Первое,что произойдет,это то,что мы откроем таблицу,индексируемую для чтения.Чтобы построить индекс для таблицы,мы должны знать,что находится в этой таблице.Индекс уже открыт для записи курсором 0 по инструкциям 3 и 4.</target>
        </trans-unit>
        <trans-unit id="5eb1752f78007fa49f66b7f76488ea011879482b" translate="yes" xml:space="preserve">
          <source>The first time that any SQLite process attempts to access the database file, it obtains a shared lock as described in &lt;a href=&quot;https://sqlite.org/section_3_2&quot;&gt;section 3.2&lt;/a&gt; above. But then it notices that there is a rollback journal file present. SQLite then checks to see if the rollback journal is a &quot;hot journal&quot;. A hot journal is a rollback journal that needs to be played back in order to restore the database to a sane state. A hot journal only exists when an earlier process was in the middle of committing a transaction when it crashed or lost power.</source>
          <target state="translated">В первый раз, когда какой-либо процесс SQLite пытается получить доступ к файлу базы данных, он получает общую блокировку, как описано в &lt;a href=&quot;https://sqlite.org/section_3_2&quot;&gt;разделе 3.2&lt;/a&gt; выше. Но затем он замечает наличие файла журнала отката. Затем SQLite проверяет, является ли журнал отката &amp;laquo;горячим журналом&amp;raquo;. Горячий журнал - это журнал отката, который необходимо воспроизвести, чтобы восстановить базу данных до нормального состояния. Горячий журнал существует только в том случае, если более ранний процесс находился в процессе фиксации транзакции, когда он потерпел сбой или потерял питание.</target>
        </trans-unit>
        <trans-unit id="e68a1d44352d39217814d6bf160a385833864476" translate="yes" xml:space="preserve">
          <source>The first time the sqlite3_aggregate_context(C,N) routine is called for a particular aggregate function, SQLite allocates N bytes of memory, zeroes out that memory, and returns a pointer to the new memory. On second and subsequent calls to sqlite3_aggregate_context() for the same aggregate function instance, the same buffer is returned. Sqlite3_aggregate_context() is normally called once for each invocation of the xStep callback and then one last time when the xFinal callback is invoked. When no rows match an aggregate query, the xStep() callback of the aggregate function implementation is never called and xFinal() is called exactly once. In those cases, sqlite3_aggregate_context() might be called for the first time from within xFinal().</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3a42cd86f3f8e7c9fddbcba13c3c1c638314931" translate="yes" xml:space="preserve">
          <source>The first time the sqlite3_aggregate_context(C,N) routine is called for a particular aggregate function, SQLite allocates N of memory, zeroes out that memory, and returns a pointer to the new memory. On second and subsequent calls to sqlite3_aggregate_context() for the same aggregate function instance, the same buffer is returned. Sqlite3_aggregate_context() is normally called once for each invocation of the xStep callback and then one last time when the xFinal callback is invoked. When no rows match an aggregate query, the xStep() callback of the aggregate function implementation is never called and xFinal() is called exactly once. In those cases, sqlite3_aggregate_context() might be called for the first time from within xFinal().</source>
          <target state="translated">При первом вызове рутины sqlite3_aggregate_context(C,N)для конкретной агрегатной функции SQLite выделяет N памяти,обнуляет эту память и возвращает указатель на новую память.При втором и последующих вызовах sqlite3_aggregate_context()для того же экземпляра агрегатной функции возвращается тот же буфер.Обычно функция Sqlite3_aggregate_context()вызывается один раз при каждом вызове функции xStep,а затем последний раз при вызове функции xFinal.Когда ни одна строка не совпадает с агрегированным запросом,обратный вызов xStep()реализации агрегированной функции никогда не вызывается,а xFinal()вызывается ровно один раз.В этих случаях sqlite3_aggregate_context()может быть вызвана впервые из xFinal().</target>
        </trans-unit>
        <trans-unit id="33a73e33477151458e48dab8a4d76f2a383719c8" translate="yes" xml:space="preserve">
          <source>The first two constants (SQLITE_MUTEX_FAST and SQLITE_MUTEX_RECURSIVE) cause sqlite3_mutex_alloc() to create a new mutex. The new mutex is recursive when SQLITE_MUTEX_RECURSIVE is used but not necessarily so when SQLITE_MUTEX_FAST is used. The mutex implementation does not need to make a distinction between SQLITE_MUTEX_RECURSIVE and SQLITE_MUTEX_FAST if it does not want to. SQLite will only request a recursive mutex in cases where it really needs one. If a faster non-recursive mutex implementation is available on the host platform, the mutex subsystem might return such a mutex in response to SQLITE_MUTEX_FAST.</source>
          <target state="translated">Первые две константы (SQLITE_MUTEX_FAST и SQLITE_MUTEX_RECURSIVE)вызывают sqlite3_mutex_alloc()для создания нового мьютекса.Новый мьютекс является рекурсивным при использовании SQLITE_MUTEX_RECURSIVE,но не обязательно при использовании SQLITE_MUTEX_FAST.В реализации мьютекса нет необходимости делать различие между SQLITE_MUTEX_RECURSIVE и SQLITE_MUTEX_FAST,если он этого не хочет.SQLite будет запрашивать рекурсивный мьютекс только в тех случаях,когда он действительно нужен.Если на хостовой платформе доступна более быстрая не рекурсивная реализация мьютекса,то подсистема мьютекса может вернуть такой мьютекс в ответ на запрос SQLITE_MUTEX_FAST.</target>
        </trans-unit>
        <trans-unit id="3ad84c4124333660ac2ec2d4b3b96a74793fd127" translate="yes" xml:space="preserve">
          <source>The first two elements in the list above, the associated</source>
          <target state="translated">Первые два элемента списка выше,связанные с</target>
        </trans-unit>
        <trans-unit id="9de36623b06dcc8a12dabc9fe8d69bf46f2afdab" translate="yes" xml:space="preserve">
          <source>The first two instructions in the VDBE program for our query are concerned with setting up values for &lt;b&gt;azColumn&lt;/b&gt;. The &lt;a href=&quot;opcode#ColumnName&quot;&gt;ColumnName&lt;/a&gt; instructions tell the VDBE what values to fill in for each element of the &lt;b&gt;azColumnName[]&lt;/b&gt; array. Every query will begin with one ColumnName instruction for each column in the result, and there will be a matching Column instruction for each one later in the query.</source>
          <target state="translated">Первые две инструкции в программе VDBE для нашего запроса связаны с настройкой значений для &lt;b&gt;azColumn&lt;/b&gt; . В &lt;a href=&quot;opcode#ColumnName&quot;&gt;ColumnName&lt;/a&gt; инструкции сказать VDBE , какие значения для заполнения для каждого элемента &lt;b&gt;azColumnName []&lt;/b&gt; массива. Каждый запрос будет начинаться с одной инструкции ColumnName для каждого столбца в результате, и позже в запросе будет соответствующая инструкция ColumnName для каждого столбца.</target>
        </trans-unit>
        <trans-unit id="80f7eaccbd1b0c6d2fde7b56494766bcf2304eb6" translate="yes" xml:space="preserve">
          <source>The first two query examples illustrate a kind of template that every SELECT program will follow. Basically, we have:</source>
          <target state="translated">Первые два примера запросов иллюстрируют вид шаблона,которому будет следовать каждая программа SELECT.В принципе,есть:</target>
        </trans-unit>
        <trans-unit id="c636087069b26e9346b965d8bb5b5d8294795344" translate="yes" xml:space="preserve">
          <source>The first value in the array of integer values corresponds to the leftmost column of the table (column 0) and the first phrase in the query (phrase 0). The values corresponding to other column/phrase combinations may be located using the following formula:</source>
          <target state="translated">Первое значение в массиве целочисленных значений соответствует самому левому столбцу таблицы (столбец 0)и первой фразе запроса (фраза 0).Значения,соответствующие другим комбинациям столбец/фраза,могут быть расположены по следующей формуле:</target>
        </trans-unit>
        <trans-unit id="61029d8449643ad48e743f1026fb94f8a1ed1222" translate="yes" xml:space="preserve">
          <source>The first, or only, integer is the blockid that corresponds to the interior node with the largest blockid that belongs to this segment b-tree. Or zero if the entire segment b-tree fits on the root node. If it exists, this node is always an interior node.</source>
          <target state="translated">Первое или единственное целое число-это блокировка,соответствующая внутреннему узлу с наибольшей блокировкой,принадлежащей этому сегменту b-дерева.Или ноль,если весь сегмент b-дерева укладывается в корневой узел.Если он существует,то этот узел всегда является внутренним узлом.</target>
        </trans-unit>
        <trans-unit id="c0ebe13b31f8942f70d44d11a35f84a9529666cd" translate="yes" xml:space="preserve">
          <source>The fix in the 3.25.0 release for the endless-loop in the byte-code associated with the ORDER BY LIMIT optimization did not work for some queries involving window functions. An additional correction is required. Ticket &lt;a href=&quot;https://sqlite.org/src/info/510cde277783b5fb&quot;&gt;510cde277783b5fb&lt;/a&gt;</source>
          <target state="translated">Исправление в выпуске 3.25.0 для бесконечного цикла в байтовом коде, связанное с оптимизацией ORDER BY LIMIT, не работало для некоторых запросов, связанных с оконными функциями. Требуется дополнительная коррекция. Билет &lt;a href=&quot;https://sqlite.org/src/info/510cde277783b5fb&quot;&gt;510cde277783b5fb&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c2032be06ad1313d23c4aa0f2d29e1f73447dfd8" translate="yes" xml:space="preserve">
          <source>The fix to the previous bug uncovered a deadlock which was also fixed.</source>
          <target state="translated">Исправление предыдущей ошибки обнаружило тупик,который также был исправлен.</target>
        </trans-unit>
        <trans-unit id="8197368f601d93edb14a348de0bf212d3c1bcf51" translate="yes" xml:space="preserve">
          <source>The flags argument to xAccess() may be &lt;a href=&quot;#SQLITE_ACCESS_EXISTS&quot; id=&quot;sqlite3vfsxaccess&quot;&gt;SQLITE_ACCESS_EXISTS&lt;/a&gt; to test for the existence of a file, or &lt;a href=&quot;#SQLITE_ACCESS_EXISTS&quot;&gt;SQLITE_ACCESS_READWRITE&lt;/a&gt; to test whether a file is readable and writable, or &lt;a href=&quot;#SQLITE_ACCESS_EXISTS&quot;&gt;SQLITE_ACCESS_READ&lt;/a&gt; to test whether a file is at least readable. The SQLITE_ACCESS_READ flag is never actually used and is not implemented in the built-in VFSes of SQLite. The file is named by the second argument and can be a directory. The xAccess method returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; on success or some non-zero error code if there is an I/O error or if the name of the file given in the second argument is illegal. If SQLITE_OK is returned, then non-zero or zero is written into *pResOut to indicate whether or not the file is accessible.</source>
          <target state="translated">Аргументом flags для xAccess () может быть &lt;a href=&quot;#SQLITE_ACCESS_EXISTS&quot; id=&quot;sqlite3vfsxaccess&quot;&gt;SQLITE_ACCESS_EXISTS&lt;/a&gt; для проверки существования файла или &lt;a href=&quot;#SQLITE_ACCESS_EXISTS&quot;&gt;SQLITE_ACCESS_READWRITE&lt;/a&gt; для проверки, доступен ли файл для чтения и записи, или &lt;a href=&quot;#SQLITE_ACCESS_EXISTS&quot;&gt;SQLITE_ACCESS_READ&lt;/a&gt; для проверки, по крайней мере, доступен для чтения файл. Флаг SQLITE_ACCESS_READ фактически никогда не используется и не реализован во встроенных VFS SQLite. Файл называется вторым аргументом и может быть каталогом. Метод xAccess возвращает &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; в случае успеха или ненулевого кода ошибки, если есть ошибка ввода-вывода или если имя файла, указанное во втором аргументе, является недопустимым. Если возвращается SQLITE_OK, то в * pResOut записывается ненулевое или нулевое значение, чтобы указать, доступен ли файл.</target>
        </trans-unit>
        <trans-unit id="ee0102cf2398a56ff989592f19a055847f5dc920" translate="yes" xml:space="preserve">
          <source>The flags argument to xAccess() may be &lt;a href=&quot;c_access_exists&quot; id=&quot;sqlite3vfsxaccess&quot;&gt;SQLITE_ACCESS_EXISTS&lt;/a&gt; to test for the existence of a file, or &lt;a href=&quot;c_access_exists&quot;&gt;SQLITE_ACCESS_READWRITE&lt;/a&gt; to test whether a file is readable and writable, or &lt;a href=&quot;c_access_exists&quot;&gt;SQLITE_ACCESS_READ&lt;/a&gt; to test whether a file is at least readable. The SQLITE_ACCESS_READ flag is never actually used and is not implemented in the built-in VFSes of SQLite. The file is named by the second argument and can be a directory. The xAccess method returns &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; on success or some non-zero error code if there is an I/O error or if the name of the file given in the second argument is illegal. If SQLITE_OK is returned, then non-zero or zero is written into *pResOut to indicate whether or not the file is accessible.</source>
          <target state="translated">Аргументом flags для xAccess () может быть &lt;a href=&quot;c_access_exists&quot; id=&quot;sqlite3vfsxaccess&quot;&gt;SQLITE_ACCESS_EXISTS&lt;/a&gt; для проверки существования файла или &lt;a href=&quot;c_access_exists&quot;&gt;SQLITE_ACCESS_READWRITE&lt;/a&gt; для проверки, доступен ли файл для чтения и записи, или &lt;a href=&quot;c_access_exists&quot;&gt;SQLITE_ACCESS_READ&lt;/a&gt; для проверки, по крайней мере, доступен для чтения файл. Флаг SQLITE_ACCESS_READ фактически никогда не используется и не реализован во встроенных VFS SQLite. Файл называется вторым аргументом и может быть каталогом. Метод xAccess возвращает &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; в случае успеха или ненулевого кода ошибки, если есть ошибка ввода-вывода или если имя файла, указанное во втором аргументе, является недопустимым. Если возвращается SQLITE_OK, то в * pResOut записывается ненулевое или нулевое значение, чтобы указать, доступен ли файл.</target>
        </trans-unit>
        <trans-unit id="d9f0c284ad1c57f7e5da616991af768f686e341f" translate="yes" xml:space="preserve">
          <source>The flags argument to xOpen() includes all bits set in the flags argument to &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;. Or if &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open()&lt;/a&gt; or &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open16()&lt;/a&gt; is used, then flags includes at least &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_READWRITE&lt;/a&gt; | &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_CREATE&lt;/a&gt;. If xOpen() opens a file read-only then it sets *pOutFlags to include &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_READONLY&lt;/a&gt;. Other bits in *pOutFlags may be set.</source>
          <target state="translated">Аргумент flags для xOpen () включает все биты, установленные в аргументе flags для &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2 ()&lt;/a&gt; . Или, если используется &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open ()&lt;/a&gt; или &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open16 ()&lt;/a&gt; , тогда flags включает как минимум &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_READWRITE&lt;/a&gt; | &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_CREATE&lt;/a&gt; . Если xOpen () открывает файл только для чтения, он устанавливает * pOutFlags для включения &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_READONLY&lt;/a&gt; . Другие биты в * pOutFlags могут быть установлены.</target>
        </trans-unit>
        <trans-unit id="f5198d48ad55972f3bafe448a5f83115c01462b7" translate="yes" xml:space="preserve">
          <source>The flags argument to xOpen() includes all bits set in the flags argument to &lt;a href=&quot;open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;. Or if &lt;a href=&quot;open&quot;&gt;sqlite3_open()&lt;/a&gt; or &lt;a href=&quot;open&quot;&gt;sqlite3_open16()&lt;/a&gt; is used, then flags includes at least &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_READWRITE&lt;/a&gt; | &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_CREATE&lt;/a&gt;. If xOpen() opens a file read-only then it sets *pOutFlags to include &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_READONLY&lt;/a&gt;. Other bits in *pOutFlags may be set.</source>
          <target state="translated">Аргумент flags для xOpen () включает все биты, установленные в аргументе flags для &lt;a href=&quot;open&quot;&gt;sqlite3_open_v2 ()&lt;/a&gt; . Или, если используется &lt;a href=&quot;open&quot;&gt;sqlite3_open ()&lt;/a&gt; или &lt;a href=&quot;open&quot;&gt;sqlite3_open16 ()&lt;/a&gt; , тогда flags включает как минимум &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_READWRITE&lt;/a&gt; | &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_CREATE&lt;/a&gt; . Если xOpen () открывает файл только для чтения, он устанавливает * pOutFlags для включения &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_READONLY&lt;/a&gt; . Другие биты в * pOutFlags могут быть установлены.</target>
        </trans-unit>
        <trans-unit id="7bc004618637404d4a4bd35b24cc91bd411a3086" translate="yes" xml:space="preserve">
          <source>The flags argument to xSync may be one of &lt;a href=&quot;#SQLITE_SYNC_DATAONLY&quot;&gt;SQLITE_SYNC_NORMAL&lt;/a&gt; or &lt;a href=&quot;#SQLITE_SYNC_DATAONLY&quot;&gt;SQLITE_SYNC_FULL&lt;/a&gt;. The first choice is the normal fsync(). The second choice is a Mac OS X style fullsync. The &lt;a href=&quot;#SQLITE_SYNC_DATAONLY&quot;&gt;SQLITE_SYNC_DATAONLY&lt;/a&gt; flag may be ORed in to indicate that only the data of the file and not its inode needs to be synced.</source>
          <target state="translated">Аргумент flags для xSync может быть одним из &lt;a href=&quot;#SQLITE_SYNC_DATAONLY&quot;&gt;SQLITE_SYNC_NORMAL&lt;/a&gt; или &lt;a href=&quot;#SQLITE_SYNC_DATAONLY&quot;&gt;SQLITE_SYNC_FULL&lt;/a&gt; . Первый выбор - это обычная fsync (). Второй вариант - это полная синхронизация в стиле Mac OS X. &lt;a href=&quot;#SQLITE_SYNC_DATAONLY&quot;&gt;SQLITE_SYNC_DATAONLY&lt;/a&gt; флаг может быть ORed , чтобы указать , что только данные файла , а не его потребности индексных дескрипторов , которые будут синхронизироваться.</target>
        </trans-unit>
        <trans-unit id="99d3aea2b8c0b18767851d7c8d3921e4603f6ed1" translate="yes" xml:space="preserve">
          <source>The flags argument to xSync may be one of &lt;a href=&quot;c_sync_dataonly&quot;&gt;SQLITE_SYNC_NORMAL&lt;/a&gt; or &lt;a href=&quot;c_sync_dataonly&quot;&gt;SQLITE_SYNC_FULL&lt;/a&gt;. The first choice is the normal fsync(). The second choice is a Mac OS X style fullsync. The &lt;a href=&quot;c_sync_dataonly&quot;&gt;SQLITE_SYNC_DATAONLY&lt;/a&gt; flag may be ORed in to indicate that only the data of the file and not its inode needs to be synced.</source>
          <target state="translated">Аргумент flags для xSync может быть одним из &lt;a href=&quot;c_sync_dataonly&quot;&gt;SQLITE_SYNC_NORMAL&lt;/a&gt; или &lt;a href=&quot;c_sync_dataonly&quot;&gt;SQLITE_SYNC_FULL&lt;/a&gt; . Первый выбор - это обычная fsync (). Второй вариант - это полная синхронизация в стиле Mac OS X. &lt;a href=&quot;c_sync_dataonly&quot;&gt;SQLITE_SYNC_DATAONLY&lt;/a&gt; флаг может быть ORed , чтобы указать , что только данные файла , а не его потребности индексных дескрипторов , которые будут синхронизироваться.</target>
        </trans-unit>
        <trans-unit id="c377d5a3884469a39150e12bd3af49c973f2fad1" translate="yes" xml:space="preserve">
          <source>The floating-point to text conversion subfunction for the built-in printf() is limited in precision to 16 significant digits or 26 significant digits if the &quot;!&quot; alternate-form-2 flag is used. Every IEEE-754 double can be represented exactly as a decimal floating-point value, but some doubles require more than 16 or 26 significant digits.</source>
          <target state="translated">Подфункция преобразования текста с плавающей точкой в текст для встроенной функции printf()ограничена по точности 16 значащими цифрами или 26 значащими цифрами,если используется флаг &quot;!&quot; переменной формы-2.Каждый двойник IEEE-754 может быть точно представлен в виде десятичной запятой с плавающей точкой,но некоторые двойники требуют более 16 или 26 значащих цифр.</target>
        </trans-unit>
        <trans-unit id="68fce5c170ab1896511f13fd3e82f411098f2695" translate="yes" xml:space="preserve">
          <source>The folder returned by the GetTempPath() system interface.</source>
          <target state="translated">Папка,возвращаемая системным интерфейсом GetTempPath().</target>
        </trans-unit>
        <trans-unit id="4f48bdf9b1dfd94aea260fd19b610d7cf9d72be5" translate="yes" xml:space="preserve">
          <source>The folder set by &lt;a href=&quot;pragma#pragma_temp_store_directory&quot;&gt;PRAGMA temp_store_directory&lt;/a&gt; or by the &lt;a href=&quot;c3ref/temp_directory&quot;&gt;sqlite3_temp_directory&lt;/a&gt; global variable</source>
          <target state="translated">Папка, заданная &lt;a href=&quot;pragma#pragma_temp_store_directory&quot;&gt;PRAGMA temp_store_directory&lt;/a&gt; или глобальной переменной &lt;a href=&quot;c3ref/temp_directory&quot;&gt;sqlite3_temp_directory&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8f393fa7f5f393cd220ff4a7a6a7ccbac66e5676" translate="yes" xml:space="preserve">
          <source>The following &lt;a href=&quot;https://xkcd.com/1597/&quot;&gt;https://xkcd.com/1597/&lt;/a&gt; cartoon is an exaggeration, yet hits close to home:</source>
          <target state="translated">Следующий мультфильм &lt;a href=&quot;https://xkcd.com/1597/&quot;&gt;https://xkcd.com/1597/&lt;/a&gt; является преувеличением, но близок к нему:</target>
        </trans-unit>
        <trans-unit id="40de557d79eeab5be4528c0beef95dcb1a5f7ef4" translate="yes" xml:space="preserve">
          <source>The following RBU database schema may be used:</source>
          <target state="translated">Может использоваться следующая схема базы данных RBU:</target>
        </trans-unit>
        <trans-unit id="ae49ebf9365c52bbf37afc8c396e0cba8b2d31d3" translate="yes" xml:space="preserve">
          <source>The following SQL demonstrates how SQLite uses column affinity to do type conversions when values are inserted into a table.</source>
          <target state="translated">Следующий SQL демонстрирует,как SQLite использует сродство столбцов для приведения типов,когда значения вставляются в таблицу.</target>
        </trans-unit>
        <trans-unit id="d10a8778dff23f69800ec8a5dd149287ef5743ba" translate="yes" xml:space="preserve">
          <source>The following SQL illustrates how to use the ieee754 and decimal extensions to compute the exact decimal equivalent for a binary64 floating-point number.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7479fafb0c600f993e6250d871980ae79cbdf35" translate="yes" xml:space="preserve">
          <source>The following SQLite command-line session illustrates the effect of the foreign key constraint added to the</source>
          <target state="translated">Следующая сессия командной строки SQLite иллюстрирует эффект ограничения по внешнему ключу,добавленному к</target>
        </trans-unit>
        <trans-unit id="1f8a8aec572c42d81f9a9d30dc36ba0c1a7ca331" translate="yes" xml:space="preserve">
          <source>The following additional compile-time options are recommended in order to provide a full-featured command-line shell:</source>
          <target state="translated">Для обеспечения полнофункциональной оболочки командной строки рекомендуются следующие дополнительные опции времени компиляции:</target>
        </trans-unit>
        <trans-unit id="e661fc6daecc53fc88e2038803ed3bcb13092e93" translate="yes" xml:space="preserve">
          <source>The following additional syntax restrictions apply to UPDATE statements that occur within the body of a &lt;a href=&quot;lang_createtrigger&quot;&gt;CREATE TRIGGER&lt;/a&gt; statement.</source>
          <target state="translated">Следующие дополнительные ограничения синтаксиса применяются к операторам UPDATE, которые встречаются в теле оператора &lt;a href=&quot;lang_createtrigger&quot;&gt;CREATE TRIGGER&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0a78308c3e0962720a3b6c6b2c92b551ac030e31" translate="yes" xml:space="preserve">
          <source>The following are allowed values for 6th argument (the F argument) to the &lt;a href=&quot;#sqlite3_deserialize&quot;&gt;sqlite3_deserialize(D,S,P,N,M,F)&lt;/a&gt; interface.</source>
          <target state="translated">Ниже приведены допустимые значения для 6-го аргумента (аргумент &lt;a href=&quot;#sqlite3_deserialize&quot;&gt;F)&lt;/a&gt; интерфейса sqlite3_deserialize (D, S, P, N, M, F) .</target>
        </trans-unit>
        <trans-unit id="b9076a86669fb7bce220c5cc2398686ebb071016" translate="yes" xml:space="preserve">
          <source>The following are allowed values for 6th argument (the F argument) to the &lt;a href=&quot;deserialize&quot;&gt;sqlite3_deserialize(D,S,P,N,M,F)&lt;/a&gt; interface.</source>
          <target state="translated">Ниже приведены допустимые значения для 6-го аргумента (аргумент &lt;a href=&quot;deserialize&quot;&gt;F)&lt;/a&gt; интерфейса sqlite3_deserialize (D, S, P, N, M, F) .</target>
        </trans-unit>
        <trans-unit id="a59459d6632d0bbc1149f827b602fb3d835358c8" translate="yes" xml:space="preserve">
          <source>The following are examples of disabling the built-in protection mechanisms of SQLite:</source>
          <target state="translated">Ниже приведены примеры отключения встроенных механизмов защиты SQLite:</target>
        </trans-unit>
        <trans-unit id="80d00e742a47603d638009e13703b23c42a0d91f" translate="yes" xml:space="preserve">
          <source>The following are other VFS implementations available in the public SQLite source tree:</source>
          <target state="translated">Ниже приведены другие реализации VFS,доступные в публичном дереве исходных текстов SQLite:</target>
        </trans-unit>
        <trans-unit id="ec123026fdd8e1c2278a5f9715d6939ab0dbeb46" translate="yes" xml:space="preserve">
          <source>The following are the available OMIT options:</source>
          <target state="translated">Ниже приведены доступные опции OMIT:</target>
        </trans-unit>
        <trans-unit id="8fa3cecc90ff41687bc039d2f339ed203679e422" translate="yes" xml:space="preserve">
          <source>The following block contains a summary of the FTS query syntax in BNF form. A detailed explanation follows.</source>
          <target state="translated">Следующий блок содержит краткое изложение синтаксиса запроса FTS в форме BNF.Ниже приводится подробное объяснение.</target>
        </trans-unit>
        <trans-unit id="9eacb2386777a09c397574d603b9f7b4a178b7c8" translate="yes" xml:space="preserve">
          <source>The following block contains an example of calling the fts3_tokenizer() function from C code:</source>
          <target state="translated">В следующем блоке приведен пример вызова функции fts3_tokenizer()из кода на языке Си:</target>
        </trans-unit>
        <trans-unit id="8a513f3e74d7cb1dc9f72503b5eb2053d246b6ad" translate="yes" xml:space="preserve">
          <source>The following block contains examples that use the offsets function.</source>
          <target state="translated">В следующем блоке приведены примеры использования функции смещения.</target>
        </trans-unit>
        <trans-unit id="5c334635414a3c37311f7280f25331d2da05c0d0" translate="yes" xml:space="preserve">
          <source>The following chart shows the substitution types supported by SQLite:</source>
          <target state="translated">На следующем графике показаны типы замен,поддерживаемые SQLite:</target>
        </trans-unit>
        <trans-unit id="16f175b629dac9ff34c51ebace5610e8bb2a6ee9" translate="yes" xml:space="preserve">
          <source>The following compile-time options are recommended for applications that are able to use them, in order to minimized the number of CPU cycles and the bytes of memory used by SQLite. Not all of these compile-time options are usable by every application. For example, the SQLITE_THREADSAFE=0 option is only usable by applications that never access SQLite from more than one thread at a time. And the SQLITE_OMIT_PROGRESS_CALLBACK option is only usable by applications that do not use the &lt;a href=&quot;c3ref/progress_handler&quot;&gt;sqlite3_progress_handler()&lt;/a&gt; interface. And so forth.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c06c8d896e801657db8f70d5a5bd2960e6843e64" translate="yes" xml:space="preserve">
          <source>The following compile-time options are recommended for applications that are able to use them, in order to minimized the number of CPU cycles and the bytes of memory used by SQLite. Not all of these compile-time options are usable by every application. For example, the SQLITE_THREADSAFE=0 option is only usable by applications that never access SQLite from more than one thread at a time. And the SQLITE_OMIT_PROGRESS_CALLBACK option is only usable by applications that doe not use the &lt;a href=&quot;c3ref/progress_handler&quot;&gt;sqlite3_progress_handler()&lt;/a&gt; interface. And so forth.</source>
          <target state="translated">Следующие параметры времени компиляции рекомендуются для приложений, которые могут их использовать, чтобы минимизировать количество циклов процессора и байтов памяти, используемых SQLite. Не все эти параметры времени компиляции могут использоваться каждым приложением. Например, параметр SQLITE_THREADSAFE = 0 может использоваться только приложениями, которые никогда не обращаются к SQLite из более чем одного потока одновременно. А параметр SQLITE_OMIT_PROGRESS_CALLBACK может использоваться только приложениями, которые не используют интерфейс &lt;a href=&quot;c3ref/progress_handler&quot;&gt;sqlite3_progress_handler ()&lt;/a&gt; . И так далее.</target>
        </trans-unit>
        <trans-unit id="1f053eef3c13d51d862b4f23cc04af6f84e75626" translate="yes" xml:space="preserve">
          <source>The following constants can be used for the T parameter to the &lt;a href=&quot;#sqlite3_stmt_scanstatus&quot;&gt;sqlite3_stmt_scanstatus(S,X,T,V)&lt;/a&gt; interface. Each constant designates a different metric for sqlite3_stmt_scanstatus() to return.</source>
          <target state="translated">Следующие константы можно использовать для параметра &lt;a href=&quot;#sqlite3_stmt_scanstatus&quot;&gt;T&lt;/a&gt; интерфейса sqlite3_stmt_scanstatus (S, X, T, V) . Каждая константа обозначает разные метрики, которые должна возвращать sqlite3_stmt_scanstatus ().</target>
        </trans-unit>
        <trans-unit id="42e5a30e943fe484b45c04468e002affa80c1a88" translate="yes" xml:space="preserve">
          <source>The following constants can be used for the T parameter to the &lt;a href=&quot;stmt_scanstatus&quot;&gt;sqlite3_stmt_scanstatus(S,X,T,V)&lt;/a&gt; interface. Each constant designates a different metric for sqlite3_stmt_scanstatus() to return.</source>
          <target state="translated">Следующие константы можно использовать для параметра &lt;a href=&quot;stmt_scanstatus&quot;&gt;T&lt;/a&gt; интерфейса sqlite3_stmt_scanstatus (S, X, T, V) . Каждая константа обозначает разные метрики, которые должна возвращать sqlite3_stmt_scanstatus ().</target>
        </trans-unit>
        <trans-unit id="0dd0f222abc9f123e613d4dc8f011601915507ab" translate="yes" xml:space="preserve">
          <source>The following diagram depicts the format of a segment b-tree interior (non-leaf) node.</source>
          <target state="translated">На следующем рисунке показан формат сегмента b-дерева внутреннего (нелистового)узла.</target>
        </trans-unit>
        <trans-unit id="24519f5efb1b482cdcbf663c45ec684bda267ab2" translate="yes" xml:space="preserve">
          <source>The following diagram depicts the format of a segment b-tree leaf node.</source>
          <target state="translated">На следующей диаграмме представлен формат узла сегмента b-деревянного листа.</target>
        </trans-unit>
        <trans-unit id="d2d809dec5a64a655b9636ca71424601eda3c8d0" translate="yes" xml:space="preserve">
          <source>The following example code illustrates the techniques described above.</source>
          <target state="translated">Следующий пример кода иллюстрирует методы,описанные выше.</target>
        </trans-unit>
        <trans-unit id="54bdf2a30ded538a716ed8a4baee084a78f8a312" translate="yes" xml:space="preserve">
          <source>The following example creates a new SQL function named &quot;hex&quot; that converts its numeric argument in to a hexadecimal encoded string:</source>
          <target state="translated">В следующем примере создается новая SQL-функция под названием &quot;hex&quot;,которая преобразует свой числовой аргумент в шестнадцатеричную закодированную строку:</target>
        </trans-unit>
        <trans-unit id="9d4eb7545f22068db9db1145bb2583cae1439f33" translate="yes" xml:space="preserve">
          <source>The following example demonstrates the effect of the various forms of the EXCLUDE clause:</source>
          <target state="translated">Следующий пример демонстрирует действие различных форм клаузулы EXCLUDE:</target>
        </trans-unit>
        <trans-unit id="3fb64142e08ab04e58bc3d16cc93b9564bb653f2" translate="yes" xml:space="preserve">
          <source>The following example illustrates precedence of operators using the standard query syntax:</source>
          <target state="translated">Следующий пример иллюстрирует приоритет операторов,использующих стандартный синтаксис запроса:</target>
        </trans-unit>
        <trans-unit id="33e08656a40dfd68bcb2d6194c63e1be80dcd4d4" translate="yes" xml:space="preserve">
          <source>The following example illustrates the above. The expressions &quot;docs&quot;, &quot;docs.docs&quot; and &quot;main.docs.docs&quot; all refer to column &quot;docs&quot;. However, the expression &quot;main.docs&quot; does not refer to any column. It could be used to refer to a table, but a table name is not allowed in the context in which it is used below.</source>
          <target state="translated">Следующий пример иллюстрирует вышеизложенное.Выражения &quot;docs&quot;,&quot;docs.docs&quot; и &quot;main.docs.docs&quot; относятся к колонке &quot;docs&quot;.Однако,выражение &quot;main.docs&quot; не относится ни к одной из колонок.Оно может быть использовано для ссылки на таблицу,но имя таблицы не разрешается в контексте,в котором оно используется ниже.</target>
        </trans-unit>
        <trans-unit id="6318f87943b573664a21e50213cf281e74663a27" translate="yes" xml:space="preserve">
          <source>The following example illustrates the behaviour of the five ranking functions - row_number(), rank(), dense_rank(), percent_rank() and cume_dist().</source>
          <target state="translated">Следующий пример иллюстрирует поведение пяти ранжирующих функций-row_number(),rank(),dense_rank(),percent_rank()и cume_dist().</target>
        </trans-unit>
        <trans-unit id="fd2f5de221e0f758d71eb8931f8c7e719ace6200" translate="yes" xml:space="preserve">
          <source>The following example illustrates the effect of using a deferred foreign key constraint.</source>
          <target state="translated">Следующий пример иллюстрирует эффект использования отложенного иностранного ключа.</target>
        </trans-unit>
        <trans-unit id="c39a3730f5c13caef84a726a00ac693030617813" translate="yes" xml:space="preserve">
          <source>The following example shows how to remove NUL character, and all text that follows, from a column of a table. So if you have a database file that contains embedded NULs and you would like to remove them, running UPDATE statements similar to the following might help:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21740a6dff76788fbc521cbbbedbec453f6795d5" translate="yes" xml:space="preserve">
          <source>The following example uses the sumint() function implemented by the above C code. For each row, the window consists of the preceding row (if any), the current row and the following row (again, if any):</source>
          <target state="translated">В следующем примере используется функция sumint(),реализованная в приведенном выше коде на языке Си.Для каждой строки окно состоит из предыдущей (если таковая имеется),текущей и следующей строки (опять же,если таковая имеется):</target>
        </trans-unit>
        <trans-unit id="9b577d330901567bab085337ea84d2a43135e876" translate="yes" xml:space="preserve">
          <source>The following example will better illustrate the use of SQLITE_CONSTRAINT as a return value from xBestIndex:</source>
          <target state="translated">Следующий пример лучше проиллюстрирует использование SQLITE_CONSTRAINT в качестве возвращаемого значения из xBestIndex:</target>
        </trans-unit>
        <trans-unit id="3f5880fbaaf652f0861c35b2ed9bf834e8800e30" translate="yes" xml:space="preserve">
          <source>The following flags may passed via the 4th parameter to &lt;a href=&quot;#sqlite3changeset_start&quot;&gt;sqlite3changeset_start_v2&lt;/a&gt; and &lt;a href=&quot;#sqlite3changegroup_add_strm&quot;&gt;sqlite3changeset_start_v2_strm&lt;/a&gt;:</source>
          <target state="translated">Следующие флаги могут быть переданы через 4-й параметр &lt;a href=&quot;#sqlite3changeset_start&quot;&gt;sqlite3changeset_start_v2&lt;/a&gt; и &lt;a href=&quot;#sqlite3changegroup_add_strm&quot;&gt;sqlite3changeset_start_v2_strm&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="dcb818ec6ae695589b5e698d66cbb55415f5689e" translate="yes" xml:space="preserve">
          <source>The following flags may passed via the 4th parameter to &lt;a href=&quot;sqlite3changeset_start&quot;&gt;sqlite3changeset_start_v2&lt;/a&gt; and &lt;a href=&quot;sqlite3changegroup_add_strm&quot;&gt;sqlite3changeset_start_v2_strm&lt;/a&gt;:</source>
          <target state="translated">Следующие флаги могут быть переданы через 4-й параметр &lt;a href=&quot;sqlite3changeset_start&quot;&gt;sqlite3changeset_start_v2&lt;/a&gt; и &lt;a href=&quot;sqlite3changegroup_add_strm&quot;&gt;sqlite3changeset_start_v2_strm&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="eaf06e6487557d77e67f76618b64eb4b39aae85e" translate="yes" xml:space="preserve">
          <source>The following flags may passed via the 9th parameter to &lt;a href=&quot;#sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply_v2&lt;/a&gt; and &lt;a href=&quot;#sqlite3changegroup_add_strm&quot;&gt;sqlite3changeset_apply_v2_strm&lt;/a&gt;:</source>
          <target state="translated">Следующие флаги могут передаваться через 9-й параметр в &lt;a href=&quot;#sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply_v2&lt;/a&gt; и &lt;a href=&quot;#sqlite3changegroup_add_strm&quot;&gt;sqlite3changeset_apply_v2_strm&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="8acfd72cc7dc7df0be4ef94764fa15b5b7e0e403" translate="yes" xml:space="preserve">
          <source>The following flags may passed via the 9th parameter to &lt;a href=&quot;sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply_v2&lt;/a&gt; and &lt;a href=&quot;sqlite3changegroup_add_strm&quot;&gt;sqlite3changeset_apply_v2_strm&lt;/a&gt;:</source>
          <target state="translated">Следующие флаги могут передаваться через 9-й параметр в &lt;a href=&quot;sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply_v2&lt;/a&gt; и &lt;a href=&quot;sqlite3changegroup_add_strm&quot;&gt;sqlite3changeset_apply_v2_strm&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="90a5abe74323cb727451a1fc89d79f6674e34a04" translate="yes" xml:space="preserve">
          <source>The following four configuration changes are recommended for maximum application security. Turning off the trust_schema setting prevents virtual tables and dodgy SQL functions from being used inside of triggers, views, CHECK constraints, generated columns, and expression indexes. Turning off the dqs_dml and dqs_ddl settings prevents the use of double-quoted strings. Turning on defensive prevents direct writes to shadow tables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f88559c5309089b2c53eff7ab551567dc8265aad" translate="yes" xml:space="preserve">
          <source>The following functions can be used to advance and query a changeset iterator created by this function:</source>
          <target state="translated">Следующие функции могут быть использованы для продвижения и запроса итератора изменений,созданного этой функцией:</target>
        </trans-unit>
        <trans-unit id="35f53ac017499b71e5f28f348a1b347ee5939139" translate="yes" xml:space="preserve">
          <source>The following is a log of all SQL used to generate one particular timeline (captured on 2016-09-16):</source>
          <target state="translated">Ниже приведен журнал всех SQL,использованных для создания одной конкретной временной шкалы (захваченный в 2016-09-16 гг.):</target>
        </trans-unit>
        <trans-unit id="8ca654574638bb42c5b323e2fbbcf528a1c97560" translate="yes" xml:space="preserve">
          <source>The following is a partial list of the kinds of messages that might appear in the error logger callback.</source>
          <target state="translated">Ниже приведен неполный список видов сообщений,которые могут появляться при обратном вызове регистратора ошибок.</target>
        </trans-unit>
        <trans-unit id="91f9f5074c39cae7458cb274b5e2472dd1f18791" translate="yes" xml:space="preserve">
          <source>The following is a random assortment of techniques used by the SQLite developers to trace, examine, and understand the behavior of the core SQLite library.</source>
          <target state="translated">Ниже приводится случайный набор методов,используемых разработчиками SQLite для отслеживания,изучения и понимания поведения ядра библиотеки SQLite.</target>
        </trans-unit>
        <trans-unit id="172b7cc8402676bd9591f1901c350fe56e3b1a3a" translate="yes" xml:space="preserve">
          <source>The following is sqlite3_analyzer output for an example places.sqlite database used by Firefox.</source>
          <target state="translated">Ниже приведен вывод анализатора sqlite3_analyzerer для примера базы данных places.sqlite,используемой Firefox.</target>
        </trans-unit>
        <trans-unit id="3b9bb38ec5e22c57b0f7c289494707329a29a947" translate="yes" xml:space="preserve">
          <source>The following limitations apply to RBU updates:</source>
          <target state="translated">Следующие ограничения распространяются на обновления RBU:</target>
        </trans-unit>
        <trans-unit id="fc2fda4c09167d54864b95b318f076cb56ce31c3" translate="yes" xml:space="preserve">
          <source>The following macros specify interface linkage for certain kinds of SQLite builds. The Makefiles will normally handle setting these macros automatically. Application developers should not need to worry with these macros. The following documentation about these macros is included completeness.</source>
          <target state="translated">Следующие макросы определяют связь интерфейса для определенных видов сборки SQLite.Обычно Makefiles автоматически обрабатывает настройку этих макросов.Разработчикам приложений не стоит беспокоиться об этих макросах.Следующая документация по этим макросам включает в себя полноту.</target>
        </trans-unit>
        <trans-unit id="e520cf121083171350ce54bdc25d9fb94f2ae9df" translate="yes" xml:space="preserve">
          <source>The following must be true for this function to succeed. If any of the following statements are false when sqlite3_snapshot_get() is called, SQLITE_ERROR is returned. The final value of *P is undefined in this case.</source>
          <target state="translated">Для успешного выполнения этой функции необходимо следующее.Если при вызове sqlite3_snapshot_get()какое-либо из следующих выражений будет ложным,то возвращается SQLITE_ERROR.Окончательное значение *P в этом случае не определено.</target>
        </trans-unit>
        <trans-unit id="13b4c313c53ce999997969a2a1da623479829206" translate="yes" xml:space="preserve">
          <source>The following options can be used to &lt;a href=&quot;footprint&quot;&gt;reduce the size of the compiled library&lt;/a&gt; by omitting unused features. This is probably only useful in embedded systems where space is especially tight, as even with all features included the SQLite library is relatively small. Don't forget to tell your compiler to optimize for binary size! (the -Os option if using GCC). Telling your compiler to optimize for size usually has a much larger impact on library footprint than employing any of these compile-time options. You should also verify that &lt;a href=&quot;#debugoptions&quot;&gt;debugging options&lt;/a&gt; are disabled.</source>
          <target state="translated">Следующие параметры можно использовать для &lt;a href=&quot;footprint&quot;&gt;уменьшения размера скомпилированной библиотеки за&lt;/a&gt; счет исключения неиспользуемых функций. Это, вероятно, полезно только во встроенных системах, где места особенно мало, поскольку даже со всеми включенными функциями библиотека SQLite относительно мала. Не забудьте указать компилятору оптимизировать двоичный размер! (параметр -Os при использовании GCC). Указание компилятору оптимизировать размер обычно оказывает гораздо большее влияние на размер библиотеки, чем использование любого из этих параметров времени компиляции. Вы также должны убедиться, что &lt;a href=&quot;#debugoptions&quot;&gt;параметры отладки&lt;/a&gt; отключены.</target>
        </trans-unit>
        <trans-unit id="aa7c844b688230c89a2857560379c0f551e0b077" translate="yes" xml:space="preserve">
          <source>The following query computes an approximation of the Mandelbrot Set and outputs the result as ASCII-art:</source>
          <target state="translated">Следующий запрос вычисляет аппроксимацию Mandelbrot Set и выводит результат в виде ASCII-art:</target>
        </trans-unit>
        <trans-unit id="165c7c17f77322908874e60dfb0fb76218a06202" translate="yes" xml:space="preserve">
          <source>The following query parameters are recognized by SQLite as of &lt;a href=&quot;https://sqlite.org/releaselog/3_15_0.html&quot;&gt;version 3.15.0&lt;/a&gt; (2016-10-14). New query parameters might be added in the future.</source>
          <target state="translated">Следующие параметры запроса распознаются SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_15_0.html&quot;&gt;начиная с версии 3.15.0&lt;/a&gt; (2016-10-14). В будущем могут быть добавлены новые параметры запроса.</target>
        </trans-unit>
        <trans-unit id="482aaeeca1acb6ff828caa9e341d537cef50e256" translate="yes" xml:space="preserve">
          <source>The following query returns all integers between 1 and 1000000:</source>
          <target state="translated">Следующий запрос возвращает все целые числа от 1 до 1000000:</target>
        </trans-unit>
        <trans-unit id="df61dccd4718a46758145386ef91e3af7a125626" translate="yes" xml:space="preserve">
          <source>The following requirements describe step 1 of the above procedure in more detail.</source>
          <target state="translated">Следующие требования более подробно описывают этап 1 вышеописанной процедуры.</target>
        </trans-unit>
        <trans-unit id="c7e0a9c1d2e39a35866f813a7b58e616f8a0dfa1" translate="yes" xml:space="preserve">
          <source>The following requirements describe step 2 of the above procedure in more detail.</source>
          <target state="translated">Следующие требования более подробно описывают этап 2 вышеуказанной процедуры.</target>
        </trans-unit>
        <trans-unit id="ab60a1fc45053970e49cb2236072b7574ce682f2" translate="yes" xml:space="preserve">
          <source>The following requirements describe step 3 of the above procedure in more detail.</source>
          <target state="translated">Следующие требования более подробно описывают 3-й этап вышеуказанной процедуры.</target>
        </trans-unit>
        <trans-unit id="0f5ce0f453d6b71b276dab07b31a916fac2ad143" translate="yes" xml:space="preserve">
          <source>The following requirements describe step 4 of the above procedure in more detail.</source>
          <target state="translated">Следующие требования более подробно описывают 4-й этап вышеуказанной процедуры.</target>
        </trans-unit>
        <trans-unit id="ff1604c4fd7473773943aa62c8883c18d8179ef1" translate="yes" xml:space="preserve">
          <source>The following requirements describe the steps enumerated above in more detail.</source>
          <target state="translated">Следующие требования более подробно описывают вышеперечисленные шаги.</target>
        </trans-unit>
        <trans-unit id="ca6589a3a75bae1a771049671e8297b9c43f424f" translate="yes" xml:space="preserve">
          <source>The following restrictions apply to DELETE statements that occur within the body of a &lt;a href=&quot;lang_createtrigger&quot;&gt;CREATE TRIGGER&lt;/a&gt; statement:</source>
          <target state="translated">Следующие ограничения применяются к операторам DELETE, которые встречаются в теле оператора &lt;a href=&quot;lang_createtrigger&quot;&gt;CREATE TRIGGER&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="1404887613e3d3d478c15bfa20064138fe1f758d" translate="yes" xml:space="preserve">
          <source>The following routines are used to implement user-defined collating sequences:</source>
          <target state="translated">Следующие процедуры используются для реализации заданных пользователем коллизионных последовательностей:</target>
        </trans-unit>
        <trans-unit id="9d61d2cb84c2da7119bdaa99ad1c2d7a32c4afe9" translate="yes" xml:space="preserve">
          <source>The following rules and caveats apply to the values specified as part of each INSERT statement:</source>
          <target state="translated">Следующие правила и предостережения применяются к значениям,указанным в каждом утверждении INSERT:</target>
        </trans-unit>
        <trans-unit id="a26a29856749163d9eb4f80a667633bb87f813e9" translate="yes" xml:space="preserve">
          <source>The following rules show how each of the locks is used.</source>
          <target state="translated">Следующие правила показывают,как используется каждый из замков.</target>
        </trans-unit>
        <trans-unit id="737ea9fa3e70c97a0a7b4c9228ebcdc9127f52cb" translate="yes" xml:space="preserve">
          <source>The following scenario illustrates how an SQLITE_BUSY_SNAPSHOT error might arise:</source>
          <target state="translated">Следующий сценарий иллюстрирует,как может возникнуть ошибка SQLITE_BUSY_SNAPSHOT:</target>
        </trans-unit>
        <trans-unit id="4840312a4c02316c9bb1b228254597da9db65628" translate="yes" xml:space="preserve">
          <source>The following script was used to gather information for the table above.</source>
          <target state="translated">Для сбора информации для вышеприведенной таблицы был использован следующий скрипт.</target>
        </trans-unit>
        <trans-unit id="5f95a6062676138baa336da2cd5b1ec87382d19c" translate="yes" xml:space="preserve">
          <source>The following section describes the API offered to auxiliary function implementations in detail. Further examples may be found in the &quot;fts5_aux.c&quot; file of the source code.</source>
          <target state="translated">В следующем разделе подробно описывается API,предлагаемый для реализации вспомогательных функций.Дальнейшие примеры можно найти в файле исходного кода &quot;fts5_aux.c&quot;.</target>
        </trans-unit>
        <trans-unit id="c91d01efc0ba3649e7eacbf59f700342ec3a53a5" translate="yes" xml:space="preserve">
          <source>The following sections describe some low-level details of the R*Tree implementation, that might be useful for trouble-shooting or performance analysis.</source>
          <target state="translated">В следующих разделах описываются некоторые низкоуровневые детали реализации R*Tree,которые могут быть полезны для поиска неисправностей или анализа производительности.</target>
        </trans-unit>
        <trans-unit id="17e43452198f5289d975fb07abeb874782ed48a0" translate="yes" xml:space="preserve">
          <source>The following sections describe the supported parameters. Specifying an unrecognized parameter name is an error.</source>
          <target state="translated">В следующих разделах описаны поддерживаемые параметры.Указание имени нераспознанного параметра является ошибкой.</target>
        </trans-unit>
        <trans-unit id="009cc36fd7239429da331a5197a208b717cdb22a" translate="yes" xml:space="preserve">
          <source>The following sections provide additional detail on the operation of the various functions that are part of the json1 extension.</source>
          <target state="translated">В следующих разделах приводятся дополнительные сведения о работе различных функций,входящих в состав json1-расширения.</target>
        </trans-unit>
        <trans-unit id="0b996a91eae66dcc3a2860511963eb7fa7efc7eb" translate="yes" xml:space="preserve">
          <source>The following syntax documentation topics are available:</source>
          <target state="translated">Доступны следующие темы синтаксической документации:</target>
        </trans-unit>
        <trans-unit id="0e5fa08cf1724f31556de517effc85351bb377ec" translate="yes" xml:space="preserve">
          <source>The following table shows how many common datatype names from more traditional SQL implementations are converted into affinities by the five rules of the previous section. This table shows only a small subset of the datatype names that SQLite will accept. Note that numeric arguments in parentheses that following the type name (ex: &quot;VARCHAR(255)&quot;) are ignored by SQLite - SQLite does not impose any length restrictions (other than the large global &lt;a href=&quot;limits#max_length&quot;&gt;SQLITE_MAX_LENGTH&lt;/a&gt; limit) on the length of strings, BLOBs or numeric values.</source>
          <target state="translated">В следующей таблице показано, сколько общих имен типов данных из более традиционных реализаций SQL преобразовано в аффинности по пяти правилам из предыдущего раздела. В этой таблице показано только небольшое подмножество имен типов данных, которые принимает SQLite. Обратите внимание, что числовые аргументы в круглых скобках, следующие за именем типа (например: &amp;laquo;VARCHAR (255)&amp;raquo;), игнорируются SQLite - SQLite не налагает никаких ограничений длины (кроме большого глобального ограничения &lt;a href=&quot;limits#max_length&quot;&gt;SQLITE_MAX_LENGTH&lt;/a&gt; ) на длину строк, BLOB-объектов или числовые значения.</target>
        </trans-unit>
        <trans-unit id="54c0ab33937bb3d0205754132a184edc97ac8f8b" translate="yes" xml:space="preserve">
          <source>The following table shows the meanings of the (non-hidden) columns of DBSTAT in both normal and aggregated mode:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54feeefe0d9e52f7880c035de3af5b0398710d6a" translate="yes" xml:space="preserve">
          <source>The following table shows the results of the NULL handling experiments.</source>
          <target state="translated">В следующей таблице приведены результаты экспериментов по работе с NULL.</target>
        </trans-unit>
        <trans-unit id="12e0a00ef75b703780c84d1074e0287b2f403501" translate="yes" xml:space="preserve">
          <source>The following table summarizes the SQLite file format changes that have occurred since version 1.0.0:</source>
          <target state="translated">В следующей таблице представлены изменения формата файлов SQLite,произошедшие с версии 1.0.0:</target>
        </trans-unit>
        <trans-unit id="ea82e2bbe8fed4a7a8a0361c062cdbf2a7cb2e1f" translate="yes" xml:space="preserve">
          <source>The following two objects and eight methods comprise the essential elements of the SQLite interface:</source>
          <target state="translated">Следующие два объекта и восемь методов составляют основные элементы интерфейса SQLite:</target>
        </trans-unit>
        <trans-unit id="1b3057a8ce2692f0addf4973e487586ba5e334ab" translate="yes" xml:space="preserve">
          <source>The foregoing is all one really needs to know in order to use SQLite effectively. All the rest is optimization and detail.</source>
          <target state="translated">Все вышесказанное действительно необходимо знать,чтобы эффективно использовать SQLite.Все остальное-оптимизация и детализация.</target>
        </trans-unit>
        <trans-unit id="75a22928178fbb3c0cbb048a8ad2cc0d5b3170b7" translate="yes" xml:space="preserve">
          <source>The foregoing text describes low-level aspects of the SQLite file format. The b-tree mechanism provides a powerful and efficient means of accessing a large data set. This section will describe how the low-level b-tree layer is used to implement higher-level SQL capabilities.</source>
          <target state="translated">Приведенный выше текст описывает низкоуровневые аспекты формата файлов SQLite.Механизм b-дерева обеспечивает мощное и эффективное средство доступа к большому массиву данных.В данном разделе будет описано,как низкоуровневый b-деревовидный слой используется для реализации возможностей SQL более высокого уровня.</target>
        </trans-unit>
        <trans-unit id="12199f4a726aab3fb6304db80ece6cf69a955319" translate="yes" xml:space="preserve">
          <source>The foreign key constraint is satisfied if for each row in the child table either one or more of the child key columns are NULL, or there exists a row in the parent table for which each parent key column contains a value equal to the value in its associated child key column.</source>
          <target state="translated">Ограничение постороннего ключа удовлетворяется,если для каждой строки в дочерней таблице либо один или несколько столбцов дочернего ключа NULL,либо существует строка в родительской таблице,для которой каждый столбец родительского ключа содержит значение,равное значению в связанном с ним столбце дочернего ключа.</target>
        </trans-unit>
        <trans-unit id="7eb5b173b9130668a2a0b17e4f207640eaa017f0" translate="yes" xml:space="preserve">
          <source>The foreign key constraints created as part of tables</source>
          <target state="translated">Иностранные ключевые ограничения,созданные в рамках таблиц</target>
        </trans-unit>
        <trans-unit id="add6cc21a0d1ec9f3c982acde6cc5dc3f05465f0" translate="yes" xml:space="preserve">
          <source>The foreign_key_check pragma checks the database, or the table called &quot;</source>
          <target state="translated">Foreign_key_check прагма проверяет базу данных,или таблицу с именем &quot;</target>
        </trans-unit>
        <trans-unit id="9efc16f15cca4547a2a6b1e6f0aea092764cfc35" translate="yes" xml:space="preserve">
          <source>The formalized assumptions in this section refer to</source>
          <target state="translated">Формализованные допущения в этом разделе относятся к</target>
        </trans-unit>
        <trans-unit id="fe9496c466bbe179ee18ac47ed69a346233c9cbd" translate="yes" xml:space="preserve">
          <source>The format for sqlite_stat2 is recorded here for legacy reference. Recent versions of SQLite no longer support sqlite_stat2 and the sqlite_stat2 table, if is exists, is simply ignored.</source>
          <target state="translated">Формат sqlite_stat2 записан здесь для справки по наследству.Последние версии SQLite больше не поддерживают sqlite_stat2 и таблица sqlite_stat2,если она существует,просто игнорируется.</target>
        </trans-unit>
        <trans-unit id="d2a469c667d3464f2b4b57e3f59fb88c3da53ff2" translate="yes" xml:space="preserve">
          <source>The format of a cell depends on which kind of b-tree page the cell appears on. The following table shows the elements of a cell, in order of appearance, for the various b-tree page types.</source>
          <target state="translated">Формат ячейки зависит от того,на какой b-деревянной странице появляется ячейка.В следующей таблице приведены элементы ячейки в порядке их внешнего вида для различных типов b-деревянных страниц.</target>
        </trans-unit>
        <trans-unit id="8f6ebed1965bbd7f7af8c4c0949451b7c054d06f" translate="yes" xml:space="preserve">
          <source>The format of the arguments to the module is very general. Each module-argument may contain keywords, string literals, identifiers, numbers, and punctuation. Each module-argument is passed as written (as text) into the &lt;a href=&quot;vtab#xcreate&quot;&gt;constructor method&lt;/a&gt; of the virtual table implementation when the virtual table is created and that constructor is responsible for parsing and interpreting the arguments. The argument syntax is sufficiently general that a virtual table implementation can, if it wants to, interpret its arguments as &lt;a href=&quot;lang_createtable#tablecoldef&quot;&gt;column definitions&lt;/a&gt; in an ordinary &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; statement. The implementation could also impose some other interpretation on the arguments.</source>
          <target state="translated">Формат аргументов модуля очень общий. Каждый аргумент модуля может содержать ключевые слова, строковые литералы, идентификаторы, числа и знаки препинания. Каждый аргумент модуля передается так, как написано (как текст), в &lt;a href=&quot;vtab#xcreate&quot;&gt;метод&lt;/a&gt; конструктора реализации виртуальной таблицы при создании виртуальной таблицы, и этот конструктор отвечает за синтаксический анализ и интерпретацию аргументов. Синтаксис аргументов достаточно общий, чтобы реализация виртуальной таблицы могла, если захочет, интерпретировать свои аргументы как &lt;a href=&quot;lang_createtable#tablecoldef&quot;&gt;определения столбцов&lt;/a&gt; в обычном операторе &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; . Реализация может также наложить другую интерпретацию аргументов.</target>
        </trans-unit>
        <trans-unit id="ce6813c51545b0e36cbda5b5ae9abe31c78f2212" translate="yes" xml:space="preserve">
          <source>The format of the main database file is as described in the &lt;a href=&quot;fileformat2&quot;&gt;file format&lt;/a&gt; document. The &lt;a href=&quot;fileformat2#vnums&quot;&gt;file format version numbers&lt;/a&gt; at offsets 18 and 19 into the main database must both be 2 to indicate that the database is in WAL mode. The main database may have an arbitrary name allowed by the underlying filesystem. No special file suffixes are required, though &quot;.db&quot;, &quot;.sqlite&quot;, and &quot;.sqlite3&quot; seem to be popular choices.</source>
          <target state="translated">Формат основного файла базы данных описан в документе о &lt;a href=&quot;fileformat2&quot;&gt;формате файла&lt;/a&gt; . Номера &lt;a href=&quot;fileformat2#vnums&quot;&gt;версий формата файлов&lt;/a&gt; на смещениях 18 и 19 в основной базе данных должны быть равны 2, чтобы указать, что база данных находится в режиме WAL. Основная база данных может иметь произвольное имя, разрешенное базовой файловой системой. Никаких специальных файловых суффиксов не требуется, хотя &quot;.db&quot;, &quot;.sqlite&quot; и &quot;.sqlite3&quot; кажутся популярными.</target>
        </trans-unit>
        <trans-unit id="c748249cfa33fdfdfb8560eb0a7a2d06c6a7130e" translate="yes" xml:space="preserve">
          <source>The format string for printf() is a template for the generated string. Substitutions are made whenever a &quot;%&quot; character appears in the format string. The &quot;%&quot; is followed by one or more additional characters that describe the substitution. Each substitution has the following format:</source>
          <target state="translated">Строка формата для функции printf()является шаблоном для сгенерированной строки.Замены производятся всякий раз,когда в строке форматирования появляется символ &quot;%&quot;.За &quot;%&quot; следует один или несколько дополнительных символов,описывающих подстановку.Каждая замена имеет следующий формат:</target>
        </trans-unit>
        <trans-unit id="e5481902d614e43b8906fc140d4dc2a9c7914623" translate="yes" xml:space="preserve">
          <source>The format used by SQLite database files has been completely revised. The old version 2.1 format and the new 3.0 format are incompatible with one another. Version 2.8 of SQLite will not read a version 3.0 database files and version 3.0 of SQLite will not read a version 2.8 database file.</source>
          <target state="translated">Формат,используемый файлами базы данных SQLite,был полностью пересмотрен.Старая версия 2.1 и новый формат 3.0 несовместимы друг с другом.Версия 2.8 SQLite не будет читать файлы баз данных версии 3.0 и версия 3.0 SQLite не будет читать файл базы данных версии 2.8.</target>
        </trans-unit>
        <trans-unit id="a376c207dbbf638ec2db0cb626e4c46931a236b1" translate="yes" xml:space="preserve">
          <source>The fossil delta format may only be used to update BLOB values. Instead of storing the new BLOB within the data_% table, the fossil delta is stored instead. And instead of specifying an 'x' as part of the rbu_control string for the column to be updated, an 'f' character is stored. When processing an 'f' update, RBU loads the original BLOB data from disk, applies the fossil delta to it and stores the results back into the database file. The RBU databases generated by &lt;a href=&quot;rbu#sqldiff&quot;&gt;sqldiff --rbu&lt;/a&gt; make use of fossil deltas wherever doing so would save space in the RBU database.</source>
          <target state="translated">Формат ископаемой дельты можно использовать только для обновления значений BLOB. Вместо того, чтобы хранить новый BLOB в таблице data_%, вместо этого сохраняется ископаемая дельта. И вместо указания &amp;laquo;x&amp;raquo; как части строки rbu_control для обновляемого столбца сохраняется символ &amp;laquo;f&amp;raquo;. При обработке обновления &amp;laquo;f&amp;raquo; RBU загружает исходные данные BLOB с диска, применяет к ним ископаемую дельту и сохраняет результаты обратно в файл базы данных. Базы данных RBU, созданные с помощью &lt;a href=&quot;rbu#sqldiff&quot;&gt;sqldiff --rbu,&lt;/a&gt; используют дельты ископаемых везде, где это может сэкономить место в базе данных RBU.</target>
        </trans-unit>
        <trans-unit id="23a39933682f9054d9fbfd81554ffb9e23300f95" translate="yes" xml:space="preserve">
          <source>The founder of SQLite and all current developers have pledged to follow spirit of The Rule to the best of their ability. They view The Rule as their promise to all SQLite users of how the developers are expected to behave in community. This is a one-way promise, or covenant. In other words, the developers are saying: &quot;We will treat you this way regardless of how you treat us.&quot;</source>
          <target state="translated">Основатель SQLite и все нынешние разработчики пообещали следовать духу Правила в меру своих возможностей.Они рассматривают это правило как свое обещание всем пользователям SQLite о том,как разработчики должны вести себя в сообществе.Это одностороннее обещание,или соглашение.Другими словами,разработчики говорят:&quot;Мы будем относиться к вам так,независимо от того,как вы к нам относитесь&quot;.</target>
        </trans-unit>
        <trans-unit id="5e2d48a3048a9448f3349d8ade2ca9593428346e" translate="yes" xml:space="preserve">
          <source>The founder of SQLite and all current developers have pledged to follow the spirit of The Rule to the best of their ability. They view The Rule as their promise to all SQLite users of how the developers are expected to behave. This is a one-way promise, or covenant. In other words, the developers are saying: &quot;We will treat you this way regardless of how you treat us.&quot;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fac57078ba906f356fde5d5be039fc86e66f550e" translate="yes" xml:space="preserve">
          <source>The founder of SQLite, and all of the current developers at the time when this document was composed, have pledged to govern their interactions with each other, with their clients, and with the larger SQLite user community in accordance with the &quot;instruments of good works&quot; from chapter 4 of &lt;a href=&quot;https://en.wikipedia.org/wiki/Rule_of_Saint_Benedict&quot;&gt;The Rule of St. Benedict&lt;/a&gt; (hereafter: &quot;The Rule&quot;). This code of ethics has proven its mettle in thousands of diverse communities for over 1,500 years, and has served as a baseline for many civil law codes since the time of Charlemagne.</source>
          <target state="translated">Основатель SQLite и все текущие разработчики на момент написания этого документа пообещали управлять своим взаимодействием друг с другом, со своими клиентами и с большим сообществом пользователей SQLite в соответствии с &amp;laquo;инструментами добрых дел&amp;raquo;. &quot;из главы 4 &lt;a href=&quot;https://en.wikipedia.org/wiki/Rule_of_Saint_Benedict&quot;&gt;Правил св. Бенедикта&lt;/a&gt; (далее:&quot; Правило &quot;). Этот этический кодекс доказал свою стойкость в тысячах различных сообществ на протяжении более 1500 лет и служил базой для многих кодексов гражданского права со времен Карла Великого.</target>
        </trans-unit>
        <trans-unit id="555d8586503882b041c2a8a309c2f9e999580160" translate="yes" xml:space="preserve">
          <source>The four utility functions</source>
          <target state="translated">Четыре функции полезности</target>
        </trans-unit>
        <trans-unit id="6cfb5a37e3c4d212e2442aae712218c04b105dd5" translate="yes" xml:space="preserve">
          <source>The four-byte page number at offset 8 is the right-most pointer. This value appears in the header of interior b-tree pages only and is omitted from all other pages.</source>
          <target state="translated">Четырехбайтовый номер страницы со смещением 8 является самым правым указателем.Это значение отображается только в заголовке внутренних страниц b-дерева и опускается со всех остальных страниц.</target>
        </trans-unit>
        <trans-unit id="76f618a5029c6002ebdae975ee6043d888618d19" translate="yes" xml:space="preserve">
          <source>The fourth argument (xFilter) passed to these functions is the &quot;filter callback&quot;. If it is not NULL, then for each table affected by at least one change in the changeset, the filter callback is invoked with the table name as the second argument, and a copy of the context pointer passed as the sixth argument as the first. If the &quot;filter callback&quot; returns zero, then no attempt is made to apply any changes to the table. Otherwise, if the return value is non-zero or the xFilter argument to is NULL, all changes related to the table are attempted.</source>
          <target state="translated">Четвертый аргумент (xFilter),переданный этим функциям-&quot;обратный вызов фильтра&quot;.Если он не NULL,то для каждой таблицы,на которую повлияло хотя бы одно изменение в changeset,вызывается фильтр обратного вызова с именем таблицы в качестве второго аргумента,а в качестве первого аргумента передается копия указателя контекста,переданного в качестве шестого аргумента.Если &quot;filter callback&quot; возвращает ноль,то никаких попыток применить изменения к таблице не предпринимается.В противном случае,если возвращаемое значение ненулевое или аргумент xFilter равен NULL,все изменения,связанные с таблицей,пытаться не будут.</target>
        </trans-unit>
        <trans-unit id="999f04c49ef94f8766fa9cb6bb9bbba18afe2ece" translate="yes" xml:space="preserve">
          <source>The fourth argument, pArg, is an application data pointer that is passed through as the first argument to the collating function callback.</source>
          <target state="translated">Четвертый аргумент,pArg,является указателем на данные приложения,который передается в качестве первого аргумента на обратный вызов коллабораторной функции.</target>
        </trans-unit>
        <trans-unit id="c6b1934196a189db01281779b0c51a4b66faf522" translate="yes" xml:space="preserve">
          <source>The fourth column is the maximum value of any rowid in the table.</source>
          <target state="translated">Четвертый столбец-это максимальное значение любой строки таблицы.</target>
        </trans-unit>
        <trans-unit id="69cc3b7ae5b0c474135cb2e440fa03951919eaf0" translate="yes" xml:space="preserve">
          <source>The fourth parameter may also optionally include the &lt;a href=&quot;#SQLITE_DETERMINISTIC&quot;&gt;SQLITE_DIRECTONLY&lt;/a&gt; flag, which if present prevents the function from being invoked from within VIEWs or TRIGGERs. For security reasons, the &lt;a href=&quot;#SQLITE_DETERMINISTIC&quot;&gt;SQLITE_DIRECTONLY&lt;/a&gt; flag is recommended for any application-defined SQL function that has side-effects.</source>
          <target state="translated">Четвертый параметр может также дополнительно включать флаг &lt;a href=&quot;#SQLITE_DETERMINISTIC&quot;&gt;SQLITE_DIRECTONLY&lt;/a&gt; , который, если он присутствует, предотвращает вызов функции из VIEW или TRIGGER. По соображениям безопасности флаг &lt;a href=&quot;#SQLITE_DETERMINISTIC&quot;&gt;SQLITE_DIRECTONLY&lt;/a&gt; рекомендуется для любой определяемой приложением функции SQL, имеющей побочные эффекты.</target>
        </trans-unit>
        <trans-unit id="c1fbaaa3083276ec5194db2d1a793d5691751026" translate="yes" xml:space="preserve">
          <source>The fourth parameter may also optionally include the &lt;a href=&quot;#sqlitedirectonly&quot;&gt;SQLITE_DIRECTONLY&lt;/a&gt; flag, which if present prevents the function from being invoked from within VIEWs, TRIGGERs, CHECK constraints, generated column expressions, index expressions, or the WHERE clause of partial indexes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f52c4099bf56a2a098b10ec045515f7e30e89130" translate="yes" xml:space="preserve">
          <source>The fourth parameter may also optionally include the &lt;a href=&quot;c_deterministic&quot;&gt;SQLITE_DIRECTONLY&lt;/a&gt; flag, which if present prevents the function from being invoked from within VIEWs or TRIGGERs. For security reasons, the &lt;a href=&quot;c_deterministic&quot;&gt;SQLITE_DIRECTONLY&lt;/a&gt; flag is recommended for any application-defined SQL function that has side-effects.</source>
          <target state="translated">Четвертый параметр может также дополнительно включать флаг &lt;a href=&quot;c_deterministic&quot;&gt;SQLITE_DIRECTONLY&lt;/a&gt; , который, если он присутствует, предотвращает вызов функции из VIEW или TRIGGER. По соображениям безопасности флаг &lt;a href=&quot;c_deterministic&quot;&gt;SQLITE_DIRECTONLY&lt;/a&gt; рекомендуется для любой определяемой приложением функции SQL, имеющей побочные эффекты.</target>
        </trans-unit>
        <trans-unit id="67ad2195f1817b78a8b4837501855037b255117b" translate="yes" xml:space="preserve">
          <source>The fourth parameter may also optionally include the &lt;a href=&quot;c_deterministic#sqlitedirectonly&quot;&gt;SQLITE_DIRECTONLY&lt;/a&gt; flag, which if present prevents the function from being invoked from within VIEWs, TRIGGERs, CHECK constraints, generated column expressions, index expressions, or the WHERE clause of partial indexes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="649add83c8043b4bf2ea6e4b6cf49a7fdf941dff" translate="yes" xml:space="preserve">
          <source>The fourth parameter may optionally be ORed with &lt;a href=&quot;#SQLITE_DETERMINISTIC&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt; to signal that the function will always return the same result given the same inputs within a single SQL statement. Most SQL functions are deterministic. The built-in &lt;a href=&quot;lang_corefunc#random&quot;&gt;random()&lt;/a&gt; SQL function is an example of a function that is not deterministic. The SQLite query planner is able to perform additional optimizations on deterministic functions, so use of the &lt;a href=&quot;#SQLITE_DETERMINISTIC&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt; flag is recommended where possible.</source>
          <target state="translated">Четвертый параметр может при желании быть &lt;a href=&quot;#SQLITE_DETERMINISTIC&quot;&gt;объединен&lt;/a&gt; оператором ИЛИ с SQLITE_DETERMINISTIC, чтобы сигнализировать, что функция всегда будет возвращать один и тот же результат при одинаковых входных данных в одном операторе SQL. Большинство функций SQL детерминированы. Встроенная функция SQL &lt;a href=&quot;lang_corefunc#random&quot;&gt;random ()&lt;/a&gt; является примером недетерминированной функции. Планировщик запросов SQLite может выполнять дополнительную оптимизацию детерминированных функций, поэтому по &lt;a href=&quot;#SQLITE_DETERMINISTIC&quot;&gt;возможности&lt;/a&gt; рекомендуется использовать флаг SQLITE_DETERMINISTIC .</target>
        </trans-unit>
        <trans-unit id="6481c8ccbbe2254925779028e6672b2de9b23312" translate="yes" xml:space="preserve">
          <source>The fourth parameter may optionally be ORed with &lt;a href=&quot;#sqlitedeterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt; to signal that the function will always return the same result given the same inputs within a single SQL statement. Most SQL functions are deterministic. The built-in &lt;a href=&quot;lang_corefunc#random&quot;&gt;random()&lt;/a&gt; SQL function is an example of a function that is not deterministic. The SQLite query planner is able to perform additional optimizations on deterministic functions, so use of the &lt;a href=&quot;#sqlitedeterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt; flag is recommended where possible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="658cc43bdf2652e8cf4b2cffdcf6459b264f185d" translate="yes" xml:space="preserve">
          <source>The fourth parameter may optionally be ORed with &lt;a href=&quot;c_deterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt; to signal that the function will always return the same result given the same inputs within a single SQL statement. Most SQL functions are deterministic. The built-in &lt;a href=&quot;../lang_corefunc#random&quot;&gt;random()&lt;/a&gt; SQL function is an example of a function that is not deterministic. The SQLite query planner is able to perform additional optimizations on deterministic functions, so use of the &lt;a href=&quot;c_deterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt; flag is recommended where possible.</source>
          <target state="translated">Четвертый параметр может при желании быть &lt;a href=&quot;c_deterministic&quot;&gt;объединен&lt;/a&gt; оператором ИЛИ с SQLITE_DETERMINISTIC, чтобы сигнализировать, что функция всегда будет возвращать один и тот же результат при одинаковых входных данных в одном операторе SQL. Большинство функций SQL детерминированы. Встроенная функция SQL &lt;a href=&quot;../lang_corefunc#random&quot;&gt;random ()&lt;/a&gt; является примером недетерминированной функции. Планировщик запросов SQLite может выполнять дополнительную оптимизацию детерминированных функций, поэтому по &lt;a href=&quot;c_deterministic&quot;&gt;возможности&lt;/a&gt; рекомендуется использовать флаг SQLITE_DETERMINISTIC .</target>
        </trans-unit>
        <trans-unit id="7980c4f3a8ec7ae6d00b95c7cb68067b43db4da9" translate="yes" xml:space="preserve">
          <source>The fourth parameter may optionally be ORed with &lt;a href=&quot;c_deterministic#sqlitedeterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt; to signal that the function will always return the same result given the same inputs within a single SQL statement. Most SQL functions are deterministic. The built-in &lt;a href=&quot;../lang_corefunc#random&quot;&gt;random()&lt;/a&gt; SQL function is an example of a function that is not deterministic. The SQLite query planner is able to perform additional optimizations on deterministic functions, so use of the &lt;a href=&quot;c_deterministic#sqlitedeterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt; flag is recommended where possible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="feefd1b9ff1b8c4a1a74b3c8f0c879ca3de261f9" translate="yes" xml:space="preserve">
          <source>The fourth parameter to sqlite3_open_v2() is the name of the &lt;a href=&quot;#sqlite3_vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object that defines the operating system interface that the new database connection should use. If the fourth parameter is a NULL pointer then the default &lt;a href=&quot;#sqlite3_vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object is used.</source>
          <target state="translated">Четвертый параметр sqlite3_open_v2 () - это имя объекта &lt;a href=&quot;#sqlite3_vfs&quot;&gt;sqlite3_vfs,&lt;/a&gt; который определяет интерфейс операционной системы, который должно использовать новое соединение с базой данных. Если четвертым параметром является указатель NULL, тогда используется объект &lt;a href=&quot;#sqlite3_vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; по умолчанию .</target>
        </trans-unit>
        <trans-unit id="b7bbbda582299a1f3186b36dde756d304b0fa7e6" translate="yes" xml:space="preserve">
          <source>The fourth parameter to sqlite3_open_v2() is the name of the &lt;a href=&quot;vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object that defines the operating system interface that the new database connection should use. If the fourth parameter is a NULL pointer then the default &lt;a href=&quot;vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object is used.</source>
          <target state="translated">Четвертый параметр sqlite3_open_v2 () - это имя объекта &lt;a href=&quot;vfs&quot;&gt;sqlite3_vfs,&lt;/a&gt; который определяет интерфейс операционной системы, который должно использовать новое соединение с базой данных. Если четвертым параметром является указатель NULL, тогда используется объект &lt;a href=&quot;vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; по умолчанию .</target>
        </trans-unit>
        <trans-unit id="d063d165e08786a1b7ee913cfa396d1655f4a730" translate="yes" xml:space="preserve">
          <source>The fourth parameter, eTextRep, specifies what &lt;a href=&quot;#SQLITE_ANY&quot;&gt;text encoding&lt;/a&gt; this SQL function prefers for its parameters. The application should set this parameter to &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16LE&lt;/a&gt; if the function implementation invokes &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_text16le()&lt;/a&gt; on an input, or &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16BE&lt;/a&gt; if the implementation invokes &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_text16be()&lt;/a&gt; on an input, or &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16&lt;/a&gt; if &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_text16()&lt;/a&gt; is used, or &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF8&lt;/a&gt; otherwise. The same SQL function may be registered multiple times using different preferred text encodings, with different implementations for each encoding. When multiple implementations of the same function are available, SQLite will pick the one that involves the least amount of data conversion.</source>
          <target state="translated">Четвертый параметр, eTextRep, указывает, какую &lt;a href=&quot;#SQLITE_ANY&quot;&gt;кодировку текста&lt;/a&gt; эта функция SQL предпочитает для своих параметров. Приложение должно установить для этого параметра значение &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16LE,&lt;/a&gt; если реализация функции вызывает &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_text16le ()&lt;/a&gt; на входе, или &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16BE,&lt;/a&gt; если реализация вызывает &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_text16be ()&lt;/a&gt; на входе, или &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16,&lt;/a&gt; если используется &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_text16 ()&lt;/a&gt; , или &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_value_text16 &lt;/a&gt;() , или SQLITE_UTF16BEв противном случае. Одна и та же функция SQL может быть зарегистрирована несколько раз с использованием различных предпочтительных текстовых кодировок с разными реализациями для каждой кодировки. Когда доступно несколько реализаций одной и той же функции, SQLite выберет ту, которая включает наименьший объем преобразования данных.</target>
        </trans-unit>
        <trans-unit id="57c66b621bee32c598b5cb9d09e4c1e1ae3f09dc" translate="yes" xml:space="preserve">
          <source>The fourth parameter, eTextRep, specifies what &lt;a href=&quot;c_any&quot;&gt;text encoding&lt;/a&gt; this SQL function prefers for its parameters. The application should set this parameter to &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16LE&lt;/a&gt; if the function implementation invokes &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_text16le()&lt;/a&gt; on an input, or &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16BE&lt;/a&gt; if the implementation invokes &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_text16be()&lt;/a&gt; on an input, or &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16&lt;/a&gt; if &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_text16()&lt;/a&gt; is used, or &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF8&lt;/a&gt; otherwise. The same SQL function may be registered multiple times using different preferred text encodings, with different implementations for each encoding. When multiple implementations of the same function are available, SQLite will pick the one that involves the least amount of data conversion.</source>
          <target state="translated">Четвертый параметр, eTextRep, указывает, какую &lt;a href=&quot;c_any&quot;&gt;кодировку текста&lt;/a&gt; эта функция SQL предпочитает для своих параметров. Приложение должно установить для этого параметра значение &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16LE,&lt;/a&gt; если реализация функции вызывает &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_text16le ()&lt;/a&gt; на входе, или &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16BE,&lt;/a&gt; если реализация вызывает &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_text16be ()&lt;/a&gt; на входе, или &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16,&lt;/a&gt; если используется &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_text16 ()&lt;/a&gt; , или &lt;a href=&quot;c_any&quot;&gt;SQLITE_value_text16 &lt;/a&gt;() , или SQLITE_UTF16BEв противном случае. Одна и та же функция SQL может быть зарегистрирована несколько раз с использованием различных предпочтительных текстовых кодировок с разными реализациями для каждой кодировки. Когда доступно несколько реализаций одной и той же функции, SQLite выберет ту, которая включает наименьший объем преобразования данных.</target>
        </trans-unit>
        <trans-unit id="cdeeaf74a0034cfafd692646911468eeef688545" translate="yes" xml:space="preserve">
          <source>The fragment is optional. If present, it is ignored.</source>
          <target state="translated">Фрагмент необязателен.Если присутствует,то он игнорируется.</target>
        </trans-unit>
        <trans-unit id="36f14f55d888327ce43d396d69903a3ff7fd8e07" translate="yes" xml:space="preserve">
          <source>The frame boundary is the first row in the &lt;a href=&quot;windowfunctions#ptxn&quot;&gt;partition&lt;/a&gt;.</source>
          <target state="translated">Граница кадра - это первая строка в &lt;a href=&quot;windowfunctions#ptxn&quot;&gt;разделе&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3a03f5ecd3e39afb46315f6d23c888ecf09dac7b" translate="yes" xml:space="preserve">
          <source>The frame boundary is the last row in the &lt;a href=&quot;windowfunctions#ptxn&quot;&gt;partition&lt;/a&gt;.</source>
          <target state="translated">Граница рамки - это последняя строка в &lt;a href=&quot;windowfunctions#ptxn&quot;&gt;разделе&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d8ad39ba6054748efcf881cf5f3cfd24dafacebd" translate="yes" xml:space="preserve">
          <source>The frame-spec determines which output rows are read by an aggregate window function. The frame-spec consists of four parts:</source>
          <target state="translated">Рамка-spec определяет,какие выходные строки считываются функцией агрегированного окна.Рамка-spec состоит из четырех частей:</target>
        </trans-unit>
        <trans-unit id="8eb0b0542bfd6ed405e2b53c332150eda864217a" translate="yes" xml:space="preserve">
          <source>The freelist is organized as a linked list of freelist trunk pages with each trunk page containing page numbers for zero or more freelist leaf pages.</source>
          <target state="translated">Фрилист организован в виде связанного списка страниц во фрилисте,в котором каждая страница во фрилисте содержит номера страниц для нулевых и более страниц во фрилисте.</target>
        </trans-unit>
        <trans-unit id="4faa37aa2595b1d3bc75280cd8996cd072597ac3" translate="yes" xml:space="preserve">
          <source>The fts3tokenize virtual table can be used on any tokenizer, regardless of whether or not there exists an FTS3 or FTS4 table that actually uses that tokenizer.</source>
          <target state="translated">Виртуальная таблица fts3tokenize может использоваться на любом токенайзере,независимо от того,существует ли таблица FTS3 или FTS4,которая на самом деле использует этот токенайзер.</target>
        </trans-unit>
        <trans-unit id="346445abda1b7582bb76e9ab2cc48bb753bf4d95" translate="yes" xml:space="preserve">
          <source>The fts5 unicode61 tokenizer is byte-for-byte compatible with the fts3/4 unicode61 tokenizer.</source>
          <target state="translated">Токенайзер fts5 unicode61 совместим с токенайзером fts3/4 unicode61 байт за байт.</target>
        </trans-unit>
        <trans-unit id="78675caf2de7d160a88a0d764272d7a44454db10" translate="yes" xml:space="preserve">
          <source>The fts5_api structure is defined as follows. It exposes three methods, one each for registering new auxiliary functions and tokenizers, and one for retrieving existing tokenizer. The latter is intended to facilitate the implementation of &quot;tokenizer wrappers&quot; similar to the built-in porter tokenizer.</source>
          <target state="translated">Структура fts5_api определяется следующим образом.Она раскрывает три метода,по одному для регистрации новых вспомогательных функций и токенайзеров,и по одному для извлечения существующих токенайзеров.Последний предназначен для облегчения реализации &quot;оберток токенайзера&quot; по аналогии со встроенным токенайзером портатора.</target>
        </trans-unit>
        <trans-unit id="162ffee085d8569c08bb1ab9fff2a388996d64c4" translate="yes" xml:space="preserve">
          <source>The fts5_api structure methods are described individually in the following sections.</source>
          <target state="translated">Методы структуры fts5_api описываются индивидуально в следующих разделах.</target>
        </trans-unit>
        <trans-unit id="10c372ee6826e322ad4396357787688e82cce472" translate="yes" xml:space="preserve">
          <source>The fts5vocab virtual table module allows users to extract information from an FTS5 full-text index directly. The fts5vocab module is a part of FTS5 - it is available whenever FTS5 is.</source>
          <target state="translated">Модуль виртуальной таблицы fts5vocab позволяет пользователям извлекать информацию из полнотекстового индекса FTS5 напрямую.Модуль fts5vocab является частью FTS5-он доступен всегда,когда FTS5.</target>
        </trans-unit>
        <trans-unit id="7f3f12f1d0cab297fd4ff2f20d0ccb7ef0778aa5" translate="yes" xml:space="preserve">
          <source>The full pathname of the database file is now remembered even if a relative path is passed into sqlite_open(). This allows the library to continue operating correctly after a chdir().</source>
          <target state="translated">Полное имя файла базы данных теперь запоминается,даже если в sqlite_open()передан относительный путь.Это позволяет библиотеке продолжить корректную работу после chdir().</target>
        </trans-unit>
        <trans-unit id="3b9a46ef2b67e207b1134faeedabd205f3bd8481" translate="yes" xml:space="preserve">
          <source>The full syntax for specifying foreign key constraints is available as part of the &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; documentation. Replacing the phrase above with any of the following creates an immediate foreign key constraint.</source>
          <target state="translated">Полный синтаксис для указания ограничений внешнего ключа доступен как часть документации &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; . Замена приведенной выше фразы любым из следующего создает немедленное ограничение внешнего ключа.</target>
        </trans-unit>
        <trans-unit id="976d387f058fd1530001e6bc24b270372cb7f6ff" translate="yes" xml:space="preserve">
          <source>The full-text index maintained by FTS5 is stored as a series of fixed-size blobs in a database table. It is not strictly necessary for all blobs that make up a full-text index to be the same size. The pgsz option determines the size of all blobs created by subsequent index writers. The default value is 1000.</source>
          <target state="translated">Полнотекстовый индекс,поддерживаемый FTS5,хранится в виде серии блоков фиксированного размера в таблице базы данных.Строго говоря,не обязательно,чтобы все блоки,составляющие полнотекстовый индекс,имели одинаковый размер.Опция pgsz определяет размер всех блоков,создаваемых последующими составителями индекса.Значение по умолчанию равно 1000.</target>
        </trans-unit>
        <trans-unit id="7d7917f6db9701130aeed21c2478cad3cdfc0903" translate="yes" xml:space="preserve">
          <source>The function name is specified in UTF-8. A separate sqlite3_create_function16() API works the same as sqlite_create_function() except that the function name is specified in UTF-16 host byte order.</source>
          <target state="translated">Имя функции указано в UTF-8.Отдельный API sqlite3_create_function16()работает так же,как sqlite_create_function(),за исключением того,что имя функции указывается в порядке байт на хосте UTF-16.</target>
        </trans-unit>
        <trans-unit id="026205ed147556f48d88752d5a21eccbd2a64b48" translate="yes" xml:space="preserve">
          <source>The function pointer returned by this routine must be valid for the lifetime of the &lt;a href=&quot;c3ref/vtab&quot;&gt;sqlite3_vtab&lt;/a&gt; object given in the first parameter.</source>
          <target state="translated">Указатель на функцию, возвращаемый этой подпрограммой, должен быть действителен в течение всего времени существования объекта &lt;a href=&quot;c3ref/vtab&quot;&gt;sqlite3_vtab,&lt;/a&gt; указанного в первом параметре.</target>
        </trans-unit>
        <trans-unit id="d5578e17f6c531f672841ef155dfdacbfa341e5d" translate="yes" xml:space="preserve">
          <source>The function presented in the previous example copies the entire source database in one call to &lt;a href=&quot;c3ref/backup_finish#sqlite3backupstep&quot;&gt;sqlite3_backup_step()&lt;/a&gt;. This requires holding a read-lock on the source database file for the duration of the operation, preventing any other database user from writing to the database. It also holds the mutex associated with database pInMemory throughout the copy, preventing any other thread from using it. The C function in this section, designed to be called by a background thread or process for creating a backup of an online database, avoids these problems using the following approach:</source>
          <target state="translated">Функция, представленная в предыдущем примере, копирует всю исходную базу данных за один вызов &lt;a href=&quot;c3ref/backup_finish#sqlite3backupstep&quot;&gt;sqlite3_backup_step ()&lt;/a&gt; . Для этого требуется удерживать блокировку чтения исходного файла базы данных на время операции, чтобы любой другой пользователь базы данных не мог писать в базу данных. Он также содержит мьютекс, связанный с базой данных pInMemory по всей копии, предотвращая его использование другими потоками. Функция C в этом разделе, предназначенная для вызова фоновым потоком или процессом для создания резервной копии онлайн-базы данных, позволяет избежать этих проблем, используя следующий подход:</target>
        </trans-unit>
        <trans-unit id="0137a1cc90b7f7f164b60d3e6a0abb13294403cf" translate="yes" xml:space="preserve">
          <source>The functionality provided by the fts4aux module is now provided by &lt;a href=&quot;fts5#the_fts5vocab_virtual_table_module&quot;&gt;fts5vocab&lt;/a&gt;. The schema of these two tables is slightly different.</source>
          <target state="translated">Функциональность, предоставляемая модулем fts4aux, теперь предоставляется &lt;a href=&quot;fts5#the_fts5vocab_virtual_table_module&quot;&gt;fts5vocab&lt;/a&gt; . Схема этих двух таблиц немного отличается.</target>
        </trans-unit>
        <trans-unit id="82f4a608941f31ed6516bc837d2ee3e175fc4792" translate="yes" xml:space="preserve">
          <source>The functionality required of each of the above functions is described in comments in sqlite3async.c.</source>
          <target state="translated">Функциональность,необходимая для каждой из вышеперечисленных функций,описана в комментариях в sqlite3async.c.</target>
        </trans-unit>
        <trans-unit id="a3e3ee73e4504a9b18df3710202691563a7ae8e5" translate="yes" xml:space="preserve">
          <source>The general purpose memory allocator is the most difficult memory pool to manage because it supports allocations of varying sizes. Since &lt;b&gt;n&lt;/b&gt; is a multiplier on &lt;b&gt;M&lt;/b&gt; we want to keep &lt;b&gt;n&lt;/b&gt; as small as possible. This argues for keeping the minimum allocation size for &lt;a href=&quot;malloc#memsys5&quot;&gt;memsys5&lt;/a&gt; as large as possible. In most applications, the &lt;a href=&quot;malloc#lookaside&quot;&gt;lookaside memory allocator&lt;/a&gt; is able to handle small allocations. So it is reasonable to set the minimum allocation size for &lt;a href=&quot;malloc#memsys5&quot;&gt;memsys5&lt;/a&gt; to 2, 4 or even 8 times the maximum size of a lookaside allocation. A minimum allocation size of 512 is a reasonable setting.</source>
          <target state="translated">Распределитель памяти общего назначения - это наиболее сложный пул памяти для управления, поскольку он поддерживает выделения различного размера. Поскольку &lt;b&gt;n&lt;/b&gt; является множителем на &lt;b&gt;M,&lt;/b&gt; мы хотим, чтобы &lt;b&gt;n было&lt;/b&gt; как можно меньше. Это аргумент в пользу сохранения минимального размера выделения для &lt;a href=&quot;malloc#memsys5&quot;&gt;memsys5&lt;/a&gt; как можно большего размера. В большинстве приложений &lt;a href=&quot;malloc#lookaside&quot;&gt;внешний распределитель памяти&lt;/a&gt; может обрабатывать небольшие выделения. Поэтому разумно установить минимальный размер выделения для &lt;a href=&quot;malloc#memsys5&quot;&gt;memsys5&lt;/a&gt; в 2, 4 или даже 8 раз больше максимального размера внешнего выделения. Минимальный размер выделения 512 является разумной настройкой.</target>
        </trans-unit>
        <trans-unit id="30bdbd95e17bffd329d217ead465e3fe28cd023c" translate="yes" xml:space="preserve">
          <source>The general rule is that indexes are only useful if there are WHERE-clause constraints on the left-most columns of the index. However, in some cases, SQLite is able to use an index even if the first few columns of the index are omitted from the WHERE clause but later columns are included.</source>
          <target state="translated">Общее правило заключается в том,что индексы полезны только в том случае,если на крайних левых столбцах индекса имеются ограничения WHERE-clause.Однако в некоторых случаях SQLite может использовать индекс,даже если первые несколько столбцов индекса опущены из пункта WHERE,но включены более поздние столбцы.</target>
        </trans-unit>
        <trans-unit id="084577b6dd782fa1eb4651ff451c238f84ef2391" translate="yes" xml:space="preserve">
          <source>The general-purpose memory allocator (&lt;a href=&quot;malloc#memsys5&quot;&gt;memsys5&lt;/a&gt;).</source>
          <target state="translated">Распределитель памяти общего назначения ( &lt;a href=&quot;malloc#memsys5&quot;&gt;memsys5&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="21a012c95267cb8d2b8d45dbbd928793f6616b70" translate="yes" xml:space="preserve">
          <source>The generate_series Table-Valued Function</source>
          <target state="translated">Функция генерации_серии Таблица-оценка</target>
        </trans-unit>
        <trans-unit id="476dfd7c8482f7d1208e7bd9537292c089264e39" translate="yes" xml:space="preserve">
          <source>The generate_series table can be simulated using a &lt;a href=&quot;lang_with#recursivecte&quot;&gt;recursive common table expression&lt;/a&gt;. If the three parameters are $start, $end, and $step, then the equivalent common table expression is:</source>
          <target state="translated">Таблицу generate_series можно смоделировать с помощью &lt;a href=&quot;lang_with#recursivecte&quot;&gt;рекурсивного общего табличного выражения&lt;/a&gt; . Если тремя параметрами являются $ start, $ end и $ step, то эквивалентное общее табличное выражение будет следующим:</target>
        </trans-unit>
        <trans-unit id="4e3c394ee97ca6ac89b21ae3983e2fd5668b4aa8" translate="yes" xml:space="preserve">
          <source>The generate_series(START,END,STEP) &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued function&lt;/a&gt; is a &lt;a href=&quot;loadext&quot;&gt;loadable extension&lt;/a&gt; included in the SQLite source tree, and compiled into the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt;. The generate_series() table has a single result column named &quot;value&quot; holding integer values and a number of rows determined by the parameters START, END, and STEP. The first row of the table has a value of START. Subsequent rows increase by STEP up to END.</source>
          <target state="translated">Возвращающая &lt;a href=&quot;vtab#tabfunc2&quot;&gt;табличное значение функция&lt;/a&gt; generate_series (START, END, STEP) - это &lt;a href=&quot;loadext&quot;&gt;загружаемое расширение,&lt;/a&gt; включенное в исходное дерево SQLite и скомпилированное в &lt;a href=&quot;cli&quot;&gt;оболочку командной строки&lt;/a&gt; . Таблица generate_series () имеет единственный столбец результата с именем &amp;laquo;значение&amp;raquo;, содержащий целочисленные значения, и количество строк, определяемых параметрами START, END и STEP. Первая строка таблицы имеет значение START. Последующие строки увеличиваются на STEP до END.</target>
        </trans-unit>
        <trans-unit id="3f2ed0d414c19e451dbd160a6e3115271ef19a02" translate="yes" xml:space="preserve">
          <source>The geopoly module defines several new SQL functions that are useful for dealing with polygons. All polygon arguments to these functions can be either the GeoJSON format or the internal binary format.</source>
          <target state="translated">В геополитическом модуле определено несколько новых SQL-функций,полезных для работы с полигонами.Все аргументы полигонов к этим функциям могут быть как в формате GeoJSON,так и во внутреннем бинарном формате.</target>
        </trans-unit>
        <trans-unit id="8d993a3d44bf40860242bebc1265b2783cf9c63f" translate="yes" xml:space="preserve">
          <source>The geopoly module is an extension to the &lt;a href=&quot;rtree&quot;&gt;R-Tree extension&lt;/a&gt;. Geopoly uses the same underlying logic and shadow tables as the &lt;a href=&quot;rtree&quot;&gt;R-Tree extension&lt;/a&gt;. Geopoly merely presents a different interface, and provides some extra logic to compute polygon decoding, overlap, and containment.</source>
          <target state="translated">Модуль геополии является расширением расширения &lt;a href=&quot;rtree&quot;&gt;R-Tree&lt;/a&gt; . Geopoly использует ту же базовую логику и теневые таблицы, что и &lt;a href=&quot;rtree&quot;&gt;расширение R-Tree&lt;/a&gt; . Geopoly просто представляет собой другой интерфейс и предоставляет некоторую дополнительную логику для вычисления декодирования полигонов, перекрытия и локализации.</target>
        </trans-unit>
        <trans-unit id="acb138b945d23f00cd83af917d94b141700de307" translate="yes" xml:space="preserve">
          <source>The geopoly module is built on top of the &lt;a href=&quot;rtree&quot;&gt;R-Tree extension&lt;/a&gt; and uses the same underlying shadow tables and algorithms. For indexing purposes, each polygon is represented in the shadow tables as a rectangular bounding box. The underlying R-Tree implementation uses bounding boxes to limit the search space. Then the geoploy_overlap() and/or geopoly_within() routines further refine the search to the exact answer.</source>
          <target state="translated">Модуль геополии построен на основе &lt;a href=&quot;rtree&quot;&gt;расширения R-Tree&lt;/a&gt; и использует те же базовые теневые таблицы и алгоритмы. В целях индексации каждый многоугольник представлен в теневых таблицах как прямоугольная ограничивающая рамка. Базовая реализация R-Tree использует ограничивающие прямоугольники для ограничения пространства поиска. Затем процедуры geoploy_overlap () и / или geopoly_within () дополнительно уточняют поиск до точного ответа.</target>
        </trans-unit>
        <trans-unit id="fdb9ae6360ea866b8222993691854e31ea695989" translate="yes" xml:space="preserve">
          <source>The geopoly_ccw(J) function returns the polygon J with counter-clockwise (CCW) rotation.</source>
          <target state="translated">Функция geopoly_ccw(J)возвращает полигон J с вращением против часовой стрелки (CCW).</target>
        </trans-unit>
        <trans-unit id="58be5b36690d1c8a61ca619684c9087df6d3c79c" translate="yes" xml:space="preserve">
          <source>The geopoly_group_bbox(P) function is an aggregate version of geopoly_bbox(P). The geopoly_group_bbox(P) function returns the smallest rectangle that will enclose all P values seen during aggregation.</source>
          <target state="translated">Функция geopoly_group_bbox(P)является агрегированной версией geopoly_bbox(P).Функция geopoly_group_bbox(P)возвращает наименьший прямоугольник,который будет заключать в себе все значения P,видимые во время агрегации.</target>
        </trans-unit>
        <trans-unit id="7aa31a665e34b0f93544b760a7bd5d5549c54d97" translate="yes" xml:space="preserve">
          <source>The geopoly_overlap(P1,P2) function is special in that the geopoly virtual table knows how to use R*Tree indexes to optimize queries in which the WHERE clause uses geopoly_overlap() as a boolean function. Only the geopoly_overlap(P1,P2) and geopoly_within(P1,P2) functions have this capability.</source>
          <target state="translated">Функция geopoly_overlap(P1,P2)особенная в том,что виртуальная геополитическая таблица знает,как использовать индексы R*Tree для оптимизации запросов,в которых выражение WHERE использует функцию geopoly_overlap()в качестве булевой функции.Только функции geopoly_overlap(P1,P2)и geopoly_within(P1,P2)имеют такую возможность.</target>
        </trans-unit>
        <trans-unit id="4552cf5a5f2e459423714152983f2ca48f86f169" translate="yes" xml:space="preserve">
          <source>The geopoly_regular(X,Y,R,N) function returns a convex, simple, regular, equilateral, equiangular polygon with N sides, centered at X,Y, and with a circumradius of R. Or, if R is negative or if N is less than 3, the function returns NULL. The N value is capped at 1000 so that the routine will never render a polygon with more than 1000 sides even if the N value is larger than 1000.</source>
          <target state="translated">Функция geopoly_regular(X,Y,R,N)возвращает выпуклый,простой,правильный,равносторонний,равносторонний,равносторонний многоугольник с N гранями,центрированный по X,Y,и с окружностью R.Или,если R отрицательный или если N меньше 3,функция возвращает NULL.Значение N ограничено 1000,так что рутина никогда не отобразит многоугольник с более чем 1000 гранями,даже если значение N больше 1000.</target>
        </trans-unit>
        <trans-unit id="01eba492c4ddd36076bba0e9fe7c2f9d9c526116" translate="yes" xml:space="preserve">
          <source>The geopoly_within(P1,P2) function is special in that the geopoly virtual table knows how to use R*Tree indexes to optimize queries in which the WHERE clause uses geopoly_within() as a boolean function. Only the geopoly_within(P1,P2) and geopoly_overlap(P1,P2) functions have this capability.</source>
          <target state="translated">Функция geopoly_within(P1,P2)особенная в том,что виртуальная геополитическая таблица знает,как использовать индексы R*Tree для оптимизации запросов,в которых в пункте WHERE в качестве булевой функции используется geopoly_within().Только функции geopoly_within(P1,P2)и geopoly_overlap(P1,P2)имеют такую возможность.</target>
        </trans-unit>
        <trans-unit id="45313c37ef01af04ca79cf8e508d2efcd3ced709" translate="yes" xml:space="preserve">
          <source>The geopoly_xform(P,A,B,C,D,E,F) function returns a new polygon that is an affine transformation of the polygon P and where the transformation is defined by values A,B,C,D,E,F. If P is not a valid polygon, this routine returns NULL.</source>
          <target state="translated">Функция geopoly_xform(P,A,B,C,D,E,F)возвращает новый многоугольник,который является аффинным преобразованием многоугольника P и где это преобразование определяется значениями A,B,C,D,E,F.Если P не является действительным многоугольником,то эта рутина возвращает NULL.</target>
        </trans-unit>
        <trans-unit id="8a7538a75bac0dc91c968f2f943ef8c77b915108" translate="yes" xml:space="preserve">
          <source>The glob(X,Y) function is equivalent to the expression &quot;&lt;b&gt;Y GLOB X&lt;/b&gt;&quot;. Note that the X and Y arguments are reversed in the glob() function relative to the infix &lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; operator. Y is the string and X is the pattern. So, for example, the following expressions are equivalent:</source>
          <target state="translated">Функция glob (X, Y) эквивалентна выражению &amp;laquo; &lt;b&gt;Y GLOB X&lt;/b&gt; &amp;raquo;. Обратите внимание, что аргументы X и Y меняются местами в функции glob () относительно инфиксного оператора &lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; . Y - строка, а X - образец. Так, например, следующие выражения эквивалентны:</target>
        </trans-unit>
        <trans-unit id="57af892941202e82d82f19e609a84ccb0531eaad" translate="yes" xml:space="preserve">
          <source>The goal is to make SQLite handle NULLs in a standards-compliant way. But the descriptions in the SQL standards on how to handle NULLs seem ambiguous. It is not clear from the standards documents exactly how NULLs should be handled in all circumstances.</source>
          <target state="translated">Цель заключается в том,чтобы сделать так,чтобы SQLite работал с NULL в соответствии со стандартами.Но описания в стандартах SQL о том,как работать с NULL,кажутся двусмысленными.Из документов стандартов не ясно,как именно NULL следует обрабатывать при любых обстоятельствах.</target>
        </trans-unit>
        <trans-unit id="2ba0147df5ada0e089bdabaebc1a5094f5e9a20f" translate="yes" xml:space="preserve">
          <source>The goal of this query is to compute some value for the five most recent entries in the table. But in the query above, the &quot;expensive_function()&quot; is invoked prior to the sort and thus is invoked on every row of the table, even rows that are ultimately omitted due to the LIMIT clause. A co-routine can be used to work around this:</source>
          <target state="translated">Целью данного запроса является вычисление некоторого значения для пяти последних записей в таблице.Однако в вышеприведенном запросе перед сортировкой вызывается &quot;expensive_function()&quot; и,таким образом,вызывается в каждой строке таблицы,даже в тех строках,которые в конечном итоге опускаются из-за выражения LIMIT.Для работы с этим можно использовать ко-маршрут:</target>
        </trans-unit>
        <trans-unit id="6cb2a89894c9f8119dfc52f2d254fce8328dc0f1" translate="yes" xml:space="preserve">
          <source>The goal of this query is to compute some value for the five most recent entries in the table. In the query above, the &quot;expensive_function()&quot; is invoked prior to the sort and thus is invoked on every row of the table, even rows that are ultimately omitted due to the LIMIT clause. A co-routine can be used to work around this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27130ed911ba5b72cf5d70b6f38c66e3447f97b9" translate="yes" xml:space="preserve">
          <source>The grammar syntax is less error prone - using symbolic names for semantic values rather that the &quot;$1&quot;-style positional notation of Yacc.</source>
          <target state="translated">Синтаксис грамматики менее склонен к ошибкам-использование символических имён для семантических значений,чем позиционная нотация Yacc в стиле &quot;$1&quot;.</target>
        </trans-unit>
        <trans-unit id="8288ae8eb06e54b34a1335f8c6fbfb99327b7542" translate="yes" xml:space="preserve">
          <source>The graph below shows the number of CPU cycles used by SQLite on a standard workload, for versions of SQLite going back about 10 years. Recent versions of SQLite use about one third as many the CPU cycles compared to older versions.</source>
          <target state="translated">На графике ниже показано количество процессорных циклов,используемых SQLite на стандартной рабочей нагрузке,для версий SQLite около 10 лет назад.Последние версии SQLite используют примерно на треть больше циклов процессора по сравнению со старыми версиями.</target>
        </trans-unit>
        <trans-unit id="ea3dfc83e3fad7e5da84aa92171fa1f2ebb6adae" translate="yes" xml:space="preserve">
          <source>The group_concat() function returns a string which is the concatenation of all non-NULL values of</source>
          <target state="translated">Функция group_concat()возвращает строку,которая является конкатенцией всех не нулевых значений параметра</target>
        </trans-unit>
        <trans-unit id="998c879f2d9a4a324ed589705e44b7743eed8ace" translate="yes" xml:space="preserve">
          <source>The group_concat(x,'') SQL function returns NULL instead of an empty string when all inputs are empty strings. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/55746f9e65f85&quot;&gt;55746f9e65&lt;/a&gt;</source>
          <target state="translated">SQL-функция group_concat (x, '') возвращает NULL вместо пустой строки, когда все входные данные являются пустыми строками. Билет &lt;a href=&quot;http://www.sqlite.org/src/info/55746f9e65f85&quot;&gt;55746f9e65&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="784b868822e251a84f7723c4b68b20334805a9ba" translate="yes" xml:space="preserve">
          <source>The group_concat(x,'') SQL function returns NULL instead of an empty string when all inputs are empty strings. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/55746f9e65f85&quot;&gt;55746f9e65&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cc69e429ade6ced467dc065c3703a231254bc0f" translate="yes" xml:space="preserve">
          <source>The handling of IN and NOT IN operators that contain a NULL on their right-hand side expression is brought into compliance with the SQL standard and with other SQL database engines. This is a bug fix, but as it has the potential to break legacy applications that depend on the older buggy behavior, we mark that as a *** Potentially incompatible change ***</source>
          <target state="translated">Обработка операторов IN и NOT IN,содержащих NULL в их правом выражении,приведена в соответствие со стандартом SQL и другими движками баз данных SQL.Это исправление ошибки,но так как оно может нарушить работу старых приложений,зависящих от старого поведения,мы отмечаем,что в качестве ***Потенциально несовместимого изменения ***</target>
        </trans-unit>
        <trans-unit id="d0efc6030fa81d141b43a701523b55c7bcf660fd" translate="yes" xml:space="preserve">
          <source>The hash tables in the shm file are designed to answer the following question quickly:</source>
          <target state="translated">Хэш-таблицы в файле shm предназначены для быстрого ответа на следующий вопрос:</target>
        </trans-unit>
        <trans-unit id="2856b370cad55dc7412b44b6f210c8cf053331d6" translate="yes" xml:space="preserve">
          <source>The hashes that identify check-ins and files on the Git mirror are different from the hashes in Fossil. There are many reasons for this, chief among them that Fossil uses a SHA3-256 hash whereas Git uses a SHA1 hash. During export, the original Fossil hash for each check-in is added as a footer to check-in comments. To avoid confusion, always use the original Fossil hash, not the Git hash, when referring to SQLite check-ins.</source>
          <target state="translated">Хэши,которые идентифицируют контрольные входы и файлы на Git-зеркале,отличаются от хэшей на Fossil.Этому есть много причин,главная из которых заключается в том,что Fossil использует хэш из SHA3-256,в то время как Git использует хэш из SHA1.При экспорте,оригинальный ископаемый хэш для каждой регистрации добавляется как нижний колонтитул для комментариев при регистрации.Чтобы избежать путаницы,всегда используйте исходный ископаемый хэш,а не Git-хэш,когда обращаетесь к регистрации на SQLite.</target>
        </trans-unit>
        <trans-unit id="e115da518074674c7bed9606a1f3c39c1334b0dc" translate="yes" xml:space="preserve">
          <source>The header of the rollback journal can be overwritten with invalid header text (for example, all zeros).</source>
          <target state="translated">Заголовок журнала отката может быть перезаписан недействительным заголовочным текстом (например,все нули).</target>
        </trans-unit>
        <trans-unit id="328251bbc9b91a18ef755ecd2993b4b5eb3cf221" translate="yes" xml:space="preserve">
          <source>The header of the rollback journal is well-formed and in particular has not been zeroed out.</source>
          <target state="translated">Заголовок журнала отката хорошо сформирован и,в частности,не обнулен.</target>
        </trans-unit>
        <trans-unit id="8908758df6621b583f7634e3a00bc808f16a9ffb" translate="yes" xml:space="preserve">
          <source>The header size varint and serial type varints will usually consist of a single byte. The serial type varints for large strings and BLOBs might extend to two or three byte varints, but that is the exception rather than the rule. The varint format is very efficient at coding the record header.</source>
          <target state="translated">Размеры заголовков вариаций и вариаций последовательного типа обычно состоят из одного байта.Для больших строк и BLOB-ов,varint последовательного типа может расширяться до двух или трех байтовых varint,но это скорее исключение,чем правило.Формат varint очень эффективен при кодировании заголовка записи.</target>
        </trans-unit>
        <trans-unit id="6a561080aa600994c95f7609f8c9a76e07664cc1" translate="yes" xml:space="preserve">
          <source>The header string: &quot;SQLite format 3\000&quot;</source>
          <target state="translated">Строка заголовка:&quot;Формат SQLite 3\000&quot;</target>
        </trans-unit>
        <trans-unit id="9618d06778e016225462d5681eb6b291f7c80aa5" translate="yes" xml:space="preserve">
          <source>The heap limits are not enforced in the current implementation if one or more of following conditions are true:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95f9212fdc8a88cf98b4e1490976ec2f7354c6a2" translate="yes" xml:space="preserve">
          <source>The heavy wrapper employed by &lt;a href=&quot;compile#memdebug&quot;&gt;SQLITE_MEMDEBUG&lt;/a&gt; is intended for use only during testing, analysis, and debugging of SQLite. The heavy wrapper has a significant performance and memory overhead and probably should not be used in production.</source>
          <target state="translated">Тяжелая оболочка, используемая &lt;a href=&quot;compile#memdebug&quot;&gt;SQLITE_MEMDEBUG&lt;/a&gt; , предназначена для использования только во время тестирования, анализа и отладки SQLite. Тяжелая оболочка имеет значительные накладные расходы на производительность и память и, вероятно, не должна использоваться в производственной среде.</target>
        </trans-unit>
        <trans-unit id="eb4610f1226d8f274f85d7debe217f5d65427f90" translate="yes" xml:space="preserve">
          <source>The heavy wrapper that is used when &lt;a href=&quot;compile#memdebug&quot;&gt;SQLITE_MEMDEBUG&lt;/a&gt; is set also makes sure each new allocation is filled with nonsense data prior to returning the allocation to the caller. And as soon as an allocation is free, it is again filled with nonsense data. These two actions help to ensure that the SQLite core does not make assumptions about the state of newly allocated memory and that memory allocations are not used after they have been freed.</source>
          <target state="translated">Тяжелая оболочка, которая используется при установке &lt;a href=&quot;compile#memdebug&quot;&gt;SQLITE_MEMDEBUG,&lt;/a&gt; также обеспечивает заполнение каждого нового выделения бессмысленными данными перед возвратом выделения вызывающей стороне. И как только выделение освобождается, оно снова заполняется бессмысленными данными. Эти два действия помогают гарантировать, что ядро ​​SQLite не делает предположений о состоянии вновь выделенной памяти и что выделения памяти не используются после того, как они были освобождены.</target>
        </trans-unit>
        <trans-unit id="a33b86543e89aa7fc91f1c01c079a10eabc5b26c" translate="yes" xml:space="preserve">
          <source>The hex() function interprets its argument as a BLOB and returns a string which is the upper-case hexadecimal rendering of the content of that blob.</source>
          <target state="translated">Функция hex()интерпретирует свой аргумент как BLOB и возвращает строку,которая является шестнадцатиричным отображением содержимого этого блока в верхнем регистре.</target>
        </trans-unit>
        <trans-unit id="47e9ec1a2ca9f6468b5d5ea9dca27a7ef3e3db0a" translate="yes" xml:space="preserve">
          <source>The high repeatability of cachegrind allows the SQLite developers to implement and measure &quot;microoptimizations&quot;. A microoptimization is a change to the code that results in a very small performance increase. Typical micro-optimizations reduce the number of CPU cycles by 0.1% or 0.05% or even less. Such improvements are impossible to measure with real-world timings. But hundreds or thousands of microoptimizations add up, resulting in measurable real-world performance gains.</source>
          <target state="translated">Высокая воспроизводимость кэшфренда позволяет разработчикам SQLite реализовывать и измерять &quot;микрооптимизации&quot;.Микрооптимизация-это изменение кода,в результате которого производительность увеличивается очень незначительно.Типичные микро-оптимизации сокращают количество циклов процессора на 0.1% или 0.05% или даже меньше.Такие улучшения невозможно измерить с помощью реальных таймингов.Но сотни или тысячи микро-оптимизаций суммируются,что приводит к измеримому повышению производительности в реальном мире.</target>
        </trans-unit>
        <trans-unit id="8ccb63c8eb8186df2591985e1dd0399f9de8ed53" translate="yes" xml:space="preserve">
          <source>The high-reliability of SQLite is proven in practice. SQLite has been used without problems in multiple billions of smart-phones, IoT devices, and desktop applications, around the world, and for almost two decades.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8285d1c1b74bc88c5caec05770baddba5bd483b5" translate="yes" xml:space="preserve">
          <source>The high-reliability of SQLite is proven in practice. SQLite has been used without problems in multiple billions of smart-phones, IoT devices, and desktop applications, around the world, and for over a decade.</source>
          <target state="translated">Высокая надежность SQLite доказана на практике.SQLite без проблем используется во множестве миллиардов смартфонов,IoT-устройств и настольных приложений по всему миру уже более десяти лет.</target>
        </trans-unit>
        <trans-unit id="f6fadaee687e9cfda1c93f7fa51b5ba3b3240bd6" translate="yes" xml:space="preserve">
          <source>The highlight() function returns a copy of the text from a specified column of the current row with extra markup text inserted to mark the start and end of phrase matches.</source>
          <target state="translated">Функция highlight()возвращает копию текста из указанного столбца текущей строки с дополнительной разметкой,вставленной для пометки начала и конца совпадения фраз.</target>
        </trans-unit>
        <trans-unit id="e43753ce0913d39afca1c9c249ea51ebaf6b6f06" translate="yes" xml:space="preserve">
          <source>The highlight() must be invoked with exactly three arguments following the table name. To be interpreted as follows:</source>
          <target state="translated">Функция highlight()должна вызываться ровно с тремя аргументами,следующими за именем таблицы.Следует интерпретировать следующим образом:</target>
        </trans-unit>
        <trans-unit id="bb9d506afb5b0054b66298f3975841775d6d258d" translate="yes" xml:space="preserve">
          <source>The histogram data is only useful if the right-hand side of the constraint is a simple compile-time constant or &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameter&lt;/a&gt; and not an expression.</source>
          <target state="translated">Данные гистограммы полезны только в том случае, если правая часть ограничения представляет собой простую константу или &lt;a href=&quot;lang_expr#varparam&quot;&gt;параметр&lt;/a&gt; времени компиляции, а не выражение.</target>
        </trans-unit>
        <trans-unit id="754b3dec45709dc037212c7449e27878498a6122" translate="yes" xml:space="preserve">
          <source>The historical behavior of SQLite is incorrect according to the SQL:1999 standard and it is inconsistent with the behavior of MySQL and PostgreSQL. Version 3.6.0 changes the behavior of the IN and NOT IN operators to conform to the standard and to give the same results as other SQL database engines.</source>
          <target state="translated">Историческое поведение SQLite некорректно согласно стандарту SQL:1999 и несовместимо с поведением MySQL и PostgreSQL.Версия 3.6.0 изменяет поведение операторов IN и NOT IN,чтобы соответствовать стандарту и давать те же результаты,что и другие движки баз данных SQL.</target>
        </trans-unit>
        <trans-unit id="3be31364c3c06e62038927597ca88135a8ca4d7a" translate="yes" xml:space="preserve">
          <source>The iCost column is the numeric cost of transforming cFrom into cTo. This value should be a non-negative integer, and should probably be less than 100. The default single-character insertion and deletion costs are 100 and the default single-character to single-character substitution cost is 150. A cost of 10000 or more is considered &quot;infinite&quot; and causes the rule to be ignored.</source>
          <target state="translated">Столбец iCost-это числовая стоимость преобразования cFrom в cTo.Это значение должно быть неотрицательным целым числом и,вероятно,должно быть меньше 100.Стоимость вставки и удаления односимволов по умолчанию составляет 100,а стоимость подстановки односимволов к односимвольным-150.Стоимость 10000 и более считается &quot;бесконечной&quot; и заставляет игнорировать правило.</target>
        </trans-unit>
        <trans-unit id="d0b9d0aa5d29da45f0b93b40de44e2f95388c2e0" translate="yes" xml:space="preserve">
          <source>The iLang column is a non-negative integer that identifies a set of costs appropriate for a particular language. The editdist3 function will only use a single iLang value for any given edit-distance computation. The default value is 0. It is recommended that applications that only need to use a single language always use iLang==0 for all entries.</source>
          <target state="translated">Столбец iLang является неотрицательным целым числом,которое идентифицирует набор затрат,подходящих для определенного языка.Функция editdist3 будет использовать только одно значение iLang для любого заданного вычисления расстояния редактирования.Значение по умолчанию равно 0.Рекомендуется,чтобы приложения,которым необходимо использовать только один язык,всегда использовали iLang==0 для всех записей.</target>
        </trans-unit>
        <trans-unit id="5013f8a1a10fac4a872743ceb29c353308c4297d" translate="yes" xml:space="preserve">
          <source>The iVersion field of &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; is provided as insurance against future enhancements. The iVersion value should always be 1 for SQLite version 3.5.</source>
          <target state="translated">Поле iVersion &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; предоставляется в качестве страховки от будущих улучшений. Значение iVersion всегда должно быть 1 для SQLite версии 3.5.</target>
        </trans-unit>
        <trans-unit id="8b61610ddf9130372f875adae334c360bf359102" translate="yes" xml:space="preserve">
          <source>The iVersion field of &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; should be 1 for SQLite version 3.5.0. This number may increase in future versions of SQLite if we have to modify the VFS object in some way. We hope that this never happens, but the provision is made in case it does.</source>
          <target state="translated">Поле iVersion &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; должно быть 1 для SQLite версии 3.5.0. Это число может увеличиться в будущих версиях SQLite, если нам придется каким-либо образом изменить объект VFS. Мы надеемся, что этого никогда не произойдет, но предусмотрены меры на случай, если это произойдет.</target>
        </trans-unit>
        <trans-unit id="ea830f2d673441ec5d80e9c5eb8623ea5999e87b" translate="yes" xml:space="preserve">
          <source>The idea behind a reserved lock is that it signals that a process intends to modify the database file in the near future but has not yet started to make the modifications. And because the modifications have not yet started, other processes can continue to read from the database. However, no other process should also begin trying to write to the database.</source>
          <target state="translated">Идея зарезервированного замка заключается в том,что он сигнализирует о том,что процесс намеревается изменить файл базы данных в ближайшем будущем,но еще не начал вносить изменения.А поскольку модификации еще не начались,другие процессы могут продолжать читать из БД.Однако ни один другой процесс также не должен начинать попытки записи в БД.</target>
        </trans-unit>
        <trans-unit id="b86c36b3766e07cfb666e3625925c99f4017f8b5" translate="yes" xml:space="preserve">
          <source>The idxNum and idxPtr values are recorded and passed into the &lt;a href=&quot;../vtab#xfilter&quot;&gt;xFilter&lt;/a&gt; method. &lt;a href=&quot;free&quot;&gt;sqlite3_free()&lt;/a&gt; is used to free idxPtr if and only if needToFreeIdxPtr is true.</source>
          <target state="translated">Значения idxNum и idxPtr записываются и передаются в метод &lt;a href=&quot;../vtab#xfilter&quot;&gt;xFilter&lt;/a&gt; . &lt;a href=&quot;free&quot;&gt;sqlite3_free ()&lt;/a&gt; используется для освобождения idxPtr тогда и только тогда, когда needToFreeIdxPtr истинно.</target>
        </trans-unit>
        <trans-unit id="357574f6e5fd171b87a29904a513e7015690c872" translate="yes" xml:space="preserve">
          <source>The idxNum and idxPtr values are recorded and passed into the &lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter&lt;/a&gt; method. &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free()&lt;/a&gt; is used to free idxPtr if and only if needToFreeIdxPtr is true.</source>
          <target state="translated">Значения idxNum и idxPtr записываются и передаются в метод &lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter&lt;/a&gt; . &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free ()&lt;/a&gt; используется для освобождения idxPtr тогда и только тогда, когда needToFreeIdxPtr истинно.</target>
        </trans-unit>
        <trans-unit id="013b479832be35dd0d8a4395d938100b93b10f74" translate="yes" xml:space="preserve">
          <source>The idxStr value may be a string obtained from an SQLite memory allocation function such as &lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_mprintf()&lt;/a&gt;. If this is the case, then the needToFreeIdxStr flag must be set to true so that the SQLite core will know to call &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_free()&lt;/a&gt; on that string when it has finished with it, and thus avoid a memory leak. The idxStr value may also be a static constant string, in which case the needToFreeIdxStr boolean should remain false.</source>
          <target state="translated">Значение idxStr может быть строкой, полученной из функции выделения памяти SQLite, такой как &lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_mprintf ()&lt;/a&gt; . В этом случае флаг needToFreeIdxStr должен быть установлен в значение true, чтобы ядро ​​SQLite знало, что нужно вызвать &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_free ()&lt;/a&gt; для этой строки, когда оно закончит с ней, и таким образом избежать утечки памяти. Значение idxStr также может быть статической постоянной строкой, и в этом случае логическое значение needToFreeIdxStr должно оставаться ложным.</target>
        </trans-unit>
        <trans-unit id="53bc345818e3cfbbe8c82ba1be412d51eef79f34" translate="yes" xml:space="preserve">
          <source>The ieee754 extension converts a floating point number between its binary64 representation and the M&amp;times;2&lt;sup&gt;&lt;small&gt;E&lt;/small&gt;&lt;/sup&gt; format. In other words in the expression:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2f1322e38e7bf458c5d54d75c7506d3ae73217c" translate="yes" xml:space="preserve">
          <source>The ieee754 extension converts between F and (M,E) and back again.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d7e2d6ba2a9578fe636d96019c4ffb56636fdf7" translate="yes" xml:space="preserve">
          <source>The ieee754 extension is not part of the &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt;, but it is included by default in the &lt;a href=&quot;cli&quot;&gt;CLI&lt;/a&gt;. If you want to include the ieee754 extension in your application, you will need to compile and load it separately.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac62a77b019e01de7ef209efbe441dd3c0eb2c08" translate="yes" xml:space="preserve">
          <source>The ieee754(F) SQL function takes a single floating-point argument as its input and returns a string that looks like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79c018ce9988c89e6d43c340880c6cf378ed2e6c" translate="yes" xml:space="preserve">
          <source>The ieee754_to_blob(F) SQL function converts the floating point number F into an 8-byte BLOB that is the big-endian binary64 encoding of that number. The ieee754_from_blob(B) function goes the other way, converting an 8-byte blob into the floating-point value that the binary64 encoding represents.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d5a7e8bc386f87dedf4ba3978aa31bcde8d6916" translate="yes" xml:space="preserve">
          <source>The ifnull() function returns a copy of its first non-NULL argument, or NULL if both arguments are NULL. Ifnull() must have exactly 2 arguments. The ifnull() function is equivalent to &lt;a href=&quot;lang_corefunc#coalesce&quot;&gt;coalesce()&lt;/a&gt; with two arguments.</source>
          <target state="translated">Функция ifnull () возвращает копию своего первого аргумента, отличного от NULL, или NULL, если оба аргумента равны NULL. Ifnull () должно иметь ровно 2 аргумента. Функция ifnull () эквивалентна &lt;a href=&quot;lang_corefunc#coalesce&quot;&gt;coalesce ()&lt;/a&gt; с двумя аргументами.</target>
        </trans-unit>
        <trans-unit id="003c977ed53ddacaa1a12c60c49d228fced8878c" translate="yes" xml:space="preserve">
          <source>The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise. The iif(X,Y,Z) function is logically equivalent to and generates the same &lt;a href=&quot;opcode&quot;&gt;bytecode&lt;/a&gt; as the &lt;a href=&quot;lang_expr#case&quot;&gt;CASE expression&lt;/a&gt; &quot;CASE WHEN X THEN Y ELSE Z END&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46220a05919fd727bb5192ff33d2f0412a4a1656" translate="yes" xml:space="preserve">
          <source>The immutable query parameter is a boolean that signals to SQLite that the underlying database file is held on read-only media and cannot be modified, even by another process with elevated privileges. SQLite always opens immutable database files read-only and it skips all file locking and change detection on immutable database files. If these query parameter (or the &lt;a href=&quot;c3ref/c_iocap_atomic&quot;&gt;SQLITE_IOCAP_IMMUTABLE&lt;/a&gt; bit in xDeviceCharacteristics) asserts that a database file is immutable and that file changes anyhow, then SQLite might return incorrect query results and/or &lt;a href=&quot;rescode#corrupt&quot;&gt;SQLITE_CORRUPT&lt;/a&gt; errors.</source>
          <target state="translated">Неизменяемый параметр запроса - это логическое значение, которое сигнализирует SQLite, что основной файл базы данных хранится на носителе только для чтения и не может быть изменен даже другим процессом с повышенными привилегиями. SQLite всегда открывает неизменяемые файлы базы данных только для чтения и пропускает все блокировки файлов и обнаружение изменений в неизменяемых файлах базы данных. Если этот параметр запроса (или бит &lt;a href=&quot;c3ref/c_iocap_atomic&quot;&gt;SQLITE_IOCAP_IMMUTABLE&lt;/a&gt; в xDeviceCharacteristics) утверждает, что файл базы данных является неизменным и этот файл &lt;a href=&quot;rescode#corrupt&quot;&gt;каким-&lt;/a&gt; либо образом изменяется, то SQLite может вернуть неверные результаты запроса и / или ошибки SQLITE_CORRUPT .</target>
        </trans-unit>
        <trans-unit id="a6b9b8cf3a7d94e9575aa22c08feee5317ab9464" translate="yes" xml:space="preserve">
          <source>The implementation for the spellfix1 virtual table is held in the SQLite source tree in the miscellaneous extensions folder and in particular in the file &lt;a href=&quot;http://www.sqlite.org/src/finfo?name=ext/misc/spellfix.c&quot;&gt;ext/misc/spellfix1.c&lt;/a&gt;. The spellfix1 virtual table is not included in the SQLite &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt; and is not a part of any standard SQLite build. It is a &lt;a href=&quot;loadext&quot;&gt;loadable extension&lt;/a&gt;.</source>
          <target state="translated">Реализация виртуальной таблицы spellfix1 содержится в дереве исходных текстов SQLite в папке различных расширений и, в частности, в файле &lt;a href=&quot;http://www.sqlite.org/src/finfo?name=ext/misc/spellfix.c&quot;&gt;ext / misc / spellfix1.c&lt;/a&gt; . Виртуальная таблица spellfix1 не включена в &lt;a href=&quot;amalgamation&quot;&gt;объединение&lt;/a&gt; SQLite и не является частью какой-либо стандартной сборки SQLite. Это &lt;a href=&quot;loadext&quot;&gt;загружаемое расширение&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b2bd756ff188c7be1eef7fbb7b81b9836511fcee" translate="yes" xml:space="preserve">
          <source>The implementation for the spellfix1 virtual table is held in the SQLite source tree in the miscellaneous extensions folder and in particular in the file &lt;a href=&quot;https://www.sqlite.org/src/finfo?name=ext/misc/spellfix.c&quot;&gt;ext/misc/spellfix1.c&lt;/a&gt;. The spellfix1 virtual table is not included in the SQLite &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt; and is not a part of any standard SQLite build. It is a &lt;a href=&quot;loadext&quot;&gt;loadable extension&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8eb5688bafc7d4405d9e0ef667e71e04726e76e8" translate="yes" xml:space="preserve">
          <source>The implementation is not required to provide versions of these routines that actually work. If the implementation does not provide working versions of these routines, it should at least provide stubs that always return true so that one does not get spurious assertion failures.</source>
          <target state="translated">Реализация не требуется для предоставления реально работающих версий этих процедур.Если реализация не предоставляет рабочих версий этих подпрограмм,она должна,по крайней мере,предоставлять шлейфы,которые всегда возвращают true,чтобы не получить поддельных ошибок утверждения.</target>
        </trans-unit>
        <trans-unit id="8b40a9e730bef66c422bb631b44b6863716defa7" translate="yes" xml:space="preserve">
          <source>The implementation is registered with the FTS5 module by calling the xCreateFunction() method of the fts5_api object. If there is already an auxiliary function with the same name, it is replaced by the new function. If a non-NULL xDestroy parameter is passed to xCreateFunction(), it is invoked with a copy of the pContext pointer passed as the only argument when the database handle is closed or when the registered auxiliary function is replaced.</source>
          <target state="translated">Реализация регистрируется в модуле FTS5 путем вызова метода xCreateFunction()объекта fts5_api.Если уже существует вспомогательная функция с тем же именем,то она заменяется на новую.Если в функцию xCreateFunction()передается параметр,отличный от NULL xDestroy,то при закрытии дескриптора базы данных или при замене зарегистрированной вспомогательной функции он вызывается с копией переданного в качестве единственного аргумента pContext указателя.</target>
        </trans-unit>
        <trans-unit id="bbe3105d33c8a4906448b08f8925bf436af3dd67" translate="yes" xml:space="preserve">
          <source>The implementation is registered with the FTS5 module by calling the xCreateTokenizer() method of the fts5_api object. If there is already a tokenizer with the same name, it is replaced. If a non-NULL xDestroy parameter is passed to xCreateTokenizer(), it is invoked with a copy of the pContext pointer passed as the only argument when the database handle is closed or when the tokenizer is replaced.</source>
          <target state="translated">Реализация регистрируется в модуле FTS5 вызовом метода xCreateTokenizer()объекта fts5_api.Если уже есть токенайзер с таким же именем,то он заменяется.Если в функцию xCreateTokenizer()передается не нулевой параметр xDestroy,то при закрытии дескриптора базы данных или при замене токенайзера он вызывается с копией указателя pContext,переданного в качестве единственного аргумента.</target>
        </trans-unit>
        <trans-unit id="8b89a513d4c178ab8d213508b88c8e5c09e3c7a1" translate="yes" xml:space="preserve">
          <source>The implementation language for the example code is &lt;a href=&quot;http://www.tcl-lang.org&quot;&gt;TCL&lt;/a&gt;, though you can easily do the same thing in another programming language. Remember that the code here is a demonstration of the technique, not a drop-in module that will automatically do everything for you. The demonstration code shown below is derived from actual code in production use. But you will need to make changes to tailor it to your application.</source>
          <target state="translated">Язык реализации для примера кода - &lt;a href=&quot;http://www.tcl-lang.org&quot;&gt;TCL&lt;/a&gt; , хотя вы можете легко сделать то же самое на другом языке программирования. Помните, что код здесь является демонстрацией техники, а не вспомогательным модулем, который автоматически все сделает за вас. Показанный ниже демонстрационный код является производным от реального кода, используемого в производственной среде. Но вам нужно будет внести изменения, чтобы адаптировать его к вашему приложению.</target>
        </trans-unit>
        <trans-unit id="1c7602fe1bd4486f649d10efe941c63ad9ebc01d" translate="yes" xml:space="preserve">
          <source>The implementation of this function could be enhanced in at least two ways:</source>
          <target state="translated">Реализация этой функции может быть усилена,по крайней мере,двумя способами:</target>
        </trans-unit>
        <trans-unit id="fb654149d36243346cb33110dabec3f86ec0e93a" translate="yes" xml:space="preserve">
          <source>The important parts of the output (the parts that the developers pay the most attention to) are shown in red. Basically, the developers want to know the size of the compiled SQLite library and how many CPU cycles were needed to run the performance test.</source>
          <target state="translated">Важные части вывода (части,которым разработчики уделяют наибольшее внимание)показаны красным цветом.В основном разработчики хотят знать размер скомпилированной библиотеки SQLite и сколько циклов процессора понадобилось для запуска теста производительности.</target>
        </trans-unit>
        <trans-unit id="98a68810edc43f0319b74cd65a4602d55569695b" translate="yes" xml:space="preserve">
          <source>The imposter table mechanism is a power analysis and debugging tool for SQLite. But as with all sharp tools, it can also be dangerous and can result in corrupt database files if misused. Do not attempt to use imposter tables in an application. Imposter tables are intended for use in the laboratory by experts.</source>
          <target state="translated">Механизм imposter table-это инструмент анализа мощности и отладки для SQLite.Но,как и все острые инструменты,он также может быть опасен и в случае неправильного использования может привести к повреждению файлов базы данных.Не пытайтесь использовать imposter-таблицы в приложении.Таблицы импотов предназначены для использования в лаборатории экспертами.</target>
        </trans-unit>
        <trans-unit id="f137c1fa92f06c6d9054e4f6699dd72be9e8aeef" translate="yes" xml:space="preserve">
          <source>The in-header database size is only considered to be valid if it is non-zero and if the 4-byte &lt;a href=&quot;fileformat2#chngctr&quot;&gt;change counter&lt;/a&gt; at offset 24 exactly matches the 4-byte &lt;a href=&quot;fileformat2#validfor&quot;&gt;version-valid-for number&lt;/a&gt; at offset 92. The in-header database size is always valid when the database is only modified using recent versions of SQLite, versions 3.7.0 (2010-07-21) and later. If a legacy version of SQLite writes to the database, it will not know to update the in-header database size and so the in-header database size could be incorrect. But legacy versions of SQLite will also leave the version-valid-for number at offset 92 unchanged so it will not match the change-counter. Hence, invalid in-header database sizes can be detected (and ignored) by observing when the change-counter does not match the version-valid-for number.</source>
          <target state="translated">Размер базы данных в заголовке считается действительным только в том случае, если он не равен нулю и если 4-байтовый &lt;a href=&quot;fileformat2#chngctr&quot;&gt;счетчик изменений&lt;/a&gt; по смещению 24 точно соответствует 4-байтовому &lt;a href=&quot;fileformat2#validfor&quot;&gt;номеру версии, допустимой для&lt;/a&gt; смещения 92. База данных в заголовке size всегда действителен, если база данных изменяется только с использованием последних версий SQLite, версии 3.7.0 (2010-07-21) и более поздних. Если устаревшая версия SQLite записывает в базу данных, она не будет знать, что нужно обновить размер базы данных в заголовке, и поэтому размер базы данных в заголовке может быть неправильным. Но унаследованные версии SQLite также оставят номер версии, действительной для смещения 92, без изменений, поэтому он не будет соответствовать счетчику изменений. Следовательно, недопустимые размеры базы данных в заголовке могут быть обнаружены (и проигнорированы) путем наблюдения, когда счетчик изменений не соответствует номеру версии, действительной для версии.</target>
        </trans-unit>
        <trans-unit id="856311d50a8fd5f75cd3339835ec40132b3ad9e1" translate="yes" xml:space="preserve">
          <source>The incremental_vacuum pragma causes up to</source>
          <target state="translated">Прагма incremental_vacuum вызывает до</target>
        </trans-unit>
        <trans-unit id="2444d76ed75c2820750a8e50ad8c1d29d5247c49" translate="yes" xml:space="preserve">
          <source>The index is not usable at all because the left-most column of the index (column &quot;a&quot;) is not constrained. Assuming there are no other indexes, the query above would result in a full table scan.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2dd53e3930b5b852ae3198064e374d5480957b02" translate="yes" xml:space="preserve">
          <source>The index is not usable at all because the left-most column of the index (column &quot;a&quot;) is not constrained. Assuming there are no other indices, the query above would result in a full table scan.</source>
          <target state="translated">Индекс вообще не используется,так как левый крайний столбец индекса (столбец &quot;а&quot;)не ограничен.Если предположить,что других индексов нет,то запрос выше приведет к полному сканированию таблицы.</target>
        </trans-unit>
        <trans-unit id="5bb4d2a2c9144ace7c8a07adac81542aa803ab36" translate="yes" xml:space="preserve">
          <source>The index is not usable because the WHERE clause terms are connected by OR instead of AND. This query would result in a full table scan. However, if three additional indexes where added that contained columns b, c, and d as their left-most columns, then the &lt;a href=&quot;#or_opt&quot;&gt;OR-clause optimization&lt;/a&gt; might apply.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af8e63da60690ffa41a028a8c03b3a46553b1974" translate="yes" xml:space="preserve">
          <source>The index is not usable because the WHERE clause terms are connected by OR instead of AND. This query would result in a full table scan. However, if three additional indices where added that contained columns b, c, and d as their left-most columns, then the &lt;a href=&quot;#or_opt&quot;&gt;OR-clause optimization&lt;/a&gt; might apply.</source>
          <target state="translated">Индекс непригоден для использования, поскольку условия предложения WHERE соединяются оператором OR вместо AND. Этот запрос приведет к полному сканированию таблицы. Однако, если добавлены три дополнительных индекса, которые содержат столбцы b, c и d в качестве крайних левых столбцов, тогда может применяться &lt;a href=&quot;#or_opt&quot;&gt;оптимизация с предложением OR&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="672cc6d4ea8af33a329ad85f582fc436091b60cb" translate="yes" xml:space="preserve">
          <source>The index of the term instance within its column. Terms are numbered in order of occurrence starting from 0.</source>
          <target state="translated">Индекс экземпляра термина в его столбце.Термины нумеруются в порядке их возникновения,начиная с 0.</target>
        </trans-unit>
        <trans-unit id="9be4bc1fc0e600b05c5d496186036ea84f9ef15d" translate="yes" xml:space="preserve">
          <source>The indexed documents are not stored within the SQLite database at all (a &quot;contentless&quot; FTS4 table), or</source>
          <target state="translated">Проиндексированные документы вообще не хранятся в базе данных SQLite (&quot;бесконтактная&quot; таблица FTS4),либо</target>
        </trans-unit>
        <trans-unit id="e1d425e949e65fa344c6b8fb0277d12b499d6fc9" translate="yes" xml:space="preserve">
          <source>The indexed documents are stored in a database table created and managed by the user (an &quot;external content&quot; FTS4 table).</source>
          <target state="translated">Проиндексированные документы хранятся в таблице БД,созданной и управляемой пользователем (таблица FTS4 &quot;внешнего содержимого&quot;).</target>
        </trans-unit>
        <trans-unit id="4f34a5ba84b8851d3a1f9940d6783cb16a9d85e9" translate="yes" xml:space="preserve">
          <source>The indexes are not required, but they do help performance for large graphs. To find all nodes of the graph that are connected to node 59, use a query similar to the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4aef068b1a0d56e1caa7dcf9dfa167672f1599ff" translate="yes" xml:space="preserve">
          <source>The infix LIKE operator is implemented by calling the application-defined SQL functions &lt;a href=&quot;lang_corefunc#like&quot;&gt;like(&lt;i&gt;Y&lt;/i&gt;,&lt;i&gt;X&lt;/i&gt;)&lt;/a&gt; or &lt;a href=&quot;lang_corefunc#like&quot;&gt;like(&lt;i&gt;Y&lt;/i&gt;,&lt;i&gt;X&lt;/i&gt;,&lt;i&gt;Z&lt;/i&gt;)&lt;/a&gt;.</source>
          <target state="translated">Инфиксный оператор LIKE реализуется путем вызова определяемых приложением функций SQL, &lt;a href=&quot;lang_corefunc#like&quot;&gt;например ( &lt;i&gt;Y&lt;/i&gt; , &lt;i&gt;X&lt;/i&gt; )&lt;/a&gt; или &lt;a href=&quot;lang_corefunc#like&quot;&gt;подобных ( &lt;i&gt;Y&lt;/i&gt; , &lt;i&gt;X&lt;/i&gt; , &lt;i&gt;Z&lt;/i&gt; )&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="88a733d117cd4f0a7921fa6f2a987e25c2eb02d1" translate="yes" xml:space="preserve">
          <source>The information above can be recast into a table format as follows:</source>
          <target state="translated">Приведенную выше информацию можно перевести в формат таблицы следующим образом:</target>
        </trans-unit>
        <trans-unit id="7c260215b8c7aaba3e0315515668088d0bdaae79" translate="yes" xml:space="preserve">
          <source>The information accessed using this API and its companion xPhraseFirstColumn() may also be obtained using xPhraseFirst/xPhraseNext (or xInst/xInstCount). The chief advantage of this API is that it is significantly more efficient than those alternatives when used with &quot;detail=column&quot; tables.</source>
          <target state="translated">Доступ к информации,полученной с помощью этого API и его спутника xPhraseFirstColumn(),также можно получить с помощью xPhraseFirst/xPhraseNext (или xInst/xInstCount).Основным преимуществом этого API является то,что при использовании с таблицами &quot;detail=column&quot; он значительно эффективнее,чем эти альтернативы.</target>
        </trans-unit>
        <trans-unit id="e6d1054c7b3f35c96345a991890c1e40578c9e8c" translate="yes" xml:space="preserve">
          <source>The information in the &lt;a href=&quot;c3ref/index_info&quot;&gt;sqlite3_index_info&lt;/a&gt; structure is ephemeral and may be overwritten or deallocated as soon as the xBestIndex method returns. If the xBestIndex method needs to remember any part of the &lt;a href=&quot;c3ref/index_info&quot;&gt;sqlite3_index_info&lt;/a&gt; structure, it should make a copy. Care must be take to store the copy in a place where it will be deallocated, such as in the idxStr field with needToFreeIdxStr set to 1.</source>
          <target state="translated">Информация в структуре &lt;a href=&quot;c3ref/index_info&quot;&gt;sqlite3_index_info&lt;/a&gt; недолговечна и может быть перезаписана или удалена, как только метод xBestIndex вернется. Если методу xBestIndex необходимо запомнить какую-либо часть структуры &lt;a href=&quot;c3ref/index_info&quot;&gt;sqlite3_index_info&lt;/a&gt; , он должен сделать копию. Необходимо соблюдать осторожность, чтобы сохранить копию в месте, где она будет освобождена, например, в поле idxStr с параметром needToFreeIdxStr, установленным в 1.</target>
        </trans-unit>
        <trans-unit id="32cf05e222bbae76e66c5abe0ecf2fd84a3a7c70" translate="yes" xml:space="preserve">
          <source>The information in this article applies only when SQLite is operating in &quot;rollback mode&quot;, or in other words when SQLite is not using a &lt;a href=&quot;wal&quot;&gt;write-ahead log&lt;/a&gt;. SQLite still supports atomic commit when write-ahead logging is enabled, but it accomplishes atomic commit by a different mechanism from the one described in this article. See the &lt;a href=&quot;wal&quot;&gt;write-ahead log documentation&lt;/a&gt; for additional information on how SQLite supports atomic commit in that context.</source>
          <target state="translated">Информация в этой статье применима только тогда, когда SQLite работает в &amp;laquo;режиме отката&amp;raquo;, или, другими словами, когда SQLite не использует &lt;a href=&quot;wal&quot;&gt;журнал упреждающей записи&lt;/a&gt; . SQLite по-прежнему поддерживает атомарную фиксацию при включенном ведении журнала упреждающей записи, но выполняет атомарную фиксацию с помощью механизма, отличного от описанного в этой статье. Смотрите &lt;a href=&quot;wal&quot;&gt;документацию журнала запись вперед&lt;/a&gt; для получения дополнительной информации о том , как SQLite поддерживает атомарную фиксацию в этом контексте.</target>
        </trans-unit>
        <trans-unit id="f9342562e97e372cf7348a184a4d34dd086f3cc5" translate="yes" xml:space="preserve">
          <source>The initial &quot;INSERT&quot; keyword can be replaced by &quot;REPLACE&quot; or &quot;INSERT OR</source>
          <target state="translated">Изначальное ключевое слово &quot;INSERT&quot; может быть заменено на &quot;REPLACE&quot; или &quot;INSERT OR&quot;.</target>
        </trans-unit>
        <trans-unit id="d2a90ccaf25a62976be28829cc53054a6feb5a8b" translate="yes" xml:space="preserve">
          <source>The initial content is UTF-16 text and sqlite3_column_bytes() or sqlite3_column_text() is called. The content must be converted to UTF-8.</source>
          <target state="translated">Исходным содержимым является текст в кодировке UTF-16 и вызывается sqlite3_column_bytes()или sqlite3_column_text().Содержимое должно быть преобразовано в UTF-8.</target>
        </trans-unit>
        <trans-unit id="f5abf60cee620000168958a8b5acfa6d74016d3a" translate="yes" xml:space="preserve">
          <source>The initial content is UTF-8 text and sqlite3_column_bytes16() or sqlite3_column_text16() is called. The content must be converted to UTF-16.</source>
          <target state="translated">Исходным содержимым является UTF-8 текст и вызывается sqlite3_column_bytes16()или sqlite3_column_text16().Содержимое должно быть преобразовано в UTF-16.</target>
        </trans-unit>
        <trans-unit id="16a79a9ef866be9ddb29420482c978bd29b5a111" translate="yes" xml:space="preserve">
          <source>The initial content is a BLOB and sqlite3_column_text() or sqlite3_column_text16() is called. A zero-terminator might need to be added to the string.</source>
          <target state="translated">Исходным содержимым является BLOB и вызывается sqlite3_column_text()или sqlite3_column_text16().Возможно,потребуется добавить в строку нулевой терминатор.</target>
        </trans-unit>
        <trans-unit id="e8f78c0547aa09c0045543ed5c95b2ff19b12417" translate="yes" xml:space="preserve">
          <source>The initial implementation of NGQP chooses N=1 for simple queries, N=5 for two-way joins and N=10 for all joins with three or more tables. This formula for selecting N might change in subsequent releases.</source>
          <target state="translated">Первоначальная реализация NGQP выбирает N=1 для простых запросов,N=5 для двухсторонних соединений и N=10 для всех соединений с тремя и более таблицами.Эта формула выбора N может измениться в последующих релизах.</target>
        </trans-unit>
        <trans-unit id="433c6a25716e7b035366d6fcddc3266fd3d25e85" translate="yes" xml:space="preserve">
          <source>The initial portion of the payload that does not spill to overflow pages.</source>
          <target state="translated">Первоначальная часть полезной нагрузки,которая не проливается на переполненные страницы.</target>
        </trans-unit>
        <trans-unit id="dd04f34f18dd2c979d9e74f1f84fb7d84f3f8036" translate="yes" xml:space="preserve">
          <source>The initial-select in this case is the simple query &quot;SELECT 59&quot;. This establishes the base case. The recursive-select consists of the other two SELECT statements. The first recursive SELECT follows edges in the bb-to-aa direction and the second recursive SELECT follows edges in the aa-to-bb direction. UNION is used instead of UNION ALL to prevent the recursion from entering an infinite loop if the graph contains cycles.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a60a09b4b0f1a33259942d5b4f17c8bccd4a335d" translate="yes" xml:space="preserve">
          <source>The inner SELECT statement is implemented by instructions 1 through 10. All this code does is make an entry in the temporary table for each row of the examp2 table with a non-NULL value for the &quot;three&quot; column. The key for each temporary table entry is the &quot;three&quot; column of examp2 and the data is an empty string since it is never used.</source>
          <target state="translated">Внутреннее заявление SELECT выполняется с помощью инструкций 1-10.Все,что делает этот код,это делает запись во временной таблице для каждой строки таблицы экзамена2 с не нулевым значением для столбца &quot;три&quot;.Ключом к каждой записи во временной таблице является &quot;три&quot; столбца экзамена2,а данные-пустая строка,поскольку она никогда не используется.</target>
        </trans-unit>
        <trans-unit id="059bc1f5d258819deb1954aaf03c0ff2e66225d4" translate="yes" xml:space="preserve">
          <source>The input data used by a simple SELECT query is a set of</source>
          <target state="translated">Входные данные,используемые в простом запросе SELECT,представляют собой набор из</target>
        </trans-unit>
        <trans-unit id="6894645090ea407676b9f33e59a0dad3066f4727" translate="yes" xml:space="preserve">
          <source>The input to &lt;a href=&quot;#sqlite3_complete&quot;&gt;sqlite3_complete()&lt;/a&gt; must be a zero-terminated UTF-8 string.</source>
          <target state="translated">Вход &lt;a href=&quot;#sqlite3_complete&quot;&gt;sqlite3_complete ()&lt;/a&gt; должен быть нулем UTF-8 , строка.</target>
        </trans-unit>
        <trans-unit id="4d7419b960ffd32c455a130a0e74d0adde2f9624" translate="yes" xml:space="preserve">
          <source>The input to &lt;a href=&quot;#sqlite3_complete&quot;&gt;sqlite3_complete16()&lt;/a&gt; must be a zero-terminated UTF-16 string in native byte order.</source>
          <target state="translated">Вход &lt;a href=&quot;#sqlite3_complete&quot;&gt;sqlite3_complete16 ()&lt;/a&gt; должен быть нулем в UTF-16 строка в родном порядке байт.</target>
        </trans-unit>
        <trans-unit id="4b672bd7f0a1d030d51edf7b207eec2b4f3ae087" translate="yes" xml:space="preserve">
          <source>The input to &lt;a href=&quot;complete&quot;&gt;sqlite3_complete()&lt;/a&gt; must be a zero-terminated UTF-8 string.</source>
          <target state="translated">Вход &lt;a href=&quot;complete&quot;&gt;sqlite3_complete ()&lt;/a&gt; должен быть нулем UTF-8 , строка.</target>
        </trans-unit>
        <trans-unit id="cfd5dd711daa7423070d67fd7c844d95a0e5c24f" translate="yes" xml:space="preserve">
          <source>The input to &lt;a href=&quot;complete&quot;&gt;sqlite3_complete16()&lt;/a&gt; must be a zero-terminated UTF-16 string in native byte order.</source>
          <target state="translated">Вход &lt;a href=&quot;complete&quot;&gt;sqlite3_complete16 ()&lt;/a&gt; должен быть нулем в UTF-16 строка в родном порядке байт.</target>
        </trans-unit>
        <trans-unit id="2d24c8f818c9e23a7423d1fe6a231842fef7a551" translate="yes" xml:space="preserve">
          <source>The inputs to TH3 are test modules written in C or SQL and small configuration files that determine how to initialize SQLite. The TH3 package includes 1,444 test modules and more than 47 configurations (as of 2018-05-19). New modules and configurations can be added to customize TH3 for specialized applications. Each time TH3 is run, it reads a subset of the available test modules and configuration files to generate a custom C program that performs all of the specified tests under all specified configurations. A complete test of SQLite normally involves running TH3 multiple times to generate multiple test programs covering different aspects of SQLite's operation, then linking all test programs against a common SQLite library and running them separately on the target platform.</source>
          <target state="translated">Входами в TH3 являются тестовые модули,написанные на C или SQL,и небольшие конфигурационные файлы,которые определяют,как инициализировать SQLite.Пакет TH3 включает 14444 тестовых модуля и более 47 конфигураций (по состоянию на 2018-05-19 гг.).Новые модули и конфигурации могут быть добавлены для настройки TH3 для специализированных приложений.При каждом запуске TH3 считывается подмножество доступных тестовых модулей и конфигурационных файлов для создания пользовательской программы на C,которая выполняет все указанные тесты при всех указанных конфигурациях.Полный тест SQLite обычно включает в себя запуск TH3 несколько раз для генерации нескольких тестовых программ,охватывающих различные аспекты работы SQLite,а затем связывание всех тестовых программ с общей библиотекой SQLite и их запуск отдельно на целевой платформе.</target>
        </trans-unit>
        <trans-unit id="bb4e6367e51d64e49b708aca20c83e616d792f73" translate="yes" xml:space="preserve">
          <source>The inspiration for this document is &lt;a href=&quot;https://en.wikipedia.org/wiki/DO-178B&quot;&gt;DO-178B&lt;/a&gt;. Among quality standards, DO-178B seems to have the highest usefulness to paperwork ratio. Even so, the amount of documentation needed for a full-up DO-178B implementation is vast. SQLite strives to be nimble and low-ceremony, and to that end, much of the required DO-178B documentation is omitted. We retain only those parts that genuinely improve quality for a open-source software project such as SQLite.</source>
          <target state="translated">Вдохновением для этого документа является &lt;a href=&quot;https://en.wikipedia.org/wiki/DO-178B&quot;&gt;DO-178B&lt;/a&gt; . Среди стандартов качества, DO-178B, кажется, имеет самое высокое соотношение полезности и бумажной волокиты. Даже в этом случае объем документации, необходимой для полноценной реализации DO-178B, огромен. SQLite стремится быть гибким и непринужденным, поэтому большая часть необходимой документации DO-178B опущена. Мы оставляем только те части, которые действительно улучшают качество для проекта программного обеспечения с открытым исходным кодом, такого как SQLite.</target>
        </trans-unit>
        <trans-unit id="eeb6f7cf85fc1473abd39059a6c5676d36ad32d5" translate="yes" xml:space="preserve">
          <source>The instr(X,Y) function finds the first occurrence of string Y within string X and returns the number of prior characters plus 1, or 0 if Y is nowhere found within X. Or, if X and Y are both BLOBs, then instr(X,Y) returns one more than the number bytes prior to the first occurrence of Y, or 0 if Y does not occur anywhere within X. If both arguments X and Y to instr(X,Y) are non-NULL and are not BLOBs then both are interpreted as strings. If either X or Y are NULL in instr(X,Y) then the result is NULL.</source>
          <target state="translated">Функция instr(X,Y)находит первое вхождение строки Y в строке X и возвращает количество предыдущих символов плюс 1,или 0,если Y нигде не встречается в пределах X.Или,если X и Y оба BLOB,то instr(X,Y)возвращает на один байт больше,чем количество байтов до первого вхождения Y,или 0,если Y нигде не встречается в пределах X.Если оба аргумента X и Y в instr(X,Y)не NULL и не являются BLOB,то оба интерпретируются как строки.Если оба аргумента X или Y в instr(X,Y)являются NULL,то результат интерпретируется как NULL.</target>
        </trans-unit>
        <trans-unit id="a78743c67ceb66f35152669e19fad52bf271ff90" translate="yes" xml:space="preserve">
          <source>The instruction &lt;a href=&quot;opcode#Close&quot;&gt;Close&lt;/a&gt; closes a cursor previously opened as P1 (0, the only open cursor). If P1 is not currently open, this instruction is a no-op.</source>
          <target state="translated">Инструкция &lt;a href=&quot;opcode#Close&quot;&gt;Close&lt;/a&gt; закрывает курсор, ранее открытый как P1 (0, единственный открытый курсор). Если P1 в настоящее время не открыт, эта инструкция не работает.</target>
        </trans-unit>
        <trans-unit id="e8c5c65cb041570fcd5ae40ccc7306b738bb99f4" translate="yes" xml:space="preserve">
          <source>The instruction &lt;a href=&quot;opcode#Commit&quot;&gt;Commit&lt;/a&gt; causes all modifications to the database that have been made since the last Transaction to actually take effect. No additional modifications are allowed until another transaction is started. The Commit instruction deletes the journal file and releases the write lock on the database. A read lock continues to be held if there are still cursors open.</source>
          <target state="translated">Инструкция &lt;a href=&quot;opcode#Commit&quot;&gt;Commit&lt;/a&gt; заставляет все изменения в базе данных, которые были сделаны с момента последней транзакции, фактически вступают в силу. Никакие дополнительные изменения не допускаются, пока не будет запущена другая транзакция. Команда фиксации удаляет файл журнала и снимает блокировку записи в базе данных. Блокировка чтения продолжает удерживаться, если все еще открыты курсоры.</target>
        </trans-unit>
        <trans-unit id="71d724f14f1b112c6a8977fb693b84af3a6cb813" translate="yes" xml:space="preserve">
          <source>The instruction &lt;a href=&quot;opcode#Halt&quot;&gt;Halt&lt;/a&gt; causes the VDBE engine to exit immediately. All open cursors, Lists, Sorts, etc are closed automatically. P1 is the result code returned by sqlite_exec(). For a normal halt, this should be SQLITE_OK (0). For errors, it can be some other value. The operand P2 is only used when there is an error. There is an implied &quot;Halt 0 0 0&quot; instruction at the end of every program, which the VDBE appends when it prepares a program to run.</source>
          <target state="translated">Команда &lt;a href=&quot;opcode#Halt&quot;&gt;Halt&lt;/a&gt; немедленно завершает работу обработчика VDBE. Все открытые курсоры, списки, сортировки и т. Д. Закрываются автоматически. P1 - это код результата, возвращаемый sqlite_exec (). Для нормальной остановки это должно быть SQLITE_OK (0). Для ошибок это может быть другое значение. Операнд P2 используется только в случае ошибки. В конце каждой программы имеется подразумеваемая инструкция &amp;laquo;Halt 0 0 0&amp;raquo;, которую VDBE добавляет при подготовке программы к запуску.</target>
        </trans-unit>
        <trans-unit id="4a2e93cc788564162251660dae046bf0362122e8" translate="yes" xml:space="preserve">
          <source>The instruction &lt;a href=&quot;opcode#IdxRecno&quot;&gt;IdxRecno&lt;/a&gt; at 13 pushes onto the stack the table record number from the index. The following MoveTo pops it and moves the table cursor to that row. The next 3 instructions select the column data the same way as in the non- indexed case. The Column instructions fetch the column data and the callback function is invoked. The final Next instruction advances the index cursor, not the table cursor, to the next row, and then branches back to the start of the loop if there are any index records left.</source>
          <target state="translated">Инструкция &lt;a href=&quot;opcode#IdxRecno&quot;&gt;IdxRecno&lt;/a&gt; в 13 помещает в стек номер записи таблицы из индекса. Следующий MoveTo всплывает и перемещает курсор таблицы в эту строку. Следующие 3 инструкции выбирают данные столбца так же, как и в случае без индексации. Инструкции Column извлекают данные столбца, и вызывается функция обратного вызова. Последняя инструкция Next перемещает курсор индекса, а не курсор таблицы, к следующей строке, а затем выполняет обратный переход к началу цикла, если остались какие-либо записи индекса.</target>
        </trans-unit>
        <trans-unit id="89a91a29199817279a977a2ce4541fd6e7fee24a" translate="yes" xml:space="preserve">
          <source>The instruction &lt;a href=&quot;opcode#Integer&quot;&gt;Integer&lt;/a&gt; pushes its P1 operand (99) onto the stack. Afterwards the stack looks like this:</source>
          <target state="translated">Инструкция &lt;a href=&quot;opcode#Integer&quot;&gt;Integer&lt;/a&gt; помещает свой операнд P1 (99) в стек. После этого стек выглядит так:</target>
        </trans-unit>
        <trans-unit id="15f722b882a29ac5b03a20e923af0ef9dcb502b1" translate="yes" xml:space="preserve">
          <source>The instruction &lt;a href=&quot;opcode#Integer&quot;&gt;Integer&lt;/a&gt; pushes the integer value P1 (0) onto the stack. Here 0 is the number of the database to use in the following OpenWrite instruction. If P3 is not NULL then it is a string representation of the same integer. Afterwards the stack looks like this:</source>
          <target state="translated">Инструкция &lt;a href=&quot;opcode#Integer&quot;&gt;Integer&lt;/a&gt; помещает в стек целочисленное значение P1 (0). Здесь 0 - это номер базы данных, которая будет использоваться в следующей инструкции OpenWrite. Если P3 не равно NULL, то это строковое представление того же целого числа. После этого стек выглядит так:</target>
        </trans-unit>
        <trans-unit id="d1df5b7ac8ac4ed32e40d9d958d1c725defad872" translate="yes" xml:space="preserve">
          <source>The instruction &lt;a href=&quot;opcode#MakeRecord&quot;&gt;MakeRecord&lt;/a&gt; pops the top P1 elements off the stack (2 in this case) and converts them into the binary format used for storing records in a database file. (See the &lt;a href=&quot;fileformat&quot;&gt;file format&lt;/a&gt; description for details.) The new record generated by the MakeRecord instruction is pushed back onto the stack. Afterwards the stack looks like this:</source>
          <target state="translated">Инструкция &lt;a href=&quot;opcode#MakeRecord&quot;&gt;MakeRecord&lt;/a&gt; извлекает верхние элементы P1 из стека (в данном случае 2) и преобразует их в двоичный формат, используемый для хранения записей в файле базы данных. (Подробности см. В описании &lt;a href=&quot;fileformat&quot;&gt;формата файла&lt;/a&gt; .) Новая запись, созданная инструкцией MakeRecord, помещается обратно в стек. После этого стек выглядит так:</target>
        </trans-unit>
        <trans-unit id="21bb54c4787b5b030612c3d381e1ba9b4bb1f341" translate="yes" xml:space="preserve">
          <source>The instruction &lt;a href=&quot;opcode#NewRecno&quot;&gt;NewRecno&lt;/a&gt; creates a new integer record number for the table pointed to by cursor P1. The record number is one not currently used as a key in the table. The new record number is pushed onto the stack. Afterwards the stack looks like this:</source>
          <target state="translated">Инструкция &lt;a href=&quot;opcode#NewRecno&quot;&gt;NewRecno&lt;/a&gt; создает новый целочисленный номер записи для таблицы, на которую указывает курсор P1. Номер записи - это тот, который в настоящее время не используется в качестве ключа в таблице. Новый номер записи помещается в стек. После этого стек выглядит так:</target>
        </trans-unit>
        <trans-unit id="213073395c8927a399e8bb754b1febc0fe16eb95" translate="yes" xml:space="preserve">
          <source>The instruction &lt;a href=&quot;opcode#OpenWrite&quot;&gt;OpenWrite&lt;/a&gt; opens a new read/write cursor with handle P1 (0 in this case) on table &quot;examp&quot;, whose root page is P2 (3, in this database file). Cursor handles can be any non-negative integer. But the VDBE allocates cursors in an array with the size of the array being one more than the largest cursor. So to conserve memory, it is best to use handles beginning with zero and working upward consecutively. Here P3 (&quot;examp&quot;) is the name of the table being opened, but this is unused, and only generated to make the code easier to read. This instruction pops the database number to use (0, the main database) from the top of the stack, so afterwards the stack is empty again.</source>
          <target state="translated">Инструкция &lt;a href=&quot;opcode#OpenWrite&quot;&gt;OpenWrite&lt;/a&gt; открывает новый курсор чтения / записи с дескриптором P1 (в данном случае 0) в таблице examp, корневой страницей которой является P2 (3 в этом файле базы данных). Дескрипторы курсора могут быть любым неотрицательным целым числом. Но VDBE выделяет курсоры в массиве, размер которого на единицу больше размера самого большого курсора. Поэтому для экономии памяти лучше всего использовать дескрипторы, начинающиеся с нуля и последовательно повышающиеся. Здесь P3 (&amp;laquo;пример&amp;raquo;) - это имя открываемой таблицы, но оно не используется и генерируется только для облегчения чтения кода. Эта инструкция выталкивает номер базы данных для использования (0, основная база данных) из вершины стека, поэтому после этого стек снова становится пустым.</target>
        </trans-unit>
        <trans-unit id="98bb30ff1b874474319c63eb890c40ec0fb09de2" translate="yes" xml:space="preserve">
          <source>The instruction &lt;a href=&quot;opcode#PutIntKey&quot;&gt;PutIntKey&lt;/a&gt; uses the top 2 stack entries to write an entry into the table pointed to by cursor P1. A new entry is created if it doesn't already exist or the data for an existing entry is overwritten. The record data is the top stack entry, and the key is the next entry down. The stack is popped twice by this instruction. Because operand P2 is 1 the row change count is incremented and the rowid is stored for subsequent return by the sqlite_last_insert_rowid() function. If P2 is 0 the row change count is unmodified. This instruction is where the insert actually occurs.</source>
          <target state="translated">Инструкция &lt;a href=&quot;opcode#PutIntKey&quot;&gt;PutIntKey&lt;/a&gt; использует две верхние записи стека для записи записи в таблицу, на которую указывает курсор P1. Новая запись создается, если она еще не существует или данные для существующей записи перезаписываются. Данные записи - это верхняя запись стека, а ключ - следующая запись вниз. Эта инструкция выталкивает стек дважды. Поскольку операнд P2 равен 1, счетчик изменений строки увеличивается, а идентификатор строки сохраняется для последующего возврата функцией sqlite_last_insert_rowid (). Если P2 равен 0, счетчик изменений строки не изменяется. В этой инструкции происходит вставка.</target>
        </trans-unit>
        <trans-unit id="0b320ec6225176f371f5c1f951d40976365b4443" translate="yes" xml:space="preserve">
          <source>The instruction &lt;a href=&quot;opcode#String&quot;&gt;String&lt;/a&gt; pushes its P3 operand onto the stack. Afterwards the stack looks like this:</source>
          <target state="translated">Инструкция &lt;a href=&quot;opcode#String&quot;&gt;String&lt;/a&gt; помещает свой операнд P3 в стек. После этого стек выглядит так:</target>
        </trans-unit>
        <trans-unit id="d914ce420de942b21ca6d5eb303d1b4bdd87f483" translate="yes" xml:space="preserve">
          <source>The instruction &lt;a href=&quot;opcode#Transaction&quot;&gt;Transaction&lt;/a&gt; begins a transaction. The transaction ends when a Commit or Rollback opcode is encountered. P1 is the index of the database file on which the transaction is started. Index 0 is the main database file. A write lock is obtained on the database file when a transaction is started. No other process can read or write the file while the transaction is underway. Starting a transaction also creates a rollback journal. A transaction must be started before any changes can be made to the database.</source>
          <target state="translated">Инструкция &lt;a href=&quot;opcode#Transaction&quot;&gt;Transaction&lt;/a&gt; начинает транзакцию. Транзакция завершается, когда встречается код операции фиксации или отката. P1 - это индекс файла базы данных, для которого запускается транзакция. Индекс 0 - это главный файл базы данных. При запуске транзакции для файла базы данных устанавливается блокировка записи. Ни один другой процесс не может читать или записывать файл во время выполнения транзакции. При запуске транзакции также создается журнал отката. Перед внесением каких-либо изменений в базу данных необходимо запустить транзакцию.</target>
        </trans-unit>
        <trans-unit id="766fac627c726045a9f4c4dcb9828d544fcadbb2" translate="yes" xml:space="preserve">
          <source>The instruction &lt;a href=&quot;opcode#VerifyCookie&quot;&gt;VerifyCookie&lt;/a&gt; checks cookie 0 (the database schema version) to make sure it is equal to P2 (the value obtained when the database schema was last read). P1 is the database number (0 for the main database). This is done to make sure the database schema hasn't been changed by another thread, in which case it has to be reread.</source>
          <target state="translated">Инструкция &lt;a href=&quot;opcode#VerifyCookie&quot;&gt;VerifyCookie&lt;/a&gt; проверяет cookie 0 (версия схемы базы данных), чтобы убедиться, что она равна P2 (значению, полученному при последнем чтении схемы базы данных). P1 - номер базы данных (0 для основной базы данных). Это делается для того, чтобы убедиться, что схема базы данных не была изменена другим потоком, и в этом случае ее необходимо перечитать.</target>
        </trans-unit>
        <trans-unit id="1541b9a811a194a4f9e80a336055e479ef3f480e" translate="yes" xml:space="preserve">
          <source>The instruction at address 9 implements the branching part of the loop. Together with the Rewind at address 5 it forms the loop logic. This is a key concept that you should pay close attention to. The &lt;a href=&quot;opcode#Next&quot;&gt;Next&lt;/a&gt; instruction advances the cursor P1 to the next record. If the cursor advance was successful, then jump immediately to P2 (6, the beginning of the loop body). If the cursor was at the end, then fall through to the following instruction, which ends the loop.</source>
          <target state="translated">Инструкция по адресу 9 реализует ветвящуюся часть цикла. Вместе с перемоткой назад по адресу 5 он формирует логику цикла. Это ключевая концепция, на которую следует обратить пристальное внимание. Команда &lt;a href=&quot;opcode#Next&quot;&gt;Next&lt;/a&gt; перемещает курсор P1 к следующей записи. Если перемещение курсора прошло успешно, сразу переходите к P2 (6, начало тела цикла). Если курсор был в конце, то переходите к следующей инструкции, которая завершает цикл.</target>
        </trans-unit>
        <trans-unit id="14da6ae11560ca2b2c31ae75e094431766a4621e" translate="yes" xml:space="preserve">
          <source>The instruction at the address in register P1 is a &lt;a href=&quot;opcode#Yield&quot;&gt;Yield&lt;/a&gt;. &lt;a href=&quot;opcode#Jump&quot;&gt;Jump&lt;/a&gt; to the P2 parameter of that &lt;a href=&quot;opcode#Yield&quot;&gt;Yield&lt;/a&gt;. After the jump, register P1 becomes undefined.</source>
          <target state="translated">Инструкция по адресу в регистре P1 - это &lt;a href=&quot;opcode#Yield&quot;&gt;доходность&lt;/a&gt; . &lt;a href=&quot;opcode#Jump&quot;&gt;Перейдите&lt;/a&gt; к параметру P2 этой &lt;a href=&quot;opcode#Yield&quot;&gt;доходности&lt;/a&gt; . После перехода регистр P1 становится неопределенным.</target>
        </trans-unit>
        <trans-unit id="cd201e480371afb73e8686f10704843996fccd91" translate="yes" xml:space="preserve">
          <source>The instructions 6 through 8 form the body of the loop that will execute once for each record in the database file. The &lt;a href=&quot;opcode#Column&quot;&gt;Column&lt;/a&gt; instructions at addresses 6 and 7 each take the P2-th column from the P1-th cursor and push it onto the stack. In this example, the first Column instruction is pushing the value for the column &quot;one&quot; onto the stack and the second Column instruction is pushing the value for column &quot;two&quot;. The &lt;a href=&quot;opcode#Callback&quot;&gt;Callback&lt;/a&gt; instruction at address 8 invokes the callback() function. The P1 operand to Callback becomes the value for &lt;b&gt;nColumn&lt;/b&gt;. The Callback instruction pops P1 values from the stack and uses them to fill the &lt;b&gt;azData[]&lt;/b&gt; array.</source>
          <target state="translated">Команды с 6 по 8 образуют тело цикла, который выполняется один раз для каждой записи в файле базы данных. В &lt;a href=&quot;opcode#Column&quot;&gt;Колонка&lt;/a&gt; инструкции по адресам 6 и 7 каждый берет Р2-й столбец из P1-го курсора и толкать его в стек. В этом примере первая инструкция столбца помещает значение столбца &amp;laquo;один&amp;raquo; в стек, а вторая инструкция столбца помещает значение столбца &amp;laquo;два&amp;raquo;. &lt;a href=&quot;opcode#Callback&quot;&gt;Обратный вызов&lt;/a&gt; Инструкция по адресу 8 вызывает функцию обратного вызова (). Операнд P1 для обратного вызова становится значением для &lt;b&gt;nColumn&lt;/b&gt; . Инструкция обратного вызова извлекает значения P1 из стека и использует их для заполнения массива &lt;b&gt;azData []&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="c46964020db9e221e22ce0203153f52f7c4afbe0" translate="yes" xml:space="preserve">
          <source>The integer values returned by two invocations of &quot;PRAGMA data_version&quot; from the same connection will be different if changes were committed to the database by any other connection in the interim. The &quot;PRAGMA data_version&quot; value is unchanged for commits made on the same database connection. The behavior of &quot;PRAGMA data_version&quot; is the same for all database connections, including database connections in separate processes and &lt;a href=&quot;sharedcache&quot;&gt;shared cache&lt;/a&gt; database connections.</source>
          <target state="translated">Целочисленные значения, возвращаемые двумя вызовами PRAGMA data_version из одного и того же соединения, будут разными, если изменения были зафиксированы в базе данных каким-либо другим соединением за это время. Значение PRAGMA data_version не изменяется для коммитов, сделанных на одном и том же соединении с базой данных. Поведение PRAGMA data_version одинаково для всех соединений с базой данных, включая соединения с базой данных в отдельных процессах и соединения с базой данных с &lt;a href=&quot;sharedcache&quot;&gt;общим кешем&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4e05f2b57d17a355c0ea1387908101e6bd52b31e" translate="yes" xml:space="preserve">
          <source>The integer values to xLock() and xUnlock() are one of</source>
          <target state="translated">Целые значения к xLock()и xUnlock()являются одним из</target>
        </trans-unit>
        <trans-unit id="3a9652af526f0c1e8a87ab92c4d5d7f777a76ac5" translate="yes" xml:space="preserve">
          <source>The integrity-check command is invoked by inserting the text value 'integrity-check' into the special column with the same name as the FTS5 table. For example:</source>
          <target state="translated">Команда проверки целостности вызывается путем вставки текстового значения 'проверка целостности' в специальный столбец с тем же именем,что и таблица FTS5.Например:</target>
        </trans-unit>
        <trans-unit id="aa2dd68a608108fab7fa4442484da9ffd1d6fcde" translate="yes" xml:space="preserve">
          <source>The integrity-check command is invoked by inserting the text value 'integrity-check' into the special column with the same name as the FTS5 table. If a value is supplied for the &quot;rank&quot; column, it must be either 0 or 1. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b9cbbc162055ec87304da9b44deb92f428d9750" translate="yes" xml:space="preserve">
          <source>The intended use of this pragma is only for testing and validation of SQLite. This pragma is subject to change without notice and is not recommended for use by application programs.</source>
          <target state="translated">Предназначение данной прагмы заключается только в тестировании и валидации SQLite.Данная прагма может быть изменена без предварительного уведомления и не рекомендуется для использования прикладными программами.</target>
        </trans-unit>
        <trans-unit id="ff65b14ad46243e5d5f2ba9708d0bfaa67d238c4" translate="yes" xml:space="preserve">
          <source>The intent of the developers is to support SQLite through the year 2050.</source>
          <target state="translated">Целью разработчиков является поддержка SQLite до 2050 года.</target>
        </trans-unit>
        <trans-unit id="b8c5c15fb8411770e1f2302c0a93c745cb58106c" translate="yes" xml:space="preserve">
          <source>The intent of these enhancements to the &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE&lt;/a&gt; and &lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt; commands is to ensure that they cannot be used to create a database that contains foreign key violations, at least while foreign key constraints are enabled. There is one exception to this rule though. If a parent key is not subject to a PRIMARY KEY or UNIQUE constraint created as part of the parent table definition, but is subject to a UNIQUE constraint by virtue of an index created using the &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt; command, then the child table may be populated without causing a &quot;foreign key mismatch&quot; error. If the UNIQUE index is dropped from the database schema, then the parent table itself is dropped, no error will be reported. However the database may be left in a state where the child table of the foreign key constraint contains rows that do not refer to any parent table row. This case can be avoided if all parent keys in the database schema are constrained by PRIMARY KEY or UNIQUE constraints added as part of the parent table definition, not by external UNIQUE indexes.</source>
          <target state="translated">Эти усовершенствования команд &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE&lt;/a&gt; и &lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt; предназначены для того, чтобы гарантировать, что их нельзя использовать для создания базы данных, содержащей нарушения внешнего ключа, по крайней мере, пока включены ограничения внешнего ключа. Однако есть одно исключение из этого правила. Если родительский ключ не подчиняется ограничениям PRIMARY KEY или UNIQUE, созданным как часть определения родительской таблицы, но подчиняется ограничению UNIQUE в силу индекса, созданного с помощью &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt;команда, то дочерняя таблица может быть заполнена, не вызывая ошибки &amp;laquo;несоответствие внешнего ключа&amp;raquo;. Если индекс UNIQUE удаляется из схемы базы данных, тогда удаляется и сама родительская таблица, об ошибках не сообщается. Однако база данных может оставаться в состоянии, когда дочерняя таблица ограничения внешнего ключа содержит строки, которые не относятся к какой-либо строке родительской таблицы. Этого случая можно избежать, если все родительские ключи в схеме базы данных ограничены ограничениями PRIMARY KEY или UNIQUE, добавленными как часть определения родительской таблицы, а не внешними индексами UNIQUE.</target>
        </trans-unit>
        <trans-unit id="f25fb84e751737880254b9bbae4d5bcd681d4573" translate="yes" xml:space="preserve">
          <source>The interface between the VDBE and B-Tree layer is enhanced such that the VDBE provides hints to the B-Tree layer letting the B-Tree layer know when it is safe to use hashing instead of B-Trees for transient tables.</source>
          <target state="translated">Интерфейс между VDBE и слоем B-Tree улучшен таким образом,что VDBE дает подсказки к слою B-Tree,давая знать слою B-Tree,когда безопасно использовать хэширование вместо B-Tree для переходных таблиц.</target>
        </trans-unit>
        <trans-unit id="8f6df7d6e95fb6e2e2d0cc834a6496c76dd46264" translate="yes" xml:space="preserve">
          <source>The interface to the B-tree subsystem and the rest of the SQLite library is defined by the header file &lt;a href=&quot;https://sqlite.org/src/file/src/btree.h&quot;&gt;btree.h&lt;/a&gt;.</source>
          <target state="translated">Интерфейс к подсистеме B-дерева и остальной части библиотеки SQLite определяется заголовочным файлом &lt;a href=&quot;https://sqlite.org/src/file/src/btree.h&quot;&gt;btree.h&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b91796ad2d511be2d8979f83ba1c6fb0431a4019" translate="yes" xml:space="preserve">
          <source>The interface to the SQLite library consists of single tcl command named &lt;b&gt;sqlite3&lt;/b&gt; Because there is only this one command, the interface is not placed in a separate namespace.</source>
          <target state="translated">Интерфейс к библиотеке SQLite состоит из одной команды tcl с именем &lt;b&gt;sqlite3.&lt;/b&gt; Поскольку существует только эта одна команда, интерфейс не помещается в отдельное пространство имен.</target>
        </trans-unit>
        <trans-unit id="3c849c0d323b0ad6135a0bb1621f8f7a986a9fa1" translate="yes" xml:space="preserve">
          <source>The interface to the SQLite library consists of three core functions, one opaque data structure, and some constants used as return values. The core interface is as follows:</source>
          <target state="translated">Интерфейс к библиотеке SQLite состоит из трех основных функций,одной непрозрачной структуры данных и некоторых констант,используемых в качестве возвращаемых значений.Интерфейс ядра выглядит следующим образом:</target>
        </trans-unit>
        <trans-unit id="da5910db62046423c913e2518dadca7a36c2bb7d" translate="yes" xml:space="preserve">
          <source>The interface used by the implementation of the aforementioned functions to retrieve the collation sequence set by this opcode is not available publicly. Only built-in functions have access to this feature.</source>
          <target state="translated">Интерфейс,используемый при реализации вышеуказанных функций для получения последовательности сравнения,заданной данным опкодом,не доступен публично.Только встроенные функции имеют доступ к этой функции.</target>
        </trans-unit>
        <trans-unit id="1824212549f384e7aed12eb3886c9cf696af6dde" translate="yes" xml:space="preserve">
          <source>The interfaces necessary to construct a function that is sometimes deterministic and sometimes non-deterministic depending on their inputs, such as the built-in date/time functions, are not published. Generic &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt; must be always deterministic or always non-deterministic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82c461e3315f13aa8457935ffce58f8ac7ef7cd3" translate="yes" xml:space="preserve">
          <source>The interfaces necessary to construct a function that is sometimes deterministic and sometimes non-deterministic depending on their inputs, such as the built-in date/time functions, are not published. Generic &lt;a href=&quot;c3ref/create_function&quot;&gt;application-defined SQL functions&lt;/a&gt; must be always deterministic or always non-deterministic.</source>
          <target state="translated">Интерфейсы, необходимые для создания функции, которая иногда является детерминированной, а иногда и недетерминированной в зависимости от их входных данных, например, встроенные функции даты / времени, не публикуются. Общие &lt;a href=&quot;c3ref/create_function&quot;&gt;определяемые приложением функции SQL&lt;/a&gt; должны быть всегда детерминированными или всегда недетерминированными.</target>
        </trans-unit>
        <trans-unit id="15015bc60e3376a39ca9d7ebc27d602beffae1d0" translate="yes" xml:space="preserve">
          <source>The internal Mem object stores the value for a single register. The abstract &lt;a href=&quot;c3ref/value&quot;&gt;sqlite3_value&lt;/a&gt; object that is exposed in the API is really just a Mem object or register.</source>
          <target state="translated">Внутренний объект Mem хранит значение для одного регистра. Абстрактный объект &lt;a href=&quot;c3ref/value&quot;&gt;sqlite3_value&lt;/a&gt; , представленный в API, на самом деле является просто объектом или регистром Mem.</target>
        </trans-unit>
        <trans-unit id="e1059fa5a511cb460ad6acfc6dbdaaa7898a9f5d" translate="yes" xml:space="preserve">
          <source>The internal organization of the SQLite library can be viewed as the stack of modules shown to the right. The Tokenizer, Parser, and Code Generator components are used to process SQL statements and convert them into executable programs in a virtual machine language or byte code. Roughly speaking, these top three layers implement &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt;. The byte code generated by the top three layers is a &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt;. The Virtual Machine module is responsible for running the SQL statement byte code. The B-Tree module organizes a database file into multiple key/value stores with ordered keys and logarithmic performance. The Pager module is responsible for loading pages of the database file into memory, for implementing and controlling transactions, and for creating and maintaining the journal files that prevent database corruption following a crash or power failure. The OS Interface is a thin abstraction that provides a common set of routines for adapting SQLite to run on different operating systems. Roughly speaking, the bottom four layers implement &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt;.</source>
          <target state="translated">Внутреннюю организацию библиотеки SQLite можно рассматривать как стек модулей, показанный справа. Компоненты Tokenizer, Parser и Code Generator используются для обработки операторов SQL и преобразования их в исполняемые программы на языке виртуальной машины или байтовом коде. Грубо говоря, эти три верхних уровня реализуют &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; . Байт-код, сгенерированный тремя верхними слоями, представляет собой &lt;a href=&quot;c3ref/stmt&quot;&gt;подготовленный оператор.&lt;/a&gt;. Модуль виртуальной машины отвечает за выполнение байтового кода оператора SQL. Модуль B-Tree организует файл базы данных в несколько хранилищ ключей / значений с упорядоченными ключами и логарифмической производительностью. Модуль пейджера отвечает за загрузку страниц файла базы данных в память, за реализацию и контроль транзакций, а также за создание и поддержку файлов журнала, которые предотвращают повреждение базы данных после сбоя или сбоя питания. Интерфейс ОС - это тонкая абстракция, которая предоставляет общий набор процедур для адаптации SQLite для работы в разных операционных системах. Грубо говоря, нижние четыре уровня реализуют &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b82fe06906efdf8da65bc9a3b09aabf0c14e629e" translate="yes" xml:space="preserve">
          <source>The internet is an increasingly hostile place. These day, developers should assume that attackers will find a way to execute arbitrary SQL in an application. Applications should be designed to prevent the execution of arbitrary SQL from escalating into a more severe exploit.</source>
          <target state="translated">Интернет становится все более враждебным местом.В наши дни разработчики должны исходить из того,что злоумышленники найдут способ выполнить произвольный SQL в приложении.Приложения должны быть спроектированы таким образом,чтобы предотвратить превращение выполнения произвольного SQL в более серьезный эксплойт.</target>
        </trans-unit>
        <trans-unit id="541368df6be3b3211d485998b29f10dd5bcba535" translate="yes" xml:space="preserve">
          <source>The interpretation of the final column, if it is present, is &lt;a href=&quot;swarmvtab#component_table_context_values&quot;&gt;described here&lt;/a&gt;.</source>
          <target state="translated">Здесь &lt;a href=&quot;swarmvtab#component_table_context_values&quot;&gt;описывается&lt;/a&gt; интерпретация последнего столбца, если он присутствует .</target>
        </trans-unit>
        <trans-unit id="ecf9411adae8ae3787bf4274e751f3717d6110f0" translate="yes" xml:space="preserve">
          <source>The ioctl on Mac OS X to control syncing to disk is F_FULLFSYNC, not F_FULLSYNC. The previous release had it wrong.</source>
          <target state="translated">ioctl на Mac OS X для управления синхронизацией с диском-F_FULLFSYNC,а не F_FULLSYNC.Предыдущий релиз ошибся.</target>
        </trans-unit>
        <trans-unit id="d9c0a5f06c6830c793bad013d5441e96d45f8af0" translate="yes" xml:space="preserve">
          <source>The job of the eval method is to execute the SQL statement or statements given in the second argument. For example, to create a new table in a database, you can do this:</source>
          <target state="translated">Задачей метода оценки является выполнение SQL-оператора или операторов,указанных во втором аргументе.Например,для создания новой таблицы в базе данных это можно сделать:</target>
        </trans-unit>
        <trans-unit id="ce55e90a07de980cc86c5f2dfac419a865729e47" translate="yes" xml:space="preserve">
          <source>The job of this method is to construct the new virtual table object (an &lt;a href=&quot;c3ref/vtab&quot;&gt;sqlite3_vtab&lt;/a&gt; object) and return a pointer to it in *ppVTab.</source>
          <target state="translated">Задача этого метода - создать новый объект виртуальной таблицы ( объект &lt;a href=&quot;c3ref/vtab&quot;&gt;sqlite3_vtab&lt;/a&gt; ) и вернуть на него указатель в * ppVTab.</target>
        </trans-unit>
        <trans-unit id="82b29f2835b0336ce594d7095e779f9ce1307885" translate="yes" xml:space="preserve">
          <source>The journal header is non-zero and well-formed, and</source>
          <target state="translated">Заголовок журнала ненулевой и хорошо сформированный,и</target>
        </trans-unit>
        <trans-unit id="3978774f2c0624ee0736d9f40af64bca3b94a2e0" translate="yes" xml:space="preserve">
          <source>The journal tests are an additional double-check over and above the crash tests to make sure that SQLite transactions will be atomic across system crashes and power failures.</source>
          <target state="translated">Журнальные тесты являются дополнительной двойной проверкой,помимо краш-тестов,чтобы удостовериться,что транзакции SQLite будут атомарными в случае сбоя системы и отключения электропитания.</target>
        </trans-unit>
        <trans-unit id="eadea62ca220c75cf3d8b7ee7d22ba8de7aa3934" translate="yes" xml:space="preserve">
          <source>The journal_mode pragma returns a string which is the new journal mode. On success, the pragma will return the string &quot;&lt;code&gt;wal&lt;/code&gt;&quot;. If the conversion to WAL could not be completed (for example, if the &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; does not support the necessary shared-memory primitives) then the journaling mode will be unchanged and the string returned from the primitive will be the prior journaling mode (for example &quot;&lt;code&gt;delete&lt;/code&gt;&quot;).</source>
          <target state="translated">Прагма journal_mode возвращает строку, которая является новым режимом журнала. В случае успеха прагма вернет строку &quot; &lt;code&gt;wal&lt;/code&gt; &quot;. Если преобразование в WAL не может быть завершено (например, если &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; не поддерживает необходимые примитивы совместно используемой памяти), то режим журналирования не изменится, а строка, возвращенная из примитива, будет предыдущим режимом журналирования (например, &quot; &lt;code&gt;delete&lt;/code&gt; &quot;).</target>
        </trans-unit>
        <trans-unit id="cf12bc7373958f09d761ed0f9bf5075e87444a0e" translate="yes" xml:space="preserve">
          <source>The journal_size_limit pragma may be used to limit the size of rollback-journal and WAL files left in the file-system after transactions or checkpoints. Each time a transaction is committed or a WAL file resets, SQLite compares the size of the rollback journal file or WAL file left in the file-system to the size limit set by this pragma and if the journal or WAL file is larger it is truncated to the limit.</source>
          <target state="translated">Прагма journal_size_limit может быть использована для ограничения размера отката журнала и файлов WAL,оставленных в файловой системе после транзакций или контрольно-пропускных пунктов.При каждой фиксации транзакции или сбросе файла WAL SQLite сравнивает размер файла журнала отката или файла WAL,оставшегося в файловой системе,с предельным размером,установленным данной прагмой,и если размер журнала или файла WAL больше,то он усекается до предела.</target>
        </trans-unit>
        <trans-unit id="e4ee7815366ce998637e6c73fab93997f9ad3bf9" translate="yes" xml:space="preserve">
          <source>The json(X) function verifies that its argument X is a valid JSON string and returns a minified version of that JSON string (with all unnecessary whitespace removed). If X is not a well-formed JSON string, then this routine throws an error.</source>
          <target state="translated">Функция json(X)проверяет,что ее аргумент X является действительной JSON-строкой,и возвращает уменьшенную версию этой JSON-строки (со всеми лишними пробелами).Если X не является хорошо сформированной JSON-строкой,то эта рутина выдает ошибку.</target>
        </trans-unit>
        <trans-unit id="b38a8f8844d02f721e88e8305af9dc835b4312f1" translate="yes" xml:space="preserve">
          <source>The json1 extension (currently) stores JSON as ordinary text.</source>
          <target state="translated">Расширение json1 (в настоящее время)хранит JSON в виде обычного текста.</target>
        </trans-unit>
        <trans-unit id="600cff3bfb9b2a0fb597c7fc0f7fa3f65076ca7b" translate="yes" xml:space="preserve">
          <source>The json1 extension does not (currently) support a binary encoding of JSON. Experiments have been unable to find a binary encoding that is significantly smaller or faster than a plain text encoding. (The present implementation parses JSON text at over 1 GB/s.) All json1 functions currently throw an error if any of their arguments are BLOBs because BLOBs are reserved for a future enhancement in which BLOBs will store the binary encoding for JSON.</source>
          <target state="translated">Расширение json1 (в настоящее время)не поддерживает двоичную кодировку JSON.Эксперименты не смогли найти двоичную кодировку,которая была бы значительно меньше или быстрее,чем обычная текстовая кодировка.(В настоящее время реализация разбирает JSON текст со скоростью более 1 ГБ/с.)Все функции json1 в настоящее время бросают ошибку,если какой-либо из их аргументов является BLOB,потому что BLOB-функции зарезервированы для будущего расширения,в котором BLOB-функции будут хранить двоичную кодировку для JSON.</target>
        </trans-unit>
        <trans-unit id="50447979a47d38485f569438ae4849e4fe11a47d" translate="yes" xml:space="preserve">
          <source>The json1 extension uses the &lt;a href=&quot;c3ref/value_subtype&quot;&gt;sqlite3_value_subtype()&lt;/a&gt; and &lt;a href=&quot;c3ref/result_subtype&quot;&gt;sqlite3_result_subtype()&lt;/a&gt; interfaces that were introduced with SQLite version 3.9.0 (2015-10-14) The json1 extension will not work in earlier versions of SQLite.</source>
          <target state="translated">Расширение json1 использует интерфейсы &lt;a href=&quot;c3ref/value_subtype&quot;&gt;sqlite3_value_subtype ()&lt;/a&gt; и &lt;a href=&quot;c3ref/result_subtype&quot;&gt;sqlite3_result_subtype (),&lt;/a&gt; которые были представлены в SQLite версии 3.9.0 (2015-10-14). Расширение json1 не будет работать в более ранних версиях SQLite.</target>
        </trans-unit>
        <trans-unit id="96336d37aaa994d4a790a5daf6a1eabf939e9f47" translate="yes" xml:space="preserve">
          <source>The json1 source code is included with the SQLite &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt;, though it is disabled by default. Add the &lt;a href=&quot;compile#enable_json1&quot;&gt;-DSQLITE_ENABLE_JSON1&lt;/a&gt; compile-time option to enable the json1 extension that is built into the &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt;. The standard makefiles include -DSQLITE_ENABLE_JSON1 when building the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; and some of the test utilities so this extension is normally available in the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt;.</source>
          <target state="translated">Исходный код json1 включен в &lt;a href=&quot;amalgamation&quot;&gt;объединение&lt;/a&gt; SQLite , хотя по умолчанию он отключен. Добавьте параметр &lt;a href=&quot;compile#enable_json1&quot;&gt;-DSQLITE_ENABLE_JSON1&lt;/a&gt; во время компиляции, чтобы включить расширение json1, встроенное в &lt;a href=&quot;amalgamation&quot;&gt;объединение&lt;/a&gt; . Стандартные файлы makefile включают -DSQLITE_ENABLE_JSON1 при создании &lt;a href=&quot;cli&quot;&gt;оболочки командной строки&lt;/a&gt; и некоторых тестовых утилит, поэтому это расширение обычно доступно в &lt;a href=&quot;cli&quot;&gt;оболочке командной строки&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bb08cc12ccf8da2d3e2af52ece257a447253b7e8" translate="yes" xml:space="preserve">
          <source>The json_array() SQL function accepts zero or more arguments and returns a well-formed JSON array that is composed from those arguments. If any argument to json_array() is a BLOB then an error is thrown.</source>
          <target state="translated">SQL-функция json_array()принимает нулевые или более аргументов и возвращает хорошо сформированный JSON-массив,который состоит из этих аргументов.Если любой аргумент функции json_array()является BLOB,то выдается ошибка.</target>
        </trans-unit>
        <trans-unit id="9521182f315a0d302eb912198a80302f20c295c7" translate="yes" xml:space="preserve">
          <source>The json_array_length(X) function returns the number of elements in the JSON array X, or 0 if X is some kind of JSON value other than an array. The json_array_length(X,P) locates the array at path P within X and returns the length of that array, or 0 if path P locates an element or X other than a JSON array, and NULL if path P does not locate any element of X. Errors are thrown if either X is not well-formed JSON or if P is not a well-formed path.</source>
          <target state="translated">Функция json_array_length(X)возвращает количество элементов в JSON-массиве X,или 0,если X является каким-либо JSON-значением,отличным от массива.Функция json_array_length(X,P)находит массив по пути P внутри X и возвращает длину этого массива,или 0,если путь P находит элемент или X,отличный от JSON-массива,и NULL,если путь P не находит ни одного элемента X.Ошибки выдаются,если либо X не является хорошо сформированным JSON,либо P не является хорошо сформированным путем.</target>
        </trans-unit>
        <trans-unit id="a38155ffebbf6577ab0909bd9445bf04a40481a5" translate="yes" xml:space="preserve">
          <source>The json_each(X) and json_tree(X) &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued functions&lt;/a&gt; walk the JSON value provided as their first argument and return one row for each element. The json_each(X) function only walks the immediate children of the top-level array or object or or just the top-level element itself if the top-level element is a primitive value. The json_tree(X) function recursively walks through the JSON substructure starting with the top-level element.</source>
          <target state="translated">Возвращающие &lt;a href=&quot;vtab#tabfunc2&quot;&gt;табличное значение функции&lt;/a&gt; json_each (X) и json_tree (X) проходят значение JSON, указанное в качестве первого аргумента, и возвращают по одной строке для каждого элемента. Функция json_each (X) просматривает только непосредственных потомков массива или объекта верхнего уровня или или только самого элемента верхнего уровня, если элемент верхнего уровня является примитивным значением. Функция json_tree (X) рекурсивно просматривает подструктуру JSON, начиная с элемента верхнего уровня.</target>
        </trans-unit>
        <trans-unit id="41fff21b05289cb2b0be52b887077b0fcae3db31" translate="yes" xml:space="preserve">
          <source>The json_each(X,P) and json_tree(X,P) functions work just like their one-argument counterparts except that they treat the element identified by path P as the top-level element.</source>
          <target state="translated">Функции json_each(X,P)и json_tree(X,P)работают точно так же,как и их однопараметрические аналоги,за исключением того,что они рассматривают элемент,идентифицируемый по пути P,как элемент верхнего уровня.</target>
        </trans-unit>
        <trans-unit id="c2ff80179397d0e306699ce5e6f1d0c9aff0af74" translate="yes" xml:space="preserve">
          <source>The json_extract(X,P1,P2,...) extracts and returns one or more values from the well-formed JSON at X. If only a single path P1 is provided, then the SQL datatype of the result is NULL for a JSON null, INTEGER or REAL for a JSON numeric value, an INTEGER zero for a JSON false value, an INTEGER one for a JSON true value, the dequoted text for a JSON string value, and a text representation for JSON object and array values. If there are multiple path arguments (P1, P2, and so forth) then this routine returns SQLite text which is a well-formed JSON array holding the various values.</source>
          <target state="translated">json_extract(X,P1,P2,...)извлекает и возвращает одно или несколько значений из хорошо сформированного JSON на X.Если предоставлен только один путь P1,то тип результата SQL-NULL для JSON нуля,INTEGER или REAL для JSON числового значения,INTEGER ноль для JSON ложного значения,INTEGER ноль для JSON истинного значения,текст в кавычках для JSON строкового значения,и текстовое представление для JSON объектов и массивов значений.Если существует несколько аргументов пути (P1,P2 и т.д.),то эта рутина возвращает текст SQLite,который является хорошо сформированным JSON-массивом,содержащим различные значения.</target>
        </trans-unit>
        <trans-unit id="0f1627c2753898c7b2ebba7d223fce4a18da0c11" translate="yes" xml:space="preserve">
          <source>The json_group_array(X) function is an &lt;a href=&quot;lang_aggfunc&quot;&gt;aggregate SQL function&lt;/a&gt; that returns a JSON array comprised of all X values in the aggregation. Similarly, the json_group_object(NAME,VALUE) function returns a JSON object comprised of all NAME/VALUE pairs in the aggregation.</source>
          <target state="translated">Функция json_group_array (X) - это &lt;a href=&quot;lang_aggfunc&quot;&gt;агрегированная функция SQL,&lt;/a&gt; которая возвращает массив JSON, состоящий из всех значений X в агрегировании. Аналогичным образом функция json_group_object (NAME, VALUE) возвращает объект JSON, состоящий из всех пар NAME / VALUE в агрегации.</target>
        </trans-unit>
        <trans-unit id="08b54ec339ea85bd242a6d5ab159f649d0636c35" translate="yes" xml:space="preserve">
          <source>The json_insert(), json_replace(), and json_set() functions always take an odd number of arguments. The first argument is always the original JSON to be edited. Subsequent arguments occur in pairs with the first element of each pair being a path and the second element being the value to insert or replace or set on that path.</source>
          <target state="translated">Функции json_insert(),json_replace()и json_set()всегда принимают нечетное количество аргументов.Первым аргументом всегда является исходный JSON,который должен быть отредактирован.Последующие аргументы встречаются парами,при этом первый элемент каждой пары представляет собой путь,а второй элемент-значение для вставки,замены или установки по этому пути.</target>
        </trans-unit>
        <trans-unit id="cc677da89c2d6a3534f49f58dca0325fe7275ac0" translate="yes" xml:space="preserve">
          <source>The json_insert(), json_replace, and json_set() functions all take a single JSON value as their first argument followed by zero or more pairs of path and value arguments, and return a new JSON string formed by updating the input JSON by the path/value pairs. The functions differ only in how they deal with creating new values and overwriting preexisting values.</source>
          <target state="translated">Функции json_insert(),json_replace и json_set()принимают в качестве первого аргумента одно JSON-значение,за которым следуют нулевые или более пар аргументов пути и значения,и возвращают новую JSON-строку,сформированную путем обновления входного JSON-значения парами путь/значение.Функции отличаются только тем,как они работают с созданием новых значений и перезаписью уже существующих.</target>
        </trans-unit>
        <trans-unit id="a89fe09131a222458243e59c86a47b9418f5cefc" translate="yes" xml:space="preserve">
          <source>The json_object() SQL function accepts zero or more pairs of arguments and returns a well-formed JSON object that is composed from those arguments. The first argument of each pair is the label and the second argument of each pair is the value. If any argument to json_object() is a BLOB then an error is thrown.</source>
          <target state="translated">SQL-функция json_object()принимает нулевые или более пар аргументов и возвращает хорошо сформированный JSON-объект,который состоит из этих аргументов.Первым аргументом каждой пары является метка,а вторым-значение.Если любой аргумент функции json_object()является BLOB,то выдается ошибка.</target>
        </trans-unit>
        <trans-unit id="2288fffe16f420052bb17e5c8958c3ccdbc841f2" translate="yes" xml:space="preserve">
          <source>The json_object() function currently allows duplicate labels without complaint, though this might change in a future enhancement.</source>
          <target state="translated">Функция json_object()в настоящее время позволяет дублировать метки без претензий,хотя в будущем это может измениться.</target>
        </trans-unit>
        <trans-unit id="5e496b884466eb1ac12c106e9502f3cd98163883" translate="yes" xml:space="preserve">
          <source>The json_patch(T,P) SQL function runs the &lt;a href=&quot;https://tools.ietf.org/html/rfc7396&quot;&gt;RFC-7396&lt;/a&gt; MergePatch algorithm to apply patch P against input T. The patched copy of T is returned.</source>
          <target state="translated">SQL-функция json_patch (T, P) запускает алгоритм &lt;a href=&quot;https://tools.ietf.org/html/rfc7396&quot;&gt;RFC-7396&lt;/a&gt; MergePatch, чтобы применить исправление P к входу T. Исправленная копия T возвращается.</target>
        </trans-unit>
        <trans-unit id="d843d41461d41ce71296d2cc16a75e0d0ddb050b" translate="yes" xml:space="preserve">
          <source>The json_quote(X) function converts the SQL value X (a number or a string) into its corresponding JSON representation.</source>
          <target state="translated">Функция json_quote(X)преобразует SQL-значение X (число или строку)в соответствующее ему JSON-представление.</target>
        </trans-unit>
        <trans-unit id="076810db69b99bc12f8c66592e6373c496370f8e" translate="yes" xml:space="preserve">
          <source>The json_remove() function throws an error if the first argument is not well-formed JSON or if any later argument is not a well-formed path, or if any argument is a BLOB.</source>
          <target state="translated">Функция json_remove()выдает ошибку,если первый аргумент не является хорошо сформированным JSON,или если любой последующий аргумент не является хорошо сформированным путем,или если любой аргумент является BLOB.</target>
        </trans-unit>
        <trans-unit id="70b06ba9150c7a013b0718a5467fee57d49bd476" translate="yes" xml:space="preserve">
          <source>The json_remove(X,P,...) function takes a single JSON value as its first argument followed by zero or more path arguments. The json_remove(X,P,...) function returns a copy of the X parameter with all the elements identified by path arguments removed. Paths that select elements not found in X are silently ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07c228732927cc33b2fd2172e7d852ff75280285" translate="yes" xml:space="preserve">
          <source>The json_remove(X,P,...) function takes a single JSON value as its first argument followed by zero or more path arguments. The json_remove(X,P,...) function returns a new JSON value that is the X with all the elements identified by path arguments removed. Paths that select elements not found in X are silently ignored.</source>
          <target state="translated">Функция json_remove(X,P,...)принимает в качестве первого аргумента одно JSON-значение,за которым следует нулевой или более аргументов пути.Функция json_remove(X,P,...)возвращает новое JSON-значение,т.е.X,при этом все элементы,идентифицируемые аргументами пути,удаляются.Пути,которые выбирают элементы,не найденные в X,беззвучно игнорируются.</target>
        </trans-unit>
        <trans-unit id="dc2a43381f4cc4dcc4e70977bde02a9d9d1a46e8" translate="yes" xml:space="preserve">
          <source>The json_type() function throws an error if any of its arguments are not well-formed or is a BLOB.</source>
          <target state="translated">Функция json_type()выдает ошибку,если любой из ее аргументов неправильно сформирован или является BLOB.</target>
        </trans-unit>
        <trans-unit id="4607298214330613e115639247f1a2af460f4cfe" translate="yes" xml:space="preserve">
          <source>The json_type(X) function returns the &quot;type&quot; of the outermost element of X. The json_type(X,P) function returns the &quot;type&quot; of the element in X that is selected by path P. The &quot;type&quot; returned by json_type() is on of the following an SQL text values: 'null', 'true', 'false', 'integer', 'real', 'text', 'array', or 'object'. If the path P in json_type(X,P) selects an element that does not exist in X, then this function returns NULL.</source>
          <target state="translated">Функция json_type(X)возвращает &quot;тип&quot; самого внешнего элемента Х.Функция json_type(X,P)возвращает &quot;тип&quot; элемента в Х,который выбирается путем P.&quot;Тип&quot;,возвращаемый функцией json_type(),состоит из следующих текстовых значений SQL:'null','true','false','integer','real','text','array' или 'object'.Если путь P в json_type(X,P)выбирает элемент,которого нет в X,то эта функция возвращает NULL.</target>
        </trans-unit>
        <trans-unit id="719a758ba2801754e03a7b8fe39124f85c9b0d1b" translate="yes" xml:space="preserve">
          <source>The json_type(X) function returns the &quot;type&quot; of the outermost element of X. The json_type(X,P) function returns the &quot;type&quot; of the element in X that is selected by path P. The &quot;type&quot; returned by json_type() is one of the following an SQL text values: 'null', 'true', 'false', 'integer', 'real', 'text', 'array', or 'object'. If the path P in json_type(X,P) selects an element that does not exist in X, then this function returns NULL.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98bb00412965806c0f2fa0e24dcf65a44105fd64" translate="yes" xml:space="preserve">
          <source>The json_valid(X) function return 1 if the argument X is well-formed JSON and return 0 if the argument X is not well-formed JSON.</source>
          <target state="translated">Функция json_valid(X)возвращает 1,если аргумент X имеет хорошо сформированный JSON,и 0,если аргумент X не имеет хорошо сформированного JSON.</target>
        </trans-unit>
        <trans-unit id="b554cbe69a3700d4f56fb5609be0488decea2e7b" translate="yes" xml:space="preserve">
          <source>The key element of a</source>
          <target state="translated">Ключевой элемент</target>
        </trans-unit>
        <trans-unit id="1f79347fd256f18500712ca620e7ffb89d509d9e" translate="yes" xml:space="preserve">
          <source>The key point is that SQLite is very forgiving of the type of data that you put into the database. For example, if a column has a datatype of &quot;INTEGER&quot; and the application inserts a text string into that column, SQLite will first try to convert the text string into an integer, just like every other SQL database engine. Thus, if one inserts &lt;b&gt;'1234'&lt;/b&gt; into an INTEGER column, that value is converted into an integer 1234 and stored. But, if you insert a non-numeric string like &lt;b&gt;'wxyz'&lt;/b&gt; into an INTEGER column, unlike other SQL databases, SQLite does not throw an error. Instead, SQLite stores the actual string value in the column.</source>
          <target state="translated">Ключевым моментом является то, что SQLite очень снисходительно относится к типу данных, которые вы помещаете в базу данных. Например, если столбец имеет тип данных &amp;laquo;INTEGER&amp;raquo; и приложение вставляет текстовую строку в этот столбец, SQLite сначала попытается преобразовать текстовую строку в целое число, как и любой другой механизм базы данных SQL. Таким образом, если вставить &lt;b&gt;&amp;laquo;1234&amp;raquo;&lt;/b&gt; в столбец INTEGER, это значение преобразуется в целое число 1234 и сохраняется. Но если вы вставляете нечисловую строку, такую ​​как &lt;b&gt;'wxyz',&lt;/b&gt; в столбец INTEGER, в отличие от других баз данных SQL, SQLite не &lt;b&gt;выдает&lt;/b&gt; ошибку. Вместо этого SQLite сохраняет фактическое строковое значение в столбце.</target>
        </trans-unit>
        <trans-unit id="3e290f56c0ef256cb5bbb18b2ba0fb09ea68db61" translate="yes" xml:space="preserve">
          <source>The key point is this: Building the CLI consists of compiling together two C-language files. The &lt;b&gt;shell.c&lt;/b&gt; file contains the definition of the entry point and the user input loop and the SQLite amalgamation &lt;b&gt;sqlite3.c&lt;/b&gt; contains the complete implementation of the SQLite library.</source>
          <target state="translated">Ключевой момент заключается в следующем: построение интерфейса командной строки состоит из компиляции двух файлов на языке C. &lt;b&gt;Shell.c&lt;/b&gt; файл содержит определение точки входа и цикл ввода пользователя , так и SQLite объединения &lt;b&gt;sqlite3.c&lt;/b&gt; содержит полную реализацию библиотеки SQLite.</target>
        </trans-unit>
        <trans-unit id="bb2fbeab5253f75ff8183f69852d5cbb7ab2bba6" translate="yes" xml:space="preserve">
          <source>The key points of the previous example were the use of the Callback instruction to invoke the callback function, and the use of the Next instruction to implement a loop over all records of the database file. This example attempts to drive home those ideas by demonstrating a slightly more complex query that involves more columns of output, some of which are computed values, and a WHERE clause that limits which records actually make it to the callback function. Consider this query:</source>
          <target state="translated">Ключевыми моментами предыдущего примера были использование команды Callback для вызова функции обратного вызова,а также использование команды Next для реализации цикла над всеми записями файла базы данных.В этом примере предпринимается попытка воплотить в жизнь эти идеи путем демонстрации немного более сложного запроса,включающего большее количество столбцов вывода,некоторые из которых являются вычисленными значениями,и пункта WHERE,ограничивающего то,какие записи на самом деле делают это для функции обратного вызова.Рассмотрим этот запрос:</target>
        </trans-unit>
        <trans-unit id="986f899677204f1290b417dd64fe3fcaa05f7c30" translate="yes" xml:space="preserve">
          <source>The keys used by each segment b-tree are terms (words). As well as the key, each segment b-tree entry has an associated &quot;doclist&quot; (document list). A doclist consists of zero or more entries, where each entry consists of:</source>
          <target state="translated">Ключами,используемыми в каждом сегменте b-дерева,являются термины (слова).Так же как и ключ,каждый элемент b-дерева сегмента имеет соответствующий &quot;доклист&quot; (список документов).Докладка состоит из нуля или более записей,из которых состоит каждая запись:</target>
        </trans-unit>
        <trans-unit id="a93934848f28a5d1e280c92cac942b828e6dc7e9" translate="yes" xml:space="preserve">
          <source>The keyword &quot;INSERT&quot;, &quot;UPDATE&quot;, or &quot;DELETE&quot;, as appropriate</source>
          <target state="translated">Ключевое слово &quot;INSERT&quot;,&quot;UPDATE&quot; или &quot;DELETE&quot;,в зависимости от обстоятельств.</target>
        </trans-unit>
        <trans-unit id="799f75f9fa5e2cb1d9335f9637de442233918b1a" translate="yes" xml:space="preserve">
          <source>The kvtest program is compiled and run on Android as follows. First install the Android SDK and NDK. Then prepare a script named &quot;android-gcc&quot; that looks approximately like this:</source>
          <target state="translated">Программа kvtest компилируется и запускается на Android следующим образом.Сначала установите Android SDK и NDK.Затем подготовьте скрипт под названием &quot;android-gcc&quot;,который выглядит примерно так:</target>
        </trans-unit>
        <trans-unit id="a518e69633f247201841ea47eb51e547b9e7d52f" translate="yes" xml:space="preserve">
          <source>The label to the right of an AS in the column list of a SELECT can now be used as part of an expression in the WHERE, ORDER BY, GROUP BY, and/or HAVING clauses.</source>
          <target state="translated">Метка справа от AS в списке столбцов SELECT теперь может использоваться как часть выражения в пунктах WHERE,ORDER BY,GROUP BY,и/или HAVING.</target>
        </trans-unit>
        <trans-unit id="5d78c31e6fd49e38e9a6929f67e573c2fcc27d5f" translate="yes" xml:space="preserve">
          <source>The language id for this entry.</source>
          <target state="translated">Идентификатор языка для этой записи.</target>
        </trans-unit>
        <trans-unit id="e80fa2a23c99c4e0919bc332ef910ec1f3215c2c" translate="yes" xml:space="preserve">
          <source>The languageid option causes the FTS4 table to have an additional hidden integer column that identifies the language of the text contained in each row. The use of the languageid option allows the same FTS4 table to hold text in multiple languages or scripts, each with different tokenizer rules, and to query each language independently of the others.</source>
          <target state="translated">Опция languageid приводит к тому,что таблица FTS4 имеет дополнительный скрытый целочисленный столбец,который идентифицирует язык текста,содержащегося в каждой строке.Использование опции languageid позволяет одной и той же таблице FTS4 хранить текст на нескольких языках или скриптах,каждый из которых имеет различные правила токенов,и запрашивать каждый язык независимо от других.</target>
        </trans-unit>
        <trans-unit id="333c7dbdc428cf52a63d6a76d33660a2004630b2" translate="yes" xml:space="preserve">
          <source>The largest payload found anywhere in the current page or btree.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a93c8c9ebe55117d8275a20a3a64f1279cc0414" translate="yes" xml:space="preserve">
          <source>The largest possible setting for SQLITE_MAX_PAGE_COUNT is 2147483646. When used with the maximum page size of 65536, this gives a maximum SQLite database size of about 140 terabytes.</source>
          <target state="translated">Наибольшая возможная настройка для SQLITE_MAX_PAGE_COUNT-2147483646.При использовании с максимальным размером страницы 65536 это дает максимальный размер базы данных SQLite около 140 терабайт.</target>
        </trans-unit>
        <trans-unit id="4e80216c90c51ba3170a6cfbdb6ff5453a279861" translate="yes" xml:space="preserve">
          <source>The largest possible setting for SQLITE_MAX_PAGE_COUNT is 4294967294. When used with the maximum page size of 65536, this gives a maximum SQLite database size of about 281 terabytes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0fabb1072d1e3ea604e33e251741f22426c0f61" translate="yes" xml:space="preserve">
          <source>The last (fourth) bullet above merits additional comment. When SQLite creates a journal file on Unix, it opens the directory that contains that file and calls fsync() on the directory, in an effort to push the directory information to disk. But suppose some other process is adding or removing unrelated files to the directory that contains the database and journal at the moment of a power failure. The supposedly unrelated actions of this other process might result in the journal file being dropped from the directory and moved into &quot;lost+found&quot;. This is an unlikely scenario, but it could happen. The best defenses are to use a journaling filesystem or to keep the database and journal in a directory by themselves.</source>
          <target state="translated">Последняя (четвертая)пуля выше заслуживает дополнительных комментариев.Когда SQLite создает файл журнала на Unix,он открывает директорию,содержащую этот файл,и вызывает fsync()в этой директории,чтобы перенести информацию о директории на диск.Но предположим,что какой-то другой процесс-это добавление или удаление несвязанных файлов в директорию,содержащую БД и журнал,в момент отключения питания.Предполагаемые несвязанные действия этого другого процесса могут привести к тому,что файл журнала будет удален из директории и перемещен в &quot;lost+found&quot;.Такой сценарий маловероятен,но может произойти.Лучшей защитой является использование файловой системы протоколирования или хранение БД и журнала в каталоге сами по себе.</target>
        </trans-unit>
        <trans-unit id="0d792644cd574497ddbf62ba435f6dbc99253564" translate="yes" xml:space="preserve">
          <source>The last bullet above is illustrated by the following:</source>
          <target state="translated">Последняя приведенная выше пуля проиллюстрирована следующим образом:</target>
        </trans-unit>
        <trans-unit id="6fcee6d642fa1ca93fa14337ac4410163d2a9df9" translate="yes" xml:space="preserve">
          <source>The last output mode is &quot;html&quot;. In this mode, sqlite3 writes the results of the query as an XHTML table. The beginning &amp;lt;TABLE&amp;gt; and the ending &amp;lt;/TABLE&amp;gt; are not written, but all of the intervening &amp;lt;TR&amp;gt;s, &amp;lt;TH&amp;gt;s, and &amp;lt;TD&amp;gt;s are. The html output mode is envisioned as being useful for CGI.</source>
          <target state="translated">Последний режим вывода - &amp;laquo;html&amp;raquo;. В этом режиме sqlite3 записывает результаты запроса в виде таблицы XHTML. Начало &amp;lt;TABLE&amp;gt; и конец &amp;lt;/TABLE&amp;gt; не записываются, но записываются все промежуточные &amp;lt;TR&amp;gt;, &amp;lt;TH&amp;gt; и &amp;lt;TD&amp;gt;. Предполагается, что режим вывода html будет полезен для CGI.</target>
        </trans-unit>
        <trans-unit id="a123c1f8dadbf6bb9cc227ef0871a1fb2cbe0f9d" translate="yes" xml:space="preserve">
          <source>The last parameter to the &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer()&lt;/a&gt; and &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer()&lt;/a&gt; routines is a pointer to a procedure used to dispose of the P pointer once SQLite has finished with it. This pointer can be NULL, in which case no destructor is called.</source>
          <target state="translated">Последний параметр процедур &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer ()&lt;/a&gt; и &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer ()&lt;/a&gt; - это указатель на процедуру, используемую для удаления указателя P после того, как SQLite завершит работу с ним. Этот указатель может иметь значение NULL, и в этом случае деструктор не вызывается.</target>
        </trans-unit>
        <trans-unit id="d52a179000f827088051359c744fec0210401d8f" translate="yes" xml:space="preserve">
          <source>The last step in the commit process is to release the exclusive lock so that other processes can once again start accessing the database file.</source>
          <target state="translated">Последним шагом в процессе фиксации является снятие эксклюзивного замка,чтобы другие процессы могли снова начать доступ к файлу базы данных.</target>
        </trans-unit>
        <trans-unit id="56b9bbac0263da28aef9dee3010ecc1e8725f669" translate="yes" xml:space="preserve">
          <source>The last transaction started will be the first transaction committed or rolled back.</source>
          <target state="translated">Последняя начатая транзакция будет первой совершенной транзакцией или откатом.</target>
        </trans-unit>
        <trans-unit id="c2015d5e4ba733546bdea54c6daefbab27ed0b3f" translate="yes" xml:space="preserve">
          <source>The last two allocations can be controlled and/or eliminated by configuring the &lt;a href=&quot;malloc#pagecache&quot;&gt;pagecache memory allocator&lt;/a&gt;, and &lt;a href=&quot;malloc#lookaside&quot;&gt;lookaside memory allocator&lt;/a&gt; appropriately, as described above. The storage space required for &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; objects depends to some extent on the length of the filename of the database file, but rarely exceeds 2KB on 32-bit systems. (More space is required on 64-bit systems due to the increased size of pointers.) Each parser object uses about 1.6KB of memory. Thus, elements 3 through 7 above can easily be controlled to keep the maximum memory allocation size below 2KB.</source>
          <target state="translated">Последние два распределения можно контролировать и / или устранены путем настройки &lt;a href=&quot;malloc#pagecache&quot;&gt;аллокатора кэша страниц памяти&lt;/a&gt; , и &lt;a href=&quot;malloc#lookaside&quot;&gt;Распределитель Lookaside памяти&lt;/a&gt; надлежащим образом , как описаны выше. Объем памяти, необходимый для объектов &lt;a href=&quot;c3ref/sqlite3&quot;&gt;подключения&lt;/a&gt; к базе данных, в некоторой степени зависит от длины имени файла базы данных, но редко превышает 2 КБ в 32-разрядных системах. (В 64-битных системах требуется больше места из-за увеличенного размера указателей.) Каждый объект анализатора использует около 1,6 КБ памяти. Таким образом, элементами с 3 по 7 выше можно легко управлять, чтобы сохранить максимальный размер выделяемой памяти ниже 2 КБ.</target>
        </trans-unit>
        <trans-unit id="dd770eea393f2ccabe1cb964e8f446d8577e90ba" translate="yes" xml:space="preserve">
          <source>The last two queries take the same amount of time, in our example. So which index, Idx1 or Idx2, will SQLite choose? If the &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; command has been run on the database, so that SQLite has had an opportunity to gather statistics about the available indices, then SQLite will know that the Idx1 index usually narrows the search down to a single item (our example of fruit='Orange' is the exception to this rule) whereas the Idx2 index will normally only narrow the search down to two rows. So, if all else is equal, SQLite will choose Idx1 with the hope of narrowing the search to as small a number of rows as possible. This choice is only possible because of the statistics provided by &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt;. If &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; has not been run then the choice of which index to use is arbitrary.</source>
          <target state="translated">В нашем примере последние два запроса занимают одинаковое время. Итак, какой индекс, Idx1 или Idx2, выберет SQLite? Если команда &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; была запущена в базе данных, чтобы SQLite имел возможность собирать статистику о доступных индексах, тогда SQLite будет знать, что индекс Idx1 обычно сужает поиск до одного элемента (наш пример fruit = ' Оранжевый 'является исключением из этого правила), тогда как индекс Idx2 обычно сужает поиск только до двух строк. Итак, если все остальное равно, SQLite выберет Idx1 в надежде сузить поиск до как можно меньшего количества строк. Этот выбор возможен только благодаря статистике, предоставленной &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; . Если &lt;a href=&quot;lang_analyze&quot;&gt;АНАЛИЗИРОВАТЬ&lt;/a&gt; не был запущен, то выбор индекса для использования является произвольным.</target>
        </trans-unit>
        <trans-unit id="0271db818028a9ffb097a09e837d0647ab050705" translate="yes" xml:space="preserve">
          <source>The last_insert_rowid() function returns the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt; of the last row insert from the database connection which invoked the function. The last_insert_rowid() SQL function is a wrapper around the &lt;a href=&quot;c3ref/last_insert_rowid&quot;&gt;sqlite3_last_insert_rowid()&lt;/a&gt; C/C++ interface function.</source>
          <target state="translated">Функция last_insert_rowid () возвращает &lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt; последней вставки строки из соединения с базой данных, которое вызвало функцию. SQL-функция last_insert_rowid () является оболочкой для интерфейсной функции &lt;a href=&quot;c3ref/last_insert_rowid&quot;&gt;sqlite3_last_insert_rowid ()&lt;/a&gt; C / C ++.</target>
        </trans-unit>
        <trans-unit id="dc54cc3b765595ad1e2bcb9ada53a0d0dfaa1af8" translate="yes" xml:space="preserve">
          <source>The latest checklists contain approximately 200 items that are individually verified for each release. Some checklist items only take a few seconds to verify and mark off. Others involve test suites that run for many hours.</source>
          <target state="translated">Последние контрольные списки содержат около 200 пунктов,которые проверяются индивидуально для каждого выпуска.Некоторые пункты контрольного списка занимают всего несколько секунд,чтобы проверить и отметить их.Другие включают наборы тестов,которые работают в течение многих часов.</target>
        </trans-unit>
        <trans-unit id="972ae3a81fba75ac7b1cb927798468eb94557f5e" translate="yes" xml:space="preserve">
          <source>The latter query can not use the partial index because there might be rows in the table with b=456 and where c is NULL. But those rows would not be in the partial index.</source>
          <target state="translated">Последний запрос не может использовать частичный индекс,так как в таблице могут быть строки с b=456 и где c-NULL.Но этих строк не будет в частичном индексе.</target>
        </trans-unit>
        <trans-unit id="5d0da56ef4fd6dfbe12fe3015e9d0a6d277654f6" translate="yes" xml:space="preserve">
          <source>The leftmost column of the &quot;%_content&quot; table is an INTEGER PRIMARY KEY field named &quot;docid&quot;. Following this is one column for each column of the FTS virtual table as declared by the user, named by prepending the column name supplied by the user with &quot;c</source>
          <target state="translated">Самый левый столбец таблицы &quot;%_content&quot;-это поле INTEGER PRIMARY KEY с именем &quot;docid&quot;.Далее следует один столбец для каждого из столбцов виртуальной таблицы FTS,объявленного пользователем,названный путем предварения имени столбца,предоставленного пользователем с буквой &quot;c&quot;.</target>
        </trans-unit>
        <trans-unit id="3fe10f10852f3ac1156d75127fc7c938a298af76" translate="yes" xml:space="preserve">
          <source>The legacy &lt;a href=&quot;compile#enable_stat3&quot;&gt;SQLITE_ENABLE_STAT3&lt;/a&gt; compile-time option is now a no-op.</source>
          <target state="translated">Наследие &lt;a href=&quot;compile#enable_stat3&quot;&gt;SQLITE_ENABLE_STAT3&lt;/a&gt; вариант компиляции является сейчас не оп.</target>
        </trans-unit>
        <trans-unit id="19d5e9050bddb7e40ed3e17c750502a0acf23cf7" translate="yes" xml:space="preserve">
          <source>The legacy alter table behavior can also be toggled on and off using the &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfiglegacyaltertable&quot;&gt;SQLITE_DBCONFIG_LEGACY_ALTER_TABLE&lt;/a&gt; option to the &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config()&lt;/a&gt; interface.</source>
          <target state="translated">&lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfiglegacyaltertable&quot;&gt;Устаревшее&lt;/a&gt; поведение таблицы изменений также можно включать и выключать с помощью параметра SQLITE_DBCONFIG_LEGACY_ALTER_TABLE в интерфейсе &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="41fd664aa5a45cba5ac773955a3426725e8decb9" translate="yes" xml:space="preserve">
          <source>The legacy alter table behavior is a per-connection setting. Turning this features on or off affects all attached database files within the &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt;. The setting does not persist. Changing this setting in one connection does not affect any other connections.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0281c5597d6458d92c064f8c4ce4817fe25c10e" translate="yes" xml:space="preserve">
          <source>The legacy xGeom callback is invoked with four arguments. The first argument is a pointer to an sqlite3_rtree_geometry structure which provides information about how the SQL function was invoked. The second argument is the number of coordinates in each r-tree entry, and is always the same for any given R*Tree. The number of coordinates is 2 for a 1-dimensional R*Tree, 4 for a 2-dimensional R*Tree, 6 for a 3-dimensional R*Tree, and so forth. The third argument, aCoord[], is an array of nCoord coordinates that defines a bounding box to be tested. The last argument is a pointer into which the callback result should be written. The result is zero if the bounding-box defined by aCoord[] is completely outside the region defined by the xGeom callback and the result is non-zero if the bounding-box is inside or overlaps with the xGeom region. The xGeom callback should normally return SQLITE_OK. If xGeom returns anything other than SQLITE_OK, then the r-tree query will abort with an error.</source>
          <target state="translated">Унаследованный обратный вызов xGeom вызывается с четырьмя аргументами.Первый аргумент-указатель на структуру sqlite3_rtree_geometry,которая предоставляет информацию о том,как была вызвана SQL-функция.Второй аргумент-количество координат в каждой записи r-дерева,и всегда одинаков для любого R*дерева.Количество координат равно 2 для 1-мерного R*Tree,4 для 2-мерного R*Tree,6 для 3-мерного R*Tree и так далее.Третий аргумент,aCoord[],представляет собой массив координат nCoord,определяющий тестируемый ограничительный блок.Последний аргумент-указатель,в который должен быть записан результат обратного вызова.Результат равен нулю,если граничное поле,определенное aCoord[],полностью находится вне области,определенной обратным вызовом xGeom,а результат ненулевой,если граничное поле находится внутри области xGeom или пересекается с областью xGeom.Обратный вызов xGeom обычно должен возвращать SQLITE_OK.Если xGeom вернет что-либо кроме SQLITE_OK,то запрос r-дерева прервется с ошибкой.</target>
        </trans-unit>
        <trans-unit id="c26ac59b1bddfababdeff98e88ee3a4d181edb8a" translate="yes" xml:space="preserve">
          <source>The legacy_file_format pragma is initialized to OFF when an existing database in the newer file format is first opened.</source>
          <target state="translated">Прагма legacy_file_format инициализируется в OFF при первом открытии существующей базы данных в новом файловом формате.</target>
        </trans-unit>
        <trans-unit id="5c416af28ee6cf9f448dc251869a118022ef5870" translate="yes" xml:space="preserve">
          <source>The length of a function name may not exceed 255 characters. Any attempt to create a function whose name exceeds 255 characters in length will result in an error.</source>
          <target state="translated">Длина имени функции не должна превышать 255 символов.Любая попытка создать функцию,имя которой превышает 255 символов,приведет к ошибке.</target>
        </trans-unit>
        <trans-unit id="64a58fb27f585f3af736420c55a5c7aba354a480" translate="yes" xml:space="preserve">
          <source>The length of the argument value can be specified by one or more letters that occur just prior to the substitution type letter. In SQLite, the length only matter for integer types. The length is ignored for the &lt;a href=&quot;lang_corefunc#printf&quot;&gt;printf() SQL function&lt;/a&gt; which always uses 64-bit values. The following table shows the length specifiers allowed by SQLite:</source>
          <target state="translated">Длина значения аргумента может быть указана одной или несколькими буквами, которые встречаются непосредственно перед буквой типа подстановки. В SQLite длина имеет значение только для целочисленных типов. Длина игнорируется для &lt;a href=&quot;lang_corefunc#printf&quot;&gt;функции SQL printf (),&lt;/a&gt; которая всегда использует 64-битные значения. В следующей таблице показаны спецификаторы длины, разрешенные SQLite:</target>
        </trans-unit>
        <trans-unit id="835ff0a5a3c1f19c6461eba222151b4907f96047" translate="yes" xml:space="preserve">
          <source>The letter &quot;j&quot; pronounced like &quot;h&quot; in Spanish: LaJolla</source>
          <target state="translated">Буква &quot;j&quot; произносится как &quot;h&quot; по-испански:LaJolla</target>
        </trans-unit>
        <trans-unit id="ee9eb5ebb3823c5e0db14477052af2948a8b37ee" translate="yes" xml:space="preserve">
          <source>The library now assumes data is stored as UTF-8 if the --enable-utf8 option is given to configure. The default behavior is to assume iso8859-x, as it has always done. This only makes a difference for LIKE and GLOB operators and the LENGTH and SUBSTR functions.</source>
          <target state="translated">Библиотека теперь предполагает,что данные хранятся в кодировке UTF-8,если задана опция --enable-utf8.Поведение по умолчанию-предположить iso8859-x,как это всегда делалось.Это имеет значение только для операторов LIKE и GLOB,а также для функций LENGTH и SUBSTR.</target>
        </trans-unit>
        <trans-unit id="2b11a2ab2af2c4ff66c5a4f077ed6909c7421f85" translate="yes" xml:space="preserve">
          <source>The life-cycle of a prepared statement object usually goes like this:</source>
          <target state="translated">Жизненный цикл подготовленного объекта заявления обычно проходит вот так:</target>
        </trans-unit>
        <trans-unit id="610e163977a4d438d498cc7745085654d18422e2" translate="yes" xml:space="preserve">
          <source>The lifecycle of an sqlite3_str object is as follows:</source>
          <target state="translated">Жизненный цикл объекта sqlite3_str следующий:</target>
        </trans-unit>
        <trans-unit id="e1c985dd036afafc48409f9dec76735bbf115b4e" translate="yes" xml:space="preserve">
          <source>The like() function is used to implement the &quot;&lt;b&gt;Y LIKE X [ESCAPE Z]&lt;/b&gt;&quot; expression. If the optional ESCAPE clause is present, then the like() function is invoked with three arguments. Otherwise, it is invoked with two arguments only. Note that the X and Y parameters are reversed in the like() function relative to the infix &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; operator. X is the pattern and Y is the string to match against that pattern. Hence, the following expressions are equivalent:</source>
          <target state="translated">Функция like () используется для реализации выражения &amp;laquo; &lt;b&gt;Y LIKE X [ESCAPE Z]&lt;/b&gt; &amp;raquo;. Если присутствует необязательное предложение ESCAPE, функция like () вызывается с тремя аргументами. В противном случае он вызывается только с двумя аргументами. Обратите внимание, что параметры X и Y меняются местами в функции like () относительно инфиксного оператора &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; . X - это шаблон, а Y - строка для сопоставления с этим шаблоном. Следовательно, следующие выражения эквивалентны:</target>
        </trans-unit>
        <trans-unit id="1725d5bdba0b7e8833554a2371c0c343ab2395e2" translate="yes" xml:space="preserve">
          <source>The likelihood(X,Y) function returns argument X unchanged. The value Y in likelihood(X,Y) must be a floating point constant between 0.0 and 1.0, inclusive. The likelihood(X) function is a no-op that the code generator optimizes away so that it consumes no CPU cycles during run-time (that is, during calls to &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt;). The purpose of the likelihood(X,Y) function is to provide a hint to the query planner that the argument X is a boolean that is true with a probability of approximately Y. The &lt;a href=&quot;lang_corefunc#unlikely&quot;&gt;unlikely(X)&lt;/a&gt; function is short-hand for likelihood(X,0.0625). The &lt;a href=&quot;lang_corefunc#likely&quot;&gt;likely(X)&lt;/a&gt; function is short-hand for likelihood(X,0.9375).</source>
          <target state="translated">Функция правдоподобия (X, Y) возвращает аргумент X без изменений. Значение Y в вероятности (X, Y) должно быть константой с плавающей запятой от 0,0 до 1,0 включительно. Функция правдоподобия (X) - это запретная операция, которую генератор кода оптимизирует, чтобы не потреблять циклы ЦП во время выполнения (то есть во время вызовов &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step ()&lt;/a&gt; ). Назначение функции правдоподобия (X, Y) состоит в том, чтобы указать планировщику запросов, что аргумент X является логическим значением, которое истинно с вероятностью приблизительно Y. Функция &lt;a href=&quot;lang_corefunc#unlikely&quot;&gt;маловероятно (X)&lt;/a&gt; является сокращением для вероятности ( Х 0,0625). Функция &lt;a href=&quot;lang_corefunc#likely&quot;&gt;вероятности (X)&lt;/a&gt; является сокращением от вероятности (X, 0,9375).</target>
        </trans-unit>
        <trans-unit id="047f4505a74dbe546931a88238b570dcea0e5906" translate="yes" xml:space="preserve">
          <source>The likely(X) function returns the argument X unchanged. The likely(X) function is a no-op that the code generator optimizes away so that it consumes no CPU cycles at run-time (that is, during calls to &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt;). The purpose of the likely(X) function is to provide a hint to the query planner that the argument X is a boolean value that is usually true. The likely(X) function is equivalent to &lt;a href=&quot;lang_corefunc#likelihood&quot;&gt;likelihood&lt;/a&gt;(X,0.9375). See also: &lt;a href=&quot;lang_corefunc#unlikely&quot;&gt;unlikely(X)&lt;/a&gt;.</source>
          <target state="translated">Функция вероятно (X) возвращает аргумент X без изменений. Вероятная функция (X) - это запретная операция, которую генератор кода оптимизирует, чтобы не потреблять циклы ЦП во время выполнения (то есть во время вызовов &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step ()&lt;/a&gt; ). Назначение функции вероятно (X) - дать подсказку планировщику запросов, что аргумент X является логическим значением, которое обычно истинно. Функция вероятно (X) эквивалентна &lt;a href=&quot;lang_corefunc#likelihood&quot;&gt;правдоподобию&lt;/a&gt; (X, 0,9375). См. Также: &lt;a href=&quot;lang_corefunc#unlikely&quot;&gt;маловероятно (X)&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="604c341d9009d83169d386485e03d9e7bc04c662" translate="yes" xml:space="preserve">
          <source>The limit value is set to zero.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7008986405b40055720891f4830c40ce21496380" translate="yes" xml:space="preserve">
          <source>The line &quot;.once</source>
          <target state="translated">Строка &quot;...один раз</target>
        </trans-unit>
        <trans-unit id="d0c3acc92dc701e819ac94a0c8098f2db90a205c" translate="yes" xml:space="preserve">
          <source>The list below is not exhaustive. Other virtual table implementation exist in the SQLite source tree and elsewhere. The list below tries to capture the more interesting virtual table implementations.</source>
          <target state="translated">Приведенный ниже список не является исчерпывающим.Другая реализация виртуальной таблицы существует в дереве исходников SQLite и в других местах.Приведенный ниже список пытается охватить более интересные реализации виртуальных таблиц.</target>
        </trans-unit>
        <trans-unit id="d3b78caa21f35e034eafcfa346ed07394d0ca6e0" translate="yes" xml:space="preserve">
          <source>The list below shows all possible keywords used by any build of SQLite regardless of &lt;a href=&quot;compile&quot;&gt;compile-time options&lt;/a&gt;. Most reasonable configurations use most or all of these keywords, but some keywords may be omitted when SQL language features are disabled. Applications can use the &lt;a href=&quot;c3ref/keyword_check&quot;&gt;sqlite3_keyword_count()&lt;/a&gt;, &lt;a href=&quot;c3ref/keyword_check&quot;&gt;sqlite3_keyword_name()&lt;/a&gt;, and &lt;a href=&quot;c3ref/keyword_check&quot;&gt;sqlite3_keyword_check()&lt;/a&gt; interfaces to determine the keywords recognized by SQLite at run-time. Regardless of the compile-time configuration, any identifier that is not on the following 143 element list is not a keyword to the SQL parser in SQLite:</source>
          <target state="translated">В приведенном ниже списке показаны все возможные ключевые слова, используемые любой сборкой SQLite, независимо от &lt;a href=&quot;compile&quot;&gt;параметров времени компиляции&lt;/a&gt; . В большинстве разумных конфигураций используются большинство или все эти ключевые слова, но некоторые ключевые слова могут быть опущены, когда функции языка SQL отключены. Приложения могут использовать интерфейсы &lt;a href=&quot;c3ref/keyword_check&quot;&gt;sqlite3_keyword_count ()&lt;/a&gt; , &lt;a href=&quot;c3ref/keyword_check&quot;&gt;sqlite3_keyword_name ()&lt;/a&gt; и &lt;a href=&quot;c3ref/keyword_check&quot;&gt;sqlite3_keyword_check ()&lt;/a&gt; для определения ключевых слов, распознаваемых SQLite во время выполнения. Независимо от конфигурации времени компиляции, любой идентификатор, который не входит в следующий список из 143 элементов, не является ключевым словом для парсера SQL в SQLite:</target>
        </trans-unit>
        <trans-unit id="0180a1bb67bb5f33291414ccd4cfdc93226599e9" translate="yes" xml:space="preserve">
          <source>The list below shows all possible keywords used by any build of SQLite regardless of &lt;a href=&quot;compile&quot;&gt;compile-time options&lt;/a&gt;. Most reasonable configurations use most or all of these keywords, but some keywords may be omitted when SQL language features are disabled. Applications can use the &lt;a href=&quot;c3ref/keyword_check&quot;&gt;sqlite3_keyword_count()&lt;/a&gt;, &lt;a href=&quot;c3ref/keyword_check&quot;&gt;sqlite3_keyword_name()&lt;/a&gt;, and &lt;a href=&quot;c3ref/keyword_check&quot;&gt;sqlite3_keyword_check()&lt;/a&gt; interfaces to determine the keywords recognized by SQLite at run-time. Regardless of the compile-time configuration, any identifier that is not on the following 145 element list is not a keyword to the SQL parser in SQLite:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="281c02e8bf5d35129f9e1be609bd2e9295d15355" translate="yes" xml:space="preserve">
          <source>The list of coordinates in the binary format contains no redundancy. The last coordinate is not a repeat of the first as it is with GeoJSON. Hence, there is always one fewer coordinate pair in the binary representation of a polygon compared to the GeoJSON representation.</source>
          <target state="translated">Список координат в двоичном формате не содержит избыточности.Последняя координата не является повторением первой,как в случае с GeoJSON.Следовательно,в бинарном представлении полигона всегда на одну пару координат меньше,чем в представлении GeoJSON.</target>
        </trans-unit>
        <trans-unit id="31509dccb06d1116de02483b9bec949662404996" translate="yes" xml:space="preserve">
          <source>The list of expressions between the SELECT and FROM keywords is known as the result expression list. If a result expression is the special expression &quot;*&quot; then all columns in the input data are substituted for that one expression. If the expression is the alias of a table or subquery in the FROM clause followed by &quot;.*&quot; then all columns from the named table or subquery are substituted for the single expression. It is an error to use a &quot;*&quot; or &quot;alias.*&quot; expression in any context other than a result expression list. It is also an error to use a &quot;*&quot; or &quot;alias.*&quot; expression in a simple SELECT query that does not have a FROM clause.</source>
          <target state="translated">Список выражений между ключевыми словами SELECT и FROM известен как список выражений результата.Если результатом является специальное выражение &quot;*&quot;,то все столбцы во входных данных подставляются под это одно выражение.Если выражение является псевдонимом таблицы или подзапроса в пункте FROM,за которым следует &quot;.*&quot;,то все столбцы из именованной таблицы или подзапроса подставляются в единственное выражение.Ошибкой является использование выражения &quot;*&quot; или &quot;псевдоним.*&quot; в любом контексте,кроме списка выражений результата.Ошибкой также является использование выражения &quot;*&quot; или &quot;alias.*&quot; в простом запросе SELECT,который не имеет пункта FROM.</target>
        </trans-unit>
        <trans-unit id="aff07670c95df2683c32cdb3b9c35bd30fecbe25" translate="yes" xml:space="preserve">
          <source>The list of integers in the stat column can optionally be followed by arguments, each of which is a sequence of non-space characters. All arguments are preceded by a single space. Unrecognized arguments are silently ignored.</source>
          <target state="translated">Список целых чисел в столбце статистика может сопровождаться аргументами,каждый из которых представляет собой последовательность не пробельных символов.Всем аргументам предшествует один пробел.Непопознанные аргументы игнорируются.</target>
        </trans-unit>
        <trans-unit id="5c584c3300424511e57cf7c45771316447fd9008" translate="yes" xml:space="preserve">
          <source>The load_extension() function will fail if the extension attempts to modify or delete an SQL function or collating sequence. The extension can add new functions or collating sequences, but cannot modify or delete existing functions or collating sequences because those functions and/or collating sequences might be used elsewhere in the currently running SQL statement. To load an extension that changes or deletes functions or collating sequences, use the &lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension()&lt;/a&gt; C-language API.</source>
          <target state="translated">Функция load_extension () завершится ошибкой, если расширение попытается изменить или удалить функцию SQL или последовательность сортировки. Расширение может добавлять новые функции или последовательности сортировки, но не может изменять или удалять существующие функции или последовательности сортировки, потому что эти функции и / или последовательности сортировки могут использоваться в другом месте в текущем выполняющемся операторе SQL. Чтобы загрузить расширение, которое изменяет или удаляет функции или последовательности сортировки, используйте API-интерфейс &lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension ()&lt;/a&gt; языка C.</target>
        </trans-unit>
        <trans-unit id="349abdc2376164ceeb049d0fdce3e4218d275600" translate="yes" xml:space="preserve">
          <source>The load_extension(X,Y) function loads &lt;a href=&quot;loadext&quot;&gt;SQLite extensions&lt;/a&gt; out of the shared library file named X using the entry point Y. The result of load_extension() is always a NULL. If Y is omitted then the default entry point name is used. The load_extension() function raises an exception if the extension fails to load or initialize correctly.</source>
          <target state="translated">Функция load_extension (X, Y) загружает &lt;a href=&quot;loadext&quot;&gt;расширения SQLite&lt;/a&gt; из файла общей библиотеки с именем X, используя точку входа Y. Результат load_extension () всегда равен NULL. Если Y опущено, используется имя точки входа по умолчанию. Функция load_extension () вызывает исключение, если расширение не может правильно загрузиться или инициализироваться.</target>
        </trans-unit>
        <trans-unit id="3c476d76e8d35e3c5addfedd0889c28cfa2868c0" translate="yes" xml:space="preserve">
          <source>The local copy of the remote head</source>
          <target state="translated">Локальная копия удаленной головки</target>
        </trans-unit>
        <trans-unit id="9c687c8acb9d37e788292221df58e5cc9d9b9e4e" translate="yes" xml:space="preserve">
          <source>The local head</source>
          <target state="translated">Местный глава</target>
        </trans-unit>
        <trans-unit id="ef999d9e04e59df040c534586df9501decb45621" translate="yes" xml:space="preserve">
          <source>The lock-byte page</source>
          <target state="translated">Байтовая страница</target>
        </trans-unit>
        <trans-unit id="5c06094b5494afcc6bc0546930a2d751ec1db7b7" translate="yes" xml:space="preserve">
          <source>The lock-byte page arose from the need to support Win95 which was the predominant operating system when this file format was designed and which only supported mandatory file locking. All modern operating systems that we know of support advisory file locking, and so the lock-byte page is not really needed any more, but is retained for backwards compatibility.</source>
          <target state="translated">Байтовая страница возникла из-за необходимости поддержки Win95,которая была доминирующей операционной системой,когда был разработан этот формат файлов,и которая поддерживала только обязательную блокировку файлов.Все современные операционные системы,которые мы знаем о поддержке рекомендательной блокировки файлов,и поэтому байтовая страница блокировки на самом деле больше не нужна,а сохранена для обратной совместимости.</target>
        </trans-unit>
        <trans-unit id="4bd512e93ea74564dff8bf82d8627bae1ed3c48e" translate="yes" xml:space="preserve">
          <source>The lock-byte page is set aside for use by the operating-system specific &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; implementation in implementing the database file locking primitives. SQLite does not use the lock-byte page. The SQLite core will never read or write the lock-byte page, though operating-system specific &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; implementations may choose to read or write bytes on the lock-byte page according to the needs and proclivities of the underlying system. The unix and win32 &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; implementations that come built into SQLite do not write to the lock-byte page, but third-party VFS implementations for other operating systems might.</source>
          <target state="translated">Страница байта блокировки предназначена для использования конкретной реализацией &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; операционной системы при реализации примитивов блокировки файлов базы данных. SQLite не использует страницу байта блокировки. Ядро SQLite никогда не будет читать или записывать байтовые байты блокировки, хотя реализации &lt;a href=&quot;vfs&quot;&gt;VFS для&lt;/a&gt; конкретных операционных систем могут выбирать чтение или запись байтов на байтовые байты блокировки в соответствии с потребностями и склонностями базовой системы. Реализации &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; unix и win32 , встроенные в SQLite, не записывают на страницу байтов блокировки, но сторонние реализации VFS для других операционных систем могут.</target>
        </trans-unit>
        <trans-unit id="df185932a5473981e68a610e19ea95a4f593a072" translate="yes" xml:space="preserve">
          <source>The lock-byte page is the single page of the database file that contains the bytes at offsets between 1073741824 and 1073742335, inclusive. A database file that is less than or equal to 1073741824 bytes in size contains no lock-byte page. A database file larger than 1073741824 contains exactly one lock-byte page.</source>
          <target state="translated">Байтовая страница-это одна страница файла базы данных,содержащая байты по смещениям между 1073741824 и 1073742335 включительно.Файл базы данных,размер которого меньше или равен 1073741824 байтам,не содержит байтовой страницы блокировки.Файл базы данных размером более 1073741824 содержит ровно одну блокировку в байтах.</target>
        </trans-unit>
        <trans-unit id="dda6a9ed2d568f9a7c6dc08407b442fb82119304" translate="yes" xml:space="preserve">
          <source>The logic is summarized like this:</source>
          <target state="translated">Логика резюмируется вот так:</target>
        </trans-unit>
        <trans-unit id="355578bfd3a4498b2a633a6f3c4ff7c7b09de69f" translate="yes" xml:space="preserve">
          <source>The logical database size is now stored in the database header so that bytes can be appended to the end of the database file without corrupting it and so that SQLite will work correctly on systems that lack support for ftruncate().</source>
          <target state="translated">Логический размер базы данных теперь хранится в заголовке базы данных,чтобы байты можно было добавлять в конец файла базы данных,не повреждая его,и чтобы SQLite корректно работал на системах,не поддерживающих ftruncate().</target>
        </trans-unit>
        <trans-unit id="e93186cc2b2b96f693bcff5f9715523649b95afa" translate="yes" xml:space="preserve">
          <source>The lookaside configuration can only be changed while there are no outstanding lookaside allocations for the database connection. Hence, the configuration should be set immediately after creating the database connection using &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt; (or equivalent) and before evaluating any SQL statements on the connection.</source>
          <target state="translated">Внешнюю конфигурацию можно изменить только при отсутствии ожидающих дополнительных выделений для подключения к базе данных. Следовательно, конфигурация должна быть установлена ​​сразу после создания соединения с базой данных с помощью &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open ()&lt;/a&gt; (или аналогичного) и до оценки любых операторов SQL в соединении.</target>
        </trans-unit>
        <trans-unit id="98de1d7e1c308aef9eeb240a9c0c48340d7aa4c3" translate="yes" xml:space="preserve">
          <source>The lookaside memory allocator is really intended as performance optimization, not as a method for assuring breakdown-free memory allocation, so it is not unreasonable to completely disable the lookaside memory allocator for safety-critical operations.</source>
          <target state="translated">Смотровой аллокатор памяти действительно предназначен для оптимизации производительности,а не для обеспечения безошибочного выделения памяти,поэтому не лишним будет полностью отключить смотровой аллокатор памяти для критичных с точки зрения безопасности операций.</target>
        </trans-unit>
        <trans-unit id="02f0ada4fc69e2b3f3d2c6c843b91333faf8b563" translate="yes" xml:space="preserve">
          <source>The lookaside pool can be changed for an individual &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; &quot;db&quot; using this call:</source>
          <target state="translated">Дополнительный пул можно изменить для отдельного &lt;a href=&quot;c3ref/sqlite3&quot;&gt;подключения к базе данных&lt;/a&gt; &quot;db&quot; с помощью этого вызова:</target>
        </trans-unit>
        <trans-unit id="31d19ac91c3d68e4ec2f5534877ee0ca68a0efec" translate="yes" xml:space="preserve">
          <source>The loop begins with the &lt;a href=&quot;opcode#MemLoad&quot;&gt;MemLoad&lt;/a&gt; instruction at 11 which pushes a copy of the index key back onto the stack. The instruction &lt;a href=&quot;opcode#IdxGT&quot;&gt;IdxGT&lt;/a&gt; at 12 compares the key to the key in the current index record pointed to by cursor P1. If the index key at the current cursor location is greater than the index we are looking for, then jump out of the loop.</source>
          <target state="translated">Цикл начинается с инструкции &lt;a href=&quot;opcode#MemLoad&quot;&gt;MemLoad&lt;/a&gt; в 11, которая помещает копию индексного ключа обратно в стек. Инструкция &lt;a href=&quot;opcode#IdxGT&quot;&gt;IdxGT&lt;/a&gt; на 12 сравнивает ключ с ключом в текущей индексной записи, на которую указывает курсор P1. Если индексный ключ в текущем местоположении курсора больше, чем индекс, который мы ищем, выйдите из цикла.</target>
        </trans-unit>
        <trans-unit id="9b4e40524d32f647817434932fe77ea61e285d86" translate="yes" xml:space="preserve">
          <source>The lower(X) function returns a copy of string X with all ASCII characters converted to lower case. The default built-in lower() function works for ASCII characters only. To do case conversions on non-ASCII characters, load the ICU extension.</source>
          <target state="translated">Функция lower(X)возвращает копию строки X со всеми ASCII символами,преобразованными в нижний регистр.Встроенная по умолчанию функция lower()работает только для ASCII символов.Для выполнения преобразования регистров на не-ASCII символах необходимо загрузить расширение ICU.</target>
        </trans-unit>
        <trans-unit id="84e26bc0d335ef0f3f91dcbee9450cd939575e9d" translate="yes" xml:space="preserve">
          <source>The ltrim(X,Y) function returns a string formed by removing any and all characters that appear in Y from the left side of X. If the Y argument is omitted, ltrim(X) removes spaces from the left side of X.</source>
          <target state="translated">Функция ltrim(X,Y)возвращает строку,образованную удалением всех символов,которые появляются в Y с левой стороны X.Если аргумент Y опущен,то ltrim(X)удаляет пробелы с левой стороны X.</target>
        </trans-unit>
        <trans-unit id="dcd00f490e6b7624f89a2b1b208cdec82ae08bf5" translate="yes" xml:space="preserve">
          <source>The mFlags parameter to sqlite3_carray_bind() must be one of:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fdcc55ab3a12db83d0fd351a3149fb5d3844b7fd" translate="yes" xml:space="preserve">
          <source>The macros in this section do not require values. The following compilation switches all have the same effect:</source>
          <target state="translated">Макросы в этом разделе не требуют значений.Следующие переключатели компиляции имеют одинаковый эффект:</target>
        </trans-unit>
        <trans-unit id="9225c9e6b4935393e2d3171b186997ddaa13f218" translate="yes" xml:space="preserve">
          <source>The main database file consists of one or more pages. The size of a page is a power of two between 512 and 65536 inclusive. All pages within the same database are the same size. The page size for a database file is determined by the 2-byte integer located at an offset of 16 bytes from the beginning of the database file.</source>
          <target state="translated">Основной файл базы данных состоит из одной или нескольких страниц.Размер одной страницы составляет от 512 до 65536 включительно.Все страницы в одной базе данных имеют одинаковый размер.Размер страницы для файла БД определяется 2-байтовым целым числом,расположенным со смещением 16 байт от начала файла БД.</target>
        </trans-unit>
        <trans-unit id="7d6f37716756d458f806be1f0cab62c9c7d22175" translate="yes" xml:space="preserve">
          <source>The main database file with an arbitrary name &quot;X&quot;.</source>
          <target state="translated">Основной файл базы данных с произвольным именем &quot;X&quot;.</target>
        </trans-unit>
        <trans-unit id="f6b3e874976f8a865414a00bc3a0b52995dae0f9" translate="yes" xml:space="preserve">
          <source>The main expression bubble diagram above shows a single syntax for all function invocations. But this is merely to simplify the expression bubble diagram. In reality, each type of function has a slightly different syntax, shown below. The function invocation syntax shown in the main expression bubble diagram is the union of the three syntaxes shown here:</source>
          <target state="translated">На приведенной выше диаграмме пузырьков основного выражения показан единый синтаксис для всех вызовов функций.Но это только для того,чтобы упростить диаграмму пузырьков выражения.В действительности,каждый тип функции имеет немного разный синтаксис,показанный ниже.Синтаксис вызовов функций,показанный на диаграмме пузырьков основных выражений,является объединением трех синтаксисов,показанных здесь:</target>
        </trans-unit>
        <trans-unit id="408e5f03d044dab233873eb64f906cb6ccb49b90" translate="yes" xml:space="preserve">
          <source>The main machine in Dallas &lt;a href=&quot;https://www.sqlite.org/&quot;&gt;https://www.sqlite.org/&lt;/a&gt; is the primary server and the one that most people use. The other two are considered backups.</source>
          <target state="translated">Основная машина в Далласе &lt;a href=&quot;https://www.sqlite.org/&quot;&gt;https://www.sqlite.org/&lt;/a&gt; - это основной сервер, который использует большинство людей. Два других считаются резервными копиями.</target>
        </trans-unit>
        <trans-unit id="1d698f91852ce738e8b0efe94402ad56dc5b35ee" translate="yes" xml:space="preserve">
          <source>The main result from &lt;b&gt;sqlite_get_table&lt;/b&gt; is an array of pointers to strings. There is one element in this array for each column of each row in the result. NULL results are represented by a NULL pointer. In addition to the regular data, there is an added row at the beginning of the array that contains the name of each column of the result.</source>
          <target state="translated">Основной результат &lt;b&gt;sqlite_get_table&lt;/b&gt; - это массив указателей на строки. В этом массиве есть один элемент для каждого столбца каждой строки результата. Результаты NULL представлены указателем NULL. В дополнение к обычным данным, в начале массива есть добавленная строка, которая содержит имя каждого столбца результата.</target>
        </trans-unit>
        <trans-unit id="2fb1295c928ccfed10f4bea85ec6d057bdb858da" translate="yes" xml:space="preserve">
          <source>The main thing that the SQLite core is trying to communicate to the virtual table is the constraints that are available to limit the number of rows that need to be searched. The aConstraint[] array contains one entry for each constraint. There will be exactly nConstraint entries in that array.</source>
          <target state="translated">Главное,что ядро SQLite пытается связаться с виртуальной таблицей,это ограничения,доступные для ограничения количества строк,которые необходимо искать.Массив aConstraint[]содержит по одной записи для каждого ограничения.В этом массиве будут именно записи nConstraint.</target>
        </trans-unit>
        <trans-unit id="c00fa1abbc4e41f8e98c7516bdb7add3970ff677" translate="yes" xml:space="preserve">
          <source>The makefiles and scripts used to generate the documentation gather text from baseline documents in the documentation source repository. Additional text is extracted from comments in the SQLite source code. Requirements coverage information is extract from special comments in the &lt;a href=&quot;testing#tcl&quot;&gt;TCL test suite&lt;/a&gt; which is part of the source repository, and from comments in the &lt;a href=&quot;th3&quot;&gt;TH3&lt;/a&gt; test suite which is a separate private repository.</source>
          <target state="translated">Make-файлы и скрипты, используемые для создания документации, собирают текст из базовых документов в репозитории исходных текстов документации. Дополнительный текст извлекается из комментариев в исходном коде SQLite. Информация о покрытии требований извлекается из специальных комментариев в &lt;a href=&quot;testing#tcl&quot;&gt;наборе тестов TCL,&lt;/a&gt; который является частью исходного репозитория, и из комментариев в &lt;a href=&quot;th3&quot;&gt;наборе&lt;/a&gt; тестов TH3, который является отдельным частным репозиторием.</target>
        </trans-unit>
        <trans-unit id="42a78601e6da24d033fc5c1c1ee7512e6c89f88c" translate="yes" xml:space="preserve">
          <source>The makefiles for SQLite have an &quot;sqlite3.c&quot; target for building the file we call &quot;the amalgamation&quot;. The amalgamation is a single C code file, named &quot;sqlite3.c&quot;, that contains all C code for the core SQLite library and the &lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt;, &lt;a href=&quot;fts5&quot;&gt;FTS5&lt;/a&gt;, &lt;a href=&quot;rtree&quot;&gt;RTREE&lt;/a&gt;, &lt;a href=&quot;dbstat&quot;&gt;DBSTAT&lt;/a&gt;, &lt;a href=&quot;json1&quot;&gt;JSON1&lt;/a&gt;, and &lt;a href=&quot;rbu&quot;&gt;RBU&lt;/a&gt; extensions. This file contains about 184K lines of code (113K if you omit blank lines and comments) and is over 6.4 megabytes in size. Though the various extensions are included in the &quot;sqlite3.c&quot; amalgamation file, they are disabled using #ifdef statements. Activate the extensions using &lt;a href=&quot;compile&quot;&gt;compile-time options&lt;/a&gt; like:</source>
          <target state="translated">У make-файлов для SQLite есть цель &amp;laquo;sqlite3.c&amp;raquo; для создания файла, который мы называем &amp;laquo;объединением&amp;raquo;. Объединение представляет собой один файл кода C с именем &amp;laquo;sqlite3.c&amp;raquo;, который содержит весь код C для основной библиотеки SQLite и &lt;a href=&quot;fts3&quot;&gt;расширения FTS3&lt;/a&gt; , &lt;a href=&quot;fts5&quot;&gt;FTS5&lt;/a&gt; , &lt;a href=&quot;rtree&quot;&gt;RTREE&lt;/a&gt; , &lt;a href=&quot;dbstat&quot;&gt;DBSTAT&lt;/a&gt; , &lt;a href=&quot;json1&quot;&gt;JSON1&lt;/a&gt; и &lt;a href=&quot;rbu&quot;&gt;RBU&lt;/a&gt; . Этот файл содержит около 184 КБ строк кода (113 КБ, если не указывать пустые строки и комментарии) и имеет размер более 6,4 МБ. Хотя различные расширения включены в файл объединения &quot;sqlite3.c&quot;, они отключены с помощью операторов #ifdef. Активируйте расширения, используя такие &lt;a href=&quot;compile&quot;&gt;параметры времени компиляции,&lt;/a&gt; как:</target>
        </trans-unit>
        <trans-unit id="0980756624132b6830b479bc71ea60b90272891a" translate="yes" xml:space="preserve">
          <source>The manner in which SQLite uses temporary files is not considered part of the contract that SQLite makes with applications. The information in this document is a correct description of how SQLite operates at the time that this document was written or last updated. But there is no guarantee that future versions of SQLite will use temporary files in the same way. New kinds of temporary files might be employed and some of the current temporary file uses might be discontinued in future releases of SQLite.</source>
          <target state="translated">Способ,которым SQLite использует временные файлы,не считается частью договора,который SQLite заключает с приложениями.Информация,содержащаяся в данном документе,представляет собой правильное описание того,как SQLite работает на момент написания или последнего обновления данного документа.Но нет никакой гарантии,что будущие версии SQLite будут использовать временные файлы таким же образом.В будущих версиях SQLite могут быть использованы новые виды временных файлов,а некоторые из текущих видов использования временных файлов могут быть прекращены.</target>
        </trans-unit>
        <trans-unit id="3c2b798d423398f0b8335bc4cb33aea4b3800944" translate="yes" xml:space="preserve">
          <source>The mapping from character to affinity is given by the SQLITE_AFF_ macros defined in sqliteInt.h.</source>
          <target state="translated">Отображение от символа к сродству дается макросами SQLITE_AFF_,определенными в sqliteInt.h.</target>
        </trans-unit>
        <trans-unit id="e5801820a892b25589a4f5acb0cdb08d7136d42b" translate="yes" xml:space="preserve">
          <source>The master journal file is only created for &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; operations that involve multiple database files where at least two of the databases meet all of the following requirements:</source>
          <target state="translated">Главный файл журнала создается только для операций &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; , в которых задействовано несколько файлов базы данных, где по крайней мере две базы данных удовлетворяют всем следующим требованиям:</target>
        </trans-unit>
        <trans-unit id="31da1199925e2ef2121e09ef393e19f883001204" translate="yes" xml:space="preserve">
          <source>The master journal file is used as part of the atomic commit process when a single transaction makes changes to multiple databases that have been added to a single &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; using the &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; statement. The master journal file is always located in the same directory as the main database file (the main database file is the database that is identified in the original &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open16()&lt;/a&gt;, or &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; call that created the &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt;) with a randomized suffix. The master journal file contains the names of all of the various attached auxiliary databases that were changed during the transaction. The multi-database transaction commits when the master journal file is deleted. See the documentation titled &lt;a href=&quot;atomiccommit&quot;&gt;Atomic Commit In SQLite&lt;/a&gt; for additional detail.</source>
          <target state="translated">Главный файл журнала используется как часть процесса атомарной фиксации, когда одна транзакция вносит изменения в несколько баз данных, которые были добавлены в одно &lt;a href=&quot;c3ref/sqlite3&quot;&gt;соединение&lt;/a&gt; с базой данных с помощью оператора &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; . Главный файл журнала всегда находится в том же каталоге, что и основной файл базы данных (основной файл базы данных - это база данных, указанная в исходном &lt;a href=&quot;c3ref/open&quot;&gt;вызове sqlite3_open ()&lt;/a&gt; , &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open16 ()&lt;/a&gt; или &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2 (),&lt;/a&gt; который создал &lt;a href=&quot;c3ref/sqlite3&quot;&gt;соединение&lt;/a&gt; с базой данных.) со случайным суффиксом. Главный файл журнала содержит имена всех различных подключенных вспомогательных баз данных, которые были изменены во время транзакции. Транзакция с несколькими базами данных фиксируется при удалении главного файла журнала. Дополнительные сведения см. В документации под названием &amp;laquo; &lt;a href=&quot;atomiccommit&quot;&gt;Атомарная фиксация в SQLite&amp;raquo;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="772c6b302e1774e25495c91e9341c8308af64569" translate="yes" xml:space="preserve">
          <source>The matchinfo 'b' flag provides similar information to the &lt;a href=&quot;fts3#matchinfo-y&quot; id=&quot;matchinfo-b&quot;&gt;matchinfo 'y' flag&lt;/a&gt;, but in a more compact form. Instead of the precise number of hits, 'b' provides a single boolean flag for each phrase/column combination. If the phrase is present in the column at least once (i.e. if the corresponding integer output of 'y' would be non-zero), the corresponding flag is set. Otherwise cleared.</source>
          <target state="translated">Флаг matchinfo 'b' предоставляет информацию, аналогичную &lt;a href=&quot;fts3#matchinfo-y&quot; id=&quot;matchinfo-b&quot;&gt;флагу matchinfo 'y'&lt;/a&gt; , но в более компактной форме. Вместо точного количества совпадений &amp;laquo;b&amp;raquo; предоставляет один логический флаг для каждой комбинации фразы / столбца. Если фраза присутствует в столбце хотя бы один раз (т. Е. Если соответствующий целочисленный вывод &amp;laquo;y&amp;raquo; был бы ненулевым), устанавливается соответствующий флаг. В противном случае очищено.</target>
        </trans-unit>
        <trans-unit id="0e92769ac2bedb9028e89c1796d219b3c41ebfd0" translate="yes" xml:space="preserve">
          <source>The matchinfo function is called with either one or two arguments. As for all auxiliary functions, the first argument must be the special &lt;a href=&quot;fts3#hiddencol&quot;&gt;FTS hidden column&lt;/a&gt;. The second argument, if it is specified, must be a text value comprised only of the characters 'p', 'c', 'n', 'a', 'l', 's', 'x', 'y' and 'b'. If no second argument is explicitly supplied, it defaults to &quot;pcx&quot;. The second argument is referred to as the &quot;format string&quot; below.</source>
          <target state="translated">Функция matchinfo вызывается с одним или двумя аргументами. Что касается всех вспомогательных функций, первым аргументом должен быть специальный &lt;a href=&quot;fts3#hiddencol&quot;&gt;скрытый столбец FTS&lt;/a&gt; . Второй аргумент, если он указан, должен быть текстовым значением, состоящим только из символов 'p', 'c', 'n', 'a', 'l', 's', 'x', 'y'. и 'b'. Если явно не указан второй аргумент, по умолчанию используется &amp;laquo;pcx&amp;raquo;. Второй аргумент ниже называется &amp;laquo;строкой формата&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="d7687da8f246deec886a3154fb495c0792554c7d" translate="yes" xml:space="preserve">
          <source>The matchinfo function is much faster than either the snippet or offsets functions. This is because the implementation of both snippet and offsets is required to retrieve the documents being analyzed from disk, whereas all data required by matchinfo is available as part of the same portions of the full-text index that are required to implement the full-text query itself. This means that of the following two queries, the first may be an order of magnitude faster than the second:</source>
          <target state="translated">Функция &quot;Информация о совпадении&quot; работает намного быстрее,чем функции &quot;фрагмент&quot; или &quot;смещение&quot;.Это связано с тем,что для получения анализируемых документов с диска требуется реализация как сниппета,так и смещения,в то время как все данные,требуемые функцией совпадения,доступны в составе тех же частей полнотекстового индекса,которые необходимы для реализации самого полнотекстного запроса.Это означает,что из следующих двух запросов первый может быть на порядок быстрее второго:</target>
        </trans-unit>
        <trans-unit id="c65df31b33c2a6ca0926acfdea9fd52aa875638d" translate="yes" xml:space="preserve">
          <source>The matchinfo function provides all the information required to calculate probabilistic &quot;bag-of-words&quot; relevancy scores such as &lt;a href=&quot;http://en.wikipedia.org/wiki/Okapi_BM25&quot;&gt;Okapi BM25/BM25F&lt;/a&gt; that may be used to order results in a full-text search application. Appendix A of this document, &quot;&lt;a href=&quot;fts3#appendix_a&quot;&gt;search application tips&lt;/a&gt;&quot;, contains an example of using the matchinfo() function efficiently.</source>
          <target state="translated">Функция matchinfo предоставляет всю информацию, необходимую для расчета вероятностных оценок релевантности &amp;laquo;мешка слов&amp;raquo;, таких как &lt;a href=&quot;http://en.wikipedia.org/wiki/Okapi_BM25&quot;&gt;Okapi BM25 / BM25F,&lt;/a&gt; которые можно использовать для упорядочивания результатов в приложении полнотекстового поиска. Приложение A к этому документу &amp;laquo; &lt;a href=&quot;fts3#appendix_a&quot;&gt;Советы по поисковому приложению&lt;/a&gt; &amp;raquo; содержит пример эффективного использования функции matchinfo ().</target>
        </trans-unit>
        <trans-unit id="e88a358cc99cfdf65d05c6a19d241ddd08554be3" translate="yes" xml:space="preserve">
          <source>The matchinfo function provides all the information required to calculate probabilistic &quot;bag-of-words&quot; relevancy scores such as &lt;a href=&quot;https://en.wikipedia.org/wiki/Okapi_BM25&quot;&gt;Okapi BM25/BM25F&lt;/a&gt; that may be used to order results in a full-text search application. Appendix A of this document, &quot;&lt;a href=&quot;fts3#appendix_a&quot;&gt;search application tips&lt;/a&gt;&quot;, contains an example of using the matchinfo() function efficiently.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e90549847387fb18f595713064d87ed6f095e05c" translate="yes" xml:space="preserve">
          <source>The matchinfo function returns a blob value. If it is used within a query that does not use the full-text index (a &quot;query by rowid&quot; or &quot;linear scan&quot;), then the blob is zero bytes in size. Otherwise, the blob consists of zero or more 32-bit unsigned integers in machine byte-order. The exact number of integers in the returned array depends on both the query and the value of the second argument (if any) passed to the matchinfo function.</source>
          <target state="translated">Функция &quot;Информация о совпадении&quot; возвращает значение в виде капли.Если оно используется внутри запроса,не использующего полнотекстовый индекс (&quot;запрос по рядку&quot; или &quot;линейный скан&quot;),то размер блока равен нулю байт.В противном случае,блок состоит из нуля или более 32-битных беззнаковых целых чисел в машинном порядке байт.Точное количество целых чисел в возвращаемом массиве зависит как от запроса,так и от значения второго аргумента (если таковой имеется),переданного в функцию matchinfo.</target>
        </trans-unit>
        <trans-unit id="5fd973e0c684054ad3dbbf4a32a2b97ce84282bb" translate="yes" xml:space="preserve">
          <source>The matchinfo option may only be set to the value &quot;fts3&quot;. Attempting to set matchinfo to anything other than &quot;fts3&quot; is an error. If this option is specified, then some of the extra information stored by FTS4 is omitted. This reduces the amount of disk space consumed by an FTS4 table until it is almost the same as the amount that would be used by the equivalent FTS3 table, but also means that the data accessed by passing the 'l' flag to the &lt;a href=&quot;fts3#matchinfo&quot;&gt;matchinfo()&lt;/a&gt; function is not available.</source>
          <target state="translated">Параметр matchinfo может быть установлен только на значение &amp;laquo;fts3&amp;raquo;. Попытка установить для matchinfo значение, отличное от &quot;fts3&quot;, является ошибкой. Если указана эта опция, то часть дополнительной информации, хранящейся в FTS4, опускается. Это уменьшает объем дискового пространства, потребляемого таблицей FTS4, до тех пор, пока он не станет почти таким же, как объем, который будет использоваться эквивалентной таблицей FTS3, но также означает, что доступ к данным осуществляется путем передачи флага 'l' в &lt;a href=&quot;fts3#matchinfo&quot;&gt;matchinfo ()&lt;/a&gt; функция недоступна.</target>
        </trans-unit>
        <trans-unit id="30566a971375718efb83d0535cdd7975a1033a22" translate="yes" xml:space="preserve">
          <source>The matrix below shows the time needed to read BLOBs stored in separate files divided by the time needed to read BLOBs stored entirely in the database. Hence, for numbers larger than 1.0, it is faster to store the BLOBs directly in the database. For numbers smaller than 1.0, it is faster to store the BLOBs in separate files.</source>
          <target state="translated">В приведенной ниже матрице показано время,необходимое для чтения BLOB-ов,хранящихся в отдельных файлах,деленное на время,необходимое для чтения BLOB-ов,полностью хранящихся в базе данных.Следовательно,для чисел больше 1.0,быстрее хранить BLOB-ы непосредственно в БД.Для чисел меньше 1.0-быстрее хранить BLOB-ы в отдельных файлах.</target>
        </trans-unit>
        <trans-unit id="4c2fbc6111561deb5f89baa2a61ac965889a611a" translate="yes" xml:space="preserve">
          <source>The max() aggregate function returns the maximum value of all values in the group. The maximum value is the value that would be returned last in an ORDER BY on the same column. Aggregate max() returns NULL if and only if there are no non-NULL values in the group.</source>
          <target state="translated">Функция агрегата Max()возвращает максимальное значение всех значений в группе.Максимальное значение-это значение,которое возвращалось бы последним в ORDER BY в том же столбце.Функция агрегирования max()возвращает NULL,если и только если в группе нет не нулевых значений.</target>
        </trans-unit>
        <trans-unit id="259079b25b4ee53dd3af62dccf64b88cf7401fe7" translate="yes" xml:space="preserve">
          <source>The maximum allowed value for the 'automerge' parameter is 16. The default value is 4. Setting the 'automerge' parameter to 0 disables the automatic incremental merging of b-trees altogether.</source>
          <target state="translated">Максимально допустимое значение для параметра 'automerge'-16.Значение по умолчанию равно 4.установка параметра 'automerge' в 0 отключает автоматическое инкрементальное слияние b-деревьев.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
