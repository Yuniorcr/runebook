<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="sqlite">
    <body>
      <group id="sqlite">
        <trans-unit id="0059fb3429a6e57de6b5c01cc5ac92570ab99c32" translate="yes" xml:space="preserve">
          <source>Argument iVal must be greater than or equal to 0, and less than the number of columns in the table affected by the current change. Otherwise, &lt;a href=&quot;../rescode#range&quot;&gt;SQLITE_RANGE&lt;/a&gt; is returned and *ppValue is set to NULL.</source>
          <target state="translated">Аргумент iVal должен быть больше или равен 0, но меньше количества столбцов в таблице, затронутых текущим изменением. В противном случае &lt;a href=&quot;../rescode#range&quot;&gt;возвращается SQLITE_RANGE,&lt;/a&gt; а * ppValue устанавливается в NULL.</target>
        </trans-unit>
        <trans-unit id="12689143ab00ad889ba38fb7f63c86273b0da663" translate="yes" xml:space="preserve">
          <source>Argument iVal must be greater than or equal to 0, and less than the number of columns in the table affected by the current change. Otherwise, &lt;a href=&quot;rescode#range&quot;&gt;SQLITE_RANGE&lt;/a&gt; is returned and *ppValue is set to NULL.</source>
          <target state="translated">Аргумент iVal должен быть больше или равен 0, но меньше количества столбцов в таблице, затронутых текущим изменением. В противном случае &lt;a href=&quot;rescode#range&quot;&gt;возвращается SQLITE_RANGE,&lt;/a&gt; а * ppValue устанавливается в NULL.</target>
        </trans-unit>
        <trans-unit id="71b5b8ce6122da2fb2f466eddd7275074f8cc26d" translate="yes" xml:space="preserve">
          <source>Argument pIn must point to a buffer containing a changeset nIn bytes in size. This function allocates and populates a buffer with a copy of the changeset rebased according to the configuration of the rebaser object passed as the first argument. If successful, (*ppOut) is set to point to the new buffer containing the rebased changeset and (*pnOut) to its size in bytes and SQLITE_OK returned. It is the responsibility of the caller to eventually free the new buffer using sqlite3_free(). Otherwise, if an error occurs, (*ppOut) and (*pnOut) are set to zero and an SQLite error code returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1502f4d9bcf958ec2d3f9df8d5434c6f3fb95622" translate="yes" xml:space="preserve">
          <source>Argument pIn must point to a buffer containing a changeset nIn bytes in size. This function allocates and populates a buffer with a copy of the changeset rebased rebased according to the configuration of the rebaser object passed as the first argument. If successful, (*ppOut) is set to point to the new buffer containing the rebased changeset and (*pnOut) to its size in bytes and SQLITE_OK returned. It is the responsibility of the caller to eventually free the new buffer using sqlite3_free(). Otherwise, if an error occurs, (*ppOut) and (*pnOut) are set to zero and an SQLite error code returned.</source>
          <target state="translated">Аргумент pIn должен указывать на буфер,содержащий изменяемый размер nIn байт.Эта функция выделяет и заполняет буфер с копией changeset rebased в соответствии с конфигурацией объекта rebaser,переданного в качестве первого аргумента.В случае успеха (*ppOut)устанавливается указание на новый буфер,содержащий ребрендированный changeset и (*pnOut)на его размер в байтах и возвращаемый SQLITE_OK.Ответственность за окончательное освобождение нового буфера лежит на вызывающем абоненте,который использует sqlite3_free().В противном случае,при возникновении ошибки,(*ppOut)и (*pnOut)устанавливаются на ноль и возвращается код ошибки SQLite.</target>
        </trans-unit>
        <trans-unit id="3273cfe93e49705347b0b90c1dbaf9e32a834424" translate="yes" xml:space="preserve">
          <source>Argument zFromDb must be the name of a database (&quot;main&quot;, &quot;temp&quot; etc.) attached to the same database handle as the session object that contains a table compatible with the table attached to the session by this function. A table is considered compatible if it:</source>
          <target state="translated">Аргумент zFromDb должен представлять собой имя БД (&quot;main&quot;,&quot;temp&quot; и т.д.),прикрепленной к тому же хэндлу БД,что и объект сеанса,содержащий таблицу,совместимую с таблицей,прикрепленной к сеансу этой функцией.Если таблица совместима,то она считается совместимой:</target>
        </trans-unit>
        <trans-unit id="c2dd08aa3192624f9fd5e4d0f584709c36b430c5" translate="yes" xml:space="preserve">
          <source>Arguments on the virtual table name are matched to &lt;a href=&quot;vtab#hiddencol&quot;&gt;hidden columns&lt;/a&gt; in order. The number of arguments can be less than the number of hidden columns, in which case the latter hidden columns are unconstrained. However, an error results if there are more arguments than there are hidden columns in the virtual table.</source>
          <target state="translated">Аргументы имени виртуальной таблицы сопоставляются со &lt;a href=&quot;vtab#hiddencol&quot;&gt;скрытыми столбцами&lt;/a&gt; по порядку. Количество аргументов может быть меньше количества скрытых столбцов, и в этом случае последние скрытые столбцы не ограничены. Однако ошибка возникает, если аргументов больше, чем скрытых столбцов в виртуальной таблице.</target>
        </trans-unit>
        <trans-unit id="90539d8182e17636548ae12105ee212ec9b16743" translate="yes" xml:space="preserve">
          <source>As SQLite developers edit the SQLite source code, they run the &lt;a href=&quot;https://sqlite.org/src/file/tool/speed-check.sh&quot;&gt;speed-check.sh&lt;/a&gt; shell script to track the performance impact of changes. This script compiles the speedtest1.c program, runs it under cachegrind, processes the cachegrind output using the &lt;a href=&quot;https://sqlite.org/src/file/tool/cg_anno.tcl&quot;&gt;cg_anno.tcl&lt;/a&gt; TCL script, then saves the results in a series of text files. Typical output from the speed-check.sh script looks like this:</source>
          <target state="translated">По мере того как разработчики SQLite редактируют исходный код SQLite, они запускают &lt;a href=&quot;https://sqlite.org/src/file/tool/speed-check.sh&quot;&gt;сценарий&lt;/a&gt; оболочки speed-check.sh для отслеживания влияния изменений на производительность. Этот сценарий компилирует программу speedtest1.c, запускает ее под управлением cachegrind, обрабатывает вывод cachegrind с помощью &lt;a href=&quot;https://sqlite.org/src/file/tool/cg_anno.tcl&quot;&gt;сценария&lt;/a&gt; TCL cg_anno.tcl , а затем сохраняет результаты в серии текстовых файлов. Типичный вывод скрипта speed-check.sh выглядит так:</target>
        </trans-unit>
        <trans-unit id="7ed7acd0a6e6b88f39315ac5d476eef951a2dd64" translate="yes" xml:space="preserve">
          <source>As a REAL value that is the fractional &lt;a href=&quot;https://en.wikipedia.org/wiki/Julian_day&quot;&gt;Julian day number&lt;/a&gt;.</source>
          <target state="translated">Как РЕАЛЬНОЕ значение, которое является дробным &lt;a href=&quot;https://en.wikipedia.org/wiki/Julian_day&quot;&gt;числом юлианского дня&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a4eeeee2e0c94cffee5c99d0db2b5529b4ec1659" translate="yes" xml:space="preserve">
          <source>As a TEXT string in the ISO-8601 format. Example: '2018-04-02 12:13:46'.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e71c00fe61fb07ca9e09493bb8ec226ec4260341" translate="yes" xml:space="preserve">
          <source>As a TEXT string in the ISO-8610 format. Example: '2018-04-02 12:13:46'.</source>
          <target state="translated">В виде строки TEXT в формате ISO-8610.Пример:'2018-04-02 12:13:46'.</target>
        </trans-unit>
        <trans-unit id="1f5eb53c0fa9975ea0940d4a4405ff35765d1d45" translate="yes" xml:space="preserve">
          <source>As a performance optimization, reduce actions in the Lemon input grammar are allowed to contain comments of the form &quot;/*A-overwrites-Z*/&quot; to indicate that the semantic value &quot;A&quot; on the right-hand side of the rule is allowed to directly overwrite the semantic value &quot;Z&quot; on the left-hand side. This simple optimization reduces the number of stack operations in the push-down automaton used to parse the input grammar, and thus improve performance of the parser. It also makes the generated code a little smaller.</source>
          <target state="translated">В качестве оптимизации производительности,уменьшающие действия во входной грамматике Лемона разрешаются содержать комментарии формы &quot;/*A-overwrites-Z*/&quot; для указания,что семантическое значение &quot;A&quot; в правой части правила разрешается непосредственно перезаписывать семантическое значение &quot;Z&quot; в левой части.Такая простая оптимизация уменьшает количество операций стека в выталкивающем автомате,используемом для разбора входной грамматики,и,таким образом,повышает производительность парсера.Это также делает сгенерированный код немного меньше.</target>
        </trans-unit>
        <trans-unit id="7bcc1829db91ffdb7536f92aca2feacdc8bcb274" translate="yes" xml:space="preserve">
          <source>As an FTS5 bareword that is not &quot;AND&quot;, &quot;OR&quot; or &quot;NOT&quot; (case sensitive). An FTS5 bareword is a string of one or more consecutive characters that are all either:</source>
          <target state="translated">В качестве голого слова FTS5,которое не является &quot;И&quot;,&quot;ИЛИ&quot; или &quot;НЕ&quot; (с учетом регистра).Голое слово FTS5-это строка,состоящая из одного или нескольких последовательных символов:</target>
        </trans-unit>
        <trans-unit id="3f6cab6c41155dd3c9ab5be0d8403065e3d7dbaf" translate="yes" xml:space="preserve">
          <source>As an INTEGER number of seconds since 1970 (also known as &quot;unix time&quot;).</source>
          <target state="translated">В качестве INTEGER число секунд с 1970 года (также известный как &quot;уникс-время&quot;).</target>
        </trans-unit>
        <trans-unit id="32bbd071581bca01328b9dfe1b573f6b34f404d8" translate="yes" xml:space="preserve">
          <source>As an alternative to step 3 above, the transaction may be rolled back. Transaction rollback is described in section</source>
          <target state="translated">В качестве альтернативы шагу 3 выше,сделка может быть откат.Откат транзакции описан в разделе</target>
        </trans-unit>
        <trans-unit id="71c1a7847b731be97050a398f7845485ca21aaa1" translate="yes" xml:space="preserve">
          <source>As an example of how UPDATE-FROM can be useful, suppose you have a point-of-sale application that accumulates purchases in the SALES table. At the end of the day, you want to adjust the INVENTORY table according to the daily sales. To do this, you can run an UPDATE against the INVENTORY table that adjusts the quantity by the aggregated sales for the day. The statement would look like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="131746c3b1aff392f599c85628677c24f8811860" translate="yes" xml:space="preserve">
          <source>As an example of the result table format, suppose a query result is as follows:</source>
          <target state="translated">В качестве примера формата таблицы результатов предположим,что результат запроса следующий:</target>
        </trans-unit>
        <trans-unit id="592d95d98cfd4f715eed1be5091215e09168934a" translate="yes" xml:space="preserve">
          <source>As an example, consider a virtual table implementation that provides read-only access to existing comma-separated-value (CSV) files on disk. There is no backing store that needs to be created or initialized for such a virtual table (since the CSV files already exist on disk) so the xCreate and xConnect methods will be identical for that module.</source>
          <target state="translated">В качестве примера рассмотрим реализацию виртуальной таблицы,которая обеспечивает доступ только на чтение к существующим на диске файлам с разделенными запятыми значениями (CSV).Для такой виртуальной таблицы нет бэк-хранилища,которое нужно создать или инициализировать (поскольку CSV-файлы уже существуют на диске),поэтому методы xCreate и xConnect будут идентичны для этого модуля.</target>
        </trans-unit>
        <trans-unit id="0e3486a0e62ced4a8499838d1b8b7393bbcb9f1f" translate="yes" xml:space="preserve">
          <source>As an example, consider creating a two-dimensional R*Tree index for use in spatial queries:</source>
          <target state="translated">В качестве примера рассмотрим создание двумерного R*Tree индекса для использования в пространственных запросах:</target>
        </trans-unit>
        <trans-unit id="1f3a827b13a126faa4b33b0ce651746d14a8fc48" translate="yes" xml:space="preserve">
          <source>As an example, consider the following query:</source>
          <target state="translated">В качестве примера рассмотрим следующий запрос:</target>
        </trans-unit>
        <trans-unit id="22e02419a6c1aa60126918f747f9d30c0add3ddc" translate="yes" xml:space="preserve">
          <source>As an example, consider the following table that tracks dollar-amount changes on various &quot;accounts&quot;:</source>
          <target state="translated">В качестве примера рассмотрим следующую таблицу,в которой отслеживаются изменения курса доллара на различных &quot;счетах&quot;:</target>
        </trans-unit>
        <trans-unit id="9685f258b372a754415995a52cb6b9f9c3a80f7a" translate="yes" xml:space="preserve">
          <source>As an example, suppose someone (perhaps a customer) asks you: &quot;What ever became of that 'prefer-coroutine-sort-subquery' branch from two years ago?&quot; You might try to answer the query by consulting the history in your version control system, thusly:</source>
          <target state="translated">В качестве примера,предположим,что кто-то (возможно,клиент)спросит вас:&quot;Что стало с тем филиалом &quot;Предпочтение-коррект-сорт-субвери&quot; двухлетней давности?&quot; Таким образом,вы можете попытаться ответить на этот вопрос,посмотрев историю в вашей системе контроля версий:</target>
        </trans-unit>
        <trans-unit id="34ff54cf6acce621207ec9ac9f6485fedf9ef893" translate="yes" xml:space="preserve">
          <source>As an example, the following graphic:</source>
          <target state="translated">В качестве примера можно привести следующий график:</target>
        </trans-unit>
        <trans-unit id="d8a7709446ce5823dd6ac2917092a6664f0dbd82" translate="yes" xml:space="preserve">
          <source>As an example, the following setup causes TCL to throw an error if an SQL statement contains an parameter that does not match any global TCL variable:</source>
          <target state="translated">В качестве примера можно привести следующую установку,при которой TCL выдает ошибку,если SQL-оператор содержит параметр,не совпадающий ни с одной глобальной переменной TCL:</target>
        </trans-unit>
        <trans-unit id="0ed757795f16facadb1fc50b83304333bb04670f" translate="yes" xml:space="preserve">
          <source>As an example, the following table show the relative sizes for an SQLite Archive, a ZIP Archive, and a Tarball of the 1,743 files in the SQLite 3.22.0 source tree:</source>
          <target state="translated">В качестве примера в следующей таблице показаны относительные размеры для SQLite Archive,ZIP Archive и Tarball из 1743 файлов в исходном дереве SQLite 3.22.0:</target>
        </trans-unit>
        <trans-unit id="9d15dfd61e0635160b8312b26c2789af818a9391" translate="yes" xml:space="preserve">
          <source>As an ordinary SQLite table, &quot;wordcount&quot; is implemented as two separate B-Trees. The main table uses the hidden rowid value as the key and stores the &quot;word&quot; and &quot;cnt&quot; columns as data. The &quot;TEXT PRIMARY KEY&quot; phrase of the CREATE TABLE statement causes the creation of an &lt;a href=&quot;lang_createindex#uniqueidx&quot;&gt;unique index&lt;/a&gt; on the &quot;word&quot; column. This index is a separate B-Tree that uses &quot;word&quot; and the &quot;rowid&quot; as the key and stores no data at all. Note that the complete text of every &quot;word&quot; is stored twice: once in the main table and again in the index.</source>
          <target state="translated">Как обычная таблица SQLite, &amp;laquo;wordcount&amp;raquo; реализована как два отдельных B-дерева. Основная таблица использует скрытое значение rowid в качестве ключа и хранит столбцы &amp;laquo;word&amp;raquo; и &amp;laquo;cnt&amp;raquo; как данные. Фраза &amp;laquo;TEXT PRIMARY KEY&amp;raquo; оператора CREATE TABLE вызывает создание &lt;a href=&quot;lang_createindex#uniqueidx&quot;&gt;уникального индекса&lt;/a&gt; для столбца &amp;laquo;word&amp;raquo;. Этот индекс представляет собой отдельное B-дерево, которое использует &amp;laquo;слово&amp;raquo; и &amp;laquo;идентификатор строки&amp;raquo; в качестве ключа и не хранит вообще никаких данных. Обратите внимание, что полный текст каждого &amp;laquo;слова&amp;raquo; сохраняется дважды: один раз в основной таблице и еще раз в индексе.</target>
        </trans-unit>
        <trans-unit id="8276f7702973f7730b88b6137faf5d630b77f015" translate="yes" xml:space="preserve">
          <source>As before, SQLite does single binary search for the range of rows in the covering index that satisfy the WHERE clause, the scans that range from top to bottom to get the desired results. The rows that satisfy the WHERE clause are guaranteed to be adjacent since the WHERE clause is an equality constraint on the left-most column of the index. And by scanning the matching index rows from top to bottom, the output is guaranteed to be ordered by state since the state column is the very next column to the right of the fruit column. And so the resulting query is very efficient.</source>
          <target state="translated">Как и прежде,SQLite выполняет одиночный двоичный поиск диапазона строк в покрывающем индексе,удовлетворяющих выражению WHERE,сканирование диапазона сверху вниз для получения желаемого результата.Строки,удовлетворяющие выражению WHERE,гарантированно будут соседними,так как выражение WHERE является ограничением на равенство в самом левом столбце индекса.И при сканировании соответствующих строк индекса сверху вниз гарантируется,что результат будет упорядочен по состоянию,так как столбец состояния-это самый ближайший столбец справа от столбца фруктов.И поэтому полученный запрос очень эффективен.</target>
        </trans-unit>
        <trans-unit id="15882cefbefb220ce1658791117147edd8cba359" translate="yes" xml:space="preserve">
          <source>As before, the Column instruction uses cursor P1 and pushes the data record in column P2 (1, column &quot;two&quot;) onto the stack. The Integer instruction pushes the value 50 onto the top of the stack. After these two instructions the stack looks like:</source>
          <target state="translated">Как и раньше,инструкция &quot;Столбец&quot; использует курсор P1 и толкает запись данных в столбце P2 (1,столбец &quot;два&quot;)на стек.Целочисленная команда выталкивает значение 50 на вершину стека.После этих двух инструкций стек выглядит так:</target>
        </trans-unit>
        <trans-unit id="6c0707574912e68bc0443d44af5e83d6ee57452b" translate="yes" xml:space="preserve">
          <source>As before, the second insert on the left will fail because the comparison will convert both strings into floating-point number first and the only difference in the strings is in the 20-th digit which exceeds the resolution of a 64-bit float. In contrast, the second insert on the right will work because in that case, the numbers being inserted are strings and are compared using memcmp().</source>
          <target state="translated">Как и прежде,вторая вставка слева будет неудачной,так как при сравнении обе строки будут сначала преобразованы в число с плавающей точкой,а единственная разница в строках-в 20-ю цифру,которая превышает разрешение 64-битного плавающего числа.Напротив,вторая вставка справа будет работать,так как в этом случае вставляемые числа являются строками и сравниваются с помощью функции memcmp().</target>
        </trans-unit>
        <trans-unit id="021a9e62497cd6d1534e29c131c8485644cff8ee" translate="yes" xml:space="preserve">
          <source>As can be seen above, a single run of multitest.tcl invokes th3make dozens of times and takes between 12 and 24 CPU hours. The middle section of the output shows the arguments to each individual th3make run and the result and elapse time for that th3make. All build products and output for the separate th3make runs are captures in subdirectories for post-test analysis. The two-line summary at the bottom shows the total number of errors and tests over all th3make runs and the total elapse time, together with the &lt;a href=&quot;c3ref/c_source_id&quot;&gt;SQLITE_SOURCE_ID&lt;/a&gt; information for the version of SQLite that was tested. This summary information is recorded in the &lt;a href=&quot;https://www.sqlite.org/checklists&quot;&gt;release checklist&lt;/a&gt; during final testing.</source>
          <target state="translated">Как видно выше, один запуск multitest.tcl вызывает th3make десятки раз и занимает от 12 до 24 часов ЦП. В средней части вывода показаны аргументы для каждого отдельного запуска th3make, а также результат и время истечения этого th3make. Все продукты сборки и выходные данные для отдельных запусков th3make фиксируются в подкаталогах для анализа после тестирования. Двухстрочная сводка внизу показывает общее количество ошибок и тестов по всем запускам th3make и общее время, вместе с информацией &lt;a href=&quot;c3ref/c_source_id&quot;&gt;SQLITE_SOURCE_ID&lt;/a&gt; для версии SQLite, которая была протестирована. Эта сводная информация записывается в &lt;a href=&quot;https://www.sqlite.org/checklists&quot;&gt;контрольный список выпуска&lt;/a&gt; во время финального тестирования.</target>
        </trans-unit>
        <trans-unit id="a57eec57195e396346032e284f403497e2a6ca2c" translate="yes" xml:space="preserve">
          <source>As far as we can tell, the SQL language specification allows the use of manifest typing. Nevertheless, most other SQL database engines are statically typed and so some people feel that the use of manifest typing is a bug in SQLite. But the authors of SQLite feel very strongly that this is a feature. The use of manifest typing in SQLite is a deliberate design decision which has proven in practice to make SQLite more reliable and easier to use, especially when used in combination with dynamically typed programming languages such as Tcl and Python.</source>
          <target state="translated">Насколько можно судить,спецификация языка SQL позволяет использовать манифестный набор текста.Тем не менее,большинство других движков баз данных SQL статически набраны,и поэтому некоторые люди считают,что использование манифестной печати является ошибкой в SQLite.Но авторы SQLite очень сильно чувствуют,что это особенность.Использование манифестной печати в SQLite-это продуманное проектное решение,которое доказало на практике,что делает SQLite более надежным и простым в использовании,особенно при использовании в сочетании с такими динамически типизированными языками программирования,как Tcl и Python.</target>
        </trans-unit>
        <trans-unit id="fc29e0fdbff3d25477a8e029f9259bac6f50556e" translate="yes" xml:space="preserve">
          <source>As for all other SQLite tables, virtual or otherwise, data is retrieved from FTS tables using a &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statement.</source>
          <target state="translated">Как и для всех других таблиц SQLite, виртуальных или иных, данные извлекаются из таблиц FTS с помощью &lt;a href=&quot;lang_select&quot;&gt;оператора SELECT&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e10a21db398e4cbe3920a0271ec03a17da9374a2" translate="yes" xml:space="preserve">
          <source>As in &lt;a href=&quot;#section_3_11&quot;&gt;section 3.11&lt;/a&gt;, the journal file might be truncated to zero length or its header might be overwritten with zeros as an optimization on systems where deleting a file is expensive. Either way, the journal is no longer hot after this step.</source>
          <target state="translated">Как и в &lt;a href=&quot;#section_3_11&quot;&gt;разделе 3.11&lt;/a&gt; , файл журнала может быть усечен до нулевой длины или его заголовок может быть перезаписан нулями в качестве оптимизации в системах, в которых удаление файла обходится дорого. В любом случае после этого шага журнал перестает быть горячим.</target>
        </trans-unit>
        <trans-unit id="4a052665302d7ed15dacb760a0e1d99f7e61c18a" translate="yes" xml:space="preserve">
          <source>As in the INSERT example, we push the database number P1 (0, the main database) onto the stack and use OpenWrite to open the cursor P1 on table P2 (base page 3, &quot;examp&quot;) for modification.</source>
          <target state="translated">Как и в примере INSERT,нажимаем номер БД P1 (0,основная БД)на стек и с помощью OpenWrite открываем курсор P1 на таблице P2 (базовая страница 3,&quot;экзамен&quot;)для модификации.</target>
        </trans-unit>
        <trans-unit id="493b86f021b95461d337801ffc16a105b55e8b55" translate="yes" xml:space="preserve">
          <source>As in the SELECT example, the &lt;a href=&quot;opcode#Rewind&quot;&gt;Rewind&lt;/a&gt; instruction rewinds the cursor to the beginning of the table, readying it for use in the loop body.</source>
          <target state="translated">Как и в примере SELECT, инструкция &lt;a href=&quot;opcode#Rewind&quot;&gt;Rewind&lt;/a&gt; перематывает курсор в начало таблицы, подготавливая его для использования в теле цикла.</target>
        </trans-unit>
        <trans-unit id="164cc333da63b4862e96f8a93857b770263a0e06" translate="yes" xml:space="preserve">
          <source>As is the case for a</source>
          <target state="translated">Как и в случае с</target>
        </trans-unit>
        <trans-unit id="ed24902923099bb89f817d03e0f964e2ddf3fe73" translate="yes" xml:space="preserve">
          <source>As its name implies, an R*Tree is organized as a tree. Each node of the tree is a bounding box. The root of the tree is a bounding box that encapsulates all elements of the tree. Beneath the root are a number of subtrees (typically 20 or more) each with their own smaller bounding boxes and each containing some subset of the R*Tree entries. The subtrees may have sub-subtrees, and so forth until finally one reaches the leaves of the tree which are the actual R*Tree entries.</source>
          <target state="translated">Как следует из названия,R*Tree организовано как дерево.Каждый узел дерева представляет собой ограничивающую рамку.Корень дерева представляет собой ограничивающую рамку,которая инкапсулирует все элементы дерева.Под корнем находится несколько поддеревьев (обычно 20 и более),каждое из которых имеет свои меньшие по размеру ограничивающие рамки,и каждое из них содержит некоторое подмножество элементов R*Tree.Поддеревья могут иметь поддеревья и т.д.до тех пор,пока,наконец,не дойдут до листьев дерева,которые являются действительными элементами R*Tree.</target>
        </trans-unit>
        <trans-unit id="1329f3ec0fa61448c27dc490e807fec1b74fd581" translate="yes" xml:space="preserve">
          <source>As its name suggests, the &quot;close&quot; method to an SQLite database just closes the database. This has the side-effect of deleting the</source>
          <target state="translated">Как следует из названия,метод &quot;закрыть&quot; базу данных SQLite просто закрывает ее.Это имеет побочный эффект,заключающийся в удалении</target>
        </trans-unit>
        <trans-unit id="3b9e6df535e040569dafb3fcef3111ff226a3e67" translate="yes" xml:space="preserve">
          <source>As long as the buffer size is greater than zero, sqlite3_snprintf() guarantees that the buffer is always zero-terminated. The first parameter &quot;n&quot; is the total size of the buffer, including space for the zero terminator. So the longest string that can be completely written will be n-1 characters.</source>
          <target state="translated">Пока размер буфера больше нуля,sqlite3_snprintf()гарантирует,что буфер всегда будет нулевым.Первый параметр &quot;n&quot;-это общий размер буфера,включая место для нулевого терминатора.Таким образом,самая длинная строка,которая может быть полностью записана,будет состоять из n-1 символов.</target>
        </trans-unit>
        <trans-unit id="26ea5ee053d47ffa17dd452debb3d0d447e3ffce" translate="yes" xml:space="preserve">
          <source>As long as the input parameter is correct, these routines can only fail if an out-of-memory error occurs during a format conversion. Only the following subset of interfaces are subject to out-of-memory errors:</source>
          <target state="translated">До тех пор,пока входной параметр корректен,эти подпрограммы могут давать сбои только в том случае,если при преобразовании формата возникает ошибка вне памяти.Ошибкам вне памяти подвержены только следующие подмножества интерфейсов:</target>
        </trans-unit>
        <trans-unit id="bc7938d9d029402b8371ec96dc41a03cdd95d8f8" translate="yes" xml:space="preserve">
          <source>As long as the input parameters are correct, these routines will only fail if an out-of-memory error occurs during a format conversion. Only the following subset of interfaces are subject to out-of-memory errors:</source>
          <target state="translated">До тех пор,пока входные параметры корректны,эти подпрограммы будут давать сбои только в том случае,если во время преобразования формата произойдет ошибка вне памяти.Ошибкам вне памяти подвержены только следующие подмножества интерфейсов:</target>
        </trans-unit>
        <trans-unit id="af3758ac84a3f79558343e605f45f43dad96f8ef" translate="yes" xml:space="preserve">
          <source>As new versions of SQLite are released, repeat steps 3.6 and 3.7 to add changes in the new release to the private branch. Additional private changes can be made on the private branch in between releases if desired.</source>
          <target state="translated">По мере выхода новых версий SQLite,повторите шаги 3.6 и 3.7,чтобы добавить изменения в новый релиз в личную ветку.Дополнительные частные изменения могут быть внесены в личную ветку в промежутках между релизами при желании.</target>
        </trans-unit>
        <trans-unit id="e442983efbc639e95659cc425a72881ca75f93d3" translate="yes" xml:space="preserve">
          <source>As noted above, there really is no such thing as a &quot;sqlite3_column()&quot; function in the SQLite API. Instead, what we here call &quot;sqlite3_column()&quot; is a place-holder for an entire family of functions that return a value from the result set in various data types. There are also routines in this family that return the size of the result (if it is a string or BLOB) and the number of columns in the result set.</source>
          <target state="translated">Как было отмечено выше,в SQLite API действительно нет такой функции,как &quot;sqlite3_column()&quot;.Вместо этого,то,что мы здесь называем &quot;sqlite3_column()&quot;-это месторасположение для целого семейства функций,возвращающих значение из результата,заданного в различных типах данных.В этом семействе также есть подпрограммы,которые возвращают размер результата (если это строка или BLOB)и количество столбцов в результирующем множестве.</target>
        </trans-unit>
        <trans-unit id="f7f8a41bee17850d3fdbafd1837635d4f3b48596" translate="yes" xml:space="preserve">
          <source>As of 2017-03-12, you must use Fossil version 2.0 or later for the following instructions to work. The SQLite repository started using artifacts named using SHA3 hashes instead of SHA1 hashes on that date, and Fossil 2.0 or later is needed in order to understand the new SHA3 hashes. To find out what version of Fossil you are running, type &quot;fossil -v&quot;.</source>
          <target state="translated">С 2017-03-12 гг.для работы необходимо использовать ископаемое исполнение 2.0 или более позднюю версию.В репозитории SQLite на эту дату начали использовать артефакты,названные с использованием SHA3-хэшей вместо SHA1-хэшей,а для понимания новых SHA3-хэшей необходимо использовать Fossil 2.0 или более позднюю версию.Чтобы узнать,какую версию &quot;Fossil&quot; вы используете,наберите &quot;fossil -v&quot;.</target>
        </trans-unit>
        <trans-unit id="46e28b72fbe9e739630682b02359c85a23e23fe2" translate="yes" xml:space="preserve">
          <source>As of 2018-05-19, the TH3 source tree consists and well over 500,000 lines of source code in 1709 separate files.</source>
          <target state="translated">По состоянию на 2018-05-19 годы дерево исходных текстов TH3 состоит из более 500 000 строк исходного кода в 1709 отдельных файлах.</target>
        </trans-unit>
        <trans-unit id="32045934e18d7d7235684ae81bb4ad3e112f0c5b" translate="yes" xml:space="preserve">
          <source>As of 2019-03-20, there is now an &lt;a href=&quot;https://github.com/sqlite/sqlite&quot;&gt;official Git mirror&lt;/a&gt; of the SQLite sources on GitHub.</source>
          <target state="translated">По состоянию на 20 марта 2019 года на GitHub есть &lt;a href=&quot;https://github.com/sqlite/sqlite&quot;&gt;официальное зеркало Git&lt;/a&gt; с исходными кодами SQLite.</target>
        </trans-unit>
        <trans-unit id="3e28505b65fc1d015c678e6ae0f3c3ddff268608" translate="yes" xml:space="preserve">
          <source>As of &lt;a href=&quot;https://sqlite.org/releaselog/3_29_0.html&quot;&gt;version 3.29.0&lt;/a&gt; (2019-07-10), the SQLite library consists of approximately 138.9 KSLOC of C code. (KSLOC means thousands of &quot;Source Lines Of Code&quot; or, in other words, lines of code excluding blank lines and comments.) By comparison, the project has 662 times as much test code and test scripts - 91946.2 KSLOC.</source>
          <target state="translated">Начиная с &lt;a href=&quot;https://sqlite.org/releaselog/3_29_0.html&quot;&gt;версии 3.29.0&lt;/a&gt; (10.07.2019), библиотека SQLite состоит примерно из 138,9 KSLOC кода C. (KSLOC означает тысячи &amp;laquo;строк исходного кода&amp;raquo; или, другими словами, строк кода, исключая пустые строки и комментарии.) Для сравнения, в проекте в 662 раза больше тестового кода и тестовых скриптов - 91946,2 KSLOC.</target>
        </trans-unit>
        <trans-unit id="2f1c2b6d73cf26867292aed34f667ddc2bada8a1" translate="yes" xml:space="preserve">
          <source>As of &lt;a href=&quot;https://sqlite.org/releaselog/3_33_0.html&quot;&gt;version 3.33.0&lt;/a&gt; (2020-08-14), the SQLite library consists of approximately 143.4 KSLOC of C code. (KSLOC means thousands of &quot;Source Lines Of Code&quot; or, in other words, lines of code excluding blank lines and comments.) By comparison, the project has 640 times as much test code and test scripts - 91911.0 KSLOC.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a53c8d218bf20b0261060ea362ee56f13c07c935" translate="yes" xml:space="preserve">
          <source>As of &lt;a href=&quot;https://sqlite.org/releaselog/3_6_19.html&quot;&gt;version 3.6.19&lt;/a&gt; (2009-10-14), SQLite supports &lt;a href=&quot;foreignkeys&quot;&gt;foreign key constraints&lt;/a&gt;. But enforcement of foreign key constraints is turned off by default (for backwards compatibility). To enable foreign key constraint enforcement, run &lt;a href=&quot;pragma#pragma_foreign_keys&quot;&gt;PRAGMA foreign_keys=ON&lt;/a&gt; or compile with &lt;a href=&quot;compile#default_foreign_keys&quot;&gt;-DSQLITE_DEFAULT_FOREIGN_KEYS=1&lt;/a&gt;.</source>
          <target state="translated">Начиная с &lt;a href=&quot;https://sqlite.org/releaselog/3_6_19.html&quot;&gt;версии 3.6.19&lt;/a&gt; (2009-10-14), SQLite поддерживает &lt;a href=&quot;foreignkeys&quot;&gt;ограничения внешнего ключа&lt;/a&gt; . Но принудительное применение ограничений внешнего ключа по умолчанию отключено (для обратной совместимости). Чтобы включить принудительное применение ограничений внешнего ключа, запустите &lt;a href=&quot;pragma#pragma_foreign_keys&quot;&gt;PRAGMA foreign_keys = ON&lt;/a&gt; или скомпилируйте с &lt;a href=&quot;compile#default_foreign_keys&quot;&gt;-DSQLITE_DEFAULT_FOREIGN_KEYS = 1&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="836b2728d9d516fbe942ba314e801009ae9980b0" translate="yes" xml:space="preserve">
          <source>As of &lt;a href=&quot;https://sqlite.org/releaselog/3_7_6.html&quot;&gt;version 3.7.6&lt;/a&gt; (2011-04-12), SQLite includes a new virtual table module called &quot;fts4aux&quot;, which can be used to inspect the full-text index of an existing FTS table directly. Despite its name, fts4aux works just as well with FTS3 tables as it does with FTS4 tables. Fts4aux tables are read-only. The only way to modify the contents of an fts4aux table is by modifying the contents of the associated FTS table. The fts4aux module is automatically included in all &lt;a href=&quot;fts3#compiling_and_enabling_fts3_and_fts4&quot;&gt;builds that include FTS&lt;/a&gt;.</source>
          <target state="translated">Начиная с &lt;a href=&quot;https://sqlite.org/releaselog/3_7_6.html&quot;&gt;версии 3.7.6&lt;/a&gt; (2011-04-12), SQLite включает новый модуль виртуальной таблицы под названием &amp;laquo;fts4aux&amp;raquo;, который можно использовать для непосредственной проверки полнотекстового индекса существующей таблицы FTS. Несмотря на свое название, fts4aux работает с таблицами FTS3 так же хорошо, как и с таблицами FTS4. Таблицы Fts4aux доступны только для чтения. Единственный способ изменить содержимое таблицы fts4aux - это изменить содержимое связанной таблицы FTS. Модуль fts4aux автоматически включается во все &lt;a href=&quot;fts3#compiling_and_enabling_fts3_and_fts4&quot;&gt;сборки, которые включают FTS&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9d225f240bc36e795cb50632150d857ce4c4d78e" translate="yes" xml:space="preserve">
          <source>As of &lt;a href=&quot;https://sqlite.org/releaselog/3_9_0.html&quot;&gt;version 3.9.0&lt;/a&gt; (2015-10-14), FTS5 is included as part of the SQLite &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt;. If using one of the two autoconf build system, FTS5 is enabled by specifying the &quot;--enable-fts5&quot; option when running the configure script. (FTS5 is currently disabled by default for the source-tree configure script and enabled by default for the amalgamation configure script, but these defaults might change in the future.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03eb89fc06866a1260f6276654306363ba727d94" translate="yes" xml:space="preserve">
          <source>As of &lt;a href=&quot;https://sqlite.org/releaselog/3_9_0.html&quot;&gt;version 3.9.0&lt;/a&gt; (2015-10-14), FTS5 is included as part of the SQLite &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt;. It is disabled by default. If using the two autoconf build system, it is enabled by specifying the &quot;--enable-fts5&quot; option when running the configure script.</source>
          <target state="translated">Начиная с &lt;a href=&quot;https://sqlite.org/releaselog/3_9_0.html&quot;&gt;версии 3.9.0&lt;/a&gt; (2015-10-14), FTS5 включен как часть &lt;a href=&quot;amalgamation&quot;&gt;объединения&lt;/a&gt; SQLite . По умолчанию он отключен. Если используется система сборки с двумя автоконфигурациями, она включается указанием опции &amp;laquo;--enable-fts5&amp;raquo; при запуске скрипта настройки.</target>
        </trans-unit>
        <trans-unit id="0cba18acfc338d803dd183b86646f960bc3ebd65" translate="yes" xml:space="preserve">
          <source>As of SQLite 3.16.0 (2017-01-02), the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; contains a dot-command &quot;.imposter&quot; that does all of the work of setting up a transient imposter table. Instead of making multiple calls to sqlite3_test_control() and figuring out and invoking a compatible CREATE TABLE statement, a transient imposter table can be constructed as follows:</source>
          <target state="translated">Начиная с SQLite 3.16.0 (02.01.2017), &lt;a href=&quot;cli&quot;&gt;оболочка командной строки&lt;/a&gt; содержит команду с точкой &quot;.imposter&quot;, которая выполняет всю работу по настройке временной таблицы самозванца. Вместо того, чтобы делать несколько вызовов sqlite3_test_control () и выяснять и вызывать совместимый оператор CREATE TABLE, временную таблицу самозванца можно построить следующим образом:</target>
        </trans-unit>
        <trans-unit id="98a2e1c87379924c2c171b5738373e64a2f944b7" translate="yes" xml:space="preserve">
          <source>As of SQLite 3.27.0 (2019-02-07) the use of a double-quoted string literal causes a warning message to be sent to the &lt;a href=&quot;errlog&quot;&gt;error log&lt;/a&gt;.</source>
          <target state="translated">Начиная с SQLite 3.27.0 (07.02.2019) использование строкового литерала в двойных кавычках вызывает отправку предупреждающего сообщения в &lt;a href=&quot;errlog&quot;&gt;журнал ошибок&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="477279c68e157e3c69007f56a275a12b81ee766f" translate="yes" xml:space="preserve">
          <source>As of SQLite 3.29.0 (2019-07-10) the use of double-quoted string literals can be disabled at run-time using the &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigdqsddl&quot;&gt;SQLITE_DBCONFIG_DQS_DDL&lt;/a&gt; and &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigdqsdml&quot;&gt;SQLITE_DBCONFIG_DQS_DML&lt;/a&gt; actions to &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config()&lt;/a&gt;. The default settings can be altered at compile-time using the &lt;a href=&quot;compile#dqs&quot;&gt;-DSQLITE_DQS=&lt;i&gt;N&lt;/i&gt;&lt;/a&gt; compile-time option. Application developers are encouraged to compile using -DSQLITE_DQS=0 in order to disable the double-quoted string literal misfeature by default. If that is not possible, then disable double-quoted string literals for individual database connections using C-code like this:</source>
          <target state="translated">Начиная с SQLite 3.29.0 (2019-07-10) использование строковых литералов в двойных кавычках можно отключить во время выполнения с помощью &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigdqsddl&quot;&gt;действий SQLITE_DBCONFIG_DQS_DDL&lt;/a&gt; и &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigdqsdml&quot;&gt;SQLITE_DBCONFIG_DQS_DML&lt;/a&gt; для &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config ()&lt;/a&gt; . Настройки по умолчанию можно изменить во время компиляции, используя параметр &lt;a href=&quot;compile#dqs&quot;&gt;-DSQLITE_DQS = &lt;i&gt;N во время&lt;/i&gt;&lt;/a&gt; компиляции. Разработчикам приложений рекомендуется компилировать с использованием -DSQLITE_DQS = 0, чтобы по умолчанию отключить неправильную строковую литералу в двойных кавычках. Если это невозможно, отключите строковые литералы в двойных кавычках для отдельных подключений к базе данных, используя C-код, например:</target>
        </trans-unit>
        <trans-unit id="27ccd6edc0578e2c50724724d1f7e72fc2202881" translate="yes" xml:space="preserve">
          <source>As of SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_11_0.html&quot;&gt;version 3.11.0&lt;/a&gt; (2016-02-15), the WAL file for a single transaction should be proportional in size to the transaction itself. Pages that are changed by the transaction should only be written into the WAL file once. However, with older versions of SQLite, the same page might be written into the WAL file multiple times if the transaction grows larger than the page cache.</source>
          <target state="translated">Начиная с &lt;a href=&quot;https://sqlite.org/releaselog/3_11_0.html&quot;&gt;версии&lt;/a&gt; SQLite 3.11.0 (15.02.2016), размер файла WAL для отдельной транзакции должен быть пропорционален самой транзакции. Страницы, измененные транзакцией, должны быть записаны в файл WAL только один раз. Однако в более старых версиях SQLite одна и та же страница может быть записана в файл WAL несколько раз, если размер транзакции превышает размер кеша страницы.</target>
        </trans-unit>
        <trans-unit id="9002d4afcf5621573059e14d645945f49cc82521" translate="yes" xml:space="preserve">
          <source>As of SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_6_1.html&quot;&gt;version 3.6.1&lt;/a&gt; (2008-08-06), the soft heap limit only applies to the general-purpose memory allocator. The soft heap limit does not know about or interact with the &lt;a href=&quot;malloc#pagecache&quot;&gt;pagecache memory allocator&lt;/a&gt; or the &lt;a href=&quot;malloc#lookaside&quot;&gt;lookaside memory allocator&lt;/a&gt;. This deficiency will likely be addressed in a future release.</source>
          <target state="translated">Начиная с &lt;a href=&quot;https://sqlite.org/releaselog/3_6_1.html&quot;&gt;версии&lt;/a&gt; SQLite 3.6.1 (2008-08-06), ограничение мягкой кучи применяется только к универсальному распределителю памяти. Предел мягкой кучи не знает и не взаимодействует с &lt;a href=&quot;malloc#pagecache&quot;&gt;распределителем памяти кэша подкачки&lt;/a&gt; или дополнительным &lt;a href=&quot;malloc#lookaside&quot;&gt;распределителем памяти&lt;/a&gt; . Этот недостаток, вероятно, будет исправлен в следующем выпуске.</target>
        </trans-unit>
        <trans-unit id="b175c36534eb0163084a39638e664737aba3d613" translate="yes" xml:space="preserve">
          <source>As of SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_6_19.html&quot;&gt;version 3.6.19&lt;/a&gt;, the default setting for foreign key enforcement is OFF. However, that might change in a future release of SQLite. The default setting for foreign key enforcement can be specified at compile-time using the &lt;a href=&quot;compile#default_foreign_keys&quot;&gt;SQLITE_DEFAULT_FOREIGN_KEYS&lt;/a&gt; preprocessor macro. To minimize future problems, applications should set the foreign key enforcement flag as required by the application and not depend on the default setting.</source>
          <target state="translated">Начиная с &lt;a href=&quot;https://sqlite.org/releaselog/3_6_19.html&quot;&gt;версии&lt;/a&gt; SQLite 3.6.19 , по умолчанию для принудительного применения внешнего ключа установлено значение OFF. Однако это может измениться в будущей версии SQLite. Настройка по умолчанию для принудительного применения внешнего ключа может быть указана во время компиляции с помощью &lt;a href=&quot;compile#default_foreign_keys&quot;&gt;макроса&lt;/a&gt; препроцессора SQLITE_DEFAULT_FOREIGN_KEYS . Чтобы свести к минимуму проблемы в будущем, приложения должны устанавливать флаг принудительного применения внешнего ключа в соответствии с требованиями приложения и не зависеть от настройки по умолчанию.</target>
        </trans-unit>
        <trans-unit id="0e6461cc943c138056429ef3ecea61d0043a0402" translate="yes" xml:space="preserve">
          <source>As of SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_9_0.html&quot;&gt;version 3.9.0&lt;/a&gt; (2015-10-14), the &lt;a href=&quot;sqldiff&quot;&gt;sqldiff&lt;/a&gt; utility is able to generate RBU databases representing the difference between two databases with identical schemas. For example, the following command:</source>
          <target state="translated">Начиная с &lt;a href=&quot;https://sqlite.org/releaselog/3_9_0.html&quot;&gt;версии&lt;/a&gt; SQLite 3.9.0 (2015-10-14), утилита &lt;a href=&quot;sqldiff&quot;&gt;sqldiff&lt;/a&gt; может создавать базы данных RBU, представляющие разницу между двумя базами данных с идентичными схемами. Например, следующая команда:</target>
        </trans-unit>
        <trans-unit id="dfbf6fd8aef52e316e037404ed7145e5b99ccf6d" translate="yes" xml:space="preserve">
          <source>As of SQLite version 3.21.0 (2017-10-24), the query planner will always prefer to use a co-routine to implement FROM-clause subqueries that contains an ORDER BY clause and that are not part of a join when the result set of the outer query is &quot;complex&quot;. This feature allows applications to shift expensive computations from before the sorter until after the sorter, which can result in faster operation. For example, consider this query:</source>
          <target state="translated">Начиная с версии SQLite 3.21.0 (2017-10-24),планировщик запросов всегда предпочитает использовать совместную маршрутизацию для реализации подзапросов FROM-clause,которые содержат пункт ORDER BY и не являются частью соединения,когда результирующий набор внешнего запроса является &quot;сложным&quot;.Эта особенность позволяет приложениям переносить дорогостоящие вычисления с момента,предшествующего сортировщику,на момент,предшествующий сортировщику,что может привести к более быстрой работе.Например,рассмотрим этот запрос:</target>
        </trans-unit>
        <trans-unit id="242b46186535aea87c089fafc2bda700b6f5e078" translate="yes" xml:space="preserve">
          <source>As of SQLite version 3.22.0, the &quot;sqlite_stat1&quot; table is an exception to some of the rules above. In SQLite, the schema of sqlite_stat1 is:</source>
          <target state="translated">Начиная с версии SQLite 3.22.0,таблица &quot;sqlite_stat1&quot; является исключением из некоторых правил,приведенных выше.В SQLite схема sqlite_stat1 есть:</target>
        </trans-unit>
        <trans-unit id="5ddb98490083a7f2dc1ca2a3b26fa7d781b747ca" translate="yes" xml:space="preserve">
          <source>As of this writing (2017-07-13), the completion virtual table only looks for SQL keywords, and schema, table, and column names. The context contained in $wholeline is completely ignored. Future enhancements will try to return new completions taken from function and pragma names and other sources, as well as consider more context. The completion table should be considered a work-in-progress.</source>
          <target state="translated">На момент написания статьи (2017-07-13),виртуальная таблица завершения ищет только ключевые слова SQL,а также имена схем,таблиц и столбцов.Контекст,содержащийся в $wholeline,полностью игнорируется.Будущие усовершенствования будут пытаться вернуть новые дополнения,взятые из имен функций и прагматических имён и других источников,а также учитывать больше контекста.Таблицу завершения следует считать незавершенной работой.</target>
        </trans-unit>
        <trans-unit id="b289cb5373e1ff5a5a0c905eb902dc91bdb7b556" translate="yes" xml:space="preserve">
          <source>As of this writing (2018-05-29) the only other recommended storage formats for datasets are XML, JSON, and CSV.</source>
          <target state="translated">На момент написания статьи (2018-05-29)единственными другими рекомендуемыми форматами хранения наборов данных являются XML,JSON и CSV.</target>
        </trans-unit>
        <trans-unit id="f2ad4e776d39a3ec2c252f71f4dae40cd1708a1c" translate="yes" xml:space="preserve">
          <source>As of this writing (2019-07-16), the SQLite developers have stopped using AFL for routine testing and instead are focused on running dbsqlfuzz. At least one instance of dbsqlfuzz is running on the latest SQLite source code at all times, in order to catch any new problems that might be introduced into the source tree as features are added and routine maintenance is performed.</source>
          <target state="translated">На момент написания этой статьи (2019-07-16)разработчики SQLite перестали использовать AFL для рутинного тестирования и вместо этого сосредоточились на запуске dbsqlfuzz.По крайней мере,один экземпляр dbsqlfuzz постоянно работает на новейших исходных кодах SQLite,чтобы выявить любые новые проблемы,которые могут быть введены в дерево исходных кодов по мере добавления функций и выполнения рутинного обслуживания.</target>
        </trans-unit>
        <trans-unit id="c36686a25a23f2cfaee766f9bfb5607ad00a8413" translate="yes" xml:space="preserve">
          <source>As one might expect, the amount of data read from the database file is minimized by caching portions of the database file in main memory. Additionally, multiple updates to the database file that are part of the same</source>
          <target state="translated">Как и следовало ожидать,объем данных,считываемых из файла БД,минимизируется за счет кэширования частей файла БД в оперативной памяти.Кроме того,несколько обновлений файла БД,которые являются частью одного и того же</target>
        </trans-unit>
        <trans-unit id="972efc3fd6678a6e105ba1a8f1aac17c41abd523" translate="yes" xml:space="preserve">
          <source>As part of opening a new</source>
          <target state="translated">В рамках открытия нового</target>
        </trans-unit>
        <trans-unit id="9b40d60a44eca2b862c669b4ece8404effe70c95" translate="yes" xml:space="preserve">
          <source>As part of the query planning process, SQLite enumerates all usable combinations of indexes and WHERE-clause constraints. For certain pathological queries, the number of these index-and-constraint combinations can be very large, resulting in slow performance by the query planner. The SQLITE_QUERY_PLANNER_LIMIT value (in conjunction with the related &lt;a href=&quot;compile#query_planner_limit_incr&quot;&gt;SQLITE_QUERY_PLANNER_LIMIT_INCR&lt;/a&gt; setting) limits the number of index-and-constraint combinations that the query planner will consider, in order to prevent the query planner from using excess CPU time. The default value for SQLITE_QUERY_PLANNER_LIMIT is set high enough so that is never reached for real-world queries. The query planner search limit only applies to queries that are deliberately crafted to use excess planning time.</source>
          <target state="translated">В рамках процесса планирования запроса SQLite перечисляет все используемые комбинации индексов и ограничений предложения WHERE. Для некоторых патологических запросов количество этих комбинаций индекса и ограничения может быть очень большим, что приводит к снижению производительности планировщика запросов. Значение SQLITE_QUERY_PLANNER_LIMIT (в сочетании со связанным параметром &lt;a href=&quot;compile#query_planner_limit_incr&quot;&gt;SQLITE_QUERY_PLANNER_LIMIT_INCR&lt;/a&gt; ) ограничивает количество комбинаций индекса и ограничения, которые будет учитывать планировщик запросов, чтобы предотвратить использование планировщиком запросов избыточного времени ЦП. Значение по умолчанию для SQLITE_QUERY_PLANNER_LIMIT установлено достаточно высоким, чтобы оно никогда не было достигнуто для реальных запросов. Ограничение поиска планировщика запросов применяется только к запросам, которые специально созданы для использования избыточного времени планирования.</target>
        </trans-unit>
        <trans-unit id="69ee480d16c703172bf696c37d4bed26f84974f4" translate="yes" xml:space="preserve">
          <source>As part of the task of creating a new &lt;a href=&quot;c3ref/vtab&quot;&gt;sqlite3_vtab&lt;/a&gt; structure, this method &lt;u&gt;must&lt;/u&gt; invoke &lt;a href=&quot;c3ref/declare_vtab&quot;&gt;sqlite3_declare_vtab()&lt;/a&gt; to tell the SQLite core about the columns and datatypes in the virtual table. The &lt;a href=&quot;c3ref/declare_vtab&quot;&gt;sqlite3_declare_vtab()&lt;/a&gt; API has the following prototype:</source>
          <target state="translated">В рамках задачи создания новой структуры &lt;a href=&quot;c3ref/vtab&quot;&gt;sqlite3_vtab&lt;/a&gt; этот метод &lt;u&gt;должен&lt;/u&gt; вызывать &lt;a href=&quot;c3ref/declare_vtab&quot;&gt;sqlite3_declare_vtab (),&lt;/a&gt; чтобы сообщить ядру SQLite о столбцах и типах данных в виртуальной таблице. &lt;a href=&quot;c3ref/declare_vtab&quot;&gt;Sqlite3_declare_vtab ()&lt;/a&gt; API имеет следующий прототип:</target>
        </trans-unit>
        <trans-unit id="c00876adc6de8fc473fb32b80195d17d4fda9f03" translate="yes" xml:space="preserve">
          <source>As pointed out in the previous paragraph, SQLite takes steps to work around the quirks of POSIX advisory locking. Part of that work-around involves keeping a global list (mutex protected) of open SQLite database files. But, if multiple copies of SQLite are linked into the same application, then there will be multiple instances of this global list. Database connections opened using one copy of the SQLite library will be unaware of database connections opened using the other copy, and will be unable to work around the POSIX advisory locking quirks. A &lt;code&gt;close()&lt;/code&gt; operation on one connection might unknowingly clear the locks on a different database connection, leading to database corruption.</source>
          <target state="translated">Как указывалось в предыдущем абзаце, SQLite предпринимает шаги для обхода особенностей рекомендательной блокировки POSIX. Часть этого обходного пути включает ведение глобального списка (защищенного мьютексом) открытых файлов базы данных SQLite. Но если несколько копий SQLite связаны с одним и тем же приложением, тогда будет несколько экземпляров этого глобального списка. Соединения с базой данных, открытые с использованием одной копии библиотеки SQLite, не будут знать о соединениях с базой данных, открытых с помощью другой копии, и не смогут обойти рекомендательные особенности блокировки POSIX. &lt;code&gt;close()&lt;/code&gt; операция на одно соединение может неосознанно очистить замки на другом соединении с базой данных, что приводит к повреждению базы данных.</target>
        </trans-unit>
        <trans-unit id="d6d67b507fa18e45da7b000070cada26cbc7cde7" translate="yes" xml:space="preserve">
          <source>As recently as version 2.7.0, SQLite ran at about the same speed as MySQL on this test. But recent optimizations to SQLite have more than doubled speed of UPDATEs.</source>
          <target state="translated">Еще в версии 2.7.0 SQLite на этом тесте работал примерно с той же скоростью,что и MySQL.Однако недавние оптимизации SQLite более чем в два раза увеличили скорость UPDATE.</target>
        </trans-unit>
        <trans-unit id="9a13d6d8189152816b2ae81d060e78c812a6905c" translate="yes" xml:space="preserve">
          <source>As soon as the PENDING lock is released from the database file, other processes can begin reading the database again. In the current implementation, the RESERVED lock is also released, but that is not essential for correct operation.</source>
          <target state="translated">Как только блокировка PENDING будет освобождена из файла базы данных,другие процессы могут начать чтение базы данных снова.В текущей реализации блокировка RESERVED также освобождается,но это не является обязательным условием для корректной работы.</target>
        </trans-unit>
        <trans-unit id="555c3a9cda5a4b25e0cdbc43fe5e7c8c0b690222" translate="yes" xml:space="preserve">
          <source>As the last step in opening a</source>
          <target state="translated">В качестве последнего шага в открытии</target>
        </trans-unit>
        <trans-unit id="de5e740293d719649dc267008b44fcf5aaa20455" translate="yes" xml:space="preserve">
          <source>As we enter the interior of the second loop (at instruction 17) the stack contains a single integer which is the key of the record we want to modify. We are going to need to use this key twice: once to fetch the old value of the record and a second time to write back the revised record. So the first instruction is a Dup to make a duplicate of the key on the top of the stack. The Dup instruction will duplicate any element of the stack, not just the top element. You specify which element to duplication using the P1 operand. When P1 is 0, the top of the stack is duplicated. When P1 is 1, the next element down on the stack duplication. And so forth.</source>
          <target state="translated">При входе во внутреннюю часть второго цикла (в инструкции 17)стек содержит единственное целое число,которое является ключом записи,которую мы хотим модифицировать.Нам нужно будет использовать этот ключ дважды:один раз-для извлечения старого значения записи и второй раз-для записи отредактированной записи.Итак,первая инструкция-это Dup для создания дубликата ключа на верхней части стека.Инструкция Dup дублирует любой элемент стека,а не только верхний элемент.Вы указываете,какой элемент дублировать,используя операнд P1.Когда P1 равен 0,дублируется верхняя часть стека.Если P1 равен 1,то дублируется следующий элемент стека.И так далее.</target>
        </trans-unit>
        <trans-unit id="cf4c617d0371eb7d2e50bdeaba7f0656cfa12c47" translate="yes" xml:space="preserve">
          <source>As well as a list of columns, the module arguments passed to a CREATE VIRTUAL TABLE statement used to create an FTS table may be used to specify a &lt;a href=&quot;fts3#tokenizer&quot;&gt;tokenizer&lt;/a&gt;. This is done by specifying a string of the form &quot;tokenize=&amp;lt;tokenizer name&amp;gt; &amp;lt;tokenizer args&amp;gt;&quot; in place of a column name, where &amp;lt;tokenizer name&amp;gt; is the name of the tokenizer to use and &amp;lt;tokenizer args&amp;gt; is an optional list of whitespace separated qualifiers to pass to the tokenizer implementation. A tokenizer specification may be placed anywhere in the column list, but at most one tokenizer declaration is allowed for each CREATE VIRTUAL TABLE statement. &lt;a href=&quot;fts3#tokenizer&quot;&gt;See below&lt;/a&gt; for a detailed description of using (and, if necessary, implementing) a tokenizer.</source>
          <target state="translated">Помимо списка столбцов, аргументы модуля, переданные оператору CREATE VIRTUAL TABLE, используемому для создания таблицы FTS, могут использоваться для указания &lt;a href=&quot;fts3#tokenizer&quot;&gt;токенизатора&lt;/a&gt; . Для этого вместо имени столбца указывается строка вида &amp;laquo;tokenize = &amp;lt;tokenizer name&amp;gt; &amp;lt;tokenizer args&amp;gt;&amp;raquo;, где &amp;lt;tokenizer name&amp;gt; - это имя используемого токенизатора, а &amp;lt;tokenizer args&amp;gt; - необязательный список квалификаторов, разделенных пробелами, для передачи реализации токенизатора. Спецификация токенизатора может быть размещена в любом месте списка столбцов, но для каждого оператора CREATE VIRTUAL TABLE разрешено не более одного объявления токенизатора. &lt;a href=&quot;fts3#tokenizer&quot;&gt;См. Ниже&lt;/a&gt; подробное описание использования (и, при необходимости, реализации) токенизатора.</target>
        </trans-unit>
        <trans-unit id="aba6435071ee404f8eb600e0af17ad3d0179b00e" translate="yes" xml:space="preserve">
          <source>As well as aggregate window functions, SQLite features a set of built-in window functions based on &lt;a href=&quot;https://www.postgresql.org/docs/10/static/functions-window.html&quot;&gt; those supported by PostgreSQL&lt;/a&gt;.</source>
          <target state="translated">Помимо агрегированных оконных функций, SQLite имеет набор встроенных оконных функций, основанных на &lt;a href=&quot;https://www.postgresql.org/docs/10/static/functions-window.html&quot;&gt;тех, которые поддерживаются PostgreSQL&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4c2adc03d8772b0c49ef19569e284dd9591a16b0" translate="yes" xml:space="preserve">
          <source>As well as being set automatically as rows are inserted into database tables, the value returned by this function may be set explicitly by &lt;a href=&quot;#sqlite3_set_last_insert_rowid&quot;&gt;sqlite3_set_last_insert_rowid()&lt;/a&gt;</source>
          <target state="translated">Значение, возвращаемое этой функцией, не только устанавливается автоматически, когда строки вставляются в таблицы базы данных, но и может быть явно установлено &lt;a href=&quot;#sqlite3_set_last_insert_rowid&quot;&gt;sqlite3_set_last_insert_rowid ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6da8075b78c1059d6422bee1d474218e1b6600d9" translate="yes" xml:space="preserve">
          <source>As well as being set automatically as rows are inserted into database tables, the value returned by this function may be set explicitly by &lt;a href=&quot;set_last_insert_rowid&quot;&gt;sqlite3_set_last_insert_rowid()&lt;/a&gt;</source>
          <target state="translated">Значение, возвращаемое этой функцией, не только устанавливается автоматически, когда строки вставляются в таблицы базы данных, но и может быть явно установлено &lt;a href=&quot;set_last_insert_rowid&quot;&gt;sqlite3_set_last_insert_rowid ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0a715526e2153a56ee0a3cbcb2c8454333e9e1d8" translate="yes" xml:space="preserve">
          <source>As well as searching for all rows that contain a term, FTS5 allows the user to search for rows that contain:</source>
          <target state="translated">Помимо поиска всех строк,которые содержат термин,FTS5 позволяет пользователю искать строки,которые содержат термин:</target>
        </trans-unit>
        <trans-unit id="19f6e18c709ce14d58e4401d523e835813272b3a" translate="yes" xml:space="preserve">
          <source>As well as the &quot;simple&quot; tokenizer, the FTS source code features a tokenizer that uses the &lt;a href=&quot;http://tartarus.org/~martin/PorterStemmer/&quot;&gt;Porter Stemming algorithm&lt;/a&gt;. This tokenizer uses the same rules to separate the input document into terms including folding all terms into lower case, but also uses the Porter Stemming algorithm to reduce related English language words to a common root. For example, using the same input document as in the paragraph above, the porter tokenizer extracts the following tokens: &quot;right now thei veri frustrat&quot;. Even though some of these terms are not even English words, in some cases using them to build the full-text index is more useful than the more intelligible output produced by the simple tokenizer. Using the porter tokenizer, the document not only matches full-text queries such as &quot;MATCH 'Frustrated'&quot;, but also queries such as &quot;MATCH 'Frustration'&quot;, as the term &quot;Frustration&quot; is reduced by the Porter stemmer algorithm to &quot;frustrat&quot; - just as &quot;Frustrated&quot; is. So, when using the porter tokenizer, FTS is able to find not just exact matches for queried terms, but matches against similar English language terms. For more information on the Porter Stemmer algorithm, please refer to the page linked above.</source>
          <target state="translated">Помимо &amp;laquo;простого&amp;raquo; токенизатора, исходный код FTS включает токенизатор, который использует &lt;a href=&quot;http://tartarus.org/~martin/PorterStemmer/&quot;&gt;алгоритм Porter Stemming.&lt;/a&gt;. Этот токенизатор использует те же правила для разделения входного документа на термины, включая сворачивание всех терминов в нижний регистр, но также использует алгоритм Porter Stemming для сведения связанных слов английского языка к общему корню. Например, используя тот же входной документ, что и в предыдущем абзаце, переносчик токенизатора извлекает следующие токены: &amp;laquo;прямо сейчас thei veri frustrat&amp;raquo;. Хотя некоторые из этих терминов даже не являются английскими словами, в некоторых случаях их использование для построения полнотекстового индекса более полезно, чем более понятный вывод, произведенный простым токенизатором. Используя токенизатор переносчика, документ сопоставляет не только полнотекстовые запросы, такие как &amp;laquo;MATCH 'Frustrated'&amp;raquo;, но также такие запросы, как &amp;laquo;MATCH 'Frustrated'&amp;raquo;, как термин &amp;laquo;Frustration&amp;raquo;.сводится алгоритмом стеммера Портера к &amp;laquo;разочарованию&amp;raquo; - точно так же, как и &amp;laquo;разочарование&amp;raquo;. Таким образом, при использовании переносного токенизатора FTS может находить не только точные совпадения для запрашиваемых терминов, но и совпадения с аналогичными терминами на английском языке. Для получения дополнительной информации об алгоритме Портера-Стеммера перейдите на страницу, указанную выше.</target>
        </trans-unit>
        <trans-unit id="03b7b3d7c7af14aee8c40f5a5eff47a557f13b7f" translate="yes" xml:space="preserve">
          <source>As well as the column values and rowid of a matching row, an application may use &lt;a href=&quot;fts5#_auxiliary_functions_&quot;&gt;FTS5 auxiliary functions&lt;/a&gt; to retrieve extra information regarding the matched row. For example, an auxiliary function may be used to retrieve a copy of a column value for a matched row with all instances of the matched term surrounded by html &amp;lt;b&amp;gt;&amp;lt;/b&amp;gt; tags. Auxiliary functions are invoked in the same way as SQLite &lt;a href=&quot;lang_corefunc&quot;&gt;scalar functions&lt;/a&gt;, except that the name of the FTS5 table is specified as the first argument. For example:</source>
          <target state="translated">Помимо значений столбцов и идентификатора строки соответствующей строки, приложение может использовать &lt;a href=&quot;fts5#_auxiliary_functions_&quot;&gt;вспомогательные функции FTS5&lt;/a&gt; для извлечения дополнительной информации о сопоставленной строке. Например, вспомогательная функция может использоваться для извлечения копии значения столбца для сопоставленной строки со всеми экземплярами сопоставленного термина, окруженными тегами html &amp;lt;b&amp;gt; &amp;lt;/b&amp;gt;. Вспомогательные функции вызываются так же, как &lt;a href=&quot;lang_corefunc&quot;&gt;скалярные функции&lt;/a&gt; SQLite , за исключением того, что имя таблицы FTS5 указывается в качестве первого аргумента. Например:</target>
        </trans-unit>
        <trans-unit id="5f0b425505ed4df313764b933ddda058638fd396" translate="yes" xml:space="preserve">
          <source>As well as the columns named by the user (or the &quot;content&quot; column if no module arguments were specified as part of the &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; statement), each FTS table has a &quot;rowid&quot; column. The rowid of an FTS table behaves in the same way as the rowid column of an ordinary SQLite table, except that the values stored in the rowid column of an FTS table remain unchanged if the database is rebuilt using the &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; command. For FTS tables, &quot;docid&quot; is allowed as an alias along with the usual &quot;rowid&quot;, &quot;oid&quot; and &quot;_oid_&quot; identifiers. Attempting to insert or update a row with a docid value that already exists in the table is an error, just as it would be with an ordinary SQLite table.</source>
          <target state="translated">Помимо столбцов, названных пользователем (или столбца &amp;laquo;содержимое&amp;raquo;, если аргументы модуля не были указаны как часть оператора &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; ), каждая таблица FTS имеет столбец &amp;laquo;rowid&amp;raquo;. Rowid таблицы FTS ведет себя так же, как столбец rowid обычной таблицы SQLite, за исключением того, что значения, хранящиеся в столбце rowid таблицы FTS, остаются неизменными, если база данных перестраивается с помощью команды &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; . Для таблиц FTS допускается использование &amp;laquo;docid&amp;raquo; в качестве псевдонима вместе с обычными идентификаторами &amp;laquo;rowid&amp;raquo;, &amp;laquo;oid&amp;raquo; и &amp;laquo;_oid_&amp;raquo;. Попытка вставить или обновить строку со значением docid, которое уже существует в таблице, является ошибкой, как и в случае с обычной таблицей SQLite.</target>
        </trans-unit>
        <trans-unit id="8231b142308216452ffa1a9e5faf9c8e3f6c4c97" translate="yes" xml:space="preserve">
          <source>As well as the command option, each invocation of &quot;.ar&quot; may specify one or more modifier options. Some modifier options require an argument, some do not. The following modifier options are available:</source>
          <target state="translated">Так же как и опция команды,каждый вызов &quot;.ar&quot; может указывать одну или несколько опций модификатора.Некоторые опции модификаторов требуют аргумента,некоторые нет.Доступны следующие опции модификаторов:</target>
        </trans-unit>
        <trans-unit id="11a7e6bcced1d592a4403e3d9c67fd5b0f5481cf" translate="yes" xml:space="preserve">
          <source>As well as the regular sqlite3changegroup_add() and sqlite3changegroup_output() functions, also available are the streaming versions sqlite3changegroup_add_strm() and sqlite3changegroup_output_strm().</source>
          <target state="translated">Помимо обычных функций sqlite3changegroup_add()и sqlite3changegroup_output()доступны также потоковые версии sqlite3changegroup_add_strm()и sqlite3changegroup_output_strm().</target>
        </trans-unit>
        <trans-unit id="c79aa6a7ac9fe81930f35128aa127b04b14a76a2" translate="yes" xml:space="preserve">
          <source>As with &quot;.tables&quot;, the &quot;.schema&quot; command shows the schema for all &lt;a href=&quot;lang_attach&quot;&gt;attached&lt;/a&gt; databases. If you only want to see the schema for a single database (perhaps &quot;main&quot;) then you can add an argument to &quot;.schema&quot; to restrict its output:</source>
          <target state="translated">Как и в случае с &amp;laquo;.tables&amp;raquo;, команда &amp;laquo;.schema&amp;raquo; показывает схему для всех &lt;a href=&quot;lang_attach&quot;&gt;подключенных&lt;/a&gt; баз данных. Если вы хотите увидеть схему только для одной базы данных (возможно, &amp;laquo;основной&amp;raquo;), вы можете добавить аргумент в &amp;laquo;.schema&amp;raquo;, чтобы ограничить ее вывод:</target>
        </trans-unit>
        <trans-unit id="ea1906458c679a89c4cf89131d2ffd0b8ce0439a" translate="yes" xml:space="preserve">
          <source>As with all SQL syntax, the case of the keywords does not matter. One can write &quot;WITHOUT rowid&quot; or &quot;without rowid&quot; or &quot;WiThOuT rOwId&quot; and it will mean the same thing.</source>
          <target state="translated">Как и в случае со всем синтаксисом SQL,случай ключевых слов не имеет значения.Можно написать &quot;БЕЗ rowid&quot;,&quot;без rowid&quot; или &quot;WiThOuT rOwId&quot; и это будет означать то же самое.</target>
        </trans-unit>
        <trans-unit id="08e240ecd7ad7f6958c55717608dff9d30301be2" translate="yes" xml:space="preserve">
          <source>As with all other SQLite APIs, those whose names end with &quot;16&quot; return UTF-16 encoded strings and the other functions return UTF-8.</source>
          <target state="translated">Как и все остальные API SQLite,те,чьи имена заканчиваются на &quot;16&quot;,возвращают строки в кодировке UTF-16,а остальные функции-UTF-8.</target>
        </trans-unit>
        <trans-unit id="dad941d012cf3c0fecce4040017740b92b3cab9e" translate="yes" xml:space="preserve">
          <source>As with all virtual table types, it is not possible to create indices or triggers attached to FTS tables. Nor is it possible to use the ALTER TABLE command to add extra columns to FTS tables (although it is possible to use ALTER TABLE to rename an FTS table).</source>
          <target state="translated">Как и во всех типах виртуальных таблиц,невозможно создавать индексы или триггеры,привязанные к таблицам FTS.Также невозможно использовать команду ALTER TABLE для добавления дополнительных столбцов в таблицы FTS (хотя можно использовать ALTER TABLE для переименования таблицы FTS).</target>
        </trans-unit>
        <trans-unit id="2c9244ac5b5d0550aa0d1fc8ca3aa52ca8dfaf6c" translate="yes" xml:space="preserve">
          <source>As with custom file formats, and unlike pure pile-of-file formats, a wrapped pile-of-files format is not as easy to edit, since usually the entire file must be rewritten in order to change any component part.</source>
          <target state="translated">Как и в случае с пользовательскими форматами файлов,и в отличие от формата &quot;куча файлов&quot;,обернутый формат &quot;куча файлов&quot; не так прост в редактировании,так как обычно весь файл должен быть переписан,чтобы изменить любую компонентную часть.</target>
        </trans-unit>
        <trans-unit id="236d7f982d31124f4b94b3c6bc8e43ed33b0fc4b" translate="yes" xml:space="preserve">
          <source>As with the output of the sqlite3session_changeset() and sqlite3session_patchset() functions, all changes related to a single table are grouped together in the output of this function. Tables appear in the same order as for the very first changeset added to the changegroup. If the second or subsequent changesets added to the changegroup contain changes for tables that do not appear in the first changeset, they are appended onto the end of the output changeset, again in the order in which they are first encountered.</source>
          <target state="translated">Как и при выводе функций sqlite3session_changeset()и sqlite3session_patchset(),все изменения,связанные с одной таблицей,группируются в выводе этой функции.Таблицы появляются в том же порядке,что и для самого первого changeset'а,добавленного в группу изменений.Если второй или последующие changeset,добавленные в группу изменений,содержат изменения для таблиц,которые не появляются в первом changeset'е,то они добавляются в конец выходного changeset'а,опять же в том же порядке,в котором они появились в первый раз.</target>
        </trans-unit>
        <trans-unit id="38abe488c2a235f79f98488263f0f24db0790ef4" translate="yes" xml:space="preserve">
          <source>As with unix, most of the code for the various Windows VFSes is shared.</source>
          <target state="translated">Как и в случае с unix,большая часть кода для различных VFS под Windows является общим.</target>
        </trans-unit>
        <trans-unit id="ae23c67b5810fa3b2f8c5dc0de91ee63f46fa321" translate="yes" xml:space="preserve">
          <source>As you can see above, our simple insert statement is implemented in 12 instructions. The first 3 and last 2 instructions are a standard prologue and epilogue, so the real work is done in the middle 7 instructions. There are no jumps, so the program executes once through from top to bottom. Let's now look at each instruction in detail.</source>
          <target state="translated">Как Вы можете видеть выше,наше простое заявление о вставке реализовано в 12 инструкциях.Первые 3 и последние 2 инструкции являются стандартными прологом и эпилогом,поэтому реальная работа выполняется в середине 7 инструкций.Прыжков нет,поэтому программа выполняется один раз сверху вниз.Теперь рассмотрим каждую инструкцию более подробно.</target>
        </trans-unit>
        <trans-unit id="5e7f8dc6fe3c7e8373b6401e629567228cb8e775" translate="yes" xml:space="preserve">
          <source>As you would expect, it is not possible to manipulate the database to a state that violates the foreign key constraint by deleting or updating rows in the</source>
          <target state="translated">Как и следовало ожидать,невозможно манипулировать базой данных до состояния,нарушающего ограничение по внешнему ключу,удаляя или обновляя строки в</target>
        </trans-unit>
        <trans-unit id="d60ffe4ee5253e97c8077a55a44490538dd90ceb" translate="yes" xml:space="preserve">
          <source>Aside from those read operations described by H35070 and H21XXX, SQLite shall read data from the database file in aligned blocks of</source>
          <target state="translated">Кроме операций чтения,описанных в H35070 и H21XXX,SQLite должен считывать данные из файла базы данных в выровненных блоках из</target>
        </trans-unit>
        <trans-unit id="42e2846af72fd7f80a66045f0952619fc82cc85d" translate="yes" xml:space="preserve">
          <source>Assert() macros are disabled by compiling with the NDEBUG macro defined. In most systems, asserts are enabled by default. But in SQLite, the asserts are so numerous and are in such performance critical places, that the database engine runs about three times slower when asserts are enabled. Hence, the default (production) build of SQLite disables asserts. Assert statements are only enabled when SQLite is compiled with the SQLITE_DEBUG preprocessor macro defined.</source>
          <target state="translated">Макросы Assert()отключаются при компиляции с определенным макросом NDEBUG.В большинстве систем по умолчанию включено использование assert().Но в SQLite их так много и они находятся в таких критических местах производительности,что движок базы данных работает примерно в три раза медленнее при включенной функции asserts.Следовательно,стандартная (производственная)сборка SQLite отключает утверждения.Ассерты включаются только тогда,когда SQLite скомпилирован с определенным препроцессором SQLITE_DEBUG.</target>
        </trans-unit>
        <trans-unit id="c350f30044b71a607c57f6c34de0b1ed5d9089b9" translate="yes" xml:space="preserve">
          <source>Assertion fault in FTS4. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/d6ec09eccf68cfc&quot;&gt;d6ec09eccf68cfc&lt;/a&gt;</source>
          <target state="translated">Ошибка утверждения в FTS4. Билет &lt;a href=&quot;https://www.sqlite.org/src/info/d6ec09eccf68cfc&quot;&gt;d6ec09eccf68cfc&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ebc26a866ddd19c561f95f02b90e42c3048bf831" translate="yes" xml:space="preserve">
          <source>Assertion fault on queries involving expressions of the form &quot;x IN (?)&quot;. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/e39d032577&quot;&gt;e39d032577&lt;/a&gt;.</source>
          <target state="translated">Ошибка утверждения в запросах, включающих выражения вида &amp;laquo;x IN (?)&amp;raquo;. Билет &lt;a href=&quot;http://www.sqlite.org/src/info/e39d032577&quot;&gt;e39d032577&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8c84e5f05e8b60b78b6a824b91605a18f1523027" translate="yes" xml:space="preserve">
          <source>Assertion fault when doing REPLACE on an index on an expression. Ticket &lt;a href=&quot;https://sqlite.org/src/info/dc3f932f5a147771&quot;&gt;dc3f932f5a147771&lt;/a&gt;</source>
          <target state="translated">Ошибка утверждения при выполнении REPLACE по индексу выражения. Билет &lt;a href=&quot;https://sqlite.org/src/info/dc3f932f5a147771&quot;&gt;dc3f932f5a147771&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="14462bb4d8840870eeb8b473a0f255cc7e22e056" translate="yes" xml:space="preserve">
          <source>Assertion fault when doing an IN operator on a constant index. Ticket &lt;a href=&quot;https://sqlite.org/src/info/aa98619ad08ddcab&quot;&gt;aa98619ad08ddcab&lt;/a&gt;</source>
          <target state="translated">Ошибка утверждения при выполнении оператора IN с постоянным индексом. Билет &lt;a href=&quot;https://sqlite.org/src/info/aa98619ad08ddcab&quot;&gt;aa98619ad08ddcab&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6cea6f6a832fd7bbb6517d045402e777f939a795" translate="yes" xml:space="preserve">
          <source>Assigned the integer at offset 68 in the &lt;a href=&quot;fileformat2#database_header&quot;&gt;database header&lt;/a&gt; as the &lt;a href=&quot;fileformat2#appid&quot;&gt;Application ID&lt;/a&gt; for when SQLite is used as an &lt;a href=&quot;appfileformat&quot;&gt;application file-format&lt;/a&gt;. Added the &lt;a href=&quot;pragma#pragma_application_id&quot;&gt;PRAGMA application_id&lt;/a&gt; command to query and set the Application ID.</source>
          <target state="translated">Назначено целое число со смещением 68 в &lt;a href=&quot;fileformat2#database_header&quot;&gt;заголовке базы данных&lt;/a&gt; в качестве &lt;a href=&quot;fileformat2#appid&quot;&gt;идентификатора приложения,&lt;/a&gt; когда SQLite используется в качестве &lt;a href=&quot;appfileformat&quot;&gt;формата файла приложения&lt;/a&gt; . Добавлена ​​команда &lt;a href=&quot;pragma#pragma_application_id&quot;&gt;PRAGMA application_id&lt;/a&gt; для запроса и установки идентификатора приложения.</target>
        </trans-unit>
        <trans-unit id="2dc2100f672c34160990cbf608240b0f61030c73" translate="yes" xml:space="preserve">
          <source>Assuming</source>
          <target state="translated">Assuming</target>
        </trans-unit>
        <trans-unit id="ea6dcdcecbe15c6b4677215943bc88e69426e6db" translate="yes" xml:space="preserve">
          <source>Assuming no errors have occurred, then after attempting to detect and roll back a</source>
          <target state="translated">Если предположить,что ошибок не было,то после попытки обнаружить и откатить</target>
        </trans-unit>
        <trans-unit id="2d3766c3aab2fade58e514ea17fb6dc49420a581" translate="yes" xml:space="preserve">
          <source>Assuming statistics are enabled, the following routine can be used to access them:</source>
          <target state="translated">Если предположить,что статистика включена,то для доступа к ней можно использовать следующую рутину:</target>
        </trans-unit>
        <trans-unit id="836ad82865d510ff9a297c7660cf9d810b0b4728" translate="yes" xml:space="preserve">
          <source>Assuming that after registering for an unlock-notify callback a database waits for the callback to be issued before taking any further action (a reasonable assumption), then using this API may cause the application to deadlock. For example, if connection X is waiting for connection Y's transaction to be concluded, and similarly connection Y is waiting on connection X's transaction, then neither connection will proceed and the system may remain deadlocked indefinitely.</source>
          <target state="translated">Если предположить,что после регистрации для обратного вызова с уведомлением о разблокировке база данных ожидает выдачи обратного вызова,прежде чем предпринять какие-либо дальнейшие действия (разумное предположение),то использование этого API может привести приложение в тупик.Например,если соединение X ожидает завершения транзакции соединения Y,и аналогично этому соединение Y ожидает завершения транзакции соединения X,то ни одно из соединений не будет продолжаться,и система может оставаться в тупике бесконечно долго.</target>
        </trans-unit>
        <trans-unit id="3ba1c75f29bb0c1b541e404f389344df8b7d3190" translate="yes" xml:space="preserve">
          <source>Assuming that any and all sectors in the transient state may be corrupted following a power or system failure is a very pessimistic approach. Some modern systems provide more sophisticated guarantees than this. SQLite allows the VFS implementation to specify at runtime that the current platform supports zero or more of the following properties:</source>
          <target state="translated">Предположение,что любой и все сектора в переходном состоянии могут быть повреждены в результате сбоя электропитания или системы,является очень пессимистическим подходом.Некоторые современные системы предоставляют более сложные гарантии.SQLite позволяет реализации VFS указать во время выполнения,что текущая платформа поддерживает нулевые или более из следующих свойств:</target>
        </trans-unit>
        <trans-unit id="22e7a33261340b9207abc7f6240781daed2437d8" translate="yes" xml:space="preserve">
          <source>Assuming that customer records are stored in the &quot;customers&quot; table, and that order records are stored in the &quot;orders&quot; table, the following UPDATE trigger ensures that all associated orders are redirected when a customer changes his or her address:</source>
          <target state="translated">Предполагая,что записи о клиентах хранятся в таблице &quot;Клиенты&quot;,а записи об ордерах-в таблице &quot;Ордера&quot;,следующий триггер UPDATE гарантирует,что все связанные с ними ордера будут перенаправлены,когда клиент изменит свой адрес:</target>
        </trans-unit>
        <trans-unit id="ff40c2070ad237bff82bd7bce4ef0b45898889d0" translate="yes" xml:space="preserve">
          <source>Assuming that the compile-time threading mode is not single-thread, then the threading mode can be changed during initialization using the &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config()&lt;/a&gt; interface. The &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigsinglethread&quot;&gt;SQLITE_CONFIG_SINGLETHREAD&lt;/a&gt; verb puts SQLite into single-thread mode, the &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmultithread&quot;&gt;SQLITE_CONFIG_MULTITHREAD&lt;/a&gt; verb sets multi-thread mode, and the &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigserialized&quot;&gt;SQLITE_CONFIG_SERIALIZED&lt;/a&gt; verb sets serialized mode.</source>
          <target state="translated">Если предположить, что режим потоковой передачи во время компиляции не является однопоточным, то режим потоковой передачи можно изменить во время инициализации с помощью интерфейса &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config ()&lt;/a&gt; . Команда &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigsinglethread&quot;&gt;SQLITE_CONFIG_SINGLETHREAD&lt;/a&gt; переводит SQLite в однопоточный режим, команда &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmultithread&quot;&gt;SQLITE_CONFIG_MULTITHREAD&lt;/a&gt; устанавливает многопоточный режим, а команда &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigserialized&quot;&gt;SQLITE_CONFIG_SERIALIZED&lt;/a&gt; устанавливает сериализованный режим.</target>
        </trans-unit>
        <trans-unit id="5e4099134714457b667c5a0d0c91727935a69b43" translate="yes" xml:space="preserve">
          <source>Assuming that the first hidden column of &quot;tablevaluedfunc&quot; is &quot;param1&quot;, the query above is semantically equivalent to this:</source>
          <target state="translated">Если предположить,что первый скрытый столбец &quot;tablevaluedfunc&quot;-это &quot;параметр1&quot;,то вышеприведенный запрос семантически эквивалентен этому:</target>
        </trans-unit>
        <trans-unit id="a392f90a65c67ef3276bb011e52cf4659579c18e" translate="yes" xml:space="preserve">
          <source>Assuming the changeset blob was created by one of the &lt;a href=&quot;#sqlite3session_changeset&quot;&gt;sqlite3session_changeset()&lt;/a&gt;, &lt;a href=&quot;#sqlite3changeset_concat&quot;&gt;sqlite3changeset_concat()&lt;/a&gt; or &lt;a href=&quot;#sqlite3changeset_invert&quot;&gt;sqlite3changeset_invert()&lt;/a&gt; functions, all changes within the changeset that apply to a single table are grouped together. This means that when an application iterates through a changeset using an iterator created by this function, all changes that relate to a single table are visited consecutively. There is no chance that the iterator will visit a change the applies to table X, then one for table Y, and then later on visit another change for table X.</source>
          <target state="translated">Предполагая, что большой двоичный &lt;a href=&quot;#sqlite3session_changeset&quot;&gt;объект набора&lt;/a&gt; изменений был создан одной из функций sqlite3session_changeset () , &lt;a href=&quot;#sqlite3changeset_concat&quot;&gt;sqlite3changeset_concat ()&lt;/a&gt; или &lt;a href=&quot;#sqlite3changeset_invert&quot;&gt;sqlite3changeset_invert ()&lt;/a&gt; , все изменения в наборе изменений, которые применяются к одной таблице, группируются вместе. Это означает, что когда приложение выполняет итерацию набора изменений с использованием итератора, созданного этой функцией, все изменения, относящиеся к одной таблице, посещаются последовательно. Нет никаких шансов, что итератор посетит изменение, которое применяется к таблице X, затем к таблице Y, а затем к другому изменению для таблицы X.</target>
        </trans-unit>
        <trans-unit id="ae768e26e15e53e036c5e372149bd64f61fe40d5" translate="yes" xml:space="preserve">
          <source>Assuming the changeset blob was created by one of the &lt;a href=&quot;sqlite3session_changeset&quot;&gt;sqlite3session_changeset()&lt;/a&gt;, &lt;a href=&quot;sqlite3changeset_concat&quot;&gt;sqlite3changeset_concat()&lt;/a&gt; or &lt;a href=&quot;sqlite3changeset_invert&quot;&gt;sqlite3changeset_invert()&lt;/a&gt; functions, all changes within the changeset that apply to a single table are grouped together. This means that when an application iterates through a changeset using an iterator created by this function, all changes that relate to a single table are visited consecutively. There is no chance that the iterator will visit a change the applies to table X, then one for table Y, and then later on visit another change for table X.</source>
          <target state="translated">Предполагая, что большой двоичный &lt;a href=&quot;sqlite3session_changeset&quot;&gt;объект набора&lt;/a&gt; изменений был создан одной из функций sqlite3session_changeset () , &lt;a href=&quot;sqlite3changeset_concat&quot;&gt;sqlite3changeset_concat ()&lt;/a&gt; или &lt;a href=&quot;sqlite3changeset_invert&quot;&gt;sqlite3changeset_invert ()&lt;/a&gt; , все изменения в наборе изменений, которые применяются к одной таблице, группируются вместе. Это означает, что когда приложение выполняет итерацию набора изменений с использованием итератора, созданного этой функцией, все изменения, относящиеся к одной таблице, посещаются последовательно. Нет никаких шансов, что итератор посетит изменение, которое применяется к таблице X, затем к таблице Y, а затем к другому изменению для таблицы X.</target>
        </trans-unit>
        <trans-unit id="ae27622bf93c5f8e58c667e3d2b3f8634b153cf3" translate="yes" xml:space="preserve">
          <source>Assuming the library is compiled with foreign key constraints enabled, it must still be enabled by the application at runtime, using the &lt;a href=&quot;pragma#pragma_foreign_keys&quot;&gt;PRAGMA foreign_keys&lt;/a&gt; command. For example:</source>
          <target state="translated">Предполагая, что библиотека скомпилирована с включенными ограничениями внешнего ключа, она все равно должна быть включена приложением во время выполнения с помощью команды &lt;a href=&quot;pragma#pragma_foreign_keys&quot;&gt;PRAGMA foreign_keys&lt;/a&gt; . Например:</target>
        </trans-unit>
        <trans-unit id="4a1dda34c843a460a37b4389bc3fdea530b33452" translate="yes" xml:space="preserve">
          <source>Assuming the nominated table does exist, then its columns must be the same as or a superset of those defined for the FTS table. The external table must also be in the same database file as the FTS table. In other words, The external table cannot be in a different database file connected using &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; nor may one of the FTS table and the external content be in the TEMP database when the other is in a persistent database file such as MAIN.</source>
          <target state="translated">Предполагая, что номинированная таблица действительно существует, тогда ее столбцы должны быть такими же или надмножеством столбцов, определенных для таблицы FTS. Внешняя таблица также должна находиться в том же файле базы данных, что и таблица FTS. Другими словами, внешняя таблица не может находиться в другом файле базы данных, подключенном с помощью &lt;a href=&quot;lang_attach&quot;&gt;ATTACH,&lt;/a&gt; и одна из таблицы FTS и внешнего содержимого не может находиться в базе данных TEMP, когда другая находится в постоянном файле базы данных, таком как MAIN.</target>
        </trans-unit>
        <trans-unit id="921866ee0046d5a80db64dfb8749244f24a09ba6" translate="yes" xml:space="preserve">
          <source>Assuming the table is not also a &lt;a href=&quot;fts5#contentless_tables&quot;&gt;contentless table&lt;/a&gt;, the &lt;a href=&quot;#xInstCount&quot;&gt;xInstCount&lt;/a&gt;, &lt;a href=&quot;#xInst&quot;&gt;xInst&lt;/a&gt;, &lt;a href=&quot;#xPhraseFirst&quot;&gt;xPhraseFirst&lt;/a&gt; and &lt;a href=&quot;#xPhraseNext&quot;&gt;xPhraseNext&lt;/a&gt; are slower than usual. This is because instead of reading the required data directly from the FTS index they have to load and tokenize the document text on demand.</source>
          <target state="translated">Предполагая , что таблица не является также &lt;a href=&quot;fts5#contentless_tables&quot;&gt;бессодержательная стол&lt;/a&gt; , то &lt;a href=&quot;#xInstCount&quot;&gt;xInstCount&lt;/a&gt; , &lt;a href=&quot;#xInst&quot;&gt;xInst&lt;/a&gt; , &lt;a href=&quot;#xPhraseFirst&quot;&gt;xPhraseFirst&lt;/a&gt; и &lt;a href=&quot;#xPhraseNext&quot;&gt;xPhraseNext&lt;/a&gt; медленнее , чем обычно. Это связано с тем, что вместо чтения необходимых данных непосредственно из индекса FTS они должны загружать и размечать текст документа по запросу.</target>
        </trans-unit>
        <trans-unit id="dc375c212f41b57083889574933fcd5e4987a611" translate="yes" xml:space="preserve">
          <source>Assuming the table is not also a contentless table, the &lt;a href=&quot;#xPhraseFirstColumn&quot;&gt;xPhraseFirstColumn&lt;/a&gt; and &lt;a href=&quot;#xPhraseNextColumn&quot;&gt;xPhraseNextColumn&lt;/a&gt; are slower than usual.</source>
          <target state="translated">Предполагая, что таблица также не является таблицей без &lt;a href=&quot;#xPhraseFirstColumn&quot;&gt;содержимого&lt;/a&gt; , xPhraseFirstColumn и &lt;a href=&quot;#xPhraseNextColumn&quot;&gt;xPhraseNextColumn&lt;/a&gt; работают медленнее, чем обычно.</target>
        </trans-unit>
        <trans-unit id="504be981e8ff80c0d63cd17a340b7f1cd587e84d" translate="yes" xml:space="preserve">
          <source>Asynchronous I/O appears to give better responsiveness, but at a price. You lose the Durable property. With the default I/O backend of SQLite, once a write completes, you know that the information you wrote is safely on disk. With the asynchronous I/O, this is not the case. If your program crashes or if a power loss occurs after the database write but before the asynchronous write thread has completed, then the database change might never make it to disk and the next user of the database might not see your change.</source>
          <target state="translated">Асинхронный ввод/вывод,похоже,дает лучшую отзывчивость,но за определенную цену.Вы теряете Прочное свойство.При использовании стандартного бэкэнда ввода/вывода SQLite,после завершения записи,вы знаете,что информация,которую вы записали,безопасно хранится на диске.С асинхронным вводом/выводом это не так.Если ваша программа выйдет из строя или произойдет отключение питания после записи в базу данных,но до завершения асинхронного потока записи,то смена базы данных может никогда не произойти на диск,и следующий пользователь базы данных может не увидеть ваших изменений.</target>
        </trans-unit>
        <trans-unit id="2c26b5cd54f0029b1a3269b19cfe3a6ff6addbcc" translate="yes" xml:space="preserve">
          <source>Asynchronous I/O works by creating an SQLite &lt;a href=&quot;c3ref/vfs&quot;&gt;VFS object&lt;/a&gt; and registering it with &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register()&lt;/a&gt;. When files opened via this VFS are written to (using the vfs xWrite() method), the data is not written directly to disk, but is placed in the &quot;write-queue&quot; to be handled by the background thread.</source>
          <target state="translated">Асинхронный ввод-вывод работает путем создания &lt;a href=&quot;c3ref/vfs&quot;&gt;объекта&lt;/a&gt; SQLite VFS и его регистрации с помощью &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register ()&lt;/a&gt; . Когда файлы, открытые через эту VFS, записываются (с использованием метода vfs xWrite ()), данные не записываются непосредственно на диск, а помещаются в &amp;laquo;очередь записи&amp;raquo; для обработки фоновым потоком.</target>
        </trans-unit>
        <trans-unit id="4c91d5ce458c482219d3664734d8a556293b6cdf" translate="yes" xml:space="preserve">
          <source>At a shell or DOS prompt, enter: &quot;&lt;b&gt;sqlite3 test.db&lt;/b&gt;&quot;. This will create a new database named &quot;test.db&quot;. (You can use a different name if you like.)</source>
          <target state="translated">В командной строке или в командной строке DOS введите: &amp;laquo; &lt;b&gt;sqlite3 test.db&lt;/b&gt; &amp;raquo;. Это создаст новую базу данных с именем &amp;laquo;test.db&amp;raquo;. (Вы можете использовать другое имя, если хотите.)</target>
        </trans-unit>
        <trans-unit id="449f6270af54115e84fbbfac0ca3ab28ec064210" translate="yes" xml:space="preserve">
          <source>At about that same time, some avionics manufacturers were expressing interest in SQLite, which prompted the SQLite developers to design TH3 to support the rigorous testing standards of &lt;a href=&quot;https://en.wikipedia.org/wiki/DO-178B&quot;&gt;DO-178B&lt;/a&gt;.</source>
          <target state="translated">Примерно в то же время некоторые производители авионики проявили интерес к SQLite, что побудило разработчиков SQLite разработать TH3 для поддержки строгих стандартов тестирования &lt;a href=&quot;https://en.wikipedia.org/wiki/DO-178B&quot;&gt;DO-178B&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d3fd57d066718d01302089d95d92c8454d1b5f4a" translate="yes" xml:space="preserve">
          <source>At any one time, a single table may have any number of active read-locks or a single active write lock. To read data a table, a connection must first obtain a read-lock. To write to a table, a connection must obtain a write-lock on that table. If a required table lock cannot be obtained, the query fails and SQLITE_LOCKED is returned to the caller.</source>
          <target state="translated">В любой момент времени одна таблица может иметь любое количество активных блокировок чтения или одну активную блокировку записи.Чтобы прочитать данные таблицы,соединение должно сначала получить блокировку на чтение.Для записи в таблицу соединение должно получить блокировку записи на эту таблицу.Если необходимая блокировка таблицы не может быть получена,то запрос завершается неудачей и вызывающему абоненту возвращается SQLITE_LOCKED.</target>
        </trans-unit>
        <trans-unit id="b7a3b82c7cb7013957f0c0e0e4f1a6c43e18aa55" translate="yes" xml:space="preserve">
          <source>At any one time, a single table may have any number of active read-locks or a single active write lock. To read data from a table, a connection must first obtain a read-lock. To write to a table, a connection must obtain a write-lock on that table. If a required table lock cannot be obtained, the query fails and SQLITE_LOCKED is returned to the caller.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2c8ad5daed2b52823fb4c80a495b310ef19384a" translate="yes" xml:space="preserve">
          <source>At any one time, each</source>
          <target state="translated">В любое время,каждый</target>
        </trans-unit>
        <trans-unit id="8560f4e49c6caa4d7228201f89aa3ea44ff72f5b" translate="yes" xml:space="preserve">
          <source>At any one time, the</source>
          <target state="translated">В любой момент</target>
        </trans-unit>
        <trans-unit id="faefe425b3756bc94c56346d8a50b44d5ccda922" translate="yes" xml:space="preserve">
          <source>At any point in time, every page in the main database has a single use which is one of the following:</source>
          <target state="translated">В любой момент времени каждая страница в основной базе данных имеет однократное использование,которое является одним из следующих:</target>
        </trans-unit>
        <trans-unit id="4998acdc6089555e0887c221354101b4a2253663" translate="yes" xml:space="preserve">
          <source>At first glance, the final two full-text queries in the example above seem to be syntactically incorrect, as there is a table name (&quot;mail&quot;) used as an SQL expression. The reason this is acceptable is that each FTS table actually has a &lt;a href=&quot;c3ref/declare_vtab&quot;&gt;HIDDEN&lt;/a&gt; column with the same name as the table itself (in this case, &quot;mail&quot;). The value stored in this column is not meaningful to the application, but can be used as the left-hand operand to a MATCH operator. This special column may also be passed as an argument to the &lt;a href=&quot;fts3#snippet&quot;&gt;FTS auxiliary functions&lt;/a&gt;.</source>
          <target state="translated">На первый взгляд, последние два полнотекстовых запроса в приведенном выше примере кажутся синтаксически некорректными, поскольку в качестве выражения SQL используется имя таблицы (&amp;laquo;mail&amp;raquo;). Причина, по которой это приемлемо, заключается в том, что каждая таблица FTS фактически имеет столбец &lt;a href=&quot;c3ref/declare_vtab&quot;&gt;HIDDEN&lt;/a&gt; с тем же именем, что и сама таблица (в данном случае &amp;laquo;mail&amp;raquo;). Значение, хранящееся в этом столбце, не имеет смысла для приложения, но может использоваться как левый операнд для оператора MATCH. Этот специальный столбец также может быть передан в качестве аргумента &lt;a href=&quot;fts3#snippet&quot;&gt;вспомогательным функциям FTS&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2f5836449640e20f49edf00efccee8083a6bcb35" translate="yes" xml:space="preserve">
          <source>At least szOsFile bytes of memory are allocated by SQLite to hold the &lt;a href=&quot;#sqlite3_file&quot;&gt;sqlite3_file&lt;/a&gt; structure passed as the third argument to xOpen. The xOpen method does not have to allocate the structure; it should just fill it in. Note that the xOpen method must set the sqlite3_file.pMethods to either a valid &lt;a href=&quot;#sqlite3_io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object or to NULL. xOpen must do this even if the open fails. SQLite expects that the sqlite3_file.pMethods element will be valid after xOpen returns regardless of the success or failure of the xOpen call.</source>
          <target state="translated">SQLite выделяет как минимум szOsFile байт памяти для хранения структуры &lt;a href=&quot;#sqlite3_file&quot;&gt;sqlite3_file,&lt;/a&gt; переданной в качестве третьего аргумента функции xOpen. Метод xOpen не должен выделять структуру; он должен просто заполнить его. Обратите внимание, что метод xOpen должен установить sqlite3_file.pMethods либо на допустимый объект &lt;a href=&quot;#sqlite3_io_methods&quot;&gt;sqlite3_io_methods,&lt;/a&gt; либо на NULL. xOpen должен делать это, даже если открытие не удается. SQLite ожидает, что элемент sqlite3_file.pMethods будет действителен после возврата xOpen независимо от успеха или неудачи вызова xOpen.</target>
        </trans-unit>
        <trans-unit id="59514e13b273471c6ec6f5f109fedbde115ba166" translate="yes" xml:space="preserve">
          <source>At least szOsFile bytes of memory are allocated by SQLite to hold the &lt;a href=&quot;file&quot;&gt;sqlite3_file&lt;/a&gt; structure passed as the third argument to xOpen. The xOpen method does not have to allocate the structure; it should just fill it in. Note that the xOpen method must set the sqlite3_file.pMethods to either a valid &lt;a href=&quot;io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object or to NULL. xOpen must do this even if the open fails. SQLite expects that the sqlite3_file.pMethods element will be valid after xOpen returns regardless of the success or failure of the xOpen call.</source>
          <target state="translated">SQLite выделяет как минимум szOsFile байт памяти для хранения структуры &lt;a href=&quot;file&quot;&gt;sqlite3_file,&lt;/a&gt; переданной в качестве третьего аргумента функции xOpen. Метод xOpen не должен выделять структуру; он должен просто заполнить его. Обратите внимание, что метод xOpen должен установить sqlite3_file.pMethods либо на допустимый объект &lt;a href=&quot;io_methods&quot;&gt;sqlite3_io_methods,&lt;/a&gt; либо на NULL. xOpen должен делать это, даже если открытие не удается. SQLite ожидает, что элемент sqlite3_file.pMethods будет действителен после возврата xOpen независимо от успеха или неудачи вызова xOpen.</target>
        </trans-unit>
        <trans-unit id="5cf0c7d5d4e31a3622d3bed10cffc599203f902a" translate="yes" xml:space="preserve">
          <source>At most one connection to a single shared cache may open a write transaction at any one time. This may co-exist with any number of read transactions.</source>
          <target state="translated">Максимум одно подключение к одному общему кэшу может открыть транзакцию записи в любой момент времени.Это может сосуществовать с любым количеством прочитанных транзакций.</target>
        </trans-unit>
        <trans-unit id="2549fa7b8565911915cfbc5b3b9d42147224732f" translate="yes" xml:space="preserve">
          <source>At one point, &lt;a href=&quot;th3&quot;&gt;TH3&lt;/a&gt; was sometimes licensed to third-parties. Such licensing no longer occurs. However, back when it was occurring, some of the TH3 test cases contained information that was sensitive and could not be released even to licensees. This sensitive information is stored in yet another repository.</source>
          <target state="translated">В какой-то момент &lt;a href=&quot;th3&quot;&gt;TH3&lt;/a&gt; иногда передавался по лицензии третьим лицам. Такого лицензирования больше не происходит. Однако, когда это происходило, некоторые из тестовых примеров TH3 содержали конфиденциальную информацию, которую нельзя было передать даже лицензиатам. Эта конфиденциальная информация хранится в еще одном репозитории.</target>
        </trans-unit>
        <trans-unit id="4d936f8adee7e8e3dc2d8a9b26c4bae945a9dd4c" translate="yes" xml:space="preserve">
          <source>At present, there is only one option that may be configured using this function. (See &lt;a href=&quot;#sqlitevtabconstraintsupport&quot;&gt;SQLITE_VTAB_CONSTRAINT_SUPPORT&lt;/a&gt;.) Further options may be added in the future.</source>
          <target state="translated">В настоящее время существует только одна опция, которую можно настроить с помощью этой функции. (См. &lt;a href=&quot;#sqlitevtabconstraintsupport&quot;&gt;SQLITE_VTAB_CONSTRAINT_SUPPORT&lt;/a&gt; .) В будущем могут быть добавлены дополнительные параметры.</target>
        </trans-unit>
        <trans-unit id="e0662b7a2bebf7dce7d12510693eb67ca1548c61" translate="yes" xml:space="preserve">
          <source>At present, there is only one option that may be configured using this function. (See &lt;a href=&quot;c_vtab_constraint_support#sqlitevtabconstraintsupport&quot;&gt;SQLITE_VTAB_CONSTRAINT_SUPPORT&lt;/a&gt;.) Further options may be added in the future.</source>
          <target state="translated">В настоящее время существует только одна опция, которую можно настроить с помощью этой функции. (См. &lt;a href=&quot;c_vtab_constraint_support#sqlitevtabconstraintsupport&quot;&gt;SQLITE_VTAB_CONSTRAINT_SUPPORT&lt;/a&gt; .) В будущем могут быть добавлены дополнительные параметры.</target>
        </trans-unit>
        <trans-unit id="598f95760d8ef9fc04e0c94379f28c6b7cd53470" translate="yes" xml:space="preserve">
          <source>At the beginning of a cache spill, the status of the database connection is as shown in &lt;a href=&quot;#section_3_6&quot;&gt;step 3.6&lt;/a&gt;. Original page content has been saved in the rollback journal and modifications of the pages exist in user memory. To spill the cache, SQLite executes steps &lt;a href=&quot;#section_3_7&quot;&gt;3.7&lt;/a&gt; through &lt;a href=&quot;#section_3_9&quot;&gt;3.9&lt;/a&gt;. In other words, the rollback journal is flushed to disk, an exclusive lock is acquired, and changes are written into the database. But the remaining steps are deferred until the transaction really commits. A new journal header is appended to the end of the rollback journal (in its own sector) and the exclusive database lock is retained, but otherwise processing returns to &lt;a href=&quot;#section_3_6&quot;&gt;step 3.6&lt;/a&gt;. When the transaction commits, or if another cache spill occurs, steps &lt;a href=&quot;#section_3_7&quot;&gt;3.7&lt;/a&gt; and &lt;a href=&quot;#section_3_9&quot;&gt;3.9&lt;/a&gt; are repeated. (Step &lt;a href=&quot;#section_3_8&quot;&gt;3.8&lt;/a&gt; is omitted on second and subsequent passes since an exclusive database lock is already held due to the first pass.)</source>
          <target state="translated">В начале разлива кеша состояние соединения с базой данных показано на &lt;a href=&quot;#section_3_6&quot;&gt;шаге 3.6&lt;/a&gt; . Исходное содержимое страницы было сохранено в журнале отката, а модификации страниц существуют в пользовательской памяти. Чтобы очистить кеш, SQLite выполняет шаги с &lt;a href=&quot;#section_3_7&quot;&gt;3.7&lt;/a&gt; по &lt;a href=&quot;#section_3_9&quot;&gt;3.9&lt;/a&gt; . Другими словами, журнал отката сбрасывается на диск, устанавливается монопольная блокировка и изменения записываются в базу данных. Но остальные шаги откладываются до тех пор, пока транзакция действительно не зафиксируется. Новый заголовок журнала добавляется в конец журнала отката (в его собственном секторе), и исключительная блокировка базы данных сохраняется, но в противном случае обработка возвращается к &lt;a href=&quot;#section_3_6&quot;&gt;шагу 3.6&lt;/a&gt; . Когда транзакция фиксируется или происходит еще одна утечка кеша, шаги &lt;a href=&quot;#section_3_7&quot;&gt;3.7&lt;/a&gt;и &lt;a href=&quot;#section_3_9&quot;&gt;3.9&lt;/a&gt; повторяются. (Шаг &lt;a href=&quot;#section_3_8&quot;&gt;3.8&lt;/a&gt; опускается на втором и последующих проходах, поскольку монопольная блокировка базы данных уже удерживается из-за первого прохода.)</target>
        </trans-unit>
        <trans-unit id="a07c0967c09d3dbc3e32b1c4ad8479eec1c47ba2" translate="yes" xml:space="preserve">
          <source>At this point you are ready to type &quot;&lt;code&gt;./configure; make&lt;/code&gt;&quot; (or on Windows with MSVC, &quot;&lt;code&gt;nmake /f Makefile.msc&lt;/code&gt;&quot;).</source>
          <target state="translated">На этом этапе вы готовы набрать &amp;laquo; &lt;code&gt;./configure; make&lt;/code&gt; &amp;raquo; (или в Windows с MSVC, &amp;laquo; &lt;code&gt;nmake /f Makefile.msc&lt;/code&gt; &amp;raquo;).</target>
        </trans-unit>
        <trans-unit id="5d9739e0c9d62ebb2f85f2435395edecdd3fc346" translate="yes" xml:space="preserve">
          <source>At this point, you can measure the amount of disk space used by the test1.db database and the space used by the test1.dir directory and all of its content. On a standard Ubuntu Linux desktop, the database file will be 1,024,512,000 bytes in size and the test1.dir directory will use 1,228,800,000 bytes of space (according to &quot;du -k&quot;), about 20% more than the database.</source>
          <target state="translated">На этом этапе можно измерить объем дискового пространства,используемого базой данных test1.db,а также пространство,используемое директорией test1.dir и все ее содержимое.На стандартном рабочем столе Ubuntu Linux файл базы данных будет иметь размер 1 024 512 000 байт,а каталог test1.dir будет использовать 1 228 800 000 байт пространства (по данным &quot;du -k&quot;),что примерно на 20% больше,чем база данных.</target>
        </trans-unit>
        <trans-unit id="05593853b78d4288d0ab3317d42f66fcc3356044" translate="yes" xml:space="preserve">
          <source>At this point, you should understand the VDBE well enough to figure out on your own how the above program works. So we will not discuss it further in this text.</source>
          <target state="translated">На данном этапе вы должны достаточно хорошо понимать VDBE,чтобы самостоятельно разобраться,как работает вышеуказанная программа.Поэтому мы не будем обсуждать это далее в этом тексте.</target>
        </trans-unit>
        <trans-unit id="7ed93611b051b3f2ce2f2e18dd2aa20d02819e82" translate="yes" xml:space="preserve">
          <source>At this point, you should understand the basics of how the VDBE writes to a database. Now let's look at how it does queries. We will use the following simple SELECT statement as our example:</source>
          <target state="translated">На данном этапе вы должны понимать основы того,как VDBE записывает в базу данных.Теперь давайте посмотрим,как он делает запросы.В качестве примера мы будем использовать следующее простое утверждение SELECT:</target>
        </trans-unit>
        <trans-unit id="ca131936c53e26b047834300b8b5909015686af9" translate="yes" xml:space="preserve">
          <source>At this time SQLite supports only FOR EACH ROW triggers, not FOR EACH STATEMENT triggers. Hence explicitly specifying FOR EACH ROW is optional. FOR EACH ROW implies that the SQL statements specified in the trigger may be executed (depending on the WHEN clause) for each database row being inserted, updated or deleted by the statement causing the trigger to fire.</source>
          <target state="translated">В настоящее время SQLite поддерживает только триггеры ДЛЯ КАЖДОГО СТРАНА,но не триггеры ДЛЯ КАЖДОГО СТАТЕМЕНТА.Следовательно,явное указание КОЛИЧЕСТВА ДЛЯ КОЛИЧЕСТВА является необязательным.FOR EACH ROW подразумевает,что триггер SQL-операторы,указанные в триггере,могут быть выполнены (в зависимости от условия WHEN)для каждой вставляемой,обновляемой или удаляемой строки БД оператором,вызывающим срабатывание триггера.</target>
        </trans-unit>
        <trans-unit id="9f2f2ddc27722f56f60ce157d4213f6b2caed0bd" translate="yes" xml:space="preserve">
          <source>At this writing, 2050 is still 34 years in the future. Nobody knows what will happen in that time, and we cannot absolutely promise that SQLite will be viable or useful that far out. But we can promise this: we plan as if we will be supporting SQLite until 2050. That long-term outlook affects our decisions in important ways.</source>
          <target state="translated">На момент написания этой статьи 2050 год-это еще 34 года в будущем.Никто не знает,что произойдет за это время,и мы не можем абсолютно обещать,что SQLite будет жизнеспособным или полезным настолько далеко.Но мы можем обещать это:мы планируем так,как будто будем поддерживать SQLite до 2050 года.Это долгосрочная перспектива влияет на наши решения важными способами.</target>
        </trans-unit>
        <trans-unit id="5dc594be0856868f818e54abe920fd51cc599639" translate="yes" xml:space="preserve">
          <source>Atomic Commit In SQLite</source>
          <target state="translated">Атомный комитет в SQLite</target>
        </trans-unit>
        <trans-unit id="2d4c9569233db52020accb44326c29045c8c4cce" translate="yes" xml:space="preserve">
          <source>Atomic Transactions</source>
          <target state="translated">Атомные операции</target>
        </trans-unit>
        <trans-unit id="01c8139f3cad23c8756bfadca13473ed3a8e76ee" translate="yes" xml:space="preserve">
          <source>Atomic commits for ATTACHed databases.</source>
          <target state="translated">Атомные коммиты для баз данных ATTACHed.</target>
        </trans-unit>
        <trans-unit id="d81553de52fcfae8fe4cc1bad5f59236dea06c3f" translate="yes" xml:space="preserve">
          <source>Atomically releases the mutex and begins waiting for the asynchronous signal. When the signal arrives, continue.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92dd7a0665a3434edc8f121885515c600f18e15b" translate="yes" xml:space="preserve">
          <source>Attach A Table To A Session Object</source>
          <target state="translated">Прикрепить таблицу к объекту сессии</target>
        </trans-unit>
        <trans-unit id="4d752510d48bfeb2c136d1e65419fdd66d0835e6" translate="yes" xml:space="preserve">
          <source>Attempt To Free Heap Memory</source>
          <target state="translated">Попытка освободить кучу памяти</target>
        </trans-unit>
        <trans-unit id="88ccf4926dcde2d4398cadb109fcd1c1c1205d36" translate="yes" xml:space="preserve">
          <source>Attempt to optimize the database. All schemas are optimized in the first two forms, and only the specified schema is optimized in the latter two.</source>
          <target state="translated">Попытайтесь оптимизировать базу данных.Все схемы оптимизируются в первых двух формах,и только указанная схема оптимизируется во вторых двух.</target>
        </trans-unit>
        <trans-unit id="72b5f89658d37542e4f2f47adfbbada66e9f74c3" translate="yes" xml:space="preserve">
          <source>Attempt to return the underlying operating system error code or error number that caused the most recent I/O error or failure to open a file. The return value is OS-dependent. For example, on unix systems, after &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_CANTOPEN&lt;/a&gt;, this interface could be called to get back the underlying &quot;errno&quot; that caused the problem, such as ENOSPC, EAUTH, EISDIR, and so forth.</source>
          <target state="translated">Попытка вернуть код ошибки базовой операционной системы или номер ошибки, которая вызвала самую последнюю ошибку ввода-вывода или отказ при открытии файла. Возвращаемое значение зависит от ОС. Например, в системах unix после того, как &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2 ()&lt;/a&gt; вернет &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_CANTOPEN&lt;/a&gt; , этот интерфейс может быть вызван для возврата основного &amp;laquo;errno&amp;raquo;, вызвавшего проблему, такого как ENOSPC, EAUTH, EISDIR и т. Д.</target>
        </trans-unit>
        <trans-unit id="50dfefcf7c07518a2714e6179a3b3e2c44246560" translate="yes" xml:space="preserve">
          <source>Attempt to return the underlying operating system error code or error number that caused the most recent I/O error or failure to open a file. The return value is OS-dependent. For example, on unix systems, after &lt;a href=&quot;open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; returns &lt;a href=&quot;../rescode#cantopen&quot;&gt;SQLITE_CANTOPEN&lt;/a&gt;, this interface could be called to get back the underlying &quot;errno&quot; that caused the problem, such as ENOSPC, EAUTH, EISDIR, and so forth.</source>
          <target state="translated">Попытка вернуть код ошибки базовой операционной системы или номер ошибки, которая вызвала самую последнюю ошибку ввода-вывода или отказ при открытии файла. Возвращаемое значение зависит от ОС. Например, в системах unix после того, как &lt;a href=&quot;open&quot;&gt;sqlite3_open_v2 ()&lt;/a&gt; вернет &lt;a href=&quot;../rescode#cantopen&quot;&gt;SQLITE_CANTOPEN&lt;/a&gt; , этот интерфейс может быть вызван для возврата основного &amp;laquo;errno&amp;raquo;, вызвавшего проблему, такого как ENOSPC, EAUTH, EISDIR и т. Д.</target>
        </trans-unit>
        <trans-unit id="316c0eb6ee34ebe2465e653e0615de6cea48d923" translate="yes" xml:space="preserve">
          <source>Attempting to read any column value except the rowid from a contentless FTS5 table returns an SQL NULL value.</source>
          <target state="translated">Попытка прочитать любое значение столбца,кроме rowid из беспорядочной таблицы FTS5,возвращает SQL NULL значение.</target>
        </trans-unit>
        <trans-unit id="759ff226aedc6e7693575bc9de2859284a195a00" translate="yes" xml:space="preserve">
          <source>Attempts to signal a waiting thread.</source>
          <target state="translated">Попытки сигнализировать ожидающему потоку.</target>
        </trans-unit>
        <trans-unit id="70c4d17e8ff8b4302eac4e4e2a0df21e83e7e1f7" translate="yes" xml:space="preserve">
          <source>Attribute to God, and not to self, whatever good you see in yourself.</source>
          <target state="translated">Приписывайся Богу,а не самому себе,что бы ты ни увидел в себе.</target>
        </trans-unit>
        <trans-unit id="825e25e0e089626089745a27ce2ef2c2c1ea38e6" translate="yes" xml:space="preserve">
          <source>Authorizer Action Codes</source>
          <target state="translated">Коды действий Авторизатора</target>
        </trans-unit>
        <trans-unit id="1592d27599a37fb2c21560009556822d633223ac" translate="yes" xml:space="preserve">
          <source>Authorizer Return Codes</source>
          <target state="translated">Коды возврата авторизатора</target>
        </trans-unit>
        <trans-unit id="8d4b099d8f18d61aaa97d7c1192205d9f09f6d1b" translate="yes" xml:space="preserve">
          <source>Authorizer callback now notified of ALTER TABLE ADD COLUMN commands</source>
          <target state="translated">Обратный вызов авторизатора теперь оповещен о командах ALTER TABLE ADD COLUMN</target>
        </trans-unit>
        <trans-unit id="f99108c69c3665b09cc818cd43a65b08e779b2ac" translate="yes" xml:space="preserve">
          <source>Auto-vacuuming is only possible if the database stores some additional information that allows each database page to be traced backwards to its referrer. Therefore, auto-vacuuming must be turned on before any tables are created. It is not possible to enable or disable auto-vacuum after a table has been created.</source>
          <target state="translated">Автоматическое вакуумирование возможно только в том случае,если в базе данных хранится некоторая дополнительная информация,позволяющая проследить каждую страницу базы данных обратно к ее референту.Поэтому перед созданием таблиц необходимо включить автоматическую вакуумизацию.Невозможно включить или выключить авто-вакуумирование после создания таблицы.</target>
        </trans-unit>
        <trans-unit id="20745b1bcf8af10b98b427193825b087099c77ec" translate="yes" xml:space="preserve">
          <source>AutoCommit</source>
          <target state="translated">AutoCommit</target>
        </trans-unit>
        <trans-unit id="356d8f675fe3749abf68433babe7ea3575fd985f" translate="yes" xml:space="preserve">
          <source>Autocheckpointing is enabled by default with an interval of 1000 or &lt;a href=&quot;compile#default_wal_autocheckpoint&quot;&gt;SQLITE_DEFAULT_WAL_AUTOCHECKPOINT&lt;/a&gt;.</source>
          <target state="translated">Автоматическая проверка включена по умолчанию с интервалом 1000 или &lt;a href=&quot;compile#default_wal_autocheckpoint&quot;&gt;SQLITE_DEFAULT_WAL_AUTOCHECKPOINT&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="22f681c869bb1ea71c5ddca4b639af93b4fef9e9" translate="yes" xml:space="preserve">
          <source>Autoincrement now works for INSERT from a SELECT.</source>
          <target state="translated">Автоинкремент теперь работает для INSERT из SELECT.</target>
        </trans-unit>
        <trans-unit id="be6b6b970c4ffe43f44cd98c8c080e19e0935d7d" translate="yes" xml:space="preserve">
          <source>Automatic Creation Of Triggers</source>
          <target state="translated">Автоматическое создание триггеров</target>
        </trans-unit>
        <trans-unit id="b08dba6041d7d4235968c19294ed55fda427f921" translate="yes" xml:space="preserve">
          <source>Automatic Undo/Redo Using SQLite</source>
          <target state="translated">Автоматическая отмена/перезагрузка при использовании SQLite</target>
        </trans-unit>
        <trans-unit id="e4c6cb294be7b858504d17f8ae3afc2b1d34ca14" translate="yes" xml:space="preserve">
          <source>Automatic Undo/Redo With SQLite</source>
          <target state="translated">Автоматическая отмена/повторная отмена с SQLite</target>
        </trans-unit>
        <trans-unit id="21544829b41ef1983cd743adcc40b46678a3e3f5" translate="yes" xml:space="preserve">
          <source>Automatic caching of prepared statements in the TCL interface</source>
          <target state="translated">Автоматическое кэширование подготовленных заявлений в интерфейсе TCL</target>
        </trans-unit>
        <trans-unit id="5c31289d03ed4b24b0edaf412e508ce77bc130da" translate="yes" xml:space="preserve">
          <source>Automatic indexing</source>
          <target state="translated">Автоматическая индексация</target>
        </trans-unit>
        <trans-unit id="b33bad308a6a3f5703b3375cd2f0464df392fd4f" translate="yes" xml:space="preserve">
          <source>Automatically Load Statically Linked Extensions</source>
          <target state="translated">Автоматически загружать статически сцепленные удлинители</target>
        </trans-unit>
        <trans-unit id="1866c31db7344041c61c845f3e6c7f6209984d28" translate="yes" xml:space="preserve">
          <source>Automatically Running ANALYZE</source>
          <target state="translated">Автоматически работающая АНАЛЫЗА</target>
        </trans-unit>
        <trans-unit id="4babc7f522c90b701f1e40024660f0e6d3fdb828" translate="yes" xml:space="preserve">
          <source>Automatically build binaries for Linux and Windows and put them on the website.</source>
          <target state="translated">Автоматически собирать двоичные файлы для Linux и Windows и размещать их на сайте.</target>
        </trans-unit>
        <trans-unit id="b5a9f83671a7145cd855649b0b10c0da797dd48a" translate="yes" xml:space="preserve">
          <source>Automatically generated ROWIDs are now sequential.</source>
          <target state="translated">Автоматически генерируемые ROWID теперь последовательны.</target>
        </trans-unit>
        <trans-unit id="33b507ce65fb930f163c0cce40902e91ce9a4aa2" translate="yes" xml:space="preserve">
          <source>Automatically intercepts the raw &lt;a href=&quot;eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; output and reformats it into an ASCII-art graph.</source>
          <target state="translated">Автоматически перехватывает необработанный вывод &lt;a href=&quot;eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; и переформатирует его в граф ASCII-art.</target>
        </trans-unit>
        <trans-unit id="415678a6fe9db48ebfdb4a92834062e2d75ff761" translate="yes" xml:space="preserve">
          <source>Automatically running ANALYZE</source>
          <target state="translated">Автоматически работающий ANALYZE</target>
        </trans-unit>
        <trans-unit id="38a90bc3ee0845edb1d6db34dc8f58cfefb8e89a" translate="yes" xml:space="preserve">
          <source>Autovacuum support added</source>
          <target state="translated">Добавлена поддержка автоматического вакуума</target>
        </trans-unit>
        <trans-unit id="1e357312422cd5ec59a0a1ff553c35208f6f0981" translate="yes" xml:space="preserve">
          <source>Auxiliary Function Changes</source>
          <target state="translated">Вспомогательные функции Изменения</target>
        </trans-unit>
        <trans-unit id="2291a1b828f145bde8901e514ec4c748f1d3e7aa" translate="yes" xml:space="preserve">
          <source>Auxiliary columns are marked with a &quot;+&quot; symbol before the column name. Auxiliary columns must come after all of the coordinate boundary columns. There is a limit of no more than 100 auxiliary columns. The following example shows an r-tree table with auxiliary columns that is equivalent to the two tables &quot;demo_index&quot; and &quot;demo_data&quot; above:</source>
          <target state="translated">Вспомогательные колонки перед названием колонки обозначаются символом &quot;+&quot;.Вспомогательные столбцы должны располагаться после всех столбцов границы координат.Существует ограничение не более 100 вспомогательных столбцов.В следующем примере показана таблица r-дерева со вспомогательными столбцами,эквивалентная двум таблицам &quot;demo_index&quot; и &quot;demo_data&quot;,приведенным выше:</target>
        </trans-unit>
        <trans-unit id="107b868f1f6fb032b0de401c1fdc39f9a1324503" translate="yes" xml:space="preserve">
          <source>Auxiliary columns in r-tree tables</source>
          <target state="translated">Вспомогательные колонны в таблицах r-деревьев</target>
        </trans-unit>
        <trans-unit id="6771e220703ae7d95117926a910b1882f3865ed2" translate="yes" xml:space="preserve">
          <source>Auxiliary function mapping</source>
          <target state="translated">Вспомогательное функциональное картирование</target>
        </trans-unit>
        <trans-unit id="2a6030396538d218b7dda424404dbcc0322cf175" translate="yes" xml:space="preserve">
          <source>Auxiliary functions are similar to &lt;a href=&quot;lang_corefunc&quot;&gt;SQL scalar functions&lt;/a&gt;, except that they may only be used within full-text queries (those that use the MATCH operator) on an FTS5 table. Their results are calculated based not only on the arguments passed to them, but also on the current match and matched row. For example, an auxiliary function may return a numeric value indicating the accuracy of the match (see the &lt;a href=&quot;fts5#the_bm25_function&quot;&gt;bm25()&lt;/a&gt; function), or a fragment of text from the matched row that contains one or more instances of the search terms (see the &lt;a href=&quot;fts5#the_snippet_function&quot;&gt;snippet()&lt;/a&gt; function).</source>
          <target state="translated">Вспомогательные функции аналогичны &lt;a href=&quot;lang_corefunc&quot;&gt;скалярным функциям SQL&lt;/a&gt; , за исключением того, что они могут использоваться только в полнотекстовых запросах (тех, которые используют оператор MATCH) к таблице FTS5. Их результаты вычисляются не только на основе переданных им аргументов, но и на основе текущего совпадения и совпавшей строки. Например, вспомогательная функция может возвращать числовое значение, указывающее точность совпадения (см. &lt;a href=&quot;fts5#the_bm25_function&quot;&gt;Функцию bm25 ()&lt;/a&gt; ), или фрагмент текста из сопоставленной строки, который содержит один или несколько экземпляров условий поиска (см. &lt;a href=&quot;fts5#the_snippet_function&quot;&gt;Фрагмент ( )&lt;/a&gt; функция).</target>
        </trans-unit>
        <trans-unit id="ad21e0c1521884ee05b9ffda048d19b6293bf5a4" translate="yes" xml:space="preserve">
          <source>Available as a &lt;a href=&quot;amalgamation&quot;&gt;single ANSI-C source-code file&lt;/a&gt; that is &lt;a href=&quot;howtocompile&quot;&gt;easy to compile&lt;/a&gt; and hence is easy to add into a larger project.</source>
          <target state="translated">Доступен как &lt;a href=&quot;amalgamation&quot;&gt;единый файл исходного кода ANSI-C,&lt;/a&gt; который &lt;a href=&quot;howtocompile&quot;&gt;легко компилировать&lt;/a&gt; и, следовательно, легко добавить в более крупный проект.</target>
        </trans-unit>
        <trans-unit id="91da5ef1fa7e2e4b29d2c4baf5ea203498773356" translate="yes" xml:space="preserve">
          <source>Avoid a possible use-after-free error by deferring schema resets until after the query planner has finished running. Ticket &lt;a href=&quot;https://sqlite.org/src/info/be436a7f4587ce5&quot;&gt;be436a7f4587ce5&lt;/a&gt;</source>
          <target state="translated">Чтобы избежать возможной ошибки использования после освобождения, отложите сброс схемы до завершения работы планировщика запросов. Билет &lt;a href=&quot;https://sqlite.org/src/info/be436a7f4587ce5&quot;&gt;be436a7f4587ce5&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1e3177c978c905dc59ea3eac3bcce9510d2af169" translate="yes" xml:space="preserve">
          <source>Avoid cache pages leaks following disk-full or I/O errors</source>
          <target state="translated">Избегайте утечки страниц в кэше после ошибок,связанных с заполнением диска или вводом/выводом.</target>
        </trans-unit>
        <trans-unit id="61ddd5eec59e56887e4ac83b6d688d5421fe618d" translate="yes" xml:space="preserve">
          <source>Avoid excess heap usage when copying expressions.</source>
          <target state="translated">Избегайте чрезмерного использования кучи при копировании выражений.</target>
        </trans-unit>
        <trans-unit id="24ba1f7d7979447a7e96cb25e07064d86e5bb1c8" translate="yes" xml:space="preserve">
          <source>Avoid invoking the &lt;a href=&quot;c3ref/profile&quot;&gt;sqlite3_trace()&lt;/a&gt; callback multiple times when a statement is automatically reprepared due to &lt;a href=&quot;rescode#schema&quot;&gt;SQLITE_SCHEMA&lt;/a&gt; errors.</source>
          <target state="translated">Избегайте многократного вызова &lt;a href=&quot;c3ref/profile&quot;&gt;функции&lt;/a&gt; обратного вызова sqlite3_trace (), когда оператор автоматически воспроизводится из-за ошибок &lt;a href=&quot;rescode#schema&quot;&gt;SQLITE_SCHEMA&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7080f3e1eff1f709a6ca19cf689cc05b5715bf56" translate="yes" xml:space="preserve">
          <source>Avoid recomputing &lt;a href=&quot;lang_createtable#notnullconst&quot;&gt;NOT NULL&lt;/a&gt; and &lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK constraints&lt;/a&gt; on unchanged columns in &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; statement.</source>
          <target state="translated">Избегайте пересчета &lt;a href=&quot;lang_createtable#ckconst&quot;&gt;ограничений &lt;/a&gt;&lt;a href=&quot;lang_createtable#notnullconst&quot;&gt;NOT NULL&lt;/a&gt; и CHECK для неизмененных столбцов в операторе &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b9f47e376b982a42c816c624a45b787e38257b92" translate="yes" xml:space="preserve">
          <source>Avoid resetting the schema of &lt;a href=&quot;sharedcache&quot;&gt;shared cache&lt;/a&gt; connections when any one connection closes. Instead, wait for the last connection to close before resetting the schema.</source>
          <target state="translated">Избегайте сброса схемы соединений &lt;a href=&quot;sharedcache&quot;&gt;общего кэша&lt;/a&gt; при закрытии любого из соединений. Вместо этого дождитесь закрытия последнего соединения перед сбросом схемы.</target>
        </trans-unit>
        <trans-unit id="d3426fcb94fc158c5d46e9b08cc237640ca2e54e" translate="yes" xml:space="preserve">
          <source>Avoid running foreign-key constraint checks on an UPDATE if none of the modified columns are associated with foreign keys.</source>
          <target state="translated">Избегайте запуска проверок на ограничение посторонних ключей для UPDATE,если ни один из измененных столбцов не связан с посторонними ключами.</target>
        </trans-unit>
        <trans-unit id="fc8f5db6ab5f0aaaf5afe5d9db180abf76160161" translate="yes" xml:space="preserve">
          <source>Avoid this step if possible, as it defeats one of the huge advantages of the whole SQL language concept, specifically that the application programmer does not need to get involved with query planning. If you do use CROSS JOIN, wait until late in your development cycle to do so, and comment the use of CROSS JOIN carefully so that you can take it out later if possible. Avoid using CROSS JOIN early in the development cycle as doing so is a premature optimization, which is well known to be &lt;a href=&quot;http://c2.com/cgi/wiki?PrematureOptimization&quot;&gt;the root of all evil&lt;/a&gt;.</source>
          <target state="translated">По возможности избегайте этого шага, поскольку он сводит на нет одно из огромных преимуществ всей концепции языка SQL, а именно то, что программисту приложения не нужно вмешиваться в планирование запросов. Если вы все же используете CROSS JOIN, дождитесь конца цикла разработки и внимательно прокомментируйте использование CROSS JOIN, чтобы вы могли убрать его позже, если это возможно. Избегайте использования CROSS JOIN на ранних этапах цикла разработки, так как это преждевременная оптимизация, которая, как известно, является &lt;a href=&quot;http://c2.com/cgi/wiki?PrematureOptimization&quot;&gt;корнем всех зол&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d522f897af88e992f364f85aee2e8282258fc265" translate="yes" xml:space="preserve">
          <source>Avoid unnecessary foreign key processing in UPDATE statements that do not touch the columns that are constrained by the foreign keys.</source>
          <target state="translated">Избегайте ненужной обработки посторонних ключей в UPDATE утверждениях,которые не касаются столбцов,ограниченных посторонними ключами.</target>
        </trans-unit>
        <trans-unit id="f0262f30f0e72ef13d068b5ef0d92433c9097800" translate="yes" xml:space="preserve">
          <source>Avoid unnecessary invalidation of &lt;a href=&quot;c3ref/blob&quot;&gt;sqlite3_blob&lt;/a&gt; handles when making changes to unrelated tables.</source>
          <target state="translated">Избегайте ненужного аннулирования дескрипторов &lt;a href=&quot;c3ref/blob&quot;&gt;sqlite3_blob&lt;/a&gt; при внесении изменений в несвязанные таблицы.</target>
        </trans-unit>
        <trans-unit id="2faf372496683418fb5422fedd49afd1602aeb2d" translate="yes" xml:space="preserve">
          <source>Avoid unnecessary loads of columns in an aggregate query that are not within an aggregate function and that are not part of the GROUP BY clause.</source>
          <target state="translated">Избегайте ненужной нагрузки столбцов в совокупном запросе,которые не входят в состав совокупной функции и не являются частью пункта GROUP BY.</target>
        </trans-unit>
        <trans-unit id="0da85f25c4d81aabb9be26649b6528ed9da5a865" translate="yes" xml:space="preserve">
          <source>Avoid unnecessary reparsing of the database schema.</source>
          <target state="translated">Избегайте ненужного переосмысления схемы базы данных.</target>
        </trans-unit>
        <trans-unit id="31ab1c695488dd1d3fd9d54bae9338af8b817457" translate="yes" xml:space="preserve">
          <source>Avoid unnecessary writes to the sqlite_sequence table when an &lt;a href=&quot;autoinc&quot;&gt;AUTOINCREMENT&lt;/a&gt; table is updated with an rowid that is less than the maximum.</source>
          <target state="translated">Избегайте ненужных операций записи в таблицу sqlite_sequence когда &lt;a href=&quot;autoinc&quot;&gt;AUTOINCREMENT&lt;/a&gt; таблица обновляется с ROWID'ом, меньше максимума.</target>
        </trans-unit>
        <trans-unit id="446e18ff4fd4514774047f13cdefc3e3875bc4b1" translate="yes" xml:space="preserve">
          <source>Avoid using a prepared statement for &quot;.stats on&quot; command of the &lt;a href=&quot;cli&quot;&gt;CLI&lt;/a&gt; after it has been closed by the &quot;.eqp full&quot; logicc. Fix for ticket &lt;a href=&quot;https://www.sqlite.org/src/info/7be932dfa60a8a6b3b26bcf76&quot;&gt;7be932dfa60a8a6b3b26bcf76&lt;/a&gt;.</source>
          <target state="translated">Избегайте использования подготовленного оператора для команды &amp;laquo;.stats on&amp;raquo; &lt;a href=&quot;cli&quot;&gt;интерфейса&lt;/a&gt; командной строки после того, как он был закрыт логикой &amp;laquo;.eqp full&amp;raquo;. Исправление для билета &lt;a href=&quot;https://www.sqlite.org/src/info/7be932dfa60a8a6b3b26bcf76&quot;&gt;7be932dfa60a8a6b3b26bcf76&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e234fd1edb94740adc1207ebef38597b49b7c1f2" translate="yes" xml:space="preserve">
          <source>Avoiding the use of low-numbered file descriptors is a defense against accidental database corruption. If a database file was opened using file descriptor 2, for example, and then an assert() failed and invoked write(2,...), that would likely cause database corruption by overwriting part of the database file with the assertion error message. Using only higher-valued file descriptors avoids this potential problem. The protection against using low-numbered file descriptors can be disabled by setting this compile-time option to 0.</source>
          <target state="translated">Избегание использования файловых дескрипторов с низким номером является защитой от случайного повреждения базы данных.Если,например,файл базы данных был открыт с помощью файлового дескриптора 2,а затем assert()отказал и вызвал запись(2,...),то это,скорее всего,приведет к повреждению базы данных,перезаписывая часть файла базы данных сообщением об ошибке утверждения.Использование только файловых дескрипторов более высокого значения позволяет избежать этой потенциальной проблемы.Защиту от использования низкопронумерованных файловых дескрипторов можно отключить,установив значение параметра времени компиляции равным 0.</target>
        </trans-unit>
        <trans-unit id="a4253b60bc870d118d832ba2a3c8eabe133ebeb0" translate="yes" xml:space="preserve">
          <source>Aways stores polygons using the binary format, which is faster and uses less space.</source>
          <target state="translated">Aways хранит полигоны,используя бинарный формат,который быстрее и занимает меньше места.</target>
        </trans-unit>
        <trans-unit id="209ebb59c54866e4ac4c2bdf04c9d0b7b4a958ec" translate="yes" xml:space="preserve">
          <source>B-Tree</source>
          <target state="translated">B-Tree</target>
        </trans-unit>
        <trans-unit id="b149afb9ac3420444ce1e62aefbcdead10e7e777" translate="yes" xml:space="preserve">
          <source>B-tree</source>
          <target state="translated">B-tree</target>
        </trans-unit>
        <trans-unit id="5b87dc158f4c367648401e86eddf1c6445bb5bf6" translate="yes" xml:space="preserve">
          <source>B-tree Cell Format</source>
          <target state="translated">Формат ячеек B-дерева</target>
        </trans-unit>
        <trans-unit id="92950af5441bd3255130ef7a72cc86532e49b1e9" translate="yes" xml:space="preserve">
          <source>B-tree Page Header Format</source>
          <target state="translated">Формат заголовка страницы B-дерева</target>
        </trans-unit>
        <trans-unit id="90a72ea1d2706a588dd39ad58e7cba99ec26696d" translate="yes" xml:space="preserve">
          <source>BEFORE</source>
          <target state="translated">BEFORE</target>
        </trans-unit>
        <trans-unit id="3598517c826f1480a241800ce73f781ae2b1cd6a" translate="yes" xml:space="preserve">
          <source>BEGIN</source>
          <target state="translated">BEGIN</target>
        </trans-unit>
        <trans-unit id="4821edeb87e72ffadc6bc2dd7758d1af495e515f" translate="yes" xml:space="preserve">
          <source>BEGIN IMMEDIATE</source>
          <target state="translated">НАЧИНАТЬ НЕМЕДЛЕННО</target>
        </trans-unit>
        <trans-unit id="8913dda08c8185748e987da82c484c6d35030cb9" translate="yes" xml:space="preserve">
          <source>BEGIN TRANSACTION</source>
          <target state="translated">НАЧАТЬ СДЕЛКУ</target>
        </trans-unit>
        <trans-unit id="51b1b0c3e98b1211a4bf44a668731efbeb0029e7" translate="yes" xml:space="preserve">
          <source>BEGIN;</source>
          <target state="translated">BEGIN;</target>
        </trans-unit>
        <trans-unit id="f8e3370718865431368fd54f746d7da4322cc582" translate="yes" xml:space="preserve">
          <source>BETWEEN</source>
          <target state="translated">BETWEEN</target>
        </trans-unit>
        <trans-unit id="2d0fe684054a53889de74128877e23cf3189b322" translate="yes" xml:space="preserve">
          <source>BIGINT</source>
          <target state="translated">BIGINT</target>
        </trans-unit>
        <trans-unit id="d05fb01e0b399387c3a28586f5fd296e2670d6a3" translate="yes" xml:space="preserve">
          <source>BINARY</source>
          <target state="translated">BINARY</target>
        </trans-unit>
        <trans-unit id="1ce04f29dadb9973458555f164627f66e504686e" translate="yes" xml:space="preserve">
          <source>BLOB</source>
          <target state="translated">BLOB</target>
        </trans-unit>
        <trans-unit id="21ca9d91ce78c58717f1f26654ca03e2a7b624ba" translate="yes" xml:space="preserve">
          <source>BLOB (a.k.a &quot;NONE&quot;)</source>
          <target state="translated">БЛОБ (так же известный как &quot;НЕТ&quot;)</target>
        </trans-unit>
        <trans-unit id="16304f06bca682f9f5ee4a2a62fcbf2abac5ed50" translate="yes" xml:space="preserve">
          <source>BLOB literals are string literals containing hexadecimal data and preceded by a single &quot;x&quot; or &quot;X&quot; character. Example: X'53514C697465'</source>
          <target state="translated">BLOB-литералы-это строковые литералы,содержащие шестнадцатиричные данные,которым предшествует один символ &quot;x&quot; или &quot;X&quot;.Пример:X'53514C697465''.</target>
        </trans-unit>
        <trans-unit id="fb465d6672ffe8826d619cf7ad2f842e941cbb22" translate="yes" xml:space="preserve">
          <source>BLOB size</source>
          <target state="translated">размер BLOB</target>
        </trans-unit>
        <trans-unit id="80845ed51d0eb2f39da54fe848593b51f5b7523f" translate="yes" xml:space="preserve">
          <source>BLOB support.</source>
          <target state="translated">Поддержка BLOB.</target>
        </trans-unit>
        <trans-unit id="9bf36d55a66f6b65f2497e6f96eb9c688f9ee788" translate="yes" xml:space="preserve">
          <source>BLOB values (even serial types 12 and larger) sort last and in the order determined by memcmp().</source>
          <target state="translated">BLOB-значения (даже последовательные типы 12 и выше)сортируются последними и в порядке,определяемом функцией memcmp().</target>
        </trans-unit>
        <trans-unit id="066ed32331b295c453ee3f4c55916aa0d7c725b0" translate="yes" xml:space="preserve">
          <source>BLOBs sort last</source>
          <target state="translated">BLOB-сообщения сортируются последними</target>
        </trans-unit>
        <trans-unit id="ab68d8e893a82cff70979ba20bec0023dbfe4be3" translate="yes" xml:space="preserve">
          <source>BOOLEAN</source>
          <target state="translated">BOOLEAN</target>
        </trans-unit>
        <trans-unit id="64c3f5e89864d5e803ba483fadc3c80068321744" translate="yes" xml:space="preserve">
          <source>BY</source>
          <target state="translated">BY</target>
        </trans-unit>
        <trans-unit id="987f01f766f58cd662fc3c685393d0d4667cbc0b" translate="yes" xml:space="preserve">
          <source>Back up cursor P1 so that it points to the previous key/data pair in its table or index. If there is no previous key/value pairs then fall through to the following instruction. But if the cursor backup was successful, jump immediately to P2.</source>
          <target state="translated">Сделайте резервную копию курсора P1 так,чтобы он указывал на предыдущую пару клавиш/данных в своей таблице или индексе.Если нет предыдущих пар ключ/значение,то перейдите к следующей инструкции.Но если резервное копирование курсора прошло успешно,немедленно перейдите к P2.</target>
        </trans-unit>
        <trans-unit id="f09881dbbda2f40a1bff480104e690d3c9470795" translate="yes" xml:space="preserve">
          <source>Backport a &lt;a href=&quot;https://www.sqlite.org/src/info/c648539b52ca28c0&quot;&gt;simple query planner optimization&lt;/a&gt; that allows the IS operator to drive an index on a LEFT OUTER JOIN. No other changes from the &lt;a href=&quot;#version_3_9_2&quot;&gt;version 3.9.2&lt;/a&gt; baseline.</source>
          <target state="translated">Backport - &lt;a href=&quot;https://www.sqlite.org/src/info/c648539b52ca28c0&quot;&gt;простая оптимизация планировщика запросов,&lt;/a&gt; которая позволяет оператору IS управлять индексом по LEFT OUTER JOIN. Никаких других изменений по &lt;a href=&quot;#version_3_9_2&quot;&gt;сравнению с&lt;/a&gt; базовой версией 3.9.2 .</target>
        </trans-unit>
        <trans-unit id="88c7762ebd772cef5a8b0f5dbf885740af02d796" translate="yes" xml:space="preserve">
          <source>Backup A: &lt;a href=&quot;https://www2.sqlite.org/docsrc&quot;&gt;https://www2.sqlite.org/docsrc&lt;/a&gt;</source>
          <target state="translated">Резервная копия A: &lt;a href=&quot;https://www2.sqlite.org/docsrc&quot;&gt;https://www2.sqlite.org/docsrc&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3758d4866043fb72f7921be565221b2798bf18ec" translate="yes" xml:space="preserve">
          <source>Backup A: &lt;a href=&quot;https://www2.sqlite.org/src&quot;&gt;https://www2.sqlite.org/src&lt;/a&gt;</source>
          <target state="translated">Резервная копия A: &lt;a href=&quot;https://www2.sqlite.org/src&quot;&gt;https://www2.sqlite.org/src&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5635a7bbe580f297d0f1cfe698eb39a60af249f7" translate="yes" xml:space="preserve">
          <source>Backup A: &lt;a href=&quot;https://www2.sqlite.org/th3&quot;&gt;https://www2.sqlite.org/th3&lt;/a&gt;</source>
          <target state="translated">Резервная копия A: &lt;a href=&quot;https://www2.sqlite.org/th3&quot;&gt;https://www2.sqlite.org/th3&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="354ff6f3afacd7c64aab0b45ca232e39fd5ab191" translate="yes" xml:space="preserve">
          <source>Backup B: &lt;a href=&quot;https://www3.sqlite.org/docsrc&quot;&gt;https://www3.sqlite.org/docsrc&lt;/a&gt;</source>
          <target state="translated">Резервная копия B: &lt;a href=&quot;https://www3.sqlite.org/docsrc&quot;&gt;https://www3.sqlite.org/docsrc&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a437cf7f4394ac5ab3c8c6bf1f4decbf817f299c" translate="yes" xml:space="preserve">
          <source>Backup B: &lt;a href=&quot;https://www3.sqlite.org/src&quot;&gt;https://www3.sqlite.org/src&lt;/a&gt;</source>
          <target state="translated">Резервная копия B: &lt;a href=&quot;https://www3.sqlite.org/src&quot;&gt;https://www3.sqlite.org/src&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="06b0bc099757fb937c2145628c4ebe2caf89fed6" translate="yes" xml:space="preserve">
          <source>Backup B: &lt;a href=&quot;https://www3.sqlite.org/th3&quot;&gt;https://www3.sqlite.org/th3&lt;/a&gt;</source>
          <target state="translated">Резервная копия B: &lt;a href=&quot;https://www3.sqlite.org/th3&quot;&gt;https://www3.sqlite.org/th3&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ad652023d4f99d0238bf9d42108eaead0a853d3a" translate="yes" xml:space="preserve">
          <source>Backup-filename</source>
          <target state="translated">Backup-filename</target>
        </trans-unit>
        <trans-unit id="8999e5aefef2d471c86fa4aebf649d22b2fddfc3" translate="yes" xml:space="preserve">
          <source>Backups on private servers</source>
          <target state="translated">Резервное копирование на частных серверах</target>
        </trans-unit>
        <trans-unit id="63591d4f03e6c8c8462a238e710f0f3cd900691f" translate="yes" xml:space="preserve">
          <source>Backwards compatibility constraints mean that SQLite is only able to store values that are NULL, integers, floating-point numbers, text, and BLOBs. It is not possible to add a sixth &quot;JSON&quot; type.</source>
          <target state="translated">Ограничения обратной совместимости означают,что SQLite может хранить только значения NULL,целые числа,числа с плавающей точкой,текст и BLOB.Невозможно добавить шестой тип &quot;JSON&quot;.</target>
        </trans-unit>
        <trans-unit id="ac8e908309343005a016d54d23589bde15362521" translate="yes" xml:space="preserve">
          <source>Backwards compatibility note:</source>
          <target state="translated">Указание на обратную совместимость:</target>
        </trans-unit>
        <trans-unit id="70457c51de59bc0303eae7ef527e14f90b80a187" translate="yes" xml:space="preserve">
          <source>Backwards-incompatible changes to some extensions in order to take advantage of the improved security offered by the new &lt;a href=&quot;bindptr&quot;&gt;pointer passing interfaces&lt;/a&gt;:</source>
          <target state="translated">Изменения с обратной несовместимостью в некоторых расширениях, чтобы воспользоваться преимуществами улучшенной безопасности, предлагаемой новыми &lt;a href=&quot;bindptr&quot;&gt;интерфейсами передачи указателей&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="af928fbbb6d75554958505ba9734eca9710f8051" translate="yes" xml:space="preserve">
          <source>Bad programmers worry about the code. Good programmers worry about data structures and their relationships.</source>
          <target state="translated">Плохие программисты беспокоятся о коде.Хорошие программисты беспокоятся о структурах данных и их взаимоотношениях.</target>
        </trans-unit>
        <trans-unit id="d97ded08ec4df20e52b3ce05668bb0a2705fa978" translate="yes" xml:space="preserve">
          <source>Bare aggregate terms</source>
          <target state="translated">Голые агрегированные условия</target>
        </trans-unit>
        <trans-unit id="5e2b9b9d48fdc95bbb5af1e6353dd4395e3738d9" translate="yes" xml:space="preserve">
          <source>Based on the above, SQLite is designed around a model of the file-system whereby any sector of a file written to is considered to be in a transient state until after the file has been successfully</source>
          <target state="translated">Основываясь на вышеизложенном,SQLite спроектирован по модели файловой системы,при которой любой сектор файла,в который он записан,считается находящимся в переходном состоянии до тех пор,пока файл не будет успешно завершен.</target>
        </trans-unit>
        <trans-unit id="2843b17c6eb4616657b580040fb118c722f6edb6" translate="yes" xml:space="preserve">
          <source>Be a help in times of trouble.</source>
          <target state="translated">Помогите во время неприятностей.</target>
        </trans-unit>
        <trans-unit id="d1a6a5570deb3a7eb7ea55daa060ee1c39dbe74c" translate="yes" xml:space="preserve">
          <source>Be a stranger to the world's ways.</source>
          <target state="translated">Будь чужим для всего мира.</target>
        </trans-unit>
        <trans-unit id="7fe99077b2a420989db9a6580456c2197461f868" translate="yes" xml:space="preserve">
          <source>Be careful when using the &quot;.save&quot; command as it will overwrite any preexisting database files having the same name without prompting for confirmation. As with the &quot;.open&quot; command, you might want to use a full pathname with forward-slash directory separators to avoid ambiguity.</source>
          <target state="translated">Будьте осторожны при использовании команды &quot;.save&quot;,так как она перезапишет все существующие файлы БД с таким же именем без запроса подтверждения.Как и в случае с командой &quot;.open&quot;,во избежание двусмысленности можно использовать полное имя пути с разделителями каталогов forward-slash.</target>
        </trans-unit>
        <trans-unit id="131acb5be798f8713c6bbeeaf8a6813dbe81748d" translate="yes" xml:space="preserve">
          <source>Be in dread of hell.</source>
          <target state="translated">Будь в адском ужасе.</target>
        </trans-unit>
        <trans-unit id="dbdb220ba30f3bde62d258265aacea82a8c9ef6a" translate="yes" xml:space="preserve">
          <source>Be not a detractor.</source>
          <target state="translated">Будь не хулителем.</target>
        </trans-unit>
        <trans-unit id="d18586b20264d29baf4b88bd2bdc140f64986d83" translate="yes" xml:space="preserve">
          <source>Be not a great eater.</source>
          <target state="translated">Будь не очень хорошим едоком.</target>
        </trans-unit>
        <trans-unit id="7c62076277d9f6b2639631bb528912ff4eff4ffa" translate="yes" xml:space="preserve">
          <source>Be not a grumbler.</source>
          <target state="translated">Не ворчи.</target>
        </trans-unit>
        <trans-unit id="288a450b2fc66179cb51c9c9d0a00b7f03fc2121" translate="yes" xml:space="preserve">
          <source>Be not addicted to wine.</source>
          <target state="translated">Не пристраститься к вину.</target>
        </trans-unit>
        <trans-unit id="30d66a95d2dfd76a1e01a40e31a7daa8f6db0117" translate="yes" xml:space="preserve">
          <source>Be not drowsy.</source>
          <target state="translated">Не будь сонливым.</target>
        </trans-unit>
        <trans-unit id="c8f81046cf302e1b08a651f45ee31005254461af" translate="yes" xml:space="preserve">
          <source>Be not jealous, nor harbor envy.</source>
          <target state="translated">Не ревнуй и не завидуй гавани.</target>
        </trans-unit>
        <trans-unit id="6f5bf647a944160204f29d66b6480eda5640fcdc" translate="yes" xml:space="preserve">
          <source>Be not lazy.</source>
          <target state="translated">Не ленитесь.</target>
        </trans-unit>
        <trans-unit id="1c899d6734a837258800bab2a2f7343b95199829" translate="yes" xml:space="preserve">
          <source>Be not proud.</source>
          <target state="translated">Не гордись.</target>
        </trans-unit>
        <trans-unit id="9305ebf69b60c3d882da16805b530bbf3e6f3d95" translate="yes" xml:space="preserve">
          <source>Bear persecution for justice's sake.</source>
          <target state="translated">Преследование ради справедливости.</target>
        </trans-unit>
        <trans-unit id="6ca5c28c37834244df00d49b68c2bef2606b1e1f" translate="yes" xml:space="preserve">
          <source>Because &quot;text&quot; columns have a different sort order from numeric, indices on &quot;text&quot; columns occur in a different order for version 2.7.0 and later database. Hence version 2.6.3 and earlier of SQLite will be unable to read a 2.7.0 or later database. But version 2.7.0 and later of SQLite will read earlier databases.</source>
          <target state="translated">Поскольку &quot;текстовые&quot; столбцы имеют иной порядок сортировки,чем цифровые,индексы на &quot;текстовых&quot; столбцах встречаются в другом порядке для базы данных версии 2.7.0 и более поздних версий.Поэтому версия 2.6.3 и более ранние версии SQLite не смогут прочитать базу данных 2.7.0 и более поздних версий.Но версии 2.7.0 и выше SQLite будет читать базы данных более ранних версий.</target>
        </trans-unit>
        <trans-unit id="85eeb52404350645676cc7b1bb211e4acfd5ad5b" translate="yes" xml:space="preserve">
          <source>Because AUTOINCREMENT keyword changes the behavior of the ROWID selection algorithm, AUTOINCREMENT is not allowed on &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables or on any table column other than INTEGER PRIMARY KEY. Any attempt to use AUTOINCREMENT on a &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; table or on a column other than the INTEGER PRIMARY KEY column results in an error.</source>
          <target state="translated">Поскольку ключевое слово AUTOINCREMENT изменяет поведение алгоритма выбора ROWID, AUTOINCREMENT не допускается в таблицах &lt;a href=&quot;withoutrowid&quot;&gt;БЕЗ ROWID&lt;/a&gt; или в любом столбце таблицы, кроме INTEGER PRIMARY KEY. Любая попытка использовать &lt;a href=&quot;withoutrowid&quot;&gt;AUTOINCREMENT в&lt;/a&gt; таблице БЕЗ ROWID или в столбце, отличном от столбца INTEGER PRIMARY KEY, приводит к ошибке.</target>
        </trans-unit>
        <trans-unit id="eeb868502c2d293980db003c26a1d7e59cde0343" translate="yes" xml:space="preserve">
          <source>Because FTS3 and FTS4 are virtual tables, The &lt;a href=&quot;compile#enable_fts3&quot;&gt;SQLITE_ENABLE_FTS3&lt;/a&gt; compile-time option is incompatible with the &lt;a href=&quot;compile#omit_virtualtable&quot;&gt;SQLITE_OMIT_VIRTUALTABLE&lt;/a&gt; option.</source>
          <target state="translated">Поскольку FTS3 и FTS4 являются виртуальными таблицами, &lt;a href=&quot;compile#enable_fts3&quot;&gt;параметр времени&lt;/a&gt; компиляции SQLITE_ENABLE_FTS3 несовместим с параметром &lt;a href=&quot;compile#omit_virtualtable&quot;&gt;SQLITE_OMIT_VIRTUALTABLE&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4912d0649aa9ed8b2a285af375de29c2823b504b" translate="yes" xml:space="preserve">
          <source>Because Lemon is a program not normally found on development machines, the complete source code to Lemon (just one C file) is included in the SQLite distribution in the &quot;tool&quot; subdirectory.</source>
          <target state="translated">Поскольку Lemon-это программа,которая обычно не встречается на машинах разработки,полный исходный код Lemon (всего один файл на C)включается в дистрибутив SQLite в подкаталоге &quot;tool&quot;.</target>
        </trans-unit>
        <trans-unit id="c877f3293b1082ca722e1e4a350d52f335812101" translate="yes" xml:space="preserve">
          <source>Because SQLite is flexible and forgiving with regard to datatypes, table columns can be created that have no specified datatype at all. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89b4ac6aceecf052168be7879566274bb4b65047" translate="yes" xml:space="preserve">
          <source>Because ZIP archives are optimized for storing big chunks of content, they encourage a style of programming where the entire document is read into memory at startup, all editing occurs in memory, then the entire document is written to disk during &quot;File/Save&quot;. OpenOffice and its descendants embrace that pattern.</source>
          <target state="translated">Поскольку ZIP-архивы оптимизированы для хранения больших кусков содержимого,они поощряют стиль программирования,при котором весь документ считывается в память при запуске,все редактирование происходит в памяти,а затем весь документ записывается на диск во время &quot;Файл/Сохранить&quot;.OpenOffice и его потомки принимают этот шаблон.</target>
        </trans-unit>
        <trans-unit id="1aef204394eb2f42a054518ac1383e25f6308e7c" translate="yes" xml:space="preserve">
          <source>Because allocations are all the same size, the memory allocator can operate much faster. The allocator need not bother with coalescing adjacent free slots or searching for a slot of an appropriate size. All unallocated memory slots can be stored on a linked list. Allocating consists of removing the first entry from the list. Deallocating is simply adding an entry to the beginning of the list.</source>
          <target state="translated">Поскольку все выделения имеют одинаковый размер,аллокатор памяти может работать намного быстрее.При этом аллокатору не нужно беспокоиться о коалесцирующих соседних свободных слотах или о поиске слота соответствующего размера.Все нераспределенные слоты памяти могут храниться в связанном списке.Выделение состоит в удалении первой записи из списка.Удаление-это простое добавление записи в начало списка.</target>
        </trans-unit>
        <trans-unit id="8fe792a90bccd6800bd67f3f37ebbaabb1467610" translate="yes" xml:space="preserve">
          <source>Because an SQLite database is a single compact file in a &lt;a href=&quot;fileformat2&quot;&gt;well-defined cross-platform format&lt;/a&gt;, it is often used as a container for transferring content from one system to another. The sender gathers content into an SQLite database file, transfers that one file to the receiver, then the receiver uses SQL to extract the content as needed.</source>
          <target state="translated">Поскольку база данных SQLite представляет собой единый компактный файл в &lt;a href=&quot;fileformat2&quot;&gt;четко определенном кроссплатформенном формате&lt;/a&gt; , он часто используется в качестве контейнера для передачи контента из одной системы в другую. Отправитель собирает контент в файл базы данных SQLite, передает этот единственный файл получателю, а затем получатель использует SQL для извлечения контента по мере необходимости.</target>
        </trans-unit>
        <trans-unit id="a4c1f92dc828402b18e6e117bb816b40d1c734ed" translate="yes" xml:space="preserve">
          <source>Because an SQLite database requires no administration, it works well in devices that must operate without expert human support. SQLite is a good fit for use in cellphones, set-top boxes, televisions, game consoles, cameras, watches, kitchen appliances, thermostats, automobiles, machine tools, airplanes, remote sensors, drones, medical devices, and robots: the &quot;internet of things&quot;.</source>
          <target state="translated">Поскольку база данных SQLite не требует администрирования,она хорошо работает на устройствах,которые должны работать без экспертной поддержки человека.SQLite хорошо подходит для использования в сотовых телефонах,телевизионных приставках,телевизорах,игровых приставках,камерах,часах,кухонных приборах,термостатах,автомобилях,станках,самолетах,дистанционных датчиках,беспилотных летательных аппаратах,медицинских приборах,а также в роботах:&quot;интернет вещей&quot;.</target>
        </trans-unit>
        <trans-unit id="788be5cf964c9ee21f08ece0ea7377ef2e19234d" translate="yes" xml:space="preserve">
          <source>Because assert() can be and is commonly misused, some programming language theorists and designers look upon it with disfavor. For example, the designers of the &lt;a href=&quot;https://golang.org&quot;&gt;Go programming language&lt;/a&gt; intentionally &lt;a href=&quot;https://golang.org/doc/faq#assertions&quot;&gt;omit a built-in assert()&lt;/a&gt;. They feel that the harm caused by misuse of assert() outweighs the benefits of including it as a language built-in. The SQLite developers disagree. In fact, the original purpose of this article is to push back against the common notion that assert() is harmful. In our experience, SQLite would be much more difficult to develop, test, and maintain without assert().</source>
          <target state="translated">Поскольку assert () может использоваться и часто используется неправильно, некоторые теоретики и дизайнеры языков программирования смотрят на него с неодобрением. Например, разработчики языка программирования &lt;a href=&quot;https://golang.org&quot;&gt;Go&lt;/a&gt; намеренно &lt;a href=&quot;https://golang.org/doc/faq#assertions&quot;&gt;опускают встроенный assert ()&lt;/a&gt; . Они считают, что вред от неправильного использования assert () перевешивает преимущества его включения в качестве встроенного языка. Разработчики SQLite не согласны. Фактически, первоначальная цель этой статьи - опровергнуть распространенное представление о том, что assert () вреден. По нашему опыту, SQLite было бы намного сложнее разрабатывать, тестировать и поддерживать без assert ().</target>
        </trans-unit>
        <trans-unit id="a6c8b76107dc390feb365087dd23a9e6847d8ec8" translate="yes" xml:space="preserve">
          <source>Because it does not have a central server to coordinate access, SQLite must close and reopen the database file, and thus invalidate its cache, for each transaction. In this test, each SQL statement is a separate transaction so the database file must be opened and closed and the cache must be flushed 1000 times. In spite of this, the asynchronous version of SQLite is still nearly as fast as MySQL. Notice how much slower the synchronous version is, however. SQLite calls &lt;b&gt;fsync()&lt;/b&gt; after each synchronous transaction to make sure that all data is safely on the disk surface before continuing. For most of the 13 seconds in the synchronous test, SQLite was sitting idle waiting on disk I/O to complete.</source>
          <target state="translated">Поскольку у него нет центрального сервера для координации доступа, SQLite должен закрыть и повторно открыть файл базы данных и, таким образом, сделать его кеш недействительным для каждой транзакции. В этом тесте каждый оператор SQL представляет собой отдельную транзакцию, поэтому файл базы данных должен быть открыт и закрыт, а кэш должен быть очищен 1000 раз. Несмотря на это, асинхронная версия SQLite по-прежнему почти такая же быстрая, как MySQL. Обратите внимание, однако, насколько медленнее синхронная версия. SQLite вызывает &lt;b&gt;fsync ()&lt;/b&gt; после каждой синхронной транзакции, чтобы убедиться, что все данные безопасно находятся на поверхности диска, прежде чем продолжить. Большую часть 13 секунд в синхронном тесте SQLite простаивал, ожидая завершения дискового ввода-вывода.</target>
        </trans-unit>
        <trans-unit id="44c3dab6a322e3be0dd40f52ec50b7f7abadf611" translate="yes" xml:space="preserve">
          <source>Because it is a simulator, running a binary in Valgrind is slower than running it on native hardware. (To a first approximation, an application running in Valgrind on a workstation will perform about the same as it would running natively on a smartphone.) So it is impractical to run the full SQLite test suite through Valgrind. However, the veryquick tests and the coverage of the TH3 tests are run through Valgrind prior to every release.</source>
          <target state="translated">Потому что это симулятор,запуск бинарного файла в Valgrind медленнее,чем запуск на родном оборудовании.(В первом приближении,приложение,запущенное в Valgrind на рабочей станции,будет работать примерно так же,как и приложение,запущенное на смартфоне).Поэтому нецелесообразно запускать полный набор тестов SQLite через Valgrind.Однако,очень быстрые тесты и покрытие TH3 тестов выполняются через Valgrind до каждого релиза.</target>
        </trans-unit>
        <trans-unit id="2d7f244d51b1fc8bd92e3755f3ff4412ae2f2b57" translate="yes" xml:space="preserve">
          <source>Because it is simple to setup and use (installation is trivial: just copy the &lt;b&gt;sqlite3&lt;/b&gt; or &lt;b&gt;sqlite3.exe&lt;/b&gt; executable to the target machine and run it) SQLite makes a good database engine for use in teaching SQL. Students can easily create as many databases as they like and can email databases to the instructor for comments or grading. For more advanced students who are interested in studying how an RDBMS is implemented, the modular and well-commented and documented SQLite code can serve as a good basis.</source>
          <target state="translated">Потому что это просто в установке и использовании (установка тривиальна: просто скопируйте &lt;b&gt;sqlite3&lt;/b&gt; или &lt;b&gt;sqlite3.exe&lt;/b&gt; исполняемый файл на целевую машину и запустить его) SQLite делает движок базы данных хорошо для использования в преподавании SQL. Студенты могут легко создавать столько баз данных, сколько захотят, и могут отправлять базы данных преподавателю по электронной почте для комментариев или выставления оценок. Для более продвинутых студентов, которые заинтересованы в изучении того, как реализована СУБД, хорошей основой может служить модульный, хорошо прокомментированный и документированный код SQLite.</target>
        </trans-unit>
        <trans-unit id="4f8ea41ffd9236f49c6f3b48d5813c7ba03da82f" translate="yes" xml:space="preserve">
          <source>Because it reorganizes the entire FTS index, the optimize command can take a long time to run. The &lt;a href=&quot;fts5#the_merge_command&quot;&gt;FTS5 merge command&lt;/a&gt; can be used to divide the work of optimizing the FTS index into multiple steps. To do this:</source>
          <target state="translated">Поскольку она реорганизует весь индекс FTS, выполнение команды optimize может занять много времени. &lt;a href=&quot;fts5#the_merge_command&quot;&gt;Команда FTS5 слияния&lt;/a&gt; может быть использована для разделения работы по оптимизации индекса FTS на несколько шагов. Сделать это:</target>
        </trans-unit>
        <trans-unit id="444393da5087c1cdc4456d5a26de8bf63b917b08" translate="yes" xml:space="preserve">
          <source>Because it stores extra information on disk in two new &lt;a href=&quot;fts3#*shadowtab&quot;&gt;shadow tables&lt;/a&gt; in order to support the performance optimizations and extra matchinfo() options, FTS4 tables may consume more disk space than the equivalent table created using FTS3. Usually the overhead is 1-2% or less, but may be as high as 10% if the documents stored in the FTS table are very small. The overhead may be reduced by specifying the directive &lt;a href=&quot;fts3#fts4matchinfo&quot;&gt;&quot;matchinfo=fts3&quot;&lt;/a&gt; as part of the FTS4 table declaration, but this comes at the expense of sacrificing some of the extra supported matchinfo() options.</source>
          <target state="translated">Поскольку он хранит дополнительную информацию на диске в двух новых &lt;a href=&quot;fts3#*shadowtab&quot;&gt;теневых таблицах&lt;/a&gt; для поддержки оптимизации производительности и дополнительных параметров matchinfo (), таблицы FTS4 могут занимать больше дискового пространства, чем эквивалентная таблица, созданная с помощью FTS3. Обычно накладные расходы составляют 1-2% или меньше, но могут достигать 10%, если документы, хранящиеся в таблице FTS, очень малы. Накладные расходы можно уменьшить, указав директиву &lt;a href=&quot;fts3#fts4matchinfo&quot;&gt;matchinfo = fts3&lt;/a&gt; как часть объявления таблицы FTS4, но это происходит за счет принесения в жертву некоторых из дополнительных поддерживаемых параметров matchinfo ().</target>
        </trans-unit>
        <trans-unit id="c9b96b15368e6c99132d7d8a67a04e723712af54" translate="yes" xml:space="preserve">
          <source>Because lookaside allocations are always the same size, the allocation and deallocation algorithms are very quick. There is no need to coalesce adjacent free slots or search for a slot of a particular size. Each &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; maintains a singly-linked list of unused slots. Allocation requests simply pull the first element of this list. Deallocations simply push the element back onto the front of the list. Furthermore, each &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; is assumed to already be running in a single thread (there are mutexes already in place to enforce this) so no additional mutexing is required to serialize access to the lookaside slot freelist. Consequently, lookaside memory allocations and deallocations are very fast. In speed tests on Linux and Mac OS X workstations, SQLite has shown overall performance improvements as high as 10% and 15%, depending on the workload how and lookaside is configured.</source>
          <target state="translated">Поскольку резервные выделения всегда имеют одинаковый размер, алгоритмы выделения и освобождения выполняются очень быстро. Нет необходимости объединять соседние свободные слоты или искать слот определенного размера. Каждое &lt;a href=&quot;c3ref/sqlite3&quot;&gt;соединение с базой данных&lt;/a&gt; поддерживает односвязный список неиспользуемых слотов. Запросы на размещение просто вытягивают первый элемент этого списка. Освобождение просто перемещает элемент обратно в начало списка. Кроме того, каждое &lt;a href=&quot;c3ref/sqlite3&quot;&gt;соединение с базой данных&lt;/a&gt;предполагается, что он уже запущен в одном потоке (уже существуют мьютексы для обеспечения этого), поэтому для сериализации доступа к свободному списку дополнительных слотов не требуется никакого дополнительного мьютекса. Следовательно, резервное выделение и освобождение памяти происходит очень быстро. В тестах скорости на рабочих станциях Linux и Mac OS X общий рост производительности SQLite составил от 10% до 15%, в зависимости от того, как и как настроена рабочая нагрузка.</target>
        </trans-unit>
        <trans-unit id="668e105a1044bfeea3b1760bf6f04ba2a54183c0" translate="yes" xml:space="preserve">
          <source>Because main-memory is a limited resource, the</source>
          <target state="translated">Так как главная память-это ограниченный ресурс,то</target>
        </trans-unit>
        <trans-unit id="fdc0f2ea6af2e7d5aa2876f1718288d4bc691129" translate="yes" xml:space="preserve">
          <source>Because of continuing security concerns, the two-argument version of of the seldom-used and little-known &lt;a href=&quot;fts3#f3tknzr&quot;&gt;fts3_tokenizer()&lt;/a&gt; function is disabled unless SQLite is compiled with the &lt;a href=&quot;compile#enable_fts3_tokenizer&quot;&gt;SQLITE_ENABLE_FTS3_TOKENIZER&lt;/a&gt;.</source>
          <target state="translated">Из-за постоянных проблем безопасности, версия с двумя аргументами редко используемой и малоизвестной функции &lt;a href=&quot;fts3#f3tknzr&quot;&gt;fts3_tokenizer ()&lt;/a&gt; отключена, если SQLite не скомпилирован с &lt;a href=&quot;compile#enable_fts3_tokenizer&quot;&gt;SQLITE_ENABLE_FTS3_TOKENIZER&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f16662c44c98100b991163c6c6a9a2f0174c0613" translate="yes" xml:space="preserve">
          <source>Because of its past success, AFL became a standard part of the testing strategy for SQLite beginning with &lt;a href=&quot;https://sqlite.org/releaselog/3_8_10.html&quot;&gt;version 3.8.10&lt;/a&gt; (2015-05-07) until it was superseded by better fuzzers in &lt;a href=&quot;https://sqlite.org/releaselog/3_29_0.html&quot;&gt;version 3.29.0&lt;/a&gt; (2019-07-10).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70e6d86d9770a8829aec592e59f4248ba67ce358" translate="yes" xml:space="preserve">
          <source>Because of its past success, AFL became a standard part of the testing strategy for SQLite beginning with &lt;a href=&quot;https://sqlite.org/releaselog/3_8_10.html&quot;&gt;version 3.8.10&lt;/a&gt; (2015-05-07). Both SQL statements and database files are fuzzed. Billions and billions of mutations have been tried, but AFL's instrumentation has narrowed them down to less than 50,000 test cases that cover all distinct behaviors. Newly discovered test cases are periodically captured and added to the &lt;a href=&quot;testing#tcl&quot;&gt;TCL test suite&lt;/a&gt; where they can be rerun using the &quot;make fuzztest&quot; or &quot;make valgrindfuzz&quot; commands.</source>
          <target state="translated">Благодаря своему прошлому успеху, AFL стал стандартной частью стратегии тестирования SQLite, начиная с &lt;a href=&quot;https://sqlite.org/releaselog/3_8_10.html&quot;&gt;версии 3.8.10&lt;/a&gt; (2015-05-07). И операторы SQL, и файлы базы данных нечеткие. Были опробованы миллиарды и миллиарды мутаций, но инструментарий AFL сузил их до менее чем 50 000 тестовых примеров, охватывающих все различные типы поведения. Вновь обнаруженные тестовые примеры периодически фиксируются и добавляются в &lt;a href=&quot;testing#tcl&quot;&gt;набор тестов TCL,&lt;/a&gt; где их можно повторно запустить с помощью команд &amp;laquo;make fuzztest&amp;raquo; или &amp;laquo;make valgrindfuzz&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="35a2bab974445beaebfdcb0d2e216e6aab6976e2" translate="yes" xml:space="preserve">
          <source>Because of security concerns, the two-argument fts3_tokenizer() feature was disabled beginning with &lt;a href=&quot;https://sqlite.org/releaselog/3_11_0.html&quot;&gt;Version 3.11.0&lt;/a&gt; (2016-02-15) unless this compile-time option is used. &lt;a href=&quot;https://sqlite.org/releaselog/3_12_0.html&quot;&gt;Version 3.12.0&lt;/a&gt; (2016-03-29) added the &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigenablefts3tokenizer&quot;&gt;SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER&lt;/a&gt;,1,0) interface that activates the two-argument version of &lt;a href=&quot;fts3#f3tknzr&quot;&gt;fts3_tokenizer()&lt;/a&gt; for a specific &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; at run-time.</source>
          <target state="translated">Из соображений безопасности функция fts3_tokenizer () с двумя аргументами была отключена, начиная с &lt;a href=&quot;https://sqlite.org/releaselog/3_11_0.html&quot;&gt;версии 3.11.0&lt;/a&gt; (2016-02-15), если не использовалась эта опция времени компиляции. &lt;a href=&quot;https://sqlite.org/releaselog/3_12_0.html&quot;&gt;Версия 3.12.0&lt;/a&gt; (29 марта 2016 г.) добавлен интерфейс &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config&lt;/a&gt; (db, &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigenablefts3tokenizer&quot;&gt;SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER&lt;/a&gt; , 1,0), который активирует версию &lt;a href=&quot;fts3#f3tknzr&quot;&gt;fts3_tokenizer ()&lt;/a&gt; с двумя аргументами для конкретного &lt;a href=&quot;c3ref/sqlite3&quot;&gt;соединения с базой данных&lt;/a&gt; во время выполнения.</target>
        </trans-unit>
        <trans-unit id="90667c0d2f4c3f9e700d1a02bf683d36a408bbd8" translate="yes" xml:space="preserve">
          <source>Because of the behaviors described above, programmers are encouraged to prefer AFTER triggers over BEFORE triggers.</source>
          <target state="translated">Из-за поведения,описанного выше,программистам рекомендуется отдавать предпочтение ПОСЛЕ триггеров,а не ПЕРЕД триггерами.</target>
        </trans-unit>
        <trans-unit id="428b411cc0640abd27f1cf3a950377d2c4b5358f" translate="yes" xml:space="preserve">
          <source>Because of the potential disadvantages, memory-mapped I/O is disabled by default. To activate memory-mapped I/O, use the &lt;a href=&quot;pragma#pragma_mmap_size&quot;&gt;mmap_size pragma&lt;/a&gt; and set the mmap_size to some large number, usually 256MB or larger, depending on how much address space your application can spare. The rest is automatic. The &lt;a href=&quot;pragma#pragma_mmap_size&quot;&gt;PRAGMA mmap_size&lt;/a&gt; statement will be a silent no-op on systems that do not support memory-mapped I/O.</source>
          <target state="translated">Из-за потенциальных недостатков ввод-вывод с отображением памяти по умолчанию отключен. Чтобы активировать ввод-вывод с отображением памяти, используйте &lt;a href=&quot;pragma#pragma_mmap_size&quot;&gt;прагму mmap_size&lt;/a&gt; и установите для mmap_size некоторое большое число, обычно 256 МБ или больше, в зависимости от того, сколько адресного пространства может сэкономить ваше приложение. Остальное автоматическое. Оператор &lt;a href=&quot;pragma#pragma_mmap_size&quot;&gt;PRAGMA mmap_size не&lt;/a&gt; будет выполнять никаких действий в системах, которые не поддерживают ввод-вывод с отображением памяти.</target>
        </trans-unit>
        <trans-unit id="3b4a67ca1996129326c7f0bddce34637e22bf4f7" translate="yes" xml:space="preserve">
          <source>Because of these advantages, SQLite always tries to do a partial sort using an index even if a complete sort by index is not possible.</source>
          <target state="translated">Из-за этих преимуществ SQLite всегда пытается выполнить частичную сортировку с помощью индекса,даже если полная сортировка по индексам невозможна.</target>
        </trans-unit>
        <trans-unit id="0aff0a8b5eb6e0fbec96bd0626840af7bfdbee19" translate="yes" xml:space="preserve">
          <source>Because resetting a database is destructive and irreversible, the process requires the use of this obscure API and multiple steps to help ensure that it does not happen by accident.</source>
          <target state="translated">Поскольку сброс базы данных является разрушительным и необратимым,процесс требует использования этого неясного API и множества шагов,чтобы гарантировать,что это не произойдет случайно.</target>
        </trans-unit>
        <trans-unit id="6b538eb844bddf9ea8a5b9a11872b1b61bfa979d" translate="yes" xml:space="preserve">
          <source>Because sorting can be expensive, SQLite works hard to convert ORDER BY clauses into no-ops. If SQLite determines that output will naturally appear in the order specified, then no sorting is done. So, for example, if you request the output in rowid order, no sorting will be done:</source>
          <target state="translated">Поскольку сортировка может быть дорогостоящей,SQLite прилагает все усилия,чтобы преобразовать пункты ORDER BY в no-ops.Если SQLite определяет,что вывод будет естественно появляться в указанном порядке,то сортировка не производится.Так,например,если вы запрашиваете вывод в порядке рядности,сортировка не будет произведена:</target>
        </trans-unit>
        <trans-unit id="b9e05ab9d98b3cd637f9791d810eeb3b04a00c42" translate="yes" xml:space="preserve">
          <source>Because the SQLite developers do not know whether the SQLITE_ENABLE_SORTER_REFERENCES option will help or hurt performance, it is disabled by default at this time (2018-05-04). It might be enabled by default in some future release, depending on what is learned about its impact on performance.</source>
          <target state="translated">Поскольку разработчики SQLite не знают,поможет или повредит производительность опция SQLITE_ENABLE_SORTER_REFERENCES,на данный момент она отключена по умолчанию (2018-05-04).В некоторых будущих релизах она может быть включена по умолчанию,в зависимости от того,что будет известно о ее влиянии на производительность.</target>
        </trans-unit>
        <trans-unit id="15ba7f227189763df8625f3bee22f683d880802a" translate="yes" xml:space="preserve">
          <source>Because the completion table is built into the command-line shell in order to provide for tab-completions, you can run test queries against the completion table directly in the command-line shell. Simply type a query such as the example shown above, filling in appropriate values for $prefix and $wholeline, and observe the output.</source>
          <target state="translated">Поскольку таблица завершения встроена в оболочку командной строки,чтобы обеспечить заполнение табуляции,вы можете запускать тестовые запросы к таблице завершения непосредственно в оболочке командной строки.Просто введите запрос,как показано выше,заполнив соответствующие значения для $prefix и $wholeline,и наблюдайте за выводом.</target>
        </trans-unit>
        <trans-unit id="a8514da27bd50380cff29e01b5a61eb7772e130b" translate="yes" xml:space="preserve">
          <source>Because the content of leaf freelist pages is unimportant, SQLite avoids storing leaf freelist page content in the rollback journal in &lt;a href=&quot;#section_3_5&quot;&gt;step 3.5&lt;/a&gt; of the commit process. If a leaf freelist page is changed and that change does not get rolled back during a transaction recovery, the database is not harmed by the omission. Similarly, the content of a new freelist page is never written back into the database at &lt;a href=&quot;#section_3_9&quot;&gt;step 3.9&lt;/a&gt; nor read from the database at &lt;a href=&quot;#section_3_3&quot;&gt;step 3.3&lt;/a&gt;. These optimizations can greatly reduce the amount of I/O that occurs when making changes to a database file that contains free space.</source>
          <target state="translated">Поскольку содержимое конечных страниц свободного списка неважно, SQLite избегает сохранения содержимого конечных страниц свободного списка в журнале отката на &lt;a href=&quot;#section_3_5&quot;&gt;шаге 3.5&lt;/a&gt; процесса фиксации. Если конечная страница бесплатного списка изменена и это изменение не откатывается во время восстановления транзакции, это не повреждает базу данных. Точно так же содержимое новой страницы списка фрилансеров никогда не записывается обратно в базу данных на &lt;a href=&quot;#section_3_9&quot;&gt;шаге 3.9 и&lt;/a&gt; не считывается из базы данных на &lt;a href=&quot;#section_3_3&quot;&gt;шаге 3.3&lt;/a&gt; . Эти оптимизации могут значительно уменьшить количество операций ввода-вывода, которые происходят при внесении изменений в файл базы данных, содержащий свободное пространство.</target>
        </trans-unit>
        <trans-unit id="e09f5109878254b678ca47d639d75e4bf226a1da" translate="yes" xml:space="preserve">
          <source>Because the indexed documents themselves are usually much larger than the full-text index, the content option can be used to achieve significant space savings.</source>
          <target state="translated">Поскольку сами индексируемые документы,как правило,намного больше,чем полнотекстовый индекс,опция контента может быть использована для достижения значительной экономии места.</target>
        </trans-unit>
        <trans-unit id="761cb8246ba69558ca8aeb80b8dbab8c62f5efed" translate="yes" xml:space="preserve">
          <source>Because the left-most column of the index does not appear in the WHERE clause of the query, one is tempted to conclude that the index is not usable here. But SQLite is able to use the index. Conceptually, SQLite uses the index as if the query were more like the following:</source>
          <target state="translated">Поскольку самый левый столбец индекса не появляется в пункте WHERE запроса,возникает соблазн сделать вывод о том,что здесь индекс не может быть использован.Но SQLite способен использовать индекс.Концептуально SQLite использует индекс так,как если бы запрос был больше похож на следующий:</target>
        </trans-unit>
        <trans-unit id="d3bc49abdbbec51c89e15d286d4a875e6d32447c" translate="yes" xml:space="preserve">
          <source>Because the name of the schema table does not appear anywhere in the file format, the meaning of the database file is not changed if the application chooses to refer to the schema table by one of these alternative names.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a128485eb3a76806acc833997f2bb0ca8f3bab85" translate="yes" xml:space="preserve">
          <source>Because the non-primary key &quot;old.*&quot; fields are omitted, no SQLITE_CHANGESET_DATA conflicts can be detected or reported if a patchset is passed to the sqlite3changeset_apply() API. Other conflict types work in the same way as for changesets.</source>
          <target state="translated">Так как поля не первичного ключа &quot;old.*&quot; опущены,конфликты SQLITE_CHANGESET_DATA не могут быть обнаружены или сообщены,если в API sqlite3changeset_apply()передан patchset_DATA.Остальные типы конфликтов работают так же,как и для changeset'ов.</target>
        </trans-unit>
        <trans-unit id="2e558ba54b31e234aa1a29ff45d5a07a13c1806f" translate="yes" xml:space="preserve">
          <source>Because the pointer is passed in the t1 column of the t1 table as a BLOB (in older versions of SQLite), such a query would have shown the value of the pointer in hex. The attacker could then modify that pointer to try to get the snippet() function to modify memory in some other part of the application address space instead of the fts3cursor object it was supposed to be operating on:</source>
          <target state="translated">Поскольку указатель передается в столбце t1 таблицы t1 как BLOB (в старых версиях SQLite),то такой запрос показывал бы значение указателя в hex.Затем злоумышленник мог бы модифицировать этот указатель,чтобы попытаться заставить функцию snippet()модифицировать память в какой-то другой части адресного пространства приложения,а не объект fts3cursor,на котором он должен был работать:</target>
        </trans-unit>
        <trans-unit id="72ea5223eef09f4a78746e1785e07a1242a94565" translate="yes" xml:space="preserve">
          <source>Because the same query could be written without the use of row values, row values do not provide new capabilities. However, many developers say that the row value format is easier to read, write, and debug.</source>
          <target state="translated">Поскольку один и тот же запрос может быть записан без использования значений строк,значения строк не предоставляют новых возможностей.Однако многие разработчики утверждают,что формат значений рядов легче читать,записывать и отлаживать.</target>
        </trans-unit>
        <trans-unit id="fc8629347e97d2900d75943390265d789337dab5" translate="yes" xml:space="preserve">
          <source>Because the session module uses the &lt;a href=&quot;../c3ref/preupdate_count&quot;&gt;sqlite3_preupdate_hook()&lt;/a&gt; API, it is not possible for an application to register a pre-update hook on a database handle that has one or more session objects attached. Nor is it possible to create a session object attached to a database handle for which a pre-update hook is already defined. The results of attempting either of these things are undefined.</source>
          <target state="translated">Поскольку модуль сеанса использует API &lt;a href=&quot;../c3ref/preupdate_count&quot;&gt;sqlite3_preupdate_hook ()&lt;/a&gt; , приложение не может зарегистрировать обработчик предварительного обновления на дескрипторе базы данных, к которому прикреплен один или несколько объектов сеанса. Также невозможно создать объект сеанса, присоединенный к дескриптору базы данных, для которого уже определена ловушка предварительного обновления. Результаты попытки любого из этих действий не определены.</target>
        </trans-unit>
        <trans-unit id="2d755c27985069d9c58f3f925b7f20c86ab3fc1d" translate="yes" xml:space="preserve">
          <source>Because the session module uses the &lt;a href=&quot;c3ref/preupdate_count&quot;&gt;sqlite3_preupdate_hook()&lt;/a&gt; API, it is not possible for an application to register a pre-update hook on a database handle that has one or more session objects attached. Nor is it possible to create a session object attached to a database handle for which a pre-update hook is already defined. The results of attempting either of these things are undefined.</source>
          <target state="translated">Поскольку модуль сеанса использует API &lt;a href=&quot;c3ref/preupdate_count&quot;&gt;sqlite3_preupdate_hook ()&lt;/a&gt; , приложение не может зарегистрировать обработчик предварительного обновления на дескрипторе базы данных, к которому прикреплен один или несколько объектов сеанса. Также невозможно создать объект сеанса, присоединенный к дескриптору базы данных, для которого уже определена ловушка предварительного обновления. Результаты попытки любого из этих действий не определены.</target>
        </trans-unit>
        <trans-unit id="adc547a5fb4644ceebfd077fa4efa0549df654d8" translate="yes" xml:space="preserve">
          <source>Because the shm file is not involved in recovery, the shm file does not need to be machine byte-order independent. Hence, numeric values in the shm file are written in the native byte order of the host computer, rather than being converted into a specific cross-platform byte order as is done with the main database file and the wal file.</source>
          <target state="translated">Так как файл shm не участвует в восстановлении,файл shm не должен быть машинным по порядку байт.Следовательно,числовые значения в файле shm записываются в родном порядке байт на хост-компьютере,а не преобразуются в специфический кросс-платформенный порядок байт,как это делается с основным файлом базы данных и файлом wal.</target>
        </trans-unit>
        <trans-unit id="57d0b82e26ee2d676d928a1d7402d5916fc2656a" translate="yes" xml:space="preserve">
          <source>Because the shm is only used to coordinate access between concurrent clients, the shm file is omitted if &lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;exclusive locking mode&lt;/a&gt; is set, as an optimization. When &lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;exclusive locking mode&lt;/a&gt; is set, SQLite uses heap memory in place of the memory-mapped shm file.</source>
          <target state="translated">Поскольку shm используется только для координации доступа между одновременно работающими клиентами, файл shm опускается, если установлен &lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;режим монопольной блокировки&lt;/a&gt; , в целях оптимизации. Когда установлен &lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;режим монопольной блокировки&lt;/a&gt; , SQLite использует память кучи вместо отображаемого в память файла shm.</target>
        </trans-unit>
        <trans-unit id="2da09f02d441cbe1ccd49c9803ec08e4160143a9" translate="yes" xml:space="preserve">
          <source>Because there is no cross-platform way to specify 64-bit integer types SQLite includes typedefs for 64-bit signed and unsigned integers.</source>
          <target state="translated">В связи с отсутствием кросс-платформенного способа указания 64-битных целочисленных типов SQLite включает typedefs для 64-битных знаковых и беззнаковых целых чисел.</target>
        </trans-unit>
        <trans-unit id="8871399a86a3489a9f90b012e36a01ad56791fa8" translate="yes" xml:space="preserve">
          <source>Before SQLite can write to a database, it must first read the database to see what is there already. Even if it is just appending new data, SQLite still has to read in the database schema from the &quot;&lt;a href=&quot;schematab&quot;&gt;sqlite_schema&lt;/a&gt;&quot; table so that it can know how to parse the INSERT statements and discover where in the database file the new information should be stored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d5873520ec115c715db00ab0ac94f393f103400" translate="yes" xml:space="preserve">
          <source>Before SQLite can write to a database, it must first read the database to see what is there already. Even if it is just appending new data, SQLite still has to read in the database schema from the &lt;b&gt;sqlite_master&lt;/b&gt; table so that it can know how to parse the INSERT statements and discover where in the database file the new information should be stored.</source>
          <target state="translated">Прежде чем SQLite сможет писать в базу данных, он должен сначала прочитать базу данных, чтобы увидеть, что там уже есть. Даже если он просто добавляет новые данные, SQLite все равно нужно читать схему базы данных из таблицы &lt;b&gt;sqlite_master,&lt;/b&gt; чтобы он мог знать, как анализировать операторы INSERT и обнаруживать, где в файле базы данных должна храниться новая информация.</target>
        </trans-unit>
        <trans-unit id="ccacc0177cbd2ba716b19132f920379d439772e2" translate="yes" xml:space="preserve">
          <source>Before a &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; statement can be run, the module specified in that statement must be registered with the database connection. This is accomplished using either of the &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module()&lt;/a&gt; or &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module_v2()&lt;/a&gt; interfaces:</source>
          <target state="translated">Прежде чем оператор &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; может быть запущен, модуль, указанный в этом операторе, должен быть зарегистрирован в соединении с базой данных. Это достигается с помощью интерфейса &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module ()&lt;/a&gt; или &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module_v2 ()&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="c589001febca68c36ef8079ff9faca5b3d4efc6b" translate="yes" xml:space="preserve">
          <source>Before a new auxiliary function or tokenizer implementation may be registered with FTS5, an application must obtain a pointer to the &quot;fts5_api&quot; structure. There is one fts5_api structure for each database connection with which the FTS5 extension is registered. To obtain the pointer, the application invokes the SQL user-defined function fts5() with a single argument. That argument must be set to a pointer to a pointer to an fts5_api object using the &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer()&lt;/a&gt; interface. The following example code demonstrates the technique:</source>
          <target state="translated">Прежде чем новая вспомогательная функция или реализация токенизатора может быть зарегистрирована в FTS5, приложение должно получить указатель на структуру &amp;laquo;fts5_api&amp;raquo;. Для каждого подключения к базе данных, с которым зарегистрировано расширение FTS5, существует одна структура fts5_api. Для получения указателя приложение вызывает пользовательскую функцию SQL fts5 () с одним аргументом. Этот аргумент должен быть установлен как указатель на указатель на объект fts5_api с использованием интерфейса &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer ()&lt;/a&gt; . Следующий пример кода демонстрирует эту технику:</target>
        </trans-unit>
        <trans-unit id="6ae8b38a31b33865e805e86015a35fae53d45a85" translate="yes" xml:space="preserve">
          <source>Before any database pages may be modified within the</source>
          <target state="translated">Перед тем,как любые страницы базы данных могут быть изменены в</target>
        </trans-unit>
        <trans-unit id="2aafeb2e2bb5cf3269cb7e705f038008b263f110" translate="yes" xml:space="preserve">
          <source>Before any information-bearing page of the database is modified, the original unmodified content of that page is written into the rollback journal. If a transaction is interrupted and needs to be rolled back, the rollback journal can then be used to restore the database to its original state. Freelist leaf pages bear no information that would need to be restored on a rollback and so they are not written to the journal prior to modification, in order to reduce disk I/O.</source>
          <target state="translated">Перед тем,как изменить какую-либо несущую информацию страницу базы данных,в журнал отката записывается оригинальное немодифицированное содержимое этой страницы.В случае прерывания транзакции и необходимости отката,журнал отката может быть использован для восстановления исходного состояния БД.На страницах листа Freelist нет информации,которую необходимо было бы восстановить при откате,и поэтому они не записываются в журнал до модификации,чтобы уменьшить объем ввода/вывода диска.</target>
        </trans-unit>
        <trans-unit id="e31e39238fffa8a7d3425c769271d3112873aa6f" translate="yes" xml:space="preserve">
          <source>Before calling this method, the SQLite core initializes an instance of the &lt;a href=&quot;c3ref/index_info&quot;&gt;sqlite3_index_info&lt;/a&gt; structure with information about the query that it is currently trying to process. This information derives mainly from the WHERE clause and ORDER BY or GROUP BY clauses of the query, but also from any ON or USING clauses if the query is a join. The information that the SQLite core provides to the xBestIndex method is held in the part of the structure that is marked as &quot;Inputs&quot;. The &quot;Outputs&quot; section is initialized to zero.</source>
          <target state="translated">Перед вызовом этого метода ядро ​​SQLite инициализирует экземпляр структуры &lt;a href=&quot;c3ref/index_info&quot;&gt;sqlite3_index_info&lt;/a&gt; с информацией о запросе, который в настоящее время пытается обработать. Эта информация извлекается в основном из предложений WHERE и ORDER BY или GROUP BY запроса, но также и из любых предложений ON или USING, если запрос является соединением. Информация, которую ядро ​​SQLite предоставляет методу xBestIndex, содержится в той части структуры, которая помечена как &amp;laquo;Входы&amp;raquo;. Раздел &amp;laquo;Выходы&amp;raquo; инициализируется нулем.</target>
        </trans-unit>
        <trans-unit id="29b6c291315b8e1fb3f265c15e369937b630aaf5" translate="yes" xml:space="preserve">
          <source>Before data may be read from a</source>
          <target state="translated">Прежде чем данные могут быть считаны из</target>
        </trans-unit>
        <trans-unit id="cae7b06f8fadf1f8b2bbb51c0629366481aebe32" translate="yes" xml:space="preserve">
          <source>Before entering a trigger program the value returned by sqlite3_changes() function is saved. After the trigger program has finished, the original value is restored.</source>
          <target state="translated">Перед входом в триггерную программу сохраняется значение,возвращаемое функцией sqlite3_changes().После завершения триггерной программы исходное значение восстанавливается.</target>
        </trans-unit>
        <trans-unit id="7968bdea3fbca698f15e058c3369cb48f81fd4ca" translate="yes" xml:space="preserve">
          <source>Before executing a statement that modifies the database schema (i.e. a CREATE or DROP TABLE statement), a connection must obtain a write-lock on</source>
          <target state="translated">Перед выполнением оператора,который модифицирует схему БД (т.е.оператора CREATE или DROP TABLE),соединение должно получить блокировку записи на</target>
        </trans-unit>
        <trans-unit id="64443a5dc257f480bf4a79d829dcae9017cc971a" translate="yes" xml:space="preserve">
          <source>Before making changes to any page of the database, the process writes the original content of that page into the rollback journal. Changes to pages are held in memory at first and are not written to the disk. The original database file remains unaltered, which means that other processes can continue to read the database.</source>
          <target state="translated">Перед тем,как внести изменения в какую-либо страницу базы данных,процесс записывает исходное содержимое этой страницы в журнал отката.Изменения страниц сначала хранятся в памяти и не записываются на диск.Файл исходной базы данных остается неизменным,что означает,что другие процессы могут продолжать читать базу данных.</target>
        </trans-unit>
        <trans-unit id="ed294139e05d80e58de31e418d68f4cfaebeb6a7" translate="yes" xml:space="preserve">
          <source>Before making changes to the database, SQLite first obtains a &quot;reserved&quot; lock on the database file. A reserved lock is similar to a shared lock in that both a reserved lock and shared lock allow other processes to read from the database file. A single reserve lock can coexist with multiple shared locks from other processes. However, there can only be a single reserved lock on the database file. Hence only a single process can be attempting to write to the database at one time.</source>
          <target state="translated">Перед внесением изменений в БД SQLite сначала получает &quot;зарезервированную&quot; блокировку на файле БД.Зарезервированная блокировка аналогична общей блокировке в том смысле,что и зарезервированная,и общая блокировка позволяют другим процессам читать из файла БД.Один резервный замок может сосуществовать с несколькими общими замками других процессов.Однако,на файле БД может быть только один зарезервированный замок.Следовательно,только один процесс может пытаться записать в базу данных одновременно.</target>
        </trans-unit>
        <trans-unit id="e0b64dbebb4ad46a9aeb1a098c15aadd4e3eaf44" translate="yes" xml:space="preserve">
          <source>Before modifying a database page within the</source>
          <target state="translated">Перед изменением страницы базы данных в</target>
        </trans-unit>
        <trans-unit id="98e0ccf77dc018ac7ea18b90477a40f1a7c510fa" translate="yes" xml:space="preserve">
          <source>Before opening a</source>
          <target state="translated">Перед открытием</target>
        </trans-unit>
        <trans-unit id="6822a9cef8f0664c32cddfaac23e4bff41485b02" translate="yes" xml:space="preserve">
          <source>Before reading from a database file, SQLite always checks to see if that database file has a hot journal. If the file does have a hot journal, then the journal is rolled back before the file is read. In this way, we ensure that the database file is in a consistent state before it is read.</source>
          <target state="translated">Перед чтением из файла базы данных SQLite всегда проверяет,есть ли в этом файле базы данных горячий журнал.Если файл действительно имеет &quot;горячий&quot; журнал,то перед чтением он откатывается назад.Таким образом,мы гарантируем,что файл базы данных находится в постоянном состоянии,прежде чем он будет прочитан.</target>
        </trans-unit>
        <trans-unit id="2ffabc9625263621654187c58d31675c59e6730d" translate="yes" xml:space="preserve">
          <source>Before the content of a page modified within the</source>
          <target state="translated">Перед тем,как содержание страницы,измененной в</target>
        </trans-unit>
        <trans-unit id="2a76187aef00ad8a5abadfac889a6b98dd1db2fb" translate="yes" xml:space="preserve">
          <source>Before the contents of the</source>
          <target state="translated">Перед содержимым</target>
        </trans-unit>
        <trans-unit id="5f97138118a317cbc3bf1e3e8dd4c6fd1edd23a0" translate="yes" xml:space="preserve">
          <source>Before we begin looking at this problem, let's briefly review how queries work in SQLite so that we will know what we are trying to accomplish. For each row in the result of a query, SQLite will invoke a callback function with the following prototype:</source>
          <target state="translated">Прежде чем мы начнем рассматривать эту проблему,давайте вкратце рассмотрим,как работают запросы в SQLite,чтобы мы знали,что мы пытаемся сделать.Для каждой строки в результате запроса SQLite будет вызывать функцию обратного вызова со следующим прототипом:</target>
        </trans-unit>
        <trans-unit id="5c00a0d3ea5cf97be2cbc8e0c749bfff4206bbf5" translate="yes" xml:space="preserve">
          <source>Begin a transaction on database P1 if a transaction is not already active. If P2 is non-zero, then a write-transaction is started, or if a read-transaction is already active, it is upgraded to a write-transaction. If P2 is zero, then a read-transaction is started.</source>
          <target state="translated">Начать транзакцию по базе данных P1,если транзакция еще не активна.Если P2 ненулевая,то начинается транзакция на запись,или если читаемая транзакция уже активна,то она обновляется до транзакции на запись.Если P2 равен нулю,то начинается чтение-транзакция.</target>
        </trans-unit>
        <trans-unit id="2fd194a93ac6ccfaf40c7f7cd5a992cb067293a7" translate="yes" xml:space="preserve">
          <source>Begin adding lots of new documentation</source>
          <target state="translated">Начать добавлять много новой документации</target>
        </trans-unit>
        <trans-unit id="90c994ef269c7ca4806cc0aace7ca7e97ba28671" translate="yes" xml:space="preserve">
          <source>Begin by obtaining a copy of SQLite in whatever form you use it. The public SQLite you obtain should be as close to your private edited copy as possible. If your project uses the SQLite amalgamation, then get a copy of the amalgamation. If you use the preprocessed separate source files, get those instead. Put all the source files in the checkout directory created in the previous step.</source>
          <target state="translated">Начните с получения копии SQLite в любой форме,в которой вы его используете.Публичный SQLite,который вы получаете,должен быть как можно ближе к вашей частной отредактированной копии.Если ваш проект использует слияние SQLite,то получите копию слияния.Если вы используете препроцессированные отдельные исходные файлы,получите их вместо них.Положите все исходные файлы в каталог проверки,созданный на предыдущем шаге.</target>
        </trans-unit>
        <trans-unit id="c95a84f6810e9547323b7d36381036499b6e85a2" translate="yes" xml:space="preserve">
          <source>Begin enforcing &lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitvdbeop&quot;&gt;SQLITE_LIMIT_VDBE_OP&lt;/a&gt;. This can be used, for example, to prevent excessively large prepared statements in systems that accept SQL queries from untrusted users.</source>
          <target state="translated">Начните применять &lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitvdbeop&quot;&gt;SQLITE_LIMIT_VDBE_OP&lt;/a&gt; . Это можно использовать, например, для предотвращения чрезмерно больших подготовленных операторов в системах, которые принимают запросы SQL от ненадежных пользователей.</target>
        </trans-unit>
        <trans-unit id="6b5e2f03338f65ea55efadd743c2073f0844124d" translate="yes" xml:space="preserve">
          <source>Begin every identifier with the letter &quot;Z&quot; as no SQL keywords start with &quot;Z&quot;.</source>
          <target state="translated">Начинайте каждый идентификатор с буквы &quot;Z&quot;,так как ключевые слова SQL не начинаются с буквы &quot;Z&quot;.</target>
        </trans-unit>
        <trans-unit id="c7c9b7ac07f4b963268a3915518a82c60026c1c8" translate="yes" xml:space="preserve">
          <source>Begin writing documentation on the TCL interface.</source>
          <target state="translated">Начните писать документацию по интерфейсу TCL.</target>
        </trans-unit>
        <trans-unit id="d93624195948cab4e3c3cf8a06c4ba66150434ee" translate="yes" xml:space="preserve">
          <source>Begin writing the &lt;a href=&quot;vdbe&quot;&gt;VDBE tutorial&lt;/a&gt;.</source>
          <target state="translated">Начните писать &lt;a href=&quot;vdbe&quot;&gt;учебник VDBE&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2891bac57361d1d80487ccfbba99ba09325df3b5" translate="yes" xml:space="preserve">
          <source>Beginning a Write Transaction</source>
          <target state="translated">Начало операции по записи</target>
        </trans-unit>
        <trans-unit id="60eca843fdd7093ad8665839ef32416ade71c639" translate="yes" xml:space="preserve">
          <source>Beginning in 2016, a team of engineers at Google started the &lt;a href=&quot;https://github.com/google/oss-fuzz&quot;&gt;OSS Fuzz&lt;/a&gt; project. OSS Fuzz uses a AFL-style guided fuzzer running on Google's infrastructure. The Fuzzer automatically downloads the latest check-ins for participating projects, fuzzes them, and sends email to the developers reporting any problems. When a fix is checked in, the fuzzer automatically detects this and emails a confirmation to the developers.</source>
          <target state="translated">Начиная с 2016 года команда инженеров Google запустила проект &lt;a href=&quot;https://github.com/google/oss-fuzz&quot;&gt;OSS Fuzz&lt;/a&gt; . OSS Fuzz использует управляемый фаззер в стиле AFL, работающий в инфраструктуре Google. Fuzzer автоматически загружает последние проверки для участвующих проектов, анализирует их и отправляет разработчикам сообщения электронной почты о любых проблемах. Когда исправление зарегистрировано, фаззер автоматически обнаруживает это и отправляет разработчикам подтверждение по электронной почте.</target>
        </trans-unit>
        <trans-unit id="52ddec92a44c4044495e3a4272f88fb5bf0d2787" translate="yes" xml:space="preserve">
          <source>Beginning in SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_15_0.html&quot;&gt;version 3.15.0&lt;/a&gt; (2016-10-14), an assignment in the SET clause can be a &lt;a href=&quot;syntax/column-name-list&quot;&gt;parenthesized list of column names&lt;/a&gt; on the left and a &lt;a href=&quot;rowvalue&quot;&gt;row value&lt;/a&gt; of the same size on the right.</source>
          <target state="translated">Начиная с &lt;a href=&quot;https://sqlite.org/releaselog/3_15_0.html&quot;&gt;версии&lt;/a&gt; SQLite 3.15.0 (2016-10-14), присвоение в предложении SET может быть заключенным в &lt;a href=&quot;syntax/column-name-list&quot;&gt;скобки списком имен столбцов&lt;/a&gt; слева и &lt;a href=&quot;rowvalue&quot;&gt;значением строки&lt;/a&gt; того же размера справа.</target>
        </trans-unit>
        <trans-unit id="8e0744464084ddf340ea6c6e0a24aad6d9c12c18" translate="yes" xml:space="preserve">
          <source>Beginning in SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_6_4.html&quot;&gt;version 3.6.4&lt;/a&gt; (2008-10-15), the TRUNCATE journal mode is also supported:</source>
          <target state="translated">Начиная с &lt;a href=&quot;https://sqlite.org/releaselog/3_6_4.html&quot;&gt;версии&lt;/a&gt; SQLite 3.6.4 (2008-10-15), также поддерживается режим журнала TRUNCATE:</target>
        </trans-unit>
        <trans-unit id="6adac7327da12129344605aed8c6230ec2a45b5c" translate="yes" xml:space="preserve">
          <source>Beginning in SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_4.html&quot;&gt;version 3.7.4&lt;/a&gt; (2010-12-07), WAL databases can be created, read, and written even if shared memory is unavailable as long as the &lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;locking_mode&lt;/a&gt; is set to EXCLUSIVE before the first attempted access. In other words, a process can interact with a WAL database without using shared memory if that process is guaranteed to be the only process accessing the database. This feature allows WAL databases to be created, read, and written by legacy &lt;a href=&quot;vfs&quot;&gt;VFSes&lt;/a&gt; that lack the &quot;version 2&quot; shared-memory methods xShmMap, xShmLock, xShmBarrier, and xShmUnmap on the &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object.</source>
          <target state="translated">Начиная с &lt;a href=&quot;https://sqlite.org/releaselog/3_7_4.html&quot;&gt;версии&lt;/a&gt; SQLite 3.7.4 (07.12.2010), базы данных WAL можно создавать, читать и записывать, даже если общая память недоступна, если для параметра &lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;lock_mode&lt;/a&gt; задано значение EXCLUSIVE перед первой попыткой доступа. Другими словами, процесс может взаимодействовать с базой данных WAL без использования разделяемой памяти, если этот процесс гарантированно является единственным процессом, имеющим доступ к базе данных. Эта функция позволяет создавать, читать и записывать базы данных WAL с помощью устаревших &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; , в которых отсутствуют методы общей памяти &amp;laquo;версии 2&amp;raquo; xShmMap, xShmLock, xShmBarrier и xShmUnmap в объекте &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0f100a899b26537fc63caa4230653ce9716130e4" translate="yes" xml:space="preserve">
          <source>Beginning in SQLite version 3.5.0, the new Virtual File System (VFS) interface contains a method named xDeviceCharacteristics which reports on special properties that the underlying mass storage device might have. Among the special properties that xDeviceCharacteristics might report is the ability of to do an atomic sector write.</source>
          <target state="translated">Начиная с версии SQLite 3.5.0,новый интерфейс виртуальной файловой системы (VFS)содержит метод xDeviceCharacteristics,который сообщает об особых свойствах,которые может иметь устройство хранения данных.Среди специальных свойств,о которых может сообщать xDeviceCharacteristics,можно отметить возможность выполнения записи в атомном секторе.</target>
        </trans-unit>
        <trans-unit id="dbe6df39f8d021809fb2ab3e47422b19fa74d670" translate="yes" xml:space="preserve">
          <source>Beginning in late 2018, SQLite has been fuzzed using a new proprietary fuzzer called &quot;dbsqlfuzz&quot;. Dbsqlfuzz is built using the &lt;a href=&quot;http://llvm.org/docs/LibFuzzer.html&quot;&gt;libFuzzer&lt;/a&gt; framework of LLVM.</source>
          <target state="translated">Начиная с конца 2018 года, SQLite был фаззирован с использованием нового проприетарного фаззера под названием &amp;laquo;dbsqlfuzz&amp;raquo;. Dbsqlfuzz построен с использованием фреймворка &lt;a href=&quot;http://llvm.org/docs/LibFuzzer.html&quot;&gt;libFuzzer&lt;/a&gt; LLVM.</target>
        </trans-unit>
        <trans-unit id="a4f6d3a3a096224887296bd514258ca7ceae764c" translate="yes" xml:space="preserve">
          <source>Beginning with &lt;a href=&quot;https://sqlite.org/releaselog/3_7_0.html&quot;&gt;version 3.7.0&lt;/a&gt; (2010-07-21), SQLite supports a new transaction control mechanism called &quot;&lt;a href=&quot;wal&quot;&gt;write-ahead log&lt;/a&gt;&quot; or &quot;&lt;a href=&quot;wal&quot;&gt;WAL&lt;/a&gt;&quot;. When a database is in WAL mode, all connections to that database must use the WAL. A particular database will use either a rollback journal or a WAL, but not both at the same time. The WAL is always located in the same directory as the database file and has the same name as the database file but with the string &quot;&lt;code&gt;-wal&lt;/code&gt;&quot; appended.</source>
          <target state="translated">Начиная с &lt;a href=&quot;https://sqlite.org/releaselog/3_7_0.html&quot;&gt;версии 3.7.0&lt;/a&gt; (2010-07-21), SQLite поддерживает новый механизм управления транзакциями, называемый &amp;laquo; &lt;a href=&quot;wal&quot;&gt;журнал упреждающей записи&lt;/a&gt; &amp;raquo; или &amp;laquo; &lt;a href=&quot;wal&quot;&gt;WAL&lt;/a&gt; &amp;raquo;. Когда база данных находится в режиме WAL, все подключения к этой базе данных должны использовать WAL. Конкретная база данных будет использовать либо журнал отката, либо WAL, но не то и другое одновременно. WAL всегда находится в том же каталоге, что и файл базы данных, и имеет то же имя, что и файл базы данных, но с добавленной строкой &amp;laquo; &lt;code&gt;-wal&lt;/code&gt; &amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="d9839d2cef57fa5d151a0ce9cbe15a6e0c36fbc7" translate="yes" xml:space="preserve">
          <source>Beginning with &lt;a href=&quot;https://sqlite.org/releaselog/3_7_17.html&quot;&gt;version 3.7.17&lt;/a&gt; (2013-05-20), SQLite has the option of accessing disk content directly using memory-mapped I/O and the new xFetch() and xUnfetch() methods on &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt;.</source>
          <target state="translated">Начиная с &lt;a href=&quot;https://sqlite.org/releaselog/3_7_17.html&quot;&gt;версии 3.7.17&lt;/a&gt; (2013-05-20), SQLite имеет возможность прямого доступа к содержимому диска с помощью ввода-вывода с отображением памяти и новых методов xFetch () и xUnfetch () в &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="26a395622db69c8b77803fcd06e3a2c5d4cdefa3" translate="yes" xml:space="preserve">
          <source>Beginning with &lt;a href=&quot;https://sqlite.org/releaselog/3_7_7.html&quot;&gt;version 3.7.7&lt;/a&gt; (2011-06-23), the SQLite database file argument to the &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open16()&lt;/a&gt;, and &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; interfaces and to the &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; command can be specified either as an ordinary filename or as a Uniform Resource Identifier or URI. The advantage of using a URI filename is that query parameters on the URI can be used to control details of the newly created database connection. For example, an alternative &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; can be specified using a &quot;vfs=&quot; query parameter. Or the database can be opened read-only by using &quot;mode=ro&quot; as a query parameter.</source>
          <target state="translated">Начиная с &lt;a href=&quot;https://sqlite.org/releaselog/3_7_7.html&quot;&gt;версии 3.7.7&lt;/a&gt; (2011-06-23), аргумент файла базы данных SQLite для интерфейсов &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open ()&lt;/a&gt; , &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open16 ()&lt;/a&gt; и &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2 ()&lt;/a&gt; и для команды &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; можно указать либо как обычное имя файла, либо как Универсальный идентификатор ресурса или URI. Преимущество использования имени файла URI заключается в том, что параметры запроса в URI могут использоваться для управления деталями вновь созданного соединения с базой данных. Например, альтернативную &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; можно указать с помощью параметра запроса &amp;laquo;vfs =&amp;raquo;. Или базу данных можно открыть только для чтения, используя &quot;mode = ro&quot; в качестве параметра запроса.</target>
        </trans-unit>
        <trans-unit id="8b26610830584adfe4c3b1f430311725c505dc65" translate="yes" xml:space="preserve">
          <source>Beginning with &lt;a href=&quot;https://sqlite.org/releaselog/3_9_0.html&quot;&gt;version 3.9.0&lt;/a&gt; (2015-10-14) SQLite uses &lt;a href=&quot;http://semver.org&quot;&gt;semantic versioning&lt;/a&gt;. Prior to that time, SQLite employed a version identifier that contained between two and four numbers.</source>
          <target state="translated">Начиная с &lt;a href=&quot;https://sqlite.org/releaselog/3_9_0.html&quot;&gt;версии 3.9.0&lt;/a&gt; (2015-10-14) SQLite использует &lt;a href=&quot;http://semver.org&quot;&gt;семантическое управление версиями&lt;/a&gt; . До этого SQLite использовал идентификатор версии, содержащий от двух до четырех чисел.</target>
        </trans-unit>
        <trans-unit id="e8a7a785dc79c6f97e7e9b629f10c98e7d6eaa12" translate="yes" xml:space="preserve">
          <source>Beginning with SQLite 3.23.0 (2018-04-02), SQLite recognizes the identifiers &quot;TRUE&quot; and &quot;FALSE&quot; as boolean literals, if and only if those identifiers are not already used for some other meaning. If there already exists columns or tables or other objects named TRUE or FALSE, then for the sake of backwards compatibility, the TRUE and FALSE identifiers refer to those other objects, not to the boolean values.</source>
          <target state="translated">Начиная с SQLite 3.23.0 (2018-04-02),SQLite распознает идентификаторы &quot;TRUE&quot; и &quot;FALSE&quot; как логические литералы,если и только если эти идентификаторы еще не используются в каком-либо другом значении.Если уже существуют столбцы или таблицы или другие объекты с именами TRUE или FALSE,то в целях обратной совместимости идентификаторы TRUE и FALSE относятся к этим другим объектам,а не к булевым значениям.</target>
        </trans-unit>
        <trans-unit id="e27a2a72ed98b30f89096b193da3e3a912285cdd" translate="yes" xml:space="preserve">
          <source>Beginning with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_10_0.html&quot;&gt;version 3.10.0&lt;/a&gt; (2016-01-06), the unix OS interface will attempt to resolve symbolic links and open the database file by its canonical name. Prior to version 3.10.0, opening a database file through a symbolic link was similar to opening a database file that had multiple hard links and resulted in undefined behavior.</source>
          <target state="translated">Начиная с &lt;a href=&quot;https://sqlite.org/releaselog/3_10_0.html&quot;&gt;версии&lt;/a&gt; SQLite 3.10.0 (2016-01-06), интерфейс ОС unix будет пытаться разрешить символические ссылки и открыть файл базы данных по его каноническому имени. До версии 3.10.0 открытие файла базы данных с помощью символической ссылки было похоже на открытие файла базы данных с несколькими жесткими ссылками, что приводило к неопределенному поведению.</target>
        </trans-unit>
        <trans-unit id="669009bffd329a7525e12f992041efbc93a9e4fc" translate="yes" xml:space="preserve">
          <source>Beginning with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_14.html&quot;&gt;version 3.14.0&lt;/a&gt; (2016-08-08), the CREATE TABLE statement that is passed into &lt;a href=&quot;c3ref/declare_vtab&quot;&gt;sqlite3_declare_vtab()&lt;/a&gt; may contain a &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; clause. This is useful for cases where the virtual table rows cannot easily be mapped into unique integers. A CREATE TABLE statement that includes WITHOUT ROWID must define one or more columns as the PRIMARY KEY. Every column of the PRIMARY KEY must individually be NOT NULL and all columns for each row must be collectively unique.</source>
          <target state="translated">Начиная с &lt;a href=&quot;https://sqlite.org/releaselog/3_14.html&quot;&gt;версии&lt;/a&gt; SQLite 3.14.0 (08.08.2016), оператор CREATE TABLE, передаваемый в &lt;a href=&quot;c3ref/declare_vtab&quot;&gt;sqlite3_declare_vtab (),&lt;/a&gt; может содержать предложение &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; . Это полезно в случаях, когда строки виртуальной таблицы не могут быть легко отображены в уникальные целые числа. Оператор CREATE TABLE, который включает WITHOUT ROWID, должен определять один или несколько столбцов в качестве ПЕРВИЧНОГО КЛЮЧА. Каждый столбец ПЕРВИЧНОГО КЛЮЧА должен индивидуально быть НЕ ПУСТОЙ, и все столбцы для каждой строки должны быть уникальными в совокупности.</target>
        </trans-unit>
        <trans-unit id="914fd4075646f327da4b592c31312990facc6a8d" translate="yes" xml:space="preserve">
          <source>Beginning with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_23_0.html&quot;&gt;version 3.23.0&lt;/a&gt; (2018-04-02), SQLite also recognizes TRUE and FALSE keywords as aliases for integer values 1 and 0, respectively. This provides better compatibility with other SQL implementations. But to retain backwards compatibility, if there are columns named TRUE or FALSE, then the keywords are treated as identifiers referencing those columns, rather than BOOLEAN literals.</source>
          <target state="translated">Начиная с &lt;a href=&quot;https://sqlite.org/releaselog/3_23_0.html&quot;&gt;версии&lt;/a&gt; SQLite 3.23.0 (2018-04-02), SQLite также распознает ключевые слова TRUE и FALSE как псевдонимы для целочисленных значений 1 и 0 соответственно. Это обеспечивает лучшую совместимость с другими реализациями SQL. Но для сохранения обратной совместимости, если есть столбцы с именами TRUE или FALSE, то ключевые слова обрабатываются как идентификаторы, ссылающиеся на эти столбцы, а не как литералы BOOLEAN.</target>
        </trans-unit>
        <trans-unit id="67498fb6faa33682195156e0b1885f3794748cc2" translate="yes" xml:space="preserve">
          <source>Beginning with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_31_0.html&quot;&gt;version 3.31.0&lt;/a&gt; (2020-01-22) the input F parameter can also be the name of a rollback journal file or WAL file in addition to the main database file. Prior to version 3.31.0, these routines would only work if F was the name of the main database file. When the F parameter is the name of the rollback journal or WAL file, it has access to all the same query parameters as were found on the main database file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9f2cb99d27921b6ac8152e7a3c891a53596352b" translate="yes" xml:space="preserve">
          <source>Beginning with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_13.html&quot;&gt;version 3.7.13&lt;/a&gt; (2012-06-11), shared cache can be used on &lt;a href=&quot;inmemorydb&quot;&gt;in-memory databases&lt;/a&gt;, provided that the database is created using a &lt;a href=&quot;uri&quot;&gt;URI filename&lt;/a&gt;. For backwards compatibility, shared cache is always disable for in-memory databases if the unadorned name &quot;:memory:&quot; is used to open the database. Prior to version 3.7.13, shared cache was always disabled for in-memory databases regardless of the database name used, current system shared cache setting, or query parameters or flags.</source>
          <target state="translated">Начиная с &lt;a href=&quot;https://sqlite.org/releaselog/3_7_13.html&quot;&gt;версии&lt;/a&gt; SQLite 3.7.13 (2012-06-11), общий кеш можно использовать &lt;a href=&quot;inmemorydb&quot;&gt;в базах данных в памяти&lt;/a&gt; , при условии, что база данных создается с использованием &lt;a href=&quot;uri&quot;&gt;имени файла URI&lt;/a&gt; . Для обратной совместимости общий кеш всегда отключен для баз данных в памяти, если для открытия базы данных используется неукрашенное имя &quot;: memory:&quot;. До версии 3.7.13 общий кэш всегда был отключен для баз данных в памяти, независимо от используемого имени базы данных, текущей настройки общего системного кеша или параметров или флагов запроса.</target>
        </trans-unit>
        <trans-unit id="6365abc3c758d3309a8a458a1000945ef77510f8" translate="yes" xml:space="preserve">
          <source>Beginning with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_13.html&quot;&gt;version 3.7.13&lt;/a&gt; (2012-06-11), shared cache can be used on &lt;a href=&quot;inmemorydb&quot;&gt;in-memory databases&lt;/a&gt;, provided that the database is created using a &lt;a href=&quot;uri&quot;&gt;URI filename&lt;/a&gt;. For backwards compatibility, shared cache is always disabled for in-memory databases if the unadorned name &quot;:memory:&quot; is used to open the database. Prior to version 3.7.13, shared cache was always disabled for in-memory databases regardless of the database name used, current system shared cache setting, or query parameters or flags.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d897fef3b918d90f462942b797bcba2f181cd38" translate="yes" xml:space="preserve">
          <source>Beginning with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_17.html&quot;&gt;version 3.7.17&lt;/a&gt; (2013-05-20), the unix OS interface will send SQLITE_WARNING messages to the &lt;a href=&quot;errlog&quot;&gt;error log&lt;/a&gt; if a database file has multiple hard links.</source>
          <target state="translated">Начиная с &lt;a href=&quot;https://sqlite.org/releaselog/3_7_17.html&quot;&gt;версии&lt;/a&gt; SQLite 3.7.17 (2013-05-20), интерфейс ОС unix будет отправлять сообщения SQLITE_WARNING в &lt;a href=&quot;errlog&quot;&gt;журнал ошибок,&lt;/a&gt; если файл базы данных имеет несколько жестких ссылок.</target>
        </trans-unit>
        <trans-unit id="7fa120398347f1152da8e84a3905c5d3c58c3466" translate="yes" xml:space="preserve">
          <source>Beginning with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_17.html&quot;&gt;version 3.7.17&lt;/a&gt; (2013-05-20), the unix OS interface will send SQLITE_WARNING messages to the &lt;a href=&quot;errlog&quot;&gt;error log&lt;/a&gt; if a database file is unlinked while it is still in use.</source>
          <target state="translated">Начиная с &lt;a href=&quot;https://sqlite.org/releaselog/3_7_17.html&quot;&gt;версии&lt;/a&gt; SQLite 3.7.17 (2013-05-20), интерфейс ОС unix будет отправлять сообщения SQLITE_WARNING в &lt;a href=&quot;errlog&quot;&gt;журнал ошибок,&lt;/a&gt; если файл базы данных отключен, пока он все еще используется.</target>
        </trans-unit>
        <trans-unit id="8f4af8bd16f5f6dcf0575ed25d9da5ad7a3cecfc" translate="yes" xml:space="preserve">
          <source>Beginning with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_3.html&quot;&gt;version 3.7.3&lt;/a&gt; (2010-10-08), the soft heap limit is enforced regardless of whether or not the &lt;a href=&quot;../compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt; compile-time option is invoked. With &lt;a href=&quot;../compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt;, the soft heap limit is enforced on every memory allocation. Without &lt;a href=&quot;../compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt;, the soft heap limit is only enforced when memory is allocated by the page cache. Testing suggests that because the page cache is the predominate memory user in SQLite, most applications will achieve adequate soft heap limit enforcement without the use of &lt;a href=&quot;../compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt;.</source>
          <target state="translated">Начиная с &lt;a href=&quot;https://sqlite.org/releaselog/3_7_3.html&quot;&gt;версии&lt;/a&gt; SQLite 3.7.3 (2010-10-08), ограничение мягкой кучи применяется независимо от того, &lt;a href=&quot;../compile#enable_memory_management&quot;&gt;активирована&lt;/a&gt; ли опция времени компиляции SQLITE_ENABLE_MEMORY_MANAGEMENT . С &lt;a href=&quot;../compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt; ограничение мягкой кучи применяется при каждом выделении памяти. Без &lt;a href=&quot;../compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt; ограничение мягкой кучи применяется только тогда, когда память выделяется кешем страниц. Тестирование показывает, что, поскольку кеш страницы является преобладающим пользователем памяти в SQLite, большинство приложений добьются адекватного применения ограничения мягкой кучи без использования &lt;a href=&quot;../compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a0dfecc63fffa644348dc3e00941cc0dedd6014a" translate="yes" xml:space="preserve">
          <source>Beginning with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_3.html&quot;&gt;version 3.7.3&lt;/a&gt; (2010-10-08), the soft heap limit is enforced regardless of whether or not the &lt;a href=&quot;compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt; compile-time option is invoked. With &lt;a href=&quot;compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt;, the soft heap limit is enforced on every memory allocation. Without &lt;a href=&quot;compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt;, the soft heap limit is only enforced when memory is allocated by the page cache. Testing suggests that because the page cache is the predominate memory user in SQLite, most applications will achieve adequate soft heap limit enforcement without the use of &lt;a href=&quot;compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt;.</source>
          <target state="translated">Начиная с &lt;a href=&quot;https://sqlite.org/releaselog/3_7_3.html&quot;&gt;версии&lt;/a&gt; SQLite 3.7.3 (2010-10-08), ограничение мягкой кучи применяется независимо от того, &lt;a href=&quot;compile#enable_memory_management&quot;&gt;активирована&lt;/a&gt; ли опция времени компиляции SQLITE_ENABLE_MEMORY_MANAGEMENT . С &lt;a href=&quot;compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt; ограничение мягкой кучи применяется при каждом выделении памяти. Без &lt;a href=&quot;compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt; ограничение мягкой кучи применяется только тогда, когда память выделяется кешем страниц. Тестирование показывает, что, поскольку кеш страницы является преобладающим пользователем памяти в SQLite, большинство приложений добьются адекватного применения ограничения мягкой кучи без использования &lt;a href=&quot;compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c179ab3e7d04af330c7efc2cec123a479ee926c3" translate="yes" xml:space="preserve">
          <source>Beginning with SQLite version 3.24.0 (2018-06-04), r-tree tables can have auxiliary columns that store arbitrary data. Auxiliary columns can be used in place of secondary tables such as &quot;demo_data&quot;.</source>
          <target state="translated">Начиная с версии SQLite 3.24.0 (2018-06-04),таблицы r-дерева могут иметь вспомогательные столбцы,в которых хранятся произвольные данные.Вспомогательные столбцы могут использоваться вместо вторичных таблиц,таких как &quot;demo_data&quot;.</target>
        </trans-unit>
        <trans-unit id="e6d8128996ffada537e69bde476b38bfd6abdaaa" translate="yes" xml:space="preserve">
          <source>Beginning with SQLite version 3.3.14 a mechanism has been added to try to reduce the needless rereading of data. In newer versions of SQLite, the data in the user-space pager cache is retained when the lock on the database file is released. Later, after the shared lock is acquired at the beginning of the next transaction, SQLite checks to see if any other process has modified the database file. If the database has been changed in any way since the lock was last released, the user-space cache is erased at that point. But commonly the database file is unchanged and the user-space cache can be retained, and some unnecessary read operations can be avoided.</source>
          <target state="translated">Начиная с версии SQLite 3.3.14 был добавлен механизм,пытающийся уменьшить ненужное повторное чтение данных.В новых версиях SQLite данные в кэше пользовательского пейджера сохраняются при освобождении замка на файле базы данных.Позже,после получения разделяемой блокировки в начале следующей транзакции,SQLite проверяет,не изменял ли другой процесс файл базы данных.Если с момента последнего снятия блокировки база данных была каким-либо образом изменена,кэш пользовательского пространства стирается в этот момент.Но обычно файл базы данных остается неизменным,и кэш пользовательского пространства может быть сохранен,а некоторые ненужные операции чтения можно избежать.</target>
        </trans-unit>
        <trans-unit id="c39116a071141537c93dfcacc99b39343f685f47" translate="yes" xml:space="preserve">
          <source>Beginning with SQLite version 3.31.0 (2020-01-22), lookaside supports two memory pools, each with a different size slot. The small-slot pool uses 128-byte slots and the large-slot pool uses whatever size is specified by &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfiglookaside&quot;&gt;SQLITE_DBCONFIG_LOOKASIDE&lt;/a&gt; (defaulting to 1200 bytes). Splitting the pool in two like this allows memory allocations to be covered by lookaside more often while at the same time reducing per-database-connection heap usage from 120KB down to 48KB.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="635d1349e5a7c9b8fbfcde84b9ea3c1fb202bc64" translate="yes" xml:space="preserve">
          <source>Beginning with SQLite version 3.31.0 (2020-01-22), the DBSTAT table has a new &lt;a href=&quot;vtab#hiddencol&quot;&gt;hidden column&lt;/a&gt; named &quot;aggregate&quot;, which if constrained to be TRUE will cause DBSTAT to generate one row per btree in the database, rather than one row per page. When running in aggregated mode, the &quot;path&quot;, &quot;pagetype&quot;, and &quot;pgoffset&quot; columns are always NULL and the &quot;pageno&quot; column holds the number of pages in the entire btree, rather than the number of the page that corresponds to the row.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0eba5a240e8bc3220e00f595afb167768fa6cb7" translate="yes" xml:space="preserve">
          <source>Beginning with release 3.25.0 (2018-09-15), references to the table within trigger bodies and view definitions are also renamed.</source>
          <target state="translated">Начиная с версии 3.25.0 (2018-09-15),ссылки на таблицу в телах триггеров и определения представлений также переименовываются.</target>
        </trans-unit>
        <trans-unit id="d654ce8d1a877b686fbd470426c428e02c9409c6" translate="yes" xml:space="preserve">
          <source>Beginning with version 2.2.0, SQLite no longer builds an index for an INTEGER PRIMARY KEY column. Instead, it uses that column as the actual B-Tree key for the main table.</source>
          <target state="translated">Начиная с версии 2.2.0,SQLite больше не строит индекс для столбца INTEGER PRIMARY KEY.Вместо этого он использует этот столбец в качестве фактического B-дерева ключа для основной таблицы.</target>
        </trans-unit>
        <trans-unit id="042e0229fee0d8bfed5724fa18cd980bad0c1945" translate="yes" xml:space="preserve">
          <source>Beginning with version 2.3.0, SQLite supports some additional syntax (the &quot;ON CONFLICT&quot; clause) in the CREATE TABLE and CREATE INDEX statements that are stored in the SQLITE_MASTER table. If you create a database that contains this new syntax, then try to read that database using version 2.2.5 or earlier, the parser will not understand the new syntax and you will get an error. Otherwise, databases for 2.2.x and 2.3.x are interchangeable.</source>
          <target state="translated">Начиная с версии 2.3.0,SQLite поддерживает некоторые дополнительные синтаксис (пункт &quot;ON CONFLICT&quot;)в операторах CREATE TABLE и CREATE INDEX,которые хранятся в таблице SQLITE_MASTER.Если вы создаете базу данных,которая содержит этот новый синтаксис,то попробуйте прочитать эту базу данных,используя версию 2.2.5 или более раннюю,синтаксический анализатор не поймет новый синтаксис,и вы получите ошибку.В противном случае,базы данных для версий 2.2.x и 2.3.x являются взаимозаменяемыми.</target>
        </trans-unit>
        <trans-unit id="d9bdf31e2f633cc8ef293e098f7f5d722da8a2a8" translate="yes" xml:space="preserve">
          <source>Beginning with version 2.4.0, SQLite added support for views. Information about views is stored in the SQLITE_MASTER table. If an older version of SQLite attempts to read a database that contains VIEW information in the SQLITE_MASTER table, the parser will not understand the new syntax and initialization will fail. Also, the way SQLite keeps track of unused disk blocks in the database file changed slightly. If an older version of SQLite attempts to write a database that was previously written by version 2.4.0 or later, then it may leak disk blocks.</source>
          <target state="translated">Начиная с версии 2.4.0,SQLite добавил поддержку представлений.Информация о представлениях хранится в таблице SQLITE_MASTER.Если старая версия SQLite попытается прочитать базу данных,содержащую информацию VIEW в таблице SQLITE_MASTER,парсер не поймет новый синтаксис и инициализация будет неудачной.Также слегка изменится способ,которым SQLite отслеживает неиспользуемые блоки диска в файле базы данных.Если старая версия SQLite попытается записать базу данных,которая ранее была написана версией 2.4.0 или более поздней,то это может привести к утечке блоков диска.</target>
        </trans-unit>
        <trans-unit id="413008ed4f165a3aca53c2fe0890bace8386a170" translate="yes" xml:space="preserve">
          <source>Beginning with version 2.4.0, SQLite allows the SQL language to be extended with new functions implemented as C code. The following interface is used:</source>
          <target state="translated">Начиная с версии 2.4.0,SQLite позволяет расширить язык SQL новыми функциями,реализованными в виде кода C.Используется следующий интерфейс:</target>
        </trans-unit>
        <trans-unit id="8dad8b696b630a32cf19067fe14052c10b2bac25" translate="yes" xml:space="preserve">
          <source>Beginning with version 2.5.0, SQLite added support for triggers. Information about triggers is stored in the SQLITE_MASTER table. If an older version of SQLite attempts to read a database that contains a CREATE TRIGGER in the SQLITE_MASTER table, the parser will not understand the new syntax and initialization will fail.</source>
          <target state="translated">Начиная с версии 2.5.0,SQLite добавил поддержку триггеров.Информация о триггерах хранится в таблице SQLITE_MASTER.Если старая версия SQLite попытается прочитать БД,содержащую CREATE TRIGGER в таблице SQLITE_MASTER,парсер не поймет новый синтаксис и инициализация будет неудачной.</target>
        </trans-unit>
        <trans-unit id="50c1ec93a00d0cbe5badad130d3d4fbd2db53937" translate="yes" xml:space="preserve">
          <source>Beginning with version 2.7.0, SQLite understands two different datatypes: text and numeric. Text data sorts in memcmp() order. Numeric data sorts in numerical order if it looks like a number, or in memcmp() order if it does not.</source>
          <target state="translated">Начиная с версии 2.7.0,SQLite понимает два разных типа данных:текстовый и цифровой.Текстовые данные сортируются в порядке,заданном функцией memcmp().Числовые данные сортируются в числовом порядке,если они выглядят как число,или в порядке memcmp(),если это не так.</target>
        </trans-unit>
        <trans-unit id="c06e002a374c4a8233bf3048a5c902a5ad629404" translate="yes" xml:space="preserve">
          <source>Beginning with version 3.5, SQLite obtains all of the heap memory it needs using the routines &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc()&lt;/a&gt;, &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_free()&lt;/a&gt;, and &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_realloc()&lt;/a&gt;. These routines have existed in prior versions of SQLite, but SQLite has previously bypassed these routines and used its own memory allocator. This all changes in version 3.5.0.</source>
          <target state="translated">Начиная с версии 3.5, SQLite получает всю необходимую ему память кучи с помощью процедур &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc ()&lt;/a&gt; , &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_free ()&lt;/a&gt; и &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_realloc ()&lt;/a&gt; . Эти процедуры существовали в предыдущих версиях SQLite, но SQLite ранее обходил эти процедуры и использовал свой собственный распределитель памяти. Это все изменения в версии 3.5.0.</target>
        </trans-unit>
        <trans-unit id="8cb8a180b3917332f0d153bfa0ea4cd9cfa4625e" translate="yes" xml:space="preserve">
          <source>Behavior when page is not already in cache</source>
          <target state="translated">Поведение,когда страница еще не записана в кэш.</target>
        </trans-unit>
        <trans-unit id="8f48bb3f768498f6c1f4331bb2d5a6b0f760fe90" translate="yes" xml:space="preserve">
          <source>Below is a simple &lt;a href=&quot;http://www.tcl-lang.org&quot;&gt;TCL program&lt;/a&gt; that demonstrates how to use the TCL interface to SQLite. The program executes the SQL statements given as the second argument on the database defined by the first argument. The commands to watch for are the &lt;b&gt;sqlite3&lt;/b&gt; command on line 7 which opens an SQLite database and creates a new object named &quot;&lt;b&gt;db&lt;/b&gt;&quot; to access that database, the use of the &lt;a href=&quot;tclsqlite#eval&quot;&gt;eval method&lt;/a&gt; on the &lt;b&gt;db&lt;/b&gt; object on line 8 to run SQL commands against the database, and the closing of the database connection on the last line of the script.</source>
          <target state="translated">Ниже приведена простая &lt;a href=&quot;http://www.tcl-lang.org&quot;&gt;программа TCL,&lt;/a&gt; которая демонстрирует, как использовать интерфейс TCL для SQLite. Программа выполняет операторы SQL, указанные в качестве второго аргумента в базе данных, определенной первым аргументом. Команды, на которые следует обратить внимание, - это команда &lt;b&gt;sqlite3&lt;/b&gt; в строке 7, которая открывает базу данных SQLite и создает новый объект с именем &amp;laquo; &lt;b&gt;db&lt;/b&gt; &amp;raquo; для доступа к этой базе данных, использование &lt;a href=&quot;tclsqlite#eval&quot;&gt;метода eval&lt;/a&gt; для объекта &lt;b&gt;db&lt;/b&gt; в строке 8 для запуска команд SQL для база данных и закрытие соединения с базой данных в последней строке скрипта.</target>
        </trans-unit>
        <trans-unit id="51e427c04349f8bec5760358d6c76a33f48f0315" translate="yes" xml:space="preserve">
          <source>Below is a simple C program that demonstrates how to use the &lt;a href=&quot;c3ref/intro&quot;&gt;C/C++ interface&lt;/a&gt; to SQLite. The name of a database is given by the first argument and the second argument is one or more SQL statements to execute against the database. The function calls to pay attention to here are the call to &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt; on line 22 which opens the database, &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec()&lt;/a&gt; on line 28 that executes SQL commands against the database, and &lt;a href=&quot;c3ref/close&quot;&gt;sqlite3_close()&lt;/a&gt; on line 33 that closes the database connection.</source>
          <target state="translated">Ниже приведена простая программа на C, которая демонстрирует, как использовать &lt;a href=&quot;c3ref/intro&quot;&gt;интерфейс C / C ++&lt;/a&gt; для SQLite. Имя базы данных задается первым аргументом, а второй аргумент - это один или несколько операторов SQL, выполняемых в отношении базы данных. Функции, на которые следует обратить внимание, - это вызов &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open ()&lt;/a&gt; в строке 22, который открывает базу данных, &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec ()&lt;/a&gt; в строке 28, который выполняет команды SQL для базы данных, и &lt;a href=&quot;c3ref/close&quot;&gt;sqlite3_close ()&lt;/a&gt; в строке 33, которая закрывает соединение с базой данных.</target>
        </trans-unit>
        <trans-unit id="14ff95327015619a83afc17706ad74370a046f84" translate="yes" xml:space="preserve">
          <source>Benefits of SQLite As A File Format</source>
          <target state="translated">Преимущества SQLite как формата файла</target>
        </trans-unit>
        <trans-unit id="616211207d8aaf668be94882f808c6f4c9f8f380" translate="yes" xml:space="preserve">
          <source>Benefits of using WITHOUT ROWID</source>
          <target state="translated">Преимущества использования БЕЗ РОУИДА</target>
        </trans-unit>
        <trans-unit id="115df5f31354f3b89a7926f5d6643866714998ab" translate="yes" xml:space="preserve">
          <source>Better Applications</source>
          <target state="translated">Лучшие приложения</target>
        </trans-unit>
        <trans-unit id="4f38499da00d33476ac2d33142547447ccd5f2e2" translate="yes" xml:space="preserve">
          <source>Better detection and handling of corrupt database files.</source>
          <target state="translated">Лучшее обнаружение и обработка поврежденных файлов базы данных.</target>
        </trans-unit>
        <trans-unit id="add6069aec6aedde19e26e2f4dc8b5d52557685c" translate="yes" xml:space="preserve">
          <source>Better error reporting when problems occur during the automatic 2.5.6 to 2.6.0 database format upgrade.</source>
          <target state="translated">Лучшее информирование об ошибках при возникновении проблем во время автоматического обновления формата базы данных 2.5.6-2.6.0.</target>
        </trans-unit>
        <trans-unit id="5c0db7dca50a13779a4f0032e6c97723feb41348" translate="yes" xml:space="preserve">
          <source>Better handling of aggregate queries where the aggregate functions are contained within subqueries.</source>
          <target state="translated">Улучшение обработки агрегированных запросов,где агрегированные функции содержатся в подзапросах.</target>
        </trans-unit>
        <trans-unit id="da084dd71de733c50c5b48104f01706c6f95c252" translate="yes" xml:space="preserve">
          <source>Better labels on column names of the result.</source>
          <target state="translated">Лучшие метки на названиях столбцов результата.</target>
        </trans-unit>
        <trans-unit id="03681c8056a98d5199927eacf80bcf86a612f164" translate="yes" xml:space="preserve">
          <source>Better optimization of some IN operator expressions.</source>
          <target state="translated">Лучшая оптимизация некоторых выражений оператора IN.</target>
        </trans-unit>
        <trans-unit id="591ea8e488260fd421c2b234d660007536c8a620" translate="yes" xml:space="preserve">
          <source>Better support for file locking so that two or more processes (or threads) can access the same database simultaneously. More work needed in this area, though.</source>
          <target state="translated">Улучшена поддержка блокировки файлов,так что два или более процесса (или потока)могут иметь доступ к одной и той же БД одновременно.Однако в этой области требуется больше работы.</target>
        </trans-unit>
        <trans-unit id="edfa329825b8b1d38ad9507f28f42ef4366de8b4" translate="yes" xml:space="preserve">
          <source>Between them, the contents of the &quot;level&quot; and &quot;idx&quot; fields define the relative age of the segment b-tree. The smaller the value stored in the &quot;level&quot; field, the more recently the segment b-tree was created. If two segment b-trees are of the same &quot;level&quot;, the segment with the larger value stored in the &quot;idx&quot; column is more recent. The PRIMARY KEY constraint on the %_segdir table prevents any two segments from having the same value for both the &quot;level&quot; and &quot;idx&quot; fields.</source>
          <target state="translated">Между ними содержимое полей &quot;уровень&quot; и &quot;idx&quot; определяет относительный возраст отрезка b-дерева.Чем меньше значение,сохраненное в поле &quot;Уровень&quot;,тем позднее был создан отрезок b-дерева.Если два сегмента b-дерева имеют один и тот же &quot;уровень&quot;,то сегмент с большим значением,хранящимся в столбце &quot;idx&quot;,является более свежим.Ограничение PRIMARY KEY в таблице %_segdir не позволяет любым двум сегментам иметь одинаковое значение для полей &quot;level&quot; и &quot;idx&quot;.</target>
        </trans-unit>
        <trans-unit id="3a826f46e213d85c4e2bac37d6cf8440b8e199d0" translate="yes" xml:space="preserve">
          <source>Beware of deleting persistent journal files by any other means since the journal file might be hot, in which case deleting it will corrupt the corresponding database file.</source>
          <target state="translated">Остерегайтесь удалять постоянные файлы журнала любыми другими способами,так как файл журнала может быть горячим,и в этом случае его удаление повредит соответствующий файл базы данных.</target>
        </trans-unit>
        <trans-unit id="bb96cbd05d1971e3d28050245a8829dd6b6aafd2" translate="yes" xml:space="preserve">
          <source>Binary operators</source>
          <target state="translated">двоичные операторы</target>
        </trans-unit>
        <trans-unit id="d2ac1eab329712a8a9c96ce99d077a92e950ad90" translate="yes" xml:space="preserve">
          <source>Bind values to &lt;a href=&quot;../lang_expr#varparam&quot;&gt;parameters&lt;/a&gt; using the sqlite3_bind_*() interfaces.</source>
          <target state="translated">Привяжите значения к &lt;a href=&quot;../lang_expr#varparam&quot;&gt;параметрам&lt;/a&gt; с помощью интерфейсов sqlite3_bind _ * ().</target>
        </trans-unit>
        <trans-unit id="e8d99e3f4d2a89e533a8c574a3feaf717d81ec03" translate="yes" xml:space="preserve">
          <source>Bind values to &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameters&lt;/a&gt; using the sqlite3_bind_*() interfaces.</source>
          <target state="translated">Привяжите значения к &lt;a href=&quot;lang_expr#varparam&quot;&gt;параметрам&lt;/a&gt; с помощью интерфейсов sqlite3_bind _ * ().</target>
        </trans-unit>
        <trans-unit id="7e1661e468dacca4fb2103651a60de473fcaf35b" translate="yes" xml:space="preserve">
          <source>Binding Values To Prepared Statements</source>
          <target state="translated">Привязка стоимости к подготовленным отчетам</target>
        </trans-unit>
        <trans-unit id="416ca5a10db41c1cbc8b3d0b2abf3f34e937f4af" translate="yes" xml:space="preserve">
          <source>Bindings are not cleared by the &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset()&lt;/a&gt; routine. Unbound parameters are interpreted as NULL.</source>
          <target state="translated">Привязки не &lt;a href=&quot;#sqlite3_reset&quot;&gt;удаляются&lt;/a&gt; процедурой sqlite3_reset () . Несвязанные параметры интерпретируются как NULL.</target>
        </trans-unit>
        <trans-unit id="712e7456596b23817bd39e4145191dbf11698c78" translate="yes" xml:space="preserve">
          <source>Bindings are not cleared by the &lt;a href=&quot;reset&quot;&gt;sqlite3_reset()&lt;/a&gt; routine. Unbound parameters are interpreted as NULL.</source>
          <target state="translated">Привязки не &lt;a href=&quot;reset&quot;&gt;удаляются&lt;/a&gt; процедурой sqlite3_reset () . Несвязанные параметры интерпретируются как NULL.</target>
        </trans-unit>
        <trans-unit id="309af9e25956170a810f78e3c71afc45e9766ccf" translate="yes" xml:space="preserve">
          <source>BitAnd</source>
          <target state="translated">BitAnd</target>
        </trans-unit>
        <trans-unit id="0c26c52f02ad0e8a5ab4b7954c846a924ecffb7e" translate="yes" xml:space="preserve">
          <source>BitNot</source>
          <target state="translated">BitNot</target>
        </trans-unit>
        <trans-unit id="f64578ede789cb16c75f551e17bc358c839da2a7" translate="yes" xml:space="preserve">
          <source>BitOr</source>
          <target state="translated">BitOr</target>
        </trans-unit>
        <trans-unit id="c24315eb20cc1f5a565ec08f29abab31c0925f1a" translate="yes" xml:space="preserve">
          <source>Blob</source>
          <target state="translated">Blob</target>
        </trans-unit>
        <trans-unit id="d309b3faf2ef71b6ca2ba079fca1c0074e7599d4" translate="yes" xml:space="preserve">
          <source>Blob containing the root node of the segment b-tree.</source>
          <target state="translated">Капля,содержащая корневой узел сегмента b-дерева.</target>
        </trans-unit>
        <trans-unit id="d284e53d53a1c613b92c33b3c974704b23b2a857" translate="yes" xml:space="preserve">
          <source>Block until the unlock-notify callback is invoked by another thread.</source>
          <target state="translated">Блокируйте до тех пор,пока не будет вызван обратный вызов разблокировки-уведомления другим потоком.</target>
        </trans-unit>
        <trans-unit id="c9ac379f83771407fb1e0d78aaf3f7b5adc6706f" translate="yes" xml:space="preserve">
          <source>Boolean Expressions</source>
          <target state="translated">булевы выражения</target>
        </trans-unit>
        <trans-unit id="c4e413aea96ae1ca804567104303036969e3a88f" translate="yes" xml:space="preserve">
          <source>Boolean datatype</source>
          <target state="translated">булевский тип данных</target>
        </trans-unit>
        <trans-unit id="cb72c24cf8f622cb6c601ea54b18c1fb6181c3db" translate="yes" xml:space="preserve">
          <source>Boolean expression</source>
          <target state="translated">булевское выражение</target>
        </trans-unit>
        <trans-unit id="275cc7006db94d75505db825dc5542aed9bfc26c" translate="yes" xml:space="preserve">
          <source>Borland</source>
          <target state="translated">Borland</target>
        </trans-unit>
        <trans-unit id="2198db2aa3b167004c136853d6cdd281fb62f84a" translate="yes" xml:space="preserve">
          <source>Borland Interbase does not support CASE expressions.</source>
          <target state="translated">Borland Interbase не поддерживает выражения CASE.</target>
        </trans-unit>
        <trans-unit id="ddec281bbecd09ca0988545c1af57dbffaa268c1" translate="yes" xml:space="preserve">
          <source>Both UPDATE statements do exactly the same thing. (They generate identical &lt;a href=&quot;opcode&quot;&gt;bytecode&lt;/a&gt;.) But the first form, the row value form, seems to make it clearer that the intent of the statement is to swap the values in columns A and B.</source>
          <target state="translated">Оба оператора UPDATE делают одно и то же. (Они генерируют идентичный &lt;a href=&quot;opcode&quot;&gt;байт-код&lt;/a&gt; .) Но первая форма, форма значения строки, кажется, проясняет, что цель оператора состоит в том, чтобы поменять местами значения в столбцах A и B.</target>
        </trans-unit>
        <trans-unit id="1dfb4c7d44434c0c4d4db97610721023fe7e4509" translate="yes" xml:space="preserve">
          <source>Both forms of the CASE expression use lazy, or short-circuit, evaluation.</source>
          <target state="translated">Обе формы выражения CASE используют ленивое,или короткое замыкание,оценивание.</target>
        </trans-unit>
        <trans-unit id="bb63583b07e5e464e63e50a8a4cb32ce2f9c5978" translate="yes" xml:space="preserve">
          <source>Both methods for loading an extension allow you to specify the name of an entry point for the extension. You can leave this argument blank - passing in a NULL pointer for the &lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension()&lt;/a&gt; C-language interface or omitting the second argument for the &lt;a href=&quot;lang_corefunc#load_extension&quot;&gt;load_extension()&lt;/a&gt; SQL interface - and the extension loader logic will attempt to figure out the entry point on its own. It will first try the generic extension name &quot;sqlite3_extension_init&quot;. If that does not work, it constructs a entry point using the template &quot;sqlite3_X_init&quot; where the X is replaced by the lowercase equivalent of every ASCII character in the filename after the last &quot;/&quot; and before the first following &quot;.&quot; omitting the first three characters if they happen to be &quot;lib&quot;. So, for example, if the filename is &quot;/usr/lib/libmathfunc-4.8.so&quot; the entry point name would be &quot;sqlite3_mathfunc_init&quot;. Or if the filename is &quot;./SpellFixExt.dll&quot; then the entry point would be called &quot;sqlite3_spellfixext_init&quot;.</source>
          <target state="translated">Оба метода загрузки расширения позволяют указать имя точки входа для расширения. Вы можете оставить этот аргумент пустым, передав указатель NULL для интерфейса языка C &lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension ()&lt;/a&gt; или пропустив второй аргумент для &lt;a href=&quot;lang_corefunc#load_extension&quot;&gt;load_extension ()&lt;/a&gt;Интерфейс SQL - и логика загрузчика расширений попытается самостоятельно определить точку входа. Сначала он попробует использовать общее имя расширения &amp;laquo;sqlite3_extension_init&amp;raquo;. Если это не работает, он создает точку входа, используя шаблон &amp;laquo;sqlite3_X_init&amp;raquo;, где X заменяется строчным эквивалентом каждого символа ASCII в имени файла после последнего &amp;laquo;/&amp;raquo; и перед первым последующим &amp;laquo;.&amp;raquo; опускание первых трех символов, если они оказались &quot;lib&quot;. Так, например, если имя файла - &amp;laquo;/usr/lib/libmathfunc-4.8.so&amp;raquo;, имя точки входа будет &amp;laquo;sqlite3_mathfunc_init&amp;raquo;. Или, если имя файла - &amp;laquo;./SpellFixExt.dll&amp;raquo;, то точка входа будет называться &amp;laquo;sqlite3_spellfixext_init&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="8d91ab9fdfa652980c96ceff09049c0ea85b3c70" translate="yes" xml:space="preserve">
          <source>Both of the RBU functions may be accomplished using SQLite's built-in SQL commands - RBU update via a series of &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;, &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; and &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; commands within a single transaction, and RBU vacuum by a single &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; command. The RBU module provides the following advantages over these simpler approaches:</source>
          <target state="translated">Обе функции RBU могут быть выполнены с использованием встроенных SQL-команд SQLite: обновление RBU с помощью серии команд &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; , &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; и &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; в рамках одной транзакции и очистка RBU с помощью одной команды &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; . Модуль RBU имеет следующие преимущества перед этими более простыми подходами:</target>
        </trans-unit>
        <trans-unit id="e0f6600d4e5a9c39fa518762238ad90dd63b65fb" translate="yes" xml:space="preserve">
          <source>Both of the above example queries would work fine without the acctchng_magnitude index. The acctchng_magnitude index index merely helps the queries to run faster, especially on databases where there are many entries in the table for each account.</source>
          <target state="translated">Оба вышеприведенных примера будут прекрасно работать без индекса acctchng_magnitude.Индекс acctchng_magnitude index просто помогает запросам работать быстрее,особенно в базах данных,где для каждой учетной записи много записей.</target>
        </trans-unit>
        <trans-unit id="7a2132ed90a9ffb07d66917a3fc0b34d8d92cac4" translate="yes" xml:space="preserve">
          <source>Both the TCL and TH3 test harnesses automatically track system resources and report resource leaks on &lt;u&gt;every&lt;/u&gt; test run. No special configuration or setup is required. The test harnesses are especially vigilant with regard to memory leaks. If a change causes a memory leak, the test harnesses will recognize this quickly. SQLite is designed to never leak memory, even after an exception such as an OOM error or disk I/O error. The test harnesses are zealous to enforce this.</source>
          <target state="translated">Оба тестовых пакета TCL и TH3 автоматически отслеживают системные ресурсы и сообщают об утечках ресурсов при &lt;u&gt;каждом&lt;/u&gt; запуске теста. Никакой специальной настройки или настройки не требуется. Тестовые жгуты особенно бдительны в отношении утечек памяти. Если изменение вызывает утечку памяти, тестовые программы быстро распознают это. SQLite предназначен для предотвращения утечки памяти даже после исключения, такого как ошибка OOM или ошибка ввода-вывода диска. Испытательные жгуты усердно следят за этим.</target>
        </trans-unit>
        <trans-unit id="0ad3d82720f17203691deee7f5777d99c121ae33" translate="yes" xml:space="preserve">
          <source>Both the WHEN clause and the trigger actions may access elements of the row being inserted, deleted or updated using references of the form &quot;NEW.</source>
          <target state="translated">Как пункт WHEN,так и триггерные действия могут обращаться к элементам вставляемой,удаляемой или обновляемой строки,используя ссылки формы &quot;НОВИНКА&quot;.</target>
        </trans-unit>
        <trans-unit id="f093637993a88624b64eec10be0614efea759e81" translate="yes" xml:space="preserve">
          <source>Both the pointer and the pointer type parameter to the &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer()&lt;/a&gt; and &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer()&lt;/a&gt; interfaces are &quot;owned&quot; by the caller. In other words, the caller is responsible for ensuring that both values remain valid until after the last access via &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_pointer()&lt;/a&gt;.</source>
          <target state="translated">И указатель, и параметр типа указателя на интерфейсы &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer ()&lt;/a&gt; и &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer ()&lt;/a&gt; &amp;laquo;принадлежат&amp;raquo; вызывающей стороне. Другими словами, вызывающая сторона отвечает за то, чтобы оба значения оставались действительными до последнего обращения через &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_pointer ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d575a966c9a089363bea2d3980a3ff66687213c3" translate="yes" xml:space="preserve">
          <source>Both virtual tables are read-only &lt;a href=&quot;vtab#epoonlyvtab&quot;&gt;eponymous-only virtual tables&lt;/a&gt;. You use them by mentioning them directly in the FROM clause of a SELECT statement. They both require a single argument which is the SQL statement to be analyzed. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2992a96404e75efb9d5d247c72b5e6d63bb4aa3e" translate="yes" xml:space="preserve">
          <source>Boundary value tests</source>
          <target state="translated">Испытания на определение граничных значений</target>
        </trans-unit>
        <trans-unit id="3145fd01726b003b2b97b5a9fb483277f3a90dd2" translate="yes" xml:space="preserve">
          <source>Branch coverage in SQLite is currently measured using &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc/Gcov.html&quot;&gt;gcov&lt;/a&gt; with the &quot;-b&quot; option. First the test program is compiled using options &quot;-g -fprofile-arcs -ftest-coverage&quot; and then the test program is run. Then &quot;gcov -b&quot; is run to generate a coverage report. The coverage report is verbose and inconvenient to read, so the gcov-generated report is processed using some simple scripts to put it into a more human-friendly format. This entire process is automated using scripts, of course.</source>
          <target state="translated">Покрытие веток в SQLite в настоящее время измеряется с помощью &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc/Gcov.html&quot;&gt;gcov&lt;/a&gt; с параметром &amp;laquo;-b&amp;raquo;. Сначала тестовая программа компилируется с использованием опций &amp;laquo;-g -fprofile-arcs -ftest-охват&amp;raquo;, а затем запускается тестовая программа. Затем запускается &quot;gcov -b&quot; для создания отчета о покрытии. Отчет о покрытии является подробным и неудобным для чтения, поэтому отчет, созданный gcov, обрабатывается с использованием некоторых простых сценариев, чтобы преобразовать его в более удобный для человека формат. Конечно, весь этот процесс автоматизирован с использованием скриптов.</target>
        </trans-unit>
        <trans-unit id="c4adfe3c542d88432092f783bc046835df0fe815" translate="yes" xml:space="preserve">
          <source>Branch coverage is more rigorous than statement coverage. Branch coverage measures the number of machine-code branch instructions that are evaluated at least once on both directions.</source>
          <target state="translated">Отраслевой охват более строг,чем охват заявлений.Покрытие отделения измеряет количество инструкций отделения машинного кода,которые хотя бы один раз оцениваются в обоих направлениях.</target>
        </trans-unit>
        <trans-unit id="a22b75ea309c645c4530e03f4541cb259f2d61c7" translate="yes" xml:space="preserve">
          <source>Branch coverage is more strict. With branch coverage, each test and each subblock within the statement is considered separately. In order to achieve 100% branch coverage in the example above, there must be at least three test cases:</source>
          <target state="translated">Отраслевое покрытие более строгое.При покрытии филиалов каждый тест и каждый субблок внутри оператора рассматривается отдельно.Для достижения 100% покрытия ветвей в приведенном выше примере должно быть как минимум три тестовых случая:</target>
        </trans-unit>
        <trans-unit id="97c730065aaff2da27316c3a4fdb27f33630fd48" translate="yes" xml:space="preserve">
          <source>Break out the &quot;Presentor Notes&quot; from each slide into a separate table, for easier access from third-party applications and/or scripts.</source>
          <target state="translated">Разбейте &quot;Заметки докладчика&quot; с каждого слайда в отдельную таблицу,чтобы облегчить доступ к ним из сторонних приложений и/или скриптов.</target>
        </trans-unit>
        <trans-unit id="c53bff6ff25ebaccf14a4078fdb0261d0ccc01ee" translate="yes" xml:space="preserve">
          <source>Break out the GDBM driver into a separate file in anticipation to added new drivers.</source>
          <target state="translated">Разбейте драйвер GDBM в отдельный файл в ожидании добавления новых драйверов.</target>
        </trans-unit>
        <trans-unit id="282c5dfb378bb6abed7a208812bdb6a15f29a876" translate="yes" xml:space="preserve">
          <source>Bring the OS/2 porting layer up-to-date.</source>
          <target state="translated">Обновите уровень портирования OS/2.</target>
        </trans-unit>
        <trans-unit id="82e575ff594a72cfcaccd19ccbf9ad35b704bb47" translate="yes" xml:space="preserve">
          <source>Bring the processing of ORDER BY into compliance with the SQL standard for case where a result alias and a table column name are in conflict. Correct behavior is to prefer the result alias. Older versions of SQLite incorrectly picked the table column. (See ticket #2822.)</source>
          <target state="translated">Привести обработку ORDER BY в соответствие со стандартом SQL в случае конфликта псевдонима результата и имени столбца таблицы.Правильным поведением является предпочтение псевдонима результата.Старые версии SQLite неправильно выбирали столбец таблицы.(См.тикет #2822.)</target>
        </trans-unit>
        <trans-unit id="4f04fd57f5bfebe96a862aebe73b135def3ab6df" translate="yes" xml:space="preserve">
          <source>Bug fix in the processing of the ORDER BY clause for GROUP BY queries</source>
          <target state="translated">Исправлена ошибка в обработке пункта ORDER BY для запросов GROUP BY</target>
        </trans-unit>
        <trans-unit id="a725ca76655ec9003bb82b1a676029a85c0e7d07" translate="yes" xml:space="preserve">
          <source>Bug fix: &quot;SELECT count(*)&quot; was returning NULL for empty tables. Now it returns 0.</source>
          <target state="translated">Исправлена ошибка:&quot;SELECT count(*)&quot; возвращал NULL для пустых таблиц.Теперь возвращается 0.</target>
        </trans-unit>
        <trans-unit id="9e476047ffbbf1baca852a2317f6d224dd2d875a" translate="yes" xml:space="preserve">
          <source>Bug fix: Add in a mutex that was omitted from the previous release.</source>
          <target state="translated">Исправление ошибки:Добавьте мьютекс,который был пропущен из предыдущего релиза.</target>
        </trans-unit>
        <trans-unit id="ab7e0eb1f7494f905f4da13b15772e1fb07bbe1e" translate="yes" xml:space="preserve">
          <source>Bug fix: An assertion was failing if &quot;PRAGMA full_column_names=ON;&quot; was set and you did a query that used a rowid, like this: &quot;SELECT rowid, * FROM ...&quot;.</source>
          <target state="translated">Исправление ошибки:Если было установлено &quot;PRAGMA full_column_names=ON;&quot;,то утверждение было неудачным,и вы делали запрос,в котором использовался rowid,как этот:&quot;SELECT rowid,*FROM ...&quot;.</target>
        </trans-unit>
        <trans-unit id="421117f09c1ef6c1c766b17bffc8c48c0d11cebc" translate="yes" xml:space="preserve">
          <source>Bug fix: An assertion was failing when a temporary table with an index had the same name as a permanent table created by a separate process.</source>
          <target state="translated">Исправление ошибки:Утверждение было неудачным,когда временная таблица с индексом имела то же имя,что и постоянная таблица,созданная отдельным процессом.</target>
        </trans-unit>
        <trans-unit id="0dceede8b9155b23f776e96cfdf9ce26f1c18497" translate="yes" xml:space="preserve">
          <source>Bug fix: An attempt to delete a single row of a table with a WHERE clause of &quot;ROWID=x&quot; when no such rowid exists was causing an error.</source>
          <target state="translated">Исправление ошибки:Попытка удалить одну строку таблицы с пунктом WHERE &quot;ROWID=x&quot;,когда такой rowid не существует,приводила к ошибке.</target>
        </trans-unit>
        <trans-unit id="faaa0c6caea2e40fd936178cd8a1148168d7f164" translate="yes" xml:space="preserve">
          <source>Bug fix: Avoid a deadlock or crash if the &lt;a href=&quot;backup&quot;&gt;backup API&lt;/a&gt;, &lt;a href=&quot;sharedcache&quot;&gt;shared cache&lt;/a&gt;, and the SQLite Encryption Extension are all used at once.</source>
          <target state="translated">Исправление ошибки: предотвращение тупиковой ситуации или сбоя, если &lt;a href=&quot;backup&quot;&gt;API резервного копирования&lt;/a&gt; , &lt;a href=&quot;sharedcache&quot;&gt;общий кеш&lt;/a&gt; и расширение шифрования SQLite используются одновременно.</target>
        </trans-unit>
        <trans-unit id="c9851f7cc2ef1b47f1ede36a70787a28d8a73936" translate="yes" xml:space="preserve">
          <source>Bug fix: Avoid leaking memory on LIMIT and OFFSET clauses in deeply nested UNION ALL queries.</source>
          <target state="translated">Исправление ошибки:Избегайте утечки памяти на клаузулах LIMIT и OFFSET в глубоко вложенных запросах UNION ALL.</target>
        </trans-unit>
        <trans-unit id="eb351871f180a85fd09c35dd04ce4b51eee599a0" translate="yes" xml:space="preserve">
          <source>Bug fix: Avoid segfault when using the &lt;a href=&quot;lang_expr#collateop&quot;&gt;COLLATE operator&lt;/a&gt; inside of a &lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK constraint&lt;/a&gt; or &lt;a href=&quot;lang_createview&quot;&gt;view&lt;/a&gt; in &lt;a href=&quot;sharedcache&quot;&gt;shared cache mode&lt;/a&gt;.</source>
          <target state="translated">Исправление ошибки: избегайте segfault при использовании &lt;a href=&quot;lang_expr#collateop&quot;&gt;оператора COLLATE&lt;/a&gt; внутри &lt;a href=&quot;lang_createtable#ckconst&quot;&gt;ограничения CHECK&lt;/a&gt; или &lt;a href=&quot;lang_createview&quot;&gt;просмотра&lt;/a&gt; в &lt;a href=&quot;sharedcache&quot;&gt;режиме общего кеша&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a618ecebefb94412f1562472983ff94e3605eaab" translate="yes" xml:space="preserve">
          <source>Bug fix: Avoid various concurrency problems in &lt;a href=&quot;sharedcache&quot;&gt;shared cache mode&lt;/a&gt;.</source>
          <target state="translated">Исправление ошибки: предотвращение различных проблем параллелизма в &lt;a href=&quot;sharedcache&quot;&gt;режиме общего кэша&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="633b128d954ff36563e10076bd92bfc7d4d254bc" translate="yes" xml:space="preserve">
          <source>Bug fix: Bare identifiers in ORDER BY clauses bind more tightly to output column names, but identifiers in expressions bind more tightly to input column names. Identifiers in GROUP BY clauses always prefer output column names, however.</source>
          <target state="translated">Исправление ошибки:Голые идентификаторы в пунктах ORDER BY более жестко привязываются к именам выводимых столбцов,но идентификаторы в выражениях более жестко привязываются к вводимым именам столбцов.Однако идентификаторы в клаузулах GROUP BY всегда предпочитают имена выходных колонок.</target>
        </trans-unit>
        <trans-unit id="6a402a829e3faf4148ff927e5cc1ab64a56cfa4a" translate="yes" xml:space="preserve">
          <source>Bug fix: Column names in the result set were not being generated correctly for some (rather complex) VIEWs. This could cause a segfault under certain circumstances.</source>
          <target state="translated">Исправление ошибки:Имена столбцов в результирующем множестве генерировались некорректно для некоторых (довольно сложных)VIEW.При определенных обстоятельствах это может привести к сегрегации.</target>
        </trans-unit>
        <trans-unit id="a6507d4034fca406ed1e6de7d9c69eb86666298e" translate="yes" xml:space="preserve">
          <source>Bug fix: Compute correct table names with the FULL_COLUMN_NAMES pragma is turned on.</source>
          <target state="translated">Исправление ошибки:Вычисление правильных имен таблиц с включенной прагмой FULL_COLUMN_NAMES.</target>
        </trans-unit>
        <trans-unit id="d170d4831a6701524951017930d51215c0de3ceb" translate="yes" xml:space="preserve">
          <source>Bug fix: Compute the correct answer for queries that contain an IS NOT NULL term in the WHERE clause and also contain an OR term in the WHERE clause and are compiled with &lt;a href=&quot;compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt;. &lt;a href=&quot;http://www.sqlite.org/src/info/4c86b126f2&quot;&gt;Ticket [4c86b126f2]&lt;/a&gt;</source>
          <target state="translated">Исправление ошибки: вычисление правильного ответа для запросов, которые содержат термин IS NOT NULL в предложении WHERE, а также содержат термин OR в предложении WHERE и скомпилированы с &lt;a href=&quot;compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt; . &lt;a href=&quot;http://www.sqlite.org/src/info/4c86b126f2&quot;&gt;Билет [4c86b126f2]&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9e9fa36344bc0f04a7e81c8fa8066aa6b76c8c72" translate="yes" xml:space="preserve">
          <source>Bug fix: Correctly handle functions that appear in the WHERE clause of a join.</source>
          <target state="translated">Исправление ошибки:Правильно обрабатываются функции,которые появляются в пункте WHERE соединения.</target>
        </trans-unit>
        <trans-unit id="b19417477425f028b30221d15629f2e13bb03e35" translate="yes" xml:space="preserve">
          <source>Bug fix: Correctly handle terms in the WHERE clause of a join that do not contain a comparison operator.</source>
          <target state="translated">Исправление ошибки:Корректно обрабатываются термины в пункте WHERE соединения,не содержащие оператора сравнения.</target>
        </trans-unit>
        <trans-unit id="f1c7035443112823f2488a80b27044cd7dc930ca" translate="yes" xml:space="preserve">
          <source>Bug fix: Creating and dropping a table all within a single transaction was not working.</source>
          <target state="translated">Исправление ошибки:Не работало создание и опускание таблицы в рамках одной транзакции.</target>
        </trans-unit>
        <trans-unit id="a65ee45495a64aa4ac7b00532e7dcdea10a45c93" translate="yes" xml:space="preserve">
          <source>Bug fix: DISTINCT now recognizes that a &lt;a href=&quot;lang_corefunc#zeroblob&quot;&gt;zeroblob&lt;/a&gt; and a blob of all 0x00 bytes are the same thing. &lt;a href=&quot;http://www.sqlite.org/src/info/fccbde530a&quot;&gt;Ticket [fccbde530a]&lt;/a&gt;</source>
          <target state="translated">Исправление ошибки: DISTINCT теперь распознает, что &lt;a href=&quot;lang_corefunc#zeroblob&quot;&gt;нулевой&lt;/a&gt; двоичный объект и большой двоичный объект размером 0x00 байтов - это одно и то же. &lt;a href=&quot;http://www.sqlite.org/src/info/fccbde530a&quot;&gt;Билет [fccbde530a]&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5e1c19457c6bcac61af13a07643a50b8996bac51" translate="yes" xml:space="preserve">
          <source>Bug fix: DROP TABLE followed by a CREATE TABLE with the same name all within a single transaction was causing a coredump.</source>
          <target state="translated">Исправление ошибки:DROP-таблица,за которой следовала CREATE-таблица с одним и тем же именем,и все это в рамках одной транзакции приводило к созданию коредумпа.</target>
        </trans-unit>
        <trans-unit id="ba00de2c0632584e59e348681ca42b12b644bcbe" translate="yes" xml:space="preserve">
          <source>Bug fix: Database corruption can occur due to the optimization that was introduced in version 2.4.0 (check-in [410]). The problem should now be fixed. The use of versions 2.4.0 through 2.5.2 is not recommended.</source>
          <target state="translated">Исправление ошибки:Повреждение базы данных может произойти из-за оптимизации,которая была введена в версии 2.4.0 (check-in [410]).Теперь проблема должна быть исправлена.Не рекомендуется использовать версии 2.4.0-2.5.2.</target>
        </trans-unit>
        <trans-unit id="bbe70e0c57d51f533365c58d207cdfb57683c5ef" translate="yes" xml:space="preserve">
          <source>Bug fix: Do not allow a virtual table to cancel the ORDER BY clause unless all outer loops are guaranteed to return no more than one row result. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/ba82a4a41eac1&quot;&gt;ba82a4a41eac1&lt;/a&gt;.</source>
          <target state="translated">Исправление ошибки: не позволяйте виртуальной таблице отменять предложение ORDER BY, если только все внешние циклы не гарантируют возврат не более одной строки результата. Билет &lt;a href=&quot;http://www.sqlite.org/src/info/ba82a4a41eac1&quot;&gt;ba82a4a41eac1&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4c3b898a085ef4e9fd7492842026dc724b1316d2" translate="yes" xml:space="preserve">
          <source>Bug fix: Do not attempt the subquery flattening optimization on queries that lack a FROM clause. To do so causes a segfault.</source>
          <target state="translated">Исправление ошибки:Не пытайтесь оптимизировать сплющивание подзапросов при запросах,в которых отсутствует пункт FROM.Это приводит к секрету.</target>
        </trans-unit>
        <trans-unit id="c7d832b024aa33f5c367340914044de719478c03" translate="yes" xml:space="preserve">
          <source>Bug fix: Do not automatically remove the DISTINCT keyword from a SELECT that forms the right-hand side of an IN operator since it is necessary if the SELECT also contains a LIMIT. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/db87229497&quot;&gt;db87229497&lt;/a&gt;.</source>
          <target state="translated">Исправление ошибки: не удаляйте автоматически ключевое слово DISTINCT из оператора SELECT, который формирует правую часть оператора IN, поскольку это необходимо, если SELECT также содержит LIMIT. Билет &lt;a href=&quot;http://www.sqlite.org/src/info/db87229497&quot;&gt;db87229497&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4ec8b17071def3e40c2a66c3efc8f85f8fbeb60d" translate="yes" xml:space="preserve">
          <source>Bug fix: Do not discard the DISTINCT as superfluous unless a subset of the result set is subject to a UNIQUE constraint &lt;em&gt;and&lt;/em&gt; it none of the columns in that subset can be NULL. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/385a5b56b9&quot;&gt;385a5b56b9&lt;/a&gt;.</source>
          <target state="translated">Исправление ошибки: не отбрасывайте DISTINCT как лишнее, если только подмножество набора результатов не подчиняется ограничению UNIQUE, &lt;em&gt;и&lt;/em&gt; ни один из столбцов в этом подмножестве не может иметь значение NULL. Билет &lt;a href=&quot;http://www.sqlite.org/src/info/385a5b56b9&quot;&gt;385a5b56b9&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d122c8d80295b61ea78f7985674ee07265e9fe63" translate="yes" xml:space="preserve">
          <source>Bug fix: Do not move WHERE clause terms inside OR expressions that are contained within an ON clause of a LEFT JOIN. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/f2369304e4&quot;&gt;f2369304e4&lt;/a&gt;</source>
          <target state="translated">Исправление ошибки: не перемещайте термины предложения WHERE внутри выражений OR, содержащихся в предложении ON в LEFT JOIN. Билет &lt;a href=&quot;http://www.sqlite.org/src/info/f2369304e4&quot;&gt;f2369304e4&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2b3ae0e3595ba9969a417594021c4332e3d08633" translate="yes" xml:space="preserve">
          <source>Bug fix: Do not optimize away an ORDER BY clause that has the same terms as a UNIQUE index unless those terms are also NOT NULL. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/2a5629202f&quot;&gt;2a5629202f&lt;/a&gt;.</source>
          <target state="translated">Исправление ошибки: не оптимизируйте предложение ORDER BY, которое имеет те же термины, что и индекс UNIQUE, если только эти термины не являются также NOT NULL. Билет &lt;a href=&quot;http://www.sqlite.org/src/info/2a5629202f&quot;&gt;2a5629202f&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b6453e25436ce2c11dc1b6194ae2dc12f5ca5250" translate="yes" xml:space="preserve">
          <source>Bug fix: Do not suppress the ORDER BY clause on a virtual table query if an IN constraint is used. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/f69b96e3076e&quot;&gt;f69b96e3076e&lt;/a&gt;.</source>
          <target state="translated">Исправление ошибки: не подавляйте предложение ORDER BY в запросе виртуальной таблицы, если используется ограничение IN. Билет &lt;a href=&quot;http://www.sqlite.org/src/info/f69b96e3076e&quot;&gt;f69b96e3076e&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6f89fece6f5c7d025fca0afff2d5506eaef79c01" translate="yes" xml:space="preserve">
          <source>Bug fix: Ensure that &quot;ORDER BY random()&quot; clauses do not get optimized out. &lt;a href=&quot;http://www.sqlite.org/src/info/65bdeb9739&quot;&gt;Ticket [65bdeb9739]&lt;/a&gt;</source>
          <target state="translated">Исправление ошибки: убедитесь, что предложения ORDER BY random () не оптимизированы. &lt;a href=&quot;http://www.sqlite.org/src/info/65bdeb9739&quot;&gt;Билет [65bdeb9739]&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ad5b813b289d7e750591bfb845e4ba940a74acee" translate="yes" xml:space="preserve">
          <source>Bug fix: Ensure the cached KeyInfo objects (an internal abstraction not visible to the application) do not go stale when operating in &lt;a href=&quot;sharedcache&quot;&gt;shared cache mode&lt;/a&gt; and frequently closing and reopening some database connections while leaving other database connections on the same shared cache open continuously. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/e4a18565a36884b00edf&quot;&gt;e4a18565a36884b00edf&lt;/a&gt;.</source>
          <target state="translated">Исправление ошибки: убедитесь, что кэшированные объекты KeyInfo (внутренняя абстракция, не видимая для приложения) не устаревают при работе в &lt;a href=&quot;sharedcache&quot;&gt;режиме общего кэша&lt;/a&gt; и частом закрытии и повторном открытии некоторых соединений с базой данных, оставляя другие соединения с базой данных в том же общем кэше открытыми постоянно. Билет &lt;a href=&quot;https://www.sqlite.org/src/info/e4a18565a36884b00edf&quot;&gt;e4a18565a36884b00edf&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1c94982c68fc72ac2f6ac980a3323226e84f8466" translate="yes" xml:space="preserve">
          <source>Bug fix: Fix a 32-bit overflow problem on CREATE INDEX for databases larger than 16GB.</source>
          <target state="translated">Исправление ошибки:Исправлена проблема 32-битного переполнения на CREATE INDEX для баз данных размером более 16 ГБ.</target>
        </trans-unit>
        <trans-unit id="b6580b5e5232c84824bf613c858acbb24fc5f483" translate="yes" xml:space="preserve">
          <source>Bug fix: Fix a potential &lt;b&gt;database corruption bug&lt;/b&gt; in &lt;a href=&quot;sharedcache&quot;&gt;shared cache mode&lt;/a&gt; when one &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; is closed while another is in the middle of a write transaction. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/e636a050b7&quot;&gt;e636a050b7&lt;/a&gt;</source>
          <target state="translated">Исправление ошибки: исправление потенциальной &lt;b&gt;ошибки повреждения базы данных&lt;/b&gt; в &lt;a href=&quot;sharedcache&quot;&gt;режиме общего кеша,&lt;/a&gt; когда одно &lt;a href=&quot;c3ref/sqlite3&quot;&gt;соединение с базой данных&lt;/a&gt; закрывается, а другое находится в середине транзакции записи. Билет &lt;a href=&quot;http://www.sqlite.org/src/info/e636a050b7&quot;&gt;e636a050b7&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="28f644aa67590d02891787c2b2d9de10e303faef" translate="yes" xml:space="preserve">
          <source>Bug fix: Fix an assertion failure that occurred when ROWID was a column in a SELECT statement on a view.</source>
          <target state="translated">Исправление ошибки:Исправлена ошибка утверждения,которая возникала,когда ROWID был столбцом в утверждении SELECT на представлении.</target>
        </trans-unit>
        <trans-unit id="6de63655427b8362357e0b9729e0309dea102b68" translate="yes" xml:space="preserve">
          <source>Bug fix: Fix an uninitialized variable in the VDBE that would could an assert failure.</source>
          <target state="translated">Исправление ошибки:Исправлена неинициализированная переменная в VDBE,которая могла привести к неудаче.</target>
        </trans-unit>
        <trans-unit id="15567e970418f92d21404d2b997ca55ed7870f2d" translate="yes" xml:space="preserve">
          <source>Bug fix: Fix column default values expressions of the form &quot;DEFAULT(-(-9223372036854775808))&quot; so that they work correctly, initializing the column to a floating point value approximately equal to +9223372036854775808.0.</source>
          <target state="translated">Исправление ошибки:Исправлены выражения значений столбца по умолчанию вида &quot;DEFAULT(-(-9223372036854775808))&quot;,чтобы они корректно работали,инициализируя столбец на значение с плавающей точкой,приблизительно равное +9223372036854775808.0.</target>
        </trans-unit>
        <trans-unit id="b572be392d93fe8f8aa3c731cb70e9adb855b95a" translate="yes" xml:space="preserve">
          <source>Bug fix: Fix the &lt;a href=&quot;lang_corefunc#char&quot;&gt;char()&lt;/a&gt; SQL function so that it returns an empty string rather than an &quot;out of memory&quot; error when called with zero arguments.</source>
          <target state="translated">Исправление ошибки: исправьте функцию SQL &lt;a href=&quot;lang_corefunc#char&quot;&gt;char (),&lt;/a&gt; чтобы она возвращала пустую строку, а не ошибку &amp;laquo;недостаточно памяти&amp;raquo; при вызове с нулевыми аргументами.</target>
        </trans-unit>
        <trans-unit id="ec8ef57ae219363ebc2f9d36c425f7585ca571b1" translate="yes" xml:space="preserve">
          <source>Bug fix: Fix the &lt;a href=&quot;lang_savepoint&quot;&gt;RELEASE&lt;/a&gt; command so that it does not cancel pending queries. This repairs a problem introduced in 3.7.11.</source>
          <target state="translated">Исправление ошибки: исправьте команду &lt;a href=&quot;lang_savepoint&quot;&gt;RELEASE,&lt;/a&gt; чтобы она не отменяла ожидающие запросы. Это устраняет проблему, появившуюся в 3.7.11.</target>
        </trans-unit>
        <trans-unit id="df416fd402ae79122987fd712ad3deeb5c8f5458" translate="yes" xml:space="preserve">
          <source>Bug fix: Generate correct column headers when a compound SELECT is used as a subquery.</source>
          <target state="translated">Исправление ошибки:Сгенерировать правильные заголовки столбцов,когда в качестве подзапроса используется составной SELECT.</target>
        </trans-unit>
        <trans-unit id="8607f97a039e79f9d7bbfb840d1dbfffbf0765f7" translate="yes" xml:space="preserve">
          <source>Bug fix: In the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; CSV import feature, do not end a field when an escaped double-quote occurs at the end of a CRLN line.</source>
          <target state="translated">Исправление ошибки: в функции импорта CSV &lt;a href=&quot;cli&quot;&gt;оболочки командной строки&lt;/a&gt; не заканчивать поле, когда в конце строки CRLN появляется экранированная двойная кавычка.</target>
        </trans-unit>
        <trans-unit id="d77f01bc12cfaa192da17d51a33bb2f997769b11" translate="yes" xml:space="preserve">
          <source>Bug fix: In the &lt;a href=&quot;fts3#unicode61&quot;&gt;unicode61&lt;/a&gt; tokenizer of &lt;a href=&quot;fts3#fts4&quot;&gt;FTS4&lt;/a&gt;, treat all private code points as identifier symbols.</source>
          <target state="translated">Исправление ошибки: в &lt;a href=&quot;fts3#unicode61&quot;&gt;токенизаторе&lt;/a&gt; unicode61 &lt;a href=&quot;fts3#fts4&quot;&gt;FTS4&lt;/a&gt; обрабатывать все частные кодовые точки как символы идентификатора.</target>
        </trans-unit>
        <trans-unit id="fc0e959c372e361cf7f33ef8b8f20d674104ba00" translate="yes" xml:space="preserve">
          <source>Bug fix: Issue an error message if the 16-bit reference counter on a view overflows due to an overly complex query.</source>
          <target state="translated">Исправление ошибки:Выдача сообщения об ошибке,если 16-битный счетчик ссылок на представлении переполнился из-за слишком сложного запроса.</target>
        </trans-unit>
        <trans-unit id="796cd2d86e5fad8940076a58510533a97b2c56bf" translate="yes" xml:space="preserve">
          <source>Bug fix: Make sure &quot;rowid&quot; columns are correctly resolved in joins between normal tables and WITHOUT ROWID tables. &lt;a href=&quot;http://www.sqlite.org/src/info/c34d0557f7&quot;&gt;Ticket [c34d0557f7]&lt;/a&gt;</source>
          <target state="translated">Исправление ошибки: убедитесь, что столбцы &quot;rowid&quot; правильно разрешены в соединениях между обычными таблицами и таблицами БЕЗ ROWID. &lt;a href=&quot;http://www.sqlite.org/src/info/c34d0557f7&quot;&gt;Билет [c34d0557f7]&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="adf0baa27394f8041aaae283cf02f3ee1bfa8b41" translate="yes" xml:space="preserve">
          <source>Bug fix: Make sure &lt;a href=&quot;pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt; statements appear in &lt;a href=&quot;c3ref/profile&quot;&gt;sqlite3_trace()&lt;/a&gt; output.</source>
          <target state="translated">Исправление ошибки: убедитесь, что операторы &lt;a href=&quot;pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt; отображаются в выводе &lt;a href=&quot;c3ref/profile&quot;&gt;sqlite3_trace ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2334a8bc658fa8a7b723fcf78436e06aa632b55a" translate="yes" xml:space="preserve">
          <source>Bug fix: Make sure an error is always reported when attempting to preform an operation that requires a &lt;a href=&quot;datatype3#collation&quot;&gt;collating sequence&lt;/a&gt; that is missing. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/0fc59f908b&quot;&gt;0fc59f908b&lt;/a&gt;</source>
          <target state="translated">Исправление ошибки: убедитесь, что всегда появляется сообщение об ошибке при попытке выполнить операцию, для которой требуется отсутствующая &lt;a href=&quot;datatype3#collation&quot;&gt;последовательность сортировки&lt;/a&gt; . Билет &lt;a href=&quot;http://www.sqlite.org/src/info/0fc59f908b&quot;&gt;0fc59f908b&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7b7a3c06c81b08010533a335b71314ea1246750e" translate="yes" xml:space="preserve">
          <source>Bug fix: Make sure that NULL results from OP_Column are fully and completely NULL and do not have the MEM_Ephem bit set. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/094d39a4c95ee4&quot;&gt;094d39a4c95ee4&lt;/a&gt;.</source>
          <target state="translated">Исправление ошибки: убедитесь, что результаты NULL из OP_Column полностью и полностью равны NULL и не имеют установленного бита MEM_Ephem. Билет &lt;a href=&quot;http://www.sqlite.org/src/info/094d39a4c95ee4&quot;&gt;094d39a4c95ee4&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2b6a649b8a7464f814f81388b6be52f54e12c25e" translate="yes" xml:space="preserve">
          <source>Bug fix: Make sure the journal file directory entry is committed to disk before writing the database file.</source>
          <target state="translated">Исправление ошибки:Перед записью файла базы данных убедитесь,что запись в каталог файлов журнала зафиксирована на диске.</target>
        </trans-unit>
        <trans-unit id="e185f43b49a3251f6e6597892c2f724efa586d32" translate="yes" xml:space="preserve">
          <source>Bug fix: Make sure the same temporary registers are not used in concurrent co-routines used to implement compound SELECT statements containing ORDER BY clauses, as such use can lead to incorrect answers. &lt;a href=&quot;http://www.sqlite.org/src/info/8c63ff0eca&quot;&gt;Ticket [8c63ff0eca]&lt;/a&gt;</source>
          <target state="translated">Исправление ошибки: убедитесь, что одни и те же временные регистры не используются в параллельных подпрограммах, используемых для реализации составных операторов SELECT, содержащих предложения ORDER BY, поскольку такое использование может привести к неправильным ответам. &lt;a href=&quot;http://www.sqlite.org/src/info/8c63ff0eca&quot;&gt;Билет [8c63ff0eca]&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="51326d84193d9019e013ecb68f17ddd96b5b7cd8" translate="yes" xml:space="preserve">
          <source>Bug fix: Make sure the schema is up-to-date prior to running pragmas table_info, index_list, index_info, and foreign_key_list.</source>
          <target state="translated">Исправление ошибки:Убедитесь,что схема обновлена перед запуском pragmaas table_info,index_list,index_info и foreign_key_list.</target>
        </trans-unit>
        <trans-unit id="21876ec37a821c06e59ab2273c8a26e3a12144f2" translate="yes" xml:space="preserve">
          <source>Bug fix: Makes sure the &lt;a href=&quot;c3ref/set_authorizer&quot;&gt;authorizer&lt;/a&gt; callback gets a valid pointer to the string &quot;ROWID&quot; for the column-name parameter when doing an &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; that changes the rowid. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/0eb70d77cb05bb2272&quot;&gt;0eb70d77cb05bb2272&lt;/a&gt;</source>
          <target state="translated">Исправление ошибки: гарантирует, что обратный вызов &lt;a href=&quot;c3ref/set_authorizer&quot;&gt;авторизатора&lt;/a&gt; получает действительный указатель на строку &amp;laquo;ROWID&amp;raquo; для параметра имени столбца при выполнении &lt;a href=&quot;lang_update&quot;&gt;UPDATE,&lt;/a&gt; которое изменяет идентификатор строки. Билет &lt;a href=&quot;http://www.sqlite.org/src/info/0eb70d77cb05bb2272&quot;&gt;0eb70d77cb05bb2272&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fa2f91d43fa97f1a5999350e4addb5cbb3edaca1" translate="yes" xml:space="preserve">
          <source>Bug fix: Only consider AS names from the result set as candidates for resolving identifiers in the WHERE clause if there are no other matches. In the ORDER BY clause, AS names take priority over any column names. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/2500cdb9be05&quot;&gt;2500cdb9be05&lt;/a&gt;</source>
          <target state="translated">Исправление ошибки: считайте имена AS из набора результатов только кандидатами для разрешения идентификаторов в предложении WHERE, если нет других совпадений. В предложении ORDER BY имена AS имеют приоритет над именами столбцов. Билет &lt;a href=&quot;http://www.sqlite.org/src/info/2500cdb9be05&quot;&gt;2500cdb9be05&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="141fde2a748db5215be1ecb9d4a778d891f1cb31" translate="yes" xml:space="preserve">
          <source>Bug fix: Passing in a NULL as the 3rd parameter to &lt;b&gt;sqlite_open()&lt;/b&gt; would sometimes cause a coredump.</source>
          <target state="translated">Исправление ошибки: передача NULL в качестве 3-го параметра функции &lt;b&gt;sqlite_open ()&lt;/b&gt; иногда приводила к отказу от ядра.</target>
        </trans-unit>
        <trans-unit id="2ab06e54b175379ab13bc77c3e0d9c481bc0c496" translate="yes" xml:space="preserve">
          <source>Bug fix: Recognize that any column in the right-hand table of a LEFT JOIN can be NULL even if the column has a NOT NULL constraint. Do not apply optimizations that assume the column is never NULL. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/6f2222d550f5b0ee7ed&quot;&gt;6f2222d550f5b0ee7ed&lt;/a&gt;.</source>
          <target state="translated">Исправление ошибки: следует понимать, что любой столбец в правой таблице LEFT JOIN может иметь значение NULL, даже если столбец имеет ограничение NOT NULL. Не применяйте оптимизацию, которая предполагает, что столбец никогда не имеет значения NULL. Билет &lt;a href=&quot;https://www.sqlite.org/src/info/6f2222d550f5b0ee7ed&quot;&gt;6f2222d550f5b0ee7ed&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="03f2e3e890c570259cec0056bb1e5602f41a8fe5" translate="yes" xml:space="preserve">
          <source>Bug fix: Repair a name-resolution error that can occur in sub-select statements contained within a TRIGGER. &lt;a href=&quot;http://www.sqlite.org/src/info/4ef7e3cfca&quot;&gt;Ticket [4ef7e3cfca]&lt;/a&gt;</source>
          <target state="translated">Исправление ошибки: устранение ошибки разрешения имен, которая может возникать в операторах подвыбора, содержащихся в TRIGGER. &lt;a href=&quot;http://www.sqlite.org/src/info/4ef7e3cfca&quot;&gt;Билет [4ef7e3cfca]&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="179d04a255aba0b12c6e57bf1304a5f158b18e87" translate="yes" xml:space="preserve">
          <source>Bug fix: SQL functions created using the TCL interface honor the &quot;nullvalue&quot; setting.</source>
          <target state="translated">Исправление ошибки:Функции SQL,созданные с помощью интерфейса TCL,учитывают установку &quot;nullvalue&quot;.</target>
        </trans-unit>
        <trans-unit id="0cd3dbb56d1124c2a6604fca7c97c5b4d246ad99" translate="yes" xml:space="preserve">
          <source>Bug fix: Sometimes arbitrary strings were passed to the callback function when the actual value of a column was NULL.</source>
          <target state="translated">Исправление ошибки:Иногда произвольные строки передавались в функцию обратного вызова,когда фактическое значение столбца было NULL.</target>
        </trans-unit>
        <trans-unit id="e6069685c787f1f2374ad59005630cac33f83a18" translate="yes" xml:space="preserve">
          <source>Bug fix: The %c format in sqlite3_mprintf() is able to handle precisions greater than 70.</source>
          <target state="translated">Исправление ошибки:Формат %c в sqlite3_mprintf()способен обрабатывать точности более 70.</target>
        </trans-unit>
        <trans-unit id="8545ae69eab7462c35ca27db0ca5feb48e882da0" translate="yes" xml:space="preserve">
          <source>Bug fix: The &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; gives an exit code of 0 when terminated using the &quot;.quit&quot; command.</source>
          <target state="translated">Исправление ошибки: &lt;a href=&quot;cli&quot;&gt;оболочка командной строки&lt;/a&gt; выдает код выхода 0 при завершении с помощью команды &amp;laquo;.quit&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="3c4dbfc44f9dd05912067f94c3eb5f1e8372f6d5" translate="yes" xml:space="preserve">
          <source>Bug fix: There was an incorrect assert() in pager.c. The real code was all correct (as far as is known) so everything should work OK if you compile with -DNDEBUG=1. When asserts are not disabled, there could be a fault.</source>
          <target state="translated">Исправление ошибки:В пейджере был некорректный assert().Реальный код был корректен (насколько известно),поэтому все должно работать нормально,если вы скомпилируете его с -DNDEBUG=1.Когда утверждения не отключены,может быть ошибка.</target>
        </trans-unit>
        <trans-unit id="ad7bd89e49a8af821827d6b028e2e799f12e2e1e" translate="yes" xml:space="preserve">
          <source>Bug fix: Updates to tables containing an INTEGER PRIMARY KEY and an index could fail.</source>
          <target state="translated">Исправление ошибки:Обновления таблиц,содержащих INTEGER PRIMARY KEY и индекс,могли давать сбои.</target>
        </trans-unit>
        <trans-unit id="6b758d1f8710d23a2038913ec37dece3bec7abf6" translate="yes" xml:space="preserve">
          <source>Bug fix: Virtual tables now handle IS NOT NULL constraints correctly.</source>
          <target state="translated">Исправление ошибки:Виртуальные таблицы теперь корректно обрабатывают НЕ НОЛЬКО ограничений.</target>
        </trans-unit>
        <trans-unit id="332e05b490c4cb7238853c006e2e916e2a9e4dbc" translate="yes" xml:space="preserve">
          <source>Bug fix: When a &lt;a href=&quot;lang_select#compound&quot;&gt;compound query&lt;/a&gt; that uses an ORDER BY clause with a &lt;a href=&quot;lang_expr#collateop&quot;&gt;COLLATE operator&lt;/a&gt;, make sure that the sorting occurs according to the specified collation and that the comparisons associate with the compound query use the native collation. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/6709574d2a8d8&quot;&gt;6709574d2a8d8&lt;/a&gt;.</source>
          <target state="translated">Исправление ошибки: при &lt;a href=&quot;lang_select#compound&quot;&gt;составном запросе, в&lt;/a&gt; котором используется предложение ORDER BY с &lt;a href=&quot;lang_expr#collateop&quot;&gt;оператором COLLATE&lt;/a&gt; , убедитесь, что сортировка выполняется в соответствии с указанным сопоставлением и что сравнения, связанные с составным запросом, используют собственное сопоставление. Билет &lt;a href=&quot;http://www.sqlite.org/src/info/6709574d2a8d8&quot;&gt;6709574d2a8d8&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2cfdb97a345b3ce143f2abc5fd945ed42741b35a" translate="yes" xml:space="preserve">
          <source>Bug fix: allow a VACUUM (without segfaulting) on an empty database after setting the EMPTY_RESULT_CALLBACKS pragma.</source>
          <target state="translated">Исправление ошибки:разрешалось использовать VACUUM (без сегментации)на пустой базе данных после установки прагмы EMPTY_RESULT_CALLBACKS.</target>
        </trans-unit>
        <trans-unit id="1e76d1db13ab52fcac380bd0ae95fbf87bf5df38" translate="yes" xml:space="preserve">
          <source>Bug fix: an assertion was failing if the disk holding the database file became full or stopped accepting writes for some other reason. New tests were added to detect similar problems in the future.</source>
          <target state="translated">Исправление ошибки:если диск,на котором хранился файл базы данных,переполнялся или прекращал прием записей по какой-либо другой причине,утверждение не срабатывало.Были добавлены новые тесты для обнаружения подобных проблем в будущем.</target>
        </trans-unit>
        <trans-unit id="f481a7837f1627a5d4384fe68dbbc8fae1d3d0ad" translate="yes" xml:space="preserve">
          <source>Bug fix: an obscure and relatively harmless bug was causing one of the tests to fail when gcc optimizations are turned on. This release fixes the problem.</source>
          <target state="translated">Исправление:неясная и относительно безобидная ошибка приводила к отказу одного из тестов при включенной gcc-оптимизации.Этот релиз исправляет проблему.</target>
        </trans-unit>
        <trans-unit id="1817a2a23947bcba57e850537b31bddd01fd4808" translate="yes" xml:space="preserve">
          <source>Bug fix: correctly evaluate a view of a view without segfaulting.</source>
          <target state="translated">Исправление ошибки:корректная оценка вида без сегментации.</target>
        </trans-unit>
        <trans-unit id="0bbfec3e6b5b062aa0e10ea3e3ec25c68f3b48e5" translate="yes" xml:space="preserve">
          <source>Bug fix: do not invoke the authorizer when reparsing the schema after a schema change.</source>
          <target state="translated">Исправление ошибки:не вызывать авторизатора при повторном представлении схемы после ее изменения.</target>
        </trans-unit>
        <trans-unit id="ff59932ad9e1623e668bc5144d9efca6daa5ff06" translate="yes" xml:space="preserve">
          <source>Bug fix: if an integer value will not fit in a 32-bit int, store it in a double instead.</source>
          <target state="translated">Исправление:если целое значение не помещалось в 32-битный int,сохраняйте его в двойнике.</target>
        </trans-unit>
        <trans-unit id="09579acd43ac94145eab3e50236de9b1df09778c" translate="yes" xml:space="preserve">
          <source>Bug fix: incorrect VDBE code was being generated for the following circumstance: a query on an indexed table containing a WHERE clause with an IN operator that had a subquery on its right-hand side.</source>
          <target state="translated">Исправление:неправильный код VDBE генерировался при следующем обстоятельстве:запрос к индексируемой таблице,содержащей пункт WHERE с оператором IN,справа от которого был подзапрос.</target>
        </trans-unit>
        <trans-unit id="e8c1bb430eed1f84c250a2cbb94468adfcff9f43" translate="yes" xml:space="preserve">
          <source>Bug fix: prevent database corruption if you dropped a trigger that had the same name as a table.</source>
          <target state="translated">Исправление ошибки:предотвратите повреждение базы данных,если вы уронили триггер,имеющий то же имя,что и таблица.</target>
        </trans-unit>
        <trans-unit id="77f87bfdf4072c6e0867b3768c5f7d3818056770" translate="yes" xml:space="preserve">
          <source>Bug fix: repair a long-standing problem that could cause incorrect query results in a 3-way or larger join that compared INTEGER fields against TEXT fields in two or more places. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/fc7bd6358f&quot;&gt;fc7bd6358f&lt;/a&gt;</source>
          <target state="translated">Исправление ошибки: устранение давней проблемы, которая могла привести к неверным результатам запроса в трехстороннем или более крупном соединении, которое сравнивало поля INTEGER с полями TEXT в двух или более местах. Билет &lt;a href=&quot;http://www.sqlite.org/src/info/fc7bd6358f&quot;&gt;fc7bd6358f&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7c0e4c435db089ba66d14c6f426f1ca923c3e24a" translate="yes" xml:space="preserve">
          <source>Bug fix: the &lt;b&gt;sqlite_busy_timeout()&lt;/b&gt; function was delaying 1000 times too long before failing.</source>
          <target state="translated">Исправление ошибки: &lt;b&gt;функция sqlite_busy_timeout ()&lt;/b&gt; задерживалась в 1000 раз дольше, прежде чем &lt;b&gt;завершилась ошибкой&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="1de9526f456e5138884e0e01586b12298617b6e1" translate="yes" xml:space="preserve">
          <source>Bug fixes</source>
          <target state="translated">Исправления ошибок</target>
        </trans-unit>
        <trans-unit id="9af1a1169b55646981d441c46e6271c5d4e76c17" translate="yes" xml:space="preserve">
          <source>Bug fixes and performance enhancements in the query optimizer</source>
          <target state="translated">Исправление ошибок и повышение производительности в оптимизаторе запросов</target>
        </trans-unit>
        <trans-unit id="c92ef11c871ae07b2d656ca889c918e8054c9d2e" translate="yes" xml:space="preserve">
          <source>Bug fixes and speed improvements. Improved test coverage.</source>
          <target state="translated">Исправление ошибок и улучшение скорости.Улучшенное тестовое покрытие.</target>
        </trans-unit>
        <trans-unit id="fa58e385720020fa0c169f308e1843b2e873b0c1" translate="yes" xml:space="preserve">
          <source>Bug fixes in fts1 and fts2 modules.</source>
          <target state="translated">Исправлены ошибки в модулях fts1 и fts2.</target>
        </trans-unit>
        <trans-unit id="7084081296e3ad1cf8f7221181be2c129e0aee5c" translate="yes" xml:space="preserve">
          <source>Bug fixes in the TCL interface identified by Oleg Oleinick.</source>
          <target state="translated">Исправлена ошибка в TCL-интерфейсе,выявленная Олегом Олейником.</target>
        </trans-unit>
        <trans-unit id="e8aa6f5aee0afe8811b93445b5db21495039c63d" translate="yes" xml:space="preserve">
          <source>Bug fixes in the experimental date/time functions.</source>
          <target state="translated">Исправлена ошибка в экспериментальных функциях даты/времени.</target>
        </trans-unit>
        <trans-unit id="b9c7777bb06388cb9dbb8f975e3fd09b2142a8c1" translate="yes" xml:space="preserve">
          <source>Bug fixes to date/time functions.</source>
          <target state="translated">Исправлены ошибки в функциях даты/времени.</target>
        </trans-unit>
        <trans-unit id="081661d86510940c54a252302be8551477973958" translate="yes" xml:space="preserve">
          <source>Bug fixes too numerous to mention (see the change log).</source>
          <target state="translated">Исправлено слишком большое количество ошибок (см.журнал изменений).</target>
        </trans-unit>
        <trans-unit id="54d964bde3b45008273493e091d5fc828d1a6056" translate="yes" xml:space="preserve">
          <source>Bug fixes:</source>
          <target state="translated">Исправление ошибок:</target>
        </trans-unit>
        <trans-unit id="a6d45e893c4329669744195bd786da10bdc76da3" translate="yes" xml:space="preserve">
          <source>Bug fixes: Correctly handle nested correlated subqueries used with indices in a WHERE clause.</source>
          <target state="translated">Исправление ошибок:Правильно обрабатываются вложенные коррелированные подзапросы,используемые с индексами в пункте WHERE.</target>
        </trans-unit>
        <trans-unit id="24673ce72a32d2ab5eb79f34d4f1d1eb683d14be" translate="yes" xml:space="preserve">
          <source>Bug fixes: Multiple problems in the legacy query optimizer were fixed by the move to &lt;a href=&quot;queryplanner-ng&quot;&gt;NGQP&lt;/a&gt;.</source>
          <target state="translated">Исправления ошибок: несколько проблем в устаревшем оптимизаторе запросов были исправлены путем перехода на &lt;a href=&quot;queryplanner-ng&quot;&gt;NGQP&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="58535f3c8aa73d70d81e761cda2cb8486c811f2f" translate="yes" xml:space="preserve">
          <source>Bugs are far less likely in SQLite than in custom-written file I/O code.</source>
          <target state="translated">Вероятность возникновения ошибок в SQLite намного ниже,чем в пользовательском файле ввода/вывода.</target>
        </trans-unit>
        <trans-unit id="5a61f35b0599148f4a6890e52dcef0661cb0913e" translate="yes" xml:space="preserve">
          <source>Bugs in the FTS3/4 virtual table. (The &quot;integrity-check&quot; command was original conceived as part of the test suite for FTS3/4.)</source>
          <target state="translated">Ошибки в виртуальной таблице FTS3/4.(Команда &quot;проверка целостности&quot; была изначально задумана как часть набора тестов для FTS3/4).</target>
        </trans-unit>
        <trans-unit id="8f202605eb190dddba6e0719369e8fd2b96ba2d8" translate="yes" xml:space="preserve">
          <source>Build the &quot;fts5.c&quot; target. Which also creates fts5.h.</source>
          <target state="translated">Постройте цель &quot;fts5.c&quot;.Что также создает fts5.h.</target>
        </trans-unit>
        <trans-unit id="00497bbc4dcbda4f80e1ffef6721bc5a34a86a97" translate="yes" xml:space="preserve">
          <source>Building SQLite directly from individual source code files is certainly possible, but it is not recommended. For some specialized applications, it might be necessary to modify the build process in ways that cannot be done using just the prebuilt amalgamation source file downloaded from the website. For those situations, it is recommended that a customized amalgamation be built (as described &lt;a href=&quot;howtocompile#amal&quot;&gt;below&lt;/a&gt;) and used. In other words, even if a project requires building SQLite beginning with individual source files, it is still recommended that an amalgamation source file be used as an intermediate step.</source>
          <target state="translated">Сборка SQLite непосредственно из отдельных файлов исходного кода, безусловно, возможна, но не рекомендуется. Для некоторых специализированных приложений может потребоваться изменить процесс сборки способами, которые невозможно сделать, используя только предварительно созданный исходный файл объединения, загруженный с веб-сайта. В таких ситуациях рекомендуется создать индивидуальное объединение (как описано &lt;a href=&quot;howtocompile#amal&quot;&gt;ниже&lt;/a&gt; ) и использовать. Другими словами, даже если проект требует создания SQLite, начиная с отдельных исходных файлов, все же рекомендуется использовать исходный файл объединения в качестве промежуточного шага.</target>
        </trans-unit>
        <trans-unit id="0a71cb495d76b612c809648873b36b593c7393c1" translate="yes" xml:space="preserve">
          <source>Building a DLL</source>
          <target state="translated">Строительство DLL</target>
        </trans-unit>
        <trans-unit id="280b6f6ad70e8ba6e9e400ea3d8e0a9edc8b3677" translate="yes" xml:space="preserve">
          <source>Building shared libraries for Mac OS X and Windows is not nearly so simple, unfortunately. For those platforms it is best to use the configure script and makefile that is included with the &lt;a href=&quot;https://sqlite.org/download.html&quot;&gt;TEA tarball&lt;/a&gt;.</source>
          <target state="translated">К сожалению, создание общих библиотек для Mac OS X и Windows далеко не так просто. Для этих платформ лучше всего использовать скрипт конфигурации и make-файл, которые включены в &lt;a href=&quot;https://sqlite.org/download.html&quot;&gt;архив TEA&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="22bc37f7023e946a78cac7bbfe5894c0db4b3f89" translate="yes" xml:space="preserve">
          <source>Building the amalgamation</source>
          <target state="translated">Строительство объединения</target>
        </trans-unit>
        <trans-unit id="baa9f6c7f9720c4460c1521a23a159ddd34e81a1" translate="yes" xml:space="preserve">
          <source>Built-In Scalar SQL Functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2d49de15987506a3eaf80acc91b361f30b458bf" translate="yes" xml:space="preserve">
          <source>Built-in &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued functions&lt;/a&gt; that return the results of &lt;a href=&quot;pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt; statements for use within ordinary SQL queries.</source>
          <target state="translated">Встроенные возвращающие &lt;a href=&quot;vtab#tabfunc2&quot;&gt;табличное значение функции&lt;/a&gt; , возвращающие результаты операторов &lt;a href=&quot;pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt; для использования в обычных SQL-запросах.</target>
        </trans-unit>
        <trans-unit id="78cbf7ad58abfcde67b880290a3fdb26ae265ea9" translate="yes" xml:space="preserve">
          <source>Built-in Aggregate Functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb80809ef25b3a813f862af2f128324a798b2745" translate="yes" xml:space="preserve">
          <source>Built-in functions may be overloaded by new application-defined functions.</source>
          <target state="translated">Встроенные функции могут быть перегружены новыми функциями,определяемыми приложением.</target>
        </trans-unit>
        <trans-unit id="224b755bc066a07e060bb8deb0ae84ff72d8c6e6" translate="yes" xml:space="preserve">
          <source>Built-in window functions honor any PARTITION BY clause in the same way as aggregate window functions - each selected row is assigned to a partition and each partition is processed separately. The ways in which any ORDER BY clause affects each built-in window function is described below. Some of the window functions (rank(), dense_rank(), percent_rank() and ntile()) use the concept of &quot;peer groups&quot; (rows within the same partition that have the same values for all ORDER BY expressions). In these cases, it does not matter whether the frame-spec specifies ROWS, GROUPS, or RANGE. For the purposes of built-in window function processing, rows with the same values for all ORDER BY expressions are considered peers regardless of the frame type.</source>
          <target state="translated">Функции встроенного окна принимают во внимание любую ЧАСТЬ В Классификации так же,как функции агрегированного окна-каждая выделенная строка приписана к простенку,и каждый простенок обрабатывается отдельно.Способы,которыми любая оговорка ЗАКАЗАТЬ ВАШЕЙ влияет на каждую функцию встроенного окна,описаны ниже.Некоторые из оконных функций (rank(),dense_rank(),percent_rank()и ntile())используют концепцию &quot;одноранговых групп&quot; (строк внутри одного и того же простенка,которые имеют одинаковые значения для всех выражений ЗАКАЗЧИКА BY).В этих случаях не имеет значения,указывает ли спецификация кадра ROWS,GROUPS или RANGE.Для целей встроенной обработки функции окна строки с одинаковыми значениями для всех выражений ORDER BY считаются равными вне зависимости от типа кадра.</target>
        </trans-unit>
        <trans-unit id="5a25ccfc2ab6b23f400787b0cd05318c6367c6b9" translate="yes" xml:space="preserve">
          <source>Builtin window functions</source>
          <target state="translated">Функции встроенного окна</target>
        </trans-unit>
        <trans-unit id="3fddbac5f0f5f0b32fe70d555580cce7a2b2229b" translate="yes" xml:space="preserve">
          <source>Bundle sqlite_encode_binary() and sqlite_decode_binary() with the library.</source>
          <target state="translated">Пакет sqlite_encode_binary()и sqlite_decode_binary()с библиотекой.</target>
        </trans-unit>
        <trans-unit id="f637663e6355164a78b8db75eb1fc4755242d81d" translate="yes" xml:space="preserve">
          <source>Bury the dead.</source>
          <target state="translated">Похороните мертвых.</target>
        </trans-unit>
        <trans-unit id="c86307059b070b415312a3a5cc51007f6e153433" translate="yes" xml:space="preserve">
          <source>But SQLite does use the declared type of a column as a hint that you prefer values in that format. So, for example, if a column is of type INTEGER and you try to insert a string into that column, SQLite will attempt to convert the string into an integer. If it can, it inserts the integer instead. If not, it inserts the string. This feature is called &lt;a href=&quot;datatype3#affinity&quot;&gt;type affinity&lt;/a&gt;.</source>
          <target state="translated">Но SQLite действительно использует объявленный тип столбца как подсказку о том, что вы предпочитаете значения в этом формате. Так, например, если столбец имеет тип INTEGER и вы пытаетесь вставить строку в этот столбец, SQLite попытается преобразовать строку в целое число. Если это возможно, вместо этого вставляется целое число. Если нет, он вставляет строку. Эта функция называется &lt;a href=&quot;datatype3#affinity&quot;&gt;сходством типов&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="23199e0b44d24bd1ee4c96e22ea9bb3d1c2f67f4" translate="yes" xml:space="preserve">
          <source>But SQLite is built into the application. So if the data is on a separate device from the application, it is required that the higher bandwidth engine-to-disk link be across the network. This works, but it is suboptimal. Hence, it is usually better to select a client/server database engine when the data is on a separate device from the application.</source>
          <target state="translated">Но SQLite встроен в приложение.Поэтому,если данные находятся на отдельном устройстве от приложения,необходимо,чтобы более высокая пропускная способность канала связи между дисками была по всей сети.Это работает,но это неоптимально.Следовательно,обычно лучше выбрать движок базы данных клиент/сервер,когда данные находятся на отдельном устройстве от приложения.</target>
        </trans-unit>
        <trans-unit id="09ce2891d1601356f9a03f1d38be77a08462a437" translate="yes" xml:space="preserve">
          <source>But an SQLite database is not limited to a simple key/value structure like a pile-of-files database. An SQLite database can have dozens or hundreds or thousands of different tables, with dozens or hundreds or thousands of fields per table, each with different datatypes and constraints and particular meanings, all cross-referencing each other, appropriately and automatically indexed for rapid retrieval, and all stored efficiently and compactly in a single disk file. And all of this structure is succinctly documented for humans by the SQL schema.</source>
          <target state="translated">Однако база данных SQLite не ограничивается простой структурой ключ/значение,как база данных &quot;куча файлов&quot;.База данных SQLite может иметь десятки,сотни и тысячи различных таблиц,с десятками,сотнями и тысячами полей на таблицу,каждая из которых имеет различные типы данных,ограничения и конкретные значения,все они имеют перекрестные ссылки друг на друга,соответствующим образом и автоматически индексируются для быстрого поиска,и все они хранятся эффективно и компактно в одном дисковом файле.И вся эта структура кратко документирована для человека по схеме SQL.</target>
        </trans-unit>
        <trans-unit id="d929882a8a439200f669cf52bfce1643d73dfffb" translate="yes" xml:space="preserve">
          <source>But as with any query planner change, upgrading to the NGQP does carry a small risk of introducing performance regressions. The problem here is not that the NGQP is incorrect or buggy or inferior to the legacy query planner. Given reliable information about the selectivity of indexes, the NGQP should always pick a plan that is as good or better than before. The problem is that some applications may be using low-quality and low-selectivity indexes without having run &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt;. The older query planners look at many fewer possible implementations for each query and so they may have stumbled over a good plan by stupid luck. The NGQP, on the other hand, looks at many more query plan possibilities, and it may choose a different query plan that works better in theory, assuming good indexes, but which gives a performance regression in practice, because of the shape of the data.</source>
          <target state="translated">Но, как и при любом изменении планировщика запросов, обновление до NGQP сопряжено с небольшим риском снижения производительности. Проблема здесь не в том, что NGQP неверен, содержит ошибки или уступает устаревшему планировщику запросов. Учитывая надежную информацию о селективности индексов, NGQP всегда должен выбирать такой же или лучший план, чем раньше. Проблема в том, что некоторые приложения могут использовать индексы низкого качества и низкой селективности без запуска &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE.&lt;/a&gt;. Старые планировщики запросов смотрят на гораздо меньше возможных реализаций для каждого запроса, поэтому они, возможно, наткнулись на хороший план по глупой удаче. NGQP, с другой стороны, рассматривает гораздо больше возможностей плана запроса и может выбрать другой план запроса, который лучше работает в теории, предполагая хорошие индексы, но который дает регресс производительности на практике из-за формы данных. .</target>
        </trans-unit>
        <trans-unit id="bcf6c11e8e6d47ec28df41f7ffce035dc6edbeac" translate="yes" xml:space="preserve">
          <source>But because the &lt;a href=&quot;../lang_select&quot;&gt;SELECT&lt;/a&gt; statement does not change the database file directly, sqlite3_stmt_readonly() would still return true.</source>
          <target state="translated">Но поскольку &lt;a href=&quot;../lang_select&quot;&gt;оператор SELECT&lt;/a&gt; не изменяет файл базы данных напрямую, sqlite3_stmt_readonly () все равно вернет true.</target>
        </trans-unit>
        <trans-unit id="452ab026c840b3ee756da71d85f2e4c8edc72d0b" translate="yes" xml:space="preserve">
          <source>But because the &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statement does not change the database file directly, sqlite3_stmt_readonly() would still return true.</source>
          <target state="translated">Но поскольку &lt;a href=&quot;lang_select&quot;&gt;оператор SELECT&lt;/a&gt; не изменяет файл базы данных напрямую, sqlite3_stmt_readonly () все равно вернет true.</target>
        </trans-unit>
        <trans-unit id="ff4e39f9bba0236549d62b5ae4b68b2eb0a104f9" translate="yes" xml:space="preserve">
          <source>But database engines like SQLite are usually not this way. The SQL scripts that are passed into SQLite come from the (trusted) application itself, not from an attacker. Sometimes applications contain bugs by which an external attacker can trick the application into sending SQL of the attackers design into the database engine. This is a separate bug in the application called an &lt;a href=&quot;https://en.wikipedia.org/wiki/SQL_injection&quot;&gt;SQL Injection vulnerability&lt;/a&gt;. Since SQL text is executable code, an SQL Injection vulnerability is actually a special case of a &lt;a href=&quot;https://en.wikipedia.org/wiki/Arbitrary_code_execution&quot;&gt;Remote Code Execution (RCE) vulnerability&lt;/a&gt;. An SQL Injection is perhaps not quite as bad as other kinds of RCEs because, while SQL is a powerful language, it is not as convenient for crafting an exploit as Python or shell script or raw machine code. Nevertheless, an SQL Injection is a serious problem.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3654dae88afc03c2b5b644ec401c70beb10ac13" translate="yes" xml:space="preserve">
          <source>But does this really save time? The number of steps in the &lt;a href=&quot;#fig16&quot;&gt;original indexless sort&lt;/a&gt; is proportional to NlogN since that is how much time it takes to sort N rows. But when we use Idx1 as shown here, we have to do N rowid lookups which take logN time each, so the total time of NlogN is the same!</source>
          <target state="translated">Но действительно ли это экономит время? Количество шагов в &lt;a href=&quot;#fig16&quot;&gt;исходной безиндексной сортировке&lt;/a&gt; пропорционально NlogN, поскольку именно столько времени требуется для сортировки N строк. Но когда мы используем Idx1, как показано здесь, нам нужно выполнить N поисков по идентификатору строки, каждый из которых занимает время входа N, поэтому общее время NlogN одинаково!</target>
        </trans-unit>
        <trans-unit id="d6fc31d48c09d06ad4b37abcbcf5f0dce6a8ec76" translate="yes" xml:space="preserve">
          <source>But from the point of view of the VDBE, a CREATE works pretty much like an INSERT and a DROP works like a DELETE. When the SQLite library opens to an existing database, the first thing it does is a SELECT to read the &quot;sql&quot; columns from all entries of the sqlite_master table. The &quot;sql&quot; column contains the complete SQL text of the CREATE statement that originally generated the index or table. This text is fed back into the SQLite parser and used to reconstruct the internal data structures describing the index or table.</source>
          <target state="translated">Но с точки зрения VDBE,CREATE работает почти как INSERT,а DROP работает как DELETE.Когда библиотека SQLite открывается для существующей базы данных,первое,что она делает,это SELECT для чтения столбцов &quot;sql&quot; из всех записей таблицы sqlite_master.Столбец &quot;sql&quot; содержит полный SQL-текст оператора CREATE,который изначально создал индекс или таблицу.Этот текст возвращается в синтаксический анализатор SQLite и используется для реконструкции внутренних структур данных,описывающих индекс или таблицу.</target>
        </trans-unit>
        <trans-unit id="48911d596580c34107a4030f62db573e6c27c85f" translate="yes" xml:space="preserve">
          <source>But if SQLite wants to access a page of the database file and memory mapped I/O is enabled, it first calls the xFetch() method. The xFetch() method asks the operating system to return a pointer to the requested page, if possible. If the requested page has been or can be mapped into the application address space, then xFetch returns a pointer to that page for SQLite to use without having to copy anything. Skipping the copy step is what makes memory mapped I/O faster.</source>
          <target state="translated">Но если SQLite хочет получить доступ к странице файла базы данных и включена память mapped I/O,он сначала вызывает метод xFetch().Метод xFetch()запрашивает операционную систему вернуть указатель на запрошенную страницу,если это возможно.Если запрашиваемая страница была или может быть отображена в адресное пространство приложения,то xFetch возвращает указатель на эту страницу для использования SQLite без необходимости копирования.Пропуск этапа копирования-это то,что ускоряет ввод/вывод отображенной памяти.</target>
        </trans-unit>
        <trans-unit id="29180962652da325c9c8e705d40a3befafb60fff" translate="yes" xml:space="preserve">
          <source>But if a hacker is able to run arbitrary SQL, he might run a slightly different query, like this:</source>
          <target state="translated">Но если хакеру удастся запустить произвольный SQL,то он может выполнить несколько другой запрос,например,такой:</target>
        </trans-unit>
        <trans-unit id="42f14da1dea8e44296cffda380cd3db71f9a44b1" translate="yes" xml:space="preserve">
          <source>But if an attacker can already run arbitrary SQL, they do not need a bug to cause a denial of service. There are plenty of perfectly legal and valid SQL statements that will consume unlimited CPU, memory, and disk I/O in order to create a denial-of-service without requiring help from bugs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="560c7f07ebe8e7827f02303fd33e3696ffc6d5d9" translate="yes" xml:space="preserve">
          <source>But if the</source>
          <target state="translated">Но если</target>
        </trans-unit>
        <trans-unit id="a0cdbfa12f5d3945de1878cd75d88dc29371bd31" translate="yes" xml:space="preserve">
          <source>But if the EMPTY_RESULT_CALLBACKS pragma is ON, then the following is returned:</source>
          <target state="translated">Но если прагма EMPTY_RESULT_CALLBACKS включена,то возвращается следующее:</target>
        </trans-unit>
        <trans-unit id="3b2f2e220bf3a85ffdbd93e68cd80fcba741ecfe" translate="yes" xml:space="preserve">
          <source>But if the case_sensitive_like pragma is enabled as follows:</source>
          <target state="translated">Но если включена прагма,подобная case_sensitive_like,следующим образом:</target>
        </trans-unit>
        <trans-unit id="917ffdb9308404a9f9ecbb2338ae37ba101af829" translate="yes" xml:space="preserve">
          <source>But if the i-th parameter is NULL we will get:</source>
          <target state="translated">Но если i-й параметр будет NULL,то мы получим:</target>
        </trans-unit>
        <trans-unit id="418b21f56edf736ac615f67f52f5ff8cd5de8694" translate="yes" xml:space="preserve">
          <source>But if we change the ORDER BY clause to add the &quot;DESC&quot; modifier, that will cause lower levels in the organization (with larger &quot;level&quot; values) to be processed first by the recursive-select, resulting in a depth-first search:</source>
          <target state="translated">Но если изменить пункт ORDER BY на добавление модификатора &quot;DESC&quot;,то нижние уровни в организации (с большими значениями &quot;уровня&quot;)будут сначала обработаны рекурсивным выбором,что приведет к первому глубинному перебору:</target>
        </trans-unit>
        <trans-unit id="b73aaf5e4e2de9f2adc91308c0011207fcb7df2b" translate="yes" xml:space="preserve">
          <source>But in a coverage measuring build, the &lt;code&gt;testcase()&lt;/code&gt; macro generates code that evaluates the conditional expression in its argument. Then during analysis, a check is made to ensure tests exist that evaluate the conditional to both true and false. &lt;code&gt;Testcase()&lt;/code&gt; macros are used, for example, to help verify that boundary values are tested. For example:</source>
          <target state="translated">Но в сборке измерения покрытия макрос &lt;code&gt;testcase()&lt;/code&gt; генерирует код, который оценивает условное выражение в своем аргументе. Затем во время анализа выполняется проверка, чтобы убедиться, что существуют тесты, оценивающие условие как истинное, так и ложное. &lt;code&gt;Testcase()&lt;/code&gt; используются, например, для проверки проверки граничных значений. Например:</target>
        </trans-unit>
        <trans-unit id="6cba989629259efaf3551fd795674dc99bb4d48d" translate="yes" xml:space="preserve">
          <source>But in the following logically equivalent formulation of the same query, the substitution of &quot;CROSS JOIN&quot; for the &quot;,&quot; means that the order of tables must be N1, E, N2.</source>
          <target state="translated">Но в следующей логически эквивалентной формулировке того же запроса замена &quot;CROSS JOIN&quot; на &quot;,&quot; означает,что порядок таблиц должен быть N1,E,N2.</target>
        </trans-unit>
        <trans-unit id="2a172174425039b0a04cf59d0c65f9b7b37ef450" translate="yes" xml:space="preserve">
          <source>But the &quot;.tables&quot; command does more. It queries the &lt;a href=&quot;schematab&quot;&gt;sqlite_schema&lt;/a&gt; table for all &lt;a href=&quot;lang_attach&quot;&gt;attached&lt;/a&gt; databases, not just the primary database. And it arranges its output into neat columns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07070136c4e43ff98642891d2498eeab4c61ffd9" translate="yes" xml:space="preserve">
          <source>But the &quot;.tables&quot; command does more. It queries the sqlite_master table for all &lt;a href=&quot;lang_attach&quot;&gt;attached&lt;/a&gt; databases, not just the primary database. And it arranges its output into neat columns.</source>
          <target state="translated">Но команда &quot;.tables&quot; делает больше. Он запрашивает таблицу sqlite_master для всех &lt;a href=&quot;lang_attach&quot;&gt;подключенных&lt;/a&gt; баз данных, а не только для первичной базы данных. И он размещает свой вывод в аккуратные столбцы.</target>
        </trans-unit>
        <trans-unit id="cc1b6b83457a776880f02cbe1ed99910a24b8fb2" translate="yes" xml:space="preserve">
          <source>But the following declaration does not result in &quot;x&quot; being an alias for the rowid:</source>
          <target state="translated">Но следующая декларация не приводит к тому,что &quot;x&quot; является псевдонимом для rowid:</target>
        </trans-unit>
        <trans-unit id="2d13a39c7ff19d1a4a67287041174bb7cee527dd" translate="yes" xml:space="preserve">
          <source>But the next query can not use the partial index:</source>
          <target state="translated">Но следующий запрос не может использовать частичный индекс:</target>
        </trans-unit>
        <trans-unit id="4968c094e6119e8a687db966e94b26bef2ebe4a4" translate="yes" xml:space="preserve">
          <source>But the use of subtypes does nothing to prevent the value of a pointer from being read using SQL code like this:</source>
          <target state="translated">Но использование подтипов ничего не делает для того,чтобы значение указателя не было прочитано с помощью такого SQL кода:</target>
        </trans-unit>
        <trans-unit id="6310277e9a108b401d7850bc8ffad69350ce478c" translate="yes" xml:space="preserve">
          <source>But there are also disadvantages:</source>
          <target state="translated">Но есть и недостатки:</target>
        </trans-unit>
        <trans-unit id="f1e940122523fbd2f68feec81164dcb25704b65b" translate="yes" xml:space="preserve">
          <source>But those routines are optional can can be omitted using a &lt;a href=&quot;compile#zero_malloc&quot;&gt;compile-time option&lt;/a&gt;.</source>
          <target state="translated">Но эти подпрограммы необязательны, их можно опустить, используя &lt;a href=&quot;compile#zero_malloc&quot;&gt;параметр времени компиляции&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b843ee326d7f7cdf5b63dd9bf52bb27bf7756e78" translate="yes" xml:space="preserve">
          <source>But what value to choose for N? One might try N=K. This makes the algorithm O(K&lt;small&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/small&gt;) which is actually still quite efficient, since the maximum value of K is 64 and K rarely exceeds 10. But that is not enough for the TPC-H Q8 problem. With N=8 on TPC-H Q8 the N3 algorithm finds the solution R-N1-C-O-L-S-N2-P with a cost of 29.78. That is a big improvement over NN, but it is still not optimal. N3 finds the optimal solution for TPC-H Q8 when N is 10 or greater.</source>
          <target state="translated">Но какое значение выбрать для N? Можно попробовать N = K. Это делает алгоритм O (K &lt;small&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/small&gt; ), который на самом деле все еще достаточно эффективен, поскольку максимальное значение K равно 64, а K редко превышает 10. Но этого недостаточно для проблемы TPC-H Q8. При N = 8 на TPC-H Q8 алгоритм N3 находит решение R-N1-COLS-N2-P со стоимостью 29,78. Это большое улучшение по сравнению с NN, но все же не оптимально. N3 находит оптимальное решение для TPC-H Q8, когда N равно 10 или больше.</target>
        </trans-unit>
        <trans-unit id="65129801103eda08bf342c707b068d5b768e6daf" translate="yes" xml:space="preserve">
          <source>But with SQLite, 200 or more SQL statement per webpage is not a problem.</source>
          <target state="translated">Но с SQLite,200 или более SQL операторов на веб-страницу не является проблемой.</target>
        </trans-unit>
        <trans-unit id="36f51675b3471666e7cff23ca3ceb542e736b084" translate="yes" xml:space="preserve">
          <source>But, generally speaking, the more constraints that the R*Tree module has to work with, and the smaller the bounding box, the faster the results will come back.</source>
          <target state="translated">Но,вообще говоря,чем больше ограничений должно работать с модулем R*Tree,и чем меньше граничное окно,тем быстрее будут возвращаться результаты.</target>
        </trans-unit>
        <trans-unit id="bb3dd504a4ceaa15395efbf567f6c35a7b699cba" translate="yes" xml:space="preserve">
          <source>By &quot;static string&quot;, we mean a zero-terminated array of bytes that is fixed and unchanging for the life of the program. In other words, the pointer type string should be a string constant. In contrast, a &quot;dynamic string&quot; is a zero-terminated array of bytes that is held in memory allocated from the heap, and which must be freed to avoid a memory leak. Do not use dynamic strings as the pointer type string.</source>
          <target state="translated">Под &quot;статической строкой&quot; мы понимаем массив байт с нулевым значением,который является фиксированным и неизменным на протяжении всего срока службы программы.Другими словами,строка типа указатель должна быть строковой константой.Напротив,&quot;динамическая строка&quot;-это нуль-терминированный массив байт,который хранится в памяти,выделенной из кучи,и который необходимо освободить,чтобы избежать утечки памяти.Не используйте динамические строки в качестве строки с указателем на тип.</target>
        </trans-unit>
        <trans-unit id="f606d9b23ace8996276bde7ccd24b4d280a3c7c4" translate="yes" xml:space="preserve">
          <source>By adding multiple synonyms for a single term to the FTS index. Using this method, when tokenizing document text, the tokenizer provides multiple synonyms for each token. So that when a document such as &quot;I won first place&quot; is tokenized, entries are added to the FTS index for &quot;i&quot;, &quot;won&quot;, &quot;first&quot;, &quot;1st&quot; and &quot;place&quot;.</source>
          <target state="translated">Путем добавления нескольких синонимов для одного термина в индекс FTS.Используя этот метод,при маркировке текста документа маркер предоставляет несколько синонимов для каждого маркера.Таким образом,при токенировании такого документа,как &quot;Я занял первое место&quot;,в индекс FTS добавляются записи для &quot;i&quot;,&quot;выиграл&quot;,&quot;первый&quot;,&quot;1-й&quot; и &quot;место&quot;.</target>
        </trans-unit>
        <trans-unit id="80b3f84643451df0998b16a1d70d04019fc8e45c" translate="yes" xml:space="preserve">
          <source>By combining location data and related information into the same table, auxiliary columns can provide a cleaner model and reduce the need to joins. For example, the earlier &lt;a href=&quot;#diquery&quot;&gt;join between demo_index and demo_data&lt;/a&gt; can now be written as a simple query, like this:</source>
          <target state="translated">Комбинируя данные о местоположении и связанную информацию в одной таблице, вспомогательные столбцы могут обеспечить более четкую модель и уменьшить потребность в объединениях. Например, более раннее &lt;a href=&quot;#diquery&quot;&gt;соединение между demo_index и demo_data&lt;/a&gt; теперь можно записать как простой запрос, например:</target>
        </trans-unit>
        <trans-unit id="e37637c9870320bdf8cbf8ef62058290a2f74da5" translate="yes" xml:space="preserve">
          <source>By configuring a callback to be invoked the first time each table is written to that indicates to the session module whether or not changes on the table should be monitored.</source>
          <target state="translated">Настройка обратного вызова при первом вызове каждой таблицы указывает модулю сеанса,следует ли отслеживать изменения на таблице или нет.</target>
        </trans-unit>
        <trans-unit id="06b847c7709546cccdb0e536dbda4965ee6a96e1" translate="yes" xml:space="preserve">
          <source>By contrast, if foreign key errors can be recognized simply by looking at the definition of the child table and without having to consult the parent table definition, then the &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; statement for the child table fails. Because the error occurs during a schema change, this is a DDL error. Foreign key DDL errors are reported regardless of whether or not foreign key constraints are enabled when the table is created.</source>
          <target state="translated">Напротив, если ошибки внешнего ключа можно распознать, просто взглянув на определение дочерней таблицы и не обращаясь к определению родительской таблицы, то оператор &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; для дочерней таблицы завершится ошибкой. Поскольку ошибка возникает во время изменения схемы, это ошибка DDL. Об ошибках DDL внешнего ключа сообщается независимо от того, включены ли ограничения внешнего ключа при создании таблицы.</target>
        </trans-unit>
        <trans-unit id="aedeaa844f352e8e17d5cb589064ea1e4109a539" translate="yes" xml:space="preserve">
          <source>By default a session object does not monitor changes on any database table. Before it does so it must be configured. There are three ways to configure the set of tables to monitor changes on:</source>
          <target state="translated">По умолчанию объект сеанса не отслеживает изменения ни в одной из таблиц БД.Перед этим он должен быть настроен.Есть три способа настроить набор таблиц для мониторинга изменений:</target>
        </trans-unit>
        <trans-unit id="55442bbcc7ceaf84de94fa28a3aed619ae9955e0" translate="yes" xml:space="preserve">
          <source>By default, &quot;unicode61&quot; attempts to remove diacritics from Latin script characters. This behaviour can be overridden by adding the tokenizer argument &quot;remove_diacritics=0&quot;. For example:</source>
          <target state="translated">По умолчанию &quot;unicode61&quot; пытается удалить диакритические знаки из символов латинского алфавита.Это поведение можно переопределить,добавив аргумент токенайзера &quot;remove_diacritics=0&quot;.Например:</target>
        </trans-unit>
        <trans-unit id="7302d3f42259627d0861634979d66a761d287cd5" translate="yes" xml:space="preserve">
          <source>By default, &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt; are considered to be non-deterministic. However, if the 4th parameter to &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function_v2()&lt;/a&gt; is OR-ed with &lt;a href=&quot;c3ref/c_deterministic#sqlitedeterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt;, then SQLite will treat that function as if it were deterministic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be3a7476bfd030e836d226174214b4408b10de5a" translate="yes" xml:space="preserve">
          <source>By default, &lt;a href=&quot;c3ref/create_function&quot;&gt;application-defined SQL functions&lt;/a&gt; are considered to be non-deterministic. However, if the 4th parameter to &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function_v2()&lt;/a&gt; is OR-ed with &lt;a href=&quot;c3ref/c_deterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt;, then SQLite will treat that function as if it were deterministic.</source>
          <target state="translated">По умолчанию, &lt;a href=&quot;c3ref/create_function&quot;&gt;функции SQL, определяемые приложением&lt;/a&gt; , считаются недетерминированными. Однако, если 4-й параметр &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function_v2 () &lt;/a&gt;&lt;a href=&quot;c3ref/c_deterministic&quot;&gt;связан&lt;/a&gt; с SQLITE_DETERMINISTIC по ИЛИ , то SQLite будет обрабатывать эту функцию, как если бы она была детерминированной.</target>
        </trans-unit>
        <trans-unit id="53685ae8370637562174590d6e02187741d1cecd" translate="yes" xml:space="preserve">
          <source>By default, ANALYZE does a full scan of every index. This can be slow for large databases. So beginning with SQLite version 3.32.0 (2020-05-22), the &lt;a href=&quot;pragma#pragma_analysis_limit&quot;&gt;PRAGMA analysis_limit&lt;/a&gt; command can be used to limit the amount of scanning performed by ANALYZE, and thus help ANALYZE to run faster, even on very large database files. We call this running an &quot;approximate ANALYZE&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78cc7d781eb449f29366e3574bdcdf238af76b02" translate="yes" xml:space="preserve">
          <source>By default, FTS queries (those that use the MATCH operator) consider only those rows with the languageid column set to 0. To query for rows with other languageid values, a constraint of the form &quot;</source>
          <target state="translated">По умолчанию FTS-запросы (те,которые используют оператор MATCH)рассматривают только те строки,для которых столбец языка установлен в 0.Для запроса строк с другими значениями языка ограничением является форма &quot;.</target>
        </trans-unit>
        <trans-unit id="a4ce99b6ecd6b9193290236a519a16ace8c29ade" translate="yes" xml:space="preserve">
          <source>By default, FTS3/4 occasionally merges together two or more of the b-trees that make up its full-text index within an INSERT, UPDATE or DELETE statement executed by the user. This means that any operation on an FTS3/4 table may turn out to be surprisingly slow, as FTS3/4 may unpredictably choose to merge together two or more large b-trees within it. FTS5 uses incremental merging by default, which limits the amount of processing that may take place within any given INSERT, UPDATE or DELETE operation.</source>
          <target state="translated">По умолчанию FTS3/4 иногда объединяет два или более b-дерева,составляющих его полнотекстовый индекс,в операторе INSERT,UPDATE или DELETE,выполняемом пользователем.Это означает,что любая операция с таблицей FTS3/4 может оказаться на удивление медленной,поскольку FTS3/4 может непредсказуемо выбрать объединение двух или более больших b-деревьев внутри нее.По умолчанию в FTS5 используется инкрементальное слияние,которое ограничивает объем обработки,которая может происходить в рамках любой заданной операции INSERT,UPDATE или DELETE.</target>
        </trans-unit>
        <trans-unit id="f6e0aaa9f2f3d9d7bf351208161c2a3a5ac7e955" translate="yes" xml:space="preserve">
          <source>By default, FTS5 full-text searches are case-independent. Like any other SQL query that does not contain an ORDER BY clause, the example above returns results in an arbitrary order. To sort results by relevance (most to least relevant), an ORDER BY may be added to a full-text query as follows:</source>
          <target state="translated">По умолчанию полнотекстовый поиск FTS5 является регистронезависимым.Как и любой другой SQL-запрос,не содержащий пункта ORDER BY,приведенный выше пример возвращает результат в произвольном порядке.Для сортировки результатов по релевантности (наиболее-менее релевантным),в полнотекстовый запрос можно добавить пункт ЗАКАЗАТЬ ПОЛУЧАТЕЛЬСТВО следующим образом:</target>
        </trans-unit>
        <trans-unit id="9bae9dce645a20ac5b291708dfb54aa225ce0774" translate="yes" xml:space="preserve">
          <source>By default, FTS5 maintains a single index recording the location of each token instance within the document set. This means that querying for complete tokens is fast, as it requires a single lookup, but querying for a prefix token can be slow, as it requires a range scan. For example, to query for the prefix token &quot;abc*&quot; requires a range scan of all tokens greater than or equal to &quot;abc&quot; and less than &quot;abd&quot;.</source>
          <target state="translated">По умолчанию FTS5 поддерживает единый индекс,записывающий местоположение каждого экземпляра маркера в наборе документов.Это означает,что запрос на полные маркеры выполняется быстро,так как требует одного поиска,но запрос на префиксный маркер может быть медленным,так как требует сканирования диапазона.Например,для запроса префиксного маркера &quot;abc*&quot; требуется сканирование диапазона всех маркеров больше или равно &quot;abc&quot; и меньше &quot;abd&quot;.</target>
        </trans-unit>
        <trans-unit id="ff82a6b03b77139ee1bba47d5624340bd5b1daef" translate="yes" xml:space="preserve">
          <source>By default, SQLite assumes that all data uses a fixed-size 8-bit character (iso8859). But if you give the --enable-utf8 option to the configure script, then the library assumes UTF-8 variable sized characters. This makes a difference for the LIKE and GLOB operators and the LENGTH() and SUBSTR() functions. The static string &lt;b&gt;sqlite_encoding&lt;/b&gt; will be set to either &quot;UTF-8&quot; or &quot;iso8859&quot; to indicate how the library was compiled. In addition, the &lt;b&gt;sqlite.h&lt;/b&gt; header file will define one of the macros &lt;b&gt;SQLITE_UTF8&lt;/b&gt; or &lt;b&gt;SQLITE_ISO8859&lt;/b&gt;, as appropriate.</source>
          <target state="translated">По умолчанию SQLite предполагает, что все данные используют 8-битный символ фиксированного размера (iso8859). Но если вы укажете параметр --enable-utf8 для сценария настройки, тогда библиотека будет использовать символы переменного размера UTF-8. Это имеет значение для операторов LIKE и GLOB и функций LENGTH () и SUBSTR (). Для статической строки &lt;b&gt;sqlite_encoding&lt;/b&gt; будет установлено значение &amp;laquo;UTF-8&amp;raquo; или &amp;laquo;iso8859&amp;raquo;, чтобы указать, как была скомпилирована библиотека. Кроме того, &lt;b&gt;файл&lt;/b&gt; заголовка &lt;b&gt;sqlite.h&lt;/b&gt; будет определять один из макросов &lt;b&gt;SQLITE_UTF8&lt;/b&gt; или &lt;b&gt;SQLITE_ISO8859&lt;/b&gt; , в зависимости от ситуации.</target>
        </trans-unit>
        <trans-unit id="cbc8ea1232230a6d65d66bdbfc39e47fe8c9edc5" translate="yes" xml:space="preserve">
          <source>By default, SQLite assumes that an operating system call to write a range of bytes will not damage or alter any bytes outside of that range even if a power loss or OS crash occurs during that write. We call this the &quot;&lt;a href=&quot;psow&quot;&gt;powersafe overwrite&lt;/a&gt;&quot; property. Prior to &lt;a href=&quot;https://sqlite.org/releaselog/3_7_9.html&quot;&gt;version 3.7.9&lt;/a&gt; (2011-11-01), SQLite did not assume powersafe overwrite. But with the standard sector size increasing from 512 to 4096 bytes on most disk drives, it has become necessary to assume powersafe overwrite in order to maintain historical performance levels and so powersafe overwrite is assumed by default in recent versions of SQLite. The assumption of powersafe overwrite property can be disabled at compile-time or a run-time if desired. See the &lt;a href=&quot;psow&quot;&gt;powersafe overwrite documentation&lt;/a&gt; for further details.</source>
          <target state="translated">По умолчанию SQLite предполагает, что вызов операционной системы для записи диапазона байтов не повредит или не изменит какие-либо байты за пределами этого диапазона, даже если во время этой записи произойдет потеря питания или сбой ОС. Мы называем это &lt;a href=&quot;psow&quot;&gt;свойством &amp;laquo;перезаписи в режиме энергосбережения&lt;/a&gt; &amp;raquo;. До &lt;a href=&quot;https://sqlite.org/releaselog/3_7_9.html&quot;&gt;версии 3.7.9&lt;/a&gt; (2011-11-01) SQLite не предполагал перезапись в режиме энергосбережения. Но при увеличении стандартного размера сектора с 512 до 4096 байт на большинстве дисковых накопителей возникла необходимость предполагать перезапись в режиме энергосбережения, чтобы сохранить исторические уровни производительности, и поэтому в последних версиях SQLite по умолчанию предполагается перезапись в режиме энергосбережения. Допущение о свойствах безопасной перезаписи может быть отключено во время компиляции или выполнения, если необходимо. Дополнительную информацию см. &lt;a href=&quot;psow&quot;&gt;В документации&lt;/a&gt; по перезаписи PowerSafe .</target>
        </trans-unit>
        <trans-unit id="f018eca355fa9ae5d020ba88bd8ea21f258703c5" translate="yes" xml:space="preserve">
          <source>By default, SQLite does a checkpoint automatically when the WAL file reaches a threshold size of 1000 pages. (The &lt;a href=&quot;compile#default_wal_autocheckpoint&quot;&gt;SQLITE_DEFAULT_WAL_AUTOCHECKPOINT&lt;/a&gt; compile-time option can be used to specify a different default.) Applications using WAL do not have to do anything in order to for these checkpoints to occur. But if they want to, applications can adjust the automatic checkpoint threshold. Or they can turn off the automatic checkpoints and run checkpoints during idle moments or in a separate thread or process.</source>
          <target state="translated">По умолчанию SQLite автоматически выполняет контрольную точку, когда файл WAL достигает порогового размера в 1000 страниц. (Параметр &lt;a href=&quot;compile#default_wal_autocheckpoint&quot;&gt;времени&lt;/a&gt; компиляции SQLITE_DEFAULT_WAL_AUTOCHECKPOINT может использоваться для указания другого значения по умолчанию.) Приложения, использующие WAL, не должны ничего делать для того, чтобы эти контрольные точки возникли. Но при желании приложения могут настроить порог автоматической контрольной точки. Или они могут отключить автоматические контрольные точки и запускать контрольные точки в моменты простоя или в отдельном потоке или процессе.</target>
        </trans-unit>
        <trans-unit id="c47d73038962ba3e0484234ad47892e41a6eccb3" translate="yes" xml:space="preserve">
          <source>By default, SQLite keeps statistics on its memory usage. These statistics are useful in helping to determine how much memory an application really needs. The statistics can also be used in high-reliability system to determine if the memory usage is coming close to or exceeding the limits of the &lt;a href=&quot;malloc#nofrag&quot;&gt;Robson proof&lt;/a&gt; and hence that the memory allocation subsystem is liable to breakdown.</source>
          <target state="translated">По умолчанию SQLite ведет статистику использования памяти. Эта статистика помогает определить, сколько памяти действительно необходимо приложению. Статистику также можно использовать в высоконадежной системе, чтобы определить, приближается ли использование памяти к пределам &lt;a href=&quot;malloc#nofrag&quot;&gt;доказательства Робсона&lt;/a&gt; или превышает их, и, следовательно, подсистема распределения памяти подвержена поломке.</target>
        </trans-unit>
        <trans-unit id="45a42d60e1bd3a274255ba5930fab23192de66e7" translate="yes" xml:space="preserve">
          <source>By default, SQLite obtains the memory it needs for objects and cache from the malloc()/free() implementation of the standard library. There is also on-going work with experimental memory allocators that satisfy all memory requests from a single fixed memory buffer handed to SQLite at application start. Additional information on these experimental memory allocators will be provided in a future revision of this document.</source>
          <target state="translated">По умолчанию SQLite получает необходимую ему память для объектов и кэш из реализации malloc()/free()стандартной библиотеки.Также ведутся работы с экспериментальными аллокаторами памяти,которые удовлетворяют все запросы к памяти из одного фиксированного буфера памяти,передаваемого SQLite при запуске приложения.Дополнительная информация об этих экспериментальных аллокаторах памяти будет представлена в последующих редакциях данного документа.</target>
        </trans-unit>
        <trans-unit id="f1f4239650661b10de63616260d0037b2cc6746e" translate="yes" xml:space="preserve">
          <source>By default, SQLite uses the malloc(), realloc(), and free() routines from the standard C library for its memory allocation needs. These routines are surrounded by a thin wrapper that also provides a &quot;memsize()&quot; function that will return the size of an existing allocation. The memsize() function is needed to keep an accurate count of the number of bytes of outstanding memory; memsize() determines how many bytes to remove from the outstanding count when an allocation is freed. The default allocator implements memsize() by always allocating 8 extra bytes on each malloc() request and storing the size of the allocation in that 8-byte header.</source>
          <target state="translated">По умолчанию SQLite для своих потребностей в выделении памяти использует подпрограммы malloc(),realloc()и free()из стандартной библиотеки Си.Эти процедуры окружены тонкой оберткой,которая также предоставляет функцию &quot;memsize()&quot;,которая возвращает размер существующего выделения.Функция memsize()необходима для сохранения точного счета количества байт выдающейся памяти;функция memsize()определяет,сколько байт нужно удалить из выдающегося счета при освобождении выделения.По умолчанию аллокатор реализует функцию memsize(),всегда выделяя 8 лишних байт при каждом запросе malloc()и сохраняя размер выделения в этом 8-байтном заголовке.</target>
        </trans-unit>
        <trans-unit id="ac7bf7e7f400c7dac01c89761055dce039c96113" translate="yes" xml:space="preserve">
          <source>By default, SQLite will automatically checkpoint whenever a &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; occurs that causes the WAL file to be 1000 pages or more in size, or when the last database connection on a database file closes. The default configuration is intended to work well for most applications. But programs that want more control can force a checkpoint using the &lt;a href=&quot;pragma#pragma_wal_checkpoint&quot;&gt;wal_checkpoint pragma&lt;/a&gt; or by calling the &lt;a href=&quot;c3ref/wal_checkpoint&quot;&gt;sqlite3_wal_checkpoint()&lt;/a&gt; C interface. The automatic checkpoint threshold can be changed or automatic checkpointing can be completely disabled using the &lt;a href=&quot;pragma#pragma_wal_autocheckpoint&quot;&gt;wal_autocheckpoint pragma&lt;/a&gt; or by calling the &lt;a href=&quot;c3ref/wal_autocheckpoint&quot;&gt;sqlite3_wal_autocheckpoint()&lt;/a&gt; C interface. A program can also use &lt;a href=&quot;c3ref/wal_hook&quot;&gt;sqlite3_wal_hook()&lt;/a&gt; to register a callback to be invoked whenever any transaction commits to the WAL. This callback can then invoke &lt;a href=&quot;c3ref/wal_checkpoint&quot;&gt;sqlite3_wal_checkpoint()&lt;/a&gt; or &lt;a href=&quot;c3ref/wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2()&lt;/a&gt; based on whatever criteria it thinks is appropriate. (The automatic checkpoint mechanism is implemented as a simple wrapper around &lt;a href=&quot;c3ref/wal_hook&quot;&gt;sqlite3_wal_hook()&lt;/a&gt;.)</source>
          <target state="translated">По умолчанию SQLite будет автоматически проверять точку всякий раз, когда происходит &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; , из-за которого размер файла WAL составляет 1000 страниц или более, или когда закрывается последнее соединение с базой данных для файла базы данных. Конфигурация по умолчанию предназначена для работы в большинстве приложений. Но программы, которым нужен больший контроль, могут принудительно установить контрольную точку, используя &lt;a href=&quot;pragma#pragma_wal_checkpoint&quot;&gt;прагму wal_checkpoint&lt;/a&gt; или вызывая интерфейс C. &lt;a href=&quot;c3ref/wal_checkpoint&quot;&gt;sqlite3_wal_checkpoint ()&lt;/a&gt; . Пороговое значение автоматической контрольной точки можно изменить или автоматическую контрольную точку можно полностью отключить с помощью &lt;a href=&quot;pragma#pragma_wal_autocheckpoint&quot;&gt;прагмы wal_autocheckpoint&lt;/a&gt; или путем вызова интерфейса C. &lt;a href=&quot;c3ref/wal_autocheckpoint&quot;&gt;sqlite3_wal_autocheckpoint ()&lt;/a&gt; . Программа также может использовать &lt;a href=&quot;c3ref/wal_hook&quot;&gt;sqlite3_wal_hook ()&lt;/a&gt;чтобы зарегистрировать обратный вызов, который будет вызываться всякий раз, когда какая-либо транзакция фиксируется в WAL. Затем этот обратный вызов может вызывать &lt;a href=&quot;c3ref/wal_checkpoint&quot;&gt;sqlite3_wal_checkpoint ()&lt;/a&gt; или &lt;a href=&quot;c3ref/wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2 ()&lt;/a&gt; на основе тех критериев, которые он считает подходящими. (Механизм автоматической контрольной точки реализован как простая оболочка вокруг &lt;a href=&quot;c3ref/wal_hook&quot;&gt;sqlite3_wal_hook ()&lt;/a&gt; .)</target>
        </trans-unit>
        <trans-unit id="dfe31588b0add6c729f8eab371bfea7925cb6297" translate="yes" xml:space="preserve">
          <source>By default, VACUUM only works only on the main database. &lt;a href=&quot;lang_attach&quot;&gt;Attached databases&lt;/a&gt; can be vacuumed by appending the appropriate schema-name to the VACUUM statement.</source>
          <target state="translated">По умолчанию VACUUM работает только с основной базой данных. &lt;a href=&quot;lang_attach&quot;&gt;Подключенные базы данных&lt;/a&gt; можно очистить, добавив соответствующее имя схемы в оператор VACUUM.</target>
        </trans-unit>
        <trans-unit id="609f717a6d90d2816632d1db2908a5d9109c172f" translate="yes" xml:space="preserve">
          <source>By default, coordinates are stored in an R*Tree using 32-bit floating point values. When a coordinate cannot be exactly represented by a 32-bit floating point number, the lower-bound coordinates are rounded down and the upper-bound coordinates are rounded up. Thus, bounding boxes might be slightly larger than specified, but will never be any smaller. This is exactly what is desired for doing the more common &quot;overlapping&quot; queries where the application wants to find every entry in the R*Tree that overlaps a query bounding box. Rounding the entry bounding boxes outward might cause a few extra entries to appears in an overlapping query if the edge of the entry bounding box corresponds to an edge of the query bounding box. But the overlapping query will never miss a valid table entry.</source>
          <target state="translated">По умолчанию координаты хранятся в R*дереве с использованием 32-битных значений с плавающей точкой.Когда координата не может быть точно представлена 32-битным числом с плавающей точкой,нижние координаты округляются вниз,а верхние-вверх.Таким образом,граничные поля могут быть немного больше,чем указано,но никогда не будут меньше.Это именно то,что нужно для выполнения более распространенных &quot;перекрывающихся&quot; запросов,где приложение хочет найти каждую запись в R*дереве,перекрывающую ограничивающее поле запроса.Округление ограничивающих полей для записей наружу может привести к появлению нескольких дополнительных записей в перекрывающемся запросе,если граница ограничивающего полей для записей соответствует границе ограничивающего полей для записей.Но перекрывающийся запрос никогда не пропустит действительную запись таблицы.</target>
        </trans-unit>
        <trans-unit id="199efd35071a0aa576610e8f4fe7005becc87773" translate="yes" xml:space="preserve">
          <source>By default, diacritics are removed from all Latin script characters. This means, for example, that &quot;A&quot;, &quot;a&quot;, &quot;&amp;Agrave;&quot;, &quot;&amp;agrave;&quot;, &quot;&amp;Acirc;&quot; and &quot;&amp;acirc;&quot; are all considered to be equivalent.</source>
          <target state="translated">По умолчанию диакритические знаки удаляются со всех символов латинского алфавита. Это означает, например, что &amp;laquo;A&amp;raquo;, &amp;laquo;a&amp;raquo;, &amp;laquo;&amp;Agrave;&amp;raquo;, &amp;laquo;&amp;agrave;&amp;raquo;, &amp;laquo;&amp;Acirc;&amp;raquo; и &amp;laquo;&amp;acirc;&amp;raquo; считаются эквивалентными.</target>
        </trans-unit>
        <trans-unit id="bb034dd2f0250c21e84e164917272d1dc5842d40" translate="yes" xml:space="preserve">
          <source>By default, differences in the schema or content of virtual tables are not reported on.</source>
          <target state="translated">По умолчанию различия в схеме или содержимом виртуальных таблиц не сообщаются.</target>
        </trans-unit>
        <trans-unit id="b77f26d39d106302cf0e476c578f7ebf5e3ef7c7" translate="yes" xml:space="preserve">
          <source>By default, each INSERT statement is its own transaction. But if you surround multiple INSERT statements with &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt;...&lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; then all the inserts are grouped into a single transaction. The time needed to commit the transaction is amortized over all the enclosed insert statements and so the time per insert statement is greatly reduced.</source>
          <target state="translated">По умолчанию каждая инструкция INSERT является отдельной транзакцией. Но если вы заключите несколько операторов INSERT в окружение &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt; ... &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT,&lt;/a&gt; тогда все вставки будут сгруппированы в одну транзакцию. Время, необходимое для фиксации транзакции, амортизируется по всем вложенным операторам вставки, поэтому время на выполнение оператора вставки значительно сокращается.</target>
        </trans-unit>
        <trans-unit id="6a7a241c9fa980ec6fabd179e76034fe7898c1e2" translate="yes" xml:space="preserve">
          <source>By default, each column is between 1 and 10 characters wide, depending on the column header name and the width of the first column of data. Data that is too wide to fit in a column is truncated. Use the &quot;.width&quot; dot-command to adjust column widths, like this:</source>
          <target state="translated">По умолчанию каждый столбец имеет ширину от 1 до 10 символов,в зависимости от названия заголовка столбца и ширины первого столбца данных.Данные,которые слишком широки,чтобы поместиться в столбец,усекаются.Используйте точечную команду &quot;.width&quot; для регулировки ширины столбцов:</target>
        </trans-unit>
        <trans-unit id="5e4318cdb175f91c3caf7375a2080f232459374d" translate="yes" xml:space="preserve">
          <source>By default, every row in SQLite has a special column, usually called the &quot;&lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;&quot;, that uniquely identifies that row within the table. However if the phrase &quot;WITHOUT ROWID&quot; is added to the end of a &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; statement, then the special &quot;rowid&quot; column is omitted. There are sometimes space and performance advantages to omitting the rowid.</source>
          <target state="translated">По умолчанию каждая строка в SQLite имеет специальный столбец, обычно называемый &amp;laquo; &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; &amp;raquo;, который однозначно идентифицирует эту строку в таблице. Однако, если в конце оператора &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; добавить фразу &amp;laquo;WITHOUT ROWID&amp;raquo; , специальный столбец &amp;laquo;rowid&amp;raquo; опускается. Иногда отсутствие rowid дает преимущества в размере и производительности.</target>
        </trans-unit>
        <trans-unit id="d6ef17af0abc70adef74ccbccb6e7ada9c1f618f" translate="yes" xml:space="preserve">
          <source>By default, kvtest runs the database I/O measurements all within a single transaction. Use the --multitrans option to run each blob read or write in a separate transaction. The --multitrans option makes SQLite much slower, and uncompetitive with direct disk I/O. This option proves, yet again, that to get the most performance out of SQLite, you should group as much database interaction as possible within a single transaction.</source>
          <target state="translated">По умолчанию kvtest выполняет измерения входов/выходов из базы данных в рамках одной транзакции.Используйте опцию --multitrans для запуска каждого блока для чтения или записи в отдельной транзакции.Опция --multitrans делает SQLite намного медленнее и неконкурентоспособнее с прямым дисковым вводом/выводом.Эта опция еще раз доказывает,что для получения максимальной производительности от SQLite необходимо сгруппировать как можно больше взаимодействия с БД в рамках одной транзакции.</target>
        </trans-unit>
        <trans-unit id="a027e685d0b82e63c37ab615c6c8b1bef894cf6d" translate="yes" xml:space="preserve">
          <source>By default, sqldiff attempts to process all non-virtual tables within the two databases provided to it. If any table appears in one database but not the other, or if any table has a slightly different schema in one database it is an error. The &quot;--table&quot; option may be useful if this causes a problem</source>
          <target state="translated">По умолчанию sqldiff пытается обрабатывать все невиртуальные таблицы в двух предоставленных ему базах данных.Если какая-либо таблица появляется в одной базе данных,но не в другой,или если какая-либо таблица имеет несколько иную схему в одной базе данных,это является ошибкой.Опция &quot;--table&quot; может быть полезна,если это приводит к проблеме.</target>
        </trans-unit>
        <trans-unit id="46b22419bd1a4fd00ad28b08bf067b6f9f4f5e90" translate="yes" xml:space="preserve">
          <source>By default, sqlite3 sends query results to standard output. You can change this using the &quot;.output&quot; and &quot;.once&quot; commands. Just put the name of an output file as an argument to .output and all subsequent query results will be written to that file. Or use the .once command instead of .output and output will only be redirected for the single next command before reverting to the console. Use .output with no arguments to begin writing to standard output again. For example:</source>
          <target state="translated">По умолчанию sqlite3 отправляет результаты запроса в стандартный вывод.Вы можете изменить это с помощью команд &quot;.output&quot; и &quot;.once&quot;.Просто поместите имя выходного файла в качестве аргумента в .output и все последующие результаты запроса будут записаны в этот файл.Или используйте команду .once вместо .output,и результаты будут перенаправлены только на одну следующую команду перед возвращением в консоль.Используйте .output без аргументов,чтобы снова начать запись в стандартный вывод.Например:</target>
        </trans-unit>
        <trans-unit id="e508a45fb514da22df2b29ba2714c0232eb3c718" translate="yes" xml:space="preserve">
          <source>By default, swarmvtab attempts to limit the number of simultaneously open databases to nine. This parameter allows that limit to be changed. For example, to create a swarmvtab table that may hold up to 30 databases open simultaneously:</source>
          <target state="translated">По умолчанию swarmvtab пытается ограничить количество одновременно открытых баз данных девятью.Данный параметр позволяет изменять это ограничение.Например,создать таблицу swarmvtab,которая может содержать до 30 одновременно открытых БД:</target>
        </trans-unit>
        <trans-unit id="aac34cb1103bf35fa437aa535e48e93e51a7d344" translate="yes" xml:space="preserve">
          <source>By default, the &quot;.expert&quot; command recommends indexes based on the query and database schema alone. This is similar to the way the &lt;a href=&quot;optoverview&quot;&gt;SQLite query planner&lt;/a&gt; selects indexes for queries if the user has not run the &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; command on the database to generate data distribution statistics.</source>
          <target state="translated">По умолчанию команда &amp;laquo;.expert&amp;raquo; рекомендует индексы только на основе запроса и схемы базы данных. Это похоже на то, как &lt;a href=&quot;optoverview&quot;&gt;планировщик запросов SQLite&lt;/a&gt; выбирает индексы для запросов, если пользователь не &lt;a href=&quot;lang_analyze&quot;&gt;выполнил&lt;/a&gt; команду ANALYZE в базе данных для генерации статистики распределения данных.</target>
        </trans-unit>
        <trans-unit id="79e59781472aaf1cab549c7756351e991a52f37c" translate="yes" xml:space="preserve">
          <source>By default, the &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; interface will automatically invoke &lt;a href=&quot;c3ref/reset&quot;&gt;sqlite3_reset()&lt;/a&gt; to reset the &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; if necessary. This compile-time option changes that behavior so that &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; will return &lt;a href=&quot;rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt; if it called again after returning anything other than &lt;a href=&quot;rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt;, &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;, or &lt;a href=&quot;rescode#locked&quot;&gt;SQLITE_LOCKED&lt;/a&gt; unless there was an intervening call to &lt;a href=&quot;c3ref/reset&quot;&gt;sqlite3_reset()&lt;/a&gt;.</source>
          <target state="translated">По умолчанию интерфейс &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step ()&lt;/a&gt; автоматически вызывает &lt;a href=&quot;c3ref/reset&quot;&gt;sqlite3_reset ()&lt;/a&gt; для сброса &lt;a href=&quot;c3ref/stmt&quot;&gt;подготовленного оператора,&lt;/a&gt; если это необходимо. Эта опция времени компиляции изменяет это поведение, так что &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step ()&lt;/a&gt; будет возвращать &lt;a href=&quot;rescode#misuse&quot;&gt;SQLITE_MISUSE,&lt;/a&gt; если он вызывается снова после возврата чего-либо, кроме &lt;a href=&quot;rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt; , &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; или &lt;a href=&quot;rescode#locked&quot;&gt;SQLITE_LOCKED,&lt;/a&gt; если не было промежуточного вызова &lt;a href=&quot;c3ref/reset&quot;&gt;sqlite3_reset ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b8f030cbd6427054daf45dea55ca6b9a3924a3dd" translate="yes" xml:space="preserve">
          <source>By default, the SQLite core double checks all constraints on each row of the virtual table that it receives. If such a check is redundant, the xBestFilter method can suppress that double-check by setting aConstraintUsage[].omit.</source>
          <target state="translated">По умолчанию ядро SQLite дважды проверяет все ограничения на каждую строку получаемой виртуальной таблицы.Если такая проверка избыточна,метод xBestFilter может подавить эту перепроверку,установив aConstraintUsage[].omit.</target>
        </trans-unit>
        <trans-unit id="fa0f172004db89e74c2b903c6ed15681a8554ce0" translate="yes" xml:space="preserve">
          <source>By default, the output of EXPLAIN QUERY PLAN commands does not include output for any operations performed by trigger programs. This option is used to set or clear (the default) a flag that governs this behavior. The first parameter passed to this operation is an integer - positive to enable output for trigger programs, or zero to disable it, or negative to leave the setting unchanged. The second parameter is a pointer to an integer into which is written 0 or 1 to indicate whether output-for-triggers has been disabled - 0 if it is not disabled, 1 if it is.</source>
          <target state="translated">По умолчанию вывод команд EXPLAIN QUERY PLAN не включает вывод для любых операций,выполняемых триггерными программами.Эта опция используется для установки или снятия (по умолчанию)флага,управляющего таким поведением.Первый параметр,передаваемый для этой операции-целое число-положительное,чтобы разрешить вывод для триггерных программ,или нулевое,чтобы отключить его,или отрицательное,чтобы оставить установку без изменений.Второй параметр-указатель на целое число,в которое записано 0 или 1,чтобы указать,был ли отключен вывод для триггеров-0,если не отключен,1,если отключен.</target>
        </trans-unit>
        <trans-unit id="d45ac6e349cce0d243d17d663e9e87155d75add6" translate="yes" xml:space="preserve">
          <source>By default, the porter tokenizer operates as a wrapper around the default tokenizer (unicode61). Or, if one or more extra arguments are added to the &quot;tokenize&quot; option following &quot;porter&quot;, they are treated as a specification for the underlying tokenizer that the porter stemmer uses. For example:</source>
          <target state="translated">По умолчанию токенайзер портатора работает как обёртка вокруг токенайзера по умолчанию (юникод61).Или,если один или несколько дополнительных аргументов добавлены в опцию &quot;tokenize&quot;,следующую за &quot;porter&quot;,они рассматриваются как спецификация базового токенайзера,который использует стволовой преобразователь порта.Например:</target>
        </trans-unit>
        <trans-unit id="923e8b64eceb6502080849392eadafdbb5ce98eb" translate="yes" xml:space="preserve">
          <source>By default, the sessions module streaming interfaces attempt to input and output data in approximately 1 KiB chunks. This operand may be used to set and query the value of this configuration setting. The pointer passed as the second argument must point to a value of type (int). If this value is greater than 0, it is used as the new streaming data chunk size for both input and output. Before returning, the (int) value pointed to by pArg is set to the final value of the streaming interface chunk size.</source>
          <target state="translated">По умолчанию интерфейсы потокового сеанса модуля сессий пытаются вводить и выводить данные примерно в 1 KiB блоке.Этот операнд может быть использован для установки и запроса значения этой конфигурационной установки.Указатель,переданный в качестве второго аргумента,должен указывать на значение типа (int).Если это значение больше 0,то оно используется в качестве размера нового потока данных как для входных,так и для выходных данных.Перед возвращением,значение (int),на которое указывает pArg,устанавливается в конечное значение размера чанка стримингового интерфейса.</target>
        </trans-unit>
        <trans-unit id="ed67e473742eb7c111c47a0cfdbbdb68f21a394b" translate="yes" xml:space="preserve">
          <source>By default, the shell is now in &quot;auto-explain&quot; mode. The output of &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt; commands is automatically formatted.</source>
          <target state="translated">По умолчанию оболочка теперь находится в режиме &amp;laquo;авто-объяснения&amp;raquo;. Вывод команд &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt; форматируется автоматически.</target>
        </trans-unit>
        <trans-unit id="52d930b9eee7711ba25f4fd9b5cbc893a2bf348f" translate="yes" xml:space="preserve">
          <source>By default, the spellfix1 table returns no more than 20 results. (It might return less than 20 if there were fewer good matches.) You can change the upper bound on the number of returned rows by adding a &quot;top=N&quot; term to the WHERE clause of your query, where N is the new maximum. For example, to see the 5 best matches:</source>
          <target state="translated">По умолчанию таблица spellfix1 возвращает не более 20 результатов.(Она может возвращать меньше 20,если было меньше хороших совпадений.)Вы можете изменить верхнюю границу на количество возвращаемых строк,добавив в выражение WHERE вашего запроса термин &quot;top=N&quot;,где N-новый максимум.Например,чтобы увидеть 5 лучших совпадений:</target>
        </trans-unit>
        <trans-unit id="801f0fef23ca30c740bc98f388b5820b01c0a8aa" translate="yes" xml:space="preserve">
          <source>By default, there is a single row in the DBSTAT table for each btree page the database file. Each row provides information about the space utilization of that one page of the database. However, if the hidden column &quot;aggregate&quot; is TRUE, then results are aggregated and there is a single row in the DBSTAT table for each btree in the database, providing information about space utilization across the entire btree.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa387565dd5968c7d1760a2e2262809354a9a035" translate="yes" xml:space="preserve">
          <source>By enclosing it in double quotes (&quot;). Within a string, any embedded double quote characters may be escaped SQL-style - by adding a second double-quote character.</source>
          <target state="translated">Заключив его в двойные кавычки (&quot;).Внутри строки любые встроенные символы двойных кавычек могут быть экранированы в SQL-стиле-путем добавления второго символа двойных кавычек.</target>
        </trans-unit>
        <trans-unit id="84617083eaab12542d0a6d482dc6332adeedf772" translate="yes" xml:space="preserve">
          <source>By explicitly specifying tables using one call to &lt;a href=&quot;session/sqlite3session_attach&quot;&gt;sqlite3session_attach()&lt;/a&gt; for each table, or</source>
          <target state="translated">Путем явного указания таблиц с помощью одного вызова &lt;a href=&quot;session/sqlite3session_attach&quot;&gt;sqlite3session_attach ()&lt;/a&gt; для каждой таблицы или</target>
        </trans-unit>
        <trans-unit id="7ec7970e0cfef9d2d98bfdb89f93e1b8b4b4b117" translate="yes" xml:space="preserve">
          <source>By invoking the xCheckReservedLock() method of the file-handle opened on the database file, SQLite checks if some other connection holds a</source>
          <target state="translated">При вызове метода xCheckReservedLock()файла-ручки,открытого в файле базы данных,SQLite проверяет,не содержит ли какое-либо другое соединение</target>
        </trans-unit>
        <trans-unit id="e392907538e008d1f980f80b5391101815ed2a70" translate="yes" xml:space="preserve">
          <source>By mapping all synonyms to a single token. In this case, the In the above example, this means that the tokenizer returns the same token for inputs &quot;first&quot; and &quot;1st&quot;. Say that token is in fact &quot;first&quot;, so that when the user inserts the document &quot;I won 1st place&quot; entries are added to the index for tokens &quot;i&quot;, &quot;won&quot;, &quot;first&quot; and &quot;place&quot;. If the user then queries for '1st + place', the tokenizer substitutes &quot;first&quot; for &quot;1st&quot; and the query works as expected.</source>
          <target state="translated">Соединив все синонимы в один маркер.В данном случае в приведенном выше примере это означает,что токенайзер возвращает один и тот же токен для входов &quot;первый&quot; и &quot;первый&quot;.Скажем,что токен на самом деле &quot;первый&quot;,так что когда пользователь вставляет документ &quot;Я выиграл 1-е место&quot;,записи добавляются в индекс для токенов &quot;i&quot;,&quot;выиграл&quot;,&quot;первый&quot; и &quot;место&quot;.Если после этого пользователь запрашивает &quot;1+местье&quot;,то токенщик подставляет &quot;первый&quot; на &quot;1-е&quot; и запрос работает,как и ожидалось.</target>
        </trans-unit>
        <trans-unit id="d6c6c3e21f2551827a19fdcc87eccf2596523e84" translate="yes" xml:space="preserve">
          <source>By mapping all synonyms to a single token. In this case, using the above example, this means that the tokenizer returns the same token for inputs &quot;first&quot; and &quot;1st&quot;. Say that token is in fact &quot;first&quot;, so that when the user inserts the document &quot;I won 1st place&quot; entries are added to the index for tokens &quot;i&quot;, &quot;won&quot;, &quot;first&quot; and &quot;place&quot;. If the user then queries for '1st + place', the tokenizer substitutes &quot;first&quot; for &quot;1st&quot; and the query works as expected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f19cb00f7026582f508ec895d006b5124a9aeb30" translate="yes" xml:space="preserve">
          <source>By querying the index for all synonyms of each query term separately. In this case, when tokenizing query text, the tokenizer may provide multiple synonyms for a single term within the document. FTS5 then queries the index for each synonym individually. For example, faced with the query:</source>
          <target state="translated">Запросом индекса для всех синонимов каждого члена запроса в отдельности.В этом случае при токенировании текста запроса маркер может предоставить несколько синонимов для одного термина внутри документа.Затем FTS5 запрашивает индекс для каждого синонима отдельно.Например,столкнувшись с запросом:</target>
        </trans-unit>
        <trans-unit id="55b05786af4043a1be86d71e95ee1411780e7ee4" translate="yes" xml:space="preserve">
          <source>By setting it to an empty string to create a contentless FTS5 table. In this case FTS5 assumes that the original column values are unavailable to it when processing queries. Full-text queries and some auxiliary functions can still be used, but no column values apart from the rowid may be read from the table.</source>
          <target state="translated">Устанавливая его в пустую строку для создания полноценной таблицы FTS5.В этом случае FTS5 предполагает,что исходные значения столбцов недоступны ему при обработке запросов.Полнотекстовые запросы и некоторые вспомогательные функции все еще могут быть использованы,но значения столбцов,кроме rowid,не могут быть прочитаны из таблицы.</target>
        </trans-unit>
        <trans-unit id="61a66a14e7dcfe0861d93ec30802747dfb7523a1" translate="yes" xml:space="preserve">
          <source>By setting it to the name of a database object (table, virtual table or view) that may be queried by FTS5 at any time to retrieve the column values. This is known as an &quot;external content&quot; table. In this case all FTS5 functionality may be used, but it is the responsibility of the user to ensure that the contents of the full-text index are consistent with the named database object. If they are not, query results may be unpredictable.</source>
          <target state="translated">Устанавливая его в качестве имени объекта БД (таблицы,виртуальной таблицы или представления),который может быть запрошен FTS5 в любой момент времени для получения значений столбцов.Это называется таблицей &quot;внешнего содержимого&quot;.В этом случае может быть использован весь функционал FTS5,однако ответственность за соответствие содержимого полнотекстового индекса названному объекту базы данных лежит на пользователе.В противном случае результаты запроса могут быть непредсказуемыми.</target>
        </trans-unit>
        <trans-unit id="b65e88a6a0b747d6c1e54c4edd9925d09b470f08" translate="yes" xml:space="preserve">
          <source>By specifying that all tables in the database should be monitored for changes using a call to &lt;a href=&quot;session/sqlite3session_attach&quot;&gt;sqlite3session_attach()&lt;/a&gt; with a NULL argument, or</source>
          <target state="translated">Указав, что все таблицы в базе данных должны отслеживаться на предмет изменений с помощью вызова &lt;a href=&quot;session/sqlite3session_attach&quot;&gt;sqlite3session_attach ()&lt;/a&gt; с аргументом NULL, или</target>
        </trans-unit>
        <trans-unit id="63f834f4a2da63acc54bc935f1fd1ad5ded1c97a" translate="yes" xml:space="preserve">
          <source>By the time &lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify()&lt;/a&gt; is invoked by wait_for_unlock_notify(), it is possible that the blocking connection that prevented the sqlite3_step() or sqlite3_prepare_v2() call from succeeding has already finished its transaction. In this case, the unlock-notify callback is invoked immediately, before &lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify()&lt;/a&gt; returns. Or, it is possible that the unlock-notify callback is invoked by a second thread after &lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify()&lt;/a&gt; is called but before the thread starts waiting to be asynchronously signaled.</source>
          <target state="translated">К тому времени, когда &lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify ()&lt;/a&gt; вызывается функцией wait_for_unlock_notify (), возможно, что блокирующее соединение, которое помешало выполнению вызова sqlite3_step () или sqlite3_prepare_v2 (), уже завершило свою транзакцию. В этом случае обратный вызов unlock-notify вызывается немедленно, прежде чем &lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify ()&lt;/a&gt; вернется. Или возможно, что обратный вызов unlock-notify вызывается вторым потоком после вызова &lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify (),&lt;/a&gt; но до того, как поток начнет ждать асинхронного сигнала.</target>
        </trans-unit>
        <trans-unit id="294016815718412ee0c20270b6745c8ced5712e1" translate="yes" xml:space="preserve">
          <source>By using its own built-in implementation, SQLite guarantees that the output will be the same on all platforms and in all LOCALEs. This is important for consistency and for testing. It would be problematic if one machine gave and answer of &quot;5.25e+08&quot; and another gave an answer of &quot;5.250e+008&quot;. Both answers are correct, but it is better when SQLite always gives the same answer.</source>
          <target state="translated">Используя собственную встроенную реализацию,SQLite гарантирует,что вывод будет одинаковым на всех платформах и во всех МЕСТах.Это важно для согласованности и для тестирования.Было бы проблематично,если бы одна машина дала и ответил &quot;5.25e+08&quot;,а другая дала ответ &quot;5.250e+008&quot;.Оба ответа верны,но лучше,когда SQLite всегда дает один и тот же ответ.</target>
        </trans-unit>
        <trans-unit id="478bcd9433faa7931ee1c7c1b62ccda2a8f4f8e8" translate="yes" xml:space="preserve">
          <source>By using standard SQL expressions in the WHERE clause of a SELECT query, a programmer can query for all R*Tree entries that intersect with or are contained within a particular bounding-box. Custom R*Tree queries, using the MATCH operator in the WHERE clause of a SELECT, allow the programmer to query for the set of R*Tree entries that intersect any arbitrary region or shape, not just a box. This capability is useful, for example, in computing the subset of objects in the R*Tree that are visible from a camera positioned in 3-D space.</source>
          <target state="translated">Используя стандартные выражения SQL в выражении WHERE в SELECT-запросе,программист может запросить все записи R*Tree,которые пересекаются с определенным граничным полем или содержатся в нем.Пользовательские запросы R*Tree,используя оператор MATCH в пункте WHERE в SELECT,позволяют запросить набор R*Tree записей,которые пересекаются с любой произвольной областью или формой,а не только с ящиком.Эта возможность полезна,например,при вычислении подмножества объектов в R*дереве,которые видны с камеры,расположенной в трехмерном пространстве.</target>
        </trans-unit>
        <trans-unit id="89a11056dc1624db725c970738aa5aaf2b86e420" translate="yes" xml:space="preserve">
          <source>Byte offset</source>
          <target state="translated">смещение байтов</target>
        </trans-unit>
        <trans-unit id="3552062ee633a28da0a78f6b8da0963926758e2e" translate="yes" xml:space="preserve">
          <source>Byte offset to the start of the page</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40c37d34180ee81abeec6396f466a7bf1d1f2f45" translate="yes" xml:space="preserve">
          <source>Bytecode Engine</source>
          <target state="translated">Двигатель байткода</target>
        </trans-unit>
        <trans-unit id="e7d87e87cd071442d28d7e11c0a34595a73b4b95" translate="yes" xml:space="preserve">
          <source>Bytecode and tables_used are &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt; built into SQLite that access information about &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statements&lt;/a&gt;. Both bytecode and tables_used operate as &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued functions&lt;/a&gt;. They take a single required argument which is either the text of an SQL statement, or a pointer to an existing prepared statement. The bytecode function returns one row of result for each &lt;a href=&quot;opcode&quot;&gt;bytecode&lt;/a&gt; operation in the prepared statement. The tables_used function returns one row for each persistent btree (either a table or an index) accessed by the prepared statement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e5fdab92dece79d7629d6d901687613ddc6ab5a" translate="yes" xml:space="preserve">
          <source>Bytes</source>
          <target state="translated">Bytes</target>
        </trans-unit>
        <trans-unit id="6e99d2b1b3cf05d1cb901ea3f769e34d773ba90a" translate="yes" xml:space="preserve">
          <source>Bytes 12-15 of the</source>
          <target state="translated">Байты 12-15</target>
        </trans-unit>
        <trans-unit id="89a9bc1f87191389726b0ed1804032da963a975c" translate="yes" xml:space="preserve">
          <source>Bytes 16-19 of the</source>
          <target state="translated">Байты 16-19</target>
        </trans-unit>
        <trans-unit id="24778eba404891c29eb268fa4b3c469a05e3f5af" translate="yes" xml:space="preserve">
          <source>Bytes 20-23 of the</source>
          <target state="translated">Байты 20-23</target>
        </trans-unit>
        <trans-unit id="5e820fc3c84f6f51bd1f6afe4e8dd983524446cf" translate="yes" xml:space="preserve">
          <source>Bytes 24-27 of the</source>
          <target state="translated">Байты 24-27</target>
        </trans-unit>
        <trans-unit id="eb167d60299b524eb07991d2141957c03c9ee5cd" translate="yes" xml:space="preserve">
          <source>Bytes 8-11 of the</source>
          <target state="translated">Байты 8-11</target>
        </trans-unit>
        <trans-unit id="a3587157a4089ec8301b2d0f784b91a32e9749e3" translate="yes" xml:space="preserve">
          <source>Bytes of unused &quot;reserved&quot; space at the end of each page. Usually 0.</source>
          <target state="translated">Байты неиспользованного &quot;зарезервированного&quot; места в конце каждой страницы.Обычно 0.</target>
        </trans-unit>
        <trans-unit id="99c76b931cbafaf267cc3e2ad6a25e46605efcf6" translate="yes" xml:space="preserve">
          <source>Bytes of useful payload on the current page or btree</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32096c2e0eff33d844ee6d675407ace18289357d" translate="yes" xml:space="preserve">
          <source>C</source>
          <target state="translated">C</target>
        </trans-unit>
        <trans-unit id="4f3cd44d015b24e6fbf168b36aa5120966aaf5ed" translate="yes" xml:space="preserve">
          <source>C API Requirements Document.</source>
          <target state="translated">Документ с требованиями C API.</target>
        </trans-unit>
        <trans-unit id="e9a1acddb6f4bd40edd805612e996267e826e064" translate="yes" xml:space="preserve">
          <source>C Interface</source>
          <target state="translated">C-интерфейс</target>
        </trans-unit>
        <trans-unit id="d5efbb98716c6e33e7f3412795c630f8a8a66abd" translate="yes" xml:space="preserve">
          <source>C Interface: Session Module</source>
          <target state="translated">Интерфейс C:Сеансовый модуль</target>
        </trans-unit>
        <trans-unit id="444516d338383f2d17d8f93aa996b6cd1762c79a" translate="yes" xml:space="preserve">
          <source>C is a great language for writing fast code. C is sometimes described as &quot;portable assembly language&quot;. It enables to developers to code as close to the underlying hardware as possible while still remaining portable across platforms.</source>
          <target state="translated">C-отличный язык для написания быстрого кода.C иногда называют &quot;портативным языком ассемблера&quot;.Он позволяет разработчикам кодировать как можно ближе к основному оборудованию,оставаясь переносимым между платформами.</target>
        </trans-unit>
        <trans-unit id="58790293552f75d17353d3ee29e85a197a62dcbb" translate="yes" xml:space="preserve">
          <source>C-language Interface Specification for SQLite</source>
          <target state="translated">Спецификация интерфейса на языке C для SQLite</target>
        </trans-unit>
        <trans-unit id="1ac091b19baa70bc10c3d1156fe018d4a8f6ef6b" translate="yes" xml:space="preserve">
          <source>C-style comments are now accepted by the tokenizer.</source>
          <target state="translated">Комментарии в стиле C теперь принимаются токенайзером.</target>
        </trans-unit>
        <trans-unit id="d4948b1f21c9b5ee92aa9e005ab2ec94317e417f" translate="yes" xml:space="preserve">
          <source>C-style comments begin with &quot;/*&quot; and extend up to and including the next &quot;*/&quot; character pair or until the end of input, whichever comes first. C-style comments can span multiple lines.</source>
          <target state="translated">Комментарии в стиле C начинаются с &quot;/*&quot; и продолжаются до следующей пары символов &quot;*/&quot; или до конца ввода,в зависимости от того,что наступит раньше.Комментарии в стиле C могут охватывать несколько строк.</target>
        </trans-unit>
        <trans-unit id="e693971cd8c5db36eaa639a8f7f4320b5c7557fd" translate="yes" xml:space="preserve">
          <source>C/C++ Interface For SQLite Version 3</source>
          <target state="translated">C/C++интерфейс для SQLite версии 3</target>
        </trans-unit>
        <trans-unit id="b7c9ebb838da580ee5ce0a6b6d3fb9492aadd0cf" translate="yes" xml:space="preserve">
          <source>C/C++ Interface For SQLite Version 3 (old)</source>
          <target state="translated">C/C++интерфейс для SQLite версии 3 (старый)</target>
        </trans-unit>
        <trans-unit id="629369eadf6dbb7e5f1900a3d284a7d0ebdf8449" translate="yes" xml:space="preserve">
          <source>CASCADE</source>
          <target state="translated">CASCADE</target>
        </trans-unit>
        <trans-unit id="55c417bda058d7601349aeb7556e3d8607c77f5d" translate="yes" xml:space="preserve">
          <source>CASE</source>
          <target state="translated">CASE</target>
        </trans-unit>
        <trans-unit id="24e95e83710f86d66debac57b5addb22a9ce7983" translate="yes" xml:space="preserve">
          <source>CASE WHEN x=w1 THEN r1 WHEN x=w2 THEN r2 ELSE r3 END</source>
          <target state="translated">КОГДА КОГДА x=w1 THEN r1 КОГДА x=w2 THEN r2 ELSE r3 END</target>
        </trans-unit>
        <trans-unit id="fcb688501c6a701cda488771d9ab7d2ba8fccbb2" translate="yes" xml:space="preserve">
          <source>CASE expression</source>
          <target state="translated">выражение CASE</target>
        </trans-unit>
        <trans-unit id="c688feeff7f51b86a16bfff0e478b5a113fd0c4a" translate="yes" xml:space="preserve">
          <source>CASE x WHEN w1 THEN r1 WHEN w2 THEN r2 ELSE r3 END</source>
          <target state="translated">CASE x WHEN w1 THEN r1 WHEN w2 THEN r2 ELSE r3 END</target>
        </trans-unit>
        <trans-unit id="274ad8f8387ab7001d3681011456578f35fd9e46" translate="yes" xml:space="preserve">
          <source>CAST</source>
          <target state="translated">CAST</target>
        </trans-unit>
        <trans-unit id="bc9630c4f8bc64a9ad87f06d690b75d5f8954d78" translate="yes" xml:space="preserve">
          <source>CAST expressions</source>
          <target state="translated">выражения CAST</target>
        </trans-unit>
        <trans-unit id="2bab9f8d26cc3165f0ac936b287a5e9381a51aad" translate="yes" xml:space="preserve">
          <source>CAST operator</source>
          <target state="translated">оператор CAST</target>
        </trans-unit>
        <trans-unit id="57c58f87e406bfa72b5233a68e16e6ce57b58a9a" translate="yes" xml:space="preserve">
          <source>CHANGESET_CONFLICT is passed as the second argument to the conflict handler while processing an INSERT change if the operation would result in duplicate primary key values.</source>
          <target state="translated">CHANGESET_CONFLICT передается в качестве второго аргумента обработчику конфликта при обработке изменения INSERT,если операция приведет к дублированию значений первичного ключа.</target>
        </trans-unit>
        <trans-unit id="49279edf04879138e2ca01fe4da87f165bb8a556" translate="yes" xml:space="preserve">
          <source>CHAR</source>
          <target state="translated">CHAR</target>
        </trans-unit>
        <trans-unit id="ec67cd542d6d42f84f8aea6727411112c2a9eee5" translate="yes" xml:space="preserve">
          <source>CHARACTER(20)</source>
          <target state="translated">CHARACTER(20)</target>
        </trans-unit>
        <trans-unit id="d37267cb2995cccac2283009e1ea4f3a6dd37db3" translate="yes" xml:space="preserve">
          <source>CHECK</source>
          <target state="translated">CHECK</target>
        </trans-unit>
        <trans-unit id="7c8e71cdac81d935a110e970f2e16db27f75d5ec" translate="yes" xml:space="preserve">
          <source>CHECK constraint</source>
          <target state="translated">ограничение КЧЕК</target>
        </trans-unit>
        <trans-unit id="91f48f96fc5990f4b552ae5c63dd0114792c0da9" translate="yes" xml:space="preserve">
          <source>CHECK constraints</source>
          <target state="translated">ограничения ЧЕК</target>
        </trans-unit>
        <trans-unit id="6c581d4e90f448ac099620dc82b1bf15e3863e36" translate="yes" xml:space="preserve">
          <source>CHECK constraints use conflict resolution algorithms correctly.</source>
          <target state="translated">Ограничения CHECK правильно используют алгоритмы разрешения конфликтов.</target>
        </trans-unit>
        <trans-unit id="700b401ca52b1bd3071dc838bf11be9cdb19fc5f" translate="yes" xml:space="preserve">
          <source>CLI</source>
          <target state="translated">CLI</target>
        </trans-unit>
        <trans-unit id="eb02003c667c1e9ee2fcede2fd0524e495d8ec1b" translate="yes" xml:space="preserve">
          <source>CLOB</source>
          <target state="translated">CLOB</target>
        </trans-unit>
        <trans-unit id="28248452f38e0300dc7c45ab12fbe5d41f97e047" translate="yes" xml:space="preserve">
          <source>COLLATE</source>
          <target state="translated">COLLATE</target>
        </trans-unit>
        <trans-unit id="093c8ab0d477c98bad008d7426a58810ce1d5c6c" translate="yes" xml:space="preserve">
          <source>COLLATE binary</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="114fac2d95aa36c73c87444e3e119061a6c497e8" translate="yes" xml:space="preserve">
          <source>COLLATE operator</source>
          <target state="translated">оператор COLLATE</target>
        </trans-unit>
        <trans-unit id="d517243e2eae9452e340645d614bbcb6cbc92a5f" translate="yes" xml:space="preserve">
          <source>COLLATE uint</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d59db8880904cdfee22d4bdd9e5cb72c42fae180" translate="yes" xml:space="preserve">
          <source>COLUMN</source>
          <target state="translated">COLUMN</target>
        </trans-unit>
        <trans-unit id="17e4d773881595e83eed7274990576cb3c33d081" translate="yes" xml:space="preserve">
          <source>COMMIT</source>
          <target state="translated">COMMIT</target>
        </trans-unit>
        <trans-unit id="b8bace9ba33552e80165d3ede409bac3b53e9442" translate="yes" xml:space="preserve">
          <source>COMMIT TRANSACTION</source>
          <target state="translated">СОВЕРШИТЬ СДЕЛКУ</target>
        </trans-unit>
        <trans-unit id="5be9cfb9ef50ef7a3f4855f3a3912ced47c9cd37" translate="yes" xml:space="preserve">
          <source>COMMIT;</source>
          <target state="translated">COMMIT;</target>
        </trans-unit>
        <trans-unit id="716a4859cb65ba79cf0a75301f937ee8dd84b958" translate="yes" xml:space="preserve">
          <source>CONFLICT</source>
          <target state="translated">CONFLICT</target>
        </trans-unit>
        <trans-unit id="eb44b374436f71b41c8c59982685ea220ef821e2" translate="yes" xml:space="preserve">
          <source>CONSTRAINT</source>
          <target state="translated">CONSTRAINT</target>
        </trans-unit>
        <trans-unit id="cabc2219177d43a5c1d71e3003445f83b9a7195f" translate="yes" xml:space="preserve">
          <source>CREATE</source>
          <target state="translated">CREATE</target>
        </trans-unit>
        <trans-unit id="4dfe073e739c382b273bdf0f1bdd27e7f10f38af" translate="yes" xml:space="preserve">
          <source>CREATE INDEX</source>
          <target state="translated">КРЕАТКИЙ ИНДЕКС</target>
        </trans-unit>
        <trans-unit id="d5c16f75a09033a1e8f65102b202f3992bcbc039" translate="yes" xml:space="preserve">
          <source>CREATE INDEX i2a ON t2(a);</source>
          <target state="translated">CREATE INDEX i2a ON t2(a);</target>
        </trans-unit>
        <trans-unit id="219d80e293971a20fc410c1cb42fe81ee5be3296" translate="yes" xml:space="preserve">
          <source>CREATE INDEX i2b ON t2(b);</source>
          <target state="translated">CREATE INDEX i2b ON t2(b);</target>
        </trans-unit>
        <trans-unit id="015ef83633db6629be0b04929a85c6e8362366cf" translate="yes" xml:space="preserve">
          <source>CREATE INDEX i3 ON t3(c);</source>
          <target state="translated">CREATE INDEX i3 ON t3(c);</target>
        </trans-unit>
        <trans-unit id="979ae29e43d609d39c91f43b7d2c9c6f0170c84c" translate="yes" xml:space="preserve">
          <source>CREATE TABLE</source>
          <target state="translated">CREATE TABLE</target>
        </trans-unit>
        <trans-unit id="61fe1c0db27d323fd657d34129f0370eddfd6b9e" translate="yes" xml:space="preserve">
          <source>CREATE TABLE ... AS SELECT Statements</source>
          <target state="translated">СОЗДАТЬ ТАБЛИЦУ...КАК ВЫБРАТИТЬ утверждения</target>
        </trans-unit>
        <trans-unit id="fdc5603516a1557309c21e74d5f3a300d7053f48" translate="yes" xml:space="preserve">
          <source>CREATE TABLE AS</source>
          <target state="translated">СОЗДАВАТЬ ТАБЛИЦУ КАК</target>
        </trans-unit>
        <trans-unit id="5c1879760c0ac0151021a298b71fc43dd31ae043" translate="yes" xml:space="preserve">
          <source>CREATE TABLE Statement</source>
          <target state="translated">CREATE TABLE Statement</target>
        </trans-unit>
        <trans-unit id="ef4e542d71b6fc791055be2754c8bba0c238f3b8" translate="yes" xml:space="preserve">
          <source>CREATE TABLE and DROP TABLE now work correctly as prepared statements.</source>
          <target state="translated">CREATE TABLE и DROP TABLE теперь работают правильно,как подготовленные отчеты.</target>
        </trans-unit>
        <trans-unit id="6a035b079a1ff283fd14f7d5c5ea363c26b68cda" translate="yes" xml:space="preserve">
          <source>CREATE TABLE t1(a INTEGER, b INTEGER, c VARCHAR(100));</source>
          <target state="translated">CREATE TABLE t1(a INTEGER,b INTEGER,c VARCHAR(100));</target>
        </trans-unit>
        <trans-unit id="4619a9be564e2fbde661edf547e025b44154bc1f" translate="yes" xml:space="preserve">
          <source>CREATE TABLE t1(a, b PRIMARY KEY);</source>
          <target state="translated">CREATE TABLE t1(a,b PRIMARY KEY);</target>
        </trans-unit>
        <trans-unit id="7b5a4e879f5838c381c1aaf9522123d8eb51ef28" translate="yes" xml:space="preserve">
          <source>CREATE TABLE t1(a, b UNIQUE);</source>
          <target state="translated">CREATE TABLE t1(a,b UNIQUE);</target>
        </trans-unit>
        <trans-unit id="472c250359f0aac3ac59d709bce28e56fc427ab7" translate="yes" xml:space="preserve">
          <source>CREATE TABLE t1(a, b);</source>
          <target state="translated">CREATE TABLE t1(a,b);</target>
        </trans-unit>
        <trans-unit id="b180c72a56f1e353661ad8a8bf096de1e31921fa" translate="yes" xml:space="preserve">
          <source>CREATE TABLE t1(c1 VARIANT);</source>
          <target state="translated">CREATE TABLE t1(c1 VARIANT);</target>
        </trans-unit>
        <trans-unit id="6c723a031c86a4c7b06f2a3f8d60439c8dcf6107" translate="yes" xml:space="preserve">
          <source>CREATE TABLE t2(a INTEGER, b INTEGER, c VARCHAR(100));</source>
          <target state="translated">CREATE TABLE t2(a INTEGER,b INTEGER,c VARCHAR(100));</target>
        </trans-unit>
        <trans-unit id="ffb49dd96e70cfeec18ece99b548162395148801" translate="yes" xml:space="preserve">
          <source>CREATE TABLE t3(a INTEGER, b INTEGER, c VARCHAR(100));</source>
          <target state="translated">CREATE TABLE t3(a INTEGER,b INTEGER,c VARCHAR(100));</target>
        </trans-unit>
        <trans-unit id="cf6418466d171e86053f358e78bdbbeb775f1f4f" translate="yes" xml:space="preserve">
          <source>CREATE TRIGGER</source>
          <target state="translated">CREATE TRIGGER</target>
        </trans-unit>
        <trans-unit id="4862717c14fde4c95f9fc018bad5f1bcdf240d46" translate="yes" xml:space="preserve">
          <source>CREATE UNIQUE INDEX t1b ON t1(b);</source>
          <target state="translated">CREATE UNIQUE INDEX t1b ON t1 b);</target>
        </trans-unit>
        <trans-unit id="c6d65be0664c12895eed3811d312f2344a61a809" translate="yes" xml:space="preserve">
          <source>CREATE VIEW</source>
          <target state="translated">КРЕАТКИЙ ВИД</target>
        </trans-unit>
        <trans-unit id="d37bcac589dd2e6a2d9d1fe15b402952fac86edd" translate="yes" xml:space="preserve">
          <source>CREATE VIRTUAL TABLE</source>
          <target state="translated">СОЗДАТЬ ВИРТУАЛЬНЫЙ СТОЛ</target>
        </trans-unit>
        <trans-unit id="3fed731b971838462d00ae70d200fd38b7750b9e" translate="yes" xml:space="preserve">
          <source>CREATE and DROP</source>
          <target state="translated">CREATE и DROP</target>
        </trans-unit>
        <trans-unit id="7ea4fbcff919d74664df2b3abbe9c64927134ca1" translate="yes" xml:space="preserve">
          <source>CROSS</source>
          <target state="translated">CROSS</target>
        </trans-unit>
        <trans-unit id="23cb1ba2135af54bb7f9dc4ac628c8c16b1274c8" translate="yes" xml:space="preserve">
          <source>CSV export</source>
          <target state="translated">экспорт CSV</target>
        </trans-unit>
        <trans-unit id="41b55f7f4ea3b51535ca8d9719be622b0aa72549" translate="yes" xml:space="preserve">
          <source>CSV import</source>
          <target state="translated">импорт CSV</target>
        </trans-unit>
        <trans-unit id="17e29dae877981f4c14c3c548258e66edf22daf5" translate="yes" xml:space="preserve">
          <source>CSV output from the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; now always uses CRNL for the row separator and avoids inserting CR in front of NLs contained in data.</source>
          <target state="translated">В выводе CSV из &lt;a href=&quot;cli&quot;&gt;оболочки командной строки&lt;/a&gt; теперь всегда используется CRNL в качестве разделителя строк и избегается вставка CR перед NL, содержащимся в данных.</target>
        </trans-unit>
        <trans-unit id="e6303ccf1ceff324ad3a408b48244faf8b681b0a" translate="yes" xml:space="preserve">
          <source>CURRENT</source>
          <target state="translated">CURRENT</target>
        </trans-unit>
        <trans-unit id="988c655ab1a28987e3b7f4aa07b43ec2f252df71" translate="yes" xml:space="preserve">
          <source>CURRENT_DATE</source>
          <target state="translated">CURRENT_DATE</target>
        </trans-unit>
        <trans-unit id="2c91dc4d76138fb01afa917b2a5880a2ce68218e" translate="yes" xml:space="preserve">
          <source>CURRENT_TIME</source>
          <target state="translated">CURRENT_TIME</target>
        </trans-unit>
        <trans-unit id="b12c7ec3f538b492b9b7b22b81788480777716ca" translate="yes" xml:space="preserve">
          <source>CURRENT_TIME, CURRENT_DATE, and CURRENT_TIMESTAMP added</source>
          <target state="translated">Добавлены файлы CURRENT_TIME,CURRENT_DATE и CURRENT_TIMESTAMP.</target>
        </trans-unit>
        <trans-unit id="a5fb7adeaa54144ee5b07100bdd633a9a88f29b3" translate="yes" xml:space="preserve">
          <source>CURRENT_TIMESTAMP</source>
          <target state="translated">CURRENT_TIMESTAMP</target>
        </trans-unit>
        <trans-unit id="65e385d9a3fe24f8571de75d22a480cc4676d324" translate="yes" xml:space="preserve">
          <source>CVE Number</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="356e8d51d92a4a7c252e86ea6fe14e667fc3ae1e" translate="yes" xml:space="preserve">
          <source>CVE-2019-19317</source>
          <target state="translated">CVE-2019-19317</target>
        </trans-unit>
        <trans-unit id="99f9264fe966c3479910c5d0ba83460e6e3729ad" translate="yes" xml:space="preserve">
          <source>CVE-2019-19923</source>
          <target state="translated">CVE-2019-19923</target>
        </trans-unit>
        <trans-unit id="eebebbb796152888eb988cbad61ced631a21ff64" translate="yes" xml:space="preserve">
          <source>CVE-2019-19924</source>
          <target state="translated">CVE-2019-19924</target>
        </trans-unit>
        <trans-unit id="9070593189adb897b13efec120fbe18b3b48119d" translate="yes" xml:space="preserve">
          <source>CVE-2019-19925</source>
          <target state="translated">CVE-2019-19925</target>
        </trans-unit>
        <trans-unit id="b944efa961d3a4a65106baa20c05ed67ed3d8528" translate="yes" xml:space="preserve">
          <source>CVE-2019-19926</source>
          <target state="translated">CVE-2019-19926</target>
        </trans-unit>
        <trans-unit id="23620708a776d0f4b23595664d860f1eb18db80f" translate="yes" xml:space="preserve">
          <source>CVE-2019-19959</source>
          <target state="translated">CVE-2019-19959</target>
        </trans-unit>
        <trans-unit id="9c19ca22b3ff09cd11be29de3092bac5ecbb6f72" translate="yes" xml:space="preserve">
          <source>CVE-2019-20218</source>
          <target state="translated">CVE-2019-20218</target>
        </trans-unit>
        <trans-unit id="f84119bb7976cd5a8c8919e495a1ea188c8d01ce" translate="yes" xml:space="preserve">
          <source>CVE-2020-11655</source>
          <target state="translated">CVE-2020-11655</target>
        </trans-unit>
        <trans-unit id="24bf60a79a1bdc939cd96a195c263490e183d008" translate="yes" xml:space="preserve">
          <source>CVE-2020-11656</source>
          <target state="translated">CVE-2020-11656</target>
        </trans-unit>
        <trans-unit id="b3458c87a366a597752314c96918a11badac6df6" translate="yes" xml:space="preserve">
          <source>CVE-2020-13434</source>
          <target state="translated">CVE-2020-13434</target>
        </trans-unit>
        <trans-unit id="0c64280d7ac694f06901161e2e4192059c94030d" translate="yes" xml:space="preserve">
          <source>CVE-2020-13435</source>
          <target state="translated">CVE-2020-13435</target>
        </trans-unit>
        <trans-unit id="d2142032cb8f67d47c0f692a8f43b0da8ba3dbb4" translate="yes" xml:space="preserve">
          <source>CVE-2020-13630</source>
          <target state="translated">CVE-2020-13630</target>
        </trans-unit>
        <trans-unit id="01b180dcf9513183380ef259d2b0841c4e7f77b3" translate="yes" xml:space="preserve">
          <source>CVE-2020-13631</source>
          <target state="translated">CVE-2020-13631</target>
        </trans-unit>
        <trans-unit id="2f01c703b75f4b1f7d0a5171ce82a9de250b7508" translate="yes" xml:space="preserve">
          <source>CVE-2020-13632</source>
          <target state="translated">CVE-2020-13632</target>
        </trans-unit>
        <trans-unit id="5d08b8e084f6c27e8e4b3ed9ca47f1f1232dd879" translate="yes" xml:space="preserve">
          <source>CVE-2020-13871</source>
          <target state="translated">CVE-2020-13871</target>
        </trans-unit>
        <trans-unit id="d794882b16e5e67f67cae72af337733774cdf3d1" translate="yes" xml:space="preserve">
          <source>CVE-2020-15358</source>
          <target state="translated">CVE-2020-15358</target>
        </trans-unit>
        <trans-unit id="e199336a03380b560a1ec76506edbffac71e2c63" translate="yes" xml:space="preserve">
          <source>CVE-2020-6405</source>
          <target state="translated">CVE-2020-6405</target>
        </trans-unit>
        <trans-unit id="e0e462c2ba637997a01ca062b46b08478eaea02c" translate="yes" xml:space="preserve">
          <source>CVE-2020-9327</source>
          <target state="translated">CVE-2020-9327</target>
        </trans-unit>
        <trans-unit id="58cc14935f8aae029bbfb78904497935571ef45e" translate="yes" xml:space="preserve">
          <source>CVEs (&quot;Common Vulnerabilities and Exposures&quot;) are reports of software bugs that might allow a system to be hacked. The idea behind CVEs is sound. They provide a common naming scheme whereby software bugs that might compromise information security can be easily tracked.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51c92beb8c02d63e98c12b62c29e821871eee1bb" translate="yes" xml:space="preserve">
          <source>CVEs about SQLite probably do not apply to your use of SQLite.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e3affda4e192cdf66e451e6d423b53be2042240" translate="yes" xml:space="preserve">
          <source>CVEs are a low-quality source of information about bugs in SQLite that are likely to affect most applications.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97154728871232f8ec1e18c7f99aae1f66258be4" translate="yes" xml:space="preserve">
          <source>Cache Validation</source>
          <target state="translated">проверка кэша</target>
        </trans-unit>
        <trans-unit id="243348169a35fc01acf2950edac2a8317e1d5705" translate="yes" xml:space="preserve">
          <source>Cache sharing is enabled and disabled for an entire process. This is a change as of SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_5_0.html&quot;&gt;version 3.5.0&lt;/a&gt; (2007-09-04). In prior versions of SQLite, sharing was enabled or disabled for each thread separately.</source>
          <target state="translated">Совместное использование кеша включено и отключено для всего процесса. Это изменение &lt;a href=&quot;https://sqlite.org/releaselog/3_5_0.html&quot;&gt;версии&lt;/a&gt; SQLite 3.5.0 (2007-09-04). В предыдущих версиях SQLite совместное использование было включено или отключено для каждого потока отдельно.</target>
        </trans-unit>
        <trans-unit id="dfad78f93ed55c3b8305d2de17eb36b19e276c8b" translate="yes" xml:space="preserve">
          <source>Call sqlite3_reset() on the statement handle. Since an SQLITE_LOCKED error may only occur on the first call to sqlite3_step() (it is not possible for one call to sqlite3_step() to return SQLITE_ROW and then the next SQLITE_LOCKED), the statement handle may be reset at this point without affecting the results of the query from the point of view of the caller. If sqlite3_reset() were not called at this point, the next call to sqlite3_step() would return SQLITE_MISUSE.</source>
          <target state="translated">Вызов sqlite3_reset()на дескрипторе оператора.Поскольку ошибка SQLITE_LOCKED может возникнуть только при первом вызове sqlite3_step()(невозможно при одном вызове sqlite3_step()вернуть SQLITE_ROW,а затем следующий SQLITE_LOCKED),то в этот момент хэндл оператора может быть сброшен,не влияя на результаты запроса с точки зрения вызывающего абонента.Если бы в этот момент не вызывалась функция sqlite3_reset(),то при следующем вызове sqlite3_step()возвращалась бы функция SQLITE_MISUSE.</target>
        </trans-unit>
        <trans-unit id="e7253d4d62ac064583560f235c4dc54e68e830f1" translate="yes" xml:space="preserve">
          <source>Call sqlite3_step() on the supplied statement handle. If the call returns anything other than SQLITE_LOCKED, then return this value to the caller. Otherwise, continue.</source>
          <target state="translated">Вызовите sqlite3_step()на входящем в комплект дескрипторе выписки.Если вызов возвращает что-либо кроме SQLITE_LOCKED,то верните это значение вызывающему абоненту.В противном случае продолжайте.</target>
        </trans-unit>
        <trans-unit id="ac89c336f7b9f31230fa306e89f0a63e33ec5741" translate="yes" xml:space="preserve">
          <source>Call sqlite3rbu_close(X) to destroy the sqlite3rbu object pointer. If sqlite3rbu_step(X) has been called enough times to completely apply the update to the target database, then the RBU database is marked as fully applied. Otherwise, the state of the RBU update application is saved in the state database (or in the RBU database if the name of the state database file in sqlite3rbu_open() is NULL) for later resumption of the update.</source>
          <target state="translated">Вызов sqlite3rbu_close(X)для уничтожения указателя объекта sqlite3rbu.Если sqlite3rbu_step(X)был вызван достаточно часто,чтобы полностью применить обновление к целевой базе данных,то база данных RBU помечается как полностью примененная.В противном случае состояние приложения обновления RBU сохраняется в базе данных состояния (или в базе данных RBU,если имя файла базы данных состояния в sqlite3rbu_open()равно NULL)для последующего возобновления обновления.</target>
        </trans-unit>
        <trans-unit id="f4cfaf571c0396d88e7a8a5942129605eebc5000" translate="yes" xml:space="preserve">
          <source>Call the table named by the &lt;a href=&quot;syntax/cte-table-name&quot;&gt;cte-table-name&lt;/a&gt; in a recursive common table expression the &quot;recursive table&quot;. In the &lt;a href=&quot;syntax/recursive-cte&quot;&gt;recursive-cte&lt;/a&gt; bubble diagram above, the recursive table must appear exactly once in the FROM clause of the recursive-select and must not appear anywhere else in either the initial-select or the recursive-select, including subqueries. The initial-select may be a &lt;a href=&quot;lang_select#compound&quot;&gt;compound select&lt;/a&gt;, but it may not include an ORDER BY, LIMIT, or OFFSET. The recursive-select must be a simple select, not a compound. The recursive-select is allowed to include an ORDER BY, LIMIT, and/or OFFSET.</source>
          <target state="translated">Вызовите таблицу, названную &lt;a href=&quot;syntax/cte-table-name&quot;&gt;cte-table-name&lt;/a&gt; в рекурсивном общем табличном выражении, &amp;laquo;рекурсивной таблицей&amp;raquo;. На пузырьковой диаграмме &lt;a href=&quot;syntax/recursive-cte&quot;&gt;рекурсивного cte&lt;/a&gt; выше рекурсивная таблица должна появляться ровно один раз в предложении FROM рекурсивного выбора и не должна появляться где-либо еще ни в начальном выборе, ни в рекурсивном выборе, включая подзапросы. Первоначальный выбор может быть &lt;a href=&quot;lang_select#compound&quot;&gt;составным&lt;/a&gt; , но не может включать ORDER BY, LIMIT или OFFSET. Рекурсивный выбор должен быть простым выбором, а не составным. Рекурсивный выбор может включать ORDER BY, LIMIT и / или OFFSET.</target>
        </trans-unit>
        <trans-unit id="42fb639b7313463881ed7d9bae34cc709237f03b" translate="yes" xml:space="preserve">
          <source>Callback</source>
          <target state="translated">Callback</target>
        </trans-unit>
        <trans-unit id="fc3110a84b56463b6ac2be236d2d0ee212bb9db8" translate="yes" xml:space="preserve">
          <source>Calling sqlite3_auto_extension(X) with an entry point X that is already on the list of automatic extensions is a harmless no-op. No entry point will be called more than once for each database connection that is opened.</source>
          <target state="translated">Вызов sqlite3_auto_extension(X)с точкой входа X,которая уже находится в списке автоматических расширений,является безобидным no-op.Ни одна точка входа не будет вызываться более одного раза для каждого открытого соединения с БД.</target>
        </trans-unit>
        <trans-unit id="fdd02e84dcaceaea19448095c3e09a162e5292ae" translate="yes" xml:space="preserve">
          <source>Calling sqlite3_free() with a pointer previously returned by sqlite3_malloc() or sqlite3_realloc() releases that memory so that it might be reused. The sqlite3_free() routine is a no-op if is called with a NULL pointer. Passing a NULL pointer to sqlite3_free() is harmless. After being freed, memory should neither be read nor written. Even reading previously freed memory might result in a segmentation fault or other severe error. Memory corruption, a segmentation fault, or other severe error might result if sqlite3_free() is called with a non-NULL pointer that was not obtained from sqlite3_malloc() or sqlite3_realloc().</source>
          <target state="translated">При вызове sqlite3_free()с указателем,ранее возвращенным функцией sqlite3_malloc()или sqlite3_realloc(),память освобождается для повторного использования.Рутина sqlite3_free()является функцией no-op,если она вызывается с указателем NULL.Передача указателя NULL в sqlite3_free()безвредна.После освобождения память не должна ни читаться,ни записываться.Даже чтение ранее освобожденной памяти может привести к ошибке сегментации или другой серьезной ошибке.Повреждение памяти,ошибка сегментации или другая серьезная ошибка может произойти,если функция sqlite3_free()будет вызвана с указателем не NULL,который не был получен с помощью функций sqlite3_malloc()или sqlite3_realloc().</target>
        </trans-unit>
        <trans-unit id="3358427e1a8ed1bea8f5a2ad2f5555efabc90a34" translate="yes" xml:space="preserve">
          <source>Calling this function with an argument that is not a NULL pointer or an open blob handle results in undefined behaviour. Calling this routine with a null pointer (such as would be returned by a failed call to &lt;a href=&quot;#sqlite3_blob_open&quot;&gt;sqlite3_blob_open()&lt;/a&gt;) is a harmless no-op. Otherwise, if this function is passed a valid open blob handle, the values returned by the sqlite3_errcode() and sqlite3_errmsg() functions are set before returning.</source>
          <target state="translated">Вызов этой функции с аргументом, который не является указателем NULL или дескриптором открытого большого двоичного объекта, приводит к неопределенному поведению. Вызов этой подпрограммы с нулевым указателем (например, который будет возвращен при неудачном вызове &lt;a href=&quot;#sqlite3_blob_open&quot;&gt;sqlite3_blob_open ()&lt;/a&gt; ) является безвредным бездействием. В противном случае, если этой функции передается действительный дескриптор открытого большого двоичного объекта, значения, возвращаемые функциями sqlite3_errcode () и sqlite3_errmsg (), устанавливаются перед возвратом.</target>
        </trans-unit>
        <trans-unit id="508bbd8f844cc227cec9347e436cbdd9ffc04285" translate="yes" xml:space="preserve">
          <source>Calling this function with an argument that is not a NULL pointer or an open blob handle results in undefined behaviour. Calling this routine with a null pointer (such as would be returned by a failed call to &lt;a href=&quot;blob_open&quot;&gt;sqlite3_blob_open()&lt;/a&gt;) is a harmless no-op. Otherwise, if this function is passed a valid open blob handle, the values returned by the sqlite3_errcode() and sqlite3_errmsg() functions are set before returning.</source>
          <target state="translated">Вызов этой функции с аргументом, который не является указателем NULL или дескриптором открытого большого двоичного объекта, приводит к неопределенному поведению. Вызов этой подпрограммы с нулевым указателем (например, который будет возвращен при неудачном вызове &lt;a href=&quot;blob_open&quot;&gt;sqlite3_blob_open ()&lt;/a&gt; ) является безвредным бездействием. В противном случае, если этой функции передается действительный дескриптор открытого большого двоичного объекта, значения, возвращаемые функциями sqlite3_errcode () и sqlite3_errmsg (), устанавливаются перед возвратом.</target>
        </trans-unit>
        <trans-unit id="64d7627e8fc4bb3206a4244a29e5baede1745ef4" translate="yes" xml:space="preserve">
          <source>Calling this routine with an argument less than or equal to zero turns off all busy handlers.</source>
          <target state="translated">Называя эту рутину аргументом меньше или равным нулю,отключаются все занятые обработчики.</target>
        </trans-unit>
        <trans-unit id="f8f92cf7b8aea43c60bffe0c687691a21c0c3628" translate="yes" xml:space="preserve">
          <source>Calls of the form &lt;a href=&quot;#sqlite3_vtab_config&quot;&gt;sqlite3_vtab_config&lt;/a&gt;(db,SQLITE_VTAB_CONSTRAINT_SUPPORT,X) are supported, where X is an integer. If X is zero, then the &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; whose &lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; or &lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; method invoked &lt;a href=&quot;#sqlite3_vtab_config&quot;&gt;sqlite3_vtab_config()&lt;/a&gt; does not support constraints. In this configuration (which is the default) if a call to the &lt;a href=&quot;vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; method returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt;, then the entire statement is rolled back as if &lt;a href=&quot;lang_conflict&quot;&gt;OR ABORT&lt;/a&gt; had been specified as part of the users SQL statement, regardless of the actual ON CONFLICT mode specified.</source>
          <target state="translated">Поддерживаются вызовы формы &lt;a href=&quot;#sqlite3_vtab_config&quot;&gt;sqlite3_vtab_config&lt;/a&gt; (db, SQLITE_VTAB_CONSTRAINT_SUPPORT, X), где X - целое число. Если X равен нулю, то &lt;a href=&quot;vtab&quot;&gt;виртуальная таблица,&lt;/a&gt; чей &lt;a href=&quot;vtab#xcreate&quot;&gt;метод xCreate&lt;/a&gt; или &lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; вызвал &lt;a href=&quot;#sqlite3_vtab_config&quot;&gt;sqlite3_vtab_config ()&lt;/a&gt; , не поддерживает ограничения. В этой конфигурации (которая используется по умолчанию), если вызов метода &lt;a href=&quot;vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; возвращает &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt; , то весь оператор откатывается, как если бы &lt;a href=&quot;lang_conflict&quot;&gt;OR ABORT&lt;/a&gt; было указано как часть пользовательского оператора SQL, независимо от фактического указанного режима ON CONFLICT.</target>
        </trans-unit>
        <trans-unit id="34ad152047e6215f524688d715005c8597525fd4" translate="yes" xml:space="preserve">
          <source>Calls of the form &lt;a href=&quot;#sqlite3_vtab_config&quot;&gt;sqlite3_vtab_config&lt;/a&gt;(db,SQLITE_VTAB_DIRECTONLY) from within the the &lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; or &lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; methods of a &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; implmentation prohibits that virtual table from being used from within triggers and views.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b0bba808ff71be3f5e68d5dc5e9c1b43f075395" translate="yes" xml:space="preserve">
          <source>Calls of the form &lt;a href=&quot;#sqlite3_vtab_config&quot;&gt;sqlite3_vtab_config&lt;/a&gt;(db,SQLITE_VTAB_INNOCUOUS) from within the the &lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; or &lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; methods of a &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; implmentation identify that virtual table as being safe to use from within triggers and views. Conceptually, the SQLITE_VTAB_INNOCUOUS tag means that the virtual table can do no serious harm even if it is controlled by a malicious hacker. Developers should avoid setting the SQLITE_VTAB_INNOCUOUS flag unless absolutely necessary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cd59c58ce5ea212cbfa095730fc7d7c0c018f0a" translate="yes" xml:space="preserve">
          <source>Calls of the form &lt;a href=&quot;vtab_config&quot;&gt;sqlite3_vtab_config&lt;/a&gt;(db,SQLITE_VTAB_CONSTRAINT_SUPPORT,X) are supported, where X is an integer. If X is zero, then the &lt;a href=&quot;../vtab&quot;&gt;virtual table&lt;/a&gt; whose &lt;a href=&quot;../vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; or &lt;a href=&quot;../vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; method invoked &lt;a href=&quot;vtab_config&quot;&gt;sqlite3_vtab_config()&lt;/a&gt; does not support constraints. In this configuration (which is the default) if a call to the &lt;a href=&quot;../vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; method returns &lt;a href=&quot;../rescode#constraint&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt;, then the entire statement is rolled back as if &lt;a href=&quot;../lang_conflict&quot;&gt;OR ABORT&lt;/a&gt; had been specified as part of the users SQL statement, regardless of the actual ON CONFLICT mode specified.</source>
          <target state="translated">Поддерживаются вызовы формы &lt;a href=&quot;vtab_config&quot;&gt;sqlite3_vtab_config&lt;/a&gt; (db, SQLITE_VTAB_CONSTRAINT_SUPPORT, X), где X - целое число. Если X равен нулю, то &lt;a href=&quot;../vtab&quot;&gt;виртуальная таблица,&lt;/a&gt; чей &lt;a href=&quot;../vtab#xcreate&quot;&gt;метод xCreate&lt;/a&gt; или &lt;a href=&quot;../vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; вызвал &lt;a href=&quot;vtab_config&quot;&gt;sqlite3_vtab_config ()&lt;/a&gt; , не поддерживает ограничения. В этой конфигурации (которая используется по умолчанию), если вызов метода &lt;a href=&quot;../vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; возвращает &lt;a href=&quot;../rescode#constraint&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt; , то весь оператор откатывается, как если бы &lt;a href=&quot;../lang_conflict&quot;&gt;OR ABORT&lt;/a&gt; было указано как часть пользовательского оператора SQL, независимо от фактического указанного режима ON CONFLICT.</target>
        </trans-unit>
        <trans-unit id="0d15b922d29010ebd3f4c6c25124e15853e06a0d" translate="yes" xml:space="preserve">
          <source>Calls of the form &lt;a href=&quot;vtab_config&quot;&gt;sqlite3_vtab_config&lt;/a&gt;(db,SQLITE_VTAB_DIRECTONLY) from within the the &lt;a href=&quot;../vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; or &lt;a href=&quot;../vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; methods of a &lt;a href=&quot;../vtab&quot;&gt;virtual table&lt;/a&gt; implmentation prohibits that virtual table from being used from within triggers and views.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="015012a4348dd0949483c59bb10d1f9a584347cd" translate="yes" xml:space="preserve">
          <source>Calls of the form &lt;a href=&quot;vtab_config&quot;&gt;sqlite3_vtab_config&lt;/a&gt;(db,SQLITE_VTAB_INNOCUOUS) from within the the &lt;a href=&quot;../vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; or &lt;a href=&quot;../vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; methods of a &lt;a href=&quot;../vtab&quot;&gt;virtual table&lt;/a&gt; implmentation identify that virtual table as being safe to use from within triggers and views. Conceptually, the SQLITE_VTAB_INNOCUOUS tag means that the virtual table can do no serious harm even if it is controlled by a malicious hacker. Developers should avoid setting the SQLITE_VTAB_INNOCUOUS flag unless absolutely necessary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86477778aa30209993df2ed08e9c32fc5e63a6fa" translate="yes" xml:space="preserve">
          <source>Calls to sqlite3_db_config() return SQLITE_OK if and only if the call is considered successful.</source>
          <target state="translated">Вызовы sqlite3_db_config()возвращают SQLITE_OK,если и только если вызов считается успешным.</target>
        </trans-unit>
        <trans-unit id="98e68b9f843bbc24802b164860be76398c7c74b1" translate="yes" xml:space="preserve">
          <source>Can I use SQLite in my commercial product without paying royalties?</source>
          <target state="translated">Могу ли я использовать SQLite в своем коммерческом продукте без уплаты роялти?</target>
        </trans-unit>
        <trans-unit id="a99feeb9b762e6e46c563375f506a5cca89929e5" translate="yes" xml:space="preserve">
          <source>Can multiple applications or multiple instances of the same application access a single database file at the same time?</source>
          <target state="translated">Могут ли несколько приложений или несколько экземпляров одного и того же приложения одновременно получить доступ к одному файлу базы данных?</target>
        </trans-unit>
        <trans-unit id="1d85ae4c67a45ca5f093c8517be6998fccbe1b6b" translate="yes" xml:space="preserve">
          <source>Cancel Automatic Extension Loading</source>
          <target state="translated">Отменить автоматическое расширение загрузки</target>
        </trans-unit>
        <trans-unit id="0f1e2a9d130c394f768ce03af8c9cfdba772362c" translate="yes" xml:space="preserve">
          <source>Capture Changes Using Triggers</source>
          <target state="translated">Захват изменений с помощью триггеров</target>
        </trans-unit>
        <trans-unit id="8d319a418b8f56b5238017081c3f614d4e2d2c3a" translate="yes" xml:space="preserve">
          <source>Carray($PTR,$N) is a &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued function&lt;/a&gt; with a single column (named &quot;value&quot;) and zero or more rows. The &quot;value&quot; of each row in the carray() is taken from a C-language array that is $N elements long. $PTR is a pointer to the beginning of the array. In this way, the carray() function provides a convenient mechanism to bind C-language arrays to SQL queries.</source>
          <target state="translated">Carray ($ PTR, $ N) - это возвращающая &lt;a href=&quot;vtab#tabfunc2&quot;&gt;табличное значение функция&lt;/a&gt; с одним столбцом (с именем &amp;laquo;значение&amp;raquo;) и нулем или более строк. &amp;laquo;Значение&amp;raquo; каждой строки в carray () берется из массива языка C, длина которого составляет $ N элементов. $ PTR - указатель на начало массива. Таким образом, функция carray () предоставляет удобный механизм для привязки массивов языка C к запросам SQL.</target>
        </trans-unit>
        <trans-unit id="8c3b32ddf313031d687668680d0df3a761eedc08" translate="yes" xml:space="preserve">
          <source>Case-folding is only performed for ASCII characters. So while &quot;A&quot; and &quot;a&quot; are considered to be equivalent, &quot;&amp;Atilde;&quot; and &quot;&amp;atilde;&quot; are distinct.</source>
          <target state="translated">Сворачивание регистра выполняется только для символов ASCII. Таким образом, хотя &amp;laquo;A&amp;raquo; и &amp;laquo;a&amp;raquo; считаются эквивалентными, &amp;laquo;&amp;Atilde;&amp;raquo; и &amp;laquo;&amp;atilde;&amp;raquo; различны.</target>
        </trans-unit>
        <trans-unit id="ddb2cf0a81747a42bb2a318554bfc6f3310b70d2" translate="yes" xml:space="preserve">
          <source>Case-insensitive matching of Unicode characters does not work.</source>
          <target state="translated">Чувствительное к регистру совпадение символов Юникода не работает.</target>
        </trans-unit>
        <trans-unit id="4a24bc7f7fc1b1e11b0cb6ad38cd14985ad78efd" translate="yes" xml:space="preserve">
          <source>Cases in which the underlying content table has an explicit INTEGER PRIMARY KEY column are slightly more difficult, as the text values stored in the rbu_control column are slightly different for the FTS index and its underlying content table. For the underlying content table, a character must be included in any rbu_control text values for the explicit IPK, but for the FTS table itself, which has an implicit rowid, it should not. This is inconvenient, but can be solved using a more complicated view, as follows:</source>
          <target state="translated">Случаи,когда базовая таблица контента имеет явный столбец INTEGER PRIMARY KEY,немного сложнее,так как текстовые значения,хранящиеся в столбце rbu_control,немного отличаются для индекса FTS и его базовой таблицы контента.Для базовой таблицы содержимого,символ должен быть включен в любые текстовые значения rbu_control для явного IPK,но для самой таблицы FTS,которая имеет неявный rowid,он не должен быть включен.Это неудобно,но может быть решено с помощью более сложного представления,как показано ниже:</target>
        </trans-unit>
        <trans-unit id="6d2fbd5980d329d5d6af3be31953582204f59e3e" translate="yes" xml:space="preserve">
          <source>Cases where a query against a WAL-mode database can return &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; include the following:</source>
          <target state="translated">Случаи, когда запрос к базе данных в режиме WAL может возвращать &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY,&lt;/a&gt; включают следующее:</target>
        </trans-unit>
        <trans-unit id="15a2b7aaa72451fad3138411af4836bb6aea25de" translate="yes" xml:space="preserve">
          <source>Cases where the page-sizes of database pInMemory and zFilename are different could be handled better.</source>
          <target state="translated">Случаи,когда размеры страниц базы данных pInMemory и zFilename различны,могут быть обработаны лучше.</target>
        </trans-unit>
        <trans-unit id="60745aef336b682ec827697b3e47b80c7d7555b3" translate="yes" xml:space="preserve">
          <source>Cast</source>
          <target state="translated">Cast</target>
        </trans-unit>
        <trans-unit id="8e96ef594fff82e127e63864e75e54aa6b53b266" translate="yes" xml:space="preserve">
          <source>Casting a REAL or INTEGER value to NUMERIC is a no-op, even if a real value could be losslessly converted to an integer.</source>
          <target state="translated">Приведение значения REAL или INTEGER в NUMERIC является нулевым значением,даже если реальное значение может быть без потерь преобразовано в целое число.</target>
        </trans-unit>
        <trans-unit id="383678fdbb040838c4ceb85e8d73bcffcce4db9f" translate="yes" xml:space="preserve">
          <source>Casting a TEXT or BLOB value into NUMERIC yields either an INTEGER or a REAL result. If the input text looks like an integer (there is no decimal point nor exponent) and the value is small enough to fit in a 64-bit signed integer, then the result will be INTEGER. Input text that looks like floating point (there is a decimal point and/or an exponent) and the text describes a value that can be losslessly converted back and forth between IEEE 754 64-bit float and a 51-bit signed integer, then the result is INTEGER. (In the previous sentence, a 51-bit integer is specified since that is one bit less than the length of the mantissa of an IEEE 754 64-bit float and thus provides a 1-bit of margin for the text-to-float conversion operation.) Any text input that describes a value outside the range of a 64-bit signed integer yields a REAL result.</source>
          <target state="translated">При переводе значения TEXT или BLOB в ЧИСЛОВЫЙ результат получается как ИНТЕГЕР,так и РЕАЛЬНЫЙ.Если вводимый текст выглядит как целое число (нет ни десятичной запятой,ни экспоненты)и значение достаточно мало,чтобы уместиться в 64-битное целое число,то результат будет INTEGER.Введите текст,который выглядит как плавающее число (есть десятичная точка и/или экспонента),и текст описывает значение,которое может быть без потерь преобразовано туда и обратно между IEEE 754 64-битным с плавающей точкой и 51-битным подписанным целым числом,то результатом будет INTEGER.(В предыдущем предложении указано 51-битное целое число,поскольку оно на один бит меньше длины мантиссы 64-битного плавающего модуля IEEE 754 и,таким образом,обеспечивает 1 бит поля для операции преобразования текста в плавающий).Любой ввод текста,описывающий значение вне диапазона 64-битного подписанного целого числа,дает REAL результат.</target>
        </trans-unit>
        <trans-unit id="6f9cada34f4e450b6e71343e035a2f6e0689a6ef" translate="yes" xml:space="preserve">
          <source>Casting a value to a type-name with no affinity causes the value to be converted into a BLOB. Casting to a BLOB consists of first casting the value to TEXT in the &lt;a href=&quot;pragma#pragma_encoding&quot;&gt;encoding&lt;/a&gt; of the database connection, then interpreting the resulting byte sequence as a BLOB instead of as TEXT.</source>
          <target state="translated">Приведение значения к имени типа без привязки приводит к преобразованию значения в BLOB. Преобразование в BLOB состоит из первого преобразования значения в TEXT в &lt;a href=&quot;pragma#pragma_encoding&quot;&gt;кодировке&lt;/a&gt; соединения с базой данных, а затем интерпретации результирующей последовательности байтов как BLOB, а не как TEXT.</target>
        </trans-unit>
        <trans-unit id="6fddff049ee62a8963c9618826e1a03cc952e4f9" translate="yes" xml:space="preserve">
          <source>Casting an INTEGER or REAL value into TEXT renders the value as if via &lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_snprintf()&lt;/a&gt; except that the resulting TEXT uses the &lt;a href=&quot;pragma#pragma_encoding&quot;&gt;encoding&lt;/a&gt; of the database connection.</source>
          <target state="translated">Приведение значения INTEGER или REAL к TEXT отображает значение, как если бы оно &lt;a href=&quot;c3ref/mprintf&quot;&gt;выполнялось с&lt;/a&gt; помощью sqlite3_snprintf (), за исключением того, что в результирующем TEXT используется &lt;a href=&quot;pragma#pragma_encoding&quot;&gt;кодировка&lt;/a&gt; соединения с базой данных.</target>
        </trans-unit>
        <trans-unit id="250b5faac42b62665141b9500e3ff0cde556b9c8" translate="yes" xml:space="preserve">
          <source>Casual readers are not expected to understand all of these rules. A key take-away from this section is that the rules for determining when query flatting is safe and when it is unsafe are subtle and complex. There have been multiple bugs over the years caused by over-aggressive query flattening. On the other hand, performance of complex queries and/or queries involving views tends to suffer if query flattening is more conservative.</source>
          <target state="translated">От случайных читателей не ожидается,что они поймут все эти правила.Ключевым моментом в этом разделе является то,что правила определения того,когда запрос сплющивается безопасно,а когда-небезопасно,являются тонкими и сложными.За эти годы было обнаружено множество ошибок,вызванных чрезмерно агрессивным выравниванием запросов.С другой стороны,производительность сложных запросов и/или запросов,связанных с представлениями,имеет тенденцию страдать,если выравнивание запроса более консервативно.</target>
        </trans-unit>
        <trans-unit id="8907a1b62f0f750985eefc9ce844fea83efeb9a9" translate="yes" xml:space="preserve">
          <source>Cause precompiled statements to expire. When an expired statement is executed using sqlite3_step() it will either automatically reprepare itself (if it was originally created using sqlite3_prepare_v2()) or it will fail with SQLITE_SCHEMA.</source>
          <target state="translated">Потому что предварительно скомпилированные заявления истекают.При выполнении просроченного оператора с помощью sqlite3_step()он либо автоматически перезапустится (если он был первоначально создан с помощью sqlite3_prepare_v2()),либо выйдет из строя с помощью SQLITE_SCHEMA.</target>
        </trans-unit>
        <trans-unit id="a305305010fac4c32d5e753f973a3552e1f13215" translate="yes" xml:space="preserve">
          <source>Causes the customer.cust_addr field to be updated for a specific customer entry that has customer.cust_id equal to the $cust_id parameter. Note how the values assigned to the view are made available as field in the special &quot;NEW&quot; table within the trigger body.</source>
          <target state="translated">Причиняет обновление поля customer.cust_addr для конкретной клиентской записи,в которой параметр customer.cust_id равен $cust_id.Обратите внимание на то,как значения,назначенные представлению,становятся доступными в виде поля в специальной таблице &quot;NEW&quot; в теле триггера.</target>
        </trans-unit>
        <trans-unit id="dbad4a6e3280246beefd6847d2978b258b3988cb" translate="yes" xml:space="preserve">
          <source>Cautions On The Use Of BEFORE triggers</source>
          <target state="translated">Меры предосторожности при использовании триггеров ДО их срабатывания</target>
        </trans-unit>
        <trans-unit id="b150cf72e99af84282f28eb7200853b8c0ee4cf4" translate="yes" xml:space="preserve">
          <source>Caveats And Bugs</source>
          <target state="translated">Пещеры и жуки</target>
        </trans-unit>
        <trans-unit id="ff583586588dbe1c7f2b18104da572d7a5f33f25" translate="yes" xml:space="preserve">
          <source>Celebrating the SQLite &quot;</source>
          <target state="translated">Празднование SQLite&quot;</target>
        </trans-unit>
        <trans-unit id="59bd6eed6ef43faee3a8233d127e632eb210e7f2" translate="yes" xml:space="preserve">
          <source>Cell content is stored in the cell content region of the b-tree page. SQLite strives to place cells as far toward the end of the b-tree page as it can, in order to leave space for future growth of the cell pointer array. The area in between the last cell pointer array entry and the beginning of the first cell is the unallocated region.</source>
          <target state="translated">Содержимое ячейки хранится в области содержимого ячейки на странице b-дерева.SQLite стремится размещать ячейки как можно дальше к концу страницы b-дерева,чтобы оставить место для будущего роста массива указателей ячеек.Область между последним входом в массив указателей ячеек и началом первой ячейки является нераспределенной областью.</target>
        </trans-unit>
        <trans-unit id="3b0cca36895145060f4680c61a83b1cba94677a3" translate="yes" xml:space="preserve">
          <source>Cell format summary</source>
          <target state="translated">Резюме в формате ячейки</target>
        </trans-unit>
        <trans-unit id="7ba571bb64ab9af59eb4c60e06ccece4c22b6946" translate="yes" xml:space="preserve">
          <source>Cell payload</source>
          <target state="translated">Полезная нагрузка ячеек</target>
        </trans-unit>
        <trans-unit id="4467e902ad5ceab8af5cb553065bb45a1d9e0f01" translate="yes" xml:space="preserve">
          <source>Change &lt;a href=&quot;cli#arinsup&quot;&gt;--update option&lt;/a&gt; in the &lt;a href=&quot;cli#sqlar&quot;&gt;.archive command&lt;/a&gt; so that it skips files that are already in the archive and are unchanged. Add the new --insert option that works like --update used to work.</source>
          <target state="translated">Измените &lt;a href=&quot;cli#arinsup&quot;&gt;параметр --update&lt;/a&gt; в команде &lt;a href=&quot;cli#sqlar&quot;&gt;.archive,&lt;/a&gt; чтобы она пропускала файлы, которые уже находятся в архиве и не изменились. Добавьте новую опцию --insert, которая работает так же, как раньше --update.</target>
        </trans-unit>
        <trans-unit id="f2cdcfee54f6e63221834526df456ae33f4748c1" translate="yes" xml:space="preserve">
          <source>Change &lt;a href=&quot;compile#default_pcache_initsz&quot;&gt;SQLITE_DEFAULT_PCACHE_INITSZ&lt;/a&gt; from 100 to 20, for improved performance.</source>
          <target state="translated">Измените &lt;a href=&quot;compile#default_pcache_initsz&quot;&gt;SQLITE_DEFAULT_PCACHE_INITSZ&lt;/a&gt; со 100 на 20 для повышения производительности.</target>
        </trans-unit>
        <trans-unit id="89533c2ad87297c6b1814e96c92819fffab5d853" translate="yes" xml:space="preserve">
          <source>Change both unix and windows &lt;a href=&quot;vfs&quot;&gt;VFSes&lt;/a&gt; to report a sector size of 4096 instead of the old default of 512.</source>
          <target state="translated">Измените &lt;a href=&quot;vfs&quot;&gt;виртуальные файловые системы UNIX&lt;/a&gt; и Windows, чтобы отображать размер сектора 4096 вместо старого по умолчанию 512.</target>
        </trans-unit>
        <trans-unit id="a9b62dcab530abf089ef055d542c538c769edd17" translate="yes" xml:space="preserve">
          <source>Change counter</source>
          <target state="translated">Счетчик изменений</target>
        </trans-unit>
        <trans-unit id="78284963454462cded2891e165a76967ce7ebecf" translate="yes" xml:space="preserve">
          <source>Change in Default Page Size in SQLite Version 3.12.0</source>
          <target state="translated">Изменение размера страницы по умолчанию в SQLite версии 3.12.0</target>
        </trans-unit>
        <trans-unit id="8ef7213e575119b9063a9829bf0081766983433e" translate="yes" xml:space="preserve">
          <source>Change log</source>
          <target state="translated">Журнал изменений</target>
        </trans-unit>
        <trans-unit id="a9b88ee2ce690ee5c74f615e035bfd14907be3b4" translate="yes" xml:space="preserve">
          <source>Change tclsqlite.c to use the Tcl_Obj interface</source>
          <target state="translated">Измените tclsqlite.c,чтобы использовать интерфейс Tcl_Obj</target>
        </trans-unit>
        <trans-unit id="c9502e13b89a0e998e0002cc9dd2ac28edd6e8ea" translate="yes" xml:space="preserve">
          <source>Change the &lt;a href=&quot;lemon&quot;&gt;Lemon&lt;/a&gt; source code to avoid calling C-library functions that OpenBSD considers dangerous. (Ex: sprintf).</source>
          <target state="translated">Измените исходный код &lt;a href=&quot;lemon&quot;&gt;Lemon,&lt;/a&gt; чтобы избежать вызова функций библиотеки C, которые OpenBSD считает опасными. (Пример: sprintf).</target>
        </trans-unit>
        <trans-unit id="5d77baa02e54aeb22b238c0441152b1e5304decd" translate="yes" xml:space="preserve">
          <source>Change the &lt;a href=&quot;tempfiles#tempdir&quot;&gt;temporary directory search algorithm&lt;/a&gt; on Unix to allow directories with write and execute permission, but without read permission, to serve as temporary directories. Apply this same standard to the &quot;.&quot; fallback directory.</source>
          <target state="translated">Измените &lt;a href=&quot;tempfiles#tempdir&quot;&gt;алгоритм поиска временного каталога&lt;/a&gt; в Unix, чтобы каталоги с разрешениями на запись и выполнение, но без разрешения на чтение, служили временными каталогами. Примените тот же стандарт к &quot;.&quot; резервный каталог.</target>
        </trans-unit>
        <trans-unit id="ddfd791371cc9a6cd54b126954447b1ad9112604" translate="yes" xml:space="preserve">
          <source>Change the &lt;b&gt;sqlite&lt;/b&gt; program so that it can read databases for which it lacks write permission. (It used to refuse all access if it could not write.)</source>
          <target state="translated">Измените программу &lt;b&gt;sqlite,&lt;/b&gt; чтобы она могла читать базы данных, для которых у нее нет разрешения на запись. (Раньше он отказывался от доступа, если не мог писать.)</target>
        </trans-unit>
        <trans-unit id="cbf993184d73b432fd33a6a4967c4e16c588f384" translate="yes" xml:space="preserve">
          <source>Change the code so that version 2.1.1 databases that were rendered unreadable by the above bug can be read by this version of the library even though the SQLITE_MASTER table is (slightly) corrupted.</source>
          <target state="translated">Измените код так,чтобы базы данных версии 2.1.1,которые были сделаны нечитаемыми из-за вышеуказанной ошибки,могли быть прочитаны этой версией библиотеки,несмотря на то,что таблица SQLITE_MASTER (слегка)повреждена.</target>
        </trans-unit>
        <trans-unit id="1b2c3ec73b516454d30b27549240c5be169d57e9" translate="yes" xml:space="preserve">
          <source>Change the datatype of SrcList.nSrc from type u8 to type int to work around an issue in the C compiler on AIX.</source>
          <target state="translated">Измените тип данных SrcList.nSrc с типа u8 на тип int для работы над проблемой в компиляторе Си на AIX.</target>
        </trans-unit>
        <trans-unit id="03b6774f351d6b79789eab0049e6b7dfa776c60c" translate="yes" xml:space="preserve">
          <source>Change the format of data records so that records up to 16MB in size can be stored.</source>
          <target state="translated">Изменить формат записей данных таким образом,чтобы можно было хранить записи размером до 16 МБ.</target>
        </trans-unit>
        <trans-unit id="cb9d727fc495b196f0a9e9dcf746f3b21fc8137d" translate="yes" xml:space="preserve">
          <source>Change the format of indices to allow for better query optimization.</source>
          <target state="translated">Изменение формата индексов для лучшей оптимизации запросов.</target>
        </trans-unit>
        <trans-unit id="5c9b7b0951ce0a0f4a0c1e9e79102e0b6bc620be" translate="yes" xml:space="preserve">
          <source>Change the format of indices to correct a design flaw the originated with version 2.1.0. *** This is an incompatible file format change *** When version 2.6.0 or later of the library attempts to open a database file created by version 2.5.6 or earlier, it will automatically and irreversibly convert the file format. &lt;b&gt;Make backup copies of older database files before opening them with version 2.6.0 of the library.&lt;/b&gt;</source>
          <target state="translated">Измените формат индексов, чтобы исправить ошибку дизайна, возникшую в версии 2.1.0. *** Это несовместимое изменение формата файла *** Когда версия 2.6.0 или более поздняя библиотека пытается открыть файл базы данных, созданный версией 2.5.6 или более ранней, она автоматически и необратимо преобразует формат файла. &lt;b&gt;Сделайте резервные копии старых файлов баз данных, прежде чем открывать их с помощью библиотеки версии 2.6.0.&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="b18ff5a16f7817612045bc810baefbc9f406946f" translate="yes" xml:space="preserve">
          <source>Change the journal mode of database P1 to P3. P3 must be one of the PAGER_JOURNALMODE_XXX values. If changing between the various rollback modes (delete, truncate, persist, off and memory), this is a simple operation. No IO is required.</source>
          <target state="translated">Изменить режим журнала базы данных P1 на P3.P3 должен быть одним из значений PAGER_JOURNALMODE_XXX.При переключении между различными режимами отката (удаление,усечение,сохранение,выключение и память)это простая операция.IO не требуется.</target>
        </trans-unit>
        <trans-unit id="6a5f740ae4d06bae054615ec1ed93d10f35a1f54" translate="yes" xml:space="preserve">
          <source>Change the makefile so that it no longer requires GNUmake extensions</source>
          <target state="translated">Измените makefile так,чтобы он больше не требовал расширения GNUmake</target>
        </trans-unit>
        <trans-unit id="1b024f79cb0f34e36e5e78085bb24625608ab395" translate="yes" xml:space="preserve">
          <source>Change the name of new_X to X using: ALTER TABLE new_X RENAME TO X.</source>
          <target state="translated">Измените имя new_X на X:ALTER ТАБЛИЦА new_X RENAME TO X.</target>
        </trans-unit>
        <trans-unit id="0f9e3a306b4bd9af67f4b8c1e8cb9e151f5fea94" translate="yes" xml:space="preserve">
          <source>Change the name of the sanity_check PRAGMA to &lt;b&gt;integrity_check&lt;/b&gt; and make it available in all compiles.</source>
          <target state="translated">Измените имя sanity_check PRAGMA на &lt;b&gt;целостность_check&lt;/b&gt; и сделайте его доступным во всех компиляциях.</target>
        </trans-unit>
        <trans-unit id="a87afe8ac8040316feb3c86d9f29d7a0de41424f" translate="yes" xml:space="preserve">
          <source>Change the round() function to return REAL instead of TEXT.</source>
          <target state="translated">Измените функцию round()на возврат REAL вместо TEXT.</target>
        </trans-unit>
        <trans-unit id="4cc900222ca19ab1e3c50fea1f145e841c36bab9" translate="yes" xml:space="preserve">
          <source>Change the schema parser so that it will error out if any of the type, name, and tbl_name columns of the &lt;a href=&quot;fileformat2#sqlite_master&quot;&gt;sqlite_master table&lt;/a&gt; have been corrupted and the database connection is not in &lt;a href=&quot;pragma#pragma_writable_schema&quot;&gt;writable_schema&lt;/a&gt; mode.</source>
          <target state="translated">Изменение схемы синтаксического анализа , так что он выдаст ошибку, если любой из типа, имени и tbl_name столбцов &lt;a href=&quot;fileformat2#sqlite_master&quot;&gt;таблицы sqlite_master&lt;/a&gt; были повреждены , и соединение с базой данных не в &lt;a href=&quot;pragma#pragma_writable_schema&quot;&gt;writable_schema&lt;/a&gt; режиме.</target>
        </trans-unit>
        <trans-unit id="8e16078deadbe9f7e3e1b2c9c9d590cfec88a614" translate="yes" xml:space="preserve">
          <source>Change the schema parser so that it will error out if any of the type, name, and tbl_name columns of the &lt;a href=&quot;schematab&quot;&gt;sqlite_master table&lt;/a&gt; have been corrupted and the database connection is not in &lt;a href=&quot;pragma#pragma_writable_schema&quot;&gt;writable_schema&lt;/a&gt; mode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cf246de2a9b8a88c663c6913b8ed3a48191818d" translate="yes" xml:space="preserve">
          <source>Change the table_info pragma so that it returns NULL for the default value if there is no default value</source>
          <target state="translated">Измените прагму table_info так,чтобы она возвращала NULL для значения по умолчанию,если нет значения по умолчанию</target>
        </trans-unit>
        <trans-unit id="b05df024c90267a155027a34482c97ed1e176816" translate="yes" xml:space="preserve">
          <source>Change the tclsqlite &quot;eval&quot; method to return a list of results if no callback script is specified.</source>
          <target state="translated">Измените метод tclsqlite &quot;eval&quot; для возврата списка результатов,если не указан скрипт обратного вызова.</target>
        </trans-unit>
        <trans-unit id="17fc584f1b3f79a52638c936555356d72a9a526e" translate="yes" xml:space="preserve">
          <source>Change the unix &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; to be tolerant of read() system calls that return less then the full number of requested bytes.</source>
          <target state="translated">Измените unix &lt;a href=&quot;vfs&quot;&gt;VFS,&lt;/a&gt; чтобы она была устойчивой к системным вызовам read (), которые возвращают меньше, чем полное количество запрошенных байтов.</target>
        </trans-unit>
        <trans-unit id="a542a095188ddcc6129238423271833568a2c07f" translate="yes" xml:space="preserve">
          <source>Change the way SUM() handles NULL values in order to comply with the SQL standard</source>
          <target state="translated">Измените способ,которым SUM()обрабатывает NULL-значения,чтобы соответствовать стандарту SQL</target>
        </trans-unit>
        <trans-unit id="5b5328bf106285a23dec346b5145893a33e1e8c9" translate="yes" xml:space="preserve">
          <source>Change the xFileControl() methods on all built-in VFSes to return &lt;a href=&quot;rescode#notfound&quot;&gt;SQLITE_NOTFOUND&lt;/a&gt; instead of &lt;a href=&quot;rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt; for an unrecognized operation code.</source>
          <target state="translated">Измените методы xFileControl () на всех встроенных VFS, чтобы они возвращали &lt;a href=&quot;rescode#notfound&quot;&gt;SQLITE_NOTFOUND&lt;/a&gt; вместо &lt;a href=&quot;rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt; для нераспознанного кода операции.</target>
        </trans-unit>
        <trans-unit id="eca73e726e881b6d471428b557f6268ef3f59ed9" translate="yes" xml:space="preserve">
          <source>Change to use strncmp() or the equivalent instead of memcmp() when comparing non-zero-terminated strings.</source>
          <target state="translated">Изменение в использовании strncmp()или эквивалента вместо memcmp()при сравнении ненулевых строк.</target>
        </trans-unit>
        <trans-unit id="5514a8922a61fec2577edc11821f533a39d0a9ca" translate="yes" xml:space="preserve">
          <source>Changed the comparison function so that numbers in exponential notation (ex: 1.234e+05) sort in numerical order.</source>
          <target state="translated">Функция сравнения изменена таким образом,что числа в экспоненциальной нотации (например:1.234e+05)сортируются в числовом порядке.</target>
        </trans-unit>
        <trans-unit id="df02ed3983d83060874d040fa7eb3a189bd673c0" translate="yes" xml:space="preserve">
          <source>Changed the default configuration of the &lt;a href=&quot;malloc#lookaside&quot;&gt;lookaside memory allocator&lt;/a&gt; from 500 slots of 128 bytes each into 125 slots of 512 bytes each.</source>
          <target state="translated">Изменена конфигурация по умолчанию &lt;a href=&quot;malloc#lookaside&quot;&gt;внешнего распределителя памяти&lt;/a&gt; с 500 слотов по 128 байт каждый на 125 слотов по 512 байт каждый.</target>
        </trans-unit>
        <trans-unit id="7e34599469a327d2e948bcc9862b0322f2e510f5" translate="yes" xml:space="preserve">
          <source>Changed the defined behavior for the &lt;a href=&quot;lang_expr#castexpr&quot;&gt;CAST expression&lt;/a&gt; when floating point values greater than +9223372036854775807 are cast into into integers so that the result is the largest possible integer, +9223372036854775807, instead of the smallest possible integer, -9223372036854775808. After this change, CAST(9223372036854775809.0 as INT) yields +9223372036854775807 instead of -9223372036854775808. &lt;b&gt;&lt;big&gt;&amp;larr;&lt;/big&gt; Potentially Incompatible Change!&lt;/b&gt;</source>
          <target state="translated">Изменено определенное поведение для &lt;a href=&quot;lang_expr#castexpr&quot;&gt;выражения CAST,&lt;/a&gt; когда значения с плавающей запятой больше +9223372036854775807 преобразуются в целые числа, так что результатом является наибольшее возможное целое число +9223372036854775807 вместо наименьшего возможного целого числа -9223372036854775808. После этого изменения CAST (9223372036854775809.0 как INT) дает +9223372036854775807 вместо -9223372036854775808. &lt;b&gt;&lt;big&gt;&amp;larr;&lt;/big&gt; Возможно несовместимое изменение!&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="8caa23815a1a8b1a9c4e9cdf79d42cbf41197489" translate="yes" xml:space="preserve">
          <source>Changed the print format for floating point values from &quot;%g&quot; to &quot;%.15g&quot;.</source>
          <target state="translated">Изменен формат печати значений с плавающей точкой с &quot;%g&quot; на &quot;%.15g&quot;.</target>
        </trans-unit>
        <trans-unit id="24a6e547edd1d04eb53e9f5fe5f292726e669a13" translate="yes" xml:space="preserve">
          <source>Changed the prototype of the &lt;a href=&quot;c3ref/auto_extension&quot;&gt;sqlite3_auto_extension()&lt;/a&gt; interface in a way that is backwards compatible but which might cause warnings in new builds of applications that use that interface.</source>
          <target state="translated">Изменен прототип интерфейса &lt;a href=&quot;c3ref/auto_extension&quot;&gt;sqlite3_auto_extension ()&lt;/a&gt; таким образом, чтобы он был обратно совместим, но мог вызывать предупреждения в новых сборках приложений, использующих этот интерфейс.</target>
        </trans-unit>
        <trans-unit id="f51c4a6bf59ab3184542658dacdac319c7bb7606" translate="yes" xml:space="preserve">
          <source>Changed the signature of the xDlSym method of the &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object in a way that is backwards compatible but which might cause compiler warnings.</source>
          <target state="translated">Изменена сигнатура метода xDlSym объекта &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; таким образом, чтобы обеспечить обратную совместимость, но это может вызывать предупреждения компилятора.</target>
        </trans-unit>
        <trans-unit id="09eb09203ab84e8c2e6e475c70c299202b24c3d8" translate="yes" xml:space="preserve">
          <source>Changegroup Handle</source>
          <target state="translated">Ручка для смены группы</target>
        </trans-unit>
        <trans-unit id="11562ffd183a3f8082c848cac1f5dad1ab2f2843" translate="yes" xml:space="preserve">
          <source>Changes In SQLite Version 3.7.10</source>
          <target state="translated">Изменения в версии SQLite 3.7.10</target>
        </trans-unit>
        <trans-unit id="2995749ac68f24f9806cbd53a3147e4763d74488" translate="yes" xml:space="preserve">
          <source>Changes are made to the database by executing SQL statements. The session object records these changes.</source>
          <target state="translated">Изменения вносятся в базу данных путем выполнения SQL-запросов.Объект сессии записывает эти изменения.</target>
        </trans-unit>
        <trans-unit id="3feb747c2cf9c224527b83786a30acbbf79e8f1b" translate="yes" xml:space="preserve">
          <source>Changes are not recorded for individual rows that have NULL values stored in one or more of their PRIMARY KEY columns.</source>
          <target state="translated">Изменения не записываются для отдельных строк,которые имеют NULL-значения,сохраненные в одном или нескольких столбцах PRIMARY KEY.</target>
        </trans-unit>
        <trans-unit id="5ba7ed905184ce22787b0029a4544681dc28b3db" translate="yes" xml:space="preserve">
          <source>Changes are not recorded for rows that have NULL values stored in one or more of their PRIMARY KEY columns. If such a row is inserted or deleted, no corresponding change is present in the changesets returned by this function. If an existing row with one or more NULL values stored in PRIMARY KEY columns is updated so that all PRIMARY KEY columns are non-NULL, only an INSERT is appears in the changeset. Similarly, if an existing row with non-NULL PRIMARY KEY values is updated so that one or more of its PRIMARY KEY columns are set to NULL, the resulting changeset contains a DELETE change only.</source>
          <target state="translated">Изменения не записываются для строк,которые имеют NULL-значения,сохраненные в одном или нескольких столбцах PRIMARY KEY.Если такая строка вставляется или удаляется,соответствующие изменения в наборах изменений,возвращаемых этой функцией,отсутствуют.Если существующая строка с одним или несколькими NULL-значениями,сохраненными в столбцах PRIMARY KEY,обновляется таким образом,что все столбцы PRIMARY KEY не являются NULL-значениями,то в changeset отображается только INSERT.Аналогично,если существующая строка со значениями,отличными от NULL PRIMARY KEY,обновляется таким образом,что один или несколько столбцов PRIMARY KEY установлены в NULL,в результирующем наборе изменений отображается только изменение DELETE (УДАЛИТЬ).</target>
        </trans-unit>
        <trans-unit id="f6e50ec4a352fdec5ac39c386ca001416ca1e482" translate="yes" xml:space="preserve">
          <source>Changes can only be recorded for tables that have a PRIMARY KEY explicitly defined as part of their CREATE TABLE statement. It does not matter if the PRIMARY KEY is an &quot;INTEGER PRIMARY KEY&quot; (rowid alias) or not. The PRIMARY KEY may consist of a single column, or may be a composite key.</source>
          <target state="translated">Изменения могут быть записаны только для таблиц,которые имеют PRIMARY KEY,явно определенный как часть оператора CREATE TABLE.Не имеет значения,является ли PRIMARY KEY &quot;INTEGER PRIMARY KEY&quot; (псевдоним rowid)или нет.PRIMARY KEY может состоять из одного столбца или может быть композитным ключом.</target>
        </trans-unit>
        <trans-unit id="c0acee58dba4e45c8d5f0399ec1f0d4976436ff2" translate="yes" xml:space="preserve">
          <source>Changes made as part of &lt;a href=&quot;../foreignkeys#fk_actions&quot;&gt;foreign key actions&lt;/a&gt; are included in the count, but those made as part of REPLACE constraint resolution are not. Changes to a view that are intercepted by INSTEAD OF triggers are not counted.</source>
          <target state="translated">Изменения, сделанные как часть действий &lt;a href=&quot;../foreignkeys#fk_actions&quot;&gt;внешнего ключа&lt;/a&gt; , включаются в подсчет, но изменения, сделанные как часть разрешения ограничения REPLACE, не включаются. Изменения в представлении, перехваченные триггерами INSTEAD OF, не учитываются.</target>
        </trans-unit>
        <trans-unit id="b4615c7abb16118eca044200ca3ffb2d42e109f3" translate="yes" xml:space="preserve">
          <source>Changes made as part of &lt;a href=&quot;foreignkeys#fk_actions&quot;&gt;foreign key actions&lt;/a&gt; are included in the count, but those made as part of REPLACE constraint resolution are not. Changes to a view that are intercepted by INSTEAD OF triggers are not counted.</source>
          <target state="translated">Изменения, сделанные как часть действий &lt;a href=&quot;foreignkeys#fk_actions&quot;&gt;внешнего ключа&lt;/a&gt; , включаются в подсчет, но изменения, сделанные как часть разрешения ограничения REPLACE, не включаются. Изменения в представлении, перехваченные триггерами INSTEAD OF, не учитываются.</target>
        </trans-unit>
        <trans-unit id="1e424444f79aa5098cffaecbf261fdab95101506" translate="yes" xml:space="preserve">
          <source>Changes made in one database connection are invisible to all other database connections prior to commit.</source>
          <target state="translated">Изменения,сделанные в одном подключении к БД,невидимы для всех остальных подключений к БД до фиксации.</target>
        </trans-unit>
        <trans-unit id="f8bcc1bfedf61a4d6d2302f5aebd841ed0c31154" translate="yes" xml:space="preserve">
          <source>Changes to CREATE VIRTUAL TABLE statements</source>
          <target state="translated">Изменения в отчетах о движении денежной наличности</target>
        </trans-unit>
        <trans-unit id="39b78ad4f8a76dbe4baff285b9df3d3da0888670" translate="yes" xml:space="preserve">
          <source>Changes to SELECT statements</source>
          <target state="translated">Изменения в заявлениях SELECT</target>
        </trans-unit>
        <trans-unit id="220e3088537dbb26a066213f366f942dc49c0e70" translate="yes" xml:space="preserve">
          <source>Changes to a view that are intercepted by &lt;a href=&quot;../lang_createtrigger#instead_of_trigger&quot;&gt;INSTEAD OF triggers&lt;/a&gt; are not counted. The value returned by sqlite3_changes() immediately after an INSERT, UPDATE or DELETE statement run on a view is always zero. Only changes made to real tables are counted.</source>
          <target state="translated">Изменения в представлении, перехваченные &lt;a href=&quot;../lang_createtrigger#instead_of_trigger&quot;&gt;триггерами INSTEAD OF&lt;/a&gt; , не учитываются. Значение, возвращаемое sqlite3_changes () сразу после выполнения инструкции INSERT, UPDATE или DELETE для представления, всегда равно нулю. Учитываются только изменения, внесенные в реальные таблицы.</target>
        </trans-unit>
        <trans-unit id="5d6b66157c1ebd92a27f45e6d4f023a3d4bc6e87" translate="yes" xml:space="preserve">
          <source>Changes to a view that are intercepted by &lt;a href=&quot;lang_createtrigger#instead_of_trigger&quot;&gt;INSTEAD OF triggers&lt;/a&gt; are not counted. The value returned by sqlite3_changes() immediately after an INSERT, UPDATE or DELETE statement run on a view is always zero. Only changes made to real tables are counted.</source>
          <target state="translated">Изменения в представлении, перехваченные &lt;a href=&quot;lang_createtrigger#instead_of_trigger&quot;&gt;триггерами INSTEAD OF&lt;/a&gt; , не учитываются. Значение, возвращаемое sqlite3_changes () сразу после выполнения инструкции INSERT, UPDATE или DELETE для представления, всегда равно нулю. Учитываются только изменения, внесенные в реальные таблицы.</target>
        </trans-unit>
        <trans-unit id="3ac2cb6fb5d947302cd716dd294d872e94891de1" translate="yes" xml:space="preserve">
          <source>Changes to comments.</source>
          <target state="translated">Изменения в комментариях.</target>
        </trans-unit>
        <trans-unit id="c84397dcd0da39654544ab29ddec3a05373f0685" translate="yes" xml:space="preserve">
          <source>Changes to compile-time options:</source>
          <target state="translated">Изменения в опциях времени компиляции:</target>
        </trans-unit>
        <trans-unit id="101e26bd8ffca056c8adaec28f53e8804617dcdd" translate="yes" xml:space="preserve">
          <source>Changes to rows that do not already appear in the changegroup are simply copied into it. Or, if both the new changeset and the changegroup contain changes that apply to a single row, the final contents of the changegroup depends on the type of each change, as follows:</source>
          <target state="translated">Изменения в строках,которые еще не появились в группе изменений,просто копируются в нее.Или же,если и новый changeset,и группа изменений содержат изменения,которые относятся к одной строке,то конечное содержимое группы изменений зависит от типа каждого изменения следующим образом:</target>
        </trans-unit>
        <trans-unit id="3fc8393d45e2f151d9e20c436cc969f753e757c8" translate="yes" xml:space="preserve">
          <source>Changes to some test scripts so that they work on Windows in addition to Unix.</source>
          <target state="translated">Изменения в некоторых тестовых скриптах,чтобы они работали под Windows в дополнение к Unix.</target>
        </trans-unit>
        <trans-unit id="e4c26ff789d743fb895c4925c581702e142ed6c8" translate="yes" xml:space="preserve">
          <source>Changes to support 64-bit architectures.</source>
          <target state="translated">Изменения для поддержки 64-битных архитектур.</target>
        </trans-unit>
        <trans-unit id="0e15c1197ceca55511517525b0c74a6a5dfd3ac1" translate="yes" xml:space="preserve">
          <source>Changes to the &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object</source>
          <target state="translated">Изменения в объекте &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="062c3354f76067d89f734b31e5b499c574c81bb7" translate="yes" xml:space="preserve">
          <source>Changes to the &lt;a href=&quot;lemon&quot;&gt;Lemon parser generator&lt;/a&gt; to help it work better when compiled using MSVC.</source>
          <target state="translated">Изменения в &lt;a href=&quot;lemon&quot;&gt;генераторе синтаксического анализатора Lemon,&lt;/a&gt; чтобы он лучше работал при компиляции с использованием MSVC.</target>
        </trans-unit>
        <trans-unit id="d0bc6551b6a2c8af14e74911872297e41927e492" translate="yes" xml:space="preserve">
          <source>Changes to the FULL_COLUMN_NAMES pragma to help out the ODBC driver.</source>
          <target state="translated">Изменения в прагме FULL_COLUMN_NAMES для помощи драйверу ODBC.</target>
        </trans-unit>
        <trans-unit id="7e96fb7803c57c4c013f472a7a7b6294655eae95" translate="yes" xml:space="preserve">
          <source>Changes to the OS-layer interface: mutexes must now be recursive.</source>
          <target state="translated">Изменения в интерфейсе OS-уровня:теперь мьютексы должны быть рекурсивными.</target>
        </trans-unit>
        <trans-unit id="32f6cdea79e8215becbb15cf7bd7e55cdcee90d2" translate="yes" xml:space="preserve">
          <source>Changes within a patchset are ordered in the same way as for changesets generated by the sqlite3session_changeset() function (i.e. all changes for a single table are grouped together, tables appear in the order in which they were attached to the session object).</source>
          <target state="translated">Изменения в наборе патчей упорядочены так же,как и для наборов изменений,генерируемых функцией sqlite3session_changeset()(т.е.все изменения для одной таблицы сгруппированы вместе,таблицы появляются в том порядке,в котором они были прикреплены к объекту сеанса).</target>
        </trans-unit>
        <trans-unit id="da04970767ae72464882ac8a4e16564000ecf171" translate="yes" xml:space="preserve">
          <source>Changes within the local changeset are rebased as follows:</source>
          <target state="translated">Изменения в локальном наборе изменений изменяются следующим образом:</target>
        </trans-unit>
        <trans-unit id="3a336eee124955ea62ce9395beedef4d114ca005" translate="yes" xml:space="preserve">
          <source>Changeset Generation</source>
          <target state="translated">генерация изменений</target>
        </trans-unit>
        <trans-unit id="83360005f23e00ab75cb5a31e370b474e7cda3dd" translate="yes" xml:space="preserve">
          <source>Changeset Iterator Handle</source>
          <target state="translated">Переключаемая ручка итератора</target>
        </trans-unit>
        <trans-unit id="e80a51a4aaef4428a67700502b5f7dc75dbd4588" translate="yes" xml:space="preserve">
          <source>Changesets may only be applied to databases that contain tables matching the above three criteria as stored in the changeset.</source>
          <target state="translated">Изменения могут применяться только к базам данных,содержащим таблицы,соответствующие трем вышеуказанным критериям,которые хранятся в наборе изменений.</target>
        </trans-unit>
        <trans-unit id="ac1c3813780e3748f7f89bcb8cde7110310ebb74" translate="yes" xml:space="preserve">
          <source>Changing Filesystems</source>
          <target state="translated">Изменение файловых систем</target>
        </trans-unit>
        <trans-unit id="5f75f4f19ef2482e0ee092a7ab747ab2b4de6353" translate="yes" xml:space="preserve">
          <source>Changing the &lt;a href=&quot;pragma#pragma_schema_version&quot;&gt;PRAGMA schema_version&lt;/a&gt; while other database connections are open.</source>
          <target state="translated">Изменение &lt;a href=&quot;pragma#pragma_schema_version&quot;&gt;версии_схемы PRAGMA&lt;/a&gt; при открытых соединениях с другими базами данных.</target>
        </trans-unit>
        <trans-unit id="9851972ccfb6ddbbe4682022996c0b7f4c61ad78" translate="yes" xml:space="preserve">
          <source>Changing the data_store_directory setting is &lt;u&gt;not&lt;/u&gt; threadsafe. Never change the data_store_directory setting if another thread within the application is running any SQLite interface at the same time. Doing so results in undefined behavior. Changing the data_store_directory setting writes to the &lt;a href=&quot;c3ref/data_directory&quot;&gt;sqlite3_data_directory&lt;/a&gt; global variable and that global variable is not protected by a mutex.</source>
          <target state="translated">Изменение параметра data_store_directory &lt;u&gt;не&lt;/u&gt; является потокобезопасным. Никогда не изменяйте параметр data_store_directory, если другой поток в приложении одновременно выполняет какой-либо интерфейс SQLite. Это приводит к неопределенному поведению. При изменении параметра data_store_directory записывается в глобальную переменную &lt;a href=&quot;c3ref/data_directory&quot;&gt;sqlite3_data_directory,&lt;/a&gt; и эта глобальная переменная не защищена мьютексом.</target>
        </trans-unit>
        <trans-unit id="430a2be1381002d87b9b8ff73223fcbf66c5e87f" translate="yes" xml:space="preserve">
          <source>Changing the foreign_keys setting affects the execution of all statements prepared using the database connection, including those prepared before the setting was changed. Any existing statements prepared using the legacy &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; interface may fail with an &lt;a href=&quot;rescode#schema&quot;&gt;SQLITE_SCHEMA&lt;/a&gt; error after the foreign_keys setting is changed.</source>
          <target state="translated">Изменение параметра foreign_keys влияет на выполнение всех операторов, подготовленных с использованием соединения с базой данных, в том числе подготовленных до изменения параметра. Любые существующие операторы, подготовленные с использованием устаревшего интерфейса &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare (),&lt;/a&gt; могут завершиться ошибкой &lt;a href=&quot;rescode#schema&quot;&gt;SQLITE_SCHEMA&lt;/a&gt; после изменения параметра foreign_keys.</target>
        </trans-unit>
        <trans-unit id="e64e5108f8dce99580f41bdd628fb1a43e13fc20" translate="yes" xml:space="preserve">
          <source>Changing the recursive_triggers setting affects the execution of all statements prepared using the database connection, including those prepared before the setting was changed. Any existing statements prepared using the legacy &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; interface may fail with an &lt;a href=&quot;rescode#schema&quot;&gt;SQLITE_SCHEMA&lt;/a&gt; error after the recursive_triggers setting is changed.</source>
          <target state="translated">Изменение параметра recursive_triggers влияет на выполнение всех инструкций, подготовленных с использованием соединения с базой данных, включая те, которые были подготовлены до изменения параметра. Любые существующие операторы, подготовленные с использованием устаревшего интерфейса &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare (),&lt;/a&gt; могут завершиться ошибкой &lt;a href=&quot;rescode#schema&quot;&gt;SQLITE_SCHEMA&lt;/a&gt; после изменения параметра recursive_triggers.</target>
        </trans-unit>
        <trans-unit id="859510e9fde4ba7098039dc9d57957c57590e8ad" translate="yes" xml:space="preserve">
          <source>Changing the temp_store_directory setting is &lt;u&gt;not&lt;/u&gt; threadsafe. Never change the temp_store_directory setting if another thread within the application is running any SQLite interface at the same time. Doing so results in undefined behavior. Changing the temp_store_directory setting writes to the &lt;a href=&quot;c3ref/temp_directory&quot;&gt;sqlite3_temp_directory&lt;/a&gt; global variable and that global variable is not protected by a mutex.</source>
          <target state="translated">Изменение параметра temp_store_directory &lt;u&gt;не&lt;/u&gt; является потокобезопасным. Никогда не изменяйте параметр temp_store_directory, если другой поток в приложении одновременно выполняет какой-либо интерфейс SQLite. Это приводит к неопределенному поведению. При изменении параметра temp_store_directory выполняется запись в глобальную переменную &lt;a href=&quot;c3ref/temp_directory&quot;&gt;sqlite3_temp_directory,&lt;/a&gt; и эта глобальная переменная не защищена мьютексом.</target>
        </trans-unit>
        <trans-unit id="4a3e8791cfca3d884c74337ea57def9c05ece108" translate="yes" xml:space="preserve">
          <source>Changing the value of this variable while a database connection is open can result in a corrupt database.</source>
          <target state="translated">Изменение значения этой переменной при открытом подключении к БД может привести к повреждению БД.</target>
        </trans-unit>
        <trans-unit id="ee9946c82d4a077c5be79e3015a3d2479d9fcaf2" translate="yes" xml:space="preserve">
          <source>Character</source>
          <target state="translated">Character</target>
        </trans-unit>
        <trans-unit id="cea842266549b8d9e4991a72c7996837bc0ff6f1" translate="yes" xml:space="preserve">
          <source>Characters in the matchinfo format string are processed from left to right. Each character in the format string causes one or more 32-bit unsigned integer values to be added to the returned array. The &quot;values&quot; column in the following table contains the number of integer values appended to the output buffer for each supported format string character. In the formula given,</source>
          <target state="translated">Символы в строке формата matchinfo обрабатываются слева направо.Каждый символ в строке форматирования приводит к добавлению одного или нескольких 32-битных целочисленных беззнаковых значений в возвращаемый массив.В столбце &quot;значения&quot; в следующей таблице указано количество целочисленных значений,добавляемых в выходной буфер для каждого поддерживаемого символа строки формата.В приведенной формуле,</target>
        </trans-unit>
        <trans-unit id="901d44a58ef0c59ab99643a19134ba47c238ad29" translate="yes" xml:space="preserve">
          <source>Chart 1: SQLite read latency relative to direct filesystem reads.</source>
          <target state="translated">График 1:Задержка чтения SQLite относительно прямого чтения файловой системы.</target>
        </trans-unit>
        <trans-unit id="27276d4efc029611aba60cde7d26cce5f51fc924" translate="yes" xml:space="preserve">
          <source>Chart 2: SQLite read latency relative to direct filesystem reads.</source>
          <target state="translated">График 2:Задержка чтения SQLite относительно прямого чтения файловой системы.</target>
        </trans-unit>
        <trans-unit id="9b63c13706e018a965e9ad083cf8558f0ea7a319" translate="yes" xml:space="preserve">
          <source>Chart 3: SQLite read latency relative to direct filesystem reads.</source>
          <target state="translated">График 3:Задержка чтения SQLite относительно прямого чтения файловой системы.</target>
        </trans-unit>
        <trans-unit id="d2affd8c541db58f31c69f6910d1f00260d88617" translate="yes" xml:space="preserve">
          <source>Chart 4: SQLite write latency relative to direct filesystem writes.</source>
          <target state="translated">Диаграмма 4:Задержки при записи SQLite относительно прямых записей файловой системы.</target>
        </trans-unit>
        <trans-unit id="3ac7623b08d5a3f0968ebaaaf80eef331d89a328" translate="yes" xml:space="preserve">
          <source>Chart 5: SQLite write latency relative to direct filesystem writes.</source>
          <target state="translated">Диаграмма 5:Задержки при записи SQLite относительно прямых записей файловой системы.</target>
        </trans-unit>
        <trans-unit id="145b22ca4b4508601bd80ce10219fd8d551a1cef" translate="yes" xml:space="preserve">
          <source>Chastise the body.</source>
          <target state="translated">Нарезать тело.</target>
        </trans-unit>
        <trans-unit id="0018d2d0130bb05c6b042cf37fbaadc3d3c580d7" translate="yes" xml:space="preserve">
          <source>Check local (non foreign key) constraints,</source>
          <target state="translated">Проверьте местные (не иностранные)ограничения,</target>
        </trans-unit>
        <trans-unit id="b2b621da54eb725e76b59b6aa64ddca11509ebb6" translate="yes" xml:space="preserve">
          <source>Check the cursor P1 to see if it is currently pointing at a NULL row. If it is, then set register P3 to NULL and jump immediately to P2. If P1 is not on a NULL row, then fall through without making any changes.</source>
          <target state="translated">Проверьте курсор P1,указывает ли он в данный момент на NULL строку.Если это так,то установите регистр P3 в NULL и сразу же перейдите к P2.Если P1 не наведен на NULL строку,то прыгайте,не внося никаких изменений.</target>
        </trans-unit>
        <trans-unit id="09e577018637d04e97c17b023b39748cce6a0852" translate="yes" xml:space="preserve">
          <source>Check the value in register P3. If it is NULL then &lt;a href=&quot;opcode#Halt&quot;&gt;Halt&lt;/a&gt; using parameter P1, P2, and P4 as if this were a &lt;a href=&quot;opcode#Halt&quot;&gt;Halt&lt;/a&gt; instruction. If the value in register P3 is not NULL, then this routine is a no-op. The P5 parameter should be 1.</source>
          <target state="translated">Проверьте значение в регистре P3. Если он равен NULL, то &lt;a href=&quot;opcode#Halt&quot;&gt;остановите,&lt;/a&gt; используя параметры P1, P2 и P4, как если бы это была инструкция &lt;a href=&quot;opcode#Halt&quot;&gt;Halt&lt;/a&gt; . Если значение в регистре P3 не равно NULL, то эта процедура не работает. Параметр P5 должен быть 1.</target>
        </trans-unit>
        <trans-unit id="853e2972eec38f585243beee1676c957c81ad890" translate="yes" xml:space="preserve">
          <source>Check to see if the database file has a hot journal. If the file does not have a hot journal, we are done. Return immediately. If there is a hot journal, that journal must be rolled back by the subsequent steps of this algorithm.</source>
          <target state="translated">Проверьте,есть ли в файле базы данных горячий журнал.Если в файле нет горячего журнала,мы закончили.Возвращайтесь немедленно.Если есть горячий журнал,то этот журнал должен быть откатан на последующих шагах данного алгоритма.</target>
        </trans-unit>
        <trans-unit id="a2f036a3bd46936cd9d2c40c2e45e1005b34f3dd" translate="yes" xml:space="preserve">
          <source>Checklist For Choosing The Right Database Engine</source>
          <target state="translated">Контрольный список для выбора правильного двигателя базы данных</target>
        </trans-unit>
        <trans-unit id="812e4bd3b7c47c7f81d4167d8aab871141a8c91b" translate="yes" xml:space="preserve">
          <source>Checklists</source>
          <target state="translated">Checklists</target>
        </trans-unit>
        <trans-unit id="5cb9afc05957645058216dd6772ded2e46522ec1" translate="yes" xml:space="preserve">
          <source>Checkpoint</source>
          <target state="translated">Checkpoint</target>
        </trans-unit>
        <trans-unit id="6c8f9631542e10f31e77b7a465542d388b6decdb" translate="yes" xml:space="preserve">
          <source>Checkpoint Information and Locks</source>
          <target state="translated">Информация о контрольно-пропускных пунктах и замках</target>
        </trans-unit>
        <trans-unit id="2a00fbbeacd66d1129876c4f2a120582b60dcc8f" translate="yes" xml:space="preserve">
          <source>Checkpoint Mode Values</source>
          <target state="translated">Значения режима контрольно-пропускного пункта</target>
        </trans-unit>
        <trans-unit id="f8b00f7fe2c53994a3c2e16e9fff90f46c54af6d" translate="yes" xml:space="preserve">
          <source>Checkpoint a database</source>
          <target state="translated">Контрольно-пропускной пункт база данных</target>
        </trans-unit>
        <trans-unit id="37924a2fe97c6ebb27cab5b2e8b0b2d0894bd2b5" translate="yes" xml:space="preserve">
          <source>Checkpoint as many frames as possible without waiting for any database readers or writers to finish, then sync the database file if all frames in the log were checkpointed. The &lt;a href=&quot;#sqlite3_busy_handler&quot;&gt;busy-handler callback&lt;/a&gt; is never invoked in the SQLITE_CHECKPOINT_PASSIVE mode. On the other hand, passive mode might leave the checkpoint unfinished if there are concurrent readers or writers.</source>
          <target state="translated">Проверяйте как можно больше кадров, не дожидаясь завершения работы каких-либо средств чтения или записи базы данных, затем синхронизируйте файл базы данных, если все кадры в журнале были проверены. &lt;a href=&quot;#sqlite3_busy_handler&quot;&gt;Занят обработчик обратного вызова&lt;/a&gt; никогда не вызывается в SQLITE_CHECKPOINT_PASSIVE режиме. С другой стороны, пассивный режим может оставить контрольную точку незавершенной, если есть одновременные читатели или писатели.</target>
        </trans-unit>
        <trans-unit id="65bebe73feb47e6a7a12e61f091ce204dad0258a" translate="yes" xml:space="preserve">
          <source>Checkpoint as many frames as possible without waiting for any database readers or writers to finish, then sync the database file if all frames in the log were checkpointed. The &lt;a href=&quot;busy_handler&quot;&gt;busy-handler callback&lt;/a&gt; is never invoked in the SQLITE_CHECKPOINT_PASSIVE mode. On the other hand, passive mode might leave the checkpoint unfinished if there are concurrent readers or writers.</source>
          <target state="translated">Проверяйте как можно больше кадров, не дожидаясь завершения работы каких-либо средств чтения или записи базы данных, затем синхронизируйте файл базы данных, если все кадры в журнале были проверены. &lt;a href=&quot;busy_handler&quot;&gt;Занят обработчик обратного вызова&lt;/a&gt; никогда не вызывается в SQLITE_CHECKPOINT_PASSIVE режиме. С другой стороны, пассивный режим может оставить контрольную точку незавершенной, если есть одновременные читатели или писатели.</target>
        </trans-unit>
        <trans-unit id="11999bbd94b14ea8ec845c4fcad50ea24f0a3d45" translate="yes" xml:space="preserve">
          <source>Checkpoint as many frames as possible without waiting for any database readers or writers to finish. Sync the db file if all frames in the log are checkpointed. This mode is the same as calling the &lt;a href=&quot;c3ref/wal_checkpoint&quot;&gt;sqlite3_wal_checkpoint()&lt;/a&gt; C interface. The &lt;a href=&quot;c3ref/busy_handler&quot;&gt;busy-handler callback&lt;/a&gt; is never invoked in this mode.</source>
          <target state="translated">Проверяйте как можно больше кадров, не дожидаясь завершения работы любых средств чтения или записи базы данных. Синхронизируйте файл db, если все кадры в журнале отмечены контрольными точками. Этот режим аналогичен вызову интерфейса C. &lt;a href=&quot;c3ref/wal_checkpoint&quot;&gt;sqlite3_wal_checkpoint ()&lt;/a&gt; C. &lt;a href=&quot;c3ref/busy_handler&quot;&gt;Занят обработчик обратного вызова&lt;/a&gt; никогда не вызывается в этом режиме.</target>
        </trans-unit>
        <trans-unit id="4db6d205b349663d744b71f2a117e634b9469124" translate="yes" xml:space="preserve">
          <source>Checkpoint database P1. This is a no-op if P1 is not currently in WAL mode. Parameter P2 is one of SQLITE_CHECKPOINT_PASSIVE, FULL, RESTART, or TRUNCATE. Write 1 or 0 into mem[P3] if the checkpoint returns SQLITE_BUSY or not, respectively. Write the number of pages in the WAL after the checkpoint into mem[P3+1] and the number of pages in the WAL that have been checkpointed after the checkpoint completes into mem[P3+2]. However on an error, mem[P3+1] and mem[P3+2] are initialized to -1.</source>
          <target state="translated">База данных контрольно-пропускных пунктов P1.Если P1 в данный момент не находится в режиме WAL,это означает,что он не работает.Параметр P2 является одним из SQLITE_CHECKPOINT_PASSIVE,FULL,RESTART или TRUNCATE.Запишите 1 или 0 в mem[P3],если контрольная точка возвращает SQLITE_BUSY или нет,соответственно.В mem[P3+1]запишите количество страниц в WAL после контрольной точки,а в mem[P3+2]-количество страниц в WAL,которые были записаны после завершения контрольной точки.Однако по ошибке mem[P3+1]и mem[P3+2]инициализируются на -1.</target>
        </trans-unit>
        <trans-unit id="c93c7ed9eb6c55536fc1fa5a09dd161c7c872485" translate="yes" xml:space="preserve">
          <source>Checkpoint sequence number</source>
          <target state="translated">Номер последовательности контрольно-пропускных пунктов</target>
        </trans-unit>
        <trans-unit id="73420aa2c87505947c6412ba6601937a69b34e0a" translate="yes" xml:space="preserve">
          <source>Checkpointing does require sync operations in order to avoid the possibility of database corruption following a power loss or hard reboot. The WAL must be synced to persistent storage prior to moving content from the WAL into the database and the database file must by synced prior to resetting the WAL. Checkpoint also requires more seeking. The checkpointer makes an effort to do as many sequential page writes to the database as it can (the pages are transferred from WAL to database in ascending order) but even then there will typically be many seek operations interspersed among the page writes. These factors combine to make checkpoints slower than write transactions.</source>
          <target state="translated">Контроль требует операций синхронизации,чтобы избежать возможности повреждения базы данных после потери питания или жесткой перезагрузки.Перед перемещением содержимого из WAL в базу данных WAL должен быть синхронизирован с постоянным хранилищем,а файл базы данных должен быть синхронизирован перед перезагрузкой WAL.Контрольная точка также требует более тщательного поиска.Контрольный индикатор прилагает усилия к тому,чтобы сделать как можно больше последовательных записей страниц в базу данных (страницы переносятся из WAL в базу данных в порядке возрастания),но даже в этом случае,как правило,будет много операций поиска,перемежающихся между записями страниц.Эти факторы в совокупности делают контрольно-пропускные пункты медленнее,чем операции записи.</target>
        </trans-unit>
        <trans-unit id="13a5691b3271955325bfbd27f548fc8c0c82dfae" translate="yes" xml:space="preserve">
          <source>Checkpoints initiated by this mechanism are &lt;a href=&quot;#sqlite3_wal_checkpoint_v2&quot;&gt;PASSIVE&lt;/a&gt;.</source>
          <target state="translated">Контрольные точки, инициированные этим механизмом, являются &lt;a href=&quot;#sqlite3_wal_checkpoint_v2&quot;&gt;ПАССИВНЫМИ&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ab8c79d054f22aac4eeb01b5ef4d71f862efa21c" translate="yes" xml:space="preserve">
          <source>Checkpoints initiated by this mechanism are &lt;a href=&quot;wal_checkpoint_v2&quot;&gt;PASSIVE&lt;/a&gt;.</source>
          <target state="translated">Контрольные точки, инициированные этим механизмом, являются &lt;a href=&quot;wal_checkpoint_v2&quot;&gt;ПАССИВНЫМИ&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="df9b91c031577503e347c145ff1b0094db4452ef" translate="yes" xml:space="preserve">
          <source>Checks if the &quot;fired&quot; flag has been set. If so, the unlock-notify callback has already been invoked. Release the mutex and continue.</source>
          <target state="translated">Проверяет,установлен ли флаг &quot;выстрел&quot;.Если да,то обратный вызов уведомления о разблокировке уже был вызван.Освободите мьютекс и продолжайте.</target>
        </trans-unit>
        <trans-unit id="d8fcd1cd020581d6d23f7d74cd403fc559263ad5" translate="yes" xml:space="preserve">
          <source>Checksum</source>
          <target state="translated">Checksum</target>
        </trans-unit>
        <trans-unit id="c2d50b4086a2009c1329398de62782c1b322789e" translate="yes" xml:space="preserve">
          <source>Checksum of the last frame in the WAL file.</source>
          <target state="translated">Контрольная сумма последнего кадра в файле WAL.</target>
        </trans-unit>
        <trans-unit id="36775ac61bbdc09836e15e4ec7e669eae516b3d3" translate="yes" xml:space="preserve">
          <source>Checksum-1: Cumulative checksum up through and including this page</source>
          <target state="translated">Контрольная сумма 1:Совокупная контрольная сумма вверх и в том числе эта страница</target>
        </trans-unit>
        <trans-unit id="0f0241436226dd5ad15b784282d744ddcaf53796" translate="yes" xml:space="preserve">
          <source>Checksum-1: First part of a checksum on the first 24 bytes of header</source>
          <target state="translated">Контрольная сумма 1:Первая часть контрольной суммы на первых 24 байтах заголовка</target>
        </trans-unit>
        <trans-unit id="25d65b4024e29fd560da0ace1eb3f77896847390" translate="yes" xml:space="preserve">
          <source>Checksum-2: Second half of the cumulative checksum.</source>
          <target state="translated">Контрольная сумма-2:Вторая половина совокупной контрольной суммы.</target>
        </trans-unit>
        <trans-unit id="abcb92542826823bd4a635495c66df0db032424c" translate="yes" xml:space="preserve">
          <source>Checksum-2: Second part of the checksum on the first 24 bytes of header</source>
          <target state="translated">Контрольная сумма-2:Вторая часть контрольной суммы на первых 24 байтах заголовка</target>
        </trans-unit>
        <trans-unit id="f67c2d32dbe70d2749477ec3873f70b148c33e3f" translate="yes" xml:space="preserve">
          <source>Checksumming only works on databases that have a &lt;a href=&quot;fileformat2#resbyte&quot;&gt;reserve bytes&lt;/a&gt; value of exactly 8. The default value for reserve-bytes is 0. Hence, newly created database files will omit the checksum by default. To create a database that includes a checksum, change the reserve-bytes value to 8 by running code similar to this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e6fc2f66d5cb19af415e45034e0124b71cc4cce" translate="yes" xml:space="preserve">
          <source>Cherrypick fixes for other obscure problems found since the 3.30.0 release</source>
          <target state="translated">Исправление Cherrypick для других непонятных проблем,найденных после выхода 3.30.0</target>
        </trans-unit>
        <trans-unit id="38f9d9f26118d80f3d659b4ee2e2b654e7c605c0" translate="yes" xml:space="preserve">
          <source>Choose the column names in a compound query from the left-most SELECT instead of the right-most.</source>
          <target state="translated">Выберите имена столбцов в составном запросе из крайнего левого SELECT,а не крайнего правого.</target>
        </trans-unit>
        <trans-unit id="11cfd2c677994d3ba2e81eb3cb8ff4634809c573" translate="yes" xml:space="preserve">
          <source>Choosing good indexes for each loop</source>
          <target state="translated">Выбор хороших показателей для каждого цикла</target>
        </trans-unit>
        <trans-unit id="070374ff80947b819eb8815e8d492bf0a862577e" translate="yes" xml:space="preserve">
          <source>Chronology</source>
          <target state="translated">Chronology</target>
        </trans-unit>
        <trans-unit id="b104217954a3ac451efc2e2bfb3fdea27198ddd0" translate="yes" xml:space="preserve">
          <source>Cksumvfs is a &lt;a href=&quot;vfs#shim&quot;&gt;VFS shim&lt;/a&gt;. When loaded, &quot;cksmvfs&quot; becomes the new default VFS, and it uses the prior default VFS as the next VFS down in the stack. This is normally what you want. However, in complex situations where multiple VFS shims are being loaded, it might be important to ensure that cksumvfs is loaded in the correct order so that it sequences itself into the default VFS Shim stack in the right order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d697c3a479d4940e72936c6c5796e737d83de121" translate="yes" xml:space="preserve">
          <source>Clean up comments and variable names. Changes to documentation. No functional changes to the code.</source>
          <target state="translated">Очищайте комментарии и имена переменных.Изменения в документации.Функциональные изменения в коде отсутствуют.</target>
        </trans-unit>
        <trans-unit id="719ea396ad92e01b4757ec2b93bb1e5f270f771d" translate="yes" xml:space="preserve">
          <source>Clear</source>
          <target state="translated">Clear</target>
        </trans-unit>
        <trans-unit id="7fe36a4f7ea83f99a8ac259b32e3aa3e06a3e0ea" translate="yes" xml:space="preserve">
          <source>Clearly, a hardware or operating system fault that introduces incorrect data into the middle of the database file or journal will cause problems. Likewise, if a rogue process opens a database file or journal and writes malformed data into the middle of it, then the database will become corrupt. There is not much that can be done about these kinds of problems so they are given no further attention.</source>
          <target state="translated">Очевидно,что неисправность аппаратного обеспечения или операционной системы,которая вносит неправильные данные в середину файла или журнала базы данных,вызовет проблемы.Точно так же,если неавторизованный процесс откроет файл или журнал базы данных и запишет неправильные данные в его середину,то база данных станет поврежденной.С такими проблемами не так уж и много можно сделать,поэтому им больше не уделяют внимания.</target>
        </trans-unit>
        <trans-unit id="95490bb933b1b789f5f61256736c0ee3697b1303" translate="yes" xml:space="preserve">
          <source>Client applications typically use a generic database interface that allows connections to various SQL database engines. It makes good sense to include SQLite in the mix of supported databases and to statically link the SQLite engine in with the client. That way the client program can be used standalone with an SQLite data file for testing or for demonstrations.</source>
          <target state="translated">Клиентские приложения обычно используют общий интерфейс базы данных,который позволяет подключаться к различным движкам баз данных SQL.Имеет смысл включить SQLite в состав поддерживаемых баз данных и статически связать движок SQLite с клиентом.Таким образом,клиентская программа может использоваться отдельно с файлом данных SQLite для тестирования или демонстрации.</target>
        </trans-unit>
        <trans-unit id="525256fa1745ebe5497d79cf726d90129b04804e" translate="yes" xml:space="preserve">
          <source>Client/server SQL database engines strive to implement a shared repository of enterprise data. They emphasize scalability, concurrency, centralization, and control. SQLite strives to provide local data storage for individual applications and devices. SQLite emphasizes economy, efficiency, reliability, independence, and simplicity.</source>
          <target state="translated">Двигатели SQL баз данных клиент/сервер стремятся реализовать общий репозиторий данных предприятия.Они делают упор на масштабируемость,параллельность,централизацию и контроль.SQLite стремится обеспечить локальное хранение данных для отдельных приложений и устройств.SQLite делает акцент на экономичность,эффективность,надежность,независимость и простоту.</target>
        </trans-unit>
        <trans-unit id="e1dbee15a55011ce9dd54d220174f35b9020dbef" translate="yes" xml:space="preserve">
          <source>Client/server database engines are designed to live inside a lovingly-attended datacenter at the core of the network. SQLite works there too, but SQLite also thrives at the edge of the network, fending for itself while providing fast and reliable data services to applications that would otherwise have dodgy connectivity.</source>
          <target state="translated">Двигатели баз данных клиент/сервер предназначены для жизни внутри любящего центра данных в ядре сети.SQLite тоже там работает,но SQLite также процветает на границе сети,защищаясь при этом,предоставляя быстрые и надежные сервисы данных приложениям,которые в противном случае имели бы сомнительное подключение.</target>
        </trans-unit>
        <trans-unit id="63b283ce3f8b364e187012832c04f432c579a52d" translate="yes" xml:space="preserve">
          <source>Client/server databases like MySQL, PostgreSQL, SQL Server, Oracle, and others are an important component of modern systems. These systems solve an important problem. But SQLite solves a different problem. Both SQLite and client/server databases have their role. Developers who are comparing SQLite against other SQL database engines need to clearly understand this distinction.</source>
          <target state="translated">Клиентские/серверные базы данных,такие как MySQL,PostgreSQL,SQL Server,Oracle и другие,являются важным компонентом современных систем.Эти системы решают важную проблему.Но SQLite решает другую проблему.И SQLite,и клиентские/серверные базы данных играют свою роль.Разработчикам,которые сравнивают SQLite с другими движками баз данных SQL,необходимо четко понимать это различие.</target>
        </trans-unit>
        <trans-unit id="bbfa773e5a63a5ea58c9b6207e608ca0120e592a" translate="yes" xml:space="preserve">
          <source>Close</source>
          <target state="translated">Close</target>
        </trans-unit>
        <trans-unit id="d692c2c202249e9e4fe0069f00e6bff039f0c2b5" translate="yes" xml:space="preserve">
          <source>Close A BLOB Handle</source>
          <target state="translated">Закрыть BLOB ручку</target>
        </trans-unit>
        <trans-unit id="2e50e33188cf1bf73dcb5e4643c391e4e29a00af" translate="yes" xml:space="preserve">
          <source>Close a cursor previously opened as P1. If P1 is not currently open, this instruction is a no-op.</source>
          <target state="translated">Закрыть курсор,ранее открытый как P1.Если P1 в данный момент не открыт,то данная инструкция не действует.</target>
        </trans-unit>
        <trans-unit id="0e4d537da92d49358e224a4a747dea32342b05b1" translate="yes" xml:space="preserve">
          <source>Close both cursors.</source>
          <target state="translated">Закройте оба курсора.</target>
        </trans-unit>
        <trans-unit id="29aaf7cec2af0b1f202abf31695f4cd37d74e8ff" translate="yes" xml:space="preserve">
          <source>Close the cursor.</source>
          <target state="translated">Закрой курсор.</target>
        </trans-unit>
        <trans-unit id="f1ceaea1ade786b6daac7b066c7f274b9fd722f8" translate="yes" xml:space="preserve">
          <source>Closing A Database Connection</source>
          <target state="translated">Закрытие соединения с базой данных</target>
        </trans-unit>
        <trans-unit id="e0046ff4ec6b0abe476379971c2a006ff70bf46c" translate="yes" xml:space="preserve">
          <source>Closing a Connection</source>
          <target state="translated">Закрытие соединения</target>
        </trans-unit>
        <trans-unit id="8661917419fb7cc5ef82c55b2e68e555b2266617" translate="yes" xml:space="preserve">
          <source>Closing a connection.</source>
          <target state="translated">Закрываю соединение.</target>
        </trans-unit>
        <trans-unit id="db1b559a50c46dcb478b73c9953c212ac94e2736" translate="yes" xml:space="preserve">
          <source>Closing a database connection is a simple matter. The open VFS file-handle is closed and in-memory</source>
          <target state="translated">Закрыть подключение к базе данных-дело простое.Открытая файловая ручка VFS закрыта и находится в памяти.</target>
        </trans-unit>
        <trans-unit id="7c60089a30c51b5540b0120bd48683a09f4c83f6" translate="yes" xml:space="preserve">
          <source>Clothe the naked.</source>
          <target state="translated">Одевай голого.</target>
        </trans-unit>
        <trans-unit id="bb887cae0ad4591660280c949ded3080d0ff24a8" translate="yes" xml:space="preserve">
          <source>Clustered Indexes and the WITHOUT ROWID Optimization</source>
          <target state="translated">Кластерные индексы и БЕЗОПАСНОСТЬ Оптимизации полосы пропускания</target>
        </trans-unit>
        <trans-unit id="79a91b7b9e81e75043a22ebed1514d4b90a130a5" translate="yes" xml:space="preserve">
          <source>Clustered indexes</source>
          <target state="translated">Кластерные индексы</target>
        </trans-unit>
        <trans-unit id="339841482704071d6be66d22a76e8ac915ed405e" translate="yes" xml:space="preserve">
          <source>Co-routines are better than storing the complete result set of the subquery in a transient table because co-routines use less memory. With a co-routine, only a single row of the result needs to be remembered, whereas all rows of the result must be stored for a transient table. Also, because the co-routine does not need to run to completion before the outer query begins its work, the first rows of output can appear much sooner, and if the overall query is aborted, less work is done overall.</source>
          <target state="translated">Ко-рутины лучше,чем хранение полного набора результатов в подзапросе в переходной таблице,так как ко-рутины используют меньше памяти.При ко-маршрутизации,только одна строка результата должна запоминаться,в то время как все строки результата должны храниться в переходной таблице.Кроме того,так как ко-маршрутизация не должна выполняться до завершения внешнего запроса,первые строки результата могут появиться гораздо раньше,и если общий запрос прерван,то меньше работы будет сделано в целом.</target>
        </trans-unit>
        <trans-unit id="fd74b2a71394e7ee81bb386b6917d0be84ba18b0" translate="yes" xml:space="preserve">
          <source>Code Generator</source>
          <target state="translated">Генератор кодов</target>
        </trans-unit>
        <trans-unit id="47dea711cabe6deab879a9b733dd07b05a63631b" translate="yes" xml:space="preserve">
          <source>Code Of Conduct</source>
          <target state="translated">Кодекс поведения</target>
        </trans-unit>
        <trans-unit id="74e1db16aadf744876e02c6a4f106f1aa7afb651" translate="yes" xml:space="preserve">
          <source>Code Of Ethics</source>
          <target state="translated">Этический кодекс</target>
        </trans-unit>
        <trans-unit id="ae87810899e1431de7026ce043d8dda320fed1e7" translate="yes" xml:space="preserve">
          <source>Code change inspection</source>
          <target state="translated">Проверка изменения кода</target>
        </trans-unit>
        <trans-unit id="b5a54c50fda17aa53c6eedfc8045f9c24c210470" translate="yes" xml:space="preserve">
          <source>Code changes to compile cleanly using OpenWatcom.</source>
          <target state="translated">Изменения кода для чистой компиляции с помощью OpenWatcom.</target>
        </trans-unit>
        <trans-unit id="478104ea503bb6e0eff3a5e3bdba87d5231ae12a" translate="yes" xml:space="preserve">
          <source>Code optimization and refactoring for improved performance.</source>
          <target state="translated">Оптимизация кода и рефакторинг для повышения производительности.</target>
        </trans-unit>
        <trans-unit id="c2b53cecb4c71a1d486f72dfb3a0761cddc764ad" translate="yes" xml:space="preserve">
          <source>Coincidentally, that same index is useful for locating the team leader of a particular team:</source>
          <target state="translated">Кстати,этот же индекс полезен для определения местонахождения лидера конкретной команды:</target>
        </trans-unit>
        <trans-unit id="d5e560637618ccf843afba6188e722395d88af53" translate="yes" xml:space="preserve">
          <source>CollSeq</source>
          <target state="translated">CollSeq</target>
        </trans-unit>
        <trans-unit id="bdc2214c3a09bee2f36f96131835f28a7049fea6" translate="yes" xml:space="preserve">
          <source>Collating functions only matter when comparing string values. Numeric values are always compared numerically, and BLOBs are always compared byte-by-byte using memcmp().</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d660ea76dd255d7ad9c4922511054c5e967af78f" translate="yes" xml:space="preserve">
          <source>Collating sequences are used for comparing two text strings. The collating sequence does not change the ordering of NULLs, numbers, or BLOBs, only text.</source>
          <target state="translated">Для сравнения двух текстовых строк используются коллекционные последовательности.Коллатирующая последовательность не изменяет порядок следования NULLs,чисел или BLOBs,а только текста.</target>
        </trans-unit>
        <trans-unit id="1e254a056c86801f8b560ebd071943f8829e763e" translate="yes" xml:space="preserve">
          <source>Collation Needed Callbacks</source>
          <target state="translated">Необходимые обратные вызовы</target>
        </trans-unit>
        <trans-unit id="e0c052d2751435fee70a8eb47de4eb3956e79de1" translate="yes" xml:space="preserve">
          <source>Collectively, the aPgno entries record the database page number stored in all frames of the WAL file. The aPgno[0] entry on the first hash table records the database page number stored in the very first frame in the WAL file. The aPgno[i] entry from the first hash table is the database page number for the i-th frame in the WAL file. The aPgno[k] entry for the second hash table is the database page number for the (k+4062)-th frame in the WAL file. The aPgno[k] entry for the n-th 32768-byte hash table in the shm file (for n&amp;gt;1) holds the database page number stored in the (k+4062+4096*(n-2))-th frame of the WAL file.</source>
          <target state="translated">В совокупности записи aPgno записывают номер страницы базы данных, хранящейся во всех фреймах файла WAL. Запись aPgno [0] в первой хэш-таблице записывает номер страницы базы данных, хранящейся в самом первом кадре в файле WAL. Запись aPgno [i] из первой хеш-таблицы - это номер страницы базы данных для i-го кадра в файле WAL. Запись aPgno [k] для второй хеш-таблицы - это номер страницы базы данных для (k + 4062) -го кадра в файле WAL. Запись aPgno [k] для n-й 32768-байтовой хеш-таблицы в файле shm (для n&amp;gt; 1) содержит номер страницы базы данных, хранящийся в (k + 4062 + 4096 * (n-2)) - -м кадре. файла WAL.</target>
        </trans-unit>
        <trans-unit id="d2925a5d74339b84bdd408d91b33688b6815af58" translate="yes" xml:space="preserve">
          <source>Colloquially, the Robson proof shows that in order to guarantee breakdown-free operation, any memory allocator must use a memory pool of size &lt;b&gt;N&lt;/b&gt; which exceeds the maximum amount of memory ever used &lt;b&gt;M&lt;/b&gt; by a multiplier that depends on &lt;b&gt;n&lt;/b&gt;, the ratio of the largest to the smallest allocation size. In other words, unless all memory allocations are of exactly the same size (&lt;b&gt;n&lt;/b&gt;=1) then the system needs access to more memory than it will ever use at one time. Furthermore, we see that the amount of surplus memory required grows rapidly as the ratio of largest to smallest allocations increases, and so there is strong incentive to keep all allocations as near to the same size as possible.</source>
          <target state="translated">В разговорной речи доказательство Робсона показывает, что для гарантии бесперебойной работы любой распределитель памяти должен использовать пул памяти размером &lt;b&gt;N,&lt;/b&gt; который превышает максимальный объем памяти, когда-либо использовавшейся &lt;b&gt;M&lt;/b&gt; , на множитель, который зависит от &lt;b&gt;n&lt;/b&gt; , отношения наибольшего к наименьшему размеру выделения. Другими словами, если все выделения памяти не имеют точно одинаковый размер ( &lt;b&gt;n&lt;/b&gt; = 1), тогда системе потребуется доступ к большему количеству памяти, чем она когда-либо будет использовать за один раз. Более того, мы видим, что объем требуемой избыточной памяти быстро растет по мере увеличения отношения наибольшего к наименьшему распределению, и поэтому есть сильный стимул для сохранения всех распределений как можно ближе к одному и тому же размеру.</target>
        </trans-unit>
        <trans-unit id="65ba00e95e60fb8971e699c771908e7c41d91624" translate="yes" xml:space="preserve">
          <source>Column</source>
          <target state="translated">Column</target>
        </trans-unit>
        <trans-unit id="7457b5eaf3d7bfc87797ee1a1767fe0cb49411af" translate="yes" xml:space="preserve">
          <source>Column Contents</source>
          <target state="translated">Содержание колонки</target>
        </trans-unit>
        <trans-unit id="dc9eb343792aa10d2e4b6816e5d06cae705abefb" translate="yes" xml:space="preserve">
          <source>Column Declared Type</source>
          <target state="translated">Колонка Объявленный тип</target>
        </trans-unit>
        <trans-unit id="edbb850ee1e2303abaa75179e5da0bca25a8e6e9" translate="yes" xml:space="preserve">
          <source>Column Definitions</source>
          <target state="translated">Определения столбцов</target>
        </trans-unit>
        <trans-unit id="f0e08cc3301877a460436bcf15d46df904fa1c8f" translate="yes" xml:space="preserve">
          <source>Column Name</source>
          <target state="translated">Наименование столбца</target>
        </trans-unit>
        <trans-unit id="cfbfc51b4b3062caab10bcf86299598910467bc8" translate="yes" xml:space="preserve">
          <source>Column Names In A Result Set</source>
          <target state="translated">Названия столбцов в результирующем наборе</target>
        </trans-unit>
        <trans-unit id="2a8d5de5174e3943971a2875266b6881264de3bb" translate="yes" xml:space="preserve">
          <source>Column definition</source>
          <target state="translated">Определение столбца</target>
        </trans-unit>
        <trans-unit id="087b86714eee3da08b0eea49abe7223a80fbe1f7" translate="yes" xml:space="preserve">
          <source>Column filter queries are not available.</source>
          <target state="translated">Запросы на фильтр для колонок недоступны.</target>
        </trans-unit>
        <trans-unit id="1fb21b8e379e9449d53a5880fcc60a3256a75dc9" translate="yes" xml:space="preserve">
          <source>Column filter specifications may also be applied to arbitrary expressions enclosed in parenthesis. In this case the column filter applies to all phrases within the expression. Nested column filter operations may only further restrict the subset of columns matched, they can not be used to re-enable filtered columns. For example:</source>
          <target state="translated">Спецификации колоночного фильтра могут также применяться к произвольным выражениям,заключенным в круглые скобки.В этом случае фильтр по колонкам применяется ко всем фразам внутри выражения.Вложенные операции фильтрации колонок могут только дополнительно ограничивать подмножество соответствующих колонок,они не могут быть использованы для повторного включения отфильтрованных колонок.Например:</target>
        </trans-unit>
        <trans-unit id="8cf5932e078596670c3be6928bc34be28df50868" translate="yes" xml:space="preserve">
          <source>Column names in UPDATE statements were case sensitive. This mistake has now been fixed.</source>
          <target state="translated">Названия колонок в заявлениях UPDATE были чувствительны к регистру.Теперь эта ошибка исправлена.</target>
        </trans-unit>
        <trans-unit id="c8e2e6347929b3f4a547cbe78f19fbf98ffe174e" translate="yes" xml:space="preserve">
          <source>Column names in the expressions of a DO UPDATE refer to the original unchanged value of the column, before the attempted INSERT. To use the value that would have been inserted had the constraint not failed, add the special &quot;excluded.&quot; table qualifier to the column name.</source>
          <target state="translated">Имена столбцов в выражениях DO UPDATE относятся к исходному неизмененному значению столбца,до попытки INSERT.Чтобы использовать значение,которое было бы вставлено,если бы ограничение не вышло из строя,добавьте к названию столбца специальный классификатор таблицы &quot;excluded.</target>
        </trans-unit>
        <trans-unit id="032e3b2732306732c32848d470fa8748f95c6026" translate="yes" xml:space="preserve">
          <source>Column zColumn does not exist,</source>
          <target state="translated">Колонка zКолонка не существует,</target>
        </trans-unit>
        <trans-unit id="ce5679997a2153bf86b8f374126d7b829b91fac4" translate="yes" xml:space="preserve">
          <source>Column zColumn is part of an index, PRIMARY KEY or UNIQUE constraint and the blob is being opened for read/write access,</source>
          <target state="translated">Колонка zColumn является частью индекса,ограничения PRIMARY KEY или UNIQUE и блок открывается для доступа на чтение/запись,</target>
        </trans-unit>
        <trans-unit id="e8afcd3f4d854da704b3aef5efd35d7f5bc218f3" translate="yes" xml:space="preserve">
          <source>Column-separator is an optional column separator string. The default is the ASCII tab character \t.</source>
          <target state="translated">Разделитель столбцов-это дополнительная строка разделителя столбцов.По умолчанию используется символ ASCII-табуляции \t.</target>
        </trans-unit>
        <trans-unit id="cf723c59b62a173547c39c3d661c4ee7c240bab1" translate="yes" xml:space="preserve">
          <source>Columns</source>
          <target state="translated">Columns</target>
        </trans-unit>
        <trans-unit id="56b17410d6d1be4171831dc03181ac757a05e7fe" translate="yes" xml:space="preserve">
          <source>Columns of type INTEGER PRIMARY KEY are actually used as the primary key in underlying B-Tree representation of the table.</source>
          <target state="translated">Столбцы типа INTEGER PRIMARY KEY фактически используются в качестве первичного ключа в базовом B-дереве представления таблицы.</target>
        </trans-unit>
        <trans-unit id="2c97a82dbca5a469c866fbcfd4a0a433b2a0bbf3" translate="yes" xml:space="preserve">
          <source>ColumnsUsed</source>
          <target state="translated">ColumnsUsed</target>
        </trans-unit>
        <trans-unit id="7dbd619aad6c366ee15f8ec72b738cda247ce874" translate="yes" xml:space="preserve">
          <source>Combine the implementations of LIKE and GLOB into a single pattern-matching subroutine.</source>
          <target state="translated">Объедините реализации LIKE и GLOB в единую подпрограмму,соответствующую шаблону.</target>
        </trans-unit>
        <trans-unit id="1f542b583ad5e9c038e3b491fcfbca274b74980c" translate="yes" xml:space="preserve">
          <source>Combining all the code for SQLite into one big file makes SQLite easier to deploy &amp;mdash; there is just one file to keep track of. And because all code is in a single translation unit, compilers can do better inter-procedure optimization resulting in machine code that is between 5% and 10% faster.</source>
          <target state="translated">Объединение всего кода для SQLite в один большой файл упрощает развертывание SQLite - нужно отслеживать только один файл. А поскольку весь код находится в одной единице трансляции, компиляторы могут лучше выполнять оптимизацию между процедурами, что приводит к тому, что машинный код работает на 5-10% быстрее.</target>
        </trans-unit>
        <trans-unit id="833e395a74a9048d3a6708096c9bceb3c4d61ab8" translate="yes" xml:space="preserve">
          <source>Comes with a standalone &lt;a href=&quot;cli&quot;&gt;command-line interface&lt;/a&gt; (CLI) client that can be used to administer SQLite databases.</source>
          <target state="translated">Поставляется с автономным клиентом &lt;a href=&quot;cli&quot;&gt;интерфейса командной строки&lt;/a&gt; (CLI), который можно использовать для администрирования баз данных SQLite.</target>
        </trans-unit>
        <trans-unit id="606ffe665dbeafe4183539a3e178cfb9ca0e425d" translate="yes" xml:space="preserve">
          <source>Command Line Shell For SQLite</source>
          <target state="translated">Оболочка командной строки для SQLite</target>
        </trans-unit>
        <trans-unit id="fce06e20e5f7f74aacccab40b59b75a56c8f7305" translate="yes" xml:space="preserve">
          <source>Comments</source>
          <target state="translated">Comments</target>
        </trans-unit>
        <trans-unit id="0538dff4886a4148d161292cddf7f24f025bd278" translate="yes" xml:space="preserve">
          <source>Comments are not SQL commands, but can occur within the text of SQL queries passed to &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; and related interfaces. Comments are treated as whitespace by the parser. Comments can begin anywhere whitespace can be found, including inside expressions that span multiple lines.</source>
          <target state="translated">Комментарии не являются командами SQL, но могут встречаться в тексте запросов SQL, передаваемых в &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; и связанные интерфейсы. Комментарии обрабатываются анализатором как пробелы. Комментарии могут начинаться в любом месте, где есть пробелы, в том числе внутри выражений, охватывающих несколько строк.</target>
        </trans-unit>
        <trans-unit id="ce2337551468efeca0ed2bee143ae11b7529f35e" translate="yes" xml:space="preserve">
          <source>Comments can appear anywhere whitespace can occur, including inside expressions and in the middle of other SQL statements. Comments do not nest.</source>
          <target state="translated">Комментарии могут появляться в любом месте,в том числе внутри выражений и в середине других SQL выражений.Комментарии не вложены.</target>
        </trans-unit>
        <trans-unit id="ffc61bb49c86bffaff083a2ed5fcbad20841a45a" translate="yes" xml:space="preserve">
          <source>Commit And Rollback Notification Callbacks</source>
          <target state="translated">Обязательное и обратное уведомление Обратные вызовы</target>
        </trans-unit>
        <trans-unit id="b67528525c7cbe3a2bdfe091a15601f0cfe434dc" translate="yes" xml:space="preserve">
          <source>Commit the transaction started in step 2.</source>
          <target state="translated">Совершение сделки начинается на шаге 2.</target>
        </trans-unit>
        <trans-unit id="3e921ad8fb3469be1c1aae1e9c542f259ea843f7" translate="yes" xml:space="preserve">
          <source>Commit the transaction started on step 1 above.</source>
          <target state="translated">Совершите сделку,начатую на шаге 1 выше.</target>
        </trans-unit>
        <trans-unit id="dcb41d75c37afedd19b91ddeac8ef4a861184289" translate="yes" xml:space="preserve">
          <source>Committing a</source>
          <target state="translated">Совершение</target>
        </trans-unit>
        <trans-unit id="ca50d239d0c5f707752157b74490a4762cc31cc1" translate="yes" xml:space="preserve">
          <source>Committing a Transaction</source>
          <target state="translated">Совершение сделки</target>
        </trans-unit>
        <trans-unit id="a6b2b4078078c94d88c10ba671b8570bcd19b64c" translate="yes" xml:space="preserve">
          <source>Committing a multi-file transaction.</source>
          <target state="translated">Совершение многофайловой сделки.</target>
        </trans-unit>
        <trans-unit id="938c8ff92d76193cdabf706c7c9bd4d6322fdb0d" translate="yes" xml:space="preserve">
          <source>Committing a read-write transaction.</source>
          <target state="translated">Совершение операции чтения и записи.</target>
        </trans-unit>
        <trans-unit id="7f07598efa7d083be720757f9b4819e013d7faa3" translate="yes" xml:space="preserve">
          <source>Committing a statement transaction.</source>
          <target state="translated">Совершить операцию с заявлением.</target>
        </trans-unit>
        <trans-unit id="3d0965b4050b33d43b6f8f1d0b90555ef5b6f358" translate="yes" xml:space="preserve">
          <source>Common Table Expressions or CTEs act like temporary &lt;a href=&quot;lang_createview&quot;&gt;views&lt;/a&gt; that exist only for the duration of a single SQL statement. There are two kinds of common table expressions: &quot;ordinary&quot; and &quot;recursive&quot;. Ordinary common table expressions are helpful for making queries easier to understand by factoring subqueries out of the main SQL statement. Recursive common table expressions provide the ability to do hierarchical or recursive queries of trees and graphs, a capability that is not otherwise available in the SQL language.</source>
          <target state="translated">Общие табличные выражения или CTE действуют как временные &lt;a href=&quot;lang_createview&quot;&gt;представления,&lt;/a&gt; которые существуют только в течение одного оператора SQL. Есть два типа общих табличных выражений: &amp;laquo;обычные&amp;raquo; и &amp;laquo;рекурсивные&amp;raquo;. Обычные общие табличные выражения помогают упростить понимание запросов за счет выделения подзапросов из основного оператора SQL. Рекурсивные общие табличные выражения предоставляют возможность выполнять иерархические или рекурсивные запросы к деревьям и графам - возможность, которая иначе недоступна в языке SQL.</target>
        </trans-unit>
        <trans-unit id="8d105cf44d3926289e65c1c83d8e37cb23fd049e" translate="yes" xml:space="preserve">
          <source>Compare</source>
          <target state="translated">Compare</target>
        </trans-unit>
        <trans-unit id="61bf40991dc6cf79e005a417dde1c212c92bf988" translate="yes" xml:space="preserve">
          <source>Compare the ages of two snapshot handles</source>
          <target state="translated">Сравните возраст двух ручек для снимков.</target>
        </trans-unit>
        <trans-unit id="c69b8e330786eb35150cb1cdb917926c81985161" translate="yes" xml:space="preserve">
          <source>Compare the ages of two snapshot handles.</source>
          <target state="translated">Сравните возраст двух ручек для снимков.</target>
        </trans-unit>
        <trans-unit id="b7893f36396a39c33c9b065563149f1fc3b7de3a" translate="yes" xml:space="preserve">
          <source>Compare the values in register P1 and P3. If reg(P3)&amp;lt;reg(P1) then jump to address P2. Or if the SQLITE_STOREP2 flag is set in P5 store the result of comparison (0 or 1 or NULL) into register P2.</source>
          <target state="translated">Сравните значения в регистре P1 и P3. Если reg (P3) &amp;lt;reg (P1), перейдите к адресу P2. Или, если в P5 установлен флаг SQLITE_STOREP2, сохраните результат сравнения (0 или 1 или NULL) в регистре P2.</target>
        </trans-unit>
        <trans-unit id="64f72da6a28852747af852811f0159350ec037fd" translate="yes" xml:space="preserve">
          <source>Compare the values in register P1 and P3. If reg(P3)==reg(P1) then jump to address P2. Or if the SQLITE_STOREP2 flag is set in P5, then store the result of comparison in register P2.</source>
          <target state="translated">Сравните значения в регистре P1 и P3.Если reg(P3)==reg(P1),то переходите к адресу P2.Или если флаг SQLITE_STOREP2 установлен в P5,то сохранить результат сравнения в регистре P2.</target>
        </trans-unit>
        <trans-unit id="716736d76052378cdb4fa2fb220c0af66c296429" translate="yes" xml:space="preserve">
          <source>Compare two vectors of registers in reg(P1)..reg(P1+P3-1) (call this vector &quot;A&quot;) and in reg(P2)..reg(P2+P3-1) (&quot;B&quot;). Save the result of the comparison for use by the next &lt;a href=&quot;opcode#Jump&quot;&gt;Jump&lt;/a&gt; instruct.</source>
          <target state="translated">Сравните два вектора регистров в регистрах reg (P1) .. reg (P1 + P3-1) (назовите этот вектор &quot;A&quot;) и в reg (P2) .. reg (P2 + P3-1) (&quot;B&quot;). Сохраните результат сравнения для использования в следующей инструкции &lt;a href=&quot;opcode#Jump&quot;&gt;Jump&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="83d5898be3634e470654cbd85b9deec85a9c9f73" translate="yes" xml:space="preserve">
          <source>Comparison affinity rules</source>
          <target state="translated">Правила сравнения сродства</target>
        </trans-unit>
        <trans-unit id="134badaaa974d64bb5437d6b34d1293f7d86554c" translate="yes" xml:space="preserve">
          <source>Comparison expressions</source>
          <target state="translated">Сравнение выражений</target>
        </trans-unit>
        <trans-unit id="8f31c13dc4b4da5bf8cbe8bac8ef033f779731d8" translate="yes" xml:space="preserve">
          <source>Comparison with fts4</source>
          <target state="translated">Сравнение с fts4</target>
        </trans-unit>
        <trans-unit id="5d60c7dd62fdcf4abcc61a6a7d335b7117968b4d" translate="yes" xml:space="preserve">
          <source>Compatibility</source>
          <target state="translated">Compatibility</target>
        </trans-unit>
        <trans-unit id="7637a56b8025cf4632b2ae465571d61372b6d40e" translate="yes" xml:space="preserve">
          <source>Compatibility node: Prior to SQLite version 3.28.0 (2019-04-16) only the --update option was supported but that option worked like --insert in that it always reinserted every file regardless of whether or not it had changed.</source>
          <target state="translated">Узел совместимости:До версии SQLite 3.28.0 (2019-04-16)поддерживалась только опция --update,но эта опция работала как --insert в том,что она всегда переустанавливала каждый файл,независимо от того,изменился он или нет.</target>
        </trans-unit>
        <trans-unit id="633ffa201e66fd459288742adf70c255cf4ddcdc" translate="yes" xml:space="preserve">
          <source>Compile SQLite in an as-delivered configuration, without any special telemetry or debugging options.</source>
          <target state="translated">Скомпилируйте SQLite в конфигурации по мере поступления,без каких-либо специальных опций телеметрии или отладки.</target>
        </trans-unit>
        <trans-unit id="4435f0088179f3879b5ae857aab9a8517a3bf84a" translate="yes" xml:space="preserve">
          <source>Compile SQLite using the &lt;a href=&quot;compile#trusted_schema&quot;&gt;-DSQLITE_TRUSTED_SCHEMA=0&lt;/a&gt; compile-time option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47c942ddb7cb0b2c2a634cd495a4fe44be7c77ab" translate="yes" xml:space="preserve">
          <source>Compile SQLite using the &lt;a href=&quot;compile#trusted_schema&quot;&gt;-DSQLITE_TRUSTED_SCHEMA=0&lt;/a&gt; compile-time option. This make SQLite distrust application-defined functions inside of the schema by default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a5b8e5cc0e47f26d2d005f2486e0f5c2a2c206c" translate="yes" xml:space="preserve">
          <source>Compile fts</source>
          <target state="translated">Компилировать штуки</target>
        </trans-unit>
        <trans-unit id="107e25274d1b787330bb17ec68cf503455bc4672" translate="yes" xml:space="preserve">
          <source>Compile the SQLite library with the either the compile-time options &lt;a href=&quot;compile#enable_8_3_names&quot;&gt;SQLITE_ENABLE_8_3_NAMES=1&lt;/a&gt; or &lt;a href=&quot;compile#enable_8_3_names&quot;&gt;SQLITE_ENABLE_8_3_NAMES=2&lt;/a&gt;. Support for 8+3 filenames is not included in SQLite by default because it does introduce some overhead. The overhead is tiny, but even so, we do not want to burden the billions of SQLite applications that do not need 8+3 filename support.</source>
          <target state="translated">Скомпилируйте библиотеку SQLite с параметрами времени компиляции &lt;a href=&quot;compile#enable_8_3_names&quot;&gt;SQLITE_ENABLE_8_3_NAMES = 1&lt;/a&gt; или &lt;a href=&quot;compile#enable_8_3_names&quot;&gt;SQLITE_ENABLE_8_3_NAMES = 2&lt;/a&gt; . Поддержка 8 + 3 имен файлов по умолчанию не включена в SQLite, потому что это приводит к некоторым накладным расходам. Накладные расходы незначительны, но даже в этом случае мы не хотим перегружать миллиарды приложений SQLite, которым не требуется поддержка файлов 8 + 3.</target>
        </trans-unit>
        <trans-unit id="c8149cd52fe785ecf8f59126442a4f04b3761167" translate="yes" xml:space="preserve">
          <source>Compile-Time Authorization Callbacks</source>
          <target state="translated">Обратные вызовы авторизации компиляции времени</target>
        </trans-unit>
        <trans-unit id="5ce286997996977a2b237b29a86f8db1efc35204" translate="yes" xml:space="preserve">
          <source>Compile-Time Library Version Numbers</source>
          <target state="translated">Номер версии библиотеки &quot;Скомпилируй время</target>
        </trans-unit>
        <trans-unit id="ab7d35e46c49beab638f326c5a28b5f3ad2b8c85" translate="yes" xml:space="preserve">
          <source>Compile-time Options</source>
          <target state="translated">Опции времени компиляции</target>
        </trans-unit>
        <trans-unit id="1453f0519dea087605be7dc19703a1f478ff0ab3" translate="yes" xml:space="preserve">
          <source>Compile-time options OS_UNIX, OS_WIN, OS_OS2, OS_OTHER, and TEMP_STORE have been renamed to include an &quot;SQLITE_&quot; prefix in order to help avoid namespace collisions with application software. The new names of these options are respectively: SQLITE_OS_UNIX, SQLITE_OS_WIN, SQLITE_OS_OS2, SQLITE_OS_OTHER, and &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt;.</source>
          <target state="translated">Параметры времени компиляции OS_UNIX, OS_WIN, OS_OS2, OS_OTHER и TEMP_STORE были переименованы, чтобы включать префикс &amp;laquo;SQLITE_&amp;raquo;, чтобы помочь избежать конфликтов пространства имен с прикладным программным обеспечением. Новые имена этих параметров соответственно: SQLITE_OS_UNIX, SQLITE_OS_WIN, SQLITE_OS_OS2, SQLITE_OS_OTHER и &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b67395ae5988ac5f1079e7140abc23ed771501d4" translate="yes" xml:space="preserve">
          <source>Compile-time options to SQLite are controlled by C-preprocessor macros. SQLite version 3.6.0 changes the names of some of these macros so that all C-preprocessor macros that are specific to SQLite begin with the &quot;SQLITE_&quot; prefix. This is done to reduce the risk of name collisions with other software modules.</source>
          <target state="translated">Опции компиляции времени в SQLite контролируются макросами C-препроцессора.SQLite версии 3.6.0 изменяет имена некоторых из этих макросов таким образом,что все макросы C-препроцессора,специфичные для SQLite,начинаются с префикса &quot;SQLITE_&quot;.Это сделано для того,чтобы снизить риск столкновения имен с другими модулями программного обеспечения.</target>
        </trans-unit>
        <trans-unit id="7bfb67af50943c68cc8db4a086f448c070c20b10" translate="yes" xml:space="preserve">
          <source>Compiling An SQL Statement</source>
          <target state="translated">Компиляция SQL-оператора</target>
        </trans-unit>
        <trans-unit id="5aad775a4fde57c9a7d789da7ebb4f28bacbccb3" translate="yes" xml:space="preserve">
          <source>Compiling Loadable Extensions</source>
          <target state="translated">Комплектующие Загрузочные удлинители</target>
        </trans-unit>
        <trans-unit id="17dae604367670c84a2179095a23e948fe606538" translate="yes" xml:space="preserve">
          <source>Compiling the CLI</source>
          <target state="translated">Составление ИЗО</target>
        </trans-unit>
        <trans-unit id="42bc083c37979291f51503e346021e5adf7ef736" translate="yes" xml:space="preserve">
          <source>Compiling the TCL interface</source>
          <target state="translated">Компиляция интерфейса TCL</target>
        </trans-unit>
        <trans-unit id="f6b7336de511d34be1007604b55dc1686fbabd26" translate="yes" xml:space="preserve">
          <source>Compiling with GCC and -Os results in a binary that is slightly less than 500KB in size. (Update 2018-07-07: Due to the addition of new features such as &lt;a href=&quot;lang_upsert&quot;&gt;UPSERT&lt;/a&gt; and &lt;a href=&quot;windowfunctions&quot;&gt;window functions&lt;/a&gt;, the library footprint is now slightly larger than 500KB.)</source>
          <target state="translated">Компиляция с использованием GCC и -Os приводит к получению двоичного файла размером чуть меньше 500 КБ. (Обновление 2018-07-07: из-за добавления новых функций, таких как &lt;a href=&quot;lang_upsert&quot;&gt;UPSERT&lt;/a&gt; и &lt;a href=&quot;windowfunctions&quot;&gt;оконные функции&lt;/a&gt; , объем библиотеки теперь немного превышает 500 КБ.)</target>
        </trans-unit>
        <trans-unit id="016600cc08f9b09c5ede26e00051860d386d3258" translate="yes" xml:space="preserve">
          <source>Completely disable all mutexing for use in single-threaded applications.</source>
          <target state="translated">Полностью отключите все виды мьютексинга для использования в однопоточных приложениях.</target>
        </trans-unit>
        <trans-unit id="92cab31e763f04f0a9379d06fa22ebdf435b210d" translate="yes" xml:space="preserve">
          <source>Completion = 100% * (pagecount() - remaining()) / pagecount()</source>
          <target state="translated">Completion=100%*(pagecount()-remaining())/pagecount()</target>
        </trans-unit>
        <trans-unit id="0e8198cb08e14211a17b2113a2bd05ad2475de6d" translate="yes" xml:space="preserve">
          <source>Complex SQL queries that compile down to large &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statements&lt;/a&gt;.</source>
          <target state="translated">Сложные SQL-запросы, которые компилируются в большие &lt;a href=&quot;c3ref/stmt&quot;&gt;подготовленные операторы&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2a71a43f0af5e946760833a731194bc756332728" translate="yes" xml:space="preserve">
          <source>Component tables must not be declared WITHOUT ROWID, and must all have the same schema, but may have different names within their databases. In this context, &quot;the same schema&quot; means that:</source>
          <target state="translated">Таблицы компонентов не должны объявляться БЕЗ РОУИДА,и все они должны иметь одну и ту же схему,но могут иметь разные имена в своих базах данных.В этом контексте &quot;одна и та же схема&quot; означает это:</target>
        </trans-unit>
        <trans-unit id="73fefbebc7ea5875c1b1def30f50ddaec200fca3" translate="yes" xml:space="preserve">
          <source>Compound SELECT Statements</source>
          <target state="translated">ВЫБОР СООТВЕТСТВУЮЩИХ ОТЧЕТСТВЕННОСТЕЙ</target>
        </trans-unit>
        <trans-unit id="fc1dbf04d5c2c01646f4f6f5a41a610a2c9e6452" translate="yes" xml:space="preserve">
          <source>Compound SELECT statements joined by UNION, EXCEPT, or INTERSECT</source>
          <target state="translated">Составные заявления о выборе,к которым присоединились ЮНИОН,ИСКЛЮЧЕНИЕ или ВВЕДЕНИЕ</target>
        </trans-unit>
        <trans-unit id="b777b90633cd6198da59fc74556aaf318e15c82b" translate="yes" xml:space="preserve">
          <source>Compound Select Statements</source>
          <target state="translated">Выборочные заявления</target>
        </trans-unit>
        <trans-unit id="41afde278d24cef38341e9c639a6f290a66a33e9" translate="yes" xml:space="preserve">
          <source>Compound select</source>
          <target state="translated">Выберите состав</target>
        </trans-unit>
        <trans-unit id="e99b67d469ceb0e0903f3fdb83544c4883bac6aa" translate="yes" xml:space="preserve">
          <source>Compressed FTS4 content</source>
          <target state="translated">Сжатое содержимое FTS4</target>
        </trans-unit>
        <trans-unit id="d750266cb42e04add18c2049e2c2458292889a29" translate="yes" xml:space="preserve">
          <source>Compute all columns for the current row of the result.</source>
          <target state="translated">Вычислите все столбцы для текущей строки результата.</target>
        </trans-unit>
        <trans-unit id="83c78585de25cd96c1c2ab80c2c2412af55dbfdf" translate="yes" xml:space="preserve">
          <source>Compute the Mandelbrot set</source>
          <target state="translated">Рассчитайте набор Мандельброта</target>
        </trans-unit>
        <trans-unit id="b448f9527d237644e1fc4a194d188e6a4b4d1334" translate="yes" xml:space="preserve">
          <source>Compute the current date.</source>
          <target state="translated">Вычислите текущую дату.</target>
        </trans-unit>
        <trans-unit id="41873a1f5500f4b614234079571f3016e43ab82f" translate="yes" xml:space="preserve">
          <source>Compute the current unix timestamp.</source>
          <target state="translated">Вычислите текущую метку времени unix.</target>
        </trans-unit>
        <trans-unit id="e04bc35c7b102a71d56a8c32d3bd5fac01970545" translate="yes" xml:space="preserve">
          <source>Compute the date and time given a unix timestamp 1092941466, and compensate for your local timezone.</source>
          <target state="translated">Вычислите дату и время с уникальной меткой времени 1092941466 и компенсируйте местный часовой пояс.</target>
        </trans-unit>
        <trans-unit id="a79ce5022e7222955180721f104a747e76cc865d" translate="yes" xml:space="preserve">
          <source>Compute the date and time given a unix timestamp 1092941466.</source>
          <target state="translated">Вычислите дату и время с уникальной меткой времени 1092941466.</target>
        </trans-unit>
        <trans-unit id="876432c3d5981b5bb35c00fb0bc71a0643cea495" translate="yes" xml:space="preserve">
          <source>Compute the date of the first Tuesday in October for the current year.</source>
          <target state="translated">Рассчитайте дату первого вторника октября для текущего года.</target>
        </trans-unit>
        <trans-unit id="85e08c9c66c5c14d3d7f7fdaf91b03031363b7fc" translate="yes" xml:space="preserve">
          <source>Compute the hash value: h = P * 383</source>
          <target state="translated">Вычислить хэш-значение:h=P*383</target>
        </trans-unit>
        <trans-unit id="7548a41024e6603fd25f9fadf45476eb046bf623" translate="yes" xml:space="preserve">
          <source>Compute the last day of the current month.</source>
          <target state="translated">Вычислите последний день текущего месяца.</target>
        </trans-unit>
        <trans-unit id="1c0a0d1208aea03d34c1fcb88dbad15854e8464f" translate="yes" xml:space="preserve">
          <source>Compute the number of days since the signing of the US Declaration of Independence.</source>
          <target state="translated">Рассчитайте количество дней,прошедших с момента подписания Декларации независимости США.</target>
        </trans-unit>
        <trans-unit id="5d82004a2aadc6ec6baebba8982b8bfbd8ed18a8" translate="yes" xml:space="preserve">
          <source>Compute the number of seconds since a particular moment in 2004:</source>
          <target state="translated">Вычислите количество секунд,прошедших с того или иного момента в 2004 году:</target>
        </trans-unit>
        <trans-unit id="9240e490f170f5bfe9b5ac2684f082567e717920" translate="yes" xml:space="preserve">
          <source>Compute the remainder after integer register P2 is divided by register P1 and store the result in register P3. If the value in register P1 is zero the result is NULL. If either operand is NULL, the result is NULL.</source>
          <target state="translated">Вычислите остаток после того,как целочисленный регистр P2 делится на регистр P1 и сохраняет результат в регистре P3.Если значение в регистре P1 равно нулю,то результат будет NULL.Если любой из операндов имеет значение NULL,то результат будет NULL.</target>
        </trans-unit>
        <trans-unit id="f47380023b575b27550d43814811cc725e477ad2" translate="yes" xml:space="preserve">
          <source>Compute the time since the unix epoch in seconds (like strftime('%s','now') except includes fractional part):</source>
          <target state="translated">Вычисляет время с эпохи unix в секундах (как strftime('%s','now'),за исключением дробной части):</target>
        </trans-unit>
        <trans-unit id="e144db42c7fe7841a847f92a642087b247050e3f" translate="yes" xml:space="preserve">
          <source>Compute the transitive closure of a set.</source>
          <target state="translated">Рассчитайте переходное закрытие набора.</target>
        </trans-unit>
        <trans-unit id="6ad79ab6353b1eee8ebbc085e10d17c4fcfb024f" translate="yes" xml:space="preserve">
          <source>Concat</source>
          <target state="translated">Concat</target>
        </trans-unit>
        <trans-unit id="bbae6853fb6e0fd40e4ce00a77adbb0072630198" translate="yes" xml:space="preserve">
          <source>Concatenate Two Changeset Objects</source>
          <target state="translated">Сосредоточить два объекта изменения</target>
        </trans-unit>
        <trans-unit id="dbcb0f9023d09dcdfc6e54ecf5de70332ecf46a5" translate="yes" xml:space="preserve">
          <source>Conceptually, the wal-index is shared memory, though the current VFS implementations use a memory-mapped file for operating-system portability. The memory-mapped file is in the same directory as the database and has the same name as the database with a &quot;&lt;code&gt;-shm&lt;/code&gt;&quot; suffix appended. Because the wal-index is shared memory, SQLite does not support &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;journal_mode=WAL&lt;/a&gt; on a network filesystem when clients are on different machines, as all clients of the database must be able to share the same memory.</source>
          <target state="translated">Концептуально wal-index - это разделяемая память, хотя текущие реализации VFS используют файл с отображением памяти для переносимости операционной системы. &lt;code&gt;-shm&lt;/code&gt; память файл находится в том же каталоге, что и база данных, и имеет то же имя, что и база данных, с добавленным суффиксом &amp;laquo; -shm &amp;raquo;. Поскольку wal-index является разделяемой памятью, SQLite не поддерживает &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;journal_mode = WAL&lt;/a&gt; в сетевой файловой системе, когда клиенты находятся на разных машинах, поскольку все клиенты базы данных должны иметь возможность совместно использовать одну и ту же память.</target>
        </trans-unit>
        <trans-unit id="49b7441ed47d615d68b5fa69e66989fb88012252" translate="yes" xml:space="preserve">
          <source>Conceptually, there is just a single DELETE-mode lock. The DELETE-mode lock for a single database connection can be in exactly one of the following states:</source>
          <target state="translated">Концептуально,есть только один замок режима DELETE.Блокировка режима DELETE для одного соединения с БД может находиться точно в одном из следующих состояний:</target>
        </trans-unit>
        <trans-unit id="e39262defe80a83fac1b793497417432c8b1a879" translate="yes" xml:space="preserve">
          <source>Conclusion</source>
          <target state="translated">Conclusion</target>
        </trans-unit>
        <trans-unit id="7a3f4c2c7a172166630a7d362c10fe1d0fc91c29" translate="yes" xml:space="preserve">
          <source>Concurrent Use By Multiple Processes</source>
          <target state="translated">Одновременное использование несколькими процессами</target>
        </trans-unit>
        <trans-unit id="eef82957c155636f622355147508a53bea076447" translate="yes" xml:space="preserve">
          <source>Configurable edit distances</source>
          <target state="translated">Настраиваемые расстояния редактирования</target>
        </trans-unit>
        <trans-unit id="b8577c99aaca7f628cb921ee68fce4bf962909c4" translate="yes" xml:space="preserve">
          <source>Configuration Options</source>
          <target state="translated">Опции конфигурации</target>
        </trans-unit>
        <trans-unit id="e6080fcd15996fc8da790077d2f333df934dd233" translate="yes" xml:space="preserve">
          <source>Configuration continues to use the SQLITE_DBCONFIG_LOOKASIDE or SQLITE_CONFIG_LOOKASIDE configuration options, as described above, with parameters &quot;sz&quot; and &quot;cnt&quot;. The total heap space used for lookaside continues to be sz*cnt bytes. But the space is allocated between the small-slot lookaside and big-slot lookaside, with preference given to small-slot lookaside. The total number of slots will usually exceed &quot;cnt&quot;, since &quot;sz&quot; is typically much larger than the small-slot size of 128 bytes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d3a088dea7acb9fc65cbb6e86dc351c6aa1d47c" translate="yes" xml:space="preserve">
          <source>Configure a changeset rebaser object</source>
          <target state="translated">Настройка объекта rebaser changeet</target>
        </trans-unit>
        <trans-unit id="c2e506c363291ec2edbc4c00e46f58bf68ba2d4e" translate="yes" xml:space="preserve">
          <source>Configure a changeset rebaser object.</source>
          <target state="translated">Настройте объект rebaser changeet.</target>
        </trans-unit>
        <trans-unit id="1cfd39d93ce243f8209e2cb0fd6a72bd5199a441" translate="yes" xml:space="preserve">
          <source>Configure an auto-checkpoint</source>
          <target state="translated">Настройте автоматическую точку проверки</target>
        </trans-unit>
        <trans-unit id="5cda84f2fffb92ec6200fae3e17f21d369027339" translate="yes" xml:space="preserve">
          <source>Configure database connections</source>
          <target state="translated">Настройка соединений с базами данных</target>
        </trans-unit>
        <trans-unit id="9104fdd73ba3ec2b0c456f6d3cca5876e340e73f" translate="yes" xml:space="preserve">
          <source>Configure global parameters</source>
          <target state="translated">Настройка глобальных параметров</target>
        </trans-unit>
        <trans-unit id="fffa5ae7207c4ce72ae9a5c16488369d68b30ee7" translate="yes" xml:space="preserve">
          <source>Configure the changeset rebaser object to rebase changesets according to the conflict resolutions described by buffer pRebase (size nRebase bytes), which must have been obtained from a previous call to sqlite3changeset_apply_v2().</source>
          <target state="translated">Настройте объект changeset rebase на rebase changeset в соответствии с разрешениями конфликтов,описанными буфером pRebase (размер байт nRebase),который должен был быть получен из предыдущего вызова sqlite3changeset_apply_v2().</target>
        </trans-unit>
        <trans-unit id="037fffb22a00fbc77fceb8bfd136c7237a83b229" translate="yes" xml:space="preserve">
          <source>Configuring Memory-Mapped I/O</source>
          <target state="translated">Настройка отображенных в памяти входов/выходов</target>
        </trans-unit>
        <trans-unit id="9d3bc7d832ae044f63c47a2f9e7fae292f78d77f" translate="yes" xml:space="preserve">
          <source>Configuring The SQLite Library</source>
          <target state="translated">Настройка библиотеки SQLite</target>
        </trans-unit>
        <trans-unit id="3479acef100487d6ec8205ddc884e90381568fa7" translate="yes" xml:space="preserve">
          <source>Configuring an ON UPDATE or ON DELETE action does not mean that the foreign key constraint does not need to be satisfied. For example, if an &quot;ON DELETE SET DEFAULT&quot; action is configured, but there is no row in the parent table that corresponds to the default values of the child key columns, deleting a parent key while dependent child keys exist still causes a foreign key violation. For example:</source>
          <target state="translated">Настройка действия ON UPDATE или ON DELETE не означает,что иностранный ключ не должен быть удовлетворен.Например,если действие &quot;ON DELETE SET DEFAULT&quot; сконфигурировано,но в родительской таблице нет строки,соответствующей значениям по умолчанию столбцов дочерних ключей,то удаление родительского ключа при наличии зависимых дочерних ключей все равно приводит к нарушению внешнего ключа.Например:</target>
        </trans-unit>
        <trans-unit id="377ada5c437e4e8ecbb86b359c764c7d510c3e88" translate="yes" xml:space="preserve">
          <source>Conflict Resolution Algorithms</source>
          <target state="translated">Алгоритмы разрешения конфликтов</target>
        </trans-unit>
        <trans-unit id="8975355354bcb513bcd2981e89b88a2159127a86" translate="yes" xml:space="preserve">
          <source>Conflict resolution modes</source>
          <target state="translated">Режимы разрешения конфликтов</target>
        </trans-unit>
        <trans-unit id="9658bf354692dbe100fe5694b8f321b7b117d4a0" translate="yes" xml:space="preserve">
          <source>Conflict-algorithm must be one of the SQLite conflict algorithms for the INSERT statement:</source>
          <target state="translated">Конфликтный алгоритм должен быть одним из алгоритмов конфликтов SQLite для оператора INSERT:</target>
        </trans-unit>
        <trans-unit id="af76481a91ddbca2a009d9ab58cd9c8e2ed5ef31" translate="yes" xml:space="preserve">
          <source>Connections hold an exclusive lock when change in between WAL mode and any of the various rollback-modes. Connections might also attempt to obtain an EXCLUSIVE lock when they disconnect from WAL mode. If a connection is able to obtain an EXCLUSIVE lock, that means it is the only connection to the database and so it may attempt to checkpoint and then delete the WAL-index and WAL files.</source>
          <target state="translated">Соединения удерживают эксклюзивную блокировку при переключении между режимом WAL и любым из различных режимов отката.Соединения могут также пытаться получить блокировку ЭКСКЛЮЗИВНО,когда они отсоединяются от режима WAL.Если соединение способно получить блокировку ЭКСКЛЮЗИВНО,это означает,что это единственное соединение с базой данных,и поэтому оно может попытаться установить контрольный пункт,а затем удалить файлы WAL-индекса и WAL-файлы.</target>
        </trans-unit>
        <trans-unit id="aec1d9b262374bdba4b3ad5a6350b6ef2fd31b30" translate="yes" xml:space="preserve">
          <source>Consider a different database with &quot;CREATE TABLE big(json JSON)&quot;. To see a complete line-by-line decomposition of the data:</source>
          <target state="translated">Рассмотрим другую базу данных с &quot;CREATE TABLE big(json JSON)&quot;.Просмотреть полное построчное разложение данных:</target>
        </trans-unit>
        <trans-unit id="89d5e40d39c9d5acb3a34ddf23480e47ca55947d" translate="yes" xml:space="preserve">
          <source>Consider a slightly different scenario:</source>
          <target state="translated">Рассмотрим немного другой сценарий:</target>
        </trans-unit>
        <trans-unit id="c5d0d6c9988bc87a91e1eceb2b1190187ebda45c" translate="yes" xml:space="preserve">
          <source>Consider a table (shown below) intended to store a vocabulary of words together with a count of the number of occurrences of each word in some text corpus:</source>
          <target state="translated">Рассмотрим таблицу (см.ниже),предназначенную для хранения словарного запаса вместе с подсчетом числа вхождений каждого слова в некоторый текстовый корпус:</target>
        </trans-unit>
        <trans-unit id="8ec68a1b2150a873bc929bf5c86810425d54b691" translate="yes" xml:space="preserve">
          <source>Consider a table such as the following:</source>
          <target state="translated">Рассмотрим следующую таблицу:</target>
        </trans-unit>
        <trans-unit id="163f9a2c7a0b11befe42d8af38ac3f4e6b7bc949" translate="yes" xml:space="preserve">
          <source>Consider a table that describes the members of an organization as well as the chain-of-command within that organization:</source>
          <target state="translated">Рассмотрим таблицу с описанием членов организации,а также порядок подчиненности в этой организации:</target>
        </trans-unit>
        <trans-unit id="4d89aaebca400a1430435ad2d544ef0799645f0e" translate="yes" xml:space="preserve">
          <source>Consider an example. Suppose you are trying to insert a string value into a database table where the string value was obtained from user input. Suppose the string to be inserted is stored in a variable named zString. The code to do the insertion might look like this:</source>
          <target state="translated">Рассмотрим пример.Предположим,вы пытаетесь вставить строковое значение в таблицу БД,где оно было получено из пользовательского ввода.Предположим,что вставляемая строка хранится в переменной с именем zString.Код для вставки может выглядеть следующим образом:</target>
        </trans-unit>
        <trans-unit id="968f255a5a54f60fb698955e4fcb28ea4353bc5f" translate="yes" xml:space="preserve">
          <source>Consider explicit collate clauses when matching WHERE constraints to indices in the query optimizer. Ticket #2391</source>
          <target state="translated">При совпадении ограничений WHERE с индексами в оптимизаторе запросов следует учитывать явно выраженные положения о коллате.Тикет #2391</target>
        </trans-unit>
        <trans-unit id="444e122b76db00a9b4c3d12c64b80faed572e3e1" translate="yes" xml:space="preserve">
          <source>Consider how this query works. The initial-select runs first and returns a single row with a single column &quot;1&quot;. This one row is added to the queue. In step 2a, that one row is extracted from the queue and added to &quot;cnt&quot;. Then the recursive-select is run in accordance with step 2c generating a single new row with value &quot;2&quot; to add to the queue. The queue still has one row, so step 2 repeats. The &quot;2&quot; row is extracted and added to the recursive table by steps 2a and 2b. Then the row containing 2 is used as if it were the complete content of the recursive table and the recursive-select is run again, resulting in a row with value &quot;3&quot; being added to the queue. This repeats 999999 times until finally at step 2a the only value on the queue is a row containing 1000000. That row is extracted and added to the recursive table. But this time, the WHERE clause causes the recursive-select to return no rows, so the queue remains empty and the recursion stops.</source>
          <target state="translated">Рассмотрим,как работает этот запрос.Начальный выбор выполняется первым и возвращает единственную строку с одним столбцом &quot;1&quot;.Эта одна строка добавляется в очередь.На шаге 2a,эта одна строка извлекается из очереди и добавляется в &quot;cnt&quot;.Затем выполняется рекурсивный выбор в соответствии с шагом 2c,генерирующий единственную новую строку со значением &quot;2&quot; для добавления в очередь.Очередь все еще имеет одну строку,поэтому шаг 2 повторяется.Строка &quot;2&quot; извлекается и добавляется в рекурсивную таблицу по шагам 2a и 2b.Затем строка,содержащая 2,используется так,как если бы она была полным содержимым рекурсивной таблицы,и рекурсивный выбор выполняется снова,в результате чего в очередь добавляется строка со значением &quot;3&quot;.Это повторяется 999999 раз,пока,наконец,на шаге 2a единственное значение в очереди не окажется строкой,содержащей 1000000.Эта строка извлекается и добавляется в рекурсивную таблицу.Но на этот раз выражение WHERE приводит к тому,что рекурсивный выбор не возвращает ни одной строки,поэтому очередь остается пустой,и рекурсия останавливается.</target>
        </trans-unit>
        <trans-unit id="f8fa74d8815f89442ddf62f70a180b631fe1665c" translate="yes" xml:space="preserve">
          <source>Consider querying this table to find the number of occurrences of the word &quot;xyzzy&quot;.:</source>
          <target state="translated">Рассмотрим вопрос об обращении к этой таблице для нахождения количества вхождений слова &quot;xyzzy&quot;..:</target>
        </trans-unit>
        <trans-unit id="8e332dd9034fe99b489d4794d57d3e6f28bfd9ef" translate="yes" xml:space="preserve">
          <source>Consider the following SQL:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e890ad26c51af96d02d41774ffeaa333b700b830" translate="yes" xml:space="preserve">
          <source>Consider the following two command sequences:</source>
          <target state="translated">Рассмотрим следующие две последовательности команд:</target>
        </trans-unit>
        <trans-unit id="38f2ce12e9214d8cde3ab5b6d1808e89b342965a" translate="yes" xml:space="preserve">
          <source>Consider using the &lt;a href=&quot;c3ref/set_authorizer&quot;&gt;sqlite3_set_authorizer()&lt;/a&gt; interface to limit the scope of SQL that will be processed. For example, an application that does not need to change the database schema might add an sqlite3_set_authorizer() callback that causes any CREATE or DROP statement to fail.</source>
          <target state="translated">Рассмотрите возможность использования интерфейса &lt;a href=&quot;c3ref/set_authorizer&quot;&gt;sqlite3_set_authorizer ()&lt;/a&gt; для ограничения объема обрабатываемого SQL. Например, приложение, которому не нужно изменять схему базы данных, может добавить обратный вызов sqlite3_set_authorizer (), который вызывает сбой любого оператора CREATE или DROP.</target>
        </trans-unit>
        <trans-unit id="3f881ec6e1c51116405b7bd7506d06d9368faea1" translate="yes" xml:space="preserve">
          <source>Consider what would happen if disk sector writes are interrupted by a power loss. If an application writes two or three bytes in the middle of some file, the operating system will implement this by first reading the entire sector containing those bytes, making the change to the sector in memory, then writing the entire sector back to the disk. If a power loss occurs during the writeback and the sector was not completely written, then on the next read after reboot, error correcting codes in the sector will probably detect irreparable damage and the disk controller will read out the sector as all zeros or all ones. Thus values will have changed outside of the range of the two or three bytes that were written at the application level - a violation of the powersafe overwrite property.</source>
          <target state="translated">Рассмотрим,что произойдет,если запись сектора диска будет прервана из-за потери питания.Если приложение записывает два или три байта в середине какого-нибудь файла,операционная система выполнит это,сначала прочитав весь сектор,содержащий эти байты,внеся изменения в сектор в памяти,а затем записав весь сектор обратно на диск.Если во время обратной записи произойдет сбой питания и сектор будет записан не полностью,то при следующем чтении после перезагрузки коды исправления ошибок в секторе,скорее всего,обнаружат непоправимые повреждения,и контроллер диска будет считывать сектор как все нули или все.Таким образом,значения изменятся за пределами диапазона двух-трех байт,которые были записаны на уровне приложения-нарушение свойства powersafe overwrite.</target>
        </trans-unit>
        <trans-unit id="454478261b68992469d64496e9cfb5f053cfbed3" translate="yes" xml:space="preserve">
          <source>Console the sorrowing.</source>
          <target state="translated">Консолируй скорбь.</target>
        </trans-unit>
        <trans-unit id="c51c1399ff5b435aa7c4c51efe988981e74f0189" translate="yes" xml:space="preserve">
          <source>Constant value 0.</source>
          <target state="translated">Постоянное значение 0.</target>
        </trans-unit>
        <trans-unit id="f14defda3a0615f9817e1062360bb6f9e7654bb6" translate="yes" xml:space="preserve">
          <source>Constant value 1. This field is omitted for any term-offset list associated with column 0.</source>
          <target state="translated">Постоянное значение 1.Данное поле опускается для любого списка смещения сроков,связанного со столбцом 0.</target>
        </trans-unit>
        <trans-unit id="f7d639ba9c48f5467c4d1a8f0152a2dc90222051" translate="yes" xml:space="preserve">
          <source>Constants Defining Special Destructor Behavior</source>
          <target state="translated">Константы,определяющие поведение специального деструктора</target>
        </trans-unit>
        <trans-unit id="af7e74633bc458147e8d5da16df8562d003b392e" translate="yes" xml:space="preserve">
          <source>Constants Passed To The Conflict Handler</source>
          <target state="translated">Константы,переданные организатору конфликта.</target>
        </trans-unit>
        <trans-unit id="aa0aeb15b7dcd6d473c7d1bf166a40ca61fee668" translate="yes" xml:space="preserve">
          <source>Constants Returned By The Conflict Handler</source>
          <target state="translated">Константы,возвращаемые организатором конфликта.</target>
        </trans-unit>
        <trans-unit id="6337f09e95dde3b3b58675d8b6f0257adf22ba40" translate="yes" xml:space="preserve">
          <source>Constants:</source>
          <target state="translated">Constants:</target>
        </trans-unit>
        <trans-unit id="f37e46006a1745cf96ebe1f73c1de5744dcf1d1d" translate="yes" xml:space="preserve">
          <source>Constraint Conflict Resolution in SQLite</source>
          <target state="translated">Урегулирование конфликтов в SQLite</target>
        </trans-unit>
        <trans-unit id="6889aa68d48cec7c8c38bf28801d4701520ff0dc" translate="yes" xml:space="preserve">
          <source>Constructor: &lt;a href=&quot;#sqlite3_blob_open&quot;&gt;sqlite3_blob_open()&lt;/a&gt;</source>
          <target state="translated">Конструктор: &lt;a href=&quot;#sqlite3_blob_open&quot;&gt;sqlite3_blob_open ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a878fca8a43e71d4ec596dfa4ec029c0c81a75d0" translate="yes" xml:space="preserve">
          <source>Constructor: &lt;a href=&quot;#sqlite3_snapshot_get&quot;&gt;sqlite3_snapshot_get()&lt;/a&gt;</source>
          <target state="translated">Конструктор: &lt;a href=&quot;#sqlite3_snapshot_get&quot;&gt;sqlite3_snapshot_get ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1a2c5628cdcd91822efac04edcb216499727358f" translate="yes" xml:space="preserve">
          <source>Constructor: &lt;a href=&quot;#sqlite3_str_new&quot;&gt;sqlite3_str_new()&lt;/a&gt;</source>
          <target state="translated">Конструктор: &lt;a href=&quot;#sqlite3_str_new&quot;&gt;sqlite3_str_new ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d1cdc0adde4d7b415af1d0d33bde5ec5e8f55638" translate="yes" xml:space="preserve">
          <source>Constructor: &lt;a href=&quot;#sqlite3changegroup_new&quot;&gt;sqlite3changegroup_new()&lt;/a&gt;</source>
          <target state="translated">Конструктор: &lt;a href=&quot;#sqlite3changegroup_new&quot;&gt;sqlite3changegroup_new ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d43a93e241e64f205e9be40e6849d360ecb314d2" translate="yes" xml:space="preserve">
          <source>Constructor: &lt;a href=&quot;#sqlite3session_create&quot;&gt;sqlite3session_create()&lt;/a&gt;</source>
          <target state="translated">Конструктор: &lt;a href=&quot;#sqlite3session_create&quot;&gt;sqlite3session_create ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="06e9fffe66b7ccd965b3d8281c4189b6873e699b" translate="yes" xml:space="preserve">
          <source>Constructor: &lt;a href=&quot;blob_open&quot;&gt;sqlite3_blob_open()&lt;/a&gt;</source>
          <target state="translated">Конструктор: &lt;a href=&quot;blob_open&quot;&gt;sqlite3_blob_open ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e898f79bdd10cd47ee3054a83ab75f61437a7aa4" translate="yes" xml:space="preserve">
          <source>Constructor: &lt;a href=&quot;snapshot_get&quot;&gt;sqlite3_snapshot_get()&lt;/a&gt;</source>
          <target state="translated">Конструктор: &lt;a href=&quot;snapshot_get&quot;&gt;sqlite3_snapshot_get ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="08db86cfe6351f2012dbf46992a9fa7d1631a5e2" translate="yes" xml:space="preserve">
          <source>Constructor: &lt;a href=&quot;sqlite3changegroup_new&quot;&gt;sqlite3changegroup_new()&lt;/a&gt;</source>
          <target state="translated">Конструктор: &lt;a href=&quot;sqlite3changegroup_new&quot;&gt;sqlite3changegroup_new ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="38014e350b2ec610dc63ea6835bc8bf20566c178" translate="yes" xml:space="preserve">
          <source>Constructor: &lt;a href=&quot;sqlite3session_create&quot;&gt;sqlite3session_create()&lt;/a&gt;</source>
          <target state="translated">Конструктор: &lt;a href=&quot;sqlite3session_create&quot;&gt;sqlite3session_create ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f94c6d14960e90153f9e56ef05e080f43ace38fd" translate="yes" xml:space="preserve">
          <source>Constructor: &lt;a href=&quot;str_new&quot;&gt;sqlite3_str_new()&lt;/a&gt;</source>
          <target state="translated">Конструктор: &lt;a href=&quot;str_new&quot;&gt;sqlite3_str_new ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3617dc14ae8be730219fa2aabd32aaa900ccfc3a" translate="yes" xml:space="preserve">
          <source>Constructors: &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open16()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;</source>
          <target state="translated">Конструкторы: &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open16 ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2 ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b2da4ffc9b2e344254d3be3ef8d1b5463c6c55d3" translate="yes" xml:space="preserve">
          <source>Constructors: &lt;a href=&quot;#sqlite3changeset_start&quot;&gt;sqlite3changeset_start()&lt;/a&gt;, &lt;a href=&quot;#sqlite3changeset_start&quot;&gt;sqlite3changeset_start_v2()&lt;/a&gt;</source>
          <target state="translated">Конструкторы: &lt;a href=&quot;#sqlite3changeset_start&quot;&gt;sqlite3changeset_start ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3changeset_start&quot;&gt;sqlite3changeset_start_v2 ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0b84725656dbaa01e32202bf862175e15f3aa743" translate="yes" xml:space="preserve">
          <source>Constructors: &lt;a href=&quot;open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;open&quot;&gt;sqlite3_open16()&lt;/a&gt;, &lt;a href=&quot;open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;</source>
          <target state="translated">Конструкторы: &lt;a href=&quot;open&quot;&gt;sqlite3_open ()&lt;/a&gt; , &lt;a href=&quot;open&quot;&gt;sqlite3_open16 ()&lt;/a&gt; , &lt;a href=&quot;open&quot;&gt;sqlite3_open_v2 ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="63842448f26d096823a3c51f076ae6fb704d1709" translate="yes" xml:space="preserve">
          <source>Constructors: &lt;a href=&quot;sqlite3changeset_start&quot;&gt;sqlite3changeset_start()&lt;/a&gt;, &lt;a href=&quot;sqlite3changeset_start&quot;&gt;sqlite3changeset_start_v2()&lt;/a&gt;</source>
          <target state="translated">Конструкторы: &lt;a href=&quot;sqlite3changeset_start&quot;&gt;sqlite3changeset_start ()&lt;/a&gt; , &lt;a href=&quot;sqlite3changeset_start&quot;&gt;sqlite3changeset_start_v2 ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5e8adbf806de9adae308cb1a722a2834efb03d01" translate="yes" xml:space="preserve">
          <source>Contains the actual data inserted into the FTS5 table. This shadow table is not present for &lt;a href=&quot;fts5#contentless_tables&quot;&gt;contentless&lt;/a&gt; or &lt;a href=&quot;fts5#external_content_tables&quot;&gt;external content&lt;/a&gt; FTS5 tables.</source>
          <target state="translated">Содержит фактические данные, вставленные в таблицу FTS5. Эта тень таблица нет для &lt;a href=&quot;fts5#contentless_tables&quot;&gt;бессодержательной&lt;/a&gt; или &lt;a href=&quot;fts5#external_content_tables&quot;&gt;внешних содержимого&lt;/a&gt; таблиц FTS5.</target>
        </trans-unit>
        <trans-unit id="6773795897579cbc7647c6d1ac1d4b8bc25387d4" translate="yes" xml:space="preserve">
          <source>Contains the size of each column of each row in the virtual table in tokens. This shadow table is not present if the &lt;a href=&quot;fts5#the_columnsize_option&quot;&gt;&quot;columnsize&quot; option&lt;/a&gt; is set to 0.</source>
          <target state="translated">Содержит размер каждого столбца каждой строки виртуальной таблицы в токенах. Эта теневая таблица отсутствует, если для параметра &lt;a href=&quot;fts5#the_columnsize_option&quot;&gt;&quot;размер столбца&quot;&lt;/a&gt; установлено значение 0.</target>
        </trans-unit>
        <trans-unit id="c6336221afe18ddc0e53b18acd141d3c916c6884" translate="yes" xml:space="preserve">
          <source>Contains the text of the term for this row.</source>
          <target state="translated">Содержит текст термина для этой строки.</target>
        </trans-unit>
        <trans-unit id="8149ba57ba940e5c3672ef00fa60ad0d2afcb776" translate="yes" xml:space="preserve">
          <source>Contains the values of persistent configuration parameters.</source>
          <target state="translated">Содержит значения постоянных параметров конфигурации.</target>
        </trans-unit>
        <trans-unit id="17ad25c1af7990d50b53a9e2d46ba0f493597884" translate="yes" xml:space="preserve">
          <source>Content Size</source>
          <target state="translated">Размер контента</target>
        </trans-unit>
        <trans-unit id="311a2e63246045d0ca04704e25eb8fe09678745a" translate="yes" xml:space="preserve">
          <source>Content can be accessed and updated using concise SQL queries instead of lengthy and error-prone procedural routines.</source>
          <target state="translated">Доступ к содержимому и его обновление могут осуществляться с помощью сжатых SQL-запросов,а не длительных и подверженных ошибкам процедурных процедур.</target>
        </trans-unit>
        <trans-unit id="54e6a597c2b0fe05466617946d21001a0e849ccf" translate="yes" xml:space="preserve">
          <source>Content can be updated continuously and atomically so that little or no work is lost in a power failure or crash.</source>
          <target state="translated">Содержимое может обновляться непрерывно и атоматически,так что мало или вообще ничего не теряется при отключении питания или аварии.</target>
        </trans-unit>
        <trans-unit id="5a0ca8d8e7e6987ce002e1b9cc19498346916cd0" translate="yes" xml:space="preserve">
          <source>Content stored in an SQLite database is more likely to be recoverable decades in the future, long after all traces of the original application have been lost. Data lives longer than code.</source>
          <target state="translated">Содержимое,хранящееся в базе данных SQLite,скорее всего,будет восстанавливаться десятилетиями в будущем,еще долгое время после того,как все следы исходного приложения будут потеряны.Данные живут дольше,чем код.</target>
        </trans-unit>
        <trans-unit id="2d4a0281b46f5532a617239a67837a43f539390e" translate="yes" xml:space="preserve">
          <source>Contentless FTS4 tables also support SELECT statements. However, it is an error to attempt to retrieve the value of any table column other than the docid column. The auxiliary function matchinfo() may be used, but snippet() and offsets() may not. For example:</source>
          <target state="translated">Бесконечные таблицы FTS4 также поддерживают утверждения SELECT.Однако,попытка получить значение любого столбца таблицы,отличного от документального,является ошибкой.Вспомогательная функция matchinfo()может быть использована,но snippet()и offsets()-нет.Например:</target>
        </trans-unit>
        <trans-unit id="466e0c80c6a0ee6d90e9a1cf84c5c7f81c6af7ec" translate="yes" xml:space="preserve">
          <source>Contentless FTS5 tables do not support UPDATE or DELETE statements, or INSERT statements that do not supply a non-NULL value for the rowid field. Contentless tables do not support REPLACE conflict handling. REPLACE and INSERT OR REPLACE statements are treated as regular INSERT statements. Rows may be deleted from a contentless table using an &lt;a href=&quot;fts5#the_delete_command&quot;&gt;FTS5 delete command&lt;/a&gt;.</source>
          <target state="translated">Бессодержательные таблицы FTS5 не поддерживают операторы UPDATE или DELETE или операторы INSERT, которые не предоставляют значение, отличное от NULL, для поля rowid. Таблицы без содержимого не поддерживают обработку конфликтов REPLACE. Операторы REPLACE и INSERT OR REPLACE обрабатываются как обычные операторы INSERT. Строки могут быть удалены из таблицы без &lt;a href=&quot;fts5#the_delete_command&quot;&gt;содержимого&lt;/a&gt; с помощью команды удаления FTS5 .</target>
        </trans-unit>
        <trans-unit id="450f660f2dc175257d82b71bd1a3662299271f61" translate="yes" xml:space="preserve">
          <source>Contentless fts4 tables</source>
          <target state="translated">Бесконечные fts4 таблицы</target>
        </trans-unit>
        <trans-unit id="f5cbdf6bfb51439be085b5c6b7460a7c91eabc3c" translate="yes" xml:space="preserve">
          <source>Contents</source>
          <target state="translated">Contents</target>
        </trans-unit>
        <trans-unit id="38c62e79a8a690e9f86401a7b90826fac3d70fe4" translate="yes" xml:space="preserve">
          <source>Continuing enhancements and improvements to &lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt;.</source>
          <target state="translated">Постоянные улучшения и улучшения &lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt; .</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
